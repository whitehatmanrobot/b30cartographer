====================
																 mft1
	   ============================================================================================================================ */
	if ( *((OSType*)profileLutPtr) == icSigLut8Type )
	{
		/* --------------------------------------------------------------------------------- get inputLuts out of the profile */
		inputTableEntries	= 256;
		offset    			= 48;	/* input luts for mft1 start at byte 48 */
		byteCount			= theLutData->colorLutInDim * inputTableEntries;
		theInputLuts = SmartNewPtr(byteCount, &aOSerr);
		err = aOSerr;
		if (err)
			goto CleanupAndExit;
		err = CMGetPartialProfileElement(theCombiData->theProfile, theTag, offset, &byteCount, theInputLuts);
		if (err)
			goto CleanupAndExit;
		if ( theCombiData->doCreate_16bit_ELut )	/* this is NOT the first Elut -or- doCreateLinkProfile */
		{
																		/* if we create a LinkProfile the Elut should not be scaled... */
			if ((theCombiData->doCreateLinkProfile) && (theCombiData->profLoop == 0))
				err = Fill_ushort_ELUTs_from_lut8Tag( theLutData, theInputLuts, adr_breite_elut, bit_breite_elut, 0 );
			else 														/* else scale Elut to gridpoints in profile... */
				err = Fill_ushort_ELUTs_from_lut8Tag( theLutData, theInputLuts, adr_breite_elut, VAL_USED_BITS, theLutData->colorLutGridPoints );
			theLutData->inputLutEntryCount = (1<<adr_breite_elut);
			theLutData->inputLutWordSize = VAL_USED_BITS;
		}
		else															/* this is the first Elut */
		{
       	    if ( theCombiData->doCreate_16bit_Combi )	/* UWE 9.2.96 */
       	   	{
	            if (theCombiData->maxProfileCount == 0)					/* if we have only one profile, the scale Elut to gridpoints in profile...*/
	                err = Fill_ushort_ELUTs_from_lut8Tag( theLutData, theInputLuts, adr_breite_elut, VAL_USED_BITS, theLutData->colorLutGridPoints );
	            else													/* else scale Elut to the gridpoints in the cube...*/
              		err = Fill_ushort_ELUTs_from_lut8Tag( theLutData, theInputLuts, adr_breite_elut, VAL_USED_BITS, theCombiData->gridPointsCube );
           		theLutData->inputLutWordSize = VAL_USED_BITS;
      	    }
      	    else
      	    {
	            if (theCombiData->maxProfileCount == 0)					/* if we have only one profile, the scale Elut to gridpoints in profile...*/
	                err = Fill_ushort_ELUTs_from_lut8Tag( theLutData, theInputLuts, adr_breite_elut, bit_breite_elut, theLutData->colorLutGridPoints );
	            else													/* else scale Elut to the gridpoints in the cube...*/
	                err = Fill_ushort_ELUTs_from_lut8Tag( theLutData, theInputLuts, adr_breite_elut, bit_breite_elut, theCombiData->gridPointsCube );
	            theLutData->inputLutWordSize = bit_breite_elut;

            }
            theLutData->inputLutEntryCount = (1<<adr_breite_elut);
		}
	}
	else
	/* ============================================================================================================================
																 mft2
	   ============================================================================================================================ */
	{
		/* --------------------------------------------------------------------------------- get inputLuts out of the profile */
		inputTableEntries	= ((icLut16Type *)profileLutPtr)->lut.inputEnt;
		if (inputTableEntries <2)
		{
#if ! realThing
			readLutFromFile = FALSE;
			inputTableEntries = 2;
#else
			err = cmProfileError;
			goto CleanupAndExit;
#endif
		}
		if (readLutFromFile)
		{
			offset    			= 52;	/* input luts for mft2 start at byte 52 */
			byteCount			= theLutData->colorLutInDim * inputTableEntries * sizeof(UINT16);
			theInputLuts = SmartNewPtr(byteCount, &aOSerr);
			err = aOSerr;
			if (err)
				goto CleanupAndExit;
			err = CMGetPartialProfileElement(theCombiData->theProfile, theTag, offset, &byteCount, theInputLuts);
#ifdef IntelMode
            SwapShortOffset( theInputLuts, 0, byteCount );
#endif
			if (err)
				goto CleanupAndExit;
		} else
		{
			theInputLuts = SmartNewPtr(inputTableEntries * sizeof(SINT16) * theLutData->colorLutInDim, &aOSerr);
			err = aOSerr;
			if (err)
				goto CleanupAndExit;	/* 12/1/95 */
			shortPtr = (UINT16*)theInputLuts;
			for (i = 0; i< (theLutData->colorLutInDim * inputTableEntries); i+=inputTableEntries)
			{
				shortPtr[i] 	= 0;
				shortPtr[i+1]	= 0xFFFF;
			}
		}
		if ( theCombiData->doCreate_16bit_ELut )						/* this is NOT the first Elut -or- doCreateLinkProfile */
		{
																		/* if we create a LinkProfile the Elut should not be scaled... */
			if ((theCombiData->doCreateLinkProfile) && (theCombiData->profLoop == 0))
				err = Fill_ushort_ELUTs_from_lut16Tag( theLutData, theInputLuts, adr_breite_elut, VAL_USED_BITS, 0, inputTableEntries );
			else 														/* else scale Elut to gridpoints in profile... */
				err = Fill_ushort_ELUTs_from_lut16Tag( theLutData, theInputLuts, adr_breite_elut, VAL_USED_BITS, theLutData->colorLutGridPoints, inputTableEntries );
			theLutData->inputLutEntryCount = (1<<adr_breite_elut);
			theLutData->inputLutWordSize = VAL_USED_BITS;
		}
		else															/* this is the first Elut */
		{
         	if ( theCombiData->doCreate_16bit_Combi ) 	/* UWE 9.2.96 */
         	{
	            if (theCombiData->maxProfileCount == 0)					/* if we have only one profile, the scale Elut to gridpoints in profile...*/
	                err = Fill_ushort_ELUTs_from_lut16Tag( theLutData, theInputLuts, adr_breite_elut, VAL_USED_BITS, theLutData->colorLutGridPoints, inputTableEntries );
	            else													/* else scale Elut to the gridpoints in the cube...*/
              		err = Fill_ushort_ELUTs_from_lut16Tag( theLutData, theInputLuts, adr_breite_elut, VAL_USED_BITS, theCombiData->gridPointsCube, inputTableEntries );
            	theLutData->inputLutWordSize = VAL_USED_BITS;
      	    }
            else
            {
	            if (theCombiData->maxProfileCount == 0)					/* if we have only one profile, the scale Elut to gridpoints in profile...*/
	                err = Fill_ushort_ELUTs_from_lut16Tag( theLutData, theInputLuts, adr_breite_elut, bit_breite_elut, theLutData->colorLutGridPoints, inputTableEntries );
	            else													/* else scale Elut to the gridpoints in the cube...*/
	                err = Fill_ushort_ELUTs_from_lut16Tag( theLutData, theInputLuts, adr_breite_elut, bit_breite_elut, theCombiData->gridPointsCube, inputTableEntries );
            	theLutData->inputLutWordSize = bit_breite_elut;
           }
            theLutData->inputLutEntryCount = (1<<adr_breite_elut);
		}
	}
	if (err)
		goto CleanupAndExit;

	/* ---------------------------------------------------------------------------------
	    clean up & exit
	   ---------------------------------------------------------------------------------*/
CleanupAndExit:
	theInputLuts = DisposeIfPtr(theInputLuts);

	LH_END_PROC("Extract_MFT_Elut")
	return err;
}

/* 
	CMError
	Extract_MFT_Xlut	  ( CMLutParamPtr	theLutData,
							LHCombiDataPtr	theCombiData,
							Ptr				profileLutPtr,
							OSType			theTag )
    */
CMError
Extract_MFT_Xlut	  ( CMLutParamPtr	theLutData,
						LHCombiDataPtr	theCombiData,
						Ptr				profileLutPtr,
						OSType			theTag )
{
 	CMError			err = noErr;
  	OSErr			aOSerr = noErr;
	SINT32			i;
	SINT32			clutSize;
	LUT_DATA_TYPE	localXlut = nil;
	Ptr				tempXlut   = nil;
	Ptr				bytePtr   = nil;
	Ptr				xlutPtr   = nil;
	SINT32			offset;
	SINT32			inputTableEntries;
	UINT32			byteCount;
	UINT32			theSize;
	UINT32			aExtraSize;
	
	LH_START_PROC("Extract_MFT_Xlut")
	
	clutSize = theLutData->colorLutOutDim;
	for(i=0; i<theLutData->colorLutInDim; i++)
		clutSize *= theLutData->colorLutGridPoints;

	/* ============================================================================================================================
																 mft1
	   ============================================================================================================================ */
	if ( *((OSType*)profileLutPtr) == icSigLut8Type )
	{
		if ( theCombiData->maxProfileCount == 0 ){			/* Link Profile UK13.8.96*/
			theSize = 1;
			aExtraSize = 1;
			for( i=0; i<(theLutData->colorLutInDim-1); ++i){	/* Extra Size for Interpolation */
				theSize *= theLutData->colorLutGridPoints;
				aExtraSize += theSize;
			}
#ifdef ALLOW_MMX
			aExtraSize++;	/* +1 for MMX 4 Byte access */
#endif
		}	
		else{
			aExtraSize = 0;
		}
		aExtraSize *= theLutData->colorLutOutDim;
		localXlut = ALLOC_DATA(clutSize+aExtraSize, &aOSerr);	
       	err = aOSerr;	
		if (err)
			goto CleanupAndExit;
		LOCK_DATA(localXlut);
		inputTableEntries	= 256;
		offset 				= 48 + (inputTableEntries * theLutData->colorLutInDim);
		byteCount			= clutSize;
		err = CMGetPartialProfileElement(theCombiData->theProfile, theTag, offset, &byteCount, DATA_2_PTR(localXlut));
		theLutData->colorLutWordSize = 8;
		if (err)
			goto CleanupAndExit;
	} else
	/* ============================================================================================================================
																 mft2
	   ============================================================================================================================ */
	{
		if (( theCombiData->maxProfileCount > 0 ) || (theCombiData->doCreateLinkProfile) || (theCombiData->doCreate_16bit_XLut))/* UWE 9.2.96*/
			clutSize *= 2;
		if ( theCombiData->maxProfileCount == 0 ){			/* Link Profile  UK13.8.96*/
			theSize = 1;
			aExtraSize = 1;
			for( i=0; i<(theLutData->colorLutInDim-1); ++i){	/* Extra Size for Interpolation */
				theSize *= theLutData->colorLutGridPoints;
				aExtraSize += theSize;
			}
			if (( theCombiData->doCreateLinkProfile) || (theCombiData->doCreate_16bit_XLut)){
				aExtraSize *= 2;
			}
#ifdef ALLOW_MMX
			aExtraSize++;	/* +1 for MMX 4 Byte access */
#endif
		}	
		else{
			aExtraSize = 0;
		}
		aExtraSize *= theLutData->colorLutOutDim;
		localXlut = ALLOC_DATA(clutSize+aExtraSize, &aOSerr);	
       	err = aOSerr;
		if (err)
			goto CleanupAndExit;
		LOCK_DATA(localXlut);
		inputTableEntries	= ((icLut16Type *)profileLutPtr)->lut.inputEnt;
		if (inputTableEntries <2)
		{
			err = cmProfileError;
			goto CleanupAndExit;
		}
		offset = 52 + ( inputTableEntries * theLutData->colorLutInDim) * sizeof(UINT16);
		
		if (( theCombiData->maxProfileCount > 0 ) || (theCombiData->doCreateLinkProfile) || (theCombiData->doCreate_16bit_XLut))/* UWE 9.2.96 */
		{
			byteCount = clutSize;
			tempXlut  = 0;
			err = CMGetPartialProfileElement(theCombiData->theProfile, theTag, offset, &byteCount, DATA_2_PTR(localXlut));
#ifdef IntelMode
           SwapShortOffset( localXlut, 0, byteCount );
#endif
			theLutData->colorLutWordSize = VAL_USED_BITS;
			if (err)
				goto CleanupAndExit;
		}
		else
		{									/* should only happen with 1 Link profile */
#ifdef DEBUG_OUTPUT
			if ( DebugCheck(kThisFile, kDebugMiscInfo) )
				DebugPrint(" Extract_MFT_Xlut: 1 Link profile mode\n",err);
#endif
			byteCount = clutSize * sizeof(UINT16);
			tempXlut  = SmartNewPtr(byteCount, &aOSerr);
	        err = aOSerr;
			if (err)
				goto CleanupAndExit;
			err = CMGetPartialProfileElement(theCombiData->theProfile, theTag, offset, &byteCount, tempXlut);
#ifdef IntelMode
/*           SwapShortOffset( tempXlut, 0, byteCount ); !! do not swap, take first byte */
#endif
			if (err)
				goto CleanupAndExit;
			bytePtr = tempXlut;
			xlutPtr = (Ptr)DATA_2_PTR(localXlut);
			for (i = 0; i < clutSize; i++)
			{
				*xlutPtr = *bytePtr;
				bytePtr+=2;
				xlutPtr++;
			}
			theLutData->colorLutWordSize = 8;
		}
	}
	UNLOCK_DATA(localXlut);
	theLutData->colorLut = localXlut;
	localXlut = nil;
	
	/* ---------------------------------------------------------------------------------
	    clean up & exit
	   ---------------------------------------------------------------------------------*/
CleanupAndExit:
	localXlut = DISPOSE_IF_DATA(localXlut);
	tempXlut  = DisposeIfPtr(tempXlut);

	LH_END_PROC("Extract_MFT_Xlut")
	return err;
}

/* 
	CMError
	Extract_MFT_Alut	  ( CMLutParamPtr	theLutData,
							LHCombiDataPtr	theCombiData,
							Ptr				profileLutPtr )
    */
CMError
Extract_MFT_Alut	  ( CMLutParamPtr	theLutData,
						LHCombiDataPtr	theCombiData,
						Ptr				profileLutPtr,
						OSType			theTag )
{
 	CMError		err = noErr;
  	OSErr		aOSerr = noErr;
	UINT32		byteCount;
	SINT32		offset;
	SINT32		clutSize;
	SINT32		i;
	SINT32		inputTableEntries;
	SINT32		outputTableEntries;
	Ptr			theOutputLuts	= nil;	/* 12/1/95;*/
	Boolean		readLutFromFile = TRUE;
	UINT16*		shortPtr;
	
	LH_START_PROC("Extract_MFT_Alut")
	
	clutSize = theLutData->colorLutOutDim;
	for(i=0; i<theLutData->colorLutInDim; i++)
		clutSize *= theLutData->colorLutGridPoints;
	/* ============================================================================================================================
																 mft1
	   ============================================================================================================================ */
	if ( *((OSType*)profileLutPtr) == icSigLut8Type )
	{
		/* --------------------------------------------------------------------------------- get outputLuts out of the profile */
		inputTableEntries  = 256;
		outputTableEntries = 256;
		offset 			   = 48 + (inputTableEntries * theLutData->colorLutInDim) + clutSize;
		byteCount = theLutData->colorLutOutDim * outputTableEntries;
       	theOutputLuts = SmartNewPtr(byteCount, &aOSerr);
		err = aOSerr;
		if (err)
			goto CleanupAndExit;
		err = CMGetPartialProfileElement(theCombiData->theProfile, theTag, offset, &byteCount, theOutputLuts);
		if (err)
			goto CleanupAndExit;
		if ( theCombiData->doCreate_16bit_ALut || theCombiData->doCreate_16bit_Combi )	/* this is NOT the last Alut*/
		{
			err = Fill_ushort_ALUTs_from_lut8Tag( theLutData, theOutputLuts, adr_breite_alut);
			if (err)
				goto CleanupAndExit;
			theLutData->outputLutEntryCount = adr_bereich_alut;
			theLutData->outputLutWordSize = VAL_USED_BITS;
		}
		else																			/* this is the last Alut */
		{
			err = Fill_byte_ALUTs_from_lut8Tag( theLutData, theOutputLuts, adr_breite_alut);
			if (err)
				goto CleanupAndExit;
			theLutData->outputLutEntryCount = adr_bereich_alut;
			theLutData->outputLutWordSize = bit_breite_alut;
		}
	}
	/* ============================================================================================================================
																 mft2
	   ============================================================================================================================ */
	else
	{
		/* --------------------------------------------------------------------------------- get outputLuts out of the profile */
		inputTableEntries	= ((icLut16Type *)profileLutPtr)->lut.inputEnt;
		if (inputTableEntries <2)
		{
#if realThing
			err = cmProfileError;
			goto CleanupAndExit;
#endif
		}
		outputTableEntries	= ((icLut16Type *)profileLutPtr)->lut.outputEnt;
		if (outputTableEntries <2)
		{
#if ! realThing
			readLutFromFile = FALSE;
			outputTableEntries = 2;
#else
			err = cmProfileError;
			goto CleanupAndExit;
#endif
		}
		if (readLutFromFile)
		{
			offset		= 52 + (( inputTableEntries * theLutData->colorLutInDim) + clutSize) * sizeof(UINT16);
			byteCount	= theLutData->colorLutOutDim * outputTableEntries * sizeof(UINT16);
           	theOutputLuts = SmartNewPtr(byteCount, &aOSerr);
			err = aOSerr;
			if (err)
				goto CleanupAndExit;
			err = CMGetPartialProfileElement(theCombiData->theProfile, theTag, offset, &byteCount, theOutputLuts);
			if (err)
				goto CleanupAndExit;
#ifdef IntelMode
           SwapShortOffset( theOutputLuts, 0, byteCount );
#endif
		} else
		{
			theOutputLuts = SmartNewPtr(2 * sizeof(SINT16) * theLutData->colorLutOutDim, &aOSerr);
			err = aOSerr;
			if (err)
				goto CleanupAndExit;
			shortPtr = (UINT16*)theOutputLuts;
			for (i = 0; i< ( theLutData->colorLutOutDim * outputTableEntries ); i+=outputTableEntries)
			{
				shortPtr[i] 	= 0;
				shortPtr[i+1]	= (UINT16)0xFFFF;
			}
		}
		if ( theCombiData->doCreate_16bit_ALut || theCombiData->doCreate_16bit_Combi )/*  UWE 9.2.96	this is NOT the last Alut */
		{
			err = Fill_ushort_ALUTs_from_lut16Tag( theLutData, theOutputLuts, adr_breite_alut, outputTableEntries);
			if (err)
				goto CleanupAndExit;
			theLutData->outputLutEntryCount = adr_bereich_alut;
			theLutData->outputLutWordSize = VAL_USED_BITS;
		}
		else														/*  this is the last Alut */
		{
			err = Fill_byte_ALUTs_from_lut16Tag( theLutData, theOutputLuts, adr_breite_alut, outputTableEntries);
			if (err)
				goto CleanupAndExit;
			theLutData->outputLutEntryCount = adr_bereich_alut;
			theLutData->outputLutWordSize = bit_breite_alut;
		}
	}
	
	/*---------------------------------------------------------------------------------
	   clean up & exit
	  ---------------------------------------------------------------------------------*/
CleanupAndExit:
	theOutputLuts = DisposeIfPtr(theOutputLuts);

	LH_END_PROC("Extract_MFT_Alut")
	return err;
}

/* 
	CMError
	ExtractAll_MFT_Luts  (  CMLutParamPtr	theLutData,
							LHCombiDataPtr	theCombiData,
							OSType			theTag )
    */
CMError
ExtractAll_MFT_Luts  (  CMLutParamPtr	theLutData,
						LHCombiDataPtr	theCombiData,
						OSType			theTag )
{
  	CMError		err = noErr;
  	OSErr		aOSerr = noErr;
	Ptr			profileLutPtr = nil;
	UINT32		elementSize;
	double		factor;
	UINT32 		byteCount;

	LH_START_PROC("ExtractAll_MFT_Luts")

	/* -------------------------------------------------------- get partial tag data from profile */
	err = CMGetProfileElement(theCombiData->theProfile, theTag, &elementSize, nil);
	if (err)
		goto CleanupAndExit;
	
	byteCount = 52;											/* get the first 52 bytes out of the profile */
  	profileLutPtr = SmartNewPtr(byteCount, &aOSerr);
	err = aOSerr;
	if (err)
		goto CleanupAndExit;
	
    err = CMGetProfileElement(theCombiData->theProfile, theTag, &byteCount, profileLutPtr);
#ifdef IntelMode
    SwapLongOffset( &((icLut16Type*)profileLutPtr)->base.sig, 0, 4 );
    SwapShortOffset( &((icLut16Type*)profileLutPtr)->lut.inputEnt, 0, 2 );
    SwapShortOffset( &((icLut16Type*)profileLutPtr)->lut.outputEnt, 0, 2 );
#endif
	if (err)
		goto CleanupAndExit;

	theLutData->colorLutInDim 		= ((icLut8Type*)profileLutPtr)->lut.inputChan;
	theLutData->colorLutOutDim 		= ((icLut8Type*)profileLutPtr)->lut.outputChan;
	theLutData->colorLutGridPoints 	= ((icLut8Type*)profileLutPtr)->lut.clutPoints;
	
	/* ---------------------------------------------------------------------- handle matrix
	 	matrix is only used if:
	 	 number of input channels is 3 and
	 	 input is XYZ
	 	matrix is identity for output when pcs == Lab
	*/
	if ( ( theLutData->colorLutInDim == 3) &&
	       ( (  theCombiData->amIPCS && (theCombiData->profileConnectionSpace == icSigXYZData) ) ||
	       	 ( !theCombiData->amIPCS && (theCombiData->dataColorSpace 		  == icSigXYZData) ) ) )
	{
		factor = 1.;
		err = GetMatrixFromProfile(theLutData, theCombiData, theTag, factor);
	}
	
	/* ---------------------------------------------------------------------- process A Lut */
	err = Extract_MFT_Alut( theLutData, theCombiData, profileLutPtr, theTag );
	if (err)
		goto CleanupAndExit;
	
	/* ---------------------------------------------------------------------- process X Lut */
	err = Extract_MFT_Xlut ( theLutData, theCombiData, profileLutPtr, theTag );
	if (err)
		goto CleanupAndExit;
	
	/* ---------------------------------------------------------------------- process E Lut */
	err = Extract_MFT_Elut( theLutData, theCombiData, profileLutPtr, theTag );
	if (err)
		goto CleanupAndExit;

	/* ---------------------------------------------------------------------------------
		 clean up
	   ---------------------------------------------------------------------------------*/
CleanupAndExit:
	profileLutPtr = DisposeIfPtr(profileLutPtr);

	LH_END_PROC("ExtractAll_MFT_Luts")
	return err;
}



/* 
	CMError
	Extract_TRC_Alut	  ( CMLutParamPtr	theLutData,
							LHCombiDataPtr	theCombiData )
    */
CMError
Extract_TRC_Alut	  ( CMLutParamPtr	theLutData,
						LHCombiDataPtr	theCombiData )
{
	OSType			trcSig[kNumOfRGBchannels];
	icCurveType*	pCurveTag	   = nil;
	icCurveType*	invertCurveTag = nil;
 	CMError			err = noErr;
  	OSErr			aOSerr = noErr;
	UINT32			elementSize;
	SINT32			loop;
	SINT32			theSize;
	SINT32			theAlutSize;
	UINT8			addrBits;
	LUT_DATA_TYPE	localAlut = nil;
	
	LH_START_PROC("Extract_TRC_Alut")
	
	/* ---------------------------------------------------- initialization */
	addrBits = adr_breite_alut;
	if ( theCombiData->doCreate_16bit_ALut || theCombiData->doCreate_16bit_Combi )/* UWE 9.2.96 */
		theSize = sizeof(UINT16);
	else
		theSize = sizeof(UINT8);
	theAlutSize = (1<<addrBits);
	localAlut = ALLOC_DATA(theLutData->colorLutOutDim * theAlutSize * theSize + theSize, &aOSerr);
	err = aOSerr;
	if (err)
	{
#ifdef DEBUG_OUTPUT
		if ( err && DebugCheck(kThisFile, kDebugErrorInfo) )
			DebugPrint(" Extract_TRC_Alut ALLOC_DATA(%d * %d) error\n",theLutData->colorLutOutDim , theAlutSize);
#endif
		goto CleanupAndExit;
	}
	LOCK_DATA(localAlut);
	if (!theCombiData->amIPCS)
	{			
		/* ---------------------------------------------------------------------------------
				if NOT PCS -> create linear Alut ...
		   ---------------------------------------------------------------------------------*/
		if ( theCombiData->doCreate_16bit_ALut || theCombiData->doCreate_16bit_Combi )/* UWE 9.2.96		this is NOT the last Alut */
		{
			CreateLinearAlut16 ( (UINT16 *)DATA_2_PTR(localAlut),theAlutSize);
			for (loop = 0; loop < theLutData->colorLutOutDim; loop++)
				BlockMoveData(DATA_2_PTR(localAlut), (Ptr)DATA_2_PTR(localAlut) + loop * theAlutSize * sizeof(UINT16), theAlutSize * sizeof(UINT16));
			theLutData->outputLutEntryCount = (SINT16)theAlutSize;
			theLutData->outputLutWordSize = VAL_USED_BITS;
		}
		else													/* this is NOT the last Alut */
		{
			CreateLinearAlut ( (UINT8 *)DATA_2_PTR(localAlut),theAlutSize);
			for (loop = 0; loop < theLutData->colorLutOutDim; loop++)
				BlockMoveData(DATA_2_PTR(localAlut), (Ptr)DATA_2_PTR(localAlut) + loop * theAlutSize, theAlutSize);
			theLutData->outputLutEntryCount = (SINT16)theAlutSize;
			theLutData->outputLutWordSize = 8;
		}
	}
	else
	{
		/* ---------------------------------------------------------------------------------
		  	... else take TRCs for Aluts
		   ---------------------------------------------------------------------------------*/
		trcSig[0] = icSigRedTRCTag;
		trcSig[1] = icSigGreenTRCTag;
		trcSig[2] = icSigBlueTRCTag;
				
		for (loop = 0; loop < kNumOfRGBchannels; loop++)
		{
			err = CMGetProfileElement(theCombiData->theProfile, trcSig[loop], &elementSize, nil);
			if (err)
				goto CleanupAndExit;
            pCurveTag = (icCurveType *)SmartNewPtr(elementSize, &aOSerr);
			err = aOSerr;
			if (err)
				goto CleanupAndExit;

			err = CMGetProfileElement(theCombiData->theProfile, trcSig[loop], &elementSize, pCurveTag);
			if (err){
				goto CleanupAndExit;
			}
#ifdef IntelMode
            SwapLongOffset( &pCurveTag->base.sig, 0, 4 );
            SwapLong( &pCurveTag->curve.count );
            SwapShortOffset( pCurveTag, (ULONG)((SINT8*)&pCurveTag->curve.data[0]-(SINT8*)pCurveTag), elementSize );
#endif
			if (pCurveTag)
			{
				if ( theCombiData->doCreate_16bit_ALut || theCombiData->doCreate_16bit_Combi )	/* UWE 9.2.96		 this is NOT the last Alut*/
				{
					err = Fill_inverse_ushort_ALUT_from_CurveTag( pCurveTag, (UINT16*)DATA_2_PTR(localAlut) + (theAlutSize * loop), addrBits);
					if (err)
						goto CleanupAndExit;
					theLutData->outputLutEntryCount = (SINT16)theAlutSize;
					theLutData->outputLutWordSize = VAL_USED_BITS;
				}
				else												/* this is the last Alut */
				{
					err = Fill_inverse_byte_ALUT_from_CurveTag( pCurveTag, (UINT8*)DATA_2_PTR(localAlut) + (theAlutSize * loop), addrBits);
					if (err)
						goto CleanupAndExit;
					theLutData->outputLutEntryCount = (SINT16)theAlutSize;
					theLutData->outputLutWordSize = bit_breite_alut;
				}
				pCurveTag = (icCurveType*)DisposeIfPtr((Ptr)pCurveTag);
			} else
			{
				err = unimpErr;
				goto CleanupAndExit;
			}
		}
	}
	UNLOCK_DATA(localAlut);
	/* ----------------------------------------------- no error occured -> save results */
	theLutData->outputLut   = localAlut;	
	localAlut = nil;
	/* ---------------------------------------------------------------------------------
	    clean up & exit
	   ---------------------------------------------------------------------------------*/
CleanupAndExit:
	localAlut 		= DISPOSE_IF_DATA(localAlut);
	pCurveTag 		= (icCurveType*)DisposeIfPtr((Ptr)pCurveTag);

	LH_END_PROC("Extract_TRC_Alut")
	return err;
}


/* 
	CMError
	Extract_TRC_Elut	  ( CMLutParamPtr	theLutData,
							LHCombiDataPtr	theCombiData )
    */
CMError
Extract_TRC_Elut	  ( CMLutParamPtr	theLutData,
						LHCombiDataPtr	theCombiData )
{
	OSType			trcSig[kNumOfRGBchannels];
	icCurveType*	pCurveTag = nil;
	SINT32			loop;
	SINT32			theElutSize;
 	CMError			err = noErr;
  	OSErr			aOSerr = noErr;
	UINT32			elementSize;
	LUT_DATA_TYPE	localElut = nil;
	Ptr				singleElut = nil;

	LH_START_PROC("Extract_TRC_Elut")

	theElutSize =  (1<<adr_breite_elut) * sizeof (UINT16);
	localElut = ALLOC_DATA(theLutData->colorLutInDim * theElutSize + sizeof (UINT16), &aOSerr);
	err = aOSerr;
	if (err)
		goto CleanupAndExit;

	/* --------------------------------------------------------------------------------- set gridPoints */
	theLutData->colorLutGridPoints = theCombiData->gridPointsCube;
	
	LOCK_DATA(localElut);
	if (theCombiData->amIPCS)
	{
		/* ---------------------------------------------------------------------------------
		  	if PCS -> create linear Elut...
		   --------------------------------------------------------------------------------- */
		if ( theCombiData->doCreate_16bit_ELut )					/* this is NOT the first Elut */
		{
			CreateLinearElut16 ( (Ptr)DATA_2_PTR(localElut), theElutSize / sizeof(UINT16), theLutData->colorLutGridPoints, 0);
			theLutData->inputLutEntryCount = theElutSize / sizeof(UINT16);
			theLutData->inputLutWordSize = VAL_USED_BITS;
		}
		else														/* this is the first Elut */
		{
          	if ( theCombiData->doCreate_16bit_Combi )				/* UWE 9.2.96 */
          	{
            	CreateLinearElut16 ( (Ptr)DATA_2_PTR(localElut), theElutSize / sizeof(UINT16), theCombiData->gridPointsCube, 0);
            	theLutData->inputLutWordSize = VAL_USED_BITS;
            }
            else
            {
            	CreateLinearElut ( (Ptr)DATA_2_PTR(localElut), theElutSize / sizeof(UINT16), theCombiData->gridPointsCube, 0);
            	theLutData->inputLutWordSize = bit_breite_elut;
            }
            theLutData->inputLutEntryCount = theElutSize / sizeof(UINT16);
		}
		for (loop = 1; loop < theLutData->colorLutInDim; loop++)
			BlockMoveData(DATA_2_PTR(localElut), (Ptr)DATA_2_PTR(localElut) + loop * theElutSize, theElutSize);
	}
	else
	{
		/* ---------------------------------------------------------------------------------
		  	... else take TRCs for Eluts
		   --------------------------------------------------------------------------------- */
		trcSig[0] = icSigRedTRCTag;
		trcSig[1] = icSigGreenTRCTag;
		trcSig[2] = icSigBlueTRCTag;
						
		singleElut = SmartNewPtr(theElutSize, &aOSerr);
		err = aOSerr;
		if (err)
			goto CleanupAndExit;
		for (loop = 0; loop < kNumOfRGBchannels; loop++)
		{
			err = CMGetProfileElement(theCombiData->theProfile, trcSig[loop], &elementSize, nil);
			if (err)
				goto CleanupAndExit;
			pCurveTag = (icCurveType *)SmartNewPtr(elementSize, &aOSerr);
			err = aOSerr;
			if (err)
				goto CleanupAndExit;

			err = CMGetProfileElement(theCombiData->theProfile, trcSig[loop], &elementSize, pCurveTag);
#ifdef IntelMode
            SwapLongOffset( &pCurveTag->base.sig, 0, 4 );
            SwapLong( &pCurveTag->curve.count );
            SwapShortOffset( pCurveTag, (ULONG)((char*)&pCurveTag->curve.data[0]-(char*)pCurveTag), elementSize );
#endif
			if (err)
				goto CleanupAndExit;
			if ( theCombiData->doCreate_16bit_ELut  )		/* this is either NOT the first Elut -or- we have a NewLinkProfile call */
			{
				if ((theCombiData->doCreateLinkProfile) && (theCombiData->profLoop == 0))
					err = Fill_ushort_ELUT_from_CurveTag(pCurveTag, (UINT16*)singleElut, adr_breite_elut, VAL_USED_BITS, 0);
				else
					err = Fill_ushort_ELUT_from_CurveTag(pCurveTag, (UINT16*)singleElut, adr_breite_elut, VAL_USED_BITS, theLutData->colorLutGridPoints);
				theLutData->inputLutEntryCount = (1<<adr_breite_elut);
				theLutData->inputLutWordSize = VAL_USED_BITS;
			}
			else														/* this is the first Elut */
			{
         	  	if ( theCombiData->doCreate_16bit_Combi ) 	/* UWE 9.2.96 */
         	  	{
                	err = Fill_ushort_ELUT_from_CurveTag(pCurveTag, (UINT16*)singleElut, adr_breite_elut, VAL_USED_BITS, theCombiData->gridPointsCube);
                    theLutData->inputLutWordSize = VAL_USED_BITS;
                }
                else
                {
                	err = Fill_ushort_ELUT_from_CurveTag(pCurveTag, (UINT16*)singleElut, adr_breite_elut, bit_breite_elut, theCombiData->gridPointsCube);
                    theLutData->inputLutWordSize = bit_breite_elut;
                }
                theLutData->inputLutEntryCount = (1<<adr_breite_elut);
			}
			if (err)
				goto CleanupAndExit;
			BlockMoveData(singleElut, (Ptr)DATA_2_PTR(localElut) + loop * theElutSize, theElutSize);
			pCurveTag  = (icCurveType *)DisposeIfPtr((Ptr)pCurveTag);
		}
	}
	/* ----------------------------------------------- no error occured -> save results */
	UNLOCK_DATA(localElut);
	theLutData->inputLut = localElut;
	localElut = nil;
	/* ---------------------------------------------------------------------------------
		clean up & exit
	   --------------------------------------------------------------------------------- */
CleanupAndExit:
	pCurveTag  = (icCurveType *)DisposeIfPtr((Ptr)pCurveTag);
	localElut  = DISPOSE_IF_DATA(localElut);
	singleElut = DisposeIfPtr(singleElut);

	LH_END_PROC("Extract_TRC_Elut")
	return err;
}
/* 
	CMError
	Extract_TRC_Matrix	  ( CMLutParamPtr	theLutData,
							LHCombiDataPtr	theCombiData )
    */
CMError
Extract_TRC_Matrix	  ( CMLutParamPtr	theLutData,
						LHCombiDataPtr	theCombiData )
{
	icXYZType 		colorantData[kNumOfRGBchannels];
	icXYZType		curMediaWhite;
	Matrix2D		localMatrix;
	Matrix2D		invertMatrix;
	OSType			colorantTags[kNumOfRGBchannels];
 	CMError			err = noErr;
  	OSErr			aOSerr = noErr;
	SINT32			loop;
	SINT32			i;
	SINT32			j;
	UINT32 			elementSize;
	double			factor;

	LH_START_PROC("Extract_TRC_Matrix")

	/* -----------------------------------------------------------------initialize */
	colorantTags[0] = icSigRedColorantTag;
	colorantTags[1] = icSigGreenColorantTag;
	colorantTags[2] = icSigBlueColorantTag;
		
	/* ---------------------------------------------------------------------------------
	  	take Matrix	from profile
	   ---------------------------------------------------------------------------------*/
	for (loop = 0; loop < kNumOfRGBchannels; loop++)
	{
		err = CMGetProfileElement(theCombiData->theProfile, colorantTags[loop], &elementSize, nil);
		if (err != noErr)
			goto CleanupAndExit;
		err = CMGetProfileElement(theCombiData->theProfile, colorantTags[loop], &elementSize, &colorantData[loop]);
#ifdef IntelMode
        SwapLongOffset( &colorantData[loop].base.sig, 0, 4 );
        SwapLongOffset( &colorantData[loop], (ULONG)((SINT8*)&colorantData[0].data.data[0]-(SINT8*)&colorantData[0]), elementSize );
#endif
		if (err != noErr)
			goto CleanupAndExit;
		localMatrix[0][loop] = ((double)colorantData[loop].data.data[0].X) / 65536.    / 2.;
		localMatrix[1][loop] = ((double)colorantData[loop].data.data[0].Y) / 65536.    / 2.;
		localMatrix[2][loop] = ((double)colorantData[loop].data.data[0].Z) / 65536.    / 2.;
	}
	
	if (theCombiData->renderingIntent == icAbsoluteColorimetric)
	{
		elementSize = sizeof(icXYZType);
		err = CMGetProfileElement(theCombiData->theProfile, icSigMediaWhitePointTag, &elementSize, &curMediaWhite);
#ifdef IntelMode
        SwapLongOffset( &curMediaWhite.base.sig, 0, 4 );
        SwapLongOffset( &curMediaWhite, (ULONG)((SINT8*)&curMediaWhite.data.data[0]-(SINT8*)&curMediaWhite), elementSize );
#endif
		if (err != cmElementTagNotFound)		/* otherwise take D50 -> do nothing */
		{
			if (err != noErr)
				goto CleanupAndExit;
		
			for (i=0; i<3; i++)		/* adjust for media white point */
			{
				if (i == 0)									/* divide X by D50 white X */
					factor = ((double)curMediaWhite.data.data[0].X) / 65536. / 0.9642;
				else if (i == 1)
					factor = ((double)curMediaWhite.data.data[0].Y) / 65536.;
				else										/* divide Z by D50 white Z */
					factor = ((double)curMediaWhite.data.data[0].Z) / 65536. / 0.8249;
				
				for (j=0; j<3; j++)
					localMatrix[i][j] *= factor;
			}
		}
	}
	
	if (theCombiData->amIPCS)
	{
		doubMatrixInvert(localMatrix, invertMatrix);
		BlockMoveData(invertMatrix, localMatrix, 9 * sizeof(double));
	}
	
	theLutData->matrixTRC = SmartNewPtr(sizeof(Matrix2D), &aOSerr);
	err = aOSerr;
	if (err)
		goto CleanupAndExit;
	BlockMoveData(localMatrix, theLutData->matrixTRC, sizeof(Matrix2D));
	/* ---------------------------------------------------------------------------------
	    clean up & exit
	   ---------------------------------------------------------------------------------*/
CleanupAndExit:

	LH_END_PROC("Extract_TRC_Matrix")
	return err;
}

/* 
	CMError
	ExtractAll_TRC_Luts  (  CMLutParamPtr	theLutData,
							LHCombiDataPtr	theCombiData )
    */
CMError
ExtractAll_TRC_Luts  (  CMLutParamPtr	theLutData,
						LHCombiDataPtr	theCombiData )
{
	CMError	err = noErr;
 	
	LH_START_PROC("ExtractAll_TRC_Luts")
 	
	theLutData->colorLutInDim = kNumOfRGBchannels;
	theLutData->colorLutOutDim = kNumOfRGBchannels;
			
	/* ------------------------------------------------------------------------- process A lut */
	err = Extract_TRC_Alut( theLutData, theCombiData);
	if (err != noErr)
		goto CleanupAndExit;
		
	/* ------------------------------------------------------------------------- process matrix */
	err = Extract_TRC_Matrix ( theLutData, theCombiData);
	if (err != noErr)
		goto CleanupAndExit;
		
	/* ------------------------------------------------------------------------- process E lut */
	err = Extract_TRC_Elut( theLutData, theCombiData);
	if (err != noErr)
		goto CleanupAndExit;
		
	/* ---------------------------------------------------------------------------------
	    clean up
	   ---------------------------------------------------------------------------------*/
CleanupAndExit:

	LH_END_PROC("ExtractAll_TRC_Luts")
	return err;
}

/* 
	CMError
	Extract_Gray_Luts	 (  CMLutParamPtr	theLutData,
							LHCombiDataPtr	theCombiData )
    */
CMError
Extract_Gray_Luts	 (  CMLutParamPtr	theLutData,
						LHCombiDataPtr	theCombiData )
{
 	CMError			err = noErr;
  	OSErr			aOSerr = noErr;
	LUT_DATA_TYPE	theElut = nil;
	LUT_DATA_TYPE	theXlut = nil;
	LUT_DATA_TYPE	theAlut = nil;
	SINT32			theElutSize;
	SINT32			theAlutSize;
	SINT32			theXlutSize;
	SINT32			loop;
	UINT32			elementSize;
	UINT8*			bytePtr 	   = nil;
	UINT16*			wordPtr 	   = nil;
	icCurveType*	pCurveTag 	   = nil;
	SINT32			theSize;
	
	LH_START_PROC("Extract_Gray_Luts")
	
	theLutData->colorLutGridPoints = 2;
	
	if (theCombiData->amIPCS)
	{
		theLutData->colorLutInDim = 3;
		theLutData->colorLutOutDim = 1;
	} else
	{
		theLutData->colorLutInDim = 1;
		theLutData->colorLutOutDim = 3;
	}
	
	if (err)
		goto CleanupAndExit;

	/* --------------------------------------------------------------------------------- get tag data */
	err = CMGetProfileElement(theCombiData->theProfile, icSigGrayTRCTag, &elementSize, nil);
	if (err)
		goto CleanupAndExit;
	pCurveTag = (icCurveType *)SmartNewPtr(elementSize, &aOSerr);
	err = aOSerr;
	if (err)
		goto CleanupAndExit;
	err = CMGetProfileElement(theCombiData->theProfile, icSigGrayTRCTag, &elementSize, pCurveTag);
#ifdef IntelMode
    SwapLongOffset( &pCurveTag->base.sig, 0, 4 );
    SwapLong( &pCurveTag->curve.count );
    SwapShortOffset( pCurveTag, (ULONG)((SINT8*)&pCurveTag->curve.data[0]-(SINT8*)pCurveTag), elementSize );
#endif
	if (err)
		goto CleanupAndExit;

	/* 
	  												X l u t
	   */
	if ( theCombiData->profileConnectionSpace == icSigLabData )
	{
		if (theCombiData->amIPCS)			/*------------------------------------------------ Lab -> Gray */
		{
			theXlutSize = ((1 << theLutData->colorLutInDim)+1 ) * (theLutData->colorLutOutDim) * sizeof(UINT16); /*+1=Extra Size for Interpolatio UK13.8.96*/
			theXlut = ALLOC_DATA(theXlutSize + sizeof (UINT16), &aOSerr);
			err = aOSerr;
			if (err)
				goto CleanupAndExit;
			LOCK_DATA(theXlut);
			wordPtr = (UINT16*)DATA_2_PTR(theXlut);
			*(wordPtr    )  = 0x0000;
			*(wordPtr + 1)  = 0x0000;
			*(wordPtr + 2)  = 0x0000;
			*(wordPtr + 3)  = 0x0000;
			*(wordPtr + 4)  = 0xffff;
			*(wordPtr + 5)  = 0xffff;
			*(wordPtr + 6)  = 0xffff;
			*(wordPtr + 7)  = 0xffff;
			UNLOCK_DATA(theXlut);
			theLutData->colorLutWordSize = 16;
		} else								/*------------------------------------------------ Gray -> Lab */
		{
			theXlutSize = (1 << theLutData->colorLutInDim ) * (theLutData->colorLutOutDim) * sizeof(UINT16);
			theXlut = ALLOC_DATA(theXlutSize + sizeof (UINT16), &aOSerr);
			err = aOSerr;
			if (err)
				goto CleanupAndExit;
			LOCK_DATA(theXlut);
			wordPtr = (UINT16*)DATA_2_PTR(theXlut);
			*(wordPtr    )  = 0x0000;
			*(wordPtr + 1)  = 0x0000;
			*(wordPtr + 2)  = 0x0000;
			*(wordPtr + 3)  = 0xffff;
			*(wordPtr + 4)  = 0xffff;
			*(wordPtr + 5)  = 0xffff;
			UNLOCK_DATA(theXlut);
			theLutData->colorLutWordSize = 16;
		}
	} else
	{
		if (theCombiData->amIPCS)			/*------------------------------------------------ XYZ -> Gray */
		{
			theLutData->colorLutGridPoints = 3;
			theXlutSize = (9 * theLutData->colorLutInDim ) * (theLutData->colorLutOutDim) * sizeof(UINT16);
			theXlut = ALLOC_DATA(theXlutSize + 7*sizeof (UINT16), &aOSerr);
			err = aOSerr;
			if (err)
				goto CleanupAndExit;
			LOCK_DATA(theXlut);
			wordPtr = (UINT16*)DATA_2_PTR(theXlut);
			for (loop = 0; loop < theLutData->colorLutGridPoints; loop ++)
			{
				*wordPtr++  = 0x0000;
				*wordPtr++  = 0x0000;
				*wordPtr++  = 0x0000;
				*wordPtr++  = 0xffff;
				*wordPtr++  = 0xffff;
				*wordPtr++  = 0xffff;
				*wordPtr++  = 0xffff;
				*wordPtr++  = 0xffff;
				*wordPtr++  = 0xffff;
			}
			UNLOCK_DATA(theXlut);
			theLutData->colorLutWordSize = 16;
		} else								/*------------------------------------------------ Gray -> XYZ */
		{
			theXlutSize = (1 << theLutData->colorLutInDim ) * (theLutData->colorLutOutDim) * sizeof(UINT16);
			theXlut = ALLOC_DATA(theXlutSize + sizeof (UINT16), &aOSerr);
			err = aOSerr;
			if (err)
				goto CleanupAndExit;
			LOCK_DATA(theXlut);
			wordPtr = (UINT16*)DATA_2_PTR(theXlut);
			*(wordPtr    )  = 0x0000;
			*(wordPtr + 1)  = 0x0000;
			*(wordPtr + 2)  = 0x0000;
			*(wordPtr + 3)  = 0x0f6d5 / 2;
			*(wordPtr + 4)  = 0x0ffff / 2;
			*(wordPtr + 5)  = 0x0d3c2 / 2;
			UNLOCK_DATA(theXlut);
			theLutData->colorLutWordSize = 16;
		}
	}

	/* 
	  												E l u t
	   */
	theElutSize = (1<<adr_breite_elut) * sizeof (UINT16);
	theElut = ALLOC_DATA(theElutSize * theLutData->colorLutInDim + sizeof (UINT16), &aOSerr);
	err = aOSerr;
	if (err)
		goto CleanupAndExit;
	LOCK_DATA(theElut);
		
	if (theCombiData->amIPCS)
	{
		/* -----------------------------------------------------------------------------
		  	if PCS -> create Elut
		   -----------------------------------------------------------------------------*/
		if ( theCombiData->doCreate_16bit_ELut )					/* this is NOT the first Elut */
		{
			CreateLinearElut16 ( (Ptr)DATA_2_PTR(theElut), theElutSize / sizeof(UINT16), theLutData->colorLutGridPoints, 0);
			theLutData->inputLutEntryCount = theElutSize / sizeof(UINT16);
			theLutData->inputLutWordSize = VAL_USED_BITS;
		}
        else														/* this is the first Elut*/
        {
          	if ( theCombiData->doCreate_16bit_Combi )	/* UWE 9.2.96 */
          	{
	            CreateLinearElut16 ( (Ptr)DATA_2_PTR(theElut), theElutSize / sizeof(UINT16), theCombiData->gridPointsCube, 0);
	            theLutData->inputLutWordSize = VAL_USED_BITS;
	        }
	        else
			{
				CreateLinearElut ( (Ptr)DATA_2_PTR(theElut), theElutSize / sizeof(UINT16), theCombiData->gridPointsCube, 0);
				theLutData->inputLutWordSize = bit_breite_elut;
			}
           	theLutData->inputLutEntryCount = theElutSize / sizeof(UINT16);
		}
	}
	else
	{
		/* -----------------------------------------------------------------------------
		  	... else get Elut from TRC tag
		   -----------------------------------------------------------------------------*/
		if ( theCombiData->doCreate_16bit_ELut  )					/* this is NOT the first Elut */
		{
			err = Fill_ushort_ELUT_from_CurveTag(pCurveTag, (UINT16*)DATA_2_PTR(theElut), adr_breite_elut, VAL_USED_BITS, theLutData->colorLutGridPoints);
			theLutData->inputLutEntryCount = (1<<adr_breite_elut);
			theLutData->inputLutWordSize = VAL_USED_BITS;
		}
		else														/* this is the first Elut */
		{
          	if ( theCombiData->doCreate_16bit_Combi )		/* UWE 9.2.96 */
          	{
	            err = Fill_ushort_ELUT_from_CurveTag(pCurveTag, (UINT16*)DATA_2_PTR(theElut), adr_breite_elut, VAL_USED_BITS, theCombiData->gridPointsCube);
	            theLutData->inputLutWordSize = VAL_USED_BITS;
			}
	     	else
	     	{
	            err = Fill_ushort_ELUT_from_CurveTag(pCurveTag, (UINT16*)DATA_2_PTR(theElut), adr_breite_elut, bit_breite_elut, theCombiData->gridPointsCube);
	            theLutData->inputLutWordSize = bit_breite_elut;
			}
            theLutData->inputLutEntryCount = (1<<adr_breite_elut);
		}

	}
	for (loop = 1; loop < (theLutData->colorLutInDim); loop++)
		BlockMoveData(DATA_2_PTR(theElut), (Ptr)DATA_2_PTR(theElut) + loop * theElutSize, theElutSize);
	UNLOCK_DATA(theElut);

	/* 
	  												A l u t
	   */
	if ( theCombiData->doCreate_16bit_ALut || theCombiData->doCreate_16bit_Combi ) /* UWE 9.2.96*/
		theSize = sizeof(UINT16);
	else
		theSize = sizeof(UINT8);
	
	theAlutSize = (1<<adr_breite_alut);
	theAlut = ALLOC_DATA(theLutData->colorLutOutDim * theAlutSize * theSize + theSize, &aOSerr);
	err = aOSerr;
	if (err)
		goto CleanupAndExit;

	LOCK_DATA(theAlut);
	if (theCombiData->amIPCS)
	{
		/* -----------------------------------------------------------------------------
		  	if PCS -> get Alut from TRC tag
		   -----------------------------------------------------------------------------*/
		if ( theCombiData->doCreate_16bit_ALut || theCombiData->doCreate_16bit_Combi )	/*  UWE 9.2.96			this is NOT the last Alut*/
		{
			err = Fill_inverse_ushort_ALUT_from_CurveTag( pCurveTag, (UINT16*)DATA_2_PTR(theAlut), adr_breite_alut);
			if (err)
				goto CleanupAndExit;
			theLutData->outputLutEntryCount = (SINT16)theAlutSize;
			theLutData->outputLutWordSize = VAL_USED_BITS;
		}
		else															/* this is the last Alut */
		{
			err = Fill_inverse_byte_ALUT_from_CurveTag( pCurveTag, (UINT8*)DATA_2_PTR(theAlut), adr_breite_alut);
			if (err)
				goto CleanupAndExit;
			theLutData->outputLutEntryCount = (SINT16)theAlutSize;
			theLutData->outputLutWordSize = bit_breite_alut;
		}
	} else
	{
		/* -----------------------------------------------------------------------------
		  	... else create linear Alut
		   -----------------------------------------------------------------------------*/
		if ( theCombiData->doCreate_16bit_ALut || theCombiData->doCreate_16bit_Combi )	/* UWE 9.2.96			this is NOT the last Alut */
		{
			CreateLinearAlut16 ( (UINT16 *)DATA_2_PTR(theAlut), theAlutSize);
			theLutData->outputLutEntryCount = (SINT16)theAlutSize;
			theLutData->outputLutWordSize = VAL_USED_BITS;
			if ( theCombiData->profileConnectionSpace == icSigLabData )
				SetMem16((Ptr)DATA_2_PTR(theAlut) + theAlutSize * theSize, (theLutData->colorLutOutDim -1 ) * theAlutSize, 0x08000);
			else
			{
				for (loop = 1; loop < theLutData->colorLutOutDim; loop++)
					BlockMoveData(DATA_2_PTR(theAlut), (Ptr)DATA_2_PTR(theAlut) + loop * theAlutSize * sizeof(UINT16), theAlutSize * sizeof(UINT16));
			}
		}
		else														/* this is the last Alut */
		{
			CreateLinearAlut ( (UINT8 *)DATA_2_PTR(theAlut), theAlutSize);
			theLutData->outputLutEntryCount = theAlutSize;
			theLutData->outputLutWordSize = VAL_USED_BITS;
			if ( theCombiData->profileConnectionSpace == icSigLabData )
				SetMem((Ptr)DATA_2_PTR(theAlut) + theAlutSize * theSize, (theLutData->colorLutOutDim -1 ) * theAlutSize * theSize, 0x080);
			else
			{
				for (loop = 1; loop < theLutData->colorLutOutDim; loop++)
					BlockMoveData(DATA_2_PTR(theAlut), (Ptr)DATA_2_PTR(theAlut) + loop * theAlutSize, theAlutSize);
			}
		}
	}
	UNLOCK_DATA(theAlut);

	/* --------------------------------------------------------------------------------- */
	theLutData->inputLut = theElut; theElut = nil;
	theLutData->outputLut = theAlut; theAlut = nil;
	theLutData->colorLut = theXlut; theXlut = nil;

	/* ---------------------------------------------------------------------------------
	    clean up
	   --------------------------------------------------------------------------------- */
CleanupAndExit:
	pCurveTag	= (icCurveType*)DisposeIfPtr((Ptr)pCurveTag);
	theElut 	=  DISPOSE_IF_DATA(theElut);
	theAlut 	=  DISPOSE_IF_DATA(theAlut);
	theXlut 	=  DISPOSE_IF_DATA(theXlut);

	LH_END_PROC("Extract_Gray_Luts")
	return err;
}

/* 
	CMError
	ExtractAllLuts    ( CMLutParamPtr	theLutData,
						LHCombiDataPtr	theCombiData )
    */
CMError
ExtractAllLuts    ( CMLutParamPtr	theLutData,
					LHCombiDataPtr	theCombiData )
{
	CMError	 	err = noErr;
	OSType		theTag;

	LH_START_PROC("ExtractAllLuts")

	/* --------------------------------------------------------------------------------- find out what tag to use... */
	if ( theCombiData->doCreateGamutLut )
		theTag = icSigGamutTag;
	else
	{
		switch (theCombiData->renderingIntent)
		{
			case icPerceptual:				/* Photographic images */
				if (theCombiData->usePreviewTag)
					theTag = icSigPreview0Tag;
				else
				{
					if (theCombiData->amIPCS)
						theTag = icSigBToA0Tag;
					else
						theTag = icSigAToB0Tag;
				}
				break;
			case icRelativeColorimetric:	/* Logo Colors */
				if (theCombiData->usePreviewTag)
					theTag = icSigPreview1Tag;
				else
				{
					if (theCombiData->amIPCS)
						theTag = icSigBToA1Tag;
					else
						theTag = icSigAToB1Tag;
				}
				break;
			case icSaturation:				/* Business graphics */
				if (theCombiData->usePreviewTag)
					theTag = icSigPreview2Tag;
				else
				{
					if (theCombiData->amIPCS)
						theTag = icSigBToA2Tag;
					else
						theTag = icSigAToB2Tag;
				}
				break;
			case icAbsoluteColorimetric:	/* Logo Colors */
				if (theCombiData->usePreviewTag)
					theTag = icSigPreview1Tag;
				else
				{
					if (theCombiData->amIPCS)
						theTag = icSigBToA1Tag;
					else
						theTag = icSigAToB1Tag;
				}
				break;
			default:
				err = cmProfileError;
				break;
		}
	}
#ifdef DEBUG_OUTPUT
	if ( DebugCheck(kThisFile, kDebugMiscInfo) )
		DebugPrint("  ExtractAllLuts: theTag = '%4.4s'=0x%08X (renderingIntent = %d)\n",  &theTag, theTag, theCombiData->renderingIntent );
#endif

	switch (theCombiData->profileClass)
	{
		/* ---------------------------------------------------------------------------------
		  	input profile
		   ---------------------------------------------------------------------------------*/
		case icSigInputClass:
			switch (theCombiData->dataColorSpace)
			{
				case icSigGrayData:																		/*  Gray Input Profile */
					err = Extract_Gray_Luts( theLutData, theCombiData);
					break;
				case icSigRgbData:																			/*  RGB Input Profile */
					err = ExtractAll_MFT_Luts( theLutData, theCombiData, theTag );
					if ( err != noErr && theCombiData->renderingIntent != icPerceptual )
					{
						if (theCombiData->amIPCS)
							theTag = icSigBToA0Tag;
						else
							theTag = icSigAToB0Tag;
#ifdef DEBUG_OUTPUT
						if ( DebugCheck(kThisFile, kDebugErrorInfo) )
							DebugPrint(" 'scnr': ExtractAll_MFT_Luts failed - continuing with '%4.4s'...\n", &theTag);
#endif
						err = ExtractAll_MFT_Luts( theLutData, theCombiData, theTag );
					}
					if (( err != noErr ) && (theCombiData->profileConnectionSpace == icSigXYZData ))
					{
						/* XYZ and no mft -> try matrix/TRC: */
#ifdef DEBUG_OUTPUT
						if ( DebugCheck(kThisFile, kDebugErrorInfo) )
							DebugPrint(" 'scnr': ExtractAll_MFT_Luts failed - continuing with TRC...\n");
#endif
						err = ExtractAll_TRC_Luts( theLutData, theCombiData );
					}
					break;
				case icSigCmykData:																		/* CMYK */
					err = ExtractAll_MFT_Luts( theLutData, theCombiData, theTag );
					if ( err != noErr && theCombiData->renderingIntent != icPerceptual )
					{
						if (theCombiData->amIPCS)
							theTag = icSigBToA0Tag;
						else
							theTag = icSigAToB0Tag;
#ifdef DEBUG_OUTPUT
						if ( DebugCheck(kThisFile, kDebugErrorInfo) )
							DebugPrint(" 'scnr': ExtractAll_MFT_Luts failed - continuing with '%4.4s'...\n", &theTag);
#endif
						err = ExtractAll_MFT_Luts( theLutData, theCombiData, theTag );
					}
					break;
				default:																				/* this covers also: cmHSVData, cmHLSData, cmCMYData */
					/* CMYK Input Profile must have an A2B0Tag (see page 17 InterColor Profile Format) */
					if (theCombiData->amIPCS)
						theTag = icSigBToA0Tag;
					else
						theTag = icSigAToB0Tag;
					err = ExtractAll_MFT_Luts( theLutData, theCombiData, theTag );
					break;
			}
			break;
		/* ---------------------------------------------------------------------------------
		  	display profile
		   ---------------------------------------------------------------------------------*/
		case icSigDisplayClass:
			switch (theCombiData->dataColorSpace)
			{
				case icSigGrayData:																		/*  Gray display Profile */
					err = Extract_Gray_Luts( theLutData, theCombiData);
					break;
				case icSigRgbData:																			/*  RGB display Profile */
					if ( theCombiData->doCreateGamutLut)
					{
						err = DoMakeGamutForMonitor( theLutData, theCombiData );
					} else
					{
						err = ExtractAll_MFT_Luts(theLutData, theCombiData, theTag);
						if (( err != noErr ) && (theCombiData->profileConnectionSpace == icSigXYZData ))
						{
							/* XYZ and no mft -> try matrix/TRC: */
#ifdef DEBUG_OUTPUT
							if ( DebugCheck(kThisFile, kDebugErrorInfo) )
								DebugPrint(" 'mntr': ExtractAll_MFT_Luts failed - continuing with TRC...\n");
#endif
							err = ExtractAll_TRC_Luts( theLutData, theCombiData );
						}
					}
					break;
				case icSigCmykData:
				default:																				/* this covers: cmCMYK, cmHSVData, cmHLSData, cmCMYData */
					err = ExtractAll_MFT_Luts(theLutData, theCombiData, theTag);
					break;
			}
			break;
		/* ---------------------------------------------------------------------------------
		  	output profile
		   ---------------------------------------------------------------------------------*/
		case icSigOutputClass:
			switch (theCombiData->dataColorSpace)
			{
				case icSigGrayData:																		/*  Gray output Profile */
					err = Extract_Gray_Luts( theLutData, theCombiData );
					break;
				case icSigRgbData:																			/*  RGB output Profile */
				case icSigCmykData:																		/*  CMYK output Profile */
				default:																				/*  this covers also: cmHSVData, cmHLSData, cmCMYData*/
					err = ExtractAll_MFT_Luts( theLutData, theCombiData, theTag );
					break;
			}
			break;
		/* ---------------------------------------------------------------------------------
		  	DeviceLink profile
		   ---------------------------------------------------------------------------------*/
		case icSigLinkClass:
			err = ExtractAll_MFT_Luts( theLutData, theCombiData, icSigAToB0Tag );
			break;
		/* ---------------------------------------------------------------------------------
		  	ColorSpaceConversion profile
		   ---------------------------------------------------------------------------------*/
        case icSigColorSpaceClass:		/* 'spac' */
			if (theCombiData->amIPCS)
				err = ExtractAll_MFT_Luts( theLutData, theCombiData, icSigBToA0Tag );
			else
				err = ExtractAll_MFT_Luts( theLutData, theCombiData, icSigAToB0Tag );
			break;
		/* ---------------------------------------------------------------------------------
		  	Abstract profile
		   ---------------------------------------------------------------------------------*/
        case icSigAbstractClass:		/* 'abst' */
			err = ExtractAll_MFT_Luts( theLutData, theCombiData, icSigAToB0Tag );
			break;
		default:
			err = cmProfileError;
			break;
	}

	LH_END_PROC("ExtractAllLuts")
	return err;
}
#ifdef RenderInt
long GetActualRenderingIntent( CMMModelPtr CMSession, UINT32 i )
{
	long Render;
	Render = icAbsoluteColorimetric;
	if( CMSession->dwFlags & kUseRelColorimetric ) Render = icRelativeColorimetric;
	if( i == 0xffffffff ) return Render;
	 /* First Intent of array is for first transform */
	if( CMSession-> aIntentArr && CMSession-> nIntents >= 1 ){
		if( i < CMSession-> nIntents ){
			Render = CMSession-> aIntentArr[i];
		}
	}
	return Render;
}
#endif
CMError InitNamedColorProfileData( 	CMMModelPtr 		storage,
						  			CMProfileRef		aProf,
									long				pcs,
									long				*theDeviceCoords);
/*CMError QuantizeNamedValues( CMMModelPtr 		storage,
							 Ptr				imgIn,
							 long				size );*/
/* 
	CMError
	Create_LH_ProfileSet	( CMMModelPtr    		CMSession,
							  CMConcatProfileSet* 	profileSet,
							  LHConcatProfileSet**	newProfileSet )
    */
CMError
Create_LH_ProfileSet	( CMMModelPtr    		CMSession,
						  CMConcatProfileSet* 	profileSet,
						  LHConcatProfileSet**	newProfileSet )
{
	icHeader				profHeader;
	LHConcatProfileSet* 	theProfileSet;
	CMProfileRef			theProfile;
   	OSType					previousDataColorSpace  = 0x20202020;
   	OSType					previousConnectionSpace = 0x20202020;
   	UINT32					previousRenderingIntent;
  	CMError					err = noErr;
  	OSErr					aOSerr = noErr;
	UINT32 					elementSize = 0;
	SINT16					max;
	SINT16					theSize;
	SINT16					index = 0;
	UINT16					profLoop;
	Boolean					amIPCS = FALSE;
	OSType					theTag;
	UINT32					intentIndex = 0;
	long					nDeviceCoords;

	LH_START_PROC("Create_LH_ProfileSet")
	
	nDeviceCoords=0;
	max = profileSet->count * 3;
	theSize = sizeof (LHConcatProfileSet) + sizeof(LHProfile) * max;
   	theProfileSet = (LHConcatProfileSet *)SmartNewPtrClear(theSize, &aOSerr);
	err = aOSerr;
	if (err)
		goto CleanupAndExit;
		
	theProfileSet->keyIndex = profileSet->keyIndex;
	
	CMSession->hasNamedColorProf = NoNamedColorProfile;
	for ( profLoop = 0; profLoop < profileSet->count; profLoop++ )
	{
		err = CMGetProfileHeader(profileSet->profileSet[profLoop], (CMCoreProfileHeader *)&profHeader);
		if (err)
			goto CleanupAndExit;
		if (profLoop == 0){
#ifdef RenderInt
			if( CMSession-> dwFlags != 0xffffffff ){
				profHeader.renderingIntent = GetActualRenderingIntent( CMSession, profLoop );
			}
#endif
			theProfileSet->prof[index].renderingIntent = profHeader.renderingIntent;
		}
		else{
#ifdef RenderInt
			if( CMSession-> dwFlags != 0xffffffff ){
				profHeader.renderingIntent = GetActualRenderingIntent( CMSession, profLoop );
				previousRenderingIntent = profHeader.renderingIntent;
			}
#endif
			theProfileSet->prof[index].renderingIntent = previousRenderingIntent;
		}
		if ( (profLoop > 0) && (profLoop < profileSet->count - 1) )
		{
			/*----------------------------------------------------------------------------- color space conv. inbetween? -> ignore the profile*/
			if( profHeader.deviceClass == icSigColorSpaceClass )
				continue;
			if( profHeader.deviceClass == icSigNamedColorClass ){
				err = cmCantConcatenateError;
				goto CleanupAndExit;
			}
		}
		/*-------------------------------------------------------------------------------------------------------
		   if we have non matching pcs color spaces, we have to add a conversion between Lab and XYZ
		  -------------------------------------------------------------------------------------------------------*/
		if( profHeader.deviceClass == icSigNamedColorClass ){
			err = InitNamedColorProfileData( CMSession, profileSet->profileSet[profLoop], profHeader.pcs, &nDeviceCoords );
			if (err)
				goto CleanupAndExit;
			profHeader.pcs = icSigLabData;
			if( profileSet->count == 1 ){
				CMSession->hasNamedColorProf = NamedColorProfileOnly;
				//CMSession->dataColorSpace = profHeader.colorSpace;
			}
			else if( profLoop == 0 ){
				CMSession->hasNamedColorProf = NamedColorProfileAtBegin;
				profHeader.colorSpace = icSigNamedData;
				CMSession->firstColorSpace = icSigNamedData;
				theProfileSet->prof[index].pcsConversionMode = kNoInfo;	
				theProfileSet->prof[index].profileSet = 0;
				index++;
				theProfileSet->prof[index].renderingIntent = previousRenderingIntent;
				previousDataColorSpace = (OSType)profHeader.colorSpace;
			}
			else if( profLoop == profileSet->count-1 ){
				CMSession->hasNamedColorProf = NamedColorProfileAtEnd;
				CMSession->lastColorSpace = icSigNamedData;
				profHeader.colorSpace = icSigNamedData;
				theProfileSet->prof[index].pcsConversionMode = kNoInfo;	
				theProfileSet->prof[index].profileSet = 0;
				index++;
				theProfileSet->prof[index].renderingIntent = previousRenderingIntent;
			}
		}
		if (amIPCS)
		{
			if (previousConnectionSpace != (OSType)profHeader.pcs)
			{
				/* insert a XYZ <--> Lab conversion lut */
				if (previousConnectionSpace == icSigLabData)
					theProfileSet->prof[index].pcsConversionMode = kDoLab2XYZ;		/* create Lab->XYZ */
				else
					theProfileSet->prof[index].pcsConversionMode = kDoXYZ2Lab;		/* create XYZ->Lab */
				index++;
				theProfileSet->prof[index].renderingIntent = previousRenderingIntent;
			}
		} else if (index > 0)
		{
			if ( previousDataColorSpace != (OSType)profHeader.colorSpace)
			{
				/* copy old profile for back transform to pcs */
				theProfileSet->prof[index].profileSet = theProfileSet->prof[index-1].profileSet;
				index++;
				theProfileSet->count = index;
				
				if (previousConnectionSpace != (OSType)profHeader.pcs)
				{
					/* insert a XYZ <--> Lab conversion lut */
					if (previousConnectionSpace == icSigLabData)
						theProfileSet->prof[index].pcsConversionMode = kDoLab2XYZ;		/* create Lab->XYZ */
					else
						theProfileSet->prof[index].pcsConversionMode = kDoXYZ2Lab;		/* create XYZ->Lab */
					theProfileSet->prof[index].renderingIntent = previousRenderingIntent;
					index++;
				}
				
				previousDataColorSpace  = profHeader.colorSpace;
				previousConnectionSpace = profHeader.pcs;
				amIPCS = TRUE;
			}
		}

		/*-------------------------------------------------------------------------------------------------------
		   copy the profile from the original profileSet to the LinoProfileSet
		  -------------------------------------------------------------------------------------------------------*/
		theProfileSet->prof[index].profileSet = profileSet->profileSet[profLoop];
		if( profHeader.deviceClass == icSigNamedColorClass ){
			theProfileSet->prof[index].profileSet = 0;
		}
		index++;
		if( intentIndex < CMSession-> nIntents -1 ) intentIndex++;
		/*-------------------------------------------------------------------------------------------------------
		   more than 2 profiles -> we have to double the profile in our own LHConcatProfileSet
		   if we have the profiles  RGB  RGB  RGB  we will now correctly generate: RGB  RGB  rgb  RGB
		                            XYZ  XYZ  XYZ                                  XYZ  XYZ  xyz  XYZ
		  -------------------------------------------------------------------------------------------------------*/
		if( amIPCS && (profLoop > 0) && (profLoop < profileSet->count - 1) )
		{
			/*----------------------------------------------------------------------------- color space conv. inbetween? -> ignore the profile*/
			if (profHeader.deviceClass == icSigColorSpaceClass)
				index--;										/* not used. behavior changed. see above */
			else
			{
				/*------------------------------------------------------------------------- if the inserted profile contains a preview tag, then use it...*/
				theProfile = theProfileSet->prof[index-1].profileSet;

				/* Do we check the right preview tag for the intent */
				switch (previousRenderingIntent)
				{
					case icPerceptual:				/* Photographic images */
						theTag = icSigPreview0Tag;
						break;
						
					case icRelativeColorimetric:	/* Logo Colors */
						theTag = icSigPreview1Tag;
						break;
						
					case icSaturation:				/* Business graphics */
						theTag = icSigPreview2Tag;
						break;
						
					case icAbsoluteColorimetric:	/* Logo Colors */
						theTag = icSigPreview1Tag;
						break;
						
					default:
						err = cmProfileError;
						goto CleanupAndExit;
				}
				err = CMGetProfileElement(theProfile, theTag, &elementSize, nil);
				
				if (err == noErr)
				{
					theProfileSet->prof[index-1].usePreviewTag = TRUE;
					theProfileSet->prof[index-1].renderingIntent = profHeader.renderingIntent;	/* for concate absolute */
				} else
				{
				/*------------------------------------------------------------------------- ... else insert the same profile once more */
					if ( (profHeader.deviceClass != icSigAbstractClass) && (profHeader.deviceClass != icSigLinkClass) && (profHeader.deviceClass != icSigNamedColorClass) )	
					{
#ifdef RenderInt
						if( CMSession-> dwFlags != 0xffffffff ){
							profHeader.renderingIntent = GetActualRenderingIntent( CMSession, 0xffffffff );
						}
#endif
						theProfileSet->prof[index].profileSet = profileSet->profileSet[profLoop];
						theProfileSet->prof[index].renderingIntent = profHeader.renderingIntent;/* for concate absolute */
						index++;
					}
				}
				amIPCS = FALSE;		/* will force that we stay in PCS... */
			}
		}
		theProfileSet->count = index;
		previousDataColorSpace  = profHeader.colorSpace;
		previousConnectionSpace = profHeader.pcs;
		previousRenderingIntent = profHeader.renderingIntent;

		if( profHeader.deviceClass == icSigLinkClass ){
			previousDataColorSpace = profHeader.pcs;
			amIPCS = TRUE;
		}
		if (amIPCS)
			amIPCS = (previousDataColorSpace == icSigLabData) || (previousDataColorSpace == icSigXYZData);
		else
			amIPCS = TRUE;
	}

#ifdef ALLOW_DEVICE_LINK
	if( (CMSession)->appendDeviceLink ){
		if( previousDataColorSpace == (CMSession)->lastColorSpace ){
			theProfileSet->prof[index].profileSet = profileSet->profileSet[profLoop];
			theProfileSet->prof[index].renderingIntent = icPerceptual;
			index++;
			theProfileSet->count = index;
			err = CMGetProfileHeader(profileSet->profileSet[profLoop], (CMCoreProfileHeader *)&profHeader);
			if (err)
				goto CleanupAndExit;
			(CMSession)->lastColorSpace = profHeader.pcs;
		}
		else{
			err = cmCantConcatenateError;
			goto CleanupAndExit;
		}
	}
	if( CMSession->hasNamedColorProf == NamedColorProfileAtEnd || CMSession->hasNamedColorProf == NamedColorProfileOnly ){
			theProfileSet->count--;
	}
	if( CMSession->hasNamedColorProf == NamedColorProfileAtBegin ){
		theProfileSet->count--;					/* remove first profile */
		for( profLoop=0; profLoop<theProfileSet->count; profLoop++){
			theProfileSet->prof[profLoop] = theProfileSet->prof[profLoop+1];
		}
	}
#endif
	*newProfileSet = theProfileSet;
	theProfileSet = nil;
	/* ---------------------------------------------------------------------------------
	    clean up
	   --------------------------------------------------------------------------------- */
CleanupAndExit:
	theProfileSet = (LHConcatProfileSet *)DisposeIfPtr((Ptr)theProfileSet);

	LH_END_PROC("Create_LH_ProfileSet")
	return err;
}

#define DoLabSpecial
#ifdef DoLabSpecial
OSErr MakeSpecialCube16(	long 			inputDim,
		  					long 			*theCubeSize,
		  					CUBE_DATA_TYPE	*theCube,
							long 			*theBits,
							long 			*theExtraSize );
OSErr MakeSpecialCube16(	long 			inputDim,
		  					long 			*theCubeSize,
		  					CUBE_DATA_TYPE	*theCube,
							long 			*theBits,
							long 			*theExtraSize )
{
	long 			needBits,theSize,aExtraSize;
	long 			i,gridPoints;
	OSErr			err = noErr;
	UINT16 			*cube = nil;
	CUBE_DATA_TYPE	tempCube;
	
	LH_START_PROC("MakeSpecialCube16")
	err = CalcGridPoints4Cube(*theCubeSize, inputDim, &gridPoints, &needBits);
	if (err)
		goto CleanupAndExit;
		
	theSize = 1;
	aExtraSize = 1;
	for( i=0; i<(inputDim-1); ++i){	/* Extra Size for Interpolation */
		theSize *= gridPoints;
		aExtraSize += theSize;
	}
	
#ifdef ALLOW_MMX
	aExtraSize++;	/* +1 for MMX 4 Byte access */
#endif
    theSize *= gridPoints;
    	
	*theExtraSize = aExtraSize;
	*theCubeSize = theSize * inputDim;
	tempCube = ALLOC_DATA( (theSize+aExtraSize) * inputDim*2, &err);
	if (err != noErr)
		goto CleanupAndExit;
	LOCK_DATA(tempCube);
	cube = (UINT16*)DATA_2_PTR(tempCube);

	*theBits = needBits;
	if( inputDim == 3)
	{
		register unsigned long  aShift;
		register long  j,k;
		register UINT16 aI, aJ, aK;
		aShift = (16 - needBits);

		gridPoints /= 2;
		needBits--;
		for( i=0; i<=gridPoints; ++i){
			aI = (UINT16)(i<< aShift);
			for( j=0; j<=gridPoints; ++j){
				aJ = (UINT16)(j<< aShift);
				for( k=0; k<=gridPoints; ++k){
					*cube++ = aI;
					*cube++ = aJ;
					aK = (UINT16)(k<< aShift);
					*cube++ = aK;
				}
				for( k=1; k<gridPoints; ++k){
					*cube++ = aI;
					*cube++ = aJ;
					aK = (UINT16)(k<< aShift);
					aK |= aK >> needBits;
					aK |= aK >> (2*needBits);
					aK |= aK >> (4*needBits);
					*cube++ = aK+0x08000;
				}
			}
			for( j=1; j<gridPoints; ++j){
				aJ = (UINT16)(j<< aShift);
				aJ |= aJ >> needBits;
				aJ |= aJ >> (2*needBits);
				aJ |= aJ >> (4*needBits);
				aJ += 0x08000;
				for( k=0; k<=gridPoints; ++k){
					*cube++ = aI;
					*cube++ = aJ;
					aK = (UINT16)(k<< aShift);
					*cube++ = aK;
				}
				for( k=1; k<gridPoints; ++k){
					*cube++ = aI;
					*cube++ = aJ;
					aK = (UINT16)(k<< aShift);
					aK |= aK >> needBits;
					aK |= aK >> (2*needBits);
					aK |= aK >> (4*needBits);
					*cube++ = aK+0x08000;
				}
			}
		}
		for( i=1; i<gridPoints; ++i){
			aI = (UINT16)(i<< aShift);
			aI |= aI >> needBits;
			aI |= aI >> (2*needBits);
			aI |= aI >> (4*needBits);
			aI += 0x08000;
			for( j=0; j<=gridPoints; ++j){
				aJ = (UINT16)(j<< aShift);
				for( k=0; k<=gridPoints; ++k){
					*cube++ = aI;
					*cube++ = aJ;
					aK = (UINT16)(k<< aShift);
					*cube++ = aK;
				}
				for( k=1; k<gridPoints; ++k){
					*cube++ = aI;
					*cube++ = aJ;
					aK = (UINT16)(k<< aShift);
					aK |= aK >> needBits;
					aK |= aK >> (2*needBits);
					aK |= aK >> (4*needBits);
					*cube++ = aK+0x08000;
				}
			}
			for( j=1; j<gridPoints; ++j){
				aJ = (UINT16)(j<< aShift);
				aJ |= aJ >> needBits;
				aJ |= aJ >> (2*needBits);
				aJ |= aJ >> (4*needBits);
				aJ += 0x08000;
				for( k=0; k<=gridPoints; ++k){
					*cube++ = aI;
					*cube++ = aJ;
					aK = (UINT16)(k<< aShift);
					*cube++ = aK;
				}
				for( k=1; k<gridPoints; ++k){
					*cube++ = aI;
					*cube++ = aJ;
					aK = (UINT16)(k<< aShift);
					aK |= aK >> needBits;
					aK |= aK >> (2*needBits);
					aK |= aK >> (4*needBits);
					*cube++ = aK+0x08000;
				}
			}
		}
	}
	UNLOCK_DATA(tempCube);
	*theCube = tempCube;
CleanupAndExit:
	LH_END_PROC("MakeSpecialCube16")
	return err;
}
#endif

/* 
	CMError
	CreateCombi	( CMMModelHandle    	modelingData,
				  CMConcatProfileSet* 	profileSet,
				  LHConcatProfileSet*	newProfileSet,
				  CMLutParam*			finalLutData,	
				  Boolean				createGamutLut )
    */
CMError
CreateCombi	( CMMModelPtr	    	modelingData,
			  CMConcatProfileSet* 	profileSet,
			  LHConcatProfileSet*	newProfileSet,
			  CMLutParamPtr			finalLutData,	
			  Boolean				createGamutLut )
{
	icHeader				profHeader;
	CMLutParam				aDoNDimTableData;
	DoMatrixForCubeStruct	aDoMatrixForCubeStruct;
	CMCalcParam 			calcParam;
			
   	CMError				err = noErr;
   	OSErr				aOSerr = noErr;
	CUBE_DATA_TYPE		inputBuffer	 = nil;
	CUBE_DATA_TYPE		outputBuffer = nil;

	SINT32				loop;
	SINT32				theSize;
	SINT32				theElutSize;
	SINT32				theAlutSize;
	SINT32				theCubeSize;
	SINT32				theExtraSize=1;
	SINT32				theCubePixelCount;
	UINT16				profLoop;
	SINT32				savedGridPoints;
	SINT32				gridBits;
	SINT32				gridPointsCube;
	Boolean 			SavedoCreate_16bit_XLut;
	Boolean 			SavedoCreate_16bit_ALut;
	void					*SaveoutputLut;
	long				SaveoutputLutEntryCount;
	long				SaveoutputLutWordSize;
	/*long				SavegridPointsCube;*/
	UINT8	 			bIsLabConnection = 0;
	
	SINT32				numOfElutsCube;

	Boolean				doSaveElut		= TRUE;
	Boolean 			skipCombi		= FALSE;
	Boolean 			pcsConversion	= FALSE;
	Boolean 			useOutputBuffer;
	LHCombiData			theCombiData;
	CMLutParam			theLutData;	
	SINT32				theBufferByteCount;
	UINT16				aUINT16;
	UINT16				*wordPtr   = nil;
	UINT8				*xlutPtr   = nil;
#ifdef DoLabSpecial
	UINT32				aFac;
	UINT32				i;
#endif

#ifdef WRITE_LUTS
	Str255				fileString;
#endif
#ifdef DEBUG_OUTPUT
	Str255				lutString;
#endif
	LH_START_PROC("CreateCombi")

	theBufferByteCount = 2;
	SetMem(&theCombiData,	sizeof(LHCombiData), 0);
	SetMem(&theLutData, 	sizeof(CMLutParam),	 0);
	
	theCombiData.amIPCS = FALSE;			/* amIPCS has to be FALSE at the beginning of the chain */
	if ( modelingData->hasNamedColorProf == NamedColorProfileAtBegin ){
		theCombiData.amIPCS = TRUE;
	}
	if (newProfileSet->count == 1)
		skipCombi = TRUE;
	
	err = CMGetProfileHeader(profileSet->profileSet[0], (CMCoreProfileHeader *)&profHeader);
	if (err)
		goto CleanupAndExit;
	modelingData->precision = (SINT16)((profHeader.flags & kQualityMask)>>16);
	
#ifdef RenderInt
	if( modelingData-> dwFlags != 0xffffffff ){
		modelingData->precision = (short)( modelingData->dwFlags & 0x0ffff);
	}
#endif
	if ( modelingData->precision >= cmBestMode )		/* first fix - best mode creates 16-bit luts */
	{
		theCombiData.doCreate_16bit_Combi = TRUE;
		modelingData->precision = cmBestMode;
	}
	else
	{
      theCombiData.doCreate_16bit_Combi = FALSE;
  	}
#ifdef DEBUG_OUTPUT
	if ( DebugCheck(kThisFile, kDebugMiscInfo) )
		DebugPrint("  CMMModelHandle->precision = %d doCreate_16bit_Combi=%d\n",modelingData->precision,theCombiData.doCreate_16bit_Combi);
#endif
	
	switch (modelingData->precision)
	{
		case cmNormalMode:
			if (createGamutLut)
				theCubePixelCount = 87382;
			else
				theCubePixelCount = 87382;
				if( modelingData->lookup )theCubePixelCount = 87382;
				break;
		case cmDraftMode:
			if (createGamutLut)
				theCubePixelCount = 5462;
			else
				theCubePixelCount = 5462;		/* 5462 * 3  4 * 8 * 8 * 8 * 8	 	->  allow 8^4 */
			break;
		case cmBestMode:
			if (createGamutLut)
				theCubePixelCount = 87382;
			else
				theCubePixelCount = 87382;   /* 87382 * 3  4 * 16 * 16 * 16 * 16;	->  allow 16^4  !!! */
			break;
	}
	theCubeSize = theCubePixelCount * 3;
	theCombiData.precision 			 = modelingData->precision;
	theCombiData.maxProfileCount 	 = newProfileSet->count-1;
	theCombiData.doCreateLinkProfile = (modelingData->currentCall == kCMMNewLinkProfile);
	switch ( modelingData->firstColorSpace )
	{
		case icSigXYZData:
		case icSigLabData:
		case icSigLuvData:
		case icSigYxyData:
		case icSigRgbData:
		case icSigHsvData:
		case icSigHlsData:
		case icSigCmyData:
#ifdef PI_Application_h
		case icSigYCbCrData:
		case icSigMCH3Data:
		case icSigNamedData:
#endif
			err = CalcGridPoints4Cube ( theCubeSize, 3, &theCombiData.gridPointsCube, &gridBits );		/* 3 input channels */
			break;
		case icSigGrayData:
			theCubeSize = 255 ;
			err = CalcGridPoints4Cube ( theCubeSize, 1, &theCombiData.gridPointsCube, &gridBits );		/* 1 input channel  */
			break;
		case icSigCmykData:
		case icSigMCH4Data:
			err = CalcGridPoints4Cube ( theCubeSize, 4, &theCombiData.gridPointsCube, &gridBits );		/* 4 input channels */
			break;
		case icSigMCH2Data:
			err = CalcGridPoints4Cube ( theCubeSize, 2, &theCombiData.gridPointsCube, &gridBits );		/* 2 input channels */
			break;
		case icSigMCH5Data:
			err = CalcGridPoints4Cube ( theCubeSize, 5, &theCombiData.gridPointsCube, &gridBits );		/* 5 input channels */
			break;
		case icSigMCH6Data:
			err = CalcGridPoints4Cube ( theCubeSize, 6, &theCombiData.gridPointsCube, &gridBits );		/* 6 input channels */
			break;
		case icSigMCH7Data:
			err = CalcGridPoints4Cube ( theCubeSize, 7, &theCombiData.gridPointsCube, &gridBits );		/* 7 input channels */
			break;
		case icSigMCH8Data:
			err = CalcGridPoints4Cube ( theCubeSize, 8, &theCombiData.gridPointsCube, &gridBits );		/* 8 input channels */
			break;
	}

	bIsLabConnection = 0;
	if( profHeader.pcs == icSigXYZData ){
		for ( profLoop = 0; profLoop < newProfileSet->count; profLoop++ ){
			if( newProfileSet->prof[profLoop].profileSet == 0 ){
				bIsLabConnection |= 1;
			}
		}
	}
	err = CMGetProfileHeader(profileSet->profileSet[profileSet->count-1], (CMCoreProfileHeader *)&profHeader);
	if (err)
		goto CleanupAndExit;
	if( profHeader.pcs == icSigXYZData ){
		for ( profLoop = 0; profLoop < newProfileSet->count; profLoop++ ){
			if( newProfileSet->prof[profLoop].profileSet == 0 && !createGamutLut ){
				bIsLabConnection |=2;
			}
		}
	}
	/*bIsLabConnection = 0;*/
	if( modelingData->hasNamedColorProf == NamedColorProfileAtBegin ){
		bIsLabConnection |=1;
		theCombiData.doCreate_16bit_Combi = TRUE;
	}
		
	if( modelingData->hasNamedColorProf == NamedColorProfileAtEnd ){
		bIsLabConnection |=2;
		theCombiData.doCreate_16bit_Combi = TRUE;
	}
		
	/*--------------------------------------------------------------------------------------------------
	  --                                  loop over all profiles
	  --------------------------------------------------------------------------------------------------*/
	for ( profLoop = 0; profLoop < newProfileSet->count; profLoop++ )
	{
#ifdef DEBUG_OUTPUT
		if ( DebugCheck(kThisFile, kDebugMiscInfo) )
			DebugPrint("  < Processing profile #%d >\n",profLoop);
#endif
		theCombiData.profLoop = (long)profLoop;
		if ( theCombiData.doCreateLinkProfile )
		{
			theCombiData.doCreate_16bit_ELut = TRUE;
            theCombiData.doCreate_16bit_XLut = TRUE; /* UWE 9.2.96 */
			theCombiData.doCreate_16bit_ALut = TRUE;
		} else
		{
			theCombiData.doCreate_16bit_ELut = ( profLoop != 0 );
            theCombiData.doCreate_16bit_XLut = theCombiData.doCreate_16bit_Combi;	/* UWE 9.2.96 */
			theCombiData.doCreate_16bit_ALut = ( profLoop != newProfileSet->count-1 );
		}
		if (newProfileSet->prof[profLoop].profileSet)
		{
			theCombiData.theProfile = newProfileSet->prof[profLoop].profileSet;
			err = CMGetProfileHeader(theCombiData.theProfile, (CMCoreProfileHeader *)&profHeader);
			if (err)
				goto CleanupAndExit;
			theCombiData.profileClass			= profHeader.deviceClass;
			theCombiData.dataColorSpace 		= profHeader.colorSpace;
			theCombiData.profileConnectionSpace	= profHeader.pcs;
			theCombiData.renderingIntent 		= newProfileSet->prof[profLoop].renderingIntent;
			pcsConversion = FALSE;
		}
		else{
			pcsConversion = TRUE;
		}
		if ( (err == noErr) || pcsConversion ){
			/*------------------------ free pointers... */
			theLutData.inputLut 	= DISPOSE_IF_DATA(theLutData.inputLut);
			theLutData.outputLut 	= DISPOSE_IF_DATA(theLutData.outputLut);
			theLutData.colorLut 	= DISPOSE_IF_DATA(theLutData.colorLut);
			theLutData.matrixMFT 	= DisposeIfPtr(theLutData.matrixMFT);
			theLutData.matrixTRC 	= DisposeIfPtr(theLutData.matrixTRC);
			
			if (pcsConversion)
			{
				/*
				  	pcsConversion: we have to convert:     XYZ <-->  Lab
				  */
				if (inputBuffer == nil)
				{
					theLutData.colorLutInDim = 3;
#ifdef DoLabSpecial
					if( modelingData->firstColorSpace == icSigLabData || modelingData->firstColorSpace == icSigLuvData ){
						err = MakeSpecialCube16(theLutData.colorLutInDim, &theCubeSize, &theLutData.colorLut, &gridBits, &theExtraSize );
					}
					else
#endif
					err = MakeCube16(theLutData.colorLutInDim, &theCubeSize, &theLutData.colorLut, &gridBits, &theExtraSize );
#ifdef DEBUG_OUTPUT
					if ( DebugCheck(kThisFile, kDebugMiscInfo) )
						DebugPrint("  MakeCube16 -> '%d' bits    cubeSize = %d\n",gridBits, theCubeSize);
#endif
					if (err)
						goto CleanupAndExit;
					theCubePixelCount = theCubeSize / theLutData.colorLutInDim;
					numOfElutsCube = theLutData.colorLutInDim;
					gridPointsCube = 1<<gridBits;
					savedGridPoints = gridPointsCube;
					if( profLoop == 0 ){
						theLutData.inputLutEntryCount = 1<<adr_breite_elut;
						if( theCombiData.doCreate_16bit_ELut ) theLutData.inputLutWordSize = VAL_USED_BITS;
						else  theLutData.inputLutWordSize = bit_breite_elut;
						theLutData.colorLutGridPoints = gridPointsCube;	
					}

				}
				else{
					theLutData.colorLut = inputBuffer;
					inputBuffer = nil;
				}
				
				LOCK_DATA(theLutData.colorLut);
#ifdef DEBUG_OUTPUT
				ShowCube16( profLoop, "Lab<->XYZ", createGamutLut, (UINT16 *)DATA_2_PTR(theLutData.colorLut), gridPointsCube, theLutData.colorLutInDim, 3,VAL_USED_BITS );
#endif
				/*if ( modelingData->hasNamedColorProf == NamedColorProfileAtBegin ){
					inputBuffer = theLutData.colorLut;
					theLutData.colorLut = 0;
					QuantizeNamedValues( modelingData, inputBuffer, theCubeSize/theLutData.colorLutInDim );
					theCombiData.amIPCS = TRUE;
#ifdef DEBUG_OUTPUT
					ShowCube16( profLoop, "after Lab<->XYZ", createGamutLut, (UINT16 *)DATA_2_PTR(theLutData.colorLut), gridPointsCube, theLutData.colorLutInDim, 3, VAL_USED_BITS );
#endif
					UNLOCK_DATA(theLutData.colorLut);
					skipCombi = FALSE;
					theLutData.colorLutInDim = kNumOfLab_XYZchannels;
					theLutData.colorLutOutDim = kNumOfLab_XYZchannels;
					continue;
				}
				else */
				if ( newProfileSet->prof[profLoop].pcsConversionMode == kDoLab2XYZ )
				{
#ifdef DEBUG_OUTPUT
					if ( DebugCheck(kThisFile, kDebugMiscInfo) )
						DebugPrint("  doing a PCS conversion:  Lab -> XYZ\n");
#endif
					Lab2XYZ_forCube16((UINT16*)DATA_2_PTR(theLutData.colorLut), theCubePixelCount);
				}
				else if ( newProfileSet->prof[profLoop].pcsConversionMode == kDoXYZ2Lab )
				{
#ifdef DEBUG_OUTPUT
					if ( DebugCheck(kThisFile, kDebugMiscInfo) )
						DebugPrint("  doing a PCS conversion:  XYZ -> Lab\n");
#endif
					XYZ2Lab_forCube16((UINT16*)DATA_2_PTR(theLutData.colorLut), theCubePixelCount);
				}
#ifdef DEBUG_OUTPUT
				ShowCube16( profLoop, "after Lab<->XYZ", createGamutLut, (UINT16 *)DATA_2_PTR(theLutData.colorLut), gridPointsCube, theLutData.colorLutInDim, 3, VAL_USED_BITS );
#endif
				UNLOCK_DATA(theLutData.colorLut);
				skipCombi = TRUE;
				theLutData.colorLutInDim = kNumOfLab_XYZchannels;
				theLutData.colorLutOutDim = kNumOfLab_XYZchannels;
			} else
			{
				/*
				  	NO pcsConversion: we are dealing with a profile
				  */
				theCombiData.doCreateGamutLut = createGamutLut && (profLoop == newProfileSet->count - 1);
				theCombiData.usePreviewTag 	  = (UINT8)newProfileSet->prof[profLoop].usePreviewTag;				
				
				/*----------------------------------------------------------------------------------------------
				   get data out of the profile
				  ----------------------------------------------------------------------------------------------*/

				if( bIsLabConnection & 1 ){
					if ( theCombiData.maxProfileCount > 0 ){
						theCombiData.maxProfileCount = 0;
						SavedoCreate_16bit_XLut = theCombiData.doCreate_16bit_XLut;
						theCombiData.doCreate_16bit_XLut = TRUE;
					}
				}
				if( bIsLabConnection & 2 ){
					SavedoCreate_16bit_ALut = theCombiData.doCreate_16bit_ALut;
					theCombiData.doCreate_16bit_ALut = TRUE;
				}
				err = ExtractAllLuts (&theLutData, &theCombiData);
				if( newProfileSet->count == 1 ){
					gridPointsCube = theLutData.colorLutGridPoints;
				}

				if( bIsLabConnection & 1 ){
					theCombiData.maxProfileCount = newProfileSet->count-1;
					if ( theCombiData.maxProfileCount > 0 ){
						theCombiData.doCreate_16bit_XLut = SavedoCreate_16bit_XLut;
					}
				}
				if( bIsLabConnection & 2 ){
					theCombiData.doCreate_16bit_ALut = SavedoCreate_16bit_ALut;
				}
				
				if (err)
					goto CleanupAndExit;
				if ( (theLutData.colorLutInDim == 0) || (theLutData.colorLutOutDim == 0))
				{
					err = cmProfileError;
					goto CleanupAndExit;
				}
			}
#ifdef DEBUG_OUTPUT
			if ( DebugCheck(kThisFile, kDebugEXASizeInfo) )
			{
				if (theLutData.inputLut)
					DebugPrint("  Elut = %6d\n", (theLutData.inputLutEntryCount*theLutData.colorLutInDim*(theLutData.inputLutWordSize>8?2:1)));
				if (theLutData.colorLut)
					DebugPrint("  Xlut colorLutGridPoints = %6d\n       colorLutInDim      = %6d\n       colorLutOutDim     = %6d\n       colorLutWordSize   = %6d\n",
								theLutData.colorLutGridPoints,theLutData.colorLutInDim,theLutData.colorLutOutDim,theLutData.colorLutWordSize);
				if (theLutData.outputLut)
					DebugPrint("  Alut = %6d ", (theLutData.outputLutEntryCount*theLutData.colorLutOutDim*(theLutData.outputLutWordSize>8?2:1)));
				DebugPrint("\n");
			}
#endif
			if (theLutData.matrixMFT)
				skipCombi = FALSE;
			/*----------------------------------------------------------------------------------------------
			   save first Elut...
			  ----------------------------------------------------------------------------------------------*/
			if (doSaveElut)	
			{
				if ( skipCombi )
					savedGridPoints = theLutData.colorLutGridPoints;
				else
				{
					if (theLutData.colorLutInDim == 1)
					{
						theCubeSize = 255 ;
					}
					/*------------------------create and initialize cube*/
#ifdef DoLabSpecial
					if( modelingData->firstColorSpace == icSigLabData || modelingData->firstColorSpace == icSigLuvData ){
						err = MakeSpecialCube16(theLutData.colorLutInDim, &theCubeSize, &inputBuffer, &gridBits, &theExtraSize );
					}
					else
#endif
					err = MakeCube16(theLutData.colorLutInDim, &theCubeSize, &inputBuffer, &gridBits, &theExtraSize);
#ifdef DEBUG_OUTPUT
					if ( DebugCheck(kThisFile, kDebugMiscInfo) )
						DebugPrint("  MakeCube16 -> '%d' bits    cubeSize = %d\n",gridBits, theCubeSize);
#endif
					if (err)
						goto CleanupAndExit;
					theCubePixelCount = theCubeSize / theLutData.colorLutInDim;
					numOfElutsCube = theLutData.colorLutInDim;
					gridPointsCube = 1<<gridBits;
					savedGridPoints = gridPointsCube;
				}
				
				/*theSize = GETDATASIZE(theLutData.inputLut);	*/			/* save final ELUT */
				theSize = theLutData.inputLutEntryCount * theLutData.colorLutInDim;				/* save final ELUT */
				if ( theLutData.inputLutWordSize > 8 )
					theSize *= 2;
				
				if( bIsLabConnection & 1 ){
					
					finalLutData->inputLut = ALLOC_DATA(theSize+2, &aOSerr);
					err = aOSerr;
					if (err)
						goto CleanupAndExit;
					
					/*------------------------------------------------------------------------------------------ create linear elut*/
					theElutSize = theSize / theLutData.colorLutInDim;
					LOCK_DATA(finalLutData->inputLut);
					if( theCombiData.doCreate_16bit_ELut || theCombiData.doCreate_16bit_Combi){
						CreateLinearElut16 ( (Ptr)DATA_2_PTR(finalLutData->inputLut), theElutSize/ sizeof (UINT16), gridPointsCube, 0 );
						finalLutData->inputLutWordSize = VAL_USED_BITS;
					}
					else{
						CreateLinearElut ( (Ptr)DATA_2_PTR(finalLutData->inputLut), theElutSize/ sizeof (UINT16), gridPointsCube, 0 );
						finalLutData->inputLutWordSize = bit_breite_elut;
					}
					for (loop = 0; loop < theLutData.colorLutInDim; loop++)
						BlockMoveData(DATA_2_PTR(finalLutData->inputLut), (Ptr)DATA_2_PTR(finalLutData->inputLut) + loop * theElutSize, theElutSize);
					finalLutData->inputLutEntryCount = theElutSize/sizeof(UINT16);
					UNLOCK_DATA(finalLutData->inputLut);
					finalLutData->colorLutInDim		 = theLutData.colorLutInDim;
					bIsLabConnection &= ~1;
				}
				else{
					finalLutData->inputLutWordSize	 = theLutData.inputLutWordSize;
					finalLutData->inputLut 			 = theLutData.inputLut;
					finalLutData->inputLutEntryCount = theLutData.inputLutEntryCount;
					finalLutData->colorLutInDim		 = theLutData.colorLutInDim;
					
					theLutData.inputLut = ALLOC_DATA(theSize+2, &aOSerr);
					err = aOSerr;
					if (err)
						goto CleanupAndExit;
					
					/*------------------------------------------------------------------------------------------ create linear elut*/
					theElutSize = theSize / theLutData.colorLutInDim;
					LOCK_DATA(theLutData.inputLut);
					CreateLinearElut16 ( (Ptr)DATA_2_PTR(theLutData.inputLut), theElutSize/ sizeof (UINT16), theLutData.colorLutGridPoints, 0);
					for (loop = 0; loop < theLutData.colorLutInDim; loop++)
						BlockMoveData(DATA_2_PTR(theLutData.inputLut), (Ptr)DATA_2_PTR(theLutData.inputLut) + loop * theElutSize, theElutSize);
					theLutData.inputLutEntryCount = theElutSize/sizeof(UINT16);
					theLutData.inputLutWordSize = VAL_USED_BITS;
					UNLOCK_DATA(theLutData.inputLut);
				}
				doSaveElut = FALSE;
#ifdef DoLabSpecial
				if( (modelingData->firstColorSpace == icSigLabData || modelingData->firstColorSpace == icSigLuvData) ){
					LOCK_DATA(finalLutData->inputLut);
					wordPtr = (UINT16 *)DATA_2_PTR( finalLutData->inputLut );
					aFac = (((1<<15)*((UINT32)finalLutData->inputLutEntryCount-1)*(UINT32)gridPointsCube + finalLutData->inputLutEntryCount/2)/
							(UINT32)finalLutData->inputLutEntryCount + gridPointsCube/2)/((UINT32)gridPointsCube-1);
					i = finalLutData->inputLutEntryCount/2 - 1;
					for( aUINT16 = 0; aUINT16 < (UINT16)finalLutData->colorLutInDim; aUINT16++){
						for( loop = 0; loop <= (SINT32)(i+1); loop++){
							*wordPtr++ = (UINT16)((*wordPtr * aFac + (1<<(15-1)) )>>15);
						}

						for( loop = 1; loop <= (SINT32)i; loop++){
							*wordPtr++ = (UINT16)((*wordPtr * ((aFac *( i - loop ) + (1<<15) * loop + i/2)/i) + (1<<(15-1)) )>>15);
						}
					}
					UNLOCK_DATA(finalLutData->inputLut);
				}	
#endif			
			}
			
			/*----------------------------------------------------------------------------------------------
			   save last Alut...
			  ----------------------------------------------------------------------------------------------*/
			if (profLoop == newProfileSet->count - 1)
			{
				/*theSize = GETDATASIZE(theLutData.outputLut);*/
				theSize = theLutData.outputLutEntryCount * theLutData.colorLutOutDim;				/* save final ALUT */
				if ( theLutData.outputLutWordSize > 8 )
					theSize *= 2;
				if( bIsLabConnection & 2 ){
					SaveoutputLut = theLutData.outputLut;
					SaveoutputLutEntryCount = theLutData.outputLutEntryCount;
					SaveoutputLutWordSize = theLutData.outputLutWordSize;
				}
				else{
					finalLutData->outputLut = theLutData.outputLut;
					finalLutData->outputLutEntryCount = theLutData.outputLutEntryCount;
					finalLutData->outputLutWordSize = theLutData.outputLutWordSize;
				}
				finalLutData->colorLutOutDim = theLutData.colorLutOutDim;

				theAlutSize = (1<<adr_breite_alut);
                if (theCombiData.doCreate_16bit_ALut || theCombiData.doCreate_16bit_Combi)/* UWE 9.2.96*/
				{
					theSize = sizeof(UINT16);;
					theLutData.outputLut = ALLOC_DATA(theLutData.colorLutOutDim * theAlutSize * theSize+theSize, &aOSerr);
					err = aOSerr;
					if (err)
						goto CleanupAndExit;
					LOCK_DATA(theLutData.outputLut);
					CreateLinearAlut16 ( (UINT16 *)DATA_2_PTR(theLutData.outputLut), theAlutSize);
					for (loop = 1; loop < theLutData.colorLutOutDim; loop++)
						BlockMoveData(DATA_2_PTR(theLutData.outputLut), (Ptr)DATA_2_PTR(theLutData.outputLut) + loop * theAlutSize * sizeof(UINT16), theAlutSize * sizeof(UINT16));
					theLutData.outputLutEntryCount = (SINT16)theAlutSize;
					theLutData.outputLutWordSize = VAL_USED_BITS;
					UNLOCK_DATA(theLutData.outputLut);
				}
				else
				{
					theSize = sizeof(UINT8);;
					theLutData.outputLut = ALLOC_DATA(theLutData.colorLutOutDim * theAlutSize * theSize+theSize, &aOSerr);
					err = aOSerr;
					if (err)
						goto CleanupAndExit;
					LOCK_DATA(theLutData.outputLut);

					CreateLinearAlut( (UINT8*)DATA_2_PTR(theLutData.outputLut), theAlutSize );
					for (loop = 1; loop < theLutData.colorLutOutDim; loop++)
						BlockMoveData(DATA_2_PTR(theLutData.outputLut), (Ptr)DATA_2_PTR(theLutData.outputLut) + loop * theAlutSize, theAlutSize);
					theLutData.outputLutEntryCount = theAlutSize;
					theLutData.outputLutWordSize = bit_breite_alut;
					UNLOCK_DATA(theLutData.outputLut);
					theBufferByteCount = 1;			/* last should be Byte ALUT*/
				}
				if( bIsLabConnection & 2 ){
					bIsLabConnection &= ~2;
					finalLutData->outputLut = theLutData.outputLut;
					finalLutData->outputLutEntryCount = theLutData.outputLutEntryCount;
					finalLutData->outputLutWordSize = theLutData.outputLutWordSize;
					theLutData.outputLut = SaveoutputLut;
					theLutData.outputLutEntryCount = SaveoutputLutEntryCount;
					theLutData.outputLutWordSize = SaveoutputLutWordSize;
				}
			}
			
			if (skipCombi)
			{
				/*=============================================================================================
				  	we have either only one profile -or- we did do a pcsConversion
				  =============================================================================================*/
				if (newProfileSet->count == 1){			/* one profile */
					theSize = 1;
					theExtraSize = 1;
					for( loop=0; loop<(theLutData.colorLutInDim-1); ++loop){	/* Extra Size for Interpolation */
						theSize *=theLutData.colorLutGridPoints ;
						theExtraSize += theSize;
					}
					theSize = 1;
					for( loop=0; loop<theLutData.colorLutInDim; ++loop){
						theSize *= theLutData.colorLutGridPoints;
					}
					theSize *= theLutData.colorLutOutDim;
#ifdef ALLOW_MMX
					theExtraSize++;	/* +1 for MMX 4 Byte access */
#endif
					theExtraSize *= theLutData.colorLutOutDim;
					inputBuffer = DISPOSE_IF_DATA(inputBuffer);
					if( theCombiData.doCreate_16bit_Combi ){
						inputBuffer = ALLOC_DATA( (theSize+theExtraSize) * 2, &aOSerr );
						err = aOSerr;
						if (err)
							goto CleanupAndExit;

						LOCK_DATA(theLutData.colorLut);
						LOCK_DATA(inputBuffer);
						wordPtr = (UINT16 *)DATA_2_PTR( inputBuffer );
						xlutPtr = (UINT8 *)DATA_2_PTR( theLutData.colorLut );
						if( theLutData.colorLutWordSize == 8 ){
							for( loop=0; loop<theSize; ++loop){
								aUINT16 = (UINT16)xlutPtr[loop];
								wordPtr[loop] = (aUINT16<<8) | aUINT16;
							}
						}
						else{
							BlockMoveData( xlutPtr, wordPtr, theSize * 2 );
						}
						UNLOCK_DATA(theLutData.colorLut);
						UNLOCK_DATA(inputBuffer);
						theLutData.colorLut = inputBuffer;
						theLutData.colorLutWordSize = 16;
						inputBuffer = 0;
					}
					else{
						inputBuffer = ALLOC_DATA( (theSize+theExtraSize), &aOSerr );
						err = aOSerr;
						if (err)
							goto CleanupAndExit;

						LOCK_DATA(theLutData.colorLut);
						LOCK_DATA(inputBuffer);
						wordPtr = (UINT16 *)DATA_2_PTR( inputBuffer );
						xlutPtr = (UINT8 *)DATA_2_PTR( theLutData.colorLut );
						BlockMoveData( xlutPtr, wordPtr, theSize );
						UNLOCK_DATA(theLutData.colorLut);
						UNLOCK_DATA(inputBuffer);
						DISPOSE_IF_DATA( theLutData.colorLut );
						theLutData.colorLut = inputBuffer;
						theLutData.colorLutWordSize = 8;
						inputBuffer = 0;
					}
/*					if( theCombiData.doCreate_16bit_Combi ){
						if( theLutData.colorLutWordSize == 8 ){
							theSize = 1;
							for( loop=0; loop<theLutData.colorLutInDim; ++loop){
								theSize *= theLutData.colorLutGridPoints;
							}
                    		theSize = theSize *  theLutData.colorLutOutDim;
							inputBuffer = DISPOSE_IF_DATA(inputBuffer);
							inputBuffer = ALLOC_DATA( theSize * 2+2, &aOSerr );
							err = aOSerr;
							if (err)
								goto CleanupAndExit;
							
							LOCK_DATA(theLutData.colorLut);
							LOCK_DATA(inputBuffer);
							wordPtr = DATA_2_PTR( inputBuffer );
							xlutPtr = DATA_2_PTR( theLutData.colorLut );
							for( loop=0; loop<theSize; ++loop){
								aUINT16 = (UINT16)xlutPtr[loop];
								wordPtr[loop] = (aUINT16<<8) | aUINT16;
							}
							UNLOCK_DATA(theLutData.colorLut);
							UNLOCK_DATA(inputBuffer);
							theLutData.colorLut = inputBuffer;
							theLutData.colorLutWordSize = 16;
							inputBuffer = 0;
						}
					}*/
				}
				inputBuffer = DISPOSE_IF_DATA(inputBuffer);
				inputBuffer = theLutData.colorLut;
				if (inputBuffer){
					theCubeSize = theCubePixelCount *  theLutData.colorLutInDim;
                    theCubeSize *= theLutData.colorLutOutDim;
				}
				theLutData.colorLut = 0;
				if ( (profLoop == newProfileSet->count - 1) && ( ! theCombiData.doCreate_16bit_ALut  && !theCombiData.doCreate_16bit_Combi) )/* UWE 9.2.96*/
					theBufferByteCount = 1;			/* last should be Byte ALUT*/

			} else
			{
				/*=============================================================================================
				  	create combi
				  =============================================================================================*/
				if (theLutData.matrixTRC)
				{
					/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
					   the profile contained a matrix/TRC:
					  +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
					LOCK_DATA(theLutData.inputLut);
					LOCK_DATA(theLutData.outputLut);
					LOCK_DATA(inputBuffer);
#ifdef DEBUG_OUTPUT
					if ( DebugCheck(kThisFile, kDebugMiscInfo) )
					{
						DebugPrint(" matrixTRC: calling DoMatrixForCube16  (gridPointsCube = %d   inputBuffer = %d)\n", gridPointsCube, theCubeSize);
						DebugPrint("  theLutData.colorLutGridPoints = %d\n", theLutData.colorLutGridPoints);
						DebugPrint("     %f    %f    %f\n     %f    %f    %f\n     %f    %f    %f\n",
								(*(Matrix2D *)theLutData.matrixTRC)[0][0],(*(Matrix2D *)theLutData.matrixTRC)[0][1],(*(Matrix2D *)theLutData.matrixTRC)[0][2],
								(*(Matrix2D *)theLutData.matrixTRC)[1][0],(*(Matrix2D *)theLutData.matrixTRC)[1][1],(*(Matrix2D *)theLutData.matrixTRC)[1][2],
								(*(Matrix2D *)theLutData.matrixTRC)[2][0],(*(Matrix2D *)theLutData.matrixTRC)[2][1],(*(Matrix2D *)theLutData.matrixTRC)[2][2]);
					}
					if ( createGamutLut )
					{
						if (DebugLutCheck(kDisplayEXAGamut) )
						{
							lutString[0] = sprintf((SINT8*)&lutString[1], "Gamut-E Lut #%d @ matrixTRC", profLoop);
							DoDisplayLutNew(lutString,&theLutData, 0);
							lutString[0] = sprintf((SINT8*)&lutString[1], "Gamut-A Lut #%d @ matrixTRC", profLoop);
							DoDisplayLutNew(lutString,&theLutData, 2);
						}
					} else if (DebugLutCheck(kDebugEXAReal))
					{
						
						lutString[0] = sprintf((SINT8*)&lutString[1], "E Lut #%d @ matrixTRC", profLoop);
						DoDisplayLutNew(lutString,&theLutData, 0);
						lutString[0] = sprintf((SINT8*)&lutString[1], "A Lut #%d @ matrixTRC", profLoop);
						DoDisplayLutNew(lutString,&theLutData, 2);
					}
#endif
#ifdef WRITE_LUTS
					if ( !createGamutLut )
					{
						fileString[0] = sprintf((SINT8*)&fileString[1], "E Lut #%d @ matrixTRC", profLoop);
						WriteLut2File( fileString,theLutData.inputLut, 'ELUT');
						fileString[0] = sprintf((SINT8*)&fileString[1], "A Lut #%d @ matrixTRC", profLoop);
						WriteLut2File( fileString,theLutData.outputLut, 'ALUT');
					}
#endif
					aDoMatrixForCubeStruct.aElutAdrSize 	= theLutData.inputLutEntryCount;
					aDoMatrixForCubeStruct.aElutAdrShift	= 0;
					aDoMatrixForCubeStruct.aElutWordSize 	= theLutData.inputLutWordSize;
					aDoMatrixForCubeStruct.separateEluts	= TRUE;
					aDoMatrixForCubeStruct.ein_lut	 		= (UINT16 *)DATA_2_PTR(theLutData.inputLut);
					aDoMatrixForCubeStruct.aAlutAdrSize 	= theLutData.outputLutEntryCount;
					aDoMatrixForCubeStruct.aAlutAdrShift 	= 0;
					aDoMatrixForCubeStruct.aAlutWordSize 	= theLutData.outputLutWordSize;
					aDoMatrixForCubeStruct.separateAluts	= TRUE;
					aDoMatrixForCubeStruct.aus_lut	 		= (UINT8 *)DATA_2_PTR(theLutData.outputLut);
					aDoMatrixForCubeStruct.theMatrix		= (Matrix2D	*)theLutData.matrixTRC;
					aDoMatrixForCubeStruct.aPointCount 		= theCubePixelCount;
					aDoMatrixForCubeStruct.gridPoints 		= gridPointsCube;
					aDoMatrixForCubeStruct.aBufferByteCount = theBufferByteCount;
					aDoMatrixForCubeStruct.theArr		 	= (UINT8 *)DATA_2_PTR(inputBuffer);
#ifdef DEBUG_OUTPUT
					ShowCube16( profLoop, "DoMatrixForCube16", createGamutLut, (UINT16 *)DATA_2_PTR(inputBuffer), gridPointsCube, numOfElutsCube, 3, VAL_USED_BITS );
#endif
#ifdef WRITE_LUTS
					if ( !createGamutLut )
					{
						fileString[0] = sprintf((SINT8*)&fileString[1], "DoMat4Cube #%d (TRC)", profLoop);
						WriteLut2File( fileString,inputBuffer, 'XLUT');
					}
#endif
					DoMatrixForCube16( &aDoMatrixForCubeStruct );
#ifdef DEBUG_OUTPUT
					ShowCube16( profLoop, "after DoMatrixForCube16", createGamutLut, (UINT16 *)DATA_2_PTR(inputBuffer), gridPointsCube, numOfElutsCube, 3, 8*theBufferByteCount );
#endif
#ifdef WRITE_LUTS
					if ( !createGamutLut )
					{
						fileString[0] = sprintf((SINT8*)&fileString[1], "after DoMat4Cube #%d (TRC)", profLoop);
						WriteLut2File( fileString,inputBuffer, 'XLUT');
					}
#endif
					
					UNLOCK_DATA(inputBuffer);
					UNLOCK_DATA(theLutData.inputLut);
					UNLOCK_DATA(theLutData.outputLut);
					/*SETDATASIZE(inputBuffer, theCubePixelCount * theLutData.colorLutOutDim * theBufferByteCount);*/
				} else
				{
					/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
					   the profile contained a mft
					  +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
					
					/*----------------------------------------------------------------------------------------- absolute colorimetry*/
					if ( theCombiData.amIPCS && newProfileSet->prof[profLoop].renderingIntent == icAbsoluteColorimetric )
					{
						/*for concate absolute, make sure this is not done when preview tag exists)*/
						if (!newProfileSet->prof[profLoop].usePreviewTag) {
							LOCK_DATA(inputBuffer);
							err = DoAbsoluteShiftForPCS_Cube16( (UINT16*)DATA_2_PTR(inputBuffer), theCubePixelCount,
														   theCombiData.theProfile, (Boolean)(theCombiData.profileConnectionSpace != icSigLabData), kAbsShiftBeforeDoNDim );
							UNLOCK_DATA(inputBuffer);
							if (err)
								goto CleanupAndExit;
						}
					}
					if (theLutData.matrixMFT)
					{
						/*-----------------------------------------------------------------------------------------
						   the profile contained a mft AND a matrix:
						  -----------------------------------------------------------------------------------------*/
						/*------------------------------------ pcs is Lab -> handle direct (without Elut and Alut) */
						LOCK_DATA(inputBuffer);
#ifdef DEBUG_OUTPUT
						if ( DebugCheck(kThisFile, kDebugMiscInfo) )
						{
							DebugPrint(" matrixMFT: calling DoOnlyMatrixForCube16\n");
							DebugPrint("     %f    %f    %f\n     %f    %f    %f\n     %f    %f    %f\n",
								(*(Matrix2D *)theLutData.matrixMFT)[0][0],(*(Matrix2D *)theLutData.matrixMFT)[0][1],(*(Matrix2D *)theLutData.matrixMFT)[0][2],
								(*(Matrix2D *)theLutData.matrixMFT)[1][0],(*(Matrix2D *)theLutData.matrixMFT)[1][1],(*(Matrix2D *)theLutData.matrixMFT)[1][2],
								(*(Matrix2D *)theLutData.matrixMFT)[2][0],(*(Matrix2D *)theLutData.matrixMFT)[2][1],(*(Matrix2D *)theLutData.matrixMFT)[2][2]);
						}
#endif
#ifdef DEBUG_OUTPUT
						ShowCube16( profLoop, "DoOnlyMatrixForCube16 (mft)", createGamutLut, (UINT16 *)DATA_2_PTR(inputBuffer), gridPointsCube, numOfElutsCube, kNumOfLab_XYZchannels, VAL_USED_BITS );
#endif
#ifdef WRITE_LUTS
						if ( !createGamutLut )
						{
							fileString[0] = sprintf((SINT8*)&fileString[1], "DoOnlyMat4Cube #%d (mft)", profLoop);
							WriteLut2File( fileString,inputBuffer, 'XLUT');
						}
#endif
						DoOnlyMatrixForCube16( (Matrix2D	*)theLutData.matrixMFT, (Ptr)DATA_2_PTR(inputBuffer), theCubePixelCount, gridPointsCube );
#ifdef DEBUG_OUTPUT
						ShowCube16( profLoop, "after DoOnlyMatrixForCube16 (mft)", createGamutLut, (UINT16 *)DATA_2_PTR(inputBuffer), gridPointsCube, numOfElutsCube, kNumOfLab_XYZchannels, VAL_USED_BITS );
#endif
#ifdef WRITE_LUTS
						if ( !createGamutLut )
						{
							fileString[0] = sprintf((SINT8*)&fileString[1], "DoOnlyMat4Cube #%d (mft)", profLoop);
							WriteLut2File( fileString,inputBuffer, 'XLUT');
						}
#endif
						
						UNLOCK_DATA(inputBuffer);
					}
					if (theLutData.colorLutInDim >= theLutData.colorLutOutDim && theBufferByteCount == 2 )
					{
						outputBuffer = inputBuffer;
						useOutputBuffer = FALSE;
					} else
					{
						outputBuffer = ALLOC_DATA( (theCubePixelCount + theExtraSize ) * theLutData.colorLutOutDim * theBufferByteCount, &aOSerr);
						err = aOSerr;
						if (err)
							goto CleanupAndExit;
						useOutputBuffer = TRUE;
					}
					LOCK_DATA(inputBuffer);
					LOCK_DATA(outputBuffer);
					LOCK_DATA(theLutData.inputLut);
					LOCK_DATA(theLutData.colorLut);
					LOCK_DATA(theLutData.outputLut);
#ifdef DEBUG_OUTPUT
					if ( createGamutLut )
					{
						if ( DebugLutCheck(kDisplayEXAGamut) )
						{
							lutString[0] = sprintf((SINT8*)&lutString[1], "Gamut-E Lut #%d @ DoNDim", profLoop);
							DoDisplayLutNew(lutString,&theLutData, 0);
							lutString[0] = sprintf((SINT8*)&lutString[1], "Gamut-A Lut #%d @ DoNDim", profLoop);
							DoDisplayLutNew(lutString,&theLutData, 2);
							lutString[0] = sprintf((SINT8*)&lutString[1], "Gamut-X Lut #%d @ DoNDim", profLoop);
							DoDisplayLutNew(lutString, &theLutData,1);
						}
					} else if (DebugLutCheck(kDebugEXAReal) )
					{
							lutString[0] = sprintf((SINT8*)&lutString[1], "E Lut #%d @ DoNDim", profLoop);
							DoDisplayLutNew(lutString,&theLutData, 0);
							lutString[0] = sprintf((SINT8*)&lutString[1], "A Lut #%d @ DoNDim", profLoop);
							DoDisplayLutNew(lutString,&theLutData, 2);
							lutString[0] = sprintf((SINT8*)&lutString[1], "X Lut #%d @ DoNDim", profLoop);
							DoDisplayLutNew(lutString, &theLutData,1);
					}
#endif
					
#ifdef WRITE_LUTS
					if ( !createGamutLut )
					{
						fileString[0] = sprintf((SINT8*)&fileString[1], "E Lut #%d @ DoNDim", profLoop);
						WriteLut2File( fileString,theLutData.inputLut, 'ELUT');
						fileString[0] = sprintf((SINT8*)&fileString[1], "A Lut #%d @ DoNDim", profLoop);
						WriteLut2File( fileString,theLutData.outputLut, 'ALUT');
						fileString[0] = sprintf((SINT8*)&fileString[1], "X Lut #%d @ DoNDim", profLoop);
						WriteLut2File( fileString,theLutData.colorLut, 'XLUT');
					}
#endif

					calcParam.cmInputColorSpace		= cm16PerChannelPacking;
					calcParam.cmOutputColorSpace	= theBufferByteCount == 1 ? cm8PerChannelPacking : cm16PerChannelPacking;
					calcParam.cmPixelPerLine		= theCubePixelCount;
					calcParam.cmLineCount			= 1;
					calcParam.cmInputPixelOffset	= sizeof(SINT16)*theLutData.colorLutInDim;
					calcParam.cmOutputPixelOffset	= theBufferByteCount*theLutData.colorLutOutDim;
					calcParam.cmInputBytesPerLine	= theCubePixelCount*calcParam.cmInputPixelOffset;
					calcParam.cmOutputBytesPerLine	= theCubePixelCount*calcParam.cmOutputPixelOffset;
/*					calcParam.cmInputBytesPerPixel	= calcParam.cmInputPixelOffset;	*/
/*					calcParam.cmOutputBytesPerPixel	= calcParam.cmOutputPixelOffset;*/
					for (loop = 0; loop<theLutData.colorLutInDim; loop++)
						calcParam.inputData[loop]	= (Ptr)(DATA_2_PTR(inputBuffer)) + loop * sizeof(SINT16);
					for (loop = 0; loop<theLutData.colorLutOutDim; loop++)
						calcParam.outputData[loop]	= (Ptr)(DATA_2_PTR(outputBuffer)) + loop * theBufferByteCount;
					calcParam.clearMask				= FALSE;
					calcParam.copyAlpha				= FALSE;

#ifdef DEBUG_OUTPUT
					ShowCube16( profLoop, "DoNDim", createGamutLut, (UINT16 *)DATA_2_PTR(inputBuffer), gridPointsCube, numOfElutsCube, theLutData.colorLutInDim, VAL_USED_BITS );
#endif
#ifdef WRITE_LUTS
					if ( !createGamutLut )
					{
						fileString[0] = sprintf((SINT8*)&fileString[1], "DoNDim #%d", profLoop);
						WriteLut2File( fileString,inputBuffer, 'XLUT');
					}
#endif

					aDoNDimTableData = theLutData;
#if ! LUTS_ARE_PTR_BASED
					aDoNDimTableData.inputLut	= DATA_2_PTR(theLutData.inputLut);
					aDoNDimTableData.colorLut	= DATA_2_PTR(theLutData.colorLut);
					aDoNDimTableData.outputLut	= DATA_2_PTR(theLutData.outputLut);
#endif
					if (theLutData.colorLutWordSize == 18)		/*  */
					{
						if ( theBufferByteCount == 1 )
							err = CalcNDim_Data16To8_Lut8(&calcParam, &aDoNDimTableData);
						else
							err = CalcNDim_Data16To16_Lut8(&calcParam, &aDoNDimTableData);
					} else
					{
						if ( theBufferByteCount == 1 )
							err = CalcNDim_Data16To8_Lut16(&calcParam, &aDoNDimTableData);
						else
							err = CalcNDim_Data16To16_Lut16(&calcParam, &aDoNDimTableData);
					}
					if (err)
						goto CleanupAndExit;
#ifdef DEBUG_OUTPUT
					ShowCube16( profLoop, "after DoNDim", createGamutLut, (UINT16 *)DATA_2_PTR(outputBuffer), gridPointsCube, numOfElutsCube, theLutData.colorLutOutDim, 8*theBufferByteCount );
#endif
#ifdef WRITE_LUTS
					if ( !createGamutLut )
					{
						fileString[0] = sprintf((SINT8*)&fileString[1], "after DoNDim #%d", profLoop);
						WriteLut2File( fileString,outputBuffer, 'XLUT');
					}
#endif
					UNLOCK_DATA(theLutData.inputLut);
					UNLOCK_DATA(theLutData.colorLut);
					UNLOCK_DATA(theLutData.outputLut);
					UNLOCK_DATA(inputBuffer);
					UNLOCK_DATA(outputBuffer);
					
					/*----------------------------------------------------------------------------------------- absolute colorimetry*/
					/*for concate absolute, make sure this IS done when preview tag exists)*/
					if (newProfileSet->prof[profLoop].usePreviewTag && newProfileSet->prof[profLoop].renderingIntent == icAbsoluteColorimetric) {
						LOCK_DATA(outputBuffer);
						err = DoAbsoluteShiftForPCS_Cube16( (UINT16*)DATA_2_PTR(outputBuffer), theCubePixelCount,
														   theCombiData.theProfile, (Boolean)(theCombiData.profileConnectionSpace != icSigLabData), kAbsShiftAfterDoNDim );
						UNLOCK_DATA(outputBuffer);
						if (err)
							goto CleanupAndExit;
					}
					if ( !theCombiData.amIPCS && newProfileSet->prof[profLoop].renderingIntent == icAbsoluteColorimetric )
					{
						LOCK_DATA(outputBuffer);
							err = DoAbsoluteShiftForPCS_Cube16( (UINT16*)DATA_2_PTR(outputBuffer), theCubePixelCount,
														   theCombiData.theProfile, (Boolean)(theCombiData.profileConnectionSpace != icSigLabData), kAbsShiftAfterDoNDim );
						UNLOCK_DATA(outputBuffer);
						if (err)
							goto CleanupAndExit;
					}

					if (useOutputBuffer)
					{
						inputBuffer = DISPOSE_IF_DATA(inputBuffer);
						inputBuffer = outputBuffer;
					} else
					{
						/*SETDATASIZE(inputBuffer, theCubePixelCount * theLutData.colorLutOutDim * theBufferByteCount);*/
						/*err = MemError();*/
                       	/*inputBuffer = ALLOC_DATA( theCubePixelCount * theLutData.colorLutOutDim * theBufferByteCount, &aOSerr );
						err = aOSerr;
						if (err)
							goto CleanupAndExit;*/
					}
					/*theCubeSize = GETDATASIZE(inputBuffer)/theBufferByteCount;*/
                   	theCubeSize = theCubePixelCount * theLutData.colorLutOutDim * theBufferByteCount;
					outputBuffer = nil;
				}
			}
		}
		skipCombi = FALSE;
		if( profHeader.deviceClass == icSigLinkClass ){
			theCombiData.dataColorSpace = profHeader.pcs;
			theCombiData.amIPCS = TRUE;
		}

		if (theCombiData.amIPCS && !pcsConversion)
			theCombiData.amIPCS = (theCombiData.usePreviewTag == TRUE) || (theCombiData.dataColorSpace == icSigLabData) || (theCombiData.dataColorSpace == icSigXYZData);
		else
			theCombiData.amIPCS = TRUE;
	}
#ifdef DEBUG_OUTPUT
	if ( DebugCheck(kThisFile, kDebugMiscInfo) )
		DebugPrint("  <>\n");
#endif
	theLutData.colorLut = DISPOSE_IF_DATA(theLutData.colorLut);
	theLutData.colorLut = inputBuffer;
	inputBuffer = nil;

	finalLutData->colorLut = theLutData.colorLut;	theLutData.colorLut = nil;
	finalLutData->colorLutGridPoints = savedGridPoints;
	if ( theBufferByteCount == 1 )
		finalLutData->colorLutWordSize = 8;
	else
		finalLutData->colorLutWordSize = 16;
	/* ---------------------------------------------------------------------------------
	    clean up
	   ---------------------------------------------------------------------------------*/
CleanupAndExit:
	inputBuffer			 = DISPOSE_IF_DATA(inputBuffer);
	outputBuffer		 = DISPOSE_IF_DATA(outputBuffer);
	theLutData.inputLut	 = DISPOSE_IF_DATA(theLutData.inputLut);
 	theLutData.outputLut = DISPOSE_IF_DATA(theLutData.outputLut);
	theLutData.colorLut	 = DISPOSE_IF_DATA(theLutData.colorLut);
 	theLutData.matrixMFT = DisposeIfPtr(theLutData.matrixMFT);
	theLutData.matrixTRC = DisposeIfPtr(theLutData.matrixTRC);

	LH_END_PROC("CreateCombi")
	return err;
}

/* 
	CMError
	PrepareCombiLUTs	( CMMModelHandle    	CMSession,
						  CMConcatProfileSet*	profileSet )
    */
/*CMError
PrepareCombiLUTsNew	( CMMModelPtr    		CMSession,
					  CMConcatProfileSet*	profileSet );*/
CMError
PrepareCombiLUTs	( CMMModelPtr    		CMSession,
					  CMConcatProfileSet*	profileSet )
{
	icHeader			 firstHeader;
	icHeader			 lastHeader;
	LHConcatProfileSet*	 newProfileSet = nil;
	CMError				 err = noErr;
	Boolean 			 needGamutCalc	= FALSE;
	CMLutParam			 theLutData;
 	UINT16		 		 count;
 	
	LH_START_PROC("PrepareCombiLUTs")
	/*err = PrepareCombiLUTsNew	( CMSession, profileSet );
	LH_END_PROC("PrepareCombiLUTs")
	return err;*/
	SetMem(&theLutData, sizeof(CMLutParam), 0);
	count = profileSet->count;

	/* ------------------------------------------------------------------------------------------------*/
	err = CMGetProfileHeader(profileSet->profileSet[0], (CMCoreProfileHeader *)&firstHeader);
	if (err)
		goto CleanupAndExit;
	(CMSession)->firstColorSpace = firstHeader.colorSpace;
	
	err = CMGetProfileHeader(profileSet->profileSet[count-1], (CMCoreProfileHeader *)&lastHeader);
	if (err)
		goto CleanupAndExit;
	(CMSession)->lastColorSpace = lastHeader.colorSpace;
	if( lastHeader.deviceClass == icSigLinkClass )
		(CMSession)->lastColorSpace = lastHeader.pcs;
	else
		(CMSession)->lastColorSpace = lastHeader.colorSpace;
#ifdef ALLOW_DEVICE_LINK
	if( count > 1 && lastHeader.deviceClass == icSigLinkClass ){
		(CMSession)->appendDeviceLink = TRUE;
		profileSet->count--;
	}
	else{
		(CMSession)->appendDeviceLink = FALSE;
	}
#endif
	/* ------------------------------------------------------------------------------------------------
		right now we create the gamut-luts always if the last profile is a display -or- an output profile
		(NO gamut-luts are created for a CMMNewLinkProfile-call).
	   ------------------------------------------------------------------------------------------------*/
	if  ( (lastHeader.deviceClass == icSigOutputClass) ||  (lastHeader.deviceClass == icSigDisplayClass) )
		needGamutCalc = TRUE;

	if ( (CMSession)->currentCall == kCMMNewLinkProfile )
		needGamutCalc = FALSE;
		
	/* ------------------------------------------------------------------------------------------------
		we could speed up the init-phase if we would use a flag in the first profile to indicate whether
		or not the gamut-luts should be created:
	   ------------------------------------------------------------------------------------------------*/
	if ( (firstHeader.flags & kCreateGamutLutMask) == kCreateGamutLutMask)
		needGamutCalc = FALSE;

#ifdef RenderInt
	if( CMSession-> dwFlags != 0xffffffff ){
		if( CMSession->dwFlags & kCreateGamutLutMask ){
			needGamutCalc = FALSE;
		}
		else if( lastHeader.deviceClass == icSigOutputClass ||
				 lastHeader.deviceClass == icSigDisplayClass )
			needGamutCalc = TRUE;
	}
#endif
	/* ------------------------------------------------------------------------------------------------*/
	err = Create_LH_ProfileSet( CMSession, profileSet, &newProfileSet);
	if (err)
		goto CleanupAndExit;
	
#ifdef DEBUG_OUTPUT
	if ( ! needGamutCalc && DebugCheck(kThisFile, kDebugMiscInfo) )
    	DebugPrint("\n  <=================== Gamut Combi is not created =================>\n\n");
#endif
    /*=============================================================================================*/
    /* Create Gamut Combi*/
    /*=============================================================================================*/
	if( CMSession->hasNamedColorProf == NamedColorProfileOnly ||
		CMSession->hasNamedColorProf == NamedColorProfileAtEnd )needGamutCalc = FALSE;
    if (needGamutCalc)
    {
#ifdef DEBUG_OUTPUT
        if ( DebugCheck(kThisFile, kDebugMiscInfo) )
            DebugPrint("  <======================= Create Gamut Combi =====================>\n");
#endif
		if( lastHeader.pcs != icSigXYZData &&			/* since there's only a makeGamutForMonitor for xyz */
			lastHeader.deviceClass == icSigDisplayClass &&
			lastHeader.colorSpace == icSigRgbData ){	/* insert a Lab->XYZ conversion */
											
			newProfileSet->prof[newProfileSet->count] = newProfileSet->prof[newProfileSet->count-1];
			newProfileSet->prof[newProfileSet->count-1].pcsConversionMode = kDoLab2XYZ;		/* create Lab->XYZ */
			newProfileSet->prof[newProfileSet->count-1].profileSet = 0;
			newProfileSet->prof[newProfileSet->count-1].renderingIntent = 0;
			newProfileSet->count++;
		}
		err = CreateCombi(CMSession, profileSet, newProfileSet, &theLutData, kDoGamutLut );
		if( lastHeader.pcs != icSigXYZData &&			/* since there's only a makeGamutForMonitor for xyz */
			lastHeader.deviceClass == icSigDisplayClass &&
			lastHeader.colorSpace == icSigRgbData ){			/* remove a Lab->XYZ conversion */	

			newProfileSet->count--;
			newProfileSet->prof[newProfileSet->count-1] = newProfileSet->prof[newProfileSet->count];
		}
		/* continue even if err != noErr !!!!*/
#ifdef DEBUG_OUTPUT
		if ( err && DebugCheck(kThisFile, kDebugErrorInfo) )
			DebugPrint(" Error: PrepareCombiLUTs - kDoGamutLut: %d\n",err);
#endif
		
		if (err == noErr)
		{
#ifdef DEBUG_OUTPUT
			if (DebugLutCheck(kDisplayEXAGamut) )
			{
				LOCK_DATA(theLutData.inputLut);
				LOCK_DATA(theLutData.colorLut);
				LOCK_DATA(theLutData.outputLut);
				DoDisplayLutNew("\pFINAL GAMUT E Lut", &theLutData, 0);
				DoDisplayLutNew("\pFINAL GAMUT A Lut", &theLutData, 2);
				DoDisplayLutNew("\pFINAL GAMUT X Lut", &theLutData, 1);
				UNLOCK_DATA(theLutData.inputLut);
				UNLOCK_DATA(theLutData.colorLut);
				UNLOCK_DATA(theLutData.outputLut);
			}
			if ( DebugLutCheck( kDisplayGamut ) )
			{
				LOCK_DATA(theLutData.colorLut);
				if ((CMSession)->precision == cmBestMode)
					Show32by32by32GamutXLUT(DATA_2_PTR(theLutData.colorLut));
				else
					Show16by16by16GamutXLUT(DATA_2_PTR(theLutData.colorLut));
				UNLOCK_DATA(theLutData.colorLut);
			}
#endif
			if (theLutData.inputLut == nil)
			{
#ifdef DEBUG_OUTPUT
				if ( DebugCheck(kThisFile, kDebugErrorInfo) )
					DebugPrint(" ERROR: final Gamut Elut == nil\n");
#endif
			} else
			{
				(CMSession)->gamutLutParam.inputLut = theLutData.inputLut;												/* E lut */
				theLutData.inputLut = nil;	
			}
			
			if (theLutData.outputLut == nil)
			{
#ifdef DEBUG_OUTPUT
				if ( DebugCheck(kThisFile, kDebugErrorInfo) )
					DebugPrint(" ERROR: final Gamut Alut == nil\n");
#endif
			} else
			{
				(CMSession)->gamutLutParam.outputLut = theLutData.outputLut;											/* A lut */
				theLutData.outputLut = nil;	
			}
			
			if (theLutData.colorLut == nil)
			{
#ifdef DEBUG_OUTPUT
				if ( DebugCheck(kThisFile, kDebugErrorInfo) )
					DebugPrint(" ERROR: final Gamut Xlut == nil\n");
#endif
			} else
			{
				(CMSession)->gamutLutParam.colorLut = theLutData.colorLut;												/* X lut */
				theLutData.colorLut = nil;	
			}
			(CMSession)->gamutLutParam.colorLutInDim		= theLutData.colorLutInDim;
			(CMSession)->gamutLutParam.colorLutOutDim		= theLutData.colorLutOutDim;
			(CMSession)->gamutLutParam.colorLutGridPoints	= theLutData.colorLutGridPoints;
			(CMSession)->gamutLutParam.colorLutWordSize		= theLutData.colorLutWordSize;
			(CMSession)->gamutLutParam.inputLutWordSize		= theLutData.inputLutWordSize;
			(CMSession)->gamutLutParam.outputLutWordSize	= theLutData.outputLutWordSize;
			(CMSession)->gamutLutParam.inputLutEntryCount	= theLutData.inputLutEntryCount;
			(CMSession)->gamutLutParam.outputLutEntryCount	= theLutData.outputLutEntryCount;
		}
	}
	/*=============================================================================================
	   Create 'real' Combi
	  =============================================================================================*/
#ifdef DEBUG_OUTPUT
	if ( DebugCheck(kThisFile, kDebugMiscInfo) )
		DebugPrint("  <======================= Create real Combi ======================>\n");
#endif

	err = CreateCombi(CMSession, profileSet, newProfileSet, &theLutData, kDoDefaultLut );
	if (err)
		goto CleanupAndExit;
	
#ifdef DEBUG_OUTPUT
	if (DebugLutCheck(kDebugEXAReal) )
	{
		LOCK_DATA(theLutData.inputLut);
		LOCK_DATA(theLutData.colorLut);
		LOCK_DATA(theLutData.outputLut);
		DoDisplayLutNew("\pFINAL E Lut", &theLutData, 0);
		DoDisplayLutNew("\pFINAL A Lut", &theLutData, 2);
		DoDisplayLutNew("\pFINAL X Lut", &theLutData, 1);
		UNLOCK_DATA(theLutData.inputLut);
		UNLOCK_DATA(theLutData.colorLut);
		UNLOCK_DATA(theLutData.outputLut);
	}
#endif
#ifdef WRITE_LUTS
	LOCK_DATA(theLutData.inputLut);
	LOCK_DATA(theLutData.colorLut);
	LOCK_DATA(theLutData.outputLut);
	WriteLut2File( "\pFINAL E Lut",theLutData.inputLut, 'ELUT');
	WriteLut2File( "\pFINAL A Lut",theLutData.outputLut, 'ALUT');
	WriteLut2File( "\pFINAL X Lut",theLutData.colorLut, 'XLUT');
	UNLOCK_DATA(theLutData.inputLut);
	UNLOCK_DATA(theLutData.colorLut);
	UNLOCK_DATA(theLutData.outputLut);
#endif
	/*------------------------ save all results...*/
	if (theLutData.inputLut == nil)
	{
#ifdef DEBUG_OUTPUT
		if ( DebugCheck(kThisFile, kDebugErrorInfo) )
			DebugPrint(" ERROR: theLutData.inputLut == nil\n");
#endif
	} else
	{
		(CMSession)->lutParam.inputLut = theLutData.inputLut;												/* E lut */
		theLutData.inputLut = nil;	
	}
	
	if (theLutData.outputLut == nil)
	{
#ifdef DEBUG_OUTPUT
		if ( DebugCheck(kThisFile, kDebugErrorInfo) )
			DebugPrint(" ERROR: theLutData.outputLut == nil\n");
#endif
	} else
	{
		(CMSession)->lutParam.outputLut = theLutData.outputLut;											/* A lut */
		theLutData.outputLut = nil;	
	}
	
	if (theLutData.colorLut == nil)
	{
#ifdef DEBUG_OUTPUT
		if ( DebugCheck(kThisFile, kDebugErrorInfo) )
			DebugPrint(" ERROR: theLutData.colorLut == nil\n");
#endif
	} else
	{
		(CMSession)->lutParam.colorLut = theLutData.colorLut;												/* X lut */
		theLutData.colorLut = nil;	
	}
	
	(CMSession)->lutParam.colorLutInDim			= theLutData.colorLutInDim;
	(CMSession)->lutParam.colorLutOutDim		= theLutData.colorLutOutDim;
	(CMSession)->lutParam.colorLutGridPoints	= theLutData.colorLutGridPoints;
	(CMSession)->lutParam.colorLutWordSize		= theLutData.colorLutWordSize;
	(CMSession)->lutParam.inputLutWordSize		= theLutData.inputLutWordSize;
	(CMSession)->lutParam.outputLutWordSize		= theLutData.outputLutWordSize;
	(CMSession)->lutParam.inputLutEntryCount	= theLutData.inputLutEntryCount;
	(CMSession)->lutParam.outputLutEntryCount	= theLutData.outputLutEntryCount;
	
	/* ---------------------------------------------------------------------------------
	    clean up & exit
	   ---------------------------------------------------------------------------------*/
CleanupAndExit:
	newProfileSet = (LHConcatProfileSet *)DisposeIfPtr((Ptr)newProfileSet);
	theLutData.inputLut		= DISPOSE_IF_DATA(theLutData.inputLut);
	theLutData.outputLut	= DISPOSE_IF_DATA(theLutData.outputLut);
	theLutData.colorLut		= DISPOSE_IF_DATA(theLutData.colorLut);

	LH_END_PROC("PrepareCombiLUTs")
	return err;
}

CMError InitNamedColorProfileData( 	CMMModelPtr 		storage,
						  			CMProfileRef		aProf,
									long				pcs,
									long				*theDeviceCoords )
{
	CMError				err = noErr;
	UINT32				elementSize,count,nDeviceCoords,i;
	LUT_DATA_TYPE		profileLutPtr = 0;
	Ptr					cPtr;
	OSErr				aOSerr;

	*theDeviceCoords = 0;
	if( storage->hasNamedColorProf != NoNamedColorProfile ){ /* allow only 1 named profile */
		err = cmCantConcatenateError;
		goto CleanupAndExit;
	}
	err = CMGetProfileElement(aProf, icSigNamedColor2Tag, &elementSize, nil);
	if (err)
		goto CleanupAndExit;
	
  	profileLutPtr = ALLOC_DATA(elementSize, &aOSerr );
	err = aOSerr;
	if (err)
		goto CleanupAndExit;
	
	LOCK_DATA(profileLutPtr);
	err = CMGetProfileElement( aProf, icSigNamedColor2Tag, &elementSize, DATA_2_PTR(profileLutPtr) );
	if (err)
		goto CleanupAndExit;
#ifdef IntelMode
	SwapLongOffset( &((icNamedColor2Type*)profileLutPtr)->ncolor.count, 0, 4 );
	SwapLongOffset( &((icNamedColor2Type*)profileLutPtr)->ncolor.nDeviceCoords, 0, 4 );
#endif
	count = ((icNamedColor2Type*)profileLutPtr)->ncolor.count;
	nDeviceCoords = ((icNamedColor2Type*)profileLutPtr)->ncolor.nDeviceCoords;
	cPtr = &((icNamedColor2Type*)profileLutPtr)->ncolor.data[0];
	if( pcs == icSigXYZData ){
		for( i=0; i<count; i++){
			cPtr += 32;
#ifdef IntelMode
			SwapShortOffset( cPtr, 0, 3*2 );
			XYZ2Lab_forCube16((unsigned short *)cPtr, 1);
			cPtr += 3*2;
			SwapShortOffset( cPtr, 0, nDeviceCoords*2 );
			cPtr += nDeviceCoords*2;
#else
			XYZ2Lab_forCube16((unsigned short *)cPtr, 1);
			cPtr += 3*2 + nDeviceCoords*2;
#endif
		}
	}
#ifdef IntelMode
	else{
		for( i=0; i<count; i++){
			cPtr += 32;
			SwapShortOffset( cPtr, 0, 3*2 );
			cPtr += 3*2;
			SwapShortOffset( cPtr, 0, nDeviceCoords*2 );
			cPtr += nDeviceCoords*2;
		}
	}
#endif
	storage->theNamedColorTagData = profileLutPtr;
	UNLOCK_DATA(profileLutPtr);
	profileLutPtr = 0;
	*theDeviceCoords = nDeviceCoords;

CleanupAndExit:
	DISPOSE_IF_DATA(profileLutPtr);
	return err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\mscmm.w98\lh_core\runtime.c ===
/*
	File:		LHCMRuntime.c

	Contains:	

	Written by:	U. J. Krabbenhoeft

	Copyright:	 1993-1997 by Heidelberger Druckmaschinen AG, all rights reserved.

	Version:	
*/

#ifndef LHGeneralIncs_h
#include "General.h"
#endif

#ifndef LHCalcEngine_h
#include "CalcEng.h"
#endif

#ifndef LHCalcEngine1Dim_h
#include "CalcEng1.h"
#endif

#ifdef ALLOW_MMX
#ifndef LHCalcEngineFas_h
#include "CalcEnF.h"
#endif
#endif

#ifndef LHCalcNDim_h
#include "CalcNDim.h"
#endif

#ifndef LHCMRuntime_h
#include "Runtime.h"
#endif

#if ! realThing
#ifdef DEBUG_OUTPUT
#define kThisFile kCMMRuntimeID
extern Boolean gUSE_NDIM_FOR_BITMAP;
#endif
#endif

typedef struct ColorSpaceInfo
{
	SINT32	origSizeIn;
	SINT32	origSizeOut;
	SINT32	usedSizeIn;
	SINT32	usedSizeOut;
	void*	tempInBuffer;
	void*	tempOutBuffer;
	SINT32	processedLinesIn;
	SINT32	processedLinesOut;
	SINT32	inputPixelSize;
	SINT32	outputPixelSize;
	Boolean inPlace;
} ColorSpaceInfo;

/* -------------------------------------------------------------------------------------------------------------- */
#define kProgressTicks 	30			/* .5secs -> min. time between calls of progressproc */
#define kMaxTempBlock	300 * 1024	/* allow max. 300 kByte temp buffer */

/* -------------------------------------------------------------------------------------------------------------- */
typedef CMError  (*CalcProcPtr)(CMCalcParamPtr calcParamPtr,
							    CMLutParamPtr  lutParamPtr );

typedef CalcProcPtr 	 CalcProcUPP;
typedef CMError  (*CalcProc1DimPtr)(CMCalcParamPtr calcParamPtr,
									CMLutParamPtr  lutParamPtr, char OutDim );

typedef CalcProc1DimPtr 	 CalcProc1DimUPP;
#define NewCalcProc(userRoutine)		\
		((CalcProcUPP) (userRoutine))
#define NewCalcProc1Dim(userRoutine)		\
		((CalcProc1DimUPP) (userRoutine))
#define CallCalcProc(userRoutine, calcParamPtr, lutParamPtr)		\
		(*(userRoutine))( (calcParamPtr), (lutParamPtr) )

/*--------------------------------------------------------------------------------------------------------------
	local prototypes
  --------------------------------------------------------------------------------------------------------------*/

OSErr	Convert5To8				( Ptr		dataPtr5,
								  Ptr		dataPtr8,
								  SINT32	startLine,
								  SINT32	height,
								  SINT32	width,
								  SINT32	rowBytes5 );
OSErr	Convert8To5				( Ptr		dataPtr8,
								  Ptr		dataPtr5,
								  SINT32	startLine,
								  SINT32	height,
								  SINT32	width,
								  SINT32	rowBytes5 );
OSErr	Convert8To1				( Ptr		dataPtr8,
								  Ptr		dataPtr5,
								  SINT32	startLine,
								  SINT32	height,
								  SINT32	width,
								  SINT32	rowBytes5 );
OSErr	Convert16To10			( Ptr 		dataPtr16, 
								  Ptr		dataPtr10,
								  SINT32	startLine,
								  SINT32	height,
								  SINT32	width,
								  SINT32	rowBytes10 );	
OSErr	Convert10To16			( Ptr 		dataPtr10, 
								  Ptr		dataPtr16,
								  SINT32	startLine,
								  SINT32	height,
								  SINT32	width,
								  SINT32	rowBytes10 );		

CMError	FillLutParam 			( CMLutParamPtr		lutParam,
 								  CMMModelPtr		modelingData );
CMError	FillLutParamChk			( CMLutParamPtr		lutParam,
 								  CMMModelPtr		modelingData );

CMError	FillCalcParam			( CMCalcParamPtr	calcParam,
				 				  const CMBitmap *	bitMap, 
							 	  const CMBitmap *	matchedBitMap );

CMError	FillCalcParamCM			( CMCalcParamPtr	calcParam,
								  CMLutParamPtr		lutParam,
								  CMColor*			myColors,
								  SINT32				count );
CMError	CheckInputColorSpace 	( const CMBitmap*	bitMap,
								  CMCalcParamPtr	calcParam,
								  ColorSpaceInfo*	info,
								  OSType			inColorSpace,
					 			  long 				colorLutInDim );
CMError	CheckOutputColorSpace	( const CMBitmap*	bitMap,
								  CMCalcParamPtr	calcParam,
								  ColorSpaceInfo*	info,
								  OSType			outColorSpace,
								  long				colorLutOutDim );
CMError	SetOutputColorSpaceInplace	( CMCalcParamPtr	calcParam,
									  ColorSpaceInfo*	info,
									  OSType 			outColorSpace );
CMError	CheckOutputColorSpaceChk( const CMBitmap*	bitMap,
								  CMCalcParamPtr	calcParam,
								  ColorSpaceInfo*	info );

CMError	AllocBufferCheckCM		( CMCalcParamPtr	calcParam,
								  ColorSpaceInfo*	info );
								  
CalcProcPtr	FindLookupRoutine 	( const CMLutParam*		lutParam,
								  const ColorSpaceInfo*	info );

CalcProcPtr	FindCalcRoutine 	( const CMCalcParam*	calcParam,
								  const CMLutParam*		lutParam,
								  const ColorSpaceInfo*	info,
								  const Boolean			lookupOnly );


#ifdef __MWERKS__
#pragma mark ================  packing/unpacking  ================
#endif

/*--------------------------------------------------------------------------------------------------------------
	Convert5To8								convert cmRGB16Space to cmRGB24Space
  --------------------------------------------------------------------------------------------------------------*/
OSErr
Convert5To8	( Ptr		dataPtr5,
			  Ptr		dataPtr8,
			  SINT32	startLine,
			  SINT32	height,
			  SINT32	width,
			  SINT32	rowBytes5 )
{
	UINT16*		srcPtr16;
	UINT8*		destPtr8   = (UINT8*)dataPtr8;
	UINT8		data8;
	UINT16		three5Bits;
	SINT32		lineLoop;
	SINT32		pixelLoop;
	OSErr		err = noErr;
	
	LH_START_PROC("Convert5To8")
	for (lineLoop = startLine;  lineLoop < startLine + height; lineLoop++)
	{
		srcPtr16 = (UINT16*)(dataPtr5 + (lineLoop*rowBytes5));
		for (pixelLoop = 0; pixelLoop < width; pixelLoop++)
		{
			three5Bits = *srcPtr16++;
			
			data8 = (three5Bits >> 10) & 0x001F;	
			*destPtr8++ = (data8 << 3) | (data8 >>2);
			
			data8 = (three5Bits >> 5) & 0x001F;
			*destPtr8++ = (data8 << 3) | (data8 >>2);
	
			data8 = three5Bits & 0x001F;	
			*destPtr8++ = (data8 << 3) | (data8 >>2);
		}
	}
	LH_END_PROC("Convert5To8")
	return err;
}

/*--------------------------------------------------------------------------------------------------------------
	Convert8To5								convert cmRGB24Space to cmRGB16Space
  --------------------------------------------------------------------------------------------------------------*/
OSErr
Convert8To5	( Ptr		dataPtr8,
			  Ptr		dataPtr5,
			  SINT32	startLine,
			  SINT32	height,
			  SINT32	width,
			  SINT32	rowBytes5 )
{
	UINT16*	destPtr16;
	UINT8*	srcPtr8		= (UINT8*)dataPtr8;
	UINT16	three5Bits;
	SINT32	lineLoop;
	SINT32	pixelLoop;
	OSErr	err = noErr;
	
	LH_START_PROC("Convert8To5")
	for (lineLoop = startLine;  lineLoop < startLine + height; lineLoop++)
	{
		destPtr16 = (UINT16*)(dataPtr5 + (lineLoop*rowBytes5));
		for (pixelLoop = 0; pixelLoop < width; pixelLoop++)
		{
			three5Bits  = (((UINT16)*srcPtr8 & 0x00F8) << 7);	
			srcPtr8++;
			three5Bits |= (((UINT16)*srcPtr8 & 0x00F8) << 2);	
			srcPtr8++;
			three5Bits |= (((UINT16)*srcPtr8 & 0x00F8) >> 3);	
			srcPtr8++;

			*destPtr16++ = three5Bits;
		}
	}
	LH_END_PROC("Convert8To5")
	return err;
}
#ifdef PI_Application_h
OSErr	Convert565To8			( Ptr		dataPtr5,
								  Ptr		dataPtr8,
								  SINT32	startLine,
								  SINT32	height,
								  SINT32	width,
								  SINT32	rowBytes5 );
OSErr	Convert8To565			( Ptr		dataPtr8,
								  Ptr		dataPtr5,
								  SINT32	startLine,
								  SINT32	height,
								  SINT32	width,
								  SINT32	rowBytes5 );
/*--------------------------------------------------------------------------------------------------------------
	Convert565To8								convert cmRGB16_565Space to cmRGB24Space
  --------------------------------------------------------------------------------------------------------------*/
OSErr
Convert565To8( Ptr		dataPtr5,
			  Ptr		dataPtr8,
			  SINT32	startLine,
			  SINT32	height,
			  SINT32	width,
			  SINT32	rowBytes5 )
{
	UINT16*		srcPtr16;
	UINT8*		destPtr8   = (UINT8*)dataPtr8;
	UINT8		data8;
	UINT16		three5Bits;
	SINT32		lineLoop;
	SINT32		pixelLoop;
	OSErr		err = noErr;
	
	LH_START_PROC("Convert565To8")
	for (lineLoop = startLine;  lineLoop < startLine + height; lineLoop++)
	{
		srcPtr16 = (UINT16*)(dataPtr5 + (lineLoop*rowBytes5));
		for (pixelLoop = 0; pixelLoop < width; pixelLoop++)
		{
			three5Bits = *srcPtr16++;
			
			data8 = (three5Bits >> 11) & 0x001F;	
			*destPtr8++ = (data8 << 3) | (data8 >>2);
			
			data8 = (three5Bits >> 5) & 0x003F;
			*destPtr8++ = (data8 << 2) | (data8 >>4);
	
			data8 = three5Bits & 0x001F;	
			*destPtr8++ = (data8 << 3) | (data8 >>2);
		}
	}
	LH_END_PROC("Convert565To8")
	return err;
}

/*--------------------------------------------------------------------------------------------------------------
	Convert8To565								convert cmRGB24Space to cmRGB16_565Space
  --------------------------------------------------------------------------------------------------------------*/
OSErr
Convert8To565( Ptr		dataPtr8,
			  Ptr		dataPtr5,
			  SINT32	startLine,
			  SINT32	height,
			  SINT32	width,
			  SINT32	rowBytes5 )
{
	UINT16*	destPtr16;
	UINT8*	srcPtr8		= (UINT8*)dataPtr8;
	UINT16	three5Bits;
	SINT32	lineLoop;
	SINT32	pixelLoop;
	OSErr	err = noErr;
	
	LH_START_PROC("Convert8To565")
	for (lineLoop = startLine;  lineLoop < startLine + height; lineLoop++)
	{
		destPtr16 = (UINT16*)(dataPtr5 + (lineLoop*rowBytes5));
		for (pixelLoop = 0; pixelLoop < width; pixelLoop++)
		{
			three5Bits  = (((UINT16)*srcPtr8 & 0x00F8) << 8);	
			srcPtr8++;
			three5Bits |= (((UINT16)*srcPtr8 & 0x00FC) << 3);	
			srcPtr8++;
			three5Bits |= (((UINT16)*srcPtr8 & 0x00F8) >> 3);	
			srcPtr8++;

			*destPtr16++ = three5Bits;
		}
	}
	LH_END_PROC("Convert8To565")
	return err;
}
#endif
/*--------------------------------------------------------------------------------------------------------------
	Convert8To1								convert 8-bit to 1-bit (gamut result)
  --------------------------------------------------------------------------------------------------------------*/
OSErr
Convert8To1	( Ptr		dataPtr8,
			  Ptr		dataPtr1,
			  SINT32	startLine,
			  SINT32	height,
			  SINT32	width,
			  SINT32	rowBytes1 )
{
	UINT8*	destPtr8;
	UINT8*	srcPtr8  = (UINT8*)dataPtr8;
	UINT8	theWord  = 0;
	SINT32	lineLoop;
	SINT32	pixelLoop;
	OSErr	err = noErr;

	LH_START_PROC("Convert8To1")
	for (lineLoop = startLine;  lineLoop < startLine + height; lineLoop++)
	{
		destPtr8 = (UINT8*)(dataPtr1 + (lineLoop*rowBytes1));
		for ( pixelLoop = 0; pixelLoop < width; pixelLoop++ )
		{
			if (*srcPtr8)
				theWord |= (1<< (7- ( pixelLoop & 7)));
			if ( (pixelLoop & 7) == 7)
			{
				*destPtr8++ = theWord;
				theWord = 0;
			}
			srcPtr8 ++;
		}
		if (width % 8)
		{
			*destPtr8 = theWord | ( ((unsigned char)255 >> (width % 8)));
			theWord = 0;
		}
	}
	LH_END_PROC("Convert8To1")
	return err;
}

/* -----------------------------------------------------------------------
	Convert16To10
   ----------------------------------------------------------------------- */
OSErr
Convert16To10	( Ptr 		dataPtr16, 
				  Ptr		dataPtr10,
				  SINT32	startLine,
				  SINT32	height,
				  SINT32	width,
				  SINT32	rowBytes10 )
{
	UINT32		data16_1;
	UINT32		data16_2;
	UINT32		data16_3;
	UINT16*		srcPtr16 = (UINT16*)dataPtr16;
	UINT32*		destPtr32;
	SINT32		lineLoop;
	SINT32		pixelLoop;
	OSErr	err = noErr;

	LH_START_PROC("Convert16To10")
	for (lineLoop = startLine;  lineLoop < startLine + height; lineLoop++)
	{
		destPtr32 = (UINT32*)( dataPtr10 + (lineLoop * rowBytes10));
		for (pixelLoop = 0; pixelLoop < width; pixelLoop++)
		{
			data16_1 = ((UINT32)*srcPtr16++  & 0x0000FFC0) << 14;
			data16_2 = ((UINT32)*srcPtr16++  & 0x0000FFC0) <<  4;
			data16_3 = ((UINT32)*srcPtr16++  & 0x0000FFC0) >>  6;
			*destPtr32++ = data16_1 | data16_2 | data16_3;
		}
	}
	LH_END_PROC("Convert16To10")
	return err;
}

/* -----------------------------------------------------------------------
	Convert10To16
   ----------------------------------------------------------------------- */
OSErr
Convert10To16	( Ptr 		dataPtr10, 
				  Ptr		dataPtr16,
				  SINT32	startLine,
				  SINT32	height,
				  SINT32	width,
				  SINT32	rowBytes10 )		
{
	UINT16		data16;
	UINT32		data32;
	UINT32*		srcPtr32;
	UINT16*		destPtr16 = (UINT16*)dataPtr16;
	SINT32		lineLoop;
	SINT32		pixelLoop;
	OSErr	err = noErr;

	LH_START_PROC("Convert10To16")
	for (lineLoop = startLine;  lineLoop < startLine + height; lineLoop++)
	{
		srcPtr32 = (UINT32*)( dataPtr10 + (lineLoop * rowBytes10));
		for (pixelLoop = 0; pixelLoop < width; pixelLoop++)
		{
			data32 = *srcPtr32++;
			data16 = (UINT16)(data32>>14) & 0x0FFC0;
			*destPtr16++  = data16 | data16>>10;
			data16 = (UINT16)(data32>>4) & 0x0FFC0;
			*destPtr16++  = data16 | data16>>10;
			data16 = (UINT16)(data32<<6);
			*destPtr16++  = data16 | data16>>10;
		}
	}
	LH_END_PROC("Convert10To16")
	return err;
}

#ifdef __MWERKS__
#pragma mark ================  setup & checking  ================
#endif

/*--------------------------------------------------------------------------------------------------------------
	FillLutParam
  --------------------------------------------------------------------------------------------------------------*/
CMError
FillLutParam 	( CMLutParamPtr		lutParam,
 				  CMMModelPtr		modelingData )
{
	CMError err = noErr;

	LH_START_PROC("FillLutParam")
	*lutParam = (modelingData)->lutParam;
#if ! LUTS_ARE_PTR_BASED
	lutParam->inputLut		 	  = DATA_2_PTR(modelingData)->lutParam.inputLut;
	lutParam->outputLut			  = DATA_2_PTR(modelingData)->lutParam.outputLut;
	lutParam->colorLut		 	  = DATA_2_PTR(modelingData)->lutParam.colorLut;
#endif
	LH_END_PROC("FillLutParam")
	return err;
}

/*--------------------------------------------------------------------------------------------------------------
	FillLutParamChk
  --------------------------------------------------------------------------------------------------------------*/
CMError
FillLutParamChk 	( CMLutParamPtr		lutParam,
 					  CMMModelPtr		modelingData )
{
	CMError err = noErr;

	LH_START_PROC("FillLutParamChk")
	*lutParam = (modelingData)->gamutLutParam;
#if ! LUTS_ARE_PTR_BASED
	lutParam->inputLut		= DATA_2_PTR(modelingData)->gamutLutParam.inputLut;
	lutParam->outputLut		= DATA_2_PTR(modelingData)->gamutLutParam.outputLut;
	lutParam->colorLut		= DATA_2_PTR(modelingData)->gamutLutParam.colorLut;
#endif
	LH_END_PROC("FillLutParamChk")
	return err;
}

/*--------------------------------------------------------------------------------------------------------------
	FillCalcParam
  --------------------------------------------------------------------------------------------------------------*/
CMError
FillCalcParam	( CMCalcParamPtr	calcParam,
 				  const CMBitmap *	bitMap, 
			 	  const CMBitmap *	matchedBitMap )
{
	CMError err = noErr;

	LH_START_PROC("FillCalcParam")

	calcParam->cmInputColorSpace	= bitMap->space;
	calcParam->cmOutputColorSpace	= matchedBitMap->space;
	calcParam->cmPixelPerLine		= bitMap->width;
	calcParam->cmInputBytesPerLine  = bitMap->rowBytes;
	calcParam->cmOutputBytesPerLine = matchedBitMap->rowBytes;
	calcParam->cmLineCount			= bitMap->height;

	LH_END_PROC("FillCalcParam")
	return err;
}

/*--------------------------------------------------------------------------------------------------------------
	FillCalcParamCM
  --------------------------------------------------------------------------------------------------------------*/
CMError
FillCalcParamCM	( CMCalcParamPtr	calcParam,
				  CMLutParamPtr		lutParam,
				  CMColor*			myColors,
				  SINT32			count )
{
	SINT32	loop;
	CMError err = noErr;

	LH_START_PROC("FillCalcParamCM")
	
	calcParam->cmInputPixelOffset  = sizeof(CMColor);
	calcParam->cmOutputPixelOffset = sizeof(CMColor);

	/* ---------------------------------------------------------- handle input */
	switch (lutParam->colorLutInDim)
	{
		case 1:
			calcParam->cmInputColorSpace = cmGraySpace;	/* cmGraySpace is 16 bit */
			calcParam->inputData[0]	= (Ptr)myColors;
			break;
		case 3:
			calcParam->cmInputColorSpace = cmRGBSpace|cm16PerChannelPacking;
			calcParam->inputData[0]	= ((Ptr)myColors);
			calcParam->inputData[1]	= ((Ptr)myColors) + 2;
			calcParam->inputData[2]	= ((Ptr)myColors) + 4;
			break;
		case 4:
			calcParam->cmInputColorSpace = cmCMYKSpace|cm16PerChannelPacking;
			calcParam->inputData[0]	= ((Ptr)myColors);
			calcParam->inputData[1]	= ((Ptr)myColors) + 2;
			calcParam->inputData[2]	= ((Ptr)myColors) + 4;
			calcParam->inputData[3]	= ((Ptr)myColors) + 6;
			break;
		case 5:
		case 6:
		case 7:
		case 8:
#if ( CM_MAX_COLOR_CHANNELS == 15 )
		case 2:
		case 9:
		case 10:
		case 11:
		case 12:
		case 13:
		case 14:
		case 15:
#endif	
			calcParam->cmInputColorSpace = cmMCFiveSpace + lutParam->colorLutInDim-5;
			calcParam->cmInputColorSpace |= cm8PerChannelPacking;
			for (loop = 0; loop<lutParam->colorLutInDim; loop++)
				calcParam->inputData[loop]	= ((Ptr)myColors) + loop;
			break;
	}
	
	/* ---------------------------------------------------------- handle output */
	switch (lutParam->colorLutOutDim)
	{
		case 1:
			calcParam->cmOutputColorSpace = cmGraySpace;	/* cmGraySpace is 16 bit */
			calcParam->outputData[0]	= (Ptr)myColors;
			break;
		case 3:
			calcParam->cmOutputColorSpace = cmRGBSpace|cm16PerChannelPacking;
			calcParam->outputData[0]	= ((Ptr)myColors);
			calcParam->outputData[1]	= ((Ptr)myColors) + 2;
			calcParam->outputData[2]	= ((Ptr)myColors) + 4;
			break;
		case 4:
			calcParam->cmOutputColorSpace = cmCMYKSpace|cm16PerChannelPacking;
			calcParam->outputData[0]	= ((Ptr)myColors);
			calcParam->outputData[1]	= ((Ptr)myColors) + 2;
			calcParam->outputData[2]	= ((Ptr)myColors) + 4;
			calcParam->outputData[3]	= ((Ptr)myColors) + 6;
			break;
		case 5:
		case 6:
		case 7:
		case 8:
#if ( CM_MAX_COLOR_CHANNELS == 15 )
		case 2:
		case 9:
		case 10:
		case 11:
		case 12:
		case 13:
		case 14:
		case 15:
#endif
			calcParam->cmOutputColorSpace = cmMCFiveSpace + lutParam->colorLutOutDim - 5;
			calcParam->cmOutputColorSpace |= cm8PerChannelPacking;
			for (loop = 0; loop<lutParam->colorLutOutDim; loop++)
				calcParam->outputData[loop]	= ((Ptr)myColors) + loop;
			break;
	}
	calcParam->cmPixelPerLine		= count;
	calcParam->cmInputBytesPerLine  = count*sizeof(CMColor);
	calcParam->cmOutputBytesPerLine = count*sizeof(CMColor);
	calcParam->cmLineCount			= 1;
	LH_END_PROC("FillCalcParamCM")
	return err;
}

#ifdef PI_Application_h
#define ALLOW_16BIT_DATA
#else
#define Byte_Factor 1
#endif
	
CMError Do8To555Setup( CMCalcParamPtr calcParam, ColorSpaceInfo *info, SINT32 *theLinesAtOnce, long reverseOrder );
CMError Do8To555Setup( CMCalcParamPtr calcParam, ColorSpaceInfo *info, SINT32 *theLinesAtOnce, long reverseOrder )
{
	SINT32	newRowBytes,linesAtOnce,bufferSize;
	SINT16	iErr = noErr;

	*theLinesAtOnce = 0;
	newRowBytes = calcParam->cmPixelPerLine * 3;	/* TempBuffer -> cmRGB24Space */
	linesAtOnce = (kMaxTempBlock) / newRowBytes;
	if (linesAtOnce == 0)
		linesAtOnce = 1;
	else if (linesAtOnce > calcParam->cmLineCount)
		linesAtOnce = calcParam->cmLineCount;
		
	bufferSize = newRowBytes * linesAtOnce;
	info->processedLinesOut = 0;
	info->origSizeOut 		= 5;
	info->usedSizeOut 		= 8;
	info->tempOutBuffer 	= (void*)SmartNewPtr(bufferSize, &iErr);
	info->outputPixelSize = 16;
	if (iErr != noErr)
	{
		return iErr;
	}

	calcParam->cmLineCount			= linesAtOnce;
	calcParam->cmOutputColorSpace   = cmRGB24Space;
	calcParam->cmOutputBytesPerLine = newRowBytes;
	if( reverseOrder ){
		calcParam->outputData[2]		=  (Ptr)info->tempOutBuffer;
		calcParam->outputData[1]		= ((Ptr)info->tempOutBuffer)+1;
		calcParam->outputData[0]		= ((Ptr)info->tempOutBuffer)+2;
	}
	else{
		calcParam->outputData[0]		=  (Ptr)info->tempOutBuffer;
		calcParam->outputData[1]		= ((Ptr)info->tempOutBuffer)+1;
		calcParam->outputData[2]		= ((Ptr)info->tempOutBuffer)+2;
	}
	calcParam->cmOutputPixelOffset	= 3;
	*theLinesAtOnce = linesAtOnce;
	return 0;
}

CMError Do555To8Setup( CMCalcParamPtr calcParam, ColorSpaceInfo *info, SINT32 *theLinesAtOnce, long reverseOrder );
CMError Do555To8Setup( CMCalcParamPtr calcParam, ColorSpaceInfo *info, SINT32 *theLinesAtOnce, long reverseOrder )
{
	SINT32	newRowBytes,linesAtOnce,bufferSize;
	SINT16	iErr = noErr;

	*theLinesAtOnce = 0;
	newRowBytes = calcParam->cmPixelPerLine * 3;	/* TempBuffer -> cmRGB24Space */
	linesAtOnce = (kMaxTempBlock) / newRowBytes;
	if (linesAtOnce == 0)
		linesAtOnce = 1;
	else if (linesAtOnce > calcParam->cmLineCount)
		linesAtOnce = calcParam->cmLineCount;
		
	bufferSize = newRowBytes * linesAtOnce;
	info->processedLinesIn = 0;
	info->origSizeIn = 5;
	info->usedSizeIn = 8;
	info->tempInBuffer = (void*)SmartNewPtr(bufferSize, &iErr);
	info->inputPixelSize = 16;
	if (iErr != noErr)
	{
		return iErr;
	}
	calcParam->cmLineCount			= linesAtOnce;
	calcParam->cmInputColorSpace	= cmRGB24Space;
	calcParam->cmInputBytesPerLine	= newRowBytes;
	if( reverseOrder ){
		calcParam->inputData[2]	=  (Ptr)info->tempInBuffer;
		calcParam->inputData[1]	= ((Ptr)info->tempInBuffer)+1;
		calcParam->inputData[0]	= ((Ptr)info->tempInBuffer)+2;
	}
	else{
		calcParam->inputData[0]	=  (Ptr)info->tempInBuffer;
		calcParam->inputData[1]	= ((Ptr)info->tempInBuffer)+1;
		calcParam->inputData[2]	= ((Ptr)info->tempInBuffer)+2;
	}
	calcParam->cmInputPixelOffset = 3;
	*theLinesAtOnce = linesAtOnce;
	return noErr;
}
/*--------------------------------------------------------------------------------------------------------------
	CheckInputColorSpace
  --------------------------------------------------------------------------------------------------------------*/
CMError
CheckInputColorSpace (const CMBitmap*	bitMap,
					  CMCalcParamPtr	calcParam,
					  ColorSpaceInfo*	info,
					  OSType			inColorSpace,
					  long 				colorLutInDim )
{
	CMError err = noErr;
	SINT32	newRowBytes;
	SINT32	bufferSize;
	SINT32	linesAtOnce;
	SINT32	loop;
	SINT16	iErr = noErr;
	CMBitmapColorSpace	inputBitMapColorSpace = calcParam->cmInputColorSpace;
#ifdef ALLOW_16BIT_DATA
	UINT8 Byte_Factor=1;
#endif

	LH_START_PROC("CheckInputColorSpace")
	colorLutInDim=colorLutInDim;
	
#ifdef ALLOW_16BIT_DATA
	if( inputBitMapColorSpace & cm16PerChannelPacking && (inputBitMapColorSpace & 31) != cmGraySpace){
		Byte_Factor = 2;
		inputBitMapColorSpace &= ~cm16PerChannelPacking;
		inputBitMapColorSpace |= cm8PerChannelPacking;
	}
#endif
	info->origSizeIn = Byte_Factor*8;
	info->usedSizeIn = Byte_Factor*8;
	switch ( inputBitMapColorSpace )
	{
		case cmNoSpace:
		case cmRGBSpace:			/* "... bitmap never uses this constant alone..." */
		case cmHSVSpace:			/* "... bitmap never uses this constant alone..." */
		case cmHLSSpace:			/* "... bitmap never uses this constant alone..." */
		case cmYXYSpace:			/* "... bitmap never uses this constant alone..." */
		case cmXYZSpace:			/* "... bitmap never uses this constant alone..." */
		case cmLUVSpace:			/* "... bitmap never uses this constant alone..." */
		case cmLABSpace:			/* "... bitmap never uses this constant alone..." */
		case cmMCFiveSpace:			/* "... bitmap never uses this constant alone..." */
		case cmMCSixSpace:			/* "... bitmap never uses this constant alone..." */
		case cmMCSevenSpace:		/* "... bitmap never uses this constant alone..." */
		case cmMCEightSpace:		/* "... bitmap never uses this constant alone..." */
		case cmGamutResultSpace:	/* "... bitmap never uses this constant alone..." */
		case cmGamutResult1Space:	/* not as colorspace for CMMatchBitmap */
#ifdef PI_Application_h
		case cmYCCSpace:			/* "... bitmap never uses this constant alone..." */
		case cmBGRSpace:			/* "... bitmap never uses this constant alone..." */
#endif
			err = cmInvalidSrcMap;
			break;
		case cmCMYKSpace:			/* "... bitmap never uses this constant alone..." */
		case cmKYMCSpace:			/* "... bitmap never uses this constant alone..." */
			err = cmInvalidSrcMap;
#if ! realThing
			if ( (inColorSpace != icSigCmykData) && (inColorSpace != icSigCmyData) )
				err = cmInvalidColorSpace;
			else
			{
				err = noErr;
				calcParam->inputData[0]	= &bitMap->image[0];
				calcParam->inputData[1]	= &bitMap->image[2];
				calcParam->inputData[2]	= &bitMap->image[4];
				calcParam->inputData[3]	= &bitMap->image[6];
				calcParam->cmInputPixelOffset = 8;
				info->origSizeIn = 16;
				info->usedSizeIn = 16;
			}
#endif
			break;
		case cmGraySpace:
			if (inColorSpace != icSigGrayData)
				err = cmInvalidColorSpace;
			else 
			{
				calcParam->inputData[0]	= &bitMap->image[0];
				calcParam->cmInputPixelOffset	= 2;
				info->origSizeIn = 16;
				info->usedSizeIn = 16;
				info->inputPixelSize = 16;
			}
			break;
		case cmGrayASpace:
			if (inColorSpace != icSigGrayData)
				err = cmInvalidColorSpace;
			else
			{
				calcParam->inputData[0]	= &bitMap->image[0];
				calcParam->inputData[1]	= &bitMap->image[2];
				calcParam->cmInputPixelOffset	= 4;
				info->origSizeIn = 16;
				info->usedSizeIn = 16;
				info->inputPixelSize = 32;
			}
			break;
		case cmLAB24Space:
			if (inColorSpace != icSigLabData)
				err = cmInvalidColorSpace;
			else
			{
				calcParam->inputData[0]	= &bitMap->image[Byte_Factor*0];
				calcParam->inputData[1]	= &bitMap->image[Byte_Factor*1];
				calcParam->inputData[2]	= &bitMap->image[Byte_Factor*2];
				calcParam->cmInputPixelOffset   = Byte_Factor*3;
					info->inputPixelSize = Byte_Factor*24;
			}
			break;

		/* separated cmRGB24Space and cmRGB32Space to reflect the bitmap format definition changes. */
		case cmRGB24Space:
			if (inColorSpace != icSigRgbData)
				err = cmInvalidColorSpace;
			else
			{
				calcParam->inputData[0]	= &bitMap->image[Byte_Factor*0];
				calcParam->inputData[1]	= &bitMap->image[Byte_Factor*1];
				calcParam->inputData[2]	= &bitMap->image[Byte_Factor*2];
				calcParam->cmInputPixelOffset	= Byte_Factor*3;
				info->inputPixelSize = Byte_Factor*24;
			}
			break;
		case cmRGB32Space:
			if (inColorSpace != icSigRgbData)
				err = cmInvalidColorSpace;
			else
			{
				calcParam->inputData[0]	= &bitMap->image[Byte_Factor*1];
				calcParam->inputData[1]	= &bitMap->image[Byte_Factor*2];
				calcParam->inputData[2]	= &bitMap->image[Byte_Factor*3];
				calcParam->inputData[3]	= &bitMap->image[Byte_Factor*0];
				calcParam->cmInputPixelOffset = Byte_Factor*4;
					info->inputPixelSize = Byte_Factor*32;
			}
			break;

		case cmRGBASpace:
		case cmRGBA32Space:
			if (inColorSpace != icSigRgbData)
				err = cmInvalidColorSpace;
			else
			{
				calcParam->inputData[0]	= &bitMap->image[Byte_Factor*0];
				calcParam->inputData[1]	= &bitMap->image[Byte_Factor*1];
				calcParam->inputData[2]	= &bitMap->image[Byte_Factor*2];
				calcParam->inputData[3]	= &bitMap->image[Byte_Factor*3];
				calcParam->cmInputPixelOffset = Byte_Factor*4;
				info->inputPixelSize = Byte_Factor*32;
			}
			break;
			
#ifdef PI_Application_h

		case cmGraySpace|cm8PerChannelPacking:
			if (inColorSpace != icSigGrayData)
				err = cmInvalidColorSpace;
			else 
			{
				calcParam->inputData[0]	= &bitMap->image[0];
				calcParam->cmInputPixelOffset	= 1;
				info->origSizeIn = 8;
				info->usedSizeIn = 8;
				info->inputPixelSize = 8;
			}
			break;
		case cmGrayASpace|cm8PerChannelPacking:
			if (inColorSpace != icSigGrayData)
				err = cmInvalidColorSpace;
			else
			{
				calcParam->inputData[0]	= &bitMap->image[0];
				calcParam->inputData[1]	= &bitMap->image[1];
				calcParam->cmInputPixelOffset	= 2;
				info->origSizeIn = 8;
				info->usedSizeIn = 8;
				info->inputPixelSize = 16;
			}
			break;


		case cmBGR24Space:
			if (inColorSpace != icSigRgbData)
				err = cmInvalidColorSpace;
			else
			{
				calcParam->inputData[0]	= &bitMap->image[Byte_Factor*2];
				calcParam->inputData[1]	= &bitMap->image[Byte_Factor*1];
				calcParam->inputData[2]	= &bitMap->image[Byte_Factor*0];
				calcParam->cmInputPixelOffset	= Byte_Factor*3;
				info->inputPixelSize = Byte_Factor*24;
			}
			break;
		case cmBGR32Space:
			if (inColorSpace != icSigRgbData)
				err = cmInvalidColorSpace;
			else
			{
				calcParam->inputData[0]	= &bitMap->image[Byte_Factor*2];
				calcParam->inputData[1]	= &bitMap->image[Byte_Factor*1];
				calcParam->inputData[2]	= &bitMap->image[Byte_Factor*0];
				calcParam->inputData[3]	= &bitMap->image[Byte_Factor*3];
				calcParam->cmInputPixelOffset = Byte_Factor*4;
				info->inputPixelSize = Byte_Factor*32;
			}
			break;

		case cmYCC32Space:
			if (inColorSpace != icSigYCbCrData)
				err = cmInvalidColorSpace;
			else
			{
				calcParam->inputData[0]		= &bitMap->image[Byte_Factor*1];
				calcParam->inputData[1]		= &bitMap->image[Byte_Factor*2];
				calcParam->inputData[2]		= &bitMap->image[Byte_Factor*3];
				calcParam->inputData[3]		= &bitMap->image[Byte_Factor*0];
				calcParam->cmInputPixelOffset	= Byte_Factor*4;
				info->inputPixelSize = Byte_Factor*32;
			}
			break;
		case cmYCC24Space:
			if (inColorSpace != icSigYCbCrData)
				err = cmInvalidColorSpace;
			else
			{
				calcParam->inputData[0]	= &bitMap->image[Byte_Factor*0];
				calcParam->inputData[1]	= &bitMap->image[Byte_Factor*1];
				calcParam->inputData[2]	= &bitMap->image[Byte_Factor*2];
				calcParam->cmInputPixelOffset = Byte_Factor*3;
				info->inputPixelSize = Byte_Factor*24;
			}
			break;

		case cmYCCASpace:
		case cmYCCA32Space:
			if (inColorSpace != icSigYCbCrData)
				err = cmInvalidColorSpace;
			else
			{
				calcParam->inputData[0]	= &bitMap->image[Byte_Factor*0];
				calcParam->inputData[1]	= &bitMap->image[Byte_Factor*1];
				calcParam->inputData[2]	= &bitMap->image[Byte_Factor*2];
				calcParam->inputData[3]	= &bitMap->image[Byte_Factor*3];
				calcParam->cmInputPixelOffset = Byte_Factor*4;
				info->inputPixelSize = Byte_Factor*32;
			}
			break;
		case cmAYCC32Space:
			if (inColorSpace != icSigYCbCrData)
				err = cmInvalidColorSpace;
			else
			{
				calcParam->inputData[0]	= &bitMap->image[Byte_Factor*1];
				calcParam->inputData[1]	= &bitMap->image[Byte_Factor*2];
				calcParam->inputData[2]	= &bitMap->image[Byte_Factor*3];
				calcParam->inputData[3]	= &bitMap->image[Byte_Factor*0];
				calcParam->cmInputPixelOffset = Byte_Factor*4;
				info->inputPixelSize = Byte_Factor*32;
			}
			break;
		case cmLong8ColorPacking + cmLABSpace:
			if (inColorSpace != icSigLabData)
				err = cmInvalidColorSpace;
			else
			{
				calcParam->inputData[0]	= &bitMap->image[Byte_Factor*0];
				calcParam->inputData[1]	= &bitMap->image[Byte_Factor*1];
				calcParam->inputData[2]	= &bitMap->image[Byte_Factor*2];
				calcParam->inputData[3]	= &bitMap->image[Byte_Factor*3];
				calcParam->cmInputPixelOffset = Byte_Factor*4;
				info->inputPixelSize = Byte_Factor*32;
			}
			break;
		case cmLong8ColorPacking + cmXYZSpace:
			if (inColorSpace != icSigXYZData)
				err = cmInvalidColorSpace;
			else
			{
				calcParam->inputData[0]	= &bitMap->image[Byte_Factor*0];
				calcParam->inputData[1]	= &bitMap->image[Byte_Factor*1];
				calcParam->inputData[2]	= &bitMap->image[Byte_Factor*2];
				calcParam->inputData[3]	= &bitMap->image[Byte_Factor*3];
				calcParam->cmInputPixelOffset = Byte_Factor*4;
				info->inputPixelSize = Byte_Factor*32;
			}
			break;
		case cmLong8ColorPacking + cmYXYSpace:
			if (inColorSpace != icSigYxyData)
				err = cmInvalidColorSpace;
			else
			{
				calcParam->inputData[0]	= &bitMap->image[Byte_Factor*0];
				calcParam->inputData[1]	= &bitMap->image[Byte_Factor*1];
				calcParam->inputData[2]	= &bitMap->image[Byte_Factor*2];
				calcParam->inputData[3]	= &bitMap->image[Byte_Factor*3];
				calcParam->cmInputPixelOffset = Byte_Factor*4;
				info->inputPixelSize = Byte_Factor*32;
			}
			break;
		case cmGenericSpace + cm8PerChannelPacking:
			{
				for (loop = 0; loop< colorLutInDim; loop++)
					calcParam->inputData[loop]	= &bitMap->image[Byte_Factor*loop];
				calcParam->cmInputPixelOffset = Byte_Factor*colorLutInDim;
				info->inputPixelSize = Byte_Factor*colorLutInDim*8;
			}
			break;
		case cmGenericSpace + cmLong8ColorPacking:
			{
				for (loop = 0; loop< (colorLutInDim+1); loop++)
					calcParam->inputData[loop]	= &bitMap->image[Byte_Factor*loop];
				calcParam->cmInputPixelOffset = Byte_Factor*(colorLutInDim+1);
				info->inputPixelSize = Byte_Factor*(colorLutInDim+1)*8;
			}
			break;
		case cmCMY24Space:
			if ( inColorSpace != icSigCmyData )
				err = cmInvalidColorSpace;
			else
			{
				calcParam->inputData[0]	= &bitMap->image[Byte_Factor*0];
				calcParam->inputData[1]	= &bitMap->image[Byte_Factor*1];
				calcParam->inputData[2]	= &bitMap->image[Byte_Factor*2];
				calcParam->cmInputPixelOffset = Byte_Factor*3;
				info->inputPixelSize = Byte_Factor*24;
			}
			break;
#endif

		case cmCMYK32Space:
			if ( (inColorSpace != icSigCmykData) && (inColorSpace != icSigCmyData) )
				err = cmInvalidColorSpace;
			else
			{
				calcParam->inputData[0]	= &bitMap->image[Byte_Factor*0];
				calcParam->inputData[1]	= &bitMap->image[Byte_Factor*1];
				calcParam->inputData[2]	= &bitMap->image[Byte_Factor*2];
				calcParam->inputData[3]	= &bitMap->image[Byte_Factor*3];
				calcParam->cmInputPixelOffset = Byte_Factor*4;
				info->inputPixelSize = Byte_Factor*32;
			}
			break;
		case cmKYMC32Space:
			if ( (inColorSpace != icSigCmykData) && (inColorSpace != icSigCmyData) )
				err = cmInvalidColorSpace;
			else
			{
				calcParam->inputData[3]	= &bitMap->image[Byte_Factor*0];
				calcParam->inputData[2]	= &bitMap->image[Byte_Factor*1];
				calcParam->inputData[1]	= &bitMap->image[Byte_Factor*2];
				calcParam->inputData[0]	= &bitMap->image[Byte_Factor*3];
				calcParam->cmInputPixelOffset = Byte_Factor*4;
				info->inputPixelSize = Byte_Factor*32;
			}
			break;
		case cmARGB32Space:
			if (inColorSpace != icSigRgbData)
				err = cmInvalidColorSpace;
			else
			{
				calcParam->inputData[0]	= &bitMap->image[Byte_Factor*1];
				calcParam->inputData[1]	= &bitMap->image[Byte_Factor*2];
				calcParam->inputData[2]	= &bitMap->image[Byte_Factor*3];
				calcParam->inputData[3]	= &bitMap->image[Byte_Factor*0];
				calcParam->cmInputPixelOffset = Byte_Factor*4;
				info->inputPixelSize = Byte_Factor*32;
			}
			break;
		case cmMCFive8Space:
			if (inColorSpace != icSigMCH5Data)
				err = cmInvalidColorSpace;
			else
			{
				for (loop = 0; loop< 5; loop++)
					calcParam->inputData[loop]	= &bitMap->image[Byte_Factor*loop];
				calcParam->cmInputPixelOffset = Byte_Factor*5;
				info->inputPixelSize = Byte_Factor*40;
			}
			break;
		case cmMCSix8Space:
			if (inColorSpace != icSigMCH6Data)
				err = cmInvalidColorSpace;
			else
			{
				for (loop = 0; loop< 6; loop++)
					calcParam->inputData[loop]	= &bitMap->image[Byte_Factor*loop];
				calcParam->cmInputPixelOffset = Byte_Factor*6;
				info->inputPixelSize = Byte_Factor*48;
			}
			break;
		case cmMCSeven8Space:
			if (inColorSpace != icSigMCH7Data)
				err = cmInvalidColorSpace;
			else
			{
				for (loop = 0; loop< 7; loop++)
					calcParam->inputData[loop]	= &bitMap->image[Byte_Factor*loop];
				calcParam->cmInputPixelOffset = Byte_Factor*7;
				info->inputPixelSize = Byte_Factor*56;
			}
			break;
		case cmMCEight8Space:
			if (inColorSpace != icSigMCH8Data)
				err = cmInvalidColorSpace;
			else
			{
				for (loop = 0; loop< 8; loop++)
					calcParam->inputData[loop]	= &bitMap->image[Byte_Factor*loop];
				calcParam->cmInputPixelOffset = Byte_Factor*8;
				info->inputPixelSize = Byte_Factor*64;
			}
			break;
#if ( CM_MAX_COLOR_CHANNELS == 15 )
		case cmMC98Space:
		case cmMCa8Space:
		case cmMCb8Space:
		case cmMCc8Space:
		case cmMCd8Space:
		case cmMCe8Space:
		case cmMCf8Space:
		case cmMC28Space:
			if (inColorSpace != icSigMCH8Data)
				err = cmInvalidColorSpace;
			else
			{
				for (loop = 0; loop< 8; loop++)
					calcParam->inputData[loop]	= &bitMap->image[Byte_Factor*loop];
				calcParam->cmInputPixelOffset = Byte_Factor*8;
				info->inputPixelSize = Byte_Factor*64;
			}
			break;
#endif
#ifdef PI_Application_h
		case cmWord5ColorPacking + cmLABSpace:
			if (inColorSpace != icSigLabData)
				err = cmInvalidColorSpace;
			else{
				newRowBytes = calcParam->cmInputBytesPerLine;
				err = Do555To8Setup( calcParam, info, &linesAtOnce, 0 );
				if( err ) goto CleanupAndExit;
			}
			break;
		case cmWord5ColorPacking + cmXYZSpace:
			if (inColorSpace != icSigXYZData)
				err = cmInvalidColorSpace;
			else{
				newRowBytes = calcParam->cmInputBytesPerLine;
				err = Do555To8Setup( calcParam, info, &linesAtOnce, 0 );
				if( err ) goto CleanupAndExit;
			}
			break;
		case cmWord5ColorPacking + cmYXYSpace:
			if (inColorSpace != icSigYxyData)
				err = cmInvalidColorSpace;
			else{
				newRowBytes = calcParam->cmInputBytesPerLine;
				err = Do555To8Setup( calcParam, info, &linesAtOnce, 0 );
				if( err ) goto CleanupAndExit;
			}
			break;
		case cmWord5ColorPacking + cmGenericSpace:
			{
				newRowBytes = calcParam->cmInputBytesPerLine;
				err = Do555To8Setup( calcParam, info, &linesAtOnce, 0 );
				if( err ) goto CleanupAndExit;
			}
			break;
		case cmWord565ColorPacking + cmGenericSpace:
			{
				newRowBytes = calcParam->cmInputBytesPerLine;
				err = Do555To8Setup( calcParam, info, &linesAtOnce, 0 );
				if( err ) goto CleanupAndExit;
				info->origSizeIn = 6;
			}
			break;
		case cmWord5ColorPacking + cmBGRSpace:
			if (inColorSpace != icSigRgbData)
				err = cmInvalidColorSpace;
			else{
				newRowBytes = calcParam->cmInputBytesPerLine;
				err = Do555To8Setup( calcParam, info, &linesAtOnce, 1 );
				if( err ) goto CleanupAndExit;
			}
			break;
		case cmWord565ColorPacking + cmBGRSpace:
			if (inColorSpace != icSigRgbData)
				err = cmInvalidColorSpace;
			else{
				newRowBytes = calcParam->cmInputBytesPerLine;
				err = Do555To8Setup( calcParam, info, &linesAtOnce, 1 );
				if( err ) goto CleanupAndExit;
				info->origSizeIn = 6;
			}
			break;
		case cmRGB16_565Space:
#endif
		case cmRGB16Space:
			if (inColorSpace != icSigRgbData)
				err = cmInvalidColorSpace;
			else{
				newRowBytes = calcParam->cmInputBytesPerLine;
				err = Do555To8Setup( calcParam, info, &linesAtOnce, 0 );
				if( err ) goto CleanupAndExit;
#ifdef PI_Application_h
				if( inputBitMapColorSpace == cmRGB16_565Space ){
					info->origSizeIn = 6;
				}
#endif
			}
			break;
		case cmNamedIndexed32Space:
			if( (inputBitMapColorSpace == cmNamedIndexed32Space) && (inColorSpace != icSigNamedData)){
				err = cmInvalidColorSpace;
			}
			else{
				newRowBytes = calcParam->cmPixelPerLine * 3;	/* TempBuffer -> 32 BIT */
				linesAtOnce = (kMaxTempBlock) / newRowBytes;
				if (linesAtOnce == 0)
					linesAtOnce = 1;
				else if (linesAtOnce > calcParam->cmLineCount)
					linesAtOnce = calcParam->cmLineCount;
					
				bufferSize = newRowBytes * linesAtOnce;
				info->processedLinesIn = 0;
				info->origSizeIn = 8;
				info->usedSizeIn = 8;
				info->tempInBuffer = (void*)SmartNewPtr(bufferSize, &iErr);
				info->inputPixelSize = 32;
				if (iErr != noErr)
				{
					err = iErr;
					goto CleanupAndExit;
				}
	
				calcParam->cmLineCount			= linesAtOnce;
				calcParam->cmInputColorSpace = cmLAB24Space;
				calcParam->inputData[0]	= ((Ptr)info->tempInBuffer)+0;
				calcParam->inputData[1]	= ((Ptr)info->tempInBuffer)+1;
				calcParam->inputData[2]	= ((Ptr)info->tempInBuffer)+2;

				calcParam->cmInputBytesPerLine	= newRowBytes;
				calcParam->cmInputPixelOffset = 3;
			}
			break;
		case cmHSV32Space:
		case cmHLS32Space:
		case cmYXY32Space:
		case cmXYZ32Space:
		case cmLUV32Space:
		case cmLAB32Space:
#ifdef PI_Application_h
		case cmBGRSpace + cmLong10ColorPacking:
		case cmRGBSpace + cmLong10ColorPacking:
		case cmGenericSpace + cmLong10ColorPacking:
#endif
			if(  (	((inputBitMapColorSpace == cmHSV32Space) && (inColorSpace != icSigHsvData)) ||
					((inputBitMapColorSpace == cmHLS32Space) && (inColorSpace != icSigHlsData)) ||
					((inputBitMapColorSpace == cmYXY32Space) && (inColorSpace != icSigYxyData)) ||
					((inputBitMapColorSpace == cmXYZ32Space) && (inColorSpace != icSigXYZData)) ||
					((inputBitMapColorSpace == cmLUV32Space) && (inColorSpace != icSigLuvData)) ||
					((inputBitMapColorSpace == cmLAB32Space) && (inColorSpace != icSigLabData))  
#ifdef PI_Application_h
					|| ((inputBitMapColorSpace == cmBGRSpace + cmLong10ColorPacking) && (inColorSpace != icSigRgbData)) 
					|| ((inputBitMapColorSpace == cmRGBSpace + cmLong10ColorPacking) && (inColorSpace != icSigRgbData)) 
					|| ((inputBitMapColorSpace == cmGenericSpace + cmLong10ColorPacking) && (inColorSpace != icSigMCH3Data)) 
#endif
					)
#if ! realThing
					&& FALSE  
#endif
				)
				err = cmInvalidColorSpace;
			else{
				newRowBytes = calcParam->cmPixelPerLine * 3 * sizeof(SINT16);	/* TempBuffer -> cm16PerChannelPacking */
				linesAtOnce = (kMaxTempBlock) / newRowBytes;
				if (linesAtOnce == 0)
					linesAtOnce = 1;
				else if (linesAtOnce > calcParam->cmLineCount)
					linesAtOnce = calcParam->cmLineCount;
					
				bufferSize = newRowBytes * linesAtOnce;
				info->processedLinesIn = 0;
				info->origSizeIn = 10;
				info->usedSizeIn = 16;
				info->tempInBuffer = (void*)SmartNewPtr(bufferSize, &iErr);
				info->inputPixelSize = 32;
				if (iErr != noErr)
				{
					err = iErr;
					goto CleanupAndExit;
				}
	
				calcParam->cmLineCount			= linesAtOnce;
				if( inputBitMapColorSpace == cmBGRSpace + cmLong10ColorPacking ){
					calcParam->cmInputColorSpace = cmBGRSpace;
					calcParam->inputData[0]	= ((Ptr)info->tempInBuffer)+4;
					calcParam->inputData[1]	= ((Ptr)info->tempInBuffer)+2;
					calcParam->inputData[2]	= ((Ptr)info->tempInBuffer)+0;
				}
				else{
					calcParam->cmInputColorSpace = cmRGBSpace;
					calcParam->inputData[0]	= ((Ptr)info->tempInBuffer)+0;
					calcParam->inputData[1]	= ((Ptr)info->tempInBuffer)+2;
					calcParam->inputData[2]	= ((Ptr)info->tempInBuffer)+4;
				}
				calcParam->cmInputBytesPerLine	= newRowBytes;
				calcParam->cmInputPixelOffset = 6;
			}
			break;
		default:
			err = cmInvalidSrcMap;
			break;
	}
	
CleanupAndExit:
	LH_END_PROC("CheckInputColorSpace")
	return err;
}

/*--------------------------------------------------------------------------------------------------------------
	CheckOutputColorSpace
  --------------------------------------------------------------------------------------------------------------*/
CMError
CheckOutputColorSpace (const CMBitmap*	bitMap,
					   CMCalcParamPtr	calcParam,
					   ColorSpaceInfo*	info,
					   OSType			outColorSpace,
					   long				colorLutOutDim )
{
	CMError err = noErr;
	SINT32	newRowBytes;
	SINT32	bufferSize;
	SINT32	linesAtOnce;
	SINT32	loop;
	SINT16	iErr = noErr;
	CMBitmapColorSpace	outputBitMapColorSpace = calcParam->cmOutputColorSpace;
#ifdef ALLOW_16BIT_DATA
	UINT8 Byte_Factor=1;
#endif

	LH_START_PROC("CheckOutputColorSpace")
	colorLutOutDim = colorLutOutDim;
	
#ifdef ALLOW_16BIT_DATA
	if( outputBitMapColorSpace & cm16PerChannelPacking && (outputBitMapColorSpace & 31) != cmGraySpace){
		Byte_Factor = 2;
		outputBitMapColorSpace &= ~cm16PerChannelPacking;
		outputBitMapColorSpace |= cm8PerChannelPacking;
	}
#endif
	info->origSizeOut = Byte_Factor*8;
	info->usedSizeOut = Byte_Factor*8;
	switch ( outputBitMapColorSpace )
	{
		case cmNoSpace:
		case cmRGBSpace:			/* "... bitmap never uses this constant alone..." */
		case cmHSVSpace:			/* "... bitmap never uses this constant alone..." */
		case cmHLSSpace:			/* "... bitmap never uses this constant alone..." */
		case cmYXYSpace:			/* "... bitmap never uses this constant alone..." */
		case cmXYZSpace:			/* "... bitmap never uses this constant alone..." */
		case cmLUVSpace:			/* "... bitmap never uses this constant alone..." */
		case cmLABSpace:			/* "... bitmap never uses this constant alone..." */
		case cmMCFiveSpace:			/* "... bitmap never uses this constant alone..." */
		case cmMCSixSpace:			/* "... bitmap never uses this constant alone..." */
		case cmMCSevenSpace:		/* "... bitmap never uses this constant alone..." */
		case cmMCEightSpace:		/* "... bitmap never uses this constant alone..." */
		case cmGamutResultSpace:	/* "... bitmap never uses this constant alone..." */
		case cmGamutResult1Space:	/* not as colorspace for CMMatchBitmap */
#ifdef PI_Application_h
		case cmYCCSpace:			/* "... bitmap never uses this constant alone..." */
		case cmBGRSpace:			/* "... bitmap never uses this constant alone..." */
#endif
			err = cmInvalidDstMap;
			break;
		case cmCMYKSpace:			/* "... bitmap never uses this constant alone..." */
		case cmKYMCSpace:			/* "... bitmap never uses this constant alone..." */
			err = cmInvalidDstMap;
#if ! realThing
			if ( (outColorSpace != icSigCmykData) && (outColorSpace != icSigCmyData) )
				err = cmInvalidColorSpace;
			else
			{
				calcParam->outputData[0]		= &bitMap->image[0];
				calcParam->outputData[1]		= &bitMap->image[2];
				calcParam->outputData[2]		= &bitMap->image[4];
				calcParam->outputData[3]		= &bitMap->image[6];
				calcParam->cmOutputPixelOffset	= 8;
				info->usedSizeOut = 16;
			}
#endif
			break;
		case cmGraySpace:
			if (outColorSpace != icSigGrayData)
				err = cmInvalidColorSpace;
			else
			{
				calcParam->outputData[0]		= &bitMap->image[0];
				calcParam->cmOutputPixelOffset	= 2;
				info->usedSizeOut = 16;
				info->outputPixelSize = 16;
			}
			break;
		case cmGrayASpace:
			if (outColorSpace != icSigGrayData)
				err = cmInvalidColorSpace;
			else
			{
				calcParam->outputData[0]		= &bitMap->image[0];
				calcParam->outputData[1]		= &bitMap->image[2];
				calcParam->cmOutputPixelOffset	= 4;
				info->usedSizeOut = 16;
				info->outputPixelSize = 32;
			}
			break;
		case cmLAB24Space:
			if (outColorSpace != icSigLabData)
				err = cmInvalidColorSpace;
			else
			{
				calcParam->outputData[0]	= &bitMap->image[Byte_Factor*0];
				calcParam->outputData[1]	= &bitMap->image[Byte_Factor*1];
				calcParam->outputData[2]	= &bitMap->image[Byte_Factor*2];
				calcParam->cmOutputPixelOffset = Byte_Factor*3;
				info->outputPixelSize = Byte_Factor*24;
			}
			break;

		/* separated cmRGB24Space and cmRGB32Space to reflect the bitmap format definition changes. */
		case cmRGB24Space:
			if (outColorSpace != icSigRgbData)
				err = cmInvalidColorSpace;
			else
			{
				calcParam->outputData[0]	= &bitMap->image[Byte_Factor*0];
				calcParam->outputData[1]	= &bitMap->image[Byte_Factor*1];
				calcParam->outputData[2]	= &bitMap->image[Byte_Factor*2];
				calcParam->cmOutputPixelOffset = Byte_Factor*3;
				info->outputPixelSize = Byte_Factor*24;
			}
			break;
		case cmRGB32Space:
			if (outColorSpace != icSigRgbData)
				err = cmInvalidColorSpace;
			else
				{
				calcParam->outputData[0]		= &bitMap->image[Byte_Factor*1];
				calcParam->outputData[1]		= &bitMap->image[Byte_Factor*2];
				calcParam->outputData[2]		= &bitMap->image[Byte_Factor*3];
				calcParam->outputData[3]		= &bitMap->image[Byte_Factor*0];
				calcParam->cmOutputPixelOffset	= Byte_Factor*4;
				calcParam->clearMask			= TRUE;
				info->outputPixelSize = Byte_Factor*32;
			}
			break;

		case cmRGBASpace:
		case cmRGBA32Space:
			if (outColorSpace != icSigRgbData)
				err = cmInvalidColorSpace;
				else
				{
				calcParam->outputData[0]	= &bitMap->image[Byte_Factor*0];
				calcParam->outputData[1]	= &bitMap->image[Byte_Factor*1];
				calcParam->outputData[2]	= &bitMap->image[Byte_Factor*2];
				calcParam->outputData[3]	= &bitMap->image[Byte_Factor*3];
				calcParam->cmOutputPixelOffset = Byte_Factor*4;
				info->outputPixelSize = Byte_Factor*32;
			}
			break;

#ifdef PI_Application_h
		case cmGraySpace|cm8PerChannelPacking:
			if (outColorSpace != icSigGrayData)
				err = cmInvalidColorSpace;
			else
			{
				calcParam->outputData[0]		= &bitMap->image[0];
				calcParam->cmOutputPixelOffset	= 1;
				info->usedSizeOut = 8;
				info->outputPixelSize = 8;
			}
			break;
		case cmGrayASpace|cm8PerChannelPacking:
			if (outColorSpace != icSigGrayData)
				err = cmInvalidColorSpace;
			else
			{
				calcParam->outputData[0]		= &bitMap->image[0];
				calcParam->outputData[1]		= &bitMap->image[1];
				calcParam->cmOutputPixelOffset	= 2;
				info->usedSizeOut = 8;
				info->outputPixelSize = 16;
			}
			break;

		case cmBGR24Space:
			if (outColorSpace != icSigRgbData)
				err = cmInvalidColorSpace;
			else
			{
				calcParam->outputData[0]	= &bitMap->image[Byte_Factor*2];
				calcParam->outputData[1]	= &bitMap->image[Byte_Factor*1];
				calcParam->outputData[2]	= &bitMap->image[Byte_Factor*0];
				calcParam->cmOutputPixelOffset = Byte_Factor*3;
				info->outputPixelSize = Byte_Factor*24;
			}
			break;
		case cmBGR32Space:
			if (outColorSpace != icSigRgbData)
				err = cmInvalidColorSpace;
			else
				{
				calcParam->outputData[0]		= &bitMap->image[Byte_Factor*2];
				calcParam->outputData[1]		= &bitMap->image[Byte_Factor*1];
				calcParam->outputData[2]		= &bitMap->image[Byte_Factor*0];
				calcParam->outputData[3]		= &bitMap->image[Byte_Factor*3];
				calcParam->cmOutputPixelOffset	= Byte_Factor*4;
				calcParam->clearMask			= FALSE;
				calcParam->copyAlpha			= TRUE;
				info->outputPixelSize = Byte_Factor*32;
			}
			break;

		case cmYCC24Space:		/* cmYCC24Space and cmYCC32Space have the same value !!!	*/
			if (outColorSpace != icSigYCbCrData)
				err = cmInvalidColorSpace;
			else
			{
				calcParam->outputData[0]	= &bitMap->image[Byte_Factor*0];
				calcParam->outputData[1]	= &bitMap->image[Byte_Factor*1];
				calcParam->outputData[2]	= &bitMap->image[Byte_Factor*2];
				calcParam->cmOutputPixelOffset = Byte_Factor*3;
				info->outputPixelSize = Byte_Factor*24;
			}
			break;
		case cmYCC32Space:
			if (outColorSpace != icSigYCbCrData)
				err = cmInvalidColorSpace;
			else
			{
				calcParam->outputData[0]		= &bitMap->image[Byte_Factor*1];
				calcParam->outputData[1]		= &bitMap->image[Byte_Factor*2];
				calcParam->outputData[2]		= &bitMap->image[Byte_Factor*3];
				calcParam->outputData[3]		= &bitMap->image[Byte_Factor*0];
				calcParam->cmOutputPixelOffset	= Byte_Factor*4;
				calcParam->clearMask			= TRUE;
				info->outputPixelSize = Byte_Factor*32;
			}
			break;

		case cmYCCASpace:
		case cmYCCA32Space:
			if (outColorSpace != icSigYCbCrData)
				err = cmInvalidColorSpace;
			else
			{
				calcParam->outputData[0]	= &bitMap->image[Byte_Factor*0];
				calcParam->outputData[1]	= &bitMap->image[Byte_Factor*1];
				calcParam->outputData[2]	= &bitMap->image[Byte_Factor*2];
				calcParam->outputData[3]	= &bitMap->image[Byte_Factor*3];
				calcParam->cmOutputPixelOffset = Byte_Factor*4;
				info->outputPixelSize = Byte_Factor*32;
			}
			break;
		case cmAYCC32Space:
			if (outColorSpace != icSigYCbCrData)
				err = cmInvalidColorSpace;
			else
			{
				calcParam->outputData[0]	= &bitMap->image[Byte_Factor*1];
				calcParam->outputData[1]	= &bitMap->image[Byte_Factor*2];
				calcParam->outputData[2]	= &bitMap->image[Byte_Factor*3];
				calcParam->outputData[3]	= &bitMap->image[Byte_Factor*0];
				calcParam->cmOutputPixelOffset = Byte_Factor*4;
				info->outputPixelSize = Byte_Factor*32;
			}
			break;
		case cmLong8ColorPacking + cmLABSpace:
			if (outColorSpace != icSigLabData)
				err = cmInvalidColorSpace;
			else
			{
				calcParam->outputData[0]	= &bitMap->image[Byte_Factor*0];
				calcParam->outputData[1]	= &bitMap->image[Byte_Factor*1];
				calcParam->outputData[2]	= &bitMap->image[Byte_Factor*2];
				calcParam->outputData[3]	= &bitMap->image[Byte_Factor*3];
				calcParam->cmOutputPixelOffset = Byte_Factor*4;
				info->outputPixelSize = Byte_Factor*32;
			}
			break;
		case cmLong8ColorPacking + cmXYZSpace:
			if (outColorSpace != icSigXYZData)
				err = cmInvalidColorSpace;
			else
			{
				calcParam->outputData[0]	= &bitMap->image[Byte_Factor*0];
				calcParam->outputData[1]	= &bitMap->image[Byte_Factor*1];
				calcParam->outputData[2]	= &bitMap->image[Byte_Factor*2];
				calcParam->outputData[3]	= &bitMap->image[Byte_Factor*3];
				calcParam->cmOutputPixelOffset = Byte_Factor*4;
				info->outputPixelSize = Byte_Factor*32;
			}
			break;
		case cmLong8ColorPacking + cmYXYSpace:
			if (outColorSpace != icSigYxyData)
				err = cmInvalidColorSpace;
			else
			{
				calcParam->outputData[0]	= &bitMap->image[Byte_Factor*0];
				calcParam->outputData[1]	= &bitMap->image[Byte_Factor*1];
				calcParam->outputData[2]	= &bitMap->image[Byte_Factor*2];
				calcParam->outputData[3]	= &bitMap->image[Byte_Factor*3];
				calcParam->cmOutputPixelOffset = Byte_Factor*4;
				info->outputPixelSize = Byte_Factor*32;
			}
			break;
		case cmGenericSpace + cm8PerChannelPacking:
			{
				for (loop = 0; loop< colorLutOutDim; loop++)
					calcParam->outputData[loop]	= &bitMap->image[Byte_Factor*loop];
				calcParam->cmOutputPixelOffset = Byte_Factor*colorLutOutDim;
				info->outputPixelSize = Byte_Factor*colorLutOutDim*8;
			}
			break;
		case cmGenericSpace + cmLong8ColorPacking:
			{
				for (loop = 0; loop< (colorLutOutDim+1); loop++)
					calcParam->outputData[loop]	= &bitMap->image[Byte_Factor*loop];
				calcParam->cmOutputPixelOffset = Byte_Factor*(colorLutOutDim+1);
				info->outputPixelSize = Byte_Factor*(colorLutOutDim+1)*8;
			}
			break;
		case cmCMY24Space:
			if ( outColorSpace != icSigCmyData )
				err = cmInvalidColorSpace;
			else
			{
				calcParam->outputData[0]	= &bitMap->image[Byte_Factor*0];
				calcParam->outputData[1]	= &bitMap->image[Byte_Factor*1];
				calcParam->outputData[2]	= &bitMap->image[Byte_Factor*2];
				calcParam->cmOutputPixelOffset = Byte_Factor*3;
				info->outputPixelSize = Byte_Factor*24;
			}
			break;
#endif

		case cmCMYK32Space:
			if ( (outColorSpace != icSigCmykData) && (outColorSpace != icSigCmyData) )
				err = cmInvalidColorSpace;
			else
			{
				calcParam->outputData[0]	= &bitMap->image[Byte_Factor*0];
				calcParam->outputData[1]	= &bitMap->image[Byte_Factor*1];
				calcParam->outputData[2]	= &bitMap->image[Byte_Factor*2];
				calcParam->outputData[3]	= &bitMap->image[Byte_Factor*3];
				calcParam->cmOutputPixelOffset = Byte_Factor*4;
				if (outColorSpace == icSigCmyData)					/* if we have CMY-Data - clear the k */
					calcParam->clearMask	= TRUE;
				info->outputPixelSize = Byte_Factor*32;
			}
			break;
		case cmKYMC32Space:
			if ( (outColorSpace != icSigCmykData) && (outColorSpace != icSigCmyData) )
				err = cmInvalidColorSpace;
			else
			{
				calcParam->outputData[3]	= &bitMap->image[Byte_Factor*0];
				calcParam->outputData[2]	= &bitMap->image[Byte_Factor*1];
				calcParam->outputData[1]	= &bitMap->image[Byte_Factor*2];
				calcParam->outputData[0]	= &bitMap->image[Byte_Factor*3];
				calcParam->cmOutputPixelOffset = Byte_Factor*4;
				if (outColorSpace == icSigCmyData)					/* if we have CMY-Data - clear the k */
					calcParam->clearMask	= TRUE;
				info->outputPixelSize = Byte_Factor*32;
			}
			break;
		case cmARGB32Space:
			if (outColorSpace != icSigRgbData)
				err = cmInvalidColorSpace;
			else
			{
				calcParam->outputData[0]	= &bitMap->image[Byte_Factor*1];
				calcParam->outputData[1]	= &bitMap->image[Byte_Factor*2];
				calcParam->outputData[2]	= &bitMap->image[Byte_Factor*3];
				calcParam->outputData[3]	= &bitMap->image[Byte_Factor*0];
				calcParam->cmOutputPixelOffset =Byte_Factor*4;
				info->outputPixelSize = Byte_Factor*32;
			}
			break;
		case cmMCFive8Space:
			if (outColorSpace != icSigMCH5Data)
				err = cmInvalidColorSpace;
			else
			{
				for (loop = 0; loop< 5; loop++)
					calcParam->outputData[loop]	= &bitMap->image[Byte_Factor*loop];
				calcParam->cmOutputPixelOffset = Byte_Factor*5;
				info->outputPixelSize = Byte_Factor*40;
			}
			break;
		case cmMCSix8Space:
			if (outColorSpace != icSigMCH6Data)
				err = cmInvalidColorSpace;
			else
			{
				for (loop = 0; loop< 6; loop++)
					calcParam->outputData[loop]	= &bitMap->image[Byte_Factor*loop];
				calcParam->cmOutputPixelOffset = Byte_Factor*6;
				info->outputPixelSize = Byte_Factor*48;
			}
			break;
		case cmMCSeven8Space:
			if (outColorSpace != icSigMCH7Data)
				err = cmInvalidColorSpace;
			else
			{
				for (loop = 0; loop< 7; loop++)
					calcParam->outputData[loop]	= &bitMap->image[Byte_Factor*loop];
				calcParam->cmOutputPixelOffset = Byte_Factor*7;
				info->outputPixelSize = Byte_Factor*56;
			}
			break;
		case cmMCEight8Space:
			if (outColorSpace != icSigMCH8Data)
				err = cmInvalidColorSpace;
			else
			{
				for (loop = 0; loop< 8; loop++)
					calcParam->outputData[loop]	= &bitMap->image[Byte_Factor*loop];
				calcParam->cmOutputPixelOffset = Byte_Factor*8;
				info->outputPixelSize = Byte_Factor*64;
			}
			break;
#ifdef PI_Application_h
		case cmWord5ColorPacking + cmLABSpace:
			if (outColorSpace != icSigLabData)
				err = cmInvalidColorSpace;
			else{
				err = Do8To555Setup( calcParam, info, &linesAtOnce, 0 );
				if( err ) goto CleanupAndExit;
			}
			break;
		case cmWord5ColorPacking + cmXYZSpace:
			if (outColorSpace != icSigXYZData)
				err = cmInvalidColorSpace;
			else{
				err = Do8To555Setup( calcParam, info, &linesAtOnce, 0 );
				if( err ) goto CleanupAndExit;
			}
			break;
		case cmWord5ColorPacking + cmYXYSpace:
			if (outColorSpace != icSigYxyData)
				err = cmInvalidColorSpace;
			else{
				err = Do8To555Setup( calcParam, info, &linesAtOnce, 0 );
				if( err ) goto CleanupAndExit;
			}
			break;
		case cmWord5ColorPacking + cmGenericSpace:
			{
				err = Do8To555Setup( calcParam, info, &linesAtOnce, 0 );
				if( err ) goto CleanupAndExit;
			}
			break;
		case cmWord565ColorPacking + cmGenericSpace:
			{
				err = Do8To555Setup( calcParam, info, &linesAtOnce, 0 );
				if( err ) goto CleanupAndExit;
				info->origSizeOut = 6;
			}
			break;
		case cmWord5ColorPacking + cmBGRSpace:
			if (outColorSpace != icSigRgbData)
				err = cmInvalidColorSpace;
			else{
				err = Do8To555Setup( calcParam, info, &linesAtOnce, 1 );
				if( err ) goto CleanupAndExit;
			}
			break;
		case cmWord565ColorPacking + cmBGRSpace:
			if (outColorSpace != icSigRgbData)
				err = cmInvalidColorSpace;
			else{
				err = Do8To555Setup( calcParam, info, &linesAtOnce, 1 );
				if( err ) goto CleanupAndExit;
				info->origSizeOut = 6;
			}
			break;
		case cmRGB16_565Space:
#endif
		case cmRGB16Space:
			if (outColorSpace != icSigRgbData)
				err = cmInvalidColorSpace;
			else{
				err = Do8To555Setup( calcParam, info, &linesAtOnce, 0 );
				if( err ) goto CleanupAndExit;
#ifdef PI_Application_h
				if( outputBitMapColorSpace == cmRGB16_565Space ){
					info->origSizeOut = 6;
				}
#endif
			}
			break;
		case cmNamedIndexed32Space:
			if( (outColorSpace == cmNamedIndexed32Space) && (outColorSpace != icSigNamedData)){
				err = cmInvalidColorSpace;
			}
			else{
				calcParam->outputData[0]	= &bitMap->image[0];
				calcParam->outputData[1]	= &bitMap->image[1];
				calcParam->outputData[2]	= &bitMap->image[2];
				calcParam->outputData[3]	= &bitMap->image[3];
				calcParam->cmOutputPixelOffset = 4;
				info->outputPixelSize = 32;
			}
			break;
		case cmHSV32Space:
		case cmHLS32Space:
		case cmYXY32Space:
		case cmXYZ32Space:
		case cmLUV32Space:
		case cmLAB32Space:
#ifdef PI_Application_h
		case cmBGRSpace + cmLong10ColorPacking:
		case cmRGBSpace + cmLong10ColorPacking:
		case cmGenericSpace + cmLong10ColorPacking:
#endif
			if ( (  ((outputBitMapColorSpace == cmHSV32Space) && (outColorSpace != icSigHsvData)) ||
					((outputBitMapColorSpace == cmHLS32Space) && (outColorSpace != icSigHlsData)) ||
					((outputBitMapColorSpace == cmYXY32Space) && (outColorSpace != icSigYxyData)) ||
					((outputBitMapColorSpace == cmXYZ32Space) && (outColorSpace != icSigXYZData)) ||
					((outputBitMapColorSpace == cmLUV32Space) && (outColorSpace != icSigLuvData)) ||
					((outputBitMapColorSpace == cmLAB32Space) && (outColorSpace != icSigLabData)) 
#ifdef PI_Application_h
					|| ((outputBitMapColorSpace == cmBGRSpace + cmLong10ColorPacking) && (outColorSpace != icSigRgbData)) 
					|| ((outputBitMapColorSpace == cmRGBSpace + cmLong10ColorPacking) && (outColorSpace != icSigRgbData)) 
					|| ((outputBitMapColorSpace == cmGenericSpace + cmLong10ColorPacking) && (outColorSpace != icSigMCH3Data)) 
#endif
					)
#if ! realThing
					&& FALSE
#endif
				)
				err = cmInvalidColorSpace;
			else{
				newRowBytes = calcParam->cmPixelPerLine * 3 * sizeof(SINT16);	/* TempBuffer -> cm16PerChannelPacking */
				linesAtOnce = (kMaxTempBlock) / newRowBytes;
				if (linesAtOnce == 0)
					linesAtOnce = 1;
				else if (linesAtOnce > calcParam->cmLineCount)
					linesAtOnce = calcParam->cmLineCount;
					
				bufferSize = newRowBytes * linesAtOnce;
				info->processedLinesOut = 0;
				info->origSizeOut 		= 10;
				info->usedSizeOut 		= 16;
				info->tempOutBuffer 	= (void*)SmartNewPtr(bufferSize, &iErr);
				info->outputPixelSize = 32;
				if (iErr != noErr)
				{
					err = iErr;
					goto CleanupAndExit;
				}
				
				calcParam->cmLineCount			= linesAtOnce;
				calcParam->cmOutputBytesPerLine	= newRowBytes;
				if( outputBitMapColorSpace == cmBGRSpace + cmLong10ColorPacking ){
					calcParam->cmOutputColorSpace = cmBGRSpace;
					calcParam->outputData[0]		= ((Ptr)info->tempOutBuffer)+4;
					calcParam->outputData[1]		= ((Ptr)info->tempOutBuffer)+2;
					calcParam->outputData[2]		= ((Ptr)info->tempOutBuffer)+0;
				}
				else{
					calcParam->cmOutputColorSpace	= cmRGBSpace;
					calcParam->outputData[0]		= ((Ptr)info->tempOutBuffer)+0;
					calcParam->outputData[1]		= ((Ptr)info->tempOutBuffer)+2;
					calcParam->outputData[2]		= ((Ptr)info->tempOutBuffer)+4;
				}
				calcParam->cmOutputPixelOffset = 6;
			}
			break;
		default:
			err = cmInvalidDstMap;
			break;
	}

CleanupAndExit:
	LH_END_PROC("CheckOutputColorSpace")
	return err;
}


/*--------------------------------------------------------------------------------------------------------------
	SetOutputColorSpaceInplace
  --------------------------------------------------------------------------------------------------------------*/
CMError
SetOutputColorSpaceInplace	( CMCalcParamPtr	calcParam,
							  ColorSpaceInfo*	info,
							  OSType 			outColorSpace )
{
	CMError err = noErr;

	LH_START_PROC("SetOutputColorSpaceInplace")

	switch ( outColorSpace )
	{
		case icSigXYZData:
			calcParam->cmOutputColorSpace = cmXYZ32Space;
			break;
		case icSigLuvData:
			calcParam->cmOutputColorSpace = cmLUV32Space;
			break;		
		case icSigYxyData:
			calcParam->cmOutputColorSpace = cmYXY32Space;
			break;
		case icSigHsvData:
			calcParam->cmOutputColorSpace = cmHSV32Space;		
			break;
		case icSigHlsData:
			calcParam->cmOutputColorSpace = cmHLS32Space;
			break;
		case icSigGrayData:
			if (calcParam->cmInputPixelOffset == 1)
				calcParam->cmOutputColorSpace = cmGraySpace|cm8PerChannelPacking;
			else if (calcParam->cmInputPixelOffset == 2)
				calcParam->cmOutputColorSpace = cmGraySpace;
			else 
				calcParam->cmOutputColorSpace = cmGrayASpace;
			break;

		case icSigRgbData:
			/* based on the size of the input bitmap, select the right rgb packing format */	
#ifdef PI_Application_h
			if( (calcParam->cmInputColorSpace & 0x1f) == cmBGRSpace ){
				if (info->inputPixelSize < 24){
					if (info->origSizeIn == 6){
						calcParam->cmOutputColorSpace = cmBGRSpace|cmWord565ColorPacking;
					}
					else{																		/* output is 5 bit */
						calcParam->cmOutputColorSpace = cmBGRSpace|cmWord5ColorPacking;
					}
				}
				if (info->inputPixelSize < 32)
					calcParam->cmOutputColorSpace = cmBGR24Space;
				else if (info->inputPixelSize == 32)
					calcParam->cmOutputColorSpace = cmBGR32Space;
				else if (info->inputPixelSize == 48)
					calcParam->cmOutputColorSpace = cmBGRSpace | cm16PerChannelPacking;
				else if (info->inputPixelSize == 64)
					calcParam->cmOutputColorSpace = cmBGR32Space | cm16PerChannelPacking;
				break;
			}
#endif
			if (info->inputPixelSize < 24)
#ifdef PI_Application_h
				if (info->origSizeIn == 6){
					calcParam->cmOutputColorSpace = cmRGB16_565Space;
				}
				else																		/* output is 5 bit */
#endif
				calcParam->cmOutputColorSpace = cmRGB16Space;
			else if (info->inputPixelSize < 32)
				calcParam->cmOutputColorSpace = cmRGB24Space;
			else if (info->inputPixelSize == 32)
				calcParam->cmOutputColorSpace = cmRGB32Space;
			else if (info->inputPixelSize == 48)
				calcParam->cmOutputColorSpace = cmRGBSpace | cm16PerChannelPacking;
			else if (info->inputPixelSize == 64)
				calcParam->cmOutputColorSpace = cmRGB32Space | cm16PerChannelPacking;
			break;
			
		case icSigLabData:
			/* based on the size of the input bitmap, select the right lab packing format */	
			if (info->inputPixelSize < 32)
				calcParam->cmOutputColorSpace = cmLAB24Space;
			else
				calcParam->cmOutputColorSpace = cmLAB32Space;
			break;
			
		case icSigCmyData:
			calcParam->cmOutputColorSpace = cmCMY24Space;
			break;
		case icSigCmykData:
#ifdef PI_Application_h
			if( (calcParam->cmInputColorSpace & 0x1f) == cmKYMCSpace ){
				calcParam->cmOutputColorSpace = cmKYMC32Space;
				break;
			}
#endif
			calcParam->cmOutputColorSpace = cmCMYK32Space;
			break;
			
		case icSigMCH5Data:
			calcParam->cmOutputColorSpace = cmMCFive8Space;
			break;
		case icSigMCH6Data:
			calcParam->cmOutputColorSpace = cmMCSix8Space;
			break;
		case icSigMCH7Data:
			calcParam->cmOutputColorSpace = cmMCSeven8Space;
			break;
		case icSigMCH8Data:
			calcParam->cmOutputColorSpace = cmMCEight8Space;
			break;
		default:
			break;
	}
 
	LH_END_PROC("SetOutputColorSpaceInplace")
	return err;
}

/*--------------------------------------------------------------------------------------------------------------
	CheckOutputColorSpaceChk
  --------------------------------------------------------------------------------------------------------------*/
CMError
CheckOutputColorSpaceChk  ( const CMBitmap*	bitMap,
							CMCalcParamPtr	calcParam,
							ColorSpaceInfo*	info )
{
	CMError err = noErr;
	SINT32	newRowBytes;
	SINT32	bufferSize;
	SINT32	linesAtOnce;
	SINT16	iErr = noErr;

	LH_START_PROC("CheckOutputColorSpaceChk")
	switch ( bitMap->space)
	{
		case cmGamutResult1Space:
			newRowBytes = calcParam->cmPixelPerLine;		/* TempBuffer -> 1 byte per pixel */
			linesAtOnce = (kMaxTempBlock) / newRowBytes;
			if (linesAtOnce == 0)
				linesAtOnce = 1;
			else if (linesAtOnce > calcParam->cmLineCount)
				linesAtOnce = calcParam->cmLineCount;
				
			bufferSize = newRowBytes * linesAtOnce;
			info->processedLinesOut = 0;
			info->origSizeOut = 1;
			info->usedSizeOut = 8;				/* ACHTUNG !!!!! bufferSize*info->usedSizeOut */
			info->tempOutBuffer 	= (void*)SmartNewPtr(bufferSize*info->usedSizeOut, &iErr);
			if (iErr != noErr)
			{
				err = iErr;
				goto CleanupAndExit;
			}
	
			calcParam->cmLineCount			 = linesAtOnce;
			calcParam->cmOutputColorSpace    = cmGraySpace|cm8PerChannelPacking;
			calcParam->cmOutputBytesPerLine  = newRowBytes;
			calcParam->outputData[0]		 =  (Ptr)info->tempOutBuffer;
			calcParam->cmOutputPixelOffset	 = 1;
			break;
		case cmGamutResultSpace:
			newRowBytes = calcParam->cmPixelPerLine;		/* TempBuffer -> 1 byte per pixel */
			linesAtOnce = (kMaxTempBlock) / newRowBytes;
			if (linesAtOnce == 0)
				linesAtOnce = 1;
			else if (linesAtOnce > calcParam->cmLineCount)
				linesAtOnce = calcParam->cmLineCount;
				
			bufferSize = newRowBytes * linesAtOnce;
			info->processedLinesOut = 0;
			info->origSizeOut = 8;
			info->usedSizeOut = 8;
			info->tempOutBuffer 	= 0;
	
			calcParam->cmLineCount			 = linesAtOnce;
			calcParam->cmOutputColorSpace    = cmGraySpace|cm8PerChannelPacking;
			calcParam->cmOutputBytesPerLine  = newRowBytes;
			calcParam->cmOutputPixelOffset	 = 1;
			calcParam->outputData[0]		= &bitMap->image[0];
			break;
		default:
			err = cmInvalidDstMap;
			break;
	}
CleanupAndExit:
	LH_END_PROC("CheckOutputColorSpaceChk")
	return err;
}

/*--------------------------------------------------------------------------------------------------------------
	AllocBufferCheckCM
  --------------------------------------------------------------------------------------------------------------*/
CMError
AllocBufferCheckCM	( CMCalcParamPtr	calcParam,
					  ColorSpaceInfo*	info )
{
	CMError err = noErr;
	SINT32	newRowBytes;
	SINT32	bufferSize;
	SINT32	linesAtOnce;
	SINT16	iErr = noErr;
	
	LH_START_PROC("AllocBufferCheckCM")
	newRowBytes = calcParam->cmPixelPerLine;		/* TempBuffer -> 1 byte per pixel */
	linesAtOnce = (kMaxTempBlock) / newRowBytes;
	if (linesAtOnce == 0)
		linesAtOnce = 1;
	else if (linesAtOnce > calcParam->cmLineCount)
		linesAtOnce = calcParam->cmLineCount;
		
	bufferSize = newRowBytes * linesAtOnce;
	info->processedLinesOut = 0;
	info->origSizeOut = 1;
	info->usedSizeOut = 8;
	info->tempOutBuffer 	= (void*)SmartNewPtr(bufferSize, &iErr);
	if (iErr != noErr)
	{
		err = iErr;
		goto CleanupAndExit;
	}

	calcParam->cmLineCount			 = linesAtOnce;
	calcParam->cmOutputColorSpace    = cmGraySpace|cm8PerChannelPacking;
	calcParam->cmOutputBytesPerLine  = newRowBytes;
	calcParam->outputData[0]		 =  (Ptr)info->tempOutBuffer;
	calcParam->cmOutputPixelOffset	 = 1;

CleanupAndExit:
	LH_END_PROC("AllocBufferCheckCM")
	return err;
}

/*--------------------------------------------------------------------------------------------------------------
	FindLookupRoutine
  --------------------------------------------------------------------------------------------------------------*/
CalcProcPtr
FindLookupRoutine   ( const CMLutParam*		lutParam,
					  const ColorSpaceInfo*	info )
{
	CalcProcPtr		proc2call	= nil;
#ifdef DEBUG_OUTPUT
	CMError err = noErr;
#endif
	LH_START_PROC("FindLookupRoutine")

	switch ( lutParam->colorLutInDim )
	{
		case 3:																						/* 3 ->															*/
			switch ( lutParam->colorLutOutDim )
			{
				case 3:																				/* 3 -> 3														*/
					switch (info->usedSizeIn)
					{	
						case 8:																		/* 3 -> 3		Di 8                     						*/
							switch (info->usedSizeOut)
							{
								case 8:																/* 3 -> 3		Di 8		Do 8								*/
									switch (lutParam->colorLutWordSize)
									{
										case 8:														/* 3 -> 3		Di 8		Do 8		Lut 8					*/
											switch (lutParam->colorLutGridPoints)
											{
#if LH_CALC_ENGINE_ALL_FORMATS_LO
												case 16:											/* 3 -> 3		Di 8		Do 8		Lut 8		Grid 16		*/
													proc2call = NewCalcProc(LHCalc3to3_Di8_Do8_Lut8_G16_LO);
													break;
#endif
												case 32:											/* 3 -> 3		Di 8		Do 8		Lut 8		Grid 32		*/
													proc2call = NewCalcProc(LHCalc3to3_Di8_Do8_Lut8_G32_LO);
													break;
											}
											break;
#if LH_CALC_ENGINE_ALL_FORMATS_LO
										case 16:													/* 3 -> 3		Di 8		Do 8		Lut 16					*/			
											switch (lutParam->colorLutGridPoints)
											{
												case 16:											/* 3 -> 3		Di 8		Do 8		Lut 16		Grid 16		*/
													proc2call = NewCalcProc(LHCalc3to3_Di8_Do8_Lut16_G16_LO);
													break;
												case 32:											/* 3 -> 3		Di 8		Do 8		Lut 16		Grid 32		*/
													proc2call = NewCalcProc(LHCalc3to3_Di8_Do8_Lut16_G32_LO);
													break;
											}
											break;
#endif
									}
									break;
#if LH_CALC_ENGINE_ALL_FORMATS_LO
								case 16:															/* 3 -> 3		Di 8		Do 16								*/
#if LH_CALC_ENGINE_MIXED_DATAFORMAT
									switch (lutParam->colorLutWordSize)
									{
										case 8:														/* 3 -> 3		Di 8		Do 16		Lut 8					*/
											switch (lutParam->colorLutGridPoints)
											{
												case 16:											/* 3 -> 3		Di 8		Do 16		Lut 8		Grid 16		*/
													proc2call = NewCalcProc(LHCalc3to3_Di8_Do16_Lut8_G16_LO);
													break;
												case 32:											/* 3 -> 3		Di 8		Do 16		Lut 8		Grid 32		*/
													proc2call = NewCalcProc(LHCalc3to3_Di8_Do16_Lut8_G32_LO);
													break;
											}
											break;
										case 16:													/* 3 -> 3		Di 8		Do 16		Lut 16					*/
											switch (lutParam->colorLutGridPoints)
											{
												case 16:											/* 3 -> 3		Di 8		Do 16		Lut 16		Grid 16		*/
													proc2call = NewCalcProc(LHCalc3to3_Di8_Do16_Lut16_G16_LO);
													break;
												case 32:											/* 3 -> 3		Di 8		Do 16		Lut 16		Grid 32		*/
													proc2call = NewCalcProc(LHCalc3to3_Di8_Do16_Lut16_G32_LO);
													break;
											}
											break;
									}
#endif
									break;
#endif
							}

							break;
#if LH_CALC_ENGINE_ALL_FORMATS_LO
						case 16:																	/* 3 -> 3		Di 16                    						*/
							switch (info->usedSizeOut)
							{
								case 8:																/* 3 -> 3		Di 16		Do 8								*/
#if LH_CALC_ENGINE_MIXED_DATAFORMAT
									switch (lutParam->colorLutWordSize)
									{
										case 8:														/* 3 -> 3		Di 16		Do 8		Lut 8					*/
											switch (lutParam->colorLutGridPoints)
											{
												case 16:											/* 3 -> 3		Di 16		Do 8		Lut 8		Grid 16		*/
													proc2call = NewCalcProc(LHCalc3to3_Di16_Do8_Lut8_G16_LO);
													break;
												case 32:											/* 3 -> 3		Di 16		Do 8		Lut 8		Grid 32		*/
													proc2call = NewCalcProc(LHCalc3to3_Di16_Do8_Lut8_G32_LO);
													break;
											}
											break;
										case 16:													/* 3 -> 3		Di 16		Do 8		Lut 16					*/
											switch (lutParam->colorLutGridPoints)
											{
												case 16:											/* 3 -> 3		Di 16		Do 8		Lut 16		Grid 16		*/
													proc2call = NewCalcProc(LHCalc3to3_Di16_Do8_Lut16_G16_LO);
													break;
												case 32:											/* 3 -> 3		Di 16		Do 8		Lut 16		Grid 32		*/
													proc2call = NewCalcProc(LHCalc3to3_Di16_Do8_Lut16_G32_LO);
													break;
											}
											break;
									}
#endif
									break;
								case 16:															/* 3 -> 3		Di 16		Do 16								*/
#if LH_CALC_ENGINE_16_BIT_LO
									switch (lutParam->colorLutWordSize)
									{
										case 8:														/* 3 -> 3		Di 16		Do 16		Lut 8					*/
											switch (lutParam->colorLutGridPoints)
											{
												case 16:											/* 3 -> 3		Di 16		Do 16		Lut 8		Grid 16		*/
													proc2call = NewCalcProc(LHCalc3to3_Di16_Do16_Lut8_G16_LO);
													break;
												case 32:											/* 3 -> 3		Di 16		Do 16		Lut 8		Grid 32		*/
													proc2call = NewCalcProc(LHCalc3to3_Di16_Do16_Lut8_G32_LO);
													break;
											}
											break;
										case 16:													/* 3 -> 3		Di 16		Do 16		Lut 16					*/
											switch (lutParam->colorLutGridPoints)
											{
												case 16:											/* 3 -> 3		Di 16		Do 16		Lut 16		Grid 16		*/
													proc2call = NewCalcProc(LHCalc3to3_Di16_Do16_Lut16_G16_LO);
													break;
												case 32:											/* 3 -> 3		Di 16		Do 16		Lut 16		Grid 32		*/
													proc2call = NewCalcProc(LHCalc3to3_Di16_Do16_Lut16_G32_LO);
													break;
											}
											break;
									}
#endif
									break;
							}
							break;
#endif
					}
					break;
#if LH_CALC_ENGINE_ALL_FORMATS_LO
				case 4:																				/* 3 -> 4														*/
					switch (info->usedSizeIn)
					{
						case 8:																		/* 3 -> 4		Di 8											*/
							switch (info->usedSizeOut)
							{
								case 8:																/* 3 -> 4		Di 8		Do 8								*/
									switch (lutParam->colorLutWordSize)
									{
										case 8:														/* 3 -> 4		Di 8		Do 8		Lut 8					*/
											switch (lutParam->colorLutGridPoints)
											{
												case 16:											/* 3 -> 4		Di 8		Do 8		Lut 8		Grid 16		*/
													proc2call = NewCalcProc(LHCalc3to4_Di8_Do8_Lut8_G16_LO);
													break;
												case 32:											/* 3 -> 4		Di 8		Do 8		Lut 8		Grid 32		*/
													proc2call = NewCalcProc(LHCalc3to4_Di8_Do8_Lut8_G32_LO);
													break;
											}
											break;
										case 16:													/* 3 -> 4		Di 8		Do 8		Lut 16					*/
											switch (lutParam->colorLutGridPoints)
											{
												case 16:											/* 3 -> 4		Di 8		Do 8		Lut 16		Grid 16		*/
													proc2call = NewCalcProc(LHCalc3to4_Di8_Do8_Lut16_G16_LO);
													break;
												case 32:											/* 3 -> 4		Di 8		Do 8		Lut 16		Grid 32		*/
													proc2call = NewCalcProc(LHCalc3to4_Di8_Do8_Lut16_G32_LO);
													break;
											}
											break;
									}
									break;
								case 16:															/* 3 -> 4		Di 8		Do 16								*/
#if LH_CALC_ENGINE_MIXED_DATAFORMAT
									switch (lutParam->colorLutWordSize)
									{
										case 8:														/* 3 -> 4		Di 8		Do 16		Lut 8					*/
											switch (lutParam->colorLutGridPoints)
											{
												case 16:											/* 3 -> 4		Di 8		Do 16		Lut 8		Grid 16		*/
													proc2call = NewCalcProc(LHCalc3to4_Di8_Do16_Lut8_G16_LO);
													break;
												case 32:											/* 3 -> 4		Di 8		Do 16		Lut 8		Grid 32		*/
													proc2call = NewCalcProc(LHCalc3to4_Di8_Do16_Lut8_G32_LO);
													break;
											}
											break;
										case 16:													/* 3 -> 4		Di 8		Do 16		Lut 16					*/
											switch (lutParam->colorLutGridPoints)
											{
												case 16:											/* 3 -> 4		Di 8		Do 16		Lut 16		Grid 16		*/
													proc2call = NewCalcProc(LHCalc3to4_Di8_Do16_Lut16_G16_LO);
													break;
												case 32:											/* 3 -> 4		Di 8		Do 16		Lut 16		Grid 32		*/
													proc2call = NewCalcProc(LHCalc3to4_Di8_Do16_Lut16_G32_LO);
													break;
											}
											break;
									}
#endif
									break;
							}
							break;
						case 16:																	/* 3 -> 4		Di 16											*/
							switch (info->usedSizeOut)
							{
								case 8:																/* 3 -> 4		Di 16		Do 8								*/
#if LH_CALC_ENGINE_MIXED_DATAFORMAT
									switch (lutParam->colorLutWordSize)
									{
										case 8:														/* 3 -> 4		Di 16		Do 8		Lut 8					*/
											switch (lutParam->colorLutGridPoints)
											{
												case 16:											/* 3 -> 4		Di 16		Do 8		Lut 8		Grid 16		*/
													proc2call = NewCalcProc(LHCalc3to4_Di16_Do8_Lut8_G16_LO);
													break;
												case 32:											/* 3 -> 4		Di 16		Do 8		Lut 8		Grid 32		*/
													proc2call = NewCalcProc(LHCalc3to4_Di16_Do8_Lut8_G32_LO);
													break;
											}
											break;
										case 16:													/* 3 -> 4		Di 16		Do 8		Lut 16					*/
											switch (lutParam->colorLutGridPoints)
											{
												case 16:											/* 3 -> 4		Di 16		Do 8		Lut 16		Grid 16		*/
													proc2call = NewCalcProc(LHCalc3to4_Di16_Do8_Lut16_G16_LO);
													break;
												case 32:											/* 3 -> 4		Di 16		Do 8		Lut 16		Grid 32		*/
													proc2call = NewCalcProc(LHCalc3to4_Di16_Do8_Lut16_G32_LO);
													break;
											}
											break;
									}
#endif
									break;
								case 16:															/* 3 -> 4		Di 16		Do 16								*/
#if LH_CALC_ENGINE_16_BIT_LO
									switch (lutParam->colorLutWordSize)
									{
										case 8:														/* 3 -> 4		Di 16		Do 16		Lut 8					*/
											switch (lutParam->colorLutGridPoints)
											{
												case 16:											/* 3 -> 4		Di 16		Do 16		Lut 8		Grid 16		*/
													proc2call = NewCalcProc(LHCalc3to4_Di16_Do16_Lut8_G16_LO);
													break;
												case 32:											/* 3 -> 4		Di 16		Do 16		Lut 8		Grid 32		*/
													proc2call = NewCalcProc(LHCalc3to4_Di16_Do16_Lut8_G32_LO);
													break;
											}
											break;
										case 16:													/* 3 -> 4		Di 16		Do 16		Lut 16					*/
											switch (lutParam->colorLutGridPoints)
											{
												case 16:											/* 3 -> 4		Di 16		Do 16		Lut 16		Grid 16		*/
													proc2call = NewCalcProc(LHCalc3to4_Di16_Do16_Lut16_G16_LO);
													break;
												case 32:											/* 3 -> 4		Di 16		Do 16		Lut 16		Grid 32		*/
													proc2call = NewCalcProc(LHCalc3to4_Di16_Do16_Lut16_G32_LO);
													break;
											}
											break;
									}
#endif
									break;
							}
							break;
					}
					break;
#endif
			}
			break;
#if LH_CALC_ENGINE_ALL_FORMATS_LO
		case 4:																						/* 4 ->															*/
			switch ( lutParam->colorLutOutDim )
			{
				case 3:																				/* 4 ->	3														*/
					switch (info->usedSizeIn)
					{
						case 8:																		/* 4 -> 3		Di 8											*/
							switch (info->usedSizeOut)
							{
								case 8:																/* 4 -> 3		Di 8		Do 8								*/
									switch (lutParam->colorLutWordSize)
									{
										case 8:														/* 4 -> 3		Di 8		Do 8		Lut 8					*/
											switch (lutParam->colorLutGridPoints)
											{
												case 8:												/* 4 -> 3		Di 8		Do 8		Lut 8		Grid 8		*/
													proc2call = NewCalcProc(LHCalc4to3_Di8_Do8_Lut8_G8_LO);
													break;
												case 16:											/* 4 -> 3		Di 8		Do 8		Lut 8		Grid 16		*/
													proc2call = NewCalcProc(LHCalc4to3_Di8_Do8_Lut8_G16_LO);
													break;
											}
											break;
										case 16:													/* 4 -> 3		Di 8		Do 8		Lut 16					*/
											switch (lutParam->colorLutGridPoints)
											{
												case 8:												/* 4 -> 3		Di 8		Do 8		Lut 16		Grid 8		*/
													proc2call = NewCalcProc(LHCalc4to3_Di8_Do8_Lut16_G8_LO);
													break;
												case 16:											/* 4 -> 3		Di 8		Do 8		Lut 16		Grid 16		*/
													proc2call = NewCalcProc(LHCalc4to3_Di8_Do8_Lut16_G16_LO);
													break;
											}
											break;
									}
									break;
								case 16:															/* 4 -> 3		Di 8		Do 16								*/
#if LH_CALC_ENGINE_MIXED_DATAFORMAT
									switch (lutParam->colorLutWordSize)
									{
										case 8:														/* 4 -> 3		Di 8		Do 16		Lut 8					*/
											switch (lutParam->colorLutGridPoints)
											{
												case 8:												/* 4 -> 3		Di 8		Do 16		Lut 8		Grid 8		*/
													proc2call = NewCalcProc(LHCalc4to3_Di8_Do16_Lut8_G8_LO);
													break;
												case 16:											/* 4 -> 3		Di 8		Do 16		Lut 8		Grid 16		*/
													proc2call = NewCalcProc(LHCalc4to3_Di8_Do16_Lut8_G16_LO);
													break;
											}
											break;
										case 16:													/* 4 -> 3		Di 8		Do 16		Lut 16					*/
											switch (lutParam->colorLutGridPoints)
											{
												case 8:												/* 4 -> 3		Di 8		Do 16		Lut 16		Grid 8		*/
													proc2call = NewCalcProc(LHCalc4to3_Di8_Do16_Lut16_G8_LO);
													break;
												case 16:											/* 4 -> 3		Di 8		Do 16		Lut 16		Grid 16		*/
													proc2call = NewCalcProc(LHCalc4to3_Di8_Do16_Lut16_G16_LO);
													break;
											}
											break;
									}
#endif
									break;
							}
							break;
						case 16:																	/* 4 -> 3		Di 16											*/
							switch (info->usedSizeOut)
							{
								case 8:																/* 4 -> 3		Di 16		Do 8								*/
#if LH_CALC_ENGINE_MIXED_DATAFORMAT
									switch (lutParam->colorLutWordSize)
									{
										case 8:														/* 4 -> 3		Di 16		Do 8		Lut 8					*/
											switch (lutParam->colorLutGridPoints)
											{
												case 8:												/* 4 -> 3		Di 16		Do 8		Lut 8		Grid 8		*/
													proc2call = NewCalcProc(LHCalc4to3_Di16_Do8_Lut8_G8_LO);
													break;
												case 16:											/* 4 -> 3		Di 16		Do 8		Lut 8		Grid 16		*/
													proc2call = NewCalcProc(LHCalc4to3_Di16_Do8_Lut8_G16_LO);
													break;
											}
											break;
										case 16:													/* 4 -> 3		Di 16		Do 8		Lut 16					*/
											switch (lutParam->colorLutGridPoints)
											{
												case 8:												/* 4 -> 3		Di 16		Do 8		Lut 16		Grid 8		*/
													proc2call = NewCalcProc(LHCalc4to3_Di16_Do8_Lut16_G8_LO);
													break;
												case 16:											/* 4 -> 3		Di 16		Do 8		Lut 16		Grid 16		*/
													proc2call = NewCalcProc(LHCalc4to3_Di16_Do8_Lut16_G16_LO);
													break;
											}
											break;
									}
#endif
									break;
								case 16:															/* 4 -> 3		Di 16		Do 16								*/
#if LH_CALC_ENGINE_16_BIT_LO
									switch (lutParam->colorLutWordSize)
									{
										case 8:														/* 4 -> 3		Di 16		Do 16		Lut 8					*/
											switch (lutParam->colorLutGridPoints)
											{
												case 8:												/* 4 -> 3		Di 16		Do 16		Lut 8		Grid 8		*/
													proc2call = NewCalcProc(LHCalc4to3_Di16_Do16_Lut8_G8_LO);
													break;
												case 16:											/* 4 -> 3		Di 16		Do 16		Lut 8		Grid 16		*/
													proc2call = NewCalcProc(LHCalc4to3_Di16_Do16_Lut8_G16_LO);
													break;
											}
											break;
										case 16:													/* 4 -> 3		Di 16		Do 16		Lut 16					*/
											switch (lutParam->colorLutGridPoints)
											{
												case 8:												/* 4 -> 3		Di 16		Do 16		Lut 16		Grid 8		*/
													proc2call = NewCalcProc(LHCalc4to3_Di16_Do16_Lut16_G8_LO);
													break;
												case 16:											/* 4 -> 3		Di 16		Do 16		Lut 16		Grid 16		*/
													proc2call = NewCalcProc(LHCalc4to3_Di16_Do16_Lut16_G16_LO);
													break;
											}
											break;
									}
#endif
									break;
							}
							break;
					}
					break;
				case 4:																				/* 4 -> 4														*/
					switch (info->usedSizeIn)
					{
						case 8:																		/* 4 -> 4		Di 8											*/
							switch (info->usedSizeOut)
							{
								case 8:																/* 4 -> 4		Di 8		Do 8								*/
									switch (lutParam->colorLutWordSize)
									{
										case 8:														/* 4 -> 4		Di 8		Do 8		Lut 8					*/
											switch (lutParam->colorLutGridPoints)
											{
												case 8:												/* 4 -> 4		Di 8		Do 8		Lut 8		Grid 8		*/
													proc2call = NewCalcProc(LHCalc4to4_Di8_Do8_Lut8_G8_LO);
													break;
												case 16:											/* 4 -> 4		Di 8		Do 8		Lut 8		Grid 16		*/
													proc2call = NewCalcProc(LHCalc4to4_Di8_Do8_Lut8_G16_LO);
													break;
											}
											break;
										case 16:													/* 4 -> 4		Di 8		Do 8		Lut 16					*/
											switch (lutParam->colorLutGridPoints)
											{
												case 8:												/* 4 -> 4		Di 8		Do 8		Lut 16		Grid 8		*/
													proc2call = NewCalcProc(LHCalc4to4_Di8_Do8_Lut16_G8_LO);
													break;
												case 16:											/* 4 -> 4		Di 8		Do 8		Lut 16		Grid 16		*/
													proc2call = NewCalcProc(LHCalc4to4_Di8_Do8_Lut16_G16_LO);
													break;
											}
											break;
									}
									break;
								case 16:															/* 4 -> 4		Di 8		Do 16								*/
#if LH_CALC_ENGINE_MIXED_DATAFORMAT
									switch (lutParam->colorLutWordSize)
									{
										case 8:														/* 4 -> 4		Di 8		Do 16		Lut 8					*/
											switch (lutParam->colorLutGridPoints)
											{
												case 8:												/* 4 -> 4		Di 8		Do 16		Lut 8		Grid 8		*/
													proc2call = NewCalcProc(LHCalc4to4_Di8_Do16_Lut8_G8_LO);
													break;
												case 16:											/* 4 -> 4		Di 8		Do 16		Lut 8		Grid 16		*/
													proc2call = NewCalcProc(LHCalc4to4_Di8_Do16_Lut8_G16_LO);
													break;
											}
											break;
										case 16:													/* 4 -> 4		Di 8		Do 16		Lut 16					*/
											switch (lutParam->colorLutGridPoints)
											{
												case 8:												/* 4 -> 4		Di 8		Do 16		Lut 16		Grid 8		*/
													proc2call = NewCalcProc(LHCalc4to4_Di8_Do16_Lut16_G8_LO);
													break;
												case 16:											/* 4 -> 4		Di 8		Do 16		Lut 16		Grid 16		*/
													proc2call = NewCalcProc(LHCalc4to4_Di8_Do16_Lut16_G16_LO);
													break;
											}
											break;
									}
#endif
									break;
							}
							break;
						case 16:																	/* 4 -> 4		Di 16											*/
							switch (info->usedSizeOut)
							{
								case 8:																/* 4 -> 4		Di 16		Do 8								*/
#if LH_CALC_ENGINE_MIXED_DATAFORMAT
									switch (lutParam->colorLutWordSize)
									{
										case 8:														/* 4 -> 4		Di 16		Do 8		Lut 8					*/
											switch (lutParam->colorLutGridPoints)
											{
												case 8:												/* 4 -> 4		Di 16		Do 8		Lut 8		Grid 8		*/
													proc2call = NewCalcProc(LHCalc4to4_Di16_Do8_Lut8_G8_LO);
													break;
												case 16:											/* 4 -> 4		Di 16		Do 8		Lut 8		Grid 16		*/
													proc2call = NewCalcProc(LHCalc4to4_Di16_Do8_Lut8_G16_LO);
													break;
											}
											break;
										case 16:													/* 4 -> 4		Di 16		Do 8		Lut 16					*/
											switch (lutParam->colorLutGridPoints)
											{
												case 8:												/* 4 -> 4		Di 16		Do 8		Lut 16		Grid 8		*/
													proc2call = NewCalcProc(LHCalc4to4_Di16_Do8_Lut16_G8_LO);
													break;
												case 16:											/* 4 -> 4		Di 16		Do 8		Lut 16		Grid 16		*/
													proc2call = NewCalcProc(LHCalc4to4_Di16_Do8_Lut16_G16_LO);
													break;
											}
											break;
									}
#endif
									break;
								case 16:															/* 4 -> 4		Di 16		Do 16								*/
#if LH_CALC_ENGINE_16_BIT_LO
									switch (lutParam->colorLutWordSize)
									{
										case 8:														/* 4 -> 4		Di 16		Do 16		Lut 8					*/
											switch (lutParam->colorLutGridPoints)
											{
												case 8:												/* 4 -> 4		Di 16		Do 16		Lut 8		Grid 8		*/
													proc2call = NewCalcProc(LHCalc4to4_Di16_Do16_Lut8_G8_LO);
													break;
												case 16:											/* 4 -> 4		Di 16		Do 16		Lut 8		Grid 16		*/
													proc2call = NewCalcProc(LHCalc4to4_Di16_Do16_Lut8_G16_LO);
													break;
											}
											break;
										case 16:													/* 4 -> 4		Di 16		Do 16		Lut 16					*/
											switch (lutParam->colorLutGridPoints)
											{
												case 8:												/* 4 -> 4		Di 16		Do 16		Lut 16		Grid 8		*/
													proc2call = NewCalcProc(LHCalc4to4_Di16_Do16_Lut16_G8_LO);
													break;
												case 16:											/* 4 -> 4		Di 16		Do 16		Lut 16		Grid 16		*/
													proc2call = NewCalcProc(LHCalc4to4_Di16_Do16_Lut16_G16_LO);
													break;
											}
											break;
									}
#endif
									break;
							}
							break;
					}
					break;
			}
			break;
#endif
	}

	LH_END_PROC("FindLookupRoutine")
	return proc2call;
}

#ifdef ALLOW_MMX
#define cpuid   __asm _emit 0x0F __asm _emit 0xA2

#define CPUID_FLAG		0x00200000
#define MMX_FLAG		0x00800000
#define FAMILY_5_FLAG	0x00000500 /* Pentium, not Pentium II */
#define FAMILY_MASK		0x00000F00

/*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
*                                                                    *
*                                                                    *
*   DetectMMX                                                        *
*                                                                    *
*   Inputs   : none                                                  *
*                                                                    *
*   Outputs  : TRUE - CPU has MMX                                    *
*                                                                    *
*   Abstract : This function detects existance of MMX-Technology.    *
*                                                                    *
*                                                                    *
*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/

static LH_UINT32 DetectMMX (void)
{
    LH_UINT32    fMMX = FALSE;

    __asm {

            push    edx             ; 
            push    ebx             ; 
			push    eax             ; 
            pushfd                  ; Push flags on stack
            pop     eax             ; and get flags into eax
            xor     eax, CPUID_FLAG ; Toggle CPUID flag
            push    eax             ; Move flags back into
            popfd                   ; flags reg
            pushfd                  ; Get flags into ebx
            pop     ebx
            and     ebx, CPUID_FLAG ; Mask CPUID flag
            and     eax, CPUID_FLAG
            cmp     eax, ebx        ; Test toggled bit
            jnz     Done            ; CPU does not support CPUID

            mov     eax, 1          ; Set CPUID mode
            cpuid
            test    edx, MMX_FLAG   ; Check MMX-Technology bit
            jz      Done            ; CPU has no MMX-Technology
			and		eax, FAMILY_MASK	; mask out family bits
            cmp     eax, FAMILY_5_FLAG	; Check Family 5 bits
            jnz     Done            ; CPU has no MMX-Technology

            mov     fMMX, TRUE      ; CPU has MMX-Technology
Done:
            ;pushfd                        ; dummy
			pop     eax             ;
            pop     ebx             ; 
            pop     edx             ; 
   }

    return (fMMX);
}

#endif
/*--------------------------------------------------------------------------------------------------------------
	FindCalcRoutine
  --------------------------------------------------------------------------------------------------------------*/
CalcProcPtr
FindCalcRoutine(	const CMCalcParam*		calcParam,
					const CMLutParam*		lutParam,
					const ColorSpaceInfo*	info,
					const Boolean			lookupOnly )
{
 	SINT32			index 		= 0;
	CalcProcPtr		proc2call	= nil;
#ifdef DEBUG_OUTPUT
	CMError err = noErr;
#endif
	
	LH_START_PROC("FindCalcRoutine")

	calcParam  = calcParam;
/* to reduce the code size change the next line to 0 - this will call DoNDim instead of the optimized functions */
#if 1
	if (lookupOnly)
		proc2call = FindLookupRoutine(lutParam, info);
	if (proc2call == nil)
	{
		switch ( lutParam->colorLutInDim )
		{
			case 1:																						/* 1 ->															*/
				switch ( lutParam->colorLutOutDim )
				{
					case 1:																				/* 1 -> 1,3,4														*/
					case 3:																				/* 1 -> 1,3,4													*/
					case 4:																				/* 1 -> 1,3,4													*/
						switch (info->usedSizeIn)
						{	
							case 8:																		/* 1 -> 1,3,4	Di 8                     						*/
								switch (info->usedSizeOut)
								{
									case 8:																/* 1 -> 1,3,4	Di 8		Do 8								*/
										switch (lutParam->colorLutWordSize)
										{
											case 8:														/* 1 -> 1,3,4	Di 8		Do 8		Lut 8					*/
												switch (lutParam->colorLutGridPoints)
												{
#if LH_Calc1toX_Di8_Do8_Lut8_G128 != LH_CALC_USE_DO_N_DIM
													case 128:											/* 1 -> 1,3,4	Di 8		Do 8		Lut 8		Grid 16		*/
														proc2call = NewCalcProc(LHCalc1toX_Di8_Do8_Lut8_G128);
														break;
#endif
												}
												break;
											case 16:													/* 1 -> 1,3,4	Di 8		Do 8		Lut 16					*/			
												switch (lutParam->colorLutGridPoints)
												{
#if LH_Calc1toX_Di8_Do8_Lut16_G128 != LH_CALC_USE_DO_N_DIM
													case 128:											/* 1 -> 1,3,4	Di 8		Do 8		Lut 16		Grid 16		*/
														proc2call = NewCalcProc(LHCalc1toX_Di8_Do8_Lut16_G128);
														break;
#endif
												}
												break;
										}
										break;
									case 16:															/* 1 -> 1,3,4	Di 8		Do 16								*/
										switch (lutParam->colorLutWordSize)
										{
											case 8:														/* 1 -> 1,3,4	Di 8		Do 8		Lut 8					*/
												switch (lutParam->colorLutGridPoints)
												{
#if LH_Calc1toX_Di8_Do16_Lut8_G128 != LH_CALC_USE_DO_N_DIM
													case 128:											/* 1 -> 1,3,4	Di 8		Do 8		Lut 8		Grid 16		*/
														proc2call = NewCalcProc(LHCalc1toX_Di8_Do16_Lut8_G128);
														break;
#endif
												}
												break;
											case 16:													/* 1 -> 1,3,4	Di 8		Do 8		Lut 16					*/			
												switch (lutParam->colorLutGridPoints)
												{
#if LH_Calc1toX_Di8_Do16_Lut16_G128 != LH_CALC_USE_DO_N_DIM
													case 128:											/* 1 -> 1,3,4	Di 8		Do 8		Lut 16		Grid 16		*/
														proc2call = NewCalcProc(LHCalc1toX_Di8_Do16_Lut16_G128);
														break;
#endif
												}
												break;
										}
										break;
								}
								break;
							case 16:																	/* 1 -> 1,3,4	Di 16                    						*/
								switch (info->usedSizeOut)
								{
									case 8:																/* 1 -> 1,3,4	Di 8		Do 8								*/
										switch (lutParam->colorLutWordSize)
										{
											case 8:														/* 1 -> 1,3,4	Di 8		Do 8		Lut 8					*/
												switch (lutParam->colorLutGridPoints)
												{
#if LH_Calc1toX_Di16_Do8_Lut8_G128 != LH_CALC_USE_DO_N_DIM
													case 128:											/* 1 -> 1,3,4	Di 8		Do 8		Lut 8		Grid 16		*/
														proc2call = NewCalcProc(LHCalc1toX_Di16_Do8_Lut8_G128);
														break;
#endif
												}
												break;
											case 16:													/* 1 -> 1,3,4	Di 8		Do 8		Lut 16					*/			
												switch (lutParam->colorLutGridPoints)
												{
#if LH_Calc1toX_Di16_Do8_Lut16_G128 != LH_CALC_USE_DO_N_DIM
													case 128:											/* 1 -> 1,3,4	Di 8		Do 8		Lut 16		Grid 16		*/
														proc2call = NewCalcProc(LHCalc1toX_Di16_Do8_Lut16_G128);
														break;
#endif
												}
												break;
										}
										break;
									case 16:															/* 1 -> 1,3,4	Di 8		Do 16								*/
										switch (lutParam->colorLutWordSize)
										{
											case 8:														/* 1 -> 1,3,4	Di 8		Do 8		Lut 8					*/
												switch (lutParam->colorLutGridPoints)
												{
#if LH_Calc1toX_Di16_Do16_Lut8_G128 != LH_CALC_USE_DO_N_DIM
													case 128:											/* 1 -> 1,3,4	Di 8		Do 8		Lut 8		Grid 16		*/
														proc2call = NewCalcProc(LHCalc1toX_Di16_Do16_Lut8_G128);
														break;
#endif
												}
												break;
											case 16:													/* 1 -> 1,3,4	Di 8		Do 8		Lut 16					*/			
												switch (lutParam->colorLutGridPoints)
												{
#if LH_Calc1toX_Di16_Do16_Lut16_G128 != LH_CALC_USE_DO_N_DIM
													case 128:											/* 1 -> 1,3,4	Di 8		Do 8		Lut 16		Grid 16		*/
														proc2call = NewCalcProc(LHCalc1toX_Di16_Do16_Lut16_G128);
														break;
#endif
												}
												break;
										}
										break;
								}
								break;
						}
						break;
					}
					break;
			case 3:																						/* 3 ->															*/
				switch ( lutParam->colorLutOutDim )
				{
					case 3:																				/* 3 -> 3														*/
						switch (info->usedSizeIn)
						{	
							case 8:																		/* 3 -> 3		Di 8                     						*/
								switch (info->usedSizeOut)
								{
									case 8:																/* 3 -> 3		Di 8		Do 8								*/
										switch (lutParam->colorLutWordSize)
										{
											case 8:														/* 3 -> 3		Di 8		Do 8		Lut 8					*/
												switch (lutParam->colorLutGridPoints)
												{
#if LH_Calc3to3_Di8_Do8_Lut8_G16 != LH_CALC_USE_DO_N_DIM
													case 16:											/* 3 -> 3		Di 8		Do 8		Lut 8		Grid 16		*/
#ifdef ALLOW_MMX
                                                        if (DetectMMX()) {
														    proc2call = NewCalcProc(LHCalc3to3_Di8_Do8_Lut8_G16_F);
                                                        }
                                                        else
#endif
#if LH_CALC_USE_ADDITIONAL_OLD_CODE
														if( !info->inPlace ){
														    proc2call = NewCalcProc(LHCalc3to3_Di8_Do8_Lut8_G16_Old);
														}
														else
#endif
    														proc2call = NewCalcProc(LHCalc3to3_Di8_Do8_Lut8_G16);
														break;
#endif
#if LH_Calc3to3_Di8_Do8_Lut8_G32 != LH_CALC_USE_DO_N_DIM
													case 32:											/* 3 -> 3		Di 8		Do 8		Lut 8		Grid 32		*/
#ifdef ALLOW_MMX
                                                        if (DetectMMX()) {
														    proc2call = NewCalcProc(LHCalc3to3_Di8_Do8_Lut8_G32_F);
                                                        }
                                                        else
#endif
#if LH_CALC_USE_ADDITIONAL_OLD_CODE
														if( !info->inPlace ){
														    proc2call = NewCalcProc(LHCalc3to3_Di8_Do8_Lut8_G32_Old);
														}
														else
#endif
    														proc2call = NewCalcProc(LHCalc3to3_Di8_Do8_Lut8_G32);
														break;
#endif
												}
												break;
											case 16:													/* 3 -> 3		Di 8		Do 8		Lut 16					*/			
												switch (lutParam->colorLutGridPoints)
												{
#if LH_Calc3to3_Di8_Do8_Lut16_G16 != LH_CALC_USE_DO_N_DIM
													case 16:											/* 3 -> 3		Di 8		Do 8		Lut 16		Grid 16		*/
														proc2call = NewCalcProc(LHCalc3to3_Di8_Do8_Lut16_G16);
														break;
#endif
#if LH_Calc3to3_Di8_Do8_Lut16_G32 != LH_CALC_USE_DO_N_DIM
													case 32:											/* 3 -> 3		Di 8		Do 8		Lut 16		Grid 32		*/
														proc2call = NewCalcProc(LHCalc3to3_Di8_Do8_Lut16_G32);
														break;
#endif
												}
												break;
										}
										break;
									case 16:															/* 3 -> 3		Di 8		Do 16								*/
										switch (lutParam->colorLutWordSize)
										{
											case 8:														/* 3 -> 3		Di 8		Do 16		Lut 8					*/
												switch (lutParam->colorLutGridPoints)
												{
#if LH_Calc3to3_Di8_Do16_Lut8_G16 != LH_CALC_USE_DO_N_DIM
													case 16:											/* 3 -> 3		Di 8		Do 16		Lut 8		Grid 16		*/
														proc2call = NewCalcProc(LHCalc3to3_Di8_Do16_Lut8_G16);
														break;
#endif
#if LH_Calc3to3_Di8_Do16_Lut8_G32 != LH_CALC_USE_DO_N_DIM
													case 32:											/* 3 -> 3		Di 8		Do 16		Lut 8		Grid 32		*/
														proc2call = NewCalcProc(LHCalc3to3_Di8_Do16_Lut8_G32);
														break;
#endif
												}
												break;
											case 16:													/* 3 -> 3		Di 8		Do 16		Lut 16					*/
												switch (lutParam->colorLutGridPoints)
												{
#if LH_Calc3to3_Di8_Do16_Lut16_G16 != LH_CALC_USE_DO_N_DIM
													case 16:											/* 3 -> 3		Di 8		Do 16		Lut 16		Grid 16		*/
														proc2call = NewCalcProc(LHCalc3to3_Di8_Do16_Lut16_G16);
														break;
#endif
#if LH_Calc3to3_Di8_Do16_Lut16_G32 != LH_CALC_USE_DO_N_DIM
													case 32:											/* 3 -> 3		Di 8		Do 16		Lut 16		Grid 32		*/
														proc2call = NewCalcProc(LHCalc3to3_Di8_Do16_Lut16_G32);
														break;
#endif
												}
												break;
										}
										break;
								}
								break;
							case 16:																	/* 3 -> 3		Di 16                    						*/
								switch (info->usedSizeOut)
								{
									case 8:																/* 3 -> 3		Di 16		Do 8								*/
										switch (lutParam->colorLutWordSize)
										{
											case 8:														/* 3 -> 3		Di 16		Do 8		Lut 8					*/
												switch (lutParam->colorLutGridPoints)
												{
#if LH_Calc3to3_Di16_Do8_Lut8_G16 != LH_CALC_USE_DO_N_DIM
													case 16:											/* 3 -> 3		Di 16		Do 8		Lut 8		Grid 16		*/
														proc2call = NewCalcProc(LHCalc3to3_Di16_Do8_Lut8_G16);
														break;
#endif
#if LH_Calc3to3_Di16_Do8_Lut8_G32 != LH_CALC_USE_DO_N_DIM
													case 32:											/* 3 -> 3		Di 16		Do 8		Lut 8		Grid 32		*/
														proc2call = NewCalcProc(LHCalc3to3_Di16_Do8_Lut8_G32);
														break;
#endif
												}
												break;
											case 16:													/* 3 -> 3		Di 16		Do 8		Lut 16					*/
												switch (lutParam->colorLutGridPoints)
												{
#if LH_Calc3to3_Di16_Do8_Lut16_G16 != LH_CALC_USE_DO_N_DIM
													case 16:											/* 3 -> 3		Di 16		Do 8		Lut 16		Grid 16		*/
														proc2call = NewCalcProc(LHCalc3to3_Di16_Do8_Lut16_G16);
														break;
#endif
#if LH_Calc3to3_Di16_Do8_Lut16_G32 != LH_CALC_USE_DO_N_DIM
													case 32:											/* 3 -> 3		Di 16		Do 8		Lut 16		Grid 32		*/
														proc2call = NewCalcProc(LHCalc3to3_Di16_Do8_Lut16_G32);
														break;
#endif
												}
												break;
										}
										break;
									case 16:															/* 3 -> 3		Di 16		Do 16								*/
										switch (lutParam->colorLutWordSize)
										{
											case 8:														/* 3 -> 3		Di 16		Do 16		Lut 8					*/
												switch (lutParam->colorLutGridPoints)
												{
#if LH_Calc3to3_Di16_Do16_Lut8_G16 != LH_CALC_USE_DO_N_DIM
													case 16:											/* 3 -> 3		Di 16		Do 16		Lut 8		Grid 16		*/
														proc2call = NewCalcProc(LHCalc3to3_Di16_Do16_Lut8_G16);
														break;
#endif
#if LH_Calc3to3_Di16_Do16_Lut8_G32 != LH_CALC_USE_DO_N_DIM
													case 32:											/* 3 -> 3		Di 16		Do 16		Lut 8		Grid 32		*/
														proc2call = NewCalcProc(LHCalc3to3_Di16_Do16_Lut8_G32);
														break;
#endif
												}
												break;
											case 16:													/* 3 -> 3		Di 16		Do 16		Lut 16					*/
												switch (lutParam->colorLutGridPoints)
												{
#if LH_Calc3to3_Di16_Do16_Lut16_G16 != LH_CALC_USE_DO_N_DIM
													case 16:											/* 3 -> 3		Di 16		Do 16		Lut 16		Grid 16		*/
														proc2call = NewCalcProc(LHCalc3to3_Di16_Do16_Lut16_G16);
														break;
#endif
#if LH_Calc3to3_Di16_Do16_Lut16_G32 != LH_CALC_USE_DO_N_DIM
													case 32:											/* 3 -> 3		Di 16		Do 16		Lut 16		Grid 32		*/
														proc2call = NewCalcProc(LHCalc3to3_Di16_Do16_Lut16_G32);
														break;
#endif
												}
												break;
										}
										break;
								}
								break;
						}
						break;
					case 4:																				/* 3 -> 4														*/
						switch (info->usedSizeIn)
						{
							case 8:																		/* 3 -> 4		Di 8											*/
								switch (info->usedSizeOut)
								{
									case 8:																/* 3 -> 4		Di 8		Do 8								*/
										switch (lutParam->colorLutWordSize)
										{
											case 8:														/* 3 -> 4		Di 8		Do 8		Lut 8					*/
												switch (lutParam->colorLutGridPoints)
												{
#if LH_Calc3to4_Di8_Do8_Lut8_G16 != LH_CALC_USE_DO_N_DIM
													case 16:											/* 3 -> 4		Di 8		Do 8		Lut 8		Grid 16		*/
#ifdef ALLOW_MMX
                                                        if (DetectMMX()) {
														    proc2call = NewCalcProc(LHCalc3to4_Di8_Do8_Lut8_G16_F);
                                                        }
                                                        else
#endif
#if LH_CALC_USE_ADDITIONAL_OLD_CODE
														if( !info->inPlace ){
														    proc2call = NewCalcProc(LHCalc3to4_Di8_Do8_Lut8_G16_Old);
														}
														else
#endif
															proc2call = NewCalcProc(LHCalc3to4_Di8_Do8_Lut8_G16);
														break;
#endif
#if LH_Calc3to4_Di8_Do8_Lut8_G32 != LH_CALC_USE_DO_N_DIM
													case 32:											/* 3 -> 4		Di 8		Do 8		Lut 8		Grid 32		*/
#ifdef ALLOW_MMX
                                                        if (DetectMMX()) {
														    proc2call = NewCalcProc(LHCalc3to4_Di8_Do8_Lut8_G32_F);
                                                        }
                                                        else
#endif
#if LH_CALC_USE_ADDITIONAL_OLD_CODE
														if( !info->inPlace ){
														    proc2call = NewCalcProc(LHCalc3to4_Di8_Do8_Lut8_G32_Old);
														}
														else
#endif
															proc2call = NewCalcProc(LHCalc3to4_Di8_Do8_Lut8_G32);
														break;
#endif
												}
												break;
											case 16:													/* 3 -> 4		Di 8		Do 8		Lut 16					*/
												switch (lutParam->colorLutGridPoints)
												{
#if LH_Calc3to4_Di8_Do8_Lut16_G16 != LH_CALC_USE_DO_N_DIM
													case 16:											/* 3 -> 4		Di 8		Do 8		Lut 16		Grid 16		*/
														proc2call = NewCalcProc(LHCalc3to4_Di8_Do8_Lut16_G16);
														break;
#endif
#if LH_Calc3to4_Di8_Do8_Lut16_G32 != LH_CALC_USE_DO_N_DIM
													case 32:											/* 3 -> 4		Di 8		Do 8		Lut 16		Grid 32		*/
														proc2call = NewCalcProc(LHCalc3to4_Di8_Do8_Lut16_G32);
														break;
#endif
												}
												break;
										}
										break;
									case 16:															/* 3 -> 4		Di 8		Do 16								*/
										switch (lutParam->colorLutWordSize)
										{
											case 8:														/* 3 -> 4		Di 8		Do 16		Lut 8					*/
												switch (lutParam->colorLutGridPoints)
												{
#if LH_Calc3to4_Di8_Do16_Lut8_G16 != LH_CALC_USE_DO_N_DIM
													case 16:											/* 3 -> 4		Di 8		Do 16		Lut 8		Grid 16		*/
														proc2call = NewCalcProc(LHCalc3to4_Di8_Do16_Lut8_G16);
														break;
#endif
#if LH_Calc3to4_Di8_Do16_Lut8_G32 != LH_CALC_USE_DO_N_DIM
													case 32:											/* 3 -> 4		Di 8		Do 16		Lut 8		Grid 32		*/
														proc2call = NewCalcProc(LHCalc3to4_Di8_Do16_Lut8_G32);
														break;
#endif
												}
												break;
											case 16:													/* 3 -> 4		Di 8		Do 16		Lut 16					*/
												switch (lutParam->colorLutGridPoints)
												{
#if LH_Calc3to4_Di8_Do16_Lut16_G16 != LH_CALC_USE_DO_N_DIM
													case 16:											/* 3 -> 4		Di 8		Do 16		Lut 16		Grid 16		*/
														proc2call = NewCalcProc(LHCalc3to4_Di8_Do16_Lut16_G16);
														break;
#endif
#if LH_Calc3to4_Di8_Do16_Lut16_G32 != LH_CALC_USE_DO_N_DIM
													case 32:											/* 3 -> 4		Di 8		Do 16		Lut 16		Grid 32		*/
														proc2call = NewCalcProc(LHCalc3to4_Di8_Do16_Lut16_G32);
														break;
#endif
												}
												break;
										}
										break;
								}
								break;
							case 16:																	/* 3 -> 4		Di 16											*/
								switch (info->usedSizeOut)
								{
									case 8:																/* 3 -> 4		Di 16		Do 8								*/
										switch (lutParam->colorLutWordSize)
										{
											case 8:														/* 3 -> 4		Di 16		Do 8		Lut 8					*/
												switch (lutParam->colorLutGridPoints)
												{
#if LH_Calc3to4_Di16_Do8_Lut8_G16 != LH_CALC_USE_DO_N_DIM
													case 16:											/* 3 -> 4		Di 16		Do 8		Lut 8		Grid 16		*/
														proc2call = NewCalcProc(LHCalc3to4_Di16_Do8_Lut8_G16);
														break;
#endif
#if LH_Calc3to4_Di16_Do8_Lut8_G32 != LH_CALC_USE_DO_N_DIM
													case 32:											/* 3 -> 4		Di 16		Do 8		Lut 8		Grid 32		*/
														proc2call = NewCalcProc(LHCalc3to4_Di16_Do8_Lut8_G32);
														break;
#endif
												}
												break;
											case 16:													/* 3 -> 4		Di 16		Do 8		Lut 16					*/
												switch (lutParam->colorLutGridPoints)
												{
#if LH_Calc3to4_Di16_Do8_Lut16_G16 != LH_CALC_USE_DO_N_DIM
													case 16:											/* 3 -> 4		Di 16		Do 8		Lut 16		Grid 16		*/
														proc2call = NewCalcProc(LHCalc3to4_Di16_Do8_Lut16_G16);
														break;
#endif
#if LH_Calc3to4_Di16_Do8_Lut16_G32 != LH_CALC_USE_DO_N_DIM
													case 32:											/* 3 -> 4		Di 16		Do 8		Lut 16		Grid 32		*/
														proc2call = NewCalcProc(LHCalc3to4_Di16_Do8_Lut16_G32);
														break;
#endif
												}
												break;
										}
										break;
									case 16:															/* 3 -> 4		Di 16		Do 16								*/
										switch (lutParam->colorLutWordSize)
										{
											case 8:														/* 3 -> 4		Di 16		Do 16		Lut 8					*/
												switch (lutParam->colorLutGridPoints)
												{
#if LH_Calc3to4_Di16_Do16_Lut8_G16 != LH_CALC_USE_DO_N_DIM
													case 16:											/* 3 -> 4		Di 16		Do 16		Lut 8		Grid 16		*/
														proc2call = NewCalcProc(LHCalc3to4_Di16_Do16_Lut8_G16);
														break;
#endif
#if LH_Calc3to4_Di16_Do16_Lut8_G32 != LH_CALC_USE_DO_N_DIM
													case 32:											/* 3 -> 4		Di 16		Do 16		Lut 8		Grid 32		*/
														proc2call = NewCalcProc(LHCalc3to4_Di16_Do16_Lut8_G32);
														break;
#endif
												}
												break;
											case 16:													/* 3 -> 4		Di 16		Do 16		Lut 16					*/
												switch (lutParam->colorLutGridPoints)
												{
#if LH_Calc3to4_Di16_Do16_Lut16_G16 != LH_CALC_USE_DO_N_DIM
													case 16:											/* 3 -> 4		Di 16		Do 16		Lut 16		Grid 16		*/
														proc2call = NewCalcProc(LHCalc3to4_Di16_Do16_Lut16_G16);
														break;
#endif
#if LH_Calc3to4_Di16_Do16_Lut16_G32 != LH_CALC_USE_DO_N_DIM
													case 32:											/* 3 -> 4		Di 16		Do 16		Lut 16		Grid 32		*/
														proc2call = NewCalcProc(LHCalc3to4_Di16_Do16_Lut16_G32);
														break;
#endif
												}
												break;
										}
										break;
								}
								break;
						}
						break;
				}
				break;
			case 4:																						/* 4 ->															*/
				switch ( lutParam->colorLutOutDim )
				{
					case 3:																				/* 4 ->	3														*/
						switch (info->usedSizeIn)
						{
							case 8:																		/* 4 -> 3		Di 8											*/
								switch (info->usedSizeOut)
								{
									case 8:																/* 4 -> 3		Di 8		Do 8								*/
										switch (lutParam->colorLutWordSize)
										{
											case 8:														/* 4 -> 3		Di 8		Do 8		Lut 8					*/
												switch (lutParam->colorLutGridPoints)
												{
#if LH_Calc4to3_Di8_Do8_Lut8_G8 != LH_CALC_USE_DO_N_DIM
													case 8:												/* 4 -> 3		Di 8		Do 8		Lut 8		Grid 8		*/
#ifdef ALLOW_MMX
                                                        if (DetectMMX()) {
														    proc2call = NewCalcProc(LHCalc4to3_Di8_Do8_Lut8_G8_F);
                                                        }
                                                        else
#endif
#if LH_CALC_USE_ADDITIONAL_OLD_CODE_4DIM
														if( !info->inPlace ){
														    proc2call = NewCalcProc(LHCalc4to3_Di8_Do8_Lut8_G8_Old);
														}
														else
#endif
															proc2call = NewCalcProc(LHCalc4to3_Di8_Do8_Lut8_G8);
														break;
#endif
#if LH_Calc4to3_Di8_Do8_Lut8_G16 != LH_CALC_USE_DO_N_DIM
													case 16:											/* 4 -> 3		Di 8		Do 8		Lut 8		Grid 16		*/
#ifdef ALLOW_MMX
                                                        if (DetectMMX()) {
														    proc2call = NewCalcProc(LHCalc4to3_Di8_Do8_Lut8_G16_F);
                                                        }
                                                        else
#endif
#if LH_CALC_USE_ADDITIONAL_OLD_CODE_4DIM
														if( !info->inPlace ){
														    proc2call = NewCalcProc(LHCalc4to3_Di8_Do8_Lut8_G16_Old);
														}
														else
#endif
															proc2call = NewCalcProc(LHCalc4to3_Di8_Do8_Lut8_G16);
														break;
#endif
												}
												break;
											case 16:													/* 4 -> 3		Di 8		Do 8		Lut 16					*/
												switch (lutParam->colorLutGridPoints)
												{
#if LH_Calc4to3_Di8_Do8_Lut16_G8 != LH_CALC_USE_DO_N_DIM
													case 8:												/* 4 -> 3		Di 8		Do 8		Lut 16		Grid 8		*/
														proc2call = NewCalcProc(LHCalc4to3_Di8_Do8_Lut16_G8);
														break;
#endif
#if LH_Calc4to3_Di8_Do8_Lut16_G16 != LH_CALC_USE_DO_N_DIM
													case 16:											/* 4 -> 3		Di 8		Do 8		Lut 16		Grid 16		*/
														proc2call = NewCalcProc(LHCalc4to3_Di8_Do8_Lut16_G16);
														break;
#endif
												}
												break;
										}
										break;
									case 16:															/* 4 -> 3		Di 8		Do 16								*/
										switch (lutParam->colorLutWordSize)
										{
											case 8:														/* 4 -> 3		Di 8		Do 16		Lut 8					*/
												switch (lutParam->colorLutGridPoints)
												{
#if LH_Calc4to3_Di8_Do16_Lut8_G8 != LH_CALC_USE_DO_N_DIM
													case 8:												/* 4 -> 3		Di 8		Do 16		Lut 8		Grid 8		*/
														proc2call = NewCalcProc(LHCalc4to3_Di8_Do16_Lut8_G8);
														break;
#endif
#if LH_Calc4to3_Di8_Do16_Lut8_G16 != LH_CALC_USE_DO_N_DIM
													case 16:											/* 4 -> 3		Di 8		Do 16		Lut 8		Grid 16		*/
														proc2call = NewCalcProc(LHCalc4to3_Di8_Do16_Lut8_G16);
														break;
#endif
												}
												break;
											case 16:													/* 4 -> 3		Di 8		Do 16		Lut 16					*/
												switch (lutParam->colorLutGridPoints)
												{
#if LH_Calc4to3_Di8_Do16_Lut16_G8 != LH_CALC_USE_DO_N_DIM
													case 8:												/* 4 -> 3		Di 8		Do 16		Lut 16		Grid 8		*/
														proc2call = NewCalcProc(LHCalc4to3_Di8_Do16_Lut16_G8);
														break;
#endif
#if LH_Calc4to3_Di8_Do16_Lut16_G16 != LH_CALC_USE_DO_N_DIM
													case 16:											/* 4 -> 3		Di 8		Do 16		Lut 16		Grid 16		*/
														proc2call = NewCalcProc(LHCalc4to3_Di8_Do16_Lut16_G16);
														break;
#endif
												}
												break;
										}
										break;
								}
								break;
							case 16:																	/* 4 -> 3		Di 16											*/
								switch (info->usedSizeOut)
								{
									case 8:																/* 4 -> 3		Di 16		Do 8								*/
										switch (lutParam->colorLutWordSize)
										{
											case 8:														/* 4 -> 3		Di 16		Do 8		Lut 8					*/
												switch (lutParam->colorLutGridPoints)
												{
#if LH_Calc4to3_Di16_Do8_Lut8_G8 != LH_CALC_USE_DO_N_DIM
													case 8:												/* 4 -> 3		Di 16		Do 8		Lut 8		Grid 8		*/
														proc2call = NewCalcProc(LHCalc4to3_Di16_Do8_Lut8_G8);
														break;
#endif
#if LH_Calc4to3_Di16_Do8_Lut8_G16 != LH_CALC_USE_DO_N_DIM
													case 16:											/* 4 -> 3		Di 16		Do 8		Lut 8		Grid 16		*/
														proc2call = NewCalcProc(LHCalc4to3_Di16_Do8_Lut8_G16);
														break;
#endif
												}
												break;
											case 16:													/* 4 -> 3		Di 16		Do 8		Lut 16					*/
												switch (lutParam->colorLutGridPoints)
												{
#if LH_Calc4to3_Di16_Do8_Lut16_G8 != LH_CALC_USE_DO_N_DIM
													case 8:												/* 4 -> 3		Di 16		Do 8		Lut 16		Grid 8		*/
														proc2call = NewCalcProc(LHCalc4to3_Di16_Do8_Lut16_G8);
														break;
#endif
#if LH_Calc4to3_Di16_Do8_Lut16_G16 != LH_CALC_USE_DO_N_DIM
													case 16:											/* 4 -> 3		Di 16		Do 8		Lut 16		Grid 16		*/
														proc2call = NewCalcProc(LHCalc4to3_Di16_Do8_Lut16_G16);
														break;
#endif
												}
												break;
										}
										break;
									case 16:															/* 4 -> 3		Di 16		Do 16								*/
										switch (lutParam->colorLutWordSize)
										{
											case 8:														/* 4 -> 3		Di 16		Do 16		Lut 8					*/
												switch (lutParam->colorLutGridPoints)
												{
#if LH_Calc4to3_Di16_Do16_Lut8_G8 != LH_CALC_USE_DO_N_DIM
													case 8:												/* 4 -> 3		Di 16		Do 16		Lut 8		Grid 8		*/
														proc2call = NewCalcProc(LHCalc4to3_Di16_Do16_Lut8_G8);
														break;
#endif
#if LH_Calc4to3_Di16_Do16_Lut8_G16 != LH_CALC_USE_DO_N_DIM
													case 16:											/* 4 -> 3		Di 16		Do 16		Lut 8		Grid 16		*/
														proc2call = NewCalcProc(LHCalc4to3_Di16_Do16_Lut8_G16);
														break;
#endif
												}
												break;
											case 16:													/* 4 -> 3		Di 16		Do 16		Lut 16					*/
												switch (lutParam->colorLutGridPoints)
												{
#if LH_Calc4to3_Di16_Do16_Lut16_G8 != LH_CALC_USE_DO_N_DIM
													case 8:												/* 4 -> 3		Di 16		Do 16		Lut 16		Grid 8		*/
														proc2call = NewCalcProc(LHCalc4to3_Di16_Do16_Lut16_G8);
														break;
#endif
#if LH_Calc4to3_Di16_Do16_Lut16_G16 != LH_CALC_USE_DO_N_DIM
													case 16:											/* 4 -> 3		Di 16		Do 16		Lut 16		Grid 16		*/
														proc2call = NewCalcProc(LHCalc4to3_Di16_Do16_Lut16_G16);
														break;
#endif
												}
												break;
										}
										break;
								}
								break;
						}
						break;
					case 4:																				/* 4 -> 4														*/
						switch (info->usedSizeIn)
						{
							case 8:																		/* 4 -> 4		Di 8											*/
								switch (info->usedSizeOut)
								{
									case 8:																/* 4 -> 4		Di 8		Do 8								*/
										switch (lutParam->colorLutWordSize)
										{
											case 8:														/* 4 -> 4		Di 8		Do 8		Lut 8					*/
												switch (lutParam->colorLutGridPoints)
												{
#if LH_Calc4to4_Di8_Do8_Lut8_G8 != LH_CALC_USE_DO_N_DIM
													case 8:												/* 4 -> 4		Di 8		Do 8		Lut 8		Grid 8		*/
#ifdef ALLOW_MMX
                                                        if (DetectMMX()) {
														    proc2call = NewCalcProc(LHCalc4to4_Di8_Do8_Lut8_G8_F);
                                                        }
                                                        else
#endif
#if LH_CALC_USE_ADDITIONAL_OLD_CODE_4DIM
														if( !info->inPlace ){
														    proc2call = NewCalcProc(LHCalc4to4_Di8_Do8_Lut8_G8_Old);
														}
														else
#endif
															proc2call = NewCalcProc(LHCalc4to4_Di8_Do8_Lut8_G8);
														break;
#endif
#if LH_Calc4to4_Di8_Do8_Lut8_G16 != LH_CALC_USE_DO_N_DIM
													case 16:											/* 4 -> 4		Di 8		Do 8		Lut 8		Grid 16		*/
#ifdef ALLOW_MMX
                                                        if (DetectMMX()) {
														    proc2call = NewCalcProc(LHCalc4to4_Di8_Do8_Lut8_G16_F);
                                                        }
                                                        else
#endif
#if LH_CALC_USE_ADDITIONAL_OLD_CODE_4DIM
														if( !info->inPlace ){
														    proc2call = NewCalcProc(LHCalc4to4_Di8_Do8_Lut8_G16_Old);
														}
														else
#endif
															proc2call = NewCalcProc(LHCalc4to4_Di8_Do8_Lut8_G16);
														break;
#endif
												}
												break;
											case 16:													/* 4 -> 4		Di 8		Do 8		Lut 16					*/
												switch (lutParam->colorLutGridPoints)
												{
#if LH_Calc4to4_Di8_Do8_Lut16_G8 != LH_CALC_USE_DO_N_DIM
													case 8:												/* 4 -> 4		Di 8		Do 8		Lut 16		Grid 8		*/
														proc2call = NewCalcProc(LHCalc4to4_Di8_Do8_Lut16_G8);
														break;
#endif
#if LH_Calc4to4_Di8_Do8_Lut16_G16 != LH_CALC_USE_DO_N_DIM
													case 16:											/* 4 -> 4		Di 8		Do 8		Lut 16		Grid 16		*/
														proc2call = NewCalcProc(LHCalc4to4_Di8_Do8_Lut16_G16);
														break;
#endif
												}
												break;
										}
										break;
									case 16:															/* 4 -> 4		Di 8		Do 16								*/
										switch (lutParam->colorLutWordSize)
										{
											case 8:														/* 4 -> 4		Di 8		Do 16		Lut 8					*/
												switch (lutParam->colorLutGridPoints)
												{
#if LH_Calc4to4_Di8_Do16_Lut8_G8 != LH_CALC_USE_DO_N_DIM
													case 8:												/* 4 -> 4		Di 8		Do 16		Lut 8		Grid 8		*/
														proc2call = NewCalcProc(LHCalc4to4_Di8_Do16_Lut8_G8);
														break;
#endif
#if LH_Calc4to4_Di8_Do16_Lut8_G16 != LH_CALC_USE_DO_N_DIM
													case 16:											/* 4 -> 4		Di 8		Do 16		Lut 8		Grid 16		*/
														proc2call = NewCalcProc(LHCalc4to4_Di8_Do16_Lut8_G16);
														break;
#endif
												}
												break;
											case 16:													/* 4 -> 4		Di 8		Do 16		Lut 16					*/
												switch (lutParam->colorLutGridPoints)
												{
#if LH_Calc4to4_Di8_Do16_Lut16_G8 != LH_CALC_USE_DO_N_DIM
													case 8:												/* 4 -> 4		Di 8		Do 16		Lut 16		Grid 8		*/
														proc2call = NewCalcProc(LHCalc4to4_Di8_Do16_Lut16_G8);
														break;
#endif
#if LH_Calc4to4_Di8_Do16_Lut16_G16 != LH_CALC_USE_DO_N_DIM
													case 16:											/* 4 -> 4		Di 8		Do 16		Lut 16		Grid 16		*/
														proc2call = NewCalcProc(LHCalc4to4_Di8_Do16_Lut16_G16);
														break;
#endif
												}
												break;
										}
										break;
								}
								break;
							case 16:																	/* 4 -> 4		Di 16											*/
								switch (info->usedSizeOut)
								{
									case 8:																/* 4 -> 4		Di 16		Do 8								*/
										switch (lutParam->colorLutWordSize)
										{
											case 8:														/* 4 -> 4		Di 16		Do 8		Lut 8					*/
												switch (lutParam->colorLutGridPoints)
												{
#if LH_Calc4to4_Di16_Do8_Lut8_G8 != LH_CALC_USE_DO_N_DIM
													case 8:												/* 4 -> 4		Di 16		Do 8		Lut 8		Grid 8		*/
														proc2call = NewCalcProc(LHCalc4to4_Di16_Do8_Lut8_G8);
														break;
#endif
#if LH_Calc4to4_Di16_Do8_Lut8_G16 != LH_CALC_USE_DO_N_DIM
													case 16:											/* 4 -> 4		Di 16		Do 8		Lut 8		Grid 16		*/
														proc2call = NewCalcProc(LHCalc4to4_Di16_Do8_Lut8_G16);
														break;
#endif
												}
												break;
											case 16:													/* 4 -> 4		Di 16		Do 8		Lut 16					*/
												switch (lutParam->colorLutGridPoints)
												{
#if LH_Calc4to4_Di16_Do8_Lut16_G8 != LH_CALC_USE_DO_N_DIM
													case 8:												/* 4 -> 4		Di 16		Do 8		Lut 16		Grid 8		*/
														proc2call = NewCalcProc(LHCalc4to4_Di16_Do8_Lut16_G8);
														break;
#endif
#if LH_Calc4to4_Di16_Do8_Lut16_G16 != LH_CALC_USE_DO_N_DIM
													case 16:											/* 4 -> 4		Di 16		Do 8		Lut 16		Grid 16		*/
														proc2call = NewCalcProc(LHCalc4to4_Di16_Do8_Lut16_G16);
														break;
#endif
												}
												break;
										}
										break;
									case 16:															/* 4 -> 4		Di 16		Do 16								*/
										switch (lutParam->colorLutWordSize)
										{
											case 8:														/* 4 -> 4		Di 16		Do 16		Lut 8					*/
												switch (lutParam->colorLutGridPoints)
												{
#if LH_Calc4to4_Di16_Do16_Lut8_G8 != LH_CALC_USE_DO_N_DIM
													case 8:												/* 4 -> 4		Di 16		Do 16		Lut 8		Grid 8		*/
														proc2call = NewCalcProc(LHCalc4to4_Di16_Do16_Lut8_G8);
														break;
#endif
#if LH_Calc4to4_Di16_Do16_Lut8_G16 != LH_CALC_USE_DO_N_DIM
													case 16:											/* 4 -> 4		Di 16		Do 16		Lut 8		Grid 16		*/
														proc2call = NewCalcProc(LHCalc4to4_Di16_Do16_Lut8_G16);
														break;
#endif
												}
												break;
											case 16:													/* 4 -> 4		Di 16		Do 16		Lut 16					*/
												switch (lutParam->colorLutGridPoints)
												{
#if LH_Calc4to4_Di16_Do16_Lut16_G8 != LH_CALC_USE_DO_N_DIM
													case 8:												/* 4 -> 4		Di 16		Do 16		Lut 16		Grid 8		*/
														proc2call = NewCalcProc(LHCalc4to4_Di16_Do16_Lut16_G8);
														break;
#endif
#if LH_Calc4to4_Di16_Do16_Lut16_G16 != LH_CALC_USE_DO_N_DIM
													case 16:											/* 4 -> 4		Di 16		Do 16		Lut 16		Grid 16		*/
														proc2call = NewCalcProc(LHCalc4to4_Di16_Do16_Lut16_G16);
														break;
#endif
												}
												break;
										}
										break;
								}
								break;
						}
						break;
				}
				break;
		}
  }
#endif
  
	if ( ( proc2call == nil )
#ifdef DEBUG_OUTPUT
		 || ( gUSE_NDIM_FOR_BITMAP )
#endif
		)						
	{
		switch (info->usedSizeIn)
		{
			case 8:																		/*	Di 8							*/
				switch (info->usedSizeOut)
				{
					case 8:																/*	Di 8		Do 8				*/
						switch (lutParam->colorLutWordSize)
						{
							case 8:														/*	Di 8		Do 8		Lut 8	*/
								proc2call = NewCalcProc(CalcNDim_Data8To8_Lut8);
								break;
							case 16:													/*	Di 8		Do 8		Lut 16	*/
								proc2call = NewCalcProc(CalcNDim_Data8To8_Lut16);
								break;
						}
						break;
					case 16:															/*	Di 8		Do 16				*/
						switch (lutParam->colorLutWordSize)
						{
							case 8:														/*	Di 8		Do 16		Lut 8	*/
								proc2call = NewCalcProc(CalcNDim_Data8To16_Lut8);
								break;
							case 16:													/*	Di 8		Do 16		Lut 16	*/
								proc2call = NewCalcProc(CalcNDim_Data8To16_Lut16);
								break;
						}
						break;
				}
				break;
			case 16:																	/*	Di 16							*/
				switch (info->usedSizeOut)
				{
					case 8:																/*	Di 16		Do 8				*/
						switch (lutParam->colorLutWordSize)
						{
							case 8:														/*	Di 16		Do 8		Lut 8	*/
								proc2call = NewCalcProc(CalcNDim_Data16To8_Lut8);
								break;
							case 16:													/*	Di 16		Do 8		Lut 16	*/
								proc2call = NewCalcProc(CalcNDim_Data16To8_Lut16);
								break;
						}
						break;
					case 16:															/*	Di 16		Do 16				*/
						switch (lutParam->colorLutWordSize)
						{
							case 8:														/*	Di 16		Do 16		Lut 8	*/
								proc2call = NewCalcProc(CalcNDim_Data16To16_Lut8);
								break;
							case 16:													/*	Di 16		Do 16		Lut 16	*/
								proc2call = NewCalcProc(CalcNDim_Data16To16_Lut16);
								break;
						}
						break;
				}
				break;
		}
	}

#ifdef DEBUG_OUTPUT
	if ( DebugCheck(kThisFile, kDebugMiscInfo) )
	{
		if ( gUSE_NDIM_FOR_BITMAP )
			DebugPrint("DoNDIM:     %1d->%1d   Di %2d   Do %2d   Grid %2d  Lut %2d\n", 	lutParam->colorLutInDim, lutParam->colorLutOutDim,
																						info->usedSizeIn, info->usedSizeOut,
																						lutParam->colorLutGridPoints, lutParam->colorLutWordSize);
		else
			DebugPrint("OPTIMIZED:  %1d->%1d   Di %2d   Do %2d   Grid %2d  Lut %2d\n", 	lutParam->colorLutInDim, lutParam->colorLutOutDim,
																						info->usedSizeIn, info->usedSizeOut,
																						lutParam->colorLutGridPoints, lutParam->colorLutWordSize);
	}
	if (proc2call == nil)
		DebugPrint(" ERROR: FindCalcRoutine is nil !!!\n");
#endif
	LH_END_PROC("FindCalcRoutine")
	return proc2call;
}

#ifdef __MWERKS__
#pragma mark ================  Match/Check CMColors  ================
#endif

/*--------------------------------------------------------------------------------------------------------------
	LHMatchColorsPrivate
  --------------------------------------------------------------------------------------------------------------*/
CMError
LHMatchColorsPrivate	 (CMMModelPtr		modelingData, 
						  CMColor*			myColors, 
						  SINT32			count)
{
	CMCalcParam 	calcParam;
	CMLutParam		lutParam;
	CMError			err = -1;
	ColorSpaceInfo	info;
	CalcProcPtr		calcRoutine   = nil;

	LH_START_PROC("LHMatchColorsPrivate")
	
	LOCK_DATA((modelingData)->lutParam.inputLut);
	LOCK_DATA((modelingData)->lutParam.colorLut);
	LOCK_DATA((modelingData)->lutParam.outputLut);

 	/* preprocess for NamedColor stuff */
	if (modelingData->hasNamedColorProf == NamedColorProfileOnly){
		err = ConvertNamedIndexToColors(modelingData,myColors,count); 
		goto CleanupAndExit;
	} 
	else if (modelingData->hasNamedColorProf==NamedColorProfileAtBegin){
		err = ConvertNamedIndexToPCS(modelingData,myColors,count); 
		if (err) goto CleanupAndExit;
	}

	SetMem(&info,		sizeof(ColorSpaceInfo), 0);
	SetMem(&calcParam,	sizeof(CMCalcParam), 	0);
 
 	info.origSizeIn  = 16;
	info.origSizeOut = 16;
	info.usedSizeIn	 = 16;
	info.usedSizeOut = 16;

	FillLutParam(&lutParam, modelingData);
	FillCalcParamCM(&calcParam, &lutParam, myColors, count );
	
	info.inPlace = TRUE;
	calcRoutine = FindCalcRoutine( &calcParam, &lutParam, &info, modelingData->lookup );
	if (calcRoutine == nil)
	{
		err = cmMethodError;
		goto CleanupAndExit;
	}
		
	err = CallCalcProc(calcRoutine,&calcParam, &lutParam);
	if (err)
		goto CleanupAndExit;
	
	/* postprocess for NamedColor stuff */
	err = ConvertPCSToNamedIndex(modelingData,myColors,count); 

CleanupAndExit:
	UNLOCK_DATA((modelingData)->lutParam.inputLut);
	UNLOCK_DATA((modelingData)->lutParam.colorLut);
	UNLOCK_DATA((modelingData)->lutParam.outputLut);

	LH_END_PROC("LHMatchColorsPrivate")
	return err;
}

/*--------------------------------------------------------------------------------------------------------------
	LHCheckColorsPrivateMS
  --------------------------------------------------------------------------------------------------------------*/
CMError LHCheckColorsPrivateMS(	CMMModelPtr		modelingData, 
								CMColor*		myColors, 
								UINT32			count, 
								UINT8 			*result )
{
	CMCalcParam 	calcParam;
	CMLutParam		lutParam;
	CMError			err = -1;
	ColorSpaceInfo	info;
	CalcProcPtr		calcRoutine   = nil;

	LH_START_PROC("LHCheckColorsPrivateMS")
	
	if( (modelingData)->gamutLutParam.colorLut == 0 )return cmMethodError;
	LOCK_DATA((modelingData)->gamutLutParam.inputLut);
	LOCK_DATA((modelingData)->gamutLutParam.colorLut);
	LOCK_DATA((modelingData)->gamutLutParam.outputLut);

 	/* preprocess for NamedColor stuff */
	if (modelingData->hasNamedColorProf == NamedColorProfileOnly){
 		err = unimpErr;
 		goto CleanupAndExit;
	} 
	else if (modelingData->hasNamedColorProf==NamedColorProfileAtBegin){
		err = ConvertNamedIndexToPCS(modelingData,myColors,count); 
		if (err) goto CleanupAndExit;
	}

	SetMem(&info,		sizeof(ColorSpaceInfo), 0);
	SetMem(&calcParam,	sizeof(CMCalcParam), 	0);
 
 	info.origSizeIn  = 16;
	info.origSizeOut = 8;
	info.usedSizeIn	 = 16;
	info.usedSizeOut = 8;

	FillLutParamChk(&lutParam, modelingData);
	FillCalcParamCM(&calcParam, &lutParam, myColors, count );
	calcParam.outputData[0]	= (Ptr)result;
	calcParam.cmOutputBytesPerLine = count*sizeof(UINT8);
	calcParam.cmOutputPixelOffset = 1;
	calcParam.cmOutputColorSpace = cmGraySpace8Bit;	/* cmGraySpace is 16 bit */

	
	info.inPlace = (UINT8 *)myColors == result;
	calcRoutine = FindCalcRoutine( &calcParam, &lutParam, &info, modelingData->lookup );
	if (calcRoutine == nil)
	{
		err = cmMethodError;
		goto CleanupAndExit;
	}
		
	err = CallCalcProc(calcRoutine,&calcParam, &lutParam);
	if (err)
		goto CleanupAndExit;
	
	/* postprocess for NamedColor stuff */
	if( modelingData->hasNamedColorProf == NamedColorProfileAtEnd ){
 		err = unimpErr;
 		goto CleanupAndExit;
	}
CleanupAndExit:
	UNLOCK_DATA((modelingData)->gamutLutParam.inputLut);
	UNLOCK_DATA((modelingData)->gamutLutParam.colorLut);
	UNLOCK_DATA((modelingData)->gamutLutParam.outputLut);

	LH_END_PROC("LHCheckColorsPrivateMS")
	return err;
}

/*--------------------------------------------------------------------------------------------------------------
	LHCheckColorsPrivate
  --------------------------------------------------------------------------------------------------------------*/
CMError 
LHCheckColorsPrivate	( CMMModelPtr		modelingData, 
						  CMColor*			myColors, 
						  UINT32 			count, 
						  UINT8 			*result )
{
	CMCalcParam 	calcParam;
	CMLutParam		lutParam;
	CMError			err = -1;
	ColorSpaceInfo	info;
	CalcProcPtr		calcRoutine   = nil;
	
	LH_START_PROC("LHCheckColorsPrivate")
	
	SetMem(&info,		sizeof(ColorSpaceInfo), 0);
	SetMem(&calcParam,	sizeof(CMCalcParam), 	0);
 
 	/* disabling check colors with Named Color Profile */
 	if ( modelingData->hasNamedColorProf == NamedColorProfileOnly ||
		 modelingData->hasNamedColorProf == NamedColorProfileAtEnd ){
 		err = unimpErr;
 		goto CleanupAndExit;
 	}
	
 	info.origSizeIn  = 16;
	info.origSizeOut = 16;
	info.usedSizeIn	 = 16;
	info.usedSizeOut = 16;

	if( (modelingData)->gamutLutParam.colorLut == 0 )return cmMethodError;
	LOCK_DATA((modelingData)->gamutLutParam.inputLut);
	LOCK_DATA((modelingData)->gamutLutParam.colorLut);
	LOCK_DATA((modelingData)->gamutLutParam.outputLut);

	FillLutParamChk(&lutParam, modelingData);
	FillCalcParamCM(&calcParam, &lutParam, myColors, count );

	AllocBufferCheckCM(&calcParam, &info);
	
	info.inPlace = info.tempOutBuffer == nil;
	calcRoutine = FindCalcRoutine( &calcParam, &lutParam, &info, modelingData->lookup  );
	if (calcRoutine == nil)
	{
		err = cmMethodError;
		goto CleanupAndExit;
	}
		
	err = CallCalcProc(calcRoutine, &calcParam, &lutParam);
	
	Convert8To1( (Ptr)info.tempOutBuffer, (Ptr)result, info.processedLinesIn, calcParam.cmLineCount, count, count*sizeof(CMColor));			

	DisposeIfPtr((Ptr)info.tempOutBuffer);
	
CleanupAndExit:
	UNLOCK_DATA((modelingData)->gamutLutParam.inputLut);
	UNLOCK_DATA((modelingData)->gamutLutParam.colorLut);
	UNLOCK_DATA((modelingData)->gamutLutParam.outputLut);
	
	LH_END_PROC("LHCheckColorsPrivate")
	return err;
}

void CopyIndexData( CMBitmap *bitMapIn, CMBitmap *bitMapOut, ColorSpaceInfo *info );
void CopyIndexData( CMBitmap *bitMapIn, CMBitmap *bitMapOut, ColorSpaceInfo *info )
{
	Ptr			imgIn=NULL;
	Ptr			imgOut=NULL;
	SINT32		i,j;
#ifdef DEBUG_OUTPUT
	CMError			err = -1;
#endif	
	LH_START_PROC("CopyIndexData")

	for( i=0; i<bitMapIn->height; i++ ){
		imgIn = bitMapIn->image + i * bitMapIn->rowBytes;
		imgOut = bitMapOut->image + i * bitMapOut->rowBytes;
		if( info->inputPixelSize == 24 ){
			if( info->outputPixelSize == 24 ){
				for (j=0;j<bitMapIn->width;j++) {
					*imgOut++  = *imgIn++;
					*imgOut++  = *imgIn++;
					*imgOut++  = *imgIn++;
				}
			}
			else if( info->outputPixelSize == 32 ){
				for (j=0;j<bitMapIn->width;j++) {
					*imgOut++  = *imgIn++;
					*imgOut++  = *imgIn++;
					*imgOut++  = *imgIn++;
					imgOut++;
				}
			}
		}
		else if( info->inputPixelSize == 32 ){
			if( info->outputPixelSize == 24 ){
				for (j=0;j<bitMapIn->width;j++) {
					*imgOut++  = *imgIn++;
					*imgOut++  = *imgIn++;
					*imgOut++  = *imgIn++;
					imgIn++;
				}
			}
			else if( info->outputPixelSize == 32 ){
				for (j=0;j<bitMapIn->width;j++) {
					*imgOut++  = *imgIn++;
					*imgOut++  = *imgIn++;
					*imgOut++  = *imgIn++;
					imgOut++;
					imgIn++;
				}
			}
		}
	}
	LH_END_PROC("CopyIndexData")
	return;
}

#ifdef __MWERKS__
#pragma mark ================  Match/Check CMBitmaps  ================
#endif

/*--------------------------------------------------------------------------------------------------------------
	LHMatchBitMapPrivate
  --------------------------------------------------------------------------------------------------------------*/
CMError
LHMatchBitMapPrivate	 ( CMMModelPtr			modelingData, 
						   const CMBitmap *		inBitMap, 
						   CMBitmapCallBackUPP	progressProc, 
						   void *				refCon, 
						   CMBitmap *			outBitMap )
{
	CMCalcParam 	calcParam;
	CMLutParam		lutParam;
	CMError			err = -1;
	ColorSpaceInfo	info;
	CalcProcPtr		calcRoutine 	= nil;
	CMBitmap 		bitMapOut;
	CMBitmap 		bitMapIn 			= *inBitMap;
	OSType			inColorSpace 	= modelingData->firstColorSpace;
	OSType			outColorSpace 	= modelingData->lastColorSpace;
	Boolean			progressProcWasCalled = FALSE;
	SINT32			offset;
	SINT32			progressTimer;
	SINT32			dimLoop;
	Boolean			matchInPlace = FALSE;
	long			progressProcCount = 0;
	SINT32			inLineCount;
	Ptr				aBuffer;
	
	LH_START_PROC("LHMatchBitMapPrivate")

	LOCK_DATA((modelingData)->lutParam.inputLut);
	LOCK_DATA((modelingData)->lutParam.colorLut);
	LOCK_DATA((modelingData)->lutParam.outputLut);

	if( outBitMap == nil ){
		bitMapOut = *inBitMap;
		matchInPlace = TRUE;
	}
	else{
		bitMapOut 	= *outBitMap;
	}

	SetMem(&info, 		sizeof(ColorSpaceInfo), 0);
 	SetMem(&calcParam,	sizeof(CMCalcParam), 	0);

	FillLutParam(&lutParam, modelingData);
	FillCalcParam(&calcParam, &bitMapIn, &bitMapOut);
	
	err = CheckInputColorSpace( &bitMapIn, &calcParam, &info, inColorSpace, lutParam.colorLutInDim );
	inLineCount = calcParam.cmLineCount;
	if (err)
		goto CleanupAndExit;
		
	if (matchInPlace){
		err = SetOutputColorSpaceInplace( &calcParam, &info, outColorSpace);
		if (err)
			goto CleanupAndExit;
	}
	err = CheckOutputColorSpace( &bitMapOut, &calcParam, &info, outColorSpace, lutParam.colorLutOutDim );
	if (err)
		goto CleanupAndExit;
	
	if (matchInPlace)		/* matching in place - check if pixel sizes are ok */
	{
		if (info.inputPixelSize < info.outputPixelSize)
		{
			err = cmInvalidDstMap;
			goto CleanupAndExit;
		}		
		/* set the color space field to the output color space */
		bitMapIn.space = calcParam.cmOutputColorSpace;
	} else
	{
		calcParam.copyAlpha = (calcParam.cmInputColorSpace & cmAlphaSpace) && (calcParam.cmOutputColorSpace & cmAlphaSpace);
	}

	info.inPlace = bitMapOut.image == bitMapIn.image && info.tempInBuffer == nil && info.tempOutBuffer == nil;
	calcRoutine = FindCalcRoutine( &calcParam, &lutParam, &info, modelingData->lookup );
	if (calcRoutine == nil)
	{
		err = cmMethodError;
		goto CleanupAndExit;
	}
	
	if( info.inPlace && calcParam.cmInputPixelOffset < calcParam.cmOutputPixelOffset ){
			for( dimLoop=0; dimLoop<8; dimLoop++){					/* now work backwards				*/
				calcParam.inputData[dimLoop] = (Ptr)calcParam.inputData[dimLoop] + (calcParam.cmLineCount-1) * calcParam.cmInputBytesPerLine + (calcParam.cmPixelPerLine-1) * calcParam.cmInputPixelOffset;
				calcParam.outputData[dimLoop] = (Ptr)calcParam.outputData[dimLoop] + (calcParam.cmLineCount-1) * calcParam.cmOutputBytesPerLine + (calcParam.cmPixelPerLine-1) * calcParam.cmOutputPixelOffset;
			}
			calcParam.cmInputPixelOffset = -calcParam.cmInputPixelOffset;	
			calcParam.cmOutputPixelOffset = -calcParam.cmOutputPixelOffset;
			calcParam.cmInputBytesPerLine = -calcParam.cmInputBytesPerLine;
			calcParam.cmOutputBytesPerLine = -calcParam.cmOutputBytesPerLine;
	}
	/* ------------------------------------------------- 8 or 16 bit data --------------------------------------------------------- */
	if ((info.tempInBuffer == nil) && (info.tempOutBuffer == nil)&& modelingData->hasNamedColorProf == NoNamedColorProfile)
	{
		if (progressProc == nil)
			err = CallCalcProc(calcRoutine,&calcParam, &lutParam);		/* no callback proc - do it all in one step */
		else
		{
			calcParam.cmLineCount = kMaxTempBlock / calcParam.cmInputBytesPerLine;
			if (calcParam.cmLineCount < 1)
				calcParam.cmLineCount = 1;
			else if (calcParam.cmLineCount > bitMapIn.height)
				calcParam.cmLineCount = bitMapIn.height;
				
			progressTimer = TickCount();
			while (	info.processedLinesIn <  bitMapIn.height )
			{
				err = CallCalcProc(calcRoutine,&calcParam, &lutParam);
			
				for (dimLoop = 0; dimLoop< lutParam.colorLutInDim; dimLoop++)
					calcParam.inputData[dimLoop] = (Ptr)calcParam.inputData[dimLoop] + calcParam.cmLineCount * calcParam.cmInputBytesPerLine;
					
				for (dimLoop = 0; dimLoop< lutParam.colorLutOutDim; dimLoop++)
					calcParam.outputData[dimLoop] =  (Ptr)calcParam.outputData[dimLoop]  + calcParam.cmLineCount * calcParam.cmOutputBytesPerLine;
	
				info.processedLinesIn += calcParam.cmLineCount;
				if ( info.processedLinesIn + calcParam.cmLineCount > bitMapIn.height )
					calcParam.cmLineCount = bitMapIn.height-info.processedLinesIn;
						
				/* - - - - - handle CMBitmapCallBackProc - - - - - */
				if ( progressProc && ( progressTimer + kProgressTicks < (SINT32)TickCount()) )	
				{
					progressProcWasCalled = TRUE;
					if (CallCMBitmapCallBackProc ( progressProc, bitMapIn.height, info.processedLinesIn, (void *)refCon ))
					{
						info.processedLinesIn =  bitMapIn.height; 
						err = userCanceledErr;
					} else
						progressTimer = TickCount();
						progressProcCount = info.processedLinesIn;
				}
			}
		}
	}
	else if (modelingData->hasNamedColorProf != NamedColorProfileOnly ){
		info.processedLinesIn = 0;
		progressTimer = TickCount();
		if( info.tempInBuffer && info.tempOutBuffer ){
			if( inLineCount > calcParam.cmLineCount )inLineCount = calcParam.cmLineCount;
		}
		else if( info.tempInBuffer ){
			if( progressProc && modelingData->hasNamedColorProf == NamedColorProfileAtEnd ){
				inLineCount /= 32;
				if( inLineCount < 1 ) inLineCount = 1;
			}
		}
		else if( info.tempOutBuffer ){
			inLineCount = calcParam.cmLineCount;
		}
		else if( progressProc ){
			inLineCount = kMaxTempBlock / calcParam.cmInputBytesPerLine;
			if (inLineCount < 1)
				inLineCount = 1;
			else if (inLineCount > bitMapIn.height)
				inLineCount = bitMapIn.height;
			if( modelingData->hasNamedColorProf == NamedColorProfileAtEnd ){
				inLineCount /= 32;
				if( inLineCount < 1 ) inLineCount = 1;
			}
		}
		while (	info.processedLinesIn <  bitMapIn.height )
		{
			if ( info.processedLinesIn + inLineCount > bitMapIn.height )
				inLineCount = bitMapIn.height-info.processedLinesIn;

			if (info.origSizeIn == 5 )																			/* input is 5 bit */
				Convert5To8  ( bitMapIn.image, (Ptr)info.tempInBuffer, info.processedLinesIn, inLineCount, bitMapIn.width, bitMapIn.rowBytes );
#ifdef PI_Application_h
			else if (info.origSizeIn == 6 )																			/* output is 5 bit */
				Convert565To8 ( bitMapIn.image, (Ptr)info.tempInBuffer, info.processedLinesIn, inLineCount, bitMapIn.width, bitMapIn.rowBytes );
#endif
			else if (info.origSizeIn == 10 ) 
					Convert10To16  ( bitMapIn.image, (Ptr)info.tempInBuffer, info.processedLinesIn, inLineCount, bitMapIn.width, bitMapIn.rowBytes );
			
			if (modelingData->hasNamedColorProf == NamedColorProfileAtBegin ){
				err = ConvertIndexToLabBitmap(	modelingData, bitMapIn.image, 
												(Ptr)info.tempInBuffer, info.processedLinesIn, 
												inLineCount, bitMapIn.width, 
												bitMapIn.rowBytes, 
												calcParam.cmInputBytesPerLine, 
												calcParam.cmInputPixelOffset*8 );
				if (err) 
					goto CleanupAndExit;
			}
			calcParam.cmLineCount = inLineCount;
			err = CallCalcProc( calcRoutine, &calcParam, &lutParam );
			if (err) 
				goto CleanupAndExit;

			if (modelingData->hasNamedColorProf == NamedColorProfileAtEnd ){
				if( info.tempOutBuffer )aBuffer = (Ptr)info.tempOutBuffer;
				else aBuffer = bitMapOut.image;
				err = ConvertLabToIndexBitmap(	modelingData, aBuffer, 
												info.processedLinesIn, 
												calcParam.cmLineCount,
												bitMapOut.width, bitMapOut.rowBytes );
				if (err) 
					goto CleanupAndExit;
			}

			if( info.origSizeOut == 5 )																			/* output is 5 bit */
				Convert8To5 ( (Ptr)info.tempOutBuffer, bitMapOut.image, info.processedLinesIn, calcParam.cmLineCount, bitMapOut.width, bitMapOut.rowBytes);
#ifdef PI_Application_h
			else if( info.origSizeOut == 6 )																			/* output is 5 bit */
				Convert8To565 ( (Ptr)info.tempOutBuffer, bitMapOut.image, info.processedLinesIn, calcParam.cmLineCount, bitMapOut.width, bitMapOut.rowBytes);
#endif
			else if( info.origSizeOut == 10 )																								/* output is 10 bit */
				Convert16To10 ( (Ptr)info.tempOutBuffer, bitMapOut.image, info.processedLinesIn, calcParam.cmLineCount, bitMapOut.width, bitMapOut.rowBytes);

			info.processedLinesIn += inLineCount;
			/* - - - - - handle CMBitmapCallBackProc - - - - - */
			if ( progressProc && ( progressTimer + kProgressTicks < (SINT32)TickCount()) )	
			{
				progressProcWasCalled = TRUE;
				if (CallCMBitmapCallBackProc ( progressProc, bitMapIn.height, info.processedLinesIn, (void *)refCon ))
				{
					info.processedLinesIn =  bitMapIn.height; 
					err = userCanceledErr;
				} else
					progressTimer = TickCount();
					progressProcCount = info.processedLinesIn;
			}
			if( !info.tempInBuffer ){
				offset = calcParam.cmLineCount * calcParam.cmInputBytesPerLine;
				for (dimLoop = 0; dimLoop< lutParam.colorLutInDim; dimLoop++)
					calcParam.inputData[dimLoop] = (Ptr)calcParam.inputData[dimLoop] + offset;
			}
			if( !info.tempOutBuffer ){
				offset = calcParam.cmLineCount * calcParam.cmOutputBytesPerLine;
				for (dimLoop = 0; dimLoop< lutParam.colorLutOutDim; dimLoop++)
					calcParam.outputData[dimLoop] =  (Ptr)calcParam.outputData[dimLoop]  + offset;
			}
		}
		DisposeIfPtr((Ptr)info.tempInBuffer);
		DisposeIfPtr((Ptr)info.tempOutBuffer);
	}
	else{
		CopyIndexData( &bitMapIn, &bitMapOut, &info );
		DisposeIfPtr((Ptr)info.tempInBuffer);
	}
	if (err) 
		goto CleanupAndExit;
	
	if( progressProcWasCalled && progressProcCount != bitMapIn.height )
		CallCMBitmapCallBackProc ( progressProc, bitMapIn.height, bitMapIn.height, (void *)refCon );
CleanupAndExit:
	UNLOCK_DATA((modelingData)->lutParam.inputLut);
	UNLOCK_DATA((modelingData)->lutParam.colorLut);
	UNLOCK_DATA((modelingData)->lutParam.outputLut);

	LH_END_PROC("LHMatchBitMapPrivate")
	
	return err;
}

/*--------------------------------------------------------------------------------------------------------------
	LHCheckBitMapPrivate
  --------------------------------------------------------------------------------------------------------------*/
CMError 
LHCheckBitMapPrivate	( CMMModelPtr			modelingData, 
						  const CMBitmap		*inBitMap,
						  CMBitmapCallBackUPP	progressProc,
						  void *				refCon, 
						  CMBitmap 				*outBitMap )
{
	CMCalcParam 	calcParam;
	CMLutParam		lutParam;
	CMError			err = -1;
	ColorSpaceInfo	info;
	CalcProcPtr		calcRoutine 	= nil;
	CMBitmap 		bitMapIn 			= *inBitMap;
	CMBitmap 		bitMapOut;
	OSType			inColorSpace 	= modelingData->firstColorSpace;
	Boolean			progressProcWasCalled = FALSE;
	SINT32			offset;
	SINT32			progressTimer;
	SINT32			dimLoop;
	Boolean			matchInPlace = FALSE;
	long			progressProcCount = 0;
	SINT32			inLineCount;
	
	LH_START_PROC("LHCheckBitMapPrivate")

	if( (modelingData)->gamutLutParam.colorLut == 0 )return cmMethodError;
	LOCK_DATA((modelingData)->gamutLutParam.inputLut);
	LOCK_DATA((modelingData)->gamutLutParam.colorLut);
	LOCK_DATA((modelingData)->gamutLutParam.outputLut);

	SetMem(&info, 		sizeof(ColorSpaceInfo), 0);
 	SetMem(&calcParam,	sizeof(CMCalcParam), 	0);

	if ( (outBitMap == nil ) || (modelingData->gamutLutParam.colorLut == nil) )
	{
		err = cmInvalidDstMap;
		goto CleanupAndExit;
	}
	bitMapOut = *outBitMap;
	FillLutParamChk(&lutParam, modelingData);
	FillCalcParam(&calcParam, &bitMapIn, &bitMapOut);
	
	err = CheckInputColorSpace( &bitMapIn, &calcParam, &info, inColorSpace, lutParam.colorLutInDim );
	inLineCount = calcParam.cmLineCount;
	if (err)
		goto CleanupAndExit;
		
	err = CheckOutputColorSpaceChk( &bitMapOut, &calcParam, &info );
	if (err)
		goto CleanupAndExit;
	
	info.inPlace = bitMapOut.image == bitMapIn.image && info.tempInBuffer == nil && info.tempOutBuffer == nil;
	calcRoutine = FindCalcRoutine( &calcParam, &lutParam, &info, modelingData->lookup );
	if (calcRoutine == nil)
	{
		err = cmMethodError;
		goto CleanupAndExit;
	}
	
	/* ------------------------------------------------- 8 or 16 bit data --------------------------------------------------------- */
	if ((info.tempInBuffer == nil) && (info.tempOutBuffer == nil) && modelingData->hasNamedColorProf == NoNamedColorProfile)
	{
		if (progressProc == nil)
			err = CallCalcProc(calcRoutine,&calcParam, &lutParam);		/* no callback proc - do it all in one step */
		else
		{
			calcParam.cmLineCount = kMaxTempBlock / calcParam.cmInputBytesPerLine;
			if (calcParam.cmLineCount < 1)
				calcParam.cmLineCount = 1;
			else if (calcParam.cmLineCount > bitMapIn.height)
				calcParam.cmLineCount = bitMapIn.height;
				
			progressTimer = TickCount();
			while (	info.processedLinesIn <  bitMapIn.height )
			{
				err = CallCalcProc(calcRoutine,&calcParam, &lutParam);
			
				for (dimLoop = 0; dimLoop< lutParam.colorLutInDim; dimLoop++)
					calcParam.inputData[dimLoop] = (Ptr)calcParam.inputData[dimLoop] + calcParam.cmLineCount * calcParam.cmInputBytesPerLine;
					
				for (dimLoop = 0; dimLoop< lutParam.colorLutOutDim; dimLoop++)
					calcParam.outputData[dimLoop] =  (Ptr)calcParam.outputData[dimLoop]  + calcParam.cmLineCount * calcParam.cmOutputBytesPerLine;
	
				info.processedLinesIn += calcParam.cmLineCount;
				if ( info.processedLinesIn + calcParam.cmLineCount > bitMapIn.height )
					calcParam.cmLineCount = bitMapIn.height-info.processedLinesIn;
						
				/* - - - - - handle CMBitmapCallBackProc - - - - - */
				if ( progressProc && ( progressTimer + kProgressTicks < (SINT32)TickCount()) )	
				{
					progressProcWasCalled = TRUE;
					if (CallCMBitmapCallBackProc ( progressProc, bitMapIn.height, info.processedLinesIn, (void *)refCon ))
					{
						info.processedLinesIn =  bitMapIn.height; 
						err = userCanceledErr;
					} else
						progressTimer = TickCount();
						progressProcCount = info.processedLinesIn;
				}
			}
		}
	}
	else if (modelingData->hasNamedColorProf != NamedColorProfileOnly ){
		info.processedLinesIn = 0;
		progressTimer = TickCount();
		if( info.tempInBuffer && info.tempOutBuffer ){
			if( inLineCount > calcParam.cmLineCount )inLineCount = calcParam.cmLineCount;
		}
		else if( info.tempInBuffer ){
		}
		else if( info.tempOutBuffer ){
			inLineCount = calcParam.cmLineCount;
		}
		else if( progressProc ){
			inLineCount = kMaxTempBlock / calcParam.cmInputBytesPerLine;
			if (inLineCount < 1)
				inLineCount = 1;
			else if (inLineCount > bitMapIn.height)
				inLineCount = bitMapIn.height;
		}
		while (	info.processedLinesIn <  bitMapIn.height )
		{
			if ( info.processedLinesIn + inLineCount > bitMapIn.height )
				inLineCount = bitMapIn.height-info.processedLinesIn;

			if (info.origSizeIn == 5 )																			/* input is 5 bit */
				Convert5To8  ( bitMapIn.image, (Ptr)info.tempInBuffer, info.processedLinesIn, inLineCount, bitMapIn.width, bitMapIn.rowBytes );
#ifdef PI_Application_h
			else if (info.origSizeIn == 6 )																			/* output is 5 bit */
				Convert565To8 ( bitMapIn.image, (Ptr)info.tempInBuffer, info.processedLinesIn, inLineCount, bitMapIn.width, bitMapIn.rowBytes );
#endif
			else if (info.origSizeIn == 10 ) 
					Convert10To16  ( bitMapIn.image, (Ptr)info.tempInBuffer, info.processedLinesIn, inLineCount, bitMapIn.width, bitMapIn.rowBytes );
			
			if (modelingData->hasNamedColorProf == NamedColorProfileAtBegin ){
				err = ConvertIndexToLabBitmap(	modelingData, bitMapIn.image, 
												(Ptr)info.tempInBuffer, info.processedLinesIn, 
												inLineCount, bitMapIn.width, 
												bitMapIn.rowBytes, 
												calcParam.cmInputBytesPerLine, 
												calcParam.cmInputPixelOffset*8 );
				if (err) 
					goto CleanupAndExit;
			}
			calcParam.cmLineCount = inLineCount;
			err = CallCalcProc( calcRoutine, &calcParam, &lutParam );
			if (err) 
				goto CleanupAndExit;

			if( info.origSizeOut == 1 )																			/* output is 5 bit */
				Convert8To1 ( (Ptr)info.tempOutBuffer, bitMapOut.image, info.processedLinesIn, calcParam.cmLineCount, bitMapOut.width, bitMapOut.rowBytes);

			info.processedLinesIn += inLineCount;
			/* - - - - - handle CMBitmapCallBackProc - - - - - */
			if ( progressProc && ( progressTimer + kProgressTicks < (SINT32)TickCount()) )	
			{
				progressProcWasCalled = TRUE;
				if (CallCMBitmapCallBackProc ( progressProc, bitMapIn.height, info.processedLinesIn, (void *)refCon ))
				{
					info.processedLinesIn =  bitMapIn.height; 
					err = userCanceledErr;
				} else
					progressTimer = TickCount();
					progressProcCount = info.processedLinesIn;
			}
			if( !info.tempInBuffer ){
				offset = calcParam.cmLineCount * calcParam.cmInputBytesPerLine;
				for (dimLoop = 0; dimLoop< lutParam.colorLutInDim; dimLoop++)
					calcParam.inputData[dimLoop] = (Ptr)calcParam.inputData[dimLoop] + offset;
			}
			if( !info.tempOutBuffer ){
				offset = calcParam.cmLineCount * calcParam.cmOutputBytesPerLine;
				for (dimLoop = 0; dimLoop< lutParam.colorLutOutDim; dimLoop++)
					calcParam.outputData[dimLoop] =  (Ptr)calcParam.outputData[dimLoop]  + offset;
			}
		}
		DisposeIfPtr((Ptr)info.tempInBuffer);
		DisposeIfPtr((Ptr)info.tempOutBuffer);
	}
	else{
		DisposeIfPtr((Ptr)info.tempInBuffer);
		err = cmMethodError;
		goto CleanupAndExit;
	}
	if (err) 
		goto CleanupAndExit;
	
	if( progressProcWasCalled && progressProcCount != bitMapIn.height )
		CallCMBitmapCallBackProc ( progressProc, bitMapIn.height, bitMapIn.height, (void *)refCon );
CleanupAndExit:
	UNLOCK_DATA((modelingData)->gamutLutParam.inputLut);
	UNLOCK_DATA((modelingData)->gamutLutParam.colorLut);
	UNLOCK_DATA((modelingData)->gamutLutParam.outputLut);

	LH_END_PROC("LHCheckBitMapPrivate")
	
	return err;
}

#ifdef __MWERKS__
#pragma mark ================  Match/Check CMBitmaps Plane ================
#endif

/*--------------------------------------------------------------------------------------------------------------
	CMError
	LHMatchBitMapPlanePrivate	 ( CMMModelPtr				modelingData, 
								   const LH_CMBitmapPlane *	bitMapLH, 
								   CMBitmapCallBackUPP		progressProc, 
							  	   void *					refCon, 
								   LH_CMBitmapPlane *		matchedBitMapLH )
  --------------------------------------------------------------------------------------------------------------*/
CMError
LHMatchBitMapPlanePrivate	 ( CMMModelPtr				modelingData, 
							   const LH_CMBitmapPlane *	bitMapLH, 
							   CMBitmapCallBackUPP		progressProc, 
						  	   void *					refCon, 
							   LH_CMBitmapPlane *		matchedBitMapLH )
{
	CMCalcParam 	calcParam;
	CMLutParam		lutParam;
	CMError			err = -1;
	ColorSpaceInfo	info;
	CalcProcPtr		calcRoutine 		= nil;
	LH_CMBitmapPlane *	secondBitmapLH 	= matchedBitMapLH;
	OSType			inColorSpace 		= (modelingData)->firstColorSpace;
	OSType			outColorSpace 		= (modelingData)->lastColorSpace;
	Boolean			progressProcWasCalled = FALSE;
	Boolean			matchInPlace = FALSE;
	SINT32			dimLoop;
	
	LH_START_PROC("LHMatchBitMapPlanePrivate")
	
	SetMem(&info, 		sizeof(ColorSpaceInfo), 0);
 	SetMem(&calcParam,	sizeof(CMCalcParam), 	0);
 	
	if (secondBitmapLH == nil)
	{
		secondBitmapLH = (LH_CMBitmapPlane *)bitMapLH;
		matchInPlace = TRUE;
	}
	
	LOCK_DATA((modelingData)->lutParam.inputLut);
	LOCK_DATA((modelingData)->lutParam.colorLut);
	LOCK_DATA((modelingData)->lutParam.outputLut);
	
	/* create CMBitmap based on the LH_CMBitmapPlane - so we can use the 'standard' setup functions */
	{
		CMBitmap		bitMap;
		CMBitmap		secondBitmap;
	
		bitMap.image			= bitMapLH->image[0];
		bitMap.width			= bitMapLH->width;
		bitMap.height			= bitMapLH->height;
		bitMap.rowBytes			= bitMapLH->rowBytes;
		bitMap.pixelSize		= bitMapLH->pixelSize;
		bitMap.space			= bitMapLH->space;
	
		secondBitmap.image		= secondBitmapLH->image[0];
		secondBitmap.width		= secondBitmapLH->width;
		secondBitmap.height		= secondBitmapLH->height;
		secondBitmap.rowBytes	= secondBitmapLH->rowBytes;
		secondBitmap.pixelSize	= secondBitmapLH->pixelSize;
		secondBitmap.space		= secondBitmapLH->space;
	
		FillLutParam(&lutParam, modelingData);
		FillCalcParam(&calcParam, &bitMap, &secondBitmap);

		err = CheckInputColorSpace(&bitMap,&calcParam, &info, inColorSpace, lutParam.colorLutInDim );
		if (err)
			goto CleanupAndExit;
		err = CheckOutputColorSpace(&secondBitmap,&calcParam, &info, outColorSpace, lutParam.colorLutOutDim );
		if (err)
			goto CleanupAndExit;
	}
	
	/* now update the input/output data pointers */
	for (dimLoop = 0; dimLoop < 8; dimLoop++)
	{
		calcParam.inputData[dimLoop]	= bitMapLH->image[dimLoop];
		calcParam.outputData[dimLoop]	= secondBitmapLH->image[dimLoop];
	}
	
	calcParam.cmInputPixelOffset = bitMapLH->elementOffset;
	calcParam.cmOutputPixelOffset = secondBitmapLH->elementOffset;
	if (bitMapLH == secondBitmapLH)		/* matching in place - check if pixeloffsets are ok */
	{
		if (calcParam.cmInputPixelOffset < calcParam.cmOutputPixelOffset)
		{
			err = cmInvalidDstMap;
			goto CleanupAndExit;
		}
		if (info.origSizeIn * lutParam.colorLutInDim < info.origSizeOut * lutParam.colorLutOutDim)
		{
			err = cmInvalidDstMap;
			goto CleanupAndExit;
		}
	} else
	{
		calcParam.copyAlpha = (calcParam.cmInputColorSpace & cmAlphaSpace) && (calcParam.cmOutputColorSpace & cmAlphaSpace);
	}

	info.inPlace = info.tempInBuffer == nil && info.tempOutBuffer == nil;
	calcRoutine = FindCalcRoutine( &calcParam, &lutParam, &info, modelingData->lookup );
	if (calcRoutine == nil)
	{
		err = cmMethodError;
		goto CleanupAndExit;
	}
	
	/* ------------------------------------------------- 8 or 16 bit data --------------------------------------------------------- */
	if ((info.tempInBuffer == nil) && (info.tempOutBuffer == nil))
	{
		err = CallCalcProc(calcRoutine,&calcParam, &lutParam);
	}
	/* ----------------------------------------------- input is 5 or 10 bit ------------------------------------------------------- */
	else if ((info.tempInBuffer != nil) && (info.tempOutBuffer == nil))
	{
		DisposeIfPtr((Ptr)info.tempInBuffer);
	}
	/* ----------------------------------------------- output is 5 or 10 bit ------------------------------------------------------- */
	else if ((info.tempInBuffer == nil) && (info.tempOutBuffer != nil))
	{
		DisposeIfPtr((Ptr)info.tempOutBuffer);
	}
	/* ------------------------------------------ input and output are 5 or 10 bit ------------------------------------------------- */
	else
	{
		DisposeIfPtr((Ptr)info.tempInBuffer);
		DisposeIfPtr((Ptr)info.tempOutBuffer);
	}
	
	if (progressProcWasCalled)
		CallCMBitmapCallBackProc ( progressProc, 0, 0, (void *)refCon );
CleanupAndExit:
	UNLOCK_DATA((modelingData)->lutParam.inputLut);
	UNLOCK_DATA((modelingData)->lutParam.colorLut);
	UNLOCK_DATA((modelingData)->lutParam.outputLut);
		
	LH_END_PROC("LHMatchBitMapPlanePrivate")
	return err;
}

#ifdef __MWERKS__
#pragma mark ================  Utilities for NamedColor ================
#endif

/*--------------------------------------------------------------------------------------------------------------
OSErr ConvertNamedIndexToColors(	CMMModelPtr	modelingData,
									CMColor 	*theData, 
									SINT32 		pixCnt )
  --------------------------------------------------------------------------------------------------------------*/
OSErr ConvertNamedIndexToColors(	CMMModelPtr	modelingData,
									CMColor 	*theData, 
									SINT32 		pixCnt )
{
	UINT16			*tagTbl = NULL;
	LUT_DATA_TYPE	tagH = NULL;
	OSErr			err = noErr;
	UINT32			i,index;
	UINT16			*colorPtr=NULL;
	int				elemSz,deviceChannelCount,count;

	LH_START_PROC("ConvertNamedIndexToColors")
	
	if ( modelingData->hasNamedColorProf!=NoNamedColorProfile) 
	{
		/* prepare the tag table */
		tagH = modelingData->theNamedColorTagData;
		if (tagH==NULL) 
		{
			err = cmparamErr;
			goto CleanUp;
		}
		LOCK_DATA(tagH);
		
		/* tagTbl should now point to beginning of first device data */
		/* = CMNamedColor2Type_header(84) + firstName(32) + PCSSize(3*2) */
		tagTbl = (UINT16 *)DATA_2_PTR(tagH) + 61;
		
		/* find out how many bytes to skip per element. div'ed 2 for indexing purpose */
		count = ((icNamedColor2Type *)DATA_2_PTR(tagH))->ncolor.count;
		deviceChannelCount = ((icNamedColor2Type *)DATA_2_PTR(tagH))->ncolor.nDeviceCoords;
		if (deviceChannelCount==3) 
		{
			elemSz = 32+(3+3)*sizeof(SINT16);
		} else if (deviceChannelCount == 4) 
		{
			elemSz = 32+(3+4)*sizeof(SINT16);
		} else if (deviceChannelCount == 0) 
		{
			elemSz = 32+(3+0)*sizeof(SINT16);
		} else 
		{
			err = cmparamErr;
			goto CleanUp;
		}
		elemSz/=2;
		
		/* doing the actual */
		for (i=0; i<(UINT32)pixCnt; i++) 
		{
			/* go to the index'th element*/
			index = theData->namedColor.namedColorIndex;
			if (index > (UINT32)count || index == 0 ) 
			{
				err = cmNamedColorNotFound;
				goto CleanUp;
			}
			colorPtr = tagTbl + (index-1)*elemSz;
			/* put in all the info */
			if (deviceChannelCount==3) 
			{
				theData->rgb.red = *colorPtr++;
				theData->rgb.green = *colorPtr++;
				theData->rgb.blue = *colorPtr++;
			} else if (deviceChannelCount==4) 
			{
				theData->cmyk.cyan = *colorPtr++;
				theData->cmyk.magenta = *colorPtr++;
				theData->cmyk.yellow = *colorPtr++;
				theData->cmyk.black = *colorPtr++;
			}
			theData++;
		}
		UNLOCK_DATA(tagH);
	}
CleanUp:
	LH_END_PROC("ConvertNamedIndexToColors")
	return err;
}

/*--------------------------------------------------------------------------------------------------------------
OSErr ConvertNamedIndexToPCS(	CMMModelPtr		cw,
								CMColor 		*theData, 
								SINT32 			pixCnt )
  --------------------------------------------------------------------------------------------------------------*/
OSErr ConvertNamedIndexToPCS(	CMMModelPtr		cw,
								CMColor 		*theData, 
								SINT32 			pixCnt )
{
	UINT16			*tagTbl = NULL;
	LUT_DATA_TYPE	tagH = NULL;
	OSErr			err = noErr;
	UINT32			i,index;
	UINT16			*colorPtr=NULL;
	int				elemSz,deviceChannelCount,count;
	CMMModelPtr		modelingData = (CMMModelPtr)cw;

	
	LH_START_PROC("ConvertNamedIndexToPCS")
	if( cw == 0 )return cmparamErr;
	{
		/* prepare the tag table */
			tagH = modelingData->theNamedColorTagData;
		if (tagH == NULL) 
		{
			err = cmparamErr;
			goto CleanUp;
		}
		LOCK_DATA(tagH);
		
		/* tagTbl should now point to beginning of first PCS data */
		/* = CMNamedColor2Type_header(84) + firstName(32) */
		tagTbl = (UINT16 *)DATA_2_PTR(tagH) + 58;
		
		/* find out how many bytes to skip per element. div'ed 2 for indexing purpose */
		count = ((icNamedColor2Type *)DATA_2_PTR(tagH))->ncolor.count;
		deviceChannelCount = ((icNamedColor2Type *)DATA_2_PTR(tagH))->ncolor.nDeviceCoords;
		if (deviceChannelCount == 3) 
		{
			elemSz = 32+(3+3)*sizeof(SINT16);
		} else if (deviceChannelCount == 4) 
		{
			elemSz = 32+(3+4)*sizeof(SINT16);
		} else if (deviceChannelCount == 0) 
		{
			elemSz = 32+(3+0)*sizeof(SINT16);
		} else 
		{
			err = cmparamErr;
			goto CleanUp;
		}
		elemSz /= 2;
		
		/* doing the actual */
		for (i=0; i<(UINT32)pixCnt; i++) 
		{
			/* go to the index'th element*/
			index = theData->namedColor.namedColorIndex;
			if (index > (UINT32)count || index == 0 ) 
			{
				err = cmNamedColorNotFound;
				goto CleanUp;
			}
			colorPtr = tagTbl + (index-1)*elemSz;
			/* put in all the info */
			theData->Lab.L = *colorPtr++;
			theData->Lab.a = *colorPtr++;
			theData->Lab.b = *colorPtr++;
			theData++;
		}
		UNLOCK_DATA(tagH);
	}
CleanUp:
	LH_END_PROC("ConvertNamedIndexToPCS")
	return err;
}



#define	POS(x)	((x) > (0) ? (UINT32)(x) : (UINT32)(-(x)))
/*--------------------------------------------------------------------------------------------------------------
OSErr ConvertPCSToNamedIndex(	CMMModelPtr	modelingData,
								CMColor 	*theData, 
								SINT32 		pixCnt )
  --------------------------------------------------------------------------------------------------------------*/
OSErr ConvertPCSToNamedIndex(	CMMModelPtr	modelingData,
								CMColor 	*theData, 
								SINT32 		pixCnt )
{
	UINT16			*tagTbl = NULL;
	LUT_DATA_TYPE	tagH = NULL;
	OSErr			err = noErr;
	UINT32			i,j,index,dE,dEnow;
	UINT16			*colorPtr=NULL;
	int				elemSz,deviceChannelCount,count;
	
	LH_START_PROC("ConvertPCSToNamedIndex")
	if (modelingData->hasNamedColorProf == NamedColorProfileAtEnd) 
	{
		/* prepare the tag table */
		tagH = modelingData->theNamedColorTagData;
		if (tagH==NULL) 
		{
			err = cmparamErr;
			goto CleanUp;
		}
		LOCK_DATA(tagH);
		
		/* tagTbl should now point to beginning of first PCS data */
		/* = CMNamedColor2Type_header(84) + firstName(32) */
		tagTbl = (UINT16 *)DATA_2_PTR(tagH) + 58;
		
		/* find out how many bytes to skip per element. div'ed 2 for indexing purpose */
		count = ((icNamedColor2Type *)DATA_2_PTR(tagH))->ncolor.count;
		deviceChannelCount = ((icNamedColor2Type *)DATA_2_PTR(tagH))->ncolor.nDeviceCoords;
		if (deviceChannelCount == 3) 
		{
			elemSz = 32+(3+3)*sizeof(SINT16);
		} else if (deviceChannelCount == 4) 
		{
			elemSz = 32+(3+4)*sizeof(SINT16);
		} else if (deviceChannelCount == 0) 
		{
			elemSz = 32+(3+0)*sizeof(SINT16);
		} else 
		{
			err = cmparamErr;
			goto CleanUp;
		}
		elemSz/=2;
		
		/* doing the actual */
		for (i=0; i < (UINT32)pixCnt; i++) 
		{
			/* go through the whole table to find the closest one*/
			dEnow = 0x40000;	/* just arbitrarily high = 256*256*4 */
			index = (UINT32)-1;
			colorPtr = tagTbl;
			for (j=0; j < (UINT32)count; j++) 
			{
				dE =      POS((long)theData->Lab.a - *(colorPtr+1));
				dE = dE + POS((long)theData->Lab.b - *(colorPtr+2));
				dE = 2*dE + (dE>>1) + POS((long)theData->Lab.L - *(colorPtr));
				if (dE < dEnow) 
				{
					index = j;
					dEnow = dE;
				}
				colorPtr += elemSz;
			}
			theData->namedColor.namedColorIndex = index+1;
			theData++;
		}
		UNLOCK_DATA(tagH);
	}
CleanUp:
	LH_END_PROC("ConvertPCSToNamedIndex")
	return err;
}

/*--------------------------------------------------------------------------------------------------------------
CMError CMConvertNamedIndexToColors(	CMWorldRef		cw,
										CMColor 		*theData, 
										unsigned long	pixCnt )
  --------------------------------------------------------------------------------------------------------------*/
CMError CMConvertNamedIndexToColors( CMWorldRef cw, CMColor *theData, unsigned long pixCnt );
CMError CMConvertNamedIndexToColors( CMWorldRef cw, CMColor *theData, unsigned long pixCnt )
{
	return ConvertNamedIndexToColors( (CMMModelPtr)cw, theData, (SINT32)pixCnt );
}
/*--------------------------------------------------------------------------------------------------------------
CMError CMConvertNamedIndexToPCS(	CMWorldRef		cw,
									CMColor 		*theData, 
									unsigned long	pixCnt )
  --------------------------------------------------------------------------------------------------------------*/
CMError CMConvertNamedIndexToPCS( CMWorldRef cw, CMColor *theData, unsigned long pixCnt );
CMError CMConvertNamedIndexToPCS( CMWorldRef cw, CMColor *theData, unsigned long pixCnt )
{
	return ConvertNamedIndexToPCS( (CMMModelPtr)cw, theData, (SINT32)pixCnt );
}
CMError ConvertLabToIndexBitmap(	CMMModelPtr	modelingData,
									Ptr 		InBuffer,
									UINT32		processedLinesIn,
									UINT32		inLineCount,
									UINT32		width,
									UINT32		rowBytes )
{
	OSErr			err = noErr;
	LUT_DATA_TYPE	tagH=NULL;
	UINT16			*tagTbl = NULL,*colorPtr = NULL;
	int				deviceChannelCount,elemSz,count;
	UINT32			i,j,k,index,dE,dEnow;
	UINT16			LL,aa,bb;
	UINT8			*imgIn=NULL,*imgOut=NULL;
	UINT32			*imgInPtr=NULL;
	UINT8			*imgInPtr8=NULL;
	UINT8			*imgOutPtr8=NULL;
	
	LH_START_PROC("ConvertLabToIndexBitmap")
	/* prepare the tag table  */
	tagH = modelingData->theNamedColorTagData;
	if (tagH==NULL){
		err = cmparamErr;
		goto CleanUp;
	}
	LOCK_DATA(tagH);
	tagTbl = (UINT16 *)DATA_2_PTR(tagH) + 58;
	count = ((icNamedColor2Type *)DATA_2_PTR(tagH))->ncolor.count;
	deviceChannelCount = ((icNamedColor2Type *)DATA_2_PTR(tagH))->ncolor.nDeviceCoords;
	if (deviceChannelCount == 3){
		elemSz = 32+(3+3)*sizeof(SINT16);
	}
	else if (deviceChannelCount == 4){
		elemSz = 32+(3+4)*sizeof(SINT16);
	}
	else if (deviceChannelCount == 0){
		elemSz = 32+(3+0)*sizeof(SINT16);
	}
	else{
		err = cmparamErr;
		goto CleanUp;
	}
	elemSz /= 2;
	
	/* search for index */
	imgIn = (UINT8*)InBuffer + processedLinesIn * rowBytes;
	imgInPtr8=((UINT8 *)imgIn);
	LL = *(imgInPtr8+0)+1;	/* do not use cache for first pixel */
	for (i = 0; i < inLineCount; i++){
		for (j = 0; j < width; j++){
			imgInPtr8=((UINT8 *)imgIn+j*4);
			if( LL == *(imgInPtr8+0) ){
				if( aa == *(imgInPtr8+1) && bb == *(imgInPtr8+2) ){
					*((UINT32 *)imgIn+j) = index+1;
					continue;
				}
			}
			LL = *(imgInPtr8+0);
			aa = *(imgInPtr8+1);
			bb = *(imgInPtr8+2);
			/* go through the whole table to find the closest one*/
			dEnow = 0x40000;	/* just arbitrarily high = 256*256*4 */
			index =(UINT32)-1;
			colorPtr = tagTbl;
			for (k = 0; k < (UINT32)count; k++){
				dE =      POS((long)aa - (*(colorPtr+1)>>8));
				dE = dE + POS((long)bb - (*(colorPtr+2)>>8));
				dE = 2*dE + (dE>>1) + POS((long)LL - (*(colorPtr)>>8));			/* Quantization L = 2.55 * (a|b) */
				if (dE < dEnow){
					index = k;
					dEnow = dE;
				}
				colorPtr += elemSz;
			}
			*((UINT32 *)imgIn+j) = index+1;
		}
		imgIn+=rowBytes;
	}
CleanUp:
	UNLOCK_DATA(tagH);
	LH_END_PROC("ConvertLabToIndexBitmap")
	return err;
}
CMError ConvertIndexToLabBitmap(	CMMModelPtr	modelingData,
									Ptr		 	InBuffer,
									Ptr		 	OutBuffer,
									UINT32		processedLinesIn,
									UINT32		lineCount,
									UINT32		inWidth,
									UINT32		inRowBytes,
									UINT32		outRowBytes,
									UINT32		outputSize )
{
	OSErr			err = noErr;
	LUT_DATA_TYPE	tagH=NULL;
	UINT16			*tagTbl = NULL,*ColorPtr = NULL;
	UINT32			*imgIn=NULL;
	UINT8			*imgOut=NULL;
	int				deviceChannelCount,elemSz;
	UINT32			i,j,index,countNamesInProfile;
	
	LH_START_PROC("ConvertIndexToLabBitmap")
	/* set up the table for indexing */
	tagH = modelingData->theNamedColorTagData;
	if (tagH==NULL) {
		err = cmparamErr;
		goto CleanUp;
	}
	
	LOCK_DATA(tagH);
	tagTbl = (UINT16 *)DATA_2_PTR(tagH) + 58;		/* points to PCS */
	deviceChannelCount = ((icNamedColor2Type *)DATA_2_PTR(tagH))->ncolor.nDeviceCoords;
	countNamesInProfile = ((icNamedColor2Type *)DATA_2_PTR(tagH))->ncolor.count;
	if (deviceChannelCount==3) {
		elemSz = 32+(3+3)*sizeof(UINT16);
	} else if (deviceChannelCount==4) {
		elemSz = 32+(3+4)*sizeof(UINT16);
	} else if (deviceChannelCount==0) {
		elemSz = 32+(3+0)*sizeof(UINT16);
	} else {
		err = cmparamErr;
		goto CleanUp;
	}
	elemSz/=2;
	
	/* ...and convert the data from index to PCS values */
	for( i=processedLinesIn; i<processedLinesIn+lineCount; i++ ){
		imgIn = (UINT32 *)(InBuffer + i * inRowBytes);
		imgOut = (UINT8*)OutBuffer + (i-processedLinesIn) * outRowBytes;
		if( outputSize == 24 ){
			for (j=0;j<inWidth;j++) {
				index = *imgIn++;
				if( index == 0 || index > countNamesInProfile ){
					err = cmNamedColorNotFound;
					goto CleanUp;
				}

				ColorPtr = tagTbl + (index-1)*elemSz;
				*imgOut++  = (*ColorPtr++)>>8;
				*imgOut++  = (*ColorPtr++)>>8;
				*imgOut++  = (*ColorPtr++)>>8;
			}
		}
		else if( outputSize == 32 ){
			for (j=0;j<inWidth;j++) {
				index = *imgIn++;
				if( index == 0 || index > countNamesInProfile ){
					err = cmNamedColorNotFound;
					goto CleanUp;
				}

				ColorPtr = tagTbl + (index-1)*elemSz;
				*imgOut++  = (*ColorPtr++)>>8;
				*imgOut++  = (*ColorPtr++)>>8;
				*imgOut    = (*ColorPtr++)>>8;
				imgOut += 2;
			}
		}
	}
CleanUp:
	UNLOCK_DATA(tagH);
	LH_END_PROC("ConvertIndexToLabBitmap")
	return err;
}

#include <string.h>
CMError CMConvNameToIndex( icNamedColor2Type *Data, pcCMColorName Ptr2Name, unsigned long *Arr2Indices, unsigned long count );
CMError CMConvNameToIndex( icNamedColor2Type *Data, pcCMColorName Ptr2Name, unsigned long *Arr2Indices, unsigned long count )
{	
	OSErr		err = noErr;
	UINT32		i,index,l,len;
	char		*colorPtr=NULL;
	long 		elemSz,deviceChannelCount,countNamesInProfile;
	const char	*aPtr;
	Ptr			tagTbl;

	LH_START_PROC("CMConvNameToIndex")
	
	if( Data == 0 || count == 0 )return cmparamErr;
		
	tagTbl = &Data->ncolor.data[0];
	/* find out how many bytes to skip per element. div'ed 2 for indexing purpose */
	countNamesInProfile = Data->ncolor.count;
	deviceChannelCount = Data->ncolor.nDeviceCoords;
	if (deviceChannelCount==3){
		elemSz = 32+(3+3)*sizeof(SINT16);
	}
	else if (deviceChannelCount == 4){
		elemSz = 32+(3+4)*sizeof(SINT16);
	}
	else if (deviceChannelCount == 0){
		elemSz = 32+(3+0)*sizeof(SINT16);
	}
	else{
		err = cmparamErr;
		goto CleanUp;
	}
	
	for (i=0; i<(UINT32)count; i++){
		colorPtr = tagTbl;
		len = strlen( Ptr2Name[i] );
		aPtr = Ptr2Name[i];
		for( index = 0; index < (UINT32)countNamesInProfile; index++ ){
			for( l = 0; l<len; l++ ){
				if( colorPtr[l] != aPtr[l] )break;
				if( colorPtr[l] == 0 )break;
			}
			if( l >= len )break;
			colorPtr += elemSz;
		}
		if( l < len )index = 0;	/* not found */
		else index++;			/* Indices are 1 based */

		/* put in all the info */
		if( index == 0 ){
			err = cmNamedColorNotFound;
			goto CleanUp;
		}
		Arr2Indices[i] = index;
	}
CleanUp:
	LH_END_PROC("CMConvNameToIndex")
	return err;
}

CMError CMConvNameToIndexCW( CMWorldRef *Storage, pcCMColorName Ptr2Name, unsigned long *Arr2Indices, unsigned long count);
CMError CMConvNameToIndexCW( CMWorldRef *Storage, pcCMColorName Ptr2Name, unsigned long *Arr2Indices, unsigned long count)
{	
	Ptr					tagTbl = NULL;
	LUT_DATA_TYPE		tagH = NULL;
	CMError				err = noErr;
	char				*colorPtr=NULL;
	CMMModelPtr 		modelingData;
	icNamedColor2Type 	*namedData;

	LH_START_PROC("CMConvNameToIndexCW")
	
	if( Storage == 0 )return cmparamErr;
	LOCK_DATA( Storage );
	modelingData = (CMMModelPtr)(DATA_2_PTR(	Storage ));
	if ( modelingData->hasNamedColorProf!=NoNamedColorProfile) 
	{
		/* prepare the tag table */
		tagH = modelingData->theNamedColorTagData;
		if (tagH==NULL){
			err = cmparamErr;
			goto CleanUp;
		}
		LOCK_DATA(tagH);
		
		namedData = (icNamedColor2Type *)DATA_2_PTR(tagH);
		err = CMConvNameToIndex( namedData, Ptr2Name, Arr2Indices, count );
		UNLOCK_DATA(tagH);
	}
CleanUp:
	UNLOCK_DATA( Storage );
	LH_END_PROC("CMConvNameToIndexCW")
	return err;
}
CMError CMConvNameToIndexProfile( CMProfileRef aProf, pcCMColorName Ptr2Name, unsigned long *Arr2Indices, unsigned long count);
CMError CMConvNameToIndexProfile( CMProfileRef aProf, pcCMColorName Ptr2Name, unsigned long *Arr2Indices, unsigned long count)
{
	CMError				err;
	short				aOSerr;
	icNamedColor2Type	*aName = 0;
	unsigned long		byteCount;

	LH_START_PROC("CMConvNameToIndexProfile")
	
	if( aProf == 0 )return cmparamErr;
	err = CMGetPartialProfileElement(	aProf,
										icSigNamedColor2Tag,
										0,
										&byteCount,
										0 );
	if (err)
		goto CleanupAndExit;
    aName = (icNamedColor2Type *)SmartNewPtr( byteCount, &aOSerr );
	err = aOSerr;
	if (err)
		goto CleanupAndExit;
	err = CMGetPartialProfileElement(	aProf,
										icSigNamedColor2Tag,
										0,
										&byteCount,
										(Ptr)aName );
	if (err){
		goto CleanupAndExit;
	}

#ifdef IntelMode
	SwapLongOffset( &aName->ncolor.count, 0, 4 );
	SwapLongOffset( &aName->ncolor.nDeviceCoords, 0, 4 );
#endif
	err = CMConvNameToIndex( aName, Ptr2Name, Arr2Indices, count );

CleanupAndExit:
	DisposeIfPtr( (Ptr)aName );
	LH_END_PROC("CMConvNameToIndexProfile")
	return err;
}

CMError CMConvIndexToName( icNamedColor2Type *Data, unsigned long *Arr2Indices, pCMColorName Ptr2Name, unsigned long count);
CMError CMConvIndexToName( icNamedColor2Type *Data, unsigned long *Arr2Indices, pCMColorName Ptr2Name, unsigned long count)
{	
	Ptr				tagTbl = NULL;
	OSErr			err = noErr;
	UINT32			i,index;
	char			*colorPtr=NULL;
	long 			elemSz,deviceChannelCount,countNamesInProfile;

	LH_START_PROC("CMConvIndexToName")
	
	if( Data == 0 || count == 0 )return cmparamErr;
	tagTbl = &Data->ncolor.data[0];
		
	/* find out how many bytes to skip per element. div'ed 2 for indexing purpose */
	countNamesInProfile = Data->ncolor.count;
	deviceChannelCount = Data->ncolor.nDeviceCoords;
	if (deviceChannelCount==3){
		elemSz = 32+(3+3)*sizeof(SINT16);
	}
	else if (deviceChannelCount == 4){
		elemSz = 32+(3+4)*sizeof(SINT16);
	} 
	else if (deviceChannelCount == 0){
		elemSz = 32+(3+0)*sizeof(SINT16);
	}
	else{
		err = cmparamErr;
		goto CleanUp;
	}
	
	/* doing the actual */
	for (i=0; i<(UINT32)count; i++){
		/* go to the index'th element*/
		index = Arr2Indices[i];
		if (index > (UINT32)countNamesInProfile || index == 0 ) 
		{
			err = cmNamedColorNotFound;
			goto CleanUp;
		}
		colorPtr = tagTbl + (index-1)*elemSz;
		/* put in all the info */
		strcpy( Ptr2Name[i], colorPtr );
	}

CleanUp:
	LH_END_PROC("CMConvIndexToName")
	return err;
}

CMError CMConvIndexToNameCW( CMWorldRef *Storage, unsigned long *Arr2Indices, pCMColorName Ptr2Name, unsigned long count);
CMError CMConvIndexToNameCW( CMWorldRef *Storage, unsigned long *Arr2Indices, pCMColorName Ptr2Name, unsigned long count)
{	
	Ptr					tagTbl = NULL;
	LUT_DATA_TYPE		tagH = NULL;
	CMError				err = noErr;
	char				*colorPtr=NULL;
	CMMModelPtr 		modelingData;
	icNamedColor2Type 	*namedData;

	LH_START_PROC("CMConvIndexToNameCW")
	
	if( Storage == 0 )return cmparamErr;
	LOCK_DATA( Storage );
	modelingData = (CMMModelPtr)(DATA_2_PTR(	Storage ));
	if ( modelingData->hasNamedColorProf!=NoNamedColorProfile) 
	{
		/* prepare the tag table */
		tagH = modelingData->theNamedColorTagData ;
		if (tagH==NULL){
			err = cmparamErr;
			goto CleanUp;
		}
		LOCK_DATA(tagH);
		
		namedData = (icNamedColor2Type *)DATA_2_PTR(tagH);
		err = CMConvIndexToName( namedData, Arr2Indices, Ptr2Name, count );
		UNLOCK_DATA(tagH);
	}
CleanUp:
	UNLOCK_DATA( Storage );
	LH_END_PROC("CMConvIndexToNameCW")
	return err;
}
CMError CMConvIndexToNameProfile( CMProfileRef aProf, unsigned long *Arr2Indices, pCMColorName Ptr2Name, unsigned long count);
CMError CMConvIndexToNameProfile( CMProfileRef aProf, unsigned long *Arr2Indices, pCMColorName Ptr2Name, unsigned long count)
{
	CMError				err;
	short				aOSerr;
	icNamedColor2Type	*aName = 0;
	unsigned long		byteCount;

	LH_START_PROC("CMConvIndexToNameProfile")
	
	if( aProf == 0 )return cmparamErr;
	err = CMGetPartialProfileElement(	aProf,
										icSigNamedColor2Tag,
										0,
										&byteCount,
										0 );
	if (err)
		goto CleanupAndExit;
    aName = (icNamedColor2Type *)SmartNewPtr( byteCount, &aOSerr );
	err = aOSerr;
	if (err)
		goto CleanupAndExit;
	err = CMGetPartialProfileElement(	aProf,
										icSigNamedColor2Tag,
										0,
										&byteCount,
										(Ptr)aName );
	if (err){
		goto CleanupAndExit;
	}

#ifdef IntelMode
	SwapLongOffset( &aName->ncolor.count, 0, 4 );
	SwapLongOffset( &aName->ncolor.nDeviceCoords, 0, 4 );
#endif
	err = CMConvIndexToName( aName, Arr2Indices, Ptr2Name, count );

CleanupAndExit:
	DisposeIfPtr( (Ptr)aName );
	LH_END_PROC("CMConvIndexToNameProfile")
	return err;
}

CMError CMGetNamedProfileInfoProfile( CMProfileRef aProf, pCMNamedProfileInfo Info );
CMError CMGetNamedProfileInfoProfile( CMProfileRef aProf, pCMNamedProfileInfo Info )
{	
	CMError				err = noErr;
	Ptr					tagTbl;
	short				aOSerr;
	icNamedColor2Type	*aName = 0;
	unsigned long		byteCount;

	LH_START_PROC("CMGetNamedProfileInfoProfile")
	
	if( aProf == 0 )return cmparamErr;
	err = CMGetPartialProfileElement(	aProf,
										icSigNamedColor2Tag,
										0,
										&byteCount,
										0 );
	if (err)
		goto CleanupAndExit;
    aName = (icNamedColor2Type *)SmartNewPtr( byteCount, &aOSerr );
	err = aOSerr;
	if (err)
		goto CleanupAndExit;
	err = CMGetPartialProfileElement(	aProf,
										icSigNamedColor2Tag,
										0,
										&byteCount,
										(Ptr)aName );
	if (err){
		goto CleanupAndExit;
	}

	
	/* = CMNamedColor2Type_header(84) + firstName(32) + PCSSize(3*2) */
	tagTbl = (Ptr)aName + 8;
	
#ifdef IntelMode
	SwapLongOffset( &aName->ncolor.count, 0, 4 );
	SwapLongOffset( &aName->ncolor.nDeviceCoords, 0, 4 );
	SwapLongOffset( &aName->ncolor.vendorFlag, 0, 4 );
#endif
	memcpy( Info, tagTbl, sizeof( CMNamedProfileInfo ));
CleanupAndExit:
	LH_END_PROC("CMGetNamedProfileInfoProfile")
	return err;
}
CMError CMGetNamedProfileInfoCW( CMWorldRef *Storage, pCMNamedProfileInfo Info );
CMError CMGetNamedProfileInfoCW( CMWorldRef *Storage, pCMNamedProfileInfo Info )
{	
	LUT_DATA_TYPE	tagH = NULL;
	OSErr			err = noErr;
	CMMModelPtr 	modelingData;
	Ptr				tagTbl;

	LH_START_PROC("CMGetNamedProfileInfoCW")
	
	if( Storage == 0 )return cmparamErr;
	LOCK_DATA( Storage );
	modelingData = (CMMModelPtr)(DATA_2_PTR(	Storage ));
	if( modelingData->hasNamedColorProf != NoNamedColorProfile ){
		/* prepare the tag table */
		tagH = modelingData->theNamedColorTagData;
		if (tagH==NULL){
			err = cmparamErr;
			goto CleanUp;
		}
		LOCK_DATA(tagH);
		
		/* tagTbl should now point to beginning of first device data */
		/* = CMNamedColor2Type_header(84) + firstName(32) + PCSSize(3*2) */
		tagTbl = (Ptr)DATA_2_PTR(tagH) + 8;
		
		memcpy( Info, tagTbl, sizeof( CMNamedProfileInfo ));
		UNLOCK_DATA(tagH);
	}
CleanUp:
	UNLOCK_DATA( Storage );
	LH_END_PROC("CMGetNamedProfileInfoCW")
	return err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\mscmm.w98\lh_core\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

MAJORCOMP=gdi
MINORCOMP=cmm_core

!ifndef ICMROOT
ICMROOT=$(NTGDI_PATH)\icm
!endif

!include $(ICMROOT)\icmsrc.inc

TARGETNAME=lh_core
TARGETTYPE=LIBRARY
TARGETPATH=..\$(ALT_PROJECT_TARGET)\$(_OBJ_DIR)
INCLUDES=..\.;..\..\lh_open

C_DEFINES=$(C_DEFINES) -DWIN32 -D__MSDOS__ -DIntelMode -DRenderInt -DMS_Icm

SOURCES= ..\calcndim.c \
         ..\dondim.c   \
         ..\fragment.c \
         ..\frgmnt16.c \
         ..\gen.c      \
         ..\genluts.c  \
         ..\genup.c    \
         ..\routines.c \
         ..\runtime.c  \
         ..\stdconv.c  \
         ..\gen1dim.c  \
         ..\memlink.c  \
         ..\genfast.c  \
         ..\calcnd3.c
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\mscmm.w98\lh_core\typedefs.h ===
/*
	File:		LHTypeDefs.h

	Contains:	

	Written by:	U. J. Krabbenhoeft

	Version:

	Copyright:	 1993-1997 by Heidelberger Druckmaschinen AG, all rights reserved.

*/

#ifndef LHTypeDefs_h
#define LHTypeDefs_h

/* flags to keep track if there is a named profile in the profile sequenc */
enum 
{
	NoNamedColorProfile 		= 0x0000,
	NamedColorProfileOnly		= 0x0001,
	NamedColorProfileAtBegin	= 0x0002,
	NamedColorProfileAtEnd		= 0x0003
};



/* ------------------------------------------------------------------------------------------------------------
	CMLutParam - lut struct - set in the Initphase and used by the Match/Check routines 
   ------------------------------------------------------------------------------------------------------------ */
typedef struct CMLutParam
{
	long 				inputLutEntryCount;		/* count of entries for input lut for one dimension */
	long 				inputLutWordSize;		/* count of bits of each entry ( e.g. 16 for UINT16 ) */
	LUT_DATA_TYPE		inputLut;				/* pointer/handle to input lut */
	long 				outputLutEntryCount;	/* count of entries for output lut for one dimension	 */
	long 				outputLutWordSize;		/* count of bits of each entry ( e.g. 8 for UINT8 ) */
	LUT_DATA_TYPE		outputLut;				/* pointer/handle to output lut */
	long 				colorLutInDim;			/* input dimension  ( e.g. 3 for LAB ; 4 for CMYK ) */
	long 				colorLutOutDim;			/* output dimension ( e.g. 3 for LAB ; 4 for CMYK ) */
	long 				colorLutGridPoints;		/* count of gridpoints for color lut ( for one Dimension ) */
	long 				colorLutWordSize;		/* count of bits of each entry ( e.g. 8 for UINT8 ) */
	LUT_DATA_TYPE		colorLut;				/* pointer/handle to color lut */

	/* --------- used in Init-Phase by CreateCombi ------------ */
	Ptr 				matrixTRC;
	Ptr 				matrixMFT;

	/* ---------- used for DoNDim - DoNDimTableData ------------*/
	unsigned long		cmInputColorSpace;		/* packing info for input		*/
	unsigned long		cmOutputColorSpace;		/* packing info for output		*/
	void*				userData;
} CMLutParam, *CMLutParamPtr, **CMLutParamHdl;


/* ------------------------------------------------------------------------------------------------------------
	CMCalcParam - calc struct for the Match/Check routines 
   ------------------------------------------------------------------------------------------------------------ */

typedef struct CMCalcParam
{
	CMBitmapColorSpace	cmInputColorSpace;		/* input color space */
	CMBitmapColorSpace	cmOutputColorSpace;		/* output color space */
	long				cmPixelPerLine;			/* pixel per line */
	long				cmLineCount;			/* number of lines */
	long				cmInputBytesPerLine;	/* bytes per line */
	long				cmOutputBytesPerLine;	/* bytes per line */
	long				cmInputPixelOffset;		/* offset to next input pixel */
	long				cmOutputPixelOffset;	/* offset to next output pixel */
	void*				inputData[8];			/* 8 pointers to input data */
	void*				outputData[8];			/* 8 pointers to output data */
	Boolean				copyAlpha;				/* true -> copy alpha */
	Boolean				clearMask;				/* true -> set to zero  false-> copy alpha (if any) */
} CMCalcParam, *CMCalcParamPtr, **CMCalcParamHdl;



/* ------------------------------------------------------------------------------------------------------------
	DoNDimCalcData - calc data for DoNDim 
   ------------------------------------------------------------------------------------------------------------ */
struct DoNDimCalcData
{ 	
	long 	pixelCount;			/* count of input pixels	*/
	Ptr		inputData;			/* input array				*/
	Ptr		outputData;			/* output array				*/
};
typedef struct DoNDimCalcData DoNDimCalcData, *DoNDimCalcDataPtr, **DoNDimCalcDataHdl;

/* ------------------------------------------------------------------------------------------------------------
	LHCombiData - struct used in initphase while creating the combi-luts 

   ------------------------------------------------------------------------------------------------------------ */
typedef struct LHCombiData
{
	CMProfileRef	theProfile;
	OSType			profileClass;
	OSType			dataColorSpace;
	OSType			profileConnectionSpace;
	long			gridPointsCube;
	long			renderingIntent;
	long			precision;
	long			maxProfileCount;
	long			profLoop;
	Boolean			doCreate_16bit_ELut;
	Boolean			doCreate_16bit_XLut;
	Boolean			doCreate_16bit_ALut;
	Boolean			doCreateLinkProfile;
	Boolean			doCreate_16bit_Combi;
	Boolean			doCreateGamutLut;
	Boolean			amIPCS;
	Boolean			usePreviewTag;
} LHCombiData, *LHCombiDataPtr, **LHCombiDataHdl;
#if powerc
#pragma options align=reset
#endif

#if powerc
#pragma options align=mac68k
#endif
/* ------------------------------------------------------------------------------------------------------------
	LHProfile - internal information for one profile 
   ------------------------------------------------------------------------------------------------------------ */
typedef struct LHProfile
{
	CMProfileRef	profileSet;
	short			pcsConversionMode;
	short			usePreviewTag;
	unsigned long	renderingIntent;
} LHProfile;

/* ------------------------------------------------------------------------------------------------------------
	LHConcatProfileSet - internal information for a set of profiles 
   ------------------------------------------------------------------------------------------------------------ */
typedef struct LHConcatProfileSet 
{
	unsigned short			keyIndex;				/* Zero-based							*/
	unsigned short			count;					/* Min 1								*/
	LHProfile				prof[1];				/* Variable. Ordered from Source -> Dest*/
} LHConcatProfileSet;
#if powerc
#pragma options align=reset
#endif


/* ------------------------------------------------------------------------------------------------------------
	CMMModelData - global CMM data 
   ------------------------------------------------------------------------------------------------------------ */
/*
#if powerc
#pragma options align=mac68k
#endif
*/
struct CMMModelData 
{
	CMLutParam				lutParam;
	CMLutParam				gamutLutParam;

	short					precision;
	Boolean					lookup;					/* false -> interpolation,  true -> lookup only */
		
	OSType					firstColorSpace;
	OSType					lastColorSpace;
	
	long					currentCall;
	long					lastCall;

	long					srcProfileVersion;
	long					dstProfileVersion;
	Handle					Monet;
	
	/* for NamedColor matching */
	long				hasNamedColorProf;
	Handle				thePCSProfHandle;
	LUT_DATA_TYPE		theNamedColorTagData;

	/*OSType				dataColorSpace;*/
	/*OSType				profileConnectionSpace;*/

	UINT32				*aIntentArr;
	UINT32				nIntents;
	UINT32				dwFlags;
	Boolean				appendDeviceLink;					/* if count > 1 && last profile is deviceLink */
	CMWorldRef			pBackwardTransform;
#if	__IS_MAC
	ComponentInstance	accelerationComponent;
#endif
};
typedef struct CMMModelData CMMModelData, *CMMModelPtr, **CMMModelHandle;

/*
#if powerc
#pragma options align=reset
#endif
*/


typedef double Matrix2D[3][3];

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\mscmm.w98\lh_open\pi_basic.h ===
/*
	File:		PI_Basic.h

	Contains:	

	Written by:	U. J. Krabbenhoeft

	Version:

	Copyright:	 1993-1997 by Heidelberger Druckmaschinen AG, all rights reserved.

*/


#ifndef PI_BasicTypes_h
#define PI_BasicTypes_h

#define TRUE 1
#define FALSE 0
#define nil 0

#ifndef NULL
#define NULL 0
#endif

typedef double DREAL;			/* double Werte fr Datenaustausch */
typedef float REAL;				/* Floating Werte fr Datenaustausch */


typedef	unsigned char	UINT8;
typedef	unsigned short	UINT16;
typedef	unsigned int	UINT32;

typedef	signed char		INT8;
typedef	signed short	INT16;
typedef	signed int		INT32;

typedef	char	SINT8;
typedef	short	SINT16;
typedef	long	SINT32;

typedef	char	SInt8;
typedef	short	SInt16;
typedef	long	SInt32;

typedef	float			Float32;			/* IEEE 	32bits (04Byte), 1 for sign, 08 for exponent, 23 mantissa */
typedef	double			Float64;			/* IEEE 	64bits (08Byte), 1 for sign, 11 for exponent, 52 mantissa */
typedef	long double		Float80;			/* IEEE 	80bits (10Byte), 1 for sign, 15 for exponent, 64 mantissa */

typedef unsigned char Boolean;
typedef unsigned char Str255[256], Str63[64], Str32[33], Str31[32], Str27[28], Str15[16];
typedef char *Ptr;
typedef char **Handle;

struct Point {
    short							v;
    short							h;
};
typedef struct Point Point;

typedef Point *PointPtr;
struct Rect {
    short							top;
    short							left;
    short							bottom;
    short							right;
};
typedef struct Rect Rect;
typedef	UINT32	Fixed;
typedef UINT32 OSType;
typedef short OSErr;

typedef Rect *RectPtr;

/*
 *	Here ends the list of things that "belong" in Windows.
 */
struct RGBColor {
    unsigned short					red;						/*magnitude of red component*/
    unsigned short					green;						/*magnitude of green component*/
    unsigned short					blue;						/*magnitude of blue component*/
};
typedef struct RGBColor RGBColor, *RGBColorPtr, **RGBColorHdl;

struct ColorSpec {
    short							value;						/*index or other value*/
    RGBColor						rgb;						/*true color*/
};
typedef struct ColorSpec ColorSpec;

typedef ColorSpec *ColorSpecPtr;

typedef ColorSpec CSpecArray[1];

struct ColorTable {
    long							ctSeed;						/*unique identifier for table*/
    short							ctFlags;					/*high bit: 0 = PixMap; 1 = device*/
    short							ctSize;						/*number of entries in CTTable*/
    CSpecArray						ctTable;					/*array [0..0] of ColorSpec*/
};
typedef struct ColorTable ColorTable, *CTabPtr, **CTabHandle;

struct PixMap {
    Ptr								baseAddr;					/*pointer to pixels*/
    short							rowBytes;					/*offset to next line*/
    Rect							bounds;						/*encloses bitmap*/
    short							pmVersion;					/*pixMap version number*/
    short							packType;					/*defines packing format*/
    long							packSize;					/*length of pixel data*/
    Fixed							hRes;						/*horiz. resolution (ppi)*/
    Fixed							vRes;						/*vert. resolution (ppi)*/
    short							pixelType;					/*defines pixel type*/
    short							pixelSize;					/*# bits in pixel*/
    short							cmpCount;					/*# components in pixel*/
    short							cmpSize;					/*# bits per component*/
    long							planeBytes;					/*offset to next plane*/
    CTabHandle						pmTable;					/*color map for this pixMap*/
    long							pmReserved;					/*for future use. MUST BE 0*/
};
typedef struct PixMap PixMap, *PixMapPtr, **PixMapHandle;

struct ColorWorldInstanceRecord {
    long							data[4];
};
typedef struct ColorWorldInstanceRecord ColorWorldInstanceRecord;

typedef ColorWorldInstanceRecord *ColorWorldInstance;

struct BitMap {
    Ptr								baseAddr;
    short							rowBytes;
    Rect							bounds;
};
typedef struct BitMap BitMap;

typedef BitMap *BitMapPtr, **BitMapHandle;

struct Picture {
    short							picSize;
    Rect							picFrame;
};
typedef struct Picture Picture;

typedef Picture *PicPtr, **PicHandle;

struct DateTimeRec {
    short							year;
    short							month;
    short							day;
    short							hour;
    short							minute;
    short							second;
    short							dayOfWeek;
};
typedef struct DateTimeRec DateTimeRec;

enum {
    noErr						= 0,
    unimpErr					= -4,		/* unimplemented core routine, should NOT occure */
	notEnoughMemoryErr    		= 8L	    /* mem Error used in ProfileAccess.c only, from winerror.h		*/
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\mscmm.w98\lh_core\stdconv.c ===
/*
	File:		LH_StdConversionLuts.c

	Contains:	conversion lut generation

	Written by:	H.Siegeritz

	Copyright:	 1993-1997 by Heidelberger Druckmaschinen AG, all rights reserved.

*/
#ifndef LHGeneralIncs_h
#include "General.h"
#endif

#ifndef __LHStdConversionLuts__
#include "StdConv.h"
#endif

#if ! realThing
#ifdef DEBUG_OUTPUT
#define kThisFile kLHStdConversionLutsID
#define __TYPES__
#endif
#endif


/* ______________________________________________________________________

	void
		Lab2XYZ_forCube16(	unsigned short	*theCube,
							long			count )
	
	Abstract:
		converts Lab data (16 bit) to linear XYZ (16 bit, 0 to 2.0)

	Params:
		theCube			(in/out)	cube grid data
		count			(in)		number of grid points

	Return:
		noErr			successful
   _____________________________________________________________________ */

void  Lab2XYZ_forCube16(unsigned short *theCube, long count)
{
	register unsigned short *v;
	long			i;
	long			lon_aOff, lon_bOff, lon_L, Xl, Yl, Zl;
	long			fract, index, leftVal, rightVal, lAux;

#ifdef DEBUG_OUTPUT
	OSErr err=noErr;
#endif

#ifdef SYM_C
	unsigned short	L2Y[432];
	v = L2Y;
	*v++=    0; *v++=    7; *v++=   14; *v++=   21; *v++=   28; *v++=   35; *v++=   43; *v++=   50;
	*v++=   57; *v++=   64; *v++=   71; *v++=   78; *v++=   85; *v++=   92; *v++=   99; *v++=  106;
	*v++=  113; *v++=  120; *v++=  128; *v++=  135; *v++=  142; *v++=  149; *v++=  156; *v++=  164;
	*v++=  171; *v++=  180; *v++=  188; *v++=  196; *v++=  205; *v++=  214; *v++=  224; *v++=  233;
	*v++=  243; *v++=  253; *v++=  263; *v++=  274; *v++=  285; *v++=  296; *v++=  308; *v++=  320;
	*v++=  332; *v++=  344; *v++=  357; *v++=  370; *v++=  384; *v++=  397; *v++=  411; *v++=  426;
	*v++=  440; *v++=  455; *v++=  471; *v++=  487; *v++=  503; *v++=  519; *v++=  536; *v++=  553;
	*v++=  570; *v++=  588; *v++=  606; *v++=  625; *v++=  644; *v++=  663; *v++=  683; *v++=  703;
	*v++=  723; *v++=  744; *v++=  766; *v++=  787; *v++=  809; *v++=  832; *v++=  855; *v++=  878;
	*v++=  902; *v++=  926; *v++=  950; *v++=  975; *v++= 1001; *v++= 1027; *v++= 1053; *v++= 1080;
	*v++= 1107; *v++= 1135; *v++= 1163; *v++= 1192; *v++= 1221; *v++= 1250; *v++= 1280; *v++= 1311;
	*v++= 1342; *v++= 1373; *v++= 1405; *v++= 1438; *v++= 1470; *v++= 1504; *v++= 1538; *v++= 1572;
	*v++= 1607; *v++= 1643; *v++= 1679; *v++= 1715; *v++= 1752; *v++= 1790; *v++= 1828; *v++= 1866;
	*v++= 1906; *v++= 1945; *v++= 1986; *v++= 2026; *v++= 2068; *v++= 2110; *v++= 2152; *v++= 2195;
	*v++= 2239; *v++= 2283; *v++= 2328; *v++= 2373; *v++= 2419; *v++= 2466; *v++= 2513; *v++= 2561;
	*v++= 2609; *v++= 2658; *v++= 2707; *v++= 2757; *v++= 2808; *v++= 2860; *v++= 2912; *v++= 2964;
	*v++= 3018; *v++= 3071; *v++= 3126; *v++= 3181; *v++= 3237; *v++= 3293; *v++= 3351; *v++= 3408;
	*v++= 3467; *v++= 3526; *v++= 3586; *v++= 3646; *v++= 3707; *v++= 3769; *v++= 3831; *v++= 3895;
	*v++= 3959; *v++= 4023; *v++= 4088; *v++= 4154; *v++= 4221; *v++= 4288; *v++= 4356; *v++= 4425;
	*v++= 4495; *v++= 4565; *v++= 4636; *v++= 4708; *v++= 4780; *v++= 4853; *v++= 4927; *v++= 5002;
	*v++= 5077; *v++= 5153; *v++= 5230; *v++= 5308; *v++= 5386; *v++= 5466; *v++= 5546; *v++= 5626;
	*v++= 5708; *v++= 5790; *v++= 5874; *v++= 5957; *v++= 6042; *v++= 6128; *v++= 6214; *v++= 6301;
	*v++= 6389; *v++= 6478; *v++= 6567; *v++= 6658; *v++= 6749; *v++= 6841; *v++= 6934; *v++= 7028;
	*v++= 7122; *v++= 7218; *v++= 7314; *v++= 7411; *v++= 7509; *v++= 7608; *v++= 7707; *v++= 7808;
	*v++= 7909; *v++= 8012; *v++= 8115; *v++= 8219; *v++= 8324; *v++= 8430; *v++= 8536; *v++= 8644;
	*v++= 8753; *v++= 8862; *v++= 8972; *v++= 9084; *v++= 9196; *v++= 9309; *v++= 9423; *v++= 9538;
	*v++= 9654; *v++= 9770; *v++= 9888; *v++=10007; *v++=10126; *v++=10247; *v++=10368; *v++=10491;
	*v++=10614; *v++=10739; *v++=10864; *v++=10991; *v++=11118; *v++=11246; *v++=11375; *v++=11506;
	*v++=11637; *v++=11769; *v++=11902; *v++=12037; *v++=12172; *v++=12308; *v++=12446; *v++=12584;
	*v++=12723; *v++=12864; *v++=13005; *v++=13147; *v++=13291; *v++=13435; *v++=13581; *v++=13727;
	*v++=13875; *v++=14024; *v++=14173; *v++=14324; *v++=14476; *v++=14629; *v++=14783; *v++=14938;
	*v++=15094; *v++=15252; *v++=15410; *v++=15569; *v++=15730; *v++=15891; *v++=16054; *v++=16218;
	*v++=16383; *v++=16549; *v++=16716; *v++=16885; *v++=17054; *v++=17225; *v++=17396; *v++=17569;
	*v++=17743; *v++=17918; *v++=18094; *v++=18272; *v++=18450; *v++=18630; *v++=18811; *v++=18993;
	*v++=19176; *v++=19361; *v++=19546; *v++=19733; *v++=19921; *v++=20110; *v++=20301; *v++=20492;
	*v++=20685; *v++=20879; *v++=21074; *v++=21270; *v++=21468; *v++=21667; *v++=21867; *v++=22068;
	*v++=22270; *v++=22474; *v++=22679; *v++=22885; *v++=23093; *v++=23301; *v++=23511; *v++=23723;
	*v++=23935; *v++=24149; *v++=24364; *v++=24580; *v++=24798; *v++=25016; *v++=25237; *v++=25458;
	*v++=25681; *v++=25905; *v++=26130; *v++=26356; *v++=26584; *v++=26814; *v++=27044; *v++=27276;
	*v++=27509; *v++=27744; *v++=27979; *v++=28216; *v++=28455; *v++=28695; *v++=28936; *v++=29178;
	*v++=29422; *v++=29668; *v++=29914; *v++=30162; *v++=30411; *v++=30662; *v++=30914; *v++=31167;
	*v++=31422; *v++=31678; *v++=31936; *v++=32195; *v++=32455; *v++=32717; *v++=32980; *v++=33245;
	*v++=33511; *v++=33778; *v++=34047; *v++=34317; *v++=34589; *v++=34862; *v++=35137; *v++=35413;
	*v++=35690; *v++=35969; *v++=36249; *v++=36531; *v++=36814; *v++=37099; *v++=37385; *v++=37673;
	*v++=37962; *v++=38252; *v++=38544; *v++=38838; *v++=39133; *v++=39429; *v++=39727; *v++=40027;
	*v++=40328; *v++=40630; *v++=40934; *v++=41240; *v++=41547; *v++=41855; *v++=42165; *v++=42477;
	*v++=42790; *v++=43105; *v++=43421; *v++=43739; *v++=44058; *v++=44379; *v++=44701; *v++=45025;
	*v++=45351; *v++=45678; *v++=46006; *v++=46337; *v++=46668; *v++=47002; *v++=47337; *v++=47673;
	*v++=48011; *v++=48351; *v++=48692; *v++=49035; *v++=49380; *v++=49726; *v++=50074; *v++=50423;
	*v++=50774; *v++=51127; *v++=51481; *v++=51837; *v++=52194; *v++=52554; *v++=52914; *v++=53277;
	*v++=53641; *v++=54007; *v++=54374; *v++=54743; *v++=55114; *v++=55486; *v++=55861; *v++=56236;
	*v++=56614; *v++=56993; *v++=57374; *v++=57756; *v++=58141; *v++=58526; *v++=58914; *v++=59303;
	*v++=59694; *v++=60087; *v++=60482; *v++=60878; *v++=61276; *v++=61675; *v++=62077; *v++=62480;
	*v++=62885; *v++=63292; *v++=63700; *v++=64110; *v++=64522; *v++=64935; *v++=65351; *v++=65535;

#else
	static unsigned short	L2Y[432] = {		/* L==100 (65535 resp 256) -> 2 ^ 14 - 1  Static OK? */
						    0,     7,    14,    21,    28,    35,    43,    50,
						   57,    64,    71,    78,    85,    92,    99,   106,
						  113,   120,   128,   135,   142,   149,   156,   164,
						  171,   180,   188,   196,   205,   214,   224,   233,
						  243,   253,   263,   274,   285,   296,   308,   320,
						  332,   344,   357,   370,   384,   397,   411,   426,
						  440,   455,   471,   487,   503,   519,   536,   553,
						  570,   588,   606,   625,   644,   663,   683,   703,
						  723,   744,   766,   787,   809,   832,   855,   878,
						  902,   926,   950,   975,  1001,  1027,  1053,  1080,
						 1107,  1135,  1163,  1192,  1221,  1250,  1280,  1311,
						 1342,  1373,  1405,  1438,  1470,  1504,  1538,  1572,
						 1607,  1643,  1679,  1715,  1752,  1790,  1828,  1866,
						 1906,  1945,  1986,  2026,  2068,  2110,  2152,  2195,
						 2239,  2283,  2328,  2373,  2419,  2466,  2513,  2561,
						 2609,  2658,  2707,  2757,  2808,  2860,  2912,  2964,
						 3018,  3071,  3126,  3181,  3237,  3293,  3351,  3408,
						 3467,  3526,  3586,  3646,  3707,  3769,  3831,  3895,
						 3959,  4023,  4088,  4154,  4221,  4288,  4356,  4425,
						 4495,  4565,  4636,  4708,  4780,  4853,  4927,  5002,
						 5077,  5153,  5230,  5308,  5386,  5466,  5546,  5626,
						 5708,  5790,  5874,  5957,  6042,  6128,  6214,  6301,
						 6389,  6478,  6567,  6658,  6749,  6841,  6934,  7028,
						 7122,  7218,  7314,  7411,  7509,  7608,  7707,  7808,
						 7909,  8012,  8115,  8219,  8324,  8430,  8536,  8644,
						 8753,  8862,  8972,  9084,  9196,  9309,  9423,  9538,
						 9654,  9770,  9888, 10007, 10126, 10247, 10368, 10491,
						10614, 10739, 10864, 10991, 11118, 11246, 11375, 11506,
						11637, 11769, 11902, 12037, 12172, 12308, 12446, 12584,
						12723, 12864, 13005, 13147, 13291, 13435, 13581, 13727,
						13875, 14024, 14173, 14324, 14476, 14629, 14783, 14938,
						15094, 15252, 15410, 15569, 15730, 15891, 16054, 16218,
						16383, 16549, 16716, 16885, 17054, 17225, 17396, 17569,
						17743, 17918, 18094, 18272, 18450, 18630, 18811, 18993,
						19176, 19361, 19546, 19733, 19921, 20110, 20301, 20492,
						20685, 20879, 21074, 21270, 21468, 21667, 21867, 22068,
						22270, 22474, 22679, 22885, 23093, 23301, 23511, 23723,
						23935, 24149, 24364, 24580, 24798, 25016, 25237, 25458,
						25681, 25905, 26130, 26356, 26584, 26814, 27044, 27276,
						27509, 27744, 27979, 28216, 28455, 28695, 28936, 29178,
						29422, 29668, 29914, 30162, 30411, 30662, 30914, 31167,
						31422, 31678, 31936, 32195, 32455, 32717, 32980, 33245,
						33511, 33778, 34047, 34317, 34589, 34862, 35137, 35413,
						35690, 35969, 36249, 36531, 36814, 37099, 37385, 37673,
						37962, 38252, 38544, 38838, 39133, 39429, 39727, 40027,
						40328, 40630, 40934, 41240, 41547, 41855, 42165, 42477,
						42790, 43105, 43421, 43739, 44058, 44379, 44701, 45025,
						45351, 45678, 46006, 46337, 46668, 47002, 47337, 47673,
						48011, 48351, 48692, 49035, 49380, 49726, 50074, 50423,
						50774, 51127, 51481, 51837, 52194, 52554, 52914, 53277,
						53641, 54007, 54374, 54743, 55114, 55486, 55861, 56236,
						56614, 56993, 57374, 57756, 58141, 58526, 58914, 59303,
						59694, 60087, 60482, 60878, 61276, 61675, 62077, 62480,
						62885, 63292, 63700, 64110, 64522, 64935, 65351, 65535 };
#endif

	LH_START_PROC("Lab2XYZ_forCube16")

	v = theCube;											/* pos. of first color */
	
	for(i=0; i<count; i++)
	{
		lon_L    = (long)v[0];
		lon_aOff = (long)v[1];
		lon_bOff = (long)v[2];
		
	/* If Xl is an L*-distorted X value: Xl = 116/500 * a + L (from CIELAB formula).  */
		
		Xl = ((lon_aOff * 19 + 15) >> 5) - 19456 + lon_L;	/* -19456 for -128 */
		if(Xl < 0)											/* Xl=65535 with white */
			Xl = 0;
		else
		{
			index = Xl >> 8;
			if(index > 431)						/* end of table */
				Xl = (long)L2Y[431] << 1;
			else											/* ordinary case */
			{
				fract    = Xl & 0x0FF;						/* 8 bits for interpolation */
				leftVal  = (long)L2Y[index];
				rightVal = (long)L2Y[index + 1];
				lAux     = (fract * (rightVal - leftVal) + 63) >> 7;	/* one bit more */
				Xl       = (leftVal << 1) + lAux;
			}
		}
		
	/* If Zl is an L*-distorted Z value: Zl = L - 116/200 * b (from CIELAB formula).  */

		Zl = lon_L - ((lon_bOff * 95 + 31) >> 6) + 48640;	/* +48640 for -128 */
		if(Zl < 0)											/* Zl=65535 with white */
			Zl = 0;
		else
		{
			index = Zl >> 8;
			if(index > 431)						/* end of table */
				Zl = (long)L2Y[431] << 1;
			else											/* ordinary case */
			{
				fract    = Zl & 0x0FF;						/* 8 bits for interpolation */
				leftVal  = (long)L2Y[index];
				rightVal = (long)L2Y[index + 1];
				lAux     = (fract * (rightVal - leftVal) + 63) >> 7;	/* one bit more */
				Zl       = (leftVal << 1) + lAux;
			}
		}
				
		Yl = lon_L;
		{
			index = Yl >> 8;								/* Y value; L<=100 -> Y index < 431 */
			{												/* ordinary case */
				fract    = Yl & 0x0FF;						/* 8 bits for interpolation */
				leftVal  = (long)L2Y[index];
				rightVal = (long)L2Y[index + 1];
				lAux     = (fract * (rightVal - leftVal) + 63) >> 7;	/* one bit more */
				Yl       = (leftVal << 1) + lAux;
			}	
		}
		
		
			/* D50 adjustment for X and Z, which are in 0 ... 1.623 range */
		Xl = (Xl * 31595 + 16384) >> 15;		/* factor 0.9642 */
		Zl = (Zl * 13515 +  8192) >> 14;		/* factor 0.8249 */

		if (Xl > 65535) Xl = 65535;
		if (Zl > 65535) Zl = 65535;
		
		*v++ = (unsigned short)Xl;							/* X value */
		*v++ = (unsigned short)Yl;							/* Y value */
		*v++ = (unsigned short)Zl;							/* Z value */
	}
	LH_END_PROC("Lab2XYZ_forCube16")
}
/* ______________________________________________________________________

	void
		XYZ2Lab_forCube16(	unsigned short	*theCube,
							long			count )
	
	Abstract:
		converts cube grid from XYZ (16 bit linear, 0 to 2.0) to Lab (16 bit)

	Params:
		theCube			(in/out)	cube grid data
		count			(in)		number of grid points

	Return:
		noErr			successful
   _____________________________________________________________________ */
void  XYZ2Lab_forCube16(unsigned short *theCube, long count)
{
	register unsigned short *v;
	long			i;
	long			lon_aOff, lon_bOff, lon_X, lon_Y, lon_Z;
	long			fract, index, leftVal, rightVal;

#ifdef DEBUG_OUTPUT
	OSErr err=noErr;
#endif

#ifdef SYM_C
	unsigned short	Y2L[432];
	v = Y2L;
	*v++=    0; *v++= 1156; *v++= 2312; *v++= 3391; *v++= 4260; *v++= 4993; *v++= 5635; *v++= 6208;
	*v++= 6730; *v++= 7209; *v++= 7654; *v++= 8070; *v++= 8462; *v++= 8833; *v++= 9185; *v++= 9520;
	*v++= 9841; *v++=10149; *v++=10445; *v++=10731; *v++=11006; *v++=11273; *v++=11531; *v++=11781;
	*v++=12024; *v++=12261; *v++=12491; *v++=12716; *v++=12935; *v++=13149; *v++=13358; *v++=13562;
	*v++=13762; *v++=13958; *v++=14150; *v++=14338; *v++=14523; *v++=14704; *v++=14883; *v++=15058;
	*v++=15230; *v++=15399; *v++=15565; *v++=15729; *v++=15890; *v++=16049; *v++=16206; *v++=16360;
	*v++=16512; *v++=16662; *v++=16810; *v++=16957; *v++=17101; *v++=17243; *v++=17384; *v++=17522;
	*v++=17659; *v++=17795; *v++=17929; *v++=18061; *v++=18192; *v++=18322; *v++=18450; *v++=18577;
	*v++=18702; *v++=18826; *v++=18949; *v++=19070; *v++=19191; *v++=19310; *v++=19428; *v++=19545;
	*v++=19661; *v++=19775; *v++=19889; *v++=20002; *v++=20114; *v++=20224; *v++=20334; *v++=20443;
	*v++=20551; *v++=20658; *v++=20764; *v++=20869; *v++=20974; *v++=21077; *v++=21180; *v++=21282;
	*v++=21383; *v++=21484; *v++=21584; *v++=21683; *v++=21781; *v++=21878; *v++=21975; *v++=22072;
	*v++=22167; *v++=22262; *v++=22356; *v++=22450; *v++=22543; *v++=22635; *v++=22727; *v++=22818;
	*v++=22908; *v++=22998; *v++=23087; *v++=23176; *v++=23265; *v++=23352; *v++=23439; *v++=23526;
	*v++=23612; *v++=23698; *v++=23783; *v++=23868; *v++=23952; *v++=24035; *v++=24119; *v++=24201;
	*v++=24284; *v++=24365; *v++=24447; *v++=24528; *v++=24608; *v++=24688; *v++=24768; *v++=24847;
	*v++=24926; *v++=25004; *v++=25082; *v++=25159; *v++=25237; *v++=25313; *v++=25390; *v++=25466;
	*v++=25541; *v++=25617; *v++=25692; *v++=25766; *v++=25840; *v++=25914; *v++=25988; *v++=26061;
	*v++=26134; *v++=26206; *v++=26278; *v++=26350; *v++=26421; *v++=26493; *v++=26563; *v++=26634;
	*v++=26704; *v++=26774; *v++=26844; *v++=26913; *v++=26982; *v++=27051; *v++=27119; *v++=27187;
	*v++=27255; *v++=27323; *v++=27390; *v++=27457; *v++=27524; *v++=27590; *v++=27656; *v++=27722;
	*v++=27788; *v++=27853; *v++=27919; *v++=27983; *v++=28048; *v++=28112; *v++=28177; *v++=28241;
	*v++=28304; *v++=28368; *v++=28431; *v++=28494; *v++=28556; *v++=28619; *v++=28681; *v++=28743;
	*v++=28805; *v++=28867; *v++=28928; *v++=28989; *v++=29050; *v++=29111; *v++=29171; *v++=29231;
	*v++=29291; *v++=29351; *v++=29411; *v++=29470; *v++=29530; *v++=29589; *v++=29647; *v++=29706;
	*v++=29765; *v++=29823; *v++=29881; *v++=29939; *v++=29996; *v++=30054; *v++=30111; *v++=30168;
	*v++=30225; *v++=30282; *v++=30339; *v++=30395; *v++=30451; *v++=30507; *v++=30563; *v++=30619;
	*v++=30674; *v++=30730; *v++=30785; *v++=30840; *v++=30895; *v++=30949; *v++=31004; *v++=31058;
	*v++=31112; *v++=31166; *v++=31220; *v++=31274; *v++=31327; *v++=31381; *v++=31434; *v++=31487;
	*v++=31540; *v++=31593; *v++=31645; *v++=31698; *v++=31750; *v++=31802; *v++=31854; *v++=31906;
	*v++=31958; *v++=32010; *v++=32061; *v++=32112; *v++=32164; *v++=32215; *v++=32265; *v++=32316;
	*v++=32367; *v++=32417; *v++=32468; *v++=32518; *v++=32568; *v++=32618; *v++=32668; *v++=32717;
	*v++=32767; *v++=32816; *v++=32866; *v++=32915; *v++=32964; *v++=33013; *v++=33062; *v++=33110;
	*v++=33159; *v++=33207; *v++=33256; *v++=33304; *v++=33352; *v++=33400; *v++=33448; *v++=33495;
	*v++=33543; *v++=33590; *v++=33638; *v++=33685; *v++=33732; *v++=33779; *v++=33826; *v++=33873;
	*v++=33919; *v++=33966; *v++=34013; *v++=34059; *v++=34105; *v++=34151; *v++=34197; *v++=34243;
	*v++=34289; *v++=34335; *v++=34380; *v++=34426; *v++=34471; *v++=34516; *v++=34562; *v++=34607;
	*v++=34652; *v++=34697; *v++=34741; *v++=34786; *v++=34831; *v++=34875; *v++=34919; *v++=34964;
	*v++=35008; *v++=35052; *v++=35096; *v++=35140; *v++=35184; *v++=35227; *v++=35271; *v++=35314;
	*v++=35358; *v++=35401; *v++=35444; *v++=35488; *v++=35531; *v++=35574; *v++=35617; *v++=35659;
	*v++=35702; *v++=35745; *v++=35787; *v++=35830; *v++=35872; *v++=35914; *v++=35956; *v++=35998;
	*v++=36040; *v++=36082; *v++=36124; *v++=36166; *v++=36208; *v++=36249; *v++=36291; *v++=36332;
	*v++=36373; *v++=36415; *v++=36456; *v++=36497; *v++=36538; *v++=36579; *v++=36620; *v++=36660;
	*v++=36701; *v++=36742; *v++=36782; *v++=36823; *v++=36863; *v++=36903; *v++=36943; *v++=36984;
	*v++=37024; *v++=37064; *v++=37104; *v++=37143; *v++=37183; *v++=37223; *v++=37262; *v++=37302;
	*v++=37342; *v++=37381; *v++=37420; *v++=37459; *v++=37499; *v++=37538; *v++=37577; *v++=37616;
	*v++=37655; *v++=37693; *v++=37732; *v++=37771; *v++=37810; *v++=37848; *v++=37887; *v++=37925;
	*v++=37963; *v++=38002; *v++=38040; *v++=38078; *v++=38116; *v++=38154; *v++=38192; *v++=38230;
	*v++=38268; *v++=38305; *v++=38343; *v++=38381; *v++=38418; *v++=38456; *v++=38493; *v++=38530;
	*v++=38568; *v++=38605; *v++=38642; *v++=38679; *v++=38716; *v++=38753; *v++=38790; *v++=38827;
	*v++=38864; *v++=38900; *v++=38937; *v++=38974; *v++=39010; *v++=39047; *v++=39083; *v++=39119;
	*v++=39156; *v++=39192; *v++=39228; *v++=39264; *v++=39300; *v++=39336; *v++=39372; *v++=39408;
	*v++=39444; *v++=39480; *v++=39516; *v++=39551; *v++=39587; *v++=39622; *v++=39658; *v++=39693;
	*v++=39729; *v++=39764; *v++=39799; *v++=39835; *v++=39870; *v++=39905; *v++=39940; *v++=39975;
#else
	static unsigned short	Y2L[439] = {			/* Y==1.0 is at 256 (not 255) and -> 2^15-1 Static OK? */
						    0,  1156,  2312,  3391,  4260,  4993,  5635,  6208,
						 6730,  7209,  7654,  8070,  8462,  8833,  9185,  9520,
						 9841, 10149, 10445, 10731, 11006, 11273, 11531, 11781,
						12024, 12261, 12491, 12716, 12935, 13149, 13358, 13562,
						13762, 13958, 14150, 14338, 14523, 14704, 14883, 15058,
						15230, 15399, 15565, 15729, 15890, 16049, 16206, 16360,
						16512, 16662, 16810, 16957, 17101, 17243, 17384, 17522,
						17659, 17795, 17929, 18061, 18192, 18322, 18450, 18577,
						18702, 18826, 18949, 19070, 19191, 19310, 19428, 19545,
						19661, 19775, 19889, 20002, 20114, 20224, 20334, 20443,
						20551, 20658, 20764, 20869, 20974, 21077, 21180, 21282,
						21383, 21484, 21584, 21683, 21781, 21878, 21975, 22072,
						22167, 22262, 22356, 22450, 22543, 22635, 22727, 22818,
						22908, 22998, 23087, 23176, 23265, 23352, 23439, 23526,
						23612, 23698, 23783, 23868, 23952, 24035, 24119, 24201,
						24284, 24365, 24447, 24528, 24608, 24688, 24768, 24847,
						24926, 25004, 25082, 25159, 25237, 25313, 25390, 25466,
						25541, 25617, 25692, 25766, 25840, 25914, 25988, 26061,
						26134, 26206, 26278, 26350, 26421, 26493, 26563, 26634,
						26704, 26774, 26844, 26913, 26982, 27051, 27119, 27187,
						27255, 27323, 27390, 27457, 27524, 27590, 27656, 27722,
						27788, 27853, 27919, 27983, 28048, 28112, 28177, 28241,
						28304, 28368, 28431, 28494, 28556, 28619, 28681, 28743,
						28805, 28867, 28928, 28989, 29050, 29111, 29171, 29231,
						29291, 29351, 29411, 29470, 29530, 29589, 29647, 29706,
						29765, 29823, 29881, 29939, 29996, 30054, 30111, 30168,
						30225, 30282, 30339, 30395, 30451, 30507, 30563, 30619,
						30674, 30730, 30785, 30840, 30895, 30949, 31004, 31058,
						31112, 31166, 31220, 31274, 31327, 31381, 31434, 31487,
						31540, 31593, 31645, 31698, 31750, 31802, 31854, 31906,
						31958, 32010, 32061, 32112, 32164, 32215, 32265, 32316,
						32367, 32417, 32468, 32518, 32568, 32618, 32668, 32717,
						32767, 32816, 32866, 32915, 32964, 33013, 33062, 33110,
						33159, 33207, 33256, 33304, 33352, 33400, 33448, 33495,
						33543, 33590, 33638, 33685, 33732, 33779, 33826, 33873,
						33919, 33966, 34013, 34059, 34105, 34151, 34197, 34243,
						34289, 34335, 34380, 34426, 34471, 34516, 34562, 34607,
						34652, 34697, 34741, 34786, 34831, 34875, 34919, 34964,
						35008, 35052, 35096, 35140, 35184, 35227, 35271, 35314,
						35358, 35401, 35444, 35488, 35531, 35574, 35617, 35659,
						35702, 35745, 35787, 35830, 35872, 35914, 35956, 35998,
						36040, 36082, 36124, 36166, 36208, 36249, 36291, 36332,
						36373, 36415, 36456, 36497, 36538, 36579, 36620, 36660,
						36701, 36742, 36782, 36823, 36863, 36903, 36943, 36984,
						37024, 37064, 37104, 37143, 37183, 37223, 37262, 37302,
						37342, 37381, 37420, 37459, 37499, 37538, 37577, 37616,
						37655, 37693, 37732, 37771, 37810, 37848, 37887, 37925,
						37963, 38002, 38040, 38078, 38116, 38154, 38192, 38230,
						38268, 38305, 38343, 38381, 38418, 38456, 38493, 38530,
						38568, 38605, 38642, 38679, 38716, 38753, 38790, 38827,
						38864, 38900, 38937, 38974, 39010, 39047, 39083, 39119,
						39156, 39192, 39228, 39264, 39300, 39336, 39372, 39409,
						39444, 39480, 39516, 39551, 39588, 39622, 39658, 39693,
						39729, 39764, 39799, 39835, 39870, 39905, 39940, 39975,
						27253, 29259, 25185, 25954, 26734, 25967, 29798 };
#endif
	
	LH_START_PROC("XYZ2Lab_forCube16")

	v = theCube;							/* pos. of first color */

	for(i=0; i<count; i++)
	{
		lon_X = (long)v[0];					/* lin. 16 bit XYZ values */
		lon_Y = (long)v[1];
		lon_Z = (long)v[2];
		
			/*------transform to L* - distorted values------*/
			
		index = lon_Y >> 7;		/* adjust for table lookup, lin. XYZ: 1.0 -> 32767 */
		fract = lon_Y & 0x7F;	/* 7 bit for interpolation */
		if(index < 431)			/* within table range ? */
		{
			leftVal  = Y2L[index];
			rightVal = Y2L[index + 1];
			lon_Y    = leftVal + ((fract * (rightVal - leftVal) + 63) >> 7);
		}
		else
			lon_Y = Y2L[431];				/* clip to the end of the table */
		
			/* D50 to white adjustment for X and Z:*/
		
		lon_X = 531 * lon_X >> 4;	/* factor 1./0.9642 with (* 531 >> 9) */
		index = lon_X >> 12;
		fract = lon_X & 0x0FFF;		/* (9 - 4) + 7 = 12 bit for interpolation */
		if(index < 431)				/* within table range ? */
		{
			leftVal  = Y2L[index];
			rightVal = Y2L[index + 1];
			lon_X    = leftVal + ((fract * (rightVal - leftVal) + 2047) >> 12);
		}
		else
			lon_X = Y2L[431];				/* clip to the end of the table */
		
		lon_Z = lon_Z * 9931 >> 8; /* factor 1./0.8249 with (* 9931 >> 13) */
		index = lon_Z >> 12;
		fract = lon_Z & 0x0FFF;		/* (13 - 8) + 7 = 12 bit for interpolation */
		if(index < 431)				/* within table range ? */
		{
			leftVal  = Y2L[index];
			rightVal = Y2L[index + 1];
			lon_Z    = leftVal + ((fract * (rightVal - leftVal) + 2047) >> 12);
		}
		else
			lon_Z = Y2L[431];				/* clip to the end of the table */
		
	/* lon_Z, lon_Z, lon_Z are L* -distorted values now with 100 <-> 32767 */
		
				/* 431 >> 7 : factor 3.3676 = 500. / 116. * 100 / 32767 * 256 */
		lon_aOff = ((lon_X - lon_Y) * 431 + 4194368) >> 7; /* 4194368 = (32768 + 0.5) * 2^7 */
		if(lon_aOff & 0xFFFF0000)
		{							/* clip to range 0...65535 (a = -128 ... 127.996) */
			if(lon_aOff < 0)
				lon_aOff = 0;
			else if(lon_aOff > 65535)
				lon_aOff = 65535;
		}
		
				/* 11035 >> 13 : factor 1.437 = 200. / 116. * 100 / 32767 * 256 */
		lon_bOff = ((lon_Y - lon_Z) * 11035 + 268439552) >> 13; /* 268439552 = (32768 + 0.5) * 2^13 */
		if(lon_bOff & 0xFFFF0000)
		{							/* clip to range 0...65535 (b = -128 ... 127.996) */
			if(lon_bOff < 0)
				lon_bOff = 0;
			else if(lon_bOff > 65535)
				lon_bOff = 65535;
		}
		
		lon_Y <<= 1;			/* see range of table above */
		if(lon_Y > 65535)
			lon_Y = 65535;		/* clip L if > 100 */

		*v++ = (unsigned short)lon_Y;		/* L */
		*v++ = (unsigned short)lon_aOff;	/* a */
		*v++ = (unsigned short)lon_bOff;	/* b */
	}
	LH_END_PROC("XYZ2Lab_forCube16")
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\mscmm.w98\lh_open\pi_cmm.h ===
/*
	File:		PI_CMMInitialization.h

	Contains:	Initialization procdures 
				
	Written by:	U. J. Krabbenhoeft

	Version:

	Copyright:	 1993-1997 by Heidelberger Druckmaschinen AG, all rights reserved.

	File Ownership:

*/
#ifndef PI_CMMInitialization_h
#define PI_CMMInitialization_h
CMError CMMInitPrivate( 			CMMModelPtr 		storage, 
						 			CMProfileRef 		srcProfile, 
						 			CMProfileRef 		dstProfile );
CMError CMMConcatInitPrivate	( 	CMMModelPtr 		storage, 
						  			CMConcatProfileSet 	*profileSet);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\mscmm.w98\lh_core\routines.c ===
/*
	File:		LHTheRoutines.c

	Contains:	

	Written by:	U. J. Krabbenhoeft

	Copyright:	 1993-1997 by Heidelberger Druckmaschinen AG, all rights reserved.

*/
#ifndef LHGeneralIncs_h
#include "General.h"
#endif

#ifndef LHTheRoutines_h
#include "Routines.h"
#endif

#if FARBR_FILES
static FILE *stream1;
#endif
#define exit  return
#if ! realThing
#ifdef DEBUG_OUTPUT
#define __TYPES__
#define kThisFile kLHTheRoutinesID
#endif
#endif

#define CLIPP(x,a) ((x)<(a)?(x):(a))

static void SetValues( long current, long inputDim, long needBits, UINT8 **Poi );

OSErr
CalcGridPoints4Cube ( long	theCubeSize,
					  long	inputDim,
					  long* theGridPoints,
					  long* theGridBits )
{
	long 			aSize,needBits,theSize;
	register long 	loop,gridPoints;
	OSErr			err = noErr;

	LH_START_PROC("CalcGridPoints4Cube")
	
	if( inputDim > 8 ) 
	{
		err = cmparamErr;
		goto CleanupAndExit;
	}
	aSize = theCubeSize / inputDim;
	needBits=0;
	do
	{
		needBits++;
		gridPoints = (1<<needBits);
		theSize = gridPoints;
		for( loop=1; loop<inputDim; ++loop)
			theSize *= gridPoints;
	} while( aSize >= theSize );
	needBits--;
	if( needBits <= 0 ) 
	{
		err = cmparamErr;
		goto CleanupAndExit;
	}
	*theGridBits = needBits;
	*theGridPoints = (1<<needBits);
CleanupAndExit:
	LH_END_PROC("CalcGridPoints4Cube")
	return err;
}

OSErr
MakeCube( long 				inputDim, 
		  long 				*theCubeSize,
		  CUBE_DATA_TYPE	*theCube,
		  long 				*theBits )
{
	long 			needBits,theSize;
	long 			i,gridPoints;
	OSErr			err = noErr;
	UINT8 			*cube = nil;
	CUBE_DATA_TYPE	tempCube;
	/*
	long DivisionReplace[]={ 0,0,7,255, 6,85, 12,4663, 4,17, 15,33693, 12,4145, 14,16449,
	 						 0, 1, 9,511, 10,1021, 11,2041, 12,4081, 13,8161, 14,16321, 15,32641, 16,65281};	
	*/
	
	LH_START_PROC("MakeCube")
	err = CalcGridPoints4Cube(*theCubeSize, inputDim, &gridPoints, &needBits);
	if (err)
		goto CleanupAndExit;
		
	theSize = gridPoints;
	for( i=1; i<inputDim; ++i)
		theSize *= gridPoints;

	*theCubeSize = theSize * inputDim;
	tempCube = ALLOC_DATA(theSize * inputDim, &err);
	if (err != noErr) 
		goto CleanupAndExit;
	LOCK_DATA(tempCube);
	cube = (UINT8*)DATA_2_PTR(tempCube);

	if( inputDim == 3)
	{
		register long  aShift;
		register long  j,k;
		register UINT8 aI, aJ;
		aShift = (8 - needBits) ;
		/*
		aShift = DivisionReplace[2*needBits] - (8 - needBits) ;
		if( aShift < 0 ){
			aFactor = DivisionReplace[2*needBits+1]*(1<<(-aShift));
			aShift = 0;
		}
		else aFactor = DivisionReplace[2*needBits+1];
		*/
		for( i=0; i<gridPoints; ++i){
			aI = (UINT8)(i<< aShift);
			for( j=0; j<gridPoints; ++j){
				aJ = (UINT8)(j<< aShift);
				for( k=0; k<gridPoints; ++k){
					*cube++ = aI; 
					*cube++ = aJ; 
					*cube++ =(UINT8)(k<< aShift); 
				}
			}
		}
	}
	else
	{
		SetValues( 0, inputDim, needBits, &cube );
	}
	*theBits = needBits;
	UNLOCK_DATA(tempCube);
	*theCube = tempCube;
CleanupAndExit:
	LH_END_PROC("MakeCube")
	return err;
}

#define UWE 2
#ifdef UWE
void SetValues16( long current, long inputDim, long needBits, UINT16 **Poi );
OSErr MakeCube16(	long 			inputDim, 
		  			long 			*theCubeSize,
		  			CUBE_DATA_TYPE	*theCube,
		  			long 			*theBits,
		  			long 			*theExtraSize )
{
	long 			needBits,theSize,aExtraSize;
	long 			i,gridPoints;
	OSErr			err = noErr;
	UINT16 			*cube = nil;
	CUBE_DATA_TYPE	tempCube;
	
	LH_START_PROC("MakeCube16")
	/*
		long DivisionReplace[]={ 0,0,7,255, 6,85, 12,4663, 4,17, 15,33693, 12,4145, 14,16449,
							 0, 1, 9,511, 10,1021, 11,2041, 12,4081, 13,8161, 14,16321, 15,32641, 16,65281};
	*/
	err = CalcGridPoints4Cube(*theCubeSize, inputDim, &gridPoints, &needBits);
	if (err)
		goto CleanupAndExit;
		
	theSize = 1;
	aExtraSize = 1;
	for( i=0; i<(inputDim-1); ++i){	/* Extra Size for Interpolation */
		theSize *= gridPoints;
		aExtraSize += theSize;
	}
	
#ifdef ALLOW_MMX
	aExtraSize++;	/* +1 for MMX 4 Byte access */
#endif
    theSize *= gridPoints;
    	
	*theExtraSize = aExtraSize;
	*theCubeSize = theSize * inputDim;
	tempCube = ALLOC_DATA( (theSize+aExtraSize) * inputDim*2, &err);
	if (err != noErr) 
		goto CleanupAndExit;
	LOCK_DATA(tempCube);
	cube = (UINT16*)DATA_2_PTR(tempCube);

	if( inputDim == 3)
	{
		register long  aShift;
		register long  j,k;
		register UINT16 aI, aJ, aK;
		aShift = (16 - needBits) ;
		/*
		aShift = DivisionReplace[2*needBits] - (8 - needBits) ;
		if( aShift < 0 ){
			aFactor = DivisionReplace[2*needBits+1]*(1<<(-aShift));
			aShift = 0;
		}
		else aFactor = DivisionReplace[2*needBits+1];
		*/
		for( i=0; i<gridPoints; ++i){
			aI = (UINT16)(i<< aShift);
			aI |= aI >> needBits;
			aI |= aI >> (2*needBits);
			aI |= aI >> (4*needBits);
			for( j=0; j<gridPoints; ++j){
				aJ = (UINT16)(j<< aShift);
				aJ |= aJ >> needBits;
				aJ |= aJ >> (2*needBits);
				aJ |= aJ >> (4*needBits);
				for( k=0; k<gridPoints; ++k){
					*cube++ = aI; 
					*cube++ = aJ;
					aK = (UINT16)(k<< aShift);
					aK |= aK >> needBits;
					aK |= aK >> (2*needBits);
					aK |= aK >> (4*needBits);
					*cube++ = aK; 
				}
			}
		}
	}
	else if( inputDim == 4)
	{
		register long  aShift;
		register long  j,k,l;
		register UINT16 aI, aJ, aK, aL;
		aShift = (16 - needBits) ;
		/*
		aShift = DivisionReplace[2*needBits] - (8 - needBits) ;
		if( aShift < 0 ){
			aFactor = DivisionReplace[2*needBits+1]*(1<<(-aShift));
			aShift = 0;
		}
		else aFactor = DivisionReplace[2*needBits+1];
		*/
		for( i=0; i<gridPoints; ++i){
			aI = (UINT16)(i<< aShift);
			aI |= aI >> needBits;
			aI |= aI >> (2*needBits);
			aI |= aI >> (4*needBits);
			for( j=0; j<gridPoints; ++j){
				aJ = (UINT16)(j<< aShift);
				aJ |= aJ >> needBits;
				aJ |= aJ >> (2*needBits);
				aJ |= aJ >> (4*needBits);
				for( k=0; k<gridPoints; ++k){
					aK = (UINT16)(k<< aShift);
					aK |= aK >> needBits;
					aK |= aK >> (2*needBits);
					aK |= aK >> (4*needBits);
					for( l=0; l<gridPoints; ++l){
						*cube++ = aI; 
						*cube++ = aJ;
						*cube++ = aK;
						aL = (UINT16)(l<< aShift);
						aL |= aL >> needBits;
						aL |= aL >> (2*needBits);
						aL |= aL >> (4*needBits);
						*cube++ = aL; 
					}
				}
			}
		}
	}
	else
	{
		SetValues16( 0, inputDim, needBits, &cube );
	}
	*theBits = needBits;
	UNLOCK_DATA(tempCube);
	*theCube = tempCube;
CleanupAndExit:
	LH_END_PROC("MakeCube16")
	return err;
}

void SetValues16( long current, long inputDim, long needBits, UINT16 **Poi )
{	
	register unsigned long lastPoint;
	register unsigned long aVal;
	register long i;
	register UINT16 u;
	
#ifdef DEBUG_OUTPUT
	OSErr err=noErr;
#endif
	/*	LH_START_PROC("SetValues16") */
	aVal = 0;
	lastPoint = (1<<needBits)-1;
	do{
		u = (UINT16)(aVal<<(16-needBits));
		u |= u >> needBits;
		u |= u >> (2*needBits);
		u |= u >> (4*needBits);
		**Poi = u;
		(*Poi)++;
		if( current < inputDim-1 ) SetValues16( current+1, inputDim, needBits, Poi );
		if( aVal < lastPoint ){	/* its the last one*/
			if( current > 0 )for( i=0; i<current; ++i)*((*Poi) + i) = *((*Poi) - inputDim + i);
			(*Poi) += current;
		}
		aVal++;
	}while( aVal <= lastPoint );
	/*	LH_END_PROC("SetValues16") */
}

#endif

OSErr
MakeCMColorCube( long inputDim, 
				 long *theCubeSize,
				 CUBE_DATA_TYPE *aHdlPtr,
			  	 long *theBits )
{
	long 	needBits,theSize;
	long 	i,gridPoints;
	OSErr	err = noErr;
	UINT16 	*cube = nil;
	register long aMaxVal;
	register long aShift;
	long		  aRound;
	
	LH_START_PROC("MakeCMColorCube")
	
	err = CalcGridPoints4Cube(*theCubeSize, inputDim, &gridPoints, &needBits);
	if (err)
		goto CleanupAndExit;
		
	theSize = gridPoints;
	for( i=1; i<inputDim; ++i)theSize *= gridPoints;

	if( inputDim > 4 ) 
	{
		err = cmparamErr;
		goto CleanupAndExit;
	}
	*theCubeSize = theSize * inputDim;
	if( inputDim != 4 )
		*theCubeSize = theSize * 4;
		
	*aHdlPtr = ALLOC_DATA(*theCubeSize*2, &err);
	if (err != noErr) 
		goto CleanupAndExit;
	
	LOCK_DATA( *aHdlPtr );
	cube = (UINT16 *)DATA_2_PTR( *aHdlPtr );
	aMaxVal = (1<<(30-needBits))-1;	/* Normierung auf 0xffff*/
	aMaxVal = aMaxVal / ( gridPoints -1 );
	aShift = 30 - needBits - 16;
	aRound = 0;/*(1<<(aShift-1))-1;*/
	if( inputDim == 1 )
	{
		for( i=0; i<gridPoints; ++i){
					*cube++ = (UINT16)(( aMaxVal * i + aRound) >> aShift); 
					*cube++ = 0; 
					*cube++ = 0; 
					*cube++ = 0; 
		}
	}
	else if( inputDim == 2)
	{
		register long  j;
		register UINT16 aI;
		for( i=0; i<gridPoints; ++i){
			aI = (UINT16)(( aMaxVal * i + aRound ) >> aShift);
			for( j=0; j<gridPoints; ++j){
					*cube++ = aI; 
					*cube++ = (UINT16)(( aMaxVal * j + aRound ) >> aShift); 
					*cube++ = 0; 
					*cube++ = 0; 
			}
		}
	}
	else if( inputDim == 3)
	{
		register long  j,k;
		register UINT16 aI, aJ;
		for( i=0; i<gridPoints; ++i){
			aI = (UINT16)(( aMaxVal * i + aRound ) >> aShift);
			for( j=0; j<gridPoints; ++j){
				aJ = (UINT16)(( aMaxVal * j + aRound ) >> aShift);
				for( k=0; k<gridPoints; ++k){
					*cube++ = aI; 
					*cube++ = aJ; 
					*cube++ = (UINT16)(( aMaxVal * k + aRound ) >> aShift); 
					*cube++ = 0; 
				}
			}
		}
	}
	else if( inputDim == 4){
		register long  j,k,l;
		register UINT16 aI, aJ,aK;
		for( i=0; i<gridPoints; ++i){
			aI = (UINT16)(( aMaxVal * i + aRound ) >> aShift);
			for( j=0; j<gridPoints; ++j){
				aJ = (UINT16)(( aMaxVal * j + aRound ) >> aShift);
				for( k=0; k<gridPoints; ++k){
					aK = (UINT16)(( aMaxVal * k + aRound ) >> aShift);
					for( l=0; l<gridPoints; ++l){
						*cube++ = aI; 
						*cube++ = aJ; 
						*cube++ = aK; 
						*cube++ = (UINT16)(( aMaxVal * l + aRound ) >> aShift); 
					}
				}
			}
		}
	}
	else
	{
		*aHdlPtr = DISPOSE_IF_DATA(*aHdlPtr);
		err = cmparamErr;
		goto CleanupAndExit;
	}
	UNLOCK_DATA(*aHdlPtr);
	*theBits = needBits;
CleanupAndExit:
	LH_END_PROC("MakeCMColorCube")
	return err;
}

void SetValues( long current, long inputDim, long needBits, UINT8 **Poi )
{	
	register UINT16 lastPoint;
	register UINT16 aVal;
	register long i;
	
#ifdef DEBUG_OUTPUT
	OSErr err=noErr;
#endif
	LH_START_PROC("SetValues")
	aVal = 0;
	lastPoint = (1<<needBits)-1;
	do{
		**Poi = (UINT8)(aVal<<(8-needBits));
		(*Poi)++;
		if( current < inputDim-1 ) SetValues( current+1, inputDim, needBits, Poi );
		if( aVal < lastPoint ){	/* its the last one*/
			if( current > 0 )for( i=0; i<current; ++i)*((*Poi) + i) = *((*Poi) - inputDim + i);
			(*Poi) += current;
		}
		aVal++;
	}while( aVal <= lastPoint );
	LH_END_PROC("SetValues")
}

/*
Wuerfel4D	( long 		bit_breit, 
			  UINT8 * 	wuerfel, 
			  UINT8 		gridPoints )
{
	unsigned long ci, cj, ck;
	long i, j, k, l;
	unsigned long * thePtr;
	
	thePtr = (unsigned long *)wuerfel;
	
	for(i=0; i< gridPoints; i++)
	{
		ci = i<<(32-bit_breit);
		for(j=0; j< gridPoints; j++)
		{
			cj = (j<<(24-bit_breit)) | ci;
			for(k=0; k< gridPoints; k++)
			{
				ck = (k<<(16-bit_breit)) | cj;
				for(l=0; l< gridPoints; l++)
				{
					*thePtr = ck | (l<<(8-bit_breit));
					thePtr++;
				}
			}
		}
	}
}	*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\mscmm.w98\lh_open\pi_color.h ===
/*
	File:		PI_ColorWorld.h

	Contains:	

	Written by:	U. J. Krabbenhoeft

	Copyright:	 1993-1997 by Heidelberger Druckmaschinen AG, all rights reserved.

	Change History (most recent first):
*/
#ifndef PI_ColorWorld_h
#define PI_ColorWorld_h
CMError LHColorWorldOpen (Ptr* storage);

CMError LHColorWorldClose( Ptr storage );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\mscmm.w98\lh_open\pi_mach.h ===
/*
	File:		PI_Mach.h

	Contains:	

	Written by:	U. J. Krabbenhoeft

	Version:

	Copyright:	 1993-1997 by Heidelberger Druckmaschinen AG, all rights reserved.

*/

#ifndef PI_Machine_h
#define PI_Machine_h

#if defined(unix) || defined(__unix) || defined(__unix__)
#define __IS_UNIX 1
#else
#define __IS_UNIX 0
#endif

#ifdef __MSDOS__
#define __IS_MSDOS 1
#else
#define __IS_MSDOS 0
#endif

#ifdef __MWERKS__
#define __IS_MAC 1
#else
#define __IS_MAC 0
#endif

#if __IS_MSDOS 
typedef long int off_t;
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\mscmm.w98\lh_open\pi_mem.h ===
/*
	File:		PI_Mem.h

	Contains:	

	Written by:	U. J. Krabbenhoeft

	Version:

	Copyright:	 1993-1997 by Heidelberger Druckmaschinen AG, all rights reserved.

*/
#ifndef PI_Memory_h
#define PI_Memory_h

#include <stdlib.h>
typedef INT32 Size;

#ifdef __cplusplus
extern "C" {
#endif
void *LH_malloc(long a);
void LH_free(void *a);
void LH_mallocInit();
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif

Ptr  		DisposeIfPtr		( Ptr aPtr );

Ptr
SmartNewPtr(Size byteCount, OSErr *resultCode);

Ptr
SmartNewPtrClear(Size byteCount, OSErr *resultCode);

UINT32 TickCount(void);
double MyTickCount(void);

double rint(double a);
void BlockMove(const void* srcPtr,
			   void* destPtr,
			   Size byteCount);
#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\mscmm.w98\lh_open\pi_mem.c ===
/*
	File:		PI_Memory.c

	Contains:	
				
	Written by:	U. J. Krabbenhoeft

	Version:

	Copyright:	 1993-1997 by Heidelberger Druckmaschinen AG, all rights reserved.

*/
#ifndef PI_BasicTypes_h
#include "PI_Basic.h"
#endif

#ifndef PI_Memory_h
#include "PI_Mem.h"
#endif

#ifndef PI_Machine_h
#include "PI_Mach.h"
#endif

#include <string.h>	
#ifdef IntelMode
#include "PI_Swap.h"
#endif

#if __IS_MAC
void Debugger();
#endif

/* --------------------------------------------------------------------------

	Ptr SmartNewPtr(Size byteCount,
					OSErr* resultCode)

	Abstract:

	Params:
		
	Return:
		noErr		successful

   -------------------------------------------------------------------------- */
Ptr SmartNewPtr(Size byteCount,
				OSErr* resultCode)
{
	Ptr aPtr;
	aPtr = (Ptr)LH_malloc(byteCount);
	if (aPtr == 0)
		*resultCode = notEnoughMemoryErr;
	else
		*resultCode = 0;
	return aPtr;
}


/* --------------------------------------------------------------------------

	Ptr SmartNewPtrClear(Size byteCount,
						 OSErr* resultCode)

	Abstract:

	Params:
		
	Return:

   -------------------------------------------------------------------------- */
Ptr SmartNewPtrClear(Size byteCount,
					 OSErr* resultCode)
{
	Ptr ptr = NULL;

	ptr = SmartNewPtr(byteCount, resultCode);

	if (ptr != NULL)
	{
 		memset( ptr, 0, byteCount );
	}
	return ptr;

}


/* --------------------------------------------------------------------------

	Ptr DisposeIfPtr(Ptr thePtr)

	Abstract:

	Params:
		
	Return:

   -------------------------------------------------------------------------- */
Ptr DisposeIfPtr(Ptr thePtr)
{
	if (thePtr)
	{
		LH_free(thePtr);
	}
	return NULL;
}

#ifdef __MWERKS__
extern pascal Ptr NewPtr(Size byteCount);
extern pascal void DisposePtr(Ptr p);
#endif	

#ifdef LH_MEMORY_DEBUG
typedef struct
{
	void* p;
	long l;
} LH_PointerType;
static LH_PointerType PListe[2001];
static long PListeCount = 0;

/* --------------------------------------------------------------------------

	void LH_mallocInit()

	Abstract:

	Params:
		
	Return:

   -------------------------------------------------------------------------- */
void LH_mallocInit()
{
	long i;
	for (i = 0; i < 2000; i++)
	{
		PListe[i].p = 0;
		PListe[i].l = 0;
	}
	PListeCount = 0;
}


/* --------------------------------------------------------------------------

	void* LH_malloc(long a)

	Abstract:

	Params:
		
	Return:

   -------------------------------------------------------------------------- */
void* LH_malloc(long a)
{
	long i;
#ifdef __MWERKS__
	void* aPtr = NewPtr(a);
#else
	void* aPtr = malloc(a);
#endif	

	for (i = 0; i < PListeCount; i++)
	{
		if (aPtr < PListe[i].p)
			continue;
		if (aPtr >= (char*)PListe[i].p + PListe[i].l)
			continue;
		Debugger();
	}

	for (i = 0; i < PListeCount; i++)
	{
		if (PListe[i].p == 0)
			break;
	}
	PListe[i].p = aPtr;
	PListe[i].l = a;
	if (i >= PListeCount)
	{
		if (PListeCount < 2000)
			PListeCount++;
	}
	return aPtr;
}


/* --------------------------------------------------------------------------

	void LH_free(void* a)

	Abstract:

	Params:
		
	Return:

   -------------------------------------------------------------------------- */
void LH_free(void* a)
{
	long i;
	for (i = 0; i < PListeCount; i++)
	{
		if (PListe[i].p == a)
			break;
	}
	if (i < PListeCount)
	{
		PListe[i].p = 0;
		PListe[i].l = 0;
#ifdef __MWERKS__
		DisposePtr(a);
#else
		free(a);
#endif	

	}
	else
	{
		Debugger();
	}
}
#else

/* --------------------------------------------------------------------------

	void LH_mallocInit()

	Abstract:

	Params:
		
	Return:

   -------------------------------------------------------------------------- */
void LH_mallocInit()
{
}


/* --------------------------------------------------------------------------

	void* LH_malloc(long a)

	Abstract:

	Params:
		
	Return:

   -------------------------------------------------------------------------- */
void* LH_malloc(long a)
{
#ifdef __MWERKS__
	return NewPtr(a);
#else
	return malloc(a);
#endif	

}


/* --------------------------------------------------------------------------

	void LH_free(void* a)

	Abstract:

	Params:
		
	Return:

   -------------------------------------------------------------------------- */
void LH_free(void* a)
{
#ifdef __MWERKS__
	DisposePtr((Ptr)a);
#else
	free(a);
#endif	

}
#endif	


/* --------------------------------------------------------------------------

	void SetMem(void* bytePtr,
				size_t numBytes,
				unsigned char byteValue);

	Abstract:

	Params:
		
	Return:

   -------------------------------------------------------------------------- */
void SetMem(void* bytePtr,
			size_t numBytes,
			unsigned char byteValue);
void SetMem(void* bytePtr,
			size_t numBytes,
			unsigned char byteValue)
{
	memset(bytePtr, byteValue, numBytes);
}

/*void SecondsToDate(unsigned long secs, DateTimeRec *d)
  {
  secs=secs;
  d->year = 55;
  d->month = 8;
  d->day = 8;
  d->hour = 0;
  d->minute = 0;
  d->second = 0;
  d->dayOfWeek = 0;
  }*/

#if !__IS_MAC
/* --------------------------------------------------------------------------

	void BlockMove(const void* srcPtr,
				   void* destPtr,
				   Size byteCount);

	Abstract:

	Params:
		
	Return:

   -------------------------------------------------------------------------- */
void BlockMove(const void* srcPtr,
			   void* destPtr,
			   Size byteCount)
{
	memmove(destPtr, srcPtr, byteCount);
}
#endif

#ifdef IntelMode
/* --------------------------------------------------------------------------

	void SwapLongOffset(void* p,
						unsigned long a,
						unsigned long b)

	Abstract:

	Params:
		
	Return:

   -------------------------------------------------------------------------- */
void SwapLongOffset(void* p,
					unsigned long a,
					unsigned long b)
{
	unsigned long* aPtr = (unsigned long*)((char*)p + a);
	unsigned long* bPtr = (unsigned long*)((char*)p + b);
	while (aPtr < bPtr)
	{
		SwapLong(aPtr);
		aPtr++;
	}
}


/* --------------------------------------------------------------------------

	void SwapShortOffset(void* p,
						 unsigned long a,
						 unsigned long b);

	Abstract:

	Params:
		
	Return:

   -------------------------------------------------------------------------- */
void SwapShortOffset(void* p,
					 unsigned long a,
					 unsigned long b);
void SwapShortOffset(void* p,
					 unsigned long a,
					 unsigned long b)
{
	unsigned short* aPtr = (unsigned short*)((char*)p + a);
	unsigned short* bPtr = (unsigned short*)((char*)p + b);
	while (aPtr < bPtr)
	{
		SwapShort(aPtr);
		aPtr++;
	}
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\mscmm.w98\lh_open\pi_priv.h ===
#ifndef PI_PrivateProfAccess_h
#define PI_PrivateProfAccess_h
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\mscmm.w98\lh_open\pi_swap.h ===
/*
	File:		PI_SwapMem.h

	Contains:	

	Written by:	U. J. Krabbenhoeft

	Version:

	Copyright:	 1993-1997 by Heidelberger Druckmaschinen AG, all rights reserved.

*/
#ifndef PI_SwapMem_h
#define PI_SwapMem_h

#ifdef IntelMode
#if defined(__cplusplus)
extern "C" {
#endif
#define SwapLong(b) (*((unsigned long *)(b))) = ((unsigned long)(((unsigned char *)(b))[3]))         | (((unsigned long)(((unsigned char *)(b))[2])) << 8) | \
		        (((unsigned long)(((unsigned char *)(b))[1])) << 16) | (((unsigned long)(((unsigned char *)(b))[0])) << 24);
#define SwapShort(b) (*((unsigned short *)(b))) = ((unsigned short)(((unsigned char *)(b))[1])) | ((unsigned short)(((unsigned char *)(b))[0] << 8));

void SwapLongOffset( void *p, unsigned long a, unsigned long b); /* */
void SwapShortOffset( void *p, unsigned long a, unsigned long b);

#if defined(__cplusplus)
}
#endif
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\mscmm.w98\lh_open\pi_tick.c ===
/*
	File:		PI_TickCount.c

	Contains:	
				
	Written by:	U. J. Krabbenhoeft

	Version:

	Copyright:	 1993-1997 by Heidelberger Druckmaschinen AG, all rights reserved.

*/
#ifndef PI_BasicTypes_h
#include "PI_Basic.h"
#endif

#ifndef PI_Machine_h
#include "PI_Mach.h"
#endif

#ifndef PI_Memory_h
#include "PI_Mem.h"
#endif

#include <time.h>
#if __IS_MSDOS
#include <wtypes.h>
#endif

double MyTickCount(void);
double MyTickCount(void)
{
	double timevalue;
#if __IS_MAC
	timevalue = TickCount()/60.;
#elif __IS_MSDOS
	timevalue = GetTickCount()/1000.;
#else
	timevalue = clock()/(CLOCKS_PER_SEC*1000.);
#endif
	return timevalue;
}

#if __IS_MSDOS
UINT32 TickCount(void)
{
	UINT32 timevalue;
	timevalue = (UINT32)(GetTickCount()/1000.*60 + .5 );
	return timevalue;
}
#endif

#if !__IS_MSDOS
#if !__IS_MAC
UINT32 TickCount(void)
{
	UINT32 timevalue;
	timevalue = (UINT32) time(NULL);
	return timevalue;
}
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\mscmm.w98\lh_open\pi_valid.h ===
#ifndef PI_Validate_h
#define PI_Validate_h

CMError CMValidateProfile( CMProfileRef prof, Boolean* valid );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\mscmm.w98\lh_open\general.h ===
/*
	File:		LHGeneralIncs.h

	Contains:	General interfaces for MAC OR 'platfrom independent'. This is the PC- Version !!

	Written by:	U. J. Krabbenhoeft

	Copyright:	 1993-1997 by Heidelberger Druckmaschinen AG, all rights reserved.

*/

#ifndef LHGeneralIncs_h
#define LHGeneralIncs_h

#if defined(_X86_)
#define ALLOW_MMX
#endif

#ifndef PI_BasicTypes_h
#include "PI_Basic.h"
#endif

#ifndef PI_Machine_h
#include "PI_Mach.h"
#endif

#ifndef PI_Memory_h
#include "PI_Mem.h"
#endif

#define LUTS_ARE_PTR_BASED 1

#ifndef LHDefines_h
#include "Defines.h"
#endif

#ifndef LHICCProfile_h
#include "Profile.h"
#endif

#ifndef PI_Application_h
#include "PI_App.h"
#endif

#ifndef RenderInt
#ifndef PI_PrivateProfAccess_h
#include "PI_Priv.h"
#endif
#endif

#ifndef DEBUG_OUTPUT
#define LH_START_PROC(x)
#define LH_END_PROC(x)
#endif

#define BlockMoveData BlockMove

#ifndef LHTypeDefs_h
#include "TypeDefs.h"
#endif

#ifdef IntelMode
#ifndef PI_SwapMem_h
#include "PI_Swap.h"
#endif
#endif

#define realThing 1

#if PRAGMA_ALIGN_SUPPORTED
#pragma options align=mac68k
#endif

#if PRAGMA_IMPORT_SUPPORTED
#pragma import on
#endif


/* our stuff without Core Includes */
#define VOLATILE(x)			if ((x));

enum {
    kCMMNewLinkProfile			= 1
};


#ifndef IntelMode
#define CMHelperICC2int16(a, b) 																\
		  (*((UINT16 *)(a))) = (*((UINT16*)(b)));
#define CMHelperICC2int32(a, b) 																\
		  (*((UINT32 *)(a))) = (*((UINT32*)(b)));
#else
#define CMHelperICC2int16(a, b) 																\
		  (*((UINT16 *)(a))) = ((UINT16)(((UINT8 *)(b))[1]))         | ((UINT16)(((UINT8 *)(b))[0] << 8));
#define CMHelperICC2int32(a, b) 																\
		  (*((UINT32 *)(a))) = ((UINT32)(((UINT8 *)(b))[3]))         | (((UINT32)(((UINT8 *)(b))[2])) << 8) | \
		        (((UINT32)(((UINT8 *)(b))[1])) << 16) | (((UINT32)(((UINT8 *)(b))[0])) << 24);
#endif

/*#define _SIZET */
/*typedef long Size; */
#ifdef __cplusplus
extern "C" {
#endif

void GetDateTime(unsigned long *secs);
extern void SecondsToDate(unsigned long secs, DateTimeRec *d);

void BlockMove(const void *srcPtr, void *destPtr, Size byteCount);
void SetMem(void *bytePtr, size_t numBytes, unsigned char byteValue);

#ifdef __cplusplus
}
#endif

#if PRAGMA_IMPORT_SUPPORTED
#pragma import off
#endif

#if PRAGMA_ALIGN_SUPPORTED
#pragma options align=reset
#endif

/*#define LH_CALC_ENGINE_16BIT_DATAFORMAT 1
#define LH_CALC_ENGINE_SMALL 1  */
#define LH_CALC_ENGINE_BIG				0	/* 1 -> Speed optimized code for all data and lut formats */
#define LH_CALC_ENGINE_ALL_FORMATS_LO	1	/* 1 -> Speed optimized code for 'looukup only' for all data and lut formats */
#define LH_CALC_ENGINE_16_BIT_LO		0	/* 1 -> Speed optimized code for 'looukup only' for 8->16 and 16->8 data and all lut formats */
#define LH_CALC_ENGINE_MIXED_DATAFORMAT	0	/* 1 -> Speed optimized code for 'looukup only' for 8->16 and 16->8 data and all lut formats */

#define LH_CALC_USE_ADDITIONAL_OLD_CODE			1	/* 1 turns on the additional generation of the old pixel cache routines for 3 dim input	*/
#define LH_CALC_USE_ADDITIONAL_OLD_CODE_4DIM	0	/* 1 turns on the additional generation of the old pixel cache routines for 4 dim input	*/		
/*						*/
/*			Use LH_CALC_USE_SMALL_ENGINE on BOTH LH_Calc3to3 and LH_Calc3to4 cases !!! 			*/

#define LH_CALC_USE_DO_N_DIM 		0	/* no speed optimized code for this funktion */
#define LH_CALC_USE_SMALL_ENGINE 	1	/* speed optimized code for this funktion */
#define LH_CALC_USE_BIG_ENGINE		2	/* full speed optimized code for this funktion */

#if ! LH_CALC_ENGINE_BIG
/* 		change this part ONLY!!!			*/

#define LH_Calc1toX_Di8_Do8_Lut8_G128	LH_CALC_USE_SMALL_ENGINE	/* use LH_CALC_USE_SMALL_ENGINE for speed optimized code */
#define LH_Calc1toX_Di8_Do8_Lut16_G128	LH_CALC_USE_SMALL_ENGINE 	/* else use LH_CALC_USE_DO_N_DIM for no speed optimization */
#define LH_Calc1toX_Di8_Do16_Lut8_G128	LH_CALC_USE_DO_N_DIM
#define LH_Calc1toX_Di8_Do16_Lut16_G128 LH_CALC_USE_DO_N_DIM
#define LH_Calc1toX_Di16_Do8_Lut8_G128	LH_CALC_USE_DO_N_DIM
#define LH_Calc1toX_Di16_Do8_Lut16_G128 LH_CALC_USE_DO_N_DIM
#define LH_Calc1toX_Di16_Do16_Lut8_G128 LH_CALC_USE_SMALL_ENGINE
#define LH_Calc1toX_Di16_Do16_Lut16_G128 LH_CALC_USE_SMALL_ENGINE

#define LH_Calc3to3_Di8_Do8_Lut8_G16     LH_CALC_USE_BIG_ENGINE
#define LH_Calc3to3_Di8_Do8_Lut8_G32     LH_CALC_USE_BIG_ENGINE
#define LH_Calc3to3_Di8_Do8_Lut16_G16    LH_CALC_USE_BIG_ENGINE
#define LH_Calc3to3_Di8_Do8_Lut16_G32    LH_CALC_USE_BIG_ENGINE

#define LH_Calc3to3_Di8_Do16_Lut8_G16    LH_CALC_USE_DO_N_DIM
#define LH_Calc3to3_Di8_Do16_Lut8_G32    LH_CALC_USE_DO_N_DIM
#define LH_Calc3to3_Di8_Do16_Lut16_G16   LH_CALC_USE_DO_N_DIM
#define LH_Calc3to3_Di8_Do16_Lut16_G32   LH_CALC_USE_DO_N_DIM

#define LH_Calc3to3_Di16_Do8_Lut8_G16    LH_CALC_USE_DO_N_DIM
#define LH_Calc3to3_Di16_Do8_Lut8_G32    LH_CALC_USE_DO_N_DIM
#define LH_Calc3to3_Di16_Do8_Lut16_G16   LH_CALC_USE_DO_N_DIM
#define LH_Calc3to3_Di16_Do8_Lut16_G32   LH_CALC_USE_DO_N_DIM

#define LH_Calc3to3_Di16_Do16_Lut8_G16   LH_CALC_USE_SMALL_ENGINE
#define LH_Calc3to3_Di16_Do16_Lut8_G32   LH_CALC_USE_SMALL_ENGINE
#define LH_Calc3to3_Di16_Do16_Lut16_G16  LH_CALC_USE_SMALL_ENGINE
#define LH_Calc3to3_Di16_Do16_Lut16_G32  LH_CALC_USE_SMALL_ENGINE

#define LH_Calc3to4_Di8_Do8_Lut8_G16     LH_CALC_USE_BIG_ENGINE
#define LH_Calc3to4_Di8_Do8_Lut8_G32     LH_CALC_USE_BIG_ENGINE
#define LH_Calc3to4_Di8_Do8_Lut16_G16    LH_CALC_USE_BIG_ENGINE
#define LH_Calc3to4_Di8_Do8_Lut16_G32    LH_CALC_USE_BIG_ENGINE

#define LH_Calc3to4_Di8_Do16_Lut8_G16    LH_CALC_USE_DO_N_DIM
#define LH_Calc3to4_Di8_Do16_Lut8_G32    LH_CALC_USE_DO_N_DIM
#define LH_Calc3to4_Di8_Do16_Lut16_G16   LH_CALC_USE_DO_N_DIM
#define LH_Calc3to4_Di8_Do16_Lut16_G32   LH_CALC_USE_DO_N_DIM

#define LH_Calc3to4_Di16_Do8_Lut8_G16    LH_CALC_USE_DO_N_DIM
#define LH_Calc3to4_Di16_Do8_Lut8_G32    LH_CALC_USE_DO_N_DIM
#define LH_Calc3to4_Di16_Do8_Lut16_G16   LH_CALC_USE_DO_N_DIM
#define LH_Calc3to4_Di16_Do8_Lut16_G32   LH_CALC_USE_DO_N_DIM

#define LH_Calc3to4_Di16_Do16_Lut8_G16   LH_CALC_USE_SMALL_ENGINE
#define LH_Calc3to4_Di16_Do16_Lut8_G32   LH_CALC_USE_SMALL_ENGINE
#define LH_Calc3to4_Di16_Do16_Lut16_G16  LH_CALC_USE_SMALL_ENGINE
#define LH_Calc3to4_Di16_Do16_Lut16_G32  LH_CALC_USE_SMALL_ENGINE


#define LH_Calc4to3_Di8_Do8_Lut8_G8      LH_CALC_USE_BIG_ENGINE
#define LH_Calc4to3_Di8_Do8_Lut8_G16     LH_CALC_USE_BIG_ENGINE
#define LH_Calc4to3_Di8_Do8_Lut16_G8     LH_CALC_USE_BIG_ENGINE
#define LH_Calc4to3_Di8_Do8_Lut16_G16    LH_CALC_USE_BIG_ENGINE

#define LH_Calc4to3_Di8_Do16_Lut8_G8     LH_CALC_USE_DO_N_DIM
#define LH_Calc4to3_Di8_Do16_Lut8_G16    LH_CALC_USE_DO_N_DIM
#define LH_Calc4to3_Di8_Do16_Lut16_G8    LH_CALC_USE_DO_N_DIM
#define LH_Calc4to3_Di8_Do16_Lut16_G16   LH_CALC_USE_DO_N_DIM

#define LH_Calc4to3_Di16_Do8_Lut8_G8     LH_CALC_USE_DO_N_DIM
#define LH_Calc4to3_Di16_Do8_Lut8_G16    LH_CALC_USE_DO_N_DIM
#define LH_Calc4to3_Di16_Do8_Lut16_G8    LH_CALC_USE_DO_N_DIM
#define LH_Calc4to3_Di16_Do8_Lut16_G16   LH_CALC_USE_DO_N_DIM

#define LH_Calc4to3_Di16_Do16_Lut8_G8    LH_CALC_USE_DO_N_DIM
#define LH_Calc4to3_Di16_Do16_Lut8_G16   LH_CALC_USE_DO_N_DIM
#define LH_Calc4to3_Di16_Do16_Lut16_G8   LH_CALC_USE_DO_N_DIM
#define LH_Calc4to3_Di16_Do16_Lut16_G16  LH_CALC_USE_DO_N_DIM

#define LH_Calc4to4_Di8_Do8_Lut8_G8      LH_CALC_USE_BIG_ENGINE
#define LH_Calc4to4_Di8_Do8_Lut8_G16     LH_CALC_USE_BIG_ENGINE
#define LH_Calc4to4_Di8_Do8_Lut16_G8     LH_CALC_USE_BIG_ENGINE
#define LH_Calc4to4_Di8_Do8_Lut16_G16    LH_CALC_USE_BIG_ENGINE

#define LH_Calc4to4_Di8_Do16_Lut8_G8     LH_CALC_USE_DO_N_DIM
#define LH_Calc4to4_Di8_Do16_Lut8_G16    LH_CALC_USE_DO_N_DIM
#define LH_Calc4to4_Di8_Do16_Lut16_G8    LH_CALC_USE_DO_N_DIM
#define LH_Calc4to4_Di8_Do16_Lut16_G16   LH_CALC_USE_DO_N_DIM

#define LH_Calc4to4_Di16_Do8_Lut8_G8     LH_CALC_USE_DO_N_DIM
#define LH_Calc4to4_Di16_Do8_Lut8_G16    LH_CALC_USE_DO_N_DIM
#define LH_Calc4to4_Di16_Do8_Lut16_G8    LH_CALC_USE_DO_N_DIM
#define LH_Calc4to4_Di16_Do8_Lut16_G16   LH_CALC_USE_DO_N_DIM

#define LH_Calc4to4_Di16_Do16_Lut8_G8    LH_CALC_USE_DO_N_DIM
#define LH_Calc4to4_Di16_Do16_Lut8_G16   LH_CALC_USE_DO_N_DIM
#define LH_Calc4to4_Di16_Do16_Lut16_G8   LH_CALC_USE_DO_N_DIM
#define LH_Calc4to4_Di16_Do16_Lut16_G16  LH_CALC_USE_DO_N_DIM

#else
/* 		do not change this part !!!			*/

#define LH_Calc1toX_Di8_Do8_Lut8_G128	LH_CALC_USE_SMALL_ENGINE	/* use LH_CALC_USE_SMALL_ENGINE for speed optimized code */
#define LH_Calc1toX_Di8_Do8_Lut16_G128	LH_CALC_USE_SMALL_ENGINE 	/* else use LH_CALC_USE_DO_N_DIM for no speed optimization */
#define LH_Calc1toX_Di8_Do16_Lut8_G128	LH_CALC_USE_SMALL_ENGINE
#define LH_Calc1toX_Di8_Do16_Lut16_G128 LH_CALC_USE_SMALL_ENGINE
#define LH_Calc1toX_Di16_Do8_Lut8_G128	LH_CALC_USE_SMALL_ENGINE
#define LH_Calc1toX_Di16_Do8_Lut16_G128 LH_CALC_USE_SMALL_ENGINE
#define LH_Calc1toX_Di16_Do16_Lut8_G128 LH_CALC_USE_SMALL_ENGINE
#define LH_Calc1toX_Di16_Do16_Lut16_G128 LH_CALC_USE_SMALL_ENGINE

#define LH_Calc3to3_Di8_Do8_Lut8_G16     LH_CALC_USE_BIG_ENGINE
#define LH_Calc3to3_Di8_Do8_Lut8_G32     LH_CALC_USE_BIG_ENGINE
#define LH_Calc3to3_Di8_Do8_Lut16_G16    LH_CALC_USE_BIG_ENGINE
#define LH_Calc3to3_Di8_Do8_Lut16_G32    LH_CALC_USE_BIG_ENGINE

#define LH_Calc3to3_Di8_Do16_Lut8_G16    LH_CALC_USE_BIG_ENGINE
#define LH_Calc3to3_Di8_Do16_Lut8_G32    LH_CALC_USE_BIG_ENGINE
#define LH_Calc3to3_Di8_Do16_Lut16_G16   LH_CALC_USE_BIG_ENGINE
#define LH_Calc3to3_Di8_Do16_Lut16_G32   LH_CALC_USE_BIG_ENGINE

#define LH_Calc3to3_Di16_Do8_Lut8_G16    LH_CALC_USE_BIG_ENGINE
#define LH_Calc3to3_Di16_Do8_Lut8_G32    LH_CALC_USE_BIG_ENGINE
#define LH_Calc3to3_Di16_Do8_Lut16_G16   LH_CALC_USE_BIG_ENGINE
#define LH_Calc3to3_Di16_Do8_Lut16_G32   LH_CALC_USE_BIG_ENGINE

#define LH_Calc3to3_Di16_Do16_Lut8_G16   LH_CALC_USE_BIG_ENGINE
#define LH_Calc3to3_Di16_Do16_Lut8_G32   LH_CALC_USE_BIG_ENGINE
#define LH_Calc3to3_Di16_Do16_Lut16_G16  LH_CALC_USE_BIG_ENGINE
#define LH_Calc3to3_Di16_Do16_Lut16_G32  LH_CALC_USE_BIG_ENGINE

#define LH_Calc3to4_Di8_Do8_Lut8_G16     LH_CALC_USE_BIG_ENGINE
#define LH_Calc3to4_Di8_Do8_Lut8_G32     LH_CALC_USE_BIG_ENGINE
#define LH_Calc3to4_Di8_Do8_Lut16_G16    LH_CALC_USE_BIG_ENGINE
#define LH_Calc3to4_Di8_Do8_Lut16_G32    LH_CALC_USE_BIG_ENGINE

#define LH_Calc3to4_Di8_Do16_Lut8_G16    LH_CALC_USE_BIG_ENGINE
#define LH_Calc3to4_Di8_Do16_Lut8_G32    LH_CALC_USE_BIG_ENGINE
#define LH_Calc3to4_Di8_Do16_Lut16_G16   LH_CALC_USE_BIG_ENGINE
#define LH_Calc3to4_Di8_Do16_Lut16_G32   LH_CALC_USE_BIG_ENGINE

#define LH_Calc3to4_Di16_Do8_Lut8_G16    LH_CALC_USE_BIG_ENGINE
#define LH_Calc3to4_Di16_Do8_Lut8_G32    LH_CALC_USE_BIG_ENGINE
#define LH_Calc3to4_Di16_Do8_Lut16_G16   LH_CALC_USE_BIG_ENGINE
#define LH_Calc3to4_Di16_Do8_Lut16_G32   LH_CALC_USE_BIG_ENGINE

#define LH_Calc3to4_Di16_Do16_Lut8_G16   LH_CALC_USE_BIG_ENGINE
#define LH_Calc3to4_Di16_Do16_Lut8_G32   LH_CALC_USE_BIG_ENGINE
#define LH_Calc3to4_Di16_Do16_Lut16_G16  LH_CALC_USE_BIG_ENGINE
#define LH_Calc3to4_Di16_Do16_Lut16_G32  LH_CALC_USE_BIG_ENGINE


#define LH_Calc4to3_Di8_Do8_Lut8_G8      LH_CALC_USE_BIG_ENGINE
#define LH_Calc4to3_Di8_Do8_Lut8_G16     LH_CALC_USE_BIG_ENGINE
#define LH_Calc4to3_Di8_Do8_Lut16_G8     LH_CALC_USE_BIG_ENGINE
#define LH_Calc4to3_Di8_Do8_Lut16_G16    LH_CALC_USE_BIG_ENGINE

#define LH_Calc4to3_Di8_Do16_Lut8_G8     LH_CALC_USE_BIG_ENGINE
#define LH_Calc4to3_Di8_Do16_Lut8_G16    LH_CALC_USE_BIG_ENGINE
#define LH_Calc4to3_Di8_Do16_Lut16_G8    LH_CALC_USE_BIG_ENGINE
#define LH_Calc4to3_Di8_Do16_Lut16_G16   LH_CALC_USE_BIG_ENGINE

#define LH_Calc4to3_Di16_Do8_Lut8_G8     LH_CALC_USE_BIG_ENGINE
#define LH_Calc4to3_Di16_Do8_Lut8_G16    LH_CALC_USE_BIG_ENGINE
#define LH_Calc4to3_Di16_Do8_Lut16_G8    LH_CALC_USE_BIG_ENGINE
#define LH_Calc4to3_Di16_Do8_Lut16_G16   LH_CALC_USE_BIG_ENGINE

#define LH_Calc4to3_Di16_Do16_Lut8_G8    LH_CALC_USE_BIG_ENGINE
#define LH_Calc4to3_Di16_Do16_Lut8_G16   LH_CALC_USE_BIG_ENGINE
#define LH_Calc4to3_Di16_Do16_Lut16_G8   LH_CALC_USE_BIG_ENGINE
#define LH_Calc4to3_Di16_Do16_Lut16_G16  LH_CALC_USE_BIG_ENGINE

#define LH_Calc4to4_Di8_Do8_Lut8_G8      LH_CALC_USE_BIG_ENGINE
#define LH_Calc4to4_Di8_Do8_Lut8_G16     LH_CALC_USE_BIG_ENGINE
#define LH_Calc4to4_Di8_Do8_Lut16_G8     LH_CALC_USE_BIG_ENGINE
#define LH_Calc4to4_Di8_Do8_Lut16_G16    LH_CALC_USE_BIG_ENGINE

#define LH_Calc4to4_Di8_Do16_Lut8_G8     LH_CALC_USE_BIG_ENGINE
#define LH_Calc4to4_Di8_Do16_Lut8_G16    LH_CALC_USE_BIG_ENGINE
#define LH_Calc4to4_Di8_Do16_Lut16_G8    LH_CALC_USE_BIG_ENGINE
#define LH_Calc4to4_Di8_Do16_Lut16_G16   LH_CALC_USE_BIG_ENGINE

#define LH_Calc4to4_Di16_Do8_Lut8_G8     LH_CALC_USE_BIG_ENGINE
#define LH_Calc4to4_Di16_Do8_Lut8_G16    LH_CALC_USE_BIG_ENGINE
#define LH_Calc4to4_Di16_Do8_Lut16_G8    LH_CALC_USE_BIG_ENGINE
#define LH_Calc4to4_Di16_Do8_Lut16_G16   LH_CALC_USE_BIG_ENGINE

#define LH_Calc4to4_Di16_Do16_Lut8_G8    LH_CALC_USE_BIG_ENGINE
#define LH_Calc4to4_Di16_Do16_Lut8_G16   LH_CALC_USE_BIG_ENGINE
#define LH_Calc4to4_Di16_Do16_Lut16_G8   LH_CALC_USE_BIG_ENGINE
#define LH_Calc4to4_Di16_Do16_Lut16_G16  LH_CALC_USE_BIG_ENGINE

#endif

#endif /* } */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\mscmm.w98\lh_open\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

MAJORCOMP=gdi
MINORCOMP=cmm_open

!ifndef ICMROOT
ICMROOT=$(NTGDI_PATH)\icm
!endif

!include $(ICMROOT)\icmsrc.inc

TARGETNAME=lh_open
TARGETTYPE=LIBRARY
TARGETPATH=..\$(ALT_PROJECT_TARGET)\$(_OBJ_DIR)

INCLUDES=..\.;..\..\lh_core

C_DEFINES=$(C_DEFINES) -DWIN32 -D__MSDOS__ -DIntelMode -DRenderInt -DMS_Icm

MSC_WARNING_LEVEL=/W3 /WX

SOURCES= ..\pi_cmm.c   \
         ..\pi_color.c \
         ..\pi_mem.c   \
         ..\pi_run.c   \
         ..\pi_tick.c  \
         ..\pi_valid.c
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\mscmm.w98\mscmm\membaspr.c ===
/*
	File:		MemBasPr.c

	Contains:	
		creation of mem based profiles

	Written by:	U. J. Krabbenhoeft

	Copyright:	 1993-1996 by Linotype-Hell AG, all rights reserved.

	Version:	
*/

#include "Windef.h"
#include "WinGdi.h"
#include <wtypes.h>
#include <winbase.h>
#include <windowsX.h>
#include "ICM.h"

#ifndef LHGeneralIncs_h
#include "General.h"
#endif

#ifndef MSNewMemProfile_h
#include "MemProf.h"
#endif

#ifdef _DEBUG
//#define WRITE_PROFILE
#endif

#ifdef WRITE_PROFILE
	void WriteProf( LPSTR name, icProfile *theProf, long currentSize );
#endif

#define MyTagCount 5
#define LINK_BUFFER_MAX 3000

CMError DeviceLinkFill( CMWorldRef cw, CMConcatProfileSet *profileSet, icProfile **theProf,
		unsigned long aIntent )
{
	CMError			err = unimpErr;
	OSErr			aOSerr = unimpErr;
#ifdef __MWERKS__
        unsigned char			theText[] = "\pDeviceLink profile  ";
#else
      char			theText[] = "\026DeviceLink profile   ";
#endif
      char	copyrightText[] = "\0371996 by Linotype-Hell  U.J.K.";
	icProfile 		*aProf=0;
	long 			theTagTabSize;
	long 			theHeaderSize;
	long 			theDescSize;
	long 			theMediaSize;
	long 			theSequenceDescSize;
	long 			theA2B0Size;
	long 			theCopyRightSize;
	long 			currentSize=0;
	long 			theTotalSize=0;
	icTag			aTag;
	UINT32			sCS,dCS,clutSize;
	Ptr				aPtr=0;

	MyDoubleXYZ D50XYZ = { 0.9642, 1.0000, 0.8249 };
	icXYZNumber D50 = { (unsigned long)(D50XYZ.X * 65536), (unsigned long)(D50XYZ.Y * 65536), (unsigned long)(D50XYZ.Z * 65536)};
	theHeaderSize = sizeof(icHeader);
	theDescSize   = 									  sizeof(OSType) 			/* type descriptor */
														+ sizeof(unsigned long) 	/* reserved */
														+ sizeof(unsigned long) 	/* ASCII length */
														+ theText[0]				/* ASCII profile description */
														+ sizeof(unsigned long)		/* Unicode code */
														+ sizeof(unsigned long)		/* Unicode character count */
														+ sizeof(unsigned short)	/* Macintosh script code */
														+ sizeof(unsigned char)		/* Macintosh string length */
														+ 67						/* Macintosh string */
														;
	theCopyRightSize   = 								  sizeof(OSType) 			/* type descriptor */
														+ sizeof(unsigned long) 	/* reserved */
														+ copyrightText[0]			/* ASCII profile description */
														;
	theMediaSize = sizeof( icXYZType );;

	theTagTabSize = MyTagCount * sizeof( icTag ) + sizeof( unsigned long );
	
	*theProf = 0;
	
	if( ((CMMModelPtr)cw)->hasNamedColorProf != NoNamedColorProfile ){
		err = cmProfileError;
		goto CleanupAndExit;
	}
	err = MyGetColorSpaces( profileSet, &sCS, &dCS );
	if (err)
		goto CleanupAndExit;
		
	aProf = (icProfile *)SmartNewPtrClear( LINK_BUFFER_MAX, &aOSerr );
	err = aOSerr;
	if (err)
		goto CleanupAndExit;

	err = MyAdd_NL_Header(theTotalSize, (icHeader*)((Ptr)aProf+currentSize), aIntent, icSigLinkClass, sCS, dCS );
	if (err)
		goto CleanupAndExit;
		
	/*----------------------------------------------------------------------------------------- cmProfileDescriptionTag */
	currentSize = theHeaderSize + theTagTabSize;
	CMHelperICC2int32Const(&(aProf->tagList.count ), MyTagCount);

	CMHelperICC2int32Const(&(aTag.sig ), icSigProfileDescriptionTag);
	CMHelperICC2int32Const(&(aTag.offset ), currentSize);
	CMHelperICC2int32Const(&(aTag.size ), theDescSize);
	aProf->tagList.tags[0] = aTag;
	err =MyAdd_NL_DescriptionTag	( (CMTextDescriptionType *)((Ptr)aProf+currentSize), (unsigned char *)theText );
	if (err)
		goto CleanupAndExit;  
	currentSize += theDescSize;
	currentSize = ( currentSize + 3 ) & ~ 3;

	CMHelperICC2int32Const(&(aTag.sig ), icSigMediaWhitePointTag);
	CMHelperICC2int32Const(&(aTag.offset ), currentSize );
	CMHelperICC2int32Const(&(aTag.size ), theMediaSize);
	aProf->tagList.tags[1] = aTag;
	MyAdd_NL_ColorantTag((icXYZType *)((Ptr)aProf+currentSize), &D50);
	currentSize += theMediaSize;
	currentSize = ( currentSize + 3 ) & ~ 3;

	CMHelperICC2int32Const(&(aTag.sig ), icSigCopyrightTag);
	CMHelperICC2int32Const(&(aTag.offset ), currentSize );
	CMHelperICC2int32Const(&(aTag.size ), theCopyRightSize);
	aProf->tagList.tags[2] = aTag;
	err = MyAdd_NL_CopyrightTag( (unsigned char *)copyrightText, (CMTextType *)((Ptr)aProf+currentSize));
	if (err)
		goto CleanupAndExit;
	currentSize += theCopyRightSize;
	currentSize = ( currentSize + 3 ) & ~ 3;
		
	err = MyAdd_NL_SequenceDescTag( profileSet, (icProfileSequenceDescType *)((Ptr)aProf+currentSize), &theSequenceDescSize );
	CMHelperICC2int32Const(&(aTag.sig ), icSigProfileSequenceDescTag);
	CMHelperICC2int32Const(&(aTag.offset ), currentSize );
	CMHelperICC2int32Const(&(aTag.size ), theSequenceDescSize);
	aProf->tagList.tags[3] = aTag;
	currentSize += theSequenceDescSize;
	currentSize = ( currentSize + 3 ) & ~ 3;

    theA2B0Size = GetSizes( (CMMModelPtr)cw, &clutSize );

	CMHelperICC2int32Const(&(aTag.sig ), icSigAToB0Tag);
	CMHelperICC2int32Const(&(aTag.offset ), currentSize );
	CMHelperICC2int32Const(&(aTag.size ), theA2B0Size);
	aProf->tagList.tags[4] = aTag;

	/* aPtr =  SmartNewPtr( theA2B0Size+currentSize, &aOSerr );
	err = aOSerr;
	if( err ){
		goto CleanupAndExit;
	}*/
	aPtr = GlobalAllocPtr( GHND, theA2B0Size+currentSize );

	if( aPtr == 0 ){
		err = GetLastError();
		goto CleanupAndExit;
	}

	if ( ((CMMModelPtr)cw)->lutParam.colorLutWordSize == 8 )
        err = MyAdd_NL_AToB0Tag_mft1( (CMMModelPtr)cw, (icLut8Type *)(aPtr+currentSize), clutSize );
    else
        err = MyAdd_NL_AToB0Tag_mft2( (CMMModelPtr)cw, (icLut16Type *)(aPtr+currentSize), clutSize );

	if (err)
		goto CleanupAndExit;

	BlockMove( (Ptr)aProf, aPtr, currentSize );
	aProf = (icProfile *)DisposeIfPtr( (Ptr)aProf );

	CMHelperICC2int32Const( aPtr, theA2B0Size+currentSize );

	*theProf = (icProfile *)aPtr;
#ifdef WRITE_PROFILE
	WriteProf( "DeviceLinkFill.pf", (icProfile *)aPtr, theA2B0Size+currentSize );
#endif
	return noErr;
	
CleanupAndExit:
	*theProf = (icProfile *)DisposeIfPtr( (Ptr)aProf );
	if( aPtr )GlobalFreePtr( aPtr );
	return err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\mscmm.w98\lh_open\pi_app.h ===
/*
	File:		PI_App.h

	Contains:	

	Written by:	U. J. Krabbenhoeft

	Version:

	Copyright:	 1993-1997 by Heidelberger Druckmaschinen AG, all rights reserved.

*/

#ifndef PI_Application_h
#define PI_Application_h

#ifndef PI_Machine_h
/*#include "PI_Machine.h"*/
#endif

#define CM_MAX_COLOR_CHANNELS 8
typedef unsigned long CMBitmapColorSpace;
typedef long CMError;
typedef unsigned int PI_OSType;
typedef struct CMPrivateProfileRecord *CMProfileRef;

#ifndef LHApplication_h
#include "App.h"
#endif

#ifdef MS_Icm
#include "Windef.h"
#include "WinGdi.h"
#include <wtypes.h>
#include "icm.h"
#endif

struct PI_NAMEDCOLOR {
    unsigned long   namedColorIndex;
    char			*pName;
};

struct PI_GRAYCOLOR {
    unsigned short    gray;
};

struct PI_RGBCOLOR {
    unsigned short    red;
    unsigned short    green;
    unsigned short    blue;
};

struct PI_CMYKCOLOR {
    unsigned short    cyan;
    unsigned short    magenta;
    unsigned short    yellow;
    unsigned short    black;
};

struct PI_XYZCOLOR {
    unsigned short    X;
    unsigned short    Y;
    unsigned short    Z;
};

struct PI_YxyCOLOR {
    unsigned short    Y;
    unsigned short    x;
    unsigned short    y;
};

struct PI_LabCOLOR {
    unsigned short    L;
    unsigned short    a;
    unsigned short    b;
};

struct PI_GENERIC3CHANNEL {
    unsigned short    ch1;
    unsigned short    ch2;
    unsigned short    ch3;
};

struct PI_HiFiCOLOR {
    unsigned char    channel[CM_MAX_COLOR_CHANNELS];
};


typedef union CMColor {
    struct PI_GRAYCOLOR        gray;
    struct PI_RGBCOLOR         rgb;
    struct PI_CMYKCOLOR        cmyk;
    struct PI_XYZCOLOR         XYZ;
    struct PI_YxyCOLOR         Yxy;
    struct PI_LabCOLOR         Lab;
    struct PI_GENERIC3CHANNEL  gen3ch;
    struct PI_NAMEDCOLOR       namedColor;
    struct PI_HiFiCOLOR        hifi;
} CMColor;

#ifdef MS_Icm
enum {
/* General Errors */
	cmopenErr               	= -200,		/* I/O Error used in ProfileAccess.c only						*/
	cmparamErr              	= ERROR_INVALID_PARAMETER,

	cmProfileError				= ERROR_INVALID_PROFILE,
	cmMethodError				= -203,		/* This is an internal error, no CalcFunction found				*/
	cmCantConcatenateError		= -208,		/* No concatenation possible									*/
														
	cmInvalidColorSpace			= ERROR_COLORSPACE_MISMATCH, /* no match between Profile colorspace bitmap type                          */
	cmInvalidSrcMap				= -210,		/* Source bitmap color space is invalid							*/
	cmInvalidDstMap				= -211,		/* Destination bitmap color space is invalid					*/
															
	cmNamedColorNotFound		= ERROR_INVALID_COLORINDEX,	/* index > count of named colors								*/

	cmElementTagNotFound		= ERROR_TAG_NOT_FOUND,

    userCanceledErr				= -128,		/* callback proc returned to cancel calculation					*/
	badProfileError      		= ERROR_INVALID_PROFILE,  /* header->magic != icMagicNumber used in ProfileAccess.c only  */
    memFullErr					= ERROR_NOT_ENOUGH_MEMORY
};
#else
enum cmErrorCodes{
/* General Errors */
	cmopenErr               	= -200,		/* I/O Error used in ProfileAccess.c only						*/
	cmparamErr              	= 86,

	cmProfileError				= 2301,
	cmMethodError				= -203,		/* This is an internal error, no CalcFunction found				*/
	cmCantConcatenateError		= -208,		/* No concatenation possible									*/
														
	cmInvalidColorSpace			= -209,		/* no match between Profile colorspace bitmap type				*/
	cmInvalidSrcMap				= -210,		/* Source bitmap color space is invalid							*/
	cmInvalidDstMap				= -211,		/* Destination bitmap color space is invalid					*/
															
	cmNamedColorNotFound		= -216,		/* index > count of named colors								*/

	cmElementTagNotFound		= 2302,

    userCanceledErr				= -128,		/* callback proc returned to cancel calculation					*/
	badProfileError      		= -228,		/* header->magic != icMagicNumber used in ProfileAccess.c only	*/
    memFullErr					= 8
};
#endif

#if RenderInt
#define CallCMBitmapCallBackProc(f,a,b,c) (!((*f)(a,b,c)))
#else
#define CallCMBitmapCallBackProc(f,a,b,c ) ((*f)((a)-(b),c))
#endif

#ifdef __cplusplus
extern "C" {
#endif

#if PRAGMA_ALIGN_SUPPORTED
#pragma options align=mac68k
#endif

#if PRAGMA_IMPORT_SUPPORTED
#pragma import on
#endif

typedef icHeader CMCoreProfileHeader;


/* Param for CWConcatColorWorld() */
struct CMConcatProfileSet {
	unsigned short 					keyIndex;					/* Zero-based */
	unsigned short 					count;						/* Min 1 */
	CMProfileRef 					profileSet[1];				/* Variable. Ordered from Source -> Dest */
};
typedef struct CMConcatProfileSet CMConcatProfileSet;

typedef icDateTimeNumber CMDateTime;
struct CMUniqueIdentification {
	icHeader 						profileHeader;
	CMDateTime 						calibrationDate;
	unsigned long 					ASCIIProfileDescriptionLen;
	char 							ASCIIProfileDescription[1];	/* variable length */
};
typedef struct CMUniqueIdentification CMUniqueIdentification;


enum {
	cmNoColorPacking			= 0x0000,
	cmAlphaSpace				= 0x0080,
	cmWord5ColorPacking			= 0x0500,
	cmWord565ColorPacking		= 0x0600,
	cmLong8ColorPacking			= 0x0800,
	cmLong10ColorPacking		= 0x0A00,
	cmAlphaFirstPacking			= 0x1000,
	cmOneBitDirectPacking		= 0x0B00,  /* for gamut check. highest bit first */
	cmAlphaLastPacking			= 0x0000,
	cm8PerChannelPacking		= 0x2000,
	cm10PerChannelPacking		= 0x0A00,
	cm16PerChannelPacking		= 0x4000,
	
	cm32_32ColorPacking			= 0x2700
};


enum {
	cmNoSpace					= 0,
	cmRGBSpace					= 1,
	cmCMYKSpace					= 2,
	cmHSVSpace					= 3,
	cmHLSSpace					= 4,
	cmYXYSpace					= 5,
	cmXYZSpace					= 6,
	cmLUVSpace					= 7,
	cmLABSpace					= 8,
	cmCMYSpace					= 9,
	cmGraySpace					= 10,
	cmReservedSpace2			= 11,
	cmGamutResultSpace			= 12,
	
	cmGenericSpace				= 13,			/*UWE: GenericDataFormat  */
	cmBGRSpace					= 14,			/*UWE: BGR  */
	cmYCCSpace					= 15,			/*UWE: YCC  */
	cmNamedIndexedSpace			= 16,			/* */

	cmMCFiveSpace				= 17,
	cmMCSixSpace				= 18,
	cmMCSevenSpace				= 19,
	cmMCEightSpace				= 20,
	
	cmKYMCSpace					= 29,
	cmRGBASpace					= cmRGBSpace + cmAlphaSpace,
	cmGrayASpace				= cmGraySpace + cmAlphaSpace,
	cmRGB16Space				= cmWord5ColorPacking + cmRGBSpace,
	cmRGB16_565Space			= cmWord565ColorPacking + cmRGBSpace,
	cmRGB32Space				= cmLong8ColorPacking + cmRGBSpace,
	cmARGB32Space				= cmLong8ColorPacking + cmAlphaFirstPacking + cmRGBASpace,
	cmCMYK32Space				= cmLong8ColorPacking + cmCMYKSpace,
	cmKYMC32Space				= cmLong8ColorPacking + cmKYMCSpace,
	cmHSV32Space				= cmLong10ColorPacking + cmHSVSpace,
	cmHLS32Space				= cmLong10ColorPacking + cmHLSSpace,
	cmYXY32Space				= cmLong10ColorPacking + cmYXYSpace,
	cmXYZ32Space				= cmLong10ColorPacking + cmXYZSpace,
	cmLUV32Space				= cmLong10ColorPacking + cmLUVSpace,
	cmLAB32Space				= cmLong10ColorPacking + cmLABSpace,
	cmGamutResult1Space			= cmOneBitDirectPacking + cmGamutResultSpace,
	cmRGB24Space				= cm8PerChannelPacking + cmRGBSpace,
	cmRGBA32Space				= cm8PerChannelPacking + cmAlphaLastPacking + cmRGBASpace,
	cmCMY24Space				= cm8PerChannelPacking + cmCMYSpace,
	cmLAB24Space				= cm8PerChannelPacking + cmLABSpace,
	
	cmGraySpace8Bit				= cmGraySpace + cm8PerChannelPacking,
	cmYCC24Space				= cm8PerChannelPacking + cmYCCSpace,
	cmYCC32Space				= cmLong8ColorPacking + cmYCCSpace,
	cmYCCASpace					= cmYCCSpace + cmAlphaSpace,
	cmYCCA32Space				= cm8PerChannelPacking + cmAlphaLastPacking + cmYCCASpace,
	cmAYCC32Space				= cmLong8ColorPacking + cmAlphaFirstPacking + cmYCCASpace,
	cmBGR24Space				= cm8PerChannelPacking + cmBGRSpace,
	cmBGR32Space				= cmLong8ColorPacking + cmBGRSpace + cmAlphaSpace,

	cmNamedIndexed24Space		= cmNamedIndexedSpace,
	cmNamedIndexed32Space		= cm32_32ColorPacking + cmNamedIndexedSpace,

	cmMCFive8Space				= cmMCFiveSpace + cm8PerChannelPacking,
	cmMCSix8Space				= cmMCSixSpace + cm8PerChannelPacking,
	cmMCSeven8Space				= cmMCSevenSpace + cm8PerChannelPacking,
	cmMCEight8Space				= cmMCEightSpace + cm8PerChannelPacking
#if ( CM_MAX_COLOR_CHANNELS == 16 )
	,
	cmMC9Space				= cmMCEight8Space + 1,
	cmMCaSpace				= cmMCEight8Space + 2,
	cmMCbSpace				= cmMCEight8Space + 3,
	cmMCcSpace				= cmMCEight8Space + 4,
	cmMCdSpace				= cmMCEight8Space + 5,
	cmMCeSpace				= cmMCEight8Space + 6,
	cmMCfSpace				= cmMCEight8Space + 7,
	cmMC2Space				= cmMCEight8Space + 8,
	cmMC98Space				= cmMC9Space + cm8PerChannelPacking,
	cmMCa8Space				= cmMCaSpace + cm8PerChannelPacking,
	cmMCb8Space				= cmMCbSpace + cm8PerChannelPacking,
	cmMCc8Space				= cmMCcSpace + cm8PerChannelPacking,
	cmMCd8Space				= cmMCdSpace + cm8PerChannelPacking,
	cmMCe8Space				= cmMCeSpace + cm8PerChannelPacking,
	cmMCf8Space				= cmMCfSpace + cm8PerChannelPacking,
	cmMC28Space				= cmMC2Space + cm8PerChannelPacking
#endif
};

struct CMBitmap {
	char *				image;			/*	pointer to image data						*/
	long 				width;			/*	count of pixel in one line					*/
	long 				height;			/*	count of lines								*/
	long 				rowBytes;		/*	offset in bytes from one line to next line	*/
	long 				pixelSize;		/*	not used									*/
	CMBitmapColorSpace	space;			/*	color space see above, e.g. cmRGB24Space	*/
	long 				user1;			/*	not used									*/
	long 				user2;			/*	not used									*/
};
typedef struct CMBitmap CMBitmap;

typedef char CMColorName[32];
typedef CMColorName *pCMColorName;
typedef const CMColorName *pcCMColorName;
typedef struct tagCMNamedProfileInfo{
	unsigned long	dwVendorFlags;
	unsigned long	dwCount;
	unsigned long   dwCountDevCoordinates;
	CMColorName		szPrefix;
	CMColorName		szSuffix;
}CMNamedProfileInfo;
typedef CMNamedProfileInfo *pCMNamedProfileInfo;

/* rendering intent element values  */

enum {
	cmPerceptual				= 0,							/* Photographic images */
	cmRelativeColorimetric		= 1,							/* Logo Colors */
	cmSaturation				= 2,							/* Business graphics */
	cmAbsoluteColorimetric		= 3								/* Logo Colors */
};

/* speed and quality flag options */
enum {
    cmNormalMode				= 0,							/* it uses the least significent two bits in the high word of flag */
    cmDraftMode					= 1,							/* it should be evaulated like this: right shift 16 bits first, mask off the */
    cmBestMode					= 2,							/* high 14 bits, and then compare with the enum to determine the option value. Do NOT shift if CWConcatColorWorld4MS is used */
    cmBestMode16Bit				= 3								/* calculate 16 bit combi LUT */
};

/* constants for the profheader-flags */
#define		kQualityMask		0x00030000		/* see Modes obove ( e.g. cmBestMode<<16 ) */
#define		kLookupOnlyMask		0x00040000
#define		kCreateGamutLutMask	0x00080000		/* Set Bit disables gamut lut creation */
#define		kUseRelColorimetric	0x00100000
#define		kStartWithXyzPCS	0x00200000
#define		kStartWithLabPCS	0x00400000
#define		kEndWithXyzPCS		0x00800000
#define		kEndWithLabPCS		0x01000000

typedef unsigned char PI_Boolean;

#if RenderInt
typedef  PI_Boolean  (__stdcall *CMBitmapCallBackProcPtr)(long max, long progress, void *refCon);
#else
typedef  PI_Boolean (*CMBitmapCallBackProcPtr)(long progress, void *refCon);
#endif
typedef CMBitmapCallBackProcPtr CMBitmapCallBackUPP;

/* Abstract data type for ColorWorld reference */
typedef struct CMPrivateColorWorldRecord *CMWorldRef;

/* Profile file and element access */
extern  PI_Boolean CMProfileElementExists(CMProfileRef prof, PI_OSType tag);
extern  CMError CMGetProfileElement(CMProfileRef prof, PI_OSType tag, unsigned long *elementSize, void *elementData);
extern  CMError CMGetProfileHeader(CMProfileRef prof, CMCoreProfileHeader *header);
extern  CMError CMGetPartialProfileElement(CMProfileRef prof, PI_OSType tag, unsigned long offset, unsigned long *byteCount, void *elementData);
extern  CMError CMSetProfileElementSize(CMProfileRef prof, PI_OSType tag, unsigned long elementSize);
extern  CMError CMSetPartialProfileElement(CMProfileRef prof, PI_OSType tag, unsigned long offset, unsigned long byteCount, void *elementData);
extern  CMError CMSetProfileElement(CMProfileRef prof, PI_OSType tag, unsigned long elementSize, void *elementData);
extern  CMError CMSetProfileHeader(CMProfileRef prof, const CMCoreProfileHeader *header);
/* Low-level matching functions */
extern  CMError CWNewColorWorld(CMWorldRef *cw, CMProfileRef src, CMProfileRef dst);
extern  CMError CWConcatColorWorld(CMWorldRef *cw, CMConcatProfileSet *profileSet);
extern  CMError CWConcatColorWorld4MS (	CMWorldRef *storage, CMConcatProfileSet	*profileSet,
									    UINT32	*aIntentArr, UINT32 nIntents,
										UINT32 dwFlags );
extern  CMError	CWCreateLink4MS( CMWorldRef storage, CMConcatProfileSet *profileSet, UINT32 aIntentArr, icProfile **theLinkProfile );
extern  CMError CWLinkColorWorld(CMWorldRef *cw, CMConcatProfileSet *profileSet);
extern  void	CWDisposeColorWorld(CMWorldRef cw);
extern  CMError CWMatchColors(CMWorldRef cw, CMColor *myColors, unsigned long count);
extern  CMError CWCheckColors(CMWorldRef cw, CMColor *myColors, unsigned long count, unsigned char *result);
extern  CMError CWCheckColorsMS(CMWorldRef cw, CMColor *myColors, unsigned long count, unsigned char *result);
extern  CMError CWGetColorSpaces(CMWorldRef cw, CMBitmapColorSpace *In, CMBitmapColorSpace *Out );
/* Bitmap matching */
extern  CMError CWMatchBitmap(CMWorldRef cw, CMBitmap *bitmap, CMBitmapCallBackUPP progressProc, void *refCon, CMBitmap *matchedBitmap);
extern  CMError CWCheckBitmap(CMWorldRef cw, const CMBitmap *bitmap, CMBitmapCallBackUPP progressProc, void *refCon, CMBitmap *resultBitmap);
extern  CMError CWMatchBitmapPlane(CMWorldRef cw, LH_CMBitmapPlane *bitmap, CMBitmapCallBackUPP progressProc, void *refCon, LH_CMBitmapPlane *matchedBitmap);
extern  CMError CWCheckBitmapPlane(CMWorldRef cw, LH_CMBitmapPlane *bitmap, CMBitmapCallBackUPP progressProc, void *refCon, LH_CMBitmapPlane *matchedBitmap);

extern  void	CMFullColorRemains( CMWorldRef Storage, long ColorMask ); /* Special function for cmyk to cmyk match */
extern  void	CMSetLookupOnlyMode( CMWorldRef Storage, PI_Boolean Mode ); /* Special function for setting or resetting LookupOnly Mode after NCMInit.., CMConcat.. */
extern  CMError CMValidateProfile( CMProfileRef prof, PI_Boolean* valid );

extern  CMError CMConvNameToIndexProfile( CMProfileRef prof, pcCMColorName, unsigned long *, unsigned long );
extern  CMError CMConvNameToIndexCW( CMWorldRef *Storage, pcCMColorName, unsigned long *, unsigned long );
extern  CMError CMConvIndexToNameProfile( CMProfileRef prof, unsigned long *, pCMColorName, unsigned long );
extern  CMError CMConvIndexToNameCW( CMWorldRef *Storage, unsigned long *, pCMColorName, unsigned long );
extern  CMError CMGetNamedProfileInfoProfile( CMProfileRef prof, pCMNamedProfileInfo );
extern  CMError CMGetNamedProfileInfoCW( CMWorldRef *Storage, pCMNamedProfileInfo );
/*
extern	CMError CMConvertNamedIndexToPCS( CMWorldRef cw, CMColor *theData, unsigned long pixCnt );
extern	CMError CMConvertNamedIndexToColors( CMWorldRef cw, CMColor *theData, unsigned long pixCnt );
extern	CMError CMConvertNamedIndexBitMap( CMWorldRef cw, CMBitmap *BitMap, CMBitmap *resultBitMap );
*/
#if PRAGMA_IMPORT_SUPPORTED
#pragma import off
#endif

#if PRAGMA_ALIGN_SUPPORTED
#pragma options align=reset
#endif

#ifdef __cplusplus
}
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\mscmm.w98\mscmm\memprof.c ===
/*
	File:		MSNewMemProfile.c

	Contains:	
		creation of mem based profiles

	Written by:	U. J. Krabbenhoeft

	Copyright:	 1993-1997 by Heidelberger Druckmaschinen AG, all rights reserved.

	Version:	
*/

#include "Windef.h"
#include "WinGdi.h"
#include <wtypes.h>
#include <winbase.h>
#include <windowsX.h>
#include "ICM.h"

#ifndef LHGeneralIncs_h
#include "General.h"
#endif

#ifndef MSNewMemProfile_h
#include "MemProf.h"
#endif

#ifndef MemLink_h
#include "MemLink.h"
#endif

#ifdef _DEBUG
//#define WRITE_PROFILE
#endif
#if ! realThing
#ifdef DEBUG_OUTPUT
#define kThisFile kLHMemProfileID
#endif
#endif

#ifdef WRITE_PROFILE
void WriteProf( LPSTR name, icProfile *theProf, long currentSize );
#endif

CMError MyNewDeviceLink( CMWorldRef cw, CMConcatProfileSet *profileSet, LPSTR theProf )
{
	CMError			err = unimpErr;
	PROFILE			pProf;
	HPROFILE		aHProf;

	pProf.pProfileData = (PVOID *)theProf;
	pProf.dwType = PROFILE_FILENAME;
	pProf.cbDataSize = strlen((const unsigned char *)pProf.pProfileData) * sizeof(CHAR);
	aHProf = OpenColorProfile( &pProf, PROFILE_READWRITE, 0, CREATE_ALWAYS );
 	if( !aHProf ){
		err = GetLastError();
		goto CleanupAndExit;
	}
	err = MyNewDeviceLinkFill( cw, profileSet, aHProf );

CleanupAndExit:
	return err;
}

CMError MyNewDeviceLinkW( CMWorldRef cw, CMConcatProfileSet *profileSet, LPWSTR theProf )
{
	CMError			err = unimpErr;
	PROFILE			pProf;
	HPROFILE		aHProf;

	pProf.pProfileData = (PVOID *)theProf;
	pProf.dwType = PROFILE_FILENAME;
	pProf.cbDataSize = wcslen((const unsigned short *)pProf.pProfileData) * sizeof(WCHAR);
	aHProf = OpenColorProfileW( &pProf, PROFILE_READWRITE, 0, CREATE_ALWAYS );
 	if( !aHProf ){
		err = GetLastError();
		goto CleanupAndExit;
	}
	err = MyNewDeviceLinkFill( cw, profileSet, aHProf );
CleanupAndExit:
	return err;
}

CMError MyNewDeviceLinkFill( CMWorldRef cw, CMConcatProfileSet *profileSet, HPROFILE aHProf )
{
	CMError			err = unimpErr;
	OSErr			aOSerr = unimpErr;
#ifdef __MWERKS__
        unsigned char			theText[] = "\pLogColorSpProfile";
#else
      char			theText[] = "\024DeviceLinkProfile   ";
#endif
	char			copyrightText[] = "\0601996 by Heidelberger Druckmaschinen AG  U.J.K.";
	Ptr 			aPtr=0;
	long 			theHeaderSize;
	long 			theDescSize;
	long 			theMediaSize;
	long 			theCopyRightSize;
	long 			currentSize=0;
	long 			theTotalSize=0;
	long 			theSequenceDescSize = 0;
	long			theA2B0Size;
	unsigned long	aIntent;
	UINT32			sCS,dCS,clutSize;
	OSErr			aOSErr;


	MyDoubleXYZ D50XYZ = { 0.9642, 1.0000, 0.8249 };
	icXYZNumber D50 = { (unsigned long)(D50XYZ.X * 65536), (unsigned long)(D50XYZ.Y * 65536), (unsigned long)(D50XYZ.Z * 65536)};
	theHeaderSize = sizeof(icHeader);

	theDescSize   = 									  sizeof(OSType) 			/* type descriptor */
														+ sizeof(unsigned long) 	/* reserved */
														+ sizeof(unsigned long) 	/* ASCII length */
														+ theText[0]				/* ASCII profile description */
														+ sizeof(unsigned long)		/* Unicode code */
														+ sizeof(unsigned long)		/* Unicode character count */
														+ sizeof(unsigned short)	/* Macintosh script code */
														+ sizeof(unsigned char)		/* Macintosh string length */
														+ 67						/* Macintosh string */
														;
	theCopyRightSize   = 								  sizeof(OSType) 			/* type descriptor */
														+ sizeof(unsigned long) 	/* reserved */
														+ copyrightText[0]			/* ASCII profile description */
														;
	theMediaSize = sizeof( icXYZType );;

	aPtr = SmartNewPtrClear( 5000, &aOSerr );
	err = aOSerr;
	if (err)
		goto CleanupAndExit;

	aIntent = 0;

	err = MyGetColorSpaces( profileSet, &sCS, &dCS );
	if (err)
		goto CleanupAndExit;
		
	err = MyAdd_NL_HeaderMS(theHeaderSize+4, (icHeader*)aPtr, aIntent, sCS, dCS );
	if (err)
		goto CleanupAndExit;
		
	err = SetColorProfileHeader( aHProf, (PPROFILEHEADER)aPtr);
	if (!err){
		err = GetLastError();
		goto CleanupAndExit;
	}

	err =MyAdd_NL_DescriptionTag	( (LHTextDescriptionType *)aPtr, (unsigned char *)theText );
	if (err)
		goto CleanupAndExit;
	err = SetColorProfileElementSize( aHProf, icSigProfileDescriptionTag, theDescSize );
	if (!err){
		err = GetLastError();
		goto CleanupAndExit;
	}
	err = SetColorProfileElement( aHProf, icSigProfileDescriptionTag, 0, (DWORD *)&theDescSize, aPtr );
	if (!err){
		err = GetLastError();
		goto CleanupAndExit;
	}

	err = MyAdd_NL_ColorantTag((icXYZType *)aPtr, &D50);
	if (err)
		goto CleanupAndExit;

	err = SetColorProfileElementSize( aHProf, icSigMediaWhitePointTag, theMediaSize );
	if (!err){
		err = GetLastError();
		goto CleanupAndExit;
	}
	err = SetColorProfileElement( aHProf, icSigMediaWhitePointTag, 0, (DWORD *)&theMediaSize, aPtr );
	if (!err){
		err = GetLastError();
		goto CleanupAndExit;
	}

	err = MyAdd_NL_CopyrightTag( (unsigned char *)copyrightText, (LHTextType *)aPtr);
	if (err)
		goto CleanupAndExit;
	err = SetColorProfileElementSize( aHProf, icSigCopyrightTag, theCopyRightSize );
	if (!err){
		err = GetLastError();
		goto CleanupAndExit;
	}
	err = SetColorProfileElement( aHProf, icSigCopyrightTag, 0, (DWORD *)&theCopyRightSize, aPtr );
	if (!err){
		err = GetLastError();
		goto CleanupAndExit;
	}
		
	err = MyAdd_NL_SequenceDescTag( profileSet, (icProfileSequenceDescType *)aPtr, &theSequenceDescSize );
	if (err)
		goto CleanupAndExit;
	err = SetColorProfileElementSize( aHProf, icSigProfileSequenceDescTag, theSequenceDescSize );
	if (!err){
		err = GetLastError();
		goto CleanupAndExit;
	}
	err = SetColorProfileElement( aHProf, icSigProfileSequenceDescTag, 0, (DWORD *)&theSequenceDescSize, aPtr );
	if (!err){
		err = GetLastError();
		goto CleanupAndExit;
	}
	
	aPtr = DisposeIfPtr( aPtr );

    theA2B0Size = GetSizes( (CMMModelPtr)cw, &clutSize );

	aPtr =  SmartNewPtr( theA2B0Size, &aOSErr );
	err = aOSErr;
	if (err)
		goto CleanupAndExit;

	if ( ((CMMModelPtr)cw)->lutParam.colorLutWordSize == 8)
        err = MyAdd_NL_AToB0Tag_mft1( (CMMModelPtr)cw, (icLut8Type *)aPtr, clutSize );
    else
        err = MyAdd_NL_AToB0Tag_mft2( (CMMModelPtr)cw, (icLut16Type *)aPtr, clutSize );

	if (err)
		goto CleanupAndExit;

	//if( theA2B0Size > 12000 ) theA2B0Size = 12000;
	err = SetColorProfileElementSize( aHProf, icSigAToB0Tag, theA2B0Size );
	if (!err){
		err = GetLastError();
		goto CleanupAndExit;
	}
	err = SetColorProfileElement( aHProf, icSigAToB0Tag, 0, (DWORD *)&theA2B0Size, aPtr );
	if (!err){
		err = GetLastError();
		goto CleanupAndExit;
	}
		
	err = noErr;
	
CleanupAndExit:
	CloseColorProfile( aHProf );
	aPtr = DisposeIfPtr( aPtr );
	return err;
}

#ifdef WRITE_PROFILE
#ifdef IS_MAC
/*#include <unistd.h>*/
/*#include <fcntl.h>*/
#else
#include <fcntl.h>
#include <io.h>
#include <sys/stat.h>
#endif
#include <stdio.h>

void WriteProf( LPSTR name, icProfile *theProf, long currentSize )
{
	int fh;
	
	fh = open( name, O_CREAT|O_RDWR|O_BINARY, _S_IREAD | _S_IWRITE );
	if( fh <= 0 ){
#ifdef DEBUG_OUTPUT
		printf("Open %s failed\n",name);
#endif
		return;
	}
	write( fh, (Ptr)theProf, currentSize );
	close(fh);
}
#endif

#include <io.h>
#include <fcntl.h>
#include <sys/stat.h>
long SaveMyProfile( LPSTR lpProfileName, LPWSTR lpProfileNameW, PPROFILE theProf )
{
	long ret;
	int fh;

	if( theProf->dwType != PROFILE_MEMBUFFER ){
		SetLastError( (unsigned long) unimpErr );
		return 0;
	}
	if( lpProfileNameW == 0 ){
		if( lpProfileName == 0 ) return 0;
		fh = _open( lpProfileName, _O_BINARY | _O_CREAT  | _O_EXCL, _S_IREAD | _S_IWRITE );
	}
	else{
		fh = _wopen( lpProfileNameW, _O_BINARY | _O_CREAT  | _O_EXCL, _S_IREAD | _S_IWRITE );
	}
	if( fh == -1 ) return -1;

	if( theProf->pProfileData == 0 ){
		SetLastError( ERROR_INVALID_DATA );
		return 0;
	}
	ret = _write( fh, theProf->pProfileData, theProf->cbDataSize );
	if( ret == -1 ) return -1;

	ret = _close( fh );
	if( ret == -1 ) return -1;
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\mscmm.w98\lh_open\pi_run.c ===
/*
	File:		PI_CWRuntime.c

	Contains:	
				
	Written by:	U. J. Krabbenhoeft

	Version:

	Copyright:	 1993-1997 by Heidelberger Druckmaschinen AG, all rights reserved.

*/

#ifndef LHGeneralIncs_h
#include "General.h"
#endif


#ifndef LHCMRuntime_h
#include "Runtime.h"
#endif
/* ______________________________________________________________________

CMError CWMatchBitmap   ( 
 							CMWorldRef          Storage,
							CMBitmap*           bitMap, 
							CMBitmapCallBackUPP progressProc, 
							void*               refCon, 
							CMBitmap*           matchedBitMap)
        Abstract:
                Match pixel data of bitMap according to the CMProfileRef parameters
                supplied to a previous call to CMMInitPrivate(), CWNewColorWorld(...),
                CMMConcatInitPrivate() or CWConcatColorWorld(...).

        Params:
                storage                 (in)            Reference to ColorWorld storage.
                bitMap                  (in/out)        Describes source BitMap data.
                progressProc            (in)            Client function which is called once
                                                        per row of the BitMap. If the
                                                        function result is TRUE then the
                                                        operation is aborted. May be NULL.
                refCon                  (in)            Client data which is passed as a
                                                        parameter to calls to progressProc.
                matchedBitMap           (in/out)        Result matched BitMap. The caller
                                                        is responsible for allocating the
                                                        pixel buffer pointed to by baseAddr.
                                                        If NULL then the source BitMap is
                                                        matched in place.
        
        Return:
               noErr                                    successful
               System or result code if an error occurs.

   _____________________________________________________________________ */

CMError CWMatchBitmap   ( 
 							CMWorldRef          Storage,
							CMBitmap*           bitMap, 
							CMBitmapCallBackUPP progressProc, 
							void*               refCon, 
							CMBitmap*           matchedBitMap)

{
	CMError			err = noErr;
	CMMModelPtr aPtr;

	if( Storage == 0 )return cmparamErr;
	LOCK_DATA( Storage );
	aPtr = (CMMModelPtr)(DATA_2_PTR(	Storage ));
	err = LHMatchBitMapPrivate(	aPtr, 
								(const CMBitmap*)bitMap, 
								progressProc,
								refCon, 
								matchedBitMap );
	UNLOCK_DATA( Storage );
	return err;
}

/* ______________________________________________________________________

CMError CWCheckBitmap (
							CMWorldRef			Storage, 
							const CMBitmap		*bitMap,
							CMBitmapCallBackUPP	progressProc,
							void				*refCon,
							CMBitmap 			*resultBitMap )
						
	Abstract:
		Gamut test pixel data of bitMap  according to the CMProfileRef
		parameters supplied to a previous call to CMMInitPrivate(), CWNewColorWorld(...),
		CMMConcatInitPrivate() or CWConcatColorWorld(...).

	Params:
		storage			(in)		Reference to ColorWorld storage.
		bitMap			(in/out)	Describes BitMap data.
		progressProc	(in)		Client function which is called
									once per row of the BitMap. If
									the function result is true then
									the operation is aborted.May be NULL.
		refCon			(in)		Client data which is passed as a
									parameter to calls to progressProc.
		resultBitMap	(in/out)	Result BitMap. Must be one bit depth
									and equal bounds of bitMap parameter.
									Pixels are set to 1 if corresponding
									pixel of bitMap is out of gamut.
		
	Return:
		noErr		successful
		System or result code if an error occurs.

   _____________________________________________________________________ */

CMError CWCheckBitmap (
							CMWorldRef			Storage, 
							const CMBitmap		*bitMap,
							CMBitmapCallBackUPP	progressProc,
							void				*refCon,
							CMBitmap 			*resultBitMap )
{
	CMError		err = noErr;
	CMMModelPtr aPtr;

	if( Storage == 0 )return cmparamErr;
	LOCK_DATA( Storage );
	aPtr = (CMMModelPtr)(DATA_2_PTR(	Storage ));
    err = LHCheckBitMapPrivate(  aPtr, 
                                  (const CMBitmap*)bitMap, 
                                  progressProc,
                                  refCon, 
                                  resultBitMap );
	UNLOCK_DATA( Storage );
	return err;
}
/* ______________________________________________________________________

CMError CWMatchBitmapPlane(	CMWorldRef          Storage,
                         	LH_CMBitmapPlane*   bitMap, 
                         	CMBitmapCallBackUPP progressProc, 
                         	void*               refCon, 
                         	LH_CMBitmapPlane*   matchedBitMap)
                        
        Abstract:
                Match pixel data of LH_CMBitmapPlane according to the CMProfileRef parameters
                supplied to a previous call to CMMInitPrivate(), CWNewColorWorld(...),
                CMMConcatInitPrivate() or CWConcatColorWorld(...).

        Params:
                storage                 (in)            Reference to ColorWorld storage.
                bitMap                  (in/out)        Describes source BitMap data.
                progressProc            (in)            Client function which is called once
                                                        per row of the BitMap. If the
                                                        function result is TRUE then the
                                                        operation is aborted. May be NULL.
                refCon                  (in)            Client data which is passed as a
                                                        parameter to calls to progressProc.
                matchedBitMap           (in/out)        Result matched BitMap. The caller
                                                        is responsible for allocating the
                                                        pixel buffer pointed to by baseAddr.
                                                        If NULL then the source BitMap is
                                                        matched in place.
        
        Return:
               noErr                                    successful
               System or result code if an error occurs.

   _____________________________________________________________________ */

CMError CWMatchBitmapPlane(	CMWorldRef          Storage,
                         	LH_CMBitmapPlane*   bitMap, 
                         	CMBitmapCallBackUPP progressProc, 
                         	void*               refCon, 
                         	LH_CMBitmapPlane*   matchedBitMap)

{
	CMError			err = noErr;
	CMMModelPtr aPtr;

	if( Storage == 0 )return cmparamErr;
	LOCK_DATA( Storage );
	aPtr = (CMMModelPtr)(DATA_2_PTR(	Storage ));
	err = LHMatchBitMapPlanePrivate(	aPtr, 
                                  		(const LH_CMBitmapPlane*)bitMap, 
                                 	 	progressProc,
                                  		refCon, 
                                  		matchedBitMap );
	UNLOCK_DATA( Storage );
	return err;
}

/* ______________________________________________________________________

 CMError CWCheckBitmapPlane(	CMWorldRef          Storage,
								LH_CMBitmapPlane*   bitMap, 
								CMBitmapCallBackUPP progressProc, 
								void*               refCon, 
								LH_CMBitmapPlane*   CheckedBitMap)
                        
        Abstract:
                Check pixel data of LH_CMBitmapPlane according to the CMProfileRef parameters
                supplied to a previous call to CMMInitPrivate(), CWNewColorWorld(...),
                CMMConcatInitPrivate() or CWConcatColorWorld(...).

        Params:
                storage                 (in)            Reference to ColorWorld storage.
                bitMap                  (in/out)        Describes source BitMap data.
                progressProc            (in)            Client function which is called once
                                                        per row of the BitMap. If the
                                                        function result is TRUE then the
                                                        operation is aborted. May be NULL.
                refCon                  (in)            Client data which is passed as a
                                                        parameter to calls to progressProc.
                CheckedBitMap           (in/out)        Result Checked BitMap. The caller
                                                        is responsible for allocating the
                                                        pixel buffer pointed to by baseAddr.
                                                        If NULL then the source BitMap is
                                                        Checked in place.
        
        Return:
               noErr                                    successful
               System or result code if an error occurs.

   _____________________________________________________________________ */

 CMError CWCheckBitmapPlane(	CMWorldRef          Storage,
								LH_CMBitmapPlane*   bitMap, 
								CMBitmapCallBackUPP progressProc, 
								void*               refCon, 
								LH_CMBitmapPlane*   CheckedBitMap)

{
	Storage=Storage;
	bitMap=bitMap;
	progressProc=progressProc;
	refCon=refCon;
	CheckedBitMap=CheckedBitMap;
	return cmparamErr;
	/*CMError			err = noErr;
	CMMModelPtr aPtr;

	if( Storage == 0 )return cmparamErr;
	LOCK_DATA( Storage );
	aPtr = (CMMModelPtr)(DATA_2_PTR(	Storage ));
	err = LHMatchBitMapPlanePrivate( aPtr, 
                                  	(const LH_CMBitmapPlane*)bitMap, 
                                 	progressProc,
                                  	refCon, 
                                  	CheckedBitMap );
	UNLOCK_DATA( Storage );
		return err;*/
}

/*---------------------------------------------------------------------------------
 CMError CWMatchColors(	CMWorldRef		Storage,
						CMColor			*myColors, 
						unsigned long	count )
						
	Abstract:
		Color-matching on a list of CMColor. The source and destination
		data types are specified by the CMProfileRef parameters to the
		previous call to the CMMInitPrivate(), CWNewColorWorld(...),
		CMMConcatInitPrivate() or CWConcatColorWorld(...) function.

	Params:
		storage		(in)		Reference to ColorWorld storage.
		myColors	(in/out)	Array of CMColor.
		count		(in)		One-based count of elements in array.
		
	Return:
		noErr		successful
		System or result code if an error occurs.

   _____________________________________________________________________ */
 CMError CWMatchColors(	CMWorldRef		Storage,
						CMColor			*myColors, 
						unsigned long	count )

{
	CMError			err = noErr;
	CMMModelPtr aPtr;

	if( Storage == 0 )return cmparamErr;
	LOCK_DATA( Storage );
	aPtr = (CMMModelPtr)(DATA_2_PTR(	Storage ));
	err = LHMatchColorsPrivate( aPtr, myColors, count );
	UNLOCK_DATA( Storage );
	return err;
}

/* ______________________________________________________________________

CMError CWCheckColorsMS ( 
						CMWorldRef 		Storage, 
						CMColor 		*myColors, 
						unsigned long	count, 
						long 			*result )
						
	Abstract:
		Gamut test a list of CMColor. The source and destination are
		specified by the CMProfileRef parameters to the previous call to
		the CMMInitPrivate(), CWNewColorWorld(...),
		CMMConcatInitPrivate() or CWConcatColorWorld(...) function.

	Params:
		storage		(in)		Reference to ColorWorld storage.
		myColors	(in)		Array of CMColor.
		count		(in)		One-based count of elements in array.
		result		(in/out)	Bits in array are set to 1 if the corresponding color is out of gamut.
		
	Return:
		noErr		successful
		System or result code if an error occurs.

   _____________________________________________________________________ */


CMError CWCheckColorsMS ( 
						CMWorldRef 		Storage, 
						CMColor 		*myColors, 
						unsigned long	count, 
						UINT8 			*result )
{
	CMError			err = noErr;
	CMMModelPtr aPtr;

	if( Storage == 0 )return cmparamErr;
	LOCK_DATA( Storage );
	aPtr = (CMMModelPtr)(DATA_2_PTR(	Storage ));
	err = LHCheckColorsPrivateMS( aPtr, myColors, count, result );
	UNLOCK_DATA( Storage );
	return err;
}
/* ______________________________________________________________________

CMError CWCheckColors ( 
						CMWorldRef 		Storage, 
						CMColor 		*myColors, 
						unsigned long	count, 
						unsigned char	*result )
						
	Abstract:
		Gamut test a list of CMColor. The source and destination are
		specified by the CMProfileRef parameters to the previous call to
		the CMMInitPrivate(), CWNewColorWorld(...),
		CMMConcatInitPrivate() or CWConcatColorWorld(...) function.

	Params:
		storage		(in)		Reference to ColorWorld storage.
		myColors	(in)		Array of CMColor.
		count		(in)		One-based count of elements in array.
		result		(in/out)	Bits in array are set to 1 if the corresponding color is out of gamut.
		
	Return:
		noErr		successful
		System or result code if an error occurs.

   _____________________________________________________________________ */


CMError CWCheckColors ( 
						CMWorldRef 		Storage, 
						CMColor 		*myColors, 
						unsigned long	count, 
						unsigned char	*result )
{
	CMError			err = noErr;
	CMMModelPtr aPtr;

	if( Storage == 0 )return cmparamErr;
	LOCK_DATA( Storage );
	aPtr = (CMMModelPtr)(DATA_2_PTR(	Storage ));
	err = LHCheckColorsPrivate( aPtr, myColors, count, result );
	UNLOCK_DATA( Storage );
	return err;
}
/* ______________________________________________________________________

 CMError CWGetColorSpaces(	CMWorldRef cw, 
							CMBitmapColorSpace *In, 
							CMBitmapColorSpace *Out );
                        
        Abstract:
                Get input and output colorspace out of CMWorldRef.

        Params:
                cw       (in)            Reference to ColorWorld storage.
                In       (Out)           Reference to input CMBitmapColorSpace.
                In       (Out)           Reference to output CMBitmapColorSpace.
        
        Return:
               noErr                                    successful
               System or result code if an error occurs.

   _____________________________________________________________________ */

CMError CWGetColorSpaces(	CMWorldRef cw, 
							CMBitmapColorSpace *In, 
							CMBitmapColorSpace *Out )

{
	CMError			err = noErr;
	CMMModelPtr aPtr;

	if( cw == 0 )return cmparamErr;
	LOCK_DATA( cw );
	aPtr = (CMMModelPtr)(DATA_2_PTR( cw ));
	*In = aPtr->firstColorSpace;
	*Out = aPtr->lastColorSpace;
	UNLOCK_DATA( cw );
	return err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\mscmm.w98\lh_open\pi_color.c ===
/*
	File:		PI_ColorWorld.c

	Contains:	
				
	Written by:	U. J. Krabbenhoeft

	Version:

	Copyright:	 1993-1997 by Heidelberger Druckmaschinen AG, all rights reserved.

*/
#ifndef LHGeneralIncs_h
#include "General.h"
#endif

#ifndef PI_ColorWorld_h
#include "PI_Color.h"
#endif

#ifndef realThing
#ifdef DEBUG_OUTPUT
#define kThisFile kLHCMDo3DID
#define __TYPES__
/*#include "DebugSpecial.h"*/
/*#include "LH_Util.h"*/
#endif
#endif

#ifndef PI_CMMInitialization_h
#include "PI_CMM.h"
#endif

#ifndef MemLink_h
#include "MemLink.h"
#endif

/* ______________________________________________________________________

         CMError
               LHColorWorldOpen (Handle* storage)

        Abstract:
                opens ColorWorld and allocates up any necessary memory

        Params:
                storage         (in/out)   pointer to
                                           handle to memory to be used by CMM

        Return:
                noErr                      successful

   _____________________________________________________________________ */

 CMError LHColorWorldOpen (Ptr* storage)
{ 
    Ptr 			    myStorage;
    OSErr               err;
    
    myStorage = (Ptr)SmartNewPtrClear( sizeof( CMMModelData ) , &err);
    if (err) 
        goto CleanupAndExit;
    else
    {
        *storage = myStorage;
    }

CleanupAndExit:
    return err;
}

/* ______________________________________________________________________

          CMError
        LHColorWorldClose(Handle storage);

        Abstract:
                closes ColorWorld and cleans up any remaining memory allocations

        Params:
                storage (in/out)        handle to memory to be used by CMM

        Return:
                noErr           successful

   _____________________________________________________________________ */

 CMError LHColorWorldClose( Ptr storage )
{ 
    CMMModelPtr  modelData = (CMMModelPtr)storage;

    if (storage)
    {
		DISPOSE_IF_DATA((modelData)->lutParam.inputLut);		
		DISPOSE_IF_DATA((modelData)->lutParam.outputLut);		
		DISPOSE_IF_DATA((modelData)->lutParam.colorLut);

		DISPOSE_IF_DATA((modelData)->gamutLutParam.inputLut);		
		DISPOSE_IF_DATA((modelData)->gamutLutParam.outputLut);		
		DISPOSE_IF_DATA((modelData)->gamutLutParam.colorLut);

		DISPOSE_IF_DATA((modelData)->theNamedColorTagData);
#if	__IS_MAC
		DisposeIfHandle((modelData)->Monet);
#endif

		DisposeIfPtr(storage);
    }
    return( noErr );
}
/* ______________________________________________________________________

         CMError
               CWNewColorWorld (CMWorldRef*    storage,
                                 CMProfileRef   srcProfile, 
                                 CMProfileRef   dstProfile)

        Abstract:
                opens ColorWorld and allocates up any necessary memory,
                fill buffer for color transformation


        Params:
                storage         (in/out)   Ptr to memory to be used by CMM
                srcProfile      (in)       pointer to source profile
                                           description
                dstProfile      (in)       pointer to destination profile
                                           description

                storage:
                typedef struct CMPrivateColorWorldRecord *CMWorldRef;

        Return:
                noErr                      successful
		System or result code if an error occurs.

   _____________________________________________________________________ */


 CMError 
       CWNewColorWorld (	CMWorldRef*    storage,
							CMProfileRef   srcProfile,
							CMProfileRef   dstProfile)
{ 
    Ptr 		myStorage;
    CMError    	err;

#ifdef DEBUG_OUTPUT
    /*printf("vor LHColorWorldOpen\n");*/
#endif
    err = LHColorWorldOpen(&myStorage);
#ifdef DEBUG_OUTPUT
    /*printf("nach LHColorWorldOpen: err = %d\n", err);*/
#endif
    if ( !err )
    {
        ((CMMModelPtr)myStorage)->aIntentArr	= 0;
		((CMMModelPtr)myStorage)->dwFlags		= 0xffffffff;
        err =  CMMInitPrivate((CMMModelPtr)myStorage,
                               srcProfile, 
                               dstProfile);
#ifdef DEBUG_OUTPUT
    /*printf("nach NCMMInitPrivate: err = %d\n", err);*/
#endif
    }


    if ( !err )
    {
		*storage = (CMWorldRef)myStorage;
    }
	else{
		*storage = (CMWorldRef)0;
		LHColorWorldClose( myStorage );
	}

    return err;
}

/* ______________________________________________________________________

         CMError
               CWConcatColorWorld (	CMWorldRef*    storage,
									CMConcatProfileSet* profileSet )

        Abstract:
                opens ColorWorld and allocates up any necessary memory,
                fill buffer for color transformation


        Params:
                storage         (in/out)   Ptr to memory to be used by CMM
				profileSet		(in)		CMConcatProfileSet contains an array of
											Profiles which describe the processing
											to be carried out.The profileSet array
											is in processing order Source through
											Destination. A minimum of one CMProfileRef
											must be specified.

                storage:
                typedef struct CMPrivateColorWorldRecord *CMWorldRef;

        Return:
                noErr                      successful
		System or result code if an error occurs.

   _____________________________________________________________________ */
 CMError 
       CWConcatColorWorld  (	CMWorldRef*         storage,
								CMConcatProfileSet* profileSet)
{ 
    Ptr 		myStorage;
    CMError     err;

    err = LHColorWorldOpen(&myStorage);

    if ( !err )
    {
        ((CMMModelPtr)myStorage)->aIntentArr	= 0;
		((CMMModelPtr)myStorage)->dwFlags		= 0xffffffff;
        err = CMMConcatInitPrivate  ((CMMModelPtr)myStorage, profileSet );
    }


    if ( !err )
    {
		*storage = (CMWorldRef)myStorage;
    }
	else{
		*storage = (CMWorldRef)0;
		LHColorWorldClose( myStorage );
	}

    return err;
}

#if WRITE_PROFILE
 void WriteProf( Ptr name, icProfile *theProf, long currentSize );
#endif
/* ______________________________________________________________________

         CMError
           CWConcatColorWorld4MS (	CMWorldRef			*storage,
									CMConcatProfileSet	*profileSet,
									UINT32				*aIntentArr,
									UINT32				nIntents,
									UINT32				dwFlags
								)

        Abstract:
                opens ColorWorld and allocates up any necessary memory,
                fill buffer for color transformation


        Params:
                storage         (in/out)   Ptr to memory to be used by CMM
				profileSet		(in)		CMConcatProfileSet contains an array of
											Profiles which describe the processing
											to be carried out.The profileSet array
											is in processing order Source through
											Destination. A minimum of one CMProfileRef
											must be specified.

				padwIntents		(in)		Points to an array of intent structures.
											0 = default behavior ( intents out of profiles )

				nIntents		(in)		Specifies the number of intents in the intent array. 
											Can be 1, or the same value as nProfiles.

				dwFlags			(in)		Specifies flags to control creation of the transform.
											These flags are intended only as hints, and it is up to the CMM
											to determine how best to use these flags. 
											Set the high-order word to ENABLE_GAMUT_CHECKING if the transform will be used 
											for gamut checking. 
											The low-order WORD can have one of the following constant values:
											PROOF_MODE, NORMAL_MODE, BEST_MODE. Moving from PROOF_MODE to BEST_MODE, 
											output quality generally improves and transform speed declines.
        Return:
                noErr                      successful
		System or result code if an error occurs.

   _____________________________________________________________________ */
 CMError	CWConcatColorWorld4MS  (	CMWorldRef			*storage,
										CMConcatProfileSet	*profileSet,
										UINT32				*aIntentArr,
										UINT32				nIntents,
										UINT32				dwFlags
								  )
{ 
    Ptr 		myStorage;
    CMError     err;
#if WRITE_PROFILE
	icProfile *theLinkProfile;
	long l;
#endif

    err = LHColorWorldOpen(&myStorage);

    if ( !err )
    {
		((CMMModelPtr)myStorage)->aIntentArr	= aIntentArr;
        ((CMMModelPtr)myStorage)->nIntents		= nIntents;
        ((CMMModelPtr)myStorage)->dwFlags		= dwFlags;
		err = CMMConcatInitPrivate  ((CMMModelPtr)myStorage, profileSet );
    }


    if ( !err )
    {
		*storage = (CMWorldRef)myStorage;
    }
	else{
		*storage = (CMWorldRef)0;
		LHColorWorldClose( myStorage );
	}

#if WRITE_PROFILE
	err = DeviceLinkFill( (CMMModelPtr)myStorage, profileSet, &theLinkProfile, 0 );
	if( !err ){
		l = *(unsigned long *)theLinkProfile;
		SwapLong(&l);
		WriteProf( "test", theLinkProfile, l );
	}
#endif
    return err;
}

 CMError 
       CWLinkColorWorld (	CMWorldRef*         storage,
                            CMConcatProfileSet* profileSet)
{ 
    Ptr 		myStorage;
    CMError     err;

    err = LHColorWorldOpen(&myStorage);

	if ( !err )
    {
		((CMMModelPtr)myStorage)->currentCall	= kCMMNewLinkProfile;
		((CMMModelPtr)myStorage)->aIntentArr	= 0;
		((CMMModelPtr)myStorage)->dwFlags		= 0xffffffff;
		err = CMMConcatInitPrivate  ((CMMModelPtr)myStorage, profileSet );
    }


    if ( !err )
    {
		*storage = (CMWorldRef)myStorage;
    }
	else{
		*storage = (CMWorldRef)0;
		LHColorWorldClose( myStorage );
	}

    return err;
}

/* ______________________________________________________________________

         CMError
               CWDisposeColorWorld (CMWorldRef storage)

        Abstract:
                closes ColorWorld and cleans up any remaining memory allocations

        Params:
                storage         (in/out)    handle to memory to be used by CMM
        
        Return:
                -
   _____________________________________________________________________ */


 void 
       CWDisposeColorWorld ( CMWorldRef storage )
{ 
    LHColorWorldClose ( (Ptr)storage ); 
}

void CMSetLookupOnlyMode( CMWorldRef	Storage,
						  PI_Boolean		Mode )
{
	CMMModelPtr		aPtr;

	if( Storage == 0 )return;
	LOCK_DATA( Storage );
	aPtr = (CMMModelPtr)(DATA_2_PTR(	Storage ));
	aPtr->lookup = Mode;
	UNLOCK_DATA( Storage );
	return;
}

void CMFullColorRemains( CMWorldRef	Storage,
						 long		ColorMask )
{
	CMMModelPtr		aPtr;
	CMLutParamPtr	lutParamPtr;
	long Address,Size,i,j;

	if( Storage == 0 )return;
	LOCK_DATA( Storage );
	aPtr = (CMMModelPtr)(DATA_2_PTR(	Storage ));
	lutParamPtr = &aPtr->lutParam; 

	Size = lutParamPtr->colorLutWordSize / 8;
	if( !(lutParamPtr->colorLutInDim == 4 && lutParamPtr->colorLutOutDim == 4 ))return;

	for( i=0; i<4; i++ ){
		if( (ColorMask & (1<<i)) == 0 ) continue;
		Address = lutParamPtr->colorLutGridPoints - 1;
		for( j=3-i+1; j<4; j++ )Address *= lutParamPtr->colorLutGridPoints;  
		Address	= Address * lutParamPtr->colorLutOutDim;
		for( j=0; j<4; j++){
			if( i == j ){
				if( Size == 1 ){
					*( ((unsigned char*)lutParamPtr->colorLut)+Address+3-j ) = (unsigned char)255;
				}
				else{
					*( ((unsigned short*)lutParamPtr->colorLut)+Address+3-j ) = (unsigned short)65535;
				}
			}
			else{
				if( Size == 1 ){
					*( ((unsigned char*)lutParamPtr->colorLut)+Address+3-j ) = (unsigned char)0;
				}
				else{
					*( ((unsigned short*)lutParamPtr->colorLut)+Address+3-j ) = (unsigned short)0;
				}
			}
		}
	}
	UNLOCK_DATA( Storage );
	return;
}

CMError	CWCreateLink4MS (				CMWorldRef			storage,
										CMConcatProfileSet	*profileSet,
										UINT32				aIntent,
										icProfile			**theLinkProfile )
{ 
    CMError     err;

	*theLinkProfile = 0;
	
	err = DeviceLinkFill( (CMMModelPtr)storage, profileSet, theLinkProfile, aIntent );

	return err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\mscmm.w98\lh_open\pi_valid.c ===
/*
	File:		PI_Val.c

	Contains:	
				
	Written by:	U. J. Krabbenhoeft

	Version:

	Copyright:	 1993-1997 by Heidelberger Druckmaschinen AG, all rights reserved.

*/
#ifndef LHGeneralIncs_h
#include "General.h"
#endif

PI_Boolean CMValInput(		CMProfileRef prof,
							icHeader* aHeader );
PI_Boolean CMValDisplay(	CMProfileRef prof,
							icHeader* aHeader );
PI_Boolean CMValOutput(		CMProfileRef prof,
							icHeader* aHeader );
PI_Boolean CMValLink(		CMProfileRef prof );
PI_Boolean CMValColorSpace(	CMProfileRef prof,
							icHeader* aHeader );
PI_Boolean CMValAbstract(	CMProfileRef prof,
							icHeader* aHeader );
PI_Boolean CMValNamed(		CMProfileRef prof,
							icHeader* aHeader );

PI_Boolean CMValGray(		CMProfileRef prof );
PI_Boolean CMValRGB(		CMProfileRef prof );
PI_Boolean CMValAToB(		CMProfileRef prof );
PI_Boolean CMValBToA(		CMProfileRef prof );
PI_Boolean CMValMftOutput(	CMProfileRef prof );

PI_Boolean CMValInput(	CMProfileRef prof,
						icHeader* aHeader )
{
	PI_Boolean valid;
	switch ( aHeader->colorSpace)
	{

		case icSigGrayData:
			valid = CMValGray(prof);
			break;

		case icSigRgbData:
			if (aHeader->pcs == icSigLabData)
			{
				valid = CMValAToB(prof);
			}
			else
			{
				valid = CMValRGB(prof);
			}
			break;

		case icSigCmyData:
		case icSigCmykData:
		case icSigMCH2Data:
		case icSigMCH3Data:
		case icSigMCH4Data:
		case icSigMCH5Data:
		case icSigMCH6Data:
		case icSigMCH7Data:
		case icSigMCH8Data:
		case icSigMCH9Data:
		case icSigMCHAData:
		case icSigMCHBData:
		case icSigMCHCData:
		case icSigMCHDData:
		case icSigMCHEData:
		case icSigMCHFData:
			valid = CMValAToB(prof);
			break;

		default:
			valid = FALSE;
	}

	if (aHeader->pcs != icSigXYZData && aHeader->pcs != icSigLabData){
		valid = FALSE;
	}
	return (valid);
}

PI_Boolean CMValDisplay(	CMProfileRef prof,
							icHeader* aHeader )
{
	PI_Boolean valid;
	switch (aHeader->colorSpace)
	{

		case icSigGrayData:
			valid = CMValGray(prof);
			break;

		case icSigRgbData:
			if (aHeader->pcs == icSigLabData){
				valid = CMValBToA(prof);
			}
			else{
				valid = CMValRGB(prof);
			}
			break;
		case icSigMCH3Data:
		case icSigMCH4Data:
		case icSigCmyData:
		case icSigCmykData:
			valid = CMValBToA(prof);
			break;

		default:
			valid = FALSE;
	}

	if (aHeader->pcs != icSigXYZData && aHeader->pcs != icSigLabData){
		valid = FALSE;
	}
	return (valid);
}

PI_Boolean CMValOutput(	CMProfileRef prof,
						icHeader* aHeader )
{
	PI_Boolean valid;
	switch (aHeader->colorSpace)
	{

		case icSigGrayData:
			valid = CMValGray(prof);
			break;

		case icSigRgbData:
		case icSigCmyData:
		case icSigCmykData:
		case icSigMCH2Data:
		case icSigMCH3Data:
		case icSigMCH4Data:
		case icSigMCH5Data:
		case icSigMCH6Data:
		case icSigMCH7Data:
		case icSigMCH8Data:
		case icSigMCH9Data:
		case icSigMCHAData:
		case icSigMCHBData:
		case icSigMCHCData:
		case icSigMCHDData:
		case icSigMCHEData:
		case icSigMCHFData:
			valid = CMValMftOutput(prof);
			break;

		default:
			valid = FALSE;
	}

	if (aHeader->pcs != icSigXYZData && aHeader->pcs != icSigLabData){
		valid = FALSE;
	}
	return (valid);
}

PI_Boolean CMValLink(	CMProfileRef prof )
{
	PI_Boolean valid;
	valid = CMProfileElementExists((CMProfileRef)prof, icSigProfileDescriptionTag);

	if (valid)
		valid = CMProfileElementExists((CMProfileRef)prof, icSigAToB0Tag);

	if (valid)
		valid = CMProfileElementExists((CMProfileRef)prof, icSigProfileSequenceDescTag);

	if (valid)
		valid = CMProfileElementExists((CMProfileRef)prof, icSigCopyrightTag);

	return (valid);
}

PI_Boolean CMValColorSpace(	CMProfileRef prof,
							icHeader* aHeader )
{
	PI_Boolean valid;
	if (aHeader->pcs != icSigXYZData && aHeader->pcs != icSigLabData){
		valid = FALSE;
		return (valid);
	}

	valid = CMProfileElementExists((CMProfileRef)prof, icSigProfileDescriptionTag);

	if (valid)
		valid = CMProfileElementExists((CMProfileRef)prof, icSigAToB0Tag);

	if (valid)
		valid = CMProfileElementExists((CMProfileRef)prof, icSigBToA0Tag);

	if (valid)
		valid = CMProfileElementExists((CMProfileRef)prof, icSigMediaWhitePointTag);

	if (valid)
		valid = CMProfileElementExists((CMProfileRef)prof, icSigCopyrightTag);

	return (valid);
}


PI_Boolean CMValAbstract(	CMProfileRef prof,
							icHeader* aHeader )
{
	PI_Boolean valid;
	switch (aHeader->pcs)
	{

		case icSigXYZData:
		case icSigLabData:
			valid = CMValAToB(prof);
			break;

		default:
			valid = FALSE;
	}

	return (valid);
}

PI_Boolean CMValNamed(		CMProfileRef prof,
							icHeader* aHeader )
{
	PI_Boolean valid;
	if (aHeader->pcs != icSigXYZData && aHeader->pcs != icSigLabData){
		valid = FALSE;
		return (valid);
	}

	valid = CMProfileElementExists((CMProfileRef)prof, icSigProfileDescriptionTag);

	if (valid)
		valid = CMProfileElementExists((CMProfileRef)prof, icSigNamedColor2Tag);

	if (valid)
		valid = CMProfileElementExists((CMProfileRef)prof, icSigMediaWhitePointTag);

	if (valid)
		valid = CMProfileElementExists((CMProfileRef)prof, icSigCopyrightTag);

	return (valid);
}

PI_Boolean CMValGray(	CMProfileRef prof )
{
	PI_Boolean valid;
	valid = CMProfileElementExists((CMProfileRef)prof, icSigProfileDescriptionTag);

	if (valid)
		valid = CMProfileElementExists((CMProfileRef)prof, icSigGrayTRCTag);

	if (valid)
		valid = CMProfileElementExists((CMProfileRef)prof, icSigMediaWhitePointTag);

	if (valid)
		valid = CMProfileElementExists((CMProfileRef)prof, icSigCopyrightTag);

	return (valid);
}

PI_Boolean CMValAToB(	CMProfileRef prof )
{
	PI_Boolean valid;
	valid = CMProfileElementExists((CMProfileRef)prof, icSigProfileDescriptionTag);

	if (valid)
		valid = CMProfileElementExists((CMProfileRef)prof, icSigAToB0Tag);

	if (valid)
		valid = CMProfileElementExists((CMProfileRef)prof, icSigMediaWhitePointTag);/* change to enum */

	if (valid)
		valid = CMProfileElementExists((CMProfileRef)prof, icSigCopyrightTag);/* change to enum */

	return (valid);
}

PI_Boolean CMValBToA(	CMProfileRef prof )
{
	PI_Boolean valid;
	valid = CMProfileElementExists((CMProfileRef)prof, icSigProfileDescriptionTag);

	if (valid)
		valid = CMProfileElementExists((CMProfileRef)prof, icSigBToA0Tag);

	if (valid)
		valid = CMProfileElementExists((CMProfileRef)prof, icSigMediaWhitePointTag);/* change to enum */

	if (valid)
		valid = CMProfileElementExists((CMProfileRef)prof, icSigCopyrightTag);/* change to enum */

	return (valid);
}

CMError CMValidateProfile(	CMProfileRef	prof,
							PI_Boolean		*valid )
{
	CMError err = noErr;
	icHeader aHeader;

	*valid = FALSE;
	err = CMGetProfileHeader((CMProfileRef)prof, &aHeader);

	if (!err)
	{
		if ((aHeader.version & 0xff000000) >= icVersionNumber ){
			switch (aHeader.deviceClass)
			  {
				case icSigInputClass:
				*valid = CMValInput(prof, &aHeader );
				break;

				case icSigDisplayClass:
				*valid = CMValDisplay(prof, &aHeader );
				break;

				case icSigOutputClass:
				*valid = CMValOutput(prof, &aHeader );
				break;

				case icSigLinkClass:
				*valid = CMValLink(prof);
				break;

				case icSigColorSpaceClass:
				*valid = CMValColorSpace(prof, &aHeader );
				break;

				case icSigAbstractClass:
				*valid = CMValAbstract(prof, &aHeader );
				break;

				case icSigNamedColorClass:
				*valid = CMValNamed(prof, &aHeader );
				break;

				default:
				*valid = FALSE;
			  }

		}
		else
		{										/* unknown profile */
			*valid = FALSE;
			return (cmProfileError);
		}
	}

	return (err);
}

PI_Boolean CMValMftOutput (	CMProfileRef prof )
{
	PI_Boolean valid;
	valid = CMProfileElementExists((CMProfileRef)prof, icSigProfileDescriptionTag);

	if (valid)
		valid = CMProfileElementExists((CMProfileRef)prof, icSigAToB0Tag);

	if (valid)
		valid = CMProfileElementExists((CMProfileRef)prof, icSigAToB1Tag);

	if (valid)
		valid = CMProfileElementExists((CMProfileRef)prof, icSigAToB2Tag);

	if (valid)
		valid = CMProfileElementExists((CMProfileRef)prof, icSigBToA0Tag);

	if (valid)
		valid = CMProfileElementExists((CMProfileRef)prof, icSigBToA1Tag);

	if (valid)
		valid = CMProfileElementExists((CMProfileRef)prof, icSigBToA2Tag);

	if (valid)
		valid = CMProfileElementExists((CMProfileRef)prof, icSigGamutTag);

	if (valid)
		valid = CMProfileElementExists((CMProfileRef)prof, icSigMediaWhitePointTag);

	if (valid)
		valid = CMProfileElementExists((CMProfileRef)prof, icSigCopyrightTag);

	return (valid);
}

PI_Boolean CMValRGB(			CMProfileRef prof )
{
	PI_Boolean valid;
	valid = CMProfileElementExists((CMProfileRef)prof, icSigProfileDescriptionTag);

	if (valid)
		valid = CMProfileElementExists((CMProfileRef)prof, icSigRedColorantTag);

	if (valid)
		valid = CMProfileElementExists((CMProfileRef)prof, icSigGreenColorantTag);

	if (valid)
		valid = CMProfileElementExists((CMProfileRef)prof, icSigBlueColorantTag);

	if (valid)
		valid = CMProfileElementExists((CMProfileRef)prof, icSigRedTRCTag);

	if (valid)
		valid = CMProfileElementExists((CMProfileRef)prof, icSigGreenTRCTag);

	if (valid)
		valid = CMProfileElementExists((CMProfileRef)prof, icSigBlueTRCTag);

	if (valid)
		valid = CMProfileElementExists((CMProfileRef)prof, icSigMediaWhitePointTag);/* wtpt change to enum */

	if (valid)
		valid = CMProfileElementExists((CMProfileRef)prof, icSigCopyrightTag);/* cprt change to enum */

	return (valid);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\mscmm.w98\mscmm\memprof.h ===
/*
	File:		MSNewMemProfile.h

	Contains:	

	Written by:	U. J. Krabbenhoeft

	Copyright:	 1993-1997 by Heidelberger Druckmaschinen AG, all rights reserved.

*/
#ifndef MSNewMemProfile_h
#define MSNewMemProfile_h


CMError MyNewAbstractW( LPLOGCOLORSPACEW	lpColorSpace, icProfile **theProf ); 
CMError MyNewAbstract(	LPLOGCOLORSPACEA	lpColorSpace, icProfile **theProf ); 
 
CMError MyNewDeviceLink( CMWorldRef cw, CMConcatProfileSet *profileSet, LPSTR theProf );
CMError MyNewDeviceLinkW( CMWorldRef cw, CMConcatProfileSet *profileSet, LPWSTR theProf );

CMError MyNewDeviceLinkFill( CMWorldRef cw, CMConcatProfileSet *profileSet, HPROFILE aHProf );
long	SaveMyProfile( LPSTR lpProfileName, LPWSTR lpProfileNameW, PPROFILE theProf );

CMError DeviceLinkFill(	CMMModelPtr cw, 
						CMConcatProfileSet *profileSet, 
						icProfile **theProf,
						unsigned long aIntent );
UINT32	GetSizes( CMMModelPtr cw, UINT32 *clutSize );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\mscmm.w98\mscmm\res.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by MSLinoCMM.rc
//
#define VER_DEBUG                       0

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\mscmm.w98\lh_open\pi_cmm.c ===
/*
	File:		PI_CMMInitialization.c

	Contains:	
				
	Written by:	U. J. Krabbenhoeft

	Version:

	Copyright:	 1993-1997 by Heidelberger Druckmaschinen AG, all rights reserved.

*/

#ifndef LHGeneralIncs_h
#include "General.h"
#endif

#ifndef LHGenLuts_h
#include "GenLuts.h"
#endif

#ifndef PI_CMMInitialization_h
#include "PI_CMM.h"
#endif

#ifndef LHStdConversionLuts_h
#include "StdConv.h"
#endif

#if ! realThing
#ifdef DEBUG_OUTPUT
#define kThisFile kCMMInitializationID
#define __TYPES__
/*#include "DebugSpecial.h"*/
/*#include "LH_Util.h"*/
#endif
#endif

#define ALLOW_DEVICE_LINK   /* allows link as the last profile in a chain, change in genluts.c too */
/* ______________________________________________________________________

CMError CMMInitPrivate( 	CMMModelPtr 		storage, 
						 	CMProfileRef 		srcProfile, 
						 	CMProfileRef 		dstProfile );

	Abstract:
		ColorWorld function called to initialize a matching session.

	Params:
		Storage		(in)		Reference to CMMModel.
		srcProfile	(in)		Reference to source CMProfileRef.
		dstProfile	(in)		Reference to destination CMProfileRef.
		
	Return:
		noErr		successful
		System or result code if an error occurs.

   _____________________________________________________________________ */

CMError CMMInitPrivate( 	CMMModelPtr 		storage, 
						 	CMProfileRef 		srcProfile, 
						 	CMProfileRef 		dstProfile )
{
    CMError					err = noErr;
    OSErr					aOSerr = noErr;
    CMConcatProfileSet 		*profileSet = nil;
    CMCoreProfileHeader		sourceHeader;
    CMCoreProfileHeader		destHeader;
    Boolean					valid;
    short					mode = 0;
#ifdef DEBUG_OUTPUT
    long					timer = TickCount();
#endif

#ifdef DEBUG_OUTPUT
    if ( DebugCheck(kThisFile, kDebugMiscInfo) )
        DebugPrint(" ->CMMInitPrivate\n");
#endif

    /*	--------------------------------------------------------------------------------------- valid profiles ???*/
    err = CMValidateProfile( srcProfile, &valid );
    if (err)
        goto CleanupAndExit;
    if (!valid)
    {
#ifdef DEBUG_OUTPUT
        if ( DebugCheck(kThisFile, kDebugErrorInfo) )
            DebugPrint(" CMMInitPrivate ERROR:  srcProfile is NOT valid!\n");
#endif
        
#ifdef realThing
        err = cmProfileError;
        goto CleanupAndExit;
#endif
    }

    err = CMValidateProfile(dstProfile, &valid );
    if (err)
        goto CleanupAndExit;
    if (!valid)
    {
#ifdef DEBUG_OUTPUT
        if ( DebugCheck(kThisFile, kDebugErrorInfo) )
            DebugPrint(" CMMInitPrivate ERROR:  dstProfile is NOT valid!\n");
#endif
#ifdef realThing
        err = cmProfileError;
        goto CleanupAndExit;
#endif
    }
    
    /*	--------------------------------------------------------------------------------------- initialization*/
	(storage)->lutParam.inputLut  = DISPOSE_IF_DATA((storage)->lutParam.inputLut);
	(storage)->lutParam.colorLut  = DISPOSE_IF_DATA((storage)->lutParam.colorLut);
	(storage)->lutParam.outputLut = DISPOSE_IF_DATA((storage)->lutParam.outputLut);
	
	(storage)->gamutLutParam.inputLut  = DISPOSE_IF_DATA((storage)->gamutLutParam.inputLut);
	(storage)->gamutLutParam.colorLut  = DISPOSE_IF_DATA((storage)->gamutLutParam.colorLut);
	(storage)->gamutLutParam.outputLut = DISPOSE_IF_DATA((storage)->gamutLutParam.outputLut);

 	(storage)->theNamedColorTagData = DISPOSE_IF_DATA((storage)->theNamedColorTagData);
	
	(storage)->srcProfileVersion = icVersionNumber;
    (storage)->dstProfileVersion = icVersionNumber;

    /*	--------------------------------------------------------------------------------------- check version of source profile*/
    err = CMGetProfileHeader( srcProfile, &sourceHeader);
    if (err)
        goto CleanupAndExit;

    if ( !((sourceHeader.version & 0xff000000) >= icVersionNumber) ){
        err = cmProfileError;
        goto CleanupAndExit;
    }
	if (sourceHeader.deviceClass == icSigLinkClass)
	{
		err = cmCantConcatenateError;
		goto CleanupAndExit;
	}

    /*	--------------------------------------------------------------------------------------- check version of destination profile*/
    err = CMGetProfileHeader( dstProfile, &destHeader);
    if (err)
        goto CleanupAndExit;

    if ( !((destHeader.version & 0xff000000) >= icVersionNumber) ){
        err = cmProfileError;
        goto CleanupAndExit;
    }
  	if (destHeader.deviceClass == icSigLinkClass)
	{
		err = cmCantConcatenateError;
		goto CleanupAndExit;
	}
  	storage->lookup =  (Boolean)((sourceHeader.flags & kLookupOnlyMask)>>16);		/* lookup vs. interpolation */
  	
#ifdef RenderInt
	if( storage-> dwFlags != 0xffffffff ){
		storage->lookup = (Boolean)((storage-> dwFlags & kLookupOnlyMask)>>16);
	}
#endif
    /*	--------------------------------------------------------------------------------------- 'normal' cases*/
                profileSet = (CMConcatProfileSet *)SmartNewPtr(sizeof (CMConcatProfileSet) + sizeof(CMProfileRef), &aOSerr);
                if (aOSerr)
                    goto CleanupAndExit;
                    
                profileSet->count    = 2;
                profileSet->keyIndex = 1;
                /* profileSet->flags	 = sourceHeader.flags; */
                profileSet->profileSet[0] = srcProfile;
                /* profileSet->profileSet[0]->renderingIntent = sourceHeader.renderingIntent; */
                profileSet->profileSet[1] = dstProfile;
                /* profileSet->profileSet[1]->renderingIntent = destHeader.renderingIntent; */
                     
                err =  PrepareCombiLUTs( storage, profileSet );	
    if (err)
        goto CleanupAndExit;

CleanupAndExit:
    profileSet = (CMConcatProfileSet*)DisposeIfPtr( (Ptr)profileSet );

#ifdef DEBUG_OUTPUT
    if ( err && DebugCheck(kThisFile, kDebugErrorInfo) )
        DebugPrint(" CMMInitPrivate: err = %d\n", err);
    if ( DebugCheck(kThisFile, kDebugTimingInfo) )
        DebugPrint("  time in CMMInitPrivate: %f second(s)\n",(TickCount()-timer)/60.0);
    if ( DebugCheck(kThisFile, kDebugMiscInfo) )
        DebugPrint(" <-CMMInitPrivate\n");
#endif
	return err;
} 

CMError MakeSessionFromLink(		CMMModelPtr 		storage, 
						  			CMConcatProfileSet 	*profileSet	);

#ifndef HD_NEW_CONCATE_INIT
CMError CMMConcatInitPrivate	( 	CMMModelPtr 		storage, 
						  			CMConcatProfileSet 	*profileSet)
{
	CMCoreProfileHeader	firstHeader;
	CMCoreProfileHeader	lastHeader;
	CMCoreProfileHeader	tempHeader;
	CMError					err = noErr;
	unsigned short			count;
	unsigned short			loop;
	Boolean					valid;
	CMProfileRef			theProfile;
	#ifdef DEBUG_OUTPUT
	long					timer = TickCount();
	#endif
	

	#ifdef DEBUG_OUTPUT
	if ( DebugCheck(kThisFile, kDebugMiscInfo) )
	{
		DebugPrint(" ->CMMConcatInitPrivate\n");
		DebugPrint("  got %d profiles      keyindex is %d \n", profileSet->count, profileSet->keyIndex);
	}
	#endif
	
	count = profileSet->count;
	if (count == 0)
	{
		err = cmparamErr;
		goto CleanupAndExit;
	}
	/* ------------------------------------------------------------------------------------------ get first header	*/
	err = CMGetProfileHeader( profileSet->profileSet[0], &firstHeader);
	if (err)
		goto CleanupAndExit;
	/* ------------------------------------------------------------------------------------------ only one profile? -> has to be a link profile	*/
  	storage->lookup =  (Boolean)((firstHeader.flags & kLookupOnlyMask)>>16);		/* lookup vs. interpolation */
  	
#ifdef RenderInt
	if( storage-> dwFlags != 0xffffffff ){
		storage->lookup = (Boolean)((storage-> dwFlags & kLookupOnlyMask)>>16);
	}
#endif
	if (count == 1 && firstHeader.deviceClass != icSigNamedColorClass )
	{
		if (firstHeader.deviceClass != icSigLinkClass && firstHeader.deviceClass != icSigAbstractClass )
		{
			err =cmCantConcatenateError;
			goto CleanupAndExit;
		}
		else{
			err = MakeSessionFromLink( storage, profileSet	);
			if( err == 0 )return noErr;
		}
		lastHeader = firstHeader;
	} else
	{
		/* -------------------------------------------------------------------------------------- get last header	*/
		err = CMGetProfileHeader( profileSet->profileSet[count-1], &lastHeader);
		if (err)
			goto CleanupAndExit;
#ifndef ALLOW_DEVICE_LINK
		if (lastHeader.deviceClass == icSigLinkClass)
		{
			err = cmCantConcatenateError;
			goto CleanupAndExit;
		}
#endif
	}
	
	/* ------------------------------------------------------------------------------------------ valid profiles ???	*/
	for ( loop = 0; loop < count; loop++)
	{
		theProfile = profileSet->profileSet[loop];
		err = CMValidateProfile( theProfile, &valid );
		if (err)
			goto CleanupAndExit;
		if (!valid)
		{
		 	#ifdef DEBUG_OUTPUT
			if ( DebugCheck(kThisFile, kDebugErrorInfo) )
				DebugPrint(" CMMConcatInitPrivate ERROR: profile #%d is NOT valid!\n", loop);
			#endif
			#ifdef realThing
			err = cmProfileError;
			goto CleanupAndExit;
			#endif
		}
		/* -------------------------------------------------------------------------------------- link profiles may not be used inbetween	*/
		if ( (loop > 0) && (loop < count-1))
		{
			err = CMGetProfileHeader( profileSet->profileSet[loop], &tempHeader);
			if (err)
				goto CleanupAndExit;
			if (tempHeader.deviceClass == icSigLinkClass)
			{
				err = cmCantConcatenateError;
				goto CleanupAndExit;
			}
		}
	}
	
	/* ------------------------------------------------------------------------------------------ no abstract profile as first or last	*/
	if ( (count >1) && ( (firstHeader.deviceClass == icSigAbstractClass) || (lastHeader.deviceClass == icSigAbstractClass) ) )
	{
		err = cmCantConcatenateError;
		goto CleanupAndExit;
	}
	
	/* ------------------------------------------------------------------------------------------ initialization	*/
	(storage)->lutParam.inputLut  = DISPOSE_IF_DATA((storage)->lutParam.inputLut);
	(storage)->lutParam.colorLut  = DISPOSE_IF_DATA((storage)->lutParam.colorLut);
	(storage)->lutParam.outputLut = DISPOSE_IF_DATA((storage)->lutParam.outputLut);
	
	(storage)->gamutLutParam.inputLut  = DISPOSE_IF_DATA((storage)->gamutLutParam.inputLut);
	(storage)->gamutLutParam.colorLut  = DISPOSE_IF_DATA((storage)->gamutLutParam.colorLut);
	(storage)->gamutLutParam.outputLut = DISPOSE_IF_DATA((storage)->gamutLutParam.outputLut);

	(storage)->theNamedColorTagData = DISPOSE_IF_DATA((storage)->theNamedColorTagData);
	/* ------------------------------------------------------------------------------------------ check 'special' cases	*/
	{
		err =  PrepareCombiLUTs( storage, profileSet );	
	}

CleanupAndExit:

	#ifdef DEBUG_OUTPUT
	if ( err && DebugCheck(kThisFile, kDebugErrorInfo) )
		DebugPrint("  CMMConcatInitPrivate: err = %d\n", err);
	DebugPrint("  time in CMMConcatInitPrivate: %f second(s)\n",(TickCount()-timer)/60.0);
	DebugPrint(" <-CMMConcatInitPrivate\n");
	#endif
	return( err );
} 

Boolean IsPowerOf2( unsigned long l );
Boolean IsPowerOf2( unsigned long l )
{
	unsigned long i;
	for( i=1; i<32; i++){
		if( (1U<<i) == l ) return 1;
	}
	return 0;
}

#endif
CMError MakeSessionFromLink(		CMMModelPtr 		storage, 
						  			CMConcatProfileSet 	*profileSet	)
{
	CMLutParam	theLut={0};	
	CMLutParam	*theLutData;	
	LHCombiData	theCombi={0};
	LHCombiData	*theCombiData;
	double		*aDoublePtr;
	double		aDouble;
	OSType		theTag = icSigAToB0Tag;

  	CMError		err = noErr;
  	OSErr		aOSerr = noErr;
	Ptr			profileLutPtr = nil;
	UINT32		elementSize;
	double		factor;
	UINT32 		byteCount;
    CMCoreProfileHeader		aHeader;

	LH_START_PROC("MakeSessionFromLink")


	theLutData = &theLut;
	theCombiData = &theCombi;
 	theCombiData->theProfile = profileSet->profileSet[0];

	/* -------------------------------------------------------- get partial tag data from profile */
	err = CMGetProfileElement(theCombiData->theProfile, theTag, &elementSize, nil);
	if (err)
		goto CleanupAndExit;
	
	byteCount = 52;											/* get the first 52 bytes out of the profile */
  	profileLutPtr = SmartNewPtr(byteCount, &aOSerr);
	err = aOSerr;
	if (err)
		goto CleanupAndExit;
	
    err = CMGetProfileElement( theCombiData->theProfile, theTag, &byteCount, profileLutPtr );
	if (err)
		goto CleanupAndExit;
#ifdef IntelMode
    SwapLongOffset( &((icLut16Type*)profileLutPtr)->base.sig, 0, 4 );
    SwapShortOffset( &((icLut16Type*)profileLutPtr)->lut.inputEnt, 0, 2 );
    SwapShortOffset( &((icLut16Type*)profileLutPtr)->lut.outputEnt, 0, 2 );
#endif

	theLutData->colorLutInDim 		= ((icLut8Type*)profileLutPtr)->lut.inputChan;
	theLutData->colorLutOutDim 		= ((icLut8Type*)profileLutPtr)->lut.outputChan;
	theLutData->colorLutGridPoints 	= ((icLut8Type*)profileLutPtr)->lut.clutPoints;

	switch( theLutData->colorLutInDim ){
	  case 3:
		if( theLutData->colorLutGridPoints != 16 && theLutData->colorLutGridPoints != 32 ){
			err = 1;
			goto CleanupAndExit;
		}
		break;
	  case 4:
		if( theLutData->colorLutGridPoints != 8 && theLutData->colorLutGridPoints != 16 ){
			err = 1;
			goto CleanupAndExit;
		}
		break;
	}

	err = CMGetProfileHeader( profileSet->profileSet[0], &aHeader);
	if (err)
		goto CleanupAndExit;
	storage->firstColorSpace = aHeader.colorSpace;
	storage->lastColorSpace = aHeader.pcs;
    storage->srcProfileVersion = icVersionNumber;
    storage->dstProfileVersion = icVersionNumber;

	if (	( theLutData->colorLutInDim == 3) &&
			( aHeader.pcs == icSigXYZData ) )
	{
		factor = 1.;
		err = GetMatrixFromProfile(theLutData, theCombiData, theTag, factor);
		if( err ) goto CleanupAndExit;
		aDoublePtr = (double *)theLutData->matrixMFT;
		if( aDoublePtr != 0 ){
			aDouble = aDoublePtr[0] + aDoublePtr[4] + aDoublePtr[8];
			if( aDouble > 3.0 + 1E-6 || aDouble < 3.0 - 1E-6 ){
				err = 1;
				goto CleanupAndExit;
			}
		}
	}
	theCombiData->maxProfileCount = 0;
	if( ((icLut16Type*)profileLutPtr)->base.sig == icSigLut16Type ){
		theCombiData->doCreate_16bit_Combi = 1;
		theCombiData->doCreate_16bit_ELut = 0;
		theCombiData->doCreate_16bit_XLut = 1;
		theCombiData->doCreate_16bit_ALut = 0;
	}
	else{
		theCombiData->doCreate_16bit_Combi = 0;
		theCombiData->doCreate_16bit_ELut = 0;
		theCombiData->doCreate_16bit_XLut = 0;
		theCombiData->doCreate_16bit_ALut = 0;
	}

	/* ---------------------------------------------------------------------- process A Lut */
	err = Extract_MFT_Alut( theLutData, theCombiData, profileLutPtr, theTag );
	if (err)
		goto CleanupAndExit;

	/* ---------------------------------------------------------------------- process X Lut */
	err = Extract_MFT_Xlut ( theLutData, theCombiData, profileLutPtr, theTag );
	if (err)
		goto CleanupAndExit;
	
	/* ---------------------------------------------------------------------- process E Lut */
	err = Extract_MFT_Elut( theLutData, theCombiData, profileLutPtr, theTag );
	if (err)
		goto CleanupAndExit;

	storage->lutParam = *theLutData;

	/* ---------------------------------------------------------------------------------
		 clean up
	   ---------------------------------------------------------------------------------*/
CleanupAndExit:
	profileLutPtr = DisposeIfPtr(profileLutPtr);
	LH_END_PROC("MakeSessionFromLink")
	return err;
}
#if 0
#define	POS(x)	((x) > (0) ? (x) : -(x))
CMError QuantizeNamedValues( CMMModelPtr 		storage,
							 Ptr				imgIn,
							 long				size )
{
	long	j,k;
	UINT16	*imgInPtr;
	UINT16	*tagTbl = NULL,*colorPtr = NULL;
	Handle	tagH = NULL;
	CMError	err = noErr;
	long	elemSz,deviceChannelCount,count;
	UINT16	LL,aa,bb;
	UINT32	dE,dEnow,index;

	LH_START_PROC("QuantizeNamedValues")
	tagH = storage->theNamedColorTagData;
	if (tagH==NULL) 
	{
		err = cmparamErr;
		goto CleanUp;
	}
	LOCK_DATA(tagH);
	
	/* tagTbl should now point to beginning of first device data */
	/* = CMNamedColor2Type_header(84) + firstName(32) + PCSSize(3*2) */
	tagTbl = (UINT16 *)DATA_2_PTR(tagH) + 61;
	
	/* find out how many bytes to skip per element. div'ed 2 for indexing purpose */
	count = ((icNamedColor2Type *)DATA_2_PTR(tagH))->ncolor.count;
	deviceChannelCount = ((icNamedColor2Type *)DATA_2_PTR(tagH))->ncolor.nDeviceCoords;
	if (deviceChannelCount==3) 
	{
		elemSz = 32+(3+3)*sizeof(SINT16);
	} else if (deviceChannelCount == 4) 
	{
		elemSz = 32+(3+4)*sizeof(SINT16);
	} else if (deviceChannelCount == 0) 
	{
		elemSz = 32+(3+0)*sizeof(SINT16);
	} else 
	{
		err = cmparamErr;
		goto CleanUp;
	}
	elemSz/=2;

	imgInPtr = (UINT16 *)  imgIn;
 	for (j = 0; j < size; j++) 
	{
		LL = (*imgInPtr+0);
		aa = (*imgInPtr+1);
		bb = (*imgInPtr+2);
		/* go through the whole table to find the closest one*/
		dEnow = 0x40000;	/* just arbitrarily high = 256*256*4 */
		index =(UINT32)-1;
		colorPtr = tagTbl;
		for (k = 0; k < count; k++) 
		{
			dE = 	  POS(LL - *(colorPtr+0));
			dE = dE + POS(aa - *(colorPtr+1));
			dE = dE + POS(bb - *(colorPtr+2));
			if (dE < dEnow) 
			{
				index = k;
				dEnow = dE;
			}
			colorPtr += elemSz;
		}
		colorPtr = tagTbl + index * elemSz;
		*(imgInPtr+0)= *(colorPtr+0);
		*(imgInPtr+1)= *(colorPtr+1);
		*(imgInPtr+2)= *(colorPtr+2);
		imgInPtr += 3;
	}
		UNLOCK_DATA(tagH);
CleanUp:
	LH_END_PROC("QuantizeNamedValues")
	return err;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\mscmm.w98\mscmm\access.c ===
/*
	File:		MSICMProfileAccess.c

	Contains:	

	Written by:	U. J. Krabbenhoeft

	Copyright:	 1993-1997 by Heidelberger Druckmaschinen AG, all rights reserved.

	Version:	
*/
#include "Windef.h"
#include "WinGdi.h"
#include <wtypes.h>
#include "ICM.h"
#include "General.h"
/* --------------------------------------------------------------------------

CMError CMGetProfileHeader(	CMProfileRef			prof,
							CMCoreProfileHeader*	header );

	Abstract:

	Params:
		
	Return:
		noErr		successful

   -------------------------------------------------------------------------- */
CMError CMGetProfileHeader(	CMProfileRef			prof,
							CMCoreProfileHeader*	header )
{
	BOOL bool;
	CMError ret = badProfileError;

	bool = GetColorProfileHeader( (HPROFILE)prof, (PPROFILEHEADER) header );
	if (header->magic == icMagicNumber && bool )
		ret = noErr;
	
	return (ret);
}


/* --------------------------------------------------------------------------

CMError CMGetProfileElement(	CMProfileRef 		prof,
								OSType 				tag,
								unsigned long*		elementSize,
								void* 				elementData );

	Abstract:
		This function gives an pointer to the requested tag back
	Params:
		
	Return:
		noErr		successful

   -------------------------------------------------------------------------- */
CMError CMGetProfileElement(	CMProfileRef 		prof,
								OSType 				tag,
								unsigned long*		elementSize,
								void* 				elementData )
{
	return (CMGetPartialProfileElement(prof, tag, 0, elementSize, elementData));
}


/* --------------------------------------------------------------------------

	CMError CMGetPartialProfileElement(	CMProfileRef 		prof,
										OSType 				tag,
										unsigned long		offset,
										unsigned long		*byteCount,
										void				*elementData )

	Abstract:
		Core likes small amounts of memory we too but this is ascetic.
	Params:
		
	Return:
		noErr		successful

   -------------------------------------------------------------------------- */

CMError CMGetPartialProfileElement(	CMProfileRef 		prof,
									OSType 				tag,
									unsigned long		offset,
									unsigned long		*byteCount,
									void				*elementData )
{
	BOOL bool;
	BOOL ret;

	if (!byteCount)
	{
		return -1;
	}
	SetLastError(0);
	/*ret = IsColorProfileTagPresent( (HPROFILE)prof, (TAGTYPE)tag, &bool );*/
	if( elementData == 0 ) *byteCount = 0;
	ret = GetColorProfileElement( (HPROFILE)prof, (TAGTYPE)tag, offset, byteCount, elementData, &bool );
	if( ret )		return (noErr);
	/*					GetColorProfileElement returns FALSE for calls with elementData = 0
						but byteCount is set correctly */		
	else if( elementData == 0 && GetLastError() == ERROR_INSUFFICIENT_BUFFER )	return (noErr);
	
	return (cmElementTagNotFound);
}

/* --------------------------------------------------------------------------

Boolean CMProfileElementExists(		CMProfileRef 	prof,
									OSType 			tag );

	Abstract:

	Params:
		
	Return:
		noErr		successful

   -------------------------------------------------------------------------- */
Boolean CMProfileElementExists(		CMProfileRef 	prof,
									OSType 			tag )
{
	BOOL bool;
	IsColorProfileTagPresent( (HPROFILE)prof, (TAGTYPE)tag, &bool );
	return (BOOLEAN)bool;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\mscmm.w98\mscmm\icm32.c ===
/*
	File:		MsLinoCMM.c

	Contains:
		Interface to MS ICM
	Written by:	U. J. Krabbenhoeft

	Copyright:	 1993-1997 by Heidelberger Druckmaschinen AG, all rights reserved.

	Version:	
*/

#include "Windef.h"
#include "WinGdi.h"
#include <wtypes.h>
#include <winbase.h>
#include <WindowsX.h>
#include "ICM.h"

#ifndef LHGeneralIncs_h
#include "General.h"
#endif

#ifndef MSNewMemProfile_h
#include "MemProf.h"
#endif

#define CMM_WIN_VERSION		0
#define CMM_IDENT			1
#define CMM_DRIVER_LEVEL	2
#define CMM_DLL_VERSION		3
#define CMM_VERSION			4
#define CMS_LEVEL_1			1

typedef HANDLE  HCMTRANSFORM;
typedef LPVOID  LPDEVCHARACTER;
typedef LPVOID  LPHPROFILE;
typedef LPVOID  LPARGBQUAD;
typedef COLORREF FAR *LPCOLORREF;

#ifdef _DEBUG
//#define WRITE_PROFILE
#endif
/* ______________________________________________________________________
			static section for holding the CW pointers
   _____________________________________________________________________ */

long IndexTransform=0;
HCMTRANSFORM TheTransform[1000] = {0};

CRITICAL_SECTION GlobalCriticalSection;		/* for multithreaded dll */

/* ______________________________________________________________________ */

/* ______________________________________________________________________

BOOL WINAPI DllMain (	HINSTANCE hinstDLL,
						DWORD fdwReason,
						LPVOID lpvReserved )

        Abstract:
                DLL Entrypoint

        Params:
                standard

        Return:
                TRUE

   _____________________________________________________________________ */
BOOL WINAPI DllMain (	HINSTANCE hinstDLL,
						DWORD fdwReason,
						LPVOID lpvReserved )
{
switch (fdwReason)
   {
   case DLL_PROCESS_ATTACH:
      DisableThreadLibraryCalls(hinstDLL);
	  InitializeCriticalSection(&GlobalCriticalSection);
      break;
   case DLL_PROCESS_DETACH:
      DeleteCriticalSection(&GlobalCriticalSection);
      break;
   }
return TRUE;
}

#define DllExport	__declspec( dllexport )

HCMTRANSFORM  WINAPI CMCreateMultiProfileTransform(	LPHPROFILE	lpahProfiles,
													DWORD 		nProfiles,
													UINT32		*aIntentArr,
													UINT32		nIntents,
													UINT32		dwFlags );
long FillProfileFromLog(	LPLOGCOLORSPACEA	lpColorSpace,
							PPROFILE			theProf );
long FillProfileFromLogW(	LPLOGCOLORSPACEW	lpColorSpace,
							PPROFILE			theProf );
BOOL  WINAPI CMCreateProfile(	LPLOGCOLORSPACEA	lpColorSpace,
								LPBYTE 				*lpProfileData );
CMWorldRef StoreTransform( CMWorldRef aRef );
CMBitmapColorSpace CMGetDataColorSpace( BMFORMAT c, long *pixelSize );
HCMTRANSFORM  WINAPI CMGetTransform( HCMTRANSFORM 	hcmTransform );
long  CMCreateMultiProfileTransformInternal(		CMWorldRef	*cw,
													LPHPROFILE	lpahProfiles,
													DWORD 		nProfiles,
													UINT32		*aIntentArr,
													UINT32		nIntents,
													UINT32		dwFlags,
													UINT32		dwCreateLink );
/* ______________________________________________________________________

DWORD WINAPI CMGetInfo( DWORD dwInfo );

Abstract:
	The CMGetInfo function retrieves various information about the ICM.

Parameter		Description
	
	dwInfo		Values that can have the following meaning:

	Type	Meaning
		
	CMS_VERSION	Retrieves the version of Windows supported.
	CMS_IDENT	Retrieves the identifier of the ICMDLL.
	CMS_DRIVER_LEVEL	Retrieves the support level of a device driver.

Returns
	CMGetInfo returns zero if an invalid parameter is passed in. If successful it returns a value that depends on the information requested.
	For CMS_VERSION CMGetInfo retrieves the version of Windows ICM interface supported by this module. For Windows 95 this should be 4.0, represented as 0x00040000.
	For CMS_IDENT CMGetInfo retrieves the identifier of the ICMDLL. This is the same as the ICC color profile header identifier.
	For CMS_DRIVER_LEVEL CMGetInfo retrieves the supported level of the device driver. ICMDLLs should return CMS_LEVEL_1. The values have been defined in a previous section.
   _____________________________________________________________________ */
DWORD WINAPI CMGetInfo( DWORD dwInfo )
{
	DWORD ret = 0;
	switch( dwInfo ){
	case CMM_VERSION:
		ret = 0x00050000;
		break;
	case CMM_WIN_VERSION:
		ret = 0x00040000;
		break;
	case CMM_DLL_VERSION:
		ret = 0x00010000;
		break;
	case CMM_IDENT:
		ret = 'Win ';
		break;
	case CMM_LOGOICON:
		ret = 100;
		break;
	case CMM_DESCRIPTION:
		ret = 100;
		break;
	case CMM_DRIVER_LEVEL:
		ret = CMS_LEVEL_1;
		break;
	default:
		ret = 0;
		break;
	}
	return 	ret;
}


long CMCreateTransformExtInternal(	CMWorldRef	*cwOut,
									UINT32		dwFlags,
									UINT32		lcsIntent,
									HPROFILE	aProf,
									LPBYTE		ptDeRef,
									LPBYTE		pdDeRef )
{
	CMWorldRef cw=0;
	CMWorldRef cw2=0;
	long err;
	HPROFILE saveProf;
	HPROFILE hArray[3];
	UINT32 aIntent[3];
	UINT32 aUINT32,count;
	CMMModelPtr theModelPtr;

	*cwOut = 0;
	aIntent[0] = icRelativeColorimetric;
	switch( lcsIntent ){
	  case LCS_GM_BUSINESS:
		aIntent[1] = icSaturation;
		break;
	  case LCS_GM_GRAPHICS:
		aIntent[1] = icRelativeColorimetric;
		break;
	  case LCS_GM_ABS_COLORIMETRIC:
		aIntent[1] = icAbsoluteColorimetric;
		break;
	  default:
		aIntent[1] = icPerceptual;
		break;
	}
	if( ptDeRef == 0 ){
		count = 2;
		hArray[0] =  aProf;
		hArray[1] =  pdDeRef;
	}
	else{
		count = 3;
		hArray[0] =  aProf;
		hArray[1] =  ptDeRef;
		hArray[2] =  pdDeRef;
		if( dwFlags & USE_RELATIVE_COLORIMETRIC )aIntent[2] = INTENT_RELATIVE_COLORIMETRIC;
		else aIntent[2] = INTENT_ABSOLUTE_COLORIMETRIC;
	}

	err = CMCreateMultiProfileTransformInternal( &cw, hArray, count, aIntent, count, dwFlags, 0 );
	if( err ){
		goto CleanupAndExit;
	}
	if( dwFlags & 0x80000000 ){				/* this is for the backward transform */
		count--;
		saveProf = hArray[count];
		hArray[count] =  hArray[0];
		hArray[0] =  saveProf;
		aUINT32 = aIntent[count];
		aIntent[count] = aIntent[0];
		aIntent[0] = aUINT32;

		count++;
		err = CMCreateMultiProfileTransformInternal( &cw2, hArray, count, aIntent, count, dwFlags, 0 );
		if( err ){
			CWDisposeColorWorld( cw );	/* delete other cw */
			goto CleanupAndExit;
		}
		LOCK_DATA( cw );
		theModelPtr = (CMMModelPtr)(DATA_2_PTR( cw ));
		theModelPtr->pBackwardTransform = cw2;
		UNLOCK_DATA( aTrans );
	}

CleanupAndExit:
	CloseColorProfile( aProf );
	if( err ){
		SetLastError( err );
		cw = (CMWorldRef)(ULONG_PTR)(err & 255);
	}
	else{
		cw = StoreTransform( cw );
	}
	*cwOut = cw;
	return 0;
}
/* ______________________________________________________________________

HCMTRANSFORM  WINAPI CMCreateTransformExt(	LPLOGCOLORSPACEA	lpColorSpace,
											LPDEVCHARACTER		lpDevCharacter,
											LPDEVCHARACTER		lpTargetDevCharacter,
											UINT32				dwFlags );

Abstract:
	The CMCreateTransformExt function creates a color transform that
	maps from an input LogColorSpace to an optional target to an
	output device.

Parameter					Description
	lpColorSpace			Pointer to input color space. If lcsFilename is non-zero,
							it is a pointer to the memory mapped profile.
	LpDevCharacter			Pointer to memory mapped device profile
	lpTargetDevCharacter	Pointer to memory mapped target profile
	dwFlags					Specifies flags to control creation of the transform.
							It is up to the CMM to determine how best to use these flags.
							Set the high-order word to ENABLE_GAMUT_CHECKING if the transform
							will be used for gamut checking.
							The low-order WORD can have one of the following constant values:
							PROOF_MODE, NORMAL_MODE, BEST_MODE.
							Moving from PROOF_MODE to BEST_MODE, output quality generally improves and transform speed declines.

Returns
	If the function is successful, it returns a color transform
	in the range 256 to 65535. Otherwise it returns an error code
	(return value < 255).

  _____________________________________________________________________ */
void WriteProf( LPSTR name, icProfile *theProf, long currentSize );
HCMTRANSFORM  WINAPI CMCreateTransformExt(	LPLOGCOLORSPACEA	lpColorSpace,
											LPDEVCHARACTER		lpDevCharacter,
											LPDEVCHARACTER		lpTargetDevCharacter,
											UINT32				dwFlags )
{
	CMWorldRef cw=0;
	long err;
	LPBYTE pt,pd, ptDeRef, pdDeRef;
	HPROFILE aProf;
	PROFILE theProf;
    BOOL   bWin95;
    OSVERSIONINFO osvi;

#if 0				/* Test for CMCreateProfile */
	CMCreateProfile( lpColorSpace, &pt );
	err = *(long *)pt;
	SwapLong(&err);
	WriteProf( "CMCreateProfile.icc", (icProfile *)pt, err );
	GlobalFreePtr( pt );
#endif


	err = FillProfileFromLog( lpColorSpace, &theProf );
	if( err ){
		SetLastError( err );
		goto CleanupAndExit;
	}
	aProf = OpenColorProfile(&theProf, PROFILE_READ, FILE_SHARE_READ, OPEN_EXISTING );
	if( !aProf ){
		err = GetLastError();
		goto CleanupAndExit;
	}
    osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    GetVersionEx(&osvi);
    bWin95 = osvi.dwMajorVersion == 4 &&
             osvi.dwMinorVersion == 0 &&
             osvi.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS;

    if (bWin95)
    {
        PROFILE myProf;
        DWORD   l;

        //
        // Handles are not provided below LCS structure, so create handles
        //

        myProf.dwType = PROFILE_MEMBUFFER;
        myProf.pProfileData = lpDevCharacter;
        l = *(DWORD *)(myProf.pProfileData);
        myProf.cbDataSize = SwapLong(&l);
        pdDeRef = OpenColorProfile(&myProf, PROFILE_READ, FILE_SHARE_READ, OPEN_EXISTING );
        if( !pdDeRef ){
                err = GetLastError();
                goto CleanupAndExit;
        }

        ptDeRef = 0;
        if (lpTargetDevCharacter)
        {
            myProf.dwType = PROFILE_MEMBUFFER;
            myProf.pProfileData = lpTargetDevCharacter;
            l = *(DWORD *)(myProf.pProfileData);
            myProf.cbDataSize = SwapLong(&l);
            ptDeRef = OpenColorProfile(&myProf, PROFILE_READ, FILE_SHARE_READ, OPEN_EXISTING );
            if( !ptDeRef ){
                    err = GetLastError();
                    goto CleanupAndExit;
            }
        }
    }
    else
    {
		pd = ((LPBYTE)lpColorSpace+sizeof(LOGCOLORSPACEA));
		pdDeRef= (LPBYTE)*(PULONG_PTR)pd;

		pt = ((LPBYTE)lpColorSpace+sizeof(LOGCOLORSPACEA)+sizeof(HPROFILE));
		ptDeRef= (LPBYTE)*(PULONG_PTR)pt;
	}

	err = CMCreateTransformExtInternal(	&cw, dwFlags,
				lpColorSpace->lcsIntent, aProf, ptDeRef, pdDeRef );

CleanupAndExit:
	if( lpColorSpace->lcsFilename[0] == 0 ){
		if( theProf.pProfileData )GlobalFreePtr( theProf.pProfileData );
		theProf.pProfileData = 0;
	}
    if (bWin95)
    {
        if (pdDeRef)
        {
            CloseColorProfile(pdDeRef);
        }
        if (ptDeRef)
        {
            CloseColorProfile(ptDeRef);
        }
    }
	if( err ){
		return (HCMTRANSFORM)(ULONG_PTR)(err & 255);
	}
	return (HCMTRANSFORM)cw;
}

/* ______________________________________________________________________

HCMTRANSFORM  WINAPI CMCreateTransform(		LPLOGCOLORSPACEA	lpColorSpace,
											LPDEVCHARACTER		lpDevCharacter,
											LPDEVCHARACTER 		lpTargetDevCharacter );

Abstract:
	The CMCreateTransform function creates a color transform that
	maps from an input LogColorSpace to an optional target to an
	output device.

Parameter					Description
	lpColorSpace			Pointer to input color space. If lcsFilename is non-zero,
							it is a pointer to the memory mapped profile.
	LpDevCharacter			Pointer to memory mapped device profile
	lpTargetDevCharacter	Pointer to memory mapped target profile

Returns
	If the function is successful, it returns a color transform
	in the range 256 to 65535. Otherwise it returns an error code
	(return value < 255).

  _____________________________________________________________________ */
HCMTRANSFORM  WINAPI CMCreateTransform	(	LPLOGCOLORSPACEA	lpColorSpace,
											LPDEVCHARACTER		lpDevCharacter,
											LPDEVCHARACTER 		lpTargetDevCharacter )
{
	return CMCreateTransformExt( lpColorSpace, lpDevCharacter, lpTargetDevCharacter, PROOF_MODE | ENABLE_GAMUT_CHECKING | 0x80000000 );
}
/* ______________________________________________________________________

HCMTRANSFORM  WINAPI CMCreateTransformExtW(	LPLOGCOLORSPACEW	lpColorSpace,
											LPDEVCHARACTER		lpDevCharacter,
											LPDEVCHARACTER 		lpTargetDevCharacter,
											UINT32				dwFlags );

Abstract:
	The CMCreateTransformExtW function creates a color transform that
	maps from an input LogColorSpace to an optional target to an
	output device.

Parameter					Description
	lpColorSpace			Pointer to input color space. If lcsFilename is non-zero, it is a pointer to the memory mapped profile.
	LpDevCharacter			Pointer to memory mapped device profile
	lpTargetDevCharacter	Pointer to memory mapped target profile
	dwFlags					Specifies flags to control creation of the transform.
							It is up to the CMM to determine how best to use these flags.
							Set the high-order word to ENABLE_GAMUT_CHECKING if the transform
							will be used for gamut checking.
							The low-order WORD can have one of the following constant values:
							PROOF_MODE, NORMAL_MODE, BEST_MODE.
							Moving from PROOF_MODE to BEST_MODE, output quality generally improves and transform speed declines.

Returns
	If the function is successful, it returns a color transform
	in the range 256 to 65535. Otherwise it returns an error code
	(return value < 255).

   _____________________________________________________________________ */
HCMTRANSFORM  WINAPI CMCreateTransformExtW(	LPLOGCOLORSPACEW 	lpColorSpace,
											LPDEVCHARACTER		lpDevCharacter,
											LPDEVCHARACTER 		lpTargetDevCharacter,
											UINT32				dwFlags )
{
	CMWorldRef cw=0;
	long err;
	LPBYTE pt,pd, ptDeRef, pdDeRef;
	HPROFILE aProf;
	PROFILE theProf;

	err = FillProfileFromLogW( lpColorSpace, &theProf );
	if( err ){
		SetLastError( err );
		goto CleanupAndExit;
	}
	aProf = OpenColorProfileW(&theProf, PROFILE_READ, FILE_SHARE_READ, OPEN_EXISTING );
	if( !aProf ){
		err = GetLastError();
		goto CleanupAndExit;
	}
	pd = ((LPBYTE)lpColorSpace+sizeof(LOGCOLORSPACEW));
	pdDeRef= (LPBYTE)*(PULONG_PTR)pd;

	pt = ((LPBYTE)lpColorSpace+sizeof(LOGCOLORSPACEW)+sizeof(HPROFILE));
	ptDeRef= (LPBYTE)*(PULONG_PTR)pt;

	err = CMCreateTransformExtInternal(	&cw, dwFlags,
				lpColorSpace->lcsIntent, aProf, ptDeRef, pdDeRef );

CleanupAndExit:
	if( lpColorSpace->lcsFilename[0] == 0 ){
		if( theProf.pProfileData )GlobalFreePtr( theProf.pProfileData );
		theProf.pProfileData = 0;
	}
	if( err ){
		return (HCMTRANSFORM)(ULONG_PTR)(err & 255);
	}
	return (HCMTRANSFORM)cw;
}

/* ______________________________________________________________________

HCMTRANSFORM  WINAPI CMCreateTransformW(	LPLOGCOLORSPACEW	lpColorSpace,
											LPDEVCHARACTER		lpDevCharacter,
											LPDEVCHARACTER 		lpTargetDevCharacter );

Abstract:
	The CMCreateTransformW function creates a color transform that
	maps from an input LogColorSpace to an optional target to an
	output device.

Parameter					Description
	lpColorSpace			Pointer to input color space. If lcsFilename is non-zero, it is a pointer to the memory mapped profile.
	LpDevCharacter			Pointer to memory mapped device profile
	lpTargetDevCharacter	Pointer to memory mapped target profile

Returns
	If the function is successful, it returns a color transform
	in the range 256 to 65535. Otherwise it returns an error code
	(return value < 255).

   _____________________________________________________________________ */
HCMTRANSFORM  WINAPI CMCreateTransformW(	LPLOGCOLORSPACEW 	lpColorSpace,
											LPDEVCHARACTER		lpDevCharacter,
											LPDEVCHARACTER 		lpTargetDevCharacter )
{
	return CMCreateTransformExtW( lpColorSpace, lpDevCharacter, lpTargetDevCharacter, PROOF_MODE | ENABLE_GAMUT_CHECKING );
}

long  CMCreateMultiProfileTransformInternal(		CMWorldRef	*cw,
													LPHPROFILE	lpahProfiles,
													DWORD 		nProfiles,
													UINT32		*aIntentArr,
													UINT32		nIntents,
													UINT32		dwFlags,
													UINT32		dwCreateLink )
{
	CMConcatProfileSet	*profileSet;
	OSErr				aOSErr;
	DWORD				i;
	long				err;
	UINT32				theFlags;
	UINT32				*arrIntents = 0;;

	profileSet = (CMConcatProfileSet *)SmartNewPtrClear( sizeof (CMConcatProfileSet) + (nProfiles)* sizeof(CMProfileRef), &aOSErr );
	if (aOSErr == 0 )
	{
		profileSet->keyIndex = 0;
		profileSet->count = (unsigned short)nProfiles;
		for( i=0; i<nProfiles; i++)
			profileSet->profileSet[i] = (CMProfileRef)((DWORD *)(((PVOID *)lpahProfiles)[i]));
	}
	else return ERROR_NOT_ENOUGH_MEMORY;

	switch( dwFlags & 0xffff ){
		case BEST_MODE:
			theFlags = cmBestMode;
			break;
		case PROOF_MODE:
			theFlags = cmDraftMode;
			break;
		default:
			theFlags = cmNormalMode;
			break;
	}
	if( ! (dwFlags & ENABLE_GAMUT_CHECKING) ){
		theFlags |= kCreateGamutLutMask;
	}
	if( dwFlags & USE_RELATIVE_COLORIMETRIC ){
		theFlags |= kUseRelColorimetric;
	}
	if( dwFlags & FAST_TRANSLATE ){
		theFlags |= kLookupOnlyMask;
	}
	if( nProfiles > 1 && nIntents == 1 ){
		arrIntents = (UINT32 *)SmartNewPtrClear( nProfiles * sizeof (UINT32), &aOSErr);
		if (aOSErr != 0 ){
			err = ERROR_NOT_ENOUGH_MEMORY;
			goto CleanupAndExit;
		}
		arrIntents[0] = icPerceptual;
		arrIntents[1] = aIntentArr[0];
		for( i=2; i<nProfiles; i++){
			arrIntents[i] = icAbsoluteColorimetric;
			if( dwFlags & kUseRelColorimetric ) arrIntents[i] = icRelativeColorimetric;
		}
		err = CWConcatColorWorld4MS( cw, profileSet, arrIntents, nProfiles, theFlags );
		arrIntents= (UINT32 *)DisposeIfPtr( (Ptr) arrIntents );
	}
	else{
		err = CWConcatColorWorld4MS( cw, profileSet, aIntentArr, nIntents, theFlags );
	}
#ifdef WRITE_PROFILE
	if( err == 0 ){
		err = MyNewDeviceLink( *cw, profileSet, "MyCreateTransform.pf" );
		//goto CleanupAndExit;
	}
#endif
CleanupAndExit:
	profileSet= (CMConcatProfileSet *)DisposeIfPtr( (Ptr) profileSet );
	return err;
}

/* ______________________________________________________________________

HCMTRANSFORM  WINAPI CMCreateMultiProfileTransform(	LPHPROFILE	lpahProfiles,
													DWORD 		nProfiles,
													UINT32		*aIntentArr,
													UINT32		nIntents,
													UINT32		dwFlags );

Abstract:
	The CMCreateMultiProfileTransform function accepts
	an array of profiles or a single device link profile
	and creates a color transform.
	This transform is a mapping from the color space specified
	by the first profile to that of the second profile
	and so on until the last one.

Parameter			Description
	lpahProfiles	Pointer to an array of profile handles
	nProfiles		Number of profiles in the array
	padwIntents		(in)		Points to an array of intent structures.
								0 = default behavior ( intents out of profiles )

	nIntents		(in)		Specifies the number of intents in the intent array.
								Can be 1, or the same value as nProfiles.

	dwFlags			(in)		Specifies flags to control creation of the transform.
								These flags are intended only as hints, and it is up to the CMM
								to determine how best to use these flags.
								Set the high-order word to ENABLE_GAMUT_CHECKING if the transform will be used
								for gamut checking.
								The low-order WORD can have one of the following constant values:
								PROOF_MODE, NORMAL_MODE, BEST_MODE. Moving from PROOF_MODE to BEST_MODE,
Returns
	If the function is successful, it returns a color transform.
	Otherwise it returns an error code (return value < 255).
   _____________________________________________________________________ */
HCMTRANSFORM  WINAPI CMCreateMultiProfileTransform(	LPHPROFILE	lpahProfiles,
													DWORD 		nProfiles,
													UINT32		*aIntentArr,
													UINT32		nIntents,
													UINT32		dwFlags )
{
	long				err;
	CMWorldRef			cw;

	err = CMCreateMultiProfileTransformInternal( &cw, lpahProfiles, nProfiles, aIntentArr, nIntents, dwFlags, 0 );
	if( err ){
		SetLastError( err );
		return (HCMTRANSFORM)(ULONG_PTR)(err & 255);
	}
	cw = StoreTransform( cw );
	return (HCMTRANSFORM)cw;
}

/* ______________________________________________________________________
BOOL  WINAPI CMDeleteTransform( HCMTRANSFORM 	hcmTransform );

Abstract:
	The CMDeleteTransform function deletes the given color transform,
	and frees any memory associated with it.

Parameter			Description
	hcmTransform	Identifies the color transform

Returns
	If the function is successful, the return value is nonzero.
	Otherwise it is zero.
   _____________________________________________________________________ */
BOOL  WINAPI CMDeleteTransform( HCMTRANSFORM 	hcmTransform )
{
	long actTransform = (long)(ULONG_PTR)hcmTransform - 256;
	HCMTRANSFORM aTrans;
	CMMModelPtr theModelPtr;
	CMWorldRef theWorldRef;

	__try {
		EnterCriticalSection(&GlobalCriticalSection);
		if( actTransform < IndexTransform && actTransform >= 0 ){
			aTrans = TheTransform[actTransform];
			TheTransform[ actTransform ] = 0;
			if( actTransform == IndexTransform-1 )IndexTransform--;
			return 1;
		}
		else return 0;
	}
	__finally{
		LeaveCriticalSection(&GlobalCriticalSection);
		
		LOCK_DATA( aTrans );
		theModelPtr = (CMMModelPtr)(DATA_2_PTR( aTrans ));
		theWorldRef = theModelPtr->pBackwardTransform;
		UNLOCK_DATA( aTrans );
		if( theWorldRef != 0 ){
			CWDisposeColorWorld( theWorldRef );
		}

		CWDisposeColorWorld( aTrans );
	}
}

/* ______________________________________________________________________
BOOL  WINAPI CMCreateProfile(	LPLOGCOLORSPACEA		lpColorSpace,
								LPBYTE 					*lpProfileData );

Abstract:
	The CMCreateProfile function creates a display color profile
	from a LogColorSpace structure.

Parameter			Description
	lpColorSpace	Pointer to color space. lcsFilename field will be NULL.
	pProfileData	Points to a pointer to a buffer.
					If successful the function allocates and fills this buffer.
					It is then the calling applications responsibility to
					free this buffer with GlobalFreePtr( lpProfileData )
					when it is no longer needed.

Returns
	If the function is successful, it returns nonzero.
	Otherwise it returns zero.

   _____________________________________________________________________ */
BOOL  WINAPI CMCreateProfile(	LPLOGCOLORSPACEA	lpColorSpace,
								LPBYTE 				*lpProfileData )
{
	CMWorldRef cw=0;
	long err;

	if( lpColorSpace->lcsFilename[0] ) return 0;
	err = MyNewAbstract( lpColorSpace, (icProfile **)lpProfileData );
	//err = FillProfileFromLog( lpColorSpace, &theProf );
	if( err ){
		SetLastError( err );
		goto CleanupAndExit;
	}
	return 1;
CleanupAndExit:
	return 0;
}

/* ______________________________________________________________________
BOOL  WINAPI CMCreateProfileW(	LPLOGCOLORSPACEW	lpColorSpace,
								LPBYTE 				*lpProfileData );

Abstract:
	The CMCreateProfileW function creates a display color profile
	from a LogColorSpace structure.

Parameter			Description
	lpColorSpace	Pointer to color space. lcsFilename field will be NULL.
	pProfileData	Points to a pointer to a buffer.
					If successful the function allocates and fills this buffer.
					It is then the calling applications responsibility to
					free this buffer with GlobalFreePtr( lpProfileData )
					when it is no longer needed.

Returns
	If the function is successful, it returns nonzero.
	Otherwise it returns zero.

   _____________________________________________________________________ */
BOOL  WINAPI CMCreateProfileW(	LPLOGCOLORSPACEW	lpColorSpace,
								LPBYTE 				*lpProfileData )
{
	CMWorldRef cw=0;
	long err;

	if( lpColorSpace->lcsFilename[0] ) return 0;
	err = MyNewAbstractW( lpColorSpace, (icProfile **)lpProfileData );
	//err = FillProfileFromLogW( lpColorSpace, &theProf );
	if( err ){
		SetLastError( err );
		goto CleanupAndExit;
	}
	return 1;
CleanupAndExit:
	return 0;
}

/* ______________________________________________________________________
BOOL  WINAPI CMCreateDeviceLinkProfile(		LPHPROFILE	lpahProfiles,
											DWORD 		nProfiles,
											UINT32		*aIntentArr,
											UINT32		nIntents,
											UINT32		dwFlags,
											LPBYTE		*lpProfileData );

Abstract:
	The CMCreateDeviceLinkProfile function creates a device link
	profile as specified by the "ICC Profile Format Specification."

Parameter			Description
	lpahProfiles	Pointer to an array of profile handles
	nProfiles		Number of profiles in the array
	padwIntents		Points to an array of rendering intents.
					Each rendering intent is represented by one of the following values:
						INTENT_PERCEPTUAL
						INTENT_SATURATION
						INTENT_RELATIVE_COLORIMETRIC
						INTENT_ABSOLUTE_COLORIMETRIC
					For more information, see Rendering Intents.

	nIntents		Specifies the number of intents in the intent array. Can be 1, or the same value as nProfiles.
	dwFlags			Specifies flags to control creation of the transform. These flags are intended only as hints,
					and it is up to the CMM to determine how best to use these flags.
					Set the high-order word to ENABLE_GAMUT_CHECKING if the transform will be used for gamut checking.
					The low-order WORD can have one of the following constant values:
						PROOF_MODE, NORMAL_MODE, BEST_MODE. Moving from PROOF_MODE to BEST_MODE,
						output quality generally improves.

	lpProfileData	Points to a pointer to a buffer.
					If successful the function allocates and fills this buffer.
					It is then the calling applications responsibility to
					free this buffer with GlobalFreePtr( lpProfileData )
					when it is no longer needed.

Returns
	If the function is successful, it returns nonzero.
	Otherwise it returns zero. SetLastError is used.

   _____________________________________________________________________ */

BOOL  WINAPI CMCreateDeviceLinkProfile(	LPHPROFILE	lpahProfiles,
										DWORD 		nProfiles,
										UINT32		*aIntentArr,
										UINT32		nIntents,
										UINT32		dwFlags,
										LPBYTE		*lpProfileData )
{
	long				err;
	OSErr				aOSErr;
	CMWorldRef			cw;
	CMConcatProfileSet	*profileSet;
	UINT32				i;

	*lpProfileData = 0;
	
	err = CMCreateMultiProfileTransformInternal( &cw, lpahProfiles, nProfiles, aIntentArr, nIntents, dwFlags, 0 );
	if( err ){
		SetLastError( err );
		return 0;
	}
	profileSet = (CMConcatProfileSet *)SmartNewPtrClear(sizeof (CMConcatProfileSet) + (nProfiles)* sizeof(CMProfileRef),&aOSErr);
	err = aOSErr;
	if (aOSErr == 0 )
	{
		profileSet->keyIndex = 0;
		profileSet->count = (unsigned short)nProfiles;
		for( i=0; i<nProfiles; i++)
			profileSet->profileSet[i] = (CMProfileRef)((DWORD *)(((PVOID *)lpahProfiles)[i]));
	}
	else goto CleanupAndExit;

	err = DeviceLinkFill( (CMMModelPtr)cw, profileSet, (icProfile **)lpProfileData, aIntentArr[0]  );
	profileSet= (CMConcatProfileSet *)DisposeIfPtr( (Ptr) profileSet );

	if( err )goto CleanupAndExit;
	CWDisposeColorWorld ( cw );
	return 1;

CleanupAndExit:
	CWDisposeColorWorld ( cw );
	SetLastError( err );
	return 0;
}

/* ______________________________________________________________________
BOOL  WINAPI CMCreateDeviceLinkProfile(	LPHPROFILE	lpahProfiles,
										DWORD 		nProfiles,
										LPBYTE		*lpProfileData );

Abstract:
	The CMCreateDeviceLinkProfile function creates a device link
	profile as specified by the "ICC Profile Format Specification."

Parameter			Description
	lpahProfiles	Pointer to an array of profile handles
	nProfiles		Number of profiles in the array
	pProfileData	Points to a pointer to a buffer.
					If successful the function allocates and fills this buffer.
					It is then the calling applications responsibility to
					free this buffer with GlobalFreePtr( lpProfileData )
					when it is no longer needed.

Returns
	If the function is successful, it returns nonzero.
	Otherwise it returns zero. SetLastError is used.

   _____________________________________________________________________ */

/*BOOL  WINAPI CMCreateDeviceLinkProfile(	LPHPROFILE	lpahProfiles,
										DWORD 		nProfiles,
										LPBYTE		*lpProfileData )
{
	long			err;
	UINT32			*arrIntents = 0;
	OSErr			aOSErr;
	DWORD			i;

	arrIntents = (UINT32 *)SmartNewPtrClear( nProfiles * sizeof (UINT32), &aOSErr);
	if (aOSErr != 0 ) return ERROR_NOT_ENOUGH_MEMORY;

	for( i=0; i<nProfiles; i++){
		arrIntents[i] = icPerceptual;
	}

	err = CMCreateDeviceLinkProfileExt( lpahProfiles, nProfiles, arrIntents, nProfiles, BEST_MODE, lpProfileData );
	
	arrIntents = (UINT32 *)DisposeIfPtr( (Ptr)arrIntents );
	return err;
}
*/
/* ______________________________________________________________________
BOOL  WINAPI CMIsProfileValid (	HPROFILE	hProfile,	
								LPBOOL		lpbValid	
							  );

Abstract:
	The CMIsProfileValid function reports if the given profile is a valid ICC profile that can be used for color matching.

Parameter			Description
	lpDevCharacter	Pointer to memory mapped profile
	lpbValid		Points to a variable that is set on exit to TRUE if the profile is a valid ICC profile, or FALSE if not.

Returns
	If it is a valid ICC profile that can be used for color matching,
	the return value is nonzero. Otherwise it is zero.
   _____________________________________________________________________ */
BOOL  WINAPI CMIsProfileValid(	HPROFILE	hProfile,	
								LPBOOL		lpbValid	
							  )
{
	Boolean valid;

	CMValidateProfile( (CMProfileRef)hProfile, &valid );

	*lpbValid = valid;
	return valid;
}

/* ______________________________________________________________________
BOOL  WINAPI CMTranslateColors(	HCMTRANSFORM	hcmTransform,
								LPCOLOR 		lpaInputColors,
								DWORD 			nColors,
								COLORTYPE		ctInput,
								LPCOLOR 		lpaOutputColors,
								COLORTYPE		ctOutput );
Abstract:
	The CMTranslateColors function translates an array of colors from
	the source colorspace to the destination colorspace as defined by
	the color transform.

Parameter			Description
	hcmTransform	Identifies the color transform to use
	lpaInputColors	Pointer to an array of COLOR structures to translate
	nColors			Number of elements in the array
	ctInput			Specifies the input color type
	lpaOutputColors	Pointer to an array of COLOR structures that receive the translated colors
	ctOutput		Specifies the output color type

Returns
	If the function is successful, the return value is nonzero.
	Otherwise it is zero.

   _____________________________________________________________________ */
BOOL  WINAPI CMTranslateColors(	HCMTRANSFORM	hcmTransform,
								LPCOLOR 		lpaInputColors,
								DWORD 			nColors,
								COLORTYPE		ctInput,
								LPCOLOR 		lpaOutputColors,
								COLORTYPE		ctOutput )
{
	long matchErr;
	long i,n;

	n = nColors * sizeof(COLOR) / sizeof(long);
	for( i=0; i<n; i++) lpaOutputColors[ i ] = lpaInputColors[ i ];

	matchErr = CWMatchColors( CMGetTransform( hcmTransform ), (CMColor *)lpaOutputColors, nColors );
	if( matchErr ){
		SetLastError( matchErr );
		return 0;
	}
	return 1;
}

/* ______________________________________________________________________
BOOL  WINAPI CMCheckColors(	HCMTRANSFORM	hcmTransform,
							LPCOLOR 		lpaInputColors,
							DWORD			nColors,
							COLORTYPE		ctInput,
							LPBYTE 			lpaResult );
Abstract:
	The CMCheckColors function determines if the given colors lie
	within the output gamut of the given transform.

Parameter			Description
	hcmTransform	Identifies the color transform to use
	lpaInputColors	Pointer to an array of COLOR structures
	nColors			Number of elements in the array
	ctInput			Input color type
	lpaResult		Pointer to an array of bytes that hold the result

Returns
	If the function is successful, the return value is nonzero.
	Otherwise it is zero.
	The lpaResult array holds the results, each byte corresponds to a
	COLOR element and has a value between 0 and 255.
	The value 0 denotes that the color is in gamut; a non-zero value
	implies that it is out of gamut, with the number "n+1" being at
	least as far out of gamut as the number "n". These values are
	usually generated from the gamutTag in the ICC profile.

   _____________________________________________________________________ */
BOOL  WINAPI CMCheckColors(	HCMTRANSFORM	hcmTransform,
							LPCOLOR 		lpaInputColors,
							DWORD			nColors,
							COLORTYPE		ctInput,
							LPBYTE 			lpaResult )
{
	long matchErr;

	matchErr = CWCheckColorsMS( CMGetTransform( hcmTransform ), (CMColor *)lpaInputColors, nColors, lpaResult );
	if( matchErr ){
		SetLastError( matchErr );
		return 0;
	}
	return 1;
}

/* ______________________________________________________________________
BOOL  WINAPI CMTranslateRGBs(	HCMTRANSFORM	hcmTransform,
								LPVOID			lpSrcBits,
								BMFORMAT		bmInput,
								DWORD			dwWidth,
								DWORD			dwHeight,
								DWORD			dwStride,
								LPVOID			lpDestBits,
								BMFORMAT		bmOutput,
								DWORD			dwTranslateDirection );
Abstract:
	The CMTranslateRGBs function takes a bitmap in one of the defined
	formats and translates the colors in the bitmap producing another
	bitmap in the requested format.

Parameter					Description
	hcmTransform			Identifies the color transform to use
	lpSrcBits				Pointer to bitmap to translate
	bmInput					Input bitmap format
	dwWidth					Number of pixels per scanline of input data
	dwHeight				Number of	 scanlines of input data
	dwStride				Number of bytes from beginning of one scanline to beginning of next
	lpDestBits				Pointer to buffer to receive translated data
	bmOutput				Output bitmap format
	dwTranslateDirection	Describes direction of transform
	Value	Meaning
	CMS_FORWARD	Use forward transform
	CMS_BACKWARD	Use reverse transform  // NOT supported

Returns
	If the function is successful, the return value is nonzero.
	Otherwise it is zero.
   _____________________________________________________________________ */
BOOL  WINAPI CMTranslateRGBs(	HCMTRANSFORM	hcmTransform,
								LPVOID			lpSrcBits,
								BMFORMAT		bmInput,
								DWORD			dwWidth,
								DWORD			dwHeight,
								DWORD			dwStride,
								LPVOID			lpDestBits,
								BMFORMAT		bmOutput,
								DWORD			dwTranslateDirection )
{
	CMBitmapColorSpace 		spaceIn,spaceOut;
	CMBitmap				InBitmap,OutBitmap;
	long matchErr, inPixelSize, outPixelSize;
	BOOL aBgrMode = FALSE;
	CMMModelPtr theModelPtr;
	CMWorldRef theWorldRef;
	HCMTRANSFORM theTransform = CMGetTransform( hcmTransform );
	
	if( dwTranslateDirection == CMS_BACKWARD ){
		if( theTransform == 0 ){
			SetLastError( (DWORD)cmparamErr );
			return 0;
		}
		LOCK_DATA( theTransform );
		theModelPtr = (CMMModelPtr)(DATA_2_PTR( theTransform ));
		theWorldRef = theModelPtr->pBackwardTransform;
		UNLOCK_DATA( theTransform );
		if( theWorldRef == 0 ){
			SetLastError( (DWORD)cmparamErr );
			return 0;
		}
		theTransform = (HCMTRANSFORM)theWorldRef;
	}

	spaceIn = CMGetDataColorSpace( bmInput, &inPixelSize );
	if( spaceIn == 0 ){
		SetLastError( (DWORD)cmInvalidColorSpace );
		return 0;
	}
	spaceOut = CMGetDataColorSpace( bmOutput, &outPixelSize );
	if( spaceOut == 0 ){
		SetLastError( (DWORD)cmInvalidColorSpace );
		return 0;
	}
	InBitmap.image		= lpSrcBits;
	InBitmap.width		= dwWidth;
	InBitmap.height		= dwHeight;
	if( dwStride == 0 ){
		InBitmap.rowBytes = ( dwWidth * (inPixelSize / 8) + 3 ) & ~3;
	}
	else{
		InBitmap.rowBytes	= dwStride;
	}
	InBitmap.pixelSize	= inPixelSize;
	InBitmap.space		= spaceIn;
		
	OutBitmap.image		= lpDestBits;
	OutBitmap.width		= dwWidth;
	OutBitmap.height	= dwHeight;
	OutBitmap.rowBytes	= ( dwWidth * (outPixelSize / 8) + 3 ) & ~3;
	OutBitmap.pixelSize	= outPixelSize;
	OutBitmap.space		= spaceOut;

	matchErr = CWMatchBitmap( theTransform, &InBitmap,
							  (CMBitmapCallBackUPP)0,(void *)NULL,&OutBitmap );
	if( matchErr ){
		SetLastError( matchErr );
		return 0;
	}
	return 1;
}

/* ______________________________________________________________________
BOOL  WINAPI CMTranslateRGBsExt(	HCMTRANSFORM	hcmTransform,
									LPVOID			lpSrcBits,
									BMFORMAT		bmInput,
									DWORD			dwWidth,
									DWORD			dwHeight,
									DWORD			dwInputStride,
									LPVOID			lpDestBits,
									BMFORMAT		bmOutput,
									DWORD			dwOutputStride,
									LPBMCALLBACKFN  lpfnCallback,
									LPARAM			ulCallbackData )
Abstract:
	The CMTranslateRGBs function takes a bitmap in one of the defined
	formats and translates the colors in the bitmap producing another
	bitmap in the requested format.

Parameter					Description
	hcmTransform			Specifies the color transform to use.
	lpSrcBits				Points to the bitmap to translate.
	bmInput					Specifies the input bitmap format.
	dwWidth					Specifies the number of pixels per scanline in the input bitmap.
	dwHeight				Specifies the number of scanlines in the input bitmap.
	dwInputStride			Specifies the number of bytes from the beginning of one scanline to
							the beginning of the next in the input bitmap.
							If dwInputStride is set to zero, the CMM should assume that scanlines
							are padded so as to be DWORD aligned.
	lpDestBits				Points to a destination buffer in which to place the translated bitmap.
	bmOutput				Specifies the output bitmap format.
	dwOutputStride			Specifies the number of bytes from the beginning of one scanline to the
							beginning of the next in the input bitmap.
							If dwOutputStride is set to zero, the CMM should pad scanlines so
							that they are DWORD aligned.
	lpfnCallback			Pointer to an application-supplied callback function called periodically
							by CMTranslateRGBsExt to report progress and allow the calling process
							to cancel the translation. (See ICMProgressProc.)
	ulCallbackData			Data passed back to the callback function, for example to identify the
							translation that is reporting progress.

Returns
	If the function is successful, the return value is nonzero.
	Otherwise it is zero.
   _____________________________________________________________________ */
BOOL  WINAPI CMTranslateRGBsExt(	HCMTRANSFORM	hcmTransform,
									LPVOID			lpSrcBits,
									BMFORMAT		bmInput,
									DWORD			dwWidth,
									DWORD			dwHeight,
									DWORD			dwInputStride,
									LPVOID			lpDestBits,
									BMFORMAT		bmOutput,
									DWORD			dwOutputStride,
									LPBMCALLBACKFN  lpfnCallback,
									LPARAM		ulCallbackData )
{
	CMBitmapColorSpace 		spaceIn,spaceOut;
	CMBitmap				InBitmap,OutBitmap;
	long matchErr, inPixelSize, outPixelSize;
	BOOL aBgrMode = FALSE;

	spaceIn = CMGetDataColorSpace( bmInput, &inPixelSize );
	if( spaceIn == 0 ){
		SetLastError( (DWORD)cmInvalidColorSpace );
		return 0;
	}
	spaceOut = CMGetDataColorSpace( bmOutput, &outPixelSize );
	if( spaceOut == 0 ){
		SetLastError( (DWORD)cmInvalidColorSpace );
		return 0;
	}
	InBitmap.image		= lpSrcBits;
	InBitmap.width		= dwWidth;
	InBitmap.height		= dwHeight;
	if( dwInputStride == 0 ){
		InBitmap.rowBytes = ( dwWidth * (inPixelSize / 8) + 3 ) & ~3;
	}
	else{
		InBitmap.rowBytes	= dwInputStride;
	}
	InBitmap.pixelSize	= inPixelSize;
	InBitmap.space		= spaceIn;
		
	OutBitmap.image		= lpDestBits;
	OutBitmap.width		= dwWidth;
	OutBitmap.height	= dwHeight;
	if( dwOutputStride == 0 ){
		OutBitmap.rowBytes = ( dwWidth * (outPixelSize / 8) + 3 ) & ~3;
	}
	else{
		OutBitmap.rowBytes	= dwOutputStride;
	}
	OutBitmap.pixelSize	= outPixelSize;
	OutBitmap.space		= spaceOut;

	matchErr = CWMatchBitmap( CMGetTransform( hcmTransform ), &InBitmap,
							  (CMBitmapCallBackUPP)lpfnCallback,(void *)ulCallbackData,&OutBitmap );
	if( matchErr ){
		SetLastError( matchErr );
		return 0;
	}
	return 1;
}

/* ______________________________________________________________________
BOOL  WINAPI CMCheckRGBs(	HCMTRANSFORM	hcmTransform,
							LPVOID			lpSrcBits,
							BMFORMAT		bmInput,
							DWORD			dwWidth,
							DWORD			dwHeight,
							DWORD			dwStride,
							LPBYTE			lpDestBits,
							PBMCALLBACKFN	pfnCallback,	
							LPARAM		ulCallbackData );
Abstract:
	The CMCheckRGBs function checks if the pixels in the bitmap lie
	within the output gamut of the given transform.

Parameter			Description

	hcmTransform	Specifies the color transform to use.
	lpSrcBits		Points to the bitmap to check against an output gamut.
	bmInput			Specifies the input bitmap format.
	dwWidth			Specifies the number of pixels per scanline in the input bitmap.
	dwHeight		Specifies the number of scanlines in the input bitmap.
	dwStride		Specifies the number of bytes from the beginning of one scanline
					to the beginning of the next in the input bitmap.
					If dwStride is set to zero, the CMM should assume that scanlines
					are padded so as to be DWORD-aligned.
	lpaResult		Points to a buffer in which the test results are to be placed.
					The results are represented by an array of bytes.
					Each byte in the array corresponds to a pixel in the bitmap,
					and on exit is set to an unsigned value between 0 and 255.
					The value 0 denotes that the color is in gamut,
					while a nonzero value denotes that it is out of gamut.
					For any integer n such that 0 < n < 255, a result value of n+1
					indicates that the corresponding color is at least as far out of
					gamut as would be indicated by a result value of n.
					These values are usually generated from the gamutTag in the ICC profile.
	pfnCallback		Pointer to an application-supplied callback function called periodically
					by CMCheckRGBs to report progress and allow the calling process
					to cancel the translation. (See ICMProgressProc.)
	ulCallbackData	Data passed back to the callback function, for example to identify
					the bitmap test that is reporting progress.

Returns
	If the function is successful, the return value is nonzero.
	Otherwise it is zero.
	The lpaResult array holds the results, each byte corresponds to a pixel
	and has a value between 0 and 255. The value 0 denotes that the color is in gamut;
	a non-zero value implies that it is out of gamut, with the number "n+1" being at
	least as far out of gamut as the number "n". These values are usually generated
	from the gamutTag in the ICC profile.
   _____________________________________________________________________ */
BOOL  WINAPI CMCheckRGBs(	HCMTRANSFORM	hcmTransform,
							LPVOID			lpSrcBits,
							BMFORMAT		bmInput,
							DWORD			dwWidth,
							DWORD			dwHeight,
							DWORD			dwStride,
							LPBYTE			lpDestBits,
							PBMCALLBACKFN	pfnCallback,	
							LPARAM		ulCallbackData )

{
	CMBitmapColorSpace 		spaceIn,spaceOut;
	CMBitmap				InBitmap,OutBitmap;
	long matchErr, inPixelSize;
	BOOL aBgrMode = FALSE;

	spaceIn = CMGetDataColorSpace( bmInput, &inPixelSize );
	if( spaceIn == 0 ){
		SetLastError( (DWORD)cmInvalidColorSpace );
		return 0;
	}
	spaceOut = cm8PerChannelPacking + cmGraySpace;

	if( spaceOut == 0 )return 0;
	InBitmap.image		= lpSrcBits;
	InBitmap.width		= dwWidth;
	InBitmap.height		= dwHeight;
	if( dwStride == 0 ){
		InBitmap.rowBytes = ( dwWidth * (inPixelSize / 8) + 3 ) & ~3;
	}
	else{
		InBitmap.rowBytes	= dwStride;
	}
	InBitmap.pixelSize	= inPixelSize;
	InBitmap.space		= spaceIn;
		
	OutBitmap.image		= lpDestBits;
	OutBitmap.width		= dwWidth;
	OutBitmap.height	= dwHeight;
	OutBitmap.rowBytes	= dwWidth;	// perhaps wrong format?
	OutBitmap.pixelSize	= 8;
	OutBitmap.space		= cmGamutResultSpace;

	matchErr = CWCheckBitmap(	CMGetTransform( hcmTransform ), &InBitmap,
								(CMBitmapCallBackUPP)pfnCallback,(void *)ulCallbackData,&OutBitmap );
	
	if( matchErr ){
		SetLastError( matchErr );
		return 0;
	}
	return 1;
}

/* ______________________________________________________________________
BOOL WINAPI CMTranslateRGB(	HCMTRANSFORM	hcmTransform,
							COLORREF		colorRef,
							LPCOLORREF		lpColorRef,
							DWORD			dwFlags );
Abstract:
	The CMTranslateRGB function translates an application supplied RGBQuad into the
	device color coordinate space.

Parameter			Description
	hcmTransform	Handle of transform to use.
	colorRef		RGBQuad to translate.
	lpColorRef		Pointer to buffer to store result.
	dwFlags			Flags that can have the following meaning

	Type			Meaning
		
	CMS_FORWARD		Specifies that the forward transform is to be used.
	CMS_BACKWARD	Specifies that the backward transform is to be used.  // NOT supported

Returns
	The return value is TRUE if the function is successful. Otherwise, it is NULL.

   _____________________________________________________________________ */
BOOL WINAPI CMTranslateRGB(	HCMTRANSFORM	hcmTransform,
							COLORREF		colorRef,
							LPCOLORREF		lpColorRef,
							DWORD			dwFlags )

{
	CMBitmapColorSpace 		spaceIn;
	CMBitmap				InBitmap,OutBitmap;
	long matchErr;
	COLORREF aColorRef = colorRef;
	BOOL aBgrMode = FALSE;
	CMBitmapColorSpace In,Out;
	CMMModelPtr theModelPtr;
	CMWorldRef theWorldRef;
	HCMTRANSFORM theTransform = CMGetTransform( hcmTransform );
	
	if( dwFlags == CMS_BACKWARD ){
		if( theTransform == 0 ){
			SetLastError( (DWORD)cmparamErr );
			return 0;
		}
		LOCK_DATA( theTransform );
		theModelPtr = (CMMModelPtr)(DATA_2_PTR( theTransform ));
		theWorldRef = theModelPtr->pBackwardTransform;
		UNLOCK_DATA( theTransform );
		if( theWorldRef == 0 ){
			SetLastError( (DWORD)cmparamErr );
			return 0;
		}
		theTransform = (HCMTRANSFORM)theWorldRef;
	}

	spaceIn = cmRGBA32Space;
	InBitmap.image		= (char *)(&aColorRef);
	InBitmap.width		= 1;
	InBitmap.height		= 1;
	InBitmap.rowBytes	= 4;
	InBitmap.pixelSize	= 32;
	InBitmap.space		= spaceIn;
	OutBitmap = InBitmap;	
	OutBitmap.image		= (char *)lpColorRef;

	matchErr = CWGetColorSpaces( theTransform, &In, &Out );
	if( matchErr ){
		SetLastError( matchErr );
		return 0;
	}
	if( Out == icSigCmykData ) OutBitmap.space = cmKYMC32Space;
	matchErr = CWMatchBitmap(	theTransform, &InBitmap,
								(CMBitmapCallBackUPP)0,(void *)NULL,&OutBitmap );
	if( matchErr ){
		SetLastError( matchErr );
		return 0;
	}
	return 1;
}


/* ______________________________________________________________________
BOOL WINAPI CMCheckColorsInGamut(	HCMTRANSFORM	hcmTransform,
									LPARGBQUAD		lpaRGBTriplet,
									LPBYTE			lpBuffer,
									UINT			nCount );
Abstract:
	The CMCheckColorInGamut determines if the given RGBs lie in the output gamut of the
	given transform.

Parameter			Description	
	hcmTransform	Handle of transform to use.
	lpaRGBTriples	Pointer to array of RGB triples to check.
	lpBuffer		Pointer to buffer to put results.
	nCount			Count of elements in array.


Returns
	The return value is TRUE if the function is successful. Otherwise, it is NULL.
	The lpBuffer holds the results, each byte corresponding to an RGB triple is a value in
	the range 0 to 255.
   _____________________________________________________________________ */
BOOL WINAPI CMCheckColorsInGamut(	HCMTRANSFORM	hcmTransform,
									LPARGBQUAD		lpaRGBTriplet,
									LPBYTE			lpBuffer,
									UINT			nCount )
{
	CMBitmap				InBitmap,OutBitmap;
	long matchErr;
	BOOL aBgrMode = FALSE;

	InBitmap.image		= (char *)(lpaRGBTriplet);
	InBitmap.width		= nCount;
	InBitmap.height		= 1;
	InBitmap.rowBytes	= 3*nCount;
	InBitmap.pixelSize	= 24;
	InBitmap.space		= cm8PerChannelPacking + cmRGBSpace;
	OutBitmap = InBitmap;	
	OutBitmap.rowBytes	= nCount;	// perhaps wrong format?
	OutBitmap.pixelSize	= 8;
	OutBitmap.image		= (char *)lpBuffer;

	matchErr = CWCheckBitmap(	CMGetTransform( hcmTransform ), &InBitmap,
								(CMBitmapCallBackUPP)0,(void *)NULL,&OutBitmap );
	if( matchErr ){
		SetLastError( matchErr );
		return 0;
	}
	return 1;
}
/* ______________________________________________________________________
long FillProfileFromLog(	LPLOGCOLORSPACEA	lpColorSpace,
							PPROFILE			theProf )
Abstract:
	The FillProfileFromLog function convertes a lpColorSpace to a PROFILE.
	If lpColorSpace has a profile name the function returns a file based profile.
	Else it returns a memory based profile.

Parameter			Description	
	lpColorSpace	Handle of transform to use.
	theProf			Pointer to the profile.

Returns
	The return value is 0 if the function is successful. Otherwise, it is an error code.
   _____________________________________________________________________ */
long FillProfileFromLog(	LPLOGCOLORSPACEA	lpColorSpace,
							PPROFILE			theProf )
{
	long l;
	icProfile *aProf;
	CMError  err = -1;

	if( lpColorSpace->lcsFilename[0] ){
		theProf->pProfileData = (char *)lpColorSpace->lcsFilename;
		theProf->dwType = PROFILE_FILENAME;
		theProf->cbDataSize = lstrlenA((const unsigned char *)theProf->pProfileData) * sizeof(CHAR);
		err = 0;
	}
	else if( lpColorSpace->lcsCSType == LCS_CALIBRATED_RGB ){
		err = MyNewAbstract( lpColorSpace, &aProf );
		theProf->pProfileData = ((PVOID *)aProf);
		theProf->dwType = PROFILE_MEMBUFFER;
		l = *(DWORD *)(theProf->pProfileData);
		theProf->cbDataSize = SwapLong(&l);
	}
	else  theProf->pProfileData = 0;

	return err;
}

/* ______________________________________________________________________
long FillProfileFromLogW(	LPLOGCOLORSPACEW	lpColorSpace,
							PPROFILE			theProf )
Abstract:
	The FillProfileFromLog function convertes a lpColorSpace to a PROFILE.
	If lpColorSpace has a profile name the function returns a file based profile.
	Else it returns a memory based profile.

Parameter			Description	
	lpColorSpace	Handle of transform to use.
	theProf			Pointer to the profile.

Returns
	The return value is 0 if the function is successful. Otherwise, it is an error code.
   _____________________________________________________________________ */
long FillProfileFromLogW(	LPLOGCOLORSPACEW	lpColorSpace,
							PPROFILE			theProf )
{
	long l;
	icProfile *aProf;
	CMError  err = -1;

	if( lpColorSpace->lcsFilename[0] ){
		theProf->pProfileData = (char *)lpColorSpace->lcsFilename;
		theProf->dwType = PROFILE_FILENAME;
		theProf->cbDataSize = lstrlenW((const unsigned short *)theProf->pProfileData) * sizeof(WCHAR);
		err = 0;
	}
	else if( lpColorSpace->lcsCSType == LCS_CALIBRATED_RGB ){
		err = MyNewAbstractW( lpColorSpace, &aProf );
		theProf->pProfileData = ((PVOID *)aProf);
		theProf->dwType = PROFILE_MEMBUFFER;
		l = *(DWORD *)(theProf->pProfileData);
		theProf->cbDataSize = SwapLong(&l);
	}
	else  theProf->pProfileData = 0;

	return err;
}

/* ______________________________________________________________________
CMBitmapColorSpace CMGetDataColorSpace( BMFORMAT bmMode, long *pixelSize );

Abstract:
	The CMGetDataColorSpace function retrieves the CMBitmapColorSpace and
	the pixel size from the BMFORMAT.

Parameter			Description
	bmMode			Identifies the data format.
	pixelSize		Pointer to pixelsize.

Returns
	function returns the internal data format
________________________________________________________________ */
CMBitmapColorSpace CMGetDataColorSpace( BMFORMAT bmMode, long *pixelSize )
{
	switch(  bmMode ){
	case BM_565RGB:
		*pixelSize = 16;
		return cmWord565ColorPacking + cmRGBSpace;
		break;
    case BM_x555RGB:
		*pixelSize = 16;
		return cmWord5ColorPacking + cmRGBSpace;
		break;
	case BM_x555XYZ:
		*pixelSize = 16;
		return cmWord5ColorPacking + cmXYZSpace;
		break;
	case BM_x555Yxy:
		*pixelSize = 16;
		return cmWord5ColorPacking + cmYXYSpace;
		break;
	case BM_x555Lab:
		*pixelSize = 16;
		return cmWord5ColorPacking + cmLABSpace;
		break;
	case BM_x555G3CH:
		*pixelSize = 16;
		return cmWord5ColorPacking + cmGenericSpace;
		break;
	case BM_RGBTRIPLETS:
		*pixelSize = 24;
		return cm8PerChannelPacking + cmBGRSpace;
		break;
	case BM_BGRTRIPLETS:
		*pixelSize = 24;
		return cm8PerChannelPacking + cmRGBSpace;
		break;
	case BM_XYZTRIPLETS:
		*pixelSize = 24;
		return cm8PerChannelPacking + cmXYZSpace;
		break;
	case BM_YxyTRIPLETS:
		*pixelSize = 24;
		return cm8PerChannelPacking + cmYXYSpace;
		break;
	case BM_LabTRIPLETS:
		*pixelSize = 24;
		return cm8PerChannelPacking + cmLABSpace;
		break;
	case BM_G3CHTRIPLETS:
		*pixelSize = 24;
		return cm8PerChannelPacking + cmGenericSpace;
		break;
	case BM_5CHANNEL:
		*pixelSize = 40;
		return cmMCFive8Space;
		break;
	case BM_6CHANNEL:
		*pixelSize = 48;
		return cmMCSix8Space;
		break;
	case BM_7CHANNEL:
		*pixelSize = 56;
		return cmMCSeven8Space;
		break;
	case BM_8CHANNEL:
		*pixelSize = 64;
		return cmMCEight8Space;
		break;
	case BM_GRAY:
		*pixelSize = 8;
		return cm8PerChannelPacking + cmGraySpace;
		break;
	case BM_xRGBQUADS:
		*pixelSize = 32;
		return cmBGR32Space;
		break;
	case BM_xBGRQUADS:
		*pixelSize = 32;
		return cmRGBA32Space;
		break;
#if 0
	case BM_xXYZQUADS:
		*pixelSize = 32;
		return cmLong8ColorPacking + cmXYZSpace;
		break;
	case BM_xYxyQUADS:
		*pixelSize = 32;
		return cmLong8ColorPacking + cmYXYSpace;
		break;
	case BM_xLabQUADS:
		*pixelSize = 32;
		return cmLong8ColorPacking + cmLABSpace;
		break;
#endif
    case BM_xG3CHQUADS:
		*pixelSize = 32;
		return cmLong8ColorPacking + cmGenericSpace;
		break;
	case BM_CMYKQUADS:
		*pixelSize = 32;
		return cmLong8ColorPacking + cmKYMCSpace;
		break;
	case BM_KYMCQUADS:
		*pixelSize = 32;
		return cmLong8ColorPacking + cmCMYKSpace;
		break;
	case BM_10b_RGB:
		*pixelSize = 32;
		return cmLong10ColorPacking + cmRGBSpace;
		break;
	case BM_10b_XYZ:
		*pixelSize = 32;
		return cmLong10ColorPacking + cmXYZSpace;
		break;
	case BM_10b_Yxy:
		*pixelSize = 32;
		return cmLong10ColorPacking + cmYXYSpace;
		break;
	case BM_10b_Lab:
		*pixelSize = 32;
		return cmLong10ColorPacking + cmLABSpace;
		break;
	case BM_10b_G3CH:
		*pixelSize = 32;
		return cmLong10ColorPacking + cmGenericSpace;
		break;
	case BM_16b_RGB:
		*pixelSize = 48;
		return cm16PerChannelPacking + cmBGRSpace;
		break;
	case BM_16b_XYZ:
		*pixelSize = 48;
		return cm16PerChannelPacking + cmXYZSpace;
		break;
	case BM_16b_Yxy:
		*pixelSize = 48;
		return cm16PerChannelPacking + cmYXYSpace;
		break;
	case BM_16b_Lab:
		*pixelSize = 48;
		return cm16PerChannelPacking + cmLABSpace;
		break;
	case BM_16b_G3CH:
		*pixelSize = 48;
		return cm16PerChannelPacking + cmGenericSpace;
		break;
	case BM_16b_GRAY:
		*pixelSize = 16;
		return cmGraySpace;
		break;
	case BM_NAMED_INDEX:
		*pixelSize = 32;
		return cmNamedIndexed32Space;
		break;
	default:
		*pixelSize = 0;
		return 0;
	}
}

/* ______________________________________________________________________
HCMTRANSFORM  WINAPI CMGetTransform( HCMTRANSFORM 	hcmTransform );

Abstract:
	The CMGetTransform function retrieves the actual transform out of the static array
	in the critical section.

Parameter			Description
	hcmTransform	Handle to the transform.

Returns
	the actual pointer to the transform
________________________________________________________________ */
HCMTRANSFORM  WINAPI CMGetTransform( HCMTRANSFORM 	hcmTransform )
{
	long actTransform = (long)(ULONG_PTR)hcmTransform - 256;
	HCMTRANSFORM aTrans;

	__try {
		EnterCriticalSection(&GlobalCriticalSection);
		if( actTransform < IndexTransform && actTransform >= 0 ){
			aTrans = TheTransform[actTransform];
			return aTrans;
		}
		else return 0;
	}
	__finally{
		LeaveCriticalSection(&GlobalCriticalSection);
 	}
}

/* ______________________________________________________________________
CMWorldRef StoreTransform( CMWorldRef aRef );

Abstract:
	The StoreTransform function stores the actual transform in the static array
	in the critical section.

Parameter		Description
	aRef		Ptr to the transform.

Returns
	valid (255 < handle < 65536 ) handle of the transform
________________________________________________________________ */
CMWorldRef StoreTransform( CMWorldRef aRef )
{
	long i;
	
	__try {
		EnterCriticalSection(&GlobalCriticalSection);

		if( IndexTransform >= 1000 )return (HCMTRANSFORM)ERROR_NOT_ENOUGH_MEMORY;
		for( i = 0; i<IndexTransform ; i++ ){
			if( TheTransform[i] == 0 ){
				TheTransform[i] = aRef;
				return (CMWorldRef)(ULONG_PTR)(i + 256 );
			}
		}
		if( i >= IndexTransform ){
			TheTransform[IndexTransform] = aRef;
			IndexTransform++;
			return (CMWorldRef)(ULONG_PTR)(IndexTransform - 1 + 256);
		}
	}
	__finally{
		LeaveCriticalSection(&GlobalCriticalSection);

	}

   return NULL;
}

BOOL  WINAPI CMConvertColorNameToIndex( HPROFILE aProf, LPCOLOR_NAME aColorNameArr, LPDWORD aDWordArr, DWORD count )
{
	CMError err;

	err = CMConvNameToIndexProfile( aProf, aColorNameArr, aDWordArr, count );
	if( err ){
		SetLastError( err );
		return 0;
	}
	return 1;
}

BOOL  WINAPI CMConvertIndexToColorName( HPROFILE aProf, LPDWORD aDWordArr, LPCOLOR_NAME aColorNameArr, DWORD count )
{
	long matchErr;

	matchErr = CMConvIndexToNameProfile( aProf, aDWordArr, aColorNameArr, count );
	if( matchErr ){
		SetLastError( matchErr );
		return 0;
	}
	return 1;
}

BOOL  WINAPI CMGetNamedProfileInfo( HPROFILE aProf, LPNAMED_PROFILE_INFO Info )
{
	long matchErr;

	matchErr = CMGetNamedProfileInfoProfile( aProf, (pCMNamedProfileInfo)Info );
	if( matchErr ){
		SetLastError( matchErr );
		return 0;
	}
	return 1;
}

/*
CMBitmapColorSpace CMGetColorType( COLORTYPE bmMode, long *pixelSize )
{
	switch(  bmMode ){
	case COLOR_GRAY:
		*pixelSize = 16;
		return cm16PerChannelPacking + cmGraySpace;
		break;
	case COLOR_	:
	case COLOR_XYZ:
	case COLOR_Yxy:
	case COLOR_Lab:
	case COLOR_3_CHANNEL:
	case COLOR_CMYK:
		*pixelSize = 64;
		return cm16PerChannelPacking + cmRGBSpace;
		break;
	case COLOR_5_CHANNEL:
	case COLOR_6_CHANNEL:
	case COLOR_7_CHANNEL:
	case COLOR_8_CHANNEL:
		*pixelSize = 64;
		return cm8PerChannelPacking + cmMCFiveSpace + bmMode - COLOR_5_CHANNEL;
		break;
	default:
		*pixelSize = 0;
		return 0;
	}
}

#define CMS_x555WORD      0x00000000
#define CMS_565WORD       0x00000001
#define CMS_RGBTRIPLETS   0x00000002
#define CMS_BGRTRIPLETS   0x00000004
#define CMS_XRGBQUADS     0x00000008
#define CMS_XBGRQUADS     0x00000010
#define CMS_QUADS         0x00000020

CMBitmapColorSpace CMGetCMSType( DWORD bmMode, long *pixelSize )
{
	if(  bmMode & CMS_x555WORD ){
		*pixelSize = 16;
		return cmWord5ColorPacking + cmRGBSpace;
	}
	else if( bmMode & CMS_RGBTRIPLETS ){
		*pixelSize = 24;
		return cm8PerChannelPacking + cmRGBSpace;
	}
	else if( bmMode &  CMS_BGRTRIPLETS ){
		*pixelSize = 24;
		return cm8PerChannelPacking + cmBGRSpace;
	}
	else if( bmMode &  CMS_XRGBQUADS ){
		*pixelSize = 32;
		return cmLong8ColorPacking + cmRGBSpace;
	}
	else if( bmMode &  CMS_XBGRQUADS ){
		*pixelSize = 32;
		return cmLong8ColorPacking + cmBGRSpace;
	}
	else if( bmMode &  CMS_QUADS	 ){
		*pixelSize = 32;
		return cmLong8ColorPacking + cmCMYKSpace;
	}
	else{
		*pixelSize = 0;
		return 0;
	}
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\mscmm.w98\mscmm\sources.inc ===
!IF 0

Copyright (c) 1996  Microsoft Corporation

!ENDIF

MAJORCOMP=windows
MINORCOMP=mscmm

!ifndef ICMROOT
ICMROOT=$(NTGDI_PATH)\icm
!endif

!include $(ICMROOT)\icmsrc.inc

TARGETNAME=icm32
TARGETTYPE=DYNLINK
TARGETPATH=$(ALT_PROJECT_TARGET)\$(_OBJ_DIR)
TARGETLIBS=$(ICMROOT)\mscms\$(O)\mscms.lib                      \
           $(SDK_LIB_PATH)\kernel32.lib                         \
           $(ICMROOT)\mscmm\lh_open\$(O)\lh_open.lib            \
           $(ICMROOT)\mscmm\lh_core\$(O)\lh_core.lib

DLLBASE=@$(COFFBASE_TXT_FILE),icm32

C_DEFINES=$(C_DEFINES) -DWIN32 -D__MSDOS__ -DIntelMode -DRenderInt -DMS_Icm

USE_MSVCRT=1
DLLENTRY=DllMain

INCLUDES=..\.;..\..\lh_core;..\..\lh_open

SOURCES= ..\icm32.rc    \
         ..\icm32.c     \
         ..\access.c    \
         ..\memprof.c

DLLDEF=..\$(TARGETNAME).def
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\mscms\globals.h ===
/****************************Module*Header******************************\
* Module Name: GLOBALS.H
*
* Module Descripton: Header file listing all global variables
*
* Warnings:
*
* Issues:
*
* Public Routines:
*
* Created:  6 May 1996
* Author:   Srinivasan Chandrasekar    [srinivac]
*
* Copyright (c) 1996, 1997  Microsoft Corporation
\***********************************************************************/

#if DBG
extern DWORD     gdwDebugControl;
#endif

extern PCMMOBJ   gpCMMChain;
extern PCMMOBJ   gpPreferredCMM;

extern char     *gszCMMReqFns[];
extern char     *gszCMMOptFns[];
extern char     *gszPSFns[];

extern TCHAR     gszICMatcher[];
extern TCHAR     gszICMRegPath[];

#if !defined(_WIN95_)
extern TCHAR     gszMonitorGUID[];
extern TCHAR     gszDeviceClass[];
#else
extern TCHAR     gszSetupPath[];
extern TCHAR     gszRegPrinter[];
extern TCHAR     gszICMDir[];
extern TCHAR     gszPrinterData[];
#endif

extern TCHAR     gszPrinter[];
extern TCHAR     gszMonitor[];
extern TCHAR     gszScanner[];
extern TCHAR     gszLink[];
extern TCHAR     gszAbstract[];
extern TCHAR     gszDefault[];
extern TCHAR     gszFriendlyName[];
extern TCHAR     gszDeviceName[];
extern TCHAR     gszDisplay[];

extern TCHAR     gszDefaultCMM[];

extern CRITICAL_SECTION critsec;

extern TCHAR     gszColorDir[];
extern TCHAR     gszBackslash[];

extern TCHAR     gszRegisteredProfiles[];
extern TCHAR     gszsRGBProfile[];

extern TCHAR     gszICMProfileListValue[];
extern TCHAR     gszICMProfileListKey[];
extern TCHAR     gszFiles[];
extern TCHAR     gszDirectory[];
extern TCHAR     gszModule[];
extern TCHAR     gszMSCMS[];
extern TCHAR     gszICMDeviceDataKey[];
extern TCHAR     gszICMProfileEnumMode[];

extern TCHAR     gszStiDll[];
extern char      gszStiCreateInstance[];
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\mscms\mscms.h ===
/****************************Module*Header******************************\
* Module Name: MSCMS.H
*
* Module Descripton: Single header file that will be precompiled. This
*   should be included first in all the source files.
*
* Warnings:
*
* Issues:
*
* Public Routines:
*
* Created:  14 March 1996
* Author:   Srinivasan Chandrasekar    [srinivac]
*
* Copyright (c) 1996, 1997  Microsoft Corporation
\***********************************************************************/

#ifndef _MSCMS_H_
#define _MSCMS_H_

#include "windows.h"
#include "windowsx.h"
#include "winspool.h"
#include "winsplp.h"
#include "debug.h"
#include "icmpriv.h"
#include "globals.h"
#include "setupapi.h"

#include "string.h"
#include "tchar.h"

#endif      // ifndef _MSCMS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\mscms\globals.c ===
/****************************Module*Header******************************\
* Module Name: GLOBALS.C
*
* Module Descripton: This file contains all the global variables
*
* Warnings:
*
* Issues:
*
* Public Routines:
*
* Created:  6 May 1996
* Author:   Srinivasan Chandrasekar    [srinivac]
*
* Copyright (c) 1996, 1997  Microsoft Corporation
\***********************************************************************/

#include "mscms.h"


#if DBG

//
// Global variable used for debugging purposes
//

DWORD gdwDebugControl = DBG_LEVEL_WARNING;

#endif

//
// These are for loading & unloading CMMs and maintaining the CMM objects
// in a chain in memory
//

PCMMOBJ  gpCMMChain     = NULL; // the list of used CMM by application
PCMMOBJ  gpPreferredCMM = NULL; // application specified preferred CMM

char    *gszCMMReqFns[] = {
    "CMGetInfo",
   #ifdef UNICODE
    "CMCreateTransformW",
    "CMCreateTransformExtW",
   #else
    "CMCreateTransform",
    "CMCreateTransformExt",
   #endif
    "CMDeleteTransform",
    "CMTranslateRGBs",
    "CMTranslateRGBsExt",
    "CMCheckRGBs",
    "CMCreateMultiProfileTransform",
    "CMTranslateColors",
    "CMCheckColors"
    };

char    *gszCMMOptFns[] = {
   #ifdef UNICODE
    "CMCreateProfileW",
   #else
    "CMCreateProfile",
   #endif
    "CMGetNamedProfileInfo",
    "CMConvertColorNameToIndex",
    "CMConvertIndexToColorName",
    "CMCreateDeviceLinkProfile",
    "CMIsProfileValid"
    };

char     *gszPSFns[] = {
    "CMGetPS2ColorSpaceArray",
    "CMGetPS2ColorRenderingIntent",
    "CMGetPS2ColorRenderingDictionary"
    };

//
// These are for registry paths
//

#if !defined(_WIN95_)
TCHAR  gszMonitorGUID[]    = __TEXT("{4D36E96E-E325-11CE-BFC1-08002BE10318}");
TCHAR  gszDeviceClass[]    = __TEXT("SYSTEM\\CurrentControlSet\\Control\\Class\\");
TCHAR  gszICMatcher[]      = __TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\ICM\\ICMatchers");
TCHAR  gszICMRegPath[]     = __TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\ICM");
#else
TCHAR  gszICMatcher[]      = __TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\ICM\\ICMatchers");
TCHAR  gszICMRegPath[]     = __TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\ICM");
TCHAR  gszSetupPath[]      = __TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Setup");
TCHAR  gszRegPrinter[]     = __TEXT("System\\CurrentControlSet\\Control\\Print\\Printers");
TCHAR  gszICMDir[]         = __TEXT("ICMPath");
TCHAR  gszPrinterData[]    = __TEXT("PrinterDriverData");
#endif

TCHAR  gszPrinter[]        = __TEXT("prtr");
TCHAR  gszMonitor[]        = __TEXT("mntr");
TCHAR  gszScanner[]        = __TEXT("scnr");
TCHAR  gszLink[]           = __TEXT("link");
TCHAR  gszAbstract[]       = __TEXT("abst");
TCHAR  gszDefault[]        = __TEXT("default");
TCHAR  gszFriendlyName[]   = __TEXT("FriendlyName");
TCHAR  gszDeviceName[]     = __TEXT("DriverDesc");
TCHAR  gszDisplay[]        = __TEXT("DISPLAY");

//
// Default CMM dll
//

TCHAR  gszDefaultCMM[] = __TEXT("icm32.dll");

//
// Synchronization objects
//

CRITICAL_SECTION   critsec;

//
// Miscellaneous
//

TCHAR  gszColorDir[]     = __TEXT("COLOR");
TCHAR  gszBackslash[]    = __TEXT("\\");

//
// Wellknown profile support
//

TCHAR  gszRegisteredProfiles[]  = __TEXT("RegisteredProfiles");
TCHAR  gszsRGBProfile[]         = __TEXT("sRGB Color Space Profile.icm");

TCHAR  gszICMProfileListKey[]   = __TEXT("CopyFiles\\ICM");
TCHAR  gszICMProfileListValue[] = __TEXT("ICMProfile");

TCHAR  gszFiles[]               = __TEXT("Files");
TCHAR  gszDirectory[]           = __TEXT("Directory");
TCHAR  gszModule[]              = __TEXT("Module");
TCHAR  gszMSCMS[]               = __TEXT("mscms.dll");

TCHAR  gszICMDeviceDataKey[]    = __TEXT("ICMData");
TCHAR  gszICMProfileEnumMode[]  = __TEXT("ProfileEnumMode");

//
// Scanner support
//

TCHAR  gszStiDll[]             = __TEXT("sti.dll");
char   gszStiCreateInstance[]  = "StiCreateInstance";
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\mscms\dllentry.c ===
/****************************Module*Header******************************\
* Module Name: DLLENTRY.C
*
* Module Descripton: This file has dll management functions and global
*   variables used by MSCMS.DLL
*
* Warnings:
*
* Issues:
*
* Public Routines:
*
* Created:  18 March 1996
* Author:   Srinivasan Chandrasekar    [srinivac]
*
* Copyright (c) 1996, 1997  Microsoft Corporation
\***********************************************************************/

#include "mscms.h"

BOOL WINAPI
DllEntryPoint(
    HINSTANCE hInstance,
    DWORD     fdwReason,
    LPVOID    lpvReserved
    )
{
    switch (fdwReason)
    {
    case DLL_PROCESS_ATTACH:
        //
        // Not nessesary to call me for DLL_THREAD_ATTACH and DLL_THREAD_DETACH
        //
        DisableThreadLibraryCalls(hInstance);
        InitializeCriticalSection(&critsec);
        break;

    case DLL_PROCESS_DETACH:
        DeleteCriticalSection(&critsec);
        break;

    default:
        break;
    }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\mscms\object.c ===
/****************************Module*Header******************************\
* Module Name: OBJECT.C
*
* Module Descripton: Object management functions.
*
* Warnings:
*
* Issues:
*
* Public Routines:
*
* Created:  18 March 1996
* Author:   Srinivasan Chandrasekar    [srinivac]
*
* Copyright (c) 1996, 1997  Microsoft Corporation
\***********************************************************************/

#include "mscms.h"

//
// Number of required and optional functions for CMMs to export
//

#define NUM_REQ_FNS    10
#define NUM_OPT_FNS    6
#define NUM_PS_FNS     3


/******************************************************************************
 *
 *                            AllocateHeapObject
 *
 *  Function:
 *       This functions allocates requested object on the process's heap,
 *       and returns a handle to it.
 *
 *  Arguments:
 *       objType  - type of object to allocate
 *
 *  Returns:
 *       Handle to object if successful, NULL otherwise
 *
 ******************************************************************************/

HANDLE
AllocateHeapObject(
    OBJECTTYPE  objType
    )
{
    DWORD    dwSize;
    POBJHEAD pObject;

    switch (objType)
    {
    case OBJ_PROFILE:
        dwSize = sizeof(PROFOBJ);
        break;

    case OBJ_TRANSFORM:
        dwSize = sizeof(TRANSFORMOBJ);
        break;

    case OBJ_CMM:
        dwSize = sizeof(CMMOBJ);
        break;

    default:
        RIP((__TEXT("Allocating invalid object\n")));
        dwSize = 0;
        break;
    }

    pObject = (POBJHEAD)MemAlloc(dwSize);

    if (!pObject)
    {
        return NULL;
    }

    pObject->objType = objType;

    return(PTRTOHDL(pObject));
}


/******************************************************************************
 *
 *                            FreeHeapObject
 *
 *  Function:
 *       This functions free an object on the process's heap
 *
 *  Arguments:
 *       hObject  - handle to object to free
 *
 *  Returns:
 *       No return value
 *
 ******************************************************************************/

VOID
FreeHeapObject(
    HANDLE hObject
    )
{
    POBJHEAD pObject;

    ASSERT(hObject != NULL);

    pObject = (POBJHEAD)HDLTOPTR(hObject);

    ASSERT(pObject->dwUseCount == 0);

    pObject->objType = 0;       // in case the handle gets reused

    MemFree((PVOID)pObject);
}


/******************************************************************************
 *
 *                            ValidHandle
 *
 *  Function:
 *       This functions checks if a given handle is a valid handle to
 *       an object of the specified type
 *
 *  Arguments:
 *       hObject  - handle to an object
 *       objType  - type of object to the handle refers to
 *
 *  Returns:
 *       TRUE is the handle is valid, FALSE otherwise.
 *
 ******************************************************************************/

BOOL
ValidHandle(
    HANDLE  hObject,
    OBJECTTYPE objType
    )
{
    POBJHEAD pObject;
    BOOL     rc;

    if (!hObject)
    {
        return FALSE;
    }

    pObject = (POBJHEAD)HDLTOPTR(hObject);

    rc = !IsBadReadPtr(pObject, sizeof(DWORD)) &&
         (pObject->objType == objType);

    return rc;
}


/******************************************************************************
 *
 *                           ValidProfile
 *
 *  Function:
 *       This function checks if a given profile is valid by doing some
 *       sanity checks on it. It is not a fool prof check.
 *
 *  Arguments:
 *       pProfObj  - pointer to profile object
 *
 *  Returns:
 *       TRUE if it is a valid profile, FALSE otherwise
 *
 ******************************************************************************/

BOOL ValidProfile(
    PPROFOBJ pProfObj
    )
{
    DWORD dwSize = FIX_ENDIAN(HEADER(pProfObj)->phSize);

    return ((dwSize <= pProfObj->dwMapSize) &&
            (HEADER(pProfObj)->phSignature == PROFILE_SIGNATURE) &&
            (dwSize >= (sizeof(PROFILEHEADER) + sizeof(DWORD))));
}


/******************************************************************************
 *
 *                            MemAlloc
 *
 *  Function:
 *       This functions allocates requested amount of zero initialized memory
 *       from the process's heap and returns a pointer to it
 *
 *  Arguments:
 *       dwSize  - amount of memory to allocate in bytes
 *
 *  Returns:
 *       Pointer to memory if successful, NULL otherwise
 *
 ******************************************************************************/

PVOID
MemAlloc(
    DWORD dwSize
    )
{
    if (dwSize > 0)
        return (PVOID)GlobalAllocPtr(GHND | GMEM_ZEROINIT, dwSize);
    else
        return NULL;
}


/******************************************************************************
 *
 *                            MemReAlloc
 *
 *  Function:
 *       This functions reallocates a block of memory from the process's
 *       heap and returns a pointer to it
 *
 *  Arguments:
 *       pMemory    - pointer to original memory
 *       dwNewSize  - new size to reallocate
 *
 *  Returns:
 *       Pointer to memory if successful, NULL otherwise
 *
 ******************************************************************************/

PVOID
MemReAlloc(
    PVOID pMemory,
    DWORD dwNewSize
    )
{
    return (PVOID)GlobalReAllocPtr(pMemory, dwNewSize, GMEM_ZEROINIT);
}


/******************************************************************************
 *
 *                            MemFree
 *
 *  Function:
 *       This functions frees memory from the process's heap
 *       and returns a handle to it.
 *
 *  Arguments:
 *       pMemory  - pointer to memory to free
 *
 *  Returns:
 *       No return value
 *
 ******************************************************************************/

VOID
MemFree(
    PVOID pMemory
    )
{
    DWORD dwErr;

    //
    // GlobalFree() resets last error, we get and set around it so we don't
    // lose anything we have set.
    //

    dwErr = GetLastError();
    GlobalFreePtr(pMemory);
    if (dwErr)
    {
        SetLastError(dwErr);
    }
}


/******************************************************************************
 *
 *                            MyCopyMemory
 *
 *  Function:
 *       This functions copies data from one place to another. It takes care
 *       of overlapping cases. The reason we have our own function and not use
 *       MoveMemory is that MoveMemory uses memmove which pulls in msvcrt.dll
 *
 *  Arguments:
 *       pDest    - pointer to destination of copy
 *       pSrc     - pointer to source
 *       dwCount  - number of bytes to copy
 *
 *  Returns:
 *       No return value
 *
 ******************************************************************************/

VOID
MyCopyMemory(
    PBYTE pDest,
    PBYTE pSrc,
    DWORD dwCount
    )
{
    //
    // Make sure overlapping cases are handled
    //

    if ((pSrc < pDest) && ((pSrc + dwCount) >= pDest))
    {
        //
        // Overlapping case, copy in reverse
        //

        pSrc += dwCount - 1;
        pDest += dwCount - 1;

        while (dwCount--)
        {
            *pDest-- = *pSrc--;
        }

    }
    else
    {
        while (dwCount--)
        {
            *pDest++ = *pSrc++;
        }
    }

    return;
}


/******************************************************************************
 *
 *                              ConvertToUnicode
 *
 *  Function:
 *       This function converts a given Ansi string to Unicode. It optionally
 *       allocates memory for the Unicode string which the calling program
 *       needs to free.
 *
 *  Arguments:
 *       pszAnsiStr      - pointer to Ansi string to convert
 *       ppwszUnicodeStr - pointer to pointer to Unicode string
 *       bAllocate       - If TRUE, allocate memory for Unicode string
 *
 *  Returns:
 *       TRUE if successful, FALSE otherwise
 *
 ******************************************************************************/

BOOL
ConvertToUnicode(
    PCSTR  pszAnsiStr,
    PWSTR *ppwszUnicodeStr,
    BOOL   bAllocate
    )
{
    DWORD dwLen;                    // length of Unicode string

    dwLen = (lstrlenA(pszAnsiStr) + 1) * sizeof(WCHAR);

    //
    // Allocate memory for Unicode string
    //

    if (bAllocate)
    {
        *ppwszUnicodeStr =  (PWSTR)MemAlloc(dwLen);
        if (! (*ppwszUnicodeStr))
        {
            WARNING((__TEXT("Error allocating memory for Unicode name\n")));
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return FALSE;
        }
    }

    //
    // Convert Ansi string to Unicode
    //

    if (! MultiByteToWideChar(CP_ACP, 0, pszAnsiStr, -1,
            *ppwszUnicodeStr, dwLen))
    {
        WARNING((__TEXT("Error converting to Unicode name\n")));
        MemFree(*ppwszUnicodeStr);
        *ppwszUnicodeStr = NULL;
        return FALSE;
    }

    return TRUE;
}


/******************************************************************************
 *
 *                              ConvertToAnsi
 *
 *  Function:
 *       This function converts a given Unicode string to Ansi. It optionally
 *       allocates memory for the Ansi string which the calling program needs
 *       to free.
 *
 *  Arguments:
 *       pwszUnicodeStr  - pointer to Unicode string to convert
 *       ppszAnsiStr     - pointer to pointer to Ansi string.
 *       bAllocate       - If TRUE, allocate memory for Ansi string
 *
 *  Returns:
 *       TRUE if successful, FALSE otherwise
 *
 ******************************************************************************/

BOOL
ConvertToAnsi(
    PCWSTR  pwszUnicodeStr,
    PSTR   *ppszAnsiStr,
    BOOL    bAllocate
    )
{
    DWORD dwLen;                    // length of Ansi string
    BOOL  bUsedDefaultChar;         // if default characters were used in
                                    // converting Unicode to Ansi

    dwLen = (lstrlenW(pwszUnicodeStr) + 1) * sizeof(char);

    //
    // Allocate memory for Ansi string
    //

    if (bAllocate)
    {
        *ppszAnsiStr = (PSTR)MemAlloc(dwLen);
        if (! (*ppszAnsiStr))
        {
            WARNING((__TEXT("Error allocating memory for ANSI name\n")));
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return FALSE;
        }
    }

    //
    // Convert Unicode string to Ansi
    //

    if (! WideCharToMultiByte(CP_ACP, 0, pwszUnicodeStr, -1, *ppszAnsiStr,
            dwLen, NULL, &bUsedDefaultChar) || bUsedDefaultChar)
    {
        WARNING((__TEXT("Error converting to Ansi name\n")));
        
        if (bAllocate)
        {
            MemFree(*ppszAnsiStr);
            *ppszAnsiStr = NULL;
        }
        
        return FALSE;
    }

    return TRUE;
}

/******************************************************************************
 *
 *                         ValidColorMatchingModule
 *
 *  Function:
 *
 *  Arguments:
 *       cmmID   - ID identifing the CMM
 *       pCMMDll - pointer to CMM module path and file name
 *
 *  Returns:
 *
 ******************************************************************************/

BOOL
ValidColorMatchingModule(
    DWORD cmmID,
    PTSTR pCMMDll
    )
{
    HINSTANCE hInstance = NULL;
    DWORD    (WINAPI *pfnCMGetInfo)(DWORD);
    FARPROC   pfnCMRequired;
    DWORD     i;
    BOOL      rc = FALSE;       // Assume failure

    //
    // Load the CMM
    //

    hInstance = LoadLibrary(pCMMDll);

    if (!hInstance)
    {
        WARNING((__TEXT("Could not load CMM %s\n"), pCMMDll));
        goto EndValidColorMatchingModule;
    }

    (PVOID) pfnCMGetInfo = (PVOID) GetProcAddress(hInstance, gszCMMReqFns[0]);

    if (!pfnCMGetInfo)
    {
        ERR((__TEXT("CMM does not export CMGetInfo\n")));
        goto EndValidColorMatchingModule;
    }

    //
    // Check if the CMM is the right version and reports the same ID
    //

    if ((pfnCMGetInfo(CMM_VERSION) < 0x00050000) ||
        (pfnCMGetInfo(CMM_IDENT) != cmmID))
    {
        ERR((__TEXT("CMM %s not correct version or reports incorrect ID\n"), pCMMDll));
        goto EndValidColorMatchingModule;
    }

    //
    // Check the remaining required functions is presented
    //

    for (i=1; i<NUM_REQ_FNS; i++)
    {
        pfnCMRequired = GetProcAddress(hInstance, gszCMMReqFns[i]);
        if (!pfnCMRequired)
        {
            ERR((__TEXT("CMM %s does not export %s\n"), pCMMDll, gszCMMReqFns[i]));
            goto EndValidColorMatchingModule;
        }
    }

    rc = TRUE;

EndValidColorMatchingModule:

    if (hInstance)
    {
        FreeLibrary(hInstance);
    }

    return rc;
}


/******************************************************************************
 *
 *                         GetColorMatchingModule
 *
 *  Function:
 *       This functions returns a pointer to a CMMObject corresponding to
 *       the ID given. It first looks a the list of CMM objects loaded
 *       into memory, and if it doesn't find the right one, loads it.
 *
 *  Arguments:
 *       cmmID   - ID identifing the CMM
 *
 *  Returns:
 *       Pointer to the CMM object if successful, NULL otherwise
 *
 ******************************************************************************/

PCMMOBJ
GetColorMatchingModule(
    DWORD cmmID
    )
{
    HANDLE    hCMMObj;
    PCMMOBJ   pCMMObj = NULL;
    FARPROC   *ppTemp;
    HINSTANCE hInstance = NULL;
    HKEY      hkCMM = NULL;
    DWORD     dwTaskID;
    TCHAR     szCMMID[5];
    DWORD     dwType, bufSize, i;
    TCHAR     szBuffer[MAX_PATH];
    BOOL      rc = FALSE;       // Assume failure

    dwTaskID = GetCurrentProcessId();

    do {
        // Attempt CMM discovery till we find a valid CMM or exhaust the 
        // valid possibilities.
        
        // First search the already loaded modules for the requested CMM
        
        EnterCriticalSection(&critsec);     // Critical section
        pCMMObj = gpCMMChain;
    
        while (pCMMObj)
        {
            if ((pCMMObj->dwCMMID == cmmID) && (pCMMObj->dwTaskID == dwTaskID))
            {
                pCMMObj->objHdr.dwUseCount++;
                break;
            }
            pCMMObj = pCMMObj->pNext;
        }
        LeaveCriticalSection(&critsec);     // Critical section
    
        if (pCMMObj)
        {
            // Exit point - we need to clean up anything we allocated
            // in this loop.
            
            if (hkCMM)
            {
                RegCloseKey(hkCMM);
            }
            
            // note: we don't cleanup hInstance here because there's no way
            // to loop back with a loaded CMM
            
            ASSERT(hInstance==NULL);

            return pCMMObj;
        }
    
        // The CMM was not already loaded.
    
        // Try load the registry CMM before attempting to load the default
        // CMM. This will allow 3rd party vendors to add their own CMMs that
        // redefine the system default CMM without having to circumvent SFP.
        // To redefine the system default CMM, define 'Win ' in the registry.
        // See gszICMatcher for the key to add.
        // If we're iterating the discovery process and we've already opened
        // the key, avoid leaking by opening it again.
    
        if ((NULL == hkCMM) &&
            (ERROR_SUCCESS != 
             RegOpenKey(HKEY_LOCAL_MACHINE, gszICMatcher, &hkCMM)))
        {
            goto OpenDefaultCMM;
        }
    
        // Make a string with the CMM ID
    
    #ifdef UNICODE
        {
            DWORD temp = FIX_ENDIAN(cmmID);
    
            if (!MultiByteToWideChar(CP_ACP, 0, (PSTR)&temp, 4, szCMMID, 5))
            {
                WARNING((__TEXT("Could not convert cmmID %x to Unicode\n"), temp));
                goto OpenDefaultCMM;
            }
        }
    #else
        for (i=0; i<4; i++)
        {
            szCMMID[i] = ((PSTR)&cmmID)[3-i];
        }
    #endif
        szCMMID[4] = '\0';
    
        // Get the file name of the CMM dll if registered.
    
        bufSize = MAX_PATH;
        if (ERROR_SUCCESS != 
            RegQueryValueEx(
                hkCMM, (PTSTR)szCMMID, 0, 
                &dwType, (BYTE *)szBuffer, &bufSize
            ))
        {
            WARNING((__TEXT("CMM %s not registered\n"), szCMMID));
            goto OpenDefaultCMM;
        }
    
        // Attempt to load the CMM referenced in the registry.
    
        hInstance = LoadLibrary(szBuffer);
    
    
    OpenDefaultCMM:
    
        if(!hInstance)
        {
            // If we failed to load the registry version, or the registry
            // entry was not present, try load the default CMM. Note that 
            // the default CMM could be remapped in the registry.
            
            if(CMM_WINDOWS_DEFAULT != cmmID)
            {
                // Try again with the default CMM
                // It's possible that the default CMM was remapped, so we
                // re-attempt the discovery process with the new cmmID.
                
                cmmID = CMM_WINDOWS_DEFAULT;
            }
            else
            {
                // We're loading the default cmmID and the it was not remapped
                // or we failed to load a remapped default properly using the 
                // registry name. 
                // Fall back to the system default CMM.
                
                hInstance = LoadLibrary(gszDefaultCMM);
                
                // There is no fallback for this case. If we can't get the 
                // system default CMM we must bail.
                
                break;
            }
        }
    } while(!hInstance);


    if (!hInstance)
    {
        // There were no valid possibilities for the CMM. 
        // Note that we will only hit this case if we failed to load the 
        // preferred CMM _and_ failed to fall back to the system CMM.
        
        WARNING((__TEXT("Could not load CMM %x\n"), cmmID));
        goto EndGetColorMatchingModule;
    }

    //
    // Allocate a CMM object
    //

    hCMMObj = AllocateHeapObject(OBJ_CMM);
    if (!hCMMObj)
    {
        ERR((__TEXT("Could not allocate CMM object\n")));
        goto EndGetColorMatchingModule;
    }

    pCMMObj = (PCMMOBJ)HDLTOPTR(hCMMObj);

    ASSERT(pCMMObj != NULL);

    //
    // Fill in the CMM object
    //

    pCMMObj->objHdr.dwUseCount = 1;
    pCMMObj->dwCMMID = cmmID;
    pCMMObj->dwTaskID = dwTaskID;
    pCMMObj->hCMM = hInstance;

    ppTemp = (FARPROC *)&pCMMObj->fns.pCMGetInfo;
    *ppTemp = GetProcAddress(hInstance, gszCMMReqFns[0]);
    ppTemp++;

    if (!pCMMObj->fns.pCMGetInfo)
    {
        ERR((__TEXT("CMM does not export CMGetInfo\n")));
        goto EndGetColorMatchingModule;
    }

    //
    // Check if the CMM is the right version and reports the same ID
    //

    if (pCMMObj->fns.pCMGetInfo(CMM_VERSION) < 0x00050000 ||
        pCMMObj->fns.pCMGetInfo(CMM_IDENT) != cmmID)
    {
        ERR((__TEXT("CMM not correct version or reports incorrect ID\n")));
        goto EndGetColorMatchingModule;
    }

    //
    // Load the remaining required functions
    //

    for (i=1; i<NUM_REQ_FNS; i++)
    {
        *ppTemp = GetProcAddress(hInstance, gszCMMReqFns[i]);
        if (!*ppTemp)
        {
            ERR((__TEXT("CMM %s does not export %s\n"), szCMMID, gszCMMReqFns[i]));
            goto EndGetColorMatchingModule;
        }
        ppTemp++;
    }

    //
    // Load the optional functions
    //

    for (i=0; i<NUM_OPT_FNS; i++)
    {
        *ppTemp = GetProcAddress(hInstance, gszCMMOptFns[i]);

        //
        // Even these functions are required for Windows default CMM
        //

        if (cmmID == CMM_WINDOWS_DEFAULT && !*ppTemp)
        {
            ERR((__TEXT("Windows default CMM does not export %s\n"), gszCMMOptFns[i]));
            goto EndGetColorMatchingModule;
        }
        ppTemp++;
    }

    //
    // Load the PS functions - these are optional even for the default CMM
    //

    for (i=0; i<NUM_PS_FNS; i++)
    {
        *ppTemp = GetProcAddress(hInstance, gszPSFns[i]);
        ppTemp++;
    }

    //
    // If any of the PS Level2 fns is not exported, do not use this CMM
    // for any of the PS Level 2 functionality
    //

    if (!pCMMObj->fns.pCMGetPS2ColorSpaceArray ||
        !pCMMObj->fns.pCMGetPS2ColorRenderingIntent ||
        !pCMMObj->fns.pCMGetPS2ColorRenderingDictionary)
    {
        pCMMObj->fns.pCMGetPS2ColorSpaceArray = NULL;
        pCMMObj->fns.pCMGetPS2ColorRenderingIntent = NULL;
        pCMMObj->fns.pCMGetPS2ColorRenderingDictionary = NULL;
        pCMMObj->dwFlags |= CMM_DONT_USE_PS2_FNS;
    }

    //
    // Add the CMM object to the chain at the beginning
    //

    EnterCriticalSection(&critsec);     // Critical section
    pCMMObj->pNext = gpCMMChain;
    gpCMMChain = pCMMObj;
    LeaveCriticalSection(&critsec);     // Critical section

    rc = TRUE;                          // Success!

EndGetColorMatchingModule:

    if (!rc)
    {
        if (pCMMObj)
        {
            pCMMObj->objHdr.dwUseCount--;   // decrement before freeing
            FreeHeapObject(hCMMObj);
            pCMMObj = NULL;
        }
        if (hInstance)
        {
            FreeLibrary(hInstance);
        }
    }

    if (hkCMM)
    {
        RegCloseKey(hkCMM);
    }

    return pCMMObj;
}


/******************************************************************************
 *
 *                         GetPreferredCMM
 *
 *  Function:
 *       This functions returns a pointer to the app specified CMM to use
 *
 *  Arguments:
 *       None
 *
 *  Returns:
 *       Pointer to app specified CMM object on success, NULL otherwise
 *
 ******************************************************************************/

PCMMOBJ GetPreferredCMM(
    )
{
    PCMMOBJ pCMMObj;

    EnterCriticalSection(&critsec);     // Critical section
    pCMMObj = gpPreferredCMM;

    if (pCMMObj)
    {
        //
        // Increment use count
        //

        pCMMObj->objHdr.dwUseCount++;
    }
    LeaveCriticalSection(&critsec);     // Critical section

    return pCMMObj;
}


/******************************************************************************
 *
 *                         ReleaseColorMatchingModule
 *
 *  Function:
 *       This functions releases a CMM object. If the ref count goes to
 *       zero, it unloads the CMM and frees all memory associated with it.
 *
 *  Arguments:
 *       pCMMObj  - pointer to CMM object to release
 *
 *  Returns:
 *       No return value
 *
 ******************************************************************************/

VOID
ReleaseColorMatchingModule(
    PCMMOBJ pCMMObj
    )
{
    EnterCriticalSection(&critsec);     // Critical section

    ASSERT(pCMMObj->objHdr.dwUseCount > 0);

    pCMMObj->objHdr.dwUseCount--;

    if (pCMMObj->objHdr.dwUseCount == 0)
    {
        //
        // Unloading the CMM everytime a transform is freed might not be
        // very efficient. So for now, I am not going to unload it. When
        // the app terminates, kernel should unload all dll's loaded by
        // this app
        //
    }
    LeaveCriticalSection(&critsec);     // Critical section

    return;
}


#if DBG

/******************************************************************************
 *
 *                              MyDebugPrint
 *
 *  Function:
 *       This function takes a format string and paramters, composes a string
 *       and sends it out to the debug port. Available only in debug build.
 *
 *  Arguments:
 *       pFormat  - pointer to format string
 *       .......  - parameters based on the format string like printf()
 *
 *  Returns:
 *       No return value
 *
 ******************************************************************************/

VOID
MyDebugPrintA(
    PSTR pFormat,
    ...
    )
{
    char     szBuffer[256];
    va_list  arglist;

    va_start(arglist, pFormat);
    wvsprintfA(szBuffer, pFormat, arglist);
    va_end(arglist);

    OutputDebugStringA(szBuffer);

    return;
}


VOID
MyDebugPrintW(
    PWSTR pFormat,
    ...
    )
{
    WCHAR    szBuffer[256];
    va_list  arglist;

    va_start(arglist, pFormat);
    wvsprintfW(szBuffer, pFormat, arglist);
    va_end(arglist);

    OutputDebugStringW(szBuffer);

    return;
}

/******************************************************************************
 *
 *                              StripDirPrefixA
 *
 *  Function:
 *       This function takes a path name and returns a pointer to the filename
 *       part. This is availabel only for the debug build.
 *
 *  Arguments:
 *       pszPathName - path name of file (can be file name alone)
 *
 *  Returns:
 *       A pointer to the file name
 *
 ******************************************************************************/

PSTR
StripDirPrefixA(
    PSTR pszPathName
    )
{
    DWORD dwLen = lstrlenA(pszPathName);

    pszPathName += dwLen - 1;       // go to the end

    while (*pszPathName != '\\' && dwLen--)
    {
        pszPathName--;
    }

    return pszPathName + 1;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\mscms\color.c ===
/****************************Module*Header******************************\
* Module Name: COLOR.C
*
* Module Descripton: Functions for color matching outside the DC
*
* Warnings:
*
* Issues:
*
* Public Routines:
*
* Created:  23 April 1996
* Author:   Srinivasan Chandrasekar    [srinivac]
*
* Copyright (c) 1996, 1997  Microsoft Corporation
\***********************************************************************/

#include "mscms.h"
#include "wingdip.h" /* for LCS_DEVICE_CMYK */

//
// Local functions
//

HTRANSFORM InternalCreateColorTransform(LPLOGCOLORSPACE, HPROFILE, HPROFILE, DWORD);
BOOL       InternalRegisterCMM(PTSTR, DWORD, PTSTR);
BOOL       InternalUnregisterCMM(PTSTR, DWORD);
DWORD      GetBitmapBytes(BMFORMAT, DWORD, DWORD);


/******************************************************************************
 *
 *                            CreateColorTransform
 *
 *  Function:
 *       These are the ANSI & Unicode wrappers for InternalCreateColorTransform.
 *       Please see InternalCreateColorTransform for more details on this
 *       function.
 *
 *  Arguments:
 *       pLogColorSpace - pointer to LOGCOLORSPACE structure identifying
 *                        source color space
 *       hDestProfile   - handle identifing the destination profile object
 *       hTargetProfile - handle identifing the target profile object
 *       dwFlags        - optimization flags
 *
 *  Returns:
 *       Handle to color transform if successful, NULL otherwise
 *
 ******************************************************************************/

#ifdef UNICODE              // Windows NT version

HTRANSFORM WINAPI CreateColorTransformA(
    LPLOGCOLORSPACEA pLogColorSpace,
    HPROFILE         hDestProfile,
    HPROFILE         hTargetProfile,
    DWORD            dwFlags
    )
{
    LOGCOLORSPACEW  wLCS;

    TRACEAPI((__TEXT("CreateColorTransformA\n")));

    //
    // Validate parameter before we touch it
    //

    if (IsBadReadPtr(pLogColorSpace, sizeof(LOGCOLORSPACEA)))
    {
        WARNING((__TEXT("Invalid parameter to CreateColorTransform\n")));
        SetLastError(ERROR_INVALID_PARAMETER);
        return NULL;
    }

    CopyMemory(&wLCS, pLogColorSpace, sizeof(LOGCOLORSPACEA));
    wLCS.lcsSize = sizeof(LOGCOLORSPACEW);

    //
    // Convert filename to Unicode and call the internal version
    //

    if (! MultiByteToWideChar(CP_ACP, 0, pLogColorSpace->lcsFilename, -1,
        wLCS.lcsFilename, MAX_PATH))
    {
        WARNING((__TEXT("Error converting LogColorSpace filename to Unicode\n")));
        return NULL;
    }

    return InternalCreateColorTransform(&wLCS, hDestProfile, hTargetProfile, dwFlags);
}


HTRANSFORM WINAPI CreateColorTransformW(
    LPLOGCOLORSPACEW pLogColorSpace,
    HPROFILE         hDestProfile,
    HPROFILE         hTargetProfile,
    DWORD            dwFlags
    )
{
    TRACEAPI((__TEXT("CreateColorTransformW\n")));

    //
    // Internal version is Unicode in Windows NT, call it directly
    //

    return InternalCreateColorTransform(pLogColorSpace, hDestProfile, hTargetProfile, dwFlags);
}

#else                   // Windows 95 version

HTRANSFORM WINAPI CreateColorTransformA(
    LPLOGCOLORSPACEA pLogColorSpace,
    HPROFILE         hDestProfile,
    HPROFILE         hTargetProfile,
    DWORD            dwFlags
    )
{
    TRACEAPI((__TEXT("CreateColorTransformA\n")));

    //
    // Internal version is ANSI in Windows 95, call it directly
    //

    return InternalCreateColorTransform(pLogColorSpace, hDestProfile, hTargetProfile, dwFlags);
}


HTRANSFORM WINAPI CreateColorTransformW(
    LPLOGCOLORSPACEW  pLogColorSpace,
    HPROFILE          hDestProfile,
    HPROFILE          hTargetProfile,
    DWORD             dwFlags
    )
{
    LOGCOLORSPACEA  aLCS;
    BOOL            bUsedDefaultChar;

    TRACEAPI((__TEXT("CreateColorTransformW\n")));

    //
    // Validate parameter before we touch it
    //

    if (IsBadReadPtr(pLogColorSpace, sizeof(LOGCOLORSPACEW)))
    {
        WARNING((__TEXT("Invalid parameter to CreateColorTransform\n")));
        SetLastError(ERROR_INVALID_PARAMETER);
        return NULL;
    }

    CopyMemory(&aLCS, pLogColorSpace, sizeof(LOGCOLORSPACEA));
    aLCS.lcsSize = sizeof(LOGCOLORSPACEA);

    //
    // Convert filename to ANSI and call the internal version
    //

    if (! WideCharToMultiByte(CP_ACP, 0, pLogColorSpace->lcsFilename, -1,
        aLCS.lcsFilename, MAX_PATH, NULL, &bUsedDefaultChar) ||
        bUsedDefaultChar)
    {
        WARNING((__TEXT("Error converting LogColorSpace filename to ANSI\n")));
        return NULL;
    }

    return InternalCreateColorTransform(&aLCS, hDestProfile, hTargetProfile, dwFlags);
}

#endif


/******************************************************************************
 *
 *                        CreateMultiProfileTransform
 *
 *  Function:
 *       This functions creates a color transform from a set of profiles.
 *
 *  Arguments:
 *       pahProfiles       - pointer to array of handles of profiles
 *       nProfiles         - number of profiles in array
 *       padwIntent        - array of intents to use
 *       nIntents          - size of array - can be 1 or nProfiles
 *       dwFlags           - optimization flags
 *       indexPreferredCMM - one based index of profile which specifies
 *                           preferred CMM to use.
 *
 *  Returns:
 *       Handle to color transform if successful, NULL otherwise
 *
 ******************************************************************************/

HTRANSFORM WINAPI CreateMultiProfileTransform(
    PHPROFILE   pahProfiles,
    DWORD       nProfiles,
    PDWORD      padwIntent,
    DWORD       nIntents,
    DWORD       dwFlags,
    DWORD       indexPreferredCMM
    )
{
    PPROFOBJ      pProfObj;
    PCMMOBJ       pCMMObj = NULL;
    DWORD         cmmID;
    HTRANSFORM    hxform = NULL;
    PTRANSFORMOBJ pxformObj;
    DWORD         i;

    TRACEAPI((__TEXT("CreateMultiProfileTransform\n")));

    //
    // Validate parameters
    //

    if (nProfiles < 1 ||
        indexPreferredCMM > nProfiles ||
        IsBadReadPtr(pahProfiles, nProfiles * sizeof(HANDLE)) ||
        padwIntent == NULL ||
        ((nIntents != nProfiles) && (nIntents != 1)) ||
        IsBadReadPtr(padwIntent, nIntents * sizeof(DWORD)))
    {
        WARNING((__TEXT("Invalid parameter to CreateMultiProfileTransform\n")));
        SetLastError(ERROR_INVALID_PARAMETER);
        return NULL;
    }

    for (i=0; i<nProfiles; i++)
    {
        if (pahProfiles[i] == NULL ||
            ! ValidHandle(pahProfiles[i], OBJ_PROFILE))
        {
            WARNING((__TEXT("Invalid profile passed to CreateMultiProfileTransform\n")));
            SetLastError(ERROR_INVALID_PARAMETER);
            return NULL;
        }

        pProfObj = (PPROFOBJ)HDLTOPTR(pahProfiles[i]);

        ASSERT(pProfObj != NULL);

        //
        // Quick check on the integrity of the profile
        //

        if (!ValidProfile(pProfObj))
        {
            WARNING((__TEXT("Invalid profile passed to CreateMultiProfileTransform\n")));
            SetLastError(ERROR_INVALID_PROFILE);
            return NULL;
        }

        ASSERT(pProfObj->pView != NULL);

        if (i+1 == indexPreferredCMM)
        {
            //
            // Get ID of preferred CMM
            //

            cmmID = HEADER(pProfObj)->phCMMType;
            cmmID = FIX_ENDIAN(cmmID);
        }
    }

    if (indexPreferredCMM == INDEX_DONT_CARE)
    {
        pCMMObj = GetPreferredCMM();

        if (!pCMMObj)
        {
            // get the dest profile

            pProfObj = (PPROFOBJ)HDLTOPTR(pahProfiles[nProfiles-1]);

            //
            // Get ID of preferred CMM
            //

            cmmID = HEADER(pProfObj)->phCMMType;
            cmmID = FIX_ENDIAN(cmmID);

            pCMMObj  = GetColorMatchingModule(cmmID);
        }
    }
    else
    {
        //
        // Get CMM associated with preferred profile
        //

        pCMMObj  = GetColorMatchingModule(cmmID);
    }

    //
    // Finally try Windows default CMM
    //

    if (!pCMMObj)
    {
        pCMMObj = GetColorMatchingModule(CMM_WINDOWS_DEFAULT);
        if (!pCMMObj)
        {
            RIP((__TEXT("Default CMM not found\n")));
            SetLastError(ERROR_INVALID_CMM);
            return NULL;
        }
    }

    //
    // Allocate an object on the heap for the transform
    //

    hxform = AllocateHeapObject(OBJ_TRANSFORM);
    if (!hxform)
    {
        WARNING((__TEXT("Could not allocate transform object\n")));
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        ReleaseColorMatchingModule(pCMMObj);
        return NULL;
    }

    pxformObj = (PTRANSFORMOBJ)HDLTOPTR(hxform);

    ASSERT(pxformObj != NULL);

    ASSERT(pCMMObj->fns.pCMCreateMultiProfileTransform != NULL);

    pxformObj->pCMMObj = pCMMObj;
    pxformObj->objHdr.dwUseCount = 1;

    pxformObj->hcmxform = pCMMObj->fns.pCMCreateMultiProfileTransform(
                            pahProfiles,
                            nProfiles,
                            padwIntent,
                            nIntents,
                            dwFlags);

    TERSE((__TEXT("CMCreateMultiProfileTransform returned 0x%x\n"), pxformObj->hcmxform));

    //
    // If return value from CMM is less than 256, then it is an error code
    //

    if (pxformObj->hcmxform <= TRANSFORM_ERROR)
    {
        WARNING((__TEXT("CMCreateMultiProfileTransform failed\n")));
        if (GetLastError() == ERROR_SUCCESS)
        {
            WARNING((__TEXT("CMM did not set error code\n")));
            SetLastError(ERROR_INVALID_PROFILE);
        }
        ReleaseColorMatchingModule(pxformObj->pCMMObj);
        pxformObj->objHdr.dwUseCount--;        // decrement before freeing
        FreeHeapObject(hxform);
        hxform = NULL;
    }

    return hxform;
}


/******************************************************************************
 *
 *                          DeleteColorTransform
 *
 *  Function:
 *       This functions deletes a color transform and frees all associated
 *       memory.
 *
 *  Arguments:
 *       hxform - handle to color transform to delete
 *
 *  Returns:
 *       TRUE if successful, FALSE otherwise
 *
 ******************************************************************************/

BOOL WINAPI DeleteColorTransform(
    HTRANSFORM  hxform
    )
{
    PTRANSFORMOBJ pxformObj;
    BOOL          rc;

    TRACEAPI((__TEXT("DeleteColorTransform\n")));

    //
    // Validate parameters
    //

    if (!ValidHandle(hxform, OBJ_TRANSFORM))
    {
        WARNING((__TEXT("Invalid parameter to DeleteColorTransform\n")));
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    pxformObj = (PTRANSFORMOBJ)HDLTOPTR(hxform);

    ASSERT(pxformObj != NULL);

    ASSERT(pxformObj->objHdr.dwUseCount > 0);

    //
    // Decrease  object count, and delete if it goes to zero.
    // The following code retains the object and returns failure if the CMM
    // fails the delete transform operation.
    //

    pxformObj->objHdr.dwUseCount--;

    if (pxformObj->objHdr.dwUseCount == 0)
    {
        ASSERT(pxformObj->pCMMObj != NULL);

        rc = pxformObj->pCMMObj->fns.pCMDeleteTransform(pxformObj->hcmxform);
        if (!rc)
        {
            pxformObj->objHdr.dwUseCount++;     // set count back
            return FALSE;
        }
        ReleaseColorMatchingModule(pxformObj->pCMMObj);
        FreeHeapObject(hxform);
    }

    return TRUE;
}


/******************************************************************************
 *
 *                          TranslateColors
 *
 *  Function:
 *       This functions translates an array of color strcutures using the
 *       given transform
 *
 *  Arguments:
 *       hxform         - handle to color transform to use
 *       paInputcolors  - pointer to array of input colors
 *       nColors        - number of colors in the array
 *       ctInput        - color type of input
 *       paOutputColors - pointer to buffer to get translated colors
 *       ctOutput       - output color type
 *
 *  Comments:
 *       Input and output color types must be consistent with the transform
 *
 *  Returns:
 *       TRUE if successful, FALSE otherwise
 *
 ******************************************************************************/

BOOL  WINAPI TranslateColors(
    HTRANSFORM  hxform,
    PCOLOR      paInputColors,
    DWORD       nColors,
    COLORTYPE   ctInput,
    PCOLOR      paOutputColors,
    COLORTYPE   ctOutput
    )
{
    PTRANSFORMOBJ pxformObj;
    BOOL          rc;

    TRACEAPI((__TEXT("TranslateColors\n")));

    //
    // Validate parameters
    //

    if (!ValidHandle(hxform, OBJ_TRANSFORM) ||
        (nColors == 0) ||
        IsBadReadPtr(paInputColors, nColors*sizeof(COLOR)) ||
        IsBadWritePtr(paOutputColors, nColors*sizeof(COLOR)))
    {
        WARNING((__TEXT("Invalid parameter to TranslateColors\n")));
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    pxformObj = (PTRANSFORMOBJ)HDLTOPTR(hxform);

    ASSERT(pxformObj != NULL);

    ASSERT(pxformObj->pCMMObj != NULL);

    rc = pxformObj->pCMMObj->fns.pCMTranslateColors(
            pxformObj->hcmxform,
            paInputColors,
            nColors,
            ctInput,
            paOutputColors,
            ctOutput);

    return rc;
}


/******************************************************************************
 *
 *                          CheckColors
 *
 *  Function:
 *       This functions checks if an array of colors fall within the output
 *       gamut of the given transform
 *
 *  Arguments:
 *       hxform         - handle to color transform to use
 *       paInputcolors  - pointer to array of input colors
 *       nColors        - number of colors in the array
 *       ctInput        - color type of input
 *       paResult       - pointer to buffer to hold the result
 *
 *  Comments:
 *       Input color type must be consistent with the transform
 *
 *  Returns:
 *       TRUE if successful, FALSE otherwise
 *
 ******************************************************************************/

BOOL  WINAPI CheckColors(
    HTRANSFORM      hxform,
    PCOLOR          paInputColors,
    DWORD           nColors,
    COLORTYPE       ctInput,
    PBYTE           paResult
    )
{
    PTRANSFORMOBJ pxformObj;
    BOOL          rc;

    TRACEAPI((__TEXT("CheckColors\n")));

    //
    // Validate parameters
    //

    if (!ValidHandle(hxform, OBJ_TRANSFORM) ||
        (nColors == 0) ||
        IsBadReadPtr(paInputColors, nColors * sizeof(COLOR)) ||
        IsBadWritePtr(paResult, nColors * sizeof(BYTE)))
    {
        WARNING((__TEXT("Invalid parameter to CheckColors\n")));
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    pxformObj = (PTRANSFORMOBJ)HDLTOPTR(hxform);

    ASSERT(pxformObj != NULL);

    ASSERT(pxformObj->pCMMObj != NULL);

    rc = pxformObj->pCMMObj->fns.pCMCheckColors(
            pxformObj->hcmxform,
            paInputColors,
            nColors,
            ctInput,
            paResult);

    return rc;
}


/******************************************************************************
 *
 *                          TranslateBitmapBits
 *
 *  Function:
 *       This functions translates the colors of a bitmap using the
 *       given transform
 *
 *  Arguments:
 *       hxform         - handle to color transform to use
 *       pSrcBits       - pointer to source bitmap
 *       bmInput        - input bitmap format
 *       dwWidth        - width in pixels of each scanline
 *       dwHeight       - number of scanlines in bitmap
 *       dwInputStride  - number of bytes from beginning of one scanline to next
 *                        in input buffer, 0 means DWORD aligned
 *       pDestBits      - pointer to destination bitmap to store results
 *       bmOutput       - output bitmap format
 *       dwOutputStride - number of bytes from beginning of one scanline to next
 *                        in output buffer, 0 means DWORD aligned
 *       pfnCallback    - callback function to report progress
 *       ulCallbackData - parameter to callback function
 *
 *  Comments:
 *       Input and output bitmap formats must be consistent with the transform
 *
 *  Returns:
 *       TRUE if successful, FALSE otherwise
 *
 ******************************************************************************/

BOOL  WINAPI TranslateBitmapBits(
    HTRANSFORM      hxform,
    PVOID           pSrcBits,
    BMFORMAT        bmInput,
    DWORD           dwWidth,
    DWORD           dwHeight,
    DWORD           dwInputStride,
    PVOID           pDestBits,
    BMFORMAT        bmOutput,
    DWORD           dwOutputStride,
    PBMCALLBACKFN   pfnCallback,
    LPARAM          ulCallbackData
)
{
    PTRANSFORMOBJ pxformObj;
    DWORD         nBytes, cbSize;
    BOOL          rc;

    TRACEAPI((__TEXT("TranslateBitmapBits\n")));

    //
    // Calculate number of bytes input bitmap should be
    //

    if (dwInputStride)
        cbSize = dwInputStride * dwHeight;
    else
        cbSize = GetBitmapBytes(bmInput, dwWidth, dwHeight);

    //
    // Calculate number of bytes output bitmap should be
    //

    if (dwOutputStride)
        nBytes = dwOutputStride * dwHeight;
    else
        nBytes = GetBitmapBytes(bmOutput, dwWidth, dwHeight);

    //
    // Validate parameters
    //

    if (nBytes == 0 ||
        cbSize == 0 ||
        !ValidHandle(hxform, OBJ_TRANSFORM) ||
        IsBadReadPtr(pSrcBits, cbSize) ||
        IsBadWritePtr(pDestBits, nBytes) ||
        (pfnCallback && IsBadCodePtr((FARPROC)pfnCallback)))
    {
        WARNING((__TEXT("Invalid parameter to TranslateBitmapBits\n")));
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    pxformObj = (PTRANSFORMOBJ)HDLTOPTR(hxform);

    ASSERT(pxformObj != NULL);

    ASSERT(pxformObj->pCMMObj != NULL);

    rc = pxformObj->pCMMObj->fns.pCMTranslateRGBsExt(
            pxformObj->hcmxform,
            pSrcBits,
            bmInput,
            dwWidth,
            dwHeight,
            dwInputStride,
            pDestBits,
            bmOutput,
            dwOutputStride,
            pfnCallback,
            ulCallbackData);

    return rc;
}


/******************************************************************************
 *
 *                           CheckBitmapBits
 *
 *  Function:
 *       This functions checks if the colors of a bitmap fall within the
 *       output gamut of the given transform
 *
 *  Arguments:
 *       hxform         - handle to color transform to use
 *       pSrcBits       - pointer to source bitmap
 *       bmInput        - input bitmap format
 *       dwWidth        - width in pixels of each scanline
 *       dwHeight       - number of scanlines in bitmap
 *       dwStride       - number of bytes from beginning of one scanline to next
 *       paResult       - pointer to buffer to hold the result
 *       pfnCallback    - callback function to report progress
 *       ulCallbackData - parameter to callback function
 *
 *  Comments:
 *       Input bitmap format must be consistent with the transform
 *
 *  Returns:
 *       TRUE if successful, FALSE otherwise
 *
 ******************************************************************************/

BOOL  WINAPI CheckBitmapBits(
    HTRANSFORM      hxform,
    PVOID           pSrcBits,
    BMFORMAT        bmInput,
    DWORD           dwWidth,
    DWORD           dwHeight,
    DWORD           dwStride,
    PBYTE           paResult,
    PBMCALLBACKFN   pfnCallback,
    LPARAM          ulCallbackData
)
{
    PTRANSFORMOBJ pxformObj;
    DWORD         cbSize;
    BOOL          rc;

    TRACEAPI((__TEXT("CheckBitmapBits\n")));

    //
    // Calculate number of bytes input bitmap should be
    //

    if (dwStride)
        cbSize = dwStride*dwHeight;
    else
        cbSize = GetBitmapBytes(bmInput, dwWidth, dwHeight);

    //
    // Validate parameters
    //

    if (!ValidHandle(hxform, OBJ_TRANSFORM) ||
        cbSize == 0 ||
        IsBadReadPtr(pSrcBits, cbSize) ||
        IsBadWritePtr(paResult, dwWidth*dwHeight) ||
        (pfnCallback && IsBadCodePtr((FARPROC)pfnCallback)))
    {
        WARNING((__TEXT("Invalid parameter to CheckBitmapBits\n")));
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    pxformObj = (PTRANSFORMOBJ)HDLTOPTR(hxform);

    ASSERT(pxformObj != NULL);

    ASSERT(pxformObj->pCMMObj != NULL);

    rc = pxformObj->pCMMObj->fns.pCMCheckRGBs(
            pxformObj->hcmxform,
            pSrcBits,
            bmInput,
            dwWidth,
            dwHeight,
            dwStride,
            paResult,
            pfnCallback,
            ulCallbackData);

    return rc;
}


/******************************************************************************
 *
 *                           GetCMMInfo
 *
 *  Function:
 *       This functions retrieves information about the CMM that created the
 *       given transform
 *
 *  Arguments:
 *       hxform         - handle to color transform
 *       dwInfo         - Can be one of the following:
 *                        CMM_WIN_VERSION: Version of Windows support
 *                        CMM_DLL_VERSION: Version of CMM
 *                        CMM_IDENT:       CMM signature registered with ICC
 *
 *  Returns:
 *       For CMM_WIN_VERSION, it returns the Windows version it was written for.
 *       For CMM_DLL_VERSION, it returns the version number of the CMM DLL.
 *       For CMM_IDENT, it returns the CMM signature registered with the ICC.
 *       If the function fails it returns zero.
 *
 ******************************************************************************/

DWORD  WINAPI GetCMMInfo(
        HTRANSFORM      hxform,
        DWORD           dwInfo
        )
{
    PTRANSFORMOBJ pxformObj;
    BOOL          rc;

    TRACEAPI((__TEXT("GetCMMInfo\n")));

    //
    // Validate parameters
    //

    if (!ValidHandle(hxform, OBJ_TRANSFORM) ||
        (dwInfo != CMM_WIN_VERSION &&
         dwInfo != CMM_DLL_VERSION &&
         dwInfo != CMM_IDENT
         )
        )
    {
        WARNING((__TEXT("Invalid parameter to GetCMMInfo\n")));
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    pxformObj = (PTRANSFORMOBJ)HDLTOPTR(hxform);

    ASSERT(pxformObj != NULL);

    ASSERT(pxformObj->pCMMObj != NULL);

    rc = pxformObj->pCMMObj->fns.pCMGetInfo(dwInfo);

    return rc;
}


/******************************************************************************
 *
 *                              RegisterCMM
 *
 *  Function:
 *       These are the ANSI and Unicode wrappers. For more information on this
 *       function, see InternalRegisterCMM.
 *
 *  Arguments:
 *       pMachineName   - name identifying machine on which the CMM should be
 *                        registered
 *       cmmID          - ID of CMM to register
 *       pCMMdll        - pointer to CMM dll to register
 *
 *  Returns:
 *       TRUE if successful, FALSE otherwise
 *
 ******************************************************************************/

#ifdef UNICODE              // Windows NT version

BOOL  WINAPI RegisterCMMA(
    PCSTR       pMachineName,
    DWORD       cmmID,
    PCSTR       pCMMdll
    )
{
    PWSTR pwszMachineName = NULL;   // Unicode machine name
    PWSTR pwszCMMdll = NULL;        // Unicode CMM dll path
    BOOL  rc = TRUE;                // return code

    TRACEAPI((__TEXT("RegisterCMMA\n")));

    //
    // Convert machine name to Unicode
    //

    if (pMachineName)
    {
        rc = ConvertToUnicode(pMachineName, &pwszMachineName, TRUE);
    }
    else
        pwszMachineName = NULL;

    //
    // Convert pCMMdll to Unicode
    //

    rc = rc && ConvertToUnicode(pCMMdll, &pwszCMMdll, TRUE);


    //
    // Call the internal Unicode function
    //

    rc = rc && InternalRegisterCMM(pwszMachineName, cmmID, pwszCMMdll);

    //
    // Free memory before leaving
    //

    if (pwszMachineName)
    {
        MemFree(pwszMachineName);
    }

    if (pwszCMMdll)
    {
        MemFree(pwszCMMdll);
    }

    return rc;
}


BOOL  WINAPI RegisterCMMW(
    PCWSTR      pMachineName,
    DWORD       cmmID,
    PCWSTR      pCMMdll
    )
{
    TRACEAPI((__TEXT("RegisterCMMW\n")));

    //
    // Internal version is Unicode in Windows NT, call it directly
    //

    return InternalRegisterCMM((PWSTR)pMachineName, cmmID, (PWSTR)pCMMdll);
}

#else                   // Windows 95 version

BOOL  WINAPI RegisterCMMA(
    PCSTR       pMachineName,
    DWORD       cmmID,
    PCSTR       pCMMdll
    )
{
    TRACEAPI((__TEXT("RegisterCMMA\n")));

    //
    // Internal version is ANSI in Windows 95, call it directly
    //

    return InternalRegisterCMM((PSTR)pMachineName, cmmID, (PSTR)pCMMdll);
}


BOOL  WINAPI RegisterCMMW(
    PCWSTR      pMachineName,
    DWORD       cmmID,
    PCWSTR      pCMMdll
    )
{
    PSTR  pszMachineName = NULL;    // Ansi machine name
    PSTR  pszCMMdll = NULL;         // Ansi CMM dll path
    BOOL  rc = TRUE;                // return code

    TRACEAPI((__TEXT("RegisterCMMW\n")));

    //
    // Convert machine name to Ansi
    //

    if (pMachineName)
    {
        rc = ConvertToAnsi(pMachineName, &pszMachineName, TRUE);
    }
    else
        pszMachineName = NULL;

    //
    // Convert pCMMdll to Ansi
    //

    rc = rc && ConvertToAnsi(pCMMdll, &pszCMMdll, TRUE);

    //
    // Call the internal Ansi function
    //

    rc = rc && InternalRegisterCMM(pszMachineName, cmmID, pszCMMdll);

    //
    // Free memory before leaving
    //

    if (pszMachineName)
    {
        MemFree(pszMachineName);
    }

    if (pszCMMdll)
    {
        MemFree(pszCMMdll);
    }

    return rc;
}

#endif


/******************************************************************************
 *
 *                            UnregisterCMM
 *
 *  Function:
 *       These are the ANSI and Unicode wrappers. For more information on this
 *       function, see InternalUnregisterCMM.
 *
 *  Arguments:
 *       pMachineName   - name identifying machine on which the CMM is
 *                        registered
 *       cmmID          - ID of CMM to unregister
 *
 *  Returns:
 *       TRUE if successful, FALSE otherwise
 *
 ******************************************************************************/

#ifdef UNICODE              // Windows NT version

BOOL  WINAPI UnregisterCMMA(
    PCSTR   pMachineName,
    DWORD   cmmID
    )
{
    PWSTR pwszMachineName = NULL;   // Unicode machine name
    BOOL  rc = TRUE;                // return code

    TRACEAPI((__TEXT("UnregisterCMMA\n")));

    //
    // Convert machine name to Unicode
    //

    if (pMachineName)
    {
        rc = ConvertToUnicode(pMachineName, &pwszMachineName, TRUE);
    }
    else
        pwszMachineName = NULL;

    //
    // Call the internal Unicode function
    //

    rc = rc && InternalUnregisterCMM(pwszMachineName, cmmID);

    //
    // Free memory before leaving
    //

    if (pwszMachineName)
    {
        MemFree(pwszMachineName);
    }

    return rc;
}


BOOL  WINAPI UnregisterCMMW(
    PCWSTR      pMachineName,
    DWORD       cmmID
    )
{
    TRACEAPI((__TEXT("UnregisterCMMW\n")));

    //
    // Internal version is Unicode in Windows NT, call it directly
    //

    return InternalUnregisterCMM((PWSTR)pMachineName, cmmID);
}

#else                   // Windows 95 version

BOOL  WINAPI UnregisterCMMA(
    PCSTR       pMachineName,
    DWORD       cmmID
    )
{
    TRACEAPI((__TEXT("UnregisterCMMA\n")));

    //
    // Internal version is ANSI in Windows 95, call it directly
    //

    return InternalUnregisterCMM((PSTR)pMachineName, cmmID);
}


BOOL  WINAPI UnregisterCMMW(
    PCWSTR      pMachineName,
    DWORD       cmmID
    )
{
    PSTR  pszMachineName = NULL;    // Ansi machine name
    BOOL  rc = TRUE;                // return code

    TRACEAPI((__TEXT("UnregisterCMMW\n")));

    //
    // Convert machine name to Ansi
    //

    if (pMachineName)
    {
        rc = ConvertToAnsi(pMachineName, &pszMachineName, TRUE);
    }
    else
        pszMachineName = NULL;

    //
    // Call the internal Ansi function
    //

    rc = rc && InternalUnregisterCMM(pszMachineName, cmmID);

    //
    // Free memory before leaving
    //

    if (pszMachineName)
    {
        MemFree(pszMachineName);
    }

    return rc;
}

#endif


/******************************************************************************
 *
 *                               SelectCMM
 *
 *  Function:
 *       This function allows an application to select the preferred CMM to use
 *
 *  Arguments:
 *       cmmID          - ID of preferred CMM to use
 *
 *  Returns:
 *       TRUE if successful, FALSE otherwise
 *
 ******************************************************************************/

BOOL  WINAPI SelectCMM(
        DWORD   dwCMMType
    )
{
    PCMMOBJ pCMMObj = NULL;

    TRACEAPI((__TEXT("SelectCMM\n")));

    if (dwCMMType)
    {
        pCMMObj  = GetColorMatchingModule(dwCMMType);
        if (!pCMMObj)
        {
            SetLastError(ERROR_INVALID_CMM);
            return FALSE;
        }
    }

    //
    // Update Preferred CMM
    //
    EnterCriticalSection(&critsec);         // Critical Section
    gpPreferredCMM = pCMMObj;
    LeaveCriticalSection(&critsec);         // Critical Section

    return TRUE;
}


/*****************************************************************************/
/***************************** Internal Functions ****************************/
/*****************************************************************************/

/******************************************************************************
 *
 *                         InternalCreateColorTransform
 *
 *  Function:
 *       This functions creates a color transform that translates from
 *       the logcolorspace to the optional target device color space to the
 *       destination device color space.
 *
 *  Arguments:
 *       pLogColorSpace - pointer to LOGCOLORSPACE structure identifying
 *                        source color space
 *       hDestProfile   - handle identifing the destination profile object
 *       hTargetProfile - handle identifing the target profile object
 *       dwFlags        - optimization flags
 *
 *  Returns:
 *       Handle to color transform if successful, NULL otherwise
 *
 ******************************************************************************/

HTRANSFORM InternalCreateColorTransform(
    LPLOGCOLORSPACE pLogColorSpace,
    HPROFILE        hDestProfile,
    HPROFILE        hTargetProfile,
    DWORD           dwFlags
    )
{
    PPROFOBJ         pDestProfObj, pTargetProfObj = NULL;
    PCMMOBJ          pCMMObj;
    DWORD            cmmID;
    HTRANSFORM       hxform = NULL;
    PTRANSFORMOBJ    pxformObj;
    LPLOGCOLORSPACE  pLCS;

    //
    // Validate parameters
    //

    if (!pLogColorSpace ||
        IsBadReadPtr(pLogColorSpace, sizeof(LOGCOLORSPACE)) ||
        pLogColorSpace->lcsSignature !=  LCS_SIGNATURE ||
        pLogColorSpace->lcsVersion < 0x00000400 ||
        !hDestProfile ||
        !ValidHandle(hDestProfile, OBJ_PROFILE) ||
        ((hTargetProfile != NULL) &&
         !ValidHandle(hTargetProfile, OBJ_PROFILE)
        )
       )
    {
        WARNING((__TEXT("Invalid parameter to CreateColorTransform\n")));
        SetLastError(ERROR_INVALID_PARAMETER);
        return NULL;
    }

    //
    // Allocate LogColorSpace and copy incoming data.
    // Leave space for passing in two handles below it
    //

    pLCS = (LPLOGCOLORSPACE)MemAlloc(sizeof(LOGCOLORSPACE) + 2*sizeof(HPROFILE));
    if (!pLCS)
    {
        WARNING((__TEXT("Could not allocate LogColorSpace")));
        return NULL;
    }
    CopyMemory((PVOID)pLCS, (PVOID)pLogColorSpace, sizeof(LOGCOLORSPACE));

    //
    // Copy handles below this structure
    //

    *((HPROFILE UNALIGNED *)((PBYTE)pLCS+sizeof(LOGCOLORSPACE))) = hDestProfile;
    *((HPROFILE UNALIGNED *)((PBYTE)pLCS+sizeof(LOGCOLORSPACE)+sizeof(HPROFILE))) = hTargetProfile;

    //
    // If input color space is a predefined color space,
    // find the right profile to use
    //

    if (pLCS->lcsCSType > LCS_DEVICE_CMYK)
    {
        DWORD cbSize = MAX_PATH;

        if (! GetStandardColorSpaceProfile(NULL, pLCS->lcsCSType,
                pLCS->lcsFilename, &cbSize))
        {
            WARNING((__TEXT("Could not get profile for predefined color space 0x%x\n"), pLCS->lcsCSType));
            goto EndCreateColorTransform;
        }
    }

    pDestProfObj = (PPROFOBJ)HDLTOPTR(hDestProfile);

    ASSERT(pDestProfObj != NULL);

    //
    // Quick check on the integrity of the profile before calling the CMM
    //

    if (!ValidProfile(pDestProfObj))
    {
        WARNING((__TEXT("Invalid dest profile passed to CreateColorTransform\n")));
        SetLastError(ERROR_INVALID_PROFILE);
        goto EndCreateColorTransform;
    }

    //
    // If target profile is given, get the profile object and check integrity
    //

    if (hTargetProfile)
    {
        pTargetProfObj = (PPROFOBJ)HDLTOPTR(hTargetProfile);

        ASSERT(pTargetProfObj != NULL);

        if (!ValidProfile(pTargetProfObj))
        {
            WARNING((__TEXT("Invalid target profile passed to CreateColorTransform\n")));
            SetLastError(ERROR_INVALID_PROFILE);
            goto EndCreateColorTransform;
        }
    }

    //
    // Check if application specified CMM is present
    //

    pCMMObj = GetPreferredCMM();
    if (!pCMMObj)
    {
        //
        // Get CMM associated with destination profile. If it does not exist,
        // get default CMM.
        //

        cmmID = HEADER(pDestProfObj)->phCMMType;
        cmmID = FIX_ENDIAN(cmmID);

        pCMMObj  = GetColorMatchingModule(cmmID);
        if (!pCMMObj)
        {
            TERSE((__TEXT("CMM associated with profile could not be found")));

            pCMMObj = GetColorMatchingModule(CMM_WINDOWS_DEFAULT);
            if (!pCMMObj)
            {
                RIP((__TEXT("Default CMM not found\n")));
                SetLastError(ERROR_INVALID_CMM);
                goto EndCreateColorTransform;
            }
        }
    }

    //
    // Allocate an object on the heap for the transform
    //

    hxform = AllocateHeapObject(OBJ_TRANSFORM);
    if (!hxform)
    {
        WARNING((__TEXT("Could not allocate transform object\n")));
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        ReleaseColorMatchingModule(pCMMObj);
        goto EndCreateColorTransform;
    }

    pxformObj = (PTRANSFORMOBJ)HDLTOPTR(hxform);

    ASSERT(pxformObj != NULL);

    //
    // Call into CMM to create a color transform
    //

    ASSERT(pCMMObj->fns.pCMCreateTransformExt != NULL);

    ASSERT(pDestProfObj->pView != NULL);

    ASSERT(!pTargetProfObj || pTargetProfObj->pView);

    pxformObj->pCMMObj = pCMMObj;
    pxformObj->objHdr.dwUseCount = 1;

    pxformObj->hcmxform = pCMMObj->fns.pCMCreateTransformExt(
                            pLCS,
                            pDestProfObj->pView,
                            pTargetProfObj ? pTargetProfObj->pView : NULL,
                            dwFlags);

    TERSE((__TEXT("CMCreateTransform returned 0x%x\n"), pxformObj->hcmxform));

    //
    // If return value from CMM is less than 256, then it is an error code
    //

    if (pxformObj->hcmxform <= TRANSFORM_ERROR)
    {
        WARNING((__TEXT("CMCreateTransform failed\n")));
        if (GetLastError() == ERROR_SUCCESS)
        {
            WARNING((__TEXT("CMM did not set error code\n")));
            SetLastError(ERROR_INVALID_PROFILE);
        }
        ReleaseColorMatchingModule(pxformObj->pCMMObj);
        pxformObj->objHdr.dwUseCount--;        // decrement before freeing
        FreeHeapObject(hxform);
        hxform = NULL;
    }

EndCreateColorTransform:
    MemFree(pLCS);

    return hxform;
}

/******************************************************************************
 *
 *                            InternalRegisterCMM
 *
 *  Function:
 *       This function associates an ID with a CMM DLL, so that we can use
 *       the ID in profiles to find the CMM to use when creating a transform.
 *
 *  Arguments:
 *       pMachineName   - name identifying machine on which the CMM should be
 *                        registered
 *       cmmID          - ID of CMM to register
 *       pCMMdll        - pointer to CMM dll to register
 *
 *  Returns:
 *       TRUE if successful, FALSE otherwise
 *
 ******************************************************************************/

BOOL  InternalRegisterCMM(
    PTSTR       pMachineName,
    DWORD       cmmID,
    PTSTR       pCMMdll
    )
{
    PCMMOBJ   pCMMObj;
    HKEY      hkCMM;
    DWORD     dwErr;
    BOOL      rc = TRUE;
    int       i;
    TCHAR     szCMMID[5];

    //
    // Validate parameters
    //

    if (!pCMMdll || IsBadReadPtr(pCMMdll, lstrlen(pCMMdll)*sizeof(TCHAR)))
    {
        WARNING((__TEXT("Invalid parameter to RegisterCMM\n")));
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }


    //
    // Only local installs are allowed now
    //

    if (pMachineName)
    {
        WARNING((__TEXT("Remote CMM registration attempted, failing...\n")));
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // Check if the CMM actually exists, and it's valid CMM
    //

    rc = ValidColorMatchingModule(cmmID,pCMMdll);

    if (rc)
    {
        //
        // Open the registry key for ICMatchers
        //

        if ((dwErr = RegCreateKey(HKEY_LOCAL_MACHINE, gszICMatcher, &hkCMM)) != ERROR_SUCCESS)
        {
            ERR((__TEXT("Could not open ICMatcher registry key: %d\n"), dwErr));
            SetLastError(dwErr);
            return FALSE;
        }

        //
        // Make a string with the CMM ID
        //

        for (i=0; i<4; i++)
        {
            szCMMID[i]  = (TCHAR)(((char*)&cmmID)[3-i]);
        }
        szCMMID[4] = '\0';

        //
        // Set the file name of the CMM dll in the registry
        //

        if ((dwErr = RegSetValueEx(hkCMM, (PTSTR)szCMMID, 0, REG_SZ, (BYTE *)pCMMdll,
            (lstrlen(pCMMdll)+1)*sizeof(TCHAR))) != ERROR_SUCCESS)
        {
            WARNING((__TEXT("Could not set CMM dll in the registry %s: %d\n"), szCMMID, dwErr));
            SetLastError(dwErr);
            rc = FALSE;
        }

        RegCloseKey(hkCMM);
    }

    return rc;
}



/******************************************************************************
 *
 *                            InternalUnregisterCMM
 *
 *  Function:
 *       This function unregisters a CMM from the system by dissociating the
 *       ID from the CMM dll in the registry.
 *
 *  Arguments:
 *       pMachineName   - name identifying machine on which the CMM is
 *                        registered
 *       cmmID          - ID of CMM to unregister
 *
 *  Returns:
 *       TRUE if successful, FALSE otherwise
 *
 ******************************************************************************/

BOOL  InternalUnregisterCMM(
    PTSTR       pMachineName,
    DWORD       cmmID
    )
{
    HKEY      hkCMM;
    TCHAR     szCMMID[5];
    DWORD     dwErr;
    BOOL      rc = TRUE;

    //
    // Only local installs are allowed now
    //

    if (pMachineName)
    {
        WARNING((__TEXT("Remote CMM unregistration attempted, failing...\n")));
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // Open the registry key for ICMatchers
    //

    if ((dwErr = RegOpenKey(HKEY_LOCAL_MACHINE, gszICMatcher, &hkCMM)) != ERROR_SUCCESS)
    {
        ERR((__TEXT("Could not open ICMatcher registry key: %d\n"), dwErr));
        SetLastError(dwErr);
        return FALSE;
    }

    //
    // Make a string with the CMM ID
    //

    szCMMID[0] = ((char *)&cmmID)[3];
    szCMMID[1] = ((char *)&cmmID)[2];
    szCMMID[2] = ((char *)&cmmID)[1];
    szCMMID[3] = ((char *)&cmmID)[0];
    szCMMID[4] = '\0';

    //
    // Delete the file name of the CMM dll from the registry
    //

    if ((dwErr = RegDeleteValue(hkCMM, (PTSTR)szCMMID)) != ERROR_SUCCESS)
    {
        WARNING((__TEXT("Could not delete CMM dll from the registry %s: %d\n"), szCMMID, dwErr));
        SetLastError(dwErr);
        rc = FALSE;
    }

    RegCloseKey(hkCMM);

    return rc;
}


/******************************************************************************
 *
 *                           GetBitmapBytes
 *
 *  Function:
 *       This functions returns number of bytes required for a bitmap given
 *       the format, the width in pixels and number of scanlines
 *
 *  Arguments:
 *       bmFmt          - format of bitmap
 *       deWidth        - number of pixels per scanline
 *       dwHeight       - number of scanlines in bitmap
 *
 *  Returns:
 *       Number of bytes required for bitmap on success, 0 on failure
 *
 ******************************************************************************/

DWORD GetBitmapBytes(
    BMFORMAT bmFmt,
    DWORD    dwWidth,
    DWORD    dwHeight
    )
{
    DWORD nBytes;

    switch (bmFmt)
    {
    //
    // 1 byte per pixel
    //

    case BM_GRAY:
        nBytes = dwWidth;
        break;

    //
    // 2 bytes per pixel
    //

    case BM_x555RGB:
    case BM_x555XYZ:
    case BM_x555Yxy:
    case BM_x555Lab:
    case BM_x555G3CH:
    case BM_16b_GRAY:
    case BM_565RGB:
        nBytes = dwWidth*2;
        break;

    //
    // 3 bytes per pixel
    //

    case BM_BGRTRIPLETS:
    case BM_RGBTRIPLETS:
    case BM_XYZTRIPLETS:
    case BM_YxyTRIPLETS:
    case BM_LabTRIPLETS:
    case BM_G3CHTRIPLETS:
        nBytes = dwWidth*3;
        break;

    //
    // 4 bytes per pixel
    //

    case BM_xRGBQUADS:
    case BM_xBGRQUADS:
    #if 0
    case BM_xXYZQUADS:
    case BM_xYxyQUADS:
    case BM_xLabQUADS:
    #endif
    case BM_xG3CHQUADS:
    case BM_KYMCQUADS:
    case BM_CMYKQUADS:
    case BM_10b_RGB:
    case BM_10b_XYZ:
    case BM_10b_Yxy:
    case BM_10b_Lab:
    case BM_10b_G3CH:
    case BM_NAMED_INDEX:
        nBytes = dwWidth*4;
        break;

    //
    // 5 bytes per pixel
    //

    case BM_5CHANNEL:
        nBytes = dwWidth*5;
        break;

    //
    // 6 bytes per pixel
    //

    case BM_16b_RGB:
    case BM_16b_XYZ:
    case BM_16b_Yxy:
    case BM_16b_Lab:
    case BM_16b_G3CH:
    case BM_6CHANNEL:
        nBytes = dwWidth*6;
        break;

    //
    // 7 bytes per pixel
    //

    case BM_7CHANNEL:
        nBytes = dwWidth*7;
        break;

    //
    // 8 bytes per pixel
    //

    case BM_8CHANNEL:
        nBytes = dwWidth*8;
        break;

    //
    // Error case
    //

    default:
        nBytes = 0;
        break;
    }

    //
    // Align to DWORD boundary
    //

    nBytes = (nBytes + 3) & ~3;

    return nBytes*dwHeight;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\mscms\ps2wrap.c ===
/****************************Module*Header******************************\
* Module Name: PS2.C
*
* Module Descripton: This file is a wrapper for the actual file that
*   implements code to generate CSAs and CRDs. The wrapper is used so
*   that the actual file can be share by the pscript5 & mscms projects
*
* Warnings:
*
* Issues:
*
* Public Routines:
*
* Created:  13 May 1996
* Author:   Srinivasan Chandrasekar    [srinivac]
*
* Copyright (c) 1996, 1997  Microsoft Corporation
\***********************************************************************/

#include "mscms.h"

#include "ps2.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\mscms\ps2.c ===
/****************************Module*Header******************************\
* Module Name: PS2.C
*
* Module Descripton: Functions for retrieving or creating PostScript
*    Level 2 operators from a profile. It is shared by mscms & pscript5
*
* Warnings:
*
* Issues:
*
* Public Routines:
*
* Created:  13 May 1996
* Author:   Srinivasan Chandrasekar    [srinivac]
*
* Copyright (c) 1996, 1997  Microsoft Corporation
\***********************************************************************/

#include <math.h>

#define MAX_LINELEN             240
#define REVCURVE_RATIO          1
#define CIEXYZRange             0x1FFEC       // 1.9997 in 16.16 notation
#define ALIGN_DWORD(nBytes)     (((nBytes) + 3) & ~3)

#define FIX_16_16_SHIFT         16
#define FIX_16_16_SCALE         (1 << (FIX_16_16_SHIFT))

#define TO_FIX(x)               ((x) << FIX_16_16_SHIFT)
#define TO_INT(x)               ((x) >> FIX_16_16_SHIFT)
#define FIX_MUL(x, y)           MulDiv((x), (y), FIX_16_16_SCALE)
#define FIX_DIV(x, y)           MulDiv((x), FIX_16_16_SCALE, (y))

#define FLOOR(x)                ((x) >> FIX_16_16_SHIFT << FIX_16_16_SHIFT)

#define TYPE_CIEBASEDDEF        1
#define TYPE_CIEBASEDDEFG       2

#define TAG_PS2CSA              'ps2s'
#define TAG_REDCOLORANT         'rXYZ'
#define TAG_GREENCOLORANT       'gXYZ'
#define TAG_BLUECOLORANT        'bXYZ'
#define TAG_REDTRC              'rTRC'
#define TAG_GREENTRC            'gTRC'
#define TAG_BLUETRC             'bTRC'
#define TAG_GRAYTRC             'kTRC'
#define TAG_MEDIAWHITEPOINT     'wtpt'
#define TAG_AToB0               'A2B0'
#define TAG_AToB1               'A2B1'
#define TAG_AToB2               'A2B2'
#define TAG_PS2INTENT0          'psi0'
#define TAG_PS2INTENT1          'psi1'
#define TAG_PS2INTENT2          'psi2'
#define TAG_PS2INTENT3          'psi3'
#define TAG_CRDINTENT0          'psd0'
#define TAG_CRDINTENT1          'psd1'
#define TAG_CRDINTENT2          'psd2'
#define TAG_CRDINTENT3          'psd3'
#define TAG_BToA0               'B2A0'
#define TAG_BToA1               'B2A1'
#define TAG_BToA2               'B2A2'
#define TAG_BToA3               'B2A3'

#define LUT8_TYPE               'mft1'
#define LUT16_TYPE              'mft2'

#define SIG_CURVE_TYPE          'curv'

#define GetCPConnSpace(pProfile)     (FIX_ENDIAN(((PPROFILEHEADER)pProfile)->phConnectionSpace))
#define GetCPDevSpace(pProfile)      (FIX_ENDIAN(((PPROFILEHEADER)pProfile)->phDataColorSpace))
#define GetCPRenderIntent(pProfile)  (FIX_ENDIAN(((PPROFILEHEADER)pProfile)->phRenderingIntent))
#define WriteObject(pBuf, pStr)      (STRCPY(pBuf, pStr), STRLEN(pStr))

#ifdef KERNEL_MODE
#define WriteInt(pBuf, i)            OPSprintf(pBuf, "%l ", (i))
#define WriteHex(pBuf, x)            OPSprintf(pBuf, "%x", ((x) & 0x00FF))
#define STRLEN                       strlen
#define STRCPY                       strcpy
#else
#define WriteInt(pBuf, i)            wsprintfA(pBuf, "%lu ", (i))
#define WriteHex(pBuf, x)            wsprintfA(pBuf, "%2.2x", ((x) & 0x00FF))
#define STRLEN                       lstrlenA
#define STRCPY                       lstrcpyA
#endif

#define MAXCHANNELS             4
#define PREVIEWCRDGRID          16
#define MAXCOLOR8               255

#define DATATYPE_LUT            0
#define DATATYPE_MATRIX         1

#define sRGB_CRC                0xa3d777b4L
#define sRGB_TAGSIZE            6168


#define BRADFORD_TRANSFORM

//
// Local typedefs
//

typedef DWORD FIX_16_16, *PFIX_16_16;

typedef struct tagCURVETYPE {
    DWORD dwSignature;
    DWORD dwReserved;
    DWORD nCount;
    WORD  data[0];
} CURVETYPE, *PCURVETYPE;

typedef struct tagXYZTYPE {
    DWORD     dwSignature;
    DWORD     dwReserved;
    FIX_16_16 afxData[0];
} XYZTYPE, *PXYZTYPE;

typedef struct tagLUT8TYPE {
    DWORD     dwSignature;
    DWORD     dwReserved;
    BYTE      nInputChannels;
    BYTE      nOutputChannels;
    BYTE      nClutPoints;
    BYTE      padding;
    FIX_16_16 e00;
    FIX_16_16 e01;
    FIX_16_16 e02;
    FIX_16_16 e10;
    FIX_16_16 e11;
    FIX_16_16 e12;
    FIX_16_16 e20;
    FIX_16_16 e21;
    FIX_16_16 e22;
    BYTE      data[0];
} LUT8TYPE, *PLUT8TYPE;

typedef struct tagLUT16TYPE {
    DWORD     dwSignature;
    DWORD     dwReserved;
    BYTE      nInputChannels;
    BYTE      nOutputChannels;
    BYTE      nClutPoints;
    BYTE      padding;
    FIX_16_16 e00;
    FIX_16_16 e01;
    FIX_16_16 e02;
    FIX_16_16 e10;
    FIX_16_16 e11;
    FIX_16_16 e12;
    FIX_16_16 e20;
    FIX_16_16 e21;
    FIX_16_16 e22;
    WORD      wInputEntries;
    WORD      wOutputEntries;
    WORD      data[0];
} LUT16TYPE, *PLUT16TYPE;

typedef struct tagHOSTCLUT {
    WORD        wSize;
    WORD        wDataType;
    DWORD       dwDev;
    DWORD       dwPCS;
    DWORD       dwIntent;
    FIX_16_16   afxIlluminantWP[3];
    FIX_16_16   afxMediaWP[3];
    BYTE        nInputCh;
    BYTE        nOutputCh;
    BYTE        nClutPoints;
    BYTE        nLutBits;
    FIX_16_16   e[9];
    WORD        nInputEntries;
    WORD        nOutputEntries;
    PBYTE       inputArray[MAXCHANNELS];
    PBYTE       outputArray[MAXCHANNELS];
    PBYTE       clut;
} HOSTCLUT, *PHOSTCLUT;

//
// Internal functions
//

BOOL  IsSRGBColorProfile(PBYTE);

BOOL  GetCSAFromProfile (PBYTE, DWORD, DWORD, PBYTE, PDWORD, PBOOL);
BOOL  GetPS2CSA_MONO_A(PBYTE, PBYTE, PDWORD, DWORD, PBOOL);
BOOL  GetPS2CSA_ABC(PBYTE, PBYTE, PDWORD, DWORD, PBOOL, BOOL);
BOOL  GetPS2CSA_ABC_Lab(PBYTE, PBYTE, PDWORD, DWORD, PBOOL);
BOOL  GetPS2CSA_DEFG(PBYTE, PBYTE, PDWORD, DWORD, DWORD, PBOOL);

BOOL  CreateMonoCRD(PBYTE, DWORD, PBYTE, PDWORD, DWORD);
BOOL  CreateLutCRD(PBYTE, DWORD, PBYTE, PDWORD, DWORD, BOOL);

BOOL  DoesCPTagExist(PBYTE, DWORD, PDWORD);
BOOL  DoesTRCAndColorantTagExist(PBYTE);
BOOL  GetCPWhitePoint(PBYTE, PFIX_16_16);
BOOL  GetCPMediaWhitePoint(PBYTE, PFIX_16_16);
BOOL  GetCPElementDataSize(PBYTE, DWORD, PDWORD);
BOOL  GetCPElementSize(PBYTE, DWORD, PDWORD);
BOOL  GetCPElementDataType(PBYTE, DWORD, PDWORD);
BOOL  GetCPElementData(PBYTE, DWORD, PBYTE, PDWORD);
BOOL  GetTRCElementSize(PBYTE, DWORD, PDWORD, PDWORD);

DWORD Ascii85Encode(PBYTE, DWORD, DWORD);

BOOL  GetCRDInputOutputArraySize(PBYTE, DWORD, PDWORD, PDWORD, PDWORD, PDWORD);
BOOL  GetHostCSA(PBYTE, PBYTE, PDWORD, DWORD, DWORD);
BOOL  GetHostColorRenderingDictionary(PBYTE, DWORD, PBYTE, PDWORD);
BOOL  GetHostColorSpaceArray(PBYTE, DWORD, PBYTE, PDWORD);

DWORD SendCRDBWPoint(PBYTE, PFIX_16_16);
DWORD SendCRDPQR(PBYTE, DWORD, PFIX_16_16);
DWORD SendCRDLMN(PBYTE, DWORD, PFIX_16_16, PFIX_16_16, DWORD);
DWORD SendCRDABC(PBYTE, PBYTE, DWORD, DWORD, PBYTE, PFIX_16_16, DWORD, BOOL);
DWORD SendCRDOutputTable(PBYTE, PBYTE, DWORD, DWORD, BOOL, BOOL);

DWORD SendCSABWPoint(PBYTE, DWORD, PFIX_16_16, PFIX_16_16);
VOID  GetMediaWP(PBYTE, DWORD, PFIX_16_16, PFIX_16_16);

DWORD CreateCRDRevArray(PBYTE, PBYTE, PCURVETYPE, PWORD, DWORD, BOOL);
DWORD SendCRDRevArray(PBYTE, PBYTE, PCURVETYPE, DWORD, BOOL);

DWORD CreateColSpArray(PBYTE, PBYTE, DWORD, BOOL);
DWORD CreateColSpProc(PBYTE, PBYTE, DWORD, BOOL);
DWORD CreateFloatString(PBYTE, PBYTE, DWORD);
DWORD CreateInputArray(PBYTE, DWORD, DWORD, PBYTE, DWORD, PBYTE, BOOL, PBYTE);
DWORD CreateOutputArray(PBYTE, DWORD, DWORD, DWORD, PBYTE, DWORD, PBYTE, BOOL, PBYTE);

DWORD GetPublicArrayName(DWORD, PBYTE);
BOOL  GetRevCurve(PCURVETYPE, PWORD, PWORD);
VOID  GetCLUTInfo(DWORD, PBYTE, PDWORD, PDWORD, PDWORD, PDWORD, PDWORD, PDWORD);
DWORD EnableGlobalDict(PBYTE);
DWORD BeginGlobalDict(PBYTE);
DWORD EndGlobalDict(PBYTE);

DWORD WriteNewLineObject(PBYTE, const char *);
DWORD WriteHNAToken(PBYTE, BYTE, DWORD);
DWORD WriteIntStringU2S(PBYTE, PBYTE, DWORD);
DWORD WriteIntStringU2S_L(PBYTE, PBYTE, DWORD);
DWORD WriteHexBuffer(PBYTE, PBYTE, PBYTE, DWORD);
DWORD WriteStringToken(PBYTE, BYTE, DWORD);
DWORD WriteByteString(PBYTE, PBYTE, DWORD);
DWORD WriteInt2ByteString(PBYTE, PBYTE, DWORD);
DWORD WriteFixed(PBYTE, FIX_16_16);
DWORD WriteFixed2dot30(PBYTE, DWORD);
#if !defined(KERNEL_MODE) || defined(USERMODE_DRIVER)
DWORD WriteDouble(PBYTE, double);

BOOL  CreateMatrixCRD(PBYTE, PBYTE, PDWORD, DWORD, BOOL);
DWORD CreateHostLutCRD(PBYTE, DWORD, PBYTE, DWORD);
DWORD CreateHostMatrixCSAorCRD(PBYTE, PBYTE, PDWORD, DWORD, BOOL);
DWORD CreateHostInputOutputArray(PBYTE, PBYTE*, DWORD, DWORD, DWORD, DWORD, PBYTE);
DWORD CreateHostTRCInputTable(PBYTE, PHOSTCLUT, PCURVETYPE, PCURVETYPE, PCURVETYPE);
DWORD CreateHostRevTRCInputTable(PBYTE, PHOSTCLUT, PCURVETYPE, PCURVETYPE, PCURVETYPE);

BOOL  CheckInputOutputTable(PHOSTCLUT, float*, BOOL, BOOL);
BOOL  CheckColorLookupTable(PHOSTCLUT, float*);

BOOL  DoHostConversionCSA(PHOSTCLUT, float*, float*);
BOOL  DoHostConversionCRD(PHOSTCLUT, PHOSTCLUT, float*, float*, BOOL);

float g(float);
float inverse_g(float);
BOOL  TableInterp3(PHOSTCLUT, float*);
BOOL  TableInterp4(PHOSTCLUT, float*);
void  LabToXYZ(float*, float*, PFIX_16_16);
void  XYZToLab(float*, float*, PFIX_16_16);
VOID  ApplyMatrix(FIX_16_16 *e, float *Input, float *Output);

BOOL  CreateColorantArray(PBYTE, double *, DWORD);
BOOL  InvertColorantArray(double *, double *);
#endif

DWORD crc32(PBYTE buff, DWORD length);

//
// Global variables
//

const char  ASCII85DecodeBegin[] = "<~";
const char  ASCII85DecodeEnd[]   = "~> cvx exec ";
const char  TestingDEFG[]       = "/SupportDEFG? {/CIEBasedDEFG \
 /ColorSpaceFamily resourcestatus { pop pop languagelevel 3 ge}{false} ifelse} def";
const char  SupportDEFG_S[]     = "SupportDEFG? { ";
const char  NotSupportDEFG_S[]  = "SupportDEFG? not { ";
const char  SupportDEFG_E[]     = "}if ";
const char  IndexArray16b[]     = " dup length 1 sub 3 -1 roll mul dup dup floor cvi\
 exch ceiling cvi 3 index exch get 32768 add 4 -1 roll 3 -1 roll get 32768 add\
 dup 3 1 roll sub 3 -1 roll dup floor cvi sub mul add ";

const char  IndexArray[]        = " dup length 1 sub 3 -1 roll mul dup dup floor cvi\
 exch ceiling cvi 3 index exch get 4 -1 roll 3 -1 roll get\
 dup 3 1 roll sub 3 -1 roll dup floor cvi sub mul add ";
const char  StartClip[]         = "dup 1.0 le{dup 0.0 ge{" ;
const char  EndClip[]           = "}if}if " ;
const char  BeginString[]       = "<";
const char  EndString[]         = ">";
const char  BeginArray[]        = "[";
const char  EndArray[]          = "]";
const char  BeginFunction[]     = "{";
const char  EndFunction[]       = "}bind ";
const char  BeginDict[]         = "<<" ;
const char  EndDict[]           = ">>" ;
const char  BlackPoint[]        = "[0 0 0]" ;
const char  DictType[]          = "/ColorRenderingType 1 ";
const char  IntentType[]        = "/RenderingIntent ";
const char  IntentPer[]         = "/Perceptual";
const char  IntentSat[]         = "/Saturation";
const char  IntentACol[]        = "/AbsoluteColorimetric";
const char  IntentRCol[]        = "/RelativeColorimetric";

const char  WhitePointTag[]     = "/WhitePoint " ;
const char  BlackPointTag[]     = "/BlackPoint " ;
const char  RangePQRTag[]       = "/RangePQR " ;
const char  TransformPQRTag[]   = "/TransformPQR " ;
const char  MatrixPQRTag[]      = "/MatrixPQR " ;
const char  RangePQR[]          = "[ -0.07 2.2 -0.02 1.4 -0.2 4.8 ]";
const char  MatrixPQR[]         = "[0.8951 -0.7502 0.0389 0.2664 1.7135 -0.0685 -0.1614 0.0367 1.0296]";
#ifdef BRADFORD_TRANSFORM
const char  *TransformPQR[3]    = {"exch pop exch 3 get mul exch pop exch 3 get div ",
                                   "exch pop exch 4 get mul exch pop exch 4 get div ",
                                   "exch pop exch 5 get mul exch pop exch 5 get div " };
#else
const char  *TransformPQR[3]    = {"4 index 0 get div 2 index 0 get mul 4 {exch pop} repeat ",
                                   "4 index 1 get div 2 index 1 get mul 4 {exch pop} repeat ",
                                   "4 index 2 get div 2 index 2 get mul 4 {exch pop} repeat " };
#endif
const char  RangeABCTag[]       = "/RangeABC " ;
const char  MatrixATag[]        = "/MatrixA ";
const char  MatrixABCTag[]      = "/MatrixABC ";
const char  EncodeABCTag[]      = "/EncodeABC " ;
const char  RangeLMNTag[]       = "/RangeLMN " ;
const char  MatrixLMNTag[]      = "/MatrixLMN " ;
const char  EncodeLMNTag[]      = "/EncodeLMN " ;
const char  RenderTableTag[]    = "/RenderTable " ;
const char  CIEBasedATag[]      = "/CIEBasedA " ;
const char  CIEBasedABCTag[]    = "/CIEBasedABC " ;
const char  CIEBasedDEFGTag[]   = "/CIEBasedDEFG " ;
const char  CIEBasedDEFTag[]    = "/CIEBasedDEF " ;
const char  DecodeATag[]        = "/DecodeA " ;
const char  DecodeABCTag[]      = "/DecodeABC " ;
const char  DecodeLMNTag[]      = "/DecodeLMN " ;
const char  DeviceRGBTag[]      = "/DeviceRGB " ;
const char  DeviceCMYKTag[]     = "/DeviceCMYK " ;
const char  DeviceGrayTag[]     = "/DeviceGray " ;
const char  TableTag[]          = "/Table " ;
const char  DecodeDEFGTag[]     = "/DecodeDEFG " ;
const char  DecodeDEFTag[]      = "/DecodeDEF " ;

const char  NullOp[]            = "";
const char  DupOp[]             = "dup ";
const char  UserDictOp[]        = "userdict ";
const char  GlobalDictOp[]      = "globaldict ";
const char  CurrentGlobalOp[]   = "currentglobal ";
const char  SetGlobalOp[]       = "setglobal ";
const char  DefOp[]             = "def ";
const char  BeginOp[]           = "begin ";
const char  EndOp[]             = "end ";
const char  TrueOp[]            = "true ";
const char  FalseOp[]           = "false ";
const char  MulOp[]             = "mul ";
const char  DivOp[]             = "div ";

const char  NewLine[]           = "\r\n" ;
const char  Slash[]             = "/" ;
const char  Space[]             = " " ;
const char  CRDBegin[]          = "%** CRD Begin ";
const char  CRDEnd[]            = "%** CRD End ";
const char  CieBasedDEFGBegin[] = "%** CieBasedDEFG CSA Begin ";
const char  CieBasedDEFBegin[]  = "%** CieBasedDEF CSA Begin ";
const char  CieBasedABCBegin[]  = "%** CieBasedABC CSA Begin ";
const char  CieBasedABegin[]    = "%** CieBasedA CSA Begin ";
const char  CieBasedDEFGEnd[]   = "%** CieBasedDEFG CSA End ";
const char  CieBasedDEFEnd[]    = "%** CieBasedDEF CSA End ";
const char  CieBasedABCEnd[]    = "%** CieBasedABC CSA End ";
const char  CieBasedAEnd[]      = "%** CieBasedA CSA End ";
const char  RangeABC[]          = "[ 0 1 0 1 0 1 ] ";
const char  RangeLMN[]          = "[ 0 2 0 2 0 2 ] ";
const char  Identity[]          = "[1 0 0 0 1 0 0 0 1]";
const char  RangeABC_Lab[]      = "[0 100 -128 127 -128 127]";
const char  Clip01[]            = "dup 1.0 ge{pop 1.0}{dup 0.0 lt{pop 0.0}if}ifelse " ;
const char  DecodeA3[]          = "256 div exp ";
const char  DecodeA3Rev[]       = "256 div 1.0 exch div exp ";
const char  DecodeABCArray[]    = "DecodeABC_";
const char  InputArray[]        = "Inp_";
const char  OutputArray[]       = "Out_";
const char  Scale8[]            = "255 div " ;
const char  Scale16[]           = "65535 div " ;
const char  Scale16XYZ[]        = "32768 div " ;
const char  TFunction8[]        = "exch 255 mul round cvi get 255 div " ;
const char  TFunction8XYZ[]     = "exch 255 mul round cvi get 128 div " ;
const char  MatrixABCLab[]      = "[1 1 1 1 0 0 0 0 -1]" ;
const char  DecodeABCLab1[]     = "[{16 add 116 div} bind {500 div} bind {200 div} bind]";
const char  DecodeALab[]        = " 50 mul 16 add 116 div ";
const char  DecodeLMNLab[]      = "dup 0.206897 ge{dup dup mul mul}{0.137931 sub 0.128419 mul} ifelse ";

const char  RangeLMNLab[]       = "[0 1 0 1 0 1]" ;
const char  EncodeLMNLab[]      = "dup 0.008856 le{7.787 mul 0.13793 add}{0.3333 exp}ifelse " ;

const char  MatrixABCLabCRD[]   = "[0 500 0 116 -500 200 0 0 -200]" ;
const char  MatrixABCXYZCRD[]   = "[0 1 0 1 0 0 0 0 1]" ;
const char  EncodeABCLab1[]     = "16 sub 100 div " ;
const char  EncodeABCLab2[]     = "128 add 255 div " ;
const char  *DecodeABCLab[]     = {"50 mul 16 add 116 div ",
                                   "128 mul 128 sub 500 div",
                                   "128 mul 128 sub 200 div"};

const char ColorSpace1[]        = "/CIEBasedABC << /DecodeLMN ";
const char ColorSpace3[]        = " exp} bind ";
const char ColorSpace5[]        = "/WhitePoint [0.9642 1 0.8249] ";

const char PreViewInArray[]     = "IPV_";
const char PreViewOutArray[]    = "OPV_";

const char sRGBColorSpaceArray[] = "[/CIEBasedABC << \r\n\
/DecodeLMN [{dup 0.03928 le {12.92321 div}{0.055 add 1.055 div 2.4 exp}ifelse} bind dup dup ] \r\n\
/MatrixLMN [0.412457 0.212673 0.019334 0.357576 0.715152 0.119192 0.180437 0.072175 0.950301] \r\n\
/WhitePoint [ 0.9505 1 1.0890 ] >> ]";

#ifdef BRADFORD_TRANSFORM
const char sRGBColorRenderingDictionary[] = "\
/RangePQR [ -0.5 2 -0.5 2 -0.5 2 ] \r\n\
/MatrixPQR [0.8951 -0.7502  0.0389 0.2664  1.7135 -0.0685 -0.1614  0.0367  1.0296] \r\n\
/TransformPQR [\
{exch pop exch 3 get mul exch pop exch 3 get div} bind \
{exch pop exch 4 get mul exch pop exch 4 get div} bind \
{exch pop exch 5 get mul exch pop exch 5 get div} bind] \r\n\
/MatrixLMN [3.240449 -0.969265  0.055643 -1.537136  1.876011 -0.204026 -0.498531  0.041556  1.057229] \r\n\
/EncodeABC [{dup 0.00304 le {12.92321 mul}{1 2.4 div exp 1.055 mul 0.055 sub}ifelse} bind dup dup] \r\n\
/WhitePoint[0.9505 1 1.0890] >>";
#else
const char sRGBColorRenderingDictionary[] = "\
/RangePQR [ -0.5 2 -0.5 2 -0.5 2 ] \r\n\
/MatrixPQR [0.8951 -0.7502  0.0389 0.2664  1.7135 -0.0685 -0.1614  0.0367  1.0296] \r\n\
/TransformPQR [\
{4 index 0 get div 2 index 0 get mul 4 {exch pop} repeat} \
{4 index 1 get div 2 index 1 get mul 4 {exch pop} repeat} \
{4 index 2 get div 2 index 2 get mul 4 {exch pop} repeat}] \r\n\
/MatrixLMN [3.240449 -0.969265  0.055643 -1.537136  1.876011 -0.204026 -0.498531  0.041556  1.057229] \r\n\
/EncodeABC [{dup 0.00304 le {12.92321 mul}{1 2.4 div exp 1.055 mul 0.055 sub}ifelse} bind dup dup] \r\n\
/WhitePoint[0.9505 1 1.0890] >>";
#endif

/******************************************************************************
 *
 *                       InternalGetPS2ColorSpaceArray
 *
 *  Function:
 *       This functions retrieves the PostScript Level 2 CSA from the profile,
 *       or creates it if the profile tag is not present
 *
 *  Arguments:
 *       hProfile  - handle identifing the profile object
 *       dwIntent  - rendering intent of CSA
 *       dwCSAType - type of CSA
 *       pbuffer   - pointer to receive the CSA
 *       pcbSize   - pointer to size of buffer. If function fails because
 *                   buffer is not big enough, it is filled with required size.
 *       pcbBinary - TRUE if binary data is requested. On return it is set to
 *                   reflect the data returned
 *
 *  Returns:
 *       TRUE if successful, FALSE otherwise
 *
 ******************************************************************************/

BOOL
InternalGetPS2ColorSpaceArray (
    PBYTE     pProfile,
    DWORD     dwIntent,
    DWORD     dwCSAType,
    PBYTE     pBuffer,
    PDWORD    pcbSize,
    LPBOOL    pbBinary
    )
{
    DWORD dwInpBufSize;
    BOOL  bRc;

    //
    // If profile has a CSA tag, get it directly
    //

    bRc = GetCSAFromProfile(pProfile, dwIntent, dwCSAType, pBuffer,
              pcbSize, pbBinary);

    if (! bRc && (GetLastError() != ERROR_INSUFFICIENT_BUFFER))
    {
        //
        // Create a CSA from the profile data
        //

        switch (dwCSAType)
        {
        case CSA_ABC:
            bRc = GetPS2CSA_ABC(pProfile, pBuffer, pcbSize,
                      dwIntent, pbBinary, FALSE);
            break;

        case CSA_DEF:
            bRc = GetPS2CSA_DEFG(pProfile, pBuffer, pcbSize, dwIntent,
                      TYPE_CIEBASEDDEF, pbBinary);
            break;

        case CSA_RGB:
        case CSA_Lab:

            dwInpBufSize = *pcbSize;

            //
            // We get a DEF CSA followed by an ABC CSA and set it up so that
            // on PS interpreters that do not support the DEF CSA, the ABC one
            // is active
            //

            bRc = GetPS2CSA_DEFG(pProfile, pBuffer, pcbSize, dwIntent,
                      TYPE_CIEBASEDDEF, pbBinary);

            if (bRc)
            {
                //
                // Create CieBasedABC for printers that do not support CieBasedDEF
                //

                DWORD cbNewSize = 0;
                PBYTE pNewBuffer;
                PBYTE pOldBuffer;

                if (pBuffer)
                {
                    pNewBuffer = pBuffer + *pcbSize;
                    pOldBuffer = pNewBuffer;
                    pNewBuffer += WriteObject(pNewBuffer, NewLine);
                    if (dwCSAType == CSA_Lab)
                    {
                        pNewBuffer += WriteNewLineObject(pNewBuffer, NotSupportDEFG_S);
                    }
                    cbNewSize = dwInpBufSize - (DWORD)(pNewBuffer - pBuffer);
                }
                else
                {
                    pNewBuffer = NULL;
                }

                bRc = GetPS2CSA_ABC(pProfile, pNewBuffer, &cbNewSize,
                          dwIntent, pbBinary, TRUE);

                if (pBuffer)
                {
                    pNewBuffer += cbNewSize;
                    if (dwCSAType == CSA_Lab)
                    {
                        pNewBuffer += WriteNewLineObject(pNewBuffer, SupportDEFG_E);
                    }
                    *pcbSize += (DWORD) (pNewBuffer - pOldBuffer);
                }
                else
                {
                    *pcbSize += cbNewSize;
                }

            }
            else
            {
                *pcbSize = dwInpBufSize;

                bRc = GetPS2CSA_ABC(pProfile, pBuffer, pcbSize, dwIntent, pbBinary, FALSE);
            }

            break;

        case CSA_CMYK:
        case CSA_DEFG:
            bRc = GetPS2CSA_DEFG(pProfile, pBuffer, pcbSize, dwIntent,
                      TYPE_CIEBASEDDEFG, pbBinary);
            break;

        case CSA_GRAY:
        case CSA_A:
            bRc = GetPS2CSA_MONO_A(pProfile, pBuffer, pcbSize, dwIntent, pbBinary);
            break;

        default:
            WARNING((__TEXT("Invalid CSA type passed to GetPS2ColorSpaceArray: %d\n"), dwCSAType));
            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }
    }

    return bRc;
}


/******************************************************************************
 *
 *                       InternalGetPS2ColorRenderingIntent
 *
 *  Function:
 *       This functions retrieves the PostScript Level 2 color rendering intent
 *       from the profile, or creates it if the profile tag is not present
 *
 *  Arguments:
 *       hProfile  - handle identifing the profile object
 *       pbuffer   - pointer to receive the color rendering intent
 *       pcbSize   - pointer to size of buffer. If function fails because
 *                   buffer is not big enough, it is filled with required size.
 *       pcbBinary - TRUE if binary data is requested. On return it is set to
 *                   reflect the data returned
 *
 *  Returns:
 *       TRUE if successful, FALSE otherwise
 *
 ******************************************************************************/

BOOL
InternalGetPS2ColorRenderingIntent(
    PBYTE     pProfile,
    DWORD     dwIntent,
    PBYTE     pBuffer,
    PDWORD    pcbSize
    )
{
    DWORD dwIndex, dwTag, dwSize;
    BOOL  bRc = FALSE;

    switch (dwIntent)
    {
    case INTENT_PERCEPTUAL:
        dwTag = TAG_PS2INTENT0;
        break;

    case INTENT_RELATIVE_COLORIMETRIC:
        dwTag = TAG_PS2INTENT1;
        break;

    case INTENT_SATURATION:
        dwTag = TAG_PS2INTENT2;
        break;

    case INTENT_ABSOLUTE_COLORIMETRIC:
        dwTag = TAG_PS2INTENT3;
        break;

    default:
        WARNING((__TEXT("Invalid intent passed to GetPS2ColorRenderingIntent: %d\n"), dwIntent));
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if (DoesCPTagExist(pProfile, dwTag, &dwIndex))
    {
        (void)GetCPElementDataSize(pProfile, dwIndex, &dwSize);

        if (pBuffer)
        {
            if (*pcbSize >= dwSize + 1) // for NULL terminating
            {
                bRc = GetCPElementData(pProfile, dwIndex, pBuffer, &dwSize);
            }
            else
            {
                WARNING((__TEXT("Buffer too small to get CRI\n")));
                SetLastError(ERROR_INSUFFICIENT_BUFFER);
            }
        }
        else
            bRc = TRUE;

        *pcbSize = dwSize;
    }
    else
    {
        WARNING((__TEXT("psi tag not present for intent %d in profile\n"), dwIntent));
        SetLastError(ERROR_TAG_NOT_PRESENT);
    }

    //
    // NULL terminate
    //

    if (bRc)
    {
        if (pBuffer)
        {
            pBuffer[*pcbSize] = '\0';
        }
        (*pcbSize)++;
    }

    return bRc;
}


/******************************************************************************
 *
 *                       InternalGetPS2ColorRenderingDictionary
 *
 *  Function:
 *       This functions retrieves the PostScript Level 2 CRD from the profile,
 *       or creates it if the profile tag is not preesnt
 *
 *  Arguments:
 *       hProfile  - handle identifing the profile object
 *       dwIntent  - intent whose CRD is required
 *       pbuffer   - pointer to receive the CSA
 *       pcbSize   - pointer to size of buffer. If function fails because
 *                   buffer is not big enough, it is filled with required size.
 *       pcbBinary - TRUE if binary data is requested. On return it is set to
 *                   reflect the data returned
 *
 *  Returns:
 *       TRUE if successful, FALSE otherwise
 *
 ******************************************************************************/

BOOL
InternalGetPS2ColorRenderingDictionary(
    PBYTE     pProfile,
    DWORD     dwIntent,
    PBYTE     pBuffer,
    PDWORD    pcbSize,
    PBOOL     pbBinary
    )
{
    DWORD dwIndex, dwSize, dwDataType;
    DWORD dwCRDTag, dwBToATag;
    BOOL  bRc = FALSE;

    switch (dwIntent)
    {
    case INTENT_PERCEPTUAL:
        dwCRDTag = TAG_CRDINTENT0;
        dwBToATag = TAG_BToA0;
        break;

    case INTENT_RELATIVE_COLORIMETRIC:
        dwCRDTag = TAG_CRDINTENT1;
        dwBToATag = TAG_BToA1;
        break;

    case INTENT_SATURATION:
        dwCRDTag = TAG_CRDINTENT2;
        dwBToATag = TAG_BToA2;
        break;

    case INTENT_ABSOLUTE_COLORIMETRIC:
        dwCRDTag = TAG_CRDINTENT3;
        dwBToATag = TAG_BToA1;
        break;

    default:
        WARNING((__TEXT("Invalid intent passed to GetPS2ColorRenderingDictionary: %d\n"), dwIntent));
        SetLastError(ERROR_INVALID_PARAMETER);
        return bRc;
    }

    if (DoesCPTagExist(pProfile, dwCRDTag, &dwIndex))
    {
        (void)GetCPElementDataSize(pProfile, dwIndex, &dwSize);

        (void)GetCPElementDataType(pProfile, dwIndex, &dwDataType);

        if (! *pbBinary && dwDataType == 1)
        {
            //
            // Profile has binary data, user asked for ASCII, so we have to
            // ASCII 85 encode it
            //

            dwSize = dwSize * 5 / 4 + sizeof(ASCII85DecodeBegin) + sizeof(ASCII85DecodeEnd) + 2048;
        }

        if (pBuffer)
        {
            if (*pcbSize >= dwSize)
            {
                (void)GetCPElementData(pProfile, dwIndex, pBuffer, &dwSize);

                if (! *pbBinary && dwDataType == 1)
                {
                    dwSize = Ascii85Encode(pBuffer, dwSize, *pcbSize);
                }
                bRc = TRUE;
            }
            else
            {
                WARNING((__TEXT("Buffer too small to get CRD\n")));
                SetLastError(ERROR_INSUFFICIENT_BUFFER);
            }
        }
        else
            bRc = TRUE;

        *pcbSize = dwSize;
    }
    else if (DoesCPTagExist(pProfile, dwBToATag, &dwIndex))
    {
        bRc = CreateLutCRD(pProfile, dwIndex, pBuffer, pcbSize, dwIntent, *pbBinary);
    }
    else if (DoesCPTagExist(pProfile, TAG_GRAYTRC, &dwIndex))
    {
        bRc = CreateMonoCRD(pProfile, dwIndex, pBuffer, pcbSize, dwIntent);
    }
#if !defined(KERNEL_MODE) || defined(USERMODE_DRIVER)
    else if (DoesTRCAndColorantTagExist(pProfile))
    {
        bRc = CreateMatrixCRD(pProfile, pBuffer, pcbSize, dwIntent, *pbBinary);
    }
#endif // !defined(KERNEL_MODE) || defined(USERMODE_DRIVER)
    else
    {
        WARNING((__TEXT("Profile doesn't have tags to create CRD\n")));
        SetLastError(ERROR_INVALID_PROFILE);
    }

    return bRc;
}

#if !defined(KERNEL_MODE) || defined(USERMODE_DRIVER)

/******************************************************************************
 *
 *                    InternalGetPS2PreviewCRD
 *
 *  Function:
 *       This functions creates a preview PostScript Level 2 CRD from the
 *       specified destination and target profiles
 *       To do this, it does the following:
 *           1) Creates host deviceCRD deviceCSA targetCRD.
 *           2) Creates proofing CRD by sampling deviceCRD deviceCSA and targetCRD.
 *           3) Uses deviceCRD's input table as proofingCRD's input table.
 *           4) Uses targetCRD's output table as proofingCRD's output table.
 *           5) Sample data is XYZ or Lab, depends on PCS of targetCRD.
 *
 *  Arguments:
 *       pDestProf    - memory mapped pointer to destination profile
 *       pTargetProf  - memory mapped pointer to target profile
 *       dwIntent     - intent whose CRD is required
 *       pbuffer      - pointer to receive the CSA
 *       pcbSize      - pointer to size of buffer. If function fails because
 *                      buffer is not big enough, it is filled with required size.
 *       pcbBinary    - TRUE if binary data is requested. On return it is set to
 *                      reflect the data returned
 *
 *  Returns:
 *       TRUE if successful, FALSE otherwise
 *
 ******************************************************************************/

BOOL
InternalGetPS2PreviewCRD(
    PBYTE   pDestProf,
    PBYTE   pTargetProf,
    DWORD   dwIntent,
    PBYTE   pBuffer,
    PDWORD  pcbSize,
    PBOOL   pbBinary
    )
{
    DWORD      i, j, k, l, dwDev, dwTag, dwPCS;
    DWORD      dwInArraySize = 0, dwOutArraySize = 0;
    DWORD      nDevGrids, nTargetGrids, nPreviewCRDGrids;
    DWORD      cbDevCRD, cbTargetCSA, cbTargetCRD;
    float      fInput[MAXCHANNELS];
    float      fOutput[MAXCHANNELS];
    float      fTemp[MAXCHANNELS];
    PBYTE      pLineStart, pStart = pBuffer;
    PBYTE      lpDevCRD = NULL, lpTargetCSA = NULL, lpTargetCRD = NULL;
    char       pPublicArrayName[5];
    BOOL       bRc = FALSE;

    dwDev = GetCPDevSpace(pTargetProf);
    i = (dwDev == SPACE_CMYK) ? 4 : 3;

    //
    // Get the input array size IntentTag and Grid of the destination profile
    //

    if (!GetCRDInputOutputArraySize(
            pTargetProf,
            dwIntent,
            &dwInArraySize,
            NULL,
            &dwTag,
            &nTargetGrids))
        return FALSE;

    //
    // Get the output array size IntentTag and Grid of the target profile
    //

    if (!GetCRDInputOutputArraySize(
            pDestProf,
            dwIntent,
            NULL,
            &dwOutArraySize,
            &dwTag,
            &nDevGrids))
        return FALSE;

    nPreviewCRDGrids = (nTargetGrids > nDevGrids) ? nTargetGrids : nDevGrids;

    //
    // Min proofing CRD grid will be PREVIEWCRDGRID
    //

    if (nPreviewCRDGrids < PREVIEWCRDGRID)
        nPreviewCRDGrids = PREVIEWCRDGRID;

    if (pBuffer == NULL)
    {
        //
        // Return size of buffer needed
        //

        *pcbSize = nPreviewCRDGrids * nPreviewCRDGrids * nPreviewCRDGrids *
                   i * 2        +    // CLUT size (Hex output)
                   dwOutArraySize +  // Output Array size
                   dwInArraySize  +  // Input Array size
                   4096;             // Extra PostScript stuff

        //
        // Add space for new line.
        //

        *pcbSize += (((*pcbSize) / MAX_LINELEN) + 1) * STRLEN(NewLine);

        return TRUE;
    }

    //
    // Query the sizes of host target CRD, target CSA and device CRD
    //

    if (!GetHostColorRenderingDictionary(pTargetProf, dwIntent, NULL, &cbTargetCRD) ||
        !GetHostColorSpaceArray(pTargetProf, dwIntent, NULL, &cbTargetCSA) ||
        !GetHostColorRenderingDictionary(pDestProf, dwIntent, NULL, &cbDevCRD))
    {
        return FALSE;
    }

    //
    // Allocate buffers for host target CRD, target CSA and device CRD
    //

    if (((lpTargetCRD = MemAlloc(cbTargetCRD)) == NULL) ||
        ((lpTargetCSA = MemAlloc(cbTargetCSA)) == NULL) ||
        ((lpDevCRD = MemAlloc(cbDevCRD)) == NULL))
    {
        goto Done;
    }

    //
    // Build host target CRD, target CSA and device CRD
    //

    if (!GetHostColorRenderingDictionary(pTargetProf, dwIntent, lpTargetCRD, &cbTargetCRD) ||
        !GetHostColorSpaceArray(pTargetProf, dwIntent, lpTargetCSA, &cbTargetCSA) ||
        !GetHostColorRenderingDictionary(pDestProf, dwIntent, lpDevCRD, &cbDevCRD))
    {
        goto Done;
    }

    //
    // Create global data
    //

    GetPublicArrayName(dwTag, pPublicArrayName);

    //
    // Build Proofing CRD based on Host target CRD, target CSA and dest CRD.
    // We use target CRD input tables and matrix as the input tables and
    // matrix of the ProofCRD. We use dest CRD output tables as the
    // output tables of the ProofCRD.
    //

    pBuffer += WriteNewLineObject(pBuffer, CRDBegin);

    pBuffer += EnableGlobalDict(pBuffer);
    pBuffer += BeginGlobalDict(pBuffer);

    pBuffer += CreateInputArray(pBuffer, 0, 0, pPublicArrayName,
                    0, NULL, *pbBinary, lpTargetCRD);

    pBuffer += CreateOutputArray(pBuffer, 0, 0, 0,
                    pPublicArrayName, 0, NULL, *pbBinary, lpDevCRD);

    pBuffer += EndGlobalDict(pBuffer);

    //
    // Start writing the CRD
    //

    pBuffer += WriteNewLineObject(pBuffer, BeginDict);     // Begin dictionary
    pBuffer += WriteObject(pBuffer, DictType);      // Dictionary type

    //
    // Send /RenderingIntent
    //

    switch (dwIntent)
    {
        case INTENT_PERCEPTUAL:
            pBuffer += WriteNewLineObject(pBuffer, IntentType);
            pBuffer += WriteObject(pBuffer, IntentPer);
            break;

        case INTENT_SATURATION:
            pBuffer += WriteNewLineObject(pBuffer, IntentType);
            pBuffer += WriteObject(pBuffer, IntentSat);
            break;

        case INTENT_RELATIVE_COLORIMETRIC:
            pBuffer += WriteNewLineObject(pBuffer, IntentType);
            pBuffer += WriteObject(pBuffer, IntentRCol);
            break;

        case INTENT_ABSOLUTE_COLORIMETRIC:
            pBuffer += WriteNewLineObject(pBuffer, IntentType);
            pBuffer += WriteObject(pBuffer, IntentACol);
            break;
    }

    //
    // /BlackPoint & /WhitePoint
    //

    pBuffer += SendCRDBWPoint(pBuffer, ((PHOSTCLUT)lpTargetCRD)->afxIlluminantWP);

    //
    // Send PQR - used for Absolute Colorimetric
    //

    pBuffer += SendCRDPQR(pBuffer, dwIntent, ((PHOSTCLUT)lpTargetCRD)->afxIlluminantWP);

    //
    // Send LMN - For Absolute Colorimetric use WhitePoint's XYZs
    //

    pBuffer += SendCRDLMN(pBuffer, dwIntent,
                   ((PHOSTCLUT)lpTargetCRD)->afxIlluminantWP,
                   ((PHOSTCLUT)lpTargetCRD)->afxMediaWP,
                   ((PHOSTCLUT)lpTargetCRD)->dwPCS);

    //
    // Send ABC
    //

    pBuffer += SendCRDABC(pBuffer, pPublicArrayName,
                   ((PHOSTCLUT)lpTargetCRD)->dwPCS,
                   ((PHOSTCLUT)lpTargetCRD)->nInputCh,
                   NULL,
                   ((PHOSTCLUT)lpTargetCRD)->e,
                   (((PHOSTCLUT)lpTargetCRD)->nLutBits == 8)? LUT8_TYPE : LUT16_TYPE,
                   *pbBinary);

    //
    // /RenderTable
    //

    pBuffer += WriteNewLineObject(pBuffer, RenderTableTag);
    pBuffer += WriteObject(pBuffer, BeginArray);

    pBuffer += WriteInt(pBuffer, nPreviewCRDGrids);  // Send down Na
    pBuffer += WriteInt(pBuffer, nPreviewCRDGrids);  // Send down Nb
    pBuffer += WriteInt(pBuffer, nPreviewCRDGrids);  // Send down Nc

    pLineStart = pBuffer;
    pBuffer += WriteNewLineObject(pBuffer, BeginArray);
    dwPCS = ((PHOSTCLUT)lpDevCRD)->dwPCS;

    for (i=0; i<nPreviewCRDGrids; i++)        // Na strings should be sent
    {
        pBuffer += WriteObject(pBuffer, NewLine);
        pLineStart = pBuffer;
        if (*pbBinary)
        {
            pBuffer += WriteStringToken(pBuffer, 143,
                nPreviewCRDGrids * nPreviewCRDGrids * ((PHOSTCLUT)lpDevCRD)->nOutputCh);
        }
        else
        {
            pBuffer += WriteObject(pBuffer, BeginString);
        }
        fInput[0] = ((float)i) / (nPreviewCRDGrids - 1);
        for (j=0; j<nPreviewCRDGrids; j++)
        {
            fInput[1] = ((float)j) / (nPreviewCRDGrids - 1);
            for (k=0; k<nPreviewCRDGrids; k++)
            {
                fInput[2] = ((float)k) / (nPreviewCRDGrids - 1);

                DoHostConversionCRD((PHOSTCLUT)lpTargetCRD, NULL, fInput, fOutput, 1);
                DoHostConversionCSA((PHOSTCLUT)lpTargetCSA, fOutput, fTemp);
                DoHostConversionCRD((PHOSTCLUT)lpDevCRD, (PHOSTCLUT)lpTargetCSA,
                                     fTemp, fOutput, 0);
                for (l=0; l<((PHOSTCLUT)lpDevCRD)->nOutputCh; l++)
                {
                    if (*pbBinary)
                    {
                        *pBuffer++ = (BYTE)(fOutput[l] * 255);
                    }
                    else
                    {
                        pBuffer += WriteHex(pBuffer, (USHORT)(fOutput[l] * 255));
                        if ((pBuffer - pLineStart) > MAX_LINELEN)
                        {
                            pLineStart = pBuffer;
                            pBuffer += WriteObject(pBuffer, NewLine);
                        }
                    }
                }
            }
        }
        if (!*pbBinary)
            pBuffer += WriteObject(pBuffer, EndString);
    }
    pBuffer += WriteNewLineObject(pBuffer, EndArray);
    pBuffer += WriteInt(pBuffer, ((PHOSTCLUT)lpDevCRD)->nOutputCh);

    //
    // Send output table
    //

    pBuffer += SendCRDOutputTable(pBuffer, pPublicArrayName,
                    ((PHOSTCLUT)lpDevCRD)->nOutputCh,
                    (((PHOSTCLUT)lpDevCRD)->nLutBits == 8)? LUT8_TYPE : LUT16_TYPE,
                    TRUE,
                    *pbBinary);

    pBuffer += WriteNewLineObject(pBuffer, EndArray);
    pBuffer += WriteObject(pBuffer, EndDict); // End dictionary definition
    pBuffer += WriteNewLineObject(pBuffer, CRDEnd);
    bRc = TRUE;

Done:
    *pcbSize = (DWORD)(pBuffer - pStart);

    if (lpTargetCRD)
         MemFree(lpTargetCRD);
    if (lpTargetCSA)
         MemFree(lpTargetCSA);
    if (lpDevCRD)
         MemFree(lpDevCRD);

    return bRc;
}

#endif //  !defined(KERNEL_MODE) || defined(USERMODE_DRIVER)


/******************************************************************************
 *
 *                               GetCSAFromProfile
 *
 *  Function:
 *       This function gets the Color Space Array from the profile if the
 *       tag is present
 *
 *  Arguments:
 *       pProfile  - pointer to the memory mapped  profile
 *       dwIntent  - rendering intent of CSA requested
 *       dwCSAType - type of CSA requested
 *       pBuffer   - pointer to receive the CSA
 *       pcbSize   - pointer to size of buffer. If function fails because
 *                   buffer is not big enough, it is filled with required size.
 *       pcbBinary - TRUE if binary data is requested. On return it is set to
 *                   reflect the data returned
 *
 *  Returns:
 *       TRUE if successful, FALSE otherwise
 *
 ******************************************************************************/

BOOL
GetCSAFromProfile (
    PBYTE  pProfile,
    DWORD  dwIntent,
    DWORD  dwCSAType,
    PBYTE  pBuffer,
    PDWORD pcbSize,
    PBOOL  pbBinary
    )
{
    DWORD dwDev, dwProfileIntent;
    DWORD dwIndex, dwSize, dwDataType;
    BOOL  bRc = FALSE;

    //
    // This function can fail without setting an error, so reset error
    // here to prevent confusion later
    //

    SetLastError(0);

    //
    // Get the profile's color space and rendering intent
    //

    dwDev = GetCPDevSpace(pProfile);
    dwProfileIntent = GetCPRenderIntent(pProfile);

    //
    // If the rendering intents don't match, or the profile's color space
    // is incompatible with requested CSA type, fail
    //

    if  ((dwIntent != dwProfileIntent) ||
         ((dwDev == SPACE_GRAY) &&
         ((dwCSAType != CSA_GRAY) && (dwCSAType != CSA_A))))
    {
        WARNING((__TEXT("Can't use profile's CSA tag due to different rendering intents\n")));
        return FALSE;
    }

    if (DoesCPTagExist(pProfile, TAG_PS2CSA, &dwIndex))
    {
        (void)GetCPElementDataSize(pProfile, dwIndex, &dwSize);

        (void)GetCPElementDataType(pProfile, dwIndex, &dwDataType);

        if (! *pbBinary && dwDataType == 1)
        {
            //
            // Profile has binary data, user asked for ASCII, so we have to
            // ASCII 85 encode it
            //

            dwSize = dwSize * 5 / 4 + sizeof(ASCII85DecodeBegin) + sizeof(ASCII85DecodeEnd) + 2048;
        }

        if (pBuffer)
        {
            if (*pcbSize >= dwSize)
            {
                (void)GetCPElementData(pProfile, dwIndex, pBuffer, &dwSize);

                if (! *pbBinary && dwDataType == 1)
                {
                    dwSize = Ascii85Encode(pBuffer, dwSize, *pcbSize);
                }
                bRc = TRUE;
            }
            else
            {
                WARNING((__TEXT("Buffer too small to get CSA\n")));
                SetLastError(ERROR_INSUFFICIENT_BUFFER);
            }
        }
        else
            bRc = TRUE;

        *pcbSize = dwSize;
    }

    return bRc;
}


/******************************************************************************
 *
 *                              GetPS2CSA_MONO_A
 *
 *  Function:
 *       This function creates a CIEBasedA colorspace array from an input
 *       GRAY profile
 *
 *  Arguments:
 *       pProfile  - pointer to the memory mapped profile
 *       pBuffer   - pointer to receive the CSA
 *       pcbSize   - pointer to size of buffer. If function fails because
 *                   buffer is not big enough, it is filled with required size.
 *       dwIntent  - rendering intent of CSA requested
 *       pcbBinary - TRUE if binary data is requested. On return it is set to
 *                   reflect the data returned
 *
 *  Returns:
 *       TRUE if successful, FALSE otherwise
 *
 ******************************************************************************/

BOOL
GetPS2CSA_MONO_A(
    PBYTE  pProfile,
    PBYTE  pBuffer,
    PDWORD pcbSize,
    DWORD  dwIntent,
    PBOOL  pbBinary
    )
{
    PCURVETYPE pData;
    PTAGDATA   pTagData;
    PBYTE      pLineStart, pStart = pBuffer;
    PBYTE      pTable;
    DWORD      i, dwPCS, nCount;
    DWORD      dwIndex, dwSize;
    DWORD      afxIlluminantWP[3];
    DWORD      afxMediaWP[3];

    //
    // Check if we can generate the CSA
    // Required tag is gray TRC
    //

    if (! DoesCPTagExist(pProfile, TAG_GRAYTRC, &dwIndex))
    {
        WARNING((__TEXT("Gray TRC tag not present to create MONO_A CSA\n")));
        SetLastError(ERROR_TAG_NOT_PRESENT);
        return FALSE;
    }

    dwPCS = GetCPConnSpace(pProfile);

    (void)GetCPElementSize(pProfile, dwIndex, &dwSize);

    pTagData = (PTAGDATA)(pProfile + sizeof(PROFILEHEADER) + sizeof(DWORD) +
               dwIndex * sizeof(TAGDATA));

    pData = (PCURVETYPE)(pProfile + FIX_ENDIAN(pTagData->dwOffset));

    nCount = FIX_ENDIAN(pData->nCount);

    //
    // Estimate size required to hold the CSA
    //

    dwSize = nCount * 6 +               // Number of INT elements
        3 * (STRLEN(IndexArray) +
             STRLEN(StartClip) +
             STRLEN(EndClip)) +
        2048;                           // + other PS stuff

    //
    // Add space for new line.
    //

    dwSize += (((dwSize) / MAX_LINELEN) + 1) * STRLEN(NewLine);

    if (! pBuffer)
    {
        *pcbSize = dwSize;
        return TRUE;
    }
    else if (*pcbSize < dwSize)
    {
        WARNING((__TEXT("Buffer too small to get MONO_A CSA\n")));
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return FALSE;
    }

    //
    // Get info about Illuminant White Point from the header
    //

    (void)GetCPWhitePoint(pProfile, afxIlluminantWP);

    //
    // Support absolute whitePoint
    //

    (void)GetMediaWP(pProfile, dwIntent, afxIlluminantWP, afxMediaWP);

    //
    // Start creating the ColorSpace
    //

    pBuffer += WriteNewLineObject(pBuffer, CieBasedABegin);

    pBuffer += WriteNewLineObject(pBuffer, BeginArray);   // Begin array

    //
    // /CIEBasedA
    //

    pBuffer += WriteObject(pBuffer, CIEBasedATag); // Create entry
    pBuffer += WriteObject(pBuffer, BeginDict);    // Begin dictionary

    //
    // Send /BlackPoint & /WhitePoint
    //

    pBuffer += SendCSABWPoint(pBuffer, dwIntent, afxIlluminantWP, afxMediaWP);

    //
    // /DecodeA
    //

    pBuffer += WriteObject(pBuffer, NewLine);
    pLineStart = pBuffer;

    if (nCount != 0)
    {
        pBuffer += WriteObject(pBuffer, DecodeATag);
        pBuffer += WriteObject(pBuffer, BeginArray);

        pBuffer += WriteObject(pBuffer, BeginFunction);

        pTable = (PBYTE)(pData->data);

        if (nCount == 1)                // Gamma supplied in ui16 format
        {
            pBuffer += WriteInt(pBuffer, FIX_ENDIAN16(*((PWORD)pTable)));
            pBuffer += WriteObject(pBuffer, DecodeA3);

            //
            // If the PCS is Lab, we need to convert Lab to XYZ
            // Now, the range is from 0 --> 0.99997.
            // Actually, the conversion from Lab to XYZ is not needed
            //

            if (dwPCS == SPACE_Lab)
            {
                pBuffer += WriteObject(pBuffer, DecodeALab);
                pBuffer += WriteObject(pBuffer, DecodeLMNLab);
            }
        }
        else
        {
            pBuffer += WriteObject(pBuffer, StartClip);
            pBuffer += WriteObject(pBuffer, BeginArray);
            for (i=0; i<nCount; i++)
            {
                pBuffer += WriteInt(pBuffer, FIX_ENDIAN16(*((PWORD)pTable)));
                pTable += sizeof(WORD);
                if (((DWORD) (pBuffer - pLineStart)) > MAX_LINELEN)
                {
                    pLineStart = pBuffer;
                    pBuffer += WriteObject (pBuffer, NewLine);
                }
            }
            pBuffer += WriteObject(pBuffer, EndArray);
            pLineStart = pBuffer;
            pBuffer += WriteObject(pBuffer, NewLine);

            pBuffer += WriteObject(pBuffer, IndexArray);
            pBuffer += WriteObject(pBuffer, Scale16);

            //
            // If the PCS is Lab, we need to convert Lab to XYZ
            // Now, the range is from 0 --> .99997.
            // Actually, the conversion from Lab to XYZ is not needed.
            //

            if (dwPCS == SPACE_Lab)
            {
                pBuffer += WriteObject(pBuffer, DecodeALab);
                pBuffer += WriteObject(pBuffer, DecodeLMNLab);
            }
            pBuffer += WriteObject(pBuffer, EndClip);
        }

        pBuffer += WriteObject(pBuffer, EndFunction);
        pBuffer += WriteObject(pBuffer, EndArray);
    }

    //
    // /MatrixA
    //

    pBuffer += WriteNewLineObject(pBuffer, MatrixATag);
    pBuffer += WriteObject(pBuffer, BeginArray);
    for (i=0; i<3; i++)
    {
        if (dwIntent == INTENT_ABSOLUTE_COLORIMETRIC)
        {
            pBuffer += WriteFixed(pBuffer, afxMediaWP[i]);
        }
        else
        {
            pBuffer += WriteFixed(pBuffer, afxIlluminantWP[i]);
        }
    }
    pBuffer += WriteObject(pBuffer, EndArray);

    //
    // /RangeLMN
    //

    pBuffer += WriteNewLineObject(pBuffer, RangeLMNTag);
    pBuffer += WriteObject(pBuffer, RangeLMN);

    //
    // /End dictionary
    //

    pBuffer += WriteObject(pBuffer, EndDict);  // End dictionary definition
    pBuffer += WriteObject(pBuffer, EndArray);

    pBuffer += WriteNewLineObject(pBuffer, CieBasedAEnd);

    *pcbSize = (DWORD) (pBuffer - pStart);

    return TRUE;
}


/******************************************************************************
 *
 *                              GetPS2CSA_ABC
 *
 *  Function:
 *       This function creates a CIEBasedABC colorspace array from an input
 *       RGB profile
 *
 *  Arguments:
 *       pProfile  - pointer to the memory mapped profile
 *       pBuffer   - pointer to receive the CSA
 *       pcbSize   - pointer to size of buffer. If function fails because
 *                   buffer is not big enough, it is filled with required size.
 *       dwIntent  - rendering intent of CSA requested
 *       pcbBinary - TRUE if binary data is requested. On return it is set to
 *                   reflect the data returned
 *       bBackup   - TRUE: A CIEBasedDEF has been created, this CSA is a backup
 *                          in case some old printer can not support CIEBasedDEF.
 *                   FALSE: No CIEBasedDEF. This is the only CSA.
 *
 *  Returns:
 *       TRUE if successful, FALSE otherwise
 *
 ******************************************************************************/

BOOL
GetPS2CSA_ABC(
    PBYTE  pProfile,
    PBYTE  pBuffer,
    PDWORD pcbSize,
    DWORD  dwIntent,
    PBOOL  pbBinary,
    BOOL   bBackup
    )
{
    PBYTE     pStart = pBuffer;
    DWORD     i, dwPCS, dwDev, dwSize;
    FIX_16_16 afxIlluminantWP[3];
    FIX_16_16 afxMediaWP[3];

    //
    // Check if we can generate the CSA:
    // Required  tags are red, green and blue Colorants & TRCs
    //

    dwPCS = GetCPConnSpace(pProfile);
    dwDev = GetCPDevSpace(pProfile);

    //
    // Call another function to handle Lab profiles
    //

    if (dwDev == SPACE_Lab)
    {
        return GetPS2CSA_ABC_Lab(pProfile, pBuffer, pcbSize, dwIntent, pbBinary);
    }

    //
    // We only handle RGB profiles in this function
    //

    if ((dwDev != SPACE_RGB)                   ||
        !DoesTRCAndColorantTagExist(pProfile))
    {
        WARNING((__TEXT("Colorant or TRC tag not present to create ABC CSA\n")));
        SetLastError(ERROR_TAG_NOT_PRESENT);
        return FALSE;
    }

    //
    // Estimate size required to hold the CSA
    //

    dwSize = 65530;

    if (! pBuffer)
    {
        *pcbSize = dwSize;
        return TRUE;
    }
    else if (*pcbSize < dwSize)
    {
        WARNING((__TEXT("Buffer too small to get ABC CSA\n")));
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return FALSE;
    }

    //
    // Get info about Illuminant White Point from the header
    //

    (void)GetCPWhitePoint(pProfile, afxIlluminantWP);

    //
    // Support absolute whitePoint
    //

    (void)GetMediaWP(pProfile, dwIntent, afxIlluminantWP, afxMediaWP);

    //
    // Create global data
    //

    pBuffer += WriteNewLineObject(pBuffer, CieBasedABCBegin);

    if (IsSRGBColorProfile(pProfile))
    {
        pBuffer += WriteNewLineObject(pBuffer, sRGBColorSpaceArray);
    }
    else
    {
        pBuffer += EnableGlobalDict(pBuffer);

        if (bBackup)
        {
            pBuffer += WriteNewLineObject(pBuffer, NotSupportDEFG_S);
        }

        pBuffer += BeginGlobalDict(pBuffer);

        pBuffer += CreateColSpArray(pProfile, pBuffer, TAG_REDTRC, *pbBinary);
        pBuffer += CreateColSpArray(pProfile, pBuffer, TAG_GREENTRC, *pbBinary);
        pBuffer += CreateColSpArray(pProfile, pBuffer, TAG_BLUETRC, *pbBinary);

        pBuffer += WriteNewLineObject(pBuffer, EndOp);

        if (bBackup)
        {
            pBuffer += WriteNewLineObject(pBuffer, SupportDEFG_E);
        }

        pBuffer += WriteNewLineObject(pBuffer, SetGlobalOp);

        if (bBackup)
        {
            pBuffer += WriteNewLineObject(pBuffer, NotSupportDEFG_S);
        }

        //
        // Start creating the ColorSpace
        //

        pBuffer += WriteNewLineObject(pBuffer, BeginArray);       // Begin array

        //
        // /CIEBasedABC
        //

        pBuffer += WriteObject(pBuffer, CIEBasedABCTag);   // Create entry
        pBuffer += WriteObject(pBuffer, BeginDict);        // Begin dictionary

        //
        // /BlackPoint & /WhitePoint
        //

        pBuffer += SendCSABWPoint(pBuffer, dwIntent, afxIlluminantWP, afxMediaWP);

        //
        // /DecodeABC
        //

        pBuffer += WriteNewLineObject(pBuffer, DecodeABCTag);
        pBuffer += WriteObject(pBuffer, BeginArray);

        pBuffer += WriteObject(pBuffer, NewLine);
        pBuffer += CreateColSpProc(pProfile, pBuffer, TAG_REDTRC, *pbBinary);
        pBuffer += WriteObject(pBuffer, NewLine);
        pBuffer += CreateColSpProc(pProfile, pBuffer, TAG_GREENTRC, *pbBinary);
        pBuffer += WriteObject(pBuffer, NewLine);
        pBuffer += CreateColSpProc(pProfile, pBuffer, TAG_BLUETRC, *pbBinary);
        pBuffer += WriteObject(pBuffer, EndArray);

        //
        // /MatrixABC
        //

        pBuffer += WriteNewLineObject(pBuffer, MatrixABCTag);
        pBuffer += WriteObject(pBuffer, BeginArray);

        pBuffer += CreateFloatString(pProfile, pBuffer, TAG_REDCOLORANT);
        pBuffer += CreateFloatString(pProfile, pBuffer, TAG_GREENCOLORANT);
        pBuffer += CreateFloatString(pProfile, pBuffer, TAG_BLUECOLORANT);

        pBuffer += WriteObject(pBuffer, EndArray);

        //
        // /RangeLMN
        //

        pBuffer += WriteObject(pBuffer, NewLine);
        pBuffer += WriteObject(pBuffer, RangeLMNTag);
        pBuffer += WriteObject(pBuffer, RangeLMN);

        //
        // /DecodeLMN
        //

        if (dwIntent == INTENT_ABSOLUTE_COLORIMETRIC)
        {
            //
            // Support absolute whitePoint
            //

            pBuffer += WriteNewLineObject(pBuffer, DecodeLMNTag);
            pBuffer += WriteObject(pBuffer, BeginArray);
            for (i=0; i<3; i++)
            {
                pBuffer += WriteObject(pBuffer, BeginFunction);
                pBuffer += WriteFixed(pBuffer, FIX_DIV(afxMediaWP[i], afxIlluminantWP[i]));
                pBuffer += WriteObject(pBuffer, MulOp);
                pBuffer += WriteObject(pBuffer, EndFunction);
            }
            pBuffer += WriteObject (pBuffer, EndArray);
        }

        //
        // End dictionary definition
        //

        pBuffer += WriteNewLineObject(pBuffer, EndDict);
        pBuffer += WriteObject(pBuffer, EndArray);

        pBuffer += WriteNewLineObject(pBuffer, CieBasedABCEnd);
    }

    *pcbSize = (DWORD) (pBuffer - pStart);

    return TRUE;
}


/******************************************************************************
 *
 *                              GetPS2CSA_ABC_Lab
 *
 *  Function:
 *       This function creates a CIEBasedABC colorspace array from an input
 *       Lab profile
 *
 *  Arguments:
 *       pProfile  - pointer to the memory mapped profile
 *       pBuffer   - pointer to receive the CSA
 *       pcbSize   - pointer to size of buffer. If function fails because
 *                   buffer is not big enough, it is filled with required size.
 *       dwIntent  - rendering intent of CSA requested
 *       pcbBinary - TRUE if binary data is requested. On return it is set to
 *                   reflect the data returned
 *
 *  Returns:
 *       TRUE if successful, FALSE otherwise
 *
 ******************************************************************************/

BOOL
GetPS2CSA_ABC_Lab(
    PBYTE  pProfile,
    PBYTE  pBuffer,
    PDWORD pcbSize,
    DWORD  dwIntent,
    PBOOL  pbBinary
    )
{
    PBYTE     pStart = pBuffer;
    DWORD     i, dwSize;
    FIX_16_16 afxIlluminantWP[3];
    FIX_16_16 afxMediaWP[3];

    //
    // Estimate size required to hold the CSA
    //

    dwSize = 65530;

    if (! pBuffer)
    {
        *pcbSize = dwSize;
        return TRUE;
    }
    else if (*pcbSize < dwSize)
    {
        WARNING((__TEXT("Buffer too small to get ABC_Lab CSA\n")));
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return FALSE;
    }

    //
    // Get info about Illuminant White Point from the header
    //

    (void)GetCPWhitePoint(pProfile, afxIlluminantWP);

    //
    // Support absolute whitePoint
    //

    GetMediaWP(pProfile, dwIntent, afxIlluminantWP, afxMediaWP);

    //
    // Start creating the ColorSpace
    //

    pBuffer += WriteNewLineObject(pBuffer, BeginArray);       // Begin array

    //
    // /CIEBasedABC
    //

    pBuffer += WriteObject(pBuffer, CIEBasedABCTag);   // Create entry
    pBuffer += WriteObject(pBuffer, BeginDict);        // Begin dictionary

    //
    // /BlackPoint & /WhitePoint
    //

    pBuffer += SendCSABWPoint(pBuffer, dwIntent, afxIlluminantWP, afxMediaWP);

    //
    // /RangeABC
    //

    pBuffer += WriteNewLineObject(pBuffer, RangeABCTag);
    pBuffer += WriteObject(pBuffer, RangeABC_Lab);

    //
    // /DecodeABC
    //

    pBuffer += WriteNewLineObject(pBuffer, DecodeABCTag);
    pBuffer += WriteObject(pBuffer, DecodeABCLab1);

    //
    // /MatrixABC
    //

    pBuffer += WriteNewLineObject(pBuffer, MatrixABCTag);
    pBuffer += WriteObject(pBuffer, MatrixABCLab);

    //
    // /DecodeLMN
    //

    pBuffer += WriteNewLineObject(pBuffer, DecodeLMNTag);
    pBuffer += WriteObject(pBuffer, BeginArray);
    for (i=0; i<3; i++)
    {
        pBuffer += WriteObject(pBuffer, BeginFunction);
        pBuffer += WriteObject(pBuffer, DecodeLMNLab);

        if (dwIntent == INTENT_ABSOLUTE_COLORIMETRIC)
        {
            pBuffer += WriteFixed(pBuffer, afxMediaWP[i]);
        }
        else
        {
            pBuffer += WriteFixed(pBuffer, afxIlluminantWP[i]);
        }
        pBuffer += WriteObject(pBuffer, MulOp);
        pBuffer += WriteObject(pBuffer, EndFunction);
        pBuffer += WriteObject(pBuffer, NewLine);
    }
    pBuffer += WriteObject(pBuffer, EndArray);


    //
    // End dictionary definition
    //

    pBuffer += WriteNewLineObject(pBuffer, EndDict);
    pBuffer += WriteObject(pBuffer, EndArray);

    pBuffer += WriteNewLineObject(pBuffer, CieBasedABCEnd);

    *pcbSize = (DWORD) (pBuffer - pStart);

    return TRUE;
}


/******************************************************************************
 *
 *                           GetPS2CSA_DEFG
 *
 *  Function:
 *       This function creates DEF and DEFG based CSAs from the data supplied
 *       in the RGB or CMYK profiles respectively
 *
 *  Arguments:
 *       pProfile  - pointer to the memory mapped profile
 *       pBuffer   - pointer to receive the CSA
 *       pcbSize   - pointer to size of buffer. If function fails because
 *                   buffer is not big enough, it is filled with required size.
 *       dwIntent  - rendering intent of CSA requested
 *       dwType    - whether DEF CSA or DEFG CSA is required
 *       pcbBinary - TRUE if binary data is requested. On return it is set to
 *                   reflect the data returned
 *
 *  Returns:
 *       TRUE if successful, FALSE otherwise
 *
 ******************************************************************************/

BOOL
GetPS2CSA_DEFG(
    PBYTE  pProfile,
    PBYTE  pBuffer,
    PDWORD pcbSize,
    DWORD  dwIntent,
    DWORD  dwType,
    PBOOL  pbBinary
    )
{
    PLUT16TYPE pLut;
    PTAGDATA   pTagData;
    PBYTE      pLineStart, pStart = pBuffer;
    PBYTE      pTable;
    DWORD      i, j, k, dwPCS, dwDev, dwIndex, dwTag, dwLutSig, SecondGrids, dwSize;
    DWORD      nInputCh, nOutputCh, nGrids, nInputTable, nOutputTable, nNumbers;
    FIX_16_16  afxIlluminantWP[3];
    FIX_16_16  afxMediaWP[3];
    char       pPublicArrayName[5];

    //
    // Make sure required tags exist
    //

    switch (dwIntent)
    {
    case INTENT_PERCEPTUAL:
        dwTag = TAG_AToB0;
        break;

    case INTENT_RELATIVE_COLORIMETRIC:
        dwTag = TAG_AToB1;
        break;

    case INTENT_SATURATION:
        dwTag = TAG_AToB2;
        break;

    case INTENT_ABSOLUTE_COLORIMETRIC:
        dwTag = TAG_AToB1;
        break;

    default:
        WARNING((__TEXT("Invalid intent passed to GetPS2CSA_DEFG: %d\n"), dwIntent));
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if (! DoesCPTagExist(pProfile, dwTag, &dwIndex))
    {
        WARNING((__TEXT("AToB%d tag not present to create DEF(G) CSA\n"), dwIntent));
        SetLastError(ERROR_TAG_NOT_PRESENT);
        return FALSE;
    }

    //
    // Check if we can generate the CSA
    // Required  tags is AToBi, where i is the rendering intent
    //

    dwPCS = GetCPConnSpace(pProfile);
    dwDev = GetCPDevSpace(pProfile);

    if ((dwType == TYPE_CIEBASEDDEF  && dwDev != SPACE_RGB) ||
        (dwType == TYPE_CIEBASEDDEFG && dwDev != SPACE_CMYK))
    {
        WARNING((__TEXT("RGB profile & requesting CMYK CSA or vice versa\n")));
        SetLastError(ERROR_TAG_NOT_PRESENT);
        return FALSE;
    }

    pTagData = (PTAGDATA)(pProfile + sizeof(PROFILEHEADER) + sizeof(DWORD) +
               dwIndex * sizeof(TAGDATA));

    pLut = (PLUT16TYPE)(pProfile + FIX_ENDIAN(pTagData->dwOffset));

    dwLutSig = FIX_ENDIAN(pLut->dwSignature);

    if (((dwPCS != SPACE_Lab) && (dwPCS != SPACE_XYZ)) ||
        ((dwLutSig != LUT8_TYPE) && (dwLutSig != LUT16_TYPE)))
    {
        WARNING((__TEXT("Invalid color space - unable to create DEF(G) CSA\n")));
        SetLastError(ERROR_INVALID_PROFILE);
        return FALSE;
    }

    //
    // Estimate size required to hold the CSA
    //

    (void)GetCLUTInfo(dwLutSig, (PBYTE)pLut, &nInputCh, &nOutputCh, &nGrids,
                &nInputTable, &nOutputTable, NULL);

    //
    // Calculate size of buffer needed
    //

    if (dwType == TYPE_CIEBASEDDEFG)
    {
        dwSize = nOutputCh * nGrids * nGrids * nGrids * nGrids * 2;
    }
    else
    {
        dwSize = nOutputCh * nGrids * nGrids * nGrids * 2;
    }

    dwSize = dwSize +
        nInputCh * nInputTable * 6 +
        nOutputCh * nOutputTable * 6 +      // Number of INT bytes
        nInputCh * (STRLEN(IndexArray) +
                    STRLEN(StartClip) +
                    STRLEN(EndClip)) +
        nOutputCh * (STRLEN(IndexArray) +
                     STRLEN(StartClip) +
                     STRLEN(EndClip)) +
        4096;                               // + other PS stuff

    //
    // Add space for new line.
    //

    dwSize += (((dwSize) / MAX_LINELEN) + 1) * STRLEN(NewLine);

    if (! pBuffer)
    {
        *pcbSize = dwSize;
        return TRUE;
    }
    else if (*pcbSize < dwSize)
    {
        WARNING((__TEXT("Buffer too small to get DEFG CSA\n")));
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return FALSE;
    }

    //
    // Get info about Illuminant White Point from the header
    //

    (void)GetCPWhitePoint(pProfile, afxIlluminantWP);

    //
    // Support absolute whitePoint
    //

    (void)GetMediaWP(pProfile, dwIntent, afxIlluminantWP, afxMediaWP);

    //
    // Testing CieBasedDEFG support
    //

    pBuffer += WriteNewLineObject(pBuffer, TestingDEFG);

    //
    // Create global data
    //

    GetPublicArrayName(dwTag, pPublicArrayName);

    if (dwType == TYPE_CIEBASEDDEFG)
    {
        pBuffer += WriteNewLineObject(pBuffer, CieBasedDEFGBegin);
    }
    else
    {
        pBuffer += WriteNewLineObject(pBuffer, CieBasedDEFBegin);
    }

    pBuffer += EnableGlobalDict(pBuffer);
    pBuffer += WriteNewLineObject(pBuffer, SupportDEFG_S);
    pBuffer += BeginGlobalDict(pBuffer);

    pBuffer += CreateInputArray(pBuffer, nInputCh, nInputTable,
                 pPublicArrayName, dwLutSig, (PBYTE)pLut, *pbBinary, NULL);

    if (dwType == TYPE_CIEBASEDDEFG)
    {
        i = nInputTable * nInputCh +
            nGrids * nGrids * nGrids * nGrids * nOutputCh;
    }
    else
    {
        i = nInputTable * nInputCh +
            nGrids * nGrids * nGrids * nOutputCh;
    }
    pBuffer += CreateOutputArray(pBuffer, nOutputCh, nOutputTable, i,
                 pPublicArrayName, dwLutSig, (PBYTE)pLut, *pbBinary, NULL);

    pBuffer += WriteNewLineObject(pBuffer, EndOp);
    pBuffer += WriteNewLineObject(pBuffer, SupportDEFG_E);
    pBuffer += WriteNewLineObject(pBuffer, SetGlobalOp);
    pBuffer += WriteNewLineObject(pBuffer, SupportDEFG_S);

    //
    // Start creating the ColorSpace
    //

    pBuffer += WriteNewLineObject(pBuffer, BeginArray);   // Begin array

    //
    // /CIEBasedDEF(G)
    //

    if (dwType == TYPE_CIEBASEDDEFG)
    {
        pBuffer += WriteObject(pBuffer, CIEBasedDEFGTag);
    }
    else
    {
        pBuffer += WriteObject(pBuffer, CIEBasedDEFTag);
    }

    pBuffer += WriteObject(pBuffer, BeginDict);    // Begin dictionary

    //
    // /BlackPoint & /WhitePoint
    //

    pBuffer += SendCSABWPoint(pBuffer, dwIntent, afxIlluminantWP, afxMediaWP);

    //
    // /DecodeDEF(G)
    //

    pLineStart = pBuffer;

    if (dwType == TYPE_CIEBASEDDEFG)
    {
        pBuffer += WriteNewLineObject(pBuffer, DecodeDEFGTag);
    }
    else
    {
        pBuffer += WriteNewLineObject(pBuffer, DecodeDEFTag);
    }

    pBuffer += WriteObject(pBuffer, BeginArray);
    for (i=0; i<nInputCh; i++)
    {
        pLineStart = pBuffer;

        pBuffer += WriteNewLineObject(pBuffer, BeginFunction);
        pBuffer += WriteObject(pBuffer, StartClip);
        pBuffer += WriteObject(pBuffer, InputArray);
        pBuffer += WriteObject(pBuffer, pPublicArrayName);
        pBuffer += WriteInt(pBuffer, i);

        if (! *pbBinary)               // Output ASCII
        {
            pBuffer += WriteObject(pBuffer, IndexArray);
        }
        else
        {                               // Output BINARY
            if (dwLutSig == LUT8_TYPE)
            {
                pBuffer += WriteObject(pBuffer, IndexArray);
            }
            else
            {
                pBuffer += WriteObject(pBuffer, IndexArray16b);
            }
        }
        pBuffer += WriteObject(pBuffer, (dwLutSig == LUT8_TYPE) ? Scale8 : Scale16);
        pBuffer += WriteObject(pBuffer, EndClip);
        pBuffer += WriteObject(pBuffer, EndFunction);
    }
    pBuffer += WriteObject(pBuffer, EndArray);

    //
    // /Table
    //

    pBuffer += WriteNewLineObject(pBuffer, TableTag);
    pBuffer += WriteObject(pBuffer, BeginArray);

    pBuffer += WriteInt(pBuffer, nGrids);  // Send down Nh
    pBuffer += WriteInt(pBuffer, nGrids);  // Send down Ni
    pBuffer += WriteInt(pBuffer, nGrids);  // Send down Nj
    nNumbers = nGrids * nGrids * nOutputCh;
    SecondGrids = 1;

    if (dwType == TYPE_CIEBASEDDEFG)
    {
        pBuffer += WriteInt (pBuffer, nGrids);  // Send down Nk
        SecondGrids = nGrids;
    }
    pBuffer += WriteNewLineObject(pBuffer, BeginArray);

    for (i=0; i<nGrids; i++)        // Nh strings should be sent
    {
        if (dwType == TYPE_CIEBASEDDEFG)
        {
            pBuffer += WriteNewLineObject(pBuffer, BeginArray);
        }
        for (k=0; k<SecondGrids; k++)
        {
            pLineStart = pBuffer;
            pBuffer += WriteObject(pBuffer, NewLine);
            if (dwLutSig == LUT8_TYPE)
            {
                pTable = (PBYTE)(((PLUT8TYPE)pLut)->data) +
                    nInputTable * nInputCh +
                    nNumbers * (i * SecondGrids + k);
            }
            else
            {
                pTable = (PBYTE)(((PLUT16TYPE)pLut)->data) +
                    2 * nInputTable * nInputCh +
                    2 * nNumbers * (i * SecondGrids + k);
            }

            if (! *pbBinary)           // Output ASCII
            {
                pBuffer += WriteObject(pBuffer, BeginString);
                if (dwLutSig == LUT8_TYPE)
                {
                    pBuffer += WriteHexBuffer(pBuffer, pTable, pLineStart, nNumbers);
                }
                else
                {
                    for (j=0; j<nNumbers; j++)
                    {
                        pBuffer += WriteHex(pBuffer, FIX_ENDIAN16(*((PWORD)pTable)) / 256);
                        pTable += sizeof(WORD);

                        if (((DWORD) (pBuffer - pLineStart)) > MAX_LINELEN)
                        {
                            pLineStart = pBuffer;
                            pBuffer += WriteObject(pBuffer, NewLine);
                        }
                    }
                }
                pBuffer += WriteObject(pBuffer, EndString);
            }
            else
            {                           // Output BINARY
                pBuffer += WriteStringToken(pBuffer, 143, nNumbers);
                if (dwLutSig == LUT8_TYPE)
                    pBuffer += WriteByteString(pBuffer, pTable, nNumbers);
                else
                    pBuffer += WriteInt2ByteString(pBuffer, pTable, nNumbers);
            }
            pBuffer += WriteObject (pBuffer, NewLine);
        }
        if (dwType == TYPE_CIEBASEDDEFG)
        {
            pBuffer += WriteObject(pBuffer, EndArray);
        }
    }
    pBuffer += WriteObject(pBuffer, EndArray);
    pBuffer += WriteObject(pBuffer, EndArray); // End array

    //
    // /DecodeABC
    //

    pLineStart = pBuffer;
    pBuffer += WriteNewLineObject(pBuffer, DecodeABCTag);
    pBuffer += WriteObject(pBuffer, BeginArray);
    for (i=0; i<nOutputCh; i++)
    {
        pLineStart = pBuffer;

        pBuffer += WriteNewLineObject(pBuffer, BeginFunction);
        pBuffer += WriteObject(pBuffer, Clip01);
        pBuffer += WriteObject(pBuffer, OutputArray);
        pBuffer += WriteObject(pBuffer, pPublicArrayName);
        pBuffer += WriteInt(pBuffer, i);

        if (! *pbBinary)
        {
            pBuffer += WriteObject(pBuffer, NewLine);

            if (dwLutSig == LUT8_TYPE)
            {
                pBuffer += WriteObject(pBuffer, TFunction8XYZ);
            }
            else
            {
                pBuffer += WriteObject(pBuffer, IndexArray);
                pBuffer += WriteObject(pBuffer, Scale16XYZ);
            }
        }
        else
        {
            if (dwLutSig == LUT8_TYPE)
            {
                pBuffer += WriteObject(pBuffer, TFunction8XYZ);
            }
            else
            {
                pBuffer += WriteObject(pBuffer, IndexArray16b);
                pBuffer += WriteObject(pBuffer, Scale16XYZ);
            }
        }

        //
        // Now, We get CieBasedXYZ output. Output range 0 --> 1.99997
        // If the connection space is absolute XYZ, We need to convert
        // from relative XYZ to absolute XYZ.
        //

        if ((dwPCS == SPACE_XYZ) && (dwIntent == INTENT_ABSOLUTE_COLORIMETRIC))
        {
            pBuffer += WriteFixed(pBuffer, FIX_DIV(afxMediaWP[i], afxIlluminantWP[i]));
            pBuffer += WriteObject(pBuffer, MulOp);
        }
        else if (dwPCS == SPACE_Lab)
        {
            //
            // If the connection space is Lab, We need to convert XYZ to Lab
            //

            pBuffer += WriteObject(pBuffer, DecodeABCLab[i]);
        }
        pBuffer += WriteObject(pBuffer, EndFunction);
    }
    pBuffer += WriteObject(pBuffer, EndArray);

    if (dwPCS == SPACE_Lab)
    {
        //
        // /MatrixABC
        //

        pBuffer += WriteNewLineObject(pBuffer, MatrixABCTag);
        pBuffer += WriteObject(pBuffer, MatrixABCLab);

        //
        // /DecodeLMN
        //

        pLineStart = pBuffer;
        pBuffer += WriteNewLineObject(pBuffer, DecodeLMNTag);
        pBuffer += WriteObject(pBuffer, BeginArray);
        for (i=0; i<3; i++)
        {
            pLineStart = pBuffer;

            pBuffer += WriteNewLineObject(pBuffer, BeginFunction);
            pBuffer += WriteObject(pBuffer, DecodeLMNLab);
            if (dwIntent == INTENT_ABSOLUTE_COLORIMETRIC)
            {
                pBuffer += WriteFixed(pBuffer, afxMediaWP[i]);
            }
            else
            {
                pBuffer += WriteFixed(pBuffer, afxIlluminantWP[i]);
            }
            pBuffer += WriteObject(pBuffer, MulOp);
            pBuffer += WriteObject(pBuffer, EndFunction);
        }
        pBuffer += WriteObject(pBuffer, EndArray);
    }
    else
    {
        //
        // /RangeLMN
        //

        pBuffer += WriteNewLineObject(pBuffer, RangeLMNTag);
        pBuffer += WriteObject(pBuffer, RangeLMN);
    }

    //
    // End dictionary definition
    //

    pBuffer += WriteNewLineObject(pBuffer, EndDict);
    pBuffer += WriteObject(pBuffer, EndArray);

    if (dwType == TYPE_CIEBASEDDEFG)
    {
        pBuffer += WriteNewLineObject(pBuffer, CieBasedDEFGEnd);
    }
    else
    {
        pBuffer += WriteNewLineObject(pBuffer, CieBasedDEFEnd);
    }

    pBuffer += WriteNewLineObject(pBuffer, SupportDEFG_E);

    *pcbSize = (DWORD) (pBuffer - pStart);

    return TRUE;
}


BOOL
InternalGetPS2CSAFromLCS(
    LPLOGCOLORSPACE pLogColorSpace,
    PBYTE           pBuffer,
    PDWORD          pcbSize,
    PBOOL           pbBinary
    )
{
    PBYTE  pStart = pBuffer;
    DWORD  dwSize = 1024*2; // same value as in pscript/icm.c

    if (! pBuffer)
    {
        *pcbSize = dwSize;

        return TRUE;
    }

    if (*pcbSize < dwSize)
    {
        WARNING((__TEXT("Buffer too small to get CSA from LCS\n")));
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return FALSE;
    }

    pBuffer += WriteObject(pBuffer, NewLine);
    pBuffer += WriteObject(pBuffer, BeginArray);    // Begin array

    pBuffer += WriteObject(pBuffer, ColorSpace1);
    pBuffer += WriteObject(pBuffer, BeginArray);    // [

    //
    // Red gamma
    //

    pBuffer += WriteObject(pBuffer, BeginFunction);
    pBuffer += WriteFixed(pBuffer, pLogColorSpace->lcsGammaRed);
    pBuffer += WriteObject(pBuffer, ColorSpace3);

    //
    // Green gamma
    //

    pBuffer += WriteObject(pBuffer, BeginFunction);
    pBuffer += WriteFixed(pBuffer, pLogColorSpace->lcsGammaGreen);
    pBuffer += WriteObject(pBuffer, ColorSpace3);

    //
    // Blue Gamma
    //

    pBuffer += WriteObject(pBuffer, BeginFunction);
    pBuffer += WriteFixed(pBuffer, pLogColorSpace->lcsGammaBlue);
    pBuffer += WriteObject(pBuffer, ColorSpace3);

    pBuffer += WriteObject(pBuffer, EndArray);      // ]

    pBuffer += WriteObject(pBuffer, ColorSpace5);   // /WhitePoint

    //
    // Matrix LMN
    //

    pBuffer += WriteObject(pBuffer, MatrixLMNTag);
    pBuffer += WriteObject(pBuffer, BeginArray);

    //
    // Red Value
    //

    pBuffer += WriteFixed2dot30(pBuffer, pLogColorSpace->lcsEndpoints.ciexyzRed.ciexyzX);
    pBuffer += WriteFixed2dot30(pBuffer, pLogColorSpace->lcsEndpoints.ciexyzRed.ciexyzY);
    pBuffer += WriteFixed2dot30(pBuffer, pLogColorSpace->lcsEndpoints.ciexyzRed.ciexyzZ);

    //
    // Green Value
    //

    pBuffer += WriteFixed2dot30(pBuffer, pLogColorSpace->lcsEndpoints.ciexyzGreen.ciexyzX);
    pBuffer += WriteFixed2dot30(pBuffer, pLogColorSpace->lcsEndpoints.ciexyzGreen.ciexyzY);
    pBuffer += WriteFixed2dot30(pBuffer, pLogColorSpace->lcsEndpoints.ciexyzGreen.ciexyzZ);

    //
    // Blue Value
    //

    pBuffer += WriteFixed2dot30(pBuffer, pLogColorSpace->lcsEndpoints.ciexyzBlue.ciexyzX);
    pBuffer += WriteFixed2dot30(pBuffer, pLogColorSpace->lcsEndpoints.ciexyzBlue.ciexyzY);
    pBuffer += WriteFixed2dot30(pBuffer, pLogColorSpace->lcsEndpoints.ciexyzBlue.ciexyzZ);

    pBuffer += WriteObject(pBuffer, EndArray);      // ]
    pBuffer += WriteObject(pBuffer, EndDict);       // End dictionary

    pBuffer += WriteObject(pBuffer, EndArray);      // ]

    *pcbSize = (DWORD) (pBuffer - pStart);

    return TRUE;
}


/******************************************************************************
 *
 *                           CreateColorSpArray
 *
 *  Function:
 *       This function creates an array that is used in /DecodeABC
 *
 *  Arguments:
 *       pProfile  - pointer to the memory mapped profile
 *       pBuffer   - pointer to receive the array
 *       dwCPTag   - Channel TRC tag
 *       bBinary   - TRUE if binary data is requested
 *
 *  Returns:
 *       Length of the data created in bytes
 *
 ******************************************************************************/

DWORD
CreateColSpArray(
    PBYTE pProfile,
    PBYTE pBuffer,
    DWORD dwCPTag,
    BOOL  bBinary
    )
{
    PCURVETYPE pData;
    PTAGDATA   pTagData;
    PBYTE      pLineStart, pStart = pBuffer;
    PBYTE      pTable;
    DWORD      i, nCount, dwIndex;

    pLineStart = pBuffer;

    if (DoesCPTagExist(pProfile, dwCPTag, &dwIndex))
    {
        pTagData = (PTAGDATA)(pProfile + sizeof(PROFILEHEADER) + sizeof(DWORD) +
                   dwIndex * sizeof(TAGDATA));

        pData = (PCURVETYPE)(pProfile + FIX_ENDIAN(pTagData->dwOffset));

        nCount = FIX_ENDIAN(pData->nCount);

        if (nCount > 1)
        {
            pBuffer += WriteNewLineObject(pBuffer, Slash);
            pBuffer += WriteObject(pBuffer, DecodeABCArray);
            pBuffer += WriteInt(pBuffer, dwCPTag);

            pTable = (PBYTE)(pData->data);

            if (! bBinary)           // Output ASCII CS
            {
                pBuffer += WriteObject(pBuffer, BeginArray);
                for (i=0; i<nCount; i++)
                {
                    pBuffer += WriteInt(pBuffer, FIX_ENDIAN16(*((PWORD)pTable)));
                    pTable += sizeof(WORD);

                    if (((DWORD) (pBuffer - pLineStart)) > MAX_LINELEN)
                    {
                        pLineStart = pBuffer;
                        pBuffer += WriteObject(pBuffer, NewLine);
                    }
                }
                pBuffer += WriteObject(pBuffer, EndArray);
            }
            else
            {                           // Output BINARY CS
                pBuffer += WriteHNAToken(pBuffer, 149, nCount);
                pBuffer += WriteIntStringU2S(pBuffer, pTable, nCount);
            }

            pBuffer += WriteObject(pBuffer, DefOp);
        }
    }
    return (DWORD) (pBuffer - pStart);
}


/******************************************************************************
 *
 *                           CreateColorSpProc
 *
 *  Function:
 *       This function creates a PostScript procedure for the color space
 *
 *  Arguments:
 *       pProfile  - pointer to the memory mapped profile
 *       pBuffer   - pointer to receive the procedure
 *       dwCPTag   - Channel TRC tag
 *       bBinary   - TRUE if binary data is requested
 *
 *  Returns:
 *       Length of the data created in bytes
 *
 ******************************************************************************/

DWORD
CreateColSpProc(
    PBYTE pProfile,
    PBYTE pBuffer,
    DWORD dwCPTag,
    BOOL  bBinary
    )
{
    PCURVETYPE pData;
    PTAGDATA   pTagData;
    PBYTE      pStart = pBuffer;
    PBYTE      pTable;
    DWORD      nCount, dwIndex;

    pBuffer += WriteObject(pBuffer, BeginFunction);

    if (DoesCPTagExist(pProfile, dwCPTag, &dwIndex))
    {
        pTagData = (PTAGDATA)(pProfile + sizeof(PROFILEHEADER) + sizeof(DWORD) +
                   dwIndex * sizeof(TAGDATA));

        pData = (PCURVETYPE)(pProfile + FIX_ENDIAN(pTagData->dwOffset));

        nCount = FIX_ENDIAN(pData->nCount);

        if (nCount != 0)
        {
            if (nCount == 1)            // Gamma supplied in ui16 format
            {
                pTable = (PBYTE)(pData->data);
                pBuffer += WriteInt(pBuffer, FIX_ENDIAN16(*((PWORD)pTable)));
                pBuffer += WriteObject(pBuffer, DecodeA3);
            }
            else
            {
                pBuffer += WriteObject(pBuffer, StartClip);
                pBuffer += WriteObject(pBuffer, DecodeABCArray);
                pBuffer += WriteInt(pBuffer, dwCPTag);

                if (! bBinary)       // Output ASCII CS
                {
                    pBuffer += WriteObject(pBuffer, IndexArray);
                }
                else
                {                    // Output BINARY CS
                    pBuffer += WriteObject(pBuffer, IndexArray16b);
                }
                pBuffer += WriteObject(pBuffer, Scale16);
                pBuffer += WriteObject(pBuffer, EndClip);
            }
        }
    }
    pBuffer += WriteObject(pBuffer, EndFunction);

    return (DWORD) (pBuffer - pStart);
}


/******************************************************************************
 *
 *                           CreateFloatString
 *
 *  Function:
 *       This function creates a string of floating point numbers for
 *       the X, Y and Z values of the specified colorant.
 *
 *  Arguments:
 *       pProfile  - pointer to the memory mapped profile
 *       pBuffer   - pointer to receive the string
 *       dwCPTag   - Colorant tag
 *
 *  Returns:
 *       Length of the data created in bytes
 *
 ******************************************************************************/

DWORD
CreateFloatString(
    PBYTE pProfile,
    PBYTE pBuffer,
    DWORD dwCPTag
    )
{
    PTAGDATA   pTagData;
    PBYTE      pStart = pBuffer;
    PDWORD     pTable;
    DWORD      i, dwIndex;

    if (DoesCPTagExist(pProfile, dwCPTag, &dwIndex))
    {
        pTagData = (PTAGDATA)(pProfile + sizeof(PROFILEHEADER) + sizeof(DWORD) +
                   dwIndex * sizeof(TAGDATA));

        pTable = (PDWORD)(pProfile + FIX_ENDIAN(pTagData->dwOffset)) + 2;

        for (i=0; i<3; i++)
        {
            pBuffer += WriteFixed(pBuffer, FIX_ENDIAN(*pTable));
            pTable ++;
        }
    }

    return (DWORD) (pBuffer - pStart);
}


/******************************************************************************
 *
 *                           CreateInputArray
 *
 *  Function:
 *       This function creates the Color Rendering Dictionary (CRD)
 *       from the data supplied in the ColorProfile's LUT8 or LUT16 tag.
 *
 *  Arguments:
 *       pBuffer        - pointer to receive the data
 *       nInputChannels - number of input channels
 *       nInputTable    - size of input table
 *       pIntent        - rendering intent signature (eg. A2B0)
 *       dwTag          - signature of the look up table (8 or 16 bits)
 *       pLut           - pointer to the look up table
 *       bBinary        - TRUE if binary data is requested
 *
 *  Returns:
 *       Length of the data created in bytes
 *
 ******************************************************************************/

DWORD
CreateInputArray(
    PBYTE pBuffer,
    DWORD nInputChannels,
    DWORD nInputTable,
    PBYTE pIntent,
    DWORD dwTag,
    PBYTE pLut,
    BOOL  bBinary,
    PBYTE pHostClut
    )
{
    DWORD i, j;
    PBYTE pLineStart, pStart = pBuffer;
    PBYTE pTable;

    if (pHostClut)
    {
        nInputChannels = ((PHOSTCLUT)pHostClut)->nInputCh;
        nInputTable = ((PHOSTCLUT)pHostClut)->nInputEntries;
        dwTag = ((PHOSTCLUT)pHostClut)->nLutBits == 8 ? LUT8_TYPE : LUT16_TYPE;
    }

    for (i=0; i<nInputChannels; i++)
    {
        pLineStart = pBuffer;
        pBuffer += WriteNewLineObject(pBuffer, Slash);
        if (pHostClut)
            pBuffer += WriteObject(pBuffer, PreViewInArray);
        else
            pBuffer += WriteObject(pBuffer, InputArray);

        pBuffer += WriteObject(pBuffer, pIntent);
        pBuffer += WriteInt(pBuffer, i);

        if (pHostClut)
        {
            pTable = ((PHOSTCLUT)pHostClut)->inputArray[i];
        }
        else
        {
            if (dwTag == LUT8_TYPE)
            {
                pTable = (PBYTE)(((PLUT8TYPE)pLut)->data) + nInputTable * i;
            }
            else
            {
                pTable = (PBYTE)(((PLUT16TYPE)pLut)->data) + 2 * nInputTable * i;
            }
        }

        if (! bBinary)
        {
            if (dwTag == LUT8_TYPE)
            {
                pBuffer += WriteObject(pBuffer, BeginString);
                pBuffer += WriteHexBuffer(pBuffer, pTable, pLineStart, nInputTable);
                pBuffer += WriteObject(pBuffer, EndString);
            }
            else
            {
                pBuffer += WriteObject(pBuffer, BeginArray);
                for (j=0; j<nInputTable; j++)
                {
                    if (pHostClut)
                        pBuffer += WriteInt(pBuffer, *((PWORD)pTable));
                    else
                        pBuffer += WriteInt(pBuffer, FIX_ENDIAN16(*((PWORD)pTable)));
                    pTable += sizeof(WORD);
                    if (((DWORD) (pBuffer - pLineStart)) > MAX_LINELEN)
                    {
                        pLineStart = pBuffer;
                        pBuffer += WriteObject(pBuffer, NewLine);
                    }
                }
                pBuffer += WriteObject(pBuffer, EndArray);
            }
        }
        else
        {
            if (dwTag == LUT8_TYPE)
            {
                pBuffer += WriteStringToken(pBuffer, 143, nInputTable);
                pBuffer += WriteByteString(pBuffer, pTable, nInputTable);
            }
            else
            {
                pBuffer += WriteHNAToken(pBuffer, 149, nInputTable);
                if (pHostClut)
                    pBuffer += WriteIntStringU2S_L(pBuffer, pTable, nInputTable);
                else
                    pBuffer += WriteIntStringU2S(pBuffer, pTable, nInputTable);
            }
        }
        pBuffer += WriteObject(pBuffer, DefOp);
    }

    return (DWORD) (pBuffer - pStart);
}



/******************************************************************************
 *
 *                           CreateOutputArray
 *
 *  Function:
 *       This function creates the Color Rendering Dictionary (CRD)
 *       from the data supplied in the ColorProfile's LUT8 or LUT16 tag.
 *
 *  Arguments:
 *       pBuffer        - pointer to receive the data
 *       nOutputChannels- number of output channels
 *       nOutputTable   - size of output table
 *       dwOffset       - offset into the output table
 *       pIntent        - rendering intent signature (eg. A2B0)
 *       dwTag          - signature of the look up table (8 or 16 bits)
 *       pLut           - pointer to the look up table
 *       bBinary        - TRUE if binary data is requested
 *
 *  Returns:
 *       Length of the data created in bytes
 *
 ******************************************************************************/

DWORD
CreateOutputArray(
    PBYTE pBuffer,
    DWORD nOutputChannels,
    DWORD nOutputTable,
    DWORD dwOffset,
    PBYTE pIntent,
    DWORD dwTag,
    PBYTE pLut,
    BOOL  bBinary,
    PBYTE pHostClut
    )
{
    DWORD i, j;
    PBYTE pLineStart, pStart = pBuffer;
    PBYTE pTable;

    if (pHostClut)
    {
        nOutputChannels = ((PHOSTCLUT)pHostClut)->nOutputCh;
        nOutputTable = ((PHOSTCLUT)pHostClut)->nOutputEntries;
        dwTag = ((PHOSTCLUT)pHostClut)->nLutBits == 8 ? LUT8_TYPE : LUT16_TYPE;
    }

    for (i=0; i<nOutputChannels; i++)
    {
        pLineStart = pBuffer;
        pBuffer += WriteNewLineObject(pBuffer, Slash);
        if (pHostClut)
            pBuffer += WriteObject(pBuffer, PreViewOutArray);
        else
            pBuffer += WriteObject(pBuffer, OutputArray);
        pBuffer += WriteObject(pBuffer, pIntent);
        pBuffer += WriteInt(pBuffer, i);

        if (pHostClut)
        {
            pTable = ((PHOSTCLUT)pHostClut)->outputArray[i];
        }
        else
        {
            if (dwTag == LUT8_TYPE)
            {
                pTable = (PBYTE)(((PLUT8TYPE)pLut)->data) +
                    dwOffset + nOutputTable * i;
            }
            else
            {
                pTable = (PBYTE)(((PLUT16TYPE)pLut)->data) +
                    2 * dwOffset + 2 * nOutputTable * i;
            }
        }

        if (! bBinary)
        {
            if (dwTag == LUT8_TYPE)
            {
                pBuffer += WriteObject(pBuffer, BeginString);
                pBuffer += WriteHexBuffer(pBuffer, pTable, pLineStart, nOutputTable);
                pBuffer += WriteObject(pBuffer, EndString);
            }
            else
            {
                pBuffer += WriteObject(pBuffer, BeginArray);
                for (j=0; j<nOutputTable; j++)
                {
                    if (pHostClut)
                        pBuffer += WriteInt(pBuffer, *((PWORD)pTable));
                    else
                        pBuffer += WriteInt(pBuffer, FIX_ENDIAN16(*((PWORD)pTable)));
                    pTable += sizeof(WORD);
                    if (((DWORD) (pBuffer - pLineStart)) > MAX_LINELEN)
                    {
                        pLineStart = pBuffer;
                        pBuffer += WriteObject(pBuffer, NewLine);
                    }
                }
                pBuffer += WriteObject(pBuffer, EndArray);
            }
        }
        else
        {
            if (dwTag == LUT8_TYPE)
            {
                pBuffer += WriteStringToken(pBuffer, 143, 256);
                pBuffer += WriteByteString(pBuffer, pTable, 256L);
            }
            else
            {
                pBuffer += WriteHNAToken(pBuffer, 149, nOutputTable);
                if (pHostClut)
                    pBuffer += WriteIntStringU2S_L(pBuffer, pTable, nOutputTable);
                else
                    pBuffer += WriteIntStringU2S(pBuffer, pTable, nOutputTable);
            }
        }
        pBuffer += WriteObject(pBuffer, DefOp);
    }

    return (DWORD)(pBuffer - pStart);
}


/******************************************************************************
 *
 *                           GetPublicArrayName
 *
 *  Function:
 *       This function creates a string with the lookup table's signature
 *
 *  Arguments:
 *       dwIntentSig      - the look up table signature
 *       pPublicArrayName - pointer to buffer
 *
 *  Returns:
 *       Length of the data created in bytes
 *
 ******************************************************************************/

DWORD
GetPublicArrayName(
    DWORD   dwIntentSig,
    PBYTE   pPublicArrayName
    )
{
    *((DWORD *)pPublicArrayName) = dwIntentSig;
    pPublicArrayName[sizeof(DWORD)] = '\0';

    return sizeof(DWORD) + 1;
}


/***************************************************************************
*                               CreateMonoCRD
*  function:
*    this is the function which creates the Color Rendering Dictionary (CRD)
*    from the data supplied in the GrayTRC tag.
*
*  returns:
*       BOOL        --  !=0 if the function was successful,
*                         0 otherwise.
*                       Returns number of bytes required/transferred
***************************************************************************/

BOOL
CreateMonoCRD(
    PBYTE  pProfile,
    DWORD  dwIndex,
    PBYTE  pBuffer,
    PDWORD pcbSize,
    DWORD  dwIntent
    )
{
    PTAGDATA   pTagData;
    PCURVETYPE pData;
    PBYTE      pLineStart, pStart = pBuffer;
    PWORD      pCurve, pRevCurve, pRevCurveStart;
    DWORD      dwPCS, dwSize, nCount, i;
    FIX_16_16  afxIlluminantWP[3];
    FIX_16_16  afxMediaWP[3];

    dwPCS = GetCPConnSpace(pProfile);

    pTagData = (PTAGDATA)(pProfile + sizeof(PROFILEHEADER) + sizeof(DWORD) +
               dwIndex * sizeof(TAGDATA));

    pData = (PCURVETYPE)(pProfile + FIX_ENDIAN(pTagData->dwOffset));

    nCount = FIX_ENDIAN(pData->nCount);

    //
    // Estimate size required to hold the CRD
    //

    dwSize = nCount * 6 * REVCURVE_RATIO + // Number of INT elements
        2048;                              // + other PS stuff

    //
    // Add space for new line.
    //

    dwSize += (((dwSize) / MAX_LINELEN) + 1) * STRLEN(NewLine);

    if (! pBuffer)
    {
        *pcbSize = dwSize;
        return TRUE;
    }
    else if (*pcbSize < dwSize)
    {
        WARNING((__TEXT("Buffer too small to get Mono CRD\n")));
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return FALSE;
    }

    //
    // Allocate memory, each entry occupy 2 bytes (1 word),
    //
    // input buffer  = (nCount * sizeof(WORD)
    // output buffer = (nCount * sizeof(WORD) * REVCURVE_RATIO)
    //

    if ((pRevCurveStart = MemAlloc(nCount * sizeof(WORD) * (REVCURVE_RATIO + 1))) == NULL)
    {
        WARNING((__TEXT("Unable to allocate memory for reverse curve\n")));
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }

    //
    // pCurve will points input buffer (which used in GetRevCurve)
    //

    pCurve    = pRevCurveStart + nCount * REVCURVE_RATIO;
    pRevCurve = pRevCurveStart;

    (void)GetRevCurve(pData, pCurve, pRevCurve);

    //
    // Get info about Illuminant White Point from the header
    //

    (void)GetCPWhitePoint(pProfile, afxIlluminantWP);

    //
    // Support absolute whitePoint
    //

    if (dwIntent == INTENT_ABSOLUTE_COLORIMETRIC)
    {
        if (! GetCPMediaWhitePoint(pProfile, afxMediaWP))
        {
            afxMediaWP[0] = afxIlluminantWP[0];
            afxMediaWP[1] = afxIlluminantWP[1];
            afxMediaWP[2] = afxIlluminantWP[2];
        }
    }

    //
    // Start writing the CRD
    //

    pBuffer += WriteNewLineObject(pBuffer, BeginDict); // Begin dictionary
    pBuffer += WriteObject(pBuffer, DictType); // Dictionary type

    //
    // Send /RenderingIntent
    //

    switch (dwIntent)
    {
        case INTENT_PERCEPTUAL:
            pBuffer += WriteNewLineObject(pBuffer, IntentType);
            pBuffer += WriteObject(pBuffer, IntentPer);
            break;

        case INTENT_SATURATION:
            pBuffer += WriteNewLineObject(pBuffer, IntentType);
            pBuffer += WriteObject(pBuffer, IntentSat);
            break;

        case INTENT_RELATIVE_COLORIMETRIC:
            pBuffer += WriteNewLineObject(pBuffer, IntentType);
            pBuffer += WriteObject(pBuffer, IntentRCol);
            break;

        case INTENT_ABSOLUTE_COLORIMETRIC:
            pBuffer += WriteNewLineObject(pBuffer, IntentType);
            pBuffer += WriteObject(pBuffer, IntentACol);
            break;
    }

    //
    // Send /BlackPoint & /WhitePoint
    //

    pBuffer += SendCRDBWPoint(pBuffer, afxIlluminantWP);

    //
    // Send PQR
    //

    pBuffer += SendCRDPQR(pBuffer, dwIntent, afxIlluminantWP);

    //
    // Send LMN
    //

    pBuffer += SendCRDLMN(pBuffer, dwIntent, afxIlluminantWP, afxMediaWP, dwPCS);

    //
    // /MatrixABC
    //

    if (dwPCS == SPACE_XYZ)
    {
        //
        // Switch ABC to BAC, since we want to output B
        // which is converted from Y
        //

        pBuffer += WriteNewLineObject(pBuffer, MatrixABCTag);
        pBuffer += WriteObject(pBuffer, MatrixABCXYZCRD);
    }
    else if (dwPCS == SPACE_Lab)
    {
        pBuffer += WriteNewLineObject(pBuffer, MatrixABCTag);
        pBuffer += WriteObject(pBuffer, MatrixABCLabCRD);
    }

    //
    // /EncodeABC
    //

    if (nCount != 0)
    {
        pBuffer += WriteObject(pBuffer, NewLine);
        pLineStart = pBuffer;
        pBuffer += WriteObject(pBuffer, EncodeABCTag);
        pBuffer += WriteObject(pBuffer, BeginArray);
        pBuffer += WriteObject(pBuffer, BeginFunction);
        if (nCount == 1)                // Gamma supplied in ui16 format
        {
            PBYTE pTable;

            pTable = (PBYTE) (pData->data);
            pBuffer += WriteInt(pBuffer, FIX_ENDIAN16(*((PWORD)pTable)));
            pBuffer += WriteObject(pBuffer, DecodeA3Rev);
        }
        else
        {
            if (dwPCS == SPACE_Lab)
            {
                pBuffer += WriteObject(pBuffer, EncodeABCLab1);
            }
            pBuffer += WriteObject(pBuffer, StartClip);
            pBuffer += WriteObject(pBuffer, BeginArray);
            for (i=0; i<nCount * REVCURVE_RATIO; i++)
            {
                pBuffer += WriteInt(pBuffer, *((WORD *)pRevCurve));
                pRevCurve++;
                if (((DWORD) (pBuffer - pLineStart)) > MAX_LINELEN)
                {
                    pLineStart = pBuffer;
                    pBuffer += WriteObject(pBuffer, NewLine);
                }
            }
            pBuffer += WriteObject(pBuffer, EndArray);
            pLineStart = pBuffer;

            pBuffer += WriteNewLineObject(pBuffer, IndexArray);
            pBuffer += WriteObject(pBuffer, Scale16);
            pBuffer += WriteObject(pBuffer, EndClip);
        }
        pBuffer += WriteObject (pBuffer, EndFunction);
        pBuffer += WriteObject (pBuffer, DupOp);
        pBuffer += WriteObject (pBuffer, DupOp);
        pBuffer += WriteObject (pBuffer, EndArray);
    }
    pBuffer += WriteObject(pBuffer, EndDict);  // End dictionary definition

    MemFree(pRevCurveStart);

    *pcbSize = (DWORD) (pBuffer - pStart);

    return TRUE;
}


/***************************************************************************
*                               CreateLutCRD
*  function:
*    this is the function which creates the Color Rendering Dictionary (CRD)
*    from the data supplied in the ColorProfile's LUT8 or LUT16 tag.
*
*  returns:
*       BOOL        --  !=0 if the function was successful,
*                         0 otherwise.
*                       Returns number of bytes required/transferred
***************************************************************************/

BOOL
CreateLutCRD(
    PBYTE  pProfile,
    DWORD  dwIndex,
    PBYTE  pBuffer,
    PDWORD pcbSize,
    DWORD  dwIntent,
    BOOL   bBinary
    )
{
    PTAGDATA   pTagData;
    PLUT16TYPE pLut;
    PBYTE      pTable;
    PBYTE      pLineStart, pStart = pBuffer;
    DWORD      dwPCS, dwSize, dwLutSig, dwTag, i, j;
    DWORD      nInputCh, nOutputCh, nGrids, nInputTable, nOutputTable, nNumbers;
    FIX_16_16  afxIlluminantWP[3];
    FIX_16_16  afxMediaWP[3];
    char       pPublicArrayName[5];

    //
    // Check if we can generate the CSA
    // Required  tags is AToBi, where i is the rendering intent
    //

    dwPCS = GetCPConnSpace(pProfile);

    pTagData = (PTAGDATA)(pProfile + sizeof(PROFILEHEADER) + sizeof(DWORD) +
               dwIndex * sizeof(TAGDATA));

    dwTag = FIX_ENDIAN(pTagData->tagType);

    pLut = (PLUT16TYPE)(pProfile + FIX_ENDIAN(pTagData->dwOffset));

    dwLutSig = FIX_ENDIAN(pLut->dwSignature);

    if ((dwLutSig != LUT8_TYPE) && (dwLutSig != LUT16_TYPE))
    {
        WARNING((__TEXT("Invalid profile - unable to create Lut CRD\n")));
        SetLastError(ERROR_INVALID_PROFILE);
        return FALSE;
    }

    //
    // Estimate size required to hold the CSA
    //

    (void)GetCLUTInfo(dwLutSig, (PBYTE)pLut, &nInputCh, &nOutputCh, &nGrids,
                &nInputTable, &nOutputTable, NULL);

    //
    // Calculate size of buffer needed
    //

    dwSize = nInputCh * nInputTable * 6 +
        nOutputCh * nOutputTable * 6 +               // Number of INT bytes
        nOutputCh * nGrids * nGrids * nGrids * 2 +   // LUT HEX bytes
        nInputCh * (STRLEN(IndexArray) +
                    STRLEN(StartClip) +
                    STRLEN(EndClip)) +
        nOutputCh * (STRLEN(IndexArray) +
                     STRLEN(StartClip) +
                     STRLEN(EndClip)) +
        2048;                                        // + other PS stuff

    //
    // Add space for new line.
    //

    dwSize += (((dwSize) / MAX_LINELEN) + 1) * STRLEN(NewLine);

    if (! pBuffer)
    {
        *pcbSize = dwSize;
        return TRUE;
    }
    else if (*pcbSize < dwSize)
    {
        WARNING((__TEXT("Buffer too small to get DEFG CSA\n")));
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return FALSE;
    }

    //
    // Get info about Illuminant White Point from the header
    //

    (void)GetCPWhitePoint(pProfile, afxIlluminantWP);

    //
    // Support absolute whitePoint
    //

    if (dwIntent == INTENT_ABSOLUTE_COLORIMETRIC)
    {
        if (! GetCPMediaWhitePoint(pProfile, afxMediaWP))
        {
            afxMediaWP[0] = afxIlluminantWP[0];
            afxMediaWP[1] = afxIlluminantWP[1];
            afxMediaWP[2] = afxIlluminantWP[2];
        }
    }

    //
    // Define global array used in EncodeABC and RenderTable
    //

    GetPublicArrayName(dwTag, pPublicArrayName);
    pBuffer += WriteNewLineObject(pBuffer, CRDBegin);

    pBuffer += EnableGlobalDict(pBuffer);
    pBuffer += BeginGlobalDict(pBuffer);

    pBuffer += CreateInputArray(pBuffer, nInputCh, nInputTable,
                 pPublicArrayName, dwLutSig, (PBYTE)pLut, bBinary, NULL);

    i = nInputTable * nInputCh +
        nGrids * nGrids * nGrids * nOutputCh;
    pBuffer += CreateOutputArray(pBuffer, nOutputCh, nOutputTable, i,
                 pPublicArrayName, dwLutSig, (PBYTE)pLut, bBinary, NULL);

    pBuffer += EndGlobalDict(pBuffer);

    //
    // Start writing the CRD
    //

    pBuffer += WriteNewLineObject(pBuffer, BeginDict); // Begin dictionary
    pBuffer += WriteObject(pBuffer, DictType); // Dictionary type

    //
    // Send /RenderingIntent
    //

    switch (dwIntent)
    {
        case INTENT_PERCEPTUAL:
            pBuffer += WriteNewLineObject(pBuffer, IntentType);
            pBuffer += WriteObject(pBuffer, IntentPer);
            break;

        case INTENT_SATURATION:
            pBuffer += WriteNewLineObject(pBuffer, IntentType);
            pBuffer += WriteObject(pBuffer, IntentSat);
            break;

        case INTENT_RELATIVE_COLORIMETRIC:
            pBuffer += WriteNewLineObject(pBuffer, IntentType);
            pBuffer += WriteObject(pBuffer, IntentRCol);
            break;

        case INTENT_ABSOLUTE_COLORIMETRIC:
            pBuffer += WriteNewLineObject(pBuffer, IntentType);
            pBuffer += WriteObject(pBuffer, IntentACol);
            break;
    }

    //
    // Send /BlackPoint & /WhitePoint
    //

    pBuffer += SendCRDBWPoint(pBuffer, afxIlluminantWP);

    //
    // Send PQR
    //

    pBuffer += SendCRDPQR(pBuffer, dwIntent, afxIlluminantWP);

    //
    // Send LMN
    //

    pBuffer += SendCRDLMN(pBuffer, dwIntent, afxIlluminantWP, afxMediaWP, dwPCS);

    //
    // Send ABC
    //

    pBuffer += SendCRDABC(pBuffer, pPublicArrayName, dwPCS, nInputCh,
                    (PBYTE)pLut, NULL, dwLutSig, bBinary);

    //
    // /RenderTable
    //

    pBuffer += WriteNewLineObject(pBuffer, RenderTableTag);
    pBuffer += WriteObject(pBuffer, BeginArray);

    pBuffer += WriteInt(pBuffer, nGrids);  // Send down Na
    pBuffer += WriteInt(pBuffer, nGrids);  // Send down Nb
    pBuffer += WriteInt(pBuffer, nGrids);  // Send down Nc

    pLineStart = pBuffer;
    pBuffer += WriteNewLineObject(pBuffer, BeginArray);
    nNumbers = nGrids * nGrids * nOutputCh;

    for (i=0; i<nGrids; i++)        // Na strings should be sent
    {
        pBuffer += WriteObject(pBuffer, NewLine);
        pLineStart = pBuffer;
        if (dwLutSig == LUT8_TYPE)
        {
            pTable = (PBYTE)(((PLUT8TYPE)pLut)->data) + nInputTable * nInputCh + nNumbers * i;
        }
        else
        {
            pTable = (PBYTE)(((PLUT16TYPE)pLut)->data) + 2 * nInputTable * nInputCh + 2 * nNumbers * i;
        }

        if (! bBinary)
        {
            pBuffer += WriteObject(pBuffer, BeginString);
            if (dwLutSig == LUT8_TYPE)
            {
                pBuffer += WriteHexBuffer(pBuffer, pTable, pLineStart, nNumbers);
            }
            else
            {
                for (j=0; j<nNumbers; j++)
                {
                    pBuffer += WriteHex(pBuffer, FIX_ENDIAN16(*((PWORD)pTable)) / 256);
                    pTable += sizeof(WORD);
                    if (((DWORD) (pBuffer - pLineStart)) > MAX_LINELEN)
                    {
                        pLineStart = pBuffer;
                        pBuffer += WriteObject(pBuffer, NewLine);
                    }
                }
            }
            pBuffer += WriteObject(pBuffer, EndString);
        }
        else
        {
            pBuffer += WriteStringToken(pBuffer, 143, nNumbers);
            if (dwLutSig == LUT8_TYPE)
            {
                pBuffer += WriteByteString(pBuffer, pTable, nNumbers);
            }
            else
            {
                pBuffer += WriteInt2ByteString(pBuffer, pTable, nNumbers);
            }
        }
    }

    pBuffer += WriteObject(pBuffer, EndArray); // End array
    pBuffer += WriteInt(pBuffer, nOutputCh);   // Send down m

    pBuffer += SendCRDOutputTable(pBuffer, pPublicArrayName,
                    nOutputCh, dwLutSig, FALSE, bBinary);

    pBuffer += WriteObject(pBuffer, EndArray); // End array
    pBuffer += WriteObject(pBuffer, EndDict);  // End dictionary definition

    pBuffer += WriteNewLineObject(pBuffer, CRDEnd);

    *pcbSize = (DWORD) (pBuffer - pStart);

    return TRUE;
}

#if !defined(KERNEL_MODE) || defined(USERMODE_DRIVER)

/***************************************************************************
*                           CreateMatrixCRD
*  function:
*    this is the function which creates the Color Rendering Dictionary (CRD)
*    from the data supplied in the redTRC, greenTRC, blueTRA, redColorant,
*    greenColorant and BlueColorant tags
*
*  returns:
*       BOOL        --  !=0 if the function was successful,
*                         0 otherwise.
*                       Returns number of bytes required/transferred
***************************************************************************/

// With matrix/TRC model, only the CIEXYZ encoding of the PCS can be used.
// So, we don't need to worry about CIELAB.

BOOL
CreateMatrixCRD(
    PBYTE  pProfile,
    PBYTE  pBuffer,
    PDWORD pcbSize,
    DWORD  dwIntent,
    BOOL   bBinary
    )
{
    PTAGDATA   pTagData;
    DWORD      dwRedTRCIndex, dwGreenTRCIndex, dwBlueTRCIndex;
    DWORD      dwRedCount, dwGreenCount, dwBlueCount;
    PBYTE      pMem = NULL;
    PCURVETYPE pRed, pGreen, pBlue;
    DWORD      i, dwSize;
    PBYTE      pStart = pBuffer;
    PWORD      pRevCurve;
    FIX_16_16  afxIlluminantWP[3];
    double     adColorant[9];
    double     adRevColorant[9];

    //
    // Check this is sRGB color profile or not.
    //

    if (IsSRGBColorProfile(pProfile))
    {
        dwSize = 4096; // hack - approx.

        //
        // Return buffer size, if this is a size request
        //

        if (! pBuffer)
        {
            *pcbSize = dwSize;
            return TRUE;
        }

        //
        // Check buffer size.
        //

        if (*pcbSize < dwSize)
        {
            WARNING((__TEXT("Buffer too small to get sRGB CRD\n")));
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
            return FALSE;
        }

        //
        // Start writing the CRD
        //

        pBuffer += WriteNewLineObject(pBuffer, CRDBegin);
        pBuffer += WriteNewLineObject(pBuffer, BeginDict);  // Begin dictionary
        pBuffer += WriteObject(pBuffer, DictType);          // Dictionary type

        //
        // Send /RenderingIntent
        //

        switch (dwIntent)
        {
            case INTENT_PERCEPTUAL:
                pBuffer += WriteNewLineObject(pBuffer, IntentType);
                pBuffer += WriteObject(pBuffer, IntentPer);
                break;

            case INTENT_SATURATION:
                pBuffer += WriteNewLineObject(pBuffer, IntentType);
                pBuffer += WriteObject(pBuffer, IntentSat);
                break;

            case INTENT_RELATIVE_COLORIMETRIC:
                pBuffer += WriteNewLineObject(pBuffer, IntentType);
                pBuffer += WriteObject(pBuffer, IntentRCol);
                break;

            case INTENT_ABSOLUTE_COLORIMETRIC:
                pBuffer += WriteNewLineObject(pBuffer, IntentType);
                pBuffer += WriteObject(pBuffer, IntentACol);
                break;
        }

        //
        // Write prepaired sRGB CRD.
        //

        pBuffer += WriteNewLineObject(pBuffer, sRGBColorRenderingDictionary);

        //
        // End CRD.
        //

        pBuffer += WriteNewLineObject(pBuffer, CRDEnd);
    }
    else
    {
        //
        // Get each TRC index for Red, Green and Blue.
        //

        if (!DoesCPTagExist(pProfile, TAG_REDTRC, &dwRedTRCIndex) ||
            !DoesCPTagExist(pProfile, TAG_GREENTRC, &dwGreenTRCIndex) ||
            !DoesCPTagExist(pProfile, TAG_BLUETRC, &dwBlueTRCIndex))
        {
            return FALSE;
        }

        //
        // Get CURVETYPE data for each Red, Green and Blue
        //

        pTagData = (PTAGDATA)(pProfile + sizeof(PROFILEHEADER) + sizeof(DWORD) +
                   dwRedTRCIndex * sizeof(TAGDATA));

        pRed = (PCURVETYPE)(pProfile + FIX_ENDIAN(pTagData->dwOffset));

        pTagData = (PTAGDATA)(pProfile + sizeof(PROFILEHEADER) + sizeof(DWORD) +
                   dwGreenTRCIndex * sizeof(TAGDATA));

        pGreen = (PCURVETYPE)(pProfile + FIX_ENDIAN(pTagData->dwOffset));

        pTagData = (PTAGDATA)(pProfile + sizeof(PROFILEHEADER) + sizeof(DWORD) +
                   dwBlueTRCIndex * sizeof(TAGDATA));

        pBlue = (PCURVETYPE)(pProfile + FIX_ENDIAN(pTagData->dwOffset));

        //
        // Get curve count for each Red, Green and Blue.
        //

        dwRedCount   = FIX_ENDIAN(pRed->nCount);
        dwGreenCount = FIX_ENDIAN(pGreen->nCount);
        dwBlueCount  = FIX_ENDIAN(pBlue->nCount);

        //
        // Estimate the memory size required to hold CRD
        //

        dwSize = (dwRedCount + dwGreenCount + dwBlueCount) * 6 * REVCURVE_RATIO +
                 4096;  // Number of INT elements + other PS stuff

        //
        // Add space for new line.
        //

        dwSize += (((dwSize) / MAX_LINELEN) + 1) * STRLEN(NewLine);

        if (pBuffer == NULL)     // This is a size request
        {
            *pcbSize = dwSize;
            return TRUE;
        }

        //
        // Check buffer size.
        //

        if (*pcbSize < dwSize)
        {
            WARNING((__TEXT("Buffer too small to get sRGB CRD\n")));
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
            return FALSE;
        }

        //
        // Allocate buffer for curves
        //

        if ((pRevCurve = MemAlloc(dwRedCount * sizeof(WORD) * (REVCURVE_RATIO + 1))) == NULL)
        {
            WARNING((__TEXT("Unable to allocate memory for reserved curve\n")));
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            MemFree(pMem);
            return FALSE;
        }

        //
        // Get info about Illuminant White Point from the header
        //

        (void)GetCPWhitePoint(pProfile, afxIlluminantWP);

        //
        // Start writing the CRD
        //

        pBuffer += EnableGlobalDict(pBuffer);
        pBuffer += BeginGlobalDict(pBuffer);

        pBuffer += CreateCRDRevArray(pProfile, pBuffer, pRed, pRevCurve, TAG_REDTRC, bBinary);
        pBuffer += CreateCRDRevArray(pProfile, pBuffer, pGreen, pRevCurve, TAG_GREENTRC, bBinary);
        pBuffer += CreateCRDRevArray(pProfile, pBuffer, pBlue, pRevCurve, TAG_BLUETRC, bBinary);

        pBuffer += EndGlobalDict(pBuffer);

        //
        // Start writing the CRD
        //

        pBuffer += WriteNewLineObject(pBuffer, CRDBegin);
        pBuffer += WriteNewLineObject(pBuffer, BeginDict);  // Begin dictionary
        pBuffer += WriteObject(pBuffer, DictType);          // Dictionary type

        //
        // Send /RenderingIntent
        //

        switch (dwIntent)
        {
            case INTENT_PERCEPTUAL:
                pBuffer += WriteNewLineObject(pBuffer, IntentType);
                pBuffer += WriteObject(pBuffer, IntentPer);
                break;

            case INTENT_SATURATION:
                pBuffer += WriteNewLineObject(pBuffer, IntentType);
                pBuffer += WriteObject(pBuffer, IntentSat);
                break;

            case INTENT_RELATIVE_COLORIMETRIC:
                pBuffer += WriteNewLineObject(pBuffer, IntentType);
                pBuffer += WriteObject(pBuffer, IntentRCol);
                break;

            case INTENT_ABSOLUTE_COLORIMETRIC:
                pBuffer += WriteNewLineObject(pBuffer, IntentType);
                pBuffer += WriteObject(pBuffer, IntentACol);
                break;
        }

        //
        // Send /BlackPoint & /WhitePoint
        //

        pBuffer += SendCRDBWPoint(pBuffer, afxIlluminantWP);

        //
        // Send PQR
        //

        pBuffer += SendCRDPQR(pBuffer, dwIntent, afxIlluminantWP);

        //
        // Send LMN
        //

        CreateColorantArray(pProfile, &adColorant[0], TAG_REDCOLORANT);
        CreateColorantArray(pProfile, &adColorant[3], TAG_GREENCOLORANT);
        CreateColorantArray(pProfile, &adColorant[6], TAG_BLUECOLORANT);
        InvertColorantArray(adColorant, adRevColorant);

        pBuffer += WriteNewLineObject(pBuffer, MatrixLMNTag);

        pBuffer += WriteObject(pBuffer, BeginArray);
        for (i = 0; i < 9; i++)
        {
            pBuffer += WriteDouble(pBuffer, adRevColorant[i]);
        }
        pBuffer += WriteObject(pBuffer, EndArray);

        //
        // /EncodeABC
        //

        pBuffer += WriteNewLineObject(pBuffer, EncodeABCTag);
        pBuffer += WriteObject(pBuffer, BeginArray);

        pBuffer += WriteObject(pBuffer, NewLine);
        pBuffer += SendCRDRevArray(pProfile, pBuffer, pRed, TAG_REDTRC, bBinary);

        pBuffer += WriteObject(pBuffer, NewLine);
        pBuffer += SendCRDRevArray(pProfile, pBuffer, pGreen, TAG_GREENTRC, bBinary);

        pBuffer += WriteObject(pBuffer, NewLine);
        pBuffer += SendCRDRevArray(pProfile, pBuffer, pBlue, TAG_BLUETRC, bBinary);

        pBuffer += WriteNewLineObject(pBuffer, EndArray);
        pBuffer += WriteObject(pBuffer, EndDict);  // End dictionary definition

        pBuffer += WriteNewLineObject(pBuffer, CRDEnd);

        MemFree (pRevCurve);
    }

    *pcbSize = (DWORD)(pBuffer - pStart);

    return TRUE;
}


DWORD
CreateCRDRevArray(
    PBYTE      pProfile,
    PBYTE      pBuffer,
    PCURVETYPE pData,
    PWORD      pRevCurve,
    DWORD      dwTag,
    BOOL       bBinary
    )
{
    DWORD i, nCount;
    PBYTE pStart, pLineStart;
    PWORD pCurve;

    pStart = pBuffer;
    pLineStart = pBuffer;

    nCount = FIX_ENDIAN(pData->nCount);
    if (nCount > 1)
    {
        pBuffer += WriteNewLineObject(pBuffer, Slash);
        pBuffer += WriteObject(pBuffer, InputArray);
        pBuffer += WriteInt(pBuffer, (INT) dwTag);

        pCurve = pRevCurve + (REVCURVE_RATIO * nCount);

        GetRevCurve (pData, pCurve, pRevCurve);

        if (!bBinary)  // Output ASCII DATA
        {
            pBuffer += WriteObject(pBuffer, BeginArray);
            for (i = 0; i < nCount * REVCURVE_RATIO; i++)
            {
                pBuffer += WriteInt(pBuffer, *pRevCurve);
                pRevCurve++;
                if (((DWORD) (pBuffer - pLineStart)) > MAX_LINELEN)
                {
                    pLineStart = pBuffer;
                    pBuffer += WriteObject(pBuffer, NewLine);
                }
            }
            pBuffer += WriteObject(pBuffer, EndArray);
        }
        else // Output BINARY DATA
        {
            pBuffer += WriteHNAToken(pBuffer, 149, nCount);
            pBuffer += WriteIntStringU2S_L(pBuffer, (PBYTE) pRevCurve, nCount);
        }
        pBuffer += WriteObject(pBuffer, DefOp);
    }

    return (DWORD)(pBuffer - pStart);
}


DWORD
SendCRDRevArray(
    PBYTE pProfile,
    PBYTE pBuffer,
    PCURVETYPE pData,
    DWORD dwTag,
    BOOL  bBinary
    )
{
    DWORD nCount;
    PBYTE pStart;
    PWORD pTable;

    pStart = pBuffer;

    pBuffer += WriteObject(pBuffer, BeginFunction);
    nCount = FIX_ENDIAN(pData->nCount);
    if (nCount != 0)
    {
        if (nCount == 1)            // Gamma supplied in ui16 format
        {
            pTable = pData->data;
            pBuffer += WriteInt(pBuffer, FIX_ENDIAN16(*pTable));
            pBuffer += WriteObject(pBuffer, DecodeA3Rev);
        }
        else
        {
            pBuffer += WriteObject(pBuffer, StartClip);
            pBuffer += WriteObject(pBuffer, InputArray);
            pBuffer += WriteInt(pBuffer, dwTag);

            if (!bBinary)       // Output ASCII CS
            {
                pBuffer += WriteObject(pBuffer, IndexArray);
            }
            else                // Output BINARY CS
            {
                pBuffer += WriteObject(pBuffer, IndexArray16b);
            }

            pBuffer += WriteObject(pBuffer, Scale16);
            pBuffer += WriteObject(pBuffer, EndClip);
        }
    }
    pBuffer += WriteObject(pBuffer, EndFunction);

    return (DWORD)(pBuffer - pStart);
}


BOOL
CreateColorantArray(
    PBYTE pProfile,
    double *lpArray,
    DWORD dwTag
    )
{
    PTAGDATA pTagData;
    PXYZTYPE pData;
    PFIX_16_16 pTable;
    DWORD i, dwIndex;
    BYTE buffer[1000];

    if (DoesCPTagExist(pProfile, dwTag, &dwIndex))
    {
        pTagData = (PTAGDATA)(pProfile + sizeof(PROFILEHEADER) + sizeof(DWORD) +
                   dwIndex * sizeof(TAGDATA));

        pData = (PXYZTYPE)(pProfile + FIX_ENDIAN(pTagData->dwOffset));

        pTable = pData->afxData;

        for (i = 0; i < 3; i++)
        {
            FIX_16_16 afxData = FIX_ENDIAN(*pTable);

            //
            // Convert Fix 16.16 to double.
            //

            *lpArray = ((double) afxData) / ((double) FIX_16_16_SCALE);

            pTable++; lpArray++;
        }

        return (TRUE);
    }

    return (FALSE);
}

#endif // !defined(KERNEL_MODE) || defined(USERMODE_DRIVER)

/***************************************************************************
*                               GetRevCurve
*  function:
*  returns:
*       BOOL        --  TRUE:  successful,
*                       FALSE: otherwise.
***************************************************************************/

BOOL
GetRevCurve(
    PCURVETYPE pData,
    PWORD      pInput,
    PWORD      pOutput
    )
{
    PBYTE       pTable;
    DWORD       nCount, dwStore, i, j;
    DWORD       dwBegin, dwEnd, dwTemp;

    nCount = FIX_ENDIAN(pData->nCount);
    pTable = (PBYTE)pData->data;

    if(nCount < 2)
    {
        WARNING((__TEXT("nCount < 2 in GetRevCurve\n")));
        return FALSE;
    }
    for (i=0; i<nCount; i++)
    {
        pInput[i] = FIX_ENDIAN16(*((PWORD)pTable));
        pTable += sizeof(WORD);
    }

    j = nCount * REVCURVE_RATIO;
    for (i=0; i<j; i++)
    {
        dwStore = i * 65535 / (j - 1);
        pOutput[i] = (dwStore < 65535) ? (WORD) dwStore : 65535;
    }

    for (i=0; i<j; i++)
    {
        dwBegin = 0;
        dwEnd = nCount - 1;
        for (;;)
        {
            if ((dwEnd - dwBegin) <= 1)
                break;
            dwTemp = (dwEnd + dwBegin) / 2;
            if (pOutput[i] < pInput[dwTemp])
                dwEnd = dwTemp;
            else
                dwBegin = dwTemp;
        }
        if (pOutput[i] <= pInput[dwBegin])
        {
            dwStore = dwBegin;
        }
        else if (pOutput[i] >= pInput[dwEnd])
        {
            dwStore = dwEnd;
        }
        else
        {
            dwStore = (pInput[dwEnd] - pOutput[i]) / (pOutput[i] - pInput[dwBegin]);
            dwStore = (dwBegin * dwStore + dwEnd) / (dwStore + 1);
        }

        dwStore = dwStore * 65535 / (nCount - 1);
        pOutput[i] = (dwStore < 65535) ? (WORD) dwStore : 65535;
    }

    return TRUE;
}


BOOL
DoesCPTagExist(
    PBYTE     pProfile,
    DWORD     dwTag,
    PDWORD    pdwIndex
    )
{
    DWORD    i, dwCount;
    PTAGDATA pTagData;
    BOOL     bRc;

    //
    // Get count of tag items - it is right after the profile header
    //

    dwCount = FIX_ENDIAN(*((DWORD *)(pProfile + sizeof(PROFILEHEADER))));

    //
    // Tag data records follow the count.
    //

    pTagData = (PTAGDATA)(pProfile + sizeof(PROFILEHEADER) + sizeof(DWORD));

    //
    // Check if any of these records match the tag passed in.
    //

    bRc = FALSE;
    dwTag = FIX_ENDIAN(dwTag);      // to match tags in profile
    for (i=0; i<dwCount; i++)
    {
        if (pTagData->tagType == dwTag)
        {
            if (pdwIndex)
            {
                *pdwIndex = i;
            }

            bRc = TRUE;
            break;
        }
        pTagData++;                     // Next record
    }

    return bRc;
}


BOOL
DoesTRCAndColorantTagExist(
    PBYTE pProfile
    )
{
    if (DoesCPTagExist(pProfile,TAG_REDCOLORANT,NULL) &&
        DoesCPTagExist(pProfile,TAG_REDTRC,NULL) &&
        DoesCPTagExist(pProfile,TAG_GREENCOLORANT,NULL) &&
        DoesCPTagExist(pProfile,TAG_GREENTRC,NULL) &&
        DoesCPTagExist(pProfile,TAG_BLUECOLORANT,NULL) &&
        DoesCPTagExist(pProfile,TAG_BLUETRC,NULL))
    {
        return TRUE;
    }

    return FALSE;
}


BOOL
GetCPWhitePoint(
    PBYTE      pProfile,
    PFIX_16_16 pafxWP
    )
{
    pafxWP[0]  = FIX_ENDIAN(((PPROFILEHEADER)pProfile)->phIlluminant.ciexyzX);
    pafxWP[1]  = FIX_ENDIAN(((PPROFILEHEADER)pProfile)->phIlluminant.ciexyzY);
    pafxWP[2]  = FIX_ENDIAN(((PPROFILEHEADER)pProfile)->phIlluminant.ciexyzZ);

    return TRUE;
}

BOOL
GetCPMediaWhitePoint(
    PBYTE      pProfile,
    PFIX_16_16 pafxMediaWP
    )
{
    PTAGDATA pTagData;
    PDWORD   pTable;
    DWORD    dwIndex, i;

    if (DoesCPTagExist (pProfile, TAG_MEDIAWHITEPOINT, &dwIndex))
    {
        pTagData = (PTAGDATA)(pProfile + sizeof(PROFILEHEADER) + sizeof(DWORD) +
               dwIndex * sizeof(TAGDATA));

        //
        // Skip the first 2 DWORDs to get to the real data
        //

        pTable = (PDWORD)(pProfile + FIX_ENDIAN(pTagData->dwOffset)) + 2;

        for (i=0; i<3; i++)
        {
            pafxMediaWP[i] = FIX_ENDIAN(*pTable);
            pTable++;
        }

        return TRUE;
    }

    return FALSE;
}


BOOL
GetCPElementDataSize(
    PBYTE  pProfile,
    DWORD  dwIndex,
    PDWORD pcbSize)
{
    PTAGDATA pTagData;

    pTagData = (PTAGDATA)(pProfile + sizeof(PROFILEHEADER) + sizeof(DWORD) +
               dwIndex * sizeof(TAGDATA));

    //
    // Actual data Size of elements of type 'dataType' is 3 DWORDs less than the
    // total tag data size
    //

    *pcbSize = FIX_ENDIAN(pTagData->cbSize) - 3 * sizeof(DWORD);

    return TRUE;
}


BOOL
GetCPElementSize(
    PBYTE  pProfile,
    DWORD  dwIndex,
    PDWORD pcbSize)
{
    PTAGDATA pTagData;

    pTagData = (PTAGDATA)(pProfile + sizeof(PROFILEHEADER) + sizeof(DWORD) +
               dwIndex * sizeof(TAGDATA));

    *pcbSize = FIX_ENDIAN(pTagData->cbSize);

    return TRUE;
}


BOOL
GetCPElementDataType(
    PBYTE  pProfile,
    DWORD  dwIndex,
    PDWORD pdwDataType)
{
    PTAGDATA pTagData;
    PBYTE    pData;

    pTagData = (PTAGDATA)(pProfile + sizeof(PROFILEHEADER) + sizeof(DWORD) +
               dwIndex * sizeof(TAGDATA));

    pData = pProfile + FIX_ENDIAN(pTagData->dwOffset);

    *pdwDataType = FIX_ENDIAN(*((DWORD *)(pData + 2 * sizeof(DWORD))));

    return TRUE;
}


BOOL
GetCPElementData(
    PBYTE  pProfile,
    DWORD  dwIndex,
    PBYTE  pBuffer,
    PDWORD pdwSize
    )
{
    PTAGDATA pTagData;
    PBYTE    pData;

    pTagData = (PTAGDATA)(pProfile + sizeof(PROFILEHEADER) + sizeof(DWORD) +
               dwIndex * sizeof(TAGDATA));

    pData = pProfile + FIX_ENDIAN(pTagData->dwOffset);

    //
    // Actual data Size of elements of type 'dataType' is 3 DWORDs less than the
    // total tag data size
    //

    *pdwSize = FIX_ENDIAN(pTagData->cbSize) - 3 * sizeof(DWORD);

    if (pBuffer)
    {
        CopyMemory(pBuffer, (pData + 3*sizeof(DWORD)), *pdwSize);
    }

    return TRUE;
}


BOOL
GetTRCElementSize(
    PBYTE  pProfile,
    DWORD  dwTag,
    PDWORD pdwIndex,
    PDWORD pdwSize
    )
{
    DWORD dwDataType;

    if (!DoesCPTagExist(pProfile, dwTag, pdwIndex) ||
        !GetCPElementDataType(pProfile, *pdwIndex, &dwDataType) ||
        !(dwDataType != SIG_CURVE_TYPE) ||
        !GetCPElementSize(pProfile, *pdwIndex, pdwSize))
    {
        return FALSE;
    }

    return TRUE;
}


DWORD
Ascii85Encode(
    PBYTE pBuffer,
    DWORD dwDataSize,
    DWORD dwBufSize
    )
{
    // WINBUG #83136 2-7-2000 bhouse Investigate empty function Ascii85Encode
    // Old Comment:
    //     - To be done

#if 0
    PBYTE     pTempBuf, pPtr;
    DWORD     dwASCII85Size = 0;
    DWORD     dwBufSize = DataSize * 5 / 4 + sizeof(ASCII85DecodeBegin)+sizeof(ASCII85DecodeEnd) + 2048;

    if ((pTempBuf = (PBYTE)MemAlloc(dwBufSize)))
    {
        pPtr = pTempBuf;
        pPtr += WriteObject(pPtr,  NewLine);
        pPtr += WriteObject(pPtr,  ASCII85DecodeBegin);
        pPtr += WriteObject(pPtr,  NewLine);
        pPtr += WriteASCII85Cont(pPtr, dwBufSize, pBuffer, dwDataSize);
        pPtr += WriteObject(pPtr,  ASCII85DecodeEnd);
        dwAscii85Size = (DWORD)(pPtr - pTempBuf);
        lstrcpyn(pBuffer, pTempBuf, dwAscii85Size);

        MemFree(pTempBuf);
    }

    return dwAscii85Size;
#else
    return 0;
#endif
}

/***************************************************************************
*
*   Function to write the Homogeneous Number Array token into the buffer
*
***************************************************************************/

DWORD
WriteHNAToken(
    PBYTE pBuffer,
    BYTE  token,
    DWORD dwNum
    )
{
    *pBuffer++ = token;
    *pBuffer++ = 32;       // 16-bit fixed integer, high-order byte first
    *pBuffer++ = (BYTE)((dwNum & 0xFF00) >> 8);
    *pBuffer++ = (BYTE)(dwNum & 0x00FF);

    return 4;
}

/***************************************************************************
*
*   Function to convert 2-bytes unsigned integer to 2-bytes signed
*   integer(-32768) and write them to the buffer. High byte first.
*
***************************************************************************/

DWORD
WriteIntStringU2S(
    PBYTE pBuffer,
    PBYTE pData,
    DWORD dwNum
    )
{
    DWORD i, dwTemp;

    for (i=0; i<dwNum; i++)
    {
        dwTemp = FIX_ENDIAN16(*((PWORD)pData)) - 32768;
        *pBuffer++ = (BYTE)((dwTemp & 0xFF00) >> 8);
        *pBuffer++ = (BYTE)(dwTemp & 0x00FF);
        pData += sizeof(WORD);
    }

    return dwNum * 2;
}


/***************************************************************************
*
*   Function to convert 2-bytes unsigned integer to 2-bytes signed
*   integer(-32768) and write them to the buffer. Low-order byte first.
*
***************************************************************************/

DWORD
WriteIntStringU2S_L(
    PBYTE pBuffer,
    PBYTE pData,
    DWORD dwNum
    )
{
    DWORD i, dwTemp;

    for (i=0; i<dwNum; i++)
    {
        dwTemp = *((PWORD)pData) - 32768;
        *pBuffer++ = (BYTE)((dwTemp & 0xFF00) >> 8);
        *pBuffer++ = (BYTE)(dwTemp & 0x00FF);
        pData += sizeof(WORD);
    }

    return dwNum * 2;
}


/***************************************************************************
*
*   Function to put the chunk of memory as string of Hex
*
***************************************************************************/

DWORD
WriteHexBuffer(
    PBYTE pBuffer,
    PBYTE pData,
    PBYTE pLineStart,
    DWORD dwBytes
    )
{
    PBYTE  pStart = pBuffer;

    for ( ; dwBytes ; dwBytes-- )
    {
        WriteHex(pBuffer, *pData);
        pBuffer += 2;
        pData++;
        if (((DWORD)(pBuffer - pLineStart)) > MAX_LINELEN)
        {
            pLineStart = pBuffer;
            pBuffer += WriteObject(pBuffer,  NewLine);
        }
    }
    return( (DWORD)(pBuffer - pStart));
}

/***************************************************************************
*
*   Function to write the string token into the buffer
*
***************************************************************************/

DWORD
WriteStringToken(
    PBYTE pBuffer,
    BYTE  token,
    DWORD dwNum
    )
{
    *pBuffer++ = token;
    *pBuffer++ = (BYTE)((dwNum & 0xFF00) >> 8);
    *pBuffer++ = (BYTE)(dwNum & 0x00FF);

    return 3;
}

/***************************************************************************
*
*   Function to put the chunk of memory into buffer
*
***************************************************************************/

DWORD
WriteByteString(
    PBYTE pBuffer,
    PBYTE pData,
    DWORD dwBytes
    )
{
    DWORD  i;

    for (i=0; i<dwBytes; i++)
        *pBuffer++ = *pData++;

    return dwBytes;
}

/***************************************************************************
*
*   Function to put the chunk of memory into buffer
*
***************************************************************************/

DWORD
WriteInt2ByteString(
    PBYTE pBuffer,
    PBYTE pData,
    DWORD dwBytes
    )
{
    DWORD  i;

    for (i=0; i<dwBytes ; i++)
    {
        *pBuffer++ = (BYTE)(FIX_ENDIAN16(*((PWORD)pData))/256);
        pData += sizeof(WORD);
    }

    return dwBytes;
}

#ifndef KERNEL_MODE
DWORD
WriteFixed(
    PBYTE     pBuffer,
    FIX_16_16 fxNum
    )
{
    double dFloat = (double) ((long) fxNum) / (double) FIX_16_16_SCALE;

    return (WriteDouble(pBuffer,dFloat));
}
#else
DWORD
WriteFixed(
    PBYTE     pBuffer,
    FIX_16_16 fxNum
    )
{
    PBYTE pStart = pBuffer;
    DWORD i;

    //
    // Integer portion
    //

    #ifndef KERNEL_MODE
    pBuffer += wsprintfA(pBuffer, "%lu", fxNum >> FIX_16_16_SHIFT);
    #else
    pBuffer += OPSprintf(pBuffer, "%l", fxNum >> FIX_16_16_SHIFT);
    #endif

    //
    // Fractional part
    //

    fxNum &= 0xffff;
    if (fxNum != 0)
    {
        //
        // We output a maximum of 6 digits after the
        // decimal point
        //

        *pBuffer++ = '.';

        i = 0;
        while (fxNum && i++ < 6)
        {
            fxNum *= 10;
            *pBuffer++ = (BYTE)(fxNum >> FIX_16_16_SHIFT) + '0';  // quotient + '0'
            fxNum -= FLOOR(fxNum);          // remainder
        }
    }

    *pBuffer++ = ' ';

    return (DWORD) (pBuffer - pStart);
}
#endif

DWORD
WriteFixed2dot30(
    PBYTE pBuffer,
    DWORD fxNum
    )
{
    PBYTE pStart = pBuffer;
    DWORD i;

    //
    // Integer portion
    //

    #ifndef KERNEL_MODE
    pBuffer += wsprintfA(pBuffer, "%lu", fxNum >> 30);
    #else
    pBuffer += OPSprintf(pBuffer, "%l", fxNum >> 30);
    #endif

    //
    // Fractional part
    //

    fxNum &= 0x3fffffffL;
    if (fxNum != 0)
    {
        //
        // We output a maximum of 10 digits after the
        // decimal point
        //

        *pBuffer++ = '.';

        i = 0;
        while (fxNum && i++ < 10)
        {
            fxNum *= 10;
            *pBuffer++ = (BYTE)(fxNum >> 30) + '0';  // quotient + '0'
            fxNum -= ((fxNum >> 30) << 30);          // remainder
        }
    }

    *pBuffer++ = ' ';

    return (DWORD) (pBuffer - pStart);
}

#if !defined(KERNEL_MODE) || defined(USERMODE_DRIVER)

/***************************************************************************
*
*   Function to write the float into the buffer
*
***************************************************************************/

DWORD WriteDouble(PBYTE pBuffer, double dFloat)
{
    LONG   lFloat  = (LONG) floor(dFloat * 10000.0 + 0.5);
    double dFloat1 = lFloat  / 10000.0 ;
    double dInt    = floor(fabs(dFloat1));
    double dFract =  fabs(dFloat1) - dInt ;
    char   cSign  = ' ' ;

    if (dFloat1 < 0)
    {
        cSign = '-' ;
    }

    return (wsprintfA(pBuffer, (LPSTR) "%c%d.%0.4lu ",
                        cSign, (WORD) dInt , (DWORD) (dFract * 10000.0)));
}

#endif // !defined(KERNEL_MODE) || defined(USERMODE_DRIVER)

DWORD WriteNewLineObject(
    PBYTE       pBuffer,
    const char *pData)
{
    PBYTE pStart = pBuffer;

    pBuffer += WriteObject(pBuffer, NewLine);
    pBuffer += WriteObject(pBuffer, pData);

    return (DWORD)(pBuffer - pStart);
}


DWORD
SendCRDBWPoint(
    PBYTE      pBuffer,
    PFIX_16_16 pafxWP
    )
{
    PBYTE pStart = pBuffer;
    int   i;

    //
    // /BlackPoint
    //

    pBuffer += WriteObject(pBuffer, NewLine);
    pBuffer += WriteObject(pBuffer, BlackPointTag);
    pBuffer += WriteObject(pBuffer, BlackPoint);

    //
    // /WhitePoint
    //

    pBuffer += WriteObject(pBuffer, NewLine);
    pBuffer += WriteObject(pBuffer, WhitePointTag);
    pBuffer += WriteObject(pBuffer, BeginArray);
    for (i=0; i<3; i++)
    {
        pBuffer += WriteFixed(pBuffer, pafxWP[i]);
    }
    pBuffer += WriteObject(pBuffer, EndArray);

    return (DWORD)(pBuffer - pStart);
}


DWORD
SendCRDPQR(
    PBYTE      pBuffer,
    DWORD      dwIntent,
    PFIX_16_16 pafxWP
    )
{
    PBYTE pStart = pBuffer;
    int   i;

    if (dwIntent != INTENT_ABSOLUTE_COLORIMETRIC)
    {
        //
        // /RangePQR
        //

        pBuffer += WriteNewLineObject(pBuffer, RangePQRTag);
        pBuffer += WriteObject(pBuffer, RangePQR);

        //
        // /MatrixPQR
        //

        pBuffer += WriteNewLineObject(pBuffer, MatrixPQRTag);
        pBuffer += WriteObject(pBuffer, MatrixPQR);
    }
    else
    {
        //
        // /RangePQR
        //

        pBuffer += WriteNewLineObject(pBuffer, RangePQRTag);
        pBuffer += WriteObject(pBuffer, BeginArray);
        for (i=0; i<3; i++)
        {
            pBuffer += WriteFixed(pBuffer, 0);
            pBuffer += WriteFixed(pBuffer, pafxWP[i]);
        }
        pBuffer += WriteObject(pBuffer, EndArray);

        //
        // /MatrixPQR
        //

        pBuffer += WriteNewLineObject(pBuffer, MatrixPQRTag);
        pBuffer += WriteObject(pBuffer, Identity);
    }

    //
    // /TransformPQR
    //

    pBuffer += WriteNewLineObject(pBuffer, TransformPQRTag);
    pBuffer += WriteObject(pBuffer, BeginArray);
    for (i=0; i<3; i++)
    {
        pBuffer += WriteObject(pBuffer, BeginFunction);
        pBuffer += WriteObject(pBuffer,
            (dwIntent != INTENT_ABSOLUTE_COLORIMETRIC) ? TransformPQR[i] : NullOp);
        pBuffer += WriteObject(pBuffer, EndFunction);
    }
    pBuffer += WriteObject(pBuffer, EndArray);

    return (DWORD)(pBuffer - pStart);
}


DWORD
SendCRDLMN(
    PBYTE      pBuffer,
    DWORD      dwIntent,
    PFIX_16_16 pafxIlluminantWP,
    PFIX_16_16 pafxMediaWP,
    DWORD      dwPCS
    )
{
    PBYTE pStart = pBuffer;
    DWORD i, j;

    //
    // /MatrixLMN
    //

    if (dwIntent == INTENT_ABSOLUTE_COLORIMETRIC)
    {
        pBuffer += WriteNewLineObject(pBuffer, MatrixLMNTag);

        pBuffer += WriteObject(pBuffer, BeginArray);
        for (i=0; i<3; i++)
        {
            for (j=0; j<3; j++)
                pBuffer += WriteFixed(pBuffer,
                    (i == j) ? FIX_DIV(pafxIlluminantWP[i], pafxMediaWP[i]) : 0);
        }
        pBuffer += WriteObject(pBuffer, EndArray);
    }

    //
    // /RangeLMN
    //

    pBuffer += WriteNewLineObject(pBuffer, RangeLMNTag);
    if (dwPCS == SPACE_XYZ)
    {
        pBuffer += WriteObject(pBuffer, BeginArray);
        for (i=0; i<3; i++)
        {
            pBuffer += WriteFixed(pBuffer, 0);
            pBuffer += WriteFixed(pBuffer, pafxIlluminantWP[i]);
        }
        pBuffer += WriteObject(pBuffer, EndArray);
    }
    else
    {
        pBuffer += WriteObject(pBuffer, RangeLMNLab);
    }

    //
    // /EncodeLMN
    //

    pBuffer += WriteNewLineObject(pBuffer, EncodeLMNTag);
    pBuffer += WriteObject(pBuffer, BeginArray);
    for (i=0; i<3; i++)
    {
        pBuffer += WriteObject(pBuffer, BeginFunction);
        if (dwPCS != SPACE_XYZ)
        {
            pBuffer += WriteFixed(pBuffer, pafxIlluminantWP[i]);
            pBuffer += WriteObject(pBuffer, DivOp);
            pBuffer += WriteObject(pBuffer, EncodeLMNLab);
        }
        pBuffer += WriteObject(pBuffer, EndFunction);
    }
    pBuffer += WriteObject(pBuffer, EndArray);

    return (DWORD)(pBuffer - pStart);
}


DWORD
SendCRDABC(
    PBYTE       pBuffer,
    PBYTE       pPublicArrayName,
    DWORD       dwPCS,
    DWORD       nInputCh,
    PBYTE       pLut,
    PFIX_16_16  e,
    DWORD       dwLutSig,
    BOOL        bBinary
    )
{
    PBYTE      pLineStart, pStart = pBuffer;
    PBYTE      pTable;
    DWORD      i, j;
    FIX_16_16  fxTempMatrixABC[9];

    //
    // /RangeABC
    //

    pBuffer += WriteNewLineObject(pBuffer, RangeABCTag);
    pBuffer += WriteObject(pBuffer, RangeABC);

    //
    // /MatrixABC
    //

    pBuffer += WriteNewLineObject(pBuffer, MatrixABCTag);
    if (dwPCS == SPACE_XYZ)
    {
        pBuffer += WriteObject(pBuffer, BeginArray);
        if (e)
        {
            for (i=0; i<3; i++)
            {
                for (j=0; j<3; j++)
                {
                    pBuffer += WriteFixed(pBuffer, e[i + j * 3]);
                }
            }
        }
        else
        {
            if (dwLutSig == LUT8_TYPE)
            {
                pTable = (PBYTE) &((PLUT8TYPE)pLut)->e00;
            }
            else
            {
                pTable = (PBYTE) &((PLUT16TYPE)pLut)->e00;
            }

            for (i=0; i<9; i++)
            {
                fxTempMatrixABC[i] = FIX_DIV(FIX_ENDIAN(*((PDWORD)pTable)), CIEXYZRange);
                pTable += sizeof(DWORD);
            }
            for (i=0; i<3; i++)
            {
                for (j=0; j<3; j++)
                {
                    pBuffer += WriteFixed(pBuffer, fxTempMatrixABC[i + j * 3]);
                }
            }
        }
        pBuffer += WriteObject(pBuffer, EndArray);
    }
    else
    {
        pBuffer += WriteObject(pBuffer, MatrixABCLabCRD);
    }

    //
    // /EncodeABC
    //

    if (nInputCh == 0)
    {
        return (DWORD)(pBuffer - pStart);
    }

    pLineStart = pBuffer;
    pBuffer += WriteNewLineObject(pBuffer, EncodeABCTag);
    pBuffer += WriteObject(pBuffer, BeginArray);
    for (i=0; i<nInputCh; i++)
    {
        pLineStart = pBuffer;

        pBuffer += WriteNewLineObject(pBuffer, BeginFunction);
        if (dwPCS == SPACE_Lab)
        {
            pBuffer += WriteObject(pBuffer, (i == 0) ? EncodeABCLab1 : EncodeABCLab2);
        }

        pBuffer += WriteObject(pBuffer, StartClip);
        if (e)
            pBuffer += WriteObject(pBuffer, PreViewInArray);
        else
            pBuffer += WriteObject(pBuffer, InputArray);

        pBuffer += WriteObject(pBuffer, pPublicArrayName);
        pBuffer += WriteInt(pBuffer, i);

        if (!bBinary)              // Output ASCII CRD
        {
            pBuffer += WriteNewLineObject(pBuffer, IndexArray);
        }
        else
        {                               // Output BINARY CRD
            if (dwLutSig == LUT8_TYPE)
            {
                pBuffer += WriteObject(pBuffer, IndexArray);
            }
            else
            {
                pBuffer += WriteObject(pBuffer, IndexArray16b);
            }
        }

        pBuffer += WriteObject(pBuffer, (dwLutSig == LUT8_TYPE) ?
                         Scale8 : Scale16);
        pBuffer += WriteObject(pBuffer, EndClip);
        pBuffer += WriteObject(pBuffer, EndFunction);
    }
    pBuffer += WriteObject(pBuffer, EndArray);

    return (DWORD)(pBuffer - pStart);
}


DWORD
SendCRDOutputTable(
    PBYTE pBuffer,
    PBYTE pPublicArrayName,
    DWORD nOutputCh,
    DWORD dwLutSig,
    BOOL  bHost,
    BOOL  bBinary
    )
{
    PBYTE pStart = pBuffer;
    DWORD i;

    for (i=0; i<nOutputCh; i++)
    {
        pBuffer += WriteNewLineObject(pBuffer, BeginFunction);
        pBuffer += WriteObject(pBuffer, Clip01);
        if (bHost)
            pBuffer += WriteObject(pBuffer, PreViewOutArray);
        else
            pBuffer += WriteObject(pBuffer, OutputArray);

        pBuffer += WriteObject(pBuffer, pPublicArrayName);
        pBuffer += WriteInt(pBuffer, i);

        if (! bBinary)
        {
            pBuffer += WriteObject(pBuffer, NewLine);
            if (dwLutSig == LUT8_TYPE)
            {
                pBuffer += WriteObject(pBuffer, TFunction8);
            }
            else
            {
                pBuffer += WriteObject(pBuffer, IndexArray);
                pBuffer += WriteObject(pBuffer, Scale16);
            }
        }
        else
        {
            if (dwLutSig == LUT8_TYPE)
            {
                pBuffer += WriteObject(pBuffer, TFunction8);
            }
            else
            {
                pBuffer += WriteObject(pBuffer, IndexArray16b);
                pBuffer += WriteObject(pBuffer, Scale16);
            }
        }

        pBuffer += WriteObject(pBuffer, EndFunction);
    }

    return (DWORD)(pBuffer - pStart);
}


VOID
GetCLUTInfo(
    DWORD  dwLutSig,
    PBYTE  pLut,
    PDWORD pnInputCh,
    PDWORD pnOutputCh,
    PDWORD pnGrids,
    PDWORD pnInputTable,
    PDWORD pnOutputTable,
    PDWORD pdwSize
    )
{
    if (dwLutSig == LUT8_TYPE)
    {
        *pnInputCh = ((PLUT8TYPE)pLut)->nInputChannels;
        *pnOutputCh = ((PLUT8TYPE)pLut)->nOutputChannels;
        *pnGrids = ((PLUT8TYPE)pLut)->nClutPoints;
        *pnInputTable = 256L;
        *pnOutputTable = 256L;
        if (pdwSize)
            *pdwSize = 1;
    }
    else
    {
        *pnInputCh = ((PLUT16TYPE)pLut)->nInputChannels;
        *pnOutputCh = ((PLUT16TYPE)pLut)->nOutputChannels;
        *pnGrids =  ((PLUT16TYPE)pLut)->nClutPoints;
        *pnInputTable = FIX_ENDIAN16(((PLUT16TYPE)pLut)->wInputEntries);
        *pnOutputTable = FIX_ENDIAN16(((PLUT16TYPE)pLut)->wOutputEntries);
        if (pdwSize)
            *pdwSize = 2;
    }

    return;
}

DWORD
EnableGlobalDict(
    PBYTE pBuffer
    )
{
    PBYTE pStart = pBuffer;

    pBuffer += WriteNewLineObject(pBuffer, CurrentGlobalOp);
    pBuffer += WriteObject(pBuffer, TrueOp);
    pBuffer += WriteObject(pBuffer, SetGlobalOp);

    return (DWORD)(pBuffer - pStart);
}

DWORD
BeginGlobalDict(
    PBYTE pBuffer
    )
{
    PBYTE pStart = pBuffer;

    pBuffer += WriteNewLineObject(pBuffer, GlobalDictOp);
    pBuffer += WriteObject(pBuffer, BeginOp);

    return (DWORD)(pBuffer - pStart);
}

DWORD
EndGlobalDict(
    PBYTE pBuffer
    )
{
    PBYTE pStart = pBuffer;

    pBuffer += WriteNewLineObject(pBuffer, EndOp);
    pBuffer += WriteObject(pBuffer, SetGlobalOp);

    return (DWORD)(pBuffer - pStart);
}

DWORD
SendCSABWPoint(
    PBYTE      pBuffer,
    DWORD      dwIntent,
    PFIX_16_16 pafxIlluminantWP,
    PFIX_16_16 pafxMediaWP
    )
{
    PBYTE pStart = pBuffer;
    int   i;

    //
    // /BlackPoint
    //

    pBuffer += WriteNewLineObject(pBuffer, BlackPointTag);
    pBuffer += WriteObject(pBuffer, BlackPoint);

    //
    // /WhitePoint
    //

    pBuffer += WriteNewLineObject(pBuffer, WhitePointTag);
    pBuffer += WriteObject(pBuffer, BeginArray);
    for (i=0; i<3; i++)
    {
        if (dwIntent == INTENT_ABSOLUTE_COLORIMETRIC)
        {
            pBuffer += WriteFixed(pBuffer, pafxMediaWP[i]);
        }
        else
        {
            pBuffer += WriteFixed(pBuffer, pafxIlluminantWP[i]);
        }
    }
    pBuffer += WriteObject(pBuffer, EndArray);

    return (DWORD)(pBuffer - pStart);
}


VOID
GetMediaWP(
    PBYTE      pProfile,
    DWORD      dwIntent,
    PFIX_16_16 pafxIlluminantWP,
    PFIX_16_16 pafxMediaWP
    )
{
    if (dwIntent == INTENT_ABSOLUTE_COLORIMETRIC)
    {
        if (! GetCPMediaWhitePoint(pProfile, pafxMediaWP))
        {
            pafxMediaWP[0] = pafxIlluminantWP[0];
            pafxMediaWP[1] = pafxIlluminantWP[1];
            pafxMediaWP[2] = pafxIlluminantWP[2];
        }
    }

    return;
}


BOOL
GetCRDInputOutputArraySize(
    PBYTE  pProfile,
    DWORD  dwIntent,
    PDWORD pdwInTblSize,
    PDWORD pdwOutTblSize,
    PDWORD pdwTag,
    PDWORD pnGrids
    )
{
    PTAGDATA   pTagData;
    PLUT16TYPE pLut;
    DWORD      dwIndex, dwLutSig;
    DWORD      nInputEntries, nOutputEntries;
    DWORD      nInputCh, nOutputCh, nGrids;
    BOOL       bRet = TRUE;

    //
    // Make sure required tags exist
    //

    switch (dwIntent)
    {
    case INTENT_PERCEPTUAL:
        *pdwTag = TAG_BToA0;
        break;

    case INTENT_RELATIVE_COLORIMETRIC:
    case INTENT_ABSOLUTE_COLORIMETRIC:
        *pdwTag = TAG_BToA1;
        break;

    case INTENT_SATURATION:
        *pdwTag = TAG_BToA2;
        break;

    default:
        WARNING((__TEXT("Invalid intent passed to GetCRDInputOutputArraySize: %d\n"), dwIntent));
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if (DoesCPTagExist(pProfile, *pdwTag, &dwIndex))
    {
        pTagData = (PTAGDATA)(pProfile + sizeof(PROFILEHEADER) + sizeof(DWORD) +
                   dwIndex * sizeof(TAGDATA));

        pLut = (PLUT16TYPE)(pProfile + FIX_ENDIAN(pTagData->dwOffset));

        dwLutSig = FIX_ENDIAN(pLut->dwSignature);

        if ((dwLutSig != LUT8_TYPE) && (dwLutSig != LUT16_TYPE))
        {
            WARNING((__TEXT("Invalid Lut type - unable to create proofing CRD\n")));
            SetLastError(ERROR_INVALID_PROFILE);
            return FALSE;
        }

        (void)GetCLUTInfo(dwLutSig, (PBYTE)pLut, &nInputCh, &nOutputCh,
                &nGrids, &nInputEntries, &nOutputEntries, NULL);

        if (pdwInTblSize)
        {
            if (nInputCh != 3)
            {
                return FALSE;
            }

            *pdwInTblSize = nInputCh * nInputEntries * 6;  // Number of INT bytes
            *pnGrids = nGrids;
        }

        if (pdwOutTblSize)
        {
            if ((nOutputCh != 3) && (nOutputCh != 4))
            {
                return FALSE;
            }

            *pdwOutTblSize = nOutputCh * nOutputEntries * 6; // Number of INT bytes
            *pnGrids = nGrids;
        }

        return TRUE;
    }
    else
    {
        //
        // Matrix icc profile.
        //

        *pnGrids = 2;

        if (pdwInTblSize)
        {
            bRet = GetHostCSA(pProfile, NULL, pdwInTblSize,
                              dwIntent, TYPE_CIEBASEDDEF);
            *pdwInTblSize = *pdwInTblSize * 3;
        }

        if (bRet && pdwOutTblSize)
        {
            bRet = GetHostCSA(pProfile, NULL, pdwInTblSize,
                              dwIntent, TYPE_CIEBASEDDEF);
            *pdwOutTblSize = *pdwOutTblSize * 3;
        }

        return bRet;
    }
}

#if !defined(KERNEL_MODE) || defined(USERMODE_DRIVER)

DWORD
CreateHostLutCRD(
    PBYTE  pProfile,
    DWORD  dwIndex,
    PBYTE  pBuffer,
    DWORD  dwIntent
    )
{
    PLUT16TYPE pLut;
    PHOSTCLUT  pHostClut;
    PTAGDATA   pTagData;
    PBYTE      pTable;
    DWORD      nInputCh, nOutputCh, nGrids;
    DWORD      nInputEntries, nOutputEntries, nNumbers;
    DWORD      dwPCS, dwLutSig;
    DWORD      dwSize, i, j;
    PBYTE      pStart = pBuffer;

    //
    // Check if we can generate the CSA
    // Required  tags is AToBi, where i is the rendering intent
    //

    dwPCS = GetCPConnSpace(pProfile);

    pTagData = (PTAGDATA)(pProfile + sizeof(PROFILEHEADER) + sizeof(DWORD) +
               dwIndex * sizeof(TAGDATA));

    pLut = (PLUT16TYPE)(pProfile + FIX_ENDIAN(pTagData->dwOffset));

    dwLutSig = FIX_ENDIAN(pLut->dwSignature);

    if ((dwLutSig != LUT8_TYPE) && (dwLutSig != LUT16_TYPE))
    {
        WARNING((__TEXT("Invalid profile - unable to create Lut CRD\n")));
        SetLastError(ERROR_INVALID_PROFILE);
        return 0;
    }

    (void)GetCLUTInfo(dwLutSig, (PBYTE)pLut, &nInputCh, &nOutputCh,
            &nGrids, &nInputEntries, &nOutputEntries, &i);

    if (((nOutputCh != 3) && (nOutputCh != 4)) ||  (nInputCh != 3))
    {
        return 0;
    }

    if (pBuffer == NULL)
    {
        //
        // Return size
        //

        dwSize = nInputCh * nInputEntries * i    +  // Input table 8/16-bits
            nOutputCh * nOutputEntries * i       +  // Output table 8/16-bits
            nOutputCh * nGrids * nGrids * nGrids +  // CLUT 8-bits only
            sizeof(HOSTCLUT)                     +  // Data structure
            2048;                                   // Other PS stuff

        //
        // Add space for new line.
        //

        dwSize += (((dwSize) / MAX_LINELEN) + 1) * STRLEN(NewLine);

        return dwSize;
    }
    
    pHostClut = (PHOSTCLUT)pBuffer;
    pBuffer += sizeof(HOSTCLUT);
    pHostClut->wSize = sizeof(HOSTCLUT);
    pHostClut->wDataType = DATATYPE_LUT;
    pHostClut->dwPCS = dwPCS;
    pHostClut->dwIntent = dwIntent;
    pHostClut->nLutBits = (dwLutSig == LUT8_TYPE) ? 8 : 16;

    (void)GetCPWhitePoint(pProfile, pHostClut->afxIlluminantWP);

    //
    // Support absolute whitePoint
    //

    if (!GetCPMediaWhitePoint(pProfile, pHostClut->afxMediaWP))
    {
        pHostClut->afxMediaWP[0] = pHostClut->afxIlluminantWP[0];
        pHostClut->afxMediaWP[1] = pHostClut->afxIlluminantWP[1];
        pHostClut->afxMediaWP[2] = pHostClut->afxIlluminantWP[2];
    }

    pHostClut->nInputCh = (BYTE)nInputCh;
    pHostClut->nOutputCh = (BYTE)nOutputCh;
    pHostClut->nClutPoints = (BYTE)nGrids;
    pHostClut->nInputEntries = (WORD)nInputEntries;
    pHostClut->nOutputEntries = (WORD)nOutputEntries;

    //
    // Input array
    //

    pBuffer += CreateHostInputOutputArray(
                        pBuffer,
                        pHostClut->inputArray,
                        nInputCh,
                        nInputEntries,
                        0,
                        dwLutSig,
                        (PBYTE)pLut);

    //
    // The offset to the position of output array.
    //

    i = nInputEntries * nInputCh +
        nGrids * nGrids * nGrids * nOutputCh;

    //
    // Output array
    //

    pBuffer += CreateHostInputOutputArray(
                        pBuffer,
                        pHostClut->outputArray,
                        nOutputCh,
                        nOutputEntries,
                        i,
                        dwLutSig,
                        (PBYTE)pLut);

    //
    // Matrix
    //

    if (dwPCS == SPACE_XYZ)
    {
        if (dwLutSig == LUT8_TYPE)
        {
            pTable = (PBYTE) &((PLUT8TYPE)pLut)->e00;
        } else
        {
            pTable = (PBYTE) &((PLUT16TYPE)pLut)->e00;
        }

        for (i=0; i<9; i++)
        {
            pHostClut->e[i] = FIX_DIV(FIX_ENDIAN(*((PDWORD)pTable)), CIEXYZRange);
            pTable += sizeof(DWORD);
        }
    }

    //
    // RenderTable
    //

    nNumbers = nGrids * nGrids * nOutputCh;
    pHostClut->clut = pBuffer;

    for (i=0; i<nGrids; i++)        // Na strings should be sent
    {
        if (dwLutSig == LUT8_TYPE)
        {
            pTable = (PBYTE)(((PLUT8TYPE)pLut)->data) +
                nInputEntries * nInputCh +
                nNumbers * i;
        }
        else
        {
            pTable = (PBYTE)(((PLUT16TYPE)pLut)->data) +
                2 * nInputEntries * nInputCh +
                2 * nNumbers * i;
        }

        if (dwLutSig == LUT8_TYPE)
        {
            CopyMemory(pBuffer, pTable, nNumbers);
            pBuffer += nNumbers;
        }
        else
        {
            for (j=0; j<nNumbers; j++)
            {
                *pBuffer++ = (BYTE)(FIX_ENDIAN16(*((PWORD)pTable)) / 256);
                pTable += sizeof(WORD);
            }
        }
    }

    return (DWORD)(pBuffer - pStart);
}


DWORD
CreateHostMatrixCSAorCRD(
    PBYTE pProfile,
    PBYTE pBuffer,
    PDWORD pcbSize,
    DWORD dwIntent,
    BOOL bCSA
    )
{
    PTAGDATA   pTagData;
    DWORD      dwRedTRCIndex, dwGreenTRCIndex, dwBlueTRCIndex;
    DWORD      dwRedCount, dwGreenCount, dwBlueCount;
    PCURVETYPE pRed, pGreen, pBlue;
    PHOSTCLUT  pHostClut;
    PBYTE      pStart = pBuffer;
    DWORD      i, dwSize;
    double     adArray[9], adRevArray[9], adTemp[9];

    //
    // Get each TRC index for Red, Green and Blue.
    //

    if (!DoesCPTagExist(pProfile, TAG_REDTRC, &dwRedTRCIndex) ||
        !DoesCPTagExist(pProfile, TAG_GREENTRC, &dwGreenTRCIndex) ||
        !DoesCPTagExist(pProfile, TAG_BLUETRC, &dwBlueTRCIndex))
    {
        return FALSE;
    }

    //
    // Get CURVETYPE data for each Red, Green and Blue
    //

    pTagData = (PTAGDATA)(pProfile + sizeof(PROFILEHEADER) + sizeof(DWORD) +
               dwRedTRCIndex * sizeof(TAGDATA));

    pRed = (PCURVETYPE)(pProfile + FIX_ENDIAN(pTagData->dwOffset));

    pTagData = (PTAGDATA)(pProfile + sizeof(PROFILEHEADER) + sizeof(DWORD) +
               dwGreenTRCIndex * sizeof(TAGDATA));

    pGreen = (PCURVETYPE)(pProfile + FIX_ENDIAN(pTagData->dwOffset));

    pTagData = (PTAGDATA)(pProfile + sizeof(PROFILEHEADER) + sizeof(DWORD) +
               dwBlueTRCIndex * sizeof(TAGDATA));

    pBlue = (PCURVETYPE)(pProfile + FIX_ENDIAN(pTagData->dwOffset));

    //
    // Get curve count for each Red, Green and Blue.
    //

    dwRedCount   = FIX_ENDIAN(pRed->nCount);
    dwGreenCount = FIX_ENDIAN(pGreen->nCount);
    dwBlueCount  = FIX_ENDIAN(pBlue->nCount);

    //
    // Estimate the memory size required to hold CRD
    //

    dwSize = (dwRedCount + dwGreenCount + dwBlueCount) * 2 +
             sizeof(HOSTCLUT) + 2048;   // data structure + extra safe space

    //
    // Add space for new line.
    //

    dwSize += (((dwSize) / MAX_LINELEN) + 1) * STRLEN(NewLine);

    if (pBuffer == NULL)     // This is a size request
    {
        *pcbSize = dwSize;
        return TRUE;
    }

    //
    // Check buffer size.
    //

    if (*pcbSize < dwSize)
    {
        WARNING((__TEXT("Buffer too small to get Host Matrix CSA/CRD\n")));
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return FALSE;
    }

    pHostClut = (PHOSTCLUT)pBuffer;
    pBuffer += sizeof(HOSTCLUT);
    pHostClut->wSize = sizeof(HOSTCLUT);
    pHostClut->wDataType = DATATYPE_MATRIX;
    pHostClut->dwPCS = SPACE_XYZ;
    pHostClut->dwIntent = dwIntent;
    pHostClut->nClutPoints = 2;

    (void)GetCPWhitePoint(pProfile, pHostClut->afxIlluminantWP);

    if (bCSA)
    {
        pHostClut->nInputEntries = (USHORT) dwRedCount;
        pHostClut->nInputCh      = 3;

        pBuffer += CreateHostTRCInputTable(pBuffer, pHostClut,
                                           pRed, pGreen, pBlue);
    }
    else
    {
        pHostClut->nOutputEntries = (USHORT) dwRedCount;
        pHostClut->nOutputCh = 3;

        pBuffer += CreateHostRevTRCInputTable(pBuffer, pHostClut,
                                              pRed, pGreen, pBlue);
    }

    if (!CreateColorantArray(pProfile, &adTemp[0], TAG_REDCOLORANT) ||
        !CreateColorantArray(pProfile, &adTemp[3], TAG_GREENCOLORANT) ||
        !CreateColorantArray(pProfile, &adTemp[6], TAG_BLUECOLORANT))
    {
        WARNING((__TEXT("Fail to create colorant array for Host Matrix CSA/CRD\n")));
        return FALSE;
    }

    for (i = 0; i < 9; i++)
    {
        adArray[i] = adTemp[i/8*8 + i*3%8];
    }

    if (bCSA)
    {
        for (i = 0; i < 9; i++)
        {
            //
            // Convert double to Fix 16.16
            //

            pHostClut->e[i] = (FIX_16_16)(adArray[i] * (double)FIX_16_16_SCALE);
        }
    }
    else
    {
        InvertColorantArray(adArray, adRevArray);
        for (i = 0; i < 9; i++)
        {
            //
            // Convert double to Fix 16.16
            //

            pHostClut->e[i] = (FIX_16_16)(adRevArray[i] * (double)FIX_16_16_SCALE);
        }
    }

    *pcbSize = (DWORD)(pBuffer - pStart);

    return TRUE;
}


DWORD
CreateHostTRCInputTable(
    PBYTE pBuffer,
    PHOSTCLUT pHostClut,
    PCURVETYPE pRed,
    PCURVETYPE pGreen,
    PCURVETYPE pBlue
    )
{
    DWORD i;
    PWORD pBuffer16 = (PWORD) pBuffer;
    PWORD pTable;

    //
    // Red
    //

    pHostClut->inputArray[0] = (PBYTE) pBuffer16;
    pTable = pRed->data;
    for (i = 0; i < pHostClut->nInputEntries; i++)
    {
        *pBuffer16++ = FIX_ENDIAN16(*pTable);
        pTable++;
    }

    //
    // Green
    //

    pHostClut->inputArray[1] = (PBYTE) pBuffer16;
    pTable = pGreen->data;
    for (i = 0; i < pHostClut->nInputEntries; i++)
    {
        *pBuffer16++ = FIX_ENDIAN16(*pTable);
        pTable++;
    }

    //
    // Blue
    //

    pHostClut->inputArray[2] = (PBYTE) pBuffer16;
    pTable = pBlue->data;
    for (i = 0; i < pHostClut->nInputEntries; i++)
    {
        *pBuffer16++ = FIX_ENDIAN16(*pTable);
        pTable++;
    }

    return (DWORD)((PBYTE)pBuffer16 - pBuffer);
}

DWORD
CreateHostRevTRCInputTable(
    PBYTE pBuffer,
    PHOSTCLUT pHostClut,
    PCURVETYPE pRed,
    PCURVETYPE pGreen,
    PCURVETYPE pBlue
    )
{
    PWORD pTemp = MemAlloc(pHostClut->nOutputEntries * (REVCURVE_RATIO + 1) * 2);

    if (! pTemp)
    {
        return 0;
    }

    //
    // Red
    //

    pHostClut->outputArray[0] = pBuffer;
    GetRevCurve(pRed, pTemp, (PWORD) pHostClut->outputArray[0]);

    //
    // Green
    //

    pHostClut->outputArray[1] = pHostClut->outputArray[0] +
                                2 * REVCURVE_RATIO * pHostClut->nOutputEntries;
    GetRevCurve(pGreen, pTemp, (PWORD) pHostClut->outputArray[1]);

    //
    // Blue
    //

    pHostClut->outputArray[2] = pHostClut->outputArray[1] +
                                2 * REVCURVE_RATIO * pHostClut->nOutputEntries;
    GetRevCurve(pBlue, pTemp, (PWORD) pHostClut->outputArray[2]);

    MemFree(pTemp);

    return (DWORD)(2 * REVCURVE_RATIO * pHostClut->nOutputEntries * 3);
}

/***************************************************************************
*                      GetHostColorRenderingDictionary
*  function:
*    this is the main function which creates the Host CRD
*  parameters:
*       cp          --  Color Profile handle
*       Intent      --  Intent.
*       lpMem       --  Pointer to the memory block.If this point is NULL,
*                       require buffer size.
*       lpcbSize    --  size of memory block.
*
*  returns:
*       SINT        --  !=0 if the function was successful,
*                         0 otherwise.
*                       Returns number of bytes required/transferred
***************************************************************************/

BOOL
GetHostColorRenderingDictionary(
    PBYTE  pProfile,
    DWORD  dwIntent,
    PBYTE  pBuffer,
    PDWORD pdwSize
    )
{
    DWORD dwBToATag, dwIndex;

    switch (dwIntent)
    {
    case INTENT_PERCEPTUAL:
        dwBToATag = TAG_BToA0;
        break;

    case INTENT_RELATIVE_COLORIMETRIC:
    case INTENT_ABSOLUTE_COLORIMETRIC:
        dwBToATag = TAG_BToA1;
        break;

    case INTENT_SATURATION:
        dwBToATag = TAG_BToA2;
        break;

    default:
        *pdwSize = 0;
        return FALSE;
    }

    if (DoesCPTagExist(pProfile, dwBToATag, &dwIndex))
    {
        *pdwSize = CreateHostLutCRD(pProfile, dwIndex, pBuffer, dwIntent);

        return *pdwSize > 0;
    }
    else if (DoesTRCAndColorantTagExist(pProfile))
    {
        return CreateHostMatrixCSAorCRD(pProfile, pBuffer, pdwSize, dwIntent, FALSE);
    }
    else
    {
        return FALSE;
    }
}


/***************************************************************************
*                           CreateHostInputOutputArray
*  function:
*    this is the function which creates the output array from the data
*    supplied in the ColorProfile's LUT8 or LUT16 tag.
*  parameters:
*    MEMPTR     lpMem        : The buffer to save output array.
*    LPHOSTCLUT lpHostClut   :
*    SINT       nOutputCh    : Number of input channel.
*    SINT       nOutputTable : The size of each input table.
*    SINT       Offset       : The position of source output data(in icc profile).
*    CSIG       Tag          : To determin the Output table is 8 or 16 bits.
*    MEMPTR     Buff         : The buffer that contains source data(copyed from icc profile)
*
*  returns:
*       SINT    Returns number of bytes of Output Array
*
***************************************************************************/

DWORD
CreateHostInputOutputArray(
    PBYTE  pBuffer,
    PBYTE  *ppArray,
    DWORD  nNumChan,
    DWORD  nTableSize,
    DWORD  dwOffset,
    DWORD  dwLutSig,
    PBYTE  pLut
    )
{
    PBYTE   pStart = pBuffer;
    PBYTE   pTable;
    DWORD   i, j;

    for (i=0; i<nNumChan; i++)
    {
        ppArray[i] = pBuffer;

        if (dwLutSig == LUT8_TYPE)
        {
            pTable = (PBYTE) (((PLUT8TYPE)pLut)->data) +
                dwOffset + nTableSize * i;

            CopyMemory(pBuffer, pTable, nTableSize);

            pBuffer += nTableSize;
        }
        else
        {
            pTable = (PBYTE) (((PLUT16TYPE)pLut)->data) +
                2 * dwOffset +
                2 * nTableSize * i;

            for (j=0; j<nTableSize; j++)
            {
                *((PWORD)pBuffer) = FIX_ENDIAN16(*((PWORD)pTable));
                pBuffer += sizeof(WORD);
                pTable += sizeof(WORD);
            }
        }
    }

    return (DWORD) (pBuffer - pStart);
}


/***************************************************************************
*                           GetHostCSA
*  function:
*    this is the function which creates a Host CSA
*  parameters:
*       CHANDLE cp       --  Color Profile handle
*       MEMPTR lpMem     --  Pointer to the memory block. If this point is NULL,
*                            require buffer size.
*       LPDWORD lpcbSize --  Size of the memory block
*       CSIG InputIntent --
*       SINT Index       --  to the icc profile tag that contains the data of Intent
*       int  Type        --  DEF or DEFG
*  returns:
*       BOOL        --  TRUE if the function was successful,
*                       FALSE otherwise.
***************************************************************************/

BOOL
GetHostCSA(
    PBYTE  pProfile,
    PBYTE  pBuffer,
    PDWORD pdwSize,
    DWORD  dwIntent,
    DWORD  dwType
    )
{
    PHOSTCLUT  pHostClut;
    PTAGDATA   pTagData;
    PLUT16TYPE pLut;
    DWORD      dwAToBTag;
    DWORD      dwPCS, dwLutSig;
    DWORD      nInputCh, nOutputCh, nGrids, SecondGrids;
    DWORD      nInputTable, nOutputTable, nNumbers;
    DWORD      dwIndex, i, j, k;
    PBYTE      pTable;
    PBYTE      pStart = pBuffer;

    switch (dwIntent)
    {
    case INTENT_PERCEPTUAL:
        dwAToBTag = TAG_AToB0;
        break;

    case INTENT_RELATIVE_COLORIMETRIC:
    case INTENT_ABSOLUTE_COLORIMETRIC:
        dwAToBTag = TAG_AToB1;
        break;

    case INTENT_SATURATION:
        dwAToBTag = TAG_AToB2;
        break;

    default:
        WARNING((__TEXT("Invalid intent passed to GetHostCSA: %d\n"), dwIntent));
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
        break;
    }

    if (!DoesCPTagExist(pProfile, dwAToBTag, &dwIndex))
    {
        if (DoesTRCAndColorantTagExist(pProfile) && (dwType == TYPE_CIEBASEDDEF))
        {
            //
            // Create Host CSA from Matrix.
            //

            return CreateHostMatrixCSAorCRD(pProfile,pBuffer,pdwSize,dwIntent,TRUE);
        }
        else
        {
            WARNING((__TEXT("AToB tag not present for intent %d\n"), dwIntent));
            SetLastError(ERROR_TAG_NOT_PRESENT);
            return FALSE;
        }
    }

    //
    // Check if we can generate the CSA
    //

    dwPCS = GetCPConnSpace(pProfile);

    pTagData = (PTAGDATA)(pProfile + sizeof(PROFILEHEADER) + sizeof(DWORD) +
               dwIndex * sizeof(TAGDATA));

    pLut = (PLUT16TYPE)(pProfile + FIX_ENDIAN(pTagData->dwOffset));

    dwLutSig = FIX_ENDIAN(pLut->dwSignature);

    if (((dwPCS != SPACE_Lab) && (dwPCS != SPACE_XYZ)) ||
        ((dwLutSig != LUT8_TYPE) && (dwLutSig != LUT16_TYPE)))
    {
        WARNING((__TEXT("Invalid color space - unable to create DEF(G) host CSA\n")));
        SetLastError(ERROR_INVALID_PROFILE);
        return FALSE;
    }

    //
    // Estimate the memory size required to hold CSA
    //

    (void)GetCLUTInfo(dwLutSig, (PBYTE)pLut, &nInputCh, &nOutputCh, &nGrids,
                &nInputTable, &nOutputTable, &i);

    if (!(nOutputCh == 3) ||
        !((nInputCh == 3) && (dwType == TYPE_CIEBASEDDEF)) &&
        !((nInputCh == 4) && (dwType == TYPE_CIEBASEDDEFG)))
    {
        return FALSE;
    }
    
    if (pBuffer == NULL)
    {
        //
        // Return size
        //

        if (dwType == TYPE_CIEBASEDDEFG)
            *pdwSize = nOutputCh * nGrids * nGrids * nGrids * nGrids;
        else
            *pdwSize = nOutputCh * nGrids * nGrids * nGrids;

        *pdwSize +=                           // size of RenderTable 8-bits only
            nInputCh * nInputTable * i    +   // size of input table 8/16-bits
            nOutputCh * nOutputTable * i  +   // size of output table 8/16-bits
            sizeof(HOSTCLUT) + 2048;          // data structure + other PS stuff

        //
        // Add space for new line.
        //

        *pdwSize += (((*pdwSize) / MAX_LINELEN) + 1) * STRLEN(NewLine);

        return TRUE;
    }

    pHostClut = (PHOSTCLUT)pBuffer;
    pBuffer += sizeof(HOSTCLUT);
    pHostClut->wSize = sizeof(HOSTCLUT);
    pHostClut->wDataType = DATATYPE_LUT;
    pHostClut->dwPCS = dwPCS;
    pHostClut->dwIntent = dwIntent;
    pHostClut->nLutBits = (dwLutSig == LUT8_TYPE) ? 8 : 16;

    //
    // Get info about Illuminant White Point from the header
    //

    (void)GetCPWhitePoint(pProfile, pHostClut->afxIlluminantWP);

    pHostClut->nInputCh = (BYTE)nInputCh;
    pHostClut->nOutputCh = (BYTE)nOutputCh;
    pHostClut->nClutPoints = (BYTE)nGrids;
    pHostClut->nInputEntries = (WORD)nInputTable;
    pHostClut->nOutputEntries = (WORD)nOutputTable;

    //
    // Input Array
    //

    pBuffer += CreateHostInputOutputArray(pBuffer, pHostClut->inputArray,
             nInputCh, nInputTable, 0, dwLutSig, (PBYTE)pLut);

    if (dwType == TYPE_CIEBASEDDEFG)
    {
        i = nInputTable * nInputCh +
            nGrids * nGrids * nGrids * nGrids * nOutputCh;
    }
    else
    {
        i = nInputTable * nInputCh +
            nGrids * nGrids * nGrids * nOutputCh;
    }

    //
    // Output Array
    //

    pBuffer += CreateHostInputOutputArray(pBuffer, pHostClut->outputArray,
             nOutputCh, nOutputTable, i, dwLutSig, (PBYTE)pLut);

    //
    // /Table
    //

    pHostClut->clut = pBuffer;
    nNumbers = nGrids * nGrids * nOutputCh;
    SecondGrids = 1;
    if (dwType == TYPE_CIEBASEDDEFG)
    {
        SecondGrids = nGrids;
    }

    for (i=0; i<nGrids; i++)        // Nh strings should be sent
    {
        for (k=0; k<SecondGrids; k++)
        {
            if (dwLutSig == LUT8_TYPE)
            {
                pTable = (PBYTE) (((PLUT8TYPE)pLut)->data) +
                    nInputTable * nInputCh +
                    nNumbers * (i * SecondGrids + k);
            }
            else
            {
                pTable = (PBYTE) (((PLUT16TYPE)pLut)->data) +
                    2 * nInputTable * nInputCh +
                    2 * nNumbers * (i * SecondGrids + k);
            }

            if (dwLutSig == LUT8_TYPE)
            {
                CopyMemory(pBuffer, pTable, nNumbers);
                pBuffer += nNumbers;
            }
            else
            {
                for (j=0; j<nNumbers; j++)
                {
                    *pBuffer++ = (BYTE)(FIX_ENDIAN16(*((PWORD)pTable)) / 256);
                    pTable += sizeof(WORD);
                }
            }
        }
    }

    *pdwSize = (DWORD) (pBuffer - pStart);

    return TRUE;
}


/***************************************************************************
*                            GetHostColorSpaceArray
*  function:
*    This is the main function which creates the Host CSA
*    from the data supplied in the Profile.
*  parameters:
*       cp          --  Color Profile handle
*       InputIntent --  Intent.
*       lpBuffer    --  Pointer to the memory block. If this point is NULL,
*                       require buffer size.
*       lpcbSize    --  Size of the memory block
*  returns:
*       BOOL        --  TRUE if the function was successful,
*                       FALSE otherwise.
***************************************************************************/

BOOL
GetHostColorSpaceArray(
    PBYTE  pProfile,
    DWORD  dwIntent,
    PBYTE  pBuffer,
    PDWORD pdwSize
    )
{
    DWORD dwDev;
    BOOL bRc = FALSE;

    dwDev = GetCPDevSpace(pProfile);

    switch (dwDev)
    {
    case SPACE_RGB:
        bRc = GetHostCSA(pProfile, pBuffer, pdwSize,
                  dwIntent, TYPE_CIEBASEDDEF);
        break;
    case SPACE_CMYK:
        bRc = GetHostCSA(pProfile, pBuffer, pdwSize,
                  dwIntent, TYPE_CIEBASEDDEFG);
        break;
    default:
        break;
    }

    return bRc;
}


/***************************************************************************
*                         DoHostConversionCRD
*  function:
*    This function converts XYZ/Lab to RGB/CMYK by using HostCRD
*  parameters:
*       LPHOSTCLUT lpHostCRD  -- pointer to a HostCRD
*       LPHOSTCLUT lpHostCSA  -- pointer to a HostCSA
*       float far *Input      -- Input XYZ/Lab
*       float far *Output     -- Output RGB/CMYK
*  returns:
*       BOOL                  -- TRUE
***************************************************************************/

BOOL
DoHostConversionCRD(
    PHOSTCLUT   pHostCRD,
    PHOSTCLUT   pHostCSA,
    float       *pfInput,
    float       *pfOutput,
    BOOL        bCheckOutputTable
    )
{
    float      fTemp[MAXCHANNELS];
    float      fTemp1[MAXCHANNELS];
    DWORD      i, j;

    //
    // Input XYZ or Lab in range [0 2]
    //
    // When sampling the deviceCRD, skip the input table.
    // If pHostCSA is not NULL, the current CRD is targetCRD, we
    // need to do input table conversion
    //

    if (pHostCSA)
    {
        //
        // Convert Lab to XYZ  in range [ 0 whitePoint ]
        //

        if ((pHostCRD->dwPCS == SPACE_XYZ) &&
            (pHostCSA->dwPCS == SPACE_Lab))
        {
            LabToXYZ(pfInput, fTemp1, pHostCRD->afxIlluminantWP);
        }
        else if ((pHostCRD->dwPCS == SPACE_Lab) &&
                 (pHostCSA->dwPCS == SPACE_XYZ))
        {
            //
            // Convert XYZ to Lab in range [ 0 1]
            //

            XYZToLab(pfInput, fTemp, pHostCSA->afxIlluminantWP);
        }
        else if ((pHostCRD->dwPCS == SPACE_Lab) &&
                 (pHostCSA->dwPCS == SPACE_Lab))
        {
            //
            // Convert Lab to range [ 0 1]
            //

            for (i=0; i<3; i++)
                fTemp[i] = pfInput[i] / 2;
        }
        else
        {
            //
            // Convert XYZ to XYZ (based on white point) to range [0 1]
            //
            //       different intents using different conversion.
            //       icRelativeColorimetric: using Bradford transform.
            //       icAbsoluteColorimetric: using scaling.
            //

            for (i=0; i<3; i++)
                fTemp1[i] = (pfInput[i] * pHostCRD->afxIlluminantWP[i]) / pHostCSA->afxIlluminantWP[i];
        }

        //
        // Matrix, used for XYZ data only.
        //

        if (pHostCRD->dwPCS == SPACE_XYZ)
        {
            ApplyMatrix(pHostCRD->e, fTemp1, fTemp);
        }

        if (pHostCRD->wDataType != DATATYPE_MATRIX)
        {
            //
            // Search input Table
            //

            (void)CheckInputOutputTable(pHostCRD, fTemp, FALSE, TRUE);
        }
    }

    //
    // If the current CRD is device CRD, we do not need to do input
    // table conversion
    //

    else
    {
        WORD nGrids;

        nGrids = pHostCRD->nClutPoints;

        //
        // Sample data may be XYZ or Lab. It depends on Target icc profile.
        // If the PCS of the target icc profile is XYZ, input data will be XYZ.
        // If the PCS of the target icc profile is Lab, input data will be Lab.
        //

        if (pHostCRD->wDataType == DATATYPE_MATRIX)
        {
            for (i = 0; i < 3; i++)
            {
                fTemp[i] = pfInput[i];
            }
        }
        else
        {
            for (i=0; i<3; i++)
            {
                fTemp[i] = pfInput[i] * (nGrids - 1);
                if (fTemp[i] > (nGrids - 1))
                    fTemp[i] = (float)(nGrids - 1);
            }
        }
    }

    if (pHostCRD->wDataType != DATATYPE_MATRIX)
    {
        //
        // Rendering table
        //

        (void)CheckColorLookupTable(pHostCRD, fTemp);
    }

    //
    // Output RGB or CMYK in range [0 1]
    //

    if (bCheckOutputTable)
    {
        (void)CheckInputOutputTable(pHostCRD, fTemp, FALSE, FALSE);
    }

    for (i=0; (i<=MAXCHANNELS) && (i<pHostCRD->nOutputCh); i++)
    {
        pfOutput[i] = fTemp[i];
    }

    return TRUE;
}

/***************************************************************************
*                         DoHostConversionCSA
*  function:
*    This function converts RGB/CMYK to XYZ/Lab by using HostCSA
*  parameters:
*       LPHOSTCLUT lpHostCLUT -- pointer to a HostCSA
*       float far *Input      -- Input XYZ/Lab
*       float far *Output     -- Output RGB/CMYK
*  returns:
*       BOOL                  -- TRUE
***************************************************************************/

BOOL
DoHostConversionCSA(
    PHOSTCLUT     pHostClut,
    float         *pfInput,
    float         *pfOutput
    )
{
    float      fTemp[MAXCHANNELS];
    DWORD      i;

    //
    // Input RGB or CMYK in range [0 1]
    //

    for (i=0; (i<=MAXCHANNELS) && (i<pHostClut->nInputCh); i++)
    {
        fTemp[i] = pfInput[i];
    }

    //
    // Search input Table
    //

    (void)CheckInputOutputTable(pHostClut, fTemp, TRUE, TRUE);

    if (pHostClut->wDataType == DATATYPE_MATRIX)
    {
        ApplyMatrix(pHostClut->e, fTemp, pfOutput);
    }
    else
    {
        //
        // Rendering table
        //

        (void)CheckColorLookupTable(pHostClut, fTemp);

        //
        // Output Table
        //

        (void)CheckInputOutputTable(pHostClut, fTemp, TRUE, FALSE);

        //
        // Output XYZ or Lab in range [0 2]
        //

        for (i=0; (i<=MAXCHANNELS) && (i<pHostClut->nOutputCh); i++)
        {
            pfOutput[i] = fTemp[i];
        }
    }

    return TRUE;
}               



/***************************************************************************
*                         CheckInputOutputTable
*  function:
*    This function check inputTable.
*  parameters:
*       LPHOSTCLUT lpHostClut --
*       float far  *fTemp     --  Input / output data
*  returns:
*       BOOL                  -- TRUE
***************************************************************************/

BOOL
CheckInputOutputTable(
    PHOSTCLUT    pHostClut,
    float        *pfTemp,
    BOOL         bCSA,
    BOOL         bInputTable
    )
{
    PBYTE      *ppArray;
    float      fIndex;
    DWORD      nNumCh;
    DWORD      nNumEntries, i;
    WORD       nGrids;
    WORD       floor1, ceiling1;

    if (bInputTable)
    {
        nNumCh = pHostClut->nInputCh;
        nNumEntries = pHostClut->nInputEntries - 1;
        ppArray = pHostClut->inputArray;
    }
    else
    {
        nNumCh = pHostClut->nOutputCh;
        nNumEntries = pHostClut->nOutputEntries - 1;
        ppArray = pHostClut->outputArray;
    }

    nGrids = pHostClut->nClutPoints;
    for (i=0; (i<=MAXCHANNELS) && (i<nNumCh); i++)
    {
        pfTemp[i] = (pfTemp[i] < 0) ? 0 : ((pfTemp[i] > 1) ? 1 : pfTemp[i]);

        fIndex = pfTemp[i] * nNumEntries;

        if (pHostClut->nLutBits == 8)
        {
            floor1 = ppArray[i][(DWORD)fIndex];
            ceiling1 = ppArray[i][((DWORD)fIndex) + 1];

            pfTemp[i] = (float)(floor1 + (ceiling1 - floor1) * (fIndex - floor(fIndex)));

            if (bCSA && !bInputTable)
                pfTemp[i] = pfTemp[i] / 127.0f;
            else
                pfTemp[i] = pfTemp[i] / 255.0f;
        }
        else
        {
            floor1 = ((PWORD)(ppArray[i]))[(DWORD)fIndex];
            ceiling1 = ((PWORD)(ppArray[i]))[((DWORD)fIndex) + 1];

            pfTemp[i] = (float)(floor1 + (ceiling1 - floor1) * (fIndex - floor(fIndex)));

            if (bCSA && !bInputTable)
                pfTemp[i] = pfTemp[i] / 32767.0f;
            else
                pfTemp[i] = pfTemp[i] / 65535.0f;

        }

        if (bInputTable)
        {
            pfTemp[i] *= (nGrids - 1);
            if (pfTemp[i] > (nGrids - 1))
                pfTemp[i] =  (float)(nGrids - 1);
        }
    }

    return TRUE;
}


/***************************************************************************
*                               g
*  function:
*    Calculate function y = g(x). used in Lab->XYZ conversion
*    y = g(x):      g(x) = x*x*x             if x >= 6/29
*                   g(x) = 108/841*(x-4/29)  otherwise
*  parameters:
*       f           --  x
*  returns:
*       SINT        --  y
***************************************************************************/

float g(
    float f
    )
{
    float fRc;

    if (f >= (6.0f/29.0f))
    {
        fRc = f * f * f;
    }
    else
    {
        fRc = f - (4.0f / 29.0f) * (108.0f / 841.0f);
    }

    return fRc;
}

/***************************************************************************
*                          inverse_g
*  function:
*    Calculate inverse function y = g(x). used in XYZ->Lab conversion
*  parameters:
*       f           --  y
*  returns:
*       SINT        --  x
***************************************************************************/

float
inverse_g(
    float f
    )
{
    double fRc;

    if (f >= (6.0f*6.0f*6.0f)/(29.0f*29.0f*29.0f))
    {
        fRc = pow(f, 1.0 / 3.0);
    }
    else
    {
        fRc = f * (841.0f / 108.0f) + (4.0f / 29.0f);
    }

    return (float)fRc;
}


void
LabToXYZ(
    float      *pfInput,
    float      *pfOutput,
    PFIX_16_16 pafxWP
    )
{
    float   fL, fa, fb;

    fL = (pfInput[0] * 50 + 16) / 116;
    fa = (pfInput[1] * 128 - 128) / 500;
    fb = (pfInput[2] * 128 - 128) / 200;

    pfOutput[0] = pafxWP[0] * g(fL + fa) / FIX_16_16_SCALE;
    pfOutput[1] = pafxWP[1] * g(fL) / FIX_16_16_SCALE;
    pfOutput[2] = pafxWP[2] * g(fL - fb) / FIX_16_16_SCALE;

    return;
}


void
XYZToLab(
    float      *pfInput,
    float      *pfOutput,
    PFIX_16_16 pafxWP
    )
{
    float  fL, fa, fb;

    fL = inverse_g(pfInput[0] * FIX_16_16_SCALE / pafxWP[0]);
    fa = inverse_g(pfInput[1] * FIX_16_16_SCALE / pafxWP[1]);
    fb = inverse_g(pfInput[2] * FIX_16_16_SCALE / pafxWP[2]);

    pfOutput[0] = (fa * 116 - 16) / 100;
    pfOutput[1] = (fL * 500 - fa * 500 + 128) / 255;
    pfOutput[2] = (fa * 200 - fb * 200 + 128) / 255;

    return;
}


BOOL
TableInterp3(
    PHOSTCLUT  pHostClut,
    float      *pfTemp
    )
{

    PBYTE        v000, v001, v010, v011;
    PBYTE        v100, v101, v110, v111;
    float        fA, fB, fC;
    float        fVx0x, fVx1x;
    float        fV0xx, fV1xx;
    DWORD        tmpA, tmpBC;
    DWORD        cellA, cellB, cellC;
    DWORD        idx;
    WORD         nGrids;
    WORD         nOutputCh;

    cellA = (DWORD)pfTemp[0];
    fA = pfTemp[0] - cellA;

    cellB = (DWORD)pfTemp[1];
    fB = pfTemp[1] - cellB;

    cellC = (DWORD)pfTemp[2];
    fC = pfTemp[2] - cellC;

    nGrids = pHostClut->nClutPoints;
    nOutputCh = pHostClut->nOutputCh;
    tmpA  = nOutputCh * nGrids * nGrids;
    tmpBC = nOutputCh * (nGrids * cellB + cellC);

    //
    // Calculate 8 surrounding cells.
    //

    v000 = pHostClut->clut + tmpA * cellA + tmpBC;
    v001 = (cellC < (DWORD)(nGrids - 1)) ? v000 + nOutputCh : v000;
    v010 = (cellB < (DWORD)(nGrids - 1)) ? v000 + nOutputCh * nGrids : v000;
    v011 = (cellC < (DWORD)(nGrids - 1)) ? v010 + nOutputCh : v010 ;

    v100 = (cellA < (DWORD)(nGrids - 1)) ? v000 + tmpA : v000;
    v101 = (cellC < (DWORD)(nGrids - 1)) ? v100 + nOutputCh : v100;
    v110 = (cellB < (DWORD)(nGrids - 1)) ? v100 + nOutputCh * nGrids : v100;
    v111 = (cellC < (DWORD)(nGrids - 1)) ? v110 + nOutputCh : v110;

    for (idx=0; idx<nOutputCh; idx++)
    {
        //
        // Calculate the average of 4 bottom cells.
        //

        fVx0x = *v000 + fC * (int)((int)*v001 - (int)*v000);
        fVx1x = *v010 + fC * (int)((int)*v011 - (int)*v010);
        fV0xx = fVx0x + fB * (fVx1x - fVx0x);

        //
        // Calculate the average of 4 upper cells.
        //

        fVx0x = *v100 + fC * (int)((int)*v101 - (int)*v100);
        fVx1x = *v110 + fC * (int)((int)*v111 - (int)*v110);
        fV1xx = fVx0x + fB * (fVx1x - fVx0x);

        //
        // Calculate the bottom and upper average.
        //

        pfTemp[idx] = (fV0xx + fA * (fV1xx - fV0xx)) / MAXCOLOR8;

        if ( idx < (DWORD)(nOutputCh - 1))
        {
            v000++;
            v001++;
            v010++;
            v011++;
            v100++;
            v101++;
            v110++;
            v111++;
        }
    }

    return TRUE;
}


BOOL
TableInterp4(
    PHOSTCLUT  pHostClut,
    float      *pfTemp
    )
{
    PBYTE     v0000, v0001, v0010, v0011;
    PBYTE     v0100, v0101, v0110, v0111;
    PBYTE     v1000, v1001, v1010, v1011;
    PBYTE     v1100, v1101, v1110, v1111;
    float     fH, fI, fJ, fK;
    float     fVxx0x, fVxx1x;
    float     fVx0xx, fVx1xx;
    float     fV0xxx, fV1xxx;
    DWORD     tmpH, tmpI, tmpJK;
    DWORD     cellH, cellI, cellJ, cellK;
    DWORD     idx;
    WORD      nGrids;
    WORD      nOutputCh;

    cellH = (DWORD)pfTemp[0];
    fH = pfTemp[0] - cellH;

    cellI = (DWORD)pfTemp[1];
    fI = pfTemp[1] - cellI;

    cellJ = (DWORD)pfTemp[2];
    fJ = pfTemp[2] - cellJ;

    cellK = (DWORD)pfTemp[3];
    fK = pfTemp[3] - cellK;

    nGrids = pHostClut->nClutPoints;
    nOutputCh = pHostClut->nOutputCh;
    tmpI  = nOutputCh * nGrids * nGrids;
    tmpH  = tmpI * nGrids;
    tmpJK = nOutputCh * (nGrids * cellJ + cellK);

    //
    // Calculate 16 surrounding cells.
    //

    v0000 = pHostClut->clut + tmpH * cellH + tmpI * cellI + tmpJK;
    v0001 = (cellK < (DWORD)(nGrids - 1))? v0000 + nOutputCh : v0000;
    v0010 = (cellJ < (DWORD)(nGrids - 1))? v0000 + nOutputCh * nGrids : v0000;
    v0011 = (cellK < (DWORD)(nGrids - 1))? v0010 + nOutputCh : v0010;

    v0100 = (cellI < (DWORD)(nGrids - 1))? v0000 + tmpI : v0000;
    v0101 = (cellK < (DWORD)(nGrids - 1))? v0100 + nOutputCh : v0100;
    v0110 = (cellJ < (DWORD)(nGrids - 1))? v0100 + nOutputCh * nGrids : v0100;
    v0111 = (cellK < (DWORD)(nGrids - 1))? v0110 + nOutputCh : v0110;

    v1000 = (cellH < (DWORD)(nGrids - 1))? v0000 + tmpH : v0000;
    v1001 = (cellK < (DWORD)(nGrids - 1))? v1000 + nOutputCh : v1000;
    v1010 = (cellJ < (DWORD)(nGrids - 1))? v1000 + nOutputCh * nGrids : v1000;
    v1011 = (cellK < (DWORD)(nGrids - 1))? v1010 + nOutputCh : v1010;

    v1100 = (cellI < (DWORD)(nGrids - 1))? v1000 + tmpI : v1000;
    v1101 = (cellK < (DWORD)(nGrids - 1))? v1100 + nOutputCh : v1100;
    v1110 = (cellJ < (DWORD)(nGrids - 1))? v1100 + nOutputCh * nGrids : v1100;
    v1111 = (cellK < (DWORD)(nGrids - 1))? v1110 + nOutputCh : v1110;


    for (idx=0; idx<nOutputCh; idx++)
    {
        //
        // Calculate the average of 8 bottom cells.
        //

        fVxx0x = *v0000 + fK * (int)((int)*v0001 - (int)*v0000);
        fVxx1x = *v0010 + fK * (int)((int)*v0011 - (int)*v0010);
        fVx0xx = fVxx0x + fJ * (fVxx1x - fVxx0x);
        fVxx0x = *v0100 + fK * (int)((int)*v0101 - (int)*v0100);
        fVxx1x = *v0110 + fK * (int)((int)*v0111 - (int)*v0110);
        fVx1xx = fVxx0x + fJ * (fVxx1x - fVxx0x);
        fV0xxx = fVx0xx + fI * (fVx1xx - fVx0xx);

        //
        // Calculate the average of 8 upper cells.
        //

        fVxx0x = *v1000 + fK * (int)((int)*v1001 - (int)*v1000);
        fVxx1x = *v1010 + fK * (int)((int)*v1011 - (int)*v1010);
        fVx0xx = fVxx0x + fJ * (fVxx1x - fVxx0x);
        fVxx0x = *v1100 + fK * (int)((int)*v1101 - (int)*v1100);
        fVxx1x = *v1110 + fK * (int)((int)*v1111 - (int)*v1110);
        fVx1xx = fVxx0x + fJ * (fVxx1x - fVxx0x);
        fV1xxx = fVx0xx + fI * (fVx1xx - fVx0xx);

        //
        // Calculate the bottom and upper average.
        //

        pfTemp[idx] = (fV0xxx + fH * (fV1xxx - fV0xxx)) / MAXCOLOR8;

        if (idx < (DWORD)(nOutputCh - 1))
        {
            v0000++;
            v0001++;
            v0010++;
            v0011++;
            v0100++;
            v0101++;
            v0110++;
            v0111++;
            v1000++;
            v1001++;
            v1010++;
            v1011++;
            v1100++;
            v1101++;
            v1110++;
            v1111++;
        }
    }

    return TRUE;
}

BOOL
InvertColorantArray(
    double *lpInMatrix,
    double *lpOutMatrix)
{
    double det;

    double *a;
    double *b;
    double *c;

    a = &(lpInMatrix[0]);
    b = &(lpInMatrix[3]);
    c = &(lpInMatrix[6]);

    det = a[0] * b[1] * c[2] + a[1] * b[2] * c[0] + a[2] * b[0] * c[1] -
         (a[2] * b[1] * c[0] + a[1] * b[0] * c[2] + a[0] * b[2] * c[1]);

    if (det == 0.0)    // What to do?
    {
        lpOutMatrix[0] = 1.0;
        lpOutMatrix[1] = 0.0;
        lpOutMatrix[2] = 0.0;

        lpOutMatrix[3] = 0.0;
        lpOutMatrix[4] = 1.0;
        lpOutMatrix[5] = 0.0;

        lpOutMatrix[6] = 0.0;
        lpOutMatrix[7] = 0.0;
        lpOutMatrix[8] = 1.0;
    }
    else
    {
        lpOutMatrix[0] = (b[1] * c[2] - b[2] * c[1]) / det;
        lpOutMatrix[3] = -(b[0] * c[2] - b[2] * c[0]) / det;
        lpOutMatrix[6] = (b[0] * c[1] - b[1] * c[0]) / det;

        lpOutMatrix[1] = -(a[1] * c[2] - a[2] * c[1]) / det;
        lpOutMatrix[4] = (a[0] * c[2] - a[2] * c[0]) / det;
        lpOutMatrix[7] = -(a[0] * c[1] - a[1] * c[0]) / det;

        lpOutMatrix[2] = (a[1] * b[2] - a[2] * b[1]) / det;
        lpOutMatrix[5] = -(a[0] * b[2] - a[2] * b[0]) / det;
        lpOutMatrix[8] = (a[0] * b[1] - a[1] * b[0]) / det;
    }

    return (TRUE);
}

VOID
ApplyMatrix(
    FIX_16_16 *e,
    float *Input,
    float *Output)
{
    DWORD i, j;

    for (i=0; i<3; i++)
    {
        j = i * 3;

        Output[i] = ((e[j]     * Input[0]) / FIX_16_16_SCALE) +
                    ((e[j + 1] * Input[1]) / FIX_16_16_SCALE) +
                    ((e[j + 2] * Input[2]) / FIX_16_16_SCALE);
    }
}


/***************************************************************************
*                         CheckColorLookupTable
*  function:
*    This function check RenderTable.
*  parameters:
*       LPHOSTCLUT lpHostClut --
*       float far  *fTemp     --  Input (in range [0 gred-1]) /
*                                 output(in range [0 1)
*  returns:
*       BOOL                  -- TRUE
***************************************************************************/

BOOL
CheckColorLookupTable(
    PHOSTCLUT   pHostClut,
    float       *pfTemp
    )
{
    if (pHostClut->nInputCh == 3)
    {
        return TableInterp3(pHostClut, pfTemp);
    }
    else if (pHostClut->nInputCh == 4)
    {
        return TableInterp4(pHostClut, pfTemp);
    }
    else
        return FALSE;
}

//
// For testing purposes
//

BOOL WINAPI
GetPS2PreviewCRD (
    HPROFILE  hDestProfile,
    HPROFILE  hTargetProfile,
    DWORD     dwIntent,
    PBYTE     pBuffer,
    PDWORD    pcbSize,
    LPBOOL    pbBinary
    )
{
    PPROFOBJ pDestProfObj;
    PPROFOBJ pTargetProfObj;

    pDestProfObj = (PPROFOBJ)HDLTOPTR(hDestProfile);
    pTargetProfObj = (PPROFOBJ)HDLTOPTR(hTargetProfile);


    return InternalGetPS2PreviewCRD(pDestProfObj->pView, pTargetProfObj->pView, dwIntent, pBuffer, pcbSize, pbBinary);
}

#endif // !defined(KERNEL_MODE) || defined(USERMODE_DRIVER)

/*
 *  Crc - 32 BIT ANSI X3.66 CRC checksum files
 *
 *
 * Copyright (C) 1986 Gary S. Brown.  You may use this program, or
 * code or tables extracted from it, as desired without restriction.
 */

static DWORD  crc_32_tab[] = { /* CRC polynomial 0xedb88320 */
0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419, 0x706af48f, 0xe963a535, 0x9e6495a3,
0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988, 0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91,
0x1db71064, 0x6ab020f2, 0xf3b97148, 0x84be41de, 0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7,
0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9, 0xfa0f3d63, 0x8d080df5,
0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172, 0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b,
0x35b5a8fa, 0x42b2986c, 0xdbbbc9d6, 0xacbcf940, 0x32d86ce3, 0x45df5c75, 0xdcd60dcf, 0xabd13d59,
0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423, 0xcfba9599, 0xb8bda50f,
0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924, 0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d,
0x76dc4190, 0x01db7106, 0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433,
0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818, 0x7f6a0dbb, 0x086d3d2d, 0x91646c97, 0xe6635c01,
0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e, 0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457,
0x65b0d9c6, 0x12b7e950, 0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65,
0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2, 0x4adfa541, 0x3dd895d7, 0xa4d1c46d, 0xd3d6f4fb,
0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0, 0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9,
0x5005713c, 0x270241aa, 0xbe0b1010, 0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,
0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17, 0x2eb40d81, 0xb7bd5c3b, 0xc0ba6cad,
0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a, 0xead54739, 0x9dd277af, 0x04db2615, 0x73dc1683,
0xe3630b12, 0x94643b84, 0x0d6d6a3e, 0x7a6a5aa8, 0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1,
0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb, 0x196c3671, 0x6e6b06e7,
0xfed41b76, 0x89d32be0, 0x10da7a5a, 0x67dd4acc, 0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5,
0xd6d6a3e8, 0xa1d1937e, 0x38d8c2c4, 0x4fdff252, 0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b,
0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55, 0x316e8eef, 0x4669be79,
0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236, 0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f,
0xc5ba3bbe, 0xb2bd0b28, 0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d,
0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a, 0x9c0906a9, 0xeb0e363f, 0x72076785, 0x05005713,
0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38, 0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21,
0x86d3d2d4, 0xf1d4e242, 0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777,
0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c, 0x8f659eff, 0xf862ae69, 0x616bffd3, 0x166ccf45,
0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2, 0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db,
0xaed16a4a, 0xd9d65adc, 0x40df0b66, 0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,
0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605, 0xcdd70693, 0x54de5729, 0x23d967bf,
0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94, 0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d
};

DWORD crc32(PBYTE buff, DWORD length)
{
    DWORD crc, charcnt;
    BYTE  c;

    crc = 0xFFFFFFFF;
    charcnt = 0;

    for (charcnt = 0 ; charcnt < length ; charcnt++)
    {
        c = buff[charcnt];
        crc = crc_32_tab[(crc ^ c) & 0xff] ^ (crc >> 8);
    }

    return crc;
}

/***************************************************************************
*                           IsSRGBColorProfile
*
*  function: check if the profile is sRGB
*
*  parameters:
*       cp          --  Color Profile handle
*
*  returns:
*       BOOL        --  TRUE if the profile is sRGB
*                       FALSE otherwise.
***************************************************************************/

BOOL IsSRGBColorProfile(
    PBYTE pProfile
    )
{
    BOOL  bMatch = FALSE;
    DWORD dwRedTRCIndex, dwGreenTRCIndex, dwBlueTRCIndex;
    DWORD dwRedCIndex, dwGreenCIndex, dwBlueCIndex;
    DWORD dwSize;
    DWORD dwRedTRCSize=0, dwGreenTRCSize=0, dwBlueTRCSize=0;
    DWORD dwRedCSize=0, dwGreenCSize=0, dwBlueCSize=0;
    PBYTE pRed, pGreen, pBlue, pRedC, pGreenC, pBlueC;
    BYTE  DataBuffer[ALIGN_DWORD(sRGB_TAGSIZE)];

    if (DoesCPTagExist(pProfile, TAG_REDTRC, &dwRedTRCIndex)             &&
        GetCPElementDataSize(pProfile, dwRedTRCIndex, &dwRedTRCSize)     &&

        DoesCPTagExist(pProfile, TAG_GREENTRC, &dwGreenTRCIndex)         &&
        GetCPElementDataSize(pProfile, dwGreenTRCIndex, &dwGreenTRCSize) &&

        DoesCPTagExist(pProfile, TAG_BLUETRC, &dwBlueTRCIndex)           &&
        GetCPElementDataSize(pProfile, dwBlueTRCIndex, &dwBlueTRCSize)   &&

        DoesCPTagExist(pProfile, TAG_REDCOLORANT, &dwRedCIndex)          &&
        GetCPElementDataSize(pProfile, dwRedCIndex, &dwRedCSize)         &&

        DoesCPTagExist(pProfile, TAG_GREENCOLORANT, &dwGreenCIndex)      &&
        GetCPElementDataSize(pProfile, dwGreenCIndex, &dwGreenCSize)     &&

        DoesCPTagExist(pProfile, TAG_BLUECOLORANT, &dwBlueCIndex)        &&
        GetCPElementDataSize(pProfile, dwBlueCIndex, &dwBlueCSize))
    {
        dwSize = dwRedTRCSize + dwGreenTRCSize + dwBlueTRCSize +
                 dwRedCSize   + dwGreenCSize   + dwBlueCSize;

        if (dwSize == sRGB_TAGSIZE)
        {
            ZeroMemory(DataBuffer,sizeof(DataBuffer));

            pRed    = DataBuffer;
            pGreen  = pRed    + dwRedTRCSize;
            pBlue   = pGreen  + dwGreenTRCSize;
            pRedC   = pBlue   + dwBlueTRCSize;
            pGreenC = pRedC   + dwRedCSize;
            pBlueC  = pGreenC + dwGreenCSize;

            if (GetCPElementData(pProfile, dwRedTRCIndex, pRed, &dwRedTRCSize)       &&
                GetCPElementData(pProfile, dwGreenTRCIndex, pGreen, &dwGreenTRCSize) &&
                GetCPElementData(pProfile, dwBlueTRCIndex, pBlue, &dwBlueTRCSize)    &&
                GetCPElementData(pProfile, dwRedCIndex, pRedC, &dwRedCSize)          &&
                GetCPElementData(pProfile, dwGreenCIndex, pGreenC, &dwGreenCSize)    &&
                GetCPElementData(pProfile, dwBlueCIndex, pBlueC, &dwBlueCSize))
            {
                bMatch = (crc32(DataBuffer, sRGB_TAGSIZE) == sRGB_CRC);
            }
        }
    }

    return (bMatch);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\mscms\sti.h ===
/*++

Copyright (c) 1986-1997  Microsoft Corporation

Module Name:

    sti.h

Abstract:

    This module contains the user mode still image APIs in COM format

Revision History:


--*/

#ifndef _STICOM_
#define _STICOM_

//
// Set packing
//
#include <pshpack8.h>

//
// Only use UNICODE STI interfaces
//
#define STI_UNICODE 1

//
// Include COM definitions
//
#ifndef _NO_COM
#include <objbase.h>
#endif

#include <stireg.h>
#include <stierr.h>

//
// Compiler pragmas
//
#pragma warning(disable:4200)       // warning about zero-sized arrays being non-stadard C extension

#define DLLEXP __declspec( dllexport )

#ifdef __cplusplus
extern "C" {
#endif

#if defined( _WIN32 ) && !defined( _NO_COM)

/*
 * Class IID's
 */

// B323F8E0-2E68-11D0-90EA-00AA0060F86C
DEFINE_GUID(CLSID_Sti, 0xB323F8E0L, 0x2E68, 0x11D0, 0x90, 0xEA, 0x00, 0xAA, 0x00, 0x60, 0xF8, 0x6C);

/*
 * Interface IID's
 */

// {641BD880-2DC8-11D0-90EA-00AA0060F86C}
DEFINE_GUID(IID_IStillImageW, 0x641BD880L, 0x2DC8, 0x11D0, 0x90, 0xEA, 0x00, 0xAA, 0x00, 0x60, 0xF8, 0x6C);

// {A7B1F740-1D7F-11D1-ACA9-00A02438AD48}
DEFINE_GUID(IID_IStillImageA, 0xA7B1F740L, 0x1D7F, 0x11D1, 0xAC, 0xA9, 0x00, 0xA0, 0x24, 0x38, 0xAD, 0x48);


// {6CFA5A80-2DC8-11D0-90EA-00AA0060F86C}
DEFINE_GUID(IID_IStiDevice, 0x6CFA5A80L, 0x2DC8, 0x11D0, 0x90, 0xEA, 0x00, 0xAA, 0x00, 0x60, 0xF8, 0x6C);

#endif

//
// Generic constants and definitions
//
#define STI_VERSION                 0x00000002
#define STI_VERSION_MIN_ALLOWED     0x00000002

#define GET_STIVER_MAJOR(dwVersion)   HIWORD(dwVersion)
#define GET_STIVER_MINOR(dwVersion)   LOWORD(dwVersion)

//
// Maximum length of internal device name
//
#define STI_MAX_INTERNAL_NAME_LENGTH    128

// begin sti_device_information

//
//  Device information definitions and prototypes
// ----------------------------------------------
//

//
//  Following information is used for enumerating still image devices , currently configured
//  in the system. Presence of the device in the enumerated list does not mean availability
// of the device, it only means that device was installed at least once and had not been removed since.
//

//
// Type of device ( scanner, camera) is represented by DWORD value with
// hi word containing generic device type , and lo word containing sub-type
//
typedef enum _STI_DEVICE_MJ_TYPE {
    StiDeviceTypeDefault          = 0,
    StiDeviceTypeScanner          = 1,
    StiDeviceTypeDigitalCamera    = 2
} STI_DEVICE_MJ_TYPE;

typedef DWORD STI_DEVICE_TYPE;

//
// Macros to extract device type/subtype from single type field
//
#define GET_STIDEVICE_TYPE(dwDevType)   HIWORD(dwDevType)
#define GET_STIDEVICE_SUBTYPE(dwDevType)   LOWORD(dwDevType)

//
// Device capabilities bits.
// Various capabilities are grouped into separate bitmasks
//

typedef struct _STI_DEV_CAPS {
    DWORD   dwGeneric;
} STI_DEV_CAPS, *PSTI_DEV_CAPS;


//
// Notifications are supported.
// If this capability set , device can be subscribed to .
//
#define STI_GENCAP_NOTIFICATIONS    0x00000001

//
// Polling required .
// This capability is used when previous is set to TRUE. Presence of it means
// that device is not capable of issuing "truly" asyncronous notifications, but can
// be polled to determine the moment when event happened
#define STI_GENCAP_POLLING_NEEDED   0x00000002


//
// Type of bus connection for those in need to know
//
#define STI_HW_CONFIG_UNKNOWN   0x0001
#define STI_HW_CONFIG_SCSI      0x0002
#define STI_HW_CONFIG_USB       0x0004
#define STI_HW_CONFIG_SERIAL    0x0008
#define STI_HW_CONFIG_PARALLEL  0x0010

//
// Device information structure, this is not configurable. This data is returned from
// device enumeration API and is used for populating UI or selecting which device
// should be used in current session
//
typedef struct _STI_DEVICE_INFORMATIONW {
    DWORD   dwSize;

    // Type of the hardware imaging device
    STI_DEVICE_TYPE   DeviceType;

    // Device identifier for reference when creating device object
    WCHAR   szDeviceInternalName[STI_MAX_INTERNAL_NAME_LENGTH];

    // Set of capabilities flags
    STI_DEV_CAPS   DeviceCapabilities;

    // This includes bus type
    DWORD   dwHardwareConfiguration;

    // Vendor description string
    LPWSTR    pszVendorDescription;

    // Device description , provided by vendor
    LPWSTR    pszDeviceDescription;

    // String , representing port on which device is accessible.
    LPWSTR    pszPortName;

    // Control panel propery provider
    LPWSTR    pszPropProvider;

    // Local specific ("friendly") name of the device, mainly used for showing in the UI
    LPWSTR    pszLocalName;

} STI_DEVICE_INFORMATIONW, *PSTI_DEVICE_INFORMATIONW;

typedef struct _STI_DEVICE_INFORMATIONA {
    DWORD   dwSize;

    // Type of the hardware imaging device
    STI_DEVICE_TYPE   DeviceType;

    // Device identifier for reference when creating device object
    CHAR    szDeviceInternalName[STI_MAX_INTERNAL_NAME_LENGTH];

    // Set of capabilities flags
    STI_DEV_CAPS   DeviceCapabilities;

    // This includes bus type
    DWORD   dwHardwareConfiguration;

    // Vendor description string
    LPCSTR    pszVendorDescription;

    // Device description , provided by vendor
    LPCSTR    pszDeviceDescription;

    // String , representing port on which device is accessible.
    LPCSTR    pszPortName;

    // Control panel propery provider
    LPCSTR    pszPropProvider;

    // Local specific ("friendly") name of the device, mainly used for showing in the UI
    LPCSTR    pszLocalName;

} STI_DEVICE_INFORMATIONA, *PSTI_DEVICE_INFORMATIONA;

#if defined(UNICODE) || defined(STI_UNICODE)
typedef STI_DEVICE_INFORMATIONW STI_DEVICE_INFORMATION;
typedef PSTI_DEVICE_INFORMATIONW PSTI_DEVICE_INFORMATION;
#else
typedef STI_DEVICE_INFORMATIONA STI_DEVICE_INFORMATION;
typedef PSTI_DEVICE_INFORMATIONA PSTI_DEVICE_INFORMATION;
#endif

// end sti_device_information

//
// Device state information.
// ------------------------
//
// Following types  are used to inquire state characteristics of the device after
// it had been opened.
//
// Device configuration structure contains configurable parameters reflecting
// current state of the device
//
//
// Device hardware status.
//

//
// Individual bits for state acquiring  through StatusMask
//

// State of hardware as known to USD
#define STI_DEVSTATUS_ONLINE_STATE      0x0001

// State of pending events ( as known to USD)
#define STI_DEVSTATUS_EVENTS_STATE      0x0002

//
// Online state values
//
#define STI_ONLINESTATE_OPERATIONAL         0x00000001
#define STI_ONLINESTATE_PENDING             0x00000002
#define STI_ONLINESTATE_ERROR               0x00000004
#define STI_ONLINESTATE_PAUSED              0x00000008
#define STI_ONLINESTATE_PAPER_JAM           0x00000010
#define STI_ONLINESTATE_PAPER_PROBLEM       0x00000020
#define STI_ONLINESTATE_OFFLINE             0x00000040
#define STI_ONLINESTATE_IO_ACTIVE           0x00000080
#define STI_ONLINESTATE_BUSY                0x00000100
#define STI_ONLINESTATE_TRANSFERRING        0x00000200
#define STI_ONLINESTATE_INITIALIZING        0x00000400
#define STI_ONLINESTATE_WARMING_UP          0x00000800
#define STI_ONLINESTATE_USER_INTERVENTION   0x00001000
#define STI_ONLINESTATE_POWER_SAVE          0x00002000

//
// Event processing parameters
//
#define STI_EVENTHANDLING_ENABLED           0x00000001
#define STI_EVENTHANDLING_POLLING           0x00000002
#define STI_EVENTHANDLING_PENDING           0x00000004

typedef struct _STI_DEVICE_STATUS {

    DWORD   dwSize;

    // Request field - bits of status to verify
    DWORD   StatusMask;

    //
    // Fields are set when status mask contains STI_DEVSTATUS_ONLINE_STATE bit set
    //
    // Bitmask describing  device state
    DWORD   dwOnlineState;

    // Device status code as defined by vendor
    DWORD   dwHardwareStatusCode;

    //
    // Fields are set when status mask contains STI_DEVSTATUS_EVENTS_STATE bit set
    //

    // State of device notification processing (enabled, pending)
    DWORD   dwEventHandlingState;

    // If device is polled, polling interval in ms
    DWORD   dwPollingInterval;

} STI_DEVICE_STATUS,*PSTI_DEVICE_STATUS;

//
// Structure to describe diagnostic ( test ) request to be processed by USD
//

// Basic test for presence of associated hardware
#define STI_DIAGCODE_HWPRESENCE         0x00000001

//
// Status bits for diagnostic
//

//
// generic diagnostic errors
//

typedef struct _ERROR_INFOW {

    DWORD   dwSize;

    // Generic error , describing results of last operation
    DWORD   dwGenericError;

    // vendor specific error code
    DWORD   dwVendorError;

    // String, describing in more details results of last operation if it failed
    WCHAR   szExtendedErrorText[255];

} STI_ERROR_INFOW,*PSTI_ERROR_INFOW;

typedef struct _ERROR_INFOA {

    DWORD   dwSize;

    DWORD   dwGenericError;
    DWORD   dwVendorError;

    CHAR   szExtendedErrorText[255];

} STI_ERROR_INFOA,*PSTI_ERROR_INFOA;

#if defined(UNICODE) || defined(STI_UNICODE)
typedef STI_ERROR_INFOW STI_ERROR_INFO;
#else
typedef STI_ERROR_INFOA STI_ERROR_INFO;
#endif

typedef STI_ERROR_INFO* PSTI_ERROR_INFO;

typedef struct _STI_DIAG {

    DWORD   dwSize;

    // Diagnostic request fields. Are set on request by caller

    // One of the
    DWORD   dwBasicDiagCode;
    DWORD   dwVendorDiagCode;

    // Response fields
    DWORD   dwStatusMask;

    STI_ERROR_INFO  sErrorInfo;

} STI_DIAG,*LPSTI_DIAG;

//
typedef STI_DIAG    DIAG;
typedef LPSTI_DIAG  LPDIAG;


// end device state information.

//
// Flags passed to WriteToErrorLog call in a first parameter, indicating type of the message
// which needs to be logged
//
#define STI_TRACE_INFORMATION       0x00000001
#define STI_TRACE_WARNING           0x00000002
#define STI_TRACE_ERROR             0x00000004

//
// Event notification mechansims.
// ------------------------------
//
// Those are used to inform last subscribed caller of the changes in device state, initiated by
// device.
//
// The only supported discipline of notification is stack. The last caller to subscribe will be notified
// and will receive notification data. After caller unsubscribes , the previously subscribed caller will
// become active.
//

// Notifications are sent to subscriber via window message. Window handle is passed as
// parameter
#define STI_SUBSCRIBE_FLAG_WINDOW   0x0001

// Device notification is signalling Win32 event ( auto-set event). Event handle
// is passed as a parameter
#define STI_SUBSCRIBE_FLAG_EVENT    0x0002

typedef struct _STISUBSCRIBE {

    DWORD   dwSize;

    DWORD   dwFlags;

    // Not used . Will be used for subscriber to set bit mask filtering different events
    DWORD   dwFilter;

    // When STI_SUBSCRIBE_FLAG_WINDOW bit is set, following fields should be set
    // Handle of the window which will receive notification message
    HWND    hWndNotify;

    // Handle of Win32 auto-reset event , which will be signalled whenever device has
    // notification pending
    HANDLE  hEvent;

    // Code of notification message, sent to window
    UINT    uiNotificationMessage;

} STISUBSCRIBE,*LPSTISUBSCRIBE;

#define MAX_NOTIFICATION_DATA   64


//
// Structure to describe notification information
//
typedef struct _STINOTIFY {

    DWORD   dwSize;                 // Total size of the notification structure

    // GUID of the notification being retrieved
    GUID    guidNotificationCode;

    // Vendor specific notification description
    BYTE    abNotificationData[MAX_NOTIFICATION_DATA];     // USD specific

} STINOTIFY,*LPSTINOTIFY;


// end event_mechanisms

//
// STI device broadcasting
//

//
// When STI Device is being added or removed, PnP broadacst is being sent , but it is not obvious
// for application code to recognize if it is STI device and if so, what is the name of the
// device. STI subsystem will analyze PnP broadcasts and rebroadcast another message via
// BroadcastSystemMessage / WM_DEVICECHANGE / DBT_USERDEFINED .

// String passed as user defined message contains STI prefix, action and device name

#define STI_ADD_DEVICE_BROADCAST_ACTION     "Arrival"
#define STI_REMOVE_DEVICE_BROADCAST_ACTION  "Removal"

#define STI_ADD_DEVICE_BROADCAST_STRING     "STI\\" STI_ADD_DEVICE_BROADCAST_ACTION "\\%s"
#define STI_REMOVE_DEVICE_BROADCAST_STRING  "STI\\" STI_REMOVE_DEVICE_BROADCAST_ACTION "\\%s"


// end STI broadcasting


//
// Device create modes
//

// Device is being opened only for status querying and notifications receiving
#define STI_DEVICE_CREATE_STATUS         0x00000001

// Device is being opened for data transfer ( supersedes status mode)
#define STI_DEVICE_CREATE_DATA           0x00000002

#define STI_DEVICE_CREATE_BOTH           0x00000003

//
// Bit mask for legitimate mode bits, which can be used when calling CreateDevice
//
#define STI_DEVICE_CREATE_MASK           0x0000FFFF

//
// Flags controlling device enumeration
//
#define STIEDFL_ALLDEVICES             0x00000000
#define STIEDFL_ATTACHEDONLY           0x00000001

//
// Control code , sent to the device through raw control interface
//
typedef  DWORD STI_RAW_CONTROL_CODE;

//
// All raw codes below this one are reserved for future use.
//
#define STI_RAW_RESERVED    0x1000

 /*
  * COM Interfaces to STI
  */

#ifdef __cplusplus

/* 'struct' not 'class' per the way DECLARE_INTERFACE_ is defined */
interface IStillImageW;
interface IStillImageA;

interface IStiDevice;

#endif

#ifndef MIDL_PASS

DLLEXP STDMETHODIMP StiCreateInstanceW(HINSTANCE hinst, DWORD dwVer, interface IStillImageW **ppSti, LPUNKNOWN punkOuter);
DLLEXP STDMETHODIMP StiCreateInstanceA(HINSTANCE hinst, DWORD dwVer, interface IStillImageA **ppSti, LPUNKNOWN punkOuter);

#if defined(UNICODE) || defined(STI_UNICODE)
#define IID_IStillImage     IID_IStillImageW
#define IStillImage         IStillImageW
#define StiCreateInstance   StiCreateInstanceW
#else
#define IID_IStillImage     IID_IStillImageA
#define IStillImage         IStillImageA
#define StiCreateInstance   StiCreateInstanceA
#endif

typedef interface IStiDevice              *LPSTILLIMAGEDEVICE;

typedef interface IStillImage             *PSTI;
typedef interface IStiDevice              *PSTIDEVICE;

typedef interface IStillImageA            *PSTIA;
typedef interface IStiDeviceA             *PSTIDEVICEA;

typedef interface IStillImageW            *PSTIW;
typedef interface IStiDeviceW             *PSTIDEVICEW;

//DLLEXP STDMETHODIMP StiCreateInstance(HINSTANCE hinst, DWORD dwVer, PSTI *ppSti, LPUNKNOWN punkOuter);

/*
 * IStillImage interface
 *
 * Top level STI access interface.
 *
 */

#undef INTERFACE
#define INTERFACE IStillImageW
DECLARE_INTERFACE_(IStillImageW, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS) PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    /*** IStillImage methods ***/
    STDMETHOD(Initialize) (THIS_ HINSTANCE hinst,DWORD dwVersion) PURE;

    STDMETHOD(GetDeviceList)(THIS_ DWORD dwType,DWORD dwFlags,DWORD *pdwItemsReturned,LPVOID *ppBuffer) PURE;
    STDMETHOD(GetDeviceInfo)(THIS_ LPWSTR  pwszDeviceName, LPVOID *ppBuffer) PURE;

    STDMETHOD(CreateDevice) (THIS_ LPWSTR  pwszDeviceName, DWORD   dwMode, PSTIDEVICE *pDevice,LPUNKNOWN punkOuter) PURE;

    //
    // Device instance values. Used to associate various data with device.
    //
    STDMETHOD(GetDeviceValue)(THIS_ LPWSTR  pwszDeviceName,LPWSTR    pValueName,LPDWORD  pType,LPBYTE   pData,LPDWORD    cbData);
    STDMETHOD(SetDeviceValue)(THIS_ LPWSTR  pwszDeviceName,LPWSTR   pValueName,DWORD   Type,LPBYTE  pData,DWORD   cbData);

    //
    // For appllication started through push model launch, returns associated information
    //
    STDMETHOD(GetSTILaunchInformation)(THIS_ LPWSTR  pwszDeviceName, DWORD *pdwEventCode,LPWSTR  pwszEventName) PURE;
    STDMETHOD(RegisterLaunchApplication)(THIS_ LPWSTR  pwszAppName,LPWSTR  pwszCommandLine) PURE;
    STDMETHOD(UnregisterLaunchApplication)(THIS_ LPWSTR  pwszAppName) PURE;

    //
    // To control state of notification handling. For polled devices this means state of monitor
    // polling, for true notification devices means enabling/disabling notification flow
    // from monitor to registered applications
    //
    STDMETHOD(EnableHwNotifications)(THIS_ LPCWSTR  pwszDeviceName,BOOL bNewState) PURE;
    STDMETHOD(GetHwNotificationState)(THIS_ LPCWSTR  pwszDeviceName,BOOL *pbCurrentState) PURE;

    //
    // When device is installed but not accessible, application may request bus refresh
    // which in some cases will make device known. This is mainly used for nonPnP buses
    // like SCSI, when device was powered on after PnP enumeration
    //
    //
    STDMETHOD(RefreshDeviceBus)(THIS_ LPCWSTR  pwszDeviceName) PURE;

    //
    // Launch application to emulate event on a device. Used by "control center" style components,
    // which intercept device event , analyze and later force launch based on certain criteria.
    //
    STDMETHOD(LaunchApplicationForDevice)(THIS_ LPWSTR  pwszDeviceName,LPWSTR    pwszAppName,LPSTINOTIFY    pStiNotify);

    //
    // For non-PnP devices with non-known bus type connection, setup extension, associated with the
    // device can set it's parameters
    //
    STDMETHOD(SetupDeviceParameters)(THIS_ PSTI_DEVICE_INFORMATIONW);

    //
    // Write message to STI error log
    //
    STDMETHOD(WriteToErrorLog)(THIS_ DWORD dwMessageType,LPCWSTR pszMessage) PURE;

    #ifdef NOT_IMPLEMENTED

        //
        // TO register application for receiving various STI notifications
        //
        STIMETHOD(RegisterDeviceNotification(THIS_ LPWSTR  pwszAppName,LPSUBSCRIBE lpSubscribe) PURE;
        STIMETHOD(UnregisterDeviceNotification(THIS_ ) PURE;

    #endif //NOT_IMPLEMENTED

};

typedef struct IStillImageW *LPSTILLIMAGEW;

#undef INTERFACE
#define INTERFACE IStillImageA
DECLARE_INTERFACE_(IStillImageA, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS) PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    /*** IStillImage methods ***/
    STDMETHOD(Initialize) (THIS_ HINSTANCE hinst,DWORD dwVersion) PURE;

    STDMETHOD(GetDeviceList)(THIS_ DWORD dwType,DWORD dwFlags,DWORD *pdwItemsReturned,LPVOID *ppBuffer) PURE;
    STDMETHOD(GetDeviceInfo)(THIS_ LPCSTR  pwszDeviceName, LPVOID *ppBuffer) PURE;

    STDMETHOD(CreateDevice) (THIS_ LPCSTR  pwszDeviceName, DWORD   dwMode, PSTIDEVICE *pDevice,LPUNKNOWN punkOuter) PURE;

    //
    // Device instance values. Used to associate various data with device.
    //
    STDMETHOD(GetDeviceValue)(THIS_ LPCSTR  pwszDeviceName,LPCSTR   pValueName,LPDWORD  pType,LPBYTE   pData,LPDWORD    cbData);
    STDMETHOD(SetDeviceValue)(THIS_ LPCSTR  pwszDeviceName,LPCSTR   pValueName,DWORD   Type,LPBYTE  pData,DWORD   cbData);

    //
    // For appllication started through push model launch, returns associated information
    //
    STDMETHOD(GetSTILaunchInformation)(THIS_ LPCSTR  pwszDeviceName, DWORD *pdwEventCode,LPSTR  pwszEventName) PURE;
    STDMETHOD(RegisterLaunchApplication)(THIS_ LPCSTR  pwszAppName,LPCSTR  pwszCommandLine) PURE;
    STDMETHOD(UnregisterLaunchApplication)(THIS_ LPCSTR  pwszAppName) PURE;

    //
    // To control state of notification handling. For polled devices this means state of monitor
    // polling, for true notification devices means enabling/disabling notification flow
    // from monitor to registered applications
    //
    STDMETHOD(EnableHwNotifications)(THIS_ LPCSTR  pwszDeviceName,BOOL bNewState) PURE;
    STDMETHOD(GetHwNotificationState)(THIS_ LPCSTR  pwszDeviceName,BOOL *pbCurrentState) PURE;

    //
    // When device is installed but not accessible, application may request bus refresh
    // which in some cases will make device known. This is mainly used for nonPnP buses
    // like SCSI, when device was powered on after PnP enumeration
    //
    //
    STDMETHOD(RefreshDeviceBus)(THIS_ LPCSTR  pwszDeviceName) PURE;

    //
    // Launch application to emulate event on a device. Used by "control center" style components,
    // which intercept device event , analyze and later force launch based on certain criteria.
    //
    STDMETHOD(LaunchApplicationForDevice)(THIS_ LPCSTR    pwszDeviceName,LPCSTR    pwszAppName,LPSTINOTIFY    pStiNotify);


    //
    // For non-PnP devices with non-known bus type connection, setup extension, associated with the
    // device can set it's parameters
    //
    STDMETHOD(SetupDeviceParameters)(THIS_ PSTI_DEVICE_INFORMATIONA);

    //
    // Write message to STI error log
    //
    STDMETHOD(WriteToErrorLog)(THIS_ DWORD dwMessageType,LPCSTR pszMessage) PURE;

    #ifdef NOT_IMPLEMENTED

        //
        // TO register application for receiving various STI notifications
        //
        STIMETHOD(RegisterDeviceNotification(THIS_ LPWSTR  pwszAppName,LPSUBSCRIBE lpSubscribe) PURE;
        STIMETHOD(UnregisterDeviceNotification(THIS_ ) PURE;

    #endif //NOT_IMPLEMENTED

};

typedef struct IStillImageA *LPSTILLIMAGEA;

#if defined(UNICODE) || defined(STI_UNICODE)
#define IStillImageVtbl     IStillImageWVtbl
#else
#define IStillImageVtbl     IStillImageAVtbl
#endif

typedef struct IStillImage  *LPSTILLIMAGE;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IStillImage_QueryInterface(p,a,b)       (p)->lpVtbl->QueryInterface(p,a,b)
#define IStillImage_AddRef(p)                   (p)->lpVtbl->AddRef(p)
#define IStillImage_Release(p)                  (p)->lpVtbl->Release(p)
#define IStillImage_Initialize(p,a,b)           (p)->lpVtbl->Initialize(p,a,b)

#define IStillImage_GetDeviceList(p,a,b,c,d)    (p)->lpVtbl->GetDeviceList(p,a,b,c,d)
#define IStillImage_GetDeviceInfo(p,a,b)        (p)->lpVtbl->GetDeviceInfo(p,a,b)
#define IStillImage_CreateDevice(p,a,b,c,d)     (p)->lpVtbl->CreateDevice(p,a,b,c,d)
#define IStillImage_GetDeviceValue(p,a,b,c,d,e)           (p)->lpVtbl->GetDeviceValue(p,a,b,c,d,e)
#define IStillImage_SetDeviceValue(p,a,b,c,d,e)           (p)->lpVtbl->SetDeviceValue(p,a,b,c,d,e)
#define IStillImage_GetSTILaunchInformation(p,a,b,c)      (p)->lpVtbl->GetSTILaunchInformation(p,a,b,c)
#define IStillImage_RegisterLaunchApplication(p,a,b)      (p)->lpVtbl->RegisterLaunchApplication(p,a,b)
#define IStillImage_UnregisterLaunchApplication(p,a)      (p)->lpVtbl->UnregisterLaunchApplication(p,a)
#define IStillImage_EnableHwNotifications(p,a,b)          (p)->lpVtbl->EnableHwNotifications(p,a,b)
#define IStillImage_GetHwNotificationState(p,a,b)         (p)->lpVtbl->GetHwNotificationState(p,a,b)
#define IStillImage_RefreshDeviceBus(p,a)                 (p)->lpVtbl->RefreshDeviceBus(p,a)

#endif

/*
 * IStillImage_Device interface
 *
 * This is generic per device interface. Specialized interfaces are also
 * available
 */
#undef INTERFACE
#define INTERFACE IStiDevice
DECLARE_INTERFACE_(IStiDevice, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS) PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    /*** IStiDevice methods ***/
    STDMETHOD(Initialize) (THIS_ HINSTANCE hinst,LPCWSTR pwszDeviceName,DWORD dwVersion,DWORD  dwMode) PURE;

    STDMETHOD(GetCapabilities) (THIS_ PSTI_DEV_CAPS pDevCaps) PURE;

    STDMETHOD(GetStatus) (THIS_ PSTI_DEVICE_STATUS pDevStatus) PURE;

    STDMETHOD(DeviceReset)(THIS ) PURE;
    STDMETHOD(Diagnostic)(THIS_ LPSTI_DIAG pBuffer) PURE;

    STDMETHOD(Escape)(THIS_ STI_RAW_CONTROL_CODE    EscapeFunction,LPVOID  lpInData,DWORD   cbInDataSize,LPVOID pOutData,DWORD dwOutDataSize,LPDWORD pdwActualData) PURE ;

    STDMETHOD(GetLastError) (THIS_ LPDWORD pdwLastDeviceError) PURE;

    STDMETHOD(LockDevice) (THIS_ DWORD dwTimeOut) PURE;
    STDMETHOD(UnLockDevice) (THIS ) PURE;

    STDMETHOD(RawReadData)(THIS_ LPVOID lpBuffer,LPDWORD lpdwNumberOfBytes,LPOVERLAPPED lpOverlapped) PURE;
    STDMETHOD(RawWriteData)(THIS_ LPVOID lpBuffer,DWORD nNumberOfBytes,LPOVERLAPPED lpOverlapped) PURE;

    STDMETHOD(RawReadCommand)(THIS_ LPVOID lpBuffer,LPDWORD lpdwNumberOfBytes,LPOVERLAPPED lpOverlapped) PURE;
    STDMETHOD(RawWriteCommand)(THIS_ LPVOID lpBuffer,DWORD nNumberOfBytes,LPOVERLAPPED lpOverlapped) PURE;

    //
    // Subscription is used to enable "control center" style applications , where flow of
    // notifications should be redirected from monitor itself to another "launcher"
    //
    STDMETHOD(Subscribe)(THIS_ LPSTISUBSCRIBE lpSubsribe) PURE;
    STDMETHOD(GetLastNotificationData)(THIS_ LPSTINOTIFY   lpNotify) PURE;
    STDMETHOD(UnSubscribe)(THIS ) PURE;

    STDMETHOD(GetLastErrorInfo) (THIS_ STI_ERROR_INFO *pLastErrorInfo) PURE;
};

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IStiDevice_QueryInterface(p,a,b)        (p)->lpVtbl->QueryInterface(p,a,b)
#define IStiDevice_AddRef(p)                    (p)->lpVtbl->AddRef(p)
#define IStiDevice_Release(p)                   (p)->lpVtbl->Release(p)
#define IStiDevice_Initialize(p,a,b,c,d)        (p)->lpVtbl->Initialize(p,a,b,c,d)

#define IStiDevice_GetCapabilities(p,a)         (p)->lpVtbl->GetCapabilities(p,a)
#define IStiDevice_GetStatus(p,a)               (p)->lpVtbl->GetStatus(p,a)
#define IStiDevice_DeviceReset(p)               (p)->lpVtbl->DeviceReset(p)
#define IStiDevice_LockDevice(p,a)              (p)->lpVtbl->LockDevice(p,a)
#define IStiDevice_UnLockDevice(p)              (p)->lpVtbl->LockDevice(p)

#define IStiDevice_Diagnostic(p,a)              (p)->lpVtbl->Diagnostic(p,a)
#define IStiDevice_Escape(p,a,b,c,d,e,f)        (p)->lpVtbl->Escape(p,a,b,c,d,e,f)
#define IStiDevice_GetLastError(p,a)            (p)->lpVtbl->GetLastError(p,a)
#define IStiDevice_RawReadData(p,a,b,c)         (p)->lpVtbl->RawReadData(p,a,b,c)
#define IStiDevice_RawWriteData(p,a,b,c)        (p)->lpVtbl->RawWriteData(p,a,b,c)
#define IStiDevice_RawReadCommand(p,a,b,c)      (p)->lpVtbl->RawReadCommand(p,a,b,c)
#define IStiDevice_RawWriteCommand(p,a,b,c)     (p)->lpVtbl->RawWriteCommand(p,a,b,c)

#define IStiDevice_Subscribe(p,a)               (p)->lpVtbl->Subscribe(p,a)
#define IStiDevice_GetNotificationData(p,a)     (p)->lpVtbl->GetNotificationData(p,a)
#define IStiDevice_UnSubscribe(p)               (p)->lpVtbl->UnSubscribe(p)

#define IStiDevice_GetLastErrorInfo(p,a)        (p)->lpVtbl->GetLastErrorInfo(p,a)

#endif

#endif  // MIDL_PASS

#ifdef __cplusplus
};
#endif

//
// Reset packing
//
#include <poppack.h>

#endif // _STICOM_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\mscms\profman.c ===
/****************************Module*Header******************************\
* Module Name: PROFMAN.C
*
* Module Descripton: Profile management functions.
*
* Warnings:
*
* Issues:
*
* Public Routines:
*
* Created: 5 Nov 1996
*
* Author:   Srinivasan Chandrasekar    [srinivac]
*
* Copyright (c) 1996, 1997  Microsoft Corporation
\***********************************************************************/

#include "mscms.h"
#include "objbase.h"
#include "initguid.h"
#include "devguid.h"
#include "sti.h"

#define TAG_DEVICESETTINGS      'devs'
#define TAG_MS01                'MS01'
#define TAG_MS02                'MS02'
#define TAG_MS03                'MS03'

#define ID_MSFT_REVERSED        'tfsm'
#define ID_MEDIATYPE_REVERSED   'aidm'
#define ID_DITHER_REVERSED      'ntfh'
#define ID_RESLN_REVERSED       'nlsr'

#define DEVICE_PROFILE_DATA      1
#define DEVICE_PROFILE_ENUMMODE  2

//
// Local types
//

typedef enum {
    NOMATCH     = 0,
    MATCH       = 1,
    EXACT_MATCH = 2,
} MATCHTYPE;

typedef struct tagREGDATA {
    DWORD dwRefCount;
    DWORD dwManuID;
    DWORD dwModelID;
} REGDATA, *PREGDATA;

typedef struct tagSCANNERDATA {
    PWSTR     pDeviceName;
    HINSTANCE hModule;
    PSTI      pSti;
} SCANNERDATA, *PSCANNERDATA;

typedef BOOL  (WINAPI *PFNOPENDEVICE)(PTSTR, LPHANDLE, PTSTR);
typedef BOOL  (WINAPI *PFNCLOSEDEVICE)(HANDLE);
typedef DWORD (WINAPI *PFNGETDEVICEDATA)(HANDLE, PTSTR, PTSTR, PDWORD, PBYTE, DWORD, PDWORD);
typedef DWORD (WINAPI *PFNSETDEVICEDATA)(HANDLE, PTSTR, PTSTR, DWORD, PBYTE, DWORD);
typedef HRESULT (__stdcall *PFNSTICREATEINSTANCE)(HINSTANCE, DWORD, PSTI*, LPDWORD);

//
// Local functions
//

BOOL  InternalGetColorDirectory(LPCTSTR, PTSTR, DWORD*);
BOOL  InternalInstallColorProfile(LPCTSTR, LPCTSTR);
BOOL  InternalUninstallColorProfile(LPCTSTR, LPCTSTR, BOOL);
BOOL  InternalAssociateColorProfileWithDevice(LPCTSTR, LPCTSTR, LPCTSTR);
BOOL  InternalDisassociateColorProfileFromDevice(LPCTSTR, LPCTSTR, LPCTSTR);
BOOL  InternalEnumColorProfiles(LPCTSTR, PENUMTYPE, PBYTE, PDWORD, PDWORD);
BOOL  InternalSetSCSProfile(LPCTSTR, DWORD, LPCTSTR);
BOOL  InternalGetSCSProfile(LPCTSTR, DWORD, PTSTR, PDWORD);
VOID  ConvertDwordToString(DWORD, PTSTR);
PTSTR ConvertClassIdToClassString(DWORD);
BOOL  GetProfileClassString(LPCTSTR, PTSTR, PPROFILEHEADER);
BOOL  GetDeviceData(LPCTSTR, DWORD, DWORD, PVOID*, PDWORD, BOOL);
BOOL  SetDeviceData(LPCTSTR, DWORD, DWORD, PVOID, DWORD);
BOOL  IGetDeviceData(LPCTSTR, DWORD, DWORD, PVOID*, PDWORD, BOOL);
BOOL  ISetDeviceData(LPCTSTR, DWORD, DWORD, PVOID, DWORD);
BOOL  IsStringInMultiSz(PTSTR, PTSTR);
DWORD RemoveStringFromMultiSz(PTSTR, PTSTR, DWORD);
VOID  InsertInBuffer(PBYTE, PBYTE, PTSTR);
MATCHTYPE DoesProfileMatchEnumRecord(PTSTR, PENUMTYPE);
MATCHTYPE CheckResMedHftnMatch(HPROFILE, PENUMTYPE);
BOOL  DwordMatches(PSETTINGS, DWORD);
BOOL  QwordMatches(PSETTINGS, PDWORD);
BOOL  WINAPI OpenPrtr(PTSTR, LPHANDLE, PTSTR);
BOOL  WINAPI ClosePrtr(HANDLE);
DWORD WINAPI GetPrtrData(HANDLE, PTSTR, PTSTR, PDWORD, PBYTE, DWORD, PDWORD);
DWORD WINAPI SetPrtrData(HANDLE, PTSTR, PTSTR, DWORD, PBYTE, DWORD);
BOOL  WINAPI OpenMonitor(PTSTR, LPHANDLE, PTSTR);
BOOL  WINAPI CloseMonitor(HANDLE);
DWORD WINAPI GetMonitorData(HANDLE, PTSTR, PTSTR, PDWORD, PBYTE, DWORD, PDWORD);
DWORD WINAPI SetMonitorData(HANDLE, PTSTR, PTSTR, DWORD, PBYTE, DWORD);
BOOL  WINAPI OpenScanner(PTSTR, LPHANDLE, PTSTR);
BOOL  WINAPI CloseScanner(HANDLE);
DWORD WINAPI GetScannerData(HANDLE, PTSTR, PTSTR, PDWORD, PBYTE, DWORD, PDWORD);
DWORD WINAPI SetScannerData(HANDLE, PTSTR, PTSTR, DWORD, PBYTE, DWORD);
#ifdef _WIN95_
BOOL  LoadSetupAPIDll(VOID);
#else
VOID  ChangeICMSetting(LPCTSTR, LPCTSTR, DWORD);
#endif // _WIN95_

//
// SetupAPI function pointers
//
typedef WINSETUPAPI HKEY
(WINAPI *FP_SetupDiOpenDevRegKey)(
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData,
    IN DWORD            Scope,
    IN DWORD            HwProfile,
    IN DWORD            KeyType,
    IN REGSAM           samDesired
);

typedef WINSETUPAPI BOOL
(WINAPI *FP_SetupDiDestroyDeviceInfoList)(
    IN HDEVINFO DeviceInfoSet
);

typedef WINSETUPAPI BOOL
(WINAPI *FP_SetupDiEnumDeviceInfo)(
    IN  HDEVINFO         DeviceInfoSet,
    IN  DWORD            MemberIndex,
    OUT PSP_DEVINFO_DATA DeviceInfoData
);

#if !defined(_WIN95_)
typedef WINSETUPAPI BOOL
(WINAPI *FP_SetupDiGetDeviceInstanceId)(
    IN  HDEVINFO         DeviceInfoSet,
    IN  PSP_DEVINFO_DATA DeviceInfoData,
    OUT PWSTR            DeviceInstanceId,
    IN  DWORD            DeviceInstanceIdSize,
    OUT PDWORD           RequiredSize          OPTIONAL
);

typedef WINSETUPAPI HDEVINFO
(WINAPI *FP_SetupDiGetClassDevs)(
    IN LPGUID ClassGuid,  OPTIONAL
    IN PCWSTR Enumerator, OPTIONAL
    IN HWND   hwndParent, OPTIONAL
    IN DWORD  Flags
);
#else
typedef WINSETUPAPI BOOL
(WINAPI *FP_SetupDiGetDeviceInstanceId)(
    IN  HDEVINFO         DeviceInfoSet,
    IN  PSP_DEVINFO_DATA DeviceInfoData,
    OUT PSTR             DeviceInstanceId,
    IN  DWORD            DeviceInstanceIdSize,
    OUT PDWORD           RequiredSize          OPTIONAL
);

typedef WINSETUPAPI HDEVINFO
(WINAPI *FP_SetupDiGetClassDevs)(
    IN LPGUID ClassGuid,  OPTIONAL
    IN PCSTR  Enumerator, OPTIONAL
    IN HWND   hwndParent, OPTIONAL
    IN DWORD  Flags
);
#endif

HMODULE ghModSetupAPIDll = NULL;

FP_SetupDiOpenDevRegKey         fpSetupDiOpenDevRegKey         = NULL;
FP_SetupDiDestroyDeviceInfoList fpSetupDiDestroyDeviceInfoList = NULL;
FP_SetupDiEnumDeviceInfo        fpSetupDiEnumDeviceInfo        = NULL;
FP_SetupDiGetDeviceInstanceId   fpSetupDiGetDeviceInstanceId   = NULL;
FP_SetupDiGetClassDevs          fpSetupDiGetClassDevs          = NULL;

//
// Predefined profiles in order - INF file has 1-based index into this list
//

TCHAR  *gszDispProfiles[] = {
    __TEXT("mnB22G15.icm"),                         // 1
    __TEXT("mnB22G18.icm"),                         // 2
    __TEXT("mnB22G21.icm"),                         // 3
    __TEXT("mnEBUG15.icm"),                         // 4
    __TEXT("mnEBUG18.icm"),                         // 5
    __TEXT("mnEBUG21.icm"),                         // 6
    __TEXT("mnP22G15.icm"),                         // 7
    __TEXT("mnP22G18.icm"),                         // 8
    __TEXT("mnP22G21.icm"),                         // 9
    __TEXT("Diamond Compatible 9300K G2.2.icm"),    // 10
    __TEXT("Hitachi Compatible 9300K G2.2.icm"),    // 11
    __TEXT("NEC Compatible 9300K G2.2.icm"),        // 12
    __TEXT("Trinitron Compatible 9300K G2.2.icm"),  // 13
    };

TCHAR  *gpszClasses[] = {  // different profile classes
    __TEXT("mntr"),                                 // 0
    __TEXT("prtr"),                                 // 1
    __TEXT("scnr"),                                 // 2
    __TEXT("link"),                                 // 3
    __TEXT("abst"),                                 // 4
    __TEXT("spac"),                                 // 5
    __TEXT("nmcl")                                  // 6
    };

#define INDEX_CLASS_MONITOR     0
#define INDEX_CLASS_PRINTER     1
#define INDEX_CLASS_SCANNER     2
#define INDEX_CLASS_LINK        3
#define INDEX_CLASS_ABSTRACT    4
#define INDEX_CLASS_COLORSPACE  5
#define INDEX_CLASS_NAMED       6

/******************************************************************************
 *
 *                            GetColorDirectory
 *
 *  Function:
 *       These are the ANSI & Unicode wrappers for InternalGetColorDirectory.
 *       Please see InternalGetColorDirectory for more details on this
 *       function.
 *
 *  Arguments:
 *       pMachineName    - name identifying machine on which the path
 *                         to the color directory is requested
 *       pBuffer         - pointer to buffer to receive pathname
 *       pdwSize         - pointer to size of buffer. On return it has size of
 *                         buffer needed if failure, and used on success
 *
 *  Returns:
 *       TRUE if successful, NULL otherwise
 *
 ******************************************************************************/

#ifdef UNICODE          // Windows NT versions

BOOL WINAPI
GetColorDirectoryA(
    PCSTR   pMachineName,
    PSTR    pBuffer,
    PDWORD  pdwSize
    )
{
    PWSTR pwszMachineName = NULL;   // Unicode machine name
    PWSTR pwBuffer = NULL;          // Unicode color directory path
    DWORD dwSize;                   // size of Unicode buffer
    DWORD dwErr = 0;                // error code
    BOOL  rc = TRUE;                // return code

    TRACEAPI((__TEXT("GetColorDirectoryA\n")));

    //
    // Validate parameters before we touch them
    //

    if (!pdwSize ||
        IsBadWritePtr(pdwSize, sizeof(DWORD)) ||
        (pBuffer && IsBadWritePtr(pBuffer, *pdwSize)))
    {
        WARNING((__TEXT("Invalid parameter to GetColorDirectory\n")));
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // Convert machine name to Unicode
    //

    if (pMachineName)
    {
        rc = ConvertToUnicode(pMachineName, &pwszMachineName, TRUE);
    }
    else
        pwszMachineName = NULL;

    dwSize = *pdwSize * sizeof(WCHAR);

    //
    // Create a buffer to get Unicode directory from system
    //

    if (pBuffer && dwSize)
    {
        pwBuffer = (PWSTR)MemAlloc(dwSize);
        if (! pwBuffer)
        {
            WARNING((__TEXT("Error allocating memory for Unicode string\n")));
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            rc = FALSE;
            goto EndGetColorDirectoryA;
        }
    }

    rc = rc && InternalGetColorDirectory(pwszMachineName, pwBuffer, &dwSize);

    *pdwSize = dwSize / sizeof(WCHAR);

    //
    // Convert Unicode path to Ansi
    //

    if (pwBuffer)
    {
        rc = rc && ConvertToAnsi(pwBuffer, &pBuffer, FALSE);
    }

EndGetColorDirectoryA:
    if (pwszMachineName)
    {
        MemFree(pwszMachineName);
    }

    if (pwBuffer)
    {
        MemFree(pwBuffer);
    }

    return rc;
}

BOOL WINAPI
GetColorDirectoryW(
    PCWSTR   pMachineName,
    PWSTR    pBuffer,
    PDWORD   pdwSize
    )
{
    TRACEAPI((__TEXT("GetColorDirectoryW\n")));

    //
    // Internal function is ANSI in Windows 95, call it directly.
    //

    return InternalGetColorDirectory(pMachineName, pBuffer, pdwSize);
}

#else                           // Windows 95 versions

BOOL WINAPI
GetColorDirectoryA(
    PCSTR   pMachineName,
    PSTR    pBuffer,
    PDWORD  pdwSize
    )
{
    TRACEAPI((__TEXT("GetColorDirectoryA\n")));

    //
    // Internal function is ANSI in Windows 95, call it directly.
    //

    return InternalGetColorDirectory(pMachineName, pBuffer, pdwSize);
}

BOOL WINAPI
GetColorDirectoryW(
    PCWSTR   pMachineName,
    PWSTR    pBuffer,
    PDWORD   pdwSize
    )
{
    PSTR pszMachineName = NULL;     // Ansi machine name
    PSTR pszBuffer = NULL;          // Ansi color directory path
    DWORD dwSize;                   // size of Ansi buffer
    BOOL  rc = TRUE;                // return code

    TRACEAPI((__TEXT("GetColorDirectoryW\n")));

    //
    // Validate parameters before we touch them
    //

    if (!pdwSize ||
        IsBadWritePtr(pdwSize, sizeof(DWORD)) ||
        (pBuffer && IsBadWritePtr(pBuffer, *pdwSize)))
    {
        WARNING((__TEXT("Invalid parameter to GetColorDirectory\n")));
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // Convert machine name to Ansi
    //

    if (pMachineName)
    {
        rc = ConvertToAnsi(pMachineName, &pszMachineName, TRUE);
    }
    else
        pszMachineName = NULL;

    //
    // Create a buffer to get Ansi directory from system
    //

    dwSize = *pdwSize / sizeof(WCHAR);

    if (pBuffer && dwSize)
    {
        pszBuffer = (PSTR)MemAlloc(dwSize);
        if (! pszBuffer)
        {
            WARNING((__TEXT("Error allocating memory for Ansi string\n")));
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            rc = FALSE;
            goto EndGetColorDirectoryW;
        }
    }

    rc = rc && InternalGetColorDirectory(pszMachineName, pszBuffer, &dwSize);

    *pdwSize = dwSize * sizeof(WCHAR);

    //
    // Convert Ansi path to Unicode
    //

    if (pszBuffer)
    {
        rc = rc && ConvertToUnicode(pszBuffer, &pBuffer, FALSE);
    }

EndGetColorDirectoryW:
    if (pszMachineName)
    {
        MemFree(pszMachineName);
    }

    if (pszBuffer)
    {
        MemFree(pszBuffer);
    }

    return rc;
}

#endif                          // ! UNICODE


/******************************************************************************
 *
 *                            InstallColorProfile
 *
 *  Function:
 *       These are the ANSI & Unicode wrappers for InternalInstallColorProfile.
 *       Please see InternalInstallColorProfile for more details on this
 *       function.
 *
 *  Arguments:
 *       pMachineName    - name identifying machine on which the profile
 *                         should be installed. NULL implies local
 *       pProfileName    - pointer to filename of profile to install
 *
 *  Returns:
 *       TRUE if successful, NULL otherwise
 *
 ******************************************************************************/

#ifdef UNICODE          // Windows NT versions

BOOL  WINAPI
InstallColorProfileA(
    PCSTR   pMachineName,
    PCSTR   pProfileName
    )

{
    PWSTR pwszMachineName = NULL;   // Unicode machine name
    PWSTR pwszProfileName = NULL;   // Unicode profile name
    BOOL  rc = TRUE;                // return code

    TRACEAPI((__TEXT("InstallColorProfileA\n")));

    //
    // Validate parameters before we touch them
    //

    if (!pProfileName)
    {
        WARNING((__TEXT("Invalid parameter to InstallColorProfile\n")));
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // Convert machine name to Unicode
    //

    if (pMachineName)
    {
        rc = ConvertToUnicode(pMachineName, &pwszMachineName, TRUE);
    }
    else
        pwszMachineName = NULL;

    //
    // Convert profile name to Unicode
    //

    rc = rc && ConvertToUnicode(pProfileName, &pwszProfileName, TRUE);

    //
    // Call the internal Unicode function
    //

    rc = rc && InternalInstallColorProfile(pwszMachineName, pwszProfileName);

    //
    // Free memory before leaving
    //

    if (pwszProfileName)
    {
        MemFree(pwszProfileName);
    }

    if (pwszMachineName)
    {
        MemFree(pwszMachineName);
    }

    return rc;
}


BOOL  WINAPI
InstallColorProfileW(
    PCWSTR   pMachineName,
    PCWSTR   pProfileName
    )
{
    TRACEAPI((__TEXT("InstallColorProfileW\n")));

    //
    // Internal function is Unicode in Windows NT, call it directly.
    //

    return InternalInstallColorProfile(pMachineName, pProfileName);
}


#else                           // Windows 95 versions

BOOL  WINAPI
InstallColorProfileA(
    PCSTR   pMachineName,
    PCSTR   pProfileName
    )
{
    TRACEAPI((__TEXT("InstallColorProfileA\n")));

    //
    // Internal function is ANSI in Windows 95, call it directly.
    //

    return InternalInstallColorProfile(pMachineName, pProfileName);
}


BOOL  WINAPI
InstallColorProfileW(
    PCWSTR   pMachineName,
    PCWSTR   pProfileName
    )
{
    PSTR  pszMachineName = NULL;    // Ansi machine name
    PSTR  pszProfileName = NULL;    // Ansi profile name
    BOOL  rc = TRUE;                // return code

    TRACEAPI((__TEXT("InstallColorProfileW\n")));

    //
    // Validate parameters before we touch them
    //

    if (!pProfileName)
    {
        WARNING((__TEXT("Invalid parameter to InstallColorProfile\n")));
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // Convert machine name to Ansi
    //

    if (pMachineName)
    {
        rc = ConvertToAnsi(pMachineName, &pszMachineName, TRUE);
    }
    else
        pszMachineName = NULL;

    //
    // Convert profile name to Ansi
    //

    rc = rc && ConvertToAnsi(pProfileName, &pszProfileName, TRUE);

    //
    // Call the internal Ansi function
    //

    rc = rc && InternalInstallColorProfile(pszMachineName, pszProfileName);

    //
    // Free memory before leaving
    //

    if (pszProfileName)
    {
        MemFree(pszProfileName);
    }

    if (pszMachineName)
    {
        MemFree(pszMachineName);
    }

    return rc;
}


#endif                          // ! UNICODE

/******************************************************************************
 *
 *                            UninstallColorProfile
 *
 *  Function:
 *       These are the ANSI & Unicode wrappers for InternalUninstallColorProfile.
 *       Please see InternalUninstallColorProfile for more details on this
 *       function.
 *
 *  Arguments:
 *       pMachineName    - name identifying machine on which the profile
 *                         should be uninstalled. NULL implies local
 *       pProfileName    - pointer to filename of profile to uninstall
 *       bDelete         - TRUE if profile should be deleted in disk
 *
 *  Returns:
 *       TRUE if successful, NULL otherwise
 *
 ******************************************************************************/

#ifdef UNICODE          // Windows NT versions

BOOL  WINAPI
UninstallColorProfileA(
    PCSTR   pMachineName,
    PCSTR   pProfileName,
    BOOL    bDelete
    )
{
    PWSTR pwszMachineName = NULL;   // Unicode machine name
    PWSTR pwszProfileName = NULL;   // Unicode profile name
    BOOL  rc = TRUE;                // return code

    TRACEAPI((__TEXT("UninstallColorProfileA\n")));

    //
    // Validate parameters before we touch them
    //

    if (!pProfileName)
    {
        WARNING((__TEXT("Invalid parameter to UninstallColorProfile\n")));
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // Convert machine name to Unicode
    //

    if (pMachineName)
    {
        rc = ConvertToUnicode(pMachineName, &pwszMachineName, TRUE);
    }
    else
        pwszMachineName = NULL;

    //
    // Convert profile name to Unicode
    //

    rc = rc && ConvertToUnicode(pProfileName, &pwszProfileName, TRUE);

    //
    // Call the internal Unicode function
    //

    rc = rc && InternalUninstallColorProfile(pwszMachineName, pwszProfileName,
                    bDelete);

    //
    // Free memory before leaving
    //

    if (pwszProfileName)
    {
        MemFree(pwszProfileName);
    }

    if (pwszMachineName)
    {
        MemFree(pwszMachineName);
    }

    return rc;
}

BOOL  WINAPI
UninstallColorProfileW(
    PCWSTR   pMachineName,
    PCWSTR   pProfileName,
    BOOL     bDelete
    )
{
    TRACEAPI((__TEXT("UninstallColorProfileW\n")));

    //
    // Internal function is Unicode in Windows NT, call it directly.
    //

    return InternalUninstallColorProfile(pMachineName, pProfileName, bDelete);
}


#else                           // Windows 95 versions

BOOL  WINAPI
UninstallColorProfileA(
    PCSTR   pMachineName,
    PCSTR   pProfileName,
    BOOL    bDelete
    )
{
    TRACEAPI((__TEXT("UninstallColorProfileA\n")));

    //
    // Internal function is ANSI in Windows 95, call it directly.
    //

    return InternalUninstallColorProfile(pMachineName, pProfileName, bDelete);
}


BOOL  WINAPI
UninstallColorProfileW(
    PCWSTR   pMachineName,
    PCWSTR   pProfileName,
    BOOL     bDelete
    )
{
    PSTR  pszMachineName = NULL;    // Ansi machine name
    PSTR  pszProfileName = NULL;    // Ansi profile name
    BOOL  rc = TRUE;                // return code

    TRACEAPI((__TEXT("UninstallColorProfileW\n")));

    //
    // Validate parameters before we touch them
    //

    if (!pProfileName)
    {
        WARNING((__TEXT("Invalid parameter to UninstallColorProfile\n")));
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // Convert machine name to Ansi
    //

    if (pMachineName)
    {
        rc = ConvertToAnsi(pMachineName, &pszMachineName, TRUE);
    }
    else
        pszMachineName = NULL;

    //
    // Convert profile name to Ansi
    //

    rc = rc && ConvertToAnsi(pProfileName, &pszProfileName, TRUE);

    //
    // Call the internal Ansi function
    //

    rc = rc && InternalUninstallColorProfile(pszMachineName, pszProfileName,
                    bDelete);

    //
    // Free memory before leaving
    //

    if (pszProfileName)
    {
        MemFree(pszProfileName);
    }

    if (pszMachineName)
    {
        MemFree(pszMachineName);
    }

    return rc;
}


#endif                          // ! UNICODE


/******************************************************************************
 *
 *                        AssociateColorProfileWithDevice
 *
 *  Function:
 *       These are the ANSI & Unicode wrappers for
 *       InternalAssociateColorProfileWithDevice. Please see
 *       InternalAssociateColorProfileWithDevice for more details
 *       on this function.
 *
 *  Arguments:
 *       pMachineName    - name identifying machine. NULL implies local
 *       pProfileName    - pointer to profile to associate
 *       pDeviceName     - pointer to device name
 *
 *  Returns:
 *       TRUE if successful, NULL otherwise
 *
 ******************************************************************************/

#ifdef UNICODE          // Windows NT versions

BOOL WINAPI
AssociateColorProfileWithDeviceA(
    PCSTR pMachineName,
    PCSTR pProfileName,
    PCSTR pDeviceName
    )
{
    PWSTR pwszMachineName = NULL;   // Unicode machine name
    PWSTR pwszProfileName = NULL;   // Unicode profile name
    PWSTR pwszDeviceName = NULL;    // Unicode device name
    BOOL  rc = TRUE;                // return code

    TRACEAPI((__TEXT("AssociateColorProfileWithDeviceA\n")));

    //
    // Validate parameters before we touch  them
    //

    if (! pProfileName ||
        ! pDeviceName)
    {
        WARNING((__TEXT("Invalid parameter to AssociateColorProfileWithDevice\n")));
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // Convert machine name to Unicode
    //

    if (pMachineName)
    {
        rc = ConvertToUnicode(pMachineName, &pwszMachineName, TRUE);
    }
    else
        pwszMachineName = NULL;

    //
    // Convert profile name to Unicode
    //

    rc = rc && ConvertToUnicode(pProfileName, &pwszProfileName, TRUE);

    //
    // Convert device name to Unicode
    //

    rc = rc && ConvertToUnicode(pDeviceName, &pwszDeviceName, TRUE);

    //
    // Call the internal Unicode function
    //

    rc = rc && InternalAssociateColorProfileWithDevice(pwszMachineName,
                pwszProfileName, pwszDeviceName);

    //
    // Free memory before leaving
    //

    if (pwszProfileName)
    {
        MemFree(pwszProfileName);
    }

    if (pwszMachineName)
    {
        MemFree(pwszMachineName);
    }

    if (pwszDeviceName)
    {
        MemFree(pwszDeviceName);
    }

    return rc;
}


BOOL WINAPI
AssociateColorProfileWithDeviceW(
    PCWSTR pMachineName,
    PCWSTR pProfileName,
    PCWSTR pDeviceName
    )
{
    TRACEAPI((__TEXT("AssociateColorProfileWithDeviceW\n")));

    //
    // Internal function is Unicode in Windows NT, call it directly.
    //

    return InternalAssociateColorProfileWithDevice(pMachineName,
                pProfileName, pDeviceName);
}


#else                           // Windows 95 versions

BOOL WINAPI
AssociateColorProfileWithDeviceA(
    PCSTR pMachineName,
    PCSTR pProfileName,
    PCSTR pDeviceName
    )
{
    TRACEAPI((__TEXT("AssociateColorProfileWithDeviceA\n")));

    //
    // Internal function is ANSI in Windows 95, call it directly.
    //

    return InternalAssociateColorProfileWithDevice(pMachineName,
                pProfileName, pDeviceName);
}


BOOL WINAPI
AssociateColorProfileWithDeviceW(
    PCWSTR pMachineName,
    PCWSTR pProfileName,
    PCWSTR pDeviceName
    )
{
    PSTR  pszMachineName = NULL;    // Ansi machine name
    PSTR  pszProfileName = NULL;    // Ansi profile name
    PSTR  pszDeviceName = NULL;     // Ansi device name
    BOOL  rc = TRUE;                // return code

    TRACEAPI((__TEXT("AssociateColorProfileWithDeviceW\n")));

    //
    // Validate parameters before we touch them
    //

    if (! pProfileName ||
        ! pDeviceName)
    {
        WARNING((__TEXT("Invalid parameter to AssociateColorProfileWithDevice\n")));
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // Convert machine name to Ansi
    //

    if (pMachineName)
    {
        rc = ConvertToAnsi(pMachineName, &pszMachineName, TRUE);
    }
    else
        pszMachineName = NULL;

    //
    // Convert profile name to Ansi
    //

    rc = rc && ConvertToAnsi(pProfileName, &pszProfileName, TRUE);

    //
    // Convert device name to Ansi
    //

    rc = rc && ConvertToAnsi(pDeviceName, &pszDeviceName, TRUE);

    //
    // Call the internal Ansi function
    //

    rc = rc && InternalAssociateColorProfileWithDevice(pszMachineName,
                pszProfileName, pszDeviceName);

    //
    // Free memory before leaving
    //

    if (pszProfileName)
    {
        MemFree(pszProfileName);
    }

    if (pszMachineName)
    {
        MemFree(pszMachineName);
    }

    if (pszDeviceName)
    {
        MemFree(pszDeviceName);
    }

    return rc;
}

#endif                          // ! UNICODE


/******************************************************************************
 *
 *                     DisassociateColorProfileFromDevice
 *
 *  Function:
 *       These are the ANSI & Unicode wrappers for
 *       InternalDisassociateColorProfileFromDevice. Please see
 *       InternalDisassociateColorProfileFromDevice for more details
 *       on this function.
 *
 *  Arguments:
 *       pMachineName    - name identifying machine. NULL implies local
 *       pProfileName    - pointer to profile to disassiciate
 *       pDeviceName     - pointer to device name
 *
 *  Returns:
 *       TRUE if successful, NULL otherwise
 *
 ******************************************************************************/

#ifdef UNICODE          // Windows NT versions

BOOL WINAPI
DisassociateColorProfileFromDeviceA(
    PCSTR pMachineName,
    PCSTR pProfileName,
    PCSTR pDeviceName
    )
{
    PWSTR pwszMachineName = NULL;   // Unicode machine name
    PWSTR pwszProfileName = NULL;   // Unicode profile name
    PWSTR pwszDeviceName = NULL;    // Unicode device name
    BOOL  rc = TRUE;                // return code

    TRACEAPI((__TEXT("DisassociateColorProfileWithDeviceA\n")));

    //
    // Validate parameters before we touch  them
    //

    if (! pProfileName ||
        ! pDeviceName)
    {
        WARNING((__TEXT("Invalid parameter to DisassociateColorProfileFromDevice\n")));
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // Convert machine name to Unicode
    //

    if (pMachineName)
    {
        rc = ConvertToUnicode(pMachineName, &pwszMachineName, TRUE);
    }
    else
        pwszMachineName = NULL;

    //
    // Convert profile name to Unicode
    //

    rc = rc && ConvertToUnicode(pProfileName, &pwszProfileName, TRUE);

    //
    // Convert device name to Unicode
    //

    rc = rc && ConvertToUnicode(pDeviceName, &pwszDeviceName, TRUE);

    //
    // Call the internal Unicode function
    //

    rc = rc && InternalDisassociateColorProfileFromDevice(pwszMachineName,
                pwszProfileName, pwszDeviceName);

    //
    // Free memory before leaving
    //

    if (pwszProfileName)
    {
        MemFree(pwszProfileName);
    }

    if (pwszMachineName)
    {
        MemFree(pwszMachineName);
    }

    if (pwszDeviceName)
    {
        MemFree(pwszDeviceName);
    }

    return rc;
}


BOOL WINAPI
DisassociateColorProfileFromDeviceW(
    PCWSTR pMachineName,
    PCWSTR pProfileName,
    PCWSTR pDeviceName
    )
{
    TRACEAPI((__TEXT("DisassociateColorProfileWithDeviceW\n")));

    //
    // Internal function is Unicode in Windows NT, call it directly.
    //

    return InternalDisassociateColorProfileFromDevice(pMachineName,
                pProfileName, pDeviceName);
}


#else                           // Windows 95 versions

BOOL WINAPI
DisassociateColorProfileFromDeviceA(
    PCSTR pMachineName,
    PCSTR pProfileName,
    PCSTR pDeviceName
    )
{
    TRACEAPI((__TEXT("DisassociateColorProfileWithDeviceA\n")));

    //
    // Internal function is ANSI in Windows 95, call it directly.
    //

    return InternalDisassociateColorProfileFromDevice(pMachineName,
                pProfileName, pDeviceName);
}


BOOL WINAPI
DisassociateColorProfileFromDeviceW(
    PCWSTR pMachineName,
    PCWSTR pProfileName,
    PCWSTR pDeviceName
    )
{
    PSTR  pszMachineName = NULL;    // Ansi machine name
    PSTR  pszProfileName = NULL;    // Ansi profile name
    PSTR  pszDeviceName = NULL;     // Ansi device name
    BOOL  rc = TRUE;                // return code

    TRACEAPI((__TEXT("DisassociateColorProfileWithDeviceW\n")));

    //
    // Validate parameters before we touch them
    //

    if (! pProfileName ||
        ! pDeviceName)
    {
        WARNING((__TEXT("Invalid parameter to AssociateColorProfileWithDevice\n")));
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // Convert machine name to Ansi
    //

    if (pMachineName)
    {
        rc = ConvertToAnsi(pMachineName, &pszMachineName, TRUE);
    }
    else
        pszMachineName = NULL;

    //
    // Convert profile name to Ansi
    //

    rc = rc && ConvertToAnsi(pProfileName, &pszProfileName, TRUE);

    //
    // Convert device name to Ansi
    //

    rc = rc && ConvertToAnsi(pDeviceName, &pszDeviceName, TRUE);

    //
    // Call the internal Ansi function
    //

    rc = rc && InternalDisassociateColorProfileFromDevice(pszMachineName,
                pszProfileName, pszDeviceName);

    //
    // Free memory before leaving
    //

    if (pszProfileName)
    {
        MemFree(pszProfileName);
    }

    if (pszMachineName)
    {
        MemFree(pszMachineName);
    }

    if (pszDeviceName)
    {
        MemFree(pszDeviceName);
    }

    return rc;
}

#endif                          // ! UNICODE



/******************************************************************************
 *
 *                               EnumColorProfiles
 *
 *  Function:
 *       These are the ANSI & Unicode wrappers for InternalEnumColorProfile.
 *       Please see InternalEnumColorProfile for more details on this
 *       function.
 *
 *  Arguments:
 *       pMachineName    - name identifying machine on which the enumeration
 *                         needs to be done
 *       pEnumRecord     - pointer to enumeration criteria
 *       pBuffer         - pointer to buffer to receive result, can be NULL
 *       pdwSize         - pointer to buffer size. On return it is actual number
 *                         of bytes copied/needed.
 *       pnProfiles      - pointer to DWORD. On return, it is number of profiles
 *                         copied to pBuffer.
 *
 *  Returns:
 *       TRUE if successful, NULL otherwise
 *
 ******************************************************************************/

#ifdef UNICODE          // Windows NT versions

BOOL WINAPI
EnumColorProfilesA(
    PCSTR      pMachineName,
    PENUMTYPEA pEnumRecord,
    PBYTE      pBuffer,
    PDWORD     pdwSize,
    PDWORD     pnProfiles
    )
{
    PWSTR pwszMachineName = NULL;   // Unicode machine name
    PWSTR pwszDeviceName = NULL;    // Unicode device name
    PSTR  pAnsiDeviceName = NULL;   // incoming Ansi device name
    PWSTR pwBuffer = NULL;          // buffer to receive data
    PWSTR pwTempBuffer = NULL;      // temporary pointer to buffer
    DWORD dwSize;                   // size of buffer
    DWORD dwSizeOfStruct;           // size of ENUMTYPE structure
    DWORD dwVersion;                // ENUMTYPE structure version
    BOOL  rc = TRUE;                // return code

    TRACEAPI((__TEXT("EnumColorProfilesA\n")));

    //
    // Validate parameters before we touch them
    //

    if (! pdwSize ||
        IsBadWritePtr(pdwSize, sizeof(DWORD)) ||
        (pBuffer && IsBadWritePtr(pBuffer, *pdwSize)) ||
        ! pEnumRecord ||
        IsBadReadPtr(pEnumRecord, sizeof(DWORD)*3))   // probe until ENUMTYPE.dwFields
    {
ParameterError_EnumColorProfilesA:
        WARNING((__TEXT("Invalid parameter to EnumColorProfiles\n")));
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // Check structure size based on its version.
    //

    dwSizeOfStruct = pEnumRecord->dwSize;
    dwVersion      = pEnumRecord->dwVersion;

    if (dwVersion >= ENUM_TYPE_VERSION)
    {
        if (dwSizeOfStruct < sizeof(ENUMTYPE))
            goto ParameterError_EnumColorProfilesA;
    }
    else if (dwVersion == 0x0200)
    {
        if (dwSizeOfStruct < sizeof(ENUMTYPE)-sizeof(DWORD))
            goto ParameterError_EnumColorProfilesA;

        //
        // Version 2 should not have ET_DEVICECLASS bit
        //

        if (pEnumRecord->dwFields & ET_DEVICECLASS)
            goto ParameterError_EnumColorProfilesA;

        WARNING((__TEXT("Old version ENUMTYPE to EnumColorProfiles\n")));
    }
    else
    {
        goto ParameterError_EnumColorProfilesA;
    }

    if (IsBadReadPtr(pEnumRecord, dwSizeOfStruct))
    {
        goto ParameterError_EnumColorProfilesA;
    }

    //
    // Convert machine name to Unicode
    //

    if (pMachineName)
    {
        rc = ConvertToUnicode(pMachineName, &pwszMachineName, TRUE);
    }
    else
        pwszMachineName = NULL;

    //
    // If device name is specified, convert it to Unicode
    //

    if (pEnumRecord->dwFields & ET_DEVICENAME)
    {
        if (! pEnumRecord->pDeviceName)
        {
            WARNING((__TEXT("Invalid parameter to EnumColorProfiles\n")));
            SetLastError(ERROR_INVALID_PARAMETER);
            rc = FALSE;
            goto EndEnumColorProfilesA;
        }

        //
        // Convert device name to Unicode
        //

        pAnsiDeviceName = (PSTR)pEnumRecord->pDeviceName;
        rc = rc && ConvertToUnicode(pAnsiDeviceName, &pwszDeviceName, TRUE);
        pEnumRecord->pDeviceName = (PSTR) pwszDeviceName;
    }

    dwSize = *pdwSize * sizeof(WCHAR);

    //
    // Allocate buffer of suitable size
    //

    if (pBuffer && dwSize)
    {
        pwBuffer = MemAlloc(dwSize);
        if (! pwBuffer)
        {
            WARNING((__TEXT("Error allocating memory for Unicode buffer\n")));
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            rc = FALSE;
            goto EndEnumColorProfilesA;
        }
    }

    //
    // Call the internal Unicode function
    //

    rc = rc && InternalEnumColorProfiles(pwszMachineName,
                (PENUMTYPEW)pEnumRecord, (PBYTE)pwBuffer, &dwSize, pnProfiles);

    if (pwBuffer && rc)
    {
        pwTempBuffer = pwBuffer;
        while (*pwTempBuffer)
        {
            rc = rc && ConvertToAnsi(pwTempBuffer, (PSTR *)&pBuffer, FALSE);
            if (!rc)
            {
                pBuffer = NULL;
                break;
            }
            pwTempBuffer += lstrlenW(pwTempBuffer) + 1;
            pBuffer  += (lstrlenA((PSTR)pBuffer) + 1) * sizeof(char);
        }

        if (pBuffer)
        {
            *((PSTR)pBuffer) = '\0';
        }
    }

    *pdwSize = dwSize / sizeof(WCHAR);

EndEnumColorProfilesA:
    if (pwszMachineName)
    {
        MemFree(pwszMachineName);
    }
    if (pAnsiDeviceName)
    {
        ASSERT(pEnumRecord->pDeviceName != NULL);

        MemFree((PBYTE)pEnumRecord->pDeviceName);
        pEnumRecord->pDeviceName = (PCSTR)pAnsiDeviceName;
    }
    if (pwBuffer)
    {
        MemFree(pwBuffer);
    }

    return rc;
}


BOOL WINAPI
EnumColorProfilesW(
    PCWSTR     pMachineName,
    PENUMTYPEW pEnumRecord,
    PBYTE      pBuffer,
    PDWORD     pdwSize,
    PDWORD     pnProfiles
    )
{
    TRACEAPI((__TEXT("EnumColorProfilesW\n")));

    //
    // Internal function is Unicode in Windows NT, call it directly.
    //

    return InternalEnumColorProfiles(pMachineName, pEnumRecord,
        pBuffer, pdwSize, pnProfiles);
}

#else                           // Windows 95 versions

BOOL WINAPI
EnumColorProfilesA(
    PCSTR      pMachineName,
    PENUMTYPEA pEnumRecord,
    PBYTE      pBuffer,
    PDWORD     pdwSize,
    PDWORD     pnProfiles
    )
{
    TRACEAPI((__TEXT("EnumColorProfilesA\n")));

    //
    // Internal function is ANSI in Windows 95, call it directly.
    //

    return InternalEnumColorProfiles(pMachineName, pEnumRecord,
        pBuffer, pdwSize, pnProfiles);
}


BOOL WINAPI
EnumColorProfilesW(
    PCWSTR     pMachineName,
    PENUMTYPEW pEnumRecord,
    PBYTE      pBuffer,
    PDWORD     pdwSize,
    PDWORD     pnProfiles
    )
{
    PSTR  pszMachineName = NULL;    // Ansi machine name
    PSTR  pszDeviceName = NULL;     // Ansi device name
    PWSTR pUnicodeDeviceName = NULL;// incoming Unicode device name
    PSTR  pszBuffer = NULL;         // buffer to receive data
    PSTR  pszTempBuffer = NULL;     // temporary pointer to buffer
    DWORD dwSize;                   // size of buffer
    DWORD dwSizeOfStruct;           // size of ENUMTYPE structure
    DWORD dwVersion;                // ENUMTYPE structure version
    BOOL  rc = TRUE;                // return code

    TRACEAPI((__TEXT("EnumColorProfilesW\n")));

    //
    // Validate parameters before we touch them
    //

    if (! pdwSize ||
        IsBadWritePtr(pdwSize, sizeof(DWORD)) ||
        (pBuffer && IsBadWritePtr(pBuffer, *pdwSize)) ||
        ! pEnumRecord ||
        IsBadReadPtr(pEnumRecord, sizeof(DWORD)*3))   // probe until ENUMTYPE.dwFields
    {
ParameterError_EnumColorProfilesW:
        WARNING((__TEXT("Invalid parameter to EnumColorProfiles\n")));
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // Check structure size based on its version.
    //

    dwSizeOfStruct = pEnumRecord->dwSize;
    dwVersion      = pEnumRecord->dwVersion;

    if (dwVersion >= ENUM_TYPE_VERSION)
    {
        if (dwSizeOfStruct < sizeof(ENUMTYPE))
            goto ParameterError_EnumColorProfilesW;
    }
    else if (dwVersion == 0x0200)
    {
        if (dwSizeOfStruct < sizeof(ENUMTYPE)-sizeof(DWORD))
            goto ParameterError_EnumColorProfilesW;

        //
        // Version 2 should not have ET_DEVICECLASS bit
        //

        if (pEnumRecord->dwFields & ET_DEVICECLASS)
            goto ParameterError_EnumColorProfilesW;

        WARNING((__TEXT("Old version ENUMTYPE to EnumColorProfiles\n")));
    }
    else
    {
        goto ParameterError_EnumColorProfilesW;
    }

    if (IsBadReadPtr(pEnumRecord, dwSizeOfStruct))
    {
        goto ParameterError_EnumColorProfilesW;
    }

    //
    // Convert machine name to Ansi
    //

    if (pMachineName)
    {
        rc = ConvertToAnsi(pMachineName, &pszMachineName, TRUE);
    }

    //
    // If device name is specified, convert it to Unicode
    //

    if (pEnumRecord->dwFields & ET_DEVICENAME)
    {
        if (! pEnumRecord->pDeviceName)
        {
            WARNING((__TEXT("Invalid parameter to EnumColorProfiles\n")));
            SetLastError(ERROR_INVALID_PARAMETER);
            goto EndEnumColorProfilesW;
        }

        //
        // Convert device name to Ansi
        //

        pUnicodeDeviceName = (PWSTR)pEnumRecord->pDeviceName;
        rc = rc && ConvertToAnsi(pUnicodeDeviceName, &pszDeviceName, TRUE);
        pEnumRecord->pDeviceName = (PCWSTR) pszDeviceName;
    }

    dwSize = *pdwSize / sizeof(WCHAR);

    //
    // Allocate buffer of suitable size
    //

    if (pBuffer && dwSize)
    {
        pszBuffer = MemAlloc(dwSize);
        if (! pszBuffer)
        {
            WARNING((__TEXT("Error allocating memory for Ansi buffer\n")));
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            rc = FALSE;
            goto EndEnumColorProfilesW;
        }
    }

    //
    // Call the internal Ansi function
    //

    rc = rc && InternalEnumColorProfiles(pszMachineName,
                (PENUMTYPEA)pEnumRecord, (PBYTE)pszBuffer, &dwSize, pnProfiles);

    if (pszBuffer && rc)
    {
        pszTempBuffer = pszBuffer;
        while (*pszTempBuffer)
        {
            rc = rc && ConvertToUnicode(pszTempBuffer, (PWSTR *)&pBuffer, FALSE);
            pszTempBuffer += lstrlenA(pszTempBuffer) + 1;
            pBuffer   += (lstrlenW((PWSTR)pBuffer) + 1) * sizeof(WCHAR);
        }

        *((PWSTR)pBuffer) = '\0';
    }
    *pdwSize = dwSize * sizeof(WCHAR);

EndEnumColorProfilesW:
    if (pszMachineName)
    {
        MemFree(pszMachineName);
    }
    if (pUnicodeDeviceName)
    {
        ASSERT(pEnumRecord->pDeviceName != NULL);

        MemFree((PSTR)pEnumRecord->pDeviceName);
        pEnumRecord->pDeviceName = (PCWSTR)pUnicodeDeviceName;
    }
    if (pszBuffer)
    {
        MemFree(pszBuffer);
    }

    return rc;
}

#endif                          // ! UNICODE


/******************************************************************************
 *
 *                          SetStandardColorSpaceProfile
 *
 *  Function:
 *       These are the ANSI & Unicode wrappers for InternalSetSCSProfile.
 *       Please see InternalSetSCSProfile for more details on this
 *       function.
 *
 *  Arguments:
 *       pMachineName    - name identifying machine on which the standard color
 *                         space profile should be registered
 *       dwSCS           - ID for the standard color space
 *       pProfileName    - pointer to profile filename
 *
 *  Returns:
 *       TRUE if successful, NULL otherwise
 *
 ******************************************************************************/

#ifdef UNICODE          // Windows NT versions

BOOL  WINAPI
SetStandardColorSpaceProfileA(
    PCSTR   pMachineName,
    DWORD   dwSCS,
    PCSTR   pProfileName
    )
{
    PWSTR pwszMachineName = NULL;   // Unicode machine name
    PWSTR pwszProfileName = NULL;   // Unicode profile name
    BOOL  rc = TRUE;                // return code

    TRACEAPI((__TEXT("SetStandardColorSpaceProfileA\n")));

    //
    // Validate parameters before we touch them
    //

    if (! pProfileName)
    {
        WARNING((__TEXT("Invalid parameter to SetStandardColorSpaceProfile\n")));
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // Convert machine name to Unicode
    //

    if (pMachineName)
    {
        rc = ConvertToUnicode(pMachineName, &pwszMachineName, TRUE);
    }
    else
        pwszMachineName = NULL;

    //
    // Convert profile name to Unicode
    //

    rc = rc && ConvertToUnicode(pProfileName, &pwszProfileName, TRUE);

    //
    // Call the internal Unicode function
    //

    rc = rc && InternalSetSCSProfile(pwszMachineName, dwSCS, pwszProfileName);

    //
    // Free memory before leaving
    //

    if (pwszProfileName)
    {
        MemFree(pwszProfileName);
    }

    if (pwszMachineName)
    {
        MemFree(pwszMachineName);
    }

    return rc;
}

BOOL  WINAPI
SetStandardColorSpaceProfileW(
    PCWSTR   pMachineName,
    DWORD    dwSCS,
    PCWSTR   pProfileName
    )
{
    TRACEAPI((__TEXT("SetStandardColorSpaceProfileW\n")));

    //
    // Internal function is Unicode in Windows NT, call it directly.
    //

    return InternalSetSCSProfile(pMachineName, dwSCS, pProfileName);
}

#else                           // Windows 95 versions

BOOL  WINAPI
SetStandardColorSpaceProfileA(
    PCSTR   pMachineName,
    DWORD   dwSCS,
    PCSTR   pProfileName
    )
{
    TRACEAPI((__TEXT("SetStandardColorSpaceProfileA\n")));

    //
    // Internal function is ANSI in Windows 95, call it directly.
    //

    return InternalSetSCSProfile(pMachineName, dwSCS, pProfileName);
}

BOOL  WINAPI
SetStandardColorSpaceProfileW(
    PCWSTR   pMachineName,
    DWORD    dwSCS,
    PCWSTR   pProfileName
    )
{
    PSTR  pszMachineName = NULL;    // Ansi machine name
    PSTR  pszProfileName = NULL;    // Ansi profile name
    BOOL  rc = TRUE;                // return code

    TRACEAPI((__TEXT("SetStandardColorSpaceProfileW\n")));

    //
    // Validate parameters before we touch them
    //

    if (! pProfileName)
    {
        WARNING((__TEXT("Invalid parameter to SetStandardColorSpaceProfile\n")));
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // Convert machine name to Ansi
    //

    if (pMachineName)
    {
        rc = ConvertToAnsi(pMachineName, &pszMachineName, TRUE);
    }
    else
        pszMachineName = NULL;

    //
    // Convert profile name to Ansi
    //

    rc = rc && ConvertToAnsi(pProfileName, &pszProfileName, TRUE);

    //
    // Call the internal Ansi function
    //

    rc = rc && InternalSetSCSProfile(pszMachineName, dwSCS, pszProfileName);

    //
    // Free memory before leaving
    //

    if (pszProfileName)
    {
        MemFree(pszProfileName);
    }

    if (pszMachineName)
    {
        MemFree(pszMachineName);
    }

    return rc;
}

#endif                          // ! UNICODE


/******************************************************************************
 *
 *                          GetStandardColorSpaceProfile
 *
 *  Function:
 *       These are the ANSI & Unicode wrappers for InternalGetSCSProfile.
 *       Please see InternalGetSCSProfile for more details on this
 *       function.
 *
 *  Arguments:
 *       pMachineName    - name identifying machine on which the standard color
 *                         space profile should be queried
 *       dwSCS           - ID for the standard color space
 *       pBuffer         - pointer to buffer to receive profile filename
 *       pdwSize         - pointer to DWORD specifying size of buffer. On return
 *                         it has size needed/used
 *
 *  Returns:
 *       TRUE if successful, NULL otherwise
 *
 ******************************************************************************/

#ifdef UNICODE          // Windows NT versions

BOOL  WINAPI
GetStandardColorSpaceProfileA(
    PCSTR   pMachineName,
    DWORD   dwSCS,
    PSTR    pBuffer,
    PDWORD  pdwSize
    )
{
    PWSTR pwszMachineName = NULL;   // Unicode machine name
    PWSTR pwBuffer = NULL;          // Unicode color directory path
    DWORD dwSize;                   // size of Unicode buffer
    BOOL  rc = TRUE;                // return code

    TRACEAPI((__TEXT("GetStandardColorSpaceProfileA\n")));

    //
    // Validate parameters before we touch them
    //

    if (! pdwSize ||
        IsBadWritePtr(pdwSize, sizeof(DWORD)) ||
        (pBuffer && IsBadWritePtr(pBuffer, *pdwSize)))
    {
        WARNING((__TEXT("Invalid parameter to GetStandardColorSpaceProfile\n")));
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // Convert machine name to Unicode
    //

    if (pMachineName)
    {
        rc = ConvertToUnicode(pMachineName, &pwszMachineName, TRUE);
    }
    else
        pwszMachineName = NULL;

    dwSize = *pdwSize * sizeof(WCHAR);

    //
    // Create a buffer to get Unicode filename from system
    //

    if (pBuffer && dwSize)
    {
        pwBuffer = (PWSTR)MemAlloc(dwSize);
        if (! pwBuffer)
        {
            WARNING((__TEXT("Error allocating memory for Unicode string\n")));
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            rc = FALSE;
            goto EndGetSCSProfileA;
        }
    }

    rc = rc && InternalGetSCSProfile(pwszMachineName, dwSCS, pwBuffer, &dwSize);

    *pdwSize = dwSize / sizeof(WCHAR);

    //
    // Convert Unicode path to Ansi
    //

    if (pwBuffer)
    {
        rc = rc && ConvertToAnsi(pwBuffer, &pBuffer, FALSE);
    }

EndGetSCSProfileA:
    if (pwszMachineName)
    {
        MemFree(pwszMachineName);
    }

    if (pwBuffer)
    {
        MemFree(pwBuffer);
    }

    return rc;
}

BOOL  WINAPI
GetStandardColorSpaceProfileW(
    PCWSTR   pMachineName,
    DWORD    dwSCS,
    PWSTR    pBuffer,
    PDWORD   pdwSize
    )
{
    TRACEAPI((__TEXT("GetStandardColorSpaceProfileW\n")));

    //
    // Internal function is Unicode in Windows NT, call it directly.
    //

    return InternalGetSCSProfile(pMachineName, dwSCS, pBuffer, pdwSize);
}

#else                           // Windows 95 versions

BOOL  WINAPI
GetStandardColorSpaceProfileA(
    PCSTR   pMachineName,
    DWORD   dwSCS,
    PSTR    pBuffer,
    PDWORD  pdwSize
    )
{
    TRACEAPI((__TEXT("GetStandardColorSpaceProfileA\n")));

    //
    // Internal function is ANSI in Windows 95, call it directly.
    //

    return InternalGetSCSProfile(pMachineName, dwSCS, pBuffer, pdwSize);
}

BOOL  WINAPI
GetStandardColorSpaceProfileW(
    PCWSTR   pMachineName,
    DWORD    dwSCS,
    PWSTR    pBuffer,
    PDWORD   pdwSize
    )
{
    PSTR pszMachineName = NULL;     // Ansi machine name
    PSTR pszBuffer = NULL;          // Ansi color directory path
    DWORD dwSize;                   // size of Ansi buffer
    BOOL  rc = TRUE;                // return code

    TRACEAPI((__TEXT("GetStandardColorSpaceProfileW\n")));

    //
    // Validate parameters before we touch them
    //

    if (! pdwSize ||
        IsBadWritePtr(pdwSize, sizeof(DWORD)) ||
        (pBuffer && IsBadWritePtr(pBuffer, *pdwSize)))
    {
        WARNING((__TEXT("Invalid parameter to GetStandardColorSpaceProfile\n")));
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // Convert machine name to Ansi
    //

    if (pMachineName)
    {
        rc = ConvertToAnsi(pMachineName, &pszMachineName, TRUE);
    }
    else
        pszMachineName = NULL;

    dwSize = *pdwSize / sizeof(WCHAR);

    //
    // Create a buffer to get Ansi profilename from system
    //

    if (pBuffer && dwSize)
    {
        pszBuffer = (PSTR)MemAlloc(dwSize);
        if (! pBuffer)
        {
            WARNING((__TEXT("Error allocating memory for Ansi string\n")));
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            rc = FALSE;
            goto EndGetSCSProfileW;
        }
    }

    rc = rc && InternalGetSCSProfile(pszMachineName, dwSCS, pszBuffer, &dwSize);

    *pdwSize = dwSize * sizeof(WCHAR);

    //
    // Convert Ansi path to Unicode
    //

    if (pszBuffer)
    {
        rc = rc && ConvertToUnicode(pszBuffer, &pBuffer, FALSE);
    }

EndGetSCSProfileW:
    if (pszMachineName)
    {
        MemFree(pszMachineName);
    }

    if (pszBuffer)
    {
        MemFree(pszBuffer);
    }

    return rc;
}

#endif                          // ! UNICODE


/******************************************************************************
 *
 *                          GenerateCopyFilePaths
 *
 *  Function:
 *       This function is called by the Windows NT spooler to find the
 *       directories from which color profiles should be picked up and copied
 *       to. This is useful if the locations are version or  processor
 *       architecture dependent. As color profiles depend on neither, we don't
 *       have to do anything, but have to export this function.
 *
 *  Arguments:
 *       don't care
 *
 *  Returns:
 *       ERROR_SUCCESS if successful, error code otherwise
 *
 ******************************************************************************/

DWORD WINAPI
GenerateCopyFilePaths(
    LPCWSTR     pszPrinterName,
    LPCWSTR     pszDirectory,
    LPBYTE      pSplClientInfo,
    DWORD       dwLevel,
    LPWSTR      pszSourceDir,
    LPDWORD     pcchSourceDirSize,
    LPWSTR      pszTargetDir,
    LPDWORD     pcchTargetDirSize,
    DWORD       dwFlags
    )
{
    TRACEAPI((__TEXT("GenerateCopyFilePaths\n")));
    return ERROR_SUCCESS;
}


/******************************************************************************
 *
 *                          SpoolerCopyFileEvent
 *
 *  Function:
 *       This function is called by the Windows NT spooler when one of the
 *       following events happens:
 *          1. When someone does a SetPrinterDataEx of the CopyFiles section
 *          2. When a printer connection is made
 *          3. When files for a printer connection get updated
 *          4. When a printer is deleted
 *
 *  Arguments:
 *       pszPrinterName  - friendly name of printer
 *       pszKey          - "CopyFiles\ICM" for us
 *       dwCopyFileEvent - reason for calling
 *
 *  Returns:
 *       TRUE if successful, NULL otherwise
 *
 ******************************************************************************/

BOOL WINAPI
SpoolerCopyFileEvent(
    LPWSTR  pszPrinterName,
    LPWSTR  pszKey,
    DWORD   dwCopyFileEvent
    )
{
    PTSTR pProfileList, pTemp, pBuffer;
    DWORD dwSize;
    BOOL  bRc = FALSE;
    TCHAR szPath[MAX_PATH];

    TRACEAPI((__TEXT("SpoolerCopyFileEvent\n")));

    switch (dwCopyFileEvent)
    {
    case COPYFILE_EVENT_SET_PRINTER_DATAEX:

        //
        // When associating profiles with printer connections, we copy
        // the files to the remote machine, and then do a SePrinterDataEx.
        // This causes this event to be generated on the remote machine. We
        // use this to install the profile. This is not needed after we make
        // our APIs remotable
        //
        // Fall thru'
        //

        TERSE((__TEXT("SetPrinterDataEx event\n")));

    case COPYFILE_EVENT_ADD_PRINTER_CONNECTION:
    case COPYFILE_EVENT_FILES_CHANGED:

        //
        // This event is generated when a printer connection is added or
        // associated profiles have changed. Install all the profiles in
        // the client machine now.
        //

        #if DBG
        if (dwCopyFileEvent == COPYFILE_EVENT_ADD_PRINTER_CONNECTION)
        {
            WARNING((__TEXT("AddPrinterConnection Event\n")));
        }
        else  if (dwCopyFileEvent == COPYFILE_EVENT_FILES_CHANGED)
        {
            WARNING((__TEXT("FilesChanged Event\n")));
        }
        #endif

        dwSize = 0;
        if (GetDeviceData((PTSTR)pszPrinterName, CLASS_PRINTER, DEVICE_PROFILE_DATA,
                          (PVOID *)&pProfileList, &dwSize, TRUE))
        {
            dwSize = sizeof(szPath);
            if (InternalGetColorDirectory(NULL, szPath, &dwSize))
            {
                lstrcat(szPath, gszBackslash);
                pBuffer = szPath + lstrlen(szPath);
                pTemp = pProfileList;
                while (*pTemp)
                {
                    lstrcpy(pBuffer, pTemp);
                    InstallColorProfile(NULL, szPath);
                    pTemp += lstrlen(pTemp) + 1;
                }
            }

            MemFree(pProfileList);
        }
        break;

    case COPYFILE_EVENT_DELETE_PRINTER:

        //
        // This event is generated when a printer is about to be deleted.
        // Get all profiles associated with the printer and disassociate
        // them now.
        //

        TERSE((__TEXT("DeletePrinterDataEx Event\n")));

        dwSize = 0;
        if (GetDeviceData((PTSTR)pszPrinterName, CLASS_PRINTER, DEVICE_PROFILE_DATA,
                          (PVOID *)&pProfileList, &dwSize, TRUE))
        {
            pTemp = pProfileList;
            while (*pTemp)
            {
                DisassociateColorProfileFromDevice(NULL, pTemp, (PTSTR)pszPrinterName);
                pTemp += lstrlen(pTemp) + 1;
            }

            MemFree(pProfileList);
        }
        break;
    }

    bRc = TRUE;

    return bRc;
}


/*****************************************************************************/
/***************************** Internal Functions ****************************/
/*****************************************************************************/

/******************************************************************************
 *
 *                         InternalGetColorDirectory
 *
 *  Function:
 *       This function returns the path to the color directory on the machine
 *       specified.
 *       associations should be removed before calling this function. It also
 *       optionally deletes the file if the profile was successfully
 *       uninstalled.
 *
 *  Arguments:
 *       pMachineName    - name identifying machine on which the path
 *                         to the color directory is requested
 *       pBuffer         - pointer to buffer to receive pathname
 *       pdwSize         - pointer to size of buffer. On return it has size of
 *                         buffer needed if failure, and used on success
 *
 *  Returns:
 *       TRUE if successful, FALSE otherwise
 *
 ******************************************************************************/

BOOL
InternalGetColorDirectory(
    LPCTSTR  pMachineName,
    PTSTR    pBuffer,
    DWORD   *pdwSize
    )
{
    DWORD dwBufLen = *pdwSize;      // size supplied
    BOOL  rc = FALSE;               // return value

    //
    // Get the printer driver directory
    //

#if !defined(_WIN95_)

    DWORD dwNeeded;                 // size needed
    BOOL bSuccess;
    DWORD dwTempSize;
    
    bSuccess = FALSE;

    if (!pBuffer && pdwSize && !IsBadWritePtr(pdwSize, sizeof(DWORD)))
    {
        *pdwSize = MAX_PATH;
        
        //
        // Doing the same thing as GetPrinterDriverDirectory does.
        // When the buffer is NULL, return FALSE and set last error.
        //

        SetLastError(ERROR_INSUFFICIENT_BUFFER);

        return FALSE;
    }

    dwTempSize = *pdwSize;
    
    bSuccess = GetPrinterDriverDirectory(
        (PTSTR)pMachineName, 
        NULL, 
        1, 
        (PBYTE)pBuffer,
        *pdwSize, 
        pdwSize
    );

    if( (!bSuccess) && 
        (GetLastError() == ERROR_INVALID_ENVIRONMENT) )
    {
        //
        // We failed with invalid environment, try this again with a 
        // guaranteed valid environment...
        // Could be IA64 -> win2K and win2K with no SP1 will fail as 
        // it didn't know about "Windows IA64"
        //
        
        *pdwSize = dwTempSize;
        
        bSuccess = GetPrinterDriverDirectory(
            (PTSTR)pMachineName, 
            __TEXT("Windows NT x86"), 
            1, 
            (PBYTE)pBuffer,
            *pdwSize, pdwSize
        );
    }

    if (bSuccess)
    {
        //
        // This API returns the print$ path appended with the environment
        // directory. e.g. c:\winnt\system32\spool\drivers\w32x86. So we need
        // to go back one step and then append the color directory.
        //

        PWSTR pDriverDir;

        if(pDriverDir = GetFilenameFromPath(pBuffer))
        {

            ASSERT (pDriverDir != NULL);

            *pdwSize -= lstrlen(pDriverDir) * sizeof(WCHAR);

            *pDriverDir = '\0';

            //
            // Calculate size of buffer needed to append color directory
            //

            dwNeeded = *pdwSize + lstrlen(gszColorDir) * sizeof(WCHAR);
            if (pBuffer[lstrlen(pBuffer) - 1] != '\\')
            {
                dwNeeded += sizeof(WCHAR);
            }

            //
            // Update size needed
            //

            *pdwSize = dwNeeded;

            //
            // If supplied buffer is big enough, append our stuff
            //

            if (dwNeeded <= dwBufLen)
            {
                if (pBuffer[lstrlen(pBuffer) - 1] != '\\')
                {
                    lstrcat(pBuffer, gszBackslash);
                }

                lstrcat(pBuffer, gszColorDir);

                rc = TRUE;
            }
            else
            {
                WARNING((__TEXT("Input buffer to GetColorDirectory not big enough\n")));
                SetLastError(ERROR_INSUFFICIENT_BUFFER);
            }
        }
    }
    else if (GetLastError() == ERROR_INVALID_USER_BUFFER)
    {
        //
        // Spooler sets this error if buffer is NULL. Map it to our error
        //

        SetLastError(ERROR_INSUFFICIENT_BUFFER);
    }
    else if (GetLastError() == RPC_S_SERVER_UNAVAILABLE)
    {
        TCHAR achTempPath[MAX_PATH * 2]; // Make sure enough path space.

        //
        // Spooler service is not running. Use hardcoded path
        //

        if (GetSystemDirectory(achTempPath,MAX_PATH) != 0)
        {
            _tcscat(achTempPath,TEXT("\\spool\\drivers\\color"));

            *pdwSize = wcslen(achTempPath) + 1;

            if (pBuffer && (*pdwSize <= dwBufLen))
            {
                _tcscpy(pBuffer,achTempPath);

                rc = TRUE;
            }
            else
            {
                WARNING((__TEXT("Input buffer to GetColorDirectory not big enough\n")));
                SetLastError(ERROR_INSUFFICIENT_BUFFER);
            }
        }
    }

#else

    HKEY  hkSetup;                  // registry key
    DWORD dwErr;                    // error code

    //
    // Only local color directory query is allowed in Memphis
    //

    if (pMachineName)
    {
        WARNING((__TEXT("Remote color directory query, failing...\n")));
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // On Memphis, get this information from the setup section in the registry.
    // The reason we don't call GetPrinterDriverDirectory is that when we call
    // this function from GDI 16, it tries to go back into 16-bit mode and
    // deadlocks on the Win16 lock.
    //

    if ((dwErr = RegOpenKey(HKEY_LOCAL_MACHINE, gszSetupPath, &hkSetup)) == ERROR_SUCCESS)
    {
        if ((dwErr = RegQueryValueEx(hkSetup, gszICMDir, 0, NULL, (PBYTE)pBuffer,
                pdwSize)) == ERROR_SUCCESS)
        {
            rc = TRUE;
        }
        RegCloseKey(hkSetup);
    }

    if (!rc)
    {
        //
        // Make error codes consistent
        //

        if (dwErr == ERROR_MORE_DATA)
        {
            dwErr = ERROR_INSUFFICIENT_BUFFER;
        }

        WARNING((__TEXT("Error getting color directory: %d\n"), dwErr));
        SetLastError(dwErr);
    }

    //
    // RegQueryValueEx returns TRUE even if the calling buffer is NULL. Our API
    // is supposed to return FALSE. Check for this case.
    //

    if (pBuffer == NULL && rc)
    {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        rc = FALSE;
    }

#endif // !defined(_WIN95_)

    return rc;
}


/******************************************************************************
 *
 *                         InternalInstallColorProfile
 *
 *  Function:
 *       This function installs a given color profile on a a given machine.
 *
 *  Arguments:
 *       pMachineName    - name identifying machine on which the profile
 *                         should be uninstalled. NULL implies local
 *       pProfileName    - Fully qualified pathname of profile to uninstall
 *       bDelete         - TRUE if profile should be deleted in disk
 *
 *  Returns:
 *       TRUE if successful, NULL otherwise
 *
 *  Warning:
 *       Currently only local install is supported, so pMachineName should
 *       be NULL.
 *
 ******************************************************************************/

BOOL
InternalInstallColorProfile(
    LPCTSTR   pMachineName,
    LPCTSTR   pProfileName
    )
{
    PROFILEHEADER header;           // profile header
    REGDATA  regData;               // for storing registry data about profile
    HKEY     hkICM = NULL;          // key to ICM branch in registry
    HKEY     hkDevice = NULL;       // key to ICM device branch in registry
    DWORD    dwSize;                // size of registry data for profile
    DWORD    dwErr;                 // error code
    BOOL     rc = FALSE;            // return code
    PTSTR    pFilename;             // profile name without path
    TCHAR    szDest[MAX_PATH];      // destination path for profile
    TCHAR    szClass[5];            // profile class
    BOOL     FileExist;             // profile already in directory?
    BOOL     RegExist;              // profile in registry?
    
    //
    // Validate parameters
    //
    
    if (!pProfileName)
    {
        WARNING((__TEXT("Invalid parameter to InstallColorProfile\n")));
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // Only local installs are allowed now
    //

    if (pMachineName)
    {
        WARNING((__TEXT("Remote install attempted, failing...\n")));
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // Get rid of the directory path and get a pointer to the filename
    //

    pFilename = GetFilenameFromPath((PTSTR)pProfileName);
    if (! pFilename)
    {
        WARNING((__TEXT("Could not parse file name from profile path %s\n"), pProfileName));
        SetLastError(ERROR_INVALID_PARAMETER);
        goto EndInstallColorProfile;
    }

    //
    // Get the profile class in the form of a string
    //

    if (! GetProfileClassString(pProfileName, szClass, &header))
    {
        WARNING((__TEXT("Installing invalid profile %s\n"), pProfileName));
        SetLastError(ERROR_INVALID_PROFILE);
        goto EndInstallColorProfile;
    }

    //
    // Open the registry path where profiles are kept
    //

    if (((dwErr = RegCreateKey(HKEY_LOCAL_MACHINE, gszICMRegPath, &hkICM)) != ERROR_SUCCESS) ||
        ((dwErr = RegCreateKey(hkICM, szClass, &hkDevice)) != ERROR_SUCCESS))
    {
        WARNING((__TEXT("Cannot open ICM\\device branch of registry: %d\n"), dwErr));
        SetLastError(dwErr);
        goto EndInstallColorProfile;
    }


    //
    // If registry data exists && the profile is in the directory,  then the profile is already installed,
    // in which case, return success. Otherwise, copy profile to color
    // directory (if it's not already there) and add it to the registry (if it's not already there).
    //

    dwSize = sizeof(szDest);
        
    //
    // Copy the file to the color directory
    //

    if (! InternalGetColorDirectory(NULL, szDest, &dwSize))
    {
        WARNING((__TEXT("Could not get color directory\n")));
        goto EndInstallColorProfile;
    }

    //
    // This creates the directory if it doesn't exist, doesn't do anything
    // if it already exists
    //

    CreateDirectory(szDest, NULL);

    if (szDest[lstrlen(szDest) - 1] != '\\')
    {
        lstrcat(szDest, gszBackslash);
    }
    lstrcat(szDest, pFilename);

    //
    // If the profile is already in the color directory, do not attempt
    // to copy it again; it will fail.
    //
        
    dwSize = sizeof(REGDATA);
    
    FileExist = GetFileAttributes(szDest) != (DWORD)-1;
    RegExist = RegQueryValueEx(hkDevice, pFilename, 0, NULL, (PBYTE)&regData, &dwSize) == ERROR_SUCCESS;

    //
    // If the file does exist, short circuit the CopyFile 
    // and go on to add it into the registry.
    //

    if (!FileExist && !CopyFile(pProfileName, szDest, FALSE))
    {
        WARNING((__TEXT("Could not copy profile %s to color directory\n"), pProfileName));
        goto EndInstallColorProfile;
    }

    //
    // Add profile to the registry
    //

    if(!RegExist) 
    {
        regData.dwRefCount = 0;
        regData.dwManuID = FIX_ENDIAN(header.phManufacturer);
        regData.dwModelID = FIX_ENDIAN(header.phModel);
        if ((dwErr = RegSetValueEx(hkDevice, pFilename, 0, REG_BINARY,
                  (PBYTE)&regData, sizeof(REGDATA))) != ERROR_SUCCESS)
        {
            WARNING((__TEXT("Could not set registry data to install profile %s: %d\n"), pFilename, dwErr));
            SetLastError(dwErr);
            goto EndInstallColorProfile;
        }
    }
    
    rc = TRUE;              // Everything went well!

EndInstallColorProfile:    
    if (hkICM)
    {
        RegCloseKey(hkICM);
    }
    if (hkDevice)
    {
        RegCloseKey(hkDevice);
    }

    return rc;
}


/******************************************************************************
 *
 *                         InternalUninstallColorProfile
 *
 *  Function:
 *       This function uninstalls a given color profile on a a given machine.
 *       It fails if the color profile is associated with any device, so all
 *       associations should be removed before calling this function. It also
 *       optionally deletes the file if the profile was successfully
 *       uninstalled.
 *
 *  Arguments:
 *       pMachineName    - name identifying machine on which the profile
 *                         should be uninstalled. NULL implies local
 *       pProfileName    - pointer to profile to uninstall
 *       bDelete         - TRUE if profile should be deleted in disk
 *
 *  Returns:
 *       TRUE if successful, NULL otherwise
 *
 *  Warning:
 *       Currently only local uninstall is supported, so pMachineName should
 *       be NULL.
 *
 ******************************************************************************/

BOOL
InternalUninstallColorProfile(
    LPCTSTR pMachineName,
    LPCTSTR pProfileName,
    BOOL    bDelete
    )
{
    REGDATA  regData;               // for storing registry data about profile
    HKEY     hkICM = NULL;          // key to ICM branch in registry
    HKEY     hkDevice = NULL;       // key to ICM device branch in registry
    DWORD    dwSize;                // size of registry data for profile
    DWORD    dwErr;                 // error code
    BOOL     rc = FALSE;            // return code
    PTSTR    pFilename;             // profile name without path
    TCHAR    szColorPath[MAX_PATH]; // full path name of profile
    TCHAR    szClass[5];            // profile class

    //
    // Validate parameters
    //

    if (!pProfileName)
    {
        WARNING((__TEXT("Invalid parameter to UninstallColorProfile\n")));
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // Only local installs are allowed now
    //

    if (pMachineName != NULL)
    {
        WARNING((__TEXT("Remote uninstall attempted, failing...\n")));
        SetLastError(ERROR_NOT_SUPPORTED);
        return FALSE;
    }

    //
    // Get rid of the directory path and get a pointer to the filename
    //

    pFilename = GetFilenameFromPath((PTSTR)pProfileName);
    if (! pFilename)
    {
        WARNING((__TEXT("Could not parse file name from profile path\n"), pProfileName));
        SetLastError(ERROR_INVALID_PARAMETER);
        goto EndUninstallColorProfile;
    }

    //
    // Create a fully qualified path name
    //

    dwSize = sizeof(szColorPath);
    if (! InternalGetColorDirectory(NULL, szColorPath, &dwSize))
    {
        WARNING((__TEXT("Could not get color directory\n")));
        goto EndUninstallColorProfile;
    }

    if (szColorPath[lstrlen(szColorPath) - 1] != '\\')
    {
        lstrcat(szColorPath, gszBackslash);
    }
    lstrcat(szColorPath, pFilename);

    //
    // Get the profile class in the form of a string
    //

    if (! GetProfileClassString(szColorPath, szClass, NULL))
    {
        WARNING((__TEXT("Installing invalid profile\n")));
        SetLastError(ERROR_INVALID_PROFILE);
        goto EndUninstallColorProfile;
    }

    //
    // Open the registry path where profiles are kept
    //

    if (((dwErr = RegOpenKey(HKEY_LOCAL_MACHINE, gszICMRegPath, &hkICM)) != ERROR_SUCCESS) ||
        ((dwErr = RegOpenKey(hkICM, szClass, &hkDevice)) != ERROR_SUCCESS))
    {
        WARNING((__TEXT("Cannot open ICM\\device branch of registry: %d\n"), dwErr));
        SetLastError(dwErr);
        goto EndUninstallColorProfile;
    }

    //
    // Check if reference count is zero and remove value from registry
    //

    dwSize = sizeof(REGDATA);
    if ((dwErr = RegQueryValueEx(hkDevice, pFilename, 0, NULL, (PBYTE)&regData,
            &dwSize)) != ERROR_SUCCESS)
    {
        WARNING((__TEXT("Trying to uninstall a profile that is not installed %s: %d\n"), pFilename, dwErr));
        SetLastError(dwErr);
        goto EndUninstallColorProfile;
    }

    if (regData.dwRefCount != 0)
    {
        WARNING((__TEXT("Trying to uninstall profile %s whose refcount is %d\n"),
            pFilename, regData.dwRefCount));
        goto EndUninstallColorProfile;
    }

    if ((dwErr = RegDeleteValue(hkDevice, pFilename)) != ERROR_SUCCESS)
    {
        WARNING((__TEXT("Error deleting profile %s from registry: %d\n"), pFilename, dwErr));
        SetLastError(dwErr);
        goto EndUninstallColorProfile;
    }

    //
    // Remove profile from the registry
    //

    if (bDelete)
    {
        //
        // Delete profile from the color directory
        //

        if (! DeleteFile(szColorPath))
        {
            WARNING((__TEXT("Error deleting profile %s: %d\n"), szColorPath, GetLastError()));
            goto EndUninstallColorProfile;
        }
    }

    rc = TRUE;              // Everything went well!

EndUninstallColorProfile:
    if (hkICM)
    {
        RegCloseKey(hkICM);
    }
    if (hkDevice)
    {
        RegCloseKey(hkDevice);
    }

    return rc;
}


/******************************************************************************
 *
 *                    InternalAssociateColorProfileWithDevice
 *
 *  Function:
 *       This function associates a color profile on a a given machine with a
 *       particular device. It fails if the color profile is not installed on
 *       the machine. It increases the usage reference count of the profile.
 *
 *  Arguments:
 *       pMachineName    - name identifying machine. NULL implies local
 *       pProfileName    - pointer to profile to associate
 *       pDeviceName     - pointer to device name
 *
 *  Returns:
 *       TRUE if successful, NULL otherwise
 *
 *  Warning:
 *       Currently only local association is supported, so pMachineName should
 *       be NULL.
 *
 ******************************************************************************/

BOOL
InternalAssociateColorProfileWithDevice(
    LPCTSTR pMachineName,
    LPCTSTR pProfileName,
    LPCTSTR pDeviceName
    )
{
    PROFILEHEADER header;           // profile header
    REGDATA  regData;               // for storing registry data about profile
    HKEY     hkICM = NULL;          // key to ICM branch in registry
    HKEY     hkDevice = NULL;       // key to ICM device branch in registry
    DWORD    dwSize;                // size of registry data
    DWORD    dwNewSize;             // new size of device registry data
    DWORD    dwErr;                 // error code
    BOOL     rc = FALSE;            // return code
    PTSTR    pFilename;             // profile name without path
    PTSTR    pProfileList = NULL;   // list of associated profiles
    TCHAR    szColorPath[MAX_PATH]; // full path name of profile
    TCHAR    szClass[5];            // profile class
    BOOL     bFirstProfile = FALSE; // First profile to be associated for device
    DWORD    dwDeviceClass;         // device class

    //
    // Validate parameters
    //

    if (! pProfileName ||
        ! pDeviceName)
    {
        WARNING((__TEXT("Invalid parameter to AssociateColorProfileWithDevice\n")));
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // Only local associations are allowed now
    //

    if (pMachineName != NULL)
    {
        WARNING((__TEXT("Remote profile association attempted, failing...\n")));
        SetLastError(ERROR_NOT_SUPPORTED);
        return FALSE;
    }

    //
    // Get rid of the directory path and get a pointer to the filename
    //

    pFilename = GetFilenameFromPath((PTSTR)pProfileName);
    if (! pFilename)
    {
        WARNING((__TEXT("Could not parse file name from profile path %s\n"), pProfileName));
        SetLastError(ERROR_INVALID_PARAMETER);
        goto EndAssociateProfileWithDevice;
    }

    //
    // Create a fully qualified path name
    //

    dwSize = sizeof(szColorPath);
    if (! InternalGetColorDirectory(NULL, szColorPath, &dwSize))
    {
        WARNING((__TEXT("Could not get color directory\n")));
        goto EndAssociateProfileWithDevice;
    }

    if (szColorPath[lstrlen(szColorPath) - 1] != '\\')
    {
        lstrcat(szColorPath, gszBackslash);
    }
    lstrcat(szColorPath, pFilename);

    //
    // Get the profile class in the form of a string
    //

    if (! GetProfileClassString(szColorPath, szClass, &header))
    {
        WARNING((__TEXT("Installing invalid profile %s\n"), szColorPath));
        SetLastError(ERROR_INVALID_PROFILE);
        goto EndAssociateProfileWithDevice;
    }

    //
    // Open the registry path where profiles are kept
    //

    if (((dwErr = RegOpenKey(HKEY_LOCAL_MACHINE, gszICMRegPath, &hkICM)) != ERROR_SUCCESS) ||
        ((dwErr = RegOpenKey(hkICM, szClass, &hkDevice)) != ERROR_SUCCESS))
    {
        WARNING((__TEXT("Cannot open ICM\\device branch of registry: %d\n"), dwErr));
        SetLastError(dwErr);
        goto EndAssociateProfileWithDevice;
    }

    //
    // Check if profile is installed
    //

    dwSize = sizeof(REGDATA);
    if ((dwErr = RegQueryValueEx(hkDevice, pFilename, 0, NULL, (PBYTE)&regData,
            &dwSize)) != ERROR_SUCCESS)
    {
        WARNING((__TEXT("Trying to associate a profile that is not installed %s: %d\n"), pFilename, dwErr));
        SetLastError(dwErr);
        goto EndAssociateProfileWithDevice;
    }

    //
    // Treat CLASS_MONITOR as CLASS_COLORSPACE.
    //
    if ((dwDeviceClass = header.phClass) == CLASS_MONITOR)
    {
        //
        // since CLASS_MONTOR profile can be associated any device class.
        //
        dwDeviceClass = CLASS_COLORSPACE;
    }

    //
    // Read in the list of profiles associated with the device
    //

    dwSize = 0;
    if (! GetDeviceData(pDeviceName, dwDeviceClass, DEVICE_PROFILE_DATA,
                        (PVOID *)&pProfileList, &dwSize, TRUE))
    {
        pProfileList = NULL;        // no data found
    }

    //
    // If the profile is already associated with the device, return success.
    // Do not check if we didn't get a profile list
    //

    if (pProfileList &&
        IsStringInMultiSz(pProfileList, pFilename) == TRUE)
    {
        rc = TRUE;
        goto EndAssociateProfileWithDevice;
    }

    if (dwSize <= sizeof(TCHAR))
    {
        bFirstProfile = TRUE;
    }

    //
    // Add new profile to the list of profiles, and double NULL
    // terminate the MULTI_SZ string.
    //

    if (dwSize > 0)
    {
        //
        // Use a temporary pointer, so that if MemReAlloc fails, we do
        // not have a memory leak - the original pointer needs to be freed
        //

        PTSTR pTemp;

        dwNewSize = dwSize + (lstrlen(pFilename) + 1) * sizeof(TCHAR);

        pTemp = MemReAlloc(pProfileList, dwNewSize);
        if (! pTemp)
        {
            WARNING((__TEXT("Error reallocating pProfileList\n")));
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            goto EndAssociateProfileWithDevice;
        }
        else
            pProfileList = pTemp;
    }
    else
    {
        //
        // Allocate extra character for double NULL termination. Setting
        // dwSize to 1 accomplishes this and lets the lstrcpy below
        // to work correctly.
        //

        dwSize = sizeof(TCHAR);     // extra char for double NULL termination

        dwNewSize = dwSize + (lstrlen(pFilename) + 1) * sizeof(TCHAR);
        pProfileList = MemAlloc(dwNewSize);
        if (! pProfileList)
        {
            WARNING((__TEXT("Error allocating pProfileList\n")));
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            goto EndAssociateProfileWithDevice;
        }
    }
    {
        PTSTR pPtr;                 // temporary pointer

        pPtr = (PTSTR)((PBYTE)pProfileList + dwSize - sizeof(TCHAR));
        lstrcpy(pPtr, pFilename);
        pPtr = (PTSTR)((PBYTE)pProfileList + dwNewSize - sizeof(TCHAR));
        *pPtr = '\0';               // double NULL terminate
    }

    //
    // Set the device data
    //

    if (! SetDeviceData(pDeviceName, dwDeviceClass, DEVICE_PROFILE_DATA,
                        pProfileList, dwNewSize))
    {
        WARNING((__TEXT("Error setting device profile data for %s\n"), pDeviceName));
        goto EndAssociateProfileWithDevice;
    }

    //
    // Increment usage count and set it
    //

    regData.dwRefCount++;
    if ((dwErr = RegSetValueEx(hkDevice, pFilename, 0, REG_BINARY,
            (PBYTE)&regData, sizeof(REGDATA))) != ERROR_SUCCESS)
    {
        ERR((__TEXT("Could not set registry data for profile %s: %d\n"), pFilename, dwErr));
        SetLastError(dwErr);
        goto EndAssociateProfileWithDevice;
    }

    #if !defined(_WIN95_)

    if (bFirstProfile)
    {
        ChangeICMSetting(pMachineName, pDeviceName, ICM_ON);
    }

    #endif

    rc = TRUE;              // Everything went well!

EndAssociateProfileWithDevice:
    if (hkICM)
    {
        RegCloseKey(hkICM);
    }
    if (hkDevice)
    {
        RegCloseKey(hkDevice);
    }
    if (pProfileList)
    {
        MemFree(pProfileList);
    }

    return rc;
}


/******************************************************************************
 *
 *                    InternalDisassociateColorProfileFromDevice
 *
 *  Function:
 *       This function disassociates a color profile on a a given machine from
 *       a particular device. It fails if the color profile is not installed
 *       on the machine and associated with the device. It decreases the usage
 *       reference count of the profile.
 *
 *  Arguments:
 *       pMachineName    - name identifying machine. NULL implies local
 *       pProfileName    - pointer to profile to disassociate
 *       pDeviceName     - pointer to device name
 *
 *  Returns:
 *       TRUE if successful, NULL otherwise
 *
 *  Warning:
 *       Currently only local disassociation is supported, so pMachineName
 *       should be NULL.
 *
 ******************************************************************************/

BOOL
InternalDisassociateColorProfileFromDevice(
    LPCTSTR pMachineName,
    LPCTSTR pProfileName,
    LPCTSTR pDeviceName
    )
{
    PROFILEHEADER header;           // profile header
    REGDATA  regData;               // for storing registry data about profile
    HKEY     hkICM = NULL;          // key to ICM branch in registry
    HKEY     hkDevice = NULL;       // key to ICM device branch in registry
    DWORD    dwSize;                // size of registry data
    DWORD    dwNewSize;             // new size of device registry data
    DWORD    dwErr;                 // error code
    BOOL     rc = FALSE;            // return code
    PTSTR    pFilename;             // profile name without path
    PTSTR    pProfileList = NULL;   // list of associated profiles
    TCHAR    szColorPath[MAX_PATH]; // full path name of profile
    TCHAR    szClass[5];            // profile class
    BOOL     bLastProfile = FALSE;  // whether last profile is being removed
    DWORD    dwDeviceClass;         // device class

    //
    // Validate parameters
    //

    if (! pProfileName ||
        ! pDeviceName)
    {
        WARNING((__TEXT("Invalid parameter to DisassociateColorProfileFromDevice\n")));
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // Only local associations are allowed now
    //

    if (pMachineName != NULL)
    {
        WARNING((__TEXT("Remote profile disassociation attempted, failing...\n")));
        SetLastError(ERROR_NOT_SUPPORTED);
        return FALSE;
    }

    //
    // Get rid of the directory path and get a pointer to the filename
    //

    pFilename = GetFilenameFromPath((PTSTR)pProfileName);
    if (! pFilename)
    {
        WARNING((__TEXT("Could not parse file name from profile path %s\n"), pProfileName));
        SetLastError(ERROR_INVALID_PARAMETER);
        goto EndDisassociateProfileWithDevice;
    }

    //
    // Create a fully qualified path name
    //

    dwSize = sizeof(szColorPath);
    if (! InternalGetColorDirectory(NULL, szColorPath, &dwSize))
    {
        WARNING((__TEXT("Could not get color directory\n")));
        goto EndDisassociateProfileWithDevice;
    }

    if (szColorPath[lstrlen(szColorPath) - 1] != '\\')
    {
        lstrcat(szColorPath, gszBackslash);
    }
    lstrcat(szColorPath, pFilename);

    //
    // Get the profile class in the form of a string
    //

    if (! GetProfileClassString(szColorPath, szClass, &header))
    {
        WARNING((__TEXT("Installing invalid profile %s\n"), szColorPath));
        SetLastError(ERROR_INVALID_PROFILE);
        goto EndDisassociateProfileWithDevice;
    }

    //
    // Open the registry path where profiles are kept
    //

    if (((dwErr = RegOpenKey(HKEY_LOCAL_MACHINE, gszICMRegPath, &hkICM)) != ERROR_SUCCESS) ||
        ((dwErr = RegOpenKey(hkICM, szClass, &hkDevice)) != ERROR_SUCCESS))
    {
        WARNING((__TEXT("Cannot open ICM\\device branch of registry: %d\n"), dwErr));
        SetLastError(dwErr);
        goto EndDisassociateProfileWithDevice;
    }

    //
    // Check if profile is installed
    //

    dwSize = sizeof(REGDATA);
    if ((dwErr = RegQueryValueEx(hkDevice, pFilename, 0, NULL, (PBYTE)&regData,
            &dwSize)) != ERROR_SUCCESS)
    {
        WARNING((__TEXT("Trying to disassociate a profile that is not installed %s: %d\n"), pFilename, dwErr));
        SetLastError(dwErr);
        goto EndDisassociateProfileWithDevice;
    }

    //
    // Treat CLASS_MONITOR as CLASS_COLORSPACE.
    //
    if ((dwDeviceClass = header.phClass) == CLASS_MONITOR)
    {
        //
        // since CLASS_MONTOR profile can be associated any device class.
        //
        dwDeviceClass = CLASS_COLORSPACE;
    }

    //
    // Read in the list of profiles associated with the device
    //

    dwSize = 0;
    if (! GetDeviceData(pDeviceName, dwDeviceClass, DEVICE_PROFILE_DATA,
                        (PVOID *)&pProfileList, &dwSize, TRUE))
    {
        pProfileList = NULL;        // no data found
    }

    //
    // If the profile is not associated with the device, return failure
    //

    if (! pProfileList ||
        ! IsStringInMultiSz(pProfileList, pFilename))
    {
        WARNING((__TEXT("Trying to disassociate a profile that is not associated %s\n"), pFilename));
        SetLastError(ERROR_PROFILE_NOT_ASSOCIATED_WITH_DEVICE);
        goto EndDisassociateProfileWithDevice;
    }

    //
    // Remove profile from the list of profiles, and double NULL
    // terminate the MULTI_SZ string.
    //

    dwNewSize = RemoveStringFromMultiSz(pProfileList, pFilename, dwSize);

    //
    // Set the device data
    //

    if (! SetDeviceData(pDeviceName, dwDeviceClass, DEVICE_PROFILE_DATA,
                        pProfileList, dwNewSize))
    {
        WARNING((__TEXT("Error setting device profile data for %s\n"), pDeviceName));
        goto EndDisassociateProfileWithDevice;
    }

    if (dwNewSize <= sizeof(TCHAR))
    {
        bLastProfile = TRUE;
    }

    //
    // Decrement usage count and set it
    //

    regData.dwRefCount--;
    if ((dwErr = RegSetValueEx(hkDevice, pFilename, 0, REG_BINARY,
            (PBYTE)&regData, sizeof(REGDATA))) != ERROR_SUCCESS)
    {
        ERR((__TEXT("Could not set registry data for profile %s: %d\n"), pFilename, dwErr));
        SetLastError(dwErr);
        goto EndDisassociateProfileWithDevice;
    }

    #if !defined(_WIN95_)

    if (bLastProfile)
    {
        ChangeICMSetting(pMachineName, pDeviceName, ICM_OFF);
    }

    #endif

    rc = TRUE;              // Everything went well!

EndDisassociateProfileWithDevice:
    if (hkICM)
    {
        RegCloseKey(hkICM);
    }
    if (hkDevice)
    {
        RegCloseKey(hkDevice);
    }
    if (pProfileList)
    {
        MemFree(pProfileList);
    }

    return rc;
}


/******************************************************************************
 *
 *                          InternalEnumColorProfiles
 *
 *  Function:
 *       These functions enumerates color profiles satisfying the given
 *       enumeration criteria. It searches among all installed profiles, and
 *       on return fills out a buffer with a series of NULL terminated profile
 *       filenames double NULL terminated at the end.
 *
 *  Arguments:
 *       pMachineName    - name identifying machine on which the enumeration
 *                         needs to be done
 *       pEnumRecord     - pointer to enumeration criteria
 *       pBuffer         - pointer to buffer to receive result, can be NULL
 *       pdwSize         - pointer to buffer size. On return it is actual number
 *                         of bytes copied/needed.
 *       pnProfiles      - pointer to DWORD. On return, it is number of profiles
 *                         copied to pBuffer.
 *
 *  Returns:
 *       TRUE if successful, NULL otherwise
 *
 *  Warning:
 *       Currently only local enumeration is supported, so pMachineName should
 *       be NULL.
 *
 ******************************************************************************/

BOOL
InternalEnumColorProfiles(
    LPCTSTR    pMachineName,
    PENUMTYPE  pEnumRecord,
    PBYTE      pBuffer,
    PDWORD     pdwSize,
    PDWORD     pnProfiles
    )
{
    REGDATA  regData;               // for storing registry data about profile
    HKEY     hkICM = NULL;          // key to ICM branch in registry
    HKEY     hkDevice = NULL;       // key to ICM device branch in registry
    PTSTR    pProfileList = NULL;   // list of associated profiles
    PTSTR    pTempProfileList;      // temporary copy of profile list
    DWORD    dwSize;                // size of profile value
    DWORD    dwDataSize;            // size of profile data
    DWORD    dwInputSize;           // incoming size of buffer
    DWORD    i, j;                  // counter variables
    DWORD    dwErr;                 // error code
    BOOL     rc = FALSE;            // return code
    TCHAR    szFullPath[MAX_PATH];  // full path of profile to open
    PTSTR    pProfile;              // pointer to profile name in full path
    DWORD    dwLen;                 // length of color directory string
    DWORD    bSkipMatch;            // true for skipping exact profile matching
    MATCHTYPE match;                // Type of profile match
    PBYTE     pBufferStart;         // Start of user given buffer
    DWORD    dwSizeOfStruct;        // size of ENUMTYPE structure
    DWORD    dwVersion;             // ENUMTYPE structure version

    //
    // Validate parameters
    //

    if (! pdwSize ||
        IsBadWritePtr(pdwSize, sizeof(DWORD)) ||
        (pBuffer && IsBadWritePtr(pBuffer, *pdwSize)) ||
        (pnProfiles && IsBadWritePtr(pnProfiles, sizeof(DWORD))) ||
        ! pEnumRecord ||
        IsBadReadPtr(pEnumRecord, sizeof(DWORD)*3))   // probe until ENUMTYPE.dwFields
    {
ParameterError_InternalEnumColorProfiles:
        WARNING((__TEXT("Invalid parameter to EnumColorProfiles\n")));
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // Check structure size based on its version.
    //

    dwSizeOfStruct = pEnumRecord->dwSize;
    dwVersion      = pEnumRecord->dwVersion;

    if (dwVersion >= ENUM_TYPE_VERSION)
    {
        if (dwSizeOfStruct < sizeof(ENUMTYPE))
            goto ParameterError_InternalEnumColorProfiles;
    }
    else if (dwVersion == 0x0200)
    {
        if (dwSizeOfStruct < sizeof(ENUMTYPE)-sizeof(DWORD))
            goto ParameterError_InternalEnumColorProfiles;

        //
        // Version 2 should not have ET_DEVICECLASS bit
        //

        if (pEnumRecord->dwFields & ET_DEVICECLASS)
            goto ParameterError_InternalEnumColorProfiles;

        WARNING((__TEXT("Old version ENUMTYPE to InternalEnumColorProfiles\n")));
    }
    else
    {
        goto ParameterError_InternalEnumColorProfiles;
    }

    if (IsBadReadPtr(pEnumRecord, dwSizeOfStruct))
    {
        goto ParameterError_InternalEnumColorProfiles;
    }

    //
    // Only local enumerations are allowed now
    //

    if (pMachineName != NULL)
    {
        WARNING((__TEXT("Remote profile enumeration attempted, failing...\n")));
        SetLastError(ERROR_NOT_SUPPORTED);
        return FALSE;
    }

    dwInputSize = *pdwSize;

    //
    // Get color directory
    //

    dwLen = sizeof(szFullPath);
    if (! InternalGetColorDirectory(NULL, szFullPath, &dwLen))
    {
        WARNING((__TEXT("Error getting color directory\n")));
        return FALSE;
    }

    if (szFullPath[lstrlen(szFullPath) - 1] != '\\')
    {
        lstrcat(szFullPath, gszBackslash);
    }
    pProfile = &szFullPath[lstrlen(szFullPath)];
    dwLen = lstrlen(szFullPath) * sizeof(TCHAR);

    //
    // Initialize return parameters
    //

    *pdwSize = 0;
    if (pnProfiles)
        *pnProfiles = 0;

    if (pBuffer && dwInputSize >= sizeof(TCHAR))
    {
        *((PTSTR)pBuffer) = '\0';
    }

    //
    // Check if we are looking for the profiles of a particular device or
    // not because we enumerate them from different places.
    //

    if (pEnumRecord->dwFields & ET_DEVICENAME)
    {
        DWORD *pbSkipMatch = &bSkipMatch;
        DWORD  dwDeviceClass;

        if (! pEnumRecord->pDeviceName)
        {
            WARNING((__TEXT("Invalid parameter to EnumColorProfiles\n")));
            SetLastError(ERROR_INVALID_PARAMETER);
            goto EndEnumerateColorProfiles;
        }

        //
        // Get list of profiles associated with the device. If we don't
        // know what device it is, specify ColorSpace, which tries all three
        //

        if (pEnumRecord->dwFields & ET_DEVICECLASS)
        {
            dwDeviceClass = pEnumRecord->dwDeviceClass;
        }
        else
        {
            dwDeviceClass = CLASS_COLORSPACE;
        }

        //
        // Get the device configuration whether we do exact matching or not.
        //

        dwSize = sizeof(DWORD);
        if (! GetDeviceData(pEnumRecord->pDeviceName, dwDeviceClass, DEVICE_PROFILE_ENUMMODE,
                            (PVOID *)&pbSkipMatch, &dwSize, FALSE))
        {
            bSkipMatch = FALSE;
        }

        //
        // Get the profile data.
        //

        dwSize = 0;
        if (! GetDeviceData(pEnumRecord->pDeviceName, dwDeviceClass, DEVICE_PROFILE_DATA,
                            (PVOID *)&pProfileList, &dwSize, TRUE))
        {
            pProfileList = NULL;    // no data found
        }

        if(! pProfileList)
        {
            //
            // No profiles associated with this device
            //

            rc = TRUE;
            if (pBuffer && dwInputSize >= sizeof(TCHAR)*2)
            {
                *((PTSTR)pBuffer + 1) = '\0';
            }
            goto EndEnumerateColorProfiles;
        }

        //
        // Run through the list of profiles and check each one to see if it
        // matches the enumeration criteria. If it does, and the buffer is
        // large enough, copy it to the buffer, and increment the byte count
        // and number of profiles enumerated.
        //

        pBufferStart = pBuffer;
        pTempProfileList = pProfileList;

        while (*pTempProfileList)
        {
            lstrcpy(pProfile, pTempProfileList);

            if (bSkipMatch)
            {
                match = EXACT_MATCH;
            }
            else
            {
                match = DoesProfileMatchEnumRecord(szFullPath, pEnumRecord);
            }

            if (match != NOMATCH)
            {
                *pdwSize += (lstrlen(pTempProfileList) + 1) * sizeof(TCHAR);

                //
                // Check strictly less than because you need one more for
                // the final NULL termination
                //

                if (pBuffer && (*pdwSize < dwInputSize))
                {
                    if (match == MATCH)
                    {
                        lstrcpy((PTSTR)pBuffer, pTempProfileList);
                    }
                    else
                    {
                        //
                        // Exact match, add to beginning of buffer
                        //

                        InsertInBuffer(pBufferStart, pBuffer, pTempProfileList);
                    }

                    pBuffer += (lstrlen(pTempProfileList) + 1) * sizeof(TCHAR);
                }

                if (pnProfiles)
                    (*pnProfiles)++;
            }

            pTempProfileList += lstrlen(pTempProfileList) + 1;
        }
    }
    else
    {
        DWORD  dwNumClasses;
        PTSTR *ppszEnumClasses;
        PTSTR  pszEnumClassArray[2];

        //
        // We are not looking at a particular device, so enumerate
        // profiles from the registry
        //

        if (pEnumRecord->dwFields & ET_DEVICECLASS)
        {
            //
            // If device class is specified, enumrate the specified device class and color
            // space class which can be associated to any device.
            //

            pszEnumClassArray[0] = ConvertClassIdToClassString(pEnumRecord->dwDeviceClass);
            pszEnumClassArray[1] = ConvertClassIdToClassString(CLASS_COLORSPACE);

            if (!pszEnumClassArray[0] || !pszEnumClassArray[1])
            {
                WARNING((__TEXT("Invalid DeviceClass to EnumColorProfiles\n")));
                SetLastError(ERROR_INVALID_PARAMETER);
                goto EndEnumerateColorProfiles;
            }

            ppszEnumClasses = pszEnumClassArray;
            dwNumClasses    = 2;
        }
        else
        {
            ppszEnumClasses = gpszClasses;
            dwNumClasses    = sizeof(gpszClasses)/sizeof(PTSTR);
        }

        //
        // Open the registry path where profiles are kept (and create it if not exist)
        //

        if ((dwErr = RegCreateKey(HKEY_LOCAL_MACHINE, gszICMRegPath, &hkICM)) != ERROR_SUCCESS)
        {
            WARNING((__TEXT("Cannot open ICM branch of registry: %d\n"), dwErr));
            SetLastError(dwErr);
            goto EndEnumerateColorProfiles;
        }

        pBufferStart = pBuffer;

        for (i=0; i<dwNumClasses; i++,ppszEnumClasses++)
        {
            DWORD   nValues;        // number of name-values in key

            if (RegOpenKey(hkICM, *ppszEnumClasses, &hkDevice) != ERROR_SUCCESS)
            {
                continue;           // go to next key
            }

            if ((dwErr = RegQueryInfoKey(hkDevice, NULL, NULL, 0, NULL, NULL, NULL,
                &nValues, NULL, NULL, NULL, NULL)) != ERROR_SUCCESS)
            {
                WARNING((__TEXT("Cannot count values in device branch of registry: %d\n"), dwErr));
                RegCloseKey(hkDevice);
                SetLastError(dwErr);
                goto EndEnumerateColorProfiles;
            }

            //
            // Go through the list of profiles and return everything that
            // satisfies the enumeration criteria
            //

            for (j=0; j<nValues; j++)
            {
                dwSize = sizeof(szFullPath) - dwLen;
                dwDataSize = sizeof(REGDATA);
                if (RegEnumValue(hkDevice, j, pProfile, &dwSize, 0,
                    NULL, (PBYTE)&regData, &dwDataSize) == ERROR_SUCCESS)
                {
                    match = DoesProfileMatchEnumRecord(szFullPath, pEnumRecord);

                    if (match != NOMATCH)
                    {
                        *pdwSize += (lstrlen(pProfile) + 1) * sizeof(TCHAR);
                        if (pBuffer && (*pdwSize < dwInputSize))
                        {
                            if (match == MATCH)
                            {
                                lstrcpy((PTSTR)pBuffer, pProfile);
                            }
                            else
                            {
                                //
                                // Exact match, add to beginning of buffer
                                //

                                InsertInBuffer(pBufferStart, pBuffer, pProfile);
                            }

                            pBuffer += (lstrlen(pProfile) + 1) * sizeof(TCHAR);
                        }

                        if (pnProfiles)
                            (*pnProfiles)++;
                    }
                }
            }

            RegCloseKey(hkDevice);
        }
    }

    *pdwSize += sizeof(TCHAR);      // extra NULL termination

    if (pBuffer && *pdwSize <= dwInputSize)
    {
        *((PTSTR)pBuffer) = '\0';
        rc = TRUE;
    }
    else
    {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
    }

EndEnumerateColorProfiles:

    if (hkICM)
    {
        RegCloseKey(hkICM);
    }
    if (pProfileList)
    {
        MemFree(pProfileList);
    }

    return rc;
}

VOID
InsertInBuffer(
    PBYTE  pStart,
    PBYTE  pEnd,
    PTSTR  pString
    )
{
    DWORD cnt = (lstrlen(pString) + 1) * sizeof(TCHAR);

    MyCopyMemory(pStart+cnt, pStart, (DWORD)(pEnd - pStart));

    lstrcpy((PTSTR)pStart, pString);

    return;
}

/******************************************************************************
 *
 *                          InternalSetSCSProfile
 *
 *  Function:
 *       These functions regsiters the given profile for the standard color
 *       space specified. This will register it in the OS and can be queried
 *       using GetStandardColorSpaceProfile.
 *
 *  Arguments:
 *       pMachineName    - name identifying machine on which the standard color
 *                         space profile should be registered
 *       dwSCS           - ID for the standard color space
 *       pProfileName    - pointer to profile filename
 *
 *  Returns:
 *       TRUE if successful, NULL otherwise
 *
 *  Warning:
 *       Currently only local registration is supported, so pMachineName should
 *       be NULL.
 *
 ******************************************************************************/

BOOL
InternalSetSCSProfile(
    LPCTSTR   pMachineName,
    DWORD     dwSCS,
    LPCTSTR   pProfileName
    )
{
    HKEY   hkICM = NULL;            // key to ICM branch in registry
    HKEY   hkRegProf = NULL;        // key to registered color spaces branch
    DWORD  dwSize;                  // size of registry data
    DWORD  dwErr;                   // error code
    BOOL   rc = FALSE;              // return code
    TCHAR  szProfileID[5];          // profile class

    //
    // Validate parameters
    //

    if (!pProfileName)
    {
        WARNING((__TEXT("Invalid parameter to SetStandardColorSpaceProfile\n")));
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // Only local registration is allowed now
    //

    if (pMachineName != NULL)
    {
        WARNING((__TEXT("Remote SCS profile registration attempted, failing...\n")));
        SetLastError(ERROR_NOT_SUPPORTED);
        return FALSE;
    }

    dwSize = (lstrlen(pProfileName) + 1) * sizeof(TCHAR);

    //
    // Open the registry location where this is kept
    //

    if (((dwErr = RegCreateKey(HKEY_LOCAL_MACHINE, gszICMRegPath, &hkICM)) == ERROR_SUCCESS) &&
        ((dwErr = RegCreateKey(hkICM, gszRegisteredProfiles, &hkRegProf))== ERROR_SUCCESS))
    {
        ConvertDwordToString(dwSCS, szProfileID);

        if ((dwErr = RegSetValueEx(hkRegProf, szProfileID, 0, REG_SZ,
            (PBYTE)pProfileName, dwSize)) == ERROR_SUCCESS)
        {
            rc = TRUE;
        }
    }

    if (hkICM)
    {
        RegCloseKey(hkICM);
    }

    if (hkRegProf)
    {
        RegCloseKey(hkRegProf);
    }

    if (!rc)
    {
        WARNING((__TEXT("InternalSetSCSProfile failed: %d\n"), dwErr));
        SetLastError(dwErr);
    }

    return rc;
}


/******************************************************************************
 *
 *                          InternalGetSCSProfile
 *
 *  Function:
 *       These functions retrieves the profile regsitered for the standard color
 *       space specified.
 *
 *  Arguments:
 *       pMachineName    - name identifying machine on which the standard color
 *                         space profile should be queried
 *       dwSCS           - ID for the standard color space
 *       pBuffer         - pointer to buffer to receive profile filename
 *       pdwSize         - pointer to DWORD specifying size of buffer. On return
 *                         it has size needed/used
 *
 *  Returns:
 *       TRUE if successful, NULL otherwise
 *
 *  Warning:
 *       Currently only local query is supported, so pMachineName should
 *       be NULL.
 *
 ******************************************************************************/

BOOL
InternalGetSCSProfile(
    LPCTSTR   pMachineName,
    DWORD     dwSCS,
    PTSTR     pBuffer,
    PDWORD    pdwSize
    )
{
    HKEY   hkICM = NULL;            // key to ICM branch in registry
    HKEY   hkRegProf = NULL;        // key to registered color spaces branch
    DWORD  dwErr;                   // error code
    DWORD  dwSize;
    BOOL   rc = FALSE;              // return code
    TCHAR  szProfileID[5];          // profile class

    //
    // Validate parameters
    //

    if (! pdwSize ||
        IsBadWritePtr(pdwSize, sizeof(DWORD)) ||
        (pBuffer && IsBadWritePtr(pBuffer, *pdwSize)))
    {
        WARNING((__TEXT("Invalid parameter to GetStandardColorSpaceProfile\n")));
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // Only local query is allowed now
    //

    if (pMachineName != NULL)
    {
        WARNING((__TEXT("Remote SCS profile query attempted, failing...\n")));
        SetLastError(ERROR_NOT_SUPPORTED);
        return FALSE;
    }

    dwSize = *pdwSize;

    //
    // Look in the registry for a profile registered for this color space ID
    //

    if (((dwErr = RegOpenKey(HKEY_LOCAL_MACHINE, gszICMRegPath, &hkICM)) == ERROR_SUCCESS) &&
        ((dwErr = RegOpenKey(hkICM, gszRegisteredProfiles, &hkRegProf)) == ERROR_SUCCESS))
    {
        ConvertDwordToString(dwSCS, szProfileID);
        if ((dwErr = RegQueryValueEx(hkRegProf, szProfileID, NULL, NULL,
                (PBYTE)pBuffer, pdwSize)) == ERROR_SUCCESS)
        {
            rc = TRUE;
        }
    }

    if (hkICM)
    {
        RegCloseKey(hkICM);
    }

    if (hkRegProf)
    {
        RegCloseKey(hkRegProf);
    }

    if (!rc && (dwSCS == LCS_sRGB || dwSCS == LCS_WINDOWS_COLOR_SPACE))
    {
        *pdwSize = dwSize;
        rc = GetColorDirectory(NULL, pBuffer, pdwSize);
        if (!rc && GetLastError() != ERROR_INSUFFICIENT_BUFFER)
        {
            return FALSE;
        }

        *pdwSize += (lstrlen(gszBackslash) + lstrlen(gszsRGBProfile)) * sizeof(TCHAR);

        if (*pdwSize <= dwSize && pBuffer)
        {
            lstrcat(pBuffer, gszBackslash);
            lstrcat(pBuffer, gszsRGBProfile);
            rc = TRUE;
        }
        else
        {
            dwErr = ERROR_INSUFFICIENT_BUFFER;
        }
    }

    if (!rc)
    {
        WARNING((__TEXT("InternalGetSCSProfile failed: %d\n"), dwErr));
        SetLastError(dwErr);
    }

    //
    // If pBuffer is NULL, RegQueryValueEx return TRUE. Our API should return FALSE
    // in this case. Handle this.
    //

    if (pBuffer == NULL && rc)
    {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        rc = FALSE;
    }

    return rc;
}


/******************************************************************************
 *
 *                           ConvertDwordToString
 *
 *  Function:
 *       This function converts a DWORD into a string. The string passed in
 *       is large enough. It converts to Unicode or Ansi depending on how
 *       this is compiled.
 *
 *  Arguments:
 *       dword           - DWORD to convert
 *       pString         - pointer to buffer to hold the result
 *
 *  Returns:
 *       Nothing
 *
 ******************************************************************************/

VOID
ConvertDwordToString(
    DWORD  dword,
    PTSTR  pString
    )
{
    int i;                          // counter

    for (i=0; i<4; i++)
    {
        pString[i]  = (TCHAR)(((char*)&dword)[3-i]);
    }

    pString[4] = '\0';

    return;
}

/******************************************************************************
 *
 *                           ConvertClassIdToClassString
 *
 *  Function:
 *       This function converts a DWORD Device Class Id into a its device string
 *
 *  Arguments:
 *       dwClassId      - Device class id.
 *
 *  Returns:
 *       pointer to a string
 *
 ******************************************************************************/

PTSTR
ConvertClassIdToClassString(
    DWORD  dwClassId
    )
{
    switch (dwClassId)
    {
    case CLASS_MONITOR:
        return (gpszClasses[INDEX_CLASS_MONITOR]);
    case CLASS_PRINTER:
        return (gpszClasses[INDEX_CLASS_PRINTER]);
    case CLASS_SCANNER:
        return (gpszClasses[INDEX_CLASS_SCANNER]);
    case CLASS_COLORSPACE:
        return (gpszClasses[INDEX_CLASS_COLORSPACE]);
    default:
        return NULL;
    }
}

/******************************************************************************
 *
 *                          GetProfileClassString
 *
 *  Function:
 *       This function returns the profile class from the header as a string.
 *       It also validates the profile.
 *
 *  Arguments:
 *       pProfileName    - name of profile
 *       pClass          - pointer to buffer to hold the profile class string
 *       pHeader         - if this is non NULL, it returns the header here
 *
 *  Returns:
 *       TRUE on success, FALSE otherwise
 *
 ******************************************************************************/

BOOL
GetProfileClassString(
    LPCTSTR        pProfileName,
    PTSTR          pClass,
    PPROFILEHEADER pHeader
    )
{
    PROFILEHEADER header;                // color profile header
    PROFILE       prof;                  // profile object for opening profile
    HPROFILE      hProfile = NULL;       // handle to opened profile
    BOOL          bValidProfile = FALSE; // validation of the profile
    BOOL          rc = FALSE;            // return code

    //
    // Open a handle to the profile
    //

    prof.dwType = PROFILE_FILENAME;
    prof.pProfileData = (PVOID)pProfileName;
    prof.cbDataSize = (lstrlen(pProfileName) + 1) * sizeof(TCHAR);

    hProfile = OpenColorProfile(&prof, PROFILE_READ, FILE_SHARE_READ,
                    OPEN_EXISTING);
    if (! hProfile)
    {
        WARNING((__TEXT("Error opening profile %s\n"), pProfileName));
        goto EndGetProfileClassString;
    }

    //
    // Check the validation of the profile.
    //
    if (! IsColorProfileValid(hProfile,&bValidProfile) || ! bValidProfile)
    {
        WARNING((__TEXT("Error invalid profile %s\n"), pProfileName));
        goto EndGetProfileClassString;
    }

    //
    // Get the profile class
    //

    if (! pHeader)
    {
        pHeader = &header;
    }

    if (! GetColorProfileHeader(hProfile, pHeader))
    {
        ERR((__TEXT("Error getting color profile header for %s\n"), pProfileName));
        goto EndGetProfileClassString;
    }
    ConvertDwordToString(pHeader->phClass, pClass);

    rc= TRUE;

EndGetProfileClassString:
    if (hProfile)
    {
        CloseColorProfile(hProfile);
    }

    return rc;
}


/******************************************************************************
 *
 *                           GetFilenameFromPath
 *
 *  Function:
 *       This function takes a fully qualified pathname and returns a pointer
 *       to the filename part alone
 *
 *  Arguments:
 *       pPathName       - pointer to pathname
 *
 *  Returns:
 *       Pointer to filename on success, NULL otherwise
 *
 ******************************************************************************/

PTSTR
GetFilenameFromPath(
    PTSTR pPathName
    )
{
    DWORD dwLen;                      // length of pathname
    PTSTR pPathNameStart = pPathName;

    dwLen = lstrlen(pPathName);

    if (dwLen == 0)
    {
        return NULL;
    }

    //
    // Go to the end of the pathname, and start going backwards till
    // you reach the beginning or a backslash
    //

    pPathName += dwLen;

    //
    // Currently 'pPathName' points null-terminate character, so move
    // the pointer to last character.
    //

    do
    {
        pPathName = CharPrev(pPathNameStart,pPathName);

        if (*pPathName == TEXT('\\'))
        {
            pPathName = CharNext(pPathName);
            break;
        }

        //
        // Loop until fist
        //

    } while (pPathNameStart < pPathName);

    //
    // if *pPathName is zero, then we had a string that ends in a backslash
    //

    return *pPathName ? pPathName : NULL;
}


/******************************************************************************
 *
 *                              GetDeviceData
 *
 *  Function:
 *       This function is a wrapper for IGetDeviceData. For devices like monitor,
 *       printer & scanner it calls the internal function. If we are asked
 *       to get the device data for a "colorspace device", we try monitor, printer
 *       and scanner till one succeeds or they all fail. This is done so that we
 *       we can associate sRGB like profiles with any device.
 *
 *  Arguments:
 *       pDeviceName     - pointer to name of the device
 *       dwClass         - device type like monitor, printer etc.
 *       ppDeviceData    - pointer to pointer to buffer to receive data
 *       pdwSize         - pointer to size of buffer. On return it is size of
 *                         data returned/size needed.
 *       bAllocate       - If TRUE, allocate memory for data
 *
 *  Returns:
 *       TRUE if successful, FALSE otherwise
 *
 ******************************************************************************/

BOOL
GetDeviceData(
    LPCTSTR pDeviceName,
    DWORD   dwClass,
    DWORD   dwDataType,
    PVOID  *ppDeviceData,
    PDWORD  pdwSize,
    BOOL    bAllocate
    )
{
    BOOL rc = FALSE;

    if (dwClass == CLASS_MONITOR ||
        dwClass == CLASS_PRINTER ||
        dwClass == CLASS_SCANNER)
    {
        rc = IGetDeviceData(pDeviceName, dwClass, dwDataType, ppDeviceData, pdwSize, bAllocate);
    }
    else if (dwClass == CLASS_COLORSPACE)
    {
        rc = IGetDeviceData(pDeviceName, CLASS_MONITOR, dwDataType, ppDeviceData, pdwSize, bAllocate) ||
             IGetDeviceData(pDeviceName, CLASS_PRINTER, dwDataType, ppDeviceData, pdwSize, bAllocate) ||
             IGetDeviceData(pDeviceName, CLASS_SCANNER, dwDataType, ppDeviceData, pdwSize, bAllocate);
    }

    return rc;
}


/******************************************************************************
 *
 *                              IGetDeviceData
 *
 *  Function:
 *       This function retrieves ICM data stored with the different devices.
 *
 *  Arguments:
 *       pDeviceName     - pointer to name of the device
 *       dwClass         - device type like monitor, printer etc.
 *       ppDeviceData    - pointer to pointer to buffer to receive data
 *       pdwSize         - pointer to size of buffer. On return it is size of
 *                         data returned/size needed.
 *       bAllocate       - If TRUE, allocate memory for data
 *
 *  Returns:
 *       TRUE if successful, FALSE otherwise
 *
 ******************************************************************************/

BOOL
IGetDeviceData(
    LPCTSTR pDeviceName,
    DWORD   dwClass,
    DWORD   dwDataType,
    PVOID  *ppDeviceData,
    PDWORD  pdwSize,
    BOOL    bAllocate
    )
{
    PFNOPENDEVICE    fnOpenDevice;
    PFNCLOSEDEVICE   fnCloseDevice;
    PFNGETDEVICEDATA fnGetData;
    HANDLE           hDevice;
    DWORD            dwSize;
    LPTSTR           pDataKey;
    LPTSTR           pDataValue;
    BOOL             rc = FALSE;

    //
    // Set up function pointers so we can write common code
    //

    switch (dwClass)
    {
    case CLASS_PRINTER:
        fnOpenDevice  = (PFNOPENDEVICE)OpenPrtr;
        fnCloseDevice = (PFNCLOSEDEVICE)ClosePrtr;
        fnGetData     = (PFNGETDEVICEDATA)GetPrtrData;
        break;

    case CLASS_MONITOR:
        fnOpenDevice  = (PFNOPENDEVICE)OpenMonitor;
        fnCloseDevice = (PFNCLOSEDEVICE)CloseMonitor;
        fnGetData     = (PFNGETDEVICEDATA)GetMonitorData;
        break;

    case CLASS_SCANNER:
        fnOpenDevice  = (PFNOPENDEVICE)OpenScanner;
        fnCloseDevice = (PFNCLOSEDEVICE)CloseScanner;
        fnGetData     = (PFNGETDEVICEDATA)GetScannerData;
        break;

    default:
        return FALSE;
    }

    //
    // Set up registry keywords.
    //

    switch (dwDataType)
    {
    case DEVICE_PROFILE_DATA:

        pDataKey      = gszICMProfileListKey;

        //
        // The way to store printer profile is different than others... trim it.
        //

        if (dwClass == CLASS_PRINTER)
        {
            pDataValue = gszFiles;
        }
        else
        {
            pDataValue = gszICMProfileListValue;
        }

        break;

    case DEVICE_PROFILE_ENUMMODE:

        pDataKey      = gszICMDeviceDataKey;
        pDataValue    = gszICMProfileEnumMode;
        break;

    default:
        return FALSE;
    }

    //
    // Open the device and get a handle to it
    //

    if (! (*fnOpenDevice)((PTSTR)pDeviceName, &hDevice, NULL))
    {
        return FALSE;
    }

    if (bAllocate || (ppDeviceData == NULL))
    {
        DWORD retcode;

        //
        // We need to allocate memory. Find out how much we need, and
        // allocate it.
        //

        dwSize = 0;
        retcode = (*fnGetData)(hDevice, pDataKey, pDataValue, NULL, NULL, 0, &dwSize);

        if ((retcode != ERROR_SUCCESS)    &&  // Win 95 returns this
            (retcode != ERROR_MORE_DATA))     // NT returns this
        {
            VERBOSE((__TEXT("GetDeviceData failed for %s\n"), pDeviceName));
            goto EndGetDeviceData;
        }

        *pdwSize = dwSize;

        if (ppDeviceData == NULL)
        {
            //
            // Caller wants to know the data size.
            //

            rc = TRUE;
            goto EndGetDeviceData;
        }
        else
        {
            //
            // Allocate buffer.
            //

            *ppDeviceData = MemAlloc(dwSize);
            if (! *ppDeviceData)
            {
                WARNING((__TEXT("Error allocating memory\n")));
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                goto EndGetDeviceData;
            }
        }
    }

    //
    // Get the data
    //

    if ((*fnGetData)(hDevice, pDataKey, pDataValue, NULL, (PBYTE)*ppDeviceData,
        *pdwSize, pdwSize) == ERROR_SUCCESS)
    {
        rc = TRUE;
    }

EndGetDeviceData:
    (*fnCloseDevice)(hDevice);

    return rc;
}


/******************************************************************************
 *
 *                              SetDeviceData
 *
 *  Function:
 *       This function is a wrapper for ISetDeviceData. For devices like monitor,
 *       printer & scanner it calls the internal function. If we are asked
 *       to set the device data for a "colorspace device", we try monitor, printer
 *       and scanner till one succeeds or they all fail. This is done so that we
 *       we can associate sRGB like profiles with any device.
 *
 *  Arguments:
 *       pDeviceName     - pointer to name of the device
 *       dwClass         - device type like monitor, printer etc.
 *       pDeviceData     - pointer buffer containing data
 *       dwSize          - size of data
 *
 *  Returns:
 *       TRUE if successful, FALSE otherwise
 *
 ******************************************************************************/

BOOL
SetDeviceData(
    LPCTSTR pDeviceName,
    DWORD   dwClass,
    DWORD   dwDataType,
    PVOID   pDeviceData,
    DWORD   dwSize
    )
{
    BOOL rc = FALSE;

    if (dwClass == CLASS_MONITOR ||
        dwClass == CLASS_PRINTER ||
        dwClass == CLASS_SCANNER)
    {
        rc = ISetDeviceData(pDeviceName, dwClass, dwDataType, pDeviceData, dwSize);
    }
    else if (dwClass == CLASS_COLORSPACE)
    {
        rc = ISetDeviceData(pDeviceName, CLASS_MONITOR, dwDataType, pDeviceData, dwSize) ||
             ISetDeviceData(pDeviceName, CLASS_PRINTER, dwDataType, pDeviceData, dwSize) ||
             ISetDeviceData(pDeviceName, CLASS_SCANNER, dwDataType, pDeviceData, dwSize);
    }

    return rc;
}


/******************************************************************************
 *
 *                              ISetDeviceData
 *
 *  Function:
 *       This function sets ICM data stored with the different devices.
 *
 *  Arguments:
 *       pDeviceName     - pointer to name of the device
 *       dwClass         - device type like monitor, printer etc.
 *       pDeviceData     - pointer buffer containing data
 *       dwSize          - size of data
 *
 *  Returns:
 *       TRUE if successful, FALSE otherwise
 *
 ******************************************************************************/

BOOL
ISetDeviceData(
    LPCTSTR pDeviceName,
    DWORD   dwClass,
    DWORD   dwDataType,
    PVOID   pDeviceData,
    DWORD   dwSize
    )
{
    PRINTER_DEFAULTS    pd;
    PFNOPENDEVICE       fnOpenDevice;
    PFNCLOSEDEVICE      fnCloseDevice;
    PFNSETDEVICEDATA    fnSetData;
    HANDLE              hDevice;
    LPTSTR              pDataKey;
    LPTSTR              pDataValue;
    DWORD               dwRegType = REG_BINARY;
    BOOL                rc = FALSE;

    //
    // Set up function pointers so we can write common code
    //

    switch (dwClass)
    {
    case CLASS_PRINTER:
        fnOpenDevice  = (PFNOPENDEVICE)OpenPrtr;
        fnCloseDevice = (PFNCLOSEDEVICE)ClosePrtr;
        fnSetData     = (PFNSETDEVICEDATA)SetPrtrData;
        pd.pDatatype  = __TEXT("RAW");
        pd.pDevMode   = NULL;
        pd.DesiredAccess = PRINTER_ACCESS_ADMINISTER;
        break;

    case CLASS_MONITOR:
        fnOpenDevice  = (PFNOPENDEVICE)OpenMonitor;
        fnCloseDevice = (PFNCLOSEDEVICE)CloseMonitor;
        fnSetData     = (PFNSETDEVICEDATA)SetMonitorData;
        break;

    case CLASS_SCANNER:
        fnOpenDevice  = (PFNOPENDEVICE)OpenScanner;
        fnCloseDevice = (PFNCLOSEDEVICE)CloseScanner;
        fnSetData     = (PFNSETDEVICEDATA)SetScannerData;
        break;

    default:
        return FALSE;
    }

    //
    // Set up registry keywords.
    //

    switch (dwDataType)
    {
    case DEVICE_PROFILE_DATA:

        pDataKey      = gszICMProfileListKey;

        //
        // The way to store printer profile is different than others... trim it.
        //

        if (dwClass == CLASS_PRINTER)
        {
            pDataValue = gszFiles;
            dwRegType  = REG_MULTI_SZ;
        }
        else
        {
            pDataValue = gszICMProfileListValue;
        }

        break;

    case DEVICE_PROFILE_ENUMMODE:

        pDataKey      = gszICMDeviceDataKey;
        pDataValue    = gszICMProfileEnumMode;
        break;

    default:
        return FALSE;
    }

    //
    // Open the device and get a handle to it
    //

    if (! (*fnOpenDevice)((PTSTR)pDeviceName, &hDevice, (PTSTR)&pd))
    {
        WARNING((__TEXT("Error opening device %s\n"), pDeviceName));
        return FALSE;
    }

    //
    // Set the data
    //

    if ((*fnSetData)(hDevice, pDataKey, pDataValue, dwRegType, (PBYTE)pDeviceData,
                     dwSize) == ERROR_SUCCESS)
    {
        rc = TRUE;
    }

#if !defined(_WIN95_)

    //
    // If this is printer class, need some more data for profile list.
    //

    if ((rc == TRUE) && (dwClass == CLASS_PRINTER) && (dwDataType == DEVICE_PROFILE_DATA))
    {
        if (((*fnSetData)(hDevice, pDataKey, gszDirectory, REG_SZ, (PBYTE)gszColorDir,
                          (lstrlen(gszColorDir) + 1)*sizeof(TCHAR)) != ERROR_SUCCESS) ||
            ((*fnSetData)(hDevice, pDataKey, gszModule, REG_SZ, (PBYTE)gszMSCMS,
                          (lstrlen(gszMSCMS) + 1)*sizeof(TCHAR)) != ERROR_SUCCESS))
        {
            rc = FALSE;
        }
    }

#endif

    (*fnCloseDevice)(hDevice);

    return rc;
}


/******************************************************************************
 *
 *                              IsStringInMultiSz
 *
 *  Function:
 *       This functions checks if a given multi-sz string has the given string
 *       as one of the strings, and returns TRUE if it does.
 *
 *  Arguments:
 *       pMultiSzString - multi sz string to look in
 *       pString        - string to find
 *
 *  Returns:
 *       TRUE
 *
 ******************************************************************************/

BOOL
IsStringInMultiSz(
    PTSTR pMultiSzString,
    PTSTR pString
    )
{
    BOOL rc = FALSE;                // return code

    while (*pMultiSzString)
    {
        if (! lstrcmpi(pMultiSzString, pString))
        {
            rc = TRUE;
            break;
        }

        pMultiSzString += lstrlen(pMultiSzString) + 1;
    }

    return rc;
}


/******************************************************************************
 *
 *                            RemoveStringFromMultiSz
 *
 *  Function:
 *       This functions removes a given string from a multi-sz string.
 *
 *  Arguments:
 *       pMultiSzString - multi sz string to look in
 *       pString        - string to remove
 *       dwSize         - size in bytes of multi-sz string
 *
 *  Returns:
 *       TRUE
 *
 ******************************************************************************/

DWORD
RemoveStringFromMultiSz(
    PTSTR pMultiSzString,
    PTSTR pString,
    DWORD dwSize
    )
{
    DWORD dwCount = dwSize;         // count of bytes remaining

    while (*pMultiSzString)
    {
        dwCount -= (lstrlen(pMultiSzString) + 1) * sizeof(TCHAR);

        if (! lstrcmpi(pMultiSzString, pString))
        {
            break;
        }

        pMultiSzString += lstrlen(pMultiSzString) + 1;
    }

    MyCopyMemory((PBYTE)pMultiSzString, (PBYTE)(pMultiSzString + lstrlen(pString) + 1), dwCount);

    return dwSize - sizeof(TCHAR) * (lstrlen(pString) + 1);
}


/******************************************************************************
 *
 *                           DoesProfileMatchEnumRecord
 *
 *  Function:
 *       This functions checks if a profile matches the criteria given in
 *       the enumeration record. Note that it does not check if the profile
 *       belongs to the device specified by pDeviceName. So that check must
 *       have happened before itself.
 *
 *  Arguments:
 *       pProfileName   - profile to look at
 *       pEnumRecord    - pointer to criteria to check against
 *
 *  Returns:
 *       MATCH or EXACT_MATCH if the profile matches the criteria, NOMATCH otherwise
 *
 ******************************************************************************/

#define SET(pEnumRecord, bit)        ((pEnumRecord)->dwFields & (bit))

MATCHTYPE
DoesProfileMatchEnumRecord(
    PTSTR     pProfileName,
    PENUMTYPE pEnumRecord
    )
{
    PROFILEHEADER header;           // color profile header
    PROFILE       prof;             // profile object for opening profile
    HPROFILE      hProfile = NULL;  // handle to opened profile
    MATCHTYPE     rc = NOMATCH;     // return code

    //
    // Open a handle to the profile
    //

    prof.dwType = PROFILE_FILENAME;
    prof.pProfileData = (PVOID)pProfileName;
    prof.cbDataSize = (lstrlen(pProfileName) + 1) * sizeof(TCHAR);

    hProfile = OpenColorProfile(&prof, PROFILE_READ, FILE_SHARE_READ,
                    OPEN_EXISTING);
    if (! hProfile)
    {
        WARNING((__TEXT("Error opening profile %s\n"), pProfileName));
        goto EndDoesProfileMatchEnumRecord;
    }

    //
    // Get the profile header
    //

    if (! GetColorProfileHeader(hProfile, &header))
    {
        ERR((__TEXT("Error getting color profile header for %s\n"), pProfileName));
        goto EndDoesProfileMatchEnumRecord;
    }

    if ((!SET(pEnumRecord, ET_CMMTYPE)         || (pEnumRecord->dwCMMType         == header.phCMMType))         &&
        (!SET(pEnumRecord, ET_CLASS)           || (pEnumRecord->dwClass           == header.phClass))           &&
        (!SET(pEnumRecord, ET_DATACOLORSPACE)  || (pEnumRecord->dwDataColorSpace  == header.phDataColorSpace))  &&
        (!SET(pEnumRecord, ET_CONNECTIONSPACE) || (pEnumRecord->dwConnectionSpace == header.phConnectionSpace)) &&
        (!SET(pEnumRecord, ET_SIGNATURE)       || (pEnumRecord->dwSignature       == header.phSignature))       &&
        (!SET(pEnumRecord, ET_PLATFORM)        || (pEnumRecord->dwPlatform        == header.phPlatform))        &&
        (!SET(pEnumRecord, ET_PROFILEFLAGS)    || (pEnumRecord->dwProfileFlags    == header.phProfileFlags))    &&
        (!SET(pEnumRecord, ET_MANUFACTURER)    || (pEnumRecord->dwManufacturer    == header.phManufacturer))    &&
        (!SET(pEnumRecord, ET_MODEL)           || (pEnumRecord->dwModel           == header.phModel))           &&
        (!SET(pEnumRecord, ET_ATTRIBUTES)      || (pEnumRecord->dwAttributes[0]   == header.phAttributes[0] &&
                                                   pEnumRecord->dwAttributes[1]   == header.phAttributes[1]))   &&
        (!SET(pEnumRecord, ET_RENDERINGINTENT) || (pEnumRecord->dwRenderingIntent == header.phRenderingIntent)) &&
        (!SET(pEnumRecord, ET_CREATOR)         || (pEnumRecord->dwCreator         == header.phCreator)))
    {
        rc = EXACT_MATCH;
    }

    //
    // Check for resolution, media type and halftoning match
    //

    if (rc != NOMATCH && SET(pEnumRecord, ET_RESOLUTION|ET_MEDIATYPE|ET_DITHERMODE))
    {
        rc = CheckResMedHftnMatch(hProfile, pEnumRecord);
    }

EndDoesProfileMatchEnumRecord:
    if (hProfile)
    {
        CloseColorProfile(hProfile);
    }

    return rc;
}


/******************************************************************************
 *
 *                           CheckResMedHftnMatch
 *
 *  Function:
 *       This functions checks if a profile matches the resolution,
 *       media type and halftoning criteria specified by the enumeration record.
 *       It allows an exact match, as well as an ambiguous match. If the
 *       profile doesn't specify the criteria, it is considered to ambiguously
 *       match the specification.
 *       is desired.
 *
 *  Arguments:
 *       hProfile       - handle identifying profile
 *       pEnumRecord    - pointer to criteria to check against
 *
 *  Returns:
 *       MATCH or EXACT_MATCH if the profile matches the criteria, NOMATCH otherwise
 *
 ******************************************************************************/

MATCHTYPE
CheckResMedHftnMatch(
    HPROFILE   hProfile,
    PENUMTYPE  pEnumRecord
    )
{
    PDEVICESETTINGS   pDevSettings = NULL;
    PPLATFORMENTRY    pPlatform;
    PSETTINGCOMBOS    pCombo;
    PSETTINGS         pSetting;
    DWORD             dwMSData[4];
    DWORD             dwSize, i, iMax, j, jMax;
    MATCHTYPE         rc = MATCH;       // Assume ambiguous match
    BOOL              bReference;

    //
    // Check if the profile has the new device settings tag
    //

    dwSize = 0;
    GetColorProfileElement(hProfile, TAG_DEVICESETTINGS, 0, &dwSize, NULL, &bReference);

    if (dwSize > 0)
    {
        if (!(pDevSettings = (PDEVICESETTINGS)GlobalAllocPtr(GHND, dwSize)))
        {
            WARNING((__TEXT("Error allocating memory\n")));
            return NOMATCH;
        }

        if (GetColorProfileElement(hProfile, TAG_DEVICESETTINGS, 0, &dwSize, (PBYTE)pDevSettings, &bReference))
        {
            pPlatform = &pDevSettings->PlatformEntry[0];

            //
            // Navigate to the place where Microsoft specific settings are kept
            //

            i = 0;
            iMax = FIX_ENDIAN(pDevSettings->nPlatforms);
            while ((i < iMax) && (pPlatform->PlatformID != ID_MSFT_REVERSED))

            {
                i++;
                pPlatform = (PPLATFORMENTRY)((PBYTE)pPlatform + FIX_ENDIAN(pPlatform->dwSize));
            }

            if (i >= iMax)
            {
                //
                // There are no MS specific settings, assume this profile is valid
                // for all settings (ambigous match)
                //

                goto EndCheckResMedHftnMatch;
            }

            //
            // Found MS specific data. Now go through each combination of settings
            //

            pCombo = &pPlatform->SettingCombos[0];
            iMax = FIX_ENDIAN(pPlatform->nSettingCombos);
            for (i=0; i<iMax; i++)
            {
                //
                // Go through each setting in the combination
                //

                pSetting = &pCombo->Settings[0];
                jMax = FIX_ENDIAN(pCombo->nSettings);
                for (j=0; j<jMax; j++)
                {
                    if (pSetting->dwSettingType == ID_MEDIATYPE_REVERSED)
                    {
                        if (SET(pEnumRecord, ET_MEDIATYPE) &&
                            !DwordMatches(pSetting, pEnumRecord->dwMediaType))
                        {
                            goto NextCombo;
                        }
                    }
                    else if (pSetting->dwSettingType == ID_DITHER_REVERSED)
                    {
                        if (SET(pEnumRecord, ET_DITHERMODE) &&
                            !DwordMatches(pSetting, pEnumRecord->dwDitheringMode))
                        {
                            goto NextCombo;
                        }
                    }
                    else if (pSetting->dwSettingType == ID_RESLN_REVERSED)
                    {
                        if (SET(pEnumRecord, ET_RESOLUTION) &&
                            !QwordMatches(pSetting, &pEnumRecord->dwResolution[0]))
                        {
                            goto NextCombo;
                        }
                    }

                    pSetting = (PSETTINGS)((PBYTE)pSetting + sizeof(SETTINGS) - sizeof(DWORD) +
                                        FIX_ENDIAN(pSetting->dwSizePerValue) * FIX_ENDIAN(pSetting->nValues));
                }

                //
                // This combination worked!
                //

                rc = EXACT_MATCH;
                goto EndCheckResMedHftnMatch;

            NextCombo:
                pCombo = (PSETTINGCOMBOS)((PBYTE)pCombo + FIX_ENDIAN(pCombo->dwSize));
            }

            rc = NOMATCH;
            goto EndCheckResMedHftnMatch;

        }
        else
        {
            rc = NOMATCH;
            goto EndCheckResMedHftnMatch;
        }
    }
    else
    {
        //
        // Check if the old MSxx tags are present
        //

        dwSize = sizeof(dwMSData);
        if (SET(pEnumRecord, ET_MEDIATYPE))
        {
            if (GetColorProfileElement(hProfile, TAG_MS01, 0, &dwSize, dwMSData, &bReference))
            {
                rc = EXACT_MATCH;       // Assume exact match

                if (pEnumRecord->dwMediaType != FIX_ENDIAN(dwMSData[2]))
                {
                    return NOMATCH;
                }
            }
        }

        dwSize = sizeof(dwMSData);
        if (SET(pEnumRecord, ET_DITHERMODE))
        {
            if (GetColorProfileElement(hProfile, TAG_MS02, 0, &dwSize, dwMSData, &bReference))
            {
                rc = EXACT_MATCH;       // Assume exact match

                if (pEnumRecord->dwDitheringMode != FIX_ENDIAN(dwMSData[2]))
                {
                    return NOMATCH;
                }
            }
        }

        dwSize = sizeof(dwMSData);
        if (SET(pEnumRecord, ET_RESOLUTION))
        {
            if (GetColorProfileElement(hProfile, TAG_MS03, 0, &dwSize, dwMSData, &bReference))
            {
                rc = EXACT_MATCH;       // Assume exact match

                if (pEnumRecord->dwResolution[0] != FIX_ENDIAN(dwMSData[2]) ||
                    pEnumRecord->dwResolution[1] != FIX_ENDIAN(dwMSData[3]))
                {
                    return NOMATCH;
                }
            }
        }
    }

EndCheckResMedHftnMatch:

    if (pDevSettings)
    {
        GlobalFreePtr(pDevSettings);
    }

    return rc;
}


BOOL
DwordMatches(
    PSETTINGS    pSetting,
    DWORD        dwValue
    )
{
    DWORD  i, iMax;
    PDWORD pValue;

    dwValue = FIX_ENDIAN(dwValue);  // so we don't have to do this in the loop

    //
    // Go through all the values. If any of them match, return TRUE.
    //

    pValue = &pSetting->Value[0];
    iMax = FIX_ENDIAN(pSetting->nValues);
    for (i=0; i<iMax; i++)
    {
        if (dwValue == *pValue)
        {
            return TRUE;
        }

        pValue++;                   // We know that it is a DWORD
    }

    return FALSE;
}


BOOL
QwordMatches(
    PSETTINGS    pSetting,
    PDWORD       pdwValue
    )
{
    DWORD  i, iMax, dwValue1, dwValue2;
    PDWORD pValue;

    dwValue1 = FIX_ENDIAN(*pdwValue);  // so we don't have to do this in the loop
    dwValue2 = FIX_ENDIAN(*(pdwValue+1));

    //
    // Go through all the values. If any of them match, return TRUE.
    //

    pValue = &pSetting->Value[0];
    iMax = FIX_ENDIAN(pSetting->nValues);
    for (i=0; i<iMax; i++)
    {
        if ((dwValue1 == *pValue) && (dwValue2 == *(pValue + 1)))
        {
            return TRUE;
        }

        pValue += 2;                   // We know that it is a QWORD
    }

    return FALSE;
}


/******************************************************************************
 *
 *                              OpenPrtr
 *
 *  Function:
 *       On Memphis, we cannot call OpenPrinter() because it calls into 16-bit
 *       code, so if we call this function from GDI-16, we deadlock. So we
 *       look into the registry directly.
 *
 *  Arguments:
 *       pDeviceName     - pointer to name of the device
 *       phDevice        - pointer that receives the handle.
 *       pDummy          - dummy parameter
 *
 *  Returns:
 *       TRUE if successful, FALSE otherwise
 *
 ******************************************************************************/

BOOL WINAPI
OpenPrtr(
    PTSTR    pDeviceName,
    LPHANDLE phDevice,
    PTSTR    pDummy
    )
{
#if !defined(_WIN95_)
    return OpenPrinter(pDeviceName, phDevice, (LPPRINTER_DEFAULTS)pDummy);
#else
    HKEY    hkDevice = NULL;        // printers branch of registry
    HKEY    hkPrtr   = NULL;        // Friendly name branch of registry
    DWORD   dwErr;                  // error code
    BOOL    rc = FALSE;             // return code

    *phDevice = NULL;

    if (((dwErr = RegOpenKey(HKEY_LOCAL_MACHINE, gszRegPrinter, &hkDevice)) != ERROR_SUCCESS) ||
        ((dwErr = RegOpenKey(hkDevice, pDeviceName, &hkPrtr)) != ERROR_SUCCESS) ||
        ((dwErr = RegOpenKey(hkPrtr, gszPrinterData, (HKEY *)phDevice)) != ERROR_SUCCESS))
    {
        WARNING((__TEXT("Cannot open printer data branch of registry for %s: %d\n"), pDeviceName, dwErr));
        SetLastError(dwErr);
        goto EndOpenPrtr;
    }

    rc = TRUE;

EndOpenPrtr:
    if (hkDevice)
    {
        RegCloseKey(hkDevice);
    }
    if (hkPrtr)
    {
        RegCloseKey(hkPrtr);
    }

    return rc;
#endif
}


/******************************************************************************
 *
 *                              ClosePrtr
 *
 *  Function:
 *       This function closes the printer handle opened by OpenPrtr.
 *
 *  Arguments:
 *       hDevice         - open handle
 *
 *  Returns:
 *       TRUE if successful, FALSE otherwise
 *
 ******************************************************************************/


BOOL WINAPI
ClosePrtr(
    HANDLE hDevice
    )
{
#if !defined(_WIN95_)
    return ClosePrinter(hDevice);
#else
    DWORD dwErr;

    dwErr = RegCloseKey((HKEY)hDevice);
    SetLastError(dwErr);
    return dwErr == ERROR_SUCCESS;
#endif
}


/******************************************************************************
 *
 *                              GetPrtrData
 *
 *  Function:
 *       This functions returns ICM data stored with the printer instance
 *
 *  Arguments:
 *       hDevice         - open printer handle
 *       pKey            - registry key for compatibility with GetPrinterDataEx
 *       pName           - name of registry value
 *       pdwType         - pointer to dword that receives type  of value
 *       pData           - pointer to  buffer to receive data
 *       dwSize          - size of buffer
 *       pdwNeeded       - on return, this has size of buffer filled/needed
 *
 *  Returns:
 *       ERROR_SUCCESS if successful, error code otherwise
 *
 ******************************************************************************/

DWORD WINAPI
GetPrtrData(
    HANDLE hDevice,
    PTSTR  pKey,
    PTSTR  pName,
    PDWORD pdwType,
    PBYTE  pData,
    DWORD  dwSize,
    PDWORD pdwNeeded
    )
{
#if !defined(_WIN95_)
    return GetPrinterDataEx(hDevice, pKey, pName, pdwType, pData, dwSize, pdwNeeded);
#else
    *pdwNeeded = dwSize;

    return RegQueryValueEx((HKEY)hDevice, pName, 0, NULL, pData, pdwNeeded);
#endif
}


/******************************************************************************
 *
 *                              SetPrtrData
 *
 *  Function:
 *       This functions stores ICM data with the printer instance
 *
 *  Arguments:
 *       hDevice         - open printer handle
 *       pKey            - registry key for compatibility with SetPrinterDataEx
 *       pName           - name of registry value
 *       dwType          - type  of value
 *       pData           - pointer to  data buffer
 *       dwSize          - size of buffer
 *
 *  Returns:
 *       ERROR_SUCCESS if successful, error code otherwise
 *
 ******************************************************************************/

DWORD WINAPI
SetPrtrData(
    HANDLE hDevice,
    PTSTR  pKey,
    PTSTR  pName,
    DWORD  dwType,
    PBYTE  pData,
    DWORD  dwSize
    )
{
#if !defined(_WIN95_)
    return SetPrinterDataEx(hDevice, pKey, pName, dwType, pData, dwSize);
#else
    return RegSetValueEx((HKEY)hDevice, pName, 0, dwType, pData, dwSize);
#endif
}


/******************************************************************************
 *
 *                              OpenMonitor
 *
 *  Function:
 *       This function returns a handle to the monitor
 *
 *  Arguments:
 *       pDeviceName     - pointer to name of the device
 *       phDevice        - pointer that receives the handle.
 *       pDummy          - dummy parameter
 *
 *  Returns:
 *       TRUE if successful, FALSE otherwise
 *
 ******************************************************************************/

BOOL WINAPI
OpenMonitor(
    PTSTR    pDeviceName,
    LPHANDLE phDevice,
    PTSTR    pDummy
    )
{
#ifdef _WIN95_

    //
    // For Windows 9x platform.
    //

    HDEVINFO        hDevInfo = INVALID_HANDLE_VALUE;
    HKEY            hkICM = NULL;
    HKEY            hkDriver = NULL;        // software branch of registry
    DWORD           dwSize;                 // size of buffer
    TCHAR           szName[MAX_PATH];       // buffer
    BOOL            rc = FALSE;             // return value
    SP_DEVINFO_DATA spdid;
    int             i;                      // instance counter

    if (!LoadSetupAPIDll())
    {
        WARNING((__TEXT("Error loading setupapi.dll: %d\n"), GetLastError()));
        return FALSE;
    }

    hDevInfo = (*fpSetupDiGetClassDevs)((LPGUID)&GUID_DEVCLASS_MONITOR, NULL,  NULL, DIGCF_PRESENT);

    if (hDevInfo == INVALID_HANDLE_VALUE)
    {
        WARNING((__TEXT("Error getting hDevInfo: %d\n"), GetLastError()));
        goto EndOpenMonitor;
    }

    i = 0;
    while (! rc)
    {
        ZeroMemory(&spdid, sizeof(SP_DEVINFO_DATA));
        spdid.cbSize = sizeof(SP_DEVINFO_DATA);
        if (! (*fpSetupDiEnumDeviceInfo)(hDevInfo, i, &spdid))
        {
            if (i == 0 && !lstrcmpi(pDeviceName, gszDisplay))
            {
                //
                // PnP support not in - open ICM key in registry
                //

                TCHAR szICMMonitorData[] = __TEXT("ICMMonitorData");

                WARNING((__TEXT("PnP support absent - Using DISPLAY\n")));

                //
                // Open the registry path where monitor data is kept
                //

                if ((RegOpenKey(HKEY_LOCAL_MACHINE, gszICMRegPath, &hkICM) != ERROR_SUCCESS) ||
                    (RegCreateKey(hkICM, szICMMonitorData, &hkDriver) != ERROR_SUCCESS))
                {
                    WARNING((__TEXT("Cannot open ICMMonitorData branch of registry\n")));
                    goto EndOpenMonitor;
                }
                rc = TRUE;
            }
            break;
        }

        //
        // Get PnP ID. Check and see if the monitor name matches it.
        //

        dwSize = sizeof(szName);
        if ((*fpSetupDiGetDeviceInstanceId)(hDevInfo, &spdid, szName, dwSize, NULL) &&
            ! lstrcmp(szName, pDeviceName))
        {
            hkDriver = (*fpSetupDiOpenDevRegKey)(hDevInfo, &spdid, DICS_FLAG_GLOBAL, 0, DIREG_DRV, KEY_ALL_ACCESS);
            if (hkDriver == INVALID_HANDLE_VALUE)
            {
                WARNING((__TEXT("Could not open monitor s/w key for all access\n")));
                hkDriver = (*fpSetupDiOpenDevRegKey)(hDevInfo, &spdid, DICS_FLAG_GLOBAL, 0, DIREG_DRV, KEY_READ);
                if (hkDriver == INVALID_HANDLE_VALUE)
                {
                    WARNING((__TEXT("Error opening s/w registry key for read access: %x\n"), GetLastError()));
                    goto EndOpenMonitor;
                }
            }

            rc = TRUE;
        }

        i++;
    }

EndOpenMonitor:

    if (hkICM)
    {
        RegCloseKey(hkICM);
    }

    if (hDevInfo != INVALID_HANDLE_VALUE)
    {
        (*fpSetupDiDestroyDeviceInfoList)(hDevInfo);
    }

    *phDevice = (HANDLE)hkDriver;

    return rc;

#else

    //
    // For Windows NT (later than 5.0) platform
    //

    TCHAR  szRegPath[MAX_PATH];
    HKEY   hkDriver = NULL;

    //
    // Copy device class root key.
    //

    lstrcpy(szRegPath,gszDeviceClass);
    lstrcat(szRegPath,gszMonitorGUID);

    if (!lstrcmpi(pDeviceName, gszDisplay))
    {
        WARNING((__TEXT("PnP support absent - Using DISPLAY\n")));

        //
        // PnP support not in -  just open "0000" device.
        //

        lstrcat(szRegPath,TEXT("\\0000"));
    }
    else
    {
        // Someone changed the input pDeviceName from uppercase to lowercase
        // and our substring search failed. (RAID #282646)
        // Add code to do an uppercase compare instead.
        
        TCHAR *pszBuffer = _tcsdup(pDeviceName);  // make a local copy
        
        if(pszBuffer)
        {
            _tcsupr(pszBuffer);                   // convert it to uppercase
            
            // we know that gszMonitorGUID is upcase already.
            // do an upcase substr compare.
            
            if (_tcsstr(pszBuffer, gszMonitorGUID))
            {
                //
                // Extract monitor number from DeviceName
                //
        
                TCHAR *pDeviceNumber = _tcsrchr(pDeviceName,TEXT('\\'));
        
                if (pDeviceNumber)
                {
                    lstrcat(szRegPath,pDeviceNumber);
                }
                else
                {
                    lstrcat(szRegPath,TEXT("\\0000"));
                }
            }
            else
            {
                //
                // This is not valid monitor name.
                // Go to error out, but don't forget to free the memory
                // we allocated above seeing as we skip the free below
                // this code block.
                //
                
                free(pszBuffer);  
                goto EndOpenMonitor;
            }
            
            free(pszBuffer);
        }
        else
        {
            goto EndOpenMonitor;   // failed to allocate temporary buffer.
        }
    }

    //
    // Open the registry path where monitor data is kept
    //

    if (RegOpenKey(HKEY_LOCAL_MACHINE, szRegPath, &hkDriver) != ERROR_SUCCESS)
    {
        WARNING((__TEXT("Cannot open %s key\n"),szRegPath));
        hkDriver = NULL;
    }

EndOpenMonitor:

    *phDevice = (HANDLE) hkDriver;

    return (hkDriver != NULL);

#endif // _WIN95_
}


/******************************************************************************
 *
 *                              CloseMonitor
 *
 *  Function:
 *       This function closes the monitor handle opened by OpenMonitor
 *
 *  Arguments:
 *       hDevice         - open handle
 *
 *  Returns:
 *       TRUE if successful, FALSE otherwise
 *
 ******************************************************************************/

BOOL WINAPI
CloseMonitor(
    HANDLE hDevice
    )
{
    DWORD dwErr;

    dwErr = RegCloseKey((HKEY)hDevice);
    SetLastError(dwErr);
    return (dwErr == ERROR_SUCCESS);
}


/******************************************************************************
 *
 *                              GetMonitorData
 *
 *  Function:
 *       This functions returns ICM data stored with the monitor instance
 *
 *  Arguments:
 *       hDevice         - open monitor handle
 *       pKey            - registry key for compatibility with GetPrinterDataEx
 *       pName           - name of registry value
 *       pdwType         - pointer to dword that receives type  of value
 *       pData           - pointer to  buffer to receive data
 *       dwSize          - size of buffer
 *       pdwNeeded       - on return, this has size of buffer filled/needed
 *
 *  Returns:
 *       ERROR_SUCCESS if successful, error code otherwise
 *
 ******************************************************************************/

DWORD WINAPI
GetMonitorData(
    HANDLE hDevice,
    PTSTR  pKey,
    PTSTR  pName,
    PDWORD pdwType,
    PBYTE  pData,
    DWORD  dwSize,
    PDWORD pdwNeeded
    )
{
    DWORD    dwType, dwTemp;
    DWORD    rc;

    *pdwNeeded = dwSize;

    rc = RegQueryValueEx((HKEY)hDevice, pName, 0, &dwType, pData, pdwNeeded);
    if (rc == ERROR_SUCCESS || rc == ERROR_MORE_DATA)
    {
        if (dwType == REG_SZ)
        {
            PTSTR pFilename;

            //
            // Old style value, convert to double null terminated binary
            //

            if (pData)
            {
                pFilename = GetFilenameFromPath((PTSTR)pData);
                if ( (pFilename) &&
                     (pFilename != (PTSTR)pData) )
                {
                    lstrcpy((PTSTR)pData, pFilename);
                }
                *pdwNeeded = lstrlen((PTSTR)pData) * sizeof(TCHAR);
            }

            *pdwNeeded += sizeof(TCHAR);    // for double NULL termination

            if ((dwSize >= *pdwNeeded) && pData)
            {
                *((PTSTR)pData + lstrlen((PTSTR)pData) + 1) = '\0';

                //
                // Set the profile name in new format
                //

                RegSetValueEx((HKEY)hDevice, pName, 0, REG_BINARY, pData, (lstrlen((PTSTR)pData)+2)*sizeof(TCHAR));
            }
        }
        else if (*pdwNeeded == 1)
        {
            //
            // If we have picked up the data and it is a 1 byte non-zero
            // value, it is an 1 based index in a list of
            // predefined profiles. Deal with this case.
            //
            // If pData is NULL, then we don't know if it is non-zero or
            // not, so we assume it is and ask for a large enough buffer.
            //

            if (!pData || *pData != 0)
            {
                //
                // Old style 1-based index value
                //

                if ((dwSize >= MAX_PATH) && pData)
                {
                    HKEY     hkICM = NULL;
                    HKEY     hkDevice = NULL;
                    REGDATA  regData;

                    //
                    // Make sure buggy inf doesn't crash us
                    //

                    if (pData[0] > sizeof(gszDispProfiles)/sizeof(gszDispProfiles[0]))
                    {
                        WARNING((__TEXT("Predefined profile index too large: %d\n"), pData[0]));
                        goto EndCompatMode;
                    }

                    lstrcpy((PTSTR)pData, gszDispProfiles[pData[0] - 1]);
                    *((PTSTR)pData + lstrlen((PTSTR)pData) + 1) = '\0';

                    //
                    // We need to update reference count as it wasn't set up
                    // using the new API
                    //
                    // Open the registry path where profiles are kept
                    //

                    if ((RegCreateKey(HKEY_LOCAL_MACHINE, gszICMRegPath, &hkICM) != ERROR_SUCCESS) ||
                        (RegCreateKey(hkICM, __TEXT("mntr"), &hkDevice) != ERROR_SUCCESS))
                    {
                        WARNING((__TEXT("Cannot open ICM\\device branch of registry\n")));
                        goto EndCompatMode;
                    }

                    //
                    // If registry data exists, then the profile is already installed,
                    // in which case, increment use count, otherwise add entry
                    //

                    dwTemp = sizeof(REGDATA);
                    if (RegQueryValueEx(hkDevice, (PTSTR)pData, 0, NULL, (PBYTE)&regData,
                            &dwTemp) == ERROR_SUCCESS)
                    {
                        regData.dwRefCount++;
                    }
                    else
                    {
                        regData.dwRefCount = 1;
                        regData.dwManuID = 'enon';  // it is our profile
                        regData.dwModelID = 'enon';
                    }

                    if (RegSetValueEx(hkDevice, (PTSTR)pData, 0, REG_BINARY,
                            (PBYTE)&regData, sizeof(REGDATA)) != ERROR_SUCCESS)
                    {
                        WARNING((__TEXT("Error setting registry value\n")));
                        goto EndCompatMode;
                    }

                    //
                    // Set the profile name in new format
                    //

                    RegSetValueEx((HKEY)hDevice, pName, 0, REG_BINARY, pData,
                                  (lstrlen((PTSTR)pData) + 2)*sizeof(TCHAR));

                EndCompatMode:
                    if (hkICM)
                    {
                        RegCloseKey(hkICM);
                    }
                    if (hkDevice)
                    {
                        RegCloseKey(hkDevice);
                    }
                }
                *pdwNeeded = MAX_PATH;
            }
        }
    }

    if ((rc == ERROR_SUCCESS) && (*pdwNeeded > dwSize))
    {
        rc = ERROR_MORE_DATA;
    }

    return rc;
}


/******************************************************************************
 *
 *                              SetMonitorData
 *
 *  Function:
 *       This functions stores ICM data with the monitor instance
 *
 *  Arguments:
 *       hDevice         - open monitor handle
 *       pKey            - registry key for compatibility with SetPrinterDataEx
 *       pName           - name of registry value
 *       dwType          - type  of value
 *       pData           - pointer to  data buffer
 *       dwSize          - size of buffer
 *
 *  Returns:
 *       ERROR_SUCCESS if successful, error code otherwise
 *
 ******************************************************************************/

DWORD WINAPI
SetMonitorData(
    HANDLE hDevice,
    PTSTR  pKey,
    PTSTR  pName,
    DWORD  dwType,
    PBYTE  pData,
    DWORD  dwSize
    )
{
    return RegSetValueEx((HKEY)hDevice, pName, 0, dwType, pData, dwSize);
}


/******************************************************************************
 *
 *                              OpenScanner
 *
 *  Function:
 *       This function returns a handle to the scanner
 *
 *  Arguments:
 *       pDeviceName     - pointer to name of the device
 *       phDevice        - pointer that receives the handle.
 *       pDummy          - dummy parameter
 *
 *  Returns:
 *       TRUE
 *
 ******************************************************************************/

BOOL WINAPI
OpenScanner(
    PTSTR    pDeviceName,
    LPHANDLE phDevice,
    PTSTR    pDummy
    )
{
    PFNSTICREATEINSTANCE pStiCreateInstance;
    PSCANNERDATA         psd = NULL;
    HRESULT              hres;
    BOOL                 bRc = FALSE;

    if (!(psd = (PSCANNERDATA)MemAlloc(sizeof(SCANNERDATA))))
    {
        WARNING((__TEXT("Error allocating memory for scanner data\n")));
        return FALSE;
    }

    if (!(psd->pDeviceName = MemAlloc((lstrlen(pDeviceName) + 1) * sizeof(WCHAR))))
    {
        WARNING((__TEXT("Error allocating memory for scanner name\n")));
        goto EndOpenScanner;
    }

    #ifdef UNICODE
    lstrcpy(psd->pDeviceName, pDeviceName);
    #else
    if (! ConvertToUnicode(pDeviceName, &psd->pDeviceName, FALSE))
    {
        WARNING((__TEXT("Error converting scanner name to Unicode\n")));
        goto EndOpenScanner;
    }
    #endif

    if (!(psd->hModule = LoadLibrary(gszStiDll)))
    {
        WARNING((__TEXT("Error loading sti.dll: %d\n"), GetLastError()));
        goto EndOpenScanner;
    }

    if (!(pStiCreateInstance = (PFNSTICREATEINSTANCE)GetProcAddress(psd->hModule, gszStiCreateInstance)))
    {
        WARNING((__TEXT("Error getting proc StiCreateInstance\n")));
        goto EndOpenScanner;
    }

    hres = (*pStiCreateInstance)(GetModuleHandle(NULL), STI_VERSION, &psd->pSti, NULL);

    if (FAILED(hres))
    {
        WARNING((__TEXT("Error creating sti instance: %d\n"), hres));
        goto EndOpenScanner;
    }

    *phDevice = (HANDLE)psd;

    bRc = TRUE;

EndOpenScanner:

    if (!bRc && psd)
    {
        CloseScanner((HANDLE)psd);
    }

    return bRc;
}


/******************************************************************************
 *
 *                              CloseScanner
 *
 *  Function:
 *       This function closes the monitor handle opened by OpenMonitor
 *
 *  Arguments:
 *       hDevice        - handle of device
 *
 *  Returns:
 *       TRUE
 *
 ******************************************************************************/

BOOL WINAPI
CloseScanner(
    HANDLE hDevice
    )
{
    PSCANNERDATA psd = (PSCANNERDATA)hDevice;

    if (psd)
    {
        if (psd->pSti)
        {
            psd->pSti->lpVtbl->Release(psd->pSti);
        }

        if (psd->pDeviceName)
        {
            MemFree(psd->pDeviceName);
        }

        if (psd->hModule)
        {
            FreeLibrary(psd->hModule);
        }

        MemFree(psd);
    }

    return TRUE;
}


/******************************************************************************
 *
 *                              GetScannerData
 *
 *  Function:
 *       This functions returns ICM data stored with the scannerr instance
 *
 *  Arguments:
 *       hDevice         - open scanner handle
 *       pKey            - registry key for compatibility with GetPrinterDataEx
 *       pName           - name of registry value
 *       pdwType         - pointer to dword that receives type  of value
 *       pData           - pointer to  buffer to receive data
 *       dwSize          - size of buffer
 *       pdwNeeded       - on return, this has size of buffer filled/needed
 *
 *  Returns:
 *       ERROR_SUCCESS if successful, error code otherwise
 *
 ******************************************************************************/

DWORD WINAPI
GetScannerData(
    HANDLE hDevice,
    PTSTR  pKey,
    PTSTR  pName,
    PDWORD pdwType,
    PBYTE  pData,
    DWORD  dwSize,
    PDWORD pdwNeeded
    )
{
    PSCANNERDATA psd = (PSCANNERDATA)hDevice;
    HRESULT      hres;
#ifndef UNICODE
    PWSTR        pwszName;

    //
    // STI interface "ALWAYS" expects Unicode.
    //
    hres = ConvertToUnicode(pName, &pwszName, TRUE);

    if (!hres)
    {
        return (ERROR_INVALID_PARAMETER);
    }

    pName = (PSTR)pwszName;

#endif

    *pdwNeeded = dwSize;

    hres = psd->pSti->lpVtbl->GetDeviceValue(psd->pSti, psd->pDeviceName, (PWSTR)pName, pdwType, pData, pdwNeeded);

#ifndef UNICODE

    MemFree(pwszName);

#endif

    return hres;
}


/******************************************************************************
 *
 *                              SetScannerData
 *
 *  Function:
 *       This functions stores ICM data with the scanner instance
 *
 *  Arguments:
 *       hDevice         - open scanner handle
 *       pKey            - registry key for compatibility with SetPrinterDataEx
 *       pName           - name of registry value
 *       dwType          - type  of value
 *       pData           - pointer to  data buffer
 *       dwSize          - size of buffer
 *
 *  Returns:
 *       ERROR_SUCCESS if successful, error code otherwise
 *
 ******************************************************************************/

DWORD WINAPI
SetScannerData(
    HANDLE hDevice,
    PTSTR  pKey,
    PTSTR  pName,
    DWORD  dwType,
    PBYTE  pData,
    DWORD  dwSize
    )
{
    PSCANNERDATA psd = (PSCANNERDATA)hDevice;
    HRESULT      hres;
#ifndef UNICODE
    PWSTR        pwszName;

    //
    // STI interface "ALWAYS" expects Unicode.
    //
    hres = ConvertToUnicode(pName, &pwszName, TRUE);

    if (!hres)
    {
        return (ERROR_INVALID_PARAMETER);
    }

    pName = (PSTR)pwszName;

#endif

    hres = psd->pSti->lpVtbl->SetDeviceValue(psd->pSti, psd->pDeviceName, (PWSTR)pName, dwType, pData, dwSize);

#ifndef UNICODE

    MemFree(pwszName);

#endif

    return hres;
}

//
// Internal functions
//

BOOL WINAPI
InternalGetDeviceConfig(
    LPCTSTR pDeviceName,
    DWORD   dwDeviceClass,
    DWORD   dwConfigType,
    PVOID   pConfigData,
    PDWORD  pdwSize
    )
{
    DWORD   dwDataType;
    DWORD   dwSizeRequired = 0;
    BOOL    rc = FALSE;

    switch (dwConfigType)
    {
    case MSCMS_PROFILE_ENUM_MODE:

        dwDataType = DEVICE_PROFILE_ENUMMODE;
        break;

    default:

        WARNING((__TEXT("Invalid parameter to InternalGetDeviceConfig\n")));
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // Query the size of the data.
    //

    if (GetDeviceData(pDeviceName,dwDeviceClass,dwDataType,NULL,&dwSizeRequired,FALSE))
    {
        if ((dwSizeRequired <= *pdwSize) && (pConfigData != NULL))
        {
            //
            // If buffer is enough, get the data.
            //

            if (GetDeviceData(pDeviceName,dwDeviceClass,dwDataType,
                              (PVOID *)&pConfigData,pdwSize,FALSE))
            {
                rc = TRUE;
            }
            else
            {
                WARNING((__TEXT("Failed on GetDeviceData to query data\n")));
                SetLastError(ERROR_INVALID_PARAMETER);
            }
        }
        else
        {
            //
            // Return nessesary buffer size to caller.
            //

            *pdwSize = dwSizeRequired;
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
        }
    }
    else
    {
        WARNING((__TEXT("Failed on GetDeviceData to query data size\n")));
        SetLastError(ERROR_INVALID_PARAMETER);
    }

    return rc;
}

BOOL WINAPI
InternalSetDeviceConfig(
    LPCTSTR pDeviceName,
    DWORD   dwDeviceClass,
    DWORD   dwConfigType,
    PVOID   pConfigData,
    DWORD   dwSize
    )
{
    DWORD   dwDataType;

    switch (dwConfigType)
    {
    case MSCMS_PROFILE_ENUM_MODE:

        dwDataType = DEVICE_PROFILE_ENUMMODE;
        break;

    default:

        WARNING((__TEXT("Invalid parameter to InternalGetDeviceConfig\n")));
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // Save the data.
    //

    return (SetDeviceData(pDeviceName,dwDeviceClass,dwDataType,pConfigData,dwSize));
}

#ifdef _WIN95_

//
// Win9x specific functions are here.
//

BOOL
LoadSetupAPIDll(
    VOID
    )
{
    EnterCriticalSection(&critsec);

    if (ghModSetupAPIDll == NULL)
    {
        ghModSetupAPIDll = LoadLibrary(TEXT("setupapi.dll"));

        if (ghModSetupAPIDll)
        {
            fpSetupDiOpenDevRegKey = (FP_SetupDiOpenDevRegKey)
                GetProcAddress(ghModSetupAPIDll,"SetupDiOpenDevRegKey");
            fpSetupDiDestroyDeviceInfoList = (FP_SetupDiDestroyDeviceInfoList)
                GetProcAddress(ghModSetupAPIDll,"SetupDiDestroyDeviceInfoList");
            fpSetupDiEnumDeviceInfo = (FP_SetupDiEnumDeviceInfo)
                GetProcAddress(ghModSetupAPIDll,"SetupDiEnumDeviceInfo");
            fpSetupDiGetDeviceInstanceId = (FP_SetupDiGetDeviceInstanceId)
                GetProcAddress(ghModSetupAPIDll,"SetupDiGetDeviceInstanceIdA");
            fpSetupDiGetClassDevs = (FP_SetupDiGetClassDevs)
                GetProcAddress(ghModSetupAPIDll,"SetupDiGetClassDevsA");

            if ((fpSetupDiOpenDevRegKey == NULL) ||
                (fpSetupDiDestroyDeviceInfoList == NULL) ||
                (fpSetupDiEnumDeviceInfo == NULL) ||
                (fpSetupDiGetDeviceInstanceId == NULL) ||
                (fpSetupDiGetClassDevs == NULL))
            {
                WARNING((__TEXT("Could not find Export function in setupapi.dll\n")));

                FreeLibrary(ghModSetupAPIDll);
                ghModSetupAPIDll = NULL;
            }
        }
    }

    LeaveCriticalSection(&critsec);

    return (!!ghModSetupAPIDll);
}

#else

//
// Win NT specific functions are here.
//

VOID
ChangeICMSetting(
    LPCTSTR pMachineName,
    LPCTSTR pDeviceName,
    DWORD   dwICMMode
    )
{
    PRINTER_INFO_8   *ppi8;
    PRINTER_INFO_9   *ppi9;
    PRINTER_DEFAULTS pd;
    HANDLE           hPrinter;
    DWORD            dwSize;
    BYTE             temp[2*1024];    // sufficient for devmode

    pd.pDatatype = NULL;
    pd.pDevMode = NULL;
    pd.DesiredAccess = PRINTER_ALL_ACCESS;

    if (!OpenPrinter((PTSTR)pDeviceName, &hPrinter, &pd))
        return;

    //
    // Get and update system devmode
    //

    ppi8 = (PRINTER_INFO_8 *)&temp;
    if (GetPrinter(hPrinter, 8, (PBYTE)ppi8, sizeof(temp), &dwSize) &&
        ppi8->pDevMode)
    {
        switch (dwICMMode)
        {
        case ICM_ON:
        case ICM_OFF:
            ppi8->pDevMode->dmFields |= DM_ICMMETHOD;
            if (dwICMMode == ICM_ON)
                ppi8->pDevMode->dmICMMethod = DMICMMETHOD_SYSTEM;
            else
                ppi8->pDevMode->dmICMMethod = DMICMMETHOD_NONE;
            SetPrinter(hPrinter, 8, (PBYTE)ppi8, 0);
            break;
        }
    }

    //
    // If the user has a per-user devmode, update this as well
    //

    ppi9 = (PRINTER_INFO_9 *)&temp;
    if (GetPrinter(hPrinter, 9, (PBYTE)ppi9, sizeof(temp), &dwSize) &&
        ppi9->pDevMode)
    {
        switch (dwICMMode)
        {
        case ICM_ON:
        case ICM_OFF:
            ppi9->pDevMode->dmFields |= DM_ICMMETHOD;
            if (dwICMMode == ICM_ON)
                ppi9->pDevMode->dmICMMethod = DMICMMETHOD_SYSTEM;
            else
                ppi9->pDevMode->dmICMMethod = DMICMMETHOD_NONE;
            SetPrinter(hPrinter, 9, (PBYTE)ppi9, 0);
            break;
        }
    }

    ClosePrinter(hPrinter);

    return;
}

#endif // _WIN95_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\mscms\sources.inc ===
!IF 0

Copyright (c) 1996  Microsoft Corporation

!ENDIF

!ifndef ICMROOT
ICMROOT=$(NTGDI_PATH)\icm
!endif

!include $(ICMROOT)\icmsrc.inc

TARGETNAME=mscms
TARGETPATH=$(ALT_PROJECT_TARGET)\$(_OBJ_DIR)
TARGETTYPE=DYNLINK
DLLBASE=@$(COFFBASE_TXT_FILE),mscms

INCLUDES=..\.;$(ICMROOT)\inc;$(INCLUDES)

DLLENTRY=DllEntryPoint

NTKEEPRESOURCETMPFILES=1
USE_MSVCRT=1

C_DEFINES=$(C_DEFINES) -DLITTLE_ENDIAN

SOURCES=\
    ..\dllentry.c          \
    ..\globals.c           \
    ..\profile.c           \
    ..\object.c            \
    ..\color.c             \
    ..\profman.c           \
    ..\ps2wrap.c           \
    ..\mscms.rc

TARGETLIBS=$(SDK_LIB_PATH)\kernel32.lib \
           $(SDK_LIB_PATH)\advapi32.lib \
           $(SDK_LIB_PATH)\winspool.lib \
           $(SDK_LIB_PATH)\user32.lib

PRECOMPILED_INCLUDE=..\mscms.h
PRECOMPILED_PCH=precomp.pch
PRECOMPILED_OBJ=precomp.obj

DLLDEF=..\$(TARGETNAME).def
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\mscms\profile.c ===
/****************************Module*Header******************************\
* Module Name: PROFILE.C
*
* Module Descripton: Profile data manipulation functions
*
* Warnings:
*
* Issues:
*
* Public Routines:
*
* Created:  11 January 1996
* Author:   Srinivasan Chandrasekar    [srinivac]
*
* Copyright (c) 1996, 1997  Microsoft Corporation
\***********************************************************************/

#include "mscms.h"

#define PROFILE_GROWTHCUSHION       16*1024

//
// Local functions
//

HPROFILE InternalOpenColorProfile(PPROFILE, DWORD, DWORD, DWORD);
BOOL InternalCreateProfileFromLCS(LPLOGCOLORSPACE, PBYTE*, BOOL);
BOOL FreeProfileObject(HPROFILE);
BOOL AddTagTableEntry(PPROFOBJ, TAGTYPE, DWORD, DWORD, BOOL);
BOOL AddTaggedElement(PPROFOBJ, TAGTYPE, DWORD);
BOOL DeleteTaggedElement(PPROFOBJ, PTAGDATA);
BOOL ChangeTaggedElementSize(PPROFOBJ, PTAGDATA, DWORD);
BOOL GrowProfile(PPROFOBJ, DWORD);
void MoveProfileData(PPROFOBJ, PBYTE, PBYTE, LONG, BOOL);
BOOL IsReferenceTag(PPROFOBJ, PTAGDATA);


/******************************************************************************
 *
 *                            OpenColorProfile
 *
 *  Function:
 *       These are the ANSI & Unicode wrappers for InternalOpenColorProfile.
 *       Please see InternalOpenColorProfile for more details on this function.
 *
 *  Returns:
 *       Handle to open profile on success, zero on failure.
 *
 ******************************************************************************/

#ifdef UNICODE          // Windows NT versions

HPROFILE WINAPI OpenColorProfileA(
    PPROFILE pProfile,
    DWORD    dwDesiredAccess,
    DWORD    dwShareMode,
    DWORD    dwCreationMode
    )
{
    PROFILE  wProfile;      // Unicode version
    HPROFILE rc = NULL;

    //
    // Validate parameters before touching them
    //

    if (!pProfile ||
        IsBadReadPtr(pProfile, sizeof(PROFILE)) ||
        (pProfile->pProfileData &&
         IsBadReadPtr(pProfile->pProfileData, pProfile->cbDataSize)) ||
        (!pProfile->pProfileData &&
         (pProfile->cbDataSize != 0)) ||
        (pProfile->dwType != PROFILE_FILENAME &&
         pProfile->dwType != PROFILE_MEMBUFFER
        )
       )
    {
        WARNING((__TEXT("Invalid parameter to OpenColorProfile\n")));
        SetLastError(ERROR_INVALID_PARAMETER);
        return NULL;
    }

    if (pProfile->dwType == PROFILE_FILENAME)
    {
        //
        // Convert the profile name to Unicode and call the Unicode version
        //

        wProfile.dwType = pProfile->dwType;

        if (!pProfile->pProfileData || pProfile->cbDataSize == 0)
        {
            WARNING((__TEXT("Invalid parameter to OpenColorProfile\n")));
            SetLastError(ERROR_INVALID_PARAMETER);
            return NULL;
        }

        wProfile.pProfileData = (WCHAR*)MemAlloc(pProfile->cbDataSize * sizeof(WCHAR));
        if (!wProfile.pProfileData)
        {
            WARNING((__TEXT("Error allocating memory for Unicode profile structure\n")));
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return NULL;
        }

        if (! MultiByteToWideChar(CP_ACP, 0, pProfile->pProfileData, pProfile->cbDataSize,
            wProfile.pProfileData, pProfile->cbDataSize))
        {
            WARNING((__TEXT("Error converting profile structure to Unicode\n")));
            goto EndOpenColorProfileA;
        }

        wProfile.cbDataSize = pProfile->cbDataSize * sizeof(WCHAR);
    }
    else
    {
        //
        // It is a memory based profile, so no ANSI/Unicode conversion
        //

        wProfile = *pProfile;
    }

    rc = InternalOpenColorProfile(&wProfile, dwDesiredAccess,
            dwShareMode, dwCreationMode);

EndOpenColorProfileA:
    if (pProfile->dwType == PROFILE_FILENAME)
    {
        MemFree(wProfile.pProfileData);
    }

    return rc;
}

HPROFILE WINAPI OpenColorProfileW(
    PPROFILE pProfile,
    DWORD    dwDesiredAccess,
    DWORD    dwShareMode,
    DWORD    dwCreationMode
    )
{
    //
    // Internal function is Unicode in Windows NT, call it directly.
    //

    return InternalOpenColorProfile(pProfile, dwDesiredAccess,
            dwShareMode, dwCreationMode);
}

#else                           // Windows 95 versions

HPROFILE WINAPI OpenColorProfileA(
    PPROFILE pProfile,
    DWORD    dwDesiredAccess,
    DWORD    dwShareMode,
    DWORD    dwCreationMode
    )
{
    //
    // Internal function is ANSI in Windows 95, call it directly.
    //

    return InternalOpenColorProfile(pProfile, dwDesiredAccess,
            dwShareMode, dwCreationMode);
}

HPROFILE WINAPI OpenColorProfileW(
    PPROFILE pProfile,
    DWORD    dwDesiredAccess,
    DWORD    dwShareMode,
    DWORD    dwCreationMode
    )
{
    PROFILE  aProfile;      // ANSI version
    HPROFILE rc = NULL;
    BOOL     bUsedDefaultChar;

    //
    // Validate parameters before touching them
    //

    if (!pProfile ||
        IsBadReadPtr(pProfile, sizeof(PROFILE)) ||
        (pProfile->pProfileData &&
         IsBadReadPtr(pProfile->pProfileData, pProfile->cbDataSize)) ||
        (!pProfile->pProfileData &&
         (pProfile->cbDataSize != 0)) ||
        (pProfile->dwType != PROFILE_FILENAME &&
         pProfile->dwType != PROFILE_MEMBUFFER
        )
       )
    {
        WARNING((__TEXT("Invalid parameter to OpenColorProfile\n")));
        SetLastError(ERROR_INVALID_PARAMETER);
        return NULL;
    }

    if (pProfile->dwType == PROFILE_FILENAME)
    {
        //
        // Convert the profile name to ANSI and call the ANSI version
        //

        aProfile.dwType = pProfile->dwType;

        if (!pProfile->pProfileData || pProfile->cbDataSize == 0)
        {
            WARNING((__TEXT("Invalid parameter to OpenColorProfile\n")));
            SetLastError(ERROR_INVALID_PARAMETER);
            return NULL;
        }

        aProfile.pProfileData = (char*)MemAlloc(pProfile->cbDataSize * sizeof(char));
        if (!aProfile.pProfileData)
        {
            WARNING((__TEXT("Error allocating memory for ANSI profile structure\n")));
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return NULL;
        }

        if (! WideCharToMultiByte(CP_ACP, 0, pProfile->pProfileData, pProfile->cbDataSize/sizeof(WCHAR),
            aProfile.pProfileData, pProfile->cbDataSize,
            NULL, &bUsedDefaultChar) || bUsedDefaultChar)
        {
            WARNING((__TEXT("Error converting profile structure to ANSI\n")));
            goto EndOpenColorProfileW;
        }

        aProfile.cbDataSize = pProfile->cbDataSize * sizeof(char);
    }
    else
    {
        //
        // It is a memory based profile, so no ANSI/Unicode conversion
        //

        aProfile = *pProfile;
    }

    rc = InternalOpenColorProfile(&aProfile, dwDesiredAccess,
            dwShareMode, dwCreationMode);

EndOpenColorProfileW:
    if (pProfile->dwType == PROFILE_FILENAME)
    {
        MemFree(aProfile.pProfileData);
    }

    return rc;
}

#endif                          // ! UNICODE

/******************************************************************************
 *
 *                            CloseColorProfile
 *
 *  Function:
 *       This functions closes a color profile object, and frees all memory
 *       associated with it.
 *
 *  Arguments:
 *       hProfile - handle identifing the profile object
 *
 *  Returns:
 *       TRUE if successful, FALSE otherwise
 *
 ******************************************************************************/

BOOL WINAPI CloseColorProfile(
    HPROFILE hProfile
    )
{
    TRACEAPI((__TEXT("CloseColorProfile\n")));

    //
    // Validate parameters
    //

    if (!ValidHandle(hProfile, OBJ_PROFILE))
    {
        WARNING((__TEXT("Invalid parameter to CloseColorProfile\n")));
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    return FreeProfileObject(hProfile);
}


/******************************************************************************
 *
 *                          GetColorProfileFromHandle
 *
 *  Function:
 *       This functions returns a buffer filled with the profile contents.
 *
 *  Arguments:
 *       hProfile     - handle identifing the profile object
 *       pProfileData - pointer to buffer to receive the data. Can be NULL.
 *       pcbData      - pointer to size of buffer. On return it is size
 *                      filled/needed.
 *
 *  Returns:
 *       TRUE if successful, FALSE otherwise
 *
 ******************************************************************************/

BOOL WINAPI GetColorProfileFromHandle(
    HPROFILE  hProfile,
    PBYTE     pProfileData,
    PDWORD    pcbSize
    )
{
    PPROFOBJ pProfObj;
    DWORD    dwFileSize;
    BOOL     rc = FALSE;

    //
    // ValidatePrameters
    //

    if (!ValidHandle(hProfile, OBJ_PROFILE) ||
        !pcbSize ||
        IsBadWritePtr(pcbSize, sizeof(DWORD)) ||
        (pProfileData &&
         IsBadWritePtr(pProfileData, *pcbSize)))
    {
        WARNING((__TEXT("Invalid parameter to CloseColorProfile\n")));
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    pProfObj = (PPROFOBJ)HDLTOPTR(hProfile);

    ASSERT(pProfObj != NULL);

    dwFileSize = FIX_ENDIAN(HEADER(pProfObj)->phSize);

    if (pProfileData && *pcbSize >= dwFileSize)
    {
        CopyMemory(pProfileData, pProfObj->pView, dwFileSize);
        rc = TRUE;
    }
    else
    {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
    }

    *pcbSize = dwFileSize;

    return rc;
}


/******************************************************************************
 *
 *                            IsColorProfileValid
 *
 *  Function:
 *       This functions checks if a given profile is a valid ICC profile
 *       that can be used for color matching
 *
 *  Arguments:
 *       hProfile - handle identifing the profile object
 *       pbValid  - Pointer to variable that receives TRUE if it is a
 *                  valid profile, FALSE otherwise
 *
 *  Returns:
 *       TRUE if successful, FALSE otherwise
 *
 ******************************************************************************/

BOOL WINAPI IsColorProfileValid(
    HPROFILE hProfile,
    PBOOL    pbValid
    )
{
    PPROFOBJ pProfObj;
    PCMMOBJ  pCMMObj;
    DWORD    cmmID;
    BOOL     rc = FALSE;

    TRACEAPI((__TEXT("IsColorProfileValid\n")));

    //
    // Validate parameters
    //

    if (!ValidHandle(hProfile, OBJ_PROFILE) ||
        !pbValid ||
        IsBadWritePtr(pbValid, sizeof(BOOL)))
    {
        WARNING((__TEXT("Invalid parameter to IsColorProfileValid\n")));
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    pProfObj = (PPROFOBJ)HDLTOPTR(hProfile);

    ASSERT(pProfObj != NULL);

    //
    // Quick check on the integrity of the profile before calling the CMM
    //

    if (!ValidProfile(pProfObj))
    {
        *pbValid = FALSE;
        return TRUE;
    }

    //
    // Get CMM associated with profile. If it does not exist or does not
    // support the CMValidate function, get default CMM.
    //

    cmmID = HEADER(pProfObj)->phCMMType;
    cmmID = FIX_ENDIAN(cmmID);

    pCMMObj  = GetColorMatchingModule(cmmID);
    if (!pCMMObj || !pCMMObj->fns.pCMIsProfileValid)
    {
        TERSE((__TEXT("CMM associated with profile could not be used")));

        if (pCMMObj)
        {
            ReleaseColorMatchingModule(pCMMObj);
        }

        pCMMObj = GetColorMatchingModule(CMM_WINDOWS_DEFAULT);
        if (!pCMMObj || !pCMMObj->fns.pCMIsProfileValid)
        {
            RIP((__TEXT("Default CMM doesn't support CMValidateProfile")));
            SetLastError(ERROR_INVALID_CMM);
            goto EndIsColorProfileValid;
        }
    }

    ASSERT(pProfObj->pView != NULL);
    rc = pCMMObj->fns.pCMIsProfileValid(hProfile, pbValid);

EndIsColorProfileValid:

    if (pCMMObj)
    {
        ReleaseColorMatchingModule(pCMMObj);
    }

    return rc;
}


/******************************************************************************
 *
 *                         CreateProfileFromLogColorSpace
 *
 *  Function:
 *       These are the ANSI & Unicode wrappers for InternalCreateProfileFromLCS.
 *       Please see InternalCreateProfileFromLCS for more details on this
 *       function.
 *
 *  Returns:
 *       TRUE if successful, FALSE otherwise
 *
 ******************************************************************************/

#ifdef UNICODE          // Windows NT versions

BOOL WINAPI CreateProfileFromLogColorSpaceA(
    LPLOGCOLORSPACEA pLogColorSpace,
    PBYTE            *pBuffer
    )
{
    LOGCOLORSPACEW lcs;

    //
    // Validate Parameters
    //

    if (! pLogColorSpace ||
        IsBadReadPtr(pLogColorSpace, sizeof(LOGCOLORSPACEA)) ||
        pLogColorSpace->lcsFilename[0] != '\0')
    {
        WARNING((__TEXT("Invalid parameter to CreateProfileFromLogColorSpace\n")));
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    *((LPLOGCOLORSPACEA)&lcs) = *pLogColorSpace;
    lcs.lcsFilename[0] = '\0';

    return InternalCreateProfileFromLCS(&lcs, pBuffer, FALSE);
}

BOOL WINAPI CreateProfileFromLogColorSpaceW(
    LPLOGCOLORSPACEW pLogColorSpace,
    PBYTE           *pBuffer
    )
{
    //
    // Internal function is Unicode in Windows NT, call it directly.
    //

    return InternalCreateProfileFromLCS(pLogColorSpace, pBuffer, TRUE);
}

#else                           // Windows 95 versions

BOOL WINAPI CreateProfileFromLogColorSpaceA(
    LPLOGCOLORSPACEA pLogColorSpace,
    PBYTE            *pBuffer
    )
{
    //
    // Internal function is ANSI in Windows 95, call it directly.
    //

    return InternalCreateProfileFromLCS(pLogColorSpace, pBuffer, TRUE);
}

BOOL WINAPI CreateProfileFromLogColorSpaceW(
    LPLOGCOLORSPACEW pLogColorSpace,
    PBYTE           *pBuffer
    )
{
    LOGCOLORSPACEA lcs;

    //
    // Validate Parameters
    //

    if (! pLogColorSpace ||
        IsBadReadPtr(pLogColorSpace, sizeof(LOGCOLORSPACEW)) ||
        pLogColorSpace->lcsFilename[0] != '\0')
    {
        WARNING((__TEXT("Invalid parameter to CreateProfileFromLogColorSpace\n")));
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    lcs = *((LPLOGCOLORSPACEA)pLogColorSpace);
    lcs.lcsFilename[0] = '\0';

    return InternalCreateProfileFromLCS(&lcs, pBuffer, FALSE);
}

#endif                          // ! UNICODE

/******************************************************************************
 *
 *                            IsColorProfileTagPresent
 *
 *  Function:
 *       This functions checks if a given tag is present in the profile
 *
 *  Arguments:
 *       hProfile - handle identifing the profile object
 *       tagType  - the tag to check for
 *       pbPrent  - pointer to variable that receives TRUE if it the tag is
 *                  present, FALSE otherwise
 *
 *  Returns:
 *       TRUE if successful, FALSE otherwise
 *
 ******************************************************************************/

BOOL WINAPI IsColorProfileTagPresent(
    HPROFILE hProfile,
    TAGTYPE  tagType,
    PBOOL    pbPresent
    )
{
    PPROFOBJ pProfObj;
    PTAGDATA pTagData;
    DWORD    nCount, i;

    TRACEAPI((__TEXT("IsColorProfileTagPresent\n")));

    //
    // Validate parameters
    //

    if (!ValidHandle(hProfile, OBJ_PROFILE) ||
        !pbPresent ||
        IsBadWritePtr(pbPresent, sizeof(BOOL)))
    {
        WARNING((__TEXT("Invalid parameter to IsColorProfileTagPresent\n")));
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    pProfObj = (PPROFOBJ)HDLTOPTR(hProfile);

    ASSERT(pProfObj != NULL);

    //
    // Check the integrity of the profile
    //

    if (!ValidProfile(pProfObj))
    {
        WARNING((__TEXT("Invalid profile passed to IsColorProfileTagPresent\n")));
        SetLastError(ERROR_INVALID_PROFILE);
        return FALSE;
    }

    //
    // Get count of tag items - it is right after the profile header
    //

    nCount = TAG_COUNT(pProfObj);
    nCount = FIX_ENDIAN(nCount);

    VERBOSE((__TEXT("Profile 0x%x has 0x%x(%d) tags\n"), hProfile, nCount, nCount));

    //
    // Tag data records follow the count.
    //

    pTagData = TAG_DATA(pProfObj);

    //
    // Check if any of these records match the tag passed in.
    //

    *pbPresent = FALSE;
    tagType = FIX_ENDIAN(tagType);      // to match tags in profile
    for (i=0; i<nCount; i++)
    {
        if (pTagData->tagType == tagType)
        {
            *pbPresent = TRUE;
            break;
        }
        pTagData++;                     // Next record
    }

    return TRUE;
}


/******************************************************************************
 *
 *                            GetCountColorProfileElements
 *
 *  Function:
 *       This functions returns the number of tagged elements in the profile
 *
 *  Arguments:
 *       hProfile - handle identifing the profile object
 *       pnCount  - pointer to variable to receive number of tagged elements
 *  Returns:
 *       TRUE if successful, FALSE otherwise
 *
 ******************************************************************************/

BOOL WINAPI GetCountColorProfileElements(
    HPROFILE hProfile,
    PDWORD   pnCount
    )
{
    PPROFOBJ pProfObj;

    TRACEAPI((__TEXT("GetCountColorProfileElements\n")));

    //
    // Validate parameters
    //

    if (!ValidHandle(hProfile, OBJ_PROFILE) ||
        !pnCount ||
        IsBadWritePtr(pnCount, sizeof(DWORD)))
    {
        WARNING((__TEXT("Invalid parameter to GetCountColorProfileElements\n")));
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    pProfObj = (PPROFOBJ)HDLTOPTR(hProfile);

    ASSERT(pProfObj != NULL);

    //
    // Check the integrity of the profile
    //

    if (!ValidProfile(pProfObj))
    {
        WARNING((__TEXT("Invalid profile passed to GetCountColorProfileElements\n")));
        SetLastError(ERROR_INVALID_PROFILE);
        return FALSE;
    }

    //
    // Get count of tag items - it is right after the profile header
    //

    *pnCount = TAG_COUNT(pProfObj);
    *pnCount = FIX_ENDIAN(*pnCount);

    return TRUE;
}


/******************************************************************************
 *
 *                            GetColorProfileElementTag
 *
 *  Function:
 *       This functions retrieves the tag name of the dwIndex'th element
 *       in the profile
 *
 *  Arguments:
 *       hProfile - handle identifing the profile object
 *       dwIndex  - one-based index of the tag whose name is required
 *       pTagType - gets the name of the tag on return
 *
 *  Returns:
 *       TRUE if successful, FALSE otherwise
 *
 ******************************************************************************/

BOOL WINAPI GetColorProfileElementTag(
    HPROFILE  hProfile,
    DWORD     dwIndex,
    PTAGTYPE  pTagType
    )
{
    PPROFOBJ pProfObj;
    PTAGDATA pTagData;
    DWORD    nCount;
    BOOL     rc = FALSE;

    TRACEAPI((__TEXT("GetColorProfileElementTag\n")));

    //
    // Validate parameters
    //

    if (!ValidHandle(hProfile, OBJ_PROFILE) ||
        IsBadWritePtr(pTagType, sizeof(TAGTYPE)) ||
        dwIndex <= 0)
    {
        WARNING((__TEXT("Invalid parameter to GetColorProfileElementTag\n")));
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    pProfObj = (PPROFOBJ)HDLTOPTR(hProfile);

    ASSERT(pProfObj != NULL);

    //
    // Check the integrity of the profile
    //

    if (!ValidProfile(pProfObj))
    {
        WARNING((__TEXT("Invalid profile passed to GetColorProfileElementTag\n")));
        SetLastError(ERROR_INVALID_PROFILE);
        return FALSE;
    }

    //
    // Get count of tag items - it is right after the profile header
    //

    nCount = TAG_COUNT(pProfObj);
    nCount = FIX_ENDIAN(nCount);

    if (dwIndex > nCount)
    {
        WARNING((__TEXT("GetColorProfileElementTag:index (%d) invalid\n"), dwIndex));
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // Tag data records follow the count.
    //

    pTagData = TAG_DATA(pProfObj);

    *pTagType = FIX_ENDIAN(pTagData[dwIndex-1].tagType);    // 1-based index

    return TRUE;
}


/******************************************************************************
 *
 *                            GetColorProfileElement
 *
 *  Function:
 *       This functions retrieves the data that a tagged element refers to
 *       starting from the given offset.
 *
 *  Arguments:
 *       hProfile - handle identifing the profile object
 *       tagType  - the tag name of the element whose data is required
 *       dwOffset - offset within the element data from which to retrieve
 *       pcbSize  - number of bytes to get. On return it is the number of
 *                  bytes retrieved
 *       pBuffer  - pointer to buffer to recieve data
 *
 *  Returns:
 *       TRUE if successful, FALSE otherwise
 *
 *  Comments:
 *       If pBuffer is NULL, it returns size of data in *pcbSize and ignores
 *       dwOffset.
 *
 ******************************************************************************/

BOOL WINAPI GetColorProfileElement(
    HPROFILE hProfile,
    TAGTYPE  tagType,
    DWORD    dwOffset,
    PDWORD   pcbSize,
    PVOID    pBuffer,
    PBOOL    pbReference
    )
{
    PPROFOBJ pProfObj;
    PTAGDATA pTagData;
    DWORD    nCount, nBytes, i;
    BOOL     found;
    BOOL     rc = FALSE;            // Assume failure

    TRACEAPI((__TEXT("GetColorProfileElement\n")));

    //
    // Validate parameters
    //

    if (!ValidHandle(hProfile, OBJ_PROFILE) ||
        !pcbSize ||
        IsBadWritePtr(pcbSize, sizeof(DWORD)) ||
        !pbReference ||
        IsBadWritePtr(pbReference, sizeof(BOOL))
       )
    {
        WARNING((__TEXT("Invalid parameter to GetColorProfileElement\n")));
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    pProfObj = (PPROFOBJ)HDLTOPTR(hProfile);

    ASSERT(pProfObj != NULL);

    //
    // Check the integrity of the profile
    //

    if (!ValidProfile(pProfObj))
    {
        WARNING((__TEXT("Invalid profile passed to GetColorProfileElement\n")));
        SetLastError(ERROR_INVALID_PROFILE);
        return FALSE;
    }

    //
    // Get count of tag items - it is right after the profile header
    //

    nCount = TAG_COUNT(pProfObj);
    nCount = FIX_ENDIAN(nCount);

    //
    // Tag data records follow the count.
    //

    pTagData = TAG_DATA(pProfObj);

    //
    // Check if any of these records match the tag passed in.
    //

    found = FALSE;
    tagType = FIX_ENDIAN(tagType);      // to match tags in profile
    for (i=0; i<nCount; i++)
    {
        if (pTagData->tagType == tagType)
        {
            found = TRUE;
            break;
        }
        pTagData++;                     // next record
    }

    if (found)
    {
        //
        // If pBuffer is NULL, copy size of data
        //

        if (!pBuffer)
        {
            *pcbSize = FIX_ENDIAN(pTagData->cbSize);
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
        }
        else
        {
            //
            // pBuffer is not NULL, get number of bytes to copy
            //

            if (dwOffset >= FIX_ENDIAN(pTagData->cbSize))
            {
                WARNING((__TEXT("dwOffset too large for GetColorProfileElement\n")));
                SetLastError(ERROR_INVALID_PARAMETER);
                return FALSE;
            }
            else if (dwOffset + *pcbSize > FIX_ENDIAN(pTagData->cbSize))
            {
                nBytes = FIX_ENDIAN(pTagData->cbSize) - dwOffset;
            }
            else
            {
                nBytes = *pcbSize;
            }

            //
            // Check if output buffer is large enough
            //

            if (IsBadWritePtr(pBuffer, nBytes))
            {
                WARNING((__TEXT("Bad buffer passed to GetColorProfileElement\n")));
                SetLastError(ERROR_INVALID_PARAMETER);
                return FALSE;
            }

            //
            // Copy the data into user supplied buffer
            //

            CopyMemory((PVOID)pBuffer,
                (PVOID)(pProfObj->pView + FIX_ENDIAN(pTagData->dwOffset)
                + dwOffset), nBytes);
            *pcbSize = nBytes;
            rc = TRUE;                      // Success!
        }

        //
        // Check if multiple tags reference this tag's data
        //

        *pbReference = IsReferenceTag(pProfObj, pTagData);
    }
    else
    {
        SetLastError(ERROR_TAG_NOT_FOUND);
    }

    return rc;
}


/******************************************************************************
 *
 *                        SetColorProfileElementSize
 *
 *  Function:
 *       This functions sets the data size of a tagged element. If the element
 *       is already present in the profile it's size is changed, and the data
 *       is truncated or extended as the case may be. If the element is not
 *       present, it is created and the data is filled with zeroes.
 *
 *  Arguments:
 *       hProfile - handle identifing the profile object
 *       tagType  - the tag name of the element
 *       cbSize   - new size for the element data
 *
 *  Returns:
 *       TRUE if successful, FALSE otherwise
 *
 *  Comments:
 *       If cbSize is 0, and the element is present, it is deleted.
 *
 ******************************************************************************/

BOOL WINAPI SetColorProfileElementSize(
    HPROFILE  hProfile,
    TAGTYPE   tagType,
    DWORD     cbSize
    )
{
    PTAGDATA pTagData;
    PPROFOBJ pProfObj;
    DWORD    i, nCount, newSize;
    TAGTYPE  rawTag;
    BOOL     found, rc = FALSE;

    TRACEAPI((__TEXT("SetColorProfileElementSize\n")));

    //
    // Validate parameters
    //

    if (!ValidHandle(hProfile, OBJ_PROFILE))
    {
        WARNING((__TEXT("Invalid parameter to SetColorProfileElementSize\n")));
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    pProfObj = (PPROFOBJ)HDLTOPTR(hProfile);

    ASSERT(pProfObj != NULL);

    //
    // Check the integrity of the profile
    //

    if (!ValidProfile(pProfObj))
    {
        WARNING((__TEXT("Invalid profile passed to SetColorProfileElementSize\n")));
        SetLastError(ERROR_INVALID_PROFILE);
        return FALSE;
    }

    //
    // Check if profile has write access
    //

    if (!(pProfObj->dwFlags & READWRITE_ACCESS))
    {
        WARNING((__TEXT("Writing to a profile without read/write access\n")));
        SetLastError(ERROR_ACCESS_DENIED);
        return FALSE;
    }

    //
    // Get count of tag items - it is right after the profile header
    //

    nCount = TAG_COUNT(pProfObj);
    nCount = FIX_ENDIAN(nCount);

    //
    // Tag data records follow the count.
    //

    pTagData = TAG_DATA(pProfObj);

    //
    // Check if any of these records match the tag passed in.
    //

    found = FALSE;
    rawTag = FIX_ENDIAN(tagType);
    for (i=0; i<nCount; i++)
    {
        if (pTagData->tagType == rawTag)
        {
            found = TRUE;
            break;
        }
        pTagData++;                     // Next record
    }

    if (found)
    {
        //
        // If it is a reference tag, create data area for it
        //

        if (IsReferenceTag(pProfObj, pTagData))
        {
            if (cbSize == 0)
            {
                PTAGDATA pTemp;

                //
                // Move everything after the tag table entry up
                // by size of one tag table entry.
                //

                MoveProfileData(pProfObj, (PBYTE)(pTagData+1), (PBYTE)pTagData,
                    PROFILE_SIZE(pProfObj) - (LONG)((PBYTE)(pTagData+1) - VIEW(pProfObj)), TRUE);

                //
                // Go through the tag table and update the pointers
                //

                pTemp = TAG_DATA(pProfObj);

                //
                // Get count of tag items - it is right after the profile header
                //

                nCount = TAG_COUNT(pProfObj);
                nCount = FIX_ENDIAN(nCount) - 1;
                TAG_COUNT(pProfObj) = FIX_ENDIAN(nCount);

                for (i=0; i<nCount; i++)
                {
                    DWORD dwTemp = FIX_ENDIAN(pTemp->dwOffset);

                    dwTemp -= sizeof(TAGDATA);
                    pTemp->dwOffset = FIX_ENDIAN(dwTemp);
                    pTemp++;                     // Next record
                }

                //
                // Use nCount as a placeholder to calculate file size
                //

                nCount = FIX_ENDIAN(HEADER(pProfObj)->phSize) - sizeof(TAGDATA);
                HEADER(pProfObj)->phSize = FIX_ENDIAN(nCount);
            }
            else
            {
                DWORD dwOffset;

                //
                // Resize the profile if needed. For memory buffers, we have to realloc,
                // and for mapped objects, we have to close and reopen the view.
                //

                newSize = FIX_ENDIAN(HEADER(pProfObj)->phSize);
                newSize = DWORD_ALIGN(newSize) + cbSize;

                //
                // Check for overflow
                //

                if (newSize < FIX_ENDIAN(HEADER(pProfObj)->phSize) ||
                    newSize < cbSize)
                {
                    WARNING((__TEXT("Overflow in setting reference element size\n")));
                    SetLastError(ERROR_ARITHMETIC_OVERFLOW);
                    return FALSE;
                }

                if (newSize > pProfObj->dwMapSize)
                {
                    //Sundown: dwOffset should not be over 4gb
                    DWORD dwOffset = (ULONG)(ULONG_PTR)(pTagData - TAG_DATA(pProfObj));

                    if (! GrowProfile(pProfObj, newSize))
                    {
                        return FALSE;
                    }
                    //
                    // Recalculate pointers as mapping or memory pointer
                    // could have changed when growing profile
                    //

                    pTagData = TAG_DATA(pProfObj) + dwOffset;
                }

                //
                // Calculate location of new data - should be DWORD aligned
                //

                dwOffset = DWORD_ALIGN(FIX_ENDIAN(HEADER(pProfObj)->phSize));
                pTagData->dwOffset = FIX_ENDIAN(dwOffset);

                //
                // Set final file size
                //

                HEADER(pProfObj)->phSize = FIX_ENDIAN(dwOffset+cbSize);
            }

            rc = TRUE;
        }
        else
        {
            if (cbSize == 0)
            {
                rc = DeleteTaggedElement(pProfObj, pTagData);
            }
            else
            {
                DWORD cbOldSize;

                //
                // Get current size of element
                //

                cbOldSize = FIX_ENDIAN(pTagData->cbSize);

                //
                // Compress or expand the file as the case may be.
                //

                if (cbSize > cbOldSize)
                {
                    //Sundown: dwOffset should be safe to truncate
                    DWORD dwOffset = (ULONG)(ULONG_PTR)(pTagData - TAG_DATA(pProfObj));

                    //
                    // Check for overflow
                    //

                    newSize = PROFILE_SIZE(pProfObj) + DWORD_ALIGN(cbSize) -
                        DWORD_ALIGN(cbOldSize);

                    if (newSize < PROFILE_SIZE(pProfObj))
                    {
                        WARNING((__TEXT("Overflow in increasing element size\n")));
                        SetLastError(ERROR_ARITHMETIC_OVERFLOW);
                        return FALSE;
                    }

                    if (!GrowProfile(pProfObj, newSize))
                    {
                        return FALSE;
                    }

                    //
                    // Recompute pointers
                    //

                    pTagData = TAG_DATA(pProfObj) + dwOffset;
                }

                rc = ChangeTaggedElementSize(pProfObj, pTagData, cbSize);
            }
        }
    }
    else
    {
        if (cbSize == 0)
        {
            WARNING((__TEXT("SetColorProfileElementSize (deleting): Tag not found\n")));
            SetLastError(ERROR_TAG_NOT_FOUND);
        }
        else
        {
            rc = AddTaggedElement(pProfObj, tagType, cbSize);
        }
    }

    return rc;
}


/******************************************************************************
 *
 *                          SetColorProfileElement
 *
 *  Function:
 *       This functions sets the data for a tagged element. It does not
 *       change the size of the element, and only writes as much data as
 *       would fit within the current size, overwriting any existing data.
 *
 *  Arguments:
 *       hProfile - handle identifing the profile object
 *       tagType  - the tag name of the element
 *       dwOffset - offset within the element data from which to write
 *       pcbSize  - number of bytes to write. On return it is the number of
 *                  bytes written.
 *       pBuffer  - pointer to buffer having data to write
 *
 *  Returns:
 *       TRUE if successful, FALSE otherwise
 *
 ******************************************************************************/

BOOL WINAPI SetColorProfileElement(
    HPROFILE  hProfile,
    TAGTYPE   tagType,
    DWORD     dwOffset,
    PDWORD    pcbSize,
    PVOID     pBuffer
    )
{
    PPROFOBJ pProfObj;
    PTAGDATA pTagData;
    DWORD    nCount, nBytes, i;
    BOOL     found;
    BOOL     rc = FALSE;            // Assume failure

    TRACEAPI((__TEXT("SetColorProfileElement\n")));

    //
    // Validate parameters
    //

    if (!ValidHandle(hProfile, OBJ_PROFILE) ||
        !pcbSize ||
        IsBadWritePtr(pcbSize, sizeof(DWORD)) ||
        !pBuffer ||
        IsBadReadPtr(pBuffer, *pcbSize)
       )
    {
        WARNING((__TEXT("Invalid parameter to SetColorProfileElement\n")));
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    pProfObj = (PPROFOBJ)HDLTOPTR(hProfile);

    ASSERT(pProfObj != NULL);

    //
    // Check the integrity of the profile
    //

    if (!ValidProfile(pProfObj))
    {
        WARNING((__TEXT("Invalid profile passed to SetColorProfileElement\n")));
        SetLastError(ERROR_INVALID_PROFILE);
        return FALSE;
    }

    //
    // Check if profile has write access
    //

    if (!(pProfObj->dwFlags & READWRITE_ACCESS))
    {
        WARNING((__TEXT("Writing to a profile without read/write access\n")));
        SetLastError(ERROR_ACCESS_DENIED);
        return FALSE;
    }

    //
    // Get count of tag items - it is right after the profile header
    //

    nCount = TAG_COUNT(pProfObj);
    nCount = FIX_ENDIAN(nCount);

    //
    // Tag data records follow the count.
    //

    pTagData = TAG_DATA(pProfObj);

    //
    // Check if any of these records match the tag passed in
    //

    found = FALSE;
    tagType = FIX_ENDIAN(tagType);
    for (i=0; i<nCount; i++)
    {
        if (pTagData->tagType == tagType)
        {
            found = TRUE;
            break;
        }
        pTagData++;                     // Next record
    }

    if (found)
    {
        //
        // If it is a reference tag, create new space for it
        //

        if (IsReferenceTag(pProfObj, pTagData))
        {
            SetColorProfileElementSize(hProfile, tagType, FIX_ENDIAN(pTagData->cbSize));
        }

        //
        // Get number of bytes to set
        //

        if (dwOffset >= FIX_ENDIAN(pTagData->cbSize))
        {
            WARNING((__TEXT("dwOffset too large for SetColorProfileElement\n")));
            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }
        else if (dwOffset + *pcbSize > FIX_ENDIAN(pTagData->cbSize))
        {
            nBytes = FIX_ENDIAN(pTagData->cbSize) - dwOffset;
        }
        else
        {
            nBytes = *pcbSize;
        }

        //
        // Copy the data into the profile
        //

        CopyMemory((PVOID)(pProfObj->pView + FIX_ENDIAN(pTagData->dwOffset)
            + dwOffset), (PVOID)pBuffer, nBytes);
        *pcbSize = nBytes;

        rc = TRUE;
    }
    else
    {
        WARNING((__TEXT("SetColorProfileElement: Tag not found\n")));
        SetLastError(ERROR_TAG_NOT_FOUND);
    }

    return rc;
}


/******************************************************************************
 *
 *                       SetColorProfileElementReference
 *
 *  Function:
 *       This functions creates a new tag and makes it refer to the same
 *       data as an existing tag.
 *
 *  Arguments:
 *       hProfile - handle identifing the profile object
 *       newTag   - new tag to create
 *       refTag   - reference tag whose data newTag should refer to
 *
 *  Returns:
 *       TRUE if successful, FALSE otherwise
 *
 ******************************************************************************/

BOOL WINAPI SetColorProfileElementReference(
    HPROFILE hProfile,
    TAGTYPE  newTag,
    TAGTYPE  refTag
    )
{
    PPROFOBJ pProfObj;
    PTAGDATA pTagData, pOrigTag;
    DWORD    nCount, i;
    BOOL     found;
    BOOL     rc = FALSE;            // Assume failure

    TRACEAPI((__TEXT("SetColorProfileElementReference\n")));

    //
    // Validate parameters
    //

    if (!ValidHandle(hProfile, OBJ_PROFILE))
    {
        WARNING((__TEXT("Invalid parameter to SetColorProfileElementReference\n")));
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    pProfObj = (PPROFOBJ)HDLTOPTR(hProfile);

    ASSERT(pProfObj != NULL);

    //
    // Check the integrity of the profile
    //

    if (!ValidProfile(pProfObj))
    {
        WARNING((__TEXT("Invalid profile passed to SetColorProfileElementReference\n")));
        SetLastError(ERROR_INVALID_PROFILE);
        return FALSE;
    }

    //
    // Check if profile has write access
    //

    if (!(pProfObj->dwFlags & READWRITE_ACCESS))
    {
        WARNING((__TEXT("Writing to a profile without read/write access\n")));
        SetLastError(ERROR_ACCESS_DENIED);
        return FALSE;
    }

    //
    // Get count of tag items - it is right after the profile header
    //
    nCount = TAG_COUNT(pProfObj);
    nCount = FIX_ENDIAN(nCount);

    //
    // Tag data records follow the count.
    //

    pTagData = TAG_DATA(pProfObj);

    //
    // Check if any of these records match the tag passed in
    //

    found = FALSE;
    refTag = FIX_ENDIAN(refTag);
    for (i=0; i<nCount; i++)
    {
        if (pTagData->tagType == refTag)
        {
            pOrigTag = pTagData;
            found = TRUE;
        }

        if (pTagData->tagType == FIX_ENDIAN(newTag))
        {
            WARNING((__TEXT("Duplicate tag present in SetColorProfileElementReference %x\n"), newTag));
            SetLastError(ERROR_DUPLICATE_TAG);
            return FALSE;
        }
        pTagData++;                     // Next record
    }

    if (found)
    {
        DWORD newSize;

        //
        // Grow profile if needed
        //

        newSize = FIX_ENDIAN(HEADER(pProfObj)->phSize);
        newSize = DWORD_ALIGN(newSize) + sizeof(TAGDATA);

        //
        // Check for overflow
        //

        if (newSize < FIX_ENDIAN(HEADER(pProfObj)->phSize))
        {
            WARNING((__TEXT("Overflow in adding element\n")));
            SetLastError(ERROR_ARITHMETIC_OVERFLOW);
            return FALSE;
        }

        if (newSize > pProfObj->dwMapSize)
        {
            //Sundown: safe truncation
            DWORD dwOffset = (ULONG)(ULONG_PTR)(pOrigTag - TAG_DATA(pProfObj));

            if (! GrowProfile(pProfObj, newSize))
            {
                return FALSE;
            }
            //
            // Recalculate pointers as mapping or memory pointer
            // could have changed when growing profile
            //

            pOrigTag = TAG_DATA(pProfObj) + dwOffset;
        }

        rc = AddTagTableEntry(pProfObj, newTag, FIX_ENDIAN(pOrigTag->dwOffset),
            FIX_ENDIAN(pOrigTag->cbSize), FALSE);
    }
    else
    {
        WARNING((__TEXT("SetColorProfileElementReference: Tag 0x%x not found\n"),
            FIX_ENDIAN(refTag)));       // Re-fix it to reflect data passed in
        SetLastError(ERROR_TAG_NOT_FOUND);
    }

    return rc;
}


/******************************************************************************
 *
 *                       GetColorProfileHeader
 *
 *  Function:
 *       This functions retrieves the header of a profile
 *
 *  Arguments:
 *       hProfile - handle identifing the profile object
 *       pHeader  - pointer to buffer to recieve the header
 *
 *  Returns:
 *       TRUE if successful, FALSE otherwise
 *
 ******************************************************************************/

BOOL WINAPI GetColorProfileHeader(
    HPROFILE       hProfile,
    PPROFILEHEADER pHeader
    )
{
    PPROFOBJ pProfObj;
    DWORD    nCount, i, temp;

    TRACEAPI((__TEXT("GetColorProfileHeader\n")));

    //
    // Validate parameters
    //

    if (!ValidHandle(hProfile, OBJ_PROFILE) ||
        IsBadWritePtr(pHeader, sizeof(PROFILEHEADER)))
    {
        WARNING((__TEXT("Invalid parameter to GetColorProfileHeader\n")));
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    pProfObj = (PPROFOBJ)HDLTOPTR(hProfile);

    ASSERT(pProfObj != NULL);

    //
    // Check the integrity of the profile.
    //

    if (!ValidProfile(pProfObj))
    {
        WARNING((__TEXT("Invalid profile passed to GetColorProfileHeader\n")));
        SetLastError(ERROR_INVALID_PROFILE);
        return FALSE;
    }

    CopyMemory((PVOID)pHeader, (PVOID)pProfObj->pView,
        sizeof(PROFILEHEADER));

    //
    // Fix up all fields to platform specific values.
    // The following code assumes that the profile header is a
    // multiple of DWORDs which it is!
    //

    ASSERT(sizeof(PROFILEHEADER) % sizeof(DWORD) == 0);

    nCount = sizeof(PROFILEHEADER)/sizeof(DWORD);
    for (i=0; i<nCount;i++)
    {
        temp = (DWORD)((PDWORD)pHeader)[i];
        ((PDWORD)pHeader)[i] = FIX_ENDIAN(temp);
    }

    return TRUE;
}


/******************************************************************************
 *
 *                       SetColorProfileHeader
 *
 *  Function:
 *       This functions sets the header of a profile
 *
 *  Arguments:
 *       hProfile - handle identifing the profile object
 *       pHeader  - pointer to buffer identifing the header
 *
 *  Returns:
 *       TRUE if successful, FALSE otherwise
 *
 ******************************************************************************/

BOOL WINAPI SetColorProfileHeader(
    HPROFILE       hProfile,
    PPROFILEHEADER pHeader
    )
{
    PPROFOBJ pProfObj;
    DWORD    nCount, i, temp;

    TRACEAPI((__TEXT("SetColorProfileHeader\n")));

    //
    // Validate parameters
    //

    if (!ValidHandle(hProfile, OBJ_PROFILE) ||
        IsBadReadPtr(pHeader, sizeof(PROFILEHEADER)))
    {
        WARNING((__TEXT("Invalid parameter to SetColorProfileHeader\n")));
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    pProfObj = (PPROFOBJ)HDLTOPTR(hProfile);

    ASSERT(pProfObj != NULL);

    //
    // Check if profile has write access
    //

    if (!(pProfObj->dwFlags & READWRITE_ACCESS))
    {
        WARNING((__TEXT("Writing to a profile without read/write access\n")));
        SetLastError(ERROR_ACCESS_DENIED);
        return FALSE;
    }

    //
    // Fix up all fields to BIG-ENDIAN.
    // The following code assumes that the profile header is a
    // multiple of DWORDs which it is!
    //

    ASSERT(sizeof(PROFILEHEADER) % sizeof(DWORD) == 0);

    nCount = sizeof(PROFILEHEADER)/sizeof(DWORD);
    for (i=0; i<nCount;i++)
    {
        temp = (DWORD)((PDWORD)pHeader)[i];
        ((PDWORD)pHeader)[i] = FIX_ENDIAN(temp);
    }

    CopyMemory((PVOID)pProfObj->pView, (PVOID)pHeader,
        sizeof(PROFILEHEADER));

    //
    // Put back app supplied buffer the way it came in
    //

    for (i=0; i<nCount;i++)
    {
        temp = (DWORD)((PDWORD)pHeader)[i];
        ((PDWORD)pHeader)[i] = FIX_ENDIAN(temp);
    }

    return TRUE;
}


/******************************************************************************
 *
 *                        GetPS2ColorSpaceArray
 *
 *  Function:
 *       This functions retrieves the PostScript Level 2 CSA from the profile
 *
 *  Arguments:
 *       hProfile  - handle identifing the profile object
 *       dwIntent  - rendering intent of CSA
 *       dwCSAType - type of CSA
 *       pbuffer   - pointer to receive the CSA
 *       pcbSize   - pointer to size of buffer. If function fails because
 *                   buffer is not big enough, it is filled with required size.
 *       pcbBinary - TRUE if binary data is requested. On return it is set to
 *                   reflect the data returned
 *
 *  Returns:
 *       TRUE if successful, FALSE otherwise
 *
 ******************************************************************************/

BOOL WINAPI
GetPS2ColorSpaceArray (
    HPROFILE  hProfile,
    DWORD     dwIntent,
    DWORD     dwCSAType,
    PBYTE     pBuffer,
    PDWORD    pcbSize,
    LPBOOL    pbBinary
    )
{
    PPROFOBJ pProfObj;
    PCMMOBJ  pCMMObj;
    DWORD    cmmID;
    BOOL     rc;

    TRACEAPI((__TEXT("GetPS2ColorSpaceArray\n")));

    //
    // Validate parameters
    //

    if (!ValidHandle(hProfile, OBJ_PROFILE)   ||
        IsBadWritePtr(pcbSize, sizeof(DWORD)) ||
        (pBuffer &&
         IsBadWritePtr(pBuffer, *pcbSize)
        )                                     ||
        IsBadWritePtr(pbBinary, sizeof(BOOL))
       )
    {
        WARNING((__TEXT("Invalid parameter to GetPS2ColorSpaceArray\n")));
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    pProfObj = (PPROFOBJ)HDLTOPTR(hProfile);

    ASSERT(pProfObj != NULL);

    //
    // Check the integrity of the profile
    //

    if (!ValidProfile(pProfObj))
    {
        WARNING((__TEXT("Invalid profile passed to GetPS2ColorSpaceArray\n")));
        SetLastError(ERROR_INVALID_PROFILE);
        return FALSE;
    }

    //
    // Check if application specified CMM is present
    //

    pCMMObj = GetPreferredCMM();
    if (!pCMMObj || (pCMMObj->dwFlags & CMM_DONT_USE_PS2_FNS) ||
        !pCMMObj->fns.pCMGetPS2ColorSpaceArray)
    {
        if (pCMMObj)
        {
            pCMMObj->dwFlags |= CMM_DONT_USE_PS2_FNS;
            ReleaseColorMatchingModule(pCMMObj);
        }

        //
        // Get CMM associated with profile. If it does not exist or does not
        // support the CMGetPS2ColorSpaceArray function, get default CMM.
        //

        cmmID = HEADER(pProfObj)->phCMMType;
        cmmID = FIX_ENDIAN(cmmID);

        pCMMObj  = GetColorMatchingModule(cmmID);

        if (!pCMMObj || (pCMMObj->dwFlags & CMM_DONT_USE_PS2_FNS) ||
            !pCMMObj->fns.pCMGetPS2ColorSpaceArray)
        {
            TERSE((__TEXT("CMM associated with profile could not be used")));

            if (pCMMObj)
            {
                pCMMObj->dwFlags |= CMM_DONT_USE_PS2_FNS;
                ReleaseColorMatchingModule(pCMMObj);
            }

            pCMMObj = GetColorMatchingModule(CMM_WINDOWS_DEFAULT);

            if (!pCMMObj || !pCMMObj->fns.pCMGetPS2ColorSpaceArray)
            {
                WARNING((__TEXT("Default CMM doesn't support CMGetPS2ColorSpaceArray\n")));
                if (pCMMObj)
                {
                    ReleaseColorMatchingModule(pCMMObj);
                    pCMMObj = NULL;
                }
            }
        }
    }

    ASSERT(pProfObj->pView != NULL);

    if (pCMMObj)
    {
        rc = pCMMObj->fns.pCMGetPS2ColorSpaceArray(hProfile, dwIntent, dwCSAType,
            pBuffer, pcbSize, pbBinary);
    }
    else
    {
        rc = InternalGetPS2ColorSpaceArray(pProfObj->pView, dwIntent,
            dwCSAType, pBuffer, pcbSize, pbBinary);
    }

    if (pCMMObj)
    {
        ReleaseColorMatchingModule(pCMMObj);
    }

    VERBOSE((__TEXT("GetPS2ColorSpaceArray returning %s\n"),
        rc ? "TRUE" : "FALSE"));

    return rc;
}


/******************************************************************************
 *
 *                       GetPS2ColorRenderingIntent
 *
 *  Function:
 *       This functions retrieves the PostScript Level 2 color rendering intent
 *       from the profile
 *
 *  Arguments:
 *       hProfile  - handle identifing the profile object
 *       pbuffer   - pointer to receive the color rendering intent
 *       pcbSize   - pointer to size of buffer. If function fails because
 *                   buffer is not big enough, it is filled with required size.
 *       pcbBinary - TRUE if binary data is requested. On return it is set to
 *                   reflect the data returned
 *
 *  Returns:
 *       TRUE if successful, FALSE otherwise
 *
 ******************************************************************************/

BOOL WINAPI GetPS2ColorRenderingIntent(
    HPROFILE  hProfile,
    DWORD     dwIntent,
    PBYTE     pBuffer,
    PDWORD    pcbSize
    )
{
    PPROFOBJ pProfObj;
    PCMMOBJ  pCMMObj;
    DWORD    cmmID;
    BOOL     rc;

    TRACEAPI((__TEXT("GetPS2ColorRenderingIntent\n")));

    //
    // Validate parameters
    //

    if (!ValidHandle(hProfile, OBJ_PROFILE) ||
        IsBadWritePtr(pcbSize, sizeof(DWORD)) ||
        (pBuffer &&
         IsBadWritePtr(pBuffer, *pcbSize)
        )
       )
    {
        WARNING((__TEXT("Invalid parameter to GetPS2ColorRenderingIntent\n")));
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    pProfObj = (PPROFOBJ)HDLTOPTR(hProfile);

    ASSERT(pProfObj != NULL);

    //
    // Check the integrity of the profile
    //

    if (!ValidProfile(pProfObj))
    {
        WARNING((__TEXT("Invalid profile passed to GetPS2ColorRenderingIntent\n")));
        SetLastError(ERROR_INVALID_PROFILE);
        return FALSE;
    }

    //
    // Check if application specified CMM is present
    //

    pCMMObj = GetPreferredCMM();
    if (!pCMMObj || (pCMMObj->dwFlags & CMM_DONT_USE_PS2_FNS) ||
        !pCMMObj->fns.pCMGetPS2ColorRenderingIntent)
    {
        if (pCMMObj)
        {
            pCMMObj->dwFlags |= CMM_DONT_USE_PS2_FNS;
            ReleaseColorMatchingModule(pCMMObj);
        }

        //
        // Get CMM associated with profile. If it does not exist or does not
        // support the CMGetPS2ColorSpaceArray function, get default CMM.
        //

        cmmID = HEADER(pProfObj)->phCMMType;
        cmmID = FIX_ENDIAN(cmmID);

        pCMMObj  = GetColorMatchingModule(cmmID);

        if (!pCMMObj || (pCMMObj->dwFlags & CMM_DONT_USE_PS2_FNS) ||
            !pCMMObj->fns.pCMGetPS2ColorRenderingIntent)
        {
            TERSE((__TEXT("CMM associated with profile could not be used")));

            if (pCMMObj)
            {
                pCMMObj->dwFlags |= CMM_DONT_USE_PS2_FNS;
                ReleaseColorMatchingModule(pCMMObj);
            }

            pCMMObj = GetColorMatchingModule(CMM_WINDOWS_DEFAULT);

            if (!pCMMObj || !pCMMObj->fns.pCMGetPS2ColorRenderingIntent)
            {
                WARNING((__TEXT("Default CMM doesn't support CMGetPS2ColorRenderingIntent\n")));
                if (pCMMObj)
                {
                    ReleaseColorMatchingModule(pCMMObj);
                    pCMMObj = NULL;
                }
            }
        }
    }

    ASSERT(pProfObj->pView != NULL);

    if (pCMMObj)
    {
        rc = pCMMObj->fns.pCMGetPS2ColorRenderingIntent(hProfile,
            dwIntent, pBuffer, pcbSize);
    }
    else
    {
        rc = InternalGetPS2ColorRenderingIntent(pProfObj->pView, dwIntent,
            pBuffer, pcbSize);
    }

    if (pCMMObj)
    {
        ReleaseColorMatchingModule(pCMMObj);
    }

    VERBOSE((__TEXT("GetPS2ColorRenderingIntent returning %s\n"),
        rc ? "TRUE" : "FALSE"));

    return rc;
}


/******************************************************************************
 *
 *                       GetPS2ColorRenderingDictionary
 *
 *  Function:
 *       This functions retrieves the PostScript Level 2 CRD from the profile
 *
 *  Arguments:
 *       hProfile  - handle identifing the profile object
 *       dwIntent  - intent whose CRD is required
 *       pbuffer   - pointer to receive the CSA
 *       pcbSize   - pointer to size of buffer. If function fails because
 *                   buffer is not big enough, it is filled with required size.
 *       pcbBinary - TRUE if binary data is requested. On return it is set to
 *                   reflect the data returned
 *
 *  Returns:
 *       TRUE if successful, FALSE otherwise
 *
 ******************************************************************************/

BOOL WINAPI GetPS2ColorRenderingDictionary(
    HPROFILE  hProfile,
    DWORD     dwIntent,
    PBYTE     pBuffer,
    PDWORD    pcbSize,
    PBOOL     pbBinary
    )
{
    PPROFOBJ pProfObj;
    PCMMOBJ  pCMMObj;
    DWORD    cmmID;
    BOOL     rc;

    TRACEAPI((__TEXT("GetPS2ColorRenderingDictionary\n")));

    //
    // Validate parameters
    //

    if (!ValidHandle(hProfile, OBJ_PROFILE)     ||
        IsBadWritePtr(pcbSize, sizeof(DWORD))   ||
        (pBuffer &&
         IsBadWritePtr(pBuffer, *pcbSize)
        )                                       ||
        IsBadWritePtr(pbBinary, sizeof(BOOL))
       )
    {
        WARNING((__TEXT("Invalid parameter to GetPS2ColorRenderingDictionary\n")));
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    pProfObj = (PPROFOBJ)HDLTOPTR(hProfile);

    ASSERT(pProfObj != NULL);

    //
    // Check the integrity of the profile
    //

    if (!ValidProfile(pProfObj))
    {
        WARNING((__TEXT("Invalid profile passed to GetPS2ColorRenderingDictionary\n")));
        SetLastError(ERROR_INVALID_PROFILE);
        return FALSE;
    }

    //
    // Check if application specified CMM is present
    //

    pCMMObj = GetPreferredCMM();
    if (!pCMMObj || (pCMMObj->dwFlags & CMM_DONT_USE_PS2_FNS) ||
        !pCMMObj->fns.pCMGetPS2ColorRenderingDictionary)
    {
        if (pCMMObj)
        {
            pCMMObj->dwFlags |= CMM_DONT_USE_PS2_FNS;
            ReleaseColorMatchingModule(pCMMObj);
        }

        //
        // Get CMM associated with profile. If it does not exist or does not
        // support the CMGetPS2ColorSpaceArray function, get default CMM.
        //

        cmmID = HEADER(pProfObj)->phCMMType;
        cmmID = FIX_ENDIAN(cmmID);

        pCMMObj  = GetColorMatchingModule(cmmID);

        if (!pCMMObj || (pCMMObj->dwFlags & CMM_DONT_USE_PS2_FNS) ||
            !pCMMObj->fns.pCMGetPS2ColorRenderingDictionary)
        {
            TERSE((__TEXT("CMM associated with profile could not be used")));

            if (pCMMObj)
            {
                pCMMObj->dwFlags |= CMM_DONT_USE_PS2_FNS;
                ReleaseColorMatchingModule(pCMMObj);
            }

            pCMMObj = GetColorMatchingModule(CMM_WINDOWS_DEFAULT);

            if (!pCMMObj || !pCMMObj->fns.pCMGetPS2ColorRenderingDictionary)
            {
                WARNING((__TEXT("Default CMM doesn't support CMGetPS2ColorRenderingDictionary\n")));
                if (pCMMObj)
                {
                    ReleaseColorMatchingModule(pCMMObj);
                    pCMMObj = NULL;
                }
            }
        }
    }

    ASSERT(pProfObj->pView != NULL);

    if (pCMMObj)
    {
        rc = pCMMObj->fns.pCMGetPS2ColorRenderingDictionary(hProfile, dwIntent,
            pBuffer, pcbSize, pbBinary);
    }
    else
    {
        rc = InternalGetPS2ColorRenderingDictionary(pProfObj->pView, dwIntent,
            pBuffer, pcbSize, pbBinary);
    }

    if (pCMMObj)
    {
        ReleaseColorMatchingModule(pCMMObj);
    }

    VERBOSE((__TEXT("GetPS2ColorRenderingDictionary returning %s\n"),
        rc ? "TRUE" : "FALSE"));

    return rc;
}


/******************************************************************************
 *
 *                         GetNamedProfileInfo
 *
 *  Function:
 *       This functions returns information about the given named color space
 *       profile. If fails if the given profile is not a named color space profile.
 *
 *  Arguments:
 *       hProfile          - handle identifying the named color space profile object
 *       pNamedProfileInfo - pointer to NAMED_PROFILE_INFO structure that is
 *                           filled on retun if successful.
 *
 *  Returns:
 *       TRUE if successful, FALSE otherwise
 *
 ******************************************************************************/

BOOL WINAPI GetNamedProfileInfo(
    HPROFILE              hProfile,
    PNAMED_PROFILE_INFO   pNamedProfileInfo
    )
{
    PPROFOBJ pProfObj;
    PCMMOBJ  pCMMObj;
    DWORD    cmmID;
    BOOL     rc;

    TRACEAPI((__TEXT("GetNamedProfileInfo\n")));

    //
    // Validate parameters
    //

    if (!ValidHandle(hProfile, OBJ_PROFILE)     ||
        !pNamedProfileInfo                      ||
        IsBadWritePtr(pNamedProfileInfo, sizeof(NAMED_PROFILE_INFO)))
    {
        WARNING((__TEXT("Invalid parameter to GetNamedProfileInfo\n")));
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    pProfObj = (PPROFOBJ)HDLTOPTR(hProfile);

    ASSERT(pProfObj != NULL);

    //
    // Check the integrity of the profile
    //

    if (!ValidProfile(pProfObj))
    {
        WARNING((__TEXT("Invalid profile passed to GetNamedProfileInfo\n")));
        SetLastError(ERROR_INVALID_PROFILE);
        return FALSE;
    }

    //
    // Check if application specified CMM is present
    //

    pCMMObj = GetPreferredCMM();
    if (!pCMMObj ||
        !pCMMObj->fns.pCMGetNamedProfileInfo)
    {
        if (pCMMObj)
        {
            ReleaseColorMatchingModule(pCMMObj);
        }

        //
        // Get CMM associated with profile. If it does not exist or does not
        // support the CMGetNamedProfileInfo function, get default CMM.
        //

        cmmID = HEADER(pProfObj)->phCMMType;
        cmmID = FIX_ENDIAN(cmmID);

        pCMMObj  = GetColorMatchingModule(cmmID);

        if (!pCMMObj ||
            !pCMMObj->fns.pCMGetNamedProfileInfo)
        {
            TERSE((__TEXT("CMM associated with profile could not be used")));

            if (pCMMObj)
            {
                ReleaseColorMatchingModule(pCMMObj);
            }

            pCMMObj = GetColorMatchingModule(CMM_WINDOWS_DEFAULT);

            if (!pCMMObj || !pCMMObj->fns.pCMGetNamedProfileInfo)
            {
                RIP((__TEXT("Default CMM doesn't support CMValidateProfile")));
                SetLastError(ERROR_INVALID_CMM);
                if (pCMMObj)
                {
                    ReleaseColorMatchingModule(pCMMObj);
                }
                return FALSE;
            }
        }
    }

    ASSERT(pProfObj->pView != NULL);

    rc = pCMMObj->fns.pCMGetNamedProfileInfo(hProfile, pNamedProfileInfo);

    ReleaseColorMatchingModule(pCMMObj);

    return rc;
}


/******************************************************************************
 *
 *                       ConvertColorNameToIndex
 *
 *  Function:
 *       This functions converts a given array of color names to color indices
 *       using the specified named color space profile
 *
 *  Arguments:
 *       hProfile     - handle identifing the named color space profile object
 *       paColorName  - pointer to array of COLOR_NAME structures
 *       paIndex      - pointer to array of DWORDs to receive the indices
 *       dwCount      - number of color names to convert
 *
 *  Returns:
 *       TRUE if successful, FALSE otherwise
 *
 ******************************************************************************/

BOOL WINAPI ConvertColorNameToIndex(
    HPROFILE      hProfile,
    PCOLOR_NAME   paColorName,
    PDWORD        paIndex,
    DWORD         dwCount
    )
{
    PPROFOBJ pProfObj;
    PCMMOBJ  pCMMObj;
    DWORD    cmmID;
    BOOL     rc;

    TRACEAPI((__TEXT("ConvertColorNameToIndex\n")));

    //
    // Validate parameters
    //

    if (!ValidHandle(hProfile, OBJ_PROFILE)     ||
        !paColorName                            ||
        dwCount == 0                            ||
        IsBadReadPtr(paColorName, dwCount*sizeof(COLOR_NAME)) ||
        !paIndex                                ||
        IsBadWritePtr(paIndex, dwCount*sizeof(DWORD)))
    {
        WARNING((__TEXT("Invalid parameter to ConvertColorNameToIndex\n")));
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    pProfObj = (PPROFOBJ)HDLTOPTR(hProfile);

    ASSERT(pProfObj != NULL);

    //
    // Check the integrity of the profile
    //

    if (!ValidProfile(pProfObj))
    {
        WARNING((__TEXT("Invalid profile passed to ConvertColorNameToIndex\n")));
        SetLastError(ERROR_INVALID_PROFILE);
        return FALSE;
    }

    //
    // Check if application specified CMM is present
    //

    pCMMObj = GetPreferredCMM();
    if (!pCMMObj ||
        !pCMMObj->fns.pCMConvertColorNameToIndex)
    {
        if (pCMMObj)
        {
            ReleaseColorMatchingModule(pCMMObj);
        }

        //
        // Get CMM associated with profile. If it does not exist or does not
        // support the CMConvertColorNameToIndex function, get default CMM.
        //

        cmmID = HEADER(pProfObj)->phCMMType;
        cmmID = FIX_ENDIAN(cmmID);

        pCMMObj  = GetColorMatchingModule(cmmID);

        if (!pCMMObj ||
            !pCMMObj->fns.pCMConvertColorNameToIndex)
        {
            TERSE((__TEXT("CMM associated with profile could not be used")));

            if (pCMMObj)
            {
                ReleaseColorMatchingModule(pCMMObj);
            }

            pCMMObj = GetColorMatchingModule(CMM_WINDOWS_DEFAULT);

            if (!pCMMObj || !pCMMObj->fns.pCMConvertColorNameToIndex)
            {
                RIP((__TEXT("Default CMM doesn't support CMConvertColorNameToIndex")));
                SetLastError(ERROR_INVALID_CMM);
                if (pCMMObj)
                {
                    ReleaseColorMatchingModule(pCMMObj);
                }
                return FALSE;
            }
        }
    }

    ASSERT(pProfObj->pView != NULL);

    rc = pCMMObj->fns.pCMConvertColorNameToIndex(
                            hProfile,
                            paColorName,
                            paIndex,
                            dwCount);

    ReleaseColorMatchingModule(pCMMObj);

    return rc;
}


/******************************************************************************
 *
 *                       ConvertIndexToColorName
 *
 *  Function:
 *       This functions converts a given array of color indices to color names
 *       using the specified named color space profile
 *
 *  Arguments:
 *       hProfile     - handle identifing the named color space profile object
 *       paIndex      - pointer to array of color indices
 *       paColorName  - pointer to array of COLOR_NAME structures
 *       dwCount      - number of color indices to convert
 *
 *  Returns:
 *       TRUE if successful, FALSE otherwise
 *
 ******************************************************************************/

BOOL WINAPI ConvertIndexToColorName(
    HPROFILE     hProfile,
    PDWORD       paIndex,
    PCOLOR_NAME  paColorName,
    DWORD        dwCount
    )
{
    PPROFOBJ pProfObj;
    PCMMOBJ  pCMMObj;
    DWORD    cmmID;
    BOOL     rc;

    TRACEAPI((__TEXT("ConvertIndexToColorName\n")));

    //
    // Validate parameters
    //

    if (!ValidHandle(hProfile, OBJ_PROFILE)     ||
        !paIndex                                ||
        dwCount == 0                            ||
        IsBadWritePtr(paIndex, dwCount*sizeof(DWORD))          ||
        !paColorName                            ||
        IsBadReadPtr(paColorName, dwCount*sizeof(COLOR_NAME)))
    {
        WARNING((__TEXT("Invalid parameter to ConvertIndexToColorName\n")));
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    pProfObj = (PPROFOBJ)HDLTOPTR(hProfile);

    ASSERT(pProfObj != NULL);

    //
    // Check the integrity of the profile
    //

    if (!ValidProfile(pProfObj))
    {
        WARNING((__TEXT("Invalid profile passed to ConvertIndexToColorName\n")));
        SetLastError(ERROR_INVALID_PROFILE);
        return FALSE;
    }

    //
    // Check if application specified CMM is present
    //

    pCMMObj = GetPreferredCMM();
    if (!pCMMObj ||
        !pCMMObj->fns.pCMConvertIndexToColorName)
    {
        if (pCMMObj)
        {
            ReleaseColorMatchingModule(pCMMObj);
        }

        //
        // Get CMM associated with profile. If it does not exist or does not
        // support the CMConvertIndexToColorName function, get default CMM.
        //

        cmmID = HEADER(pProfObj)->phCMMType;
        cmmID = FIX_ENDIAN(cmmID);

        pCMMObj  = GetColorMatchingModule(cmmID);

        if (!pCMMObj ||
            !pCMMObj->fns.pCMConvertIndexToColorName)
        {
            TERSE((__TEXT("CMM associated with profile could not be used")));

            if (pCMMObj)
            {
                ReleaseColorMatchingModule(pCMMObj);
            }

            pCMMObj = GetColorMatchingModule(CMM_WINDOWS_DEFAULT);

            if (!pCMMObj || !pCMMObj->fns.pCMConvertIndexToColorName)
            {
                RIP((__TEXT("Default CMM doesn't support CMConvertIndexToColorName")));
                SetLastError(ERROR_INVALID_CMM);
                if (pCMMObj)
                {
                    ReleaseColorMatchingModule(pCMMObj);
                }
                return FALSE;
            }
        }
    }

    ASSERT(pProfObj->pView != NULL);

    rc = pCMMObj->fns.pCMConvertIndexToColorName(
                            hProfile,
                            paIndex,
                            paColorName,
                            dwCount);

    ReleaseColorMatchingModule(pCMMObj);

    return rc;
}


/******************************************************************************
 *
 *                         CreateDeviceLinkProfile
 *
 *  Function:
 *       This functions creates a device link profile from the given set
 *       of profiles, using specified intents.
 *
 *  Arguments:
 *       pahProfiles       - pointer to array of handles of profiles
 *       nProfiles         - number of profiles in array
 *       padwIntent        - array of intents to use
 *       nIntents          - size of array - can be 1 or nProfiles
 *       dwFlags           - optimization flags
 *       pProfileData      - pointer to pointer to buffer to receive data which
 *                           this function allocates; caller needs to free.
 *       indexPreferredCMM - zero based index of profile which specifies
 *                           preferred CMM to use.
 *
 *  Returns:
 *       TRUE if successful, FALSE otherwise
 *
 ******************************************************************************/

BOOL  WINAPI CreateDeviceLinkProfile(
    PHPROFILE   pahProfiles,
    DWORD       nProfiles,
    PDWORD      padwIntent,
    DWORD       nIntents,
    DWORD       dwFlags,
    PBYTE      *pProfileData,
    DWORD       indexPreferredCMM
    )
{
    PPROFOBJ      pProfObj;
    PCMMOBJ       pCMMObj;
    DWORD         cmmID, i;
    BOOL          rc;

    TRACEAPI((__TEXT("CreateDeviceLinkProfile\n")));

    //
    // Validate parameters
    //

    if (nProfiles <= 1 ||
        indexPreferredCMM >= nProfiles ||
        pahProfiles == NULL ||
        IsBadReadPtr(pahProfiles, sizeof(HPROFILE) * nProfiles) ||
        padwIntent == NULL ||
        ((nIntents != nProfiles) && (nIntents != 1)) ||
        IsBadReadPtr(padwIntent, nIntents * sizeof(DWORD)))
    {
        WARNING((__TEXT("Invalid parameter to CreateDeviceLinkProfile\n")));
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    for (i=0; i<nProfiles; i++)
    {
        if ((pahProfiles[i] == NULL) ||
            ! ValidHandle(pahProfiles[i], OBJ_PROFILE))

        {
            WARNING((__TEXT("Invalid profile passed to CreateDeviceLinkProfile\n")));
            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }

        pProfObj = (PPROFOBJ)HDLTOPTR(pahProfiles[i]);

        ASSERT(pProfObj != NULL);

        ASSERT(pProfObj->pView != NULL);

        //
        // Quick check on the integrity of the profile
        //

        if (!ValidProfile(pProfObj))
        {
            WARNING((__TEXT("Invalid profile passed to CreateDeviceLinkProfile\n")));
            SetLastError(ERROR_INVALID_PROFILE);
            return FALSE;
        }

        if (i == indexPreferredCMM)
        {
            //
            // Get ID of preferred CMM
            //

            cmmID = HEADER(pProfObj)->phCMMType;
            cmmID = FIX_ENDIAN(cmmID);
        }
    }

    //
    // Get CMM associated with preferred profile. If it does not exist,
    // get default CMM.
    //

    pCMMObj  = GetColorMatchingModule(cmmID);
    if (!pCMMObj || !pCMMObj->fns.pCMCreateDeviceLinkProfile)
    {
        TERSE((__TEXT("CMM associated with profile could not be used")));

        if (pCMMObj)
        {
            ReleaseColorMatchingModule(pCMMObj);
        }

        pCMMObj = GetColorMatchingModule(CMM_WINDOWS_DEFAULT);
        if (!pCMMObj)
        {
            RIP((__TEXT("Default CMM not found\n")));
            SetLastError(ERROR_INVALID_CMM);
            return FALSE;
        }
    }

    ASSERT(pCMMObj->fns.pCMCreateDeviceLinkProfile != NULL);

    rc = pCMMObj->fns.pCMCreateDeviceLinkProfile(
                            pahProfiles,
                            nProfiles,
                            padwIntent,
                            nIntents,
                            dwFlags,
                            pProfileData);

    ReleaseColorMatchingModule(pCMMObj);

    return rc;
}


/*****************************************************************************/
/***************************** Internal Functions ****************************/
/*****************************************************************************/

/******************************************************************************
 *
 *                          InternalOpenColorProfile
 *
 *  Function:
 *       This functions opens a color profile specified by the pProfile
 *       parameter, creates an internal profile object, and returns a handle
 *       to it.
 *
 *  Arguments:
 *       pProfile - ptr to a profile structure that specifies the profile
 *                  to open
 *       dwDesiredAccess - specifies the mode in which to open the profile.
 *                         Any combination of these values can be used:
 *            PROFILE_READ: Allows the app to read the profile.
 *            PROFILE_READWRITE: Allows the app to read and write to the profile.
 *       dwShareMode - specifies the mode to share the profile with other
 *                     processes if it is a file. Any combination of these
 *                     values can be used.
 *            0               : Prevents the file from being shared.
 *            FILE_SHARE_READ: Allows opening for read only by other processes.
 *            FILE_SHARE_WRITE: Allows opening for write by other processes.
 *       dwCreationMode - specifies which actions to take on the profile while
 *                        opening it (if it is a file). Any one of the following
 *                        values can be used.
 *            CREATE_NEW: Creates a new file. Fails if one exists already.
 *            CREATE_ALWAYS: Always create a new file. Overwriting existing.
 *            OPEN_EXISTING: Open exisiting file. Fail if not found.
 *            OPEN_ALWAYS: Open existing. If not found, create a new one.
 *            TRUNCATE_EXISTING: Open existing and truncate to zero bytes. Fail
 *                               if not found.
 *
 *  Returns:
 *       Handle to open profile on success, zero on failure.
 *
 ******************************************************************************/

HPROFILE InternalOpenColorProfile(
    PPROFILE pProfile,
    DWORD    dwDesiredAccess,
    DWORD    dwShareMode,
    DWORD    dwCreationMode
    )
{
    SECURITY_ATTRIBUTES sa;
    PPROFOBJ  pProfObj;
    HPROFILE  hProfile;
    DWORD     dwMapSize;
    BOOL      bNewFile = FALSE;
    BOOL      bError = TRUE;      // Assume failure

    TRACEAPI((__TEXT("OpenColorProfile\n")));

    //
    // Validate parameters
    //

    if (!pProfile ||
        IsBadReadPtr(pProfile, sizeof(PROFILE)) ||
        (pProfile->pProfileData &&
         IsBadReadPtr(pProfile->pProfileData, pProfile->cbDataSize)) ||
        (!pProfile->pProfileData &&
         (pProfile->cbDataSize != 0)) ||
        (pProfile->dwType != PROFILE_FILENAME &&
         pProfile->dwType != PROFILE_MEMBUFFER
        ) ||
        (dwDesiredAccess != PROFILE_READ &&
         dwDesiredAccess != PROFILE_READWRITE
        )
       )
    {
        WARNING((__TEXT("Invalid parameter to OpenColorProfile\n")));
        SetLastError(ERROR_INVALID_PARAMETER);
        return NULL;
    }

    //
    // Allocate an object on the heap for the profile
    //

    hProfile = AllocateHeapObject(OBJ_PROFILE);
    if (!hProfile)
    {
        WARNING((__TEXT("Could not allocate profile object\n")));
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return NULL;
    }

    pProfObj = (PPROFOBJ)HDLTOPTR(hProfile);

    ASSERT(pProfObj != NULL);

    //
    // Copy profile information to our object
    //

    pProfObj->objHdr.dwUseCount = 1;
    pProfObj->dwType       = pProfile->dwType;
    pProfObj->cbDataSize   = pProfile->cbDataSize;
    pProfObj->pProfileData = (PBYTE)MemAlloc(pProfile->cbDataSize + sizeof(TCHAR));
    if (!pProfObj->pProfileData)
    {
        WARNING((__TEXT("Could not allocate memory for profile data\n")));
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        goto EndOpenColorProfile;
    }

    CopyMemory((PVOID)pProfObj->pProfileData,
        (PVOID)pProfile->pProfileData,
        pProfile->cbDataSize);

    if (pProfObj->dwType == PROFILE_FILENAME)
    {
        LPTSTR lpFilename;

        if (!pProfile->pProfileData ||
             pProfile->cbDataSize == 0 ||
             lstrlen((LPCTSTR)pProfile->pProfileData) > MAX_PATH ||
             pProfile->cbDataSize > (MAX_PATH * sizeof(TCHAR)))
        {
            WARNING((__TEXT("Invalid parameter to OpenColorProfile\n")));
            SetLastError(ERROR_INVALID_PARAMETER);
            goto EndOpenColorProfile;
        }

        //
        // If only filename is given, it is wrt color directory
        //

        lpFilename = GetFilenameFromPath((LPTSTR)pProfObj->pProfileData);
        if (lpFilename == pProfObj->pProfileData)
        {
            DWORD dwLen = MAX_PATH;
            lpFilename = MemAlloc(dwLen);
            if (!lpFilename)
            {
                WARNING((__TEXT("Could not allocate memory for file name\n")));
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                goto EndOpenColorProfile;
            }
            (VOID)GetColorDirectory(NULL, lpFilename, &dwLen);
            lstrcat(lpFilename, gszBackslash);
            lstrcat(lpFilename, (LPTSTR)pProfObj->pProfileData);
            MemFree(pProfObj->pProfileData);
            pProfObj->pProfileData = (PVOID)lpFilename;
            pProfObj->cbDataSize = MAX_PATH;
        }

        //
        // File name already null terminates as we used GHND flag which
        // zero initializes the allocated memory
        //
        // Create file mapping
        //

        pProfObj->dwFlags |= MEMORY_MAPPED;

        if (dwCreationMode == OPEN_ALWAYS)
        {
            //
            // If we find a zero length profile, we should error out
            // saying it is a bad profile. If we create a zero length
            // profile, it is fine. To distinguish these two cases, we
            // check for file's existence and if present, change the
            // creation mode to OPEN_EXISTING
            //

            if (GetFileAttributes(pProfObj->pProfileData) != (DWORD)-1)
            {
                dwCreationMode = OPEN_EXISTING;
            }
        }

        //
        // Set security attribute structure
        //

        sa.nLength = sizeof(SECURITY_ATTRIBUTES);
        sa.lpSecurityDescriptor = NULL;         // default security
        sa.bInheritHandle = FALSE;

        pProfObj->hFile = CreateFile(pProfObj->pProfileData,
            (dwDesiredAccess == PROFILE_READWRITE) ? GENERIC_READ | GENERIC_WRITE : GENERIC_READ,
            dwShareMode, &sa, dwCreationMode, FILE_FLAG_RANDOM_ACCESS, 0);

        if (pProfObj->hFile == INVALID_HANDLE_VALUE)
        {
            WARNING((__TEXT("Err %ld, could not open profile %s\n"),
                GetLastError(), pProfObj->pProfileData));
            goto EndOpenColorProfile;
        }

        //
        // Get size of file mapping. Add a cushion so that profile can
        // be grown. When closing the profile, the file size is truncated
        // to the size of the actual data. If the profile size grows beyond
        // the cushion, it is continually grown in chunks.
        //

        dwMapSize = GetFileSize(pProfObj->hFile, NULL);
        if (dwMapSize == 0)
        {
            if (dwCreationMode == OPEN_EXISTING)
            {
                WARNING((__TEXT("Invalid profile  - zero length\n")));
                SetLastError(ERROR_INVALID_PROFILE);
                goto EndOpenColorProfile;

            }
            else
            {
                dwMapSize = PROFILE_GROWTHCUSHION;
                bNewFile = TRUE;
            }
        }

        pProfObj->hMap = CreateFileMapping(pProfObj->hFile, 0,
            (dwDesiredAccess == PROFILE_READWRITE) ? PAGE_READWRITE : PAGE_READONLY,
            0, dwMapSize, 0);

        if (!pProfObj->hMap)
        {
            WARNING((__TEXT("Err %ld, could not create map of profile %s\n"),
                GetLastError(), pProfObj->pProfileData));
            goto EndOpenColorProfile;
        }

        pProfObj->dwMapSize = dwMapSize;

        pProfObj->pView = (PBYTE)MapViewOfFile(pProfObj->hMap,
            (dwDesiredAccess == PROFILE_READWRITE) ? FILE_MAP_ALL_ACCESS : FILE_MAP_READ,
            0, 0, 0);

        if (!pProfObj->pView)
        {
            WARNING((__TEXT("Err %ld, could not create view of profile %s\n"),
                GetLastError(), pProfObj->pProfileData));
            goto EndOpenColorProfile;
        }

        //
        // If a new profile has been created, initialize size
        // and tag table count
        //
        if (bNewFile && dwDesiredAccess == PROFILE_READWRITE)
        {
            HEADER(pProfObj)->phSize = FIX_ENDIAN(sizeof(PROFILEHEADER) +
                                                  sizeof(DWORD));
            HEADER(pProfObj)->phVersion = 0x02000000;
            HEADER(pProfObj)->phSignature = PROFILE_SIGNATURE;
            TAG_COUNT(pProfObj) = 0;
        }
    }
    else
    {
        if (pProfile->cbDataSize == 0)
        {
            //
            // Allocate a small buffer and create a new profile in it
            //

            pProfObj->cbDataSize = PROFILE_GROWTHCUSHION;
            MemFree(pProfObj->pProfileData);
            pProfObj->pView = pProfObj->pProfileData = MemAlloc(pProfObj->cbDataSize);
            if (!pProfObj->pView)
            {
                WARNING((__TEXT("Could not allocate memory for profile data\n")));
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                goto EndOpenColorProfile;
            }

            HEADER(pProfObj)->phSize = FIX_ENDIAN(sizeof(PROFILEHEADER) +
                                                  sizeof(DWORD));
            HEADER(pProfObj)->phVersion = 0x02000000;
            HEADER(pProfObj)->phSignature = PROFILE_SIGNATURE;
            TAG_COUNT(pProfObj) = 0;
            pProfObj->dwMapSize = pProfObj->cbDataSize;
        }
        else
        {
            //
            // Treat buffer as view of file
            //

            pProfObj->pView = pProfObj->pProfileData;
            pProfObj->dwMapSize = pProfObj->cbDataSize;

            //
            // Do a sanity check on the profile
            //

            if (!ValidProfile(pProfObj))
            {
                WARNING((__TEXT("Invalid profile passed to OpenColorProfile\n")));
                SetLastError(ERROR_INVALID_PROFILE);
                goto EndOpenColorProfile;
            }
        }
    }

    if (dwDesiredAccess == PROFILE_READWRITE)
        pProfObj->dwFlags |= READWRITE_ACCESS;

    bError = FALSE;          // Success!

EndOpenColorProfile:

    if (bError)
    {
        if (hProfile)
            FreeProfileObject(hProfile);
        hProfile = NULL;
    }

    return hProfile;
}


/******************************************************************************
 *
 *                         InternalCreateProfileFromLCS
 *
 *  Function:
 *       This functions takes a logical color space and creates an ICC profile
 *
 *  Arguments:
 *       pLogColorSpace - Pointer to LogColorSpace structure
 *       pBuffer - Pointer to pointer to buffer. This function allocates and
 *                 fills this buffer with the profile on success.
 *
 *  Returns:
 *       TRUE if successful, FALSE otherwise
 *
 ******************************************************************************/

BOOL InternalCreateProfileFromLCS(
    LPLOGCOLORSPACE pLogColorSpace,
    PBYTE          *pBuffer,
    BOOL           bValidateParams
    )
{
    PCMMOBJ  pCMMObj = NULL;
    BOOL     rc;

    //
    // Validate parameters
    //

    if (bValidateParams &&
        (! pLogColorSpace ||
         IsBadReadPtr(pLogColorSpace, sizeof(LOGCOLORSPACE)) ||
         pLogColorSpace->lcsFilename[0] != '\0'))
    {
        WARNING((__TEXT("Invalid parameter to CreateProfileFromLogColorSpace\n")));
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // We use the default CMM for this
    //

    pCMMObj = GetColorMatchingModule(CMM_WINDOWS_DEFAULT);
    if (!pCMMObj)
    {
        RIP((__TEXT("Default CMM not found\n")));
        SetLastError(ERROR_INVALID_CMM);
        return FALSE;
    }


    ASSERT(pCMMObj->fns.pCMCreateProfile != NULL);

    rc = pCMMObj->fns.pCMCreateProfile(pLogColorSpace, pBuffer);

    ReleaseColorMatchingModule(pCMMObj);

    return rc;
}


/******************************************************************************
 *
 *                       FreeProfileObject
 *
 *  Function:
 *       This functions frees a profile object and associated memory
 *
 *  Arguments:
 *       hProfile  - handle identifing the profile object to free
 *
 *  Returns:
 *       TRUE if successful, FALSE otherwise
 *
 ******************************************************************************/

BOOL FreeProfileObject(
    HANDLE   hProfile
    )
{
    PPROFOBJ pProfObj;
    DWORD    dwFileSize = 0;
    DWORD    dwErr;

    ASSERT(hProfile != NULL);

    pProfObj = (PPROFOBJ)HDLTOPTR(hProfile);

    ASSERT(pProfObj != NULL);

    dwErr = GetLastError();     // remember any errors we may have set

    //
    // Free memory associated with profile data
    //

    if (pProfObj->pProfileData)
        MemFree((PVOID)pProfObj->pProfileData);

    //
    // If it a memory mapped profile, unmap it
    //

    if (pProfObj->dwFlags & MEMORY_MAPPED)
    {
        if (pProfObj->pView)
        {
            dwFileSize = FIX_ENDIAN(HEADER(pProfObj)->phSize);
            UnmapViewOfFile(pProfObj->pView);
        }
        if (pProfObj->hMap)
            CloseHandle(pProfObj->hMap);

        if (pProfObj->hFile)
        {

            //
            // Set the size of the file correctly
            //

            SetFilePointer(pProfObj->hFile, dwFileSize, NULL, FILE_BEGIN);
            SetEndOfFile(pProfObj->hFile);
            CloseHandle(pProfObj->hFile);
        }
    }

    //
    // Free heap object
    //

    pProfObj->objHdr.dwUseCount--;      // decrement before freeing
    FreeHeapObject(hProfile);

    if (dwErr)
    {
        SetLastError(dwErr);            // reset our error
    }

    return TRUE;
}


/******************************************************************************
 *
 *                       GrowProfile
 *
 *  Function:
 *       This functions grows a profile to the new size
 *
 *  Arguments:
 *       pProfObj  - pointer to profile object
 *       dwNewSize - new size for the profile
 *
 *  Returns:
 *       TRUE if successful, FALSE otherwise
 *
 ******************************************************************************/

BOOL GrowProfile(
    PPROFOBJ pProfObj,
    DWORD dwNewSize
    )
{
    if (pProfObj->dwMapSize >= dwNewSize)
        return TRUE;

    //
    // Add cushion for future growth
    //

    dwNewSize += PROFILE_GROWTHCUSHION;

    if (pProfObj->dwFlags & MEMORY_MAPPED)
    {
        //
        // Profile is a memory mapped file
        //

        //
        // Close previous view and map
        //

        UnmapViewOfFile(pProfObj->pView);
        CloseHandle(pProfObj->hMap);

        pProfObj->hMap = CreateFileMapping(pProfObj->hFile, 0,
            PAGE_READWRITE, 0, dwNewSize, 0);

        if (!pProfObj->hMap)
        {
            WARNING((__TEXT("Err %ld, could not recreate map of profile %s\n"),
                GetLastError(), pProfObj->pProfileData));
            return FALSE;
        }

        pProfObj->pView = (PBYTE) MapViewOfFile(pProfObj->hMap, FILE_MAP_ALL_ACCESS, 0, 0, 0);
        if (!pProfObj->pView)
        {
            WARNING((__TEXT("Err %ld, could not recreate view of profile %s\n"),
                GetLastError(), pProfObj->pProfileData));
            return FALSE;
        }


        //
        // Set new size
        //

        pProfObj->dwMapSize = dwNewSize;
    }
    else
    {
        //
        // Profile is an in-memory buffer
        //

        PVOID pTemp = MemReAlloc(pProfObj->pView, dwNewSize);

        if (!pTemp)
        {
            WARNING((__TEXT("Error reallocating memory\n")));
            return FALSE;
        }

        pProfObj->pView = pProfObj->pProfileData = pTemp;
        pProfObj->cbDataSize = pProfObj->dwMapSize = dwNewSize;
    }

    return TRUE;
}


/******************************************************************************
 *
 *                       AddTagTableEntry
 *
 *  Function:
 *       This functions adds a tag to the tag table
 *
 *  Arguments:
 *       pProfObj  - pointer to profile object
 *       tagType   - tag to add
 *       dwOffset  - offset of tag data from start of file
 *       cbSize    - size of tag data
 *       bNewData  - TRUE if new tag is not a reference to existing data
 *
 *  Returns:
 *       TRUE if successful, FALSE otherwise
 *
 ******************************************************************************/

BOOL AddTagTableEntry(
    PPROFOBJ pProfObj,
    TAGTYPE  tagType,
    DWORD    dwOffset,
    DWORD    cbSize,
    BOOL     bNewData
    )
{
    PTAGDATA pTagData;
    PBYTE    src, dest;
    DWORD    nCount;
    DWORD    cnt, i;

    //
    // Get count of tag items - it is right after the profile header
    //

    nCount = TAG_COUNT(pProfObj);
    nCount = FIX_ENDIAN(nCount);

    //
    // Increase count of tag elements by 1, and add new tag to end of
    // tag table. Move all data below tag table downwards by the size
    // of one tag table entry.
    //

    nCount++;

    dest = (PBYTE)TAG_DATA(pProfObj) + nCount * sizeof(TAGDATA);
    src  = (PBYTE)TAG_DATA(pProfObj) + (nCount - 1) * sizeof(TAGDATA);

    //
    // # bytes to move = file size - header - tag count - tag table
    //

    cnt  = FIX_ENDIAN(HEADER(pProfObj)->phSize) - sizeof(PROFILEHEADER) -
                 sizeof(DWORD) - (nCount - 1) * sizeof(TAGDATA);

    if (cnt > 0)
    {
        //
        // NOTE: CopyMemory() doesn't work for overlapped memory.
        // Use internal function instead.
        //

        MyCopyMemory((PVOID)dest, (PVOID)src, cnt);
    }

    TAG_COUNT(pProfObj) = FIX_ENDIAN(nCount);

    pTagData = (PTAGDATA)src;
    pTagData->tagType  = FIX_ENDIAN(tagType);
    pTagData->cbSize   = FIX_ENDIAN(cbSize);
    pTagData->dwOffset =  FIX_ENDIAN(dwOffset);

    //
    // Go through the tag table and update the offsets of all elements
    // by the size of one tag table entry that we inserted.
    //

    pTagData = TAG_DATA(pProfObj);
    for (i=0; i<nCount; i++)
    {
        cnt = FIX_ENDIAN(pTagData->dwOffset);
        cnt += sizeof(TAGDATA);
        pTagData->dwOffset = FIX_ENDIAN(cnt);
        pTagData++;     // Next element
    }

    //
    // Set final file size
    //

    cnt = DWORD_ALIGN(FIX_ENDIAN(HEADER(pProfObj)->phSize)) + sizeof(TAGDATA);
    if (bNewData)
    {
        //
        // The new tag is not a reference to an old tag. Increment
        // file size of size of new data also
        //

        cnt += cbSize;
    }
    HEADER(pProfObj)->phSize = FIX_ENDIAN(cnt);

    return TRUE;
}


/******************************************************************************
 *
 *                       AddTaggedElement
 *
 *  Function:
 *       This functions adds a new tagged element to a profile
 *
 *  Arguments:
 *       pProfObj  - pointer to profile object
 *       tagType   - tag to add
 *       cbSize    - size of tag data
 *
 *  Returns:
 *       TRUE if successful, FALSE otherwise
 *
 ******************************************************************************/

BOOL AddTaggedElement(
    PPROFOBJ pProfObj,
    TAGTYPE  tagType,
    DWORD    cbSize
    )
{
    DWORD    dwOffset, newSize;

    ASSERT(pProfObj != NULL);
    ASSERT(cbSize > 0);

    //
    // Resize the profile if needed. For memory buffers, we have to realloc,
    // and for mapped objects, we have to close and reopen the view.
    //

    newSize = FIX_ENDIAN(HEADER(pProfObj)->phSize);
    newSize = DWORD_ALIGN(newSize) + sizeof(TAGDATA) + cbSize;

    //
    // Check for overflow
    //

    if (newSize < FIX_ENDIAN(HEADER(pProfObj)->phSize) ||
        newSize < cbSize)
    {
        WARNING((__TEXT("Overflow in adding element\n")));
        SetLastError(ERROR_ARITHMETIC_OVERFLOW);
        return FALSE;
    }

    if (newSize > pProfObj->dwMapSize)
    {
        if (! GrowProfile(pProfObj, newSize))
        {
            return FALSE;
        }
    }

    //
    // Calculate location of new data - should be DWORD aligned
    //

    dwOffset = FIX_ENDIAN(HEADER(pProfObj)->phSize);
    dwOffset = DWORD_ALIGN(dwOffset);

    return AddTagTableEntry(pProfObj, tagType, dwOffset, cbSize, TRUE);
}


/******************************************************************************
 *
 *                       DeleteTaggedElement
 *
 *  Function:
 *       This functions deletes a tagged element from the profile
 *
 *  Arguments:
 *       pProfObj  - pointer to profile object
 *       pTagData  - pointer to tagged element to delete
 *
 *  Returns:
 *       TRUE if successful, FALSE otherwise
 *
 ******************************************************************************/

BOOL DeleteTaggedElement(
    PPROFOBJ pProfObj,
    PTAGDATA pTagData
    )
{
    PBYTE    pData;
    PTAGDATA pTemp;
    DWORD    cbSize, nCount, dwOffset, i;

    //
    // Remember location of data and move everything upto the data upwards
    // by size of one tag table entry. Then move everything below the tag data
    // upward by size of data plus size of one tage table entry.
    //

    pData = VIEW(pProfObj) + FIX_ENDIAN(pTagData->dwOffset);
    cbSize = FIX_ENDIAN(pTagData->cbSize);
    cbSize = DWORD_ALIGN(cbSize);
    dwOffset = FIX_ENDIAN(pTagData->dwOffset);

    MoveProfileData(pProfObj, (PBYTE)(pTagData+1), (PBYTE)pTagData,
        (LONG)(pData-(PBYTE)(pTagData+1)), FALSE);

    //
    // Do not attempt to move data past the tag if we are deleting the last tag
    //

    if (pData + cbSize < VIEW(pProfObj) + PROFILE_SIZE(pProfObj))
    {
        MoveProfileData(pProfObj, pData+cbSize, pData-sizeof(TAGDATA),
            PROFILE_SIZE(pProfObj)-(LONG)(pData - VIEW(pProfObj)) - cbSize, TRUE);
    }

    //
    // Get count of tag items - it is right after the profile header, and
    // decrement it by one.
    //

    nCount = TAG_COUNT(pProfObj);
    nCount = FIX_ENDIAN(nCount) - 1;
    TAG_COUNT(pProfObj) = FIX_ENDIAN(nCount);

    //
    // Go through the tag table and update the pointers
    //

    pTemp = TAG_DATA(pProfObj);

    for (i=0; i<nCount; i++)
    {
        DWORD dwTemp = FIX_ENDIAN(pTemp->dwOffset);

        if (dwTemp > dwOffset)
        {
            dwTemp -= cbSize;        // cbSize already DWORD aligned
        }
        dwTemp -= sizeof(TAGDATA);
        pTemp->dwOffset = FIX_ENDIAN(dwTemp);
        pTemp++;                     // Next record
    }

    //
    // Use nCount as a placeholder to calculate file size
    //

    nCount = DWORD_ALIGN(FIX_ENDIAN(HEADER(pProfObj)->phSize));
    nCount -= sizeof(TAGDATA) + cbSize;
    HEADER(pProfObj)->phSize = FIX_ENDIAN(nCount);

    return TRUE;
}


/******************************************************************************
 *
 *                       ChangeTaggedElementSize
 *
 *  Function:
 *       This functions changes the size of a tagged element in the profile
 *
 *  Arguments:
 *       pProfObj  - pointer to profile object
 *       pTagData  - pointer to tagged element whose size is to be changed
 *       cbSize    - new size for the element
 *
 *  Returns:
 *       TRUE if successful, FALSE otherwise
 *
 ******************************************************************************/

BOOL ChangeTaggedElementSize(
    PPROFOBJ pProfObj,
    PTAGDATA pTagData,
    DWORD    cbSize
    )
{
    PTAGDATA pTemp;
    PBYTE    pData;
    DWORD    nCount, cbOldSize;
    DWORD    dwOffset, cnt, i;

    ASSERT(pProfObj != NULL);
    ASSERT(cbSize > 0);

    //
    // Get current size of element
    //

    cbOldSize = FIX_ENDIAN(pTagData->cbSize);

    if (cbOldSize == cbSize)
    {
        return TRUE;        // Sizes are the same - Do nothing
    }
    pData = VIEW(pProfObj) + FIX_ENDIAN(pTagData->dwOffset);

    //
    // Do not attempt to move data beyond end of file. There is no need to move
    // anything if the last data item is being resized.
    //

    if (pData + DWORD_ALIGN(cbOldSize) < VIEW(pProfObj) + PROFILE_SIZE(pProfObj))
    {
        MoveProfileData(pProfObj, pData + DWORD_ALIGN(cbOldSize), pData + DWORD_ALIGN(cbSize),
            PROFILE_SIZE(pProfObj) - (LONG)(pData - VIEW(pProfObj)) - DWORD_ALIGN(cbOldSize), TRUE);
    }

    pTagData->cbSize = FIX_ENDIAN(cbSize);  // Set the new size

    //
    // Get count of tag items - it is right after the profile header
    //

    nCount = TAG_COUNT(pProfObj);
    nCount = FIX_ENDIAN(nCount);

    //
    // Go through the tag table and update the pointers
    //

    pTemp = TAG_DATA(pProfObj);

    dwOffset = FIX_ENDIAN(pTagData->dwOffset);
    for (i=0; i<nCount; i++)
    {
        DWORD dwTemp = FIX_ENDIAN(pTemp->dwOffset);

        if (dwTemp > dwOffset)
        {
            dwTemp += DWORD_ALIGN(cbSize) - DWORD_ALIGN(cbOldSize);
            pTemp->dwOffset = FIX_ENDIAN(dwTemp);
        }
        pTemp++;                     // Next record
    }

    //
    // Use cnt as a placeholder to calculate file size
    //

    cnt = FIX_ENDIAN(HEADER(pProfObj)->phSize);
    cnt += DWORD_ALIGN(cbSize) - DWORD_ALIGN(cbOldSize);
    HEADER(pProfObj)->phSize = FIX_ENDIAN(cnt);

    return TRUE;
}


/******************************************************************************
 *
 *                       MoveProfileData
 *
 *  Function:
 *       This function moves data in a profile up or down (from src to dest),
 *       and then zeroes out the end of the file or the extra space created.
 *
 *  Arguments:
 *       pProfObj  - pointer to profile object
 *       src       - pointer to source of block to move
 *       dest      - pointer to destination for block to move to
 *       cnt       - number of bytes to move
 *
 *  Returns:
 *       TRUE if successful, FALSE otherwise
 *
 ******************************************************************************/

void MoveProfileData(
    PPROFOBJ pProfObj,
    PBYTE src,
    PBYTE dest,
    LONG cnt,
    BOOL bZeroMemory
    )
{
    //
    // NOTE: CopyMemory() doesn't work for overlapped memory.
    // Use internal function instead.
    //

    MyCopyMemory((PVOID)dest, (PVOID)src, cnt);

    if (bZeroMemory)
    {
        cnt = ABS((LONG)(dest - src));

        if (dest < src)
        {
            //
            // Size decreased, so zero out end of file
            //

            dest = VIEW(pProfObj) + FIX_ENDIAN(HEADER(pProfObj)->phSize) -
                   (src - dest);
        }
        else
        {
            //
            // Size increased, so zero out the increased tagdata
            //

            dest = src;
        }
        ZeroMemory(dest, cnt);
    }

    return;
}


/******************************************************************************
 *
 *                           IsReferenceTag
 *
 *  Function:
 *       This function checks if a given tag's data is referred to by another
 *       tag in the profile
 *
 *  Arguments:
 *       pProfObj  - pointer to profile object
 *       pTagData  - pointer to tagdata which should be checked
 *
 *  Returns:
 *       TRUE if it is a referece, FALSE otherwise
 *
 ******************************************************************************/

BOOL IsReferenceTag(
    PPROFOBJ pProfObj,
    PTAGDATA pTagData
    )
{
    PTAGDATA pTemp;
    DWORD    nCount, i;
    BOOL     bReference = FALSE;

    pTemp = TAG_DATA(pProfObj);
    nCount = TAG_COUNT(pProfObj);
    nCount = FIX_ENDIAN(nCount);

    for (i=0; i<nCount; i++)
    {
        if ((pTagData->dwOffset == pTemp->dwOffset) &&
            (pTagData->tagType  != pTemp->tagType))
        {
            bReference = TRUE;
            break;
        }
        pTemp++;                     // next record
    }

    return bReference;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\mscms\stierr.h ===
/*++

Copyright (c) 1986-1997  Microsoft Corporation

Module Name:

    stierr.h

Abstract:

    This module contains the user mode still image APIs error and status codes

Author:


Revision History:


--*/

#ifndef _STIERR_
#define _STIERR_


//
// Generic test for success on any status value (non-negative numbers
// indicate success).
//

#define NT_SUCCESS(Status) ((NTSTATUS)(Status) >= 0)

//
// Generic test for information on any status value.
//

#define NT_INFORMATION(Status) ((ULONG)(Status) >> 30 == 1)

//
// Generic test for warning on any status value.
//

#define NT_WARNING(Status) ((ULONG)(Status) >> 30 == 2)

//
// Generic test for error on any status value.
//

#define NT_ERROR(Status) ((ULONG)(Status) >> 30 == 3)

//
// Error codes are constructed as compound COM status codes
//

/*
 * The operation completed successfully
 */
#define STI_OK  S_OK
#define STI_ERROR_NO_ERROR          STI_OK

/*
 * The device exists but not currently attached to the system
 */
#define STI_NOTCONNECTED            S_FALSE

/*
 * The requested change in device mode settings had no effect
 */
#define STI_CHANGENOEFFECT          S_FALSE

/*
 * The application requires newer version
 */
#define STIERR_OLD_VERSION      \
        MAKE_HRESULT(SEVERITY_ERROR,FACILITY_WIN32,ERROR_OLD_WIN_VERSION)

/*
 * The application was written for pre-release version of provider DLL
 */
#define STIERR_BETA_VERSION     \
        MAKE_HRESULT(SEVERITY_ERROR,FACILITY_WIN32,ERROR_RMODE_APP)

/*
 * The requested object could not be created due to incompatible or mismatched driver
 */
#define STIERR_BADDRIVER        \
        MAKE_HRESULT(SEVERITY_ERROR,FACILITY_WIN32,ERROR_BAD_DRIVER_LEVEL)

/*
 * The device is not registered
 */
#define STIERR_DEVICENOTREG     REGDB_E_CLASSNOTREG

/*
 * The requested container does not exist
 */
#define STIERR_OBJECTNOTFOUND \
        MAKE_HRESULT(SEVERITY_ERROR,FACILITY_WIN32,ERROR_FILE_NOT_FOUND)

/*
 * An invalid or not state matching parameter was passed to the API
 */
#define STIERR_INVALID_PARAM    E_INVALIDARG

/*
 * The specified interface is not supported
 */
#define STIERR_NOINTERFACE      E_NOINTERFACE

/*
 * The undetermined error occured
 */
#define STIERR_GENERIC          E_FAIL

/*
 * There is not enough memory to perform requested operation
 */
#define STIERR_OUTOFMEMORY      E_OUTOFMEMORY

/*
 * The application called unsupported (at this time)function
 */
#define STIERR_UNSUPPORTED      E_NOTIMPL

/*
 * The application requires newer version
 */
#define STIERR_NOT_INITIALIZED     \
        MAKE_HRESULT(SEVERITY_ERROR,FACILITY_WIN32,ERROR_NOT_READY)

/*
 * The application requires newer version
 */
#define STIERR_ALREADY_INITIALIZED     \
        MAKE_HRESULT(SEVERITY_ERROR,FACILITY_WIN32,ERROR_ALREADY_INITIALIZED)

/*
 * The operation can not performed while device is locked
 */
#define STIERR_DEVICE_LOCKED    \
        MAKE_HRESULT(SEVERITY_ERROR,FACILITY_WIN32,ERROR_LOCK_VIOLATION)

/*
 * The specified propery can not be changed for this device
 */
#define STIERR_READONLY         E_ACCESSDENIED

/*
 * The device already has notification handle associated with it
 */
#define STIERR_NOTINITIALIZED   E_ACCESSDENIED


/*
 * The device needs to be locked before attempting this operation
 */
#define STIERR_NEEDS_LOCK    \
        MAKE_HRESULT(SEVERITY_ERROR,FACILITY_WIN32,ERROR_NOT_LOCKED)

/*
 * The device is opened by another application in data mode
 */
#define STIERR_SHARING_VIOLATION    \
        MAKE_HRESULT(SEVERITY_ERROR,FACILITY_WIN32,ERROR_SHARING_VIOLATION)


/*
 * Handle already set for this context
 */
#define STIERR_HANDLEEXISTS     \
        MAKE_HRESULT(SEVERITY_ERROR,FACILITY_WIN32,ERROR_ALREADY_EXISTS)

 /*
  * Device name is not recognized
  */
#define STIERR_INVALID_DEVICE_NAME     \
        MAKE_HRESULT(SEVERITY_ERROR,FACILITY_WIN32,ERROR_INVALID_NAME)

 /*
  * Device hardware type is not valid
  */
#define STIERR_INVALID_HW_TYPE     \
        MAKE_HRESULT(SEVERITY_ERROR,FACILITY_WIN32,ERROR_INVALID_DATA)
                            

 /*
  * Device hardware type is not valid
  */
#define STIERR_INVALID_HW_TYPE     \
        MAKE_HRESULT(SEVERITY_ERROR,FACILITY_WIN32,ERROR_INVALID_DATA)
                            
 /*
  * No events available
  */
#define STIERR_NOEVENTS     \
        MAKE_HRESULT(SEVERITY_ERROR,FACILITY_WIN32,ERROR_NO_MORE_ITEMS)


//#define STIERR_


#endif // _STIERR_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\icm\mscms\stireg.h ===
/*++

Copyright (c) 1986-1997  Microsoft Corporation

Module Name:

    stireg.h

Abstract:

    This module contains the STI registry entries

Author:


Revision History:


--*/

#ifndef _STIREG_
#define _STIREG_

//
// Registry keys and values
//
#define REGSTR_VAL_TYPE_W            L"Type"
#define REGSTR_VAL_VENDOR_NAME_W     L"Vendor"
#define REGSTR_VAL_DEVICETYPE_W      L"DeviceType"
#define REGSTR_VAL_DEVICESUBTYPE_W   L"DeviceSubType"
#define REGSTR_VAL_DEV_NAME_W        L"DeviceName"
#define REGSTR_VAL_DRIVER_DESC_W     L"DriverDesc"
#define REGSTR_VAL_FRIENDLY_NAME_W   L"FriendlyName"
#define REGSTR_VAL_GENERIC_CAPS_W    L"Capabilities"
#define REGSTR_VAL_HARDWARE_W        L"HardwareConfig"
#define REGSTR_VAL_DEVICE_NAME_W     L"DriverDesc"
#define REGSTR_VAL_DATA_W            L"DeviceData"
#define REGSTR_VAL_GUID_W            L"GUID"
#define REGSTR_VAL_GUID               "GUID"
#define REGSTR_VAL_LAUNCH_APPS_W     L"LaunchApplications"
#define REGSTR_VAL_LAUNCH_APPS        "LaunchApplications"
#define REGSTR_VAL_LAUNCHABLE_W      L"Launchable"
#define REGSTR_VAL_LAUNCHABLE         "Launchable"

//
// Device instance value names
//
#define STI_DEVICE_VALUE_TWAIN_NAME    L"TwainDS"
#define STI_DEVICE_VALUE_ISIS_NAME     L"ISISDriverName"
#define STI_DEVICE_VALUE_ICM_PROFILE   L"ICMProfile"
#define STI_DEVICE_VALUE_DEFAULT_LAUNCHAPP  L"DefaultLaunchApp"
#define STI_DEVICE_VALUE_TIMEOUT       L"PollTimeout"

#endif // _STIREG_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\image\alpha.cxx ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name

   alpha.cxx

Abstract:

   alpha blending functions

Author:

   Mark Enstrom   (marke)  23-Jun-1996

Enviornment:

   User Mode

Revision History:

--*/

#include "precomp.hxx"

#pragma hdrstop

#if DBG
ULONG DbgAlpha = 0;
#endif


#if !(_WIN32_WINNT >= 0x500)



#if defined(_X86_)

BOOL gbMMX = FALSE;

/**************************************************************************\
* bIsMMXProcessor
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    4/10/1997 Mark Enstrom [marke]
*
\**************************************************************************/

#define CPUID _asm _emit 0fh _asm _emit 0a2h

BOOL
bIsMMXProcessor(VOID)
{
    BOOL  retval = TRUE;
    DWORD RegEDX;

    //
    // Find out if procesor supports CPUID
    //

    __try
    {
        _asm
        {
            mov eax, 1

            // code bytes = 0fh,  0a2h

            CPUID
            mov RegEDX, edx
        }
    } __except(EXCEPTION_EXECUTE_HANDLER)
    {
        retval = FALSE;
    }

    if (retval == FALSE)
    {
        //
        // processor does not support CPUID
        //

        return FALSE;
    }

    //
    // bit 23 is set for MMX technology
    //

    if (RegEDX & 0x800000)
    {

      //
      // save and restore fp state around emms
      //

      __try
      {
          _asm emms
      }
      __except(EXCEPTION_EXECUTE_HANDLER)
      {
          retval = FALSE;
      }
    }
    else
    {
        //
        // processor supports CPUID but does not have MMX technology
        //

        return FALSE;
    }

    //
    // if retval == 0 here that means the processor has MMX technology but
    // the FP emulation is on so MMX technology is unavailable
    //

   return retval;
}

#endif

/**************************************************************************\
* bDetermineAlphaBlendFunction
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    1/21/1997 Mark Enstrom [marke]
*
\**************************************************************************/

BOOL
bDetermineAlphaBlendFunction(
    CONST DIBINFO          *pdibDst,
    CONST DIBINFO          *pdibSrc,
    PALPHA_DISPATCH_FORMAT  pAlphaDispatch
    )
{
    PULONG pulSrcMask = (PULONG)&pdibSrc->pbmi->bmiColors[0];
    ULONG  ulSrcFlRed;
    ULONG  ulSrcFlGreen;
    ULONG  ulSrcFlBlue;

    PULONG pulDstMask = (PULONG)&pdibDst->pbmi->bmiColors[0];
    ULONG  ulDstFlRed;
    ULONG  ulDstFlGreen;
    ULONG  ulDstFlBlue;

    ULONG DstBitPerPixel = pdibDst->pbmi->bmiHeader.biBitCount;
    LONG  DstWidth        = pdibDst->pbmi->bmiHeader.biWidth;
    ULONG SrcBitPerPixel = pdibSrc->pbmi->bmiHeader.biBitCount;
    LONG  SrcWidth        = pdibSrc->pbmi->bmiHeader.biWidth;

    LONG  cxDst = pdibDst->rclDIB.right - pdibDst->rclDIB.left;

    pAlphaDispatch->ulDstBitsPerPixel = DstBitPerPixel;
    pAlphaDispatch->ulSrcBitsPerPixel = SrcBitPerPixel;

    //
    //  does src btimap have alpha
    //

    BOOL bSrcHasAlpha = FALSE;

    if (
         (pAlphaDispatch->BlendFunction.AlphaFormat & AC_SRC_ALPHA) &&
         (SrcBitPerPixel ==  32) &&
         (
           (pdibSrc->pbmi->bmiHeader.biCompression == BI_RGB) ||
           (
             (pdibSrc->pbmi->bmiHeader.biCompression == BI_BITFIELDS) &&
             (
               (pulSrcMask[0] == 0xff0000) &&
               (pulSrcMask[1] == 0x00ff00) &&
               (pulSrcMask[2] == 0x0000ff)
             )
           )
         )
       )
    {
        bSrcHasAlpha = TRUE;
    }

    //
    // try to find special case
    //

    if (bSrcHasAlpha && (pAlphaDispatch->BlendFunction.SourceConstantAlpha == 255))
    {
        pAlphaDispatch->pfnGeneralBlend = vPixelOver;

        #if defined(_X86_)

            //
            // source and dest alignment must be 8 byte aligned to use mmx
            //

            if (gbMMX && (cxDst >= 8))
            {
                pAlphaDispatch->pfnGeneralBlend = mmxPixelOver;
            }

        #endif
    }
    else
    {
        //
        // if source format doesn't support alpha then use
        // constant src alpha routine
        //

        if (bSrcHasAlpha)
        {
            pAlphaDispatch->pfnGeneralBlend = vPixelBlendOrDissolveOver;

            #if defined(_X86_)

                //
                // source and dest alignment must be 8 byte aligned to use mmx
                //

                if (gbMMX && (cxDst >= 8))
                {
                    pAlphaDispatch->pfnGeneralBlend = mmxPixelBlendOrDissolveOver;
                }

            #endif
        }
        else
        {
            pAlphaDispatch->pfnGeneralBlend = vPixelBlend;
        }
    }

    //
    // determine output conversion and storage routines
    //

    switch (DstBitPerPixel)
    {
    case 1:
        pAlphaDispatch->pfnLoadDstAndConvert = vLoadAndConvert1ToBGRA;
        pAlphaDispatch->pfnConvertAndStore   = vConvertAndSaveBGRAToDest;
        break;

    case 4:
        pAlphaDispatch->pfnLoadDstAndConvert = vLoadAndConvert4ToBGRA;
        pAlphaDispatch->pfnConvertAndStore   = vConvertAndSaveBGRAToDest;
        break;

    case 8:
        pAlphaDispatch->pfnLoadDstAndConvert = vLoadAndConvert8ToBGRA;
        pAlphaDispatch->pfnConvertAndStore   = vConvertAndSaveBGRAToDest;
        break;

    case 16:

        if (pdibDst->pbmi->bmiHeader.biCompression == BI_RGB)
        {
            ulDstFlRed   = 0x7c00;
            ulDstFlGreen = 0x03e0;
            ulDstFlBlue  = 0x001f;
        }
        else if (pdibDst->pbmi->bmiHeader.biCompression == BI_BITFIELDS)
        {
            ulDstFlRed   = pulDstMask[0];
            ulDstFlGreen = pulDstMask[1];
            ulDstFlBlue  = pulDstMask[2];
        }
        else
        {
            return(FALSE);
        }

        if (
             (ulDstFlRed   == 0xf800) &&
             (ulDstFlGreen == 0x07e0) &&
             (ulDstFlBlue  == 0x001f)
           )
        {
            pAlphaDispatch->pfnLoadDstAndConvert = vLoadAndConvertRGB16_565ToBGRA;
            pAlphaDispatch->pfnConvertAndStore   = vConvertAndSaveBGRAToRGB16_565;
        }
        else if (
             (ulDstFlRed   == 0x7c00) &&
             (ulDstFlGreen == 0x03e0) &&
             (ulDstFlBlue  == 0x001f)
           )
        {
            pAlphaDispatch->pfnLoadDstAndConvert = vLoadAndConvertRGB16_555ToBGRA;
            pAlphaDispatch->pfnConvertAndStore   = vConvertAndSaveBGRAToRGB16_555;
        }
        else
        {
            return(FALSE);
        }

        break;

    case 24:
        pAlphaDispatch->pfnLoadDstAndConvert = vLoadAndConvertRGB24ToBGRA;
        pAlphaDispatch->pfnConvertAndStore   = vConvertAndSaveBGRAToRGB24;
        break;

    case 32:

        if (pdibDst->pbmi->bmiHeader.biCompression == BI_RGB)
        {
            ulDstFlRed   = 0xff0000;
            ulDstFlGreen = 0x00ff00;
            ulDstFlBlue  = 0x0000ff;
        }
        else if (pdibDst->pbmi->bmiHeader.biCompression == BI_BITFIELDS)
        {
            ulDstFlRed   = pulDstMask[0];
            ulDstFlGreen = pulDstMask[1];
            ulDstFlBlue  = pulDstMask[2];
        }
        else
        {
            return(FALSE);
        }

        if (
                (ulDstFlRed   == 0xff0000) &&
                (ulDstFlGreen == 0x00ff00) &&
                (ulDstFlBlue  == 0x0000ff)
           )
        {
            //
            // assigned to null indicates no conversion needed
            //

            pAlphaDispatch->pfnLoadDstAndConvert = NULL;
            pAlphaDispatch->pfnConvertAndStore   = NULL;
        }
        else if (
                  (ulDstFlRed   == 0x0000ff) &&
                  (ulDstFlGreen == 0x00ff00) &&
                  (ulDstFlBlue  == 0xff0000)
                )
        {
            pAlphaDispatch->pfnLoadDstAndConvert = vLoadAndConvertRGB32ToBGRA;
            pAlphaDispatch->pfnConvertAndStore   = vConvertAndSaveBGRAToRGB32;
        }
        else
        {
            pAlphaDispatch->pfnLoadDstAndConvert = vLoadAndConvert32BitfieldsToBGRA;
            pAlphaDispatch->pfnConvertAndStore   = vConvertAndSaveBGRAToDest;
        }

        break;
    }

    //
    // determine input load and conversion routine
    //

    switch (SrcBitPerPixel)
    {
    case 1:
        pAlphaDispatch->pfnLoadSrcAndConvert = vLoadAndConvert1ToBGRA;
        break;

    case 4:
        pAlphaDispatch->pfnLoadSrcAndConvert = vLoadAndConvert4ToBGRA;
        break;

    case 8:
        pAlphaDispatch->pfnLoadSrcAndConvert = vLoadAndConvert8ToBGRA;
        break;

    case 16:

        if (pdibSrc->pbmi->bmiHeader.biCompression == BI_RGB)
        {
            ulSrcFlRed   = 0x7c00;
            ulSrcFlGreen = 0x03e0;
            ulSrcFlBlue  = 0x001f;
        }
        else if (pdibSrc->pbmi->bmiHeader.biCompression == BI_BITFIELDS)
        {
            ulSrcFlRed   = pulSrcMask[0];
            ulSrcFlGreen = pulSrcMask[1];
            ulSrcFlBlue  = pulSrcMask[2];
        }
        else
        {
            return(FALSE);
        }

        if (
             (ulSrcFlRed   == 0xf800) &&
             (ulSrcFlGreen == 0x07e0) &&
             (ulSrcFlBlue  == 0x001f)
           )
        {
            pAlphaDispatch->pfnLoadSrcAndConvert = vLoadAndConvertRGB16_565ToBGRA;
        }
        else if (
             (ulSrcFlRed   == 0x7c00) &&
             (ulSrcFlGreen == 0x03e0) &&
             (ulSrcFlBlue  == 0x001f)
           )
        {
            pAlphaDispatch->pfnLoadSrcAndConvert = vLoadAndConvertRGB16_555ToBGRA;
        }
        else
        {
            pAlphaDispatch->pfnLoadSrcAndConvert = vLoadAndConvert16BitfieldsToBGRA;
        }

        break;

    case 24:
        pAlphaDispatch->pfnLoadSrcAndConvert = vLoadAndConvertRGB24ToBGRA;
        break;

    case 32:

        if (pdibSrc->pbmi->bmiHeader.biCompression == BI_RGB)
        {
            ulSrcFlRed   = 0xff0000;
            ulSrcFlGreen = 0x00ff00;
            ulSrcFlBlue  = 0x0000ff;
        }
        else if (pdibSrc->pbmi->bmiHeader.biCompression == BI_BITFIELDS)
        {
            ulSrcFlRed   = pulSrcMask[0];
            ulSrcFlGreen = pulSrcMask[1];
            ulSrcFlBlue  = pulSrcMask[2];
        }
        else
        {
            return(FALSE);
        }

        if (
             (ulSrcFlRed   == 0xff0000) &&
             (ulSrcFlGreen == 0x00ff00) &&
             (ulSrcFlBlue  == 0x0000ff)
           )
        {
            pAlphaDispatch->pfnLoadSrcAndConvert = NULL;
        }
        else if (
                  (ulSrcFlRed   == 0x0000ff) &&
                  (ulSrcFlGreen == 0x00ff00) &&
                  (ulSrcFlBlue  == 0xff0000)
                )
        {
            pAlphaDispatch->pfnLoadSrcAndConvert = vLoadAndConvertRGB32ToBGRA;
        }
        else
        {
            pAlphaDispatch->pfnLoadSrcAndConvert = vLoadAndConvert32BitfieldsToBGRA;
        }

        break;
    }

    //
    // special case 16 bpp vPixelBlend
    //

    if (pAlphaDispatch->pfnGeneralBlend == vPixelBlend)
    {
        if ((pAlphaDispatch->pfnLoadSrcAndConvert == vLoadAndConvertRGB24ToBGRA) &&
            (pAlphaDispatch->pfnLoadDstAndConvert == vLoadAndConvertRGB24ToBGRA))
        {
            //
            // use direct 16 bpp blend
            //

            pAlphaDispatch->pfnGeneralBlend = vPixelBlend24;

            #if defined(_X86_)

                //
                // source and dest alignment must be 8 byte aligned to use mmx
                //

                if (gbMMX && (cxDst >= 8))
                {
                    pAlphaDispatch->pfnGeneralBlend = mmxPixelBlend24; 
                }

            #endif

            pAlphaDispatch->pfnLoadSrcAndConvert = NULL;
            pAlphaDispatch->pfnLoadDstAndConvert = NULL;
            pAlphaDispatch->pfnConvertAndStore   = NULL;
        }

        #if defined(_X86_) 

            else if ((pAlphaDispatch->pfnLoadSrcAndConvert == vLoadAndConvertRGB16_555ToBGRA) &&
                     (pAlphaDispatch->pfnLoadDstAndConvert == vLoadAndConvertRGB16_555ToBGRA))
            {
                //
                // use direct 16 bpp blend
                //
    
                pAlphaDispatch->pfnGeneralBlend = vPixelBlend16_555;
    
                //
                // source and dest alignment must be 8 byte aligned to use mmx
                //

                if (gbMMX && (cxDst >= 8))
                {
                    pAlphaDispatch->pfnGeneralBlend = mmxPixelBlend16_555; 
                }
    
                pAlphaDispatch->pfnLoadSrcAndConvert = NULL;
                pAlphaDispatch->pfnLoadDstAndConvert = NULL;
                pAlphaDispatch->pfnConvertAndStore   = NULL;
    
                //
                // convert blend function from x/255 to y/31
                //
    
                int ia = pAlphaDispatch->BlendFunction.SourceConstantAlpha;
    
                ia = (ia * 31 + 128)/255;
                pAlphaDispatch->BlendFunction.SourceConstantAlpha = (BYTE)ia;
            }
            else if ((pAlphaDispatch->pfnLoadSrcAndConvert == vLoadAndConvertRGB16_565ToBGRA) &&
                     (pAlphaDispatch->pfnLoadDstAndConvert == vLoadAndConvertRGB16_565ToBGRA))
            {
                //
                // use direct 16 bpp blend
                //
    
                pAlphaDispatch->pfnGeneralBlend = vPixelBlend16_565;
    
                //
                // source and dest alignment must be 8 byte aligned to use mmx
                //

                if (gbMMX && (cxDst >= 8))
                {
                    pAlphaDispatch->pfnGeneralBlend = mmxPixelBlend16_565; 
                }
    
                pAlphaDispatch->pfnLoadSrcAndConvert = NULL;
                pAlphaDispatch->pfnLoadDstAndConvert = NULL;
                pAlphaDispatch->pfnConvertAndStore   = NULL;
    
                //
                // convert blend function from x/255 to y/31
                //
    
                int ia = pAlphaDispatch->BlendFunction.SourceConstantAlpha;
    
                ia = (ia * 31 + 128)/255;
                pAlphaDispatch->BlendFunction.SourceConstantAlpha = (BYTE)ia;
            }
        #endif
    }

    return(TRUE);
}

/******************************Public*Routine******************************\
* WinAlphaBlend
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    12/10/1996 Mark Enstrom [marke]
*
\**************************************************************************/

BOOL
WinAlphaBlend(
    HDC           hdcDst,
    int           DstX,
    int           DstY,
    int           DstCx,
    int           DstCy,
    HDC           hdcSrc,
    int           SrcX,
    int           SrcY,
    int           SrcCx,
    int           SrcCy,
    BLENDFUNCTION BlendFunction
    )
{
    DIBINFO    dibInfoDst;
    DIBINFO    dibInfoSrc;

    ULONG      ulStatus;
    BOOL       bRet;
    BOOL       bReadable;
    ALPHA_DISPATCH_FORMAT AlphaDispatch;

    INT OldSrcMapMode,OldDstMapMode;

    //
    // init source and dest surface info
    //

    bRet = bInitDIBINFO(hdcDst,DstX,DstY,DstCx,DstCy,&dibInfoDst);

    if (!bRet)
    {
        return(FALSE);
    }

    bRet = bInitDIBINFO(hdcSrc,SrcX,SrcY,SrcCx,SrcCy,&dibInfoSrc);

    if (!bRet)
    {
        goto AlphaBlendCleanup;
    }

    bSetupBitmapInfos(&dibInfoDst,&dibInfoSrc);

    //
    // get access to src surface or temp DIB
    //

    bRet = bGetSrcDIBits(&dibInfoDst,&dibInfoSrc,SOURCE_ALPHA, 0);

    if (!bRet)
    {
        goto AlphaBlendCleanup;
    }

    //
    // get access to Dst surface or temp DIB
    //
    // DST can be printer DC
    //

    if (dibInfoDst.flag & PRINTER_DC)
    {
        bReadable = FALSE;
        bRet = FALSE;
    }
    else
    {
        bRet = bGetDstDIBits(&dibInfoDst,&bReadable,SOURCE_ALPHA);
    }

    if ((!bRet) || (!bReadable) || (dibInfoDst.rclBounds.left == dibInfoDst.rclBounds.right))
    {
        goto AlphaBlendCleanup;
    }

    //
    // check blend
    //

    if (BlendFunction.BlendOp != AC_SRC_OVER)
    {
        WARNING("Illegal blend function\n");
        bRet = FALSE;
    }

    AlphaDispatch.BlendFunction = BlendFunction;

    //
    // determine alpha routine
    //

    bRet = bDetermineAlphaBlendFunction(&dibInfoDst,&dibInfoSrc,&AlphaDispatch);

    if (bRet)
    {

        //
        // call alpha blending routine
        //

        ulStatus = AlphaScanLineBlend(
                               (PBYTE)dibInfoDst.pvBase,
                               (PRECTL)&dibInfoDst.rclDIB,
                               dibInfoDst.stride,
                               (PBYTE)dibInfoSrc.pvBase,
                               dibInfoSrc.stride,
                               (PPOINTL)&dibInfoSrc.rclDIB,
                               &AlphaDispatch,
                               &dibInfoSrc,
                               &dibInfoDst
                               );
        //
        // ALPHA_COMPLETE:  success, written to destination
        // ALPHA_SEND_TEMP: success, must write tmp bmp to dest
        // ALPHA_FAIL:      error
        //

        if (ulStatus == ALPHA_SEND_TEMP)
        {
            bRet = bSendDIBINFO(hdcDst,&dibInfoDst);
        }
        else if (ulStatus == ALPHA_FAIL)
        {
            bRet = FALSE;
        }
    }

    //
    // release any temp storage
    //

AlphaBlendCleanup:

    vCleanupDIBINFO(&dibInfoDst);
    vCleanupDIBINFO(&dibInfoSrc);

    return(bRet);
}

#endif

/******************************Public*Routine******************************\
* AlphaBlend
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    12/3/1996 Mark Enstrom [marke]
*
\**************************************************************************/

BOOL
AlphaBlend(
    HDC           hdcDest,
    int           DstX,
    int           DstY,
    int           DstCx,
    int           DstCy,
    HDC           hSrc,
    int           SrcX,
    int           SrcY,
    int           SrcCx,
    int           SrcCy,
    BLENDFUNCTION BlendFunction
    )
{
    BOOL bRet;

    //
    // check blend
    //

    if ((BlendFunction.BlendOp != AC_SRC_OVER) ||
        ((BlendFunction.AlphaFormat & (~ AC_SRC_ALPHA)) != 0))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        WARNING("AlphaBlend: Invalid Blend Function\n");
        return(FALSE);
    }

    //
    // flags used, must be zero or one of the valid ones. 
    //

    if ((BlendFunction.BlendFlags & (~(AC_USE_HIGHQUALITYFILTER|AC_MIRRORBITMAP))) != 0)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        WARNING("AlphaBlend: Invalid Blend Function\n");
        return(FALSE);
    }

    //
    // If the caller claims that the source contains an Alpha channel, than the source
    // must be 32BPP.
    //
    
    if (BlendFunction.AlphaFormat & AC_SRC_ALPHA)
    {
        if (GetObjectType(hSrc) == OBJ_MEMDC)
        {
            HBITMAP hbitmap;
            BITMAP  bitmap;
    
            if (hbitmap = (HBITMAP) GetCurrentObject(hSrc, OBJ_BITMAP))
            {
                if (!GetObject(hbitmap, sizeof(BITMAP), &bitmap))
                {
                    WARNING("AlphaBlend:  can't get bitmap information for source.  Proeeding anyway");
                }
                else
                {
                    if(bitmap.bmBitsPixel != 32)
                    {
                        WARNING("AlphaBlend:  AlphaFormat claims that there is an alpha channel in a surface that's not 32BPP\n");
        
                        SetLastError(ERROR_INVALID_PARAMETER);
                        return FALSE;
                    }
                }
            }
            else
            {
                WARNING("AlphaBlend:  can't get bitmap information for source memory dc.  Proceeding anyway");
            }
        }
        else
        {
            if (GetDeviceCaps(hSrc, BITSPIXEL) != 32)
            {
                WARNING("AlphaBlend:  AlphaFormat claims that there is an alpha channel in a surface that's not 32BPP\n");
    
                SetLastError(ERROR_INVALID_PARAMETER);
                return FALSE;
            }
        }
    }

    //
    // no mirroring
    //

    if ((DstCx < 0) || (DstCy < 0) || (SrcCx < 0) || (SrcCy < 0))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        WARNING("AlphaBlend: Invalid parameter\n");
        return(FALSE);
    }

    //
    // dispatch call
    //

    bRet = gpfnAlphaBlend(hdcDest,DstX,DstY,DstCx,DstCy,hSrc,SrcX,SrcY,SrcCx,SrcCy,BlendFunction);

    return(bRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\image\dib.cxx ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name


Abstract:

   Lingyun Wang

Author:


Enviornment:

   User Mode

Revision History:

--*/

#include "precomp.hxx"
#include <ddraw.h>
#include <ddrawp.h>
#include <ddrawi.h>


#pragma hdrstop

extern PFNTRANSBLT gpfnTransparentImage;
extern PFNTRANSDIB gpfnTransparentDIBImage;

BOOL gbddrawSet = FALSE;

#if (_WIN32_WINNT == 0x400)

extern HMODULE ghddrawlib;
extern BOOL gbddraw;
extern PFN_GETSURFACEFROMDC pfnGetSurfaceFromDC;
PFN_GETSURFACEFROMDC pfnGetSurfaceDesc;

PALETTEENTRY gapeVgaPalette[16] =
{
    { 0,   0,   0,    0 },
    { 0x80,0,   0,    0 },
    { 0,   0x80,0,    0 },
    { 0x80,0x80,0,    0 },
    { 0,   0,   0x80, 0 },
    { 0x80,0,   0x80, 0 },
    { 0,   0x80,0x80, 0 },
    { 0x80,0x80,0x80, 0 },
    { 0xC0,0xC0,0xC0, 0 },
    { 0xFF,0,   0,    0 },
    { 0,   0xFF,0,    0 },
    { 0xFF,0xFF,0,    0 },
    { 0,   0,   0xFF, 0 },
    { 0xFF,0,   0xFF, 0 },
    { 0,   0xFF,0xFF, 0 },
    { 0xFF,0xFF,0xFF, 0 }
};

/**************************************************************************\
*  Dprintf
*
*
* Arguments:
*
*   szFmt - format string and argrs
*
* Return Value:
*
*   none
*
* History:
*
*
\**************************************************************************/

#if DBG
VOID Dprintf( LPSTR szFmt, ... ) {
    TCHAR szMsg[80];
    DWORD cb;
    va_list marker;

    va_start( marker, szFmt );
    wvsprintf( szMsg, szFmt, marker );
    cb = lstrlen(szMsg);
    szMsg[cb++] = '\r';
    szMsg[cb++] = '\n';
    WriteFile( GetStdHandle( STD_OUTPUT_HANDLE ), szMsg, sizeof(TCHAR) * cb,
        &cb, NULL );

    va_end( marker );

    return;
}
#else
VOID Dprintf (LPSTR szFmt, ...) {
    return;
}
#endif


/******************************Public*Routine******************************\
* MyGetSystemPaletteEntries
*
* Internal version of GetSystemPaletteEntries.
*
* GetSystemPaletteEntries fails on some 4bpp devices.  This version
* will detect the 4bpp case and supply the hardcoded 16-color VGA palette.
* Otherwise, it will pass the call on to GDI's GetSystemPaletteEntries.
*
* It is expected that this call will only be called in the 4bpp and 8bpp
* cases as it is not necessary for OpenGL to query the system palette
* for > 8bpp devices.
*
* History:
*  17-Aug-1995 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

static UINT
MyGetSystemPaletteEntries(HDC hdc, UINT iStartIndex, UINT nEntries,
                          LPPALETTEENTRY lppe)
{
    int nDeviceBits;

    nDeviceBits = GetDeviceCaps(hdc, BITSPIXEL) * GetDeviceCaps(hdc, PLANES);

    //
    // Some 4bpp displays will fail the GetSystemPaletteEntries call.
    // So if detected, return the hardcoded table.
    //

    if ( nDeviceBits == 4 )
    {
        if ( lppe )
        {
            nEntries = min(nEntries, (16 - iStartIndex));

            memcpy(lppe, &gapeVgaPalette[iStartIndex],
                   nEntries * sizeof(PALETTEENTRY));
        }
        else
            nEntries = 16;

        return nEntries;
    }
    else
    {
        return GetSystemPaletteEntries(hdc, iStartIndex, nEntries, lppe);
    }
}

/******************************Public*Routine******************************\
* bFillColorTable
*
* Initialize the color table of the BITMAPINFO pointed to by pbmi.  Colors
* are set to the current system palette.
*
* Note: call only valid for displays of 8bpp or less.
*
* Returns:
*   TRUE if successful, FALSE otherwise.
*
* History:
*  23-Jan-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

static BOOL
bFillColorTable(HDC hdc, HPALETTE hpal, BITMAPINFO *pbmi)
{
    BOOL bRet = FALSE;
    BYTE aj[sizeof(PALETTEENTRY) * 256];
    LPPALETTEENTRY lppe = (LPPALETTEENTRY) aj;
    RGBQUAD *prgb = (RGBQUAD *) &pbmi->bmiColors[0];
    ULONG cColors;

    cColors = 1 << pbmi->bmiHeader.biBitCount;

    if ( cColors <= 256 )
    {
        if ( hpal ? GetPaletteEntries(hpal, 0, cColors, lppe)
                  : MyGetSystemPaletteEntries(hdc, 0, cColors, lppe) )
        {
            UINT i;

            for (i = 0; i < cColors; i++)
            {
                prgb[i].rgbRed      = lppe[i].peRed;
                prgb[i].rgbGreen    = lppe[i].peGreen;
                prgb[i].rgbBlue     = lppe[i].peBlue;
                prgb[i].rgbReserved = 0;
            }

            bRet = TRUE;
        }
        else
        {
            //WARNING ("bFillColorTable: MyGetSystemPaletteEntries failed\n");
        }
    }

    return bRet;
}


/******************************Public*Routine******************************\
* bFillBitmapInfoDirect
*
* Fills in the fields of a BITMAPINFO so that we can create a bitmap
* that matches the format of the display.
*
* This is done by creating a compatible bitmap and calling GetDIBits
* to return the color masks.  This is done with two calls.  The first
* call passes in biBitCount = 0 to GetDIBits which will fill in the
* base BITMAPINFOHEADER data.  The second call to GetDIBits (passing
* in the BITMAPINFO filled in by the first call) will return the color
* table or bitmasks, as appropriate.
*
* Returns:
*   TRUE if successful, FALSE otherwise.
*
* History:
*  07-Jun-1995 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL
bFillBitmapInfoDirect(HDC hdc, HPALETTE hpal, BITMAPINFO *pbmi)
{
    HBITMAP hbm;
    BOOL    bRet = FALSE;

    //
    // Create a dummy bitmap from which we can query color format info
    // about the device surface.
    //

    if ((hbm = CreateCompatibleBitmap(hdc, 1, 1)) != NULL)
    {
        pbmi->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);

        //
        // Call first time to fill in BITMAPINFO header.
        //
        GetDIBits(hdc, hbm, 0, 0, NULL, pbmi, DIB_RGB_COLORS);

        if (( pbmi->bmiHeader.biBitCount <= 8 ) || ( pbmi->bmiHeader.biCompression == BI_BITFIELDS ))
        {
            //
            // Call a second time to get the color masks.
            // It's a GetDIBits Win32 "feature".
            //

            GetDIBits(hdc, hbm, 0, pbmi->bmiHeader.biHeight, NULL, pbmi,
                      DIB_RGB_COLORS);
        }

        bRet = TRUE;

        DeleteObject(hbm);
    }
    else
    {
        WARNING("bFillBitmapInfoDirect: CreateCompatibleBitmap failed\n");
    }

    return bRet;
}

/******************************Public*Routine******************************\
* bFillBitmapInfoMemory
*
* Fills in the fields of a BITMAPINFO so that we can create a bitmap
* that matches the format of a memory DC.
*
*
* Returns:
*   TRUE if successful, FALSE otherwise.
*
* History:
*  05-Dec-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
BOOL
bFillBitmapInfoMemory(HDC hdc, HPALETTE hpal, BITMAPINFO *pbmi)
{
    HBITMAP hbm;
    BOOL    bRet = FALSE;

    if ( (hbm = (HBITMAP)GetCurrentObject(hdc, OBJ_BITMAP)) != NULL )
    {
        pbmi->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);

        //
        // Call first time to fill in BITMAPINFO header.
        //
        GetDIBits(hdc, hbm, 0, 0, NULL, pbmi, DIB_RGB_COLORS);

        if (( pbmi->bmiHeader.biBitCount <= 8 )
           || ( pbmi->bmiHeader.biCompression == BI_BITFIELDS ))
        {
                //
                // Call a second time to get the color masks.
                // It's a GetDIBits Win32 "feature".
                //

                GetDIBits(hdc, hbm, 0, pbmi->bmiHeader.biHeight, NULL, pbmi,
                          DIB_RGB_COLORS);
         }

         bRet = TRUE;
    }
    else
    {
        WARNING("bFillBitmapInfoMemory: CreateCompatibleBitmap failed\n");
    }

    return bRet;
}

/******************************Public*Routine******************************\
* bFillDIBSection
*
* Fill in the DIBSection structure for a memory dc
* Fills in the fields of a BITMAPINFO so that we can create a bitmap
* that matches the format of a memory DC.
*
*
* Returns:
*   TRUE if successful, FALSE otherwise.
*
* History:
*  05-Dec-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
BOOL
bFillDIBSection(
    PDIBINFO pDibInfo)
{
    HBITMAP hbm;
    BOOL    bRet = FALSE;
    BOOL    bddraw = FALSE;
    DIBSECTION dib;

    if ( (hbm = (HBITMAP)GetCurrentObject(pDibInfo->hdc, OBJ_BITMAP)) != NULL )
    {
        GetObject (hbm, sizeof(DIBSECTION), &dib);

        #if 0
        Dprintf ("DIBSECTION is:\n");

        Dprintf("bmType=%x dsBm.bmBits = %x\n", dib.dsBm.bmType, dib.dsBm.bmBits);

        Dprintf("bmWidth = %x, bmHeight = %x, bmWidthBytes = %x \n",
                 dib.dsBm.bmWidth, dib.dsBm.bmHeight, dib.dsBm.bmWidthBytes);

        Dprintf("bmPlanes = %x, bmBitsPixel = %x\n",dib.dsBm.bmPlanes, dib.dsBm.bmBitsPixel);

        Dprintf("dsBmh.biSize=%x, biWidth = %x, biHeight = %x\n",
                    dib.dsBmih.biSize, dib.dsBmih.biWidth, dib.dsBmih.biHeight);

        Dprintf("dsBmh.biPlanes = %x, biBitCount = %x, biCompression = %x, biSizeImage = %x\n",
                 dib.dsBmih.biPlanes, dib.dsBmih.biBitCount, dib.dsBmih.biSizeImage);
        #endif

        //
        // it is a DIBSECTION
        //
        if ((pDibInfo->pvBits = dib.dsBm.bmBits) != NULL)
        {
             //
             // it is a DIBSection, now see if it might be a DD Surface (on WIn95)
             //
             // gbddraw is set at msimg32.dll's dll init time
             // gbddrawSet is set by ddraw.dll at its init time
             //
             if (gbddraw || gbddrawSet)
             {
                //
                // if this is the first time we call in here
                //
                if (!ghddrawlib)
                {
                    //
                    // increment handle count for ddraw.dll
                    //

                    ghddrawlib = LoadLibrary (TEXT("ddraw.dll"));

                    //Dprintf("LoadLibrary returns %x", hddrawlib);

                    if (ghddrawlib)
                        pfnGetSurfaceFromDC = (PFN_GETSURFACEFROMDC)GetProcAddress(
                                                   ghddrawlib, "GetSurfaceFromDC");
                }

                HDC hdcDevice;

                HRESULT ddVal;

                if (pfnGetSurfaceFromDC &&
                    ((ddVal = pfnGetSurfaceFromDC(pDibInfo->hdc, &pDibInfo->pdds, &hdcDevice)) == DD_OK))
                {
                    bddraw = TRUE;

                    ddVal = pDibInfo->pdds->GetSurfaceDesc(&pDibInfo->ddsd);

                    //
                    // !!we DON'T need to lock the surface here, GetDC will do an internal lock
                    // until dc is release!!
                    //

                    if (ddVal == DD_OK)
                    {
                       Dprintf("pfnGetSurfaceFromDC succeed\n");

                       // printout ddsurface
                       Dprintf ("ddsd.lpSurface = %x\n", pDibInfo->ddsd.lpSurface);
                       Dprintf ("ddsd.lPitch = %x\n", pDibInfo->ddsd.lPitch);
                       Dprintf ("ddsd.dwWidth = %x, ddsd.dwHight = %x\n", pDibInfo->ddsd.dwWidth, pDibInfo->ddsd.dwHeight);
                       Dprintf ("ddsd.ddpfPixelFormat.dwRGBBitCount=%x\n", pDibInfo->ddsd.ddpfPixelFormat.dwRGBBitCount);

                       //
                       // correct the stride
                       //

                       dib.dsBm.bmWidthBytes = pDibInfo->ddsd.lPitch;

                       #if 0

                       pDibInfo->stride = pDibInfo->ddsd.lPitch;

                       pDibInfo->pbmi->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);

                       pDibInfo->pbmi->bmiHeader.biCompression = BI_RGB;
                       pDibInfo->pbmi->bmiHeader.biPlanes = 1;

                       pDibInfo->pbmi->bmiHeader.biWidth = pDibInfo->ddsd.dwWidth;
                       pDibInfo->pbmi->bmiHeader.biHeight = pDibInfo->ddsd.dwHeight;

                       switch (pDibInfo->ddsd.ddpfPixelFormat.dwRGBBitCount)
                       {
                          case DDBD_1:
                                     pDibInfo->pbmi->bmiHeader.biBitCount = 1;
                                     break;

                          case DDBD_4:
                                     pDibInfo->pbmi->bmiHeader.biBitCount = 4;
                                     break;

                          case DDBD_8:
                                     pDibInfo->pbmi->bmiHeader.biBitCount = 8;
                                     bFillColorTable (pDibInfo->hdc, 0, pDibInfo->pbmi);
                                     break;

                          case DDBD_16:
                                     pDibInfo->pbmi->bmiHeader.biBitCount = 16;
                                     *(DWORD *)&pDibInfo->pbmi->bmiColors[0] = pDibInfo->ddsd.ddpfPixelFormat.dwRBitMask;
                                     *(DWORD *)&pDibInfo->pbmi->bmiColors[1] = pDibInfo->ddsd.ddpfPixelFormat.dwGBitMask;
                                     *(DWORD *)&pDibInfo->pbmi->bmiColors[2] = pDibInfo->ddsd.ddpfPixelFormat.dwBBitMask;
                                     break;

                          case DDBD_24:
                                     pDibInfo->pbmi->bmiHeader.biBitCount = 24;
                                     break;

                          case DDBD_32:
                                     pDibInfo->pbmi->bmiHeader.biBitCount = 32;
                                     break;
                          default:
                                     WARNING("bad bitformat for ddraw surface\n");
                       }

                       pDibInfo->rclClipDC.left = 0;
                       pDibInfo->rclClipDC.top =0;
                       pDibInfo->rclClipDC.right = pDibInfo->ddsd.dwWidth;
                       pDibInfo->rclClipDC.bottom = pDibInfo->ddsd.dwHeight;
                       #endif

                       bRet = TRUE;
                    }
                    else
                    {
                       Dprintf("fail to GET the surface, ddVal = %x\n", ddVal);
                    }
               }
               else
               {
                   Dprintf("fail GetSurfaceFromDC, ddVal = %x\n", ddVal);
               }
             }

             Dprintf ("bddraw = %x\n", gbddraw);

             //
             // continue with dibsection
             //
             {
                 //
                 // If biHeight is positive, then the bitmap is a bottom-up DIB.
                 // If biHeight is negative, then the bitmap is a top-down DIB.
                 //

                 {
                     // WINBUG #365315 4-10-2001 jasonha Bug in bFillDIBSection
                     // 
                     // Old Comment:
                     //   GDI Bug 19374: bmWidthBytes returns pitch assuming
                     //        that DIB scanlines are WORD aligned (as they
                     //        are in Win95).  But NT DIBs are DWORD aligned.
                     //        When bug if corrected, we can remove this block of
                     //        code.
                     OSVERSIONINFO osvi;
                     
                     osvi.dwOSVersionInfoSize = sizeof(osvi);
                     if (GetVersionEx(&osvi))
                     {
                         if ( osvi.dwPlatformId == VER_PLATFORM_WIN32_NT )
                         {
                             dib.dsBm.bmWidthBytes = (dib.dsBm.bmWidthBytes + 3) & ~3;
                         }
                     }
                     else
                     {
                         return bRet;
                     }
                 }

                 if ( dib.dsBmih.biHeight > 0 )
                 {
                      pDibInfo->pvBase  = (PVOID) (((int) dib.dsBm.bmBits) + (dib.dsBm.bmWidthBytes *
                                                          (dib.dsBm.bmHeight - 1)));

                      pDibInfo->stride = (ULONG) (-dib.dsBm.bmWidthBytes);
                 }
                 else
                 {
                     pDibInfo->pvBase  = dib.dsBm.bmBits;

                     pDibInfo->stride = dib.dsBm.bmWidthBytes;
                 }

                  //
                  // fill up the BITMAPINFOHEADER
                  //
                  pDibInfo->pbmi->bmiHeader = dib.dsBmih;

                  //
                  // fill up the color table
                  //
                  if ((pDibInfo->pbmi->bmiHeader.biBitCount <= 8) || ( pDibInfo->pbmi->bmiHeader.biCompression == BI_BITFIELDS ))
                  {
                      ULONG count = 1 << pDibInfo->pbmi->bmiHeader.biBitCount;

                      GetDIBits(pDibInfo->hdc, hbm, 0, pDibInfo->pbmi->bmiHeader.biHeight, NULL, pDibInfo->pbmi,
                                  DIB_RGB_COLORS);

                  }

                  //
                  // fill prcl
                  //
                  pDibInfo->rclClipDC.left   = 0;
                  pDibInfo->rclClipDC.top    = 0;
                  pDibInfo->rclClipDC.right  = dib.dsBm.bmWidth;
                  pDibInfo->rclClipDC.bottom = dib.dsBm.bmHeight;

                  if (pDibInfo->rclClipDC.bottom < 0)
                  {
                      pDibInfo->rclClipDC.bottom = -pDibInfo->rclClipDC.bottom;
                  }

                  bRet = TRUE;
             }

        }
        else
        {
            Dprintf("not a dibseciton");
        }
    }
    return(bRet);
}





/******************************Public*Routine******************************\
* bFillBimapInfo
*
* Fill up the BITMAPINFO structure based on the hdc passed in
* and fill up the window(if direct dc) or surface (if memory dc)
* rectangle.
*
* if it's a dibsection, convert DIBSECTION to BITMAPINFO
*
* Returns:
*   BOOLEAN
*
* History:
*  09-Dec-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
BOOL bFillBitmapInfo(
    PDIBINFO pDibInfo
    )
{
    BOOL bRet = FALSE;

    //
    // if it is printer surface, return TRUE
    //
    if (GetDeviceCaps(pDibInfo->hdc, TECHNOLOGY) == DT_RASPRINTER)
    {
        pDibInfo->flag |= PRINTER_DC;
        pDibInfo->rclClipDC.left = 0;
        pDibInfo->rclClipDC.right = GetDeviceCaps(pDibInfo->hdc, HORZRES);
        pDibInfo->rclClipDC.top = 0;
        pDibInfo->rclClipDC.bottom = GetDeviceCaps(pDibInfo->hdc, VERTRES);

        pDibInfo->rclDIB = pDibInfo->rclClipDC;

        return (TRUE);
    }

    {
       //
       // fill up a BITMAPINFO structure compatible with the
       // Destination DC and reduce ulWidth and ulHeight if
       // possible
       //
       if (GetObjectType(pDibInfo->hdc) == OBJ_DC)
       {
           //
           // get the destination bitmapinfo struct
           //
           if (bRet = bFillBitmapInfoDirect(pDibInfo->hdc, 0, pDibInfo->pbmi))
           {
              HWND hwnd = WindowFromDC(pDibInfo->hdc);

              if (hwnd)
              {
                  GetClientRect(hwnd,(RECT *)&pDibInfo->rclClipDC);
              }
           }
       }
       else if (GetObjectType(pDibInfo->hdc) == OBJ_MEMDC)
       {
           if (!(bRet = bFillDIBSection (pDibInfo)))
           {
               //
               // if the bitmap selected in the memory dc is NOT
               // a DIBSECTION, call bFillBitmapInfoMemory
               //

               if (bRet = bFillBitmapInfoMemory(pDibInfo->hdc, 0, pDibInfo->pbmi))
               {
                   pDibInfo->rclClipDC.left   = 0;
                   pDibInfo->rclClipDC.top    = 0;
                   pDibInfo->rclClipDC.right  = pDibInfo->pbmi->bmiHeader.biWidth;
                   pDibInfo->rclClipDC.bottom = pDibInfo->pbmi->bmiHeader.biHeight;

                   if (pDibInfo->rclClipDC.bottom < 0)
                   {
                       pDibInfo->rclClipDC.bottom = -pDibInfo->rclClipDC.bottom;
                   }
               }
           }

       }
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* bSameDIBformat
*
* Given two BITMAPINFO structs and compare if they are the same
*
* Returns:
*   VOID
*
* History:
*  09-Dec-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
BOOL bSameDIBformat (
    PBITMAPINFO pbmiDst,
    PBITMAPINFO pbmiSrc)
{
    BOOL bRet = FALSE;

    if ((pbmiDst->bmiHeader.biBitCount == pbmiSrc->bmiHeader.biBitCount) &&
        (pbmiDst->bmiHeader.biCompression == pbmiSrc->bmiHeader.biCompression))
    {
        bRet = TRUE;

        //
        // compare bit Bitfields masks
        //
        if (pbmiDst->bmiHeader.biCompression == BI_BITFIELDS)
        {
           if ((*(DWORD *)&pbmiDst->bmiColors[0] != *(DWORD *)&pbmiSrc->bmiColors[0]) ||
               (*(DWORD *)&pbmiDst->bmiColors[1] != *(DWORD *)&pbmiSrc->bmiColors[1]) ||
               (*(DWORD *)&pbmiDst->bmiColors[2] != *(DWORD *)&pbmiSrc->bmiColors[2]))
           {
               bRet = FALSE;
           }
        }

        //
        // compare color table
        //
        if (pbmiDst->bmiHeader.biBitCount <= 8)
        {
            ULONG cColors = 1 << pbmiDst->bmiHeader.biBitCount;
            ULONG i;

            for (i = 0; i < cColors; i++)
            {
                if ((pbmiDst->bmiColors[i].rgbBlue != pbmiSrc->bmiColors[i].rgbBlue) ||
                    (pbmiDst->bmiColors[i].rgbGreen != pbmiSrc->bmiColors[i].rgbGreen) ||
                    (pbmiDst->bmiColors[i].rgbRed != pbmiSrc->bmiColors[i].rgbRed))

                {
                    return (FALSE);
                }
            }
        }
    }
    return (bRet);
}
/******************************Public*Routine******************************\
* CreateCompatibleDIB
*
* Create a DIB_RGB_COLORS dib section based on the given width/height and pbmi
*
* Returns:
*   Bitmap handle
*
* History:
*  09-Dec-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
HBITMAP CreateCompatibleDIB (
    HDC         hdc,
    ULONG       ulWidth,
    ULONG       ulHeight,
    PVOID       *ppvBits,
    PBITMAPINFO pbmi)
{
    HBITMAP hbm;

    //
    // Change bitmap size to match specified dimensions.
    //
    pbmi->bmiHeader.biWidth = ulWidth;
    pbmi->bmiHeader.biHeight = ulHeight;

    if (pbmi->bmiHeader.biCompression == BI_RGB)
    {
        pbmi->bmiHeader.biSizeImage = 0;
    }
    else
    {
        if ( pbmi->bmiHeader.biBitCount == 16 )
            pbmi->bmiHeader.biSizeImage = ulWidth * ulHeight * 2;
        else if ( pbmi->bmiHeader.biBitCount == 32 )
            pbmi->bmiHeader.biSizeImage = ulWidth * ulHeight * 4;
        else
            pbmi->bmiHeader.biSizeImage = 0;
    }

    pbmi->bmiHeader.biClrUsed = 0;
    pbmi->bmiHeader.biClrImportant = 0;

    hbm = CreateDIBSection(hdc, (PBITMAPINFO)pbmi, DIB_RGB_COLORS, ppvBits, NULL, 0);

    return (hbm);
}

/******************************Public*Routine******************************\
* GetCompatibleDIBInfo
*
* Copies pointer to bitmap origin to ppvBase and bitmap stride to plStride.
* Win32 DIBs can be created bottom-up (the default) with the origin at the
* lower left corner or top-down with the origin at the upper left corner.
* If the bitmap is top-down, *plStride is positive; if bottom-up, *plStride
* us negative.
*
* Also, because of restrictions on the alignment of scan lines the width
* the bitmap is often not the same as the stride (stride is the number of
* bytes between vertically adjacent pixels).
*
* The ppvBase and plStride value returned will allow you to address any
* given pixel (x, y) in the bitmap as follows:
*
* PIXEL *ppix;
*
* ppix = (PIXEL *) (((BYTE *)*ppvBase) + (y * *plStride) + (x * sizeof(PIXEL)));
*
* Returns:
*   TRUE if successful, FALSE otherwise.
*
* History:
*  02-Feb-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL GetCompatibleDIBInfo(HBITMAP hbm, PVOID *ppvBase, LONG *plStride)
{
    BOOL bRet = FALSE;
    DIBSECTION ds;

    //
    // Call GetObject to return a DIBSECTION.  If successful, the
    // bitmap is a DIB section and we can retrieve the pointer to
    // the bitmap bits and other parameters.
    //

    if ( (GetObject(hbm, sizeof(ds), &ds) == sizeof(ds))
         && ds.dsBm.bmBits )
    {
        // WINBUG #365315 4-10-2001 jasonha Bug in GetCompatibleDIBInfo
        //
        // Old Comment:
        //    GDI Bug 19374: bmWidthBytes returns pitch assuming
        //        that DIB scanlines are WORD aligned (as they
        //        are in Win95).  But NT DIBs are DWORD aligned.
        //        When bug if corrected, we can remove this block of
        //        code.
        {
            OSVERSIONINFO osvi;

            osvi.dwOSVersionInfoSize = sizeof(osvi);
            if (GetVersionEx(&osvi))
            {
                if ( osvi.dwPlatformId == VER_PLATFORM_WIN32_NT )
                {
                    ds.dsBm.bmWidthBytes = (ds.dsBm.bmWidthBytes + 3) & ~3;
                }
            }
            else
            {
                return bRet;
            }
        }

        //
        // If biHeight is positive, then the bitmap is a bottom-up DIB.
        // If biHeight is negative, then the bitmap is a top-down DIB.
        //

        if ( ds.dsBmih.biHeight > 0 )
        {
            *ppvBase  = (PVOID) (((int) ds.dsBm.bmBits) + (ds.dsBm.bmWidthBytes * (ds.dsBm.bmHeight - 1)));
            *plStride = (ULONG) (-ds.dsBm.bmWidthBytes);
        }
        else
        {
            *ppvBase  = ds.dsBm.bmBits;
            *plStride = ds.dsBm.bmWidthBytes;
        }

        bRet = TRUE;
    }
    else
    {
        WARNING("GetCompatibleDIBInfo: cannot get pointer to DIBSECTION bmBits\n");
    }

    return bRet;
}

/******************************************************
* bSetupBitmapInfos
*
* Calls bFillBitmapInfo to fill the Dst and Src DIBINFO
*
* 4/4/97 -- by Lingyun Wang [lingyunw]
*******************************************************/
BOOL bSetupBitmapInfos(
    PDIBINFO pDibInfoDst,
    PDIBINFO pDibInfoSrc
    )
{
    BOOL bRet;

    bRet = bFillBitmapInfo (pDibInfoDst);

    //
    // fill up bitmapinfo if it is not coming from TransparentDIBits
    //

    if (bRet && (pDibInfoSrc != NULL))
    {
        if (pDibInfoSrc->hdc != NULL)
        {
            bRet = bFillBitmapInfo (pDibInfoSrc);
        }
        else
        {
            //
            // src is DIB
            //

            pDibInfoSrc->rclClipDC.left   = 0;
            pDibInfoSrc->rclClipDC.right  = pDibInfoSrc->pbmi->bmiHeader.biWidth;
            pDibInfoSrc->rclClipDC.top    = 0;
            pDibInfoSrc->rclClipDC.bottom = pDibInfoSrc->pbmi->bmiHeader.biHeight;

            if (pDibInfoSrc->rclClipDC.bottom < 0)
            {
                pDibInfoSrc->rclClipDC.bottom = -pDibInfoSrc->rclClipDC.bottom;
            }

        }
    }

   return (bRet);

}


/******************************Public*Routine******************************\
* vCopyBitmapInfo
*
* Copy a BITMAPINFO stucture along with its bit masks or colortable
*
* Returns:
*   VOID.
*
* History:
*  16-Dec-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
VOID vCopyBitmapInfo (
    PBITMAPINFO pbmiTo,
    PBITMAPINFO pbmiFrom
    )
{
    *pbmiTo = *pbmiFrom;

    //
    // copy BitFields masks
    //

    if (pbmiFrom->bmiHeader.biCompression == BI_BITFIELDS)
    {
        pbmiTo->bmiColors[0] = pbmiFrom->bmiColors[0];
        pbmiTo->bmiColors[1] = pbmiFrom->bmiColors[1];
        pbmiTo->bmiColors[2] = pbmiFrom->bmiColors[2];
    }
    else
    {
        //
        // copy color table
        //

        ULONG cMaxColors = 1 << pbmiFrom->bmiHeader.biBitCount;
        ULONG cColors = pbmiFrom->bmiHeader.biClrUsed;

        //
        // validate number of colors
        //

        if ((cColors == 0) || (cColors > cMaxColors))
        {
            cColors = cMaxColors;
        }

        if (cColors <= 256)
        {
           UINT i;

           for (i = 0; i < cColors; i++)
           {
               pbmiTo->bmiColors[i] = pbmiFrom->bmiColors[i];
           }
        }
    }

    return;
}

/**************************************************************************\
* vIndexToRGB
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    4/16/1997 -by- Lingyun Wang [lingyunw]
*
\**************************************************************************/

VOID vIndexToRGB (
     RGBQUAD *pIndex,
     RGBQUAD *pColors,
     ULONG   count)
{
    ULONG i;

    if (count > 256)
    {
        WARNING ("vIndexToRGB -- bad count\n");
        return;
    }

    for (i=0; i < count; i++)
    {
        pIndex[i] = pColors[((ULONG *)pIndex)[i]];
    }
    return;
}

#if 1

/******************************Public*Routine******************************\
* vMapPALtoRGB
*
* Given a DIB_PAL_COLORS iusage bmiColors table, convert the indices into RGB
* colors, the bmiColors table will be a DIB_RGB_COLORS table after the convertion.
*
* Returns:
*   VOID.
*
* History:
*  16-Dec-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/

VOID
vMapPALtoRGB(
     PDIBINFO pDibInfoDst,
     PDIBINFO pDibInfoSrc,
     ULONG TransColor)
{
    //
    // only called in DIB API case
    //

    if (pDibInfoSrc->hdc == NULL)
    {
        PBITMAPINFO pbmi = (PBITMAPINFO)LOCALALLOC(sizeof(BITMAPINFO) + sizeof(RGBQUAD) * 255);

        if (pbmi)
        {
            ZeroMemory (pbmi,sizeof(BITMAPINFO) + sizeof(RGBQUAD) * 255);
            vCopyBitmapInfo(pbmi, pDibInfoSrc->pbmi);

            HPALETTE hpalDC = (HPALETTE)GetCurrentObject(pDibInfoDst->hdc,OBJ_PAL);

            if (hpalDC)
            {
                USHORT usNumPaletteEntries = 0;
                DWORD numColors;
                DWORD bmiClrUsed = pDibInfoSrc->pbmi->bmiHeader.biClrUsed;

                int iRet = GetObject(hpalDC,2,&usNumPaletteEntries);

                if ((iRet != 0) && (usNumPaletteEntries != 0))
                {
                    switch (pDibInfoSrc->pbmi->bmiHeader.biBitCount)
                    {
                    case 1:
                        numColors = 2;
                        break;

                    case 4:
                        numColors = 16;
                        if ((bmiClrUsed > 0) &&
                            (bmiClrUsed < 16)
                           )
                        {
                            numColors = bmiClrUsed;
                        }
                        break;

                    case 8:
                        numColors = 256;
                        if ((bmiClrUsed > 0) &&
                            (bmiClrUsed < 256)
                           )
                        {
                            numColors = bmiClrUsed;
                        }
                        break;
                    default:
                        numColors = 0;
                    }

                    if (numColors != 0)
                    {
                        PALETTEENTRY *ppal = (PALETTEENTRY *)LOCALALLOC(sizeof(PALETTEENTRY) * usNumPaletteEntries);

                        if (ppal)
                        {
                            iRet = GetPaletteEntries(hpalDC,0,usNumPaletteEntries,ppal);

                            if (iRet == (int)usNumPaletteEntries)
                            {
                                ULONG   Index;

                                RGBQUAD *pRGB     = (RGBQUAD *)&pbmi->bmiColors[0];
                                PUSHORT pPalIndex = (PUSHORT)&pDibInfoSrc->pbmi->bmiColors[0];

                                //
                                // map PALETTEENTRY to RGBQUAD
                                //

                                for (Index=0;Index<numColors;Index++)
                                {
                                    ULONG CurIndex = pPalIndex[Index];

                                    if (CurIndex > usNumPaletteEntries)
                                    {
                                        CurIndex = CurIndex % usNumPaletteEntries;
                                    }

                                    pRGB[Index].rgbRed      = ppal[CurIndex].peRed;
                                    pRGB[Index].rgbGreen    = ppal[CurIndex].peGreen;
                                    pRGB[Index].rgbBlue     = ppal[CurIndex].peBlue;
                                    pRGB[Index].rgbReserved = ppal[CurIndex].peFlags;
                                }

                                //
                                // swap pbmi in pDibInfoSrc
                                //

                                LOCALFREE(pDibInfoSrc->pbmi);

                                pDibInfoSrc->pbmi = pbmi;
                            }

                            LOCALFREE(ppal);
                        }
                    }
                }
            }
        }
    }

}

#else

/******************************Public*Routine******************************\
* vMapPALtoRGB
*
* Given a DIB_PAL_COLORS iusage bmiColors table, convert the indices into RGB
* colors, the bmiColors table will be a DIB_RGB_COLORS table after the convertion.
*
* Returns:
*   VOID.
*
* History:
*  16-Dec-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/

VOID
vMapPALtoRGB(
     PDIBINFO pDibInfoDst,
     PDIBINFO pDibInfoSrc,
     ULONG TransColor)
{
    HDC         hdc = pDibInfoDst->hdc;
    HDC         hdcMem;
    ULONG       cx = 1 << pDibInfoSrc->pbmi->bmiHeader.biBitCount;
    HBITMAP     hbm;
    PULONG      pBits;
    ULONG       cBytes = sizeof(BITMAPINFO) + sizeof(RGBQUAD) * 2;
    PBITMAPINFO pbmi;
    ULONG       i;
    BYTE        pBytes[256];
    ULONG       ulWidthDst, ulHeightDst, ulWidthSrc, ulHeightSrc;
    HPALETTE    hpalDC;

    pbmi = (PBITMAPINFO)LOCALALLOC(cBytes);

    if (pbmi == NULL)
    {
        WARNING("MapCopy fail to alloc mem\n");
        return ;
    }

    hdcMem = CreateCompatibleDC (hdc);

    if (hdcMem != NULL)
    {
        HPALETTE hpalDC = (HPALETTE)GetCurrentObject(hdc,OBJ_PAL);

        SelectPalette(hdcMem,hpalDC,TRUE);
        RealizePalette(hdcMem);

        pbmi->bmiHeader.biSize            = sizeof(BITMAPINFOHEADER);
        pbmi->bmiHeader.biWidth           = 256;
        pbmi->bmiHeader.biHeight          = 1;
        pbmi->bmiHeader.biPlanes          = 1;
        pbmi->bmiHeader.biBitCount        = 32;
        pbmi->bmiHeader.biCompression     = BI_RGB;
        pbmi->bmiHeader.biSizeImage       = 0;
        pbmi->bmiHeader.biXPelsPerMeter   = 0;
        pbmi->bmiHeader.biYPelsPerMeter   = 0;
        pbmi->bmiHeader.biClrUsed         = 0;
        pbmi->bmiHeader.biClrImportant    = 0;

        //
        // save the original width/height
        //

        ulWidthDst = pDibInfoDst->pbmi->bmiHeader.biWidth;
        ulHeightDst = pDibInfoDst->pbmi->bmiHeader.biHeight;

        pDibInfoDst->pbmi->bmiHeader.biWidth = 256;
        pDibInfoDst->pbmi->bmiHeader.biHeight = 1;

        //
        // create a dib using 32 format
        //

        hbm = CreateDIBSection(hdc, pbmi, DIB_RGB_COLORS, (PVOID *)&pBits, NULL, 0);

        if ((hbm != NULL) && (SelectObject(hdcMem,hbm) != NULL))
        {
            //
            // init pBytes to array of each pixel
            //

            switch (cx)
            {
            case 256:
                for (i=0; i < cx; i++)
                {
                    pBytes[i] = (BYTE)i;
                }
                break;

            case 16:
                pBytes[0] = 0x01;
                pBytes[1] = 0x23;
                pBytes[2] = 0x45;
                pBytes[3] = 0x67;
                pBytes[4] = 0x89;
                pBytes[5] = 0xab;
                pBytes[6] = 0xcd;
                pBytes[7] = 0xef;
                break;

            case 2:
                pBytes[0] = 0x40;
                break;
            }

            ulWidthSrc  = pDibInfoSrc->pbmi->bmiHeader.biWidth;
            ulHeightSrc = pDibInfoSrc->pbmi->bmiHeader.biHeight;

            pDibInfoSrc->pbmi->bmiHeader.biWidth = cx;
            pDibInfoSrc->pbmi->bmiHeader.biHeight = 1;


            if (!SetDIBitsToDevice (hdcMem, 0, 0, cx, 1, 0, 0, 0, 1, pBytes, pDibInfoSrc->pbmi, DIB_PAL_COLORS))
            {
                 //Dprintf("fail to SetDIBitsTodevice HDC=%x\n",hdcMem);
            }


            for (i=0; i < cx; i++)
            {
                pDibInfoSrc->pbmi->bmiColors[i] = ((RGBQUAD *)pBits)[i];
                //Dprintf("i=%x, pBits[i]=%x", i, pBits[i]);
            }

            pDibInfoSrc->pbmi->bmiHeader.biWidth = ulWidthSrc;
            pDibInfoSrc->pbmi->bmiHeader.biHeight = ulHeightSrc;


            pDibInfoDst->pbmi->bmiHeader.biWidth = ulWidthDst;
            pDibInfoDst->pbmi->bmiHeader.biHeight = ulHeightDst;

            pDibInfoSrc->iUsage = DIB_RGB_COLORS;
        }

        DeleteDC (hdcMem);

        if (hbm != NULL)
        {
            DeleteObject(hbm);
        }
    }
}

#endif


/**************************************************************************\
* bGetSrcDIBits:
*
*   Setup SRC DIB surface and retrieve the dibits.
*   Ported from kernel mode
*
* Arguments:
*
*   pDibInfoDst  - information on dest surface
*   pDibInfoSrc  - information on src surfcace
*   ulSourceType - type of src surface needed
*   ulTranColor  - transparent color for TransparentBlt
*
* Return Value:
*
*   Status
*
* History:
*
*    4/16/1997 - by Lingyun Wang [lingyunw]
*
\**************************************************************************/

BOOL
bGetSrcDIBits(
    PDIBINFO pDibInfoDst,
    PDIBINFO pDibInfoSrc,
    ULONG    ulSourceType,
    ULONG    ulTranColor
    )
{
    BOOL bRet  = TRUE;
    LONG DstCx = pDibInfoDst->rclBounds.right  - pDibInfoDst->rclBounds.left;
    LONG DstCy = pDibInfoDst->rclBounds.bottom - pDibInfoDst->rclBounds.top;

    LONG SrcCx = pDibInfoSrc->rclBounds.right  - pDibInfoSrc->rclBounds.left;
    LONG SrcCy = pDibInfoSrc->rclBounds.bottom - pDibInfoSrc->rclBounds.top;

    PVOID       pvBits  = pDibInfoSrc->pvBits;
    PBITMAPINFO pbmi    = NULL;
    HDC         hdcTemp = NULL;
    HBITMAP     hbm;

    LONG   SrcTrimLeft;
    LONG   SrcTrimRight;
    LONG   SrcTrimTop;
    LONG   SrcTrimBottom;

    BOOL bStretch = ((DstCx != SrcCx) || (DstCy != SrcCy));

    SrcTrimLeft   = 0;
    SrcTrimRight  = 0;
    SrcTrimTop    = 0;
    SrcTrimBottom = 0;

    //
    // trim destination bounds rect to surface bounds. Src rect must also
    // be trimmed by same amount (in src space)
    //

    if (pDibInfoDst->rclBoundsTrim.left < pDibInfoDst->rclClipDC.left)
    {
        SrcTrimLeft = pDibInfoDst->rclClipDC.left - pDibInfoDst->rclBoundsTrim.left;
        pDibInfoDst->rclBoundsTrim.left = pDibInfoDst->rclClipDC.left;
    }

    if (pDibInfoDst->rclBoundsTrim.top < pDibInfoDst->rclClipDC.top)
    {
        SrcTrimTop = pDibInfoDst->rclClipDC.top - pDibInfoDst->rclBoundsTrim.top;
        pDibInfoDst->rclBoundsTrim.top = pDibInfoDst->rclClipDC.top;
    }

    if (pDibInfoDst->rclBoundsTrim.right > pDibInfoDst->rclClipDC.right)
    {
        SrcTrimRight = pDibInfoDst->rclBoundsTrim.right - pDibInfoDst->rclClipDC.right;
        pDibInfoDst->rclBoundsTrim.right = pDibInfoDst->rclClipDC.right;
    }

    if (pDibInfoDst->rclBoundsTrim.bottom > pDibInfoDst->rclClipDC.bottom)
    {
        SrcTrimBottom = pDibInfoDst->rclBoundsTrim.bottom - pDibInfoDst->rclClipDC.bottom;
        pDibInfoDst->rclBoundsTrim.bottom = pDibInfoDst->rclClipDC.bottom;
    }

    //
    // does src need to be reduced because of dst
    //

    if (bStretch)
    {
        //
        // convert dst trim to src space and reduce src rect
        //
        // WARNING: ROUNDING
        //

        if ((SrcTrimLeft != 0) || (SrcTrimRight != 0))
        {
            double fDstToSrcX = (double)SrcCx / (double)DstCx;

            //
            // convert dst trim amound to src
            //

            SrcTrimLeft  = (LONG)((double)SrcTrimLeft * fDstToSrcX);
            SrcTrimRight = (LONG)((double)SrcTrimRight * fDstToSrcX);

            pDibInfoSrc->rclBoundsTrim.left  += SrcTrimLeft;
            pDibInfoSrc->rclBoundsTrim.right -= SrcTrimRight;
        }

        if ((SrcTrimTop != 0) || (SrcTrimBottom != 0))
        {
            double fDstToSrcY = (double)SrcCy / (double)DstCy;

            //
            // convert dst trim amound to src
            //

            SrcTrimTop    = (LONG)((double)SrcTrimTop * fDstToSrcY);
            SrcTrimBottom = (LONG)((double)SrcTrimBottom * fDstToSrcY);

            pDibInfoSrc->rclBoundsTrim.top    += SrcTrimTop;
            pDibInfoSrc->rclBoundsTrim.bottom -= SrcTrimBottom;
        }
    }
    else
    {
        //
        // reduce src rect
        //

        if (SrcTrimLeft != 0)
        {
            pDibInfoSrc->rclBoundsTrim.left  += SrcTrimLeft;
        }

        if (SrcTrimRight != 0)
        {
            pDibInfoSrc->rclBoundsTrim.right -= SrcTrimRight;
        }

        if (SrcTrimTop != 0)
        {
            pDibInfoSrc->rclBoundsTrim.top    += SrcTrimTop;
        }

        if (SrcTrimBottom != 0)
        {
            pDibInfoSrc->rclBoundsTrim.bottom -= SrcTrimBottom;
        }
    }

    //
    // Does src still exceed bounds
    //

    SrcTrimLeft   = 0;
    SrcTrimRight  = 0;
    SrcTrimTop    = 0;
    SrcTrimBottom = 0;

    //
    // trim destination bounds rect to surface bounds. Src rect must also
    // be trimmed by same amount (in src space)
    //

    if (pDibInfoSrc->rclBoundsTrim.left < pDibInfoSrc->rclClipDC.left)
    {
        SrcTrimLeft = pDibInfoSrc->rclClipDC.left - pDibInfoSrc->rclBoundsTrim.left;
        pDibInfoSrc->rclBoundsTrim.left = pDibInfoSrc->rclClipDC.left;
    }

    if (pDibInfoSrc->rclBoundsTrim.top < pDibInfoSrc->rclClipDC.top)
    {
        SrcTrimTop = pDibInfoSrc->rclClipDC.top - pDibInfoSrc->rclBoundsTrim.top;
        pDibInfoSrc->rclBoundsTrim.top = pDibInfoSrc->rclClipDC.top;
    }

    if (pDibInfoSrc->rclBoundsTrim.right > pDibInfoSrc->rclClipDC.right)
    {
        SrcTrimRight = pDibInfoSrc->rclBoundsTrim.right - pDibInfoSrc->rclClipDC.right;
        pDibInfoSrc->rclBoundsTrim.right = pDibInfoSrc->rclClipDC.right;
    }

    if (pDibInfoSrc->rclBoundsTrim.bottom > pDibInfoSrc->rclClipDC.bottom)
    {
        SrcTrimBottom = pDibInfoSrc->rclBoundsTrim.bottom - pDibInfoSrc->rclClipDC.bottom;
        pDibInfoSrc->rclBoundsTrim.bottom = pDibInfoSrc->rclClipDC.bottom;
    }

    //
    // Src rectangle is not allowed to exceed src surface bounds (same
    // behavior as NT)
    //
    if (SrcTrimLeft || SrcTrimRight || SrcTrimTop || SrcTrimBottom)
    {
        WARNING("Error in dib.cxx:  source rectangle exceeds source surface bounds");
        return FALSE;
    }
    
    //
    // does Dst need to be reduced because of Src
    //

    if (bStretch)
    {
        //
        // WARNING: ROUNDING
        //

        if ((SrcTrimLeft != 0) || (SrcTrimRight != 0))
        {
            double fSrcToDstX = (double)DstCx / (double)SrcCx;

            //
            // convert dst trim amound to src
            //

            SrcTrimLeft  = (LONG)((double)SrcTrimLeft * fSrcToDstX);
            SrcTrimRight = (LONG)((double)SrcTrimRight * fSrcToDstX);

            pDibInfoDst->rclBoundsTrim.left  += SrcTrimLeft;
            pDibInfoDst->rclBoundsTrim.right -= SrcTrimRight;
        }

        if ((SrcTrimTop != 0) || (SrcTrimBottom != 0))
        {
            double fSrcToDstY = (double)DstCy / (double)SrcCy;

            //
            // convert dst trim amound to src
            //

            SrcTrimTop    = (LONG)((double)SrcTrimTop * fSrcToDstY);
            SrcTrimBottom = (LONG)((double)SrcTrimBottom * fSrcToDstY);

            pDibInfoDst->rclBoundsTrim.top    += SrcTrimTop;
            pDibInfoDst->rclBoundsTrim.bottom -= SrcTrimBottom;
        }
    }
    else
    {
        //
        // reduce dst rect
        //

        if (SrcTrimLeft != 0)
        {
            pDibInfoDst->rclBoundsTrim.left  += SrcTrimLeft;
        }

        if (SrcTrimRight != 0)
        {
            pDibInfoDst->rclBoundsTrim.right -= SrcTrimRight;
        }

        if (SrcTrimTop != 0)
        {
            pDibInfoDst->rclBoundsTrim.top    += SrcTrimTop;
        }

        if (SrcTrimBottom != 0)
        {
            pDibInfoDst->rclBoundsTrim.bottom -= SrcTrimBottom;
        }
    }

    //
    // check for clipped out Dst and Src
    //

    if (
        (pDibInfoDst->rclBoundsTrim.left < pDibInfoDst->rclBoundsTrim.right)  &&
        (pDibInfoDst->rclBoundsTrim.top  < pDibInfoDst->rclBoundsTrim.bottom) &&
        (pDibInfoSrc->rclBoundsTrim.left < pDibInfoSrc->rclBoundsTrim.right)  &&
        (pDibInfoSrc->rclBoundsTrim.top  < pDibInfoSrc->rclBoundsTrim.bottom)
       )
    {

        if ((bStretch) || (pDibInfoSrc->pvBits == NULL))
        {
            //
            // allocate compatible DC and surface
            //

            hdcTemp = CreateCompatibleDC(pDibInfoSrc->hdc);

            if (hdcTemp)
            {
                //
                // copy pDibInfoSrc->pbmi into pbmi
                //

                if (!pDibInfoSrc->hdc)
                {
                    ULONG cBytes = sizeof(BITMAPINFO) + sizeof(RGBQUAD) * 255;
                    pbmi = (PBITMAPINFO)LOCALALLOC(cBytes);

                    if (pbmi != NULL)
                    {
                        ZeroMemory (pbmi,cBytes);
                        vCopyBitmapInfo (pbmi, pDibInfoSrc->pbmi);
                    }
                    else
                    {
                        WARNING("bGetSrcDIBits fail to alloc mem\n");
                        bRet = FALSE;
                    }
                }

                if (bRet)
                {
                    //
                    // create temp DIB size of dst rect
                    //

                    RECTL  rclDstCopy = {
                                         0,
                                         0,
                                         pDibInfoDst->rclBoundsTrim.right  - pDibInfoDst->rclBoundsTrim.left,
                                         pDibInfoDst->rclBoundsTrim.bottom - pDibInfoDst->rclBoundsTrim.top
                                        };

                    hbm = CreateCompatibleDIB(hdcTemp,
                                              rclDstCopy.right,
                                              rclDstCopy.bottom,
                                              &pDibInfoSrc->pvBits,
                                              pDibInfoSrc->pbmi);

                    if (hbm)
                    {
                        pDibInfoSrc->hDIB = hbm;

                        GetCompatibleDIBInfo (hbm, &pDibInfoSrc->pvBase, &pDibInfoSrc->stride);

                        HBITMAP hbmDefault = (HBITMAP)SelectObject (hdcTemp, hbm);

                        ULONG OldMode = SetStretchBltMode(hdcTemp,COLORONCOLOR);

                        //
                        // Stretch data into source temp DIB
                        //
                        //
                        // Blt data into source temp DIB
                        //

                        if (pDibInfoSrc->hdc)
                        {
                            StretchBlt (hdcTemp,
                                 0,
                                 0,
                                 rclDstCopy.right,
                                 rclDstCopy.bottom,
                                 pDibInfoSrc->hdc,
                                 pDibInfoSrc->rclBoundsTrim.left,
                                 pDibInfoSrc->rclBoundsTrim.top,
                                 pDibInfoSrc->rclBoundsTrim.right  - pDibInfoSrc->rclBoundsTrim.left,
                                 pDibInfoSrc->rclBoundsTrim.bottom - pDibInfoSrc->rclBoundsTrim.top,
                                 SRCCOPY);
                        }
                        else
                        {

                            //
                            // adjust ySrc to be compatible
                            //

                            LONG cySrc = pDibInfoSrc->rclBoundsTrim.bottom-pDibInfoSrc->rclBoundsTrim.top;
                            LONG ySrc  = pDibInfoSrc->rclClipDC.bottom - pDibInfoSrc->rclBoundsTrim.top - cySrc;

                            StretchDIBits (hdcTemp,
                                 0,
                                 0,
                                 rclDstCopy.right,
                                 rclDstCopy.bottom,
                                 pDibInfoSrc->rclBoundsTrim.left,
                                 ySrc,
                                 pDibInfoSrc->rclBoundsTrim.right-pDibInfoSrc->rclBoundsTrim.left,
                                 cySrc,
                                 pvBits,
                                 pbmi,
                                 DIB_RGB_COLORS,
                                 SRCCOPY);
                        }

                        SetStretchBltMode(hdcTemp,OldMode);

                        SelectObject (hdcTemp, hbmDefault);

                        pDibInfoSrc->rclDIB = rclDstCopy;
                    }
                    else
                    {
                        WARNING ("bGetSrcDIBits -- fail to createcompatibleDIB\n");
                        bRet = FALSE;
                    }
                }
            }
            else
            {
                WARNING ("bGetSrcDIBits -- fail to createcompatibledc\n");
                bRet = FALSE;
            }
        }
        else
        {
            pDibInfoSrc->rclDIB = pDibInfoSrc->rclBoundsTrim;
        }
    }
    else
    {
        //
        // clipped out
        //

        pDibInfoDst->rclBoundsTrim.left = pDibInfoDst->rclBoundsTrim.right  = 0;
        pDibInfoDst->rclBoundsTrim.top  = pDibInfoDst->rclBoundsTrim.bottom = 0;
        pDibInfoSrc->rclBoundsTrim.left = pDibInfoSrc->rclBoundsTrim.right  = 0;
        pDibInfoSrc->rclBoundsTrim.top  = pDibInfoSrc->rclBoundsTrim.bottom = 0;
        bRet = FALSE;
    }

    if (pbmi)
    {
        LOCALFREE (pbmi);
    }

    if (hdcTemp)
    {
        DeleteDC(hdcTemp);
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* bGetDstDIBits
*
* Setup the destination DIB surface and retrieve the bits
*
* Ported from psSetupDstSurface
*
*
*
* Return Value:
*
*
*
* History:
*
*    4-April-1997 -by- Lingyun Wang [lingyunw]
*
\**************************************************************************/

BOOL
bGetDstDIBits
(
    PDIBINFO pDibInfoDst,
    BOOL    *pbReadable,
    FLONG    flCopyMode
)
{
    HDC  hdc  = pDibInfoDst->hdc;
    BOOL bRet = TRUE;
    int  iRegionComplexity;
    RECT rclClipBox;

    *pbReadable = TRUE;

    //
    // read clipping of dst surface. Clipping complexity must not be
    // more than SIMPLEREGION, and bounding box must fill drawing
    // rect or a temp DIB is created.
    //

    iRegionComplexity = GetClipBox(pDibInfoDst->hdc,&rclClipBox);

    //
    // try to clip to dst surface, dst should be clipped in all cases except
    // gradient fill
    //

    if (flCopyMode & (SOURCE_GRADIENT_RECT | SOURCE_GRADIENT_TRI))
    {
        //
        // trim destination bounds rect to surface bounds. Src rect must also
        // be trimmed by same amount (in src space)
        //

        if (pDibInfoDst->rclBoundsTrim.left < pDibInfoDst->rclClipDC.left)
        {
            pDibInfoDst->rclBoundsTrim.left = pDibInfoDst->rclClipDC.left;
        }

        if (pDibInfoDst->rclBoundsTrim.top < pDibInfoDst->rclClipDC.top)
        {
            pDibInfoDst->rclBoundsTrim.top = pDibInfoDst->rclClipDC.top;
        }

        if (pDibInfoDst->rclBoundsTrim.right > pDibInfoDst->rclClipDC.right)
        {
            pDibInfoDst->rclBoundsTrim.right = pDibInfoDst->rclClipDC.right;
        }

        if (pDibInfoDst->rclBoundsTrim.bottom > pDibInfoDst->rclClipDC.bottom)
        {
            pDibInfoDst->rclBoundsTrim.bottom = pDibInfoDst->rclClipDC.bottom;
        }

        //
        // set offset for gradient fill
        //

        pDibInfoDst->ptlGradOffset.x = 0;
        pDibInfoDst->ptlGradOffset.y = 0;

        //
        // don't allocate surface for triangles at 8,4,1
        // Must use internal palette routines
        //

        if (
            (pDibInfoDst->pbmi->bmiHeader.biBitCount == 8) ||
            (pDibInfoDst->pbmi->bmiHeader.biBitCount == 4) ||
            (pDibInfoDst->pbmi->bmiHeader.biBitCount == 1)
           )
        {
            *pbReadable = FALSE;
        }
    }

    LONG DstCx = pDibInfoDst->rclBoundsTrim.right  - pDibInfoDst->rclBoundsTrim.left;
    LONG DstCy = pDibInfoDst->rclBoundsTrim.bottom - pDibInfoDst->rclBoundsTrim.top;

    //
    // make sure draswing rect lies within clip box
    //

    if (iRegionComplexity != NULLREGION)
    {
        //
        // convert to NULLREGION if drawing rect inside clip box
        //

        if (iRegionComplexity == SIMPLEREGION)
        {
            if (
                  (pDibInfoDst->rclBoundsTrim.left   >= rclClipBox.left)  &&
                  (pDibInfoDst->rclBoundsTrim.top    >= rclClipBox.top)   &&
                  (pDibInfoDst->rclBoundsTrim.right  <= rclClipBox.right) &&
                  (pDibInfoDst->rclBoundsTrim.bottom <= rclClipBox.bottom)
               )
            {
               iRegionComplexity = NULLREGION;
            }
        }
    }

    //
    // check for need to allocate temp dst surface
    //

    if ((*pbReadable == TRUE) && ((pDibInfoDst->pvBits == NULL) || (iRegionComplexity != NULLREGION)))
    {
        if (pDibInfoDst->rclBounds.left > 0)
        {
            pDibInfoDst->ptlGradOffset.x = pDibInfoDst->rclBounds.left;
        }

        if (pDibInfoDst->rclBounds.top > 0)
        {
            pDibInfoDst->ptlGradOffset.y = pDibInfoDst->rclBounds.top;
        }

        //
        // allocate surface
        //

        HDC hdcTemp = CreateCompatibleDC (hdc);

        if (hdcTemp)
        {
            HBITMAP hbm = CreateCompatibleDIB (hdcTemp,
                                       DstCx,
                                       DstCy,
                                       &pDibInfoDst->pvBits,
                                       pDibInfoDst->pbmi);

            if (hbm != NULL)
            {
                pDibInfoDst->hDIB = hbm;
                GetCompatibleDIBInfo (hbm, &pDibInfoDst->pvBase, &pDibInfoDst->stride);

                HGDIOBJ hret = SelectObject(hdcTemp, hbm);

                if (hret != NULL)
                {
                    RECTL  rclCopy;

                    rclCopy.left   = 0;
                    rclCopy.right  = DstCx;
                    rclCopy.top    = 0;
                    rclCopy.bottom = DstCy;

                    //
                    // gradient rect does not need source bitmap data
                    //

                    if (flCopyMode != SOURCE_GRADIENT_RECT)
                    {
                        bRet = BitBlt(hdcTemp,
                                      0,
                                      0,
                                      DstCx,
                                      DstCy,
                                      pDibInfoDst->hdc,
                                      pDibInfoDst->rclBoundsTrim.left,
                                      pDibInfoDst->rclBoundsTrim.top,
                                      SRCCOPY);
                    }

                    //
                    // adjust dst rect
                    //

                    if (bRet)
                    {
                        pDibInfoDst->rclDIB = rclCopy;
                    }
                }
                else
                {
                    bRet = NULL;
                    WARNING ("bGetDstDIBits -- fail to select compatible DIB\n");
                }

                *pbReadable = bRet;
            }
            else
            {
                bRet = FALSE;
            }

            DeleteDC (hdcTemp);
        }
        else
        {
            WARNING ("bGetDstDIBits -- fail to createcompatibledc\n");
            bRet = FALSE;
        }
    }
    else
    {
        pDibInfoDst->rclDIB = pDibInfoDst->rclBoundsTrim;
    }

    return(bRet);
}



/******************************Public*Routine******************************\
* bDIBGetSrcDIBits
*
* Create or get the source dib bits
*
* Returns:
*   VOID.
*
* History:
*  09-Dec-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
BOOL bDIBGetSrcDIBits (
    PDIBINFO pDibInfoDst,
    PDIBINFO pDibInfoSrc,
    FLONG    flSourceMode,
    ULONG    TransColor
    )
{

    if (pDibInfoSrc->iUsage == DIB_PAL_COLORS)
    {
        vMapPALtoRGB (pDibInfoDst, pDibInfoSrc, 0);
    }

    //pDibInfoSrc->rclDIB = pDibInfoSrc->rclClipDC;

    return (bGetSrcDIBits(pDibInfoDst,pDibInfoSrc,flSourceMode, TransColor));

}

/******************************Public*Routine******************************\
* bDIBInitDIBINFO
*
* Returns:
*   BOOLEAN.
*
* History:
*  09-Dec-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
BOOL
bDIBInitDIBINFO(
          PBITMAPINFO  pbmi,
          CONST VOID * pvBits,
          int          x,
          int          y,
          int          cx,
          int          cy,
          PDIBINFO     pDibInfo)
{
    PVOID p;
    ULONG cBytes = sizeof(BITMAPINFO) + sizeof(RGBQUAD) * 255;
    int bmWidthBytes;
    POINT lpPoints[2];

    p = LOCALALLOC(cBytes);

    if (!p)
    {
        WARNING("fail to alloc mem\n");
        return (FALSE);
    }

    ZeroMemory (p,cBytes);

    //
    // copy the input pbmi
    //

    vCopyBitmapInfo ((PBITMAPINFO)p, pbmi);

    pDibInfo->pbmi = (PBITMAPINFO)p;
    pDibInfo->hdc  = NULL;

    pDibInfo->rclBounds.left   = x;
    pDibInfo->rclBounds.top    = y;
    pDibInfo->rclBounds.right  = x+cx;
    pDibInfo->rclBounds.bottom = y+cy;

    pDibInfo->rclBoundsTrim = pDibInfo->rclBounds;

    pDibInfo->pvBits    = (PVOID)pvBits;
    pDibInfo->iUsage    = DIB_RGB_COLORS;

    //
    // align width to WORD boundary
    //

    bmWidthBytes = ((pbmi->bmiHeader.biWidth*pbmi->bmiHeader.biBitCount + 15)>>4)<<1;

    if (pbmi->bmiHeader.biHeight > 0)
    {
        pDibInfo->pvBase  = (PBYTE)pDibInfo->pvBits + bmWidthBytes * (pbmi->bmiHeader.biHeight - 1);
        pDibInfo->stride  = (ULONG) (-bmWidthBytes);
    }
    else
    {
        pDibInfo->pvBase = pDibInfo->pvBits;
        pDibInfo->stride = bmWidthBytes;
    }

    pDibInfo->hDIB   = NULL;

    pDibInfo->pdds = NULL;
    pDibInfo->ddsd.dwSize = sizeof(DDSURFACEDESC);

    return(TRUE);
}

/******************************Public*Routine******************************\
* bInitDIBINFO
*
* Returns:
*   BOOLEAN.
*
* History:
*  09-Dec-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
BOOL
bInitDIBINFO(
          HDC         hdc,
          int         x,
          int         y,
          int         cx,
          int         cy,
          PDIBINFO    pDibInfo)
{
    ULONG cBytes;
    PVOID p;
    POINT lpPoints[2];

    pDibInfo->hdc = hdc;

    pDibInfo->rclBounds.left   = x;
    pDibInfo->rclBounds.top    = y;
    pDibInfo->rclBounds.right  = x+cx;
    pDibInfo->rclBounds.bottom = y+cy;

    //
    // setup rclBounds in device space
    //

    LPtoDP (hdc, (POINT *)&pDibInfo->rclBounds, 2);

    //
    // order rect
    //

    if (pDibInfo->rclBounds.left > pDibInfo->rclBounds.right)
    {
        LONG lTemp = pDibInfo->rclBounds.left;
        pDibInfo->rclBounds.left = pDibInfo->rclBounds.right;
        pDibInfo->rclBounds.right = lTemp;
    }

    if (pDibInfo->rclBounds.top > pDibInfo->rclBounds.bottom)
    {
        LONG lTemp = pDibInfo->rclBounds.top;
        pDibInfo->rclBounds.top = pDibInfo->rclBounds.bottom;
        pDibInfo->rclBounds.bottom = lTemp;
    }

    pDibInfo->rclBoundsTrim = pDibInfo->rclBounds;

    //
    // Now operate in MM_TEXT mode
    //

    SetViewportOrgEx(hdc, 0, 0, &pDibInfo->ViewportOrg);
    SetViewportExtEx(hdc, 1, 1, &pDibInfo->ViewportExt);
    SetWindowOrgEx(hdc,   0, 0, &pDibInfo->WindowOrg);
    SetWindowExtEx(hdc,   1, 1, &pDibInfo->WindowExt);
    pDibInfo->Mapmode = SetMapMode(hdc,MM_TEXT);

    pDibInfo->pvBits    = NULL;
    pDibInfo->pvBase    = NULL;
    pDibInfo->hDIB      = NULL;
    pDibInfo->iUsage    = DIB_RGB_COLORS;
    pDibInfo->flag      = 0;


    cBytes = sizeof(BITMAPINFO) + sizeof(RGBQUAD) * 255;

    p = LOCALALLOC(cBytes);

    if (!p)
    {
        WARNING("fail to alloc mem\n");
        return (FALSE);
    }

    ZeroMemory (p,cBytes);

    pDibInfo->pbmi = (PBITMAPINFO)p;

    pDibInfo->pdds = NULL;
    pDibInfo->ddsd.dwSize = sizeof(DDSURFACEDESC);

    return(TRUE);
}

/******************************Public*Routine******************************\
* bSendDIBInfo
*
* Returns:
*   BOOLEAN.
*
* History:
*  09-Dec-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
BOOL
bSendDIBINFO(
    HDC      hdcDst,
    PDIBINFO pDibInfo
    )
{
    BOOL bRet = TRUE;

    if (pDibInfo->hDIB)
    {
        bRet = SetDIBitsToDevice(hdcDst,
                                 pDibInfo->rclBoundsTrim.left,
                                 pDibInfo->rclBoundsTrim.top,
                                 pDibInfo->rclBoundsTrim.right  - pDibInfo->rclBoundsTrim.left,
                                 pDibInfo->rclBoundsTrim.bottom - pDibInfo->rclBoundsTrim.top,
                                 0,
                                 0,
                                 0,
                                 pDibInfo->rclDIB.bottom - pDibInfo->rclDIB.top,
                                 pDibInfo->pvBits,
                                 pDibInfo->pbmi,
                                 DIB_RGB_COLORS);

    }
    return (bRet);
}

/******************************Public*Routine******************************\
* vCleanupDIBInfo
*
* Returns:
*   VOID.
*
* History:
*  09-Dec-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
VOID
vCleanupDIBINFO(
     PDIBINFO pDibInfo)
{
    //
    // restore DC map modes
    //

    if (pDibInfo->hdc != NULL)
    {
        SetMapMode(pDibInfo->hdc,pDibInfo->Mapmode);

        SetViewportOrgEx(pDibInfo->hdc, pDibInfo->ViewportOrg.x, pDibInfo->ViewportOrg.y, NULL);
        SetViewportExtEx(pDibInfo->hdc, pDibInfo->ViewportExt.cx, pDibInfo->ViewportExt.cy, NULL);

        SetWindowOrgEx(pDibInfo->hdc, pDibInfo->WindowOrg.x, pDibInfo->WindowOrg.y, NULL);
        SetWindowExtEx(pDibInfo->hdc, pDibInfo->WindowExt.cx, pDibInfo->WindowExt.cy, NULL);
    }

    //
    // free allocated DIB and memory buffers
    //

    if (pDibInfo->hDIB)
    {
        DeleteObject (pDibInfo->hDIB);
    }

    if (pDibInfo->pbmi)
    {
        LOCALFREE ((PVOID)pDibInfo->pbmi);
    }

    if (pDibInfo->pdds)
    {
        pDibInfo->pdds->Unlock(pDibInfo->ddsd.lpSurface);
    }
}
#endif

/******************************Public*Routine******************************\
* VOID vSetDdrawflag
*
* Returns:
*   private call by ddraw to set a flag to indicate it has loaded
*
* History:
*  29-April-1997 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
VOID vSetDdrawflag ()
{
    gbddrawSet = TRUE;
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\image\alphatran.cxx ===
/******************************Module*Header*******************************\
* Module Name: tranblt.cxx
*
* Transparent BLT
*
* Created: 21-Jun-1996
* Author: Mark Enstrom [marke]
*
* Copyright (c) 1996-1999 Microsoft Corporation
\**************************************************************************/
#include "precomp.hxx"

#if !(_WIN32_WINNT >= 0x500)


/******************************Public*Routine******************************\
* Routines to load a pixel and convert it to BGRA representaion for 
* blending operations
*   
* Arguments:
*   
*
*
* Return Value:
*
*
*
* History:
*
*    12/2/1996 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vLoadAndConvert1ToBGRA(
    PULONG   pulDstAddr,
    PBYTE    pSrcAddr,
    LONG     SrcX,
    LONG     SrcCx,
    PVOID    pDibInfo
    )
{
    BYTE   SrcByte;
    LONG   cxUnalignedStart = 7 & (8 - (SrcX & 7));
    PULONG ppal = (PULONG)&((PDIBINFO)pDibInfo)->pbmi->bmiColors[0];

    pSrcAddr = pSrcAddr + (SrcX >> 3);

    cxUnalignedStart = MIN(SrcCx,cxUnalignedStart);

    //
    // unaligned start
    //

    if (cxUnalignedStart)
    {
        LONG iDst = 7 - (SrcX & 0x07); 
        SrcByte = *pSrcAddr;
        pSrcAddr++;

        while (cxUnalignedStart--)
        {
            ULONG ulSrc = ((SrcByte & (1 << iDst)) >> iDst);
    
            ulSrc = ppal[ulSrc] | 0xFF000000;
            *pulDstAddr = ulSrc;
            
            pulDstAddr++;
            SrcCx--;
            iDst--;
        }
    }

    //
    // aligned whole bytes
    //

    while (SrcCx >= 8)
    {
        SrcCx -= 8;

        SrcByte = *pSrcAddr;

        *(pulDstAddr + 0) = (ppal[(SrcByte & 0x80) >> 7] | 0xff000000);
        *(pulDstAddr + 1) = (ppal[(SrcByte & 0x40) >> 6] | 0xff000000);
        *(pulDstAddr + 2) = (ppal[(SrcByte & 0x20) >> 5] | 0xff000000);
        *(pulDstAddr + 3) = (ppal[(SrcByte & 0x10) >> 4] | 0xff000000);
        *(pulDstAddr + 4) = (ppal[(SrcByte & 0x08) >> 3] | 0xff000000);
        *(pulDstAddr + 5) = (ppal[(SrcByte & 0x04) >> 2] | 0xff000000);
        *(pulDstAddr + 6) = (ppal[(SrcByte & 0x02) >> 1] | 0xff000000);
        *(pulDstAddr + 7) = (ppal[(SrcByte & 0x01) >> 0] | 0xff000000);

        pSrcAddr++;
        pulDstAddr+=8;
    }

    //
    // unaligned end
    //

    if (SrcCx)
    {
        BYTE SrcByte = *pSrcAddr;
        LONG iDst    = 7;

        while (SrcCx)
        {
            ULONG ulSrc = ((SrcByte & (1 << iDst)) >> iDst);
    
            ulSrc = ppal[ulSrc] | 0xff000000;
            *pulDstAddr = ulSrc;
            
            pulDstAddr++;
            SrcCx--;
            iDst--;
        }
    }
}

/**************************************************************************\
* vLoadAndConvert4ToBGRA
*   
*   
* Arguments:
*   
*
*
* Return Value:
*
*
*
* History:
*
*    1/22/1997 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vLoadAndConvert4ToBGRA(
    PULONG   pulDstAddr,
    PBYTE    pSrcAddr,
    LONG     SrcX,
    LONG     SrcCx,
    PVOID    pDibInfo
    )
{
    BYTE SrcByte;
    pSrcAddr = pSrcAddr + (SrcX >> 1);
    LONG cxUnalignedStart = 1 & (2 - (SrcX & 1));
    PULONG ppal = (PULONG)&((PDIBINFO)pDibInfo)->pbmi->bmiColors[0];

    cxUnalignedStart = MIN(SrcCx,cxUnalignedStart);

    //
    // unaligned start
    //

    if (cxUnalignedStart)
    {
        SrcByte = *pSrcAddr;
        *pulDstAddr = ppal[SrcByte & 0x0f] | 0xff000000;
        pSrcAddr++;
        pulDstAddr++;
        SrcCx--;
    }

    //
    // aligned whole bytes
    //

    while (SrcCx >= 2)
    {
        SrcCx -= 2;

        SrcByte = *pSrcAddr;

        *(pulDstAddr + 0) = ppal[(SrcByte >> 4)  ] | 0xff000000;
        *(pulDstAddr + 1) = ppal[(SrcByte & 0x0f)] | 0xff000000;

        pSrcAddr++;
        pulDstAddr+=2;
    }

    //
    // unaligned end
    //

    if (SrcCx)
    {
        SrcByte = *pSrcAddr;
        *pulDstAddr = ppal[SrcByte >> 4] | 0xff000000;
    }
}

/**************************************************************************\
* vLoadAndConvert8ToBGRA
*   
*   
* Arguments:
*   
*
*
* Return Value:
*
*
*
* History:
*
*    1/22/1997 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vLoadAndConvert8ToBGRA(
    PULONG   pulDstAddr,
    PBYTE    pSrcAddr,
    LONG     SrcX,
    LONG     SrcCx,
    PVOID    pDibInfo
    )
{
    PBYTE pjSrc = pSrcAddr + SrcX;
    PBYTE pjEnd = pjSrc + SrcCx;

    PULONG ppal = (PULONG)&((PDIBINFO)pDibInfo)->pbmi->bmiColors[0];

    while (pjSrc != pjEnd)
    {
        *pulDstAddr = ppal[*pjSrc] | 0xff000000;

        pulDstAddr++;
        pjSrc++;
    }
}

/**************************************************************************\
* vLoadAndConvertRGB16_565ToBGRA
*   
*   
* Arguments:
*   
*
*
* Return Value:
*
*
*
* History:
*
*    1/22/1997 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vLoadAndConvertRGB16_565ToBGRA(
    PULONG   pulDstAddr,
    PBYTE    pSrcAddr,
    LONG     SrcX,
    LONG     SrcCx,
    PVOID    pDibInfo
    )
{
    PUSHORT pusSrc = (PUSHORT)pSrcAddr + SrcX;
    PUSHORT pusEnd = pusSrc + SrcCx;

    while (pusSrc != pusEnd)
    {
        ALPHAPIX pixIn;
        ALPHAPIX pixOut;

        pixIn.ul = *pusSrc;

        pixOut.pix.r = (BYTE)((pixIn.ul & 0xf800) >> 8);
        pixOut.pix.g = (BYTE)((pixIn.ul & 0x07e0) >> 3);
        pixOut.pix.b = (BYTE)((pixIn.ul & 0x001f) << 3);
        pixOut.pix.a = 0xff;
        *pulDstAddr = pixOut.ul;

        pusSrc++;
        pulDstAddr++;
    }
}

/**************************************************************************\
* vLoadAndConvertRGB16_555ToBGRA
*   
*   
* Arguments:
*   
*
*
* Return Value:
*
*
*
* History:
*
*    1/22/1997 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vLoadAndConvertRGB16_555ToBGRA(
    PULONG   pulDstAddr,
    PBYTE    pSrcAddr,
    LONG     SrcX,
    LONG     SrcCx,
    PVOID    pDibInfo
    )
{
    PUSHORT pusSrc = (PUSHORT)pSrcAddr + SrcX;
    PUSHORT pusEnd = pusSrc + SrcCx;
    while (pusSrc != pusEnd)
    {
        ALPHAPIX pixIn;
        ALPHAPIX pixOut;

        pixIn.ul = *pusSrc;

        pixOut.pix.r = (BYTE)((pixIn.ul & 0x7c00) >> 7);
        pixOut.pix.g = (BYTE)((pixIn.ul & 0x03e0) >> 2);
        pixOut.pix.b = (BYTE)((pixIn.ul & 0x001f) << 3);

        pixOut.pix.a = 0xff;

        *pulDstAddr = pixOut.ul;

        pusSrc++;
        pulDstAddr++;
    }
}

/**************************************************************************\
* vLoadAndConvert16BitfieldsToBGRA
*   
*   
* Arguments:
*   
*
*
* Return Value:
*
*
*
* History:
*
*    1/22/1997 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vLoadAndConvert16BitfieldsToBGRA(
    PULONG   pulDstAddr,
    PBYTE    pSrcAddr,
    LONG     SrcX,
    LONG     SrcCx,
    PVOID    pDibInfo
    )
{
    PUSHORT pusSrc = (PUSHORT)pSrcAddr + SrcX;
    PUSHORT pusEnd = pusSrc + SrcCx;
    while (pusSrc != pusEnd)
    {
        ULONG ulTmp;

        ulTmp = *pusSrc;

        //ulTmp = ppal.ulBitfieldToRGB(ulTmp);

        ulTmp |= 0xff000000;

        *pulDstAddr = ulTmp;

        pusSrc++;
        pulDstAddr++;
    }
}

/**************************************************************************\
* vLoadAndConvertRGB24ToBGRA
*   
*   
* Arguments:
*   
*
*
* Return Value:
*
*
*
* History:
*
*    1/22/1997 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vLoadAndConvertRGB24ToBGRA(
    PULONG   pulDstAddr,
    PBYTE    pSrcAddr,
    LONG     SrcX,
    LONG     SrcCx,
    PVOID    pDibInfo
    )
{
    PBYTE pjSrc = pSrcAddr + 3 * SrcX;
    PBYTE pjEnd = pjSrc    + 3 * SrcCx;

    while (pjSrc != pjEnd)
    {
        ALPHAPIX pixRet;

        pixRet.pix.b = *(((PBYTE)pjSrc));
        pixRet.pix.g = *(((PBYTE)pjSrc)+1);
        pixRet.pix.r = *(((PBYTE)pjSrc)+2);
        pixRet.pix.a = 0xff;

        *pulDstAddr = pixRet.ul;

        pjSrc += 3;
        pulDstAddr++;
    }
}

/**************************************************************************\
* vLoadAndConvertRGB32ToBGRA
*   
*   
* Arguments:
*   
*
*
* Return Value:
*
*
*
* History:
*
*    1/22/1997 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vLoadAndConvertRGB32ToBGRA(
    PULONG   pulDstAddr,
    PBYTE    pSrcAddr,
    LONG     SrcX,
    LONG     SrcCx,
    PVOID    pDibInfo
    )
{
    PULONG pulSrc = (PULONG)pSrcAddr + SrcX;
    PULONG pulEnd = pulSrc + SrcCx;

    while (pulSrc != pulEnd)
    {
        ALPHAPIX pixIn;
        ALPHAPIX pixOut;

        pixIn.ul = *pulSrc;

        pixOut.pix.r = pixIn.pix.b;
        pixOut.pix.g = pixIn.pix.g;
        pixOut.pix.b = pixIn.pix.r;
        pixOut.pix.a = pixIn.pix.a;

        *pulDstAddr = pixOut.ul;

        pulSrc++;
        pulDstAddr++;
    }
}

/**************************************************************************\
* vLoadAndConvert32BitfieldsToBGRA
*   
*   
* Arguments:
*   
*
*
* Return Value:
*
*
*
* History:
*
*    1/22/1997 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vLoadAndConvert32BitfieldsToBGRA(
    PULONG   pulDstAddr,
    PBYTE    pSrcAddr,
    LONG     SrcX,
    LONG     SrcCx,
    PVOID    pDibInfo
    )
{
    PULONG pulSrc = (PULONG)pSrcAddr + SrcX;
    PULONG pulEnd = pulSrc + SrcCx;

    while (pulSrc != pulEnd)
    {
        ULONG ulTmp;

        ulTmp = *pulSrc;

        //ulTmp = ppal.ulBitfieldToRGB(ulTmp);

        *pulDstAddr = ulTmp;

        pulSrc++;
        pulDstAddr++;
    }
}

//
// 
// STORE ROUTINES  
// convert BGRA to RGB332, look up in table
//

//#define PALETTE_MATCH(pixIn,ppalInfo)                         \
//{                                                             \
//    pixIn.ul = ppalInfo->pxlate332[                           \
//                    ((pixIn.pix.r & 0xe0))      |             \
//                    ((pixIn.pix.g & 0xe0) >> 3) |             \
//                    ((pixIn.pix.b & 0xc0) >> 6)];             \
//}                                                             \

/**************************************************************************\
* vConvertAndSaveBGRATo8
*   
*   
* Arguments:
*   
*
*
* Return Value:
*
*
*
* History:
*
*    1/22/1997 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vConvertAndSaveBGRAToDest(
    PBYTE       pDst,
    PULONG      pulSrc,
    LONG        cx,
    LONG        DstX,
    LONG        y,
    PVOID       pvdibInfoDst,
    PBYTE       pWriteMask,
    HDC         hdc32
    )
{
    PDIBINFO pDibInfo = (PDIBINFO)pvdibInfoDst;

    BitBlt(pDibInfo->hdc,
           pDibInfo->rclBoundsTrim.left,
           pDibInfo->rclBoundsTrim.top + y,
           pDibInfo->rclBoundsTrim.right  - pDibInfo->rclBoundsTrim.left,
           1,
           hdc32,
           0,
           0,
           SRCCOPY);
}

/**************************************************************************\
* vConvertAndSaveBGRAToRGB16_565
*   
*   
* Arguments:
*   
*
*
* Return Value:
*
*
*
* History:
*
*    1/22/1997 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vConvertAndSaveBGRAToRGB16_565(
    PBYTE       pjDst,
    PULONG      pulSrc,
    LONG        cx,
    LONG        DstX,
    LONG        y,
    PVOID       pvdibInfoDst,
    PBYTE       pWriteMask,
    HDC         hdc32
    )
{
    PUSHORT pusDst = (PUSHORT)pjDst + DstX;
    PUSHORT pusEnd = pusDst + cx;

    while (pusDst != pusEnd)
    {
        ALPHAPIX  pixIn;
        ALPHAPIX  pixOut;

        pixIn.ul = *pulSrc;

        pixOut.ul =    ((pixIn.pix.r & 0xf8) << 8) |
                       ((pixIn.pix.g & 0xfc) << 3) |
                       ((pixIn.pix.b & 0xf8) >> 3);


        *pusDst = (USHORT)pixOut.ul;

        pulSrc++;
        pusDst++;
    }
}

/**************************************************************************\
* vConvertAndSaveBGRAToRGB16_555
*   
*   
* Arguments:
*   
*
*
* Return Value:
*
*
*
* History:
*
*    1/22/1997 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vConvertAndSaveBGRAToRGB16_555(
    PBYTE       pjDst,
    PULONG      pulSrc,
    LONG        cx,
    LONG        DstX,
    LONG        y,
    PVOID       pvdibInfoDst,
    PBYTE       pWriteMask,
    HDC         hdc32
    )
{
    PUSHORT pusDst = (PUSHORT)pjDst + DstX;
    PUSHORT pusEnd = pusDst + cx;

    while (pusDst != pusEnd)
    {
        ALPHAPIX  pixIn;
        ALPHAPIX  pixOut;

        pixIn.ul = *pulSrc;

        pixOut.ul =    ((pixIn.pix.r & 0xf8) << 7) |
                       ((pixIn.pix.g & 0xf8) << 2) |
                       ((pixIn.pix.b & 0xf8) >> 3);

        *pusDst = (USHORT)pixOut.ul;

        pulSrc++;
        pusDst++;
    }
}

/**************************************************************************\
* vConvertAndSaveBGRAToRGB24
*   
*   
* Arguments:
*   
*
*
* Return Value:
*
*
*
* History:
*
*    1/22/1997 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vConvertAndSaveBGRAToRGB24(
    PBYTE       pDst,
    PULONG      pulSrc,
    LONG        cx,
    LONG        DstX,
    LONG        y,
    PVOID       pvdibInfoDst,
    PBYTE       pWriteMask,
    HDC         hdc32
    )
{
    PBYTE pjDst = (PBYTE)pDst + (3 * DstX);
    PBYTE pjEnd = pjDst + (3 * cx);

    while (pjDst != pjEnd)
    {
        ALPHAPIX  pixIn;

        pixIn.ul = *pulSrc;

        *pjDst     = pixIn.pix.b;
        *(pjDst+1) = pixIn.pix.g;
        *(pjDst+2) = pixIn.pix.r;

        pulSrc++;
        pjDst+=3;
    }
}

/**************************************************************************\
* vConvertAndSaveBGRAToRGB32
*   
*   
* Arguments:
*   
*
*
* Return Value:
*
*
*
* History:
*
*    1/22/1997 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vConvertAndSaveBGRAToRGB32(
    PBYTE       pjDst,
    PULONG      pulSrc,
    LONG        cx,
    LONG        DstX,
    LONG        y,
    PVOID       pvdibInfoDst,
    PBYTE       pWriteMask,
    HDC         hdc32
    )
{
    PULONG pulDst = (PULONG)pjDst + DstX;
    PULONG pulEnd = pulDst + cx;
    while (pulDst != pulEnd)
    {
        ALPHAPIX  pixIn;
        ALPHAPIX  pixOut;

        pixIn.ul = *pulSrc;

        pixOut.pix.r = pixIn.pix.b;
        pixOut.pix.g = pixIn.pix.g;
        pixOut.pix.b = pixIn.pix.r;
        pixOut.pix.a = 0;

        *pulDst = pixOut.ul;

        pulSrc++;
        pulDst++;
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\image\alphaimg.cxx ===
/******************************Module*Header*******************************\
* Module Name: tranblt.cxx
*
* Transparent BLT
*
* Created: 21-Jun-1996
* Author: Mark Enstrom [marke]
*
* Copyright (c) 1996-1999 Microsoft Corporation
\**************************************************************************/
#include "precomp.hxx"
#pragma hdrstop

#if !(_WIN32_WINNT >= 0x500)

//
// global memory DC with single scan line 32 bpp DIBSection,
// use protected by semLocal
//

HDC        ghdc32Tmp;
HDC        ghdc32;
PULONG     gpulDIB32;

/**************************************************************************\
* bInitAlpha
*
*   Init global scan line DC
*   
* Arguments:
*   
*   none
*
* Return Value:
*
*   status
*
* History:
*
*    4/30/1997 Mark Enstrom [marke]
*
\**************************************************************************/

BOOL
bInitAlpha()
{
    BOOL bRet = TRUE;
    BITMAPINFO bmi32;
                
    bmi32.bmiHeader.biSize            = sizeof(BITMAPINFOHEADER);
    bmi32.bmiHeader.biWidth           = SCAN_LINE_DC_WIDTH;
    bmi32.bmiHeader.biHeight          = 1;
    bmi32.bmiHeader.biPlanes          = 1;
    bmi32.bmiHeader.biBitCount        = 32;
    bmi32.bmiHeader.biCompression     = BI_RGB;
    bmi32.bmiHeader.biSizeImage       = 0;
    bmi32.bmiHeader.biXPelsPerMeter   = 0;
    bmi32.bmiHeader.biYPelsPerMeter   = 0;
    bmi32.bmiHeader.biClrUsed         = 0;
    bmi32.bmiHeader.biClrImportant    = 0;

    HDC         hdc32 = CreateCompatibleDC(NULL);

    if (hdc32 != NULL)
    {
        PULONG      pulDIBSrc;
        HBITMAP     hbmSrc = CreateDIBSection(hdc32,&bmi32,DIB_RGB_COLORS,(PVOID *)&pulDIBSrc,NULL,0);

        if (hbmSrc)
        {
            HBITMAP hbmOld = (HBITMAP)SelectObject(hdc32,hbmSrc);

            if (hbmOld != NULL)
            {
                ghdc32     = hdc32;
                ghdc32Tmp  = hdc32;
                gpulDIB32  = pulDIBSrc;
            }
            else
            {
                DeleteDC(hdc32);
                DeleteObject(hbmSrc);
                bRet = FALSE;
            }
        }
        else
        {
            DeleteDC(hdc32);
            bRet = FALSE;
        }
    }
    else
    {
        bRet = FALSE;
    }
    
    return(bRet);
}



/**************************************************************************\
* CleanupGlobals
*   
*   Free any global DIBsections, DCs, etc. from initialization.
*
* Arguments:
*   none.
*
* Return Value:
*   none.
*
* History:
*
*    1/19/2000 Donald Chinn [DChinn]
*
\**************************************************************************/
VOID CleanupGlobals()
{
    ASSERTGDI(ghdc32 == ghdc32Tmp, "ghdc32Tmp is still being used.");
    if (!ghdc32)
    {
        DeleteDC(ghdc32);
    }
    if (!gpulDIB32)
    {
        DeleteObject(gpulDIB32);
    }
    return;
}


/**************************************************************************\
* hdcAllocateScanLineDC
*   
*   allocate tmp scan line DC. try to use fast allocator.
*
* Arguments:
*   
*   hdcComp     - hdc for compatible bitmap
*   width       - width of scan line
*   pulScanLine - return pointer to temp scan line
*
* Return Value:
*
*
*
* History:
*
*    4/30/1997 Mark Enstrom [marke]
*
\**************************************************************************/

HDC
hdcAllocateScanLineDC(
    LONG        width,
    PULONG      *pulScanLine
    )
{
    ASSERTGDI(pulScanLine != NULL,"Scan line pointer must not be NULL");

    HDC hdcRet = NULL;

    //
    // try to acquire global scan line DC
    //

    if (width <= SCAN_LINE_DC_WIDTH)
    {
        hdcRet = (HDC)InterlockedExchange((PLONG)&ghdc32Tmp, 0);
    }

    if (hdcRet != NULL)
    {
        //
        // allocation succeded, assign pointer
        //

        *pulScanLine = gpulDIB32;
    }
    else
    {
        //
        // if acquire failed, allocate
        //

        BITMAPINFO bmi32;
    
        bmi32.bmiHeader.biSize            = sizeof(BITMAPINFOHEADER);
        bmi32.bmiHeader.biWidth           = width;
        bmi32.bmiHeader.biHeight          = 1;
        bmi32.bmiHeader.biPlanes          = 1;
        bmi32.bmiHeader.biBitCount        = 32;
        bmi32.bmiHeader.biCompression     = BI_RGB;
        bmi32.bmiHeader.biSizeImage       = 0;
        bmi32.bmiHeader.biXPelsPerMeter   = 0;
        bmi32.bmiHeader.biYPelsPerMeter   = 0;
        bmi32.bmiHeader.biClrUsed         = 0;
        bmi32.bmiHeader.biClrImportant    = 0;
        
        HDC         hdc32 = CreateCompatibleDC(NULL);

        if (hdc32 != NULL)
        {
            PULONG      pulDIBSrc;
            HBITMAP     hbmSrc = CreateDIBSection(hdc32,&bmi32,DIB_RGB_COLORS,(PVOID *)&pulDIBSrc,NULL,0);

            if (hbmSrc)
            {
                HBITMAP hbmOld = (HBITMAP)SelectObject(hdc32,hbmSrc);

                if (hbmOld != NULL)
                {
                    hdcRet = hdc32;
                    *pulScanLine = pulDIBSrc;
                }
                else
                {
                    DeleteDC(hdc32);
                    DeleteObject(hbmSrc);
                }
            }
            else
            {
                DeleteDC(hdc32);
            }
        }
    }

    return(hdcRet);
}

/**************************************************************************\
* vFreeScanLineDC
*   
*   free tmp scan line dc and dibsection   
*
* Arguments:
*   
*   hdcFree - scan line DC
*
* Return Value:
*
*   none
*
* History:
*
*    4/30/1997 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vFreeScanLineDC(
    HDC     hdcFree
    )
{
    ASSERTGDI(hdcFree != NULL,"vFreeScanLineDC: DC can't be NULL");

    if (hdcFree == ghdc32)
    {
        //
        // release global hdc
        // 

        ghdc32Tmp = ghdc32;
    }
    else
    {
        //
        // free allocated DC and bitmap
        //

        HBITMAP hbmOld = (HBITMAP)GetCurrentObject(hdcFree,OBJ_BITMAP);

        DeleteDC(hdcFree);
        
        if (hbmOld)
        {
            DeleteObject(hbmOld);
        }
    }
}

/**************************************************************************\
* vPixelOver
*   
*   optimized routine used when the blend function is SRC_OVER and the
*   SourceConstantAlpha is 255.
*
*       Dst = Src + (1-SrcAlpha) * Dst
*   
* Arguments:
*   
*   ppixDst        - address of dst pixel
*   ppixSrc        - address of src pixel
*   cx             - number of pixels in scan line
*   BlendFunction  - blend to be done on each pixel
*   pwrMask        - set each byte to 0 for pixel that doesn't need 
*                    to be written to dst
*
* Return Value:
*
*   none
*
* History:
*
*    1/23/1997 Mark Enstrom [marke]
*
\**************************************************************************/

#if !defined(_X86_)

VOID
vPixelOver(
    ALPHAPIX       *ppixDst,
    ALPHAPIX       *ppixSrc,
    LONG           cx,
    BLENDFUNCTION  BlendFunction,
    PBYTE          pwrMask
    )
{
    ALPHAPIX pixSrc;
    ALPHAPIX pixDst;

    while (cx--)
    {
        pixSrc = *ppixSrc;

        if (pixSrc.pix.a != 0)
        {
            pixDst = *ppixDst;

            if (pixSrc.pix.a == 255)
            {
                pixDst = pixSrc;
            }
            else
            {
                //
                // Dst = Src + (1-SrcAlpha) * Dst
                //

                ULONG Multa = 255 - pixSrc.pix.a;
                ULONG _D1_00AA00GG = (pixDst.ul & 0xff00ff00) >> 8;
                ULONG _D1_00RR00BB = (pixDst.ul & 0x00ff00ff);
                
                ULONG _D2_AAAAGGGG = _D1_00AA00GG * Multa + 0x00800080;
                ULONG _D2_RRRRBBBB = _D1_00RR00BB * Multa + 0x00800080;
                
                ULONG _D3_00AA00GG = (_D2_AAAAGGGG & 0xff00ff00) >> 8;
                ULONG _D3_00RR00BB = (_D2_RRRRBBBB & 0xff00ff00) >> 8;
                
                
                ULONG _D4_AA00GG00 = (_D2_AAAAGGGG + _D3_00AA00GG) & 0xFF00FF00;
                ULONG _D4_00RR00BB = ((_D2_RRRRBBBB + _D3_00RR00BB) & 0xFF00FF00) >> 8;
                
                pixDst.ul = pixSrc.ul + _D4_AA00GG00 + _D4_00RR00BB;
            }

            *ppixDst = pixDst;
        }
        else
        {
            *pwrMask = 0;
        }

        pwrMask++;
        ppixSrc++;
        ppixDst++;
    }
}

#endif

/**************************************************************************\
* vPixelBlendOrDissolveOver
*   
*   Blend routine when the blend function is SRC_OVER, but when 
*   SourceConstantAlpah != 255 and The source bitmap does have alpha values
*
*       if SrcAlpha == 255 then
*           (Blend)
*           Dst = Dst + ConstAlpha * (Src - Dst)
*
*       else
*           (Dissolve)
*           Src = Src * ConstAlpha
*           (Over)
*           Dst = Src + (1 - SrcAlpha) Dst       
*   
* Arguments:
*   
*   ppixDst        - address of dst pixel
*   ppixSrc        - address of src pixel
*   cx             - number of pixels in scan line
*   BlendFunction  - blend to be done on each pixel
*   pwrMask        - set each byte to 0 for pixel that doesn't need 
*                    to be written to dst
*
* Return Value:
*
*   None
*
* History:
*
*    3/12/1997 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vPixelBlendOrDissolveOver(
    ALPHAPIX       *ppixDst,
    ALPHAPIX       *ppixSrc,
    LONG           cx,
    BLENDFUNCTION  BlendFunction,
    PBYTE          pwrMask
    )
{
    ALPHAPIX pixSrc;
    ALPHAPIX pixDst;
    BYTE     ConstAlpha = BlendFunction.SourceConstantAlpha;

    while (cx--)
    {
        pixSrc = *ppixSrc;

        if (pixSrc.pix.a != 0)
        {
            pixDst = *ppixDst;

            if (pixSrc.pix.a == 255)
            {
                //
                // Blend: D = sA * S + (1-sA) * D
                //
                // red and blue
                //
        
                ULONG uB00rr00bb = pixDst.ul & 0x00ff00ff;
                ULONG uF00rr00bb = pixSrc.ul & 0x00ff00ff;
        
                ULONG uMrrrrbbbb = ((uB00rr00bb<<8)-uB00rr00bb) + 
                                   (ConstAlpha * (uF00rr00bb - uB00rr00bb)) + 0x00800080;
        
                ULONG uM00rr00bb = (uMrrrrbbbb & 0xff00ff00) >> 8;
        
                ULONG uD00rr00bb = ((uMrrrrbbbb+uM00rr00bb) & 0xff00ff00)>>8;
        
                //
                // alpha and green
                //
        
                ULONG uB00aa00gg = (pixDst.ul >> 8) & 0xff00ff;
                ULONG uF00aa00gg = (pixSrc.ul >> 8) & 0xff00ff;
        
                ULONG uMaaaagggg = ((uB00aa00gg <<8)-uB00aa00gg) +
                                   (ConstAlpha * (uF00aa00gg-uB00aa00gg)) + 0x00800080;
        
                ULONG uM00aa00gg = (uMaaaagggg & 0xff00ff00)>>8;
        
                ULONG uDaa00gg00 = (uMaaaagggg + uM00aa00gg) & 0xff00ff00;
        
                pixDst.ul  = uD00rr00bb + uDaa00gg00;
            }
            else
            {
                //
                // disolve
                //

                ULONG ul_B_00AA00GG = (pixSrc.ul & 0xff00ff00) >> 8;
                ULONG ul_B_00RR00BB = (pixSrc.ul & 0x00ff00ff);
        
                ULONG ul_T_AAAAGGGG = ul_B_00AA00GG * ConstAlpha + 0x00800080;
                ULONG ul_T_RRRRBBBB = ul_B_00RR00BB * ConstAlpha + 0x00800080;
        
                ULONG ul_T_00AA00GG = (ul_T_AAAAGGGG & 0xFF00FF00) >> 8;
                ULONG ul_T_00RR00BB = (ul_T_RRRRBBBB & 0xFF00FF00) >> 8;
        
                ULONG ul_C_AA00GG00 = ((ul_T_AAAAGGGG + ul_T_00AA00GG) & 0xFF00FF00);
                ULONG ul_C_00RR00BB = ((ul_T_RRRRBBBB + ul_T_00RR00BB) & 0xFF00FF00) >> 8;
        
                pixSrc.ul = (ul_C_AA00GG00 | ul_C_00RR00BB);

                //
                // over
                //


                ULONG Multa = 255 - pixSrc.pix.a;
                ULONG _D1_00AA00GG = (pixDst.ul & 0xff00ff00) >> 8;
                ULONG _D1_00RR00BB = (pixDst.ul & 0x00ff00ff);

                ULONG _D2_AAAAGGGG = _D1_00AA00GG * Multa + 0x00800080;
                ULONG _D2_RRRRBBBB = _D1_00RR00BB * Multa + 0x00800080;

                ULONG _D3_00AA00GG = (_D2_AAAAGGGG & 0xff00ff00) >> 8;
                ULONG _D3_00RR00BB = (_D2_RRRRBBBB & 0xff00ff00) >> 8;


                ULONG _D4_AA00GG00 = (_D2_AAAAGGGG + _D3_00AA00GG) & 0xFF00FF00;
                ULONG _D4_00RR00BB = ((_D2_RRRRBBBB + _D3_00RR00BB) & 0xFF00FF00) >> 8;

                pixDst.ul = pixSrc.ul + _D4_AA00GG00 + _D4_00RR00BB;
            }

            *ppixDst = pixDst;
        }
        else
        {
            *pwrMask = 0;
        }

        pwrMask++;
        ppixSrc++;
        ppixDst++;
    }
}

#if !defined(_X86_)

/******************************Public*Routine******************************\
* vPixelBlend
*   
*   Blend function used then BlendFunction is SRC_OVER and 
*   SourceConstantAlpha != 255, and Src image does NOT have
*   it's own alpha channel. (assume 255)
*
*           Dst = Dst + ConstAlpha * (Src - Dst)
*   
* Arguments:
*   
*   ppixDst        - address of dst pixel
*   ppixSrc        - address of src pixel
*   cx             - number of pixels in scan line
*   BlendFunction  - blend to be done on each pixel
*   pwrMask        - set each byte to 0 for pixel that doesn't need 
*                    to be written to dst
*
* Return Value:
*   
*   None
*
* History:
*
*    12/2/1996 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vPixelBlend(
    ALPHAPIX       *ppixDst,
    ALPHAPIX       *ppixSrc,
    LONG           cx,
    BLENDFUNCTION  BlendFunction,
    PBYTE          pwrMask
    )
{
    PULONG   pulSrc = (PULONG)ppixSrc;
    PULONG   pulDst = (PULONG)ppixDst;
    PULONG   pulSrcEnd = pulSrc + cx;
    BYTE     ConstAlpha = BlendFunction.SourceConstantAlpha;

    //
    // Blend: D = sA * S + (1-sA) * D
    //

    while (pulSrc != pulSrcEnd)
    {
        ULONG ulDst = *pulDst;
        ULONG ulSrc = *pulSrc;
        ULONG uB00rr00bb = ulDst & 0x00ff00ff;
        ULONG uF00rr00bb = ulSrc & 0x00ff00ff;

        ULONG uMrrrrbbbb; 
        ULONG uM00rr00bb; 
        ULONG uD00rr00bb; 
        ULONG uB00aa00gg;
        ULONG uF00aa00gg;
        ULONG uMaaaagggg;
        ULONG uM00aa00gg;
        ULONG uDaa00gg00;

        //
        // red and blue
        //

        uB00rr00bb = ulDst & 0x00ff00ff;
        uF00rr00bb = ulSrc & 0x00ff00ff;

        uMrrrrbbbb = ((uB00rr00bb<<8)-uB00rr00bb) + 
                     (ConstAlpha * (uF00rr00bb - uB00rr00bb)) + 0x00800080;

        uM00rr00bb = (uMrrrrbbbb & 0xff00ff00) >> 8;

        uD00rr00bb = ((uMrrrrbbbb+uM00rr00bb) & 0xff00ff00)>>8;

        //
        // alpha and green
        //

        uB00aa00gg = (ulDst >> 8) & 0xff00ff;
        uF00aa00gg = (ulSrc >> 8) & 0xff00ff;

        uMaaaagggg = ((uB00aa00gg <<8)-uB00aa00gg) +
                     (ConstAlpha * (uF00aa00gg-uB00aa00gg)) + 0x00800080;

        uM00aa00gg = (uMaaaagggg & 0xff00ff00)>>8;

        uDaa00gg00 = (uMaaaagggg + uM00aa00gg) & 0xff00ff00;

        *pulDst = uD00rr00bb + uDaa00gg00;

        pulSrc++;
        pulDst++;
    }
}

#endif

/******************************Public*Routine******************************\
* vPixelBlend24
*   
*   Blend two 24 bpp images with a constant alpha value
*
* Arguments:
*   
*   pixDst,      
*   pixSrc,      
*   cx,          
*   BlendFunction
*   pwrMask      
*
* Return Value:
*
*
*
* History:
*
*    12/2/1996 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vPixelBlend24(
    ALPHAPIX     *ppixDst,
    ALPHAPIX     *ppixSrc,
    LONG          cx,
    BLENDFUNCTION BlendFunction,
    PBYTE         pwrMask
    )
{
    BYTE    ConstAlpha = BlendFunction.SourceConstantAlpha;
    PBYTE   pjSrc      = (PBYTE)ppixSrc;
    PBYTE   pjDst      = (PBYTE)ppixDst;
    PBYTE   pjSrcEnd   = pjSrc + 3*cx;

    while (pjSrc != pjSrcEnd)
    {
        ULONG ulDst = (*pjDst) << 16;
        ULONG ulSrc = (*pjSrc) << 16;

        ULONG uB00rr00bb;
        ULONG uF00rr00bb;
        ULONG uMrrrrbbbb; 
        ULONG uM00rr00bb; 
        ULONG uD00rr00bb; 
        ULONG uB000000gg;
        ULONG uF000000gg;
        ULONG uM0000gggg;
        ULONG uM000000gg;
        ULONG uD000000gg;

        //
        // red and blue
        //

        uB00rr00bb = uB00rr00bb = ulDst | (*(pjDst+1)); 
        uF00rr00bb = uF00rr00bb = ulSrc | (*(pjSrc+1)); 

        uMrrrrbbbb = ((uB00rr00bb<<8)-uB00rr00bb) + 
                     (ConstAlpha * (uF00rr00bb - uB00rr00bb)) + 0x00800080;

        uM00rr00bb = (uMrrrrbbbb & 0xff00ff00) >> 8;

        uD00rr00bb = ((uMrrrrbbbb+uM00rr00bb) & 0xff00ff00)>>8;

        //
        // green
        //

        uB000000gg = *(pjDst+2);
        uF000000gg = *(pjSrc+2);

        uM0000gggg = ((uB000000gg <<8)-uB000000gg) +
                     (ConstAlpha * (uF000000gg-uB000000gg)) + 0x00000080;

        uM000000gg = (uM0000gggg & 0x0000ff00)>>8;

        uD000000gg = ((uM0000gggg + uM000000gg) & 0x0000ff00) >> 8;

        *pjDst     = (BYTE)(uD00rr00bb >> 16);
        *(pjDst+1) = (BYTE)(uD00rr00bb);
        *(pjDst+2) = (BYTE)(uD000000gg);

        pjSrc+=3;
        pjDst+=3;
    }
}


#if defined(_X86_)

typedef unsigned __int64 QWORD;

/**************************************************************************
  THIS FUNCTION DOES NOT DO ANY PARAMETER VALIDATION
  DO NOT CALL THIS FUNCTION WITH WIDTH == 0

  This function operates on 32 bit pixels (BGRA) in a row of a bitmap.
  This function performs the following:

  		SrcTran = 255 - pixSrc.a
		pixDst.r = pixSrc.r + (((SrcTran * pixDst.r)+127)/255);
		pixDst.g = pixSrc.g + (((SrcTran * pixDst.g)+127)/255);
		pixDst.b = pixSrc.b + (((SrcTran * pixDst.b)+127)/255);
		pixDst.a = pixSrc.a + (((SrcTran * pixDst.a)+127)/255);

  pDst is assumed to be aligned to a DWORD boundary when passed to this function.
  Step 1:
	Check pDst for QWORD alignment.  If aligned, do Step 2.  If unaligned, do first pixel
	as a DWORD, then do Step 2.
  Step 2:
	QuadAligned
	pDst is QWORD aligned.  If two pixels can be done as a QWORD, do Step 3.  If only one
	pixel left, do as a DWORD.
  Step 3:
	Load two source pixels, S1 and S2.  Get (255 - alpha value) for each source pixel, 255-S1a and 255-S2a.
	Copy 255-S1a as four words into an MMX register.  Copy 255-S2a as four words into an MMX register.
	Load two destination pixels, D1 and D2.  Expand each byte in D1 into four words
	of an MMX register.  If at least four pixels can be done, do Step 4.  If not, jump over
	FourPixelsPerPass and finish doing two pixels at TwoPixelsLeft, Step 5.
  Step 4:
	FourPixelsPerPass
	Expand each byte in D2 into four words of an MMX register.  Multiply each byte
	of D1 by 255-S1a.  Multiply each byte of D2 by 255-S2a.  Add 128 to each intermediate result
	of both pixels.  Copy the results of each pixel into an MMX register.  Shift each result of
	both pixels by 8.  Add the shifted results to the copied results.  Shift these results by 8.
	Pack the results into one MMX register.  Add the packed results to the source pixels.  Store result
	over destination pixels.  Stay in FourPixelsPerPass loop until there are less than four pixels to do.
  Step 5:
    TwoPixelsLeft
	Do same as Step 4 above; but do not loop.
  Step 6:
	OnePixelLeft
	If there is one pixel left (odd number of original pixels) do last pixel as a DWORD.
**************************************************************************/
VOID
mmxPixelOver(
    ALPHAPIX       *pDst,
    ALPHAPIX       *pSrc,
	LONG			Width,
	BLENDFUNCTION	BlendFunction,
	PBYTE			pwrMask)
{
	static QWORD W128 = 0x0080008000800080;
	static QWORD AlphaMask = 0x000000FF000000FF;

	_asm
	{
        mov			esi, pSrc
        mov			edi, pDst
    
        movq		mm7, W128		// |  0  | 128 |  0  | 128 |  0  | 128 |  0  | 128 |
                                    //	This register never changes
        pxor		mm6, mm6		// |  0  |  0  |  0  |  0  |  0  |  0  |  0  |  0  |
                                    //	This register never changes
    
        mov			ecx, Width
                                    // Step 1:
        test		edi, 7			// Test first pixel for QWORD alignment
        jz			QuadAligned		// if unaligned,
    
        jmp			Do1Pixel		// do first pixel only
    
    QuadAligned:					// Step 2:
        mov			eax, ecx		// Save the width in eax for later (see OnePixelLeft:)
        shr			ecx, 1			// Want to do 2 pixels (1 quad) at once, so make ecx even
        test		ecx, ecx		// Make sure there is at least 1 quad to do
        jz			OnePixelLeft	// If we take this jump, width was 1 (aligned) or 2 (unaligned)
    
                                    // Step 3:
        movq		mm0, [esi]		// | S2a | S2r | S2g | S2b | S1a | S1r | S1g | S1b |
        psrld		mm0, 24			// |  0  |  0  | 0 |  S2a  |  0  |  0  | 0 |  S1a  |
        pxor		mm0, AlphaMask	// |  0  |  0  | 0 |255-S2a|  0  |  0  | 0 |255-S1a|
        movq		mm1, mm0		// |  0  |  0  | 0 |255-S2a|  0  |  0  | 0 |255-S1a|
    
        punpcklwd	mm0, mm0		// |     0	   |     0	   |  255-S1a  |  255-S1a  |
        movq		mm2, [edi]		// | D2a | D2r | D2g | D2b | D1a | D1r | D1g | D1b |
        punpckhwd	mm1, mm1		// |     0	   |     0	   |  255-S2a  |  255-S2a  |
        movq		mm3, mm2		// | D2a | D2r | D2g | D2b | D1a | D1r | D1g | D1b |
    
        punpckldq	mm0, mm0		// |  255-S1a  |  255-S1a  |  255-S1a  |  255-S1a  |
        punpckldq	mm1, mm1		// |  255-S2a  |  255-S2a  |  255-S2a  |  255-S2a  |
        punpcklbw	mm2, mm6		// |  0  | D1a |  0  | D1r |  0  | D1g |  0  | D1b |
    
        dec			ecx
        jz			TwoPixelsLeft
    
    FourPixelsPerPass:				// Step 4:
        // Indenting indicates operations on the next set of pixels
        // Within this loop, instructions will pair as shown for the Pentium processor
                                    //	T1 = 255-S1a	T2 = 255-S2a
        punpckhbw	mm3, mm6		// |  0  | D2a |  0  | D2r |  0  | D2g |  0  | D2b |
        pmullw		mm2, mm0		// |   T1*D1a  |   T1*D1r  |   T1*D1g  |   T1*D1b  |
    
        movq		mm0, [esi+8]	// | S2a | S2r | S2g | S2b | S1a | S1r | S1g | S1b |
        pmullw		mm3, mm1		// |   T2*D2a  |   T2*D2r  |   T2*D2g  |   T2*D2b  |
    
        psrld		mm0, 24			// |  0  |  0  | 0 |  S2a  |  0  |  0  | 0 |  S1a  |
        add			esi, 8			// pSrc++;
    
        pxor		mm0, AlphaMask	// |  0  |  0  | 0 |255-S2a|  0  |  0  | 0 |255-S1a|
        paddusw		mm2, mm7		// |T1*D1a+128 |T1*D1r+128 |T1*D1g+128 |T1*D1b+128 |
    
        paddusw		mm3, mm7		// |T2*D2a+128 |T2*D2r+128 |T2*D2g+128 |T2*D2b+128 |
        movq		mm1, mm0		// |  0  |  0  | 0 |255-S2a|  0  |  0  | 0 |255-S1a|
    
        movq		mm4, mm2		// |T1*D1a+128 |T1*D1r+128 |T1*D1g+128 |T1*D1b+128 |
        punpcklwd	mm0, mm0		// |     0	   |     0	   |  255-S1a  |  255-S1a  |
    
        movq		mm5, mm3		// |T2*D2a+128 |T2*D2r+128 |T2*D2g+128 |T2*D2b+128 |
        punpckhwd	mm1, mm1		// |     0	   |     0	   |  255-S2a  |  255-S2a  |
                                    //	TDXx' = TX*DXx+128
        psrlw		mm2, 8			// |  TD1a'>>8 |  TD1r'>>8 |  TD1g'>>8 |  TD1b'>>8 |
    
                                    //  TDXx" = (TX*DXx+128)+(TDXx'>>8)
        psrlw		mm3, 8			// |  TD2a'>>8 |  TD2r'>>8 |  TD2g'>>8 |  TD2b'>>8 |
        paddusw		mm4, mm2		// |  TD1a"    |  TD1r"    |  TD1g"    |  TD1b"    |
    
        paddusw		mm5, mm3		// |  TD2a"    |  TD2r"    |  TD2g"    |  TD2b"    |
        psrlw		mm4, 8			// |  TD1a">>8 |  TD1r">>8 |  TD1g">>8 |  TD1b">>8 |
    
        movq		mm2, [edi+8]	// | D2a | D2r | D2g | D2b | D1a | D1r | D1g | D1b |
        psrlw		mm5, 8			// |  TD2a">>8 |  TD2r">>8 |  TD2g">>8 |  TD2b">>8 |
    
        movq		mm3, mm2		// | D2a | D2r | D2g | D2b | D1a | D1r | D1g | D1b |
        packuswb	mm4, mm5		// |TD2a'"|TD2r'"|TD2g'"|TD2b'"|TD1a'"|TD1r'"|TD1g'"|TD1b'"|  
    
        paddusb		mm4, [esi-8]
        punpckldq	mm0, mm0		// |  255-S1a  |  255-S1a  |  255-S1a  |  255-S1a  |
    
        movq		[edi], mm4
        punpckldq	mm1, mm1		// |  255-S2a  |  255-S2a  |  255-S2a  |  255-S2a  |
    
        punpcklbw	mm2, mm6		// |  0  | D1a |  0  | D1r |  0  | D1g |  0  | D1b |
        add			edi, 8			//	pDst++;
        
        dec			ecx
        jnz			FourPixelsPerPass
    
    TwoPixelsLeft:					// Step 5:
        punpckhbw	mm3, mm6		// |  0  | D2a |  0  | D2r |  0  | D2g |  0  | D2b |
        pmullw		mm2, mm0		// |   T1*D1a  |   T1*D1r  |   T1*D1g  |   T1*D1b  |
        pmullw		mm3, mm1		// |   T2*D2a  |   T2*D2r  |   T2*D2g  |   T2*D2b  |
    
        paddusw		mm2, mm7		// |T1*D1a+128 |T1*D1r+128 |T1*D1g+128 |T1*D1b+128 |
        paddusw		mm3, mm7		// |T2*D2a+128 |T2*D2r+128 |T2*D2g+128 |T2*D2b+128 |
    
        movq		mm4, mm2		// |T1*D1a+128 |T1*D1r+128 |T1*D1g+128 |T1*D1b+128 |
        movq		mm5, mm3		// |T2*D2a+128 |T2*D2r+128 |T2*D2g+128 |T2*D2b+128 |
    
        psrlw		mm2, 8			// |  TD1a'>>8 |  TD1r'>>8 |  TD1g'>>8 |  TD1b'>>8 |
        psrlw		mm3, 8			// |  TD2a'>>8 |  TD2r'>>8 |  TD2g'>>8 |  TD2b'>>8 |
    
        paddusw		mm4, mm2		// |  TD1a"    |  TD1r"    |  TD1g"    |  TD1b"    |
        paddusw		mm5, mm3		// |  TD2a"    |  TD2r"    |  TD2g"    |  TD2b"    |
    
        psrlw		mm4, 8			// |  TD1a">>8 |  TD1r">>8 |  TD1g">>8 |  TD1b">>8 |
        psrlw		mm5, 8			// |  TD2a">>8 |  TD2r">>8 |  TD2g">>8 |  TD2b">>8 |
    
        packuswb	mm4, mm5		// |TD2a'"|TD2r'"|TD2g'"|TD2b'"|TD1a'"|TD1r'"|TD1g'"|TD1b'"|  
    
        paddusb		mm4, [esi]
    
        movq		[edi], mm4
    
        add			edi, 8
        add			esi, 8
    
    OnePixelLeft:				    // Step 6:
        // This tests for 0 or 1 pixel left in row - eax contains real width, not width/2
        // If 0, there were an even number of pixels and we're done
        // If 1, there is an odd number of pixels and we need to do one more
        test		eax, 1	
        jz			Done
    
    Do1Pixel:						// make as a macro if used in asm file
                                    // T = 255-S1x
        movd		mm0, DWORD PTR[esi]		// |  0  |  0  |  0  |  0  | S1a | S1r | S1g | S1b |
        psrld		mm0, 24			// |  0  |  0  |  0  |  0  |  0  |  0  | 0 |  S1a  |
        pxor		mm0, AlphaMask	// |  0  |  0  |  0  | 255 |  0  |  0  | 0 |255-S1a|
        punpcklwd	mm0, mm0		// |     0	   |     0	   |  255-S1a  |  255-S1a  |
        punpckldq	mm0, mm0		// |  255-S1a  |  255-S1a  |  255-S1a  |  255-S1a  |
    
        movd		mm1, [edi]		// |  0  |  0  |  0  |  0  | D1a | D1r | D1g | D1b |
        punpcklbw	mm1, mm6		// |  0  | D1a |  0  | D1r |  0  | D1g |  0  | D1b |
        pmullw		mm0, mm1		// |	 T*D1a |	 T*D1r |	 T*D1g |	 T*D1b |
        paddusw		mm0, mm7		// | T*D1a+128 | T*D1r+128 | T*D1g+128 | T*D1b+128 |
        movq		mm1, mm0		// | T*D1a+128 | T*D1r+128 | T*D1g+128 | T*D1b+128 |
        psrlw		mm0, 8			// |  TD1a'>>8 |  TD1r'>>8 |  TD1g'>>8 |  TD1b'>>8 |
        paddusw		mm0, mm1		// |  TD1a"    |  TD1r"    |  TD1g"    |  TD1b"    |
        psrlw		mm0, 8			// |  TD1a">>8 |  TD1r">>8 |  TD1g">>8 |  TD1b">>8 |
        movd        mm1, [esi]
        packuswb	mm0, mm0		// |TD2a'"|TD2r'"|TD2g'"|TD2b'"|TD1a'"|TD1r'"|TD1g'"|TD1b'"|  
        paddusb		mm0, mm1
        movd		[edi], mm0
        add			edi, 4			//	pDst++;
        add			esi, 4			//	pSrc++;
    
        test		ecx, ecx
        jz			Done			// just processed the last pixel of the row
        dec			ecx
        jmp			QuadAligned		// just processed the first pixel of the row
    
    Done:
        emms						// remove for optimizations, have calling function do emms
	}
}

/**************************************************************************\
* mmxPixelBlendOrDissolveOver
*   
*   Blend routine when the blend function is SRC_OVER, but when 
*   SourceConstantAlpah != 255 and The source bitmap does have alpha values
*
*       if SrcAlpha == 255 then
*
*           Dst = Dst + ConstAlpha * (Src - Dst)
*
*       else
*
*           Src = Src * ConstAlpha
*           Dst = Src + (1 - SrcAlpha) Dst       
*   
* Arguments:
*   
*   ppixDst        - address of dst pixel
*   ppixSrc        - address of src pixel
*   cx             - number of pixels in scan line
*   BlendFunction  - blend to be done on each pixel
*   pwrMask        - set each byte to 0 for pixel that doesn't need 
*                    to be written to dst
*
* Return Value:
*
*   None
*
* History:
*
*    3/12/1997 Mark Enstrom [marke]
*
\**************************************************************************/



/**************************************************************************
  THIS FUNCTION DOES NOT DO ANY PARAMETER VALIDATION
  DO NOT CALL THIS FUNCTION WITH WIDTH == 0

  This function operates on 32 bit pixels (BGRA) in a row of a bitmap.
  This function performs the following:
	first,
  		pixSrc.r = (((ConstAlpha * pixSrc.r)+127)/255);
		pixSrc.g = (((ConstAlpha * pixSrc.g)+127)/255);
		pixSrc.b = (((ConstAlpha * pixSrc.b)+127)/255);
		pixSrc.a = (((ConstAlpha * pixSrc.a)+127)/255);
	then,
  		SrcTran = 255 - pixSrc.a
		pixDst.r = pixSrc.r + (((SrcTran * pixDst.r)+127)/255);
		pixDst.g = pixSrc.g + (((SrcTran * pixDst.g)+127)/255);
		pixDst.b = pixSrc.b + (((SrcTran * pixDst.b)+127)/255);
		pixDst.a = pixSrc.a + (((SrcTran * pixDst.a)+127)/255);

  pDst is assumed to be aligned to a DWORD boundary when passed to this function.
  Step 1:
	Check pDst for QWORD alignment.  If aligned, do Step 2.  If unaligned, do first pixel
	as a DWORD, then do Step 2.
  Step 2:
	QuadAligned
	pDst is QWORD aligned.  If two pixels can be done as a QWORD, do Step 3.  If only one
	pixel left, do as a DWORD.
  Step 3:
	Load two source pixels, S1 and S2, as one QWORD.  Expand S1 and S2 as four words into two MMX registers.
	Multiply each word in S1 and S2 by ConstAlpha.  Add 128 to each result of both pixels.  Copy the results
	of each pixel into an MMX register.  Shift each result of both pixels by 8.  Add the shifted results
	to the copied results.  Shift these results by 8.  Pack the results into one MMX register...this will
	be used later.
	Shift the packed results by 24 to get only the alpha value for each pixel.
  Step 4:
	Get (255 - new alpha value) for each pixel, 255-S1a and 255-S2a.
	Copy 255-S1a as four words into an MMX register.  Copy 255-S2a as four words into an MMX register.
	Load two destination pixels, D1 and D2.  Expand D1 and D2 as four words into two MMX registers.
	Multiply each byte of D1 by 255-S1a.  Multiply each byte of D2 by 255-S2a.  Add 128 to each intermediate
	result of both pixels.  Copy the results of each pixel into an MMX register.  Shift each result of
	both pixels by 8.  Add the shifted results to the copied results.  Shift these results by 8.
	Pack the results into one MMX register.  Add the packed results to the new source pixels saved from
	above.  Store result over destination pixels.  Stay in TwoPixelsAtOnceLoop loop until there is less than
	two pixels to do.
  Step 5:
	OnePixelLeft
	If there is one pixel left (odd number of original pixels) do last pixel as a DWORD.
**************************************************************************/
VOID
mmxPixelBlendOrDissolveOver(
    ALPHAPIX	  *pDst,
    ALPHAPIX	  *pSrc,
	LONG 	       Width,
    BLENDFUNCTION  BlendFunction,
    PBYTE          pwrMask
    )
{
    BYTE    ConstAlpha = BlendFunction.SourceConstantAlpha;
	static QWORD W128 = 0x0080008000800080;
	static QWORD AlphaMask = 0x000000FF000000FF;
	static QWORD Zeros = 0;
	_asm
	{
        mov			esi, pSrc
        mov			edi, pDst
    
        movq		mm7, W128		// This register never changes
        pxor		mm4, mm4		// This register never changes
    
        xor			eax, eax
        mov			al, ConstAlpha	
        movd		mm5, eax		// |		   |		   |		   |		CA |
        punpcklwd	mm5, mm5		// |		   |		   |		CA |		CA |
        punpcklwd	mm5, mm5		// |		CA |		CA |		CA |		CA |
                                    // This register never changes
    
        mov			ecx, Width
                                    // Step 1:
        test		edi, 7			// Test first pixel for QWORD alignment
        jz			QuadAligned		// if unaligned,
    
        jmp			Do1Pixel		// do first pixel only
    
    QuadAligned:					// Step 2:
        mov			eax, ecx		// Save the width in eax for later (see OnePixelLeft:)
        shr			ecx, 1			// Want to do 2 pixels (1 quad) at once, so make ecx even
        test		ecx, ecx		// Make sure there is at least 1 quad to do
        jz			OnePixelLeft	// If we take this jump, width was 1 (aligned) or 2 (unaligned)
    
    TwoPixelsAtOnceLoop:			// Step 3:
        // Within this loop, instructions will pair as shown for the Pentium processor
    
        /* Dissolve
            pixSrc.r = (((ConstAlpha * pixSrc.r)+127)/255);
            pixSrc.g = (((ConstAlpha * pixSrc.g)+127)/255);
            pixSrc.b = (((ConstAlpha * pixSrc.b)+127)/255);
            pixSrc.a = (((ConstAlpha * pixSrc.a)+127)/255);
        */
    
        movq		mm0, [esi]			// | S2a | S2r | S2g | S2b | S1a | S1r | S1g | S1b |
    
        movq		mm1, mm0			// | S2a | S2r | S2g | S2b | S1a | S1r | S1g | S1b |
        punpcklbw	mm0, mm4			// |  0  | S1a |  0  | S1r |  0  | S1g |  0  | S1b |
    
        punpckhbw	mm1, mm4			// |  0  | S2a |  0  | S2r |  0  | S2g |  0  | S2b |
        pmullw		mm0, mm5			// |	CA*S1a |    CA*S1r |	 CA*S1g |	CA*S1b |
    
        add			esi, 8			//	pSrc++;
        pmullw		mm1, mm5			// |	CA*S2a |	CA*S2r |	 CA*S2g |	CA*S2b |
    
        paddusw		mm1, mm7			// |CA*S2a+128 |CA*S2r+128 |CA*S2g+128 |CA*S2b+128 |
        paddusw		mm0, mm7			// |CA*S1a+128 |CA*S1r+128 |CA*S1g+128 |CA*S1b+128 |
    
        movq		mm2, mm0			// |CA*S1a+128 |CA*S1r+128 |CA*S1g+128 |CA*S1b+128 |
        psrlw		mm0, 8				// |  S1a'>>8 |  S1r'>>8 |  S1g'>>8 |  S1b'>>8 |
    
                                    //	S1x' = CA*S1x+128		 S2x' = CA*S2x+128
        movq		mm3, mm1			// |CA*S2a+128 |CA*S2r+128 |CA*S2g+128 |CA*S2b+128 |
        psrlw		mm1, 8				// |  S2a'>>8 |  S2r'>>8 |  S2g'>>8 |  S2b'>>8 |
    
                                    //	S1x" = (CA*S1x+128)>>8  S2x" = (CA*S2x+128)>>8
        paddusw		mm0, mm2			// |  S1a"    |  S1r"    |  S1g"    |  S1b"    |
        paddusw		mm1, mm3			// |  S2a"    |  S2r"    |  S2g"    |  S2b"    |
    
        psrlw		mm0, 8				// |  S1a">>8 |  S1r">>8 |  S1g">>8 |  S1b">>8 |
    
                                    //	SXx'" = ((CA*SXx+128)>>8)>>8)
        psrlw		mm1, 8				// |  S2a">>8 |  S2r">>8 |  S2g">>8 |  S2b">>8 |
        packuswb	mm0, mm1			// |S2a'"|S2r'"|S2g'"|S2b'"|S1a'"|S1r'"|S1g'"|S1b'"|
    
        movq		mm6, mm0
        psrld		mm0, 24				// |  0  |  0  | 0 |  S2a  |  0  |  0  | 0 |  S1a  |
    
        /* Over
            SrcTran = 255 - pixSrc.a
            pixDst.r = pixSrc.r + (((SrcTran * pixDst.r)+128)/255);
            pixDst.g = pixSrc.g + (((SrcTran * pixDst.g)+128)/255);
            pixDst.b = pixSrc.b + (((SrcTran * pixDst.b)+128)/255);
            pixDst.a = pixSrc.a + (((SrcTran * pixDst.a)+128)/255);
        */
                                    // Step 4:
        pxor		mm0, AlphaMask		// |  0  |  0  | 0 |255-S2a|  0  |  0  | 0 |255-S1a|
    
        movq		mm1, mm0			// |  0  |  0  | 0 |255-S2a|  0  |  0  | 0 |255-S1a|
        punpcklwd	mm0, mm0			// |     0	   |     0	   |   255-S1a |   255-S1a |
    
        movq		mm2, [edi]			// | D2a | D2r | D2g | D2b | D1a | D1r | D1g | D1b |
        punpcklwd	mm0, mm0			// |   255-S1a |   255-S1a |   255-S1a |   255-S1a |
    
        movq		mm3, mm2			// | D2a | D2r | D2g | D2b | D1a | D1r | D1g | D1b |
        punpckhwd	mm1, mm1			// |     0	   |     0	   |   255-S2a |   255-S2a |
    
        punpcklwd	mm1, mm1			// |   255-S2a |   255-S2a |   255-S2a |   255-S2a |
    
        punpckhbw	mm3, mm4			// |  0  | D2a |  0  | D2r |  0  | D2g |  0  | D2b |
    
                                    //	T1 = 255-S1a	T2 = 255-S2a
        punpcklbw	mm2, mm4			// |  0  | D1a |  0  | D1r |  0  | D1g |  0  | D1b |
        pmullw		mm1, mm3			// |	T2*D2a |	T2*D2r |	 T2*D2g |	T2*D2b |
    
        add			edi, 8			//	pDst++;
        pmullw		mm0, mm2			// |	T1*D1a |	T1*D1r |	 T1*D1g |	T1*D1b |
    
        paddusw		mm0, mm7			// |T1*D1a+128 |T1*D1r+128 |T1*D1g+128 |T1*D1b+128 |
        paddusw		mm1, mm7			// |T2*D2a+128 |T2*D2r+128 |T2*D2g+128 |T2*D2b+128 |
    
        movq		mm3, mm1			// |T2*D2a+128 |T2*D2r+128 |T2*D2g+128 |T2*D2b+128 |
                                    //  TDXx' = TX*DXx+128
        psrlw		mm1, 8				// |  TD2a'>>8 |  TD2r'>>8 |  TD2g'>>8 |  TD2b'>>8 |
    
        movq		mm2, mm0			// |T1*D1a+128 |T1*D1r+128 |T1*D1g+128 |T1*D1b+128 |
        psrlw		mm0, 8				// |  TD1a'>>8 |  TD1r'>>8 |  TD1g'>>8 |  TD1b'>>8 |
                                    //  TDXx" = (TX*DXx+128)+(TDXx'>>8)
        paddusw		mm1, mm3			// |  TD2a"    |  TD2r"    |  TD2g"    |  TD2b"    |
        paddusw		mm0, mm2			// |  TD1a"    |  TD1r"    |  TD1g"    |  TD1b"    |
    
        psrlw		mm1, 8				// |  TD2a">>8 |  TD2r">>8 |  TD2g">>8 |  TD2b">>8 |
    
        psrlw		mm0, 8				// |  TD1a">>8 |  TD1r">>8 |  TD1g">>8 |  TD1b">>8 |
    
        packuswb	mm0, mm1		// |TD2a'"|TD2r'"|TD2g'"|TD2b'"|TD1a'"|TD1r'"|TD1g'"|TD1b'"|  
                                    //	SXx = SXx'"	TDXx = TDXx'"
        paddusb		mm0, mm6// |S2a+TD2a|S2r+TD2r|S2g+TD2g|S2b+TD2b|S1a+TD1a|S1r+TD1r|S1g+TD1g|S1b+TD1b|
    
        movq		[edi-8], mm0
    
        dec			ecx
        jnz			TwoPixelsAtOnceLoop
    
    OnePixelLeft:					// Step 5:
        // This tests for 0 or 1 pixel left in row - eax contains real width, not width/2
        // If 0, there were an even number of pixels and we're done
        // If 1, there is an odd number of pixels and we need to do one more
        test		eax, 1	
        jz			Done
        
    Do1Pixel:						// make as a macro if used in asm file
    
        /* Dissolve
            pixSrc.r = (((ConstAlpha * pixSrc.r)+127)/255);
            pixSrc.g = (((ConstAlpha * pixSrc.g)+127)/255);
            pixSrc.b = (((ConstAlpha * pixSrc.b)+127)/255);
            pixSrc.a = (((ConstAlpha * pixSrc.a)+127)/255);
        */
    
        movd		mm0, [esi]			// | S2a | S2r | S2g | S2b | S1a | S1r | S1g | S1b |
        punpcklbw	mm0, mm4			// |  0  | S1a |  0  | S1r |  0  | S1g |  0  | S1b |
    
        pmullw		mm0, mm5			// |	CA*S1a |    CA*S1r |	 CA*S1g |	CA*S1b |
        paddusw		mm0, mm7			// |CA*S1a+128 |CA*S1r+128 |CA*S1g+128 |CA*S1b+128 |
        movq		mm2, mm0			// |CA*S1a+128 |CA*S1r+128 |CA*S1g+128 |CA*S1b+128 |
    
                                    //	 S1x' = CA*S1x+128		 S2x' = CA*S2x+128
        psrlw		mm0, 8				// |  S1a'>>8 |  S1r'>>8 |  S1g'>>8 |  S1b'>>8 |
                                    //	 S1x" = (CA*S1x+128)>>8 S2x" = (CA*S2x+128)>>8
        paddusw		mm0, mm2			// |  S1a"    |  S1r"    |  S1g"    |  S1b"    |
        psrlw		mm0, 8				// |  S1a">>8 |  S1r">>8 |  S1g">>8 |  S1b">>8 |
        packuswb	mm0, mm0			// |S2a'"|S2r'"|S2g'"|S2b'"|S1a'"|S1r'"|S1g'"|S1b'"|
        movq		mm6, mm0
        psrld		mm0, 24				// |  0  |  0  | 0 |  S2a  |  0  |  0  | 0 |  S1a  |
    
        /* Over
            SrcTran = 255 - pixSrc.a
            pixDst.r = pixSrc.r + (((SrcTran * pixDst.r)+128)/255);
            pixDst.g = pixSrc.g + (((SrcTran * pixDst.g)+128)/255);
            pixDst.b = pixSrc.b + (((SrcTran * pixDst.b)+128)/255);
            pixDst.a = pixSrc.a + (((SrcTran * pixDst.a)+128)/255);
        */
    
        pxor		mm0, AlphaMask		// |  0  |  0  | 0 |255-S2a|  0  |  0  | 0 |255-S1a|
        punpcklwd	mm0, mm0			// |  0  |  0  |  0  |  0  |  0  |  0  |255-S1a|255-S1a|
        punpckldq	mm0, mm0			// |    255-S1a|    255-S1a|    255-S1a|    255-S1a|
        movd		mm2, [edi]			// |  0  |  0  |  0  |  0  | D1a | D1r | D1g | D1b |
        punpcklbw	mm2, mm4			// |	   D1a |	   D1r |	   D1g |	   D1b |
                                    //	T = 255-S1x
        pmullw		mm0, mm2			// |	 T*D1a |	 T*D1r |	 T*D1g |	 T*D1b |
        paddusw		mm0, mm7			// | T*D1a+128 | T*D1r+128 | T*D1g+128 | T*D1b+128 |
        movq		mm1, mm0			// | T*D1a+128 | T*D1r+128 | T*D1g+128 | T*D1b+128 |
        psrlw		mm0, 8				// |  TD1a'>>8 |  TD1r'>>8 |  TD1g'>>8 |  TD1b'>>8 |
        paddusw		mm0, mm1			// |  TD1a"    |  TD1r"    |  TD1g"    |  TD1b"    |
        psrlw		mm0, 8
        packuswb	mm0, mm0		// |TD2a'"|TD2r'"|TD2g'"|TD2b'"|TD1a'"|TD1r'"|TD1g'"|TD1b'"|  
        paddusb		mm0, mm6  
        movd		[edi], mm0
        add			edi, 4			// pDst++;
        add			esi, 4			// pSrc++;
    
        test		ecx, ecx
        jz			Done			// just processed the last pixel of the row
        dec			ecx
        jmp			QuadAligned		// just processed the first pixel of the row
    
    Done:
        emms						// remove for optimizations, have calling function do emms
	}
}

/**************************************************************************
  THIS FUNCTION DOES NOT DO ANY PARAMETER VALIDATION

  This function operates on 16 bit pixels (5 for Red, 5 for Green, and 5 for Blue) in a row of a bitmap.
  It blends source and destination bitmaps, without alpha channels, using a constant alpha input.
  The function performs the following on each byte:

  tmp1 = Alpha(Src - Dst) + 16 + (Dst * 31)

  tmp2 = tmp1 AND 3E0h (mask off low 5 bits)
  tmp2 = tmp2 shr 5 (move high 5 bits to low 5 bits)
  tmp2 = tmp2 + tmp1
  tmp2 = tmp2 AND 3E0h (mask off low 5 bits)
  tmp2 = tmp2 shr 5 (move high 5 bits to low 5 bits)
  Dst = tmp2

  pDst is assumed to be aligned to a DWORD boundary when passed to this function.

  Red and blue are processed together in the same register.  Green is processed separately.
  For two pixels at once, the reds and blues for both pixels are processed in the same register; and the
  greens are processed together in a separate register.

  The loop structure is as follows:
  Step 1:
	Check pDst for QWORD alignment.  If aligned, do Step 2.  If unaligned, do first pixel
	as a DWORD (OnePixelLeft:), then do Step 2.
  Step 2:
  (QuadAligned:)
	pDst is QWORD aligned.  If two pixels can be done as a QWORD, do Step 3.  If only one
	pixel left, do as a DWORD.
  Step 3:
  (TwoPixelsAtOnceLoop:)
	Perform the above function, using MMX instructions, on two pixels per pass of the loop.
  Step 4:
  (OnePixelLeft:)
	If there is one pixel left (odd number of original pixels) do last pixel as a DWORD.
**************************************************************************/
VOID
mmxPixelBlend16_555(
    PALPHAPIX     pDst,
    PALPHAPIX     pSrc,
    LONG          Width,
    BLENDFUNCTION BlendFunction,
    PBYTE         pwrMask
    )
{
	static QWORD RMask  = 0x007C0000007C0000;
	static QWORD GMask  = 0x0000000003E003E0;
	static QWORD BMask  = 0x0000001F0000001F;
	static QWORD RBConst = 0x0010001000100010;
	static QWORD GConst = 0x0000000000100010;
	static QWORD RGBMask  = 0x03E003E003E003E0;
	static QWORD RedMask  =  0x001F0000001F0000;
	static QWORD CA;	// ConstAlpha in 4 words of a qword
    BYTE         ConstAlpha = BlendFunction.SourceConstantAlpha;

	_asm
	{
		mov			ecx, Width		// Make sure there is at least one pixel to do
		test		ecx, ecx
		jz			Done

		mov			esi, pSrc
		mov			edi, pDst

		xor			eax, eax
		mov			al, ConstAlpha
		movd		mm5, eax		// |		   |		   |		   |		CA |
		punpcklwd	mm5, mm5		// |		   |		   |		CA |		CA |
		punpcklwd	mm5, mm5		// |		CA |		CA |		CA |		CA |
		movq		CA, mm5
									// Step 1:
		test		edi, 7			// Test first pixel for QWORD alignment
		jz			QuadAligned		// if unaligned,

		jmp			Do1Pixel		// do first pixel only

	QuadAligned:					// Step 2:
		mov			eax, ecx		// Save the width in eax for later (see OnePixelLeft:)
		shr			ecx, 1			// Want to do 2 pixels (1 quad) at once, so make ecx even
		test		ecx, ecx		// Make sure there is at least 1 quad to do
		jz			OnePixelLeft	// If we take this jump, width was 1 (aligned) or 2 (unaligned)

	TwoPixelsAtOnceLoop:			// Step 3:
		movd		mm0, [edi]	// | 0 | 0 | 0 | 0 | D2xrrrrrgg | D2gggbbbbb | D1xrrrrrgg | D1gggbbbbb |
		pxor		mm7, mm7
									
		movd		mm1, [esi]	// | 0 | 0 | 0 | 0 | S2xrrrrrgg | S2gggbbbbb | S1xrrrrrgg | S1gggbbbbb |
		movq		mm2, mm0	// | 0 | 0 | 0 | 0 | D2xrrrrrgg | D2gggbbbbb | D1xrrrrrgg | D1gggbbbbb |

		movq		mm3, mm1	// | 0 | 0 | 0 | 0 | S2xrrrrrgg | S2gggbbbbb | S1xrrrrrgg | S1gggbbbbb |
		punpcklbw	mm0, mm7	// | D2xrrrrrgg | D2gggbbbbb | D1xrrrrrgg | D1gggbbbbb |

		punpcklbw	mm1, mm7	// | S2xrrrrrgg | S2gggbbbbb | S1xrrrrrgg | S1gggbbbbb |
		movq		mm4, mm0	// | D2xrrrrrgg | D2gggbbbbb | D1xrrrrrgg | D1gggbbbbb |

		pand		mm0, RMask	// | D20rrrrr00 |     0      | D10rrrrr00 |     0      |
		movq		mm5, mm1	// | S2xrrrrrgg | S2gggbbbbb | S1xrrrrrgg | S1gggbbbbb |

		pand		mm4, BMask	// |     0      | D2000bbbbb |     0      | D1000bbbbb |
		psrlw		mm0, 2		// |    D2rrrrr |     0      |    D1rrrrr |     0      |

		pand		mm1, RMask	// | S20rrrrr00 |     0      | S10rrrrr00 |     0      |
		por			mm0, mm4	// |    D2rrrrr |    D2bbbbb |    D1rrrrr |    D1bbbbb |

		pand		mm5, BMask	// |     0      |    S2bbbbb |     0      |    S1bbbbb |
		movq		mm4, mm0	// |    D2rrrrr |    D2bbbbb |    D1rrrrr |    D1bbbbb |

		pand		mm2, GMask	// |     0      |     0      |D2ggggg00000|D1ggggg00000|
		psllw		mm4, 5		// |D2rrrrr00000|D2bbbbb00000|D1rrrrr00000|D1bbbbb00000|

		pand		mm3, GMask	// |     0      |     0      |S2ggggg00000|S1ggggg00000|
		psrlw		mm1, 2		// |    S2rrrrr |     0      |    S1rrrrr |     0      |

		por			mm5, mm1	// |    S2rrrrr |    S2bbbbb |    S1rrrrr |    S1bbbbb |
		movq		mm6, mm2	// |     0      |     0      |D2ggggg00000|D1ggggg00000|

		psubw		mm5, mm0	// |   S2r-D2r  |   S2b-D2b  |   S1r-D1r  |   S1b-D1b  |
		psrlw		mm2, 5		// |     0      |     0      |    D2ggggg |    D1ggggg |

		pmullw		mm5, CA		// |    CA2r    |    CA2b    |    CA1r    |    CA1b    |
		psubw		mm4, mm0	// |   D2r*31   |   D2b*31   |   D1r*31   |   D1b*31   |

		paddw		mm4, RBConst// |   CA2r+c   |   CA2b+c   |   CA1r+c   |   CA1b+c   |
		psrlw		mm3, 5		// |     0      |     0      |    S2ggggg |    S1ggggg |

		psubw		mm3, mm2	// |     0      |     0      |   S2g-D2g  |   S1g-D1g  |
		add			esi, 4		// pSrc++;

		pmullw		mm3, CA		// |     0      |     0      |    CA2g    |    CA1g    |
		paddw		mm4, mm5	// RBtmp1 = Alpha(RBSrc - RBDst) + 16 + (RBDst * 31)

		psubw		mm6, mm2	// |     0      |     0      |   D2g*31   |   D2g*31   |
		add			edi, 4		// pDst++;

		paddw		mm6, GConst	// |     0      |     0      |   CA2g+c   |   CA1g+c   |
		movq		mm1, mm4	// RBtmp1 = Alpha(RBSrc - RBDst) + 16 + (RBDst * 31)

		pand		mm4, RGBMask// RBtmp2 = RBtmp1 AND 3E0h (mask off low 5 bits)
		paddw		mm6, mm3	// Gtmp1 = Alpha(GSrc - GDst) + 16 + (GDst * 31)

		movq		mm5, mm6	// Gtmp1 = Alpha(GSrc - GDst) + 16 + (GDst * 31)
		psrlw		mm4, 5		// RBtmp2 = RBtmp2 shr 5 (move high 5 bits to low 5 bits)

		pand		mm6, RGBMask// Gtmp2 = Gtmp1 AND 3E0h (mask off low 5 bits)
		paddw		mm1, mm4	// RBtmp2 = RBtmp2 + RBtmp1

		pand		mm1, RGBMask// RBtmp2 = RBtmp2 AND 3E0h (mask off low 5 bits)
		psrlw		mm6, 5		// Gtmp2 = Gtmp2 shr 5 (move high 5 bits to low 5 bits)

		paddw		mm5, mm6	// Gtmp2 = Gtmp2 + Gtmp1
		psrlw		mm1, 5		// RBtmp2 = RBtmp2 shr 5 (move high 5 bits to low 5 bits)

		pand		mm5, RGBMask// Gtmp2 = Gtmp2 AND 3E0h (mask off low 5 bits)
		movq		mm4, mm1	// RBtmp2 = RBtmp2 shr 5 (move high 5 bits to low 5 bits)

		pand		mm4, RedMask// Mask to get red

		pand		mm1, BMask	// Mask to get blue
		psllw		mm4, 2		// Line up the red

		por			mm4, mm1	// Combine reds and blues in proper bit location

		packuswb	mm4, mm7	// | 0 | 0 | 0 | 0 | D20rrrrrgg | D2gggbbbbb | D10rrrrrgg | D1gggbbbbb |

		por			mm4, mm5	// | 0 | 0 | 0 | 0 | D20rrrrrgg | D2gggbbbbb | D10rrrrrgg | D1gggbbbbb |

		movd		[edi-4], mm4

		dec			ecx
		jnz			TwoPixelsAtOnceLoop

	OnePixelLeft:						// Step 4:
		// This tests for 0 or 1 pixel left in row - eax contains real width, not width/2
		// If 0, there was an even number of pixels and we're done
		// If 1, there is an odd number of pixels and we need to do one more
		test		eax, 1	
		jz			Done

	Do1Pixel:							// make as a macro if used in asm file

		movzx   edx,WORD PTR[edi]       ; edx = D 0000 0000 0rrr rrgg gggb bbbb
        movzx   ebx,WORD PTR[esi]       ; ebx = S 0000 0000 0rrr rrgg gggb bbbb

		movd		mm0, edx	// | 0 | 0 | 0 | 0 | 0 | 0 | D1xrrrrrgg | D1gggbbbbb |
		pxor		mm7, mm7
									
		movd		mm1, ebx	// | 0 | 0 | 0 | 0 | 0 | 0 | S1xrrrrrgg | S1gggbbbbb |
		movq		mm2, mm0	// | 0 | 0 | 0 | 0 | 0 | 0 | D1xrrrrrgg | D1gggbbbbb |
									
		movq		mm3, mm1	// | 0 | 0 | 0 | 0 | 0 | 0 | S1xrrrrrgg | S1gggbbbbb |
		punpcklbw	mm0, mm7	// | 0 | 0 | D1xrrrrrgg | D1gggbbbbb |

		punpcklbw	mm1, mm7	// | 0 | 0 | S1xrrrrrgg | S1gggbbbbb |
		movq		mm4, mm0	// | 0 | 0 | D1xrrrrrgg | D1gggbbbbb |

		pand		mm0, RMask	// | 0 | 0 | D10rrrrr00 |     0      |
		movq		mm5, mm1	// | 0 | 0 | S1xrrrrrgg | S1gggbbbbb |

		pand		mm4, BMask	// | 0 | 0 |     0      | D1000bbbbb |
		psrlw		mm0, 2		// | 0 | 0 |    D1rrrrr |     0      |

		pand		mm1, RMask	// | 0 | 0 | S10rrrrr00 |     0      |
		por			mm0, mm4	// | 0 | 0 |    D1rrrrr |    D1bbbbb |

		pand		mm5, BMask	// | 0 | 0 |     0      |    S1bbbbb |
		movq		mm4, mm0	// | 0 | 0 |    D1rrrrr |    D1bbbbb |

		pand		mm2, GMask	// | 0 | 0 |     0      |D1ggggg00000|
		psllw		mm4, 5		// | 0 | 0 |D1rrrrr00000|D1bbbbb00000|

		pand		mm3, GMask	// | 0 | 0 |     0      |S1ggggg00000|
		psrlw		mm1, 2		// | 0 | 0 |    S1rrrrr |     0      |

		por			mm5, mm1	// | 0 | 0 |    S1rrrrr |    S1bbbbb |
		movq		mm6, mm2	// | 0 | 0 |     0      |D1ggggg00000|
		// mm1 is free
		psubw		mm5, mm0	// | 0 | 0 |   S1r-D1r  |   S1b-D1b  |
		psrlw		mm2, 5		// | 0 | 0 |     0      |    D1ggggg |

		pmullw		mm5, CA		// | 0 | 0 |    CA1r    |    CA1b    |
		psubw		mm4, mm0	// | 0 | 0 |   D1r*31   |   D1b*31   |

		paddw		mm4, RBConst// | 0 | 0 |   CA1r+c   |   CA1b+c   |
		psrlw		mm3, 5		// | 0 | 0 |     0      |    S1ggggg |

		psubw		mm3, mm2	// | 0 | 0 |     0      |   S1g-D1g  |
		add			esi, 2		// pSrc++;

		pmullw		mm3, CA		// | 0 | 0 |     0      |    CA1g    |
		paddw		mm4, mm5	// RBtmp1 = Alpha(RBSrc - RBDst) + 16 + (RBDst * 31)

		psubw		mm6, mm2	// | 0 | 0 |     0      |D1ggggg00000-D1ggggg|
		add			edi, 2		// pDst++;

		paddw		mm6, GConst	// | 0 | 0 |     0      |   CA1g+c   |
		movq		mm1, mm4	// RBtmp1 = Alpha(RBSrc - RBDst) + 16 + (RBDst * 31)

		pand		mm4, RGBMask// RBtmp2 = RBtmp1 AND 3E0h (mask off low 5 bits)
		paddw		mm6, mm3	// Gtmp1 = Alpha(GSrc - GDst) + 16 + (GDst * 31)

		movq		mm5, mm6	// Gtmp1 = Alpha(GSrc - GDst) + 16 + (GDst * 31)
		psrlw		mm4, 5		// RBtmp2 = RBtmp2 shr 5 (move high 5 bits to low 5 bits)

		pand		mm6, RGBMask// Gtmp2 = Gtmp1 AND 3E0h (mask off low 5 bits)
		paddw		mm1, mm4	// RBtmp2 = RBtmp2 + RBtmp1

		pand		mm1, RGBMask// RBtmp2 = RBtmp2 AND 3E0h (mask off low 5 bits)
		psrlw		mm6, 5		// Gtmp2 = Gtmp2 shr 5 (move high 5 bits to low 5 bits)

		paddw		mm5, mm6	// Gtmp2 = Gtmp2 + Gtmp1
		psrlw		mm1, 5		// RBtmp2 = RBtmp2 shr 5 (move high 5 bits to low 5 bits)

		pand		mm5, RGBMask// Gtmp2 = Gtmp2 AND 3E0h (mask off low 5 bits)
		movq		mm4, mm1	// RBtmp2 = RBtmp2 shr 5 (move high 5 bits to low 5 bits)

		pand		mm4, RedMask// Mask to get red

		pand		mm1, BMask	// Mask to get blue
		psllw		mm4, 2		// Line up the red

		por			mm4, mm1	// Combine reds and blues in proper bit location

		packsswb	mm4, mm7	// | 0 | 0 | D10rrrrr00 | D1000bbbbb |

		por			mm4, mm5	// | 0 | 0 | D10rrrrrgg | D1gggbbbbb |

		movd		edx, mm4

		mov			[edi-2], dx

		test		ecx, ecx
		jz			Done			// just processed the last pixel of the row
		dec			ecx
		jmp			QuadAligned		// just processed the first pixel of the row

	Done:
		emms						// remove for optimizations, have calling function do emms
	}
}

/**************************************************************************
  THIS FUNCTION DOES NOT DO ANY PARAMETER VALIDATION

  This function operates on 16 bit pixels (5 for Red, 6 for Green, and 5 for Blue) in a row of a bitmap.
  It blends source and destination bitmaps, without alpha channels, using a constant alpha input.
  The function performs the following:

  For red and blue:
  tmp1 = Alpha(Src - Dst) + 16 + (Dst * 31)

  tmp2 = tmp1 AND 3E0h (mask off low 5 bits)
  tmp2 = tmp2 shr 5 (move high 5 bits to low 5 bits)
  tmp2 = tmp2 + tmp1
  tmp2 = tmp2 AND 3E0h (mask off low 5 bits)
  tmp2 = tmp2 shr 5 (move high 5 bits to low 5 bits)
  Dst = tmp2

  For green:
  tmp1 = Alpha(Src - Dst) + 32 + (Dst * 63)

  tmp2 = tmp1 AND FC0h (mask off low 6 bits)
  tmp2 = tmp2 shr 6 (move high 6 bits to low 6 bits)
  tmp2 = tmp2 + tmp1
  tmp2 = tmp2 AND FC0h (mask off low 6 bits)
  tmp2 = tmp2 shr 6 (move high 6 bits to low 6 bits)
  Dst = tmp2

  pDst is assumed to be aligned to a DWORD boundary when passed to this function.

  Red and blue are processed together in the same register.  Green is processed separately.
  For two pixels at once, the reds and blues for both pixels are processed in the same register; and the
  greens are processed together in a separate register.

  The loop structure is as follows:
  Step 1:
	Check pDst for QWORD alignment.  If aligned, do Step 2.  If unaligned, do first pixel
	as a DWORD (OnePixelLeft:), then do Step 2.
  Step 2:
  (QuadAligned:)
	pDst is QWORD aligned.  If two pixels can be done as a QWORD, do Step 3.  If only one
	pixel left, do as a DWORD.
  Step 3:
  (TwoPixelsAtOnceLoop:)
	Perform the above function, using MMX instructions, on two pixels per pass of the loop.
  Step 4:
  (OnePixelLeft:)
	If there is one pixel left (odd number of original pixels) do last pixel as a DWORD.
**************************************************************************/
VOID
mmxPixelBlend16_565(
    PALPHAPIX     pDst,
    PALPHAPIX     pSrc,
    LONG          Width,
    BLENDFUNCTION BlendFunction,
    PBYTE         pwrMask
    )
{
	static QWORD RMask  = 0x00FF000000FF0000;
	static QWORD GMask  = 0x0000000007E007E0;
	static QWORD BMask  = 0x0000001F0000001F;
	static QWORD RBConst = 0x0010001000100010;
	static QWORD GConst = 0x0000000000200020;
	static QWORD RBMask  = 0x03E003E003E003E0;
	static QWORD GreenMask  =  0x000000000FC00FC0;
	static QWORD CA;	// ConstAlpha in 4 words of a qword
    BYTE        ConstAlpha = BlendFunction.SourceConstantAlpha;

	_asm
	{
		mov			ecx, Width		// Make sure there is at least one pixel to do
		test		ecx, ecx
		jz			Done

		mov			esi, pSrc
		mov			edi, pDst

		xor			eax, eax
		mov			al, ConstAlpha
		movd		mm5, eax		// |		   |		   |		   |		CA |
		punpcklwd	mm5, mm5		// |		   |		   |		CA |		CA |
		punpcklwd	mm5, mm5		// |		CA |		CA |		CA |		CA |
		movq		CA, mm5
									// Step 1:
		test		edi, 7			// Test first pixel for QWORD alignment
		jz			QuadAligned		// if unaligned,

		jmp			Do1Pixel		// do first pixel only

	QuadAligned:					// Step 2:
		mov			eax, ecx		// Save the width in eax for later (see OnePixelLeft:)
		shr			ecx, 1			// Want to do 2 pixels (1 quad) at once, so make ecx even
		test		ecx, ecx		// Make sure there is at least 1 quad to do
		jz			OnePixelLeft	// If we take this jump, width was 1 (aligned) or 2 (unaligned)

	TwoPixelsAtOnceLoop:			// Step 3:
		movd		mm0, [edi]		// | 0 | 0 | 0 | 0 | D2rrrrrggg | D2gggbbbbb | D1rrrrrggg | D1gggbbbbb |
		pxor		mm7, mm7		
									
		movd		mm1, [esi]		// | 0 | 0 | 0 | 0 | S2rrrrrggg | S2gggbbbbb | S1rrrrrggg | S1gggbbbbb |
		movq		mm2, mm0		// | 0 | 0 | 0 | 0 | D2rrrrrggg | D2gggbbbbb | D1rrrrrggg | D1gggbbbbb |
									
		movq		mm3, mm1		// | 0 | 0 | 0 | 0 | S2rrrrrggg | S2gggbbbbb | S1rrrrrggg | S1gggbbbbb |
		punpcklbw	mm0, mm7		// | D2rrrrrggg | D2gggbbbbb | D1rrrrrggg | D1gggbbbbb |
									
		punpcklbw	mm1, mm7		// | S2rrrrrggg | S2gggbbbbb | S1rrrrrggg | S1gggbbbbb |
		movq		mm4, mm0		// | D2rrrrrggg | D2gggbbbbb | D1rrrrrggg | D1gggbbbbb |

		pand		mm0, RMask		// | D2rrrrr000 |    0     | D1rrrrr000 |    0     |
		movq		mm5, mm1		// | S2rrrrrggg | S2gggbbbbb | S1rrrrrggg | S1gggbbbbb |
									
		pand		mm4, BMask		// |    0     | D2000bbbbb |    0     | D1000bbbbb |
		psrlw		mm0, 3			// |    D2rrrrr |    0     |    D1rrrrr |    0     |
									
		pand		mm1, RMask		// | S2rrrrr000 |    0     | S1rrrrr000 |    0     |
		por			mm0, mm4		// |    D2rrrrr |    D2bbbbb |    D1rrrrr |    D1bbbbb |
									
		pand		mm5, BMask		// |    0     |    S2bbbbb |    0     |    S1bbbbb |
		movq		mm4, mm0		// |    D2rrrrr |    D2bbbbb |    D1rrrrr |    D1bbbbb |
									
		pand		mm2, GMask		// |    0     |    0     |D2gggggg00000|D1gggggg00000|
		psllw		mm4, 5			// |D2rrrrr00000|D2bbbbb00000|D1rrrrr00000|D1bbbbb00000|
									
		pand		mm3, GMask		// |    0     |    0     |S2gggggg00000|S1gggggg00000|
		psrlw		mm1, 3			// |    S2rrrrr |    0     |    S1rrrrr |    0     |
									
		por			mm5, mm1		// |    S2rrrrr |    S2bbbbb |    S1rrrrr |    S1bbbbb |
		movq		mm6, mm2		// |    0     |    0     |D2gggggg00000|D1gggggg00000|

		psubw		mm5, mm0		// |   S2r-D2r  |   S2b-D2b  |   S1r-D1r  |   S1b-D1b  |
		psrlw		mm2, 5			// |    0     |    0     |   D2gggggg |   D1gggggg |
									
		pmullw		mm5, CA			// |    CA2r    |    CA2b    |    CA1r    |    CA1b    |
		psubw		mm4, mm0		// |   D2r*31   |   D2b*31   |   D1r*31   |   D1b*31   |
									
		paddw		mm4, RBConst	// |   CA2r+c   |   CA2b+c   |   CA1r+c   |   CA1b+c   |
		psrlw		mm3, 5			// |    0     |    0     |   S2gggggg |   S1gggggg |
									
		psubw		mm3, mm2		// |    0     |    0     |   S2g-D2g  |   S1g-D1g  |
		add			esi, 4			// pSrc++;
									
		pmullw		mm3, CA			// |    0     |    0     |    CA2g    |    CA1g    |
		psllw		mm6, 1			// |    0     |    0     |D2gggggg000000|D1gggggg000000|
									
		paddw		mm4, mm5		// RBtmp1 = Alpha(RBSrc - RBDst) + 16 + (RBDst * 31)
		psubw		mm6, mm2		// |    0     |    0     |   D2g*63   |   D1g*63   |
									
		paddw		mm6, GConst		// |    0     |    0     |   CA2g+c   |   CA1g+c   |
		movq		mm1, mm4		// RBtmp1 = Alpha(RBSrc - RBDst) + 16 + (RBDst * 31)
									
		add			edi, 4			// pDst++;
		psllw		mm3, 1			// |    0     |    0     |   CA2g*2   |   CA1g*2   |
									
		pand		mm4, RBMask		// RBtmp2 = RBtmp1 AND 3E0h (mask off low 5 bits)
		paddw		mm6, mm3		// Gtmp1 = Alpha(GSrc - GDst) + 32 + (GDst * 63)
									
		movq		mm5, mm6		// Gtmp1 = Alpha(GSrc - GDst) + 32 + (GDst * 63)
		psrlw		mm4, 5			// RBtmp2 = RBtmp2 shr 5 (move high 5 bits to low 5 bits)

		pand		mm6, GreenMask	// Gtmp2 = Gtmp1 AND FC0h (mask off low 6 bits)
		paddw		mm1, mm4		// RBtmp2 = RBtmp2 + RBtmp1

		pand		mm1, RBMask		// RBtmp2 = RBtmp2 AND 3E0h (mask off low 5 bits)
		psrlw		mm6, 6			// Gtmp2 = Gtmp2 shr 6 (move high 6 bits to low 6 bits)

		paddw		mm5, mm6		// Gtmp2 = Gtmp2 + Gtmp1
		psrlw		mm1, 5			// RBtmp2 = RBtmp2 shr 5 (move high 5 bits to low 5 bits)

		pand		mm5, GreenMask	// Gtmp2 = Gtmp2 AND FC0h (mask off low 6 bits)
		movq		mm4, mm1		// RBtmp2 = RBtmp2 shr 5 (move high 5 bits to low 5 bits)

		pand		mm4, RMask		// Mask to get red
		psrlw		mm5, 1			// Align the green

		pand		mm1, BMask		// Mask to get blue
		psllw		mm4, 3			// Align the red

		por			mm4, mm1		// Combine reds and blues in proper bit location

		packuswb	mm4, mm7		// | 0 | 0 | 0 | 0 | D2rrrrr000 | D2000bbbbb | D1rrrrr000 | D1000bbbbb |

		por			mm4, mm5		// | 0 | 0 | 0 | 0 | D2rrrrrggg | D2gggbbbbb | D1rrrrrggg | D1gggbbbbb |

		movd		[edi-4], mm4

		dec			ecx
		jnz			TwoPixelsAtOnceLoop

	OnePixelLeft:						// Step 4:
		// This tests for 0 or 1 pixel left in row - eax contains real width, not width/2
		// If 0, there were an even number of pixels and we're done
		// If 1, there is an odd number of pixels and we need to do one more
		test		eax, 1	
		jz			Done

	Do1Pixel:							// make as a macro if used in asm file

		movzx   edx,WORD PTR[edi]      ; edx = D 0000 0000 rrrr rggg gggb bbbb
       movzx   ebx,WORD PTR[esi]      ; ebx = S 0000 0000 rrrr rggg gggb bbbb

		movd		mm0, edx		// | 0 | 0 | 0 | 0 | 0 | 0 | D1xrrrrrgg | D1gggbbbbb |
		pxor		mm7, mm7		
										
		movd		mm1, ebx		// | 0 | 0 | 0 | 0 | 0 | 0 | S1rrrrrggg | S1gggbbbbb |
		movq		mm2, mm0		// | 0 | 0 | 0 | 0 | 0 | 0 | D1rrrrrggg | D1gggbbbbb |
										
		movq		mm3, mm1		// | 0 | 0 | 0 | 0 | 0 | 0 | S1rrrrrggg | S1gggbbbbb |
		punpcklbw	mm0, mm7		// | 0 | 0 | D1rrrrrggg | D1gggbbbbb |
									
		punpcklbw	mm1, mm7		// | 0 | 0 | S1rrrrrggg | S1gggbbbbb |
		movq		mm4, mm0		// | 0 | 0 | D1rrrrrggg | D1gggbbbbb |
									
		pand		mm0, RMask		// | 0 | 0 | D1rrrrr000 |    0     |
		movq		mm5, mm1		// | 0 | 0 | S1rrrrrggg | S1gggbbbbb |
									
		pand		mm4, BMask		// | 0 | 0 |    0     | D1000bbbbb |
		psrlw		mm0, 3			// | 0 | 0 |    D1rrrrr |    0     |
									
		pand		mm1, RMask		// | 0 | 0 | S1rrrrr000 |    0     |
		por			mm0, mm4		// | 0 | 0 |    D1rrrrr |    D1bbbbb |
									
		pand		mm5, BMask		// | 0 | 0 |    0     |    S1bbbbb |
		movq		mm4, mm0		// | 0 | 0 |    D1rrrrr |    D1bbbbb |
									
		pand		mm2, GMask		// | 0 | 0 |    0     |D1gggggg00000|
		psllw		mm4, 5			// | 0 | 0 |D1rrrrr00000|D1bbbbb00000|
									
		pand		mm3, GMask		// | 0 | 0 |    0     |S1gggggg00000|
		psrlw		mm1, 3			// | 0 | 0 |    S1rrrrr |    0     |
									
		por			mm5, mm1		// | 0 | 0 |    S1rrrrr |    S1bbbbb |
		movq		mm6, mm2		// | 0 | 0 |    0     |D1gggggg00000|
									
		psubw		mm5, mm0		// | 0 | 0 |   S1r-D1r  |   S1b-D1b  |
		psrlw		mm2, 5			// | 0 | 0 |    0     |   D1gggggg |
									
		pmullw		mm5, CA			// | 0 | 0 |    CA1r    |    CA1b    |
		psubw		mm4, mm0		// | 0 | 0 |   D1r*31   |   D1b*31   |
									
		paddw		mm4, RBConst	// | 0 | 0 |   CA1r+c   |   CA1b+c   |
		psrlw		mm3, 5			// | 0 | 0 |    0     |   S1gggggg |
									
		psubw		mm3, mm2		// | 0 | 0 |    0     |   S1g-D1g  |
		add			esi, 2			// pSrc++;
									
		pmullw		mm3, CA			// | 0 | 0 |    0     |    CA1g    |
		paddw		mm4, mm5		// RBtmp1 = Alpha(RBSrc - RBDst) + 16 + (RBDst * 31)
									
		psllw		mm6, 1			// | 0 | 0 |    0     |D1gggggg000000|
									
		psubw		mm6, mm2		// | 0 | 0 |    0     |   D1g*63   |
		add			edi, 2			// pDst++;
									
		paddw		mm6, GConst		// | 0 | 0 |    0     |   CA1g+c   |
		movq		mm1, mm4		// RBtmp1 = Alpha(RBSrc - RBDst) + 16 + (RBDst * 31)
									
		psllw		mm3, 1			// | 0 | 0 |    0     |   CA1g*2   |
									
		pand		mm4, RBMask		// RBtmp2 = RBtmp1 AND 3E0h (mask off low 5 bits)
		paddw		mm6, mm3		// Gtmp1 = Alpha(GSrc - GDst) + 32 + (GDst * 63)
									
		movq		mm5, mm6		// Gtmp1 = Alpha(GSrc - GDst) + 32 + (GDst * 63)
		psrlw		mm4, 5			// RBtmp2 = RBtmp2 shr 5 (move high 5 bits to low 5 bits)

		pand		mm6, GreenMask	// Gtmp2 = Gtmp1 AND FC0h (mask off low 6 bits)
		paddw		mm1, mm4		// RBtmp2 = RBtmp2 + RBtmp1

		pand		mm1, RBMask		// RBtmp2 = RBtmp2 AND 3E0h (mask off low 5 bits)
		psrlw		mm6, 6			// Gtmp2 = Gtmp2 shr 6 (move high 6 bits to low 6 bits)

		paddw		mm5, mm6		// Gtmp2 = Gtmp2 + Gtmp1
		psrlw		mm1, 5			// RBtmp2 = RBtmp2 shr 5 (move high 5 bits to low 5 bits)

		pand		mm5, GreenMask	// Gtmp2 = Gtmp2 AND FC0h (mask off low 6 bits)
		movq		mm4, mm1		// RBtmp2 = RBtmp2 shr 5 (move high 5 bits to low 5 bits)

		pand		mm4, RMask		// Mask to get red
		psrlw		mm5, 1			// Align the green

		pand		mm1, BMask		// Mask to get blue
		psllw		mm4, 3			// Align the red

		por			mm4, mm1		// Combine reds and blues in proper bit location

		packuswb	mm4, mm7		// | 0 | 0 | D1rrrrr000 | D1000bbbbb |

		por			mm4, mm5		// | 0 | 0 | D1rrrrrggg | D1gggbbbbb |

		movd		edx, mm4

		mov			[edi-2], dx

		test		ecx, ecx
		jz			Done			// just processed the last pixel of the row
		dec			ecx
		jmp			QuadAligned		// just processed the first pixel of the row

	Done:
		emms						// remove for optimizations, have calling function do emms
	}
}

/**************************************************************************
  THIS FUNCTION DOES NOT DO ANY PARAMETER VALIDATION

  This function operates on 24 bit pixels (8 bits each for Red, Green, and Blue) in a row of a bitmap.
  It blends source and destination bitmaps, without alpha channels, using a constant alpha input.
  The function performs the following on each byte:

  tmp1 = Alpha(Src - Dst) + 128 + (Dst * 127)

  tmp2 = tmp1 AND FF00h (mask off low byte)
  tmp2 = tmp2 shr 8 (move high byte to low byte)
  tmp2 = tmp2 + tmp1
  tmp2 = tmp2 AND FF00h (mask off low byte)
  tmp2 = tmp2 shr 8 (move high byte to low byte)
  Dst = tmp2

  pDst is assumed to be aligned to a DWORD boundary when passed to this function.
  The loop structure is as follows:
  Step 1:
	Multiply width in pixels by 3 to get width in bytes.  Byte count is kept in ecx and eax.
	ecx is used as the loop counter.
  Step 2:
	Check pDst for QWORD alignment.  If aligned, do Step 3.  If unaligned, test to see if there
	are at least 4 bytes to do...if yes, do four bytes at once (Do1DWORD:) and then do Step 3.
	If no, there are only 3 bytes to do; so do them one at a time (OneToThreeBytesLeft:).
  Step 3:
  (QuadAligned:)
	pDst is QWORD aligned.  We want to do 8 bytes (1 quad) at once, so divide byte count by 8 to get loop
	count.  If ecx is 0 at this point, there are no more quads to do; so do 0 to 7 bytes (NoQuadsLeft:),
	in Step 5.
  Step 4:
  (Do1QUAD:)
	Perform the above function, using MMX instructions, on 8 bytes per pass of the loop.
  Step 5:
  (NoQuadsLeft:)
	Mask eax with 7 to get the byte count modulo 8, 0 to 7 bytes left.  Copy eax into ecx.  Test to see
	if there are at least 4 bytes to do...if yes, do four bytes at once (Do1DWORD:); if no, there are
	only 3 bytes to do, so do them one at a time (OneToThreeBytesLeft:).
  Step 6:
  (Do1DWORD:)
	Perform the above function, using MMX instructions, on 4 bytes.  Do Step 3 (QuadAligned:) to see if
	there are more bytes to do.
  Step 7:
  (OneToThreeBytesLeft:)
	Do one byte at a time.  This will happen if there are less than 4 bytes left to do.
**************************************************************************/
VOID
mmxPixelBlend24(
    PALPHAPIX    pDst,
    PALPHAPIX    pSrc,
    LONG        Width,
    BLENDFUNCTION BlendFunction,
    PBYTE        pwrMask
    )
{
	static QWORD WordConst = 0x0080008000800080;
	static QWORD WordMask = 0xFF00FF00FF00FF00;
	static QWORD ByteConst = 0x0000000000000080;
	static QWORD ByteMask = 0x000000000000FF00;
	static QWORD CA;	// ConstAlpha in 4 words of a qword
    BYTE        ConstAlpha = BlendFunction.SourceConstantAlpha;
	
	_asm
	{
		mov			ecx, Width		// Make sure there is at least one pixel to do
		test		ecx, ecx
		jz			Done

		mov			esi, pSrc
		mov			edi, pDst

		xor			eax, eax
		mov			al, ConstAlpha
		movd		mm5, eax		// |		   |		   |		   |		CA |
		punpcklwd	mm5, mm5		// |		   |		   |		CA |		CA |
		punpcklwd	mm5, mm5		// |		CA |		CA |		CA |		CA |
		movq		CA, mm5

									// Step 1:
		lea			ecx, [2*ecx+ecx]// NumPixels * 3 bytes/pixel = NumBytes

									// Step 2:
		test		edi, 7			// Test first pixel for QWORD alignment
		jz			QuadAligned		// If unaligned,

		cmp			ecx, 4			//	test to see if there are 4 bytes to do
		jae			Do1DWORD		//	if yes, do 4 bytes
		jmp			OneToThreeBytesLeft// if no, do 1 to 3 bytes

	QuadAligned:					// Step 3:
		mov			eax, ecx		// Save the width in eax for later (see NoQuadsLeft:)
		shr			ecx, 3			// Want to do 8 bytes at once, so divide 
									//		byte count by 8 to get loop count
		test		ecx, ecx		// Make sure there is at least 1 QUAD (8 bytes) to do
		jz			NoQuadsLeft		// If we take this jump, there are 0 to 7 bytes left

	Do1QUAD:						// Step 4:
									// Instructions will pair as shown for the Pentium processor
		movq		mm0, [edi]		// | D8 | D7 | D6 | D5 | D4 | D3 | D2 | D1 |
		pxor		mm7, mm7							
														
		movq		mm1, [esi]		// | S8 | S7 | S6 | S5 | S4 | S3 | S2 | S1 |
		movq		mm2, mm0		// | D8 | D7 | D6 | D5 | D4 | D3 | D2 | D1 |
														
		movq		mm3, mm1		// | S8 | S7 | S6 | S5 | S4 | S3 | S2 | S1 |
		punpcklbw	mm0, mm7		// |	  D4 |     D3 |     D2 |	    D1 |
													
		movq		mm4, mm0		// |	  D4 |     D3 |     D2 |	    D1 |
		punpcklbw	mm1, mm7		// |	  S4 |     S3 |     S2 |	    S1 |
													
		punpckhbw	mm2, mm7		// |	  D8 |     D7 |     D6 |	    D5 |
		psubw		mm1, mm0		// |   S4-D4 |   S3-D3 |   S2-D2 |   S1-D1 |
													
		pmullw		mm1, CA			// |   CA4   |   CA3   |   CA2   |   CA1   |
		punpckhbw	mm3, mm7		// |	  S8 |     S7 |     S6 |	    S5 |
													
		psubw		mm3, mm2		// |   S8-D8 |   S7-D7 |   S6-D6 |   S5-D5 |
		movq		mm6, mm2		// |	  D8 |     D7 |     D6 |	    D5 |
													
		pmullw		mm3, CA			// |   CA8   |   CA7   |   CA6   |   CA5   |
		psllw		mm4, 8			// | D4*128  | D3*128  | D2*128  | D1*128  |
													
		psllw		mm6, 8			// | D8*128  | D7*128  | D6*128  | D5*128  |
		psubw		mm4, mm0		// | D4*127  | D3*127  | D2*127  | D1*127  |

		paddw		mm4, WordConst	// | D4*127+C| D3*127+C| D2*127+C| D1*127+C|
		psubw		mm6, mm2		// | D8*127  | D7*127  | D6*127  | D5*127  |

		paddw		mm6, WordConst	// | D8*127+C| D7*127+C| D6*127+C| D5*127+C|
		paddw		mm4, mm1		// tmp1 = Alpha(Src1 - Dst1) + 128 + (Dst1 * 127)

		paddw		mm6, mm3		// tmp2 = Alpha(Src2 - Dst2) + 128 + (Dst2 * 127)
		movq		mm3, mm4		// tmp1 = Alpha(Src1 - Dst1) + 128 + (Dst1 * 127)

		pand		mm4, WordMask	// tmp3 = tmp1 AND FF00h (mask off low bytes)
		movq		mm5, mm6		// tmp2 = Alpha(Src2 - Dst2) + 128 + (Dst2 * 127)

		pand		mm6, WordMask	// tmp4 = tmp2 AND FF00h (mask off low bytes)
		psrlw		mm4, 8			// tmp3 = tmp3 shr 8 (move high byte to low byte)

		psrlw		mm6, 8			// tmp4 = tmp4 shr 8 (move high byte to low byte)
		paddw		mm4, mm3		// tmp3 = tmp3 + tmp1

		pand		mm4, WordMask	// tmp3 = tmp3 AND FF00h (mask off low bytes)
		paddw		mm6, mm5		// tmp4 = tmp4 + tmp2

		pand		mm6, WordMask	// tmp4 = tmp4 AND FF00h (mask off low bytes)
		psrlw		mm4, 8			// tmp3 = tmp3 shr 8 (move high byte to low byte)

		psrlw		mm6, 8			// tmp4 = tmp4 shr 8 (move high byte to low byte)
		add			edi, 8			//	pDst++;

		packuswb	mm4, mm6		// | D8 | D7 | D6 | D5 | D4 | D3 | D2 | D1 |
		add			esi, 8			//	pSrc++;

		movq		[edi-8], mm4

		dec			ecx
		jnz			Do1QUAD

	NoQuadsLeft:						// Step 5:
		// This tests for 0 to 7 bytes left in row - eax contains initial byte count
		and			eax, 7				// 0 to 7 bytes left to do
		jz			Done				
		cmp			eax, 4				// Test to see if there are 4 bytes to do
		mov			ecx, eax			
		jae			Do1DWORD			//	if yes, do 4 bytes
		jmp			OneToThreeBytesLeft	//  if no, do 1 to 3 bytes

									// Step 6:
	Do1DWORD:						// make as a macro if used in asm file
		movd		mm0, [edi]		// |  0 |  0 |  0 |  0 | D4 | D3 | D2 | D1 |
		pxor		mm7, mm7		
										
		movd		mm1, [esi]		// |  0 |  0 |  0 |  0 | S4 | S3 | S2 | S1 |
		punpcklbw	mm0, mm7		// |	  D4 |     D3 |     D2 |	    D1 |
									
		movq		mm4, mm0		// |	  D4 |     D3 |     D2 |	    D1 |
		punpcklbw	mm1, mm7		// |	  S4 |     S3 |     S2 |	    S1 |
									
		psllw		mm4, 8			// | D4*128 | D3*128  | D2*128  | D1*128  |
		psubw		mm1, mm0		// |  S4-D4 |  S3-D3  |  S2-D2  |  S1-D1  |
									
		pmullw		mm1, CA			// |   CA4  |   CA3   |   CA2   |   CA1   |
		psubw		mm4, mm0		// | D4*127 | D3*127  | D2*127  | D1*127  |

		paddw		mm4, WordConst	// | D4*127+C| D3*127+C| D2*127+C| D1*127+C|

		paddw		mm4, mm1		// tmp1 = Alpha(Src1 - Dst1) + 128 + (Dst1 * 127)
									
		movq		mm3, mm4		// tmp1 = Alpha(Src1 - Dst1) + 128 + (Dst1 * 127)

		pand		mm4, WordMask	// tmp2 = tmp1 AND FF00h (mask off low bytes)

		psrlw		mm4, 8			// tmp2 = tmp2 shr 8 (move high byte to low byte)
									
		paddw		mm4, mm3		// tmp2 = tmp2 + tmp1

		pand		mm4, WordMask	// tmp2 = tmp2 AND FF00h (mask off low bytes)

		psrlw		mm4, 8			// tmp2 = tmp2 shr 8 (move high byte to low byte)
		add			edi, 4			//	pDst++;

		packuswb	mm4, mm4		// | D4 | D3 | D2 | D1 | D4 | D3 | D2 | D1 |
		add			esi, 4			//	pSrc++;

		movd		[edi-4], mm4

		sub			ecx, 4			// Just did 4 bytes at the beginning or end of a scan line
		jmp			QuadAligned		// Jump to QuadAligned to determine if there are more bytes to do

	OneToThreeBytesLeft:			// Step 7:

		movzx   edx,BYTE PTR[edi]      ; edx = Dest Byte
		movzx   ebx,BYTE PTR[esi]      ; ebx = Src Byte

		movd		mm0, edx		// | 0 | 0 | 0 | 0 | 0 | 0 | 0 | Db |
		pxor		mm7, mm7		
										
		movd		mm1, ebx		// | 0 | 0 | 0 | 0 | 0 | 0 | 0 | Sb |
		movq		mm2, mm0		// | 0 | 0 | 0 | 0 | 0 | 0 | 0 | Db |
										
		psllw		mm2, 8			// | 0 | 0 | 0 | 0 | 0 | 0 | Db|  0 |
									
		psubw		mm1, mm0		// | 0 | 0 | 0 | Sb-Db |

		pmullw		mm1, CA			// | 0 | 0 | 0 | CAb   |
		psubw		mm2, mm0		// | 0 | 0 | 0 | Db*127|

		paddw		mm2, ByteConst	// | 0 | 0 | 0 |Db*127+128|

		paddw		mm1, mm2		// tmp1 = Alpha(Src1 - Dst1) + 128 + (Dst1 * 127)

		movq		mm2, mm1		// tmp1 = Alpha(Src1 - Dst1) + 128 + (Dst1 * 127)

		pand		mm2, ByteMask	// tmp2 = tmp1 AND FF00h

		psrlw		mm2, 8			// tmp2 = tmp2 shr 8

		paddw		mm2, mm1		// tmp2 = tmp2 + tmp1

		pand		mm2, ByteMask	// tmp2 = tmp2 AND FF00h

		psrlw		mm2, 8			// tmp2 = tmp2 shr 8

		movd		edx, mm2

		mov			BYTE PTR[edi], dl

		inc			edi
		inc			esi

		dec			ecx
       jnz			OneToThreeBytesLeft

	Done:
		emms						// remove for optimizations, have calling function do emms
	}
}

#endif

/******************************Public*Routine******************************\
* AlphaScanLineBlend
*
*   Blends source and destionation surfaces one scan line at a time. 
*
*   Allocate a scan line buffer for xlate of src to 32BGRA if needed.
*   Allocate a scan line buffer for xlate of dst to 32BGRA if needed.
*   Blend scan line using blend function from pAlphaDispatch
*   Write scan line back to dst (if needed)
*     
* Arguments:
*   
*   pDst         - pointer to dst surface      
*   pDstRect      - Dst output rect
*   DeltaDst      - dst scan line delat
*   pSrc         - pointer to src surface
*   DeltaSrc      - src scan line delta     
*   pptlSrc       - src offset
*   pxloSrcTo32    - xlateobj from src to 32BGR
*   pxlo32ToDst    - xlateobj from 32BGR to dst
*   palDst        - destination palette
*   palSrc        - source palette
*   pAlphaDispatch - blend data and function pointers
*
* Return Value:
*
*     ALPHA_COMPLETE:  success, written to destination
*     ALPHA_SEND_TEMP: success, must write tmp bmp to dest
*     ALPHA_FAIL:     error
*
* History:
*
*    10/14/1996 Mark Enstrom [marke]
*
\**************************************************************************/

ULONG
AlphaScanLineBlend(
    PBYTE                pDst,
    PRECTL                pDstRect,
    ULONG                DeltaDst,
    PBYTE                pSrc,
    ULONG                DeltaSrc,
    PPOINTL               pptlSrc,
    PALPHA_DISPATCH_FORMAT   pAlphaDispatch,
    PDIBINFO              pDibInfoSrc,
    PDIBINFO              pDibInfoDst
    )
{
    //
    // get two scanlines of RGBA data, blend pixels, store
    //

    LONG    cx = pDstRect->right - pDstRect->left;
    LONG    cy = pDstRect->bottom - pDstRect->top;
    LONG    ScanBufferWidth = cx * 4;
    LONG    WriteMaskSize    = cx;
    LONG    AllocationSize = 0;
    ULONG    ulSrcBytesPerPixel = pAlphaDispatch->ulSrcBitsPerPixel/8;
    ULONG    ulDstBytesPerPixel = pAlphaDispatch->ulDstBitsPerPixel/8;
    PBYTE    pjSrcTempScanBuffer = NULL;
    PBYTE    pjDstTempScanBuffer = NULL;
    PBYTE    pjAlloc = NULL;
    PBYTE    pjDstTmp;
    PBYTE    pjSrcTmp;
    PBYTE    pWriteMask;
    LONG    lRet = ALPHA_SEND_TEMP;
    
    HDC     hdc32 = NULL;
    PULONG   pulDIBSrc = NULL;

    //
    // if there is a temp dst needed, use dc allocator
    //

    if (pAlphaDispatch->pfnLoadDstAndConvert != NULL)
    {
       hdc32 = hdcAllocateScanLineDC(cx,&pulDIBSrc);

       if (hdc32 == NULL)
       {
          return(ALPHA_FAIL);
       }

       //
       // set temp scan line
       // 

       pjDstTempScanBuffer = (PBYTE)pulDIBSrc;
    }

    //
    // calculate destination starting address
    //

    if (ulDstBytesPerPixel)
    {
       pjDstTmp = pDst + ulDstBytesPerPixel * pDstRect->left + DeltaDst * pDstRect->top;
    }
    else if (pAlphaDispatch->ulDstBitsPerPixel == 1)
    {
       pjDstTmp = pDst + pDstRect->left/8 + DeltaDst * pDstRect->top;
    }
    else
    {
       pjDstTmp = pDst + pDstRect->left/2 + DeltaDst * pDstRect->top;
    }

    //
    // calculate source starting address
    //

    if (ulSrcBytesPerPixel)
    {
       pjSrcTmp = pSrc + ulSrcBytesPerPixel * pptlSrc->x + DeltaSrc * pptlSrc->y;
    }
    else if (pAlphaDispatch->ulSrcBitsPerPixel == 1)
    {
       pjSrcTmp = pSrc + pptlSrc->x/8 + DeltaSrc * pptlSrc->y;
    }
    else
    {
       pjSrcTmp = pSrc + pptlSrc->x/2 + DeltaSrc * pptlSrc->y;
    }

    //
    // calculate size of needed scan line buffer
    //

    if (pAlphaDispatch->pfnLoadSrcAndConvert != NULL)
    {
       AllocationSize += ScanBufferWidth;
    }

    AllocationSize += WriteMaskSize;

    //
    // allocate scan line buffer memory
    //

    pWriteMask = (PBYTE)LOCALALLOC(AllocationSize);

    if (pWriteMask != NULL)
    {
       //
       // calc offsets
       //
    
       PBYTE pjTemp = pWriteMask + WriteMaskSize;
    
       if (pAlphaDispatch->pfnLoadSrcAndConvert != NULL)
       {
          pjSrcTempScanBuffer = pjTemp;
          pjTemp    += ScanBufferWidth;
    
       }
    
       //
       // Blend scan lines
       //
    
       LONG yScan = 0;
    
       while (cy--)
       {
          PBYTE pjSource = pjSrcTmp;
          PBYTE pjDest   = pjDstTmp;
    
          //
          // get src scan line if needed
          //
    
          if (pjSrcTempScanBuffer)
          {
             (*pAlphaDispatch->pfnLoadSrcAndConvert)(
                             (PULONG)pjSrcTempScanBuffer,
                             pjSrcTmp,
                             0,
                             cx,
                             (PVOID)pDibInfoSrc);
    
             pjSource = pjSrcTempScanBuffer;
          }
    
          //
          // get dst scan line if needed
          //
    
          if (pjDstTempScanBuffer)
          {
             (*pAlphaDispatch->pfnLoadDstAndConvert)(
                             (PULONG)pjDstTempScanBuffer,
                             pjDstTmp,
                             0,
                             cx,
                             (PVOID)pDibInfoDst);
    
             pjDest = pjDstTempScanBuffer;
          }
    
          //
          // blend
          //
    
          memset(pWriteMask,1,WriteMaskSize);
    
          (*pAlphaDispatch->pfnGeneralBlend)(
                            (PALPHAPIX)pjDest,
                            (PALPHAPIX)pjSource,
                            cx,
                            pAlphaDispatch->BlendFunction,
                            pWriteMask
                            );
    
          //
          // write buffer back if needed
          //
    
          if (pjDstTempScanBuffer)
          {
             (*pAlphaDispatch->pfnConvertAndStore)(
                             pjDstTmp,
                             (PULONG)pjDstTempScanBuffer,
                             cx,
                             0,
                             yScan,
                             (PVOID)pDibInfoDst,
                             pWriteMask,
                             hdc32
                             );
          }
    
          pjDstTmp += DeltaDst;
          pjSrcTmp += DeltaSrc;
          yScan++;
       }
    
       //
       // free any temp buffer memory
       //
    
       LOCALFREE(pWriteMask);
    }
    else
    {
       lRet = ALPHA_FAIL;
    }

    if (hdc32)
    {
       vFreeScanLineDC(hdc32);
    }

    if (
        (lRet != ALPHA_FAIL) &&
        (pAlphaDispatch->pfnConvertAndStore == vConvertAndSaveBGRAToDest)
      )
    {
       lRet = ALPHA_COMPLETE;
    }

    return(lRet);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\image\fix.h ===
/******************************Module*Header*******************************\
* Module Name: fix.h
*
* Copyright (c) 1997-1999 Microsoft Corporation
\**************************************************************************/

#if (_WIN32_WINNT == 0x400)
#define STAMP_DESIGNVECTOR  (0x8000000 + 'd' + ('v' << 8))
#define STAMP_AXESLIST      (0x8000000 + 'a' + ('l' << 8))
#define MM_MAX_NUMAXES      16



typedef struct tagDESIGNVECTOR
{
    DWORD  dvReserved;
    DWORD  dvNumAxes;
    LONG   dvValues[MM_MAX_NUMAXES];
} DESIGNVECTOR, *PDESIGNVECTOR, FAR *LPDESIGNVECTOR;
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\image\dllinit.cxx ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name

   dllinit.cxx

Abstract:



Author:

   Mark Enstrom   (marke)  23-Jun-1996

Enviornment:

   User Mode

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

INT                gbCheckHandleLevel = 0;
OSVERSIONINFO    Win32VersionInformation;

HMODULE ghddrawlib = 0;
BOOL gbddraw = FALSE;

PFNTRANSBLT gpfnTransparentBlt;
PFNGRFILL   gpfnGradientFill;
PFNALPHABLEND gpfnAlphaBlend;
PFN_GETSURFACEFROMDC pfnGetSurfaceFromDC=NULL;

extern "C" {
BOOLEAN
DllInitialize(
    PVOID pvDllHandle,
    ULONG ulReason,
    PCONTEXT pcontext
    );
}


/*++

Routine Description:



Arguments



Return Value



--*/


BOOLEAN
DllInitialize(
    PVOID pvDllHandle,
    ULONG ulReason,
    PCONTEXT pcontext)
{
    NTSTATUS status = 0;
    INT i;
    BOOLEAN  fServer;
    PTEB pteb = NtCurrentTeb();
    BOOLEAN bRet = TRUE;
    HMODULE hlib;

    switch (ulReason)
    {
    case DLL_PROCESS_ATTACH:

        //
        // We don't want to get DLL_THREAD_ATTACH and DLL_THREAD_DETACH messages
        //

        DisableThreadLibraryCalls ((HMODULE) pvDllHandle);

        //
        // determine os version
        //

        Win32VersionInformation.dwOSVersionInfoSize = sizeof(Win32VersionInformation);

        if (!GetVersionEx(&Win32VersionInformation))
        {
            //
            // default win95
            //

            Win32VersionInformation.dwPlatformId = VER_PLATFORM_WIN32_WINDOWS;
        }

        //
        // resolve API enrty points
        //

        #if !(_WIN32_WINNT >= 0x500)

            hlib=LoadLibrary (TEXT("gdi32.dll"));

            gpfnTransparentBlt = (PFNTRANSBLT)GetProcAddress (hlib, "GdiTransparentBlt");
            if (!gpfnTransparentBlt)
            {
                gpfnTransparentBlt = WinTransparentBlt;
            }

            gpfnGradientFill = (PFNGRFILL)GetProcAddress (hlib, "GdiGradientFill");
            if (!gpfnGradientFill)
            {
                gpfnGradientFill = WinGradientFill;
            }

            gpfnAlphaBlend = (PFNALPHABLEND)GetProcAddress (hlib, "GdiAlphaBlend");
            if (!gpfnAlphaBlend)
            {
                gpfnAlphaBlend = WinAlphaBlend;
            }

            FreeLibrary(hlib);

            //
            // Is this an MMX processor
            //

            #if defined(_X86_)
               gbMMX = bIsMMXProcessor();
            #endif

            //
            // alpha blending init
            //

            bInitAlpha();


        ghddrawlib = GetModuleHandleA("ddraw");

        if (ghddrawlib)
        {
           Dprintf("GetModuleHandleA succeed\n");

           //
           // ddraw is already loaded, increment the reference count
           // so it won't get released while we are using it
           //
           ghddrawlib = LoadLibrary (TEXT("ddraw.dll"));

           Dprintf("LoadLibrary returns %x", ghddrawlib);

           if (ghddrawlib)
           {
               gbddraw = TRUE;

               pfnGetSurfaceFromDC = (PFN_GETSURFACEFROMDC)GetProcAddress(
                                            ghddrawlib, "GetSurfaceFromDC");
           }

        }

        #else
            gpfnTransparentBlt = GdiTransparentBlt;
            gpfnGradientFill = GdiGradientFill;
            gpfnAlphaBlend = GdiAlphaBlend;
        #endif

        #if 0
            gpfnAlphaBlend = WinAlphaBlend;
            gpfnGradientFill = WinGradientFill;
            gpfnTransparentBlt = WinTransparentBlt;
        #endif
        
        break;

    case DLL_THREAD_ATTACH:
        break;

    case DLL_PROCESS_DETACH:
#if !(_WIN32_WINNT >= 0x500)
        CleanupGlobals();
#endif
        if (ghddrawlib)
        {
            FreeLibrary(ghddrawlib);
        }
        break;

    case DLL_THREAD_DETACH:
        break;
    }

    return(bRet);

    pcontext;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\image\gradrect.cxx ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name

   trimesh.cxx

Abstract:

    Implement triangle mesh API

Author:

   Mark Enstrom   (marke)  23-Jun-1996

Enviornment:

   User Mode

Revision History:

--*/


#include "precomp.hxx"
#include "dciman.h"
#pragma hdrstop

#if !(_WIN32_WINNT >= 0x500)

VOID
ImgFillMemoryULONG(
    PBYTE pDst,
    ULONG cxBytes,
    ULONG ulPat
    )
{
    PULONG pulDst = (PULONG)pDst;
    PULONG pulEnd = (PULONG)(pDst + ((cxBytes / 4)*4));
    while (pulDst != pulEnd)
    {
        *pulDst = ulPat;
        pulDst++;
    }
}

/**************************************************************************\
*
*   Dither information for 8bpp. This is customized for dithering to
*   the halftone palette [6,6,6] color cube.
*
* History:
*
*    2/24/1997 Mark Enstrom [marke]
*
\**************************************************************************/

BYTE gDitherMatrix16x16Halftone[256] = {
  3, 28,  9, 35,  4, 30, 11, 36,  3, 29, 10, 35,  5, 30, 11, 37,
 41, 16, 48, 22, 43, 17, 49, 24, 42, 16, 48, 22, 43, 18, 50, 24,
  6, 32,  0, 25,  8, 33,  1, 27,  6, 32,  0, 26,  8, 34,  2, 27,
 44, 19, 38, 12, 46, 20, 40, 14, 45, 19, 38, 13, 46, 21, 40, 14,
  5, 31, 12, 37,  4, 29, 10, 36,  6, 31, 12, 38,  4, 30, 10, 36,
 44, 18, 50, 24, 42, 16, 48, 23, 44, 18, 50, 25, 42, 17, 49, 23,
  8, 34,  2, 28,  7, 32,  0, 26,  9, 34,  2, 28,  7, 33,  1, 26,
 47, 21, 40, 15, 45, 20, 39, 13, 47, 22, 41, 15, 46, 20, 39, 14,
  3, 29,  9, 35,  5, 30, 11, 37,  3, 28,  9, 35,  4, 30, 11, 36,
 41, 16, 48, 22, 43, 17, 49, 24, 41, 15, 47, 22, 43, 17, 49, 23,
  6, 32,  0, 25,  8, 33,  1, 27,  6, 31,  0, 25,  7, 33,  1, 27,
 45, 19, 38, 13, 46, 21, 40, 14, 44, 19, 38, 12, 46, 20, 39, 14,
  5, 31, 12, 37,  4, 29, 10, 36,  5, 31, 11, 37,  3, 29, 10, 35,
 44, 18, 50, 25, 42, 17, 49, 23, 43, 18, 50, 24, 42, 16, 48, 23,
  9, 34,  2, 28,  7, 33,  1, 26,  8, 34,  2, 27,  7, 32,  0, 26,
 47, 21, 41, 15, 45, 20, 39, 13, 47, 21, 40, 15, 45, 19, 39, 13
 };

BYTE gDitherMatrix16x16Default[256] = {
    8, 72, 24, 88, 12, 76, 28, 92,  9, 73, 25, 89, 13, 77, 29, 93,
  104, 40,120, 56,108, 44,124, 60,105, 41,121, 57,109, 45,125, 61,
   16, 80,  0, 64, 20, 84,  4, 68, 17, 81,  1, 65, 21, 85,  5, 69,
  112, 48, 96, 32,116, 52,100, 36,113, 49, 97, 33,117, 53,101, 37,
   14, 78, 30, 94, 10, 74, 26, 90, 15, 79, 31, 95, 11, 75, 27, 91,
  110, 46,126, 62,106, 42,122, 58,111, 47,126, 63,107, 43,123, 59,
   22, 86,  6, 70, 18, 82,  2, 66, 23, 87,  7, 71, 19, 83,  3, 67,
  118, 54,102, 38,114, 50, 98, 34,119, 55,103, 39,115, 51, 99, 35,
    9, 73, 25, 89, 13, 77, 29, 93,  8, 72, 24, 88, 12, 76, 28, 92,
  105, 41,121, 57,109, 45,125, 61,104, 40,120, 56,108, 44,124, 60,
   17, 81,  1, 65, 21, 85,  5, 69, 16, 80,  0, 64, 20, 84,  4, 68,
  113, 49, 97, 33,117, 53,101, 37,112, 48, 96, 32,116, 52,100, 36,
   15, 79, 31, 95, 11, 75, 27, 91, 14, 78, 30, 94, 10, 74, 26, 90,
  111, 47,126, 63,107, 43,123, 59,110, 46,126, 62,106, 42,122, 58,
   23, 87,  7, 71, 19, 83,  3, 67, 22, 86,  6, 70, 18, 82,  2, 66,
  119, 55,103, 39,115, 51, 99, 35,118, 54,102, 38,114, 50, 98, 34
  };

/**************************************************************************\
* HalftoneSaturationTable
*
*   This table maps a 8 bit pixel plus a dither error term in the range
*   of 0 to 51 onto a 8 bit pixel. Overflow of up to 31 is considered
*   saturated (255+51 = 255). The level 51 (0x33) is used to map pixels
*   and error values to the halftone palette
*
* DefaultSaturationTable
*
*   map to default colors (0,128,255) (does not use "magic" colors)
*
* IdentitySaturationTable
*
*   prevent overflow
*
* History:
*
*    3/4/1997 Mark Enstrom [marke]
*
\**************************************************************************/

BYTE HalftoneSaturationTable[256 + 128] = {
   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
   0,  0,  0, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51,
  51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51,
  51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51,
  51, 51, 51, 51, 51, 51,102,102,102,102,102,102,102,102,102,102,
 102,102,102,102,102,102,102,102,102,102,102,102,102,102,102,102,
 102,102,102,102,102,102,102,102,102,102,102,102,102,102,102,102,
 102,102,102,102,102,102,102,102,102,153,153,153,153,153,153,153,
 153,153,153,153,153,153,153,153,153,153,153,153,153,153,153,153,
 153,153,153,153,153,153,153,153,153,153,153,153,153,153,153,153,
 153,153,153,153,153,153,153,153,153,153,153,153,204,204,204,204,
 204,204,204,204,204,204,204,204,204,204,204,204,204,204,204,204,
 204,204,204,204,204,204,204,204,204,204,204,204,204,204,204,204,
 204,204,204,204,204,204,204,204,204,204,204,204,204,204,204,255,
 255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
 255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
 255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
 255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
 255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
 255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
 255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
 255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255
};

BYTE DefaultSaturationTable[256 + 128] = {
   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,
 128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,
 128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,
 128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,
 128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,
 128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,
 128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,
 128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,255,
 255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
 255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
 255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
 255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
 255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
 255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
 255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
 255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255
};

BYTE Saturation16_5[64] = {
    0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,
    0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x1e,0x1f,
    0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    };

BYTE Saturation16_6[128] = {
    0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,
    0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x1e,0x1f,
    0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x28,0x29,0x2a,0x2b,0x2c,0x2d,0x2e,0x2f,
    0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,
    0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,
    0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    };


/**************************************************************************\
*   gulDither32 - 4-4 dither matrix
*
*
* History:
*
*    1/31/1997 Mark Enstrom [marke]
*
\**************************************************************************/

ULONG gulDither32[] =
{
    0x00000000,
    0x00008000,
    0x00002000,
    0x0000a000,

    0x0000c000,
    0x00004000,
    0x0000e000,
    0x00006000,

    0x00003000,
    0x0000b000,
    0x00001000,
    0x00009000,

    0x0000f000,
    0x00007000,
    0x0000d000,
    0x00005000
};

//*******************************************************************************
//  
//
//
//
//  Triangel drawing routines
//
//
//
//
//
//*******************************************************************************

/******************************Public*Routine******************************\
* vFillTriDIBUnreadable
*
*   If a surface can't be read, draw triangle to a scan line, then call
*   BitBlt on each scan line. BitBlt is called to take advantage of
*   cached 32bpp to 8bpp lookup table (memphis)
*
* Arguments:
*
*   pDibInfo - surface information
*   ptData   - triangle information
*
* Return Value:
*
*   none
*
* History:
*
*    11/21/1996 Mark Enstrom [marke]
*
\**************************************************************************/


VOID
vFillTriDIBUnreadable(
    PDIBINFO      pDibInfo,
    PTRIANGLEDATA ptData
    )
{
    LONG     lDelta = pDibInfo->stride;
    LONG     yScan  = ptData->y0;
    LONG     yScanBottom;
    LONG     cxClip = ptData->rcl.right - ptData->rcl.left;
    PTRIEDGE pEdge  = &ptData->TriEdge[0];

    LONGLONG lldRdX = ptData->lldRdX; 
    LONGLONG lldGdX = ptData->lldGdX; 
    LONGLONG lldBdX = ptData->lldBdX; 

    COLOR_INTERP clrRed,clrGreen,clrBlue,clrAlpha;

    PBYTE    pDst = NULL;
    HDC      hdc32;
    PBYTE    pDitherMatrix    = gDitherMatrix16x16Halftone;
    PBYTE    pSaturationTable = HalftoneSaturationTable;
    LONG     yDitherOrg = ptData->ptDitherOrg.y;
    LONG     xDitherOrg = ptData->ptDitherOrg.x;

    BOOL    b1bpp = (pDibInfo->pbmi->bmiHeader.biBitCount == 1);

    //
    // WINBUG #365339 4-10-2001 jasonha Investigate using default dither table
    // Old Comment:
    //   - should use default dither table for 8bpp w/o
    //     halftone palette
    //

    if (
         (pDibInfo->pbmi->bmiHeader.biBitCount == 4) ||
         (b1bpp)
       )
    {
        pDitherMatrix    = gDitherMatrix16x16Default;
        pSaturationTable = DefaultSaturationTable;
    }

    //
    // allocate temp storage
    //

    hdc32 = hdcAllocateScanLineDC(cxClip,(PULONG *)&pDst);

    if (hdc32 == NULL)
    {
        return;
    }

    yScanBottom = MIN(ptData->rcl.bottom,ptData->y1);

    while(yScan < yScanBottom)
    {
        PULONG pulDstX;
        LONG   xScanRight;
        LONG   xScanLeft;

        clrRed.ullColor   = pEdge->llRed;
        clrGreen.ullColor = pEdge->llGreen;
        clrBlue.ullColor  = pEdge->llBlue;

        PBYTE pDitherLevel = &pDitherMatrix[(16 * ((yScan+yDitherOrg) & DITHER_8_MASK_Y))];

        xScanLeft  = MAX(pEdge->xLeft,ptData->rcl.left);
        xScanRight = MIN(pEdge->xRight,ptData->rcl.right);

        if (xScanLeft < xScanRight)
        {
            pulDstX           = (PULONG)pDst + xScanLeft  - ptData->rcl.left;
            LONG xScan = xScanLeft;

            //
            // skip span from left edge scan to left edge clip rect
            //

            LONG GradientLeft = ptData->rcl.left - pEdge->xLeft;

            if (GradientLeft > 0)
            {
                clrRed.ullColor   += lldRdX * GradientLeft;
                clrGreen.ullColor += lldGdX * GradientLeft;
                clrBlue.ullColor  += lldBdX * GradientLeft;
            }

            //
            // fill span within clipping boundary
            //

            while (xScan < xScanRight)
            {
                BYTE jDitherMatrix = *(pDitherLevel + ((xScan + xDitherOrg) & DITHER_8_MASK_X));

                ULONG iRed   = clrRed.b[7];
                ULONG iGreen = clrGreen.b[7]; 
                ULONG iBlue  = clrBlue.b[7]; 

                if (b1bpp)
                {
                    jDitherMatrix *= 2;

                    iRed   = iRed   + jDitherMatrix;

                    if (iRed >= 255)
                    {
                        iRed = 255;
                    }
                    else
                    {
                        iRed = 0;
                    }

                    iGreen = iGreen + jDitherMatrix;

                    if (iGreen >= 255)
                    {
                        iGreen = 255;
                    }
                    else
                    {
                        iGreen = 0;
                    }

                    iBlue  = iBlue  + jDitherMatrix;

                    if (iBlue >= 255)
                    {
                        iBlue = 255;
                    }
                    else
                    {
                        iBlue = 0;
                    }
                }
                else
                {
                    iRed   = pSaturationTable[iRed   + jDitherMatrix];
                    iGreen = pSaturationTable[iGreen + jDitherMatrix];
                    iBlue  = pSaturationTable[iBlue  + jDitherMatrix];
                }

                *pulDstX = (iRed   << 16) |
                           (iGreen <<  8) |
                           (iBlue       );

                pulDstX++;
                xScan++;
                clrRed.ullColor   += lldRdX;
                clrGreen.ullColor += lldGdX;
                clrBlue.ullColor  += lldBdX;
            }

            //
            // write span to device
            //

            BitBlt(pDibInfo->hdc,
                   xScanLeft,
                   yScan,
                   xScanRight-xScanLeft,
                   1,
                   hdc32,
                   xScanLeft  - ptData->rcl.left,
                   0,
                   SRCCOPY);
        }

        pEdge++;
        yScan++;
    }

    if (hdc32 != NULL)
    {
        vFreeScanLineDC(hdc32);
    }
}

/******************************Public*Routine******************************\
* vFillTriDIB32BGRA
*
*
* Arguments:
*
*   pDibInfo - surface information
*   ptData   - triangle information
*
* Return Value:
*
*
*
* History:
*
*    11/21/1996 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vFillTriDIB32BGRA(
    PDIBINFO      pDibInfo,
    PTRIANGLEDATA ptData
    )
{
    LONG     lDelta = pDibInfo->stride;
    LONG     yScan  = ptData->y0;
    LONG     yScanBottom;
    PBYTE    pDst   = (PBYTE)pDibInfo->pvBase + lDelta * yScan;
    PTRIEDGE pEdge  = &ptData->TriEdge[0];
    LONGLONG lldRdX = ptData->lldRdX; 
    LONGLONG lldGdX = ptData->lldGdX; 
    LONGLONG lldBdX = ptData->lldBdX; 
    LONGLONG lldAdX = ptData->lldAdX; 
    COLOR_INTERP clrRed,clrGreen,clrBlue,clrAlpha;

    yScanBottom = MIN(ptData->rcl.bottom,ptData->y1);

    while(yScan < yScanBottom)
    {
        PULONG pulDstX;
        PULONG pulDstScanRight,pulDstScanLeft;

        clrRed.ullColor   = pEdge->llRed;
        clrGreen.ullColor = pEdge->llGreen;
        clrBlue.ullColor  = pEdge->llBlue;
        clrAlpha.ullColor = pEdge->llAlpha;

        LONG xScanLeft  = MAX(pEdge->xLeft,ptData->rcl.left);
        LONG xScanRight = MIN(pEdge->xRight,ptData->rcl.right);

        if (xScanLeft < xScanRight)
        {
            pulDstX         = (PULONG)pDst + xScanLeft;
            pulDstScanRight = (PULONG)pDst + xScanRight;

            //
            // skip pixels from left edge to left clip, while
            // incrementing gradient
            //

            LONG GradientLeft = ptData->rcl.left - pEdge->xLeft;

            if (GradientLeft > 0)
            {
                clrRed.ullColor   += lldRdX * GradientLeft;
                clrGreen.ullColor += lldGdX * GradientLeft;
                clrBlue.ullColor  += lldBdX * GradientLeft;
                clrAlpha.ullColor += lldAdX * GradientLeft;
            }

            //
            // fill span
            //

            while (pulDstX < pulDstScanRight)
            {
                *pulDstX = (clrAlpha.b[7] << 24) |
                           (clrRed.b[7]   << 16) |
                           (clrGreen.b[7] << 8)  |
                           (clrBlue.b[7]);

                pulDstX++;

                clrRed.ullColor   += lldRdX;
                clrGreen.ullColor += lldGdX;
                clrBlue.ullColor  += lldBdX;
                clrAlpha.ullColor += lldAdX;
            }
        }

        pDst += lDelta;
        pEdge++;
        yScan++;
    }
}

/******************************Public*Routine******************************\
* vFillTriDIB32RGB
*
*
* Arguments:
*
*   pDibInfo - surface information
*   ptData   - triangle information
*
* Return Value:
*
*
*
* History:
*
*    11/21/1996 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vFillTriDIB32RGB(
    PDIBINFO      pDibInfo,
    PTRIANGLEDATA ptData
    )
{
    LONG     lDelta = pDibInfo->stride;
    LONG     yScan  = ptData->y0;
    LONG     yScanBottom;
    PBYTE    pDst   = (PBYTE)pDibInfo->pvBase + lDelta * yScan;
    PTRIEDGE pEdge  = &ptData->TriEdge[0];

    LONGLONG lldRdX = ptData->lldRdX; 
    LONGLONG lldGdX = ptData->lldGdX; 
    LONGLONG lldBdX = ptData->lldBdX; 

    COLOR_INTERP clrRed,clrGreen,clrBlue;

    yScanBottom = MIN(ptData->rcl.bottom,ptData->y1);

    while(yScan < yScanBottom)
    {
        PULONG pulDstX;
        PULONG pulDstScanRight,pulDstScanLeft;

        clrRed.ullColor   = pEdge->llRed;
        clrGreen.ullColor = pEdge->llGreen;
        clrBlue.ullColor  = pEdge->llBlue;

        LONG xScanLeft  = MAX(pEdge->xLeft,ptData->rcl.left);
        LONG xScanRight = MIN(pEdge->xRight,ptData->rcl.right);

        if (xScanLeft < xScanRight)
        {
            pulDstX           = (PULONG)pDst + xScanLeft;
            pulDstScanRight   = (PULONG)pDst + xScanRight;
    
            //
            // skip pixels from left edge to left clip, while
            // incrementing gradient
            //

            LONG GradientLeft = ptData->rcl.left - pEdge->xLeft;

            if (GradientLeft > 0)
            {
                clrRed.ullColor   += lldRdX * GradientLeft;
                clrGreen.ullColor += lldGdX * GradientLeft;
                clrBlue.ullColor  += lldBdX * GradientLeft;
            }
    
            //
            // fill span
            //
    
            while (pulDstX < pulDstScanRight)
            {
                *pulDstX = 
                           (clrBlue.b[7]  << 16) |
                           (clrGreen.b[7] << 8)  |
                           (clrRed.b[7]);

                pulDstX++;
                clrRed.ullColor   += lldRdX;
                clrGreen.ullColor += lldGdX;
                clrBlue.ullColor  += lldBdX;
            }
        }

        pDst += lDelta;
        pEdge++;
        yScan++;
    }
}

/******************************Public*Routine******************************\
* vFillTriDIB24RGB
*
*
* Arguments:
*
*   pDibInfo - surface information
*   ptData   - triangle information
*
* Return Value:
*
*
*
* History:
*
*    11/21/1996 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vFillTriDIB24RGB(
    PDIBINFO      pDibInfo,
    PTRIANGLEDATA ptData
    )
{
    LONG     lDelta = pDibInfo->stride;
    LONG     yScan  = ptData->y0;
    LONG     yScanBottom;
    PBYTE    pDst   = (PBYTE)pDibInfo->pvBase + lDelta * yScan;
    PTRIEDGE pEdge  = &ptData->TriEdge[0];
    LONGLONG lldRdX = ptData->lldRdX; 
    LONGLONG lldGdX = ptData->lldGdX; 
    LONGLONG lldBdX = ptData->lldBdX; 

    COLOR_INTERP clrRed,clrGreen,clrBlue;

    yScanBottom = MIN(ptData->rcl.bottom,ptData->y1);

    while(yScan < yScanBottom)
    {
        PBYTE pDstX;
        PBYTE pDstScanRight;

        clrRed.ullColor   = pEdge->llRed;
        clrGreen.ullColor = pEdge->llGreen;
        clrBlue.ullColor  = pEdge->llBlue;

        LONG xScanLeft  = MAX(pEdge->xLeft,ptData->rcl.left);
        LONG xScanRight = MIN(pEdge->xRight,ptData->rcl.right);

        if (xScanLeft < xScanRight)
        {
            pDstX             = pDst + 3 * xScanLeft;
            pDstScanRight     = pDst + 3 * xScanRight;
    
            //
            // skip pixels from left edge to left clip, while
            // incrementing gradient
            //

            LONG GradientLeft = ptData->rcl.left - pEdge->xLeft;

            if (GradientLeft > 0)
            {
                clrRed.ullColor   += lldRdX * GradientLeft;
                clrGreen.ullColor += lldGdX * GradientLeft;
                clrBlue.ullColor  += lldBdX * GradientLeft;
            }

            while (pDstX < pDstScanRight)
            {
                *pDstX     = clrBlue.b[7];
                *(pDstX+1) = clrGreen.b[7];
                *(pDstX+2) = clrRed.b[7];

                clrRed.ullColor   += lldRdX;
                clrGreen.ullColor += lldGdX;
                clrBlue.ullColor  += lldBdX;

                pDstX+=3;
            }
        }

        pDst += lDelta;
        pEdge++;
        yScan++;
    }
}

/******************************Public*Routine******************************\
* vFillDIB16_565
*
*
* Arguments:
*
*   pDibInfo - surface information
*   ptData   - triangle information
*
* Return Value:
*
*
*
* History:
*
*    11/21/1996 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vFillTriDIB16_565(
    PDIBINFO      pDibInfo,
    PTRIANGLEDATA ptData
    )
{
    LONG     lDelta = pDibInfo->stride;
    LONG     yScan  = ptData->y0;
    LONG     yScanBottom;
    PBYTE    pDst   = (PBYTE)pDibInfo->pvBase + lDelta * yScan;
    PTRIEDGE pEdge  = &ptData->TriEdge[0];
    LONGLONG lldRdX = ptData->lldRdX; 
    LONGLONG lldGdX = ptData->lldGdX; 
    LONGLONG lldBdX = ptData->lldBdX; 

    COLOR_INTERP clrRed,clrGreen,clrBlue;

    yScanBottom = MIN(ptData->rcl.bottom,ptData->y1);

    LONG    yDitherOrg = ptData->ptDitherOrg.y;
    LONG    xDitherOrg = ptData->ptDitherOrg.x;

    while(yScan < yScanBottom)
    {
        PUSHORT pusDstX,pusDstScanRight;
        PULONG pulDither = &gulDither32[0] + 4 * ((yScan+yDitherOrg) & 3);

        clrRed.ullColor   = pEdge->llRed;
        clrGreen.ullColor = pEdge->llGreen;
        clrBlue.ullColor  = pEdge->llBlue;

        LONG xScanRight = MIN(pEdge->xRight,ptData->rcl.right);
        LONG xScanLeft  = MAX(pEdge->xLeft,ptData->rcl.left);

        if (xScanLeft < xScanRight)
        {
            pusDstX         = (PUSHORT)pDst + xScanLeft;
            pusDstScanRight = (PUSHORT)pDst + xScanRight;
    
            //
            // skip pixels from left edge to left clip, while
            // incrementing gradient
            //

            LONG GradientLeft = ptData->rcl.left - pEdge->xLeft;

            if (GradientLeft > 0)
            {
                clrRed.ullColor   += lldRdX * GradientLeft;
                clrGreen.ullColor += lldGdX * GradientLeft;
                clrBlue.ullColor  += lldBdX * GradientLeft;
            }
    
            //
            // Gradient fill scan line with dither
            //

            while (pusDstX < pusDstScanRight)
            {
                ULONG   ulDither = pulDither[(xScanLeft + xDitherOrg) & 3];

                ULONG   iRed   = Saturation16_5[((clrRed.ul[1]   >> (8+3)) + ulDither) >> 16];
                ULONG   iGreen = Saturation16_6[((clrGreen.ul[1] >> (8+2)) + ulDither) >> 16];
                ULONG   iBlue  = Saturation16_5[((clrBlue.ul[1]  >> (8+3)) + ulDither) >> 16];
    
                *pusDstX = rgb565(iRed,iGreen,iBlue);
    
                xScanLeft++;
                pusDstX++;

                clrRed.ullColor   += lldRdX;
                clrGreen.ullColor += lldGdX;
                clrBlue.ullColor  += lldBdX;
            }
        }

        pDst += lDelta;
        pEdge++;
        yScan++;
    }
}

/******************************Public*Routine******************************\
* vFillTriDIB16_555
*
*
* Arguments:
*
*   pDibInfo - surface information
*   ptData   - triangle information
*
* Return Value:
*
*
*
* History:
*
*    11/21/1996 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vFillTriDIB16_555(
    PDIBINFO      pDibInfo,
    PTRIANGLEDATA ptData
    )
{
    LONG     lDelta = pDibInfo->stride;
    LONG     yScan  = ptData->y0;
    LONG     yScanBottom;
    PBYTE    pDst   = (PBYTE)pDibInfo->pvBase + lDelta * yScan;
    PTRIEDGE pEdge  = &ptData->TriEdge[0];
    LONGLONG lldRdX = ptData->lldRdX; 
    LONGLONG lldGdX = ptData->lldGdX; 
    LONGLONG lldBdX = ptData->lldBdX; 

    COLOR_INTERP clrRed,clrGreen,clrBlue;

    yScanBottom = MIN(ptData->rcl.bottom,ptData->y1);

    LONG    yDitherOrg = ptData->ptDitherOrg.y;
    LONG    xDitherOrg = ptData->ptDitherOrg.x;

    while(yScan < yScanBottom)
    {
        PUSHORT pusDstX,pusDstScanRight;

        PULONG  pulDither = &gulDither32[0] + 4 * ((yScan+yDitherOrg) & 3);

        clrRed.ullColor   = pEdge->llRed;
        clrGreen.ullColor = pEdge->llGreen;
        clrBlue.ullColor  = pEdge->llBlue;

        LONG xScanRight = MIN(pEdge->xRight,ptData->rcl.right);
        LONG xScanLeft  = MAX(pEdge->xLeft,ptData->rcl.left);

        if (xScanLeft < xScanRight)
        {
            pusDstX         = (PUSHORT)pDst + xScanLeft;
            pusDstScanRight = (PUSHORT)pDst + xScanRight;
    
            //
            // skip pixels from left edge to left clip, while
            // incrementing gradient
            //

            LONG GradientLeft = ptData->rcl.left - pEdge->xLeft;

            if (GradientLeft > 0)
            {
                clrRed.ullColor   += lldRdX * GradientLeft;
                clrGreen.ullColor += lldGdX * GradientLeft;
                clrBlue.ullColor  += lldBdX * GradientLeft;
            }
    
            //
            // Gradient fill scan line with dither
            //

            while (pusDstX < pusDstScanRight)
            {
                ULONG   ulDither = pulDither[(xScanLeft + xDitherOrg) & 3];
    
                ULONG   iRed   = Saturation16_5[((clrRed.ul[1]   >> (8+3)) + ulDither) >> 16];
                ULONG   iGreen = Saturation16_5[((clrGreen.ul[1] >> (8+3)) + ulDither) >> 16];
                ULONG   iBlue  = Saturation16_5[((clrBlue.ul[1]  >> (8+3)) + ulDither) >> 16];

                *pusDstX = rgb555(iRed,iGreen,iBlue);
    
                xScanLeft++;
                pusDstX++;

                clrRed.ullColor   += lldRdX;
                clrGreen.ullColor += lldGdX;
                clrBlue.ullColor  += lldBdX;
            }
        }

        pDst += lDelta;
        pEdge++;
        yScan++;
    }
}

//*******************************************************************************
//  
//
//
//
//  Rectangle drawing routines
//
//
//
//
//
//*******************************************************************************

/******************************Public*Routine******************************\
* vFillGRectDIB32BGRA
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    11/21/1996 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vFillGRectDIB32BGRA(
    PDIBINFO          pDibInfo,
    PGRADIENTRECTDATA pgData
    )
{
    LONG    lDelta = pDibInfo->stride;
    LONG    cyClip = pgData->szDraw.cy;

    //
    // fill rect with gradient fill. if this is horizontal mode then
    // draw one scan line and replicate in v, if this is vertical mode then 
    // draw one vertical stripe and replicate in h
    //

    COLOR_INTERP clrR,clrG,clrB,clrA;

    if (pgData->ulMode == GRADIENT_FILL_RECT_H)
    {
        PBYTE    pjDst   = (PBYTE)pDibInfo->pvBase + lDelta * pgData->ptDraw.y;
        PULONG   pulBuffer = (PULONG)LOCALALLOC(4 * pgData->szDraw.cx);

        if (pulBuffer)
        {
            clrR.ullColor = pgData->llRed;
            clrG.ullColor = pgData->llGreen;
            clrB.ullColor = pgData->llBlue;
            clrA.ullColor = pgData->llAlpha;

            LONGLONG lldRdX   = pgData->lldRdX;
            LONGLONG lldGdX   = pgData->lldGdX;
            LONGLONG lldBdX   = pgData->lldBdX;
            LONGLONG lldAdX   = pgData->lldAdX;
    
            //
            // adjust gradient fill for clipped portion
            //
    
            if (pgData->xScanAdjust > 0)
            {
                clrR.ullColor += lldRdX * (pgData->xScanAdjust); 
                clrG.ullColor += lldGdX * (pgData->xScanAdjust);  
                clrB.ullColor += lldBdX * (pgData->xScanAdjust);  
                clrA.ullColor += lldAdX * (pgData->xScanAdjust);  
            }
    
            //
            // draw 1 scan line 
            //
    
            PULONG pulDstX  =  pulBuffer;
            PULONG pulEndX  =  pulDstX + pgData->szDraw.cx;
    
            while (pulDstX != pulEndX)
            {
                *pulDstX = (ULONG)(((clrA.b[6]) << 24) |
                                   ((clrR.b[6]) << 16) |
                                   ((clrG.b[6]) << 8)  |
                                   ((clrB.b[6])));
    
                clrR.ullColor += lldRdX;
                clrG.ullColor += lldGdX;
                clrB.ullColor += lldBdX;
                clrA.ullColor += lldAdX;
    
                pulDstX++;
            }
    
            //
            // replicate
            //
    
            PULONG pulDstY = (PULONG)pjDst + pgData->ptDraw.x;
            PULONG pulEndY = (PULONG)((PBYTE)pulDstY + lDelta * cyClip);
    
            while (pulDstY != pulEndY)
            {
                memcpy(pulDstY,pulBuffer,4*pgData->szDraw.cx);
                pulDstY = (PULONG)((PBYTE)pulDstY + lDelta);
            }

            LOCALFREE(pulBuffer);
        }
    }
    else
    {
        clrR.ullColor = pgData->llRed;
        clrG.ullColor = pgData->llGreen;
        clrB.ullColor = pgData->llBlue;
        clrA.ullColor = pgData->llAlpha;

        LONGLONG lldRdY = pgData->lldRdY;
        LONGLONG lldGdY = pgData->lldGdY;
        LONGLONG lldBdY = pgData->lldBdY;
        LONGLONG lldAdY = pgData->lldAdY;

        //
        // vertical gradient. 
        // replicate each x value accross whole scan line
        //

        if (pgData->yScanAdjust > 0)
        {
            clrR.ullColor += lldRdY * (pgData->yScanAdjust); 
            clrG.ullColor += lldGdY * (pgData->yScanAdjust);  
            clrB.ullColor += lldBdY * (pgData->yScanAdjust);  
            clrA.ullColor += lldAdY * (pgData->yScanAdjust);  
        }

        PBYTE    pDst   = (PBYTE)pDibInfo->pvBase + lDelta * pgData->ptDraw.y;

        pDst = pDst + 4 * pgData->ptDraw.x;

        while (cyClip--)
        {
            ULONG ul = (ULONG)(((clrA.b[6]) << 24) |
                               ((clrR.b[6]) << 16) |
                               ((clrG.b[6]) << 8)  |
                               ((clrB.b[6])));

            ImgFillMemoryULONG(pDst,pgData->szDraw.cx*4,ul);

            clrR.ullColor += lldRdY;
            clrG.ullColor += lldGdY;
            clrB.ullColor += lldBdY;
            clrA.ullColor += lldAdY;

            pDst += lDelta;
        }
    }
}

/******************************Public*Routine******************************\
* vFillGRectDIB32RGB
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    11/21/1996 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vFillGRectDIB32RGB(
    PDIBINFO          pDibInfo,
    PGRADIENTRECTDATA pgData
    )
{
    LONG    lDelta = pDibInfo->stride;
    LONG    cyClip = pgData->szDraw.cy;

    //
    // fill rect with gradient fill. if this is horizontal mode then
    // draw one scan line and replicate in v, if this is vertical mode then 
    // draw one vertical stripe and replicate in h
    //

    COLOR_INTERP clrR,clrG,clrB,clrA;

    clrR.ullColor = pgData->llRed;
    clrG.ullColor = pgData->llGreen;
    clrB.ullColor = pgData->llBlue;

    if (pgData->ulMode == GRADIENT_FILL_RECT_H)
    {
        PBYTE    pjDst   = (PBYTE)pDibInfo->pvBase + lDelta * pgData->ptDraw.y;
        PULONG   pulBuffer = (PULONG)LOCALALLOC(4 * pgData->szDraw.cx);

        if (pulBuffer)
        {
            LONGLONG lldRed   = pgData->lldRdX;
            LONGLONG lldGreen = pgData->lldGdX;
            LONGLONG lldBlue  = pgData->lldBdX;
    
            //
            // adjust gradient fill for clipped portion
            //
    
            if (pgData->xScanAdjust > 0)
            {
                clrR.ullColor += lldRed   * (pgData->xScanAdjust); 
                clrG.ullColor += lldGreen * (pgData->xScanAdjust);  
                clrB.ullColor += lldBlue  * (pgData->xScanAdjust);  
            }
    
            //
            // draw 1 scan line to temp buffer
            //
    
            PULONG pulDstX  =  pulBuffer;
            PULONG pulEndX  =  pulDstX + pgData->szDraw.cx;
    
            while (pulDstX != pulEndX)
            {
                *pulDstX = (ULONG)(
                           ((clrR.b[6]))        |
                           ((clrG.b[6]) << 8) |
                           ((clrB.b[6]) << 16));
    
                clrR.ullColor += lldRed;
                clrG.ullColor += lldGreen;
                clrB.ullColor += lldBlue;
    
                pulDstX++;
            }
    
            //
            // replicate
            //
    
            PULONG pulDstY = (PULONG)pjDst + pgData->ptDraw.x;
            PULONG pulEndY = (PULONG)((PBYTE)pulDstY + lDelta * cyClip);
    
            while (pulDstY != pulEndY)
            {
                memcpy(pulDstY,pulBuffer,4*pgData->szDraw.cx);
                pulDstY = (PULONG)((PBYTE)pulDstY + lDelta);
            }
    
            LOCALFREE(pulBuffer);
        }
    }
    else
    {
        LONGLONG     lldRed   = pgData->lldRdY;
        LONGLONG     lldGreen = pgData->lldGdY;
        LONGLONG     lldBlue  = pgData->lldBdY;

        //
        // vertical gradient. 
        // replicate each x value accross whole scan line
        //

        if (pgData->yScanAdjust > 0)
        {
            clrR.ullColor +=  lldRed   * (pgData->yScanAdjust); 
            clrG.ullColor +=  lldGreen * (pgData->yScanAdjust);  
            clrB.ullColor +=  lldBlue  * (pgData->yScanAdjust);  
        }

        PBYTE    pDst   = (PBYTE)pDibInfo->pvBase + lDelta * pgData->ptDraw.y;

        pDst = pDst + 4 * pgData->ptDraw.x;

        while (cyClip--)
        {
            ULONG ul = (ULONG)(
                       ((clrR.b[6])      ) |
                       ((clrG.b[6])  << 8) |
                       ((clrB.b[6]) << 16));

            ImgFillMemoryULONG(pDst,pgData->szDraw.cx*4,ul);

            clrR.ullColor += lldRed;
            clrG.ullColor += lldGreen;
            clrB.ullColor += lldBlue;

            pDst += lDelta;
        }
    }

}

/******************************Public*Routine******************************\
* vFillGRectDIB24RGB
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    11/21/1996 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vFillGRectDIB24RGB(
    PDIBINFO          pDibInfo,
    PGRADIENTRECTDATA pgData
    )
{
    LONG    lDelta = pDibInfo->stride;
    LONG    cyClip = pgData->szDraw.cy;
        PBYTE    pDst   = (PBYTE)pDibInfo->pvBase + lDelta * pgData->ptDraw.y;

    COLOR_INTERP clrR,clrG,clrB,clrAlpha;

    clrR.ullColor = pgData->llRed;
    clrG.ullColor = pgData->llGreen;
    clrB.ullColor = pgData->llBlue;

    //
    // fill rect with gradient fill. if this is horizontal mode then
    // draw one scan line and replicate in v, if this is vertical mode then 
    // draw one vertical stripe and replicate in h
    //

    if (pgData->ulMode == GRADIENT_FILL_RECT_H)
    {

        LONGLONG lldRed   = pgData->lldRdX;
        LONGLONG lldGreen = pgData->lldGdX;
        LONGLONG lldBlue  = pgData->lldBdX;

        //
        // adjust gradient fill for clipped portion
        //

        if (pgData->xScanAdjust > 0)
        {
            clrR.ullColor += lldRed   * (pgData->xScanAdjust); 
            clrG.ullColor += lldGreen * (pgData->xScanAdjust);  
            clrB.ullColor += lldBlue  * (pgData->xScanAdjust);  
        }

        PBYTE  pBuffer = (PBYTE)LOCALALLOC(3 * pgData->szDraw.cx);

        if (pBuffer)
        {
            if (pBuffer)
            {
                PBYTE  pDstX  =  pBuffer;
                PBYTE  pLast  =  pDstX + 3 * pgData->szDraw.cx;
        
                while (pDstX != pLast)
                {
                    *pDstX     =  (clrB.b[6]);
                    *(pDstX+1) =  (clrG.b[6]);
                    *(pDstX+2) =  (clrR.b[6]);
        
                    clrR.ullColor += lldRed;
                    clrG.ullColor += lldGreen;
                    clrB.ullColor += lldBlue;
        
                    pDstX+=3;
                }
        
                //
                // Replicate the scan line. It would be much better to write the scan line
                // out to a memory buffer for drawing to a device surface
                //
    
                PBYTE  pDst   = (PBYTE)pDibInfo->pvBase +
                                            lDelta * pgData->ptDraw.y +
                                            3 * pgData->ptDraw.x;

        
                while (cyClip--)
                {
                    memcpy(pDst,pBuffer,3*pgData->szDraw.cx);
                    pDst += lDelta;
                }
    
                LOCALFREE(pBuffer);
            }
        }
    }
    else
    {
        //
        // vertical gradient. 
        // replicate each x value accross whole scan line
        //

        PBYTE    pDst   = (PBYTE)pDibInfo->pvBase + lDelta * pgData->ptDraw.y;

        LONGLONG lldRed   = pgData->lldRdY;
        LONGLONG lldGreen = pgData->lldGdY;
        LONGLONG lldBlue  = pgData->lldBdY;

        //
        // vertical gradient. 
        // replicate each x value accross whole scan line
        //

        if (pgData->yScanAdjust > 0)
        {
            clrR.ullColor +=  lldRed   * (pgData->yScanAdjust); 
            clrG.ullColor +=  lldGreen * (pgData->yScanAdjust);  
            clrB.ullColor +=  lldBlue  * (pgData->yScanAdjust);  
        }

        pDst = pDst + 3 * pgData->ptDraw.x;

        while (cyClip--)
        {
            //
            // fill scan line with solid color
            //

            PBYTE pTemp  = pDst;
            PBYTE pEnd   = pDst + 3 * pgData->szDraw.cx;
            
            while (pTemp != pEnd)
            {
                *pTemp     = clrB.b[6];
                *(pTemp+1) = clrG.b[6];
                *(pTemp+2) = clrR.b[6];
                pTemp+=3;
            }

            //
            // increment colors for next scan line
            //

            clrR.ullColor += lldRed;
            clrG.ullColor += lldGreen;
            clrB.ullColor += lldBlue;

            //
            // inc pointer to next scan line
            // 

            pDst += lDelta;
        }
    }
}

/******************************Public*Routine******************************\
* vFillGRectDIB16_565
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    11/21/1996 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vFillGRectDIB16_565(
    PDIBINFO          pDibInfo,
    PGRADIENTRECTDATA pgData
    )
{
    LONG     lDelta = pDibInfo->stride;
    LONG     cxClip = pgData->szDraw.cx;

    LONG     yScan       = pgData->ptDraw.y;
    LONG     yScanBottom = yScan + pgData->szDraw.cy;

    PBYTE    pDst   = (PBYTE)pDibInfo->pvBase + lDelta * pgData->ptDraw.y;

    LONGLONG lldxRed   = pgData->lldRdX;
    LONGLONG lldxGreen = pgData->lldGdX;
    LONGLONG lldxBlue  = pgData->lldBdX;
            
    LONGLONG lldyRed   = pgData->lldRdY;
    LONGLONG lldyGreen = pgData->lldGdY;
    LONGLONG lldyBlue  = pgData->lldBdY;

    //
    // lleRed,Green,Blue keep track of color gradient
    // in y. This may be repeated each scan line for different
    // dither values.  PERF could allocate temp scan line
    // buffer, run gradient 1 time and dither from this source
    //

    ULONGLONG lleRed;
    ULONGLONG lleGreen;
    ULONGLONG lleBlue;

    lleRed   = pgData->llRed;  
    lleGreen = pgData->llGreen;
    lleBlue  = pgData->llBlue; 

    PULONG   pulDither;

    //
    // skip down to left edge
    //

    if (pgData->yScanAdjust)
    {
        lleRed   += lldyRed   * (pgData->yScanAdjust); 
        lleGreen += lldyGreen * (pgData->yScanAdjust); 
        lleBlue  += lldyBlue  * (pgData->yScanAdjust); 
    }

    LONG    yDitherOrg = pgData->ptDitherOrg.y;
    LONG    xDitherOrg = pgData->ptDitherOrg.x;

    while(yScan < yScanBottom)
    {
        PUSHORT pusDstX;
        PUSHORT pusDstScanRight,pusDstScanLeft;
        LONG    xScan;
        COLOR_INTERP clrR,clrG,clrB,clrAlpha;

        pulDither = &gulDither32[0] + 4 * ((yScan + yDitherOrg) & 3);


        clrR.ullColor = lleRed;
        clrG.ullColor = lleGreen;
        clrB.ullColor = lleBlue;

        if (pgData->xScanAdjust)
        {
            clrR.ullColor += lldxRed   * (pgData->xScanAdjust); 
            clrG.ullColor += lldxGreen * (pgData->xScanAdjust); 
            clrB.ullColor += lldxBlue  * (pgData->xScanAdjust); 
        }

        xScan           = pgData->ptDraw.x + xDitherOrg;
        pusDstX         = (PUSHORT)pDst + pgData->ptDraw.x;
        pusDstScanRight = pusDstX + pgData->szDraw.cx;

        while (pusDstX < pusDstScanRight)
        {
            ULONG   ulDither = pulDither[xScan & 3];

            ULONG   iRed   = Saturation16_5[((clrR.ul[1] >> (3)) + ulDither) >> 16];
            ULONG   iGreen = Saturation16_6[((clrG.ul[1] >> (2)) + ulDither) >> 16];
            ULONG   iBlue  = Saturation16_5[((clrB.ul[1] >> (3)) + ulDither) >> 16];

            *pusDstX = rgb565(iRed,iGreen,iBlue);

            pusDstX++;
            xScan++;

            clrR.ullColor += lldxRed;
            clrG.ullColor += lldxGreen;
            clrB.ullColor += lldxBlue;
        }

        lleRed   += lldyRed;
        lleGreen += lldyGreen;
        lleBlue  += lldyBlue;

        yScan++;

        pDst += lDelta;
    }
}

/******************************Public*Routine******************************\
* vFillGRectDIB16_555
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    11/21/1996 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vFillGRectDIB16_555(
    PDIBINFO          pDibInfo,
    PGRADIENTRECTDATA pgData
    )
{
    LONG     lDelta = pDibInfo->stride;
    LONG     cxClip = pgData->szDraw.cx;

    LONG     yScan       = pgData->ptDraw.y;
    LONG     yScanBottom = yScan + pgData->szDraw.cy;

    PBYTE    pDst   = (PBYTE)pDibInfo->pvBase + lDelta * pgData->ptDraw.y;

    LONGLONG     lldxRed   = pgData->lldRdX;
    LONGLONG     lldxGreen = pgData->lldGdX;
    LONGLONG     lldxBlue  = pgData->lldBdX;
            
    LONGLONG     lldyRed   = pgData->lldRdY;
    LONGLONG     lldyGreen = pgData->lldGdY;
    LONGLONG     lldyBlue  = pgData->lldBdY;

    //
    // lleRed,Green,Blue keep track of color gradient
    // in y. This may be repeated each scan line for different
    // dither values.   PERF could allocate temp scan line
    // buffer, run gradient 1 time and dither from this source
    //

    ULONGLONG    lleRed;
    ULONGLONG    lleGreen;
    ULONGLONG    lleBlue;

    PULONG   pulDither;

    //
    // skip down to left edge
    //

    lleRed   = pgData->llRed;  
    lleGreen = pgData->llGreen;
    lleBlue  = pgData->llBlue; 

    if (pgData->yScanAdjust)
    {
        lleRed   += lldyRed   * (pgData->yScanAdjust); 
        lleGreen += lldyGreen * (pgData->yScanAdjust); 
        lleBlue  += lldyBlue  * (pgData->yScanAdjust); 
    }

    LONG    yDitherOrg = pgData->ptDitherOrg.y;

    while(yScan < yScanBottom)
    {
        PUSHORT   pusDstX;
        PUSHORT   pusDstScanRight,pusDstScanLeft;

        COLOR_INTERP clrR,clrG,clrB,clrAlpha;

        LONG      xScan;

        pulDither = &gulDither32[0] + 4 * ((yScan + yDitherOrg) & 3);

        clrR.ullColor = lleRed;
        clrG.ullColor = lleGreen;
        clrB.ullColor = lleBlue;

        if (pgData->xScanAdjust)
        {
            clrR.ullColor += lldxRed   * (pgData->xScanAdjust); 
            clrG.ullColor += lldxGreen * (pgData->xScanAdjust); 
            clrB.ullColor += lldxBlue  * (pgData->xScanAdjust); 
        }

        xScan           = pgData->ptDraw.x + pgData->ptDitherOrg.x;
        pusDstX         = (PUSHORT)pDst + pgData->ptDraw.x;
        pusDstScanRight = pusDstX + pgData->szDraw.cx;

        while (pusDstX < pusDstScanRight)
        {

            ULONG   ulDither = pulDither[xScan & 3];

            ULONG   iRed   = Saturation16_5[((clrR.ul[1] >> (3)) + ulDither) >> 16];
            ULONG   iGreen = Saturation16_5[((clrG.ul[1] >> (3)) + ulDither) >> 16];
            ULONG   iBlue  = Saturation16_5[((clrB.ul[1] >> (3)) + ulDither) >> 16];

            *pusDstX = rgb555(iRed,iGreen,iBlue);

            pusDstX++;
            xScan++;

            clrR.ullColor += lldxRed;
            clrG.ullColor += lldxGreen;
            clrB.ullColor += lldxBlue;
        }

        lleRed   += lldyRed;
        lleGreen += lldyGreen;
        lleBlue  += lldyBlue;

        yScan  ++;
        pDst   += lDelta;
    }
}

/******************************Public*Routine******************************\
* vFillGRectDIB32Direct
*
*   This routine draws in dithered 32 bpp and is used to diplay on 8,4,1
*   surfaces
*
* Arguments:
*
*   pDibInfo    -   surface information
*   pgData      -   gradient rectange information
*
* Return Value:
*   
*   none
*
* History:
*
*    11/21/1996 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vFillGRectDIB32Direct(
    PDIBINFO          pDibInfo,
    PGRADIENTRECTDATA pgData
    )
{
    LONG    lDelta = pDibInfo->stride;

    LONG    yScan       = pgData->ptDraw.y;
    LONG    yScanBottom = yScan + pgData->szDraw.cy;

    PULONG  pulDst;
    HDC     hdc32;

    LONGLONG     lldxRed   = pgData->lldRdX;
    LONGLONG     lldxGreen = pgData->lldGdX;
    LONGLONG     lldxBlue  = pgData->lldBdX;

    LONGLONG     lldyRed   = pgData->lldRdY;
    LONGLONG     lldyGreen = pgData->lldGdY;
    LONGLONG     lldyBlue  = pgData->lldBdY;

    //
    // lleRed,Green,Blue keep track of color gradient
    // in y. This may be repeated each scan line for different
    // dither values.  PERF could allocate temp scan line
    // buffer, run gradient 1 time and dither from this source
    //

    ULONGLONG    lleRed;
    ULONGLONG    lleGreen;
    ULONGLONG    lleBlue;

    PBYTE   pDitherMatrix    = gDitherMatrix16x16Halftone; 
    PBYTE   pSaturationTable = HalftoneSaturationTable;

    BOOL    b1bpp = (pDibInfo->pbmi->bmiHeader.biBitCount == 1);

    // WINBUG #365339 4-10-2001 jasonha Investigate using default dither table
    //
    // Old Comment:
    //  - should use default dither table for 8bpp w/o
    //    halftone palette
    //

    if (
         (pDibInfo->pbmi->bmiHeader.biBitCount == 4) ||
         (b1bpp)
       )
    {
        pDitherMatrix    = gDitherMatrix16x16Default;  
        pSaturationTable = DefaultSaturationTable;     
    }

    //
    // get scan line buffer with 32 bpp DC
    //

    hdc32 = hdcAllocateScanLineDC(pgData->szDraw.cx,&pulDst);

    if (hdc32 == NULL)
    {
        return;
    }

    //
    // skip down to left edge
    //

    lleRed   = pgData->llRed;   
    lleGreen = pgData->llGreen; 
    lleBlue  = pgData->llBlue;  

    if (pgData->yScanAdjust)
    {
        lleRed   += lldyRed   * (pgData->yScanAdjust); 
        lleGreen += lldyGreen * (pgData->yScanAdjust); 
        lleBlue  += lldyBlue  * (pgData->yScanAdjust); 
    }

    LONG    yDitherOrg = pgData->ptDitherOrg.y;
    LONG    xDitherOrg = pgData->ptDitherOrg.x;

    while(yScan < yScanBottom)
    {
        PULONG  pulDstX;
        LONG    xScanLeft  = pgData->ptDraw.x;
        LONG    xScan      = xScanLeft;
        LONG    xScanRight = xScanLeft + pgData->szDraw.cx;
        ULONG   Red;
        ULONG   Green;
        ULONG   Blue;

        COLOR_INTERP clrR,clrG,clrB,clrAlpha;

        clrR.ullColor = lleRed;
        clrG.ullColor = lleGreen;
        clrB.ullColor = lleBlue;

        if (pgData->xScanAdjust)
        {
            clrR.ullColor += lldxRed   * (pgData->xScanAdjust); 
            clrG.ullColor += lldxGreen * (pgData->xScanAdjust); 
            clrB.ullColor += lldxBlue  * (pgData->xScanAdjust); 
        }

        pulDstX        = pulDst + xScanLeft;

        PBYTE pDitherLevel = &pDitherMatrix[(16 * ((yScan+yDitherOrg) & DITHER_8_MASK_Y))];

        while (xScan < xScanRight)
        {
            //
            // calculate x component of dither
            //

            ULONG  iRed   = clrR.b[6];
            ULONG  iGreen = clrG.b[6]; 
            ULONG  iBlue  = clrB.b[6]; 

            BYTE jDitherMatrix = *(pDitherLevel + ((xScan + xDitherOrg) & DITHER_8_MASK_X));

            if (b1bpp)
            {
                jDitherMatrix *= 2;

                iRed   = iRed   + jDitherMatrix;

                if (iRed >= 255)
                {
                    iRed = 255;
                }
                else
                {
                    iRed = 0;
                }

                iGreen = iGreen + jDitherMatrix; 

                if (iGreen >= 255)
                {
                    iGreen = 255;
                }
                else
                {
                    iGreen = 0;
                }

                iBlue  = iBlue  + jDitherMatrix; 

                if (iBlue >= 255)
                {
                    iBlue = 255;
                }
                else
                {
                    iBlue = 0;
                }
            }
            else
            {
                iRed   = pSaturationTable[iRed   + jDitherMatrix];
                iGreen = pSaturationTable[iGreen + jDitherMatrix];
                iBlue  = pSaturationTable[iBlue  + jDitherMatrix];
            }

            *pulDstX = ((iRed << 16) | (iGreen << 8) | iBlue);

            xScan++;
            pulDstX++;
            clrR.ullColor += lldxRed;
            clrG.ullColor += lldxGreen;
            clrB.ullColor += lldxBlue;
        }

        //
        // write span to device
        //
        
        BitBlt(pDibInfo->hdc,
               xScanLeft,
               yScan,
               xScanRight-xScanLeft,
               1,
               hdc32,
               xScanLeft,
               0,
               SRCCOPY);

        //
        // add y color increment
        //

        lleRed   += lldyRed;
        lleGreen += lldyGreen;
        lleBlue  += lldyBlue;
        yScan++;
    }

    if (hdc32)
    {
        vFreeScanLineDC(hdc32);
    }
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\image\local.h ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name

   gdxlocal.h

Abstract:



Author:

   Mark Enstrom   (marke)  23-Jun-1996

Enviornment:

   User Mode

Revision History:

--*/




extern PGDI_SHARED_MEMORY pGdiSharedMemory;
extern PDEVCAPS           pGdiDevCaps;
extern PENTRY             pGdiSharedHandleTable;
extern W32PID             gW32PID;





#define HANDLE_TO_INDEX(h) (ULONG)h & 0x0000ffff
HANDLE GdiFixUpHandle(HANDLE h);

/******************************Public*Macro********************************\
*
*  PSHARED_GET_VALIDATE
*
*  Validate all handle information, return user pointer if the handle
*  is valid or NULL otherwise.
*
* Arguments:
*
*   p       - pointer to assign to pUser is successful
*   h       - handle to object
*   iType   - handle type
*
\**************************************************************************/

#define PSHARED_GET_VALIDATE(p,h,iType)                                 \
{                                                                       \
    UINT uiIndex = HANDLE_TO_INDEX(h);                                  \
    p = NULL;                                                           \
                                                                        \
    if (uiIndex < MAX_HANDLE_COUNT)                                     \
    {                                                                   \
        PENTRY pentry = &pGdiSharedHandleTable[uiIndex];                \
                                                                        \
        if (                                                            \
             (pentry->Objt == iType) &&                                 \
             (pentry->FullUnique == ((ULONG)h >> 16)) &&                \
             (pentry->ObjectOwner.Share.Pid == gW32PID)                 \
           )                                                            \
        {                                                               \
            p = pentry->pUser;                                          \
        }                                                               \
    }                                                                   \
}


#define VALIDATE_HANDLE(bRet, h,iType)                                  \
{                                                                       \
    UINT uiIndex = HANDLE_TO_INDEX(h);                                  \
    bRet = FALSE;                                                       \
                                                                        \
    if (uiIndex < MAX_HANDLE_COUNT)                                     \
    {                                                                   \
        PENTRY pentry = &pGdiSharedHandleTable[uiIndex];                \
                                                                        \
        if (                                                            \
             (pentry->Objt == iType) &&                                 \
             (pentry->FullUnique == ((ULONG)h >> 16)) &&                \
             ((pentry->ObjectOwner.Share.Pid == gW32PID) ||             \
             (pentry->ObjectOwner.Share.Pid == 0))                      \
              )                                                         \
        {                                                               \
           bRet = TRUE;                                                 \
        }                                                               \
    }                                                                   \
}

/******************************Public*Macros******************************\
* FIXUP_HANDLE(h) and FIXUP_HANDLEZ(h)
*
* check to see if the handle has been truncated.
* FIXUP_HANDLEZ() adds an extra check to allow NULL.
*
* Arguments:
*   h - handle to be checked and fix
*
* Return Value:
*
* History:
*
*    25-Jan-1996 -by- Lingyun Wang [lingyunw]
*
\**************************************************************************/



#define HANDLE_FIXUP 0

#if DBG
extern INT gbCheckHandleLevel;
#endif

#define NEEDS_FIXING(h)    (!((ULONG)h & 0xffff0000))

#if DBG
#define HANDLE_WARNING()                                                 \
{                                                                        \
        if (gbCheckHandleLevel == 1)                                     \
        {                                                                \
            WARNING ("truncated handle\n");                              \
        }                                                                \
        ASSERTGDI (gbCheckHandleLevel != 2, "truncated handle\n");       \
}
#else
#define HANDLE_WARNING()
#endif

#if DBG
#define CHECK_HANDLE_WARNING(h, bZ)                                      \
{                                                                        \
    BOOL bFIX = NEEDS_FIXING(h);                                         \
                                                                         \
    if (bZ) bFIX = h && bFIX;                                            \
                                                                         \
    if (bFIX)                                                            \
    {                                                                    \
        if (gbCheckHandleLevel == 1)                                     \
        {                                                                \
            WARNING ("truncated handle\n");                              \
        }                                                                \
        ASSERTGDI (gbCheckHandleLevel != 2, "truncated handle\n");       \
    }                                                                    \
}
#else
#define CHECK_HANDLE_WARNING(h,bZ)
#endif


#if HANDLE_FIXUP
#define FIXUP_HANDLE(h)                                 \
{                                                       \
    if (NEEDS_FIXING(h))                                \
    {                                                   \
        HANDLE_WARNING();                               \
        h = GdiFixUpHandle(h);                          \
    }                                                   \
}
#else
#define FIXUP_HANDLE(h)                                 \
{                                                       \
    CHECK_HANDLE_WARNING(h,FALSE);                      \
}
#endif

#if HANDLE_FIXUP
#define FIXUP_HANDLEZ(h)                                \
{                                                       \
    if (h && NEEDS_FIXING(h))                           \
    {                                                   \
        HANDLE_WARNING();                               \
        h = GdiFixUpHandle(h);                          \
    }                                                   \
}
#else
#define FIXUP_HANDLEZ(h)                                \
{                                                       \
    CHECK_HANDLE_WARNING(h,TRUE);                       \
}
#endif

#define FIXUP_HANDLE_NOW(h)                             \
{                                                       \
    if (NEEDS_FIXING(h))                                \
    {                                                   \
        HANDLE_WARNING();                               \
        h = GdiFixUpHandle(h);                          \
    }                                                   \
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\image\gdiext.h ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name

   gdiext.h

Abstract:

    GDI exensions for transparent blt, blending, gradient fill

Author:

   Mark Enstrom   (marke)  23-Jun-1996

Enviornment:

   User Mode

Revision History:

--*/


typedef LONG  PTFX8;
typedef USHORT COLOR16;

typedef struct _VERTEX
{
    PTFX8   x;
    PTFX8   y;
    COLOR16 Red;
    COLOR16 Green;
    COLOR16 Blue;
    COLOR16 Alpha;
}VERTEX,*PVERTEX;

BOOL
TransparentImage(
    HDC      hdcDest,
    LONG     DstX,
    LONG     DstY,
    LONG     DstCx,
    LONG     DstCy,
    HANDLE   hSrc,
    LONG     SrcX,
    LONG     SrcY,
    LONG     SrcCx,
    LONG     SrcCy
    );


BOOL
AlphaImage(
    HDC      hdcDest,
    LONG     DstX,
    LONG     DstY,
    LONG     DstCx,
    LONG     DstCy,
    HANDLE   hSrc,
    LONG     SrcX,
    LONG     SrcY,
    LONG     SrcCx,
    LONG     SrcCy,
    ULONG    fAlpha
    );

BOOL
StretchImage(
    HDC      hdcDest,
    LONG     DstX,
    LONG     DstY,
    LONG     DstCx,
    LONG     DstCy,
    HANDLE   hSrc,
    LONG     SrcX,
    LONG     SrcY,
    LONG     SrcCx,
    LONG     SrcCy
    );


BOOL
TriangleMesh(
    HDC       hdc,
    PVERTEX   pVertex,
    ULONG     nVertex,
    PULONG    pMesh,
    ULONG     nCount
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\image\sources.inc ===
MAJORCOMP=windows
MINORCOMP=msimg32

TARGETNAME=msimg32
TARGETTYPE=DYNLINK
TARGETPATH=$(ALT_PROJECT_TARGET)\$(_OBJ_DIR)

TARGETLIBS=$(SDK_LIB_PATH)\kernel32.lib                                    \
           $(WINDOWS_LIB_PATH)\w32umode.lib                                \
           $(WINDOWS_LIB_PATH)\user32p.lib                                 \
           $(WINDOWS_LIB_PATH)\gdi32p.lib                                  \
           $(NTGDI_PATH)\math\$(ALT_PROJECT)\$(O)\efloat.lib               \
           $(NTGDI_PATH)\icm\mscms\winnt\$(O)\mscms.lib                    \
           $(WINDOWS_LIB_PATH)\dciman32.lib                                \
           $(SDK_LIB_PATH)\advapi32.lib

LINKLIBS= $(WINDOWS_LIB_PATH)\w32umode.lib

!IFNDEF MSC_WARNING_LEVEL
MSC_WARNING_LEVEL=/W3
!ENDIF
MSC_WARNING_LEVEL=$(MSC_WARNING_LEVEL) /WX
DLLENTRY=DllInitialize

INCLUDES=..;                                       \
         ..\..\inc;                                \
         ..\..\client;                             \
         $(WINCORE_PATH)\w32inc;                   \
         $(MULTIMEDIA_INC_PATH);                   \
         $(DDK_INC_PATH)

C_DEFINES=$(C_DEFINES) -D_GDI32_ -DWINVER=0x0400 -DGL_METAFILE

USE_NTDLL=1

DLLDEF=..\$(TARGETNAME).def
DLLORDER=..\$(TARGETNAME).prf

SOURCES= ..\dllinit.cxx      \
         ..\alpha.cxx        \
         ..\alphaimg.cxx     \
         ..\alphatran.cxx    \
         ..\dib.cxx          \
         ..\tran.cxx         \
         ..\trimesh.cxx      \
         ..\tricalc.cxx      \
         ..\gradrect.cxx     \
         ..\gdiext.rc

PRECOMPILED_INCLUDE=..\precomp.hxx
PRECOMPILED_PCH=precomp.pch
PRECOMPILED_OBJ=precomp.obj
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\image\tran.cxx ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name


Abstract:

   Lingyun Wang

Author:


Enviornment:

   User Mode

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

extern PFNTRANSBLT gpfnTransparentBlt;

#if (_WIN32_WINNT == 0x400)
typedef struct _LOGPALETTE2
{
    USHORT PalVersion;
    USHORT PalNumEntries;
    PALETTEENTRY palPalEntry[2];
} LOGPALETTE2;

typedef struct _LOGPALETTE16
{
    USHORT PalVersion;
    USHORT PalNumEntries;
    PALETTEENTRY palPalEntry[16];
} LOGPALETTE16;

typedef struct _LOGPALETTE256
{
    USHORT PalVersion;
    USHORT PalNumEntries;
    PALETTEENTRY palPalEntry[256];
} LOGPALETTE256;

/******************************Public*Routine******************************\
* StartPixel
*    Give a scanline pointer and position of a pixel, return the byte address
* of where the pixel is at depending on the format
*
* History:
*  2-Dec-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
PBYTE StartPixel (
    PBYTE pjBits,
    ULONG xStart,
    ULONG iBitmapFormat
)
{
   PBYTE pjStart = pjBits;
    //
    // getting the starting pixel
    //
    switch (iBitmapFormat)
    {
      case 1:
          pjStart = pjBits + (xStart >> 3);
          break;

       case 4:
          pjStart = pjBits + (xStart >> 1);
          break;

       case 8:
          pjStart = pjBits + xStart;
          break;

       case 16:
          pjStart = pjBits + 2*xStart;
          break;

       case 24:
          pjStart = pjBits + 3*xStart;
          break;

       case 32:
          pjStart = pjBits+4*xStart;
          break;

       default:
           WARNING ("Startpixel -- bad iFormatSrc\n");
    }

    return (pjStart);
}


/******************************Public*Routine******************************\
* vTransparentIdentityCopy4
*
* Doing a transparent copy on two same size 4BPP format DIBs
*
* Returns:
*   VOID.
*
* History:
*  09-Dec-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
VOID vTransparentIdentityCopy4 (
     PDIBINFO pDibInfoDst,
     PDIBINFO pDibInfoSrc,
     ULONG   TransColor)
{
     PBYTE   pjDst = (PBYTE)pDibInfoDst->pvBase + pDibInfoDst->stride*pDibInfoDst->rclDIB.top
                            + (pDibInfoDst->rclDIB.left >> 1);
     PBYTE   pjSrc = (PBYTE)pDibInfoSrc->pvBase + pDibInfoSrc->stride*pDibInfoSrc->rclDIB.top
                            + (pDibInfoSrc->rclDIB.left >> 1);
     LONG    cx = pDibInfoDst->rclDIB.right - pDibInfoDst->rclDIB.left;
     LONG    cy = pDibInfoDst->rclDIB.bottom - pDibInfoDst->rclDIB.top;

     PBYTE   pjDstTemp;
     PBYTE   pjSrcTemp;
     LONG    cxTemp;

     BYTE   jSrc=0;
     BYTE   jDst=0;
     LONG   iSrc, iDst;


     while(cy--)
     {
         cxTemp = cx;

         iSrc = pDibInfoSrc->rclDIB.left;
         iDst = pDibInfoDst->rclDIB.left;

         pjSrcTemp = pjSrc;
         pjDstTemp = pjDst;

         while (cxTemp--)
         {
             if (iSrc & 0x00000001)
             {
                 jSrc = *pjSrcTemp & 0x0F;
                 pjSrcTemp++;
             }
             else
             {
                 jSrc = (*pjSrcTemp & 0xF0)>>4;
             }

             iSrc++;

             if (iDst & 0x00000001)
             {
                 if (jSrc != (BYTE)TransColor)
                 {
                     jDst |= jSrc & 0x0F;
                 }
                 else
                 {
                     jDst |= *pjDstTemp & 0x0F;
                 }

                 *pjDstTemp++ = jDst;
                 jDst = 0;
             }
             else
             {
                 if (jSrc != (BYTE)TransColor)
                 {
                     jDst |= (jSrc << 4);
                 }
                 else
                 {
                     jDst |= *pjDstTemp & 0xF0;
                 }
             }

             iDst++;
         }
         pjDst += pDibInfoDst->stride;
         pjSrc += pDibInfoSrc->stride;
     }
}

/******************************Public*Routine******************************\
* vTransparentS4D1
*
* Doing a transparent copy from 4PP to 1BPP
*
* Returns:
*   VOID.
*
* History:
*  09-Dec-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
VOID vTransparentS4D1 (
     PDIBINFO pDibInfoDst,
     PDIBINFO pDibInfoSrc,
     ULONG   TransColor)
{
     PBYTE   pjDst = (PBYTE)pDibInfoDst->pvBase + pDibInfoDst->stride*pDibInfoDst->rclDIB.top
                            + (pDibInfoDst->rclDIB.left >> 3);

     PBYTE   pjSrc = (PBYTE)pDibInfoSrc->pvBase + pDibInfoSrc->stride*pDibInfoSrc->rclDIB.top
                            + (pDibInfoSrc->rclDIB.left >> 1);
     LONG    cx = pDibInfoDst->rclDIB.right - pDibInfoDst->rclDIB.left;
     LONG    cy = pDibInfoDst->rclDIB.bottom - pDibInfoDst->rclDIB.top;
     PBYTE   pjDstTemp;
     PBYTE   pjSrcTemp;
     BYTE    jSrc, jDst;
     LONG    cxTemp;
     BYTE    rgbBlue, rgbGreen, rgbRed;
     LONG    iSrc, iDst;
     LOGPALETTE2 logPal2;
     HPALETTE    hPal;
     LONG    i;
     ULONG   rgbColor;
     BYTE    xlate[16];

     //
     // build up our xlate table
     //
     logPal2.PalVersion    = 0x300;
     logPal2.PalNumEntries = 2;

     for (i = 0; i < 2; i++)
     {
         logPal2.palPalEntry[i].peRed         = pDibInfoDst->pbmi->bmiColors[i].rgbRed;
         logPal2.palPalEntry[i].peGreen       = pDibInfoDst->pbmi->bmiColors[i].rgbGreen;
         logPal2.palPalEntry[i].peBlue        = pDibInfoDst->pbmi->bmiColors[i].rgbBlue;
         logPal2.palPalEntry[i].peFlags       = 0;
     }

     hPal = CreatePalette ((LOGPALETTE *)&logPal2);

     for (i = 0; i<16; i++)
     {
         rgbColor = RGB(pDibInfoSrc->pbmi->bmiColors[i].rgbRed, pDibInfoSrc->pbmi->bmiColors[i].rgbGreen,
                        pDibInfoSrc->pbmi->bmiColors[i].rgbBlue);

         xlate[i] = (BYTE)GetNearestPaletteIndex(hPal, rgbColor);
     }

     if (hPal) 
     {
         DeleteObject(hPal);
     }

     while(cy--)
     {
         cxTemp = cx;

         iSrc = pDibInfoSrc->rclDIB.left;
         iDst = pDibInfoDst->rclDIB.left & 0x07;

         pjDstTemp = pjDst;

         jDst = *pjDstTemp >> (8 - iDst);

         pjSrcTemp = pjSrc;

         while (cxTemp--)
         {
             if (iSrc & 0x00000001)
             {
                 jSrc = *pjSrcTemp & 0x0F;
                 pjSrcTemp++;
             }
             else
             {
                 jSrc = (*pjSrcTemp & 0xF0)>>4;
             }

             iSrc++;

             //
             // put one pixel in the dest
             //
             if (jSrc != TransColor)
             {
                jDst |= xlate[jSrc];  //0 OR 1
             }
             else
             {
                jDst |= 1-xlate[jSrc];
             }

             jDst = jDst << 1;
             iDst++;

             if (!(iDst & 0x07))
             {
                *(pjDstTemp++) = jDst;
                jDst = 0;
             }
          }

          if (iDst & 0x00000007)
          {
            // We need to build up the last pel correctly.

            BYTE jMask = (BYTE) (0x000000FF >> (iDst & 0x00000007));

            jDst = (BYTE) (jDst << (8 - (iDst & 0x00000007)));

	         *pjDstTemp = (BYTE) ((*pjDstTemp & jMask) | (jDst & ~jMask));
           }

           pjDst += pDibInfoDst->stride;
           pjSrc += pDibInfoSrc->stride;
     }
}

/******************************Public*Routine******************************\
* vTransparentS4D4
*
* Doing a transparent copy from 4PP to 4bpp non identity
*
* Returns:
*   VOID.
*
* History:
*  09-Dec-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
VOID vTransparentS4D4 (
     PDIBINFO pDibInfoDst,
     PDIBINFO pDibInfoSrc,
     ULONG   TransColor)
{
     PBYTE   pjDst = (PBYTE)pDibInfoDst->pvBase + pDibInfoDst->stride*pDibInfoDst->rclDIB.top
                            + (pDibInfoDst->rclDIB.left >> 1);
     PBYTE   pjSrc = (PBYTE)pDibInfoSrc->pvBase + pDibInfoSrc->stride*pDibInfoSrc->rclDIB.top
                            + (pDibInfoSrc->rclDIB.left >> 1);

     LONG    cx = pDibInfoDst->rclDIB.right - pDibInfoDst->rclDIB.left;
     LONG    cy = pDibInfoDst->rclDIB.bottom - pDibInfoDst->rclDIB.top;
     PBYTE   pjDstTemp;
     PBYTE   pjSrcTemp;
     BYTE    jSrc, jDst;
     BYTE    rgbBlue, rgbGreen, rgbRed;
     LONG    iSrc, iDst;
     LOGPALETTE16 logPal16;
     HPALETTE    hPal;
     LONG    i;
     ULONG   cxTemp;
     ULONG   rgbColor;
     BYTE    xlate[16];

     //
     // build up translate table
     //
     logPal16.PalVersion    = 0x300;
     logPal16.PalNumEntries = 16;

     for (i = 0; i < 16; i++)
     {
         logPal16.palPalEntry[i].peRed         = pDibInfoDst->pbmi->bmiColors[i].rgbRed;
         logPal16.palPalEntry[i].peGreen       = pDibInfoDst->pbmi->bmiColors[i].rgbGreen;
         logPal16.palPalEntry[i].peBlue        = pDibInfoDst->pbmi->bmiColors[i].rgbBlue;
         logPal16.palPalEntry[i].peFlags       = 0;
     }

     hPal = CreatePalette ((LOGPALETTE *)&logPal16);

     for (i = 0; i<16; i++)
     {
         rgbColor = RGB(pDibInfoSrc->pbmi->bmiColors[i].rgbRed, pDibInfoSrc->pbmi->bmiColors[i].rgbGreen,
                        pDibInfoSrc->pbmi->bmiColors[i].rgbBlue);

         xlate[i] = (BYTE)GetNearestPaletteIndex(hPal, rgbColor);
     }

     if (hPal) 
     {
         DeleteObject(hPal);
     }

     while(cy--)
     {
         cxTemp = cx;

         iSrc = pDibInfoSrc->rclDIB.left;
         iDst = pDibInfoDst->rclDIB.left;

         pjDstTemp = pjDst;
         pjSrcTemp = pjSrc;

         while (cxTemp--)
         {
             if (iSrc & 0x00000001)
             {
                 jSrc = *pjSrcTemp & 0x0F;
                 pjSrcTemp++;
             }
             else
             {
                 jSrc = (*pjSrcTemp & 0xF0)>>4;
             }

             iSrc++;

             if (iDst & 0x00000001)
             {
                 if (jSrc != (BYTE)TransColor)
                 {
                     jDst |= xlate[jSrc] & 0x0F;
                 }
                 else
                 {
                     jDst |= *pjDstTemp & 0x0F;
                 }

                 *pjDstTemp++ = jDst;
                 jDst = 0;
             }
             else
             {
                 if (jSrc != (BYTE)TransColor)
                 {
                     jDst |= (xlate[jSrc] << 4);
                 }
                 else
                 {
                     jDst |= *pjDstTemp & 0xF0;
                 }
             }

             iDst++;
         }

         pjDst += pDibInfoDst->stride;
         pjSrc += pDibInfoSrc->stride;
     }
}

/******************************Public*Routine******************************\
* vTransparentS4D8
*
* Doing a transparent copy from 4PP to 8bpp
*
* Returns:
*   VOID.
*
* History:
*  09-Dec-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
VOID vTransparentS4D8 (
     PDIBINFO pDibInfoDst,
     PDIBINFO pDibInfoSrc,
     ULONG   TransColor)
{
     PBYTE   pjDst = (PBYTE)pDibInfoDst->pvBase + pDibInfoDst->stride*pDibInfoDst->rclDIB.top;
                            + pDibInfoDst->rclDIB.left;
     PBYTE   pjSrc = (PBYTE)pDibInfoSrc->pvBase + pDibInfoSrc->stride*pDibInfoSrc->rclDIB.top
                            + (pDibInfoSrc->rclDIB.left >> 1);
     LONG    cx = pDibInfoDst->rclDIB.right - pDibInfoDst->rclDIB.left;
     LONG    cy = pDibInfoDst->rclDIB.bottom - pDibInfoDst->rclDIB.top;
     PBYTE   pjDstTemp;
     PBYTE   pjSrcTemp;
     BYTE    jSrc;
     LONG    cxTemp;
     BYTE    rgbBlue, rgbGreen, rgbRed;
     LONG    iSrc;
     LOGPALETTE256 logPal256;
     HPALETTE    hPal;
     LONG    i;
     ULONG   rgbColor;
     BYTE    xlate[16];

     logPal256.PalVersion    = 0x300;
     logPal256.PalNumEntries = 256;

     for (i = 0; i < 256; i++)
     {
         logPal256.palPalEntry[i].peRed         = pDibInfoDst->pbmi->bmiColors[i].rgbRed;
         logPal256.palPalEntry[i].peGreen       = pDibInfoDst->pbmi->bmiColors[i].rgbGreen;
         logPal256.palPalEntry[i].peBlue        = pDibInfoDst->pbmi->bmiColors[i].rgbBlue;
         logPal256.palPalEntry[i].peFlags       = 0;
     }

     hPal = CreatePalette ((LOGPALETTE *)&logPal256);

     for (i = 0; i<16; i++)
     {
         rgbColor = RGB(pDibInfoSrc->pbmi->bmiColors[i].rgbRed, pDibInfoSrc->pbmi->bmiColors[i].rgbGreen,
                        pDibInfoSrc->pbmi->bmiColors[i].rgbBlue);

         xlate[i] = (BYTE)GetNearestPaletteIndex(hPal, rgbColor);

         //Dprintf("i=%x, rgbColor = 0x%08x, xlate[i] = %x", i, rgbColor, xlate[i]);
     }
     
     if (hPal) 
     {
         DeleteObject(hPal);
     }

     while(cy--)
     {
         cxTemp = cx;

         iSrc = pDibInfoSrc->rclDIB.left;

         pjDstTemp = pjDst;
         pjSrcTemp = pjSrc;

         while (cxTemp--)
         {
             if (iSrc & 0x00000001)
             {
                 jSrc = *pjSrcTemp & 0x0F;
                 pjSrcTemp++;
             }
             else
             {
                 jSrc = (*pjSrcTemp & 0xF0)>>4;
             }

             iSrc++;

             if (jSrc != (BYTE)TransColor)
             {
                 *pjDstTemp = xlate[jSrc];
             }

             pjDstTemp++;
         }

         pjDst += pDibInfoDst->stride;
         pjSrc += pDibInfoSrc->stride;
     }
}

/******************************Public*Routine******************************\
* vTransparentS4D16
*
* Doing a transparent copy from 4BPP to 16BPP
*
* Returns:
*   VOID.
*
* History:
*  09-Dec-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
VOID vTransparentS4D16 (
     PDIBINFO pDibInfoDst,
     PDIBINFO pDibInfoSrc,
     ULONG   TransColor)
{
     PBYTE   pjDst = (PBYTE)pDibInfoDst->pvBase + pDibInfoDst->stride*pDibInfoDst->rclDIB.top
                            + pDibInfoDst->rclDIB.left*2;
     PBYTE   pjSrc = (PBYTE)pDibInfoSrc->pvBase + pDibInfoSrc->stride*pDibInfoSrc->rclDIB.top
                            + (pDibInfoSrc->rclDIB.left >> 1);

     LONG    cx = pDibInfoDst->rclDIB.right - pDibInfoDst->rclDIB.left;
     LONG    cy = pDibInfoDst->rclDIB.bottom - pDibInfoDst->rclDIB.top;
     PBYTE   pjDstTemp;
     PBYTE   pjSrcTemp;
     BYTE    jSrc;
     LONG    cxTemp;
     BYTE    rgbBlue, rgbGreen, rgbRed;
     LONG    iSrc, iDst;

     while(cy--)
     {
         cxTemp = cx;

         iSrc = pDibInfoSrc->rclDIB.left;
         iDst = pDibInfoDst->rclDIB.left;

         pjDstTemp = pjDst;
         pjSrcTemp = pjSrc;

         while (cxTemp--)
         {
             if (iSrc & 0x00000001)
             {
                 jSrc = *pjSrcTemp & 0x0F;
                 pjSrcTemp++;
             }
             else
             {
                 jSrc = (*pjSrcTemp & 0xF0)>>4;
             }

             iSrc++;

             if (jSrc != (BYTE)TransColor)
             {
                 rgbBlue  = pDibInfoSrc->pbmi->bmiColors[jSrc].rgbBlue;
                 rgbGreen = pDibInfoSrc->pbmi->bmiColors[jSrc].rgbGreen;
                 rgbRed   = pDibInfoSrc->pbmi->bmiColors[jSrc].rgbRed;

                 //
                 // figure out 5-5-5 or 5-6-5
                 //
                 if (pDibInfoDst->pbmi->bmiHeader.biCompression == BI_BITFIELDS)
                 {
                      //5-5-5
                      if (*(DWORD *)&pDibInfoDst->pbmi->bmiColors[1] == 0x03E0)
                      {
                          *(PUSHORT)pjDstTemp = (USHORT)rgbBlue >> 3;
                          *(PUSHORT)pjDstTemp |= (USHORT)(rgbGreen >> 3) << 5;
                          *(PUSHORT)pjDstTemp |= (USHORT)(rgbRed >> 3) << 10;
                      }
                      // 5-6-5
                      else if (*(DWORD *)&pDibInfoDst->pbmi->bmiColors[1] == 0x07E0)
                      {
                          *(PUSHORT)pjDstTemp = (USHORT)rgbBlue >> 3;
                          *(PUSHORT)pjDstTemp |= (USHORT)(rgbGreen >> 2) << 5;
                          *(PUSHORT)pjDstTemp |= (USHORT)(rgbRed >> 3) << 11;
                      }
                      else
                      {
                          WARNING ("unsupported BITFIELDS\n");
                      }
                 }
                 else
                 {
                       *(PUSHORT)pjDstTemp = (USHORT)rgbBlue >> 3;
                       *(PUSHORT)pjDstTemp |= (USHORT)(rgbGreen >> 3) << 5;
                       *(PUSHORT)pjDstTemp |= (USHORT)(rgbRed >> 3) << 10;
                 }
             }

             pjDstTemp += 2;
         }

         pjDst += pDibInfoDst->stride;
         pjSrc += pDibInfoSrc->stride;
     }
}

/******************************Public*Routine******************************\
* vTransparentS4D24
*
* Doing a transparent copy from 4BPP to 24BPP
*
* Returns:
*   VOID.
*
* History:
*  09-Dec-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
VOID vTransparentS4D24 (
     PDIBINFO pDibInfoDst,
     PDIBINFO pDibInfoSrc,
     ULONG   TransColor)
{
     PBYTE   pjDst = (PBYTE)pDibInfoDst->pvBase + pDibInfoDst->stride*pDibInfoDst->rclDIB.top
                            + pDibInfoDst->rclDIB.left*3;
     PBYTE   pjSrc = (PBYTE)pDibInfoSrc->pvBase + pDibInfoSrc->stride*pDibInfoSrc->rclDIB.top
                            + (pDibInfoSrc->rclDIB.left >> 1);

     LONG    cx = pDibInfoDst->rclDIB.right - pDibInfoDst->rclDIB.left;
     LONG    cy = pDibInfoDst->rclDIB.bottom - pDibInfoDst->rclDIB.top;
     PBYTE   pjDstTemp;
     PBYTE   pjSrcTemp;
     LONG    cxTemp;
     BYTE    jSrc;
     LONG    iSrc, iDst;
     BYTE    rgbBlue, rgbGreen, rgbRed;

     while(cy--)
     {
         cxTemp = cx;

         pjDstTemp = pjDst;
         pjSrcTemp = pjSrc;

         iSrc = pDibInfoSrc->rclDIB.left;
         iDst = pDibInfoDst->rclDIB.left;

         while (cxTemp--)
         {
             if (iSrc & 0x00000001)
             {
                 jSrc = *pjSrcTemp & 0x0F;
                 pjSrcTemp++;
             }
             else
             {
                 jSrc = (*pjSrcTemp & 0xF0)>>4;
             }

             iSrc++;

             if (jSrc != (BYTE)TransColor)
             {
                 rgbBlue  = pDibInfoSrc->pbmi->bmiColors[jSrc].rgbBlue;
                 rgbGreen = pDibInfoSrc->pbmi->bmiColors[jSrc].rgbGreen;
                 rgbRed   = pDibInfoSrc->pbmi->bmiColors[jSrc].rgbRed;

                 *(pjDstTemp++) = (BYTE) rgbBlue;
                 *(pjDstTemp++) = (BYTE) rgbGreen;
                 *(pjDstTemp++) = (BYTE) rgbRed;
             }
             else
             {
                 pjDstTemp += 3;
             }
         }

         pjDst += pDibInfoDst->stride;
         pjSrc += pDibInfoSrc->stride;
     }
}

/******************************Public*Routine******************************\
* vTransparentS4D32
*
* Doing a transparent copy from 4BPP to 32BPP
*
* Returns:
*   VOID.
*
* History:
*  09-Dec-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
VOID vTransparentS4D32 (
     PDIBINFO pDibInfoDst,
     PDIBINFO pDibInfoSrc,
     ULONG   TransColor)
{
     PBYTE   pjDst = (PBYTE)pDibInfoDst->pvBase + pDibInfoDst->stride*pDibInfoDst->rclDIB.top
                            + pDibInfoDst->rclDIB.left*4;
     PBYTE   pjSrc = (PBYTE)pDibInfoSrc->pvBase + pDibInfoSrc->stride*pDibInfoSrc->rclDIB.top
                            + (pDibInfoSrc->rclDIB.left >> 1);

     LONG    cx = pDibInfoDst->rclDIB.right - pDibInfoDst->rclDIB.left;
     LONG    cy = pDibInfoDst->rclDIB.bottom - pDibInfoDst->rclDIB.top;
     PBYTE   pjDstTemp;
     PBYTE   pjSrcTemp;
     LONG    cxTemp;
     BYTE    jSrc;
     LONG    iSrc, iDst;
     BYTE    rgbBlue, rgbGreen, rgbRed;

     while(cy--)
     {
         cxTemp = cx;

         pjDstTemp = pjDst;
         pjSrcTemp = pjSrc;
         iSrc = pDibInfoSrc->rclDIB.left;
         iDst = pDibInfoDst->rclDIB.left;

         while (cxTemp--)
         {
             if (iSrc & 0x00000001)
             {
                 jSrc = *pjSrcTemp & 0x0F;
                 pjSrcTemp++;
             }
             else
             {
                 jSrc = (*pjSrcTemp & 0xF0)>>4;
             }

             iSrc++;

             if (jSrc != (BYTE)TransColor)
             {
                 rgbBlue  = pDibInfoSrc->pbmi->bmiColors[jSrc].rgbBlue;
                 rgbGreen = pDibInfoSrc->pbmi->bmiColors[jSrc].rgbGreen;
                 rgbRed   = pDibInfoSrc->pbmi->bmiColors[jSrc].rgbRed;

                 *(PULONG)pjDstTemp = (DWORD) (rgbBlue | (WORD)rgbGreen << 8 | (DWORD)rgbRed << 16);
             }
             pjDstTemp += 4;
         }

         pjDst += pDibInfoDst->stride;
         pjSrc += pDibInfoSrc->stride;
     }
}

/******************************Public*Routine******************************\
* vTransparentS8D16
*
* Doing a transparent copy from 8BPP to 16BPP
*
* Returns:
*   VOID.
*
* History:
*  09-Dec-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
VOID vTransparentS8D16 (
     PDIBINFO pDibInfoDst,
     PDIBINFO pDibInfoSrc,
     ULONG   TransColor)
{
     PBYTE   pjDst = (PBYTE)pDibInfoDst->pvBase + pDibInfoDst->stride*pDibInfoDst->rclDIB.top
                            +  pDibInfoDst->rclDIB.left*2;
     PBYTE   pjSrc = (PBYTE)pDibInfoSrc->pvBase + pDibInfoSrc->stride*pDibInfoSrc->rclDIB.top
                            + pDibInfoSrc->rclDIB.left;

     LONG    cx = pDibInfoDst->rclDIB.right - pDibInfoDst->rclDIB.left;
     LONG    cy = pDibInfoDst->rclDIB.bottom - pDibInfoDst->rclDIB.top;
     PBYTE   pjDstTemp;
     PBYTE   pjSrcTemp;
     BYTE    jSrc;
     LONG    cxTemp;
     BYTE    rgbBlue, rgbGreen, rgbRed;

     while(cy--)
     {
         cxTemp = cx;

         pjDstTemp = pjDst;
         pjSrcTemp = pjSrc;

         while (cxTemp--)
         {
             jSrc = *pjSrcTemp++;

            //
            // put one pixel in the dest
            //
            if (jSrc != (BYTE)TransColor)
            {
                 rgbBlue  = pDibInfoSrc->pbmi->bmiColors[jSrc].rgbBlue;
                 rgbGreen = pDibInfoSrc->pbmi->bmiColors[jSrc].rgbGreen;
                 rgbRed   = pDibInfoSrc->pbmi->bmiColors[jSrc].rgbRed;

                 //
                 // figure out 5-5-5 or 5-6-5
                 //
                 if (pDibInfoDst->pbmi->bmiHeader.biCompression == BI_BITFIELDS)
                 {
                      //5-5-5
                      if (*(DWORD *)&pDibInfoDst->pbmi->bmiColors[1] == 0x03E0)
                      {
                          *(PUSHORT)pjDstTemp = (USHORT)rgbBlue >> 3;
                          *(PUSHORT)pjDstTemp |= (USHORT)(rgbGreen >> 3) << 5;
                          *(PUSHORT)pjDstTemp |= (USHORT)(rgbRed >> 3) << 10;
                      }
                      // 5-6-5
                      else if (*(DWORD *)&pDibInfoDst->pbmi->bmiColors[1] == 0x07E0)
                      {
                          *(PUSHORT)pjDstTemp = (USHORT)rgbBlue >> 3;
                          *(PUSHORT)pjDstTemp |= (USHORT)(rgbGreen >> 2) << 5;
                          *(PUSHORT)pjDstTemp |= (USHORT)(rgbRed >> 3) << 11;
                      }
                      else
                      {
                          WARNING ("unsupported BITFIELDS\n");
                      }
                 }
                 else
                 {
                       *(PUSHORT)pjDstTemp = (USHORT)rgbBlue >> 3;
                       *(PUSHORT)pjDstTemp |= (USHORT)(rgbGreen >> 3) << 5;
                       *(PUSHORT)pjDstTemp |= (USHORT)(rgbRed >> 3) << 10;
                 }
            }

            pjDstTemp += 2;

         }

         pjDst += pDibInfoDst->stride;
         pjSrc += pDibInfoSrc->stride;
     }
}

/******************************Public*Routine******************************\
* vTransparentS8D24
*
* Doing a transparent copy from 8BPP to 16BPP
*
* Returns:
*   VOID.
*
* History:
*  09-Dec-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
VOID vTransparentS8D24 (
     PDIBINFO pDibInfoDst,
     PDIBINFO pDibInfoSrc,
     ULONG   TransColor)
{
     PBYTE   pjDst = (PBYTE)pDibInfoDst->pvBase + pDibInfoDst->stride*pDibInfoDst->rclDIB.top
                            +  pDibInfoDst->rclDIB.left*3;
     PBYTE   pjSrc = (PBYTE)pDibInfoSrc->pvBase + pDibInfoSrc->stride*pDibInfoSrc->rclDIB.top
                            + pDibInfoSrc->rclDIB.left;

     LONG    cx = pDibInfoDst->rclDIB.right - pDibInfoDst->rclDIB.left;
     LONG    cy = pDibInfoDst->rclDIB.bottom - pDibInfoDst->rclDIB.top;
     PBYTE   pjDstTemp;
     PBYTE   pjSrcTemp;
     BYTE    jSrc;
     LONG    cxTemp;
     BYTE    rgbBlue, rgbGreen, rgbRed;

     while(cy--)
     {
         cxTemp = cx;

         pjDstTemp = pjDst;
         pjSrcTemp = pjSrc;

         while (cxTemp--)
         {
             jSrc = *pjSrcTemp++;

             if (jSrc != (BYTE)TransColor)
             {
                 rgbBlue  = pDibInfoSrc->pbmi->bmiColors[jSrc].rgbBlue;
                 rgbGreen = pDibInfoSrc->pbmi->bmiColors[jSrc].rgbGreen;
                 rgbRed   = pDibInfoSrc->pbmi->bmiColors[jSrc].rgbRed;

                 *(pjDstTemp++) = (BYTE) rgbBlue;
                 *(pjDstTemp++) = (BYTE) rgbGreen;
                 *(pjDstTemp++) = (BYTE) rgbRed;
             }
             else
             {
                 pjDstTemp += 3;
             }
         }

         pjDst += pDibInfoDst->stride;
         pjSrc += pDibInfoSrc->stride;
     }
}

/******************************Public*Routine******************************\
* vTransparentS8D32
*
* Doing a transparent copy from 8BPP to 32BPP
*
* Returns:
*   VOID.
*
* History:
*  09-Dec-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
VOID vTransparentS8D32 (
     PDIBINFO pDibInfoDst,
     PDIBINFO pDibInfoSrc,
     ULONG   TransColor)
{
     PBYTE   pjDst = (PBYTE)pDibInfoDst->pvBase + pDibInfoDst->stride*pDibInfoDst->rclDIB.top
                            +  pDibInfoDst->rclDIB.left*4;
     PBYTE   pjSrc = (PBYTE)pDibInfoSrc->pvBase + pDibInfoSrc->stride*pDibInfoSrc->rclDIB.top
                            + pDibInfoSrc->rclDIB.left;
     LONG    cx = pDibInfoDst->rclDIB.right - pDibInfoDst->rclDIB.left;
     LONG    cy = pDibInfoDst->rclDIB.bottom - pDibInfoDst->rclDIB.top;
     PBYTE   pjDstTemp;
     PBYTE   pjSrcTemp;
     BYTE    jSrc;
     LONG    cxTemp;
     BYTE    rgbBlue, rgbGreen, rgbRed;

     while(cy--)
     {
         cxTemp = cx;

         pjDstTemp = pjDst;
         pjSrcTemp = pjSrc;

         while (cxTemp--)
         {
             jSrc = *pjSrcTemp++;

             if (jSrc != (BYTE)TransColor)
             {
                 rgbBlue  = pDibInfoSrc->pbmi->bmiColors[jSrc].rgbBlue;
                 rgbGreen = pDibInfoSrc->pbmi->bmiColors[jSrc].rgbGreen;
                 rgbRed   = pDibInfoSrc->pbmi->bmiColors[jSrc].rgbRed;

                 *(PULONG)pjDstTemp = (DWORD) (rgbBlue | (WORD)rgbGreen << 8 | (DWORD)rgbRed << 16);
             }
             pjDstTemp += 4;
         }

         pjDst += pDibInfoDst->stride;
         pjSrc += pDibInfoSrc->stride;
     }
}




/******************************Public*Routine******************************\
* vTransparentS8D1
*
* Doing a transparent copy from 8BPP to other 1,16,24,32bpp format DIBs
*
* Returns:
*   VOID.
*
* History:
*  09-Dec-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
VOID vTransparentS8D1 (
     PDIBINFO pDibInfoDst,
     PDIBINFO pDibInfoSrc,
     ULONG   TransColor)
{
     PBYTE   pjDst = (PBYTE)pDibInfoDst->pvBase + pDibInfoDst->stride*pDibInfoDst->rclDIB.top;

     pjDst = StartPixel (pjDst, pDibInfoDst->rclDIB.left, pDibInfoDst->pbmi->bmiHeader.biBitCount);

     PBYTE   pjSrc = (PBYTE)pDibInfoSrc->pvBase + pDibInfoSrc->stride*pDibInfoSrc->rclDIB.top
                            + pDibInfoSrc->rclDIB.left;

     LONG    cx = pDibInfoDst->rclDIB.right - pDibInfoDst->rclDIB.left;
     LONG    cy = pDibInfoDst->rclDIB.bottom - pDibInfoDst->rclDIB.top;
     PBYTE   pjDstTemp;
     PBYTE   pjSrcTemp;
     BYTE    jSrc;
     LONG    cxTemp;
     HDC     hdc;
     HBITMAP hbm;
     ULONG   ulWidthDst, ulHeightDst, ulWidthSrc, ulHeightSrc;
     BYTE    pByte[32];
     INT     i, j;
     BYTE    pByteSrc[256];
     LONG    iDst;
     BYTE    jDst;

     //
     // build the color translation table
     //
     hdc = CreateCompatibleDC (pDibInfoDst->hdc);

     //
     // save the original width/height
     //
     ulWidthDst = pDibInfoDst->pbmi->bmiHeader.biWidth;
     ulHeightDst = pDibInfoDst->pbmi->bmiHeader.biHeight;

     pDibInfoDst->pbmi->bmiHeader.biWidth = 256;
     pDibInfoDst->pbmi->bmiHeader.biHeight = 1;

     //
     // Create a 256X1 DIB
     //
     hbm = CreateDIBSection(hdc, (PBITMAPINFO)pDibInfoDst->pbmi, DIB_RGB_COLORS, (PVOID *)&pByte, NULL, 0);

     if (!hdc || !hbm)
     {
         //
         // It's bad to fail and return here without a return value, but it's better
         // than crashing later when accessing pByte.  At some point it would be nice
         // to change the vTansparentxxxx functions to return success/failure.
         //
         if (hdc) 
         {
             DeleteDC(hdc);
         }
         
         if (hbm) 
         {
             DeleteObject(hbm);
         }
         
         pDibInfoDst->pbmi->bmiHeader.biWidth = ulWidthDst;
         pDibInfoDst->pbmi->bmiHeader.biHeight = ulHeightDst;
         WARNING ("failed to create hdc or hbm\n");
         return;
     }

     SelectObject (hdc, hbm);

     for (i = 0; i < 256; i++)
     {
         pByteSrc[i] = (unsigned char)i;
     }

     ulWidthSrc = pDibInfoSrc->pbmi->bmiHeader.biWidth;
     ulHeightSrc = pDibInfoSrc->pbmi->bmiHeader.biHeight;

     pDibInfoSrc->pbmi->bmiHeader.biWidth = 256;
     pDibInfoSrc->pbmi->bmiHeader.biHeight = 1;

     SetDIBits(hdc, hbm, 0, 1, pByteSrc, (PBITMAPINFO)pDibInfoSrc->pbmi,pDibInfoSrc->iUsage);

     //
     // retore bitmap width/height
     //
     pDibInfoSrc->pbmi->bmiHeader.biWidth = ulWidthSrc;
     pDibInfoSrc->pbmi->bmiHeader.biHeight = ulHeightSrc;

     pDibInfoDst->pbmi->bmiHeader.biWidth = ulWidthDst;
     pDibInfoDst->pbmi->bmiHeader.biHeight = ulHeightDst;

     //
     // now pByte contains all the 256 color mappings, just need to split them up
     //
     BYTE bTmp = 0;

     while(cy--)
     {
         cxTemp = cx;

         pjDstTemp = pjDst;
         pjSrcTemp = pjSrc;

         iDst = pDibInfoDst->rclDIB.left & 0x07;

         jDst = *pjDstTemp >> (7 - iDst);

         while (cxTemp--)
         {
             jSrc = *pjSrcTemp++;

             //
             // put one pixel in the dest
             //
             bTmp = pByte[jSrc >> 3];
             bTmp >>= 7 - (jSrc & 0x07);

             if (jSrc != TransColor)
             {
                jDst |= bTmp;
             }
             else
             {
                jDst |= 1-bTmp;
             }

             jDst <<= 1;

             iDst++;

             if (!(iDst & 0x07))
             {
                *(pjDstTemp++) = jDst;
                jDst = 0;
             }
         }
         pjDst += pDibInfoDst->stride;
         pjSrc += pDibInfoSrc->stride;
     }

     DeleteDC(hdc);
     DeleteObject(hbm);
}

/******************************Public*Routine******************************\
* vTransparentS8D4
*
* Doing a transparent copy from 8BPP to other 1,16,24,32bpp format DIBs
*
* Returns:
*   VOID.
*
* History:
*  09-Dec-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
VOID vTransparentS8D4 (
     PDIBINFO pDibInfoDst,
     PDIBINFO pDibInfoSrc,
     ULONG   TransColor)
{
     PBYTE   pjDst = (PBYTE)pDibInfoDst->pvBase + pDibInfoDst->stride*pDibInfoDst->rclDIB.top;

     pjDst = StartPixel (pjDst, pDibInfoDst->rclDIB.left, pDibInfoDst->pbmi->bmiHeader.biBitCount);

     PBYTE   pjSrc = (PBYTE)pDibInfoSrc->pvBase + pDibInfoSrc->stride*pDibInfoSrc->rclDIB.top
                            + pDibInfoSrc->rclDIB.left;

     LONG    cx = pDibInfoDst->rclDIB.right - pDibInfoDst->rclDIB.left;
     LONG    cy = pDibInfoDst->rclDIB.bottom - pDibInfoDst->rclDIB.top;
     PBYTE   pjDstTemp;
     PBYTE   pjSrcTemp;
     BYTE    jSrc;
     LONG    cxTemp;
     HDC     hdc;
     HBITMAP hbm;
     ULONG   ulWidthDst, ulHeightDst, ulWidthSrc, ulHeightSrc;
     BYTE    pByte[128];
     INT     i, j;
     BYTE    xlate[256];
     BYTE    pByteSrc[256];
     LONG    iDst;

     //
     // build the color translation table
     //
     hdc = CreateCompatibleDC (pDibInfoDst->hdc);

     //
     // save the original width/height
     //
     ulWidthDst = pDibInfoDst->pbmi->bmiHeader.biWidth;
     ulHeightDst = pDibInfoDst->pbmi->bmiHeader.biHeight;

     pDibInfoDst->pbmi->bmiHeader.biWidth = 256;
     pDibInfoDst->pbmi->bmiHeader.biHeight = 1;

     //
     // Create a 256X1 DIB
     //
     hbm = CreateDIBSection(hdc, (PBITMAPINFO)pDibInfoDst->pbmi, DIB_RGB_COLORS, (PVOID *)&pByte, NULL, 0);

     if (!hdc || !hbm)
     {
         //
         // It's bad to fail and return here without a return value, but it's better
         // than crashing later when accessing pByte.  At some point it would be nice
         // to change the vTansparentxxxx functions to return success/failure.
         //
         if (hdc) 
         {
             DeleteDC(hdc);
         }
         
         if (hbm) 
         {
             DeleteObject(hbm);
         }
         
         pDibInfoDst->pbmi->bmiHeader.biWidth = ulWidthDst;
         pDibInfoDst->pbmi->bmiHeader.biHeight = ulHeightDst;
         WARNING ("failed to create hdc or hbm\n");
         return;
     }

     SelectObject (hdc, hbm);

     for (i = 0; i < 256; i++)
     {
         pByteSrc[i] = (unsigned char)i;
     }

     ulWidthSrc = pDibInfoSrc->pbmi->bmiHeader.biWidth;
     ulHeightSrc = pDibInfoSrc->pbmi->bmiHeader.biHeight;

     pDibInfoSrc->pbmi->bmiHeader.biWidth = 256;
     pDibInfoSrc->pbmi->bmiHeader.biHeight = 1;

     SetDIBits(hdc, hbm, 0, 1, pByteSrc, (PBITMAPINFO)pDibInfoSrc->pbmi,DIB_RGB_COLORS);

     //
     // retore bitmap width/height
     //
     pDibInfoSrc->pbmi->bmiHeader.biWidth = ulWidthSrc;
     pDibInfoSrc->pbmi->bmiHeader.biHeight = ulHeightSrc;

     pDibInfoDst->pbmi->bmiHeader.biWidth = ulWidthDst;
     pDibInfoDst->pbmi->bmiHeader.biHeight = ulHeightDst;

     //
     // now pByte contains all the 256 color mappings, just need to split them up
     //
     j = 0;
     for (i = 0; i < 128; i++)
     {
         xlate[j] = (pByte[i] & 0xF0) >> 4;
         xlate[j++] = pByte[i] & 0x0F;
     }

     BYTE jDst;

     while(cy--)
     {
         cxTemp = cx;

         iDst = pDibInfoDst->rclDIB.left;

         pjDstTemp = pjDst;
         pjSrcTemp = pjSrc;

         while (cxTemp--)
         {
             jSrc = *pjSrcTemp++;

             if (iDst & 0x00000001)
             {
                 if (jSrc != (BYTE)TransColor)
                 {
                     jDst |= (xlate[jSrc] & 0x0F);
                 }
                 else
                 {
                     jDst |= (*pjDstTemp & 0x0F);
                 }

                 *pjDstTemp = jDst;
                 jDst = 0;

                 pjDstTemp++;
             }
             else
             {
                 if (jSrc != (BYTE)TransColor)
                 {
                     jDst |= (xlate[jSrc] & 0x0F)<< 4;
                 }
                 else
                 {
                     jDst |= (*pjDstTemp & 0x0F) << 4;
                 }
             }

             iDst++;
         }

         pjDst += pDibInfoDst->stride;
         pjSrc += pDibInfoSrc->stride;
     }

     DeleteDC(hdc);
     DeleteObject(hbm);
}


/******************************Public*Routine******************************\
* vTransparentIdentityCopy8
*
* Doing a transparent copy on two same size 8BPP format DIBs
*
* Returns:
*   VOID.
*
* History:
*  09-Dec-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
VOID vTransparentIdentityCopy8 (
     PDIBINFO pDibInfoDst,
     PDIBINFO pDibInfoSrc,
     ULONG   TransColor)
{
     PBYTE   pjDst = (PBYTE)pDibInfoDst->pvBase + pDibInfoDst->stride*pDibInfoDst->rclDIB.top
                            + pDibInfoDst->rclDIB.left;
     PBYTE   pjSrc = (PBYTE)pDibInfoSrc->pvBase + pDibInfoSrc->stride*pDibInfoSrc->rclDIB.top
                            + pDibInfoSrc->rclDIB.left;
     LONG    cx = pDibInfoSrc->rclDIB.right - pDibInfoSrc->rclDIB.left;
     LONG    cy = pDibInfoSrc->rclDIB.bottom - pDibInfoSrc->rclDIB.top;
     PBYTE   pjDstTemp;
     PBYTE   pjSrcTemp;

     LONG   cxTemp;

     while(cy--)
     {
         cxTemp = cx;

         pjDstTemp = pjDst;
         pjSrcTemp = pjSrc;

         while (cxTemp--)
         {
             if (*pjSrcTemp != (BYTE)TransColor)
             {
                 *pjDstTemp = *pjSrcTemp;
             }
             pjDstTemp++;
             pjSrcTemp++;
         }

         pjDst += pDibInfoDst->stride;
         pjSrc += pDibInfoSrc->stride;
     }
}

/******************************Public*Routine******************************\
* vTransparentS8D8
*
* Doing a transparent copy on two same size 8BPP format DIBs
*
* Returns:
*   VOID.
*
* History:
*  09-Dec-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
VOID vTransparentS8D8 (
     PDIBINFO pDibInfoDst,
     PDIBINFO pDibInfoSrc,
     ULONG   TransColor)
{
     PBYTE   pjDst = (PBYTE)pDibInfoDst->pvBase + pDibInfoDst->stride*pDibInfoDst->rclDIB.top
                            + pDibInfoDst->rclDIB.left;
     PBYTE   pjSrc = (PBYTE)pDibInfoSrc->pvBase + pDibInfoSrc->stride*pDibInfoSrc->rclDIB.top
                            + pDibInfoSrc->rclDIB.left;
     LONG    cx = pDibInfoDst->rclDIB.right - pDibInfoDst->rclDIB.left;
     LONG    cy = pDibInfoDst->rclDIB.bottom - pDibInfoDst->rclDIB.top;
     PBYTE   pjDstTemp;
     PBYTE   pjSrcTemp;
     LONG    cxTemp;
     HDC     hdc;
     HBITMAP hbm;
     ULONG   ulWidthDst, ulHeightDst, ulWidthSrc, ulHeightSrc;
     INT     i, j;
     BYTE    pByteSrc[256];
     PBYTE   pxlate;
     LONG    iDst;

     //
     // build the color translation table
     //
     hdc = CreateCompatibleDC (pDibInfoDst->hdc);

     //
     // save the original width/height
     //
     ulWidthDst = pDibInfoDst->pbmi->bmiHeader.biWidth;
     ulHeightDst = pDibInfoDst->pbmi->bmiHeader.biHeight;

     pDibInfoDst->pbmi->bmiHeader.biWidth = 256;
     pDibInfoDst->pbmi->bmiHeader.biHeight = 1;

     //
     // Create a 256X1 DIB
     //
     hbm = CreateDIBSection(hdc, (PBITMAPINFO)pDibInfoDst->pbmi, DIB_RGB_COLORS, (PVOID *)&pxlate, NULL, 0);

     if (!hdc || !hbm)
     {
         //
         // It's bad to fail and return here without a return value, but it's better
         // than crashing later when accessing pxlate.  At some point it would be nice
         // to change the vTansparentxxxx functions to return success/failure.
         //
         if (hdc) 
         {
             DeleteDC(hdc);
         }
         
         if (hbm) 
         {
             DeleteObject(hbm);
         }
         
         pDibInfoDst->pbmi->bmiHeader.biWidth = ulWidthDst;
         pDibInfoDst->pbmi->bmiHeader.biHeight = ulHeightDst;
         WARNING ("failed to create hdc or hbm\n");
         return;
     }

     SelectObject (hdc, hbm);

     for (i = 0; i < 256; i++)
     {
         pByteSrc[i] = (unsigned char)i;
     }

     ulWidthSrc = pDibInfoSrc->pbmi->bmiHeader.biWidth;
     ulHeightSrc = pDibInfoSrc->pbmi->bmiHeader.biHeight;

     pDibInfoSrc->pbmi->bmiHeader.biWidth = 256;
     pDibInfoSrc->pbmi->bmiHeader.biHeight = 1;

     SetDIBits(hdc, hbm, 0, 1, pByteSrc, (PBITMAPINFO)pDibInfoSrc->pbmi,DIB_RGB_COLORS);

     //
     // retore bitmap width/height
     //
     pDibInfoSrc->pbmi->bmiHeader.biWidth = ulWidthSrc;
     pDibInfoSrc->pbmi->bmiHeader.biHeight = ulHeightSrc;

     pDibInfoDst->pbmi->bmiHeader.biWidth = ulWidthDst;
     pDibInfoDst->pbmi->bmiHeader.biHeight = ulHeightDst;


     while(cy--)
     {
         cxTemp = cx;

         pjDstTemp = pjDst;
         pjSrcTemp = pjSrc;

         while (cxTemp--)
         {
             if (*pjSrcTemp != (BYTE)TransColor)
             {
                 *pjDstTemp = pxlate[*pjSrcTemp];
             }

             pjDstTemp++;
             pjSrcTemp++;
         }

         pjDst += pDibInfoDst->stride;
         pjSrc += pDibInfoSrc->stride;
     }

     DeleteObject(hbm);
     DeleteDC(hdc);
}



#if 0
/******************************Public*Routine******************************\
* vTransparentIdentityCopy16
*
* Doing a transparent copy on two same size 16BPP format DIBs
*
* Returns:
*   VOID.
*
* History:
*  09-Dec-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
VOID vTransparentIdentityCopy16 (
     PDIBINFO pDibInfoDst,
     PDIBINFO pDibInfoSrc,
     ULONG   TransColor)
{
     PUSHORT   pusDst = (PUSHORT)((PBYTE)pDibInfoDst->pvBase + pDibInfoDst->rclDIB.top*pDibInfoDst->stride)
                        + pDibInfoDst->rclDIB.left;
     PUSHORT   pusSrc = (PUSHORT)((PBYTE)pDibInfoSrc->pvBase + pDibInfoSrc->rclDIB.top*pDibInfoDst->stride)
                        + pDibInfoSrc->rclDIB.left;
     LONG      cx = pDibInfoDst->rclDIB.right - pDibInfoDst->rclDIB.left;
     LONG      cy = pDibInfoDst->rclDIB.bottom - pDibInfoDst->rclDIB.top;
     PUSHORT   pusDstTemp;
     PUSHORT   pusSrcTemp;
     LONG      cxTemp;

     while(cy--)
     {
         cxTemp = cx;

         pusDstTemp = pusDst;
         pusSrcTemp = pusSrc;

         while (cxTemp--)
         {
             if (*pusSrcTemp != (USHORT)TransColor)
             {
                 *pusDstTemp = *pusSrcTemp;
             }

             pusDstTemp++;
             pusSrcTemp++;
         }

         pusDst = (PUSHORT)((PBYTE)pusDst + pDibInfoDst->stride);
         pusSrc = (PUSHORT)((PBYTE)pusSrc + pDibInfoSrc->stride);
     }
}

/******************************Public*Routine******************************\
* vTransparentIdentityCopy24
*
* Doing a transparent copy on two same size 8BPP format DIBs
*
* Returns:
*   VOID.
*
* History:
*  09-Dec-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
VOID vTransparentIdentityCopy24 (
     PDIBINFO pDibInfoDst,
     PDIBINFO pDibInfoSrc,
     ULONG   TransColor)
{
     PBYTE   pjDst = (PBYTE)pDibInfoDst->pvBase + pDibInfoDst->stride*pDibInfoDst->rclDIB.top
                            + pDibInfoDst->rclDIB.left*3;
     PBYTE   pjSrc = (PBYTE)pDibInfoSrc->pvBase + pDibInfoSrc->stride*pDibInfoSrc->rclDIB.top
                            + pDibInfoSrc->rclDIB.left*3;
     LONG    cx = pDibInfoDst->rclDIB.right - pDibInfoDst->rclDIB.left;
     LONG    cy = pDibInfoDst->rclDIB.bottom - pDibInfoDst->rclDIB.top;
     PBYTE   pjDstTemp;
     PBYTE   pjSrcTemp;
     ULONG   ulTemp;
     LONG   cxTemp;

     while(cy--)
     {
         cxTemp = cx;

         pjDstTemp = pjDst;
         pjSrcTemp = pjSrc;

         while (cxTemp--)
         {
            ulTemp = (ULONG) *(pjSrcTemp + 2);
            ulTemp = ulTemp << 8;
            ulTemp |= (ULONG) *(pjSrcTemp + 1);
            ulTemp = ulTemp << 8;
            ulTemp |= (ULONG) *pjSrcTemp;

            if (ulTemp != TransColor)
            {
               *(pjDstTemp++) = (BYTE) ulTemp;
               *(pjDstTemp++) = (BYTE) (ulTemp >> 8);
               *(pjDstTemp++) = (BYTE) (ulTemp >> 16);
            }
            else
            {
                pjDstTemp += 3;
            }

            pjSrcTemp += 3;
         }

         pjDst += pDibInfoDst->stride;
         pjSrc += pDibInfoSrc->stride;
     }
}
#endif

/******************************Public*Routine******************************\
* vTransparentIdentityCopy32
*
* Doing a transparent copy on two same size 32BPP format DIBs
*
* Returns:
*   VOID.
*
* History:
*  09-Dec-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
VOID vTransparentIdentityCopy32 (
     PDIBINFO pDibInfoDst,
     PDIBINFO pDibInfoSrc,
     ULONG   TransColor)
{
     PULONG   pulDst = (PULONG)((PBYTE)pDibInfoDst->pvBase + pDibInfoDst->stride*pDibInfoDst->rclDIB.top)
                       + pDibInfoDst->rclDIB.left;
     PULONG   pulSrc = (PULONG)((PBYTE)pDibInfoSrc->pvBase + pDibInfoSrc->stride*pDibInfoSrc->rclDIB.top)
                       + pDibInfoSrc->rclDIB.left;
     LONG     cx = pDibInfoDst->rclDIB.right - pDibInfoDst->rclDIB.left;
     LONG     cy = pDibInfoDst->rclDIB.bottom - pDibInfoDst->rclDIB.top;
     PULONG   pulDstTemp;
     PULONG   pulSrcTemp;
     LONG     cxTemp;

     while(cy--)
     {
         cxTemp = cx;

         pulDstTemp = pulDst;
         pulSrcTemp = pulSrc;

         while (cxTemp--)
         {
             // mask off highest byte -- workaround Memphis problem
             if ((*pulSrcTemp & 0x00FFFFFF) != TransColor)
             {
                 *pulDstTemp = *pulSrcTemp;
             }

             pulDstTemp++;
             pulSrcTemp++;
         }

         pulDst = (PULONG)((PBYTE)pulDst + pDibInfoDst->stride);
         pulSrc = (PULONG)((PBYTE)pulSrc + pDibInfoSrc->stride);
     }
}


/******************************Public*Routine******************************\
* vTransparentS16D32
*
* Doing a transparent copy from 16BPP to 32BPP
*
* Returns:
*   VOID.
*
* History:
*  22-Aug-1997 -by- Ori Gershony [orig]
* Wrote it.
\**************************************************************************/
VOID vTransparentS16D32 (
     PDIBINFO pDibInfoDst,
     PDIBINFO pDibInfoSrc,
     ULONG   TransColor)
{
     PBYTE   pjDst = (PBYTE)pDibInfoDst->pvBase + pDibInfoDst->stride*pDibInfoDst->rclDIB.top
                            +  pDibInfoDst->rclDIB.left*4;
     PBYTE   pjSrc = (PBYTE)pDibInfoSrc->pvBase + pDibInfoSrc->stride*pDibInfoSrc->rclDIB.top
                            +  pDibInfoSrc->rclDIB.left*2;
     LONG    cx = pDibInfoDst->rclDIB.right - pDibInfoDst->rclDIB.left;
     LONG    cy = pDibInfoDst->rclDIB.bottom - pDibInfoDst->rclDIB.top;
     PBYTE   pjDstTemp;
     PUSHORT  pjSrcTemp;
     USHORT   jSrc;
     LONG    cxTemp;
     BYTE    rgbBlue, rgbGreen, rgbRed;

     while(cy--)
     {
         cxTemp = cx;

         pjDstTemp = pjDst;
         pjSrcTemp = (PUSHORT) pjSrc;

         while (cxTemp--)
         {
             jSrc = *pjSrcTemp++;

             //
             // If 5-5-5 we should mask out the 16th bit so that we'd recognize the transparent
             // color
             //
             if ((!(pDibInfoSrc->pbmi->bmiHeader.biCompression == BI_BITFIELDS)) ||
                 ((*(DWORD *)&pDibInfoSrc->pbmi->bmiColors[1] == 0x03E0)))
             {
                 jSrc &= 0x7fff;
                 TransColor &= 0x7fff;
             }

             if (jSrc != (USHORT)TransColor)
             {

                 //
                 // figure out 5-5-5 or 5-6-5
                 //
                 if (pDibInfoSrc->pbmi->bmiHeader.biCompression == BI_BITFIELDS)
                 {
                      //5-5-5
                      if (*(DWORD *)&pDibInfoSrc->pbmi->bmiColors[1] == 0x03E0)
                      {
                          rgbBlue  = (jSrc         & 0x1f) << 3;
                          rgbGreen = ((jSrc >> 5)  & 0x1f) << 3;
                          rgbRed   = ((jSrc >> 10) & 0x1f) << 3;
                      }
                      // 5-6-5
                      else if (*(DWORD *)&pDibInfoDst->pbmi->bmiColors[1] == 0x07E0)
                      {
                          rgbBlue  = (jSrc         & 0x1f) << 3;
                          rgbGreen = ((jSrc >> 5)  & 0x3f) << 2;
                          rgbRed   = ((jSrc >> 11) & 0x1f) << 3;
                      }
                      else
                      {
                          WARNING ("unsupported BITFIELDS\n");
                      }
                 }
                 else
                 {
                     rgbBlue  = (jSrc         & 0x1f) << 3;
                     rgbGreen = ((jSrc >> 5)  & 0x1f) << 3;
                     rgbRed   = ((jSrc >> 10) & 0x1f) << 3;
                 }

                 *(PULONG)pjDstTemp = (DWORD) (rgbBlue << 0 | (WORD)rgbGreen << 8 | (DWORD)rgbRed << 16);
             }
             pjDstTemp += 4;
         }

         pjDst += pDibInfoDst->stride;
         pjSrc += pDibInfoSrc->stride;
     }
}




/******************************Public*Routine******************************\
* vTransparentS24D32
*
* Doing a transparent copy from 24BPP to 32BPP
*
* Returns:
*   VOID.
*
* History:
*  22-Aug-1997 -by- Ori Gershony [orig]
* Wrote it.
\**************************************************************************/
VOID vTransparentS24D32 (
     PDIBINFO pDibInfoDst,
     PDIBINFO pDibInfoSrc,
     ULONG   TransColor)
{
     PBYTE   pjDst = (PBYTE)pDibInfoDst->pvBase + pDibInfoDst->stride*pDibInfoDst->rclDIB.top
                            +  pDibInfoDst->rclDIB.left*4;
     PBYTE   pjSrc = (PBYTE)pDibInfoSrc->pvBase + pDibInfoSrc->stride*pDibInfoSrc->rclDIB.top
                            +  pDibInfoSrc->rclDIB.left*3;
     LONG    cx = pDibInfoDst->rclDIB.right - pDibInfoDst->rclDIB.left;
     LONG    cy = pDibInfoDst->rclDIB.bottom - pDibInfoDst->rclDIB.top;
     PBYTE   pjDstTemp;
     PBYTE  pjSrcTemp;
     ULONG   jSrc;
     LONG    cxTemp;
     BYTE    rgbBlue, rgbGreen, rgbRed;

     while(cy--)
     {
         cxTemp = cx;

         pjDstTemp = pjDst;
         pjSrcTemp = pjSrc;

         while (cxTemp--)
         {
             jSrc = (ULONG) *(pjSrcTemp+2);
             jSrc <<= 8;
             jSrc |= (ULONG) *(pjSrcTemp+1);
             jSrc <<= 8;
             jSrc |= (ULONG) *(pjSrcTemp);
             pjSrcTemp +=3;
             
             if (jSrc != TransColor)
             {
                 *(PULONG)pjDstTemp = jSrc;
             }
             pjDstTemp += 4;
         }

         pjDst += pDibInfoDst->stride;
         pjSrc += pDibInfoSrc->stride;
     }
}



/******************************Public*Routine******************************\
* vTransparentS32D32
*
* Doing a transparent copy from 32BPP to 32BPP
*
* Returns:
*   VOID.
*
* History:
*  22-Aug-1997 -by- Ori Gershony [orig]
* Wrote it.
\**************************************************************************/

#define vTransparentS32D32 vTransparentIdentityCopy32




/******************************Public*Routine******************************\
* MapTransparentColor
*
* Getting the correct transparent color mapped to the specified DIB format
* by creating a solid brush on the colorref, then PatBlt to a 1X1 DIB, the
* resulting pixel is the mapped transparent color
*
* Returns:
*   VOID.
*
* History:
*  09-Dec-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
DWORD MapTransparentColor(
    PDIBINFO pDibInfo,
    COLORREF Color
    )
{
    HBRUSH hbr, hbrDefault;
    HBITMAP hbm, hbmDefault;
    HDC hdcTemp;
    UINT iUsage;
    PVOID pvBits = NULL;
    DWORD trancolor;
    ULONG ulWidth, ulHeight;

    hdcTemp = CreateCompatibleDC(pDibInfo->hdc);

    hbr = CreateSolidBrush (Color);

    //
    // save the original width/height
    //
    ulWidth = pDibInfo->pbmi->bmiHeader.biWidth;
    ulHeight = pDibInfo->pbmi->bmiHeader.biHeight;

    pDibInfo->pbmi->bmiHeader.biWidth = 1;
    pDibInfo->pbmi->bmiHeader.biHeight = 1;

    //
    // Create a 1X1 DIB
    //
    hbm = CreateDIBSection(hdcTemp, (PBITMAPINFO)pDibInfo->pbmi, DIB_RGB_COLORS, &pvBits, NULL, 0);

    if (hbm && hbr)
    {
        hbmDefault = (HBITMAP)SelectObject (hdcTemp, hbm);
        hbrDefault = (HBRUSH)SelectObject (hdcTemp, hbr);

        PatBlt (hdcTemp, 0, 0, 1, 1, PATCOPY);

        SelectObject (hdcTemp, hbrDefault);
        SelectObject (hdcTemp, hbmDefault);
    }

    if (pvBits)
    {
          switch (pDibInfo->pbmi->bmiHeader.biBitCount)
          {
          case 1:
              trancolor = *(BYTE *)pvBits;
              trancolor = (DWORD)(((BYTE)trancolor) & 0x80) >>7;
              break;

          case 4:
              trancolor = *(BYTE *)pvBits;
              trancolor = (DWORD)(((BYTE)trancolor) & 0xF0) >>4;
              break;
          case 8:
              trancolor = (DWORD)(*(BYTE *)pvBits);
              trancolor &= 0x000000FF;
              break;
          case 16:
              trancolor = (DWORD)(*(USHORT *)pvBits);
              trancolor &= 0x0000FFFF;
              break;
          case 24:
              trancolor = *(DWORD *)pvBits;
              trancolor &= 0x00FFFFFF;
              break;
          case 32:
              trancolor = *(DWORD *)pvBits;
              trancolor &= 0x00FFFFFF;
              break;
          }
    }

    pDibInfo->pbmi->bmiHeader.biWidth = ulWidth;
    pDibInfo->pbmi->bmiHeader.biHeight = ulHeight;

    //
    // cleanup
    //
    DeleteObject (hbm);
    DeleteObject (hbr);
    DeleteDC(hdcTemp);

    return (trancolor);
}

/******************************Public*Routine******************************\
* DIBMapTransparentColor
*
* Getting the correct transparent color mapped to the specified DIB format
* This is only for DIB_PAL_COLORS passed into transparentDIBits
*
* Returns:
*   VOID.
*
* History:
*  09-Dec-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
DWORD DIBMapTransparentColor(
    PDIBINFO pDibInfoDst,
    PDIBINFO pDibInfoSrc,
    COLORREF Color
    )
{
    HBITMAP hbm, hbmDefault;
    HDC hdcTemp;
    UINT iUsage;
    PVOID pvBits;
    DWORD trancolor;
    ULONG ulWidth, ulHeight;

    hdcTemp = CreateCompatibleDC(pDibInfoDst->hdc);

    //
    // save the original width/height
    //
    ulWidth = pDibInfoDst->pbmi->bmiHeader.biWidth;
    ulHeight = pDibInfoDst->pbmi->bmiHeader.biHeight;

    pDibInfoDst->pbmi->bmiHeader.biWidth = 1;
    pDibInfoDst->pbmi->bmiHeader.biHeight = 1;

    //
    // Create a 1X1 DIB
    //
    hbm = CreateDIBSection(hdcTemp, (PBITMAPINFO)pDibInfoDst->pbmi, DIB_RGB_COLORS, &pvBits, NULL, 0);

    if (hbm)
    {
        hbmDefault = (HBITMAP)SelectObject (hdcTemp, hbm);

        StretchDIBits (hdcTemp,
                       0,
                       0,
                       1,
                       1,
                       0,
                       0,
                       1,
                       1,
                       &Color,
                       pDibInfoSrc->pbmi,
                       pDibInfoSrc->iUsage,
                       SRCCOPY);

        SelectObject (hdcTemp, hbmDefault);
    }

    if (pvBits)
    {
          switch (pDibInfoDst->pbmi->bmiHeader.biBitCount)
          {
          case 4:
              trancolor = *(BYTE *)pvBits;
              trancolor = (DWORD)(((BYTE)trancolor) & 0xF0) >>4;
              break;
          case 8:
              trancolor = (DWORD)(*(BYTE *)pvBits);
              trancolor &= 0x000000FF;
              break;
          case 16:
              trancolor = (DWORD)(*(USHORT *)pvBits);
              trancolor &= 0x0000FFFF;
              break;
          case 24:
              trancolor = *(DWORD *)pvBits;
              trancolor &= 0x00FFFFFF;
              break;
          case 32:
              trancolor = *(DWORD *)pvBits;
              trancolor &= 0x00FFFFFF;
              break;
          }
    }

    pDibInfoDst->pbmi->bmiHeader.biWidth = ulWidth;
    pDibInfoDst->pbmi->bmiHeader.biHeight = ulHeight;

    //
    // cleanup
    //
    DeleteObject (hbm);
    DeleteDC(hdcTemp);

    return (trancolor);
}


/******************************Public*Routine******************************\
* vTransparentMapCopy
*
* Map the Dest surface to 32bpp and does transparent on to that
*
* Returns:
*   VOID.
*
* History:
*  09-Dec-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
VOID vTransparentMapCopy (
     PDIBINFO pDibInfoDst,
     PDIBINFO pDibInfoSrc,
     ULONG TransColor)
{
     HDC hdc = pDibInfoSrc->hdc;
     ULONG cxDst = pDibInfoDst->rclDIB.right - pDibInfoDst->rclDIB.left;
     ULONG cyDst = pDibInfoDst->rclDIB.bottom - pDibInfoDst->rclDIB.top;
     HBITMAP hbm;
     PVOID   pBits;
     ULONG cBytes = sizeof(BITMAPINFO) + sizeof(RGBQUAD) * 255;
     PBITMAPINFO pbmi;
     PVOID p = LOCALALLOC(cBytes);

     if (!p)
     {
        WARNING("MapCopy fail to alloc mem\n");
        return ;
     }

     ZeroMemory (p,cBytes);

     pbmi = (PBITMAPINFO)p;

     vCopyBitmapInfo (pbmi, pDibInfoDst->pbmi);

     hdc = CreateCompatibleDC (hdc);

     pbmi->bmiHeader.biBitCount = 32;
     pbmi->bmiHeader.biCompression = BI_RGB;
     
     // create a dib using 32 format
     if (!(hbm = CreateCompatibleDIB (hdc, cxDst, cyDst, &pBits, pbmi)))
     {
         WARNING("Error in msimg32!vTransparentMapCopy:  call to CreateCompatibleDIB failed\n");
         
         if (hdc) 
         {
             DeleteDC(hdc);
         }

         if (p) 
         {
             LOCALFREE(p);
         }         
         
         return;
     }

     SetDIBits (hdc, hbm, 0, cyDst, pDibInfoDst->pvBits, pDibInfoDst->pbmi, DIB_RGB_COLORS);

     vCopyBitmapInfo (pDibInfoDst->pbmi,pbmi);

     GetCompatibleDIBInfo (hbm, &pDibInfoDst->pvBase, &pDibInfoDst->stride);

     PVOID pvBitsOrig = pDibInfoDst->pvBits;
     pDibInfoDst->pvBits = pBits;

     pDibInfoDst->rclDIB.left = 0;
     pDibInfoDst->rclDIB.right = cxDst;
     pDibInfoDst->rclDIB.top = 0;
     pDibInfoDst->rclDIB.bottom = cyDst;

     switch(pDibInfoSrc->pbmi->bmiHeader.biBitCount)
     {
         case 4:
             vTransparentS4D32 (pDibInfoDst, pDibInfoSrc, TransColor);
             break;
             
         case 8:
             vTransparentS8D32 (pDibInfoDst, pDibInfoSrc, TransColor);
             break;
             
         case 16:
             vTransparentS16D32 (pDibInfoDst, pDibInfoSrc, TransColor);
             break;
    
         case 24:
             vTransparentS24D32 (pDibInfoDst, pDibInfoSrc, TransColor);
             break;
    
         case 32:
             vTransparentS32D32 (pDibInfoDst, pDibInfoSrc, TransColor);
             break;
     }
     
     //
     // If destination is a memory dc, then now is the time to set the bits at
     // the destination format.
     //
     HBITMAP hbmDest;     
     if ((GetObjectType(pDibInfoDst->hdc) == OBJ_MEMDC) &&
         ((hbmDest = (HBITMAP)GetCurrentObject(pDibInfoDst->hdc, OBJ_BITMAP)) != NULL))
     {
         SetDIBits (pDibInfoDst->hdc, hbmDest, 0, cyDst, pBits, pbmi, DIB_RGB_COLORS);
     }

     if (pDibInfoDst->hDIB) 
     {
         //
         // Replace the old hDIB with the one allocated above.  Make sure
         // the old one doesn't get leaked.  pDibInfoDst->hDIB will get
         // cleaned up in vCleanupDIBINFO.
         //
         DeleteObject(pDibInfoDst->hDIB);
         pDibInfoDst->hDIB = hbm;
     }
     else
     {
         //
         // This is the case where the destination was a dibsection with
         // no stretching.  The correct data was already written in the
         // above call to SetDIBits.
         //
         DeleteObject(hbm);
         pDibInfoDst->pvBits = pvBitsOrig;
     }
          
     if (p)
     {
         LOCALFREE (p);
     }

     if (hdc) 
     {
         DeleteDC(hdc);
     }     
}

/******************************Public*Routine******************************\
* ReadScanLine
*     read the scanline until it hits a transparent color pixel
*
* History:
*  26-Nov-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
ULONG ReadScanLine(
    PBYTE pjSrc,
    ULONG xStart,
    ULONG xEnd,
    ULONG iFormat,
    ULONG TransparentColor,
    PDIBINFO pDibInfoSrc)
{
    ULONG  cx = xEnd-xStart;
    ULONG  Shift = (iFormat - 3 > 0) ? iFormat : 1;
    ULONG  iPos;
    ULONG  ulSrc;
    BOOL   bStop = FALSE;

    pjSrc = StartPixel (pjSrc, xStart, iFormat);

    //
    // performance can be improved by breaking this routine into many
    // dealing with different format so that we can save two comparsions
    // for each pixel operation.  But working set size will be large
    //
     iPos = xStart;

     //
     // read one pixel at a time and compare it to the transparent color
     // if it matches the transparent color, come out
     //
     BYTE jSrc = *pjSrc << (iPos & 0x7);

     while ((iPos < xEnd) && !bStop)
     {
         //
         // get a pixel from source and compare is to the transparent color
         //
         switch (iFormat)
         {
         case 1:
             ulSrc = (ULONG) (jSrc & 0x80);
             ulSrc >>= 7;
             jSrc <<= 1;

             if (!(iPos & 0x00000007) )
                 pjSrc++;
             break;

         case 4:
             if (iPos & 0x00000001)
             {
                 ulSrc = *pjSrc & 0x0F;
                 pjSrc++;
             }
             else
             {
                 ulSrc = (*pjSrc & 0xF0)>>4;
             }
             break;

         case 8:
             ulSrc = (ULONG) *pjSrc;
             pjSrc++;
             break;

         case 16:
             ulSrc = (ULONG) *((PUSHORT)pjSrc);
             
             //
             // If 5-5-5 we should mask out the 16th bit so that we'd recognize the transparent
             // color
             //
             if ((!(pDibInfoSrc->pbmi->bmiHeader.biCompression == BI_BITFIELDS)) ||
                 ((*(DWORD *)&pDibInfoSrc->pbmi->bmiColors[1] == 0x03E0)))
             {
                 ulSrc &= 0x7fff;
             }
             pjSrc += 2;
             break;

         case 24:
             ulSrc = *(pjSrc + 2);
             ulSrc = ulSrc << 8;
             ulSrc |= (ULONG) *(pjSrc + 1);
             ulSrc = ulSrc << 8;
             ulSrc |= (ULONG) *pjSrc;
             pjSrc += 3;
             break;

          case 32:
             ulSrc = *(PULONG)(pjSrc);
             ulSrc &= 0x00ffffff;  // Ignore upper byte since it doesn't contain color information
             pjSrc +=4;
             break;

          default:
              WARNING ("vTransparentScan -- bad iFormatSrc\n");
              return(0);

         } /*switch*/

         if (ulSrc == TransparentColor)
             bStop = TRUE;

         iPos++;
    }

    return (iPos);
}

/******************************Public*Routine******************************\
* SkipScanLine
*     read the scanline until it hits a non-transparent color pixel
*
* History:
*  26-Nov-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
ULONG SkipScanLine(
    PBYTE pjSrc,
    ULONG xStart,
    ULONG xEnd,
    ULONG iFormat,
    ULONG TransparentColor,
    PDIBINFO pDibInfoSrc)
{
    ULONG  Shift = (iFormat - 3 > 0) ? iFormat : 1;
    ULONG  iPos = xStart;
    ULONG  ulSrc;
    BOOL   bStop = FALSE;

    pjSrc = StartPixel (pjSrc, xStart, iFormat);

    //
    // performance can be improved by breaking this routine into many
    // dealing with different format so that we can save two comparsions
    // for each pixel operation.  But working set size will be large
    //

     //
     // read one pixel at a time and compare it to the transparent color
     // if it matches the transparent color, come out
     //
     BYTE jSrc = *pjSrc << (iPos & 0x7);
     
     while ((iPos < xEnd) && !bStop)
     {
         //
         // get a pixel from source and compare is to the transparent color
         //
         switch (iFormat)
         {
         case 1:
             ulSrc = *pjSrc & 0x00000001;
             ulSrc = (ULONG) (jSrc & 0x80);
             ulSrc >>= 7;
             jSrc <<= 1;

             if (!(iPos & 0x00000007) )
                 pjSrc++;
             break;

         case 4:
             if (iPos & 0x00000001)
             {
                 ulSrc = *pjSrc & 0x0F;
                 pjSrc++;
             }
             else
             {
                 ulSrc = (*pjSrc & 0xF0)>>4;
             }
             break;

         case 8:
             ulSrc = (ULONG) *pjSrc;
             pjSrc++;
             break;

         case 16:

             ulSrc = (ULONG) *((PUSHORT)pjSrc);
             //
             // If 5-5-5 we should mask out the 16th bit so that we'd recognize the transparent
             // color
             //
             if ((!(pDibInfoSrc->pbmi->bmiHeader.biCompression == BI_BITFIELDS)) ||
                 ((*(DWORD *)&pDibInfoSrc->pbmi->bmiColors[1] == 0x03E0)))
             {
                 ulSrc &= 0x7fff;
             }             
             pjSrc += 2;
             break;

         case 24:
             ulSrc = *(pjSrc + 2);
             ulSrc = ulSrc << 8;
             ulSrc |= (ULONG) *(pjSrc + 1);
             ulSrc = ulSrc << 8;
             ulSrc |= (ULONG) *pjSrc;
             pjSrc += 3;
             break;

          case 32:
             ulSrc = *(PULONG)(pjSrc);
             ulSrc &= 0x00ffffff;  // Ignore upper two bytes since they don't contain color information
             pjSrc +=4;
             break;

          default:
              WARNING ("vTransparentScan -- bad iFormatSrc\n");
              return (0);

         } /*switch*/

         if (ulSrc != TransparentColor)
             bStop = TRUE;

         iPos++;   // move to the next pixel
    }

    return (iPos);
}

/******************************Public*Routine******************************\
* VOID vTransparentCopyScan
*
* Read a scanline at a time and send the non-transparent pixel scans over
*
* History:
*  2-Dec-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/

VOID vTransparentCopyScan (
    PDIBINFO  pDibInfoDst,
    PDIBINFO  pDibInfoSrc,
    ULONG     TransparentColor)
{
    ULONG xStart;
    ULONG cx = pDibInfoSrc->rclDIB.right - pDibInfoSrc->rclDIB.left;
    ULONG cy =  pDibInfoSrc->rclDIB.bottom - pDibInfoSrc->rclDIB.top;
    ULONG xEnd;
    ULONG xSrc;
    ULONG ySrc = pDibInfoSrc->rclDIB.bottom;
    ULONG xDst;
    ULONG yDst = pDibInfoDst->rclBoundsTrim.top;
    ULONG xStop, xReStart;

    PBYTE pjSrc = (PBYTE)pDibInfoSrc->pvBase + pDibInfoSrc->rclDIB.top*pDibInfoSrc->stride;

    //
    // make the bitmap into one scanline bitmap
    // since pscript will send entire bitmap over otherwise
    //
    LONG OldHeight = pDibInfoSrc->pbmi->bmiHeader.biHeight;
    pDibInfoSrc->pbmi->bmiHeader.biHeight = 1;

    while (cy--)
    {
       xStart = pDibInfoSrc->rclDIB.left;
       xEnd = xStart + cx;

       xSrc = pDibInfoSrc->rclDIB.left;
       xDst = pDibInfoDst->rclBoundsTrim.left;

       while (xStart < xEnd)
       {
           xStop = ReadScanLine((PBYTE)pjSrc,
                                 xStart,
                                 xEnd,
                                 pDibInfoSrc->pbmi->bmiHeader.biBitCount,
                                 TransparentColor,
                                 pDibInfoSrc);

           if (xStop-1 > xStart)
           {
               //
               // send the partial scan line over
               //

               StretchDIBits (
                          pDibInfoDst->hdc,
                          xDst,
                          yDst,
                          xStop-xStart-1, //width
                          1,
                          xSrc-1,
                          0,
                          xStop-xStart-1,
                          1,
                          (PBYTE)pjSrc,
                          pDibInfoSrc->pbmi,
                          DIB_RGB_COLORS,
                          SRCCOPY);

               //Dprintf("StretchDIBits xDst=%x, yDst=%x, width=%x, pjSrc=%x\n",
               //             xDst, yDst, xStop-xStart-1,pjSrc);

           }

           //get to the next non transparent pixel
           xReStart = SkipScanLine((PBYTE)pjSrc,
                                    xStop-1,
                                    xEnd,
                                    pDibInfoSrc->pbmi->bmiHeader.biBitCount,
                                    TransparentColor,
                                    pDibInfoSrc);

           xDst = xDst + xReStart-xStart;

           xSrc = xReStart;

           xStart = xReStart;
        }

        pjSrc += pDibInfoSrc->stride;

        ySrc--;
        yDst++;
     }

     //
     // restore biHeight
     //
     pDibInfoSrc->pbmi->bmiHeader.biHeight = OldHeight;

     //Dprintf("out of copyscan\n");
}


/******************************Public*Routine******************************\
* WinTransparentBlt
*
* Returns:
*   BOOL.
*
* History:
*  09-Dec-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/


BOOL
WinTransparentBlt(
                 HDC   hdcDst,
                 int   xDst,
                 int   yDst,
                 int   cxDst,
                 int   cyDst,
                 HDC   hdcSrc,
                 int   xSrc,
                 int   ySrc,
                 int   cxSrc,
                 int   cySrc,
                 UINT  TransColor
                 )

{
    BOOL bRet = TRUE;
    DIBINFO DibInfoDst, DibInfoSrc;
    PDIBINFO pDibInfoDst, pDibInfoSrc;
    BOOL     bReadable;
    //
    // parameter checking
    //

    if (cxDst < 0 || cyDst < 0 || cxSrc < 0 || cySrc < 0)
    {
        WARNING("bad parameters\n");
        return (FALSE);
    }

    pDibInfoDst = &DibInfoDst;
    ZeroMemory (pDibInfoDst, sizeof(DIBINFO));

    if (!bInitDIBINFO (hdcDst, xDst, yDst, cxDst, cyDst, pDibInfoDst))
        return (FALSE);

    pDibInfoSrc = &DibInfoSrc;
    ZeroMemory (pDibInfoSrc, sizeof(DIBINFO));

    if (!bInitDIBINFO (hdcSrc, xSrc, ySrc, cxSrc, cySrc, pDibInfoSrc))
        return (FALSE);

    bRet = bSetupBitmapInfos (pDibInfoDst, pDibInfoSrc);

    if (bRet)
    {
       TransColor = MapTransparentColor (pDibInfoSrc, TransColor);

       bRet =  bGetSrcDIBits(pDibInfoDst, pDibInfoSrc, SOURCE_TRAN, TransColor);

       if (bRet)
       {
          // DST can be printer DC
          if (pDibInfoDst->flag & PRINTER_DC)
          {
              bRet = TRUE;
              bReadable = FALSE;
          }
          else
          {
              bRet = bGetDstDIBits (pDibInfoDst, &bReadable, SOURCE_TRAN);
          }

          if (bRet)
          {
             if (bReadable)
             {
                switch (pDibInfoSrc->pbmi->bmiHeader.biBitCount)
                {
                case 1:
                     // The performance of the 1BPP source case is not critical.  Easiest to
                     // just send it through the printer code path...
                     vTransparentCopyScan (pDibInfoDst, pDibInfoSrc, TransColor);
                     break;

                case 4:
                     if (bSameDIBformat(pDibInfoDst->pbmi,pDibInfoSrc->pbmi))
                     {
                         vTransparentIdentityCopy4 (pDibInfoDst, pDibInfoSrc, TransColor);
                     }
                     else if (pDibInfoDst->pbmi->bmiHeader.biBitCount == 4)
                     {
                         vTransparentS4D4 (pDibInfoDst, pDibInfoSrc, TransColor);
                     }
                     else if (pDibInfoDst->pbmi->bmiHeader.biBitCount == 8)
                     {
                         vTransparentS4D8(pDibInfoDst, pDibInfoSrc, TransColor);
                     }
                     else if (pDibInfoDst->pbmi->bmiHeader.biBitCount == 16)
                     {
                         vTransparentS4D16 (pDibInfoDst, pDibInfoSrc, TransColor);
                     }
                     else if (pDibInfoDst->pbmi->bmiHeader.biBitCount == 24)
                     {
                         vTransparentS4D24 (pDibInfoDst, pDibInfoSrc, TransColor);
                     }
                     else if (pDibInfoDst->pbmi->bmiHeader.biBitCount == 32)
                     {
                         vTransparentS4D32 (pDibInfoDst, pDibInfoSrc, TransColor);
                     }
                     else
                     {   //1
                         vTransparentMapCopy (pDibInfoDst, pDibInfoSrc, TransColor);
                     }
                     break;

                case 8:
                     if (bSameDIBformat(pDibInfoDst->pbmi,pDibInfoSrc->pbmi))
                     {
                         vTransparentIdentityCopy8 (pDibInfoDst, pDibInfoSrc, TransColor);
                     }
                     else if (pDibInfoDst->pbmi->bmiHeader.biBitCount == 8)
                     {
                         vTransparentS8D8 (pDibInfoDst, pDibInfoSrc, TransColor);
                     }
                     else if (pDibInfoDst->pbmi->bmiHeader.biBitCount == 16)
                     {
                        vTransparentS8D16 (pDibInfoDst, pDibInfoSrc, TransColor);
                     }
                     else if (pDibInfoDst->pbmi->bmiHeader.biBitCount == 24)
                     {
                        vTransparentS8D24 (pDibInfoDst, pDibInfoSrc, TransColor);
                     }
                     else if (pDibInfoDst->pbmi->bmiHeader.biBitCount == 32)
                     {
                        vTransparentS8D32 (pDibInfoDst, pDibInfoSrc, TransColor);
                     }
                     else
                     {
                        //1, 4
                        vTransparentMapCopy (pDibInfoDst, pDibInfoSrc, TransColor);
                     }
                     break;

                case 16:
                case 24:
                case 32:
                    vTransparentMapCopy (pDibInfoDst, pDibInfoSrc, TransColor);
                    break;
                      
                default:
                     WARNING ("src format not currently supported\n");
                     bRet = FALSE;
                     goto CleanUp;
                     break;
                }

                //
                // if we have created a temp destination DIB, send the final result to destination
                // Note:  do this only if we haven't called vTransparentCopyScan
                //

                if (pDibInfoSrc->pbmi->bmiHeader.biBitCount != 1)
                {
                    bRet = bSendDIBINFO (hdcDst, pDibInfoDst);
                }
             }
             else
             {
                 //
                 // non-readable dest surface
                 //
                 vTransparentCopyScan (pDibInfoDst, pDibInfoSrc, TransColor);
             }
          }
          else
          {
              WARNING ("GetSrcDIBits failed\n");
              bRet = FALSE;
          }
       }
    }
    else
    {
        WARNING ("GetDstDIBits failed \n");
        bRet = FALSE;
    }
    //
    // clean up
    //
CleanUp:
    vCleanupDIBINFO (pDibInfoDst);
    vCleanupDIBINFO (pDibInfoSrc);


    return (bRet);
}

#endif

BOOL
TransparentBlt(
                 HDC   hdcDest,
                 int   DstX,
                 int   DstY,
                 int   DstCx,
                 int   DstCy,
                 HDC   hSrc,
                 int   SrcX,
                 int   SrcY,
                 int   SrcCx,
                 int   SrcCy,
                 UINT  Color
                 )
{
    BOOL bRet = FALSE;

    bRet = gpfnTransparentBlt(
                      hdcDest,
                      DstX,
                      DstY,
                      DstCx,
                      DstCy,
                      (HDC)hSrc,
                      SrcX,
                      SrcY,
                      SrcCx,
                      SrcCy,
                      Color
                      );

    return(bRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\image\tricalc.cxx ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name

   trimesh.cxx

Abstract:

    Implement triangle mesh API

Author:

   Mark Enstrom   (marke)  23-Jun-1996

Enviornment:

   User Mode

Revision History:

--*/


#include "precomp.hxx"
#include "dciman.h"
#pragma hdrstop

#if !(_WIN32_WINNT >= 0x500)

/******************************Public*Routine******************************\
* vHorizontalLine
*   
*   Record information for horizontal line.
*   Colors are recorded as fixed point 8.56
*
* Arguments:
*
*   pv1      - vertex 1
*   pv2      - vertex 2
*   ptData   - triangle data
*   ptridda  - dda data
*
* Return Value:
*
*   none
*
* History:
*
*    11/20/1996 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vHorizontalLine(
    PTRIVERTEX    pv1,
    PTRIVERTEX    pv2,
    PTRIANGLEDATA ptData,
    PTRIDDA       ptridda
    )
{
    LONG yPosition = ptridda->N0;
    LONG yIndex    = yPosition - ptData->y0;

    //
    // check if this line is whithin clipping in y
    //

    if (
         (yPosition >= ptData->rcl.top)   &&
         (yPosition < ptData->rcl.bottom)
       )
    {
       //
       // find left edge
       //

       if (pv1->x <= pv2->x)
       {
            //
            // left edge
            //

            ptData->TriEdge[yIndex].xLeft   = pv1->x;
            ptData->TriEdge[yIndex].llRed   = ((LONGLONG)pv1->Red)   << 48;
            ptData->TriEdge[yIndex].llGreen = ((LONGLONG)pv1->Green) << 48;
            ptData->TriEdge[yIndex].llBlue  = ((LONGLONG)pv1->Blue)  << 48;
            ptData->TriEdge[yIndex].llAlpha = ((LONGLONG)pv1->Alpha) << 48;

            //
            // right edge
            //

            ptData->TriEdge[yIndex].xRight = pv2->x;
       }
       else
       {
            //
            // left edge
            //

            ptData->TriEdge[yIndex].xLeft   = pv2->x;
            ptData->TriEdge[yIndex].llRed   = pv2->Red   << 48;
            ptData->TriEdge[yIndex].llGreen = pv2->Green << 48;
            ptData->TriEdge[yIndex].llBlue  = pv2->Blue  << 48;
            ptData->TriEdge[yIndex].llAlpha = pv2->Alpha << 48;

            //
            // right edge
            //

            ptData->TriEdge[yIndex].xRight = pv1->x;
        }
    }
}

/******************************Public*Routine******************************\
* vEdgeDDA
*
*   Run line DDA down an edge of the triangle recording edge
*   position and color
*
* Arguments:
*
*   ptData  - triangle data
*   ptridda - line dda information
*
* Return Value:
*
*   None
*
* History:
*
*    11/20/1996 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vEdgeDDA(
     PTRIANGLEDATA ptData,
     PTRIDDA       ptridda
     )
{
    LONG NumScanLines = ptridda->NumScanLines;
    LONG yIndex       = ptridda->yIndex;
    LONGLONG llRed    = ptridda->llRed;
    LONGLONG llGreen  = ptridda->llGreen;
    LONGLONG llBlue   = ptridda->llBlue;
    LONGLONG llAlpha  = ptridda->llAlpha;
    LONG L            = ptridda->L;
    LONG Rb           = ptridda->Rb;

    //
    // Scan all lines, only record lines contained by
    // the clipping in ptData->rcl (y)
    //

    while (NumScanLines--)
    {
        //
        // check for and record left edge
        //

        if (yIndex >= 0)
        {
            if (L < ptData->TriEdge[yIndex].xLeft)
            {
                ptData->TriEdge[yIndex].xLeft   = L;
                ptData->TriEdge[yIndex].llRed   = llRed;
                ptData->TriEdge[yIndex].llGreen = llGreen;
                ptData->TriEdge[yIndex].llBlue  = llBlue;
                ptData->TriEdge[yIndex].llAlpha = llAlpha;
            }

            if (L > ptData->TriEdge[yIndex].xRight)
            {
                ptData->TriEdge[yIndex].xRight = L;
            }
        }

        //
        // inc y by one scan line, inc x(L) by integer step
        // and inc error term by dR
        //

        yIndex++;

        L  += ptridda->dL;
        Rb -= ptridda->dR;

        //
        // inc color components by y and integer x components
        //

        llRed   += (ptridda->lldxyRed);
        llGreen += (ptridda->lldxyGreen);
        llBlue  += (ptridda->lldxyBlue);
        llAlpha += (ptridda->lldxyAlpha);

        //
        // check for DDA error term overflow, add one
        // more step in x and color if true, 
        // and correct error term
        //

        if (Rb < 0)
        {
            //
            // fraction step in x
            //

            L += ptridda->Linc;

            //
            // fraction step in color components
            //

            llRed   += ptData->lldRdX;
            llGreen += ptData->lldGdX;
            llBlue  += ptData->lldBdX;
            llAlpha += ptData->lldAdX;

            //
            // adjust error term
            //

            Rb += ptridda->dN;
        }
    }
}

/******************************Public*Routine******************************\
* vCalulateLine
*
*   calculate bounding line
*
* Arguments:
*
*   pv1    - vertex 1
*   pv2    - vertex 2
*   ptData - triangle data
*
* Return Value:
*
*   none
*
* History:
*
*    11/20/1996 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vCalculateLine(
    PTRIVERTEX      pv1,
    PTRIVERTEX      pv2,
    PTRIANGLEDATA   ptData
    )
{
    TRIDDA tridda;

    //
    // initial y component
    //

    tridda.lldxyRed   = ptData->lldRdY;
    tridda.lldxyGreen = ptData->lldGdY;
    tridda.lldxyBlue  = ptData->lldBdY;
    tridda.lldxyAlpha = ptData->lldAdY;

    //
    // N0 = integer y starting location
    // M0 = integer x starting location
    // dN = integer delta y
    // dM = integer delta x
    //
    // Arrange lines, must run DDA in positive delta y.
    //

    if (pv2->y >= pv1->y)
    {
        tridda.dN      = pv2->y - pv1->y;
        tridda.dM      = pv2->x - pv1->x;
        tridda.N0      = pv1->y;
        tridda.M0      = pv1->x;
    }
    else
    {
        tridda.dN       = pv1->y - pv2->y;
        tridda.dM       = pv1->x - pv2->x;
        tridda.N0       = pv2->y;
        tridda.M0       = pv2->x;
    }

    //
    // caclulate initial color value at stating vertex
    //

    tridda.llRed   = ptData->lldRdY * (tridda.N0 - ptData->ptColorCalcOrg.y) +
                     ptData->lldRdX * (tridda.M0 - ptData->ptColorCalcOrg.x) +    
                     ptData->llRA;
    
    tridda.llGreen = ptData->lldGdY * (tridda.N0 - ptData->ptColorCalcOrg.y) +
                     ptData->lldGdX * (tridda.M0 - ptData->ptColorCalcOrg.x) +    
                     ptData->llGA;
 
    tridda.llBlue  = ptData->lldBdY * (tridda.N0 - ptData->ptColorCalcOrg.y) +
                     ptData->lldBdX * (tridda.M0 - ptData->ptColorCalcOrg.x) +    
                     ptData->llBA;
 
    tridda.llAlpha = ptData->lldAdY * (tridda.N0 - ptData->ptColorCalcOrg.y) +
                     ptData->lldAdX * (tridda.M0 - ptData->ptColorCalcOrg.x) +    
                     ptData->llAA;
                 
    //
    // Check for horizontal line, dN == 0 is a horizontal line.
    // In this case just record the end points.
    //

    if (tridda.dN == 0)
    {
        vHorizontalLine(pv1,pv2,ptData,&tridda);
    }
    else
    {
        LONGLONG l0,Frac;

        tridda.Linc = 1;

        //
        // yIndex is the offset into the edge array for
        // the current line. Calc number of scan lines
        // and maximum y position
        //

        tridda.yIndex = tridda.N0 - ptData->y0;

        tridda.NumScanLines = tridda.dN;

        LONG NMax   = tridda.N0 + tridda.NumScanLines;

        //
        // make sure scan lines do not overrun buffer due to
        // clipping
        //

        if (
             (tridda.N0 > ptData->rcl.bottom) ||
             (NMax < ptData->rcl.top)
           )
        {
            //
            // nothing to draw
            // 

            return;
        }
        else if (NMax > ptData->rcl.bottom)
        {
            //
            // clipped number of scan lines !!! only clipped against bottom, what about top !!!
            //

            tridda.NumScanLines = tridda.NumScanLines - (NMax - ptData->rcl.bottom);
        }

        tridda.j = tridda.N0;

        tridda.C = ((LONGLONG)tridda.M0 * (LONGLONG)tridda.dN) - ((LONGLONG)tridda.N0 * (LONGLONG)tridda.dM) -1;

        tridda.C = tridda.C + tridda.dN;

        LONGLONG LongL;

        if (tridda.dM > 0)
        {
            tridda.dL = tridda.dM / tridda.dN;
            tridda.dR = tridda.dM - tridda.dL * tridda.dN;
        }
        else if (tridda.dM < 0)
        {
            //
            // negative divide
            //

            LONG dLQ,dLR;

            tridda.dM = -tridda.dM;

            dLQ = (tridda.dM - 1) / tridda.dN;
            dLR = tridda.dM - 1 - (dLQ * tridda.dN);
            tridda.dL  = -(dLQ + 1);
            tridda.dR  = tridda.dN - dLR - 1;
        }
        else
        {
            //
            // dM = 0
            //

            tridda.dL = 0;
            tridda.dR = 0;
        }

        l0    = tridda.j * tridda.dL;
        LongL = tridda.j * tridda.dR + tridda.C;

        if (LongL > 0)
        {
            Frac = (LONG)(LongL/tridda.dN);
        }
        else if (LongL < 0)
        {
            LONGLONG Q = ((-LongL - 1)/tridda.dN);
            Frac = -(Q + 1);
        }
        else
        {
            Frac = 0;
        }

        tridda.R  = (LONG)(LongL - (Frac * tridda.dN));
        tridda.L  = (LONG)(l0 + Frac);
        tridda.Rb = tridda.dN - tridda.R - 1;

        //
        // Calculate color steps for dx
        //

        tridda.lldxyRed   = tridda.lldxyRed   + (ptData->lldRdX * tridda.dL);
        tridda.lldxyGreen = tridda.lldxyGreen + (ptData->lldGdX * tridda.dL); 
        tridda.lldxyBlue  = tridda.lldxyBlue  + (ptData->lldBdX * tridda.dL);
        tridda.lldxyAlpha = tridda.lldxyAlpha + (ptData->lldAdX * tridda.dL);

        //
        // run edge dda
        //

        vEdgeDDA(ptData,&tridda);
    }
}

/**************************************************************************\
* bCalulateColorGradient
*
*   Calculate all color gradients    
*   
* Arguments:
*   
*   pv0,pv1,pv2 - triangle verticies
*   ptData      - triangel data
*
* Return Value:
*   
*   status
*
* History:
*
*    5/22/1997 Kirk Olnyk [kirko]
*
\**************************************************************************/

BOOL
bCalulateColorGradient(
    PTRIVERTEX      pv0,
    PTRIVERTEX      pv1,
    PTRIVERTEX      pv2,
    PTRIANGLEDATA   ptData
    )
{
    GRADSTRUCT g;
    LONGLONG d;
    LONG z;

    g.x1 = pv1->x;
    g.y1 = pv1->y;
    g.x2 = pv2->x;
    g.y2 = pv2->y;

    z = pv0->x;
    g.x1 -= z;
    g.x2 -= z;

    z = pv0->y;
    g.y1 -= z;
    g.y2 -= z;

    g.d  = g.x1 * g.y2 - g.x2 * g.y1;

    LONG tx = MIN(g.x1,0);
    LONG ty = MIN(g.y1,0);

    g.m = MIN(tx,g.x2) + MIN(ty,g.y2);

    d = (LONGLONG) ABS(g.d);
    g.Q = (LONGLONG)TWO_TO_THE_48TH / d;
    g.R = (LONGLONG)TWO_TO_THE_48TH % d;

    ptData->ptColorCalcOrg.x = pv0->x;
    ptData->ptColorCalcOrg.y = pv0->y;

    bDoGradient(  &ptData->lldRdX   // &A
                , &ptData->lldRdY   // &B
                , &ptData->llRA     // &C
                , pv0->Red          // R0
                , pv1->Red          // R1
                , pv2->Red          // R2
                , &g             );

    bDoGradient(  &ptData->lldGdX
                , &ptData->lldGdY
                , &ptData->llGA
                , pv0->Green
                , pv1->Green
                , pv2->Green
                , &g             );

    bDoGradient(  &ptData->lldBdX
                , &ptData->lldBdY
                , &ptData->llBA
                , pv0->Blue
                , pv1->Blue
                , pv2->Blue
                , &g             );


    bDoGradient(  &ptData->lldAdX
                , &ptData->lldAdY
                , &ptData->llAA
                , pv0->Alpha
                , pv1->Alpha
                , pv2->Alpha
                , &g             );

    return(TRUE);
}

/**************************************************************************\
* MDiv64
*   64 bit mul-div
*   
* Arguments:
*   
*   return = (a * b) / c
*
* Return Value:
*
*
*
* History:
*
*    5/22/1997 Kirk Olnyk [kirko]
*
\**************************************************************************/

LONGLONG 
MDiv64(
    LONGLONG a, 
    LONGLONG b, 
    LONGLONG c)
{
    LONGLONG Result;
    int isNegative=0;

    Result = 0;
    if (a != 0 && b != 0)
    {
        if (a < 0)
        {
            a = -a;
            isNegative = 1;
        }
        else if (b < 0)
        {
            b = -b;
            isNegative = 1;
        }
        a = a * b - (LONGLONG) isNegative;
        Result = a / c;
        if (isNegative)
        {
            Result = - Result - 1;
        }
    }
    return(Result);
}

/**************************************************************************\
* bDoGradient
*   
*   calc color gradient for one color
*   
* Arguments:
*   
*   pA
*   pB
*   pC
*   g0
*   g1
*   g2 
*   pg
*
* Return Value:
*
*   status
*
* History:
*
*    5/22/1997 Kirk Olnyk   [kirko]
*
\**************************************************************************/

BOOL
bDoGradient(
    LONGLONG *pA,
    LONGLONG *pB,
    LONGLONG *pC,
    LONG g0,
    LONG g1,
    LONG g2,
    GRADSTRUCT *pg
    )
{
    BOOL bDiv(LONGLONG*, LONGLONG, LONG);
    LONGLONG a,b,c,d;

    g1 = g1 - g0;
    g2 = g2 - g0;

    a = g1 * pg->y2 - g2 * pg->y1;
    b = g2 * pg->x1 - g1 * pg->x2;
    d = pg->d;

    if (d < 0)
    {
        a = -a;
        b = -b;
        d = -d;
    }

    *pA = pg->Q * a + MDiv64(a, pg->R, d);
    *pB = pg->Q * b + MDiv64(b, pg->R, d);

    c = (d >> 1) + 1;
    a = c * pg->R - pg->m - 1;
    a /= d;
    a += c * pg->Q;
    a += pg->m;

    *pC = a + (((LONGLONG) g0) << 48);
    return(TRUE);
}

/**************************************************************************\
* lCalculateTriangleArea
*
* Arguments:
*
*  pv0    - vertex
*  pv1    - vertex 
*  pv2    - vertex 
*  ptData - triangle data
*   
* Return Value:
*
*    < 0 = negative area
*    0   = 0 area
*    > 0 = positive area
*
* History:
*
*    2/26/1997 Mark Enstrom [marke]
*
\**************************************************************************/

LONG
lCalculateTriangleArea(
    PTRIVERTEX      pv0,
    PTRIVERTEX      pv1,
    PTRIVERTEX      pv2,
    PTRIANGLEDATA   ptData
    )
{
    LONG lRet;

    //
    // calc area, color gradients in x,y
    //
    // area = (v2-v0) X (v1 - v2)
    //

    LONGLONG v12x = pv1->x - pv2->x;
    LONGLONG v12y = pv1->y - pv2->y;

    LONGLONG v02x = pv0->x - pv2->x;
    LONGLONG v02y = pv0->y - pv2->y;

    LONGLONG Area = (v12y * v02x) - (v12x * v02y);

    if (Area == 0)
    {
        lRet = 0;
    }
    else if (Area > 0)
    {
        lRet = 1;

        if (ptData != NULL)
        {
            ptData->Area = Area;
        }
    }
    else
    {
        lRet = -1;
    }

    return(lRet);
}


/**************************************************************************\
* LIMIT_COLOR
*
*   Actual input colors are limited to 0x0000 - 0xff00
*       256 * (0x00 - 0xff)
*
* Arguments:
*   
*   pv - vertex
*
* History:
*
*    2/26/1997 Mark Enstrom [marke]
*
\**************************************************************************/

#define LIMIT_COLOR(pv)        \
                               \
    if (pv->Red > 0xff00)      \
    {                          \
        pv->Red = 0xff00;      \
    }                          \
                               \
    if (pv->Green > 0xff00)    \
    {                          \
        pv->Green = 0xff00;    \
    }                          \
                               \
    if (pv->Blue > 0xff00)     \
    {                          \
        pv->Blue = 0xff00;     \
    }                          


/**************************************************************************\
* bIsTriangleInBounds
*   
*   Is triangle inside bounding rect   
*
* Arguments:
*   
*   pInV0  - vertex 0 
*   pInV1  - vertex 1
*   pInV2  - vertex 2
*   ptData - triangle data
*
* Return Value:
*   
*   TRUE in any of the triangle is contained in bounding rect
*
* History:
*
*    5/8/1997 Mark Enstrom [marke]
*
\**************************************************************************/

BOOL
bIsTriangleInBounds(
    PTRIVERTEX      pInV0,
    PTRIVERTEX      pInV1,
    PTRIVERTEX      pInV2,
    PTRIANGLEDATA   ptData
    )
{
    PRECTL prclClip = &ptData->rcl;

    RECTL  rclTri;

    rclTri.left   = MIN(pInV0->x,pInV1->x);
    rclTri.right  = MAX(pInV0->x,pInV1->x); 
    rclTri.top    = MIN(pInV0->y,pInV1->y);
    rclTri.bottom = MAX(pInV0->y,pInV1->y); 

    rclTri.left   = MIN(rclTri.left,pInV2->x); 
    rclTri.right  = MAX(rclTri.right,pInV2->x); 
    rclTri.top    = MIN(rclTri.top,pInV2->y); 
    rclTri.bottom = MAX(rclTri.bottom,pInV2->y); 

    if ((rclTri.left   >= prclClip->right) ||
        (rclTri.right  <= prclClip->left)  ||
        (rclTri.top    >= prclClip->bottom) ||
        (rclTri.bottom <= prclClip->top))
    {
        return(FALSE);
    }

    return(TRUE);
}

/**************************************************************************\
* bTriangleNeedSplit
*   determine whether triangle needs split
*   
* Arguments:
*   
*   pv0,pv1,pv2 - triangle vertex
*
* Return Value:
*   
*   TRUE if triangle needs to be split
*
* History:
*
*    5/8/1997 Mark Enstrom [marke]
*
\**************************************************************************/

BOOL
bTriangleNeedsSplit(
    PTRIVERTEX      pv0,
    PTRIVERTEX      pv1,
    PTRIVERTEX      pv2
    )
{
    //
    // calc dx,dy for each leg
    //

    LONG dx01 = ABS(pv0->x - pv1->x);
    LONG dy01 = ABS(pv0->y - pv1->y);

    LONG dx02 = ABS(pv0->x - pv2->x);
    LONG dy02 = ABS(pv0->y - pv2->y);

    LONG dx12 = ABS(pv1->x - pv2->x);
    LONG dy12 = ABS(pv1->y - pv2->y);

    //
    // if any length is longer than max, break triangle into two pieces
    // and call this routine for each
    //

    if ( 
         (
           (dx01 > MAX_EDGE_LENGTH) || (dy01 > MAX_EDGE_LENGTH) ||
           (dx02 > MAX_EDGE_LENGTH) || (dy02 > MAX_EDGE_LENGTH) || 
           (dx12 > MAX_EDGE_LENGTH) || (dy12 > MAX_EDGE_LENGTH)
         )
       )
    {
        return(TRUE);
    }
    
    return(FALSE);
}

/**************************************************************************\
* bSplitTriangle
*   Determine is triangle must be split. 
*   Split triangle along longest edge
*   
* Arguments:
*   
*   pv0,pv1,pv2 - triangle
*   pvNew       - new vertex
*   pGrad       - mesh
*
* Return Value:
*
*   TRUE if split, FALSE otherwise
*
* History:
*
*    5/8/1997 Mark Enstrom [marke]
*
\**************************************************************************/

BOOL
bSplitTriangle(
    PTRIVERTEX           pVert,
    PULONG               pFreeVert,
    PGRADIENT_TRIANGLE   pMesh,
    PULONG               pFreeMesh,
    PULONG               pRecurseLevel
    )
{
    BOOL bStatus = FALSE;

    ULONG CurrentMesh = (*pFreeMesh) - 1;

    ULONG ulTM0 = pMesh[CurrentMesh].Vertex1;
    ULONG ulTM1 = pMesh[CurrentMesh].Vertex2;
    ULONG ulTM2 = pMesh[CurrentMesh].Vertex3;

    PTRIVERTEX         pv0 = &pVert[ulTM0];
    PTRIVERTEX         pv1 = &pVert[ulTM1]; 
    PTRIVERTEX         pv2 = &pVert[ulTM2]; 

    PTRIVERTEX         pvT0 = pv0;
    PTRIVERTEX         pvT1 = pv1;
    PTRIVERTEX         pvT2 = pv2;

    TRIVERTEX          triNew;

    //
    // find longest edge
    //
    
    LONGLONG dx01 = ABS(pv0->x - pv1->x);
    LONGLONG dy01 = ABS(pv0->y - pv1->y);
    
    LONGLONG dx02 = ABS(pv0->x - pv2->x);
    LONGLONG dy02 = ABS(pv0->y - pv2->y);
    
    LONGLONG dx12 = ABS(pv1->x - pv2->x);
    LONGLONG dy12 = ABS(pv1->y - pv2->y);

    //
    // determine if triangle needs to be split
    //

    if ( 
         (
           (dx01 > MAX_EDGE_LENGTH) || (dy01 > MAX_EDGE_LENGTH) ||
           (dx02 > MAX_EDGE_LENGTH) || (dy02 > MAX_EDGE_LENGTH) || 
           (dx12 > MAX_EDGE_LENGTH) || (dy12 > MAX_EDGE_LENGTH)
         )
       )
    {
        //
        // make sure this is a triangle
        //

        if (lCalculateTriangleArea(pv0,pv1,pv2,NULL) != 0)
        {
            //
            // Find longest edge, swap verticies so edge 0-1 is
            // longest.
            //
            
            LONGLONG d01Max = dx01 * dx01 + dy01 * dy01;
            LONGLONG d02Max = dx02 * dx02 + dy02 * dy02;
            LONGLONG d12Max = dx12 * dx12 + dy12 * dy12;

            if (d01Max > d02Max)
            {
                if (d01Max > d12Max)
                {
                    //
                    // d01 largest, default
                    //

                }
                else
                {
                    //
                    // d12 largest, swap 0 and 2
                    //
            
                    pvT0  = pv2;
                    pvT2  = pv0;
                    ulTM0 = pMesh[CurrentMesh].Vertex3; 
                    ulTM2 = pMesh[CurrentMesh].Vertex1; 
                }
            }
            else
            {
                if (d02Max > d12Max)
                {
                    //
                    // d02 largest, swap 1,2
                    //
            
                    pvT1  = pv2;
                    pvT2  = pv1;
                    ulTM1 = pMesh[CurrentMesh].Vertex3; 
                    ulTM2 = pMesh[CurrentMesh].Vertex2; 
                }
                else
                {
                    //
                    // d12 largest, swap 0,2
                    //
            
                    pvT0  = pv2;
                    pvT2  = pv0;
                    ulTM0 = pMesh[CurrentMesh].Vertex3; 
                    ulTM2 = pMesh[CurrentMesh].Vertex1; 
                }
            }
            
            //
            // 2 new triangles 0,2,N and 1,2,N  (float)
            //
            
            triNew.x = pvT0->x + ((pvT1->x - pvT0->x)/2);
            triNew.y = pvT0->y + ((pvT1->y - pvT0->y)/2);
        
            triNew.Red   = pvT0->Red   + ((pvT1->Red   - pvT0->Red  )/2);
            triNew.Green = pvT0->Green + ((pvT1->Green - pvT0->Green)/2);
            triNew.Blue  = pvT0->Blue  + ((pvT1->Blue  - pvT0->Blue )/2);
            triNew.Alpha = pvT0->Alpha + ((pvT1->Alpha - pvT0->Alpha)/2);
        
            //
            // add new entry to vertex array and two new entries to mesh array
            //
            // 0,2,New and 1,2,New
            //
    
            ULONG FreeVert = *pFreeVert;
            ULONG FreeMesh = *pFreeMesh;
    
            pVert[FreeVert] = triNew;
    
            pMesh[FreeMesh].Vertex1   = ulTM0;
            pMesh[FreeMesh].Vertex2   = ulTM2;
            pMesh[FreeMesh].Vertex3   = FreeVert;
    
            pMesh[FreeMesh+1].Vertex1 = ulTM1;
            pMesh[FreeMesh+1].Vertex2 = ulTM2;
            pMesh[FreeMesh+1].Vertex3 = FreeVert;
    
            pRecurseLevel[FreeMesh]   = 1;
            pRecurseLevel[FreeMesh+1] = 0;
    
            *pFreeMesh += 2;
            *pFreeVert += 1;
    
            bStatus = TRUE;
        }
        else
        {
            WARNING("bSplitTriangle:Error: triangle area = 0\n\n");
        }
    }

    return(bStatus);
}

/******************************Public*Routine******************************\
* bCalculateAndDrawTriangle
*
*   if triangle is too largre, break it in into 2 triangles and call this
*   routine on each
*
*   Calculate color gradients, then scan the three lines that make up the
*   triangle. Fill out a structure that can later be used to fill in the
*   interior of the triangle.
*
* Arguments:
*
*   pSurfDst - destination surface
*   pInV0    - vertex
*   pInV1    - vertex
*   pInV2    - vertex
*   ptData   - triangle data
*   pfnG     - surface gradient draw routine
*
* Return Value:
*
*   status
*
* History:
*
*    17-Jul-1996 -by- Mark Enstrom [marke]
*
\**************************************************************************/

BOOL
bCalculateAndDrawTriangle(
    PDIBINFO        pDibDst,
    PTRIVERTEX      pInV0,
    PTRIVERTEX      pInV1,
    PTRIVERTEX      pInV2,
    PTRIANGLEDATA   ptData,
    PFN_TRIFILL     pfnG
    )
{
    BOOL        bStatus = TRUE;
    LONG        index;
    LONG        lStatus;
    PTRIVERTEX  pv0 = pInV0;
    PTRIVERTEX  pv1 = pInV1;
    PTRIVERTEX  pv2 = pInV2;

    {
        PTRIVERTEX pvt;

        //
        // sort in y for line processing
        //

        if (pv0->y > pv1->y)
        {
            SWAP_VERTEX(pv0,pv1,pvt);
        }

        if (pv1->y > pv2->y)
        {
            SWAP_VERTEX(pv1,pv2,pvt);
        }

        if (pv0->y > pv1->y)
        {
            SWAP_VERTEX(pv0,pv1,pvt);
        }
    
        lStatus = lCalculateTriangleArea(pv0,pv1,pv2,ptData);
    
        //
        // if area is zero then this is a degenerate triangle
        //
    
        if (lStatus == 0)
        {
            return(FALSE);
        }
        else if (lStatus <0)
        {
            //
            // negative area, swap pv1 and pv2 and recalcualte
            //
    
            SWAP_VERTEX(pv1,pv2,pvt);

            lStatus = lCalculateTriangleArea(pv0,pv1,pv2,ptData);
    
            if (lStatus == 0)
            {
                return(FALSE);
            }
            else if (lStatus <0)
            {
                WARNING1("Triangle Area still negative after vertex swap\n");
                return(FALSE);
            }
        }
    
        //
        // calc min and max drawing y
        //
    
        ptData->y0   = MAX(pv0->y,ptData->rcl.top);
        LONG MaxY    = MAX(pv1->y,pv2->y);
        ptData->y1   = MIN(MaxY,ptData->rcl.bottom);
    
        {
            //
            // init ptdata
            //
    
            LONG lIndex;
    
            for (lIndex=0;lIndex<(ptData->y1-ptData->y0);lIndex++)
            {
                ptData->TriEdge[lIndex].xLeft  = LONG_MAX;
                ptData->TriEdge[lIndex].xRight = LONG_MIN;
            }
        }
    
        //
        // calculate color gradients for each color. There is a little redundant
        // work here with calculation of deltas. Should make this one call or
        // do it in place.
        //
    
        LIMIT_COLOR(pv0);
        LIMIT_COLOR(pv1);
        LIMIT_COLOR(pv2);
    
        bCalulateColorGradient(pv0,pv1,pv2,ptData);
    
        //
        // draw lines into data array
        //
    
        vCalculateLine(pv0,pv1,ptData);
        vCalculateLine(pv1,pv2,ptData);
        vCalculateLine(pv2,pv0,ptData);
    
        pfnG(pDibDst,ptData);
    }

    return(bStatus);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\image\trimesh.cxx ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name

   trimesh.cxx

Abstract:

    Implement triangle mesh API

Author:

   Mark Enstrom   (marke)  23-Jun-1996

Enviornment:

   User Mode

Revision History:

--*/


#include "precomp.hxx"
#include "dciman.h"
#pragma hdrstop

extern PFNGRFILL gpfnGradientFill;

#if !(_WIN32_WINNT >= 0x500)

/**************************************************************************\
*  bCalcGradientRectOffsets
*
*   quick summary of gradient rect drawing bounds
*
* Arguments:
*
*   pGradRect - gradient rect data
*
* Return Value:
*
*   status
*
* History:
*
*    2/14/1997 Mark Enstrom [marke]
*
\**************************************************************************/

BOOL
bCalcGradientRectOffsets(
    PGRADIENTRECTDATA pGradRect
    )
{
    LONG yScanTop     = MAX(pGradRect->rclClip.top,pGradRect->rclGradient.top);
    LONG yScanBottom  = MIN(pGradRect->rclClip.bottom,pGradRect->rclGradient.bottom);
    LONG yScanLeft    = MAX(pGradRect->rclClip.left,pGradRect->rclGradient.left);
    LONG yScanRight   = MIN(pGradRect->rclClip.right,pGradRect->rclGradient.right);

    //
    // calc actual widht, check for early out
    //

    pGradRect->ptDraw.x = yScanLeft;
    pGradRect->ptDraw.y = yScanTop;
    pGradRect->szDraw.cx = yScanRight  - yScanLeft;
    pGradRect->szDraw.cy = yScanBottom - yScanTop;

    LONG ltemp = pGradRect->rclClip.left - pGradRect->rclGradient.left;

    if (ltemp <= 0)
    {
        ltemp = 0;
    }

    pGradRect->xScanAdjust  = ltemp;

    ltemp = pGradRect->rclClip.top  - pGradRect->rclGradient.top;

    if (ltemp <= 0)
    {
        ltemp = 0;
    }

    pGradRect->yScanAdjust = ltemp;

    return((pGradRect->szDraw.cx > 0) && (pGradRect->szDraw.cy > 0));
}


/******************************Public*Routine******************************\
* pfnGradientRectFillFunction
*
*   look at format to decide if DIBSection should be drawn directly
*
*    32 bpp RGB
*    32 bpp BGR
*    24 bpp
*    16 bpp 565
*    16 bpp 555
*
* Trangles are only filled in high color (no palette) surfaces
*
* Arguments:
*
*   pDibInfo - information about destination surface
*
* Return Value:
*
*   PFN_GRADRECT - triangle filling routine
*
* History:
*
*    12/6/1996 Mark Enstrom [marke]
*
\**************************************************************************/

PFN_GRADRECT
pfnGradientRectFillFunction(
    PDIBINFO pDibInfo
    )
{
    PFN_GRADRECT pfnRet = NULL;

    PULONG pulMasks = (PULONG)&pDibInfo->pbmi->bmiColors[0];

    //
    // 32 bpp RGB
    //

    if (
         (pDibInfo->pbmi->bmiHeader.biBitCount    == 32) &&
         (pDibInfo->pbmi->bmiHeader.biCompression == BI_RGB)
       )
    {
        pfnRet = vFillGRectDIB32BGRA;
    }

    else if (
         (pDibInfo->pbmi->bmiHeader.biBitCount    == 32) &&
         (pDibInfo->pbmi->bmiHeader.biCompression == BI_BITFIELDS) &&
         (pulMasks[0]   == 0xff0000)           &&
         (pulMasks[1]   == 0x00ff00)           &&
         (pulMasks[2]   == 0x0000ff)
       )
    {
        pfnRet = vFillGRectDIB32BGRA;
    }

    else if (
         (pDibInfo->pbmi->bmiHeader.biBitCount    == 32) &&
         (pDibInfo->pbmi->bmiHeader.biCompression == BI_BITFIELDS) &&
         (pulMasks[0]   == 0x0000ff)           &&
         (pulMasks[1]   == 0x00ff00)           &&
         (pulMasks[2]   == 0xff0000)
       )
    {
        pfnRet = vFillGRectDIB32RGB;
    }

    else if (
         (pDibInfo->pbmi->bmiHeader.biBitCount    == 24) &&
         (pDibInfo->pbmi->bmiHeader.biCompression == BI_RGB)
       )
    {
        pfnRet = vFillGRectDIB24RGB;
    }

    //
    // 16 BPP
    //

    else if (
         (pDibInfo->pbmi->bmiHeader.biBitCount    == 16) &&
         (pDibInfo->pbmi->bmiHeader.biCompression == BI_BITFIELDS)
       )
    {

        //
        // 565,555
        //

        if (
             (pulMasks[0]   == 0xf800)           &&
             (pulMasks[1]   == 0x07e0)           &&
             (pulMasks[2]   == 0x001f)
           )
        {
            pfnRet = vFillGRectDIB16_565;
        }
        else if (
            (pulMasks[0]   == 0x7c00)           &&
            (pulMasks[1]   == 0x03e0)           &&
            (pulMasks[2]   == 0x001f)
          )
       {
           pfnRet = vFillGRectDIB16_555;
       }
    }
    else
    {
        pfnRet = vFillGRectDIB32Direct;
    }

    return(pfnRet);
}


/**************************************************************************\
* DIBGradientRect
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    2/11/1997 Mark Enstrom [marke]
*
\**************************************************************************/

BOOL
DIBGradientRect(
    HDC            hdc,
    PTRIVERTEX     pVertex,
    ULONG          nVertex,
    PGRADIENT_RECT pMesh,
    ULONG          nMesh,
    ULONG          ulMode,
    PRECTL         prclPhysExt,
    PDIBINFO       pDibInfo,
    PPOINTL        pptlDitherOrg
    )
{
    BOOL          bStatus = TRUE;
    PFN_GRADRECT  pfnGradRect = NULL;
    ULONG         ulIndex;

    pfnGradRect = pfnGradientRectFillFunction(pDibInfo);

    if (pfnGradRect == NULL)
    {
        WARNING("DIBGradientRect:Can't draw to surface\n");
        return(TRUE);
    }

    //
    // work in physical map mode, restore before return
    //

    ULONG OldMode = SetMapMode(hdc,MM_TEXT);

    //
    // fake up scale !!!
    //

    for (ulIndex=0;ulIndex<nVertex;ulIndex++)
    {
        pVertex[ulIndex].x = pVertex[ulIndex].x * 16;
        pVertex[ulIndex].y = pVertex[ulIndex].y * 16;
    }

    //
    // limit rectangle output to clipped output
    //

    LONG dxRect = prclPhysExt->right  - prclPhysExt->left;
    LONG dyRect = prclPhysExt->bottom - prclPhysExt->top;

    //
    // check for clipped out
    //

    if ((dyRect > 0) && (dxRect > 0))
    {
        GRADIENTRECTDATA grData;

        //
        // clip output
        //

        grData.rclClip = *prclPhysExt;
        grData.ptDitherOrg = *pptlDitherOrg;

        for (ulIndex=0;ulIndex<nMesh;ulIndex++)
        {
            ULONG ulRect0 = pMesh[ulIndex].UpperLeft;
            ULONG ulRect1 = pMesh[ulIndex].LowerRight;

            //
            // make sure index are in array
            //

            if (
                 (ulRect0 > nVertex) ||
                 (ulRect1 > nVertex)
               )
            {
                bStatus = FALSE;
                break;
            }

            TRIVERTEX  tvert0 = pVertex[ulRect0];
            TRIVERTEX  tvert1 = pVertex[ulRect1];
            PTRIVERTEX pv0 = &tvert0;
            PTRIVERTEX pv1 = &tvert1;
            PTRIVERTEX pvt;

            //
            // make sure rectangle endpoints are properly ordered
            //

            if (ulMode == GRADIENT_FILL_RECT_H)
            {
                if (pv0->x > pv1->x)
                {
                    SWAP_VERTEX(pv0,pv1,pvt);
                }

                if (pv0->y > pv1->y)
                {
                    //
                    // must swap y
                    //

                    LONG ltemp = pv1->y;
                    pv1->y = pv0->y;
                    pv0->y = ltemp;

                }
            }
            else
            {
                if (pv0->y > pv1->y)
                {
                    SWAP_VERTEX(pv0,pv1,pvt);
                }


                if (pv0->x > pv1->x)
                {
                    //
                    // must swap x
                    //

                    LONG ltemp = pv1->x;
                    pv1->x = pv0->x;
                    pv0->x = ltemp;
                }
            }

            //
            // gradient definition rectangle
            //

            grData.rclGradient.left   = pv0->x >> 4;
            grData.rclGradient.top    = pv0->y >> 4;

            grData.rclGradient.right  = pv1->x >> 4;
            grData.rclGradient.bottom = pv1->y >> 4;

            LONG dxGrad = grData.rclGradient.right  - grData.rclGradient.left;
            LONG dyGrad = grData.rclGradient.bottom - grData.rclGradient.top;

            //
            // make sure this is not an empty rectangle
            //

            if ((dxGrad > 0) && (dyGrad > 0))
            {
                grData.ulMode  = ulMode;

                //
                // calculate color gradients for x and y
                //

                grData.llRed   = ((LONGLONG)pv0->Red)   << 40;
                grData.llGreen = ((LONGLONG)pv0->Green) << 40;
                grData.llBlue  = ((LONGLONG)pv0->Blue)  << 40;
                grData.llAlpha = ((LONGLONG)pv0->Alpha) << 40;

                if (ulMode == GRADIENT_FILL_RECT_H)
                {

                    grData.lldRdY = 0;
                    grData.lldGdY = 0;
                    grData.lldBdY = 0;
                    grData.lldAdY = 0;

                    LONGLONG lldRed   = (LONGLONG)(pv1->Red)   << 40;
                    LONGLONG lldGreen = (LONGLONG)(pv1->Green) << 40;
                    LONGLONG lldBlue  = (LONGLONG)(pv1->Blue)  << 40;
                    LONGLONG lldAlpha = (LONGLONG)(pv1->Alpha) << 40;

                    lldRed   -= (LONGLONG)(pv0->Red)   << 40;
                    lldGreen -= (LONGLONG)(pv0->Green) << 40;
                    lldBlue  -= (LONGLONG)(pv0->Blue)  << 40;
                    lldAlpha -= (LONGLONG)(pv0->Alpha) << 40;

                    grData.lldRdX = MDiv64(lldRed  ,(LONGLONG)1,(LONGLONG)dxGrad);
                    grData.lldGdX = MDiv64(lldGreen,(LONGLONG)1,(LONGLONG)dxGrad);
                    grData.lldBdX = MDiv64(lldBlue ,(LONGLONG)1,(LONGLONG)dxGrad);
                    grData.lldAdX = MDiv64(lldAlpha,(LONGLONG)1,(LONGLONG)dxGrad);
                }
                else
                {

                    grData.lldRdX = 0;
                    grData.lldGdX = 0;
                    grData.lldBdX = 0;
                    grData.lldAdX = 0;

                    LONGLONG lldRed   = (LONGLONG)(pv1->Red)   << 40;
                    LONGLONG lldGreen = (LONGLONG)(pv1->Green) << 40;
                    LONGLONG lldBlue  = (LONGLONG)(pv1->Blue)  << 40;
                    LONGLONG lldAlpha = (LONGLONG)(pv1->Alpha) << 40;

                    lldRed   -= (LONGLONG)(pv0->Red)   << 40;
                    lldGreen -= (LONGLONG)(pv0->Green) << 40;
                    lldBlue  -= (LONGLONG)(pv0->Blue)  << 40;
                    lldAlpha -= (LONGLONG)(pv0->Alpha) << 40;

                    grData.lldRdY = MDiv64(lldRed  ,(LONGLONG)1,(LONGLONG)dyGrad);
                    grData.lldGdY = MDiv64(lldGreen,(LONGLONG)1,(LONGLONG)dyGrad);
                    grData.lldBdY = MDiv64(lldBlue ,(LONGLONG)1,(LONGLONG)dyGrad);
                    grData.lldAdY = MDiv64(lldAlpha,(LONGLONG)1,(LONGLONG)dyGrad);
                }

                //
                // calculate common offsets
                //

                if (bCalcGradientRectOffsets(&grData))
                {
                    //
                    // call specific drawing routine if output
                    // not totally clipped
                    //

                    (*pfnGradRect)(pDibInfo,&grData);
                }
            }

        }
    }

    SetMapMode(hdc,OldMode);

    return(bStatus);
}


/******************************Public*Routine******************************\
* DIBTriangleMesh
*
*   Draw triangle mesh to surface
*
* Arguments:
*
*   hdc           - dc
*   pVertex       - vertex array
*   nVertex       - elements in vertex array
*   pMesh         - mesh array
*   nMesh         - elements in mesh array
*   ulMode        - drawing mode
*   prclPhysExt   - physical extents
*   prclMeshExt   - unconstrained physical mesh ext
*   pDibInfo      - surface information
*   pptlDitherOrg - dither origin
*   bReadable     - surface readable
*
* Return Value:
*
*   status
*
* History:
*
*   12/4/1996 Mark Enstrom [marke]
*
\**************************************************************************/

BOOL
DIBTriangleMesh(
    HDC                hdc,
    PTRIVERTEX         pVertex,
    ULONG              nVertex,
    PGRADIENT_TRIANGLE pMesh,
    ULONG              nMesh,
    ULONG              ulMode,
    PRECTL             prclPhysExt,
    PRECTL             prclMeshExt,
    PDIBINFO           pDibInfo,
    PPOINTL            pptlDitherOrg,
    BOOL               bReadable
    )
{
    BOOL          bStatus = TRUE;
    RECTL         rclDst;
    RECTL         rclDstWk;
    ULONG         ulIndex;
    PTRIANGLEDATA ptData = NULL;
    PFN_TRIFILL   pfnTriFill = NULL;

    pfnTriFill = pfnTriangleFillFunction(pDibInfo,bReadable);

    if (pfnTriFill == NULL)
    {
        WARNING("DIBTriangleMesh:Can't draw to surface\n");
        return(TRUE);
    }

    //
    // work in physical map mode, restore before return
    //

    ULONG OldMode = SetMapMode(hdc,MM_TEXT);

    //
    // limit recorded triangle to clipped output
    //

    LONG   dxTri = prclPhysExt->right  - prclPhysExt->left;
    LONG   dyTri = prclPhysExt->bottom - prclPhysExt->top;

    //
    // check for clipped out
    //

    if ((dyTri > 0) && (dxTri > 0))
    {
        //
        // allocate structure to hold scan line data for all triangles
        // drawn during this call
        //

        ptData = (PTRIANGLEDATA)LOCALALLOC(sizeof(TRIANGLEDATA) + (dyTri-1) * sizeof(TRIEDGE));

        if (ptData != NULL)
        {
            //
            // Init Global Data
            //

            ptData->rcl         = *prclPhysExt;
            ptData->DrawMode    = ulMode;
            ptData->ptDitherOrg = *pptlDitherOrg;

            //
            // if triangle does not need to be split, draw each one.
            // Triangles need to be split if any edge exceeds a length
            // that will cause math problems.
            //

            if  (
                  ((prclMeshExt->right  - prclMeshExt->left) < MAX_EDGE_LENGTH) &&
                  ((prclMeshExt->bottom - prclMeshExt->top) < MAX_EDGE_LENGTH)
                )
            {
                //
                // no split needed
                //

                ULONG ulIndex;

                for (ulIndex = 0;ulIndex<nMesh;ulIndex++)
                {
                    PTRIVERTEX pv0 = &pVertex[pMesh[ulIndex].Vertex1];
                    PTRIVERTEX pv1 = &pVertex[pMesh[ulIndex].Vertex2];
                    PTRIVERTEX pv2 = &pVertex[pMesh[ulIndex].Vertex3];
    
                    if (bIsTriangleInBounds(pv0,pv1,pv2,ptData))
                    {
                        bStatus = bCalculateAndDrawTriangle(pDibInfo,pv0,pv1,pv2,ptData,pfnTriFill);
                    }
                }
            }
            else
            {
                //
                // some triangles exceed maximum length, need to scan through triangles 
                // and split triangles that exceed maximum edge length. This routine 
                // works in a pseudo recursive manner, by splitting one triangle, then
                // splitting one of those 2 and so on. maximum depth is:
                //
                // 2 * ((log(2)(max dx,dy)) - 10)
                //
                // 10 = log(2) MAX_EDGE_LENGTH (2^14)
                // LOG(2)(2^28) = 28
                // 
                // 2 * (28 - 14) = 28
                //
    
                ULONG              ulMaxVertex = nVertex + 28;
                ULONG              ulMaxMesh   = nMesh   + 28;
                PBYTE              pAlloc      = NULL;
                ULONG              ulSizeAlloc = (sizeof(TRIVERTEX) * ulMaxVertex) + 
                                                 (sizeof(GRADIENT_TRIANGLE) * ulMaxMesh) +
                                                 (sizeof(ULONG) * ulMaxMesh);

                pAlloc = (PBYTE)LOCALALLOC(ulSizeAlloc);

                if (pAlloc != NULL)
                {
                    //
                    // assign buffers
                    // 
        
                    PTRIVERTEX         pTempVertex = (PTRIVERTEX)pAlloc; 
                    PGRADIENT_TRIANGLE pTempMesh   = (PGRADIENT_TRIANGLE)(pAlloc + (sizeof(TRIVERTEX) * ulMaxVertex));
                    PULONG             pRecurse    = (PULONG)((PBYTE)pTempMesh + (sizeof(GRADIENT_TRIANGLE) * ulMaxMesh));

                    //
                    // copy initial triangle information
                    //
        
                    memcpy(pTempVertex,pVertex,sizeof(TRIVERTEX) * nVertex);
                    memcpy(pTempMesh,pMesh,sizeof(TRIVERTEX) * nMesh);
                    memset(pRecurse,0,nMesh * sizeof(ULONG));

                    //
                    // next free location in vertex and mesh arrays
                    //
        
                    ULONG FreeVertex    = nVertex;
                    ULONG FreeMesh      = nMesh;

                    do
                    {
                        BOOL bSplit = FALSE;

                        //
                        // always operate on the last triangle in array
                        //
        
                        ULONG CurrentMesh = FreeMesh - 1;

                        ASSERTGDI(CurrentMesh >= 0,"bTriangleMesh: Error in CurrentMesh\n");

                        //
                        // validate mesh pointers
                        //

                        if (
                             (pTempMesh[CurrentMesh].Vertex1 >= ulMaxVertex) ||
                             (pTempMesh[CurrentMesh].Vertex2 >= ulMaxVertex) ||
                             (pTempMesh[CurrentMesh].Vertex3 >= ulMaxVertex)
                           )
                        {
                            RIP("Error in triangle split routine:Vertex out of range\n");
                            break;
                        }
    
                        PTRIVERTEX pv0 = &pTempVertex[pTempMesh[CurrentMesh].Vertex1];
                        PTRIVERTEX pv1 = &pTempVertex[pTempMesh[CurrentMesh].Vertex2];
                        PTRIVERTEX pv2 = &pTempVertex[pTempMesh[CurrentMesh].Vertex3];
        
                        //
                        // check if triangle boundary is inside clip rect
                        // 

                        if (bIsTriangleInBounds(pv0,pv1,pv2,ptData))
                        {
                            bSplit = bSplitTriangle(pTempVertex,&FreeVertex,pTempMesh,&FreeMesh,pRecurse);

                            if (!bSplit)
                            {
                                //
                                // draw triangle
                                //
        
                                bStatus = bCalculateAndDrawTriangle(pDibInfo,pv0,pv1,pv2,ptData,pfnTriFill);
                            }
                            else
                            {
                                //
                                // validate array indcies
                                //
            
                                if ((FreeVertex > ulMaxVertex) ||
                                    (FreeMesh   > ulMaxMesh))
                                {
                                    RIP("Error in triangle split routine: indicies out of range\n");
                                    break;
                                }
                            }
                        }

                        //
                        // if triangle was not split, then remove from list.
                        //

                        if (!bSplit)
                        {
                            //
                            // remove triangle just drawn. If this is the second triangle of a 
                            // split, then remove the added vertex and the original triangle as
                            // well
                            //

                            do
                            {
                                FreeMesh--;

                                if (pRecurse[FreeMesh])
                                {
                                    FreeVertex--;
                                }

                            } while ((FreeMesh != 0) && (pRecurse[FreeMesh] == 1));
                        }
        
                    } while (FreeMesh != 0);

                    LOCALFREE(pAlloc);
                }
                else
                {
                    WARNING1("Memory allocation failed for temp triangle buffers\n");
                    bStatus = FALSE;
                }
            }
        }
        else
        {
            DbgPrint("DIBTriangleMesh:Failed alloc   \n");
            bStatus = FALSE;
        }

        //
        // cleanup
        //

        if (ptData)
        {
            LOCALFREE(ptData);
        }
    }

    return(bStatus);
}

/******************************Public*Routine******************************\
* vCalcMeshExtent
*
*   Calculate bounding rect of drawing
*
* Arguments:
*
*  pVertex - vertex array
*  nVertex - number of vertex in array
*  pMesh   - array of rect or tri
*  nMesh   - number in mesh array
*  ulMode  - triangle or rectangle
*  prclExt - return extent rect
*
* Return Value:
*
*   None - if prcl in NULL then error occured
*
* History:
*
*    12/3/1996 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vCalcMeshExtent(
    PTRIVERTEX  pVertex,
    ULONG       nVertex,
    PVOID       pMesh,
    ULONG       nMesh,
    ULONG       ulMode,
    RECTL       *prclExt
    )
{
    ULONG ulIndex;
    LONG xmin = MAX_INT;
    LONG xmax = MIN_INT;
    LONG ymin = MAX_INT;
    LONG ymax = MIN_INT;

    if (
          (ulMode == GRADIENT_FILL_RECT_H) || 
          (ulMode == GRADIENT_FILL_RECT_V)
       )
    {
        ASSERTGDI(nMesh == 1,"vCalcMeshExtent: nMesh must be 1 for rect mode");
        RECTL rcl;

        ULONG vul = ((PGRADIENT_RECT)pMesh)->UpperLeft;
        ULONG vlr = ((PGRADIENT_RECT)pMesh)->LowerRight;

        if ((vul <= nVertex) && (vlr <= nVertex))
        {
            if (pVertex[vul].x < xmin)
            {
                xmin = pVertex[vul].x;
            }

            if (pVertex[vul].x > xmax)
            {
                xmax = pVertex[vul].x;
            }

            if (pVertex[vul].y < ymin)
            {
                ymin = pVertex[vul].y;
            }

            if (pVertex[vul].y > ymax)
            {
                ymax = pVertex[vul].y;
            }

            if (pVertex[vlr].x < xmin)
            {
                xmin = pVertex[vlr].x;
            }

            if (pVertex[vlr].x > xmax)
            {
                xmax = pVertex[vlr].x;
            }

            if (pVertex[vlr].y < ymin)
            {
                ymin = pVertex[vlr].y;
            }

            if (pVertex[vlr].y > ymax)
            {
                ymax = pVertex[vlr].y;
            }
        }
    }
    else if (ulMode == GRADIENT_FILL_TRIANGLE)
    {

        PGRADIENT_TRIANGLE pGradTri = (PGRADIENT_TRIANGLE)pMesh;

        for (ulIndex=0;ulIndex<nMesh;ulIndex++)
        {
            LONG lVertex[3];
            LONG vIndex;

            lVertex[0] = pGradTri->Vertex1;
            lVertex[1] = pGradTri->Vertex2;
            lVertex[2] = pGradTri->Vertex3;

            for (vIndex=0;vIndex<3;vIndex++)
            {
                ULONG TriVertex = lVertex[vIndex];

                if (TriVertex < nVertex)
                {
                    if (pVertex[TriVertex].x < xmin)
                    {
                        xmin = pVertex[TriVertex].x;
                    }

                    if (pVertex[TriVertex].x > xmax)
                    {
                        xmax = pVertex[TriVertex].x;
                    }

                    if (pVertex[TriVertex].y < ymin)
                    {
                        ymin = pVertex[TriVertex].y;
                    }

                    if (pVertex[TriVertex].y > ymax)
                    {
                        ymax = pVertex[TriVertex].y;
                    }
                }
                else
                {
                    //
                    // error in mesh/vertex  array, return null
                    // bounding rect
                    //

                    prclExt->left   = 0;
                    prclExt->right  = 0;
                    prclExt->top    = 0;
                    prclExt->bottom = 0;

                    return;

                }
            }

            pGradTri++;
        }
    }

    prclExt->left   = xmin;
    prclExt->right  = xmax;
    prclExt->top    = ymin;
    prclExt->bottom = ymax;
}

/******************************Public*Routine******************************\
* bConvertVertexToPhysical
*
*   Convert from logical to physical coordinates
*
* Arguments:
*
*   hdc         - hdc
*   pVertex     - logical vertex array
*   nVertex     - number of elements in vertex array
*   pPhysVert   - physical vertex array
*
* Return Value:
*
*   status
*
* History:
*
*    12/4/1996 Mark Enstrom [marke]
*
\**************************************************************************/

BOOL
bConvertVertexToPhysical(
    HDC        hdc,
    PTRIVERTEX pVertex,
    ULONG      nVertex,
    PTRIVERTEX pPhysVert
    )
{
    ULONG ulIndex;

    for (ulIndex = 0;ulIndex<nVertex;ulIndex++)
    {
        POINT pt;

        pt.x = pVertex[ulIndex].x;
        pt.y = pVertex[ulIndex].y;

        if (!LPtoDP(hdc,&pt,1))
        {
            return(FALSE);
        }

        pPhysVert[ulIndex].x     = pt.x;
        pPhysVert[ulIndex].y     = pt.y;
        pPhysVert[ulIndex].Red   = pVertex[ulIndex].Red;
        pPhysVert[ulIndex].Green = pVertex[ulIndex].Green;
        pPhysVert[ulIndex].Blue  = pVertex[ulIndex].Blue;
        pPhysVert[ulIndex].Alpha = pVertex[ulIndex].Alpha;
    }

    return(TRUE);
}

/******************************Public*Routine******************************\
* pfnTriangleFillFunction
*
*   look at format to decide if DIBSection should be drawn directly
*
*    32 bpp RGB
*    32 bpp BGR
*    24 bpp
*    16 bpp 565
*    16 bpp 555
*    (bitfields,8,4,1)
*
* Trangles are only filled in high color (no palette) surfaces
*
* Arguments:
*
*   pDibInfo  - information about destination surface
*   bReadable - Can dst surface be read?
*
* Return Value:
*
*   PFN_TRIFILL - triangle filling routine
*
* History:
*
*    12/6/1996 Mark Enstrom [marke]
*
\**************************************************************************/

PFN_TRIFILL
pfnTriangleFillFunction(
    PDIBINFO pDibInfo,
    BOOL bReadable
    )
{
    PFN_TRIFILL pfnRet = NULL;

    PULONG pulMasks = (PULONG)&pDibInfo->pbmi->bmiColors[0];

    //
    // 32 bpp RGB
    //

    if (!bReadable || (pDibInfo->flag & PRINTER_DC))
    {
        pfnRet = vFillTriDIBUnreadable;
    }
    else if (
         (pDibInfo->pbmi->bmiHeader.biBitCount    == 32) &&
         (pDibInfo->pbmi->bmiHeader.biCompression == BI_RGB)
       )
    {
        pfnRet = vFillTriDIB32BGRA;
    }

    else if (
         (pDibInfo->pbmi->bmiHeader.biBitCount    == 32) &&
         (pDibInfo->pbmi->bmiHeader.biCompression == BI_BITFIELDS) &&
         (pulMasks[0]   == 0xff0000)           &&
         (pulMasks[1]   == 0x00ff00)           &&
         (pulMasks[2]   == 0x0000ff)
       )
    {
        pfnRet = vFillTriDIB32BGRA;
    }

    else if (
         (pDibInfo->pbmi->bmiHeader.biBitCount    == 32) &&
         (pDibInfo->pbmi->bmiHeader.biCompression == BI_BITFIELDS) &&
         (pulMasks[0]   == 0x0000ff)           &&
         (pulMasks[1]   == 0x00ff00)           &&
         (pulMasks[2]   == 0xff0000)
       )
    {
        pfnRet = vFillTriDIB32RGB;
    }

    else if (
         (pDibInfo->pbmi->bmiHeader.biBitCount    == 24) &&
         (pDibInfo->pbmi->bmiHeader.biCompression == BI_RGB)
       )
    {
        pfnRet = vFillTriDIB24RGB;
    }

    //
    // 16 BPP
    //

    else if (
         (pDibInfo->pbmi->bmiHeader.biBitCount    == 16) &&
         (pDibInfo->pbmi->bmiHeader.biCompression == BI_BITFIELDS)
       )
    {

        //
        // 565,555
        //

        if (
             (pulMasks[0]   == 0xf800)           &&
             (pulMasks[1]   == 0x07e0)           &&
             (pulMasks[2]   == 0x001f)
           )
        {
            pfnRet = vFillTriDIB16_565;
        }
        else if (
            (pulMasks[0]   == 0x7c00)           &&
            (pulMasks[1]   == 0x03e0)           &&
            (pulMasks[2]   == 0x001f)
          )
       {
           pfnRet = vFillTriDIB16_555;
       }
    }
    else
    {
        pfnRet = vFillTriDIBUnreadable;
    }

    return(pfnRet);
}

/******************************Public*Routine******************************\
* WinTriangleMesh
*   win95 emulation
*
* Arguments:
*
*   hdc           - dc
*   pVertex       - vertex array
*   nVertex       - elements in vertex array
*   pMesh         - mesh array
*   nMesh         - elements in mesh array
*   ulMode        - drawing mode
*
* Return Value:
*
*   status
*
* History:
*
*    12/3/1996 Mark Enstrom [marke]
*
\**************************************************************************/

BOOL
WinGradientFill(
    HDC         hdc,
    PTRIVERTEX  pLogVertex,
    ULONG       nVertex,
    PVOID       pMesh,
    ULONG       nMesh,
    ULONG       ulMode
    )
{

    //
    // If the DC has a DIBSection selected, then draw direct to DIBSECTION.
    // else copy the rectangle needed from the dst to a 32bpp temp buffer,
    // draw into the buffer, then bitblt to dst.
    //
    // calc extents for drawing
    //
    // convert extents and points to physical
    //
    // if no global then
    //      create memory DC with dibsection of correct size
    // copy dst into dibsection (if can't make clipping)
    // draw physical into dibsection
    // copy dibsection to destination
    //

    PBYTE       pDIB;
    RECTL       rclPhysMeshExt;
    RECTL       rclPhysExt;
    RECTL       rclLogExt;
    PRECTL      prclClip;
    BOOL        bStatus = FALSE;
    PFN_TRIFILL pfnTriFill;
    DIBINFO     dibInfoDst;
    PALINFO     palDst;
    ULONG       ulDIBMode = SOURCE_GRADIENT_TRI;
    BOOL        bReadable;
    POINTL      ptlDitherOrg = {0,0};

    //
    // validate params and buffers
    //

    if ((ulMode & ~GRADIENT_FILL_OP_FLAG)  != 0)
    {
        WARNING("NtGdiGradientFill: illegal parametets\n");
        return(FALSE);
    }

    if (
         (ulMode == GRADIENT_FILL_RECT_H) || 
         (ulMode == GRADIENT_FILL_RECT_V)
       )
    {
        ASSERTGDI(nMesh == 1,"Mesh must be one in GRADIENT_RECT");
        ulDIBMode        = SOURCE_GRADIENT_RECT;
    }
    else if (ulMode != GRADIENT_FILL_TRIANGLE)
    {
        WARNING("Invalid mode in call to GradientFill\n");
        return(FALSE);
    }

    //
    // allocate space for copy of vertex data in device space
    //

    PTRIVERTEX  pPhysVertex = (PTRIVERTEX)LOCALALLOC(nVertex * sizeof(TRIVERTEX));

    if (pPhysVertex != NULL)
    {
        //
        // convert to physical
        //

        bStatus = bConvertVertexToPhysical(hdc,pLogVertex,nVertex,pPhysVertex);

        if (bStatus)
        {
            //
            // get logical extents
            //

            vCalcMeshExtent(pLogVertex,nVertex,pMesh,nMesh,ulMode,&rclLogExt);

            //
            // convert to physical extents
            //

            rclPhysExt = rclLogExt;

            LPtoDP(hdc,(LPPOINT)&rclPhysExt,2);

            //
            // save unclipped mesh ext
            //

            rclPhysMeshExt = rclPhysExt;

            //
            // Set DIB information, convert to physical
            //

            bStatus = bInitDIBINFO(hdc,
                                   rclLogExt.left,
                                   rclLogExt.top,
                                   rclLogExt.right  - rclLogExt.left,
                                   rclLogExt.bottom - rclLogExt.top,
                                  &dibInfoDst);

            if (bStatus)
            {
                //
                // get a destination DIB. For RECT Mode, the destination is not read.
                //

                bSetupBitmapInfos(&dibInfoDst, NULL);

                //
                // DST can be printer DC
                //

                if (dibInfoDst.flag & PRINTER_DC)
                {
                    bReadable = FALSE;
                    bStatus = TRUE;
                }
                else
                {
                    bStatus = bGetDstDIBits(&dibInfoDst, &bReadable,ulDIBMode);
                }

                if (!((!bStatus) || (dibInfoDst.rclClipDC.left == dibInfoDst.rclClipDC.right)))
                {
                    ULONG ulIndex;

                    if (bStatus)
                    {
                        if (dibInfoDst.hDIB)
                        {
                            //
                            // if temp surface has been allocated,
                            // subtract origin from points
                            //

                            for (ulIndex=0;ulIndex<nVertex;ulIndex++)
                            {
                                pPhysVertex[ulIndex].x -= dibInfoDst.ptlGradOffset.x;
                                pPhysVertex[ulIndex].y -= dibInfoDst.ptlGradOffset.y;
                                rclPhysMeshExt.left    -= dibInfoDst.ptlGradOffset.x; 
                                rclPhysMeshExt.right   -= dibInfoDst.ptlGradOffset.x; 
                                rclPhysMeshExt.top     -= dibInfoDst.ptlGradOffset.y; 
                                rclPhysMeshExt.bottom  -= dibInfoDst.ptlGradOffset.y; 
                            }

                            //
                            // clipping now in relation to temp DIB
                            //

                            rclPhysExt     = dibInfoDst.rclDIB;

                            //
                            // adjust dither org
                            //

                            ptlDitherOrg.x = dibInfoDst.rclBounds.left;
                            ptlDitherOrg.y = dibInfoDst.rclBounds.top;
                        }
                        else
                        {
                            //
                            // clip extents to destination clip rect
                            //

                            if (rclPhysExt.left < dibInfoDst.rclClipDC.left)
                            {
                                rclPhysExt.left = dibInfoDst.rclClipDC.left;
                            }

                            if (rclPhysExt.right > dibInfoDst.rclClipDC.right)
                            {
                                rclPhysExt.right = dibInfoDst.rclClipDC.right;
                            }

                            if (rclPhysExt.top < dibInfoDst.rclClipDC.top)
                            {
                                rclPhysExt.top = dibInfoDst.rclClipDC.top;
                            }

                            if (rclPhysExt.bottom > dibInfoDst.rclClipDC.bottom)
                            {
                                rclPhysExt.bottom = dibInfoDst.rclClipDC.bottom;
                            }
                        }

                        if (
                             (ulMode == GRADIENT_FILL_RECT_H) ||
                             (ulMode == GRADIENT_FILL_RECT_V)
                           )
                        {
                            //
                            // draw gradient rectangles
                            //

                            bStatus = DIBGradientRect(hdc,
                                                      pPhysVertex,
                                                      nVertex,
                                                      (PGRADIENT_RECT)pMesh,
                                                      nMesh,
                                                      ulMode,
                                                      &rclPhysExt,
                                                      &dibInfoDst,
                                                      &ptlDitherOrg);
                        }
                        else if (ulMode == GRADIENT_FILL_TRIANGLE)
                        {
                            //
                            // draw triangles
                            //

                            bStatus = DIBTriangleMesh(hdc,
                                                      pPhysVertex,
                                                      nVertex,
                                                      (PGRADIENT_TRIANGLE)pMesh,
                                                      nMesh,
                                                      ulMode,
                                                      &rclPhysExt,
                                                      &rclPhysMeshExt,
                                                      &dibInfoDst,
                                                      &ptlDitherOrg,
                                                      bReadable);
                        }

                        //
                        // copy output to final dest if needed
                        //

                        if (bStatus && bReadable)
                        {
                            bStatus = bSendDIBINFO (hdc,&dibInfoDst);
                        }
                    }
                }
            }

            vCleanupDIBINFO(&dibInfoDst);
        }

        LOCALFREE(pPhysVertex);
    }
    else
    {
        bStatus = FALSE;
    }

    return(bStatus);
}

#endif

/******************************Public*Routine******************************\
* GradientFill
*
*   Draw gradient rectangle or triangle
*
* Arguments:
*
*   hdc           - dc
*   pVertex       - vertex array
*   nVertex       - elements in vertex array
*   pMesh         - mesh array
*   nMesh         - elements in mesh array
*   ulMode        - drawing mode
*
* Return Value:
*
*   status
*
* History:
*
*    12/3/1996 Mark Enstrom [marke]
*
\**************************************************************************/

BOOL
GradientFill(
    HDC         hdc,
    PTRIVERTEX  pVertex,
    ULONG       nVertex,
    PVOID       pMesh,
    ULONG       nMesh,
    ULONG       ulMode
    )
{
    BOOL bRet;


    #if !(_WIN32_WINNT >= 0x500)

        //
        // Convert GradientRect mesh into multiple single rect calls.
        // This is more efficient in enulation since each rect covers
        // dst surface (unless clipped)
        //

        if (
             (
                (ulMode == GRADIENT_FILL_RECT_H) || 
                (ulMode == GRADIENT_FILL_RECT_V)
             ) &&
             ((nMesh > 1) || (nVertex > 2))
           )
        {
            PGRADIENT_RECT pGradMesh = (PGRADIENT_RECT)pMesh;
            GRADIENT_RECT  GradRectFixed = {0,1};
            TRIVERTEX      TriVertex[2];

            while (nMesh--)
            {
                //
                // find two vertex structures referenced by GradientRect mesh
                //

                if (
                     (pGradMesh->UpperLeft < nVertex) &&
                     (pGradMesh->LowerRight < nVertex)
                   )
                {
                    TriVertex[0] = pVertex[pGradMesh->UpperLeft];
                    TriVertex[1] = pVertex[pGradMesh->LowerRight];

                    bRet = gpfnGradientFill(hdc,
                                            &TriVertex[0],
                                            2,
                                            (PVOID)&GradRectFixed,
                                            1,
                                            ulMode
                                            );
                }
                else
                {
                    bRet = FALSE;
                }

                if (!bRet)
                {
                    break;
                }

                pGradMesh++;
            }
        }
        else
        {
            bRet = gpfnGradientFill(hdc,
                                    pVertex,
                                    nVertex,
                                    pMesh,
                                    nMesh,
                                    ulMode
                                    );

        }

    #else

        bRet = gpfnGradientFill(hdc,
                                pVertex,
                                nVertex,
                                pMesh,
                                nMesh,
                                ulMode
                                );

    #endif

    return(bRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\image\i386\overblend.asm ===
page ,132
;------------------------------Module-Header----------------------------;
; Module Name: alphaimg.asm
;
; Inner loop dfor alpha bending
;
; Created: 12-Mar-1997
; Author: Mark Enstrom
;
; Copyright (c) 1997-1999 Microsoft Corporation
;-----------------------------------------------------------------------;


        .386
        .model  small,c

        assume cs:FLAT,ds:FLAT,es:FLAT,ss:FLAT
        assume fs:nothing,gs:nothing

        .xlist
        include callconv.inc
        include ks386.inc



ovr_DstLast     equ 000H
ovr_EDI         equ 004H
ovr_ESI         equ 008H
ovr_EDX         equ 00cH
ovr_ECX         equ 010H
ovr_EBX         equ 014H
ovr_ppixEBP     equ 018H
ovr_RA          equ 01cH
ovr_ppixDst     equ 020H
ovr_ppixSrc     equ 024H
ovr_cx          equ 028H
ovr_Blend       equ 02cH
ovr_pwrMask     equ 030H

ble_ConstAlpha  equ 000H
ble_LastX       equ 004H
ble_EDI         equ 008H
ble_ESI         equ 00cH
ble_EDX         equ 010H
ble_ECX         equ 014H
ble_EBX         equ 018H
ble_EBP         equ 01cH
ble_RA          equ 020H
ble_ppixDst     equ 024H
ble_ppixSrc     equ 028H
ble_cx          equ 02cH
ble_Blend       equ 030H

ble16_tSrc        equ 000H
ble16_tDst        equ 004H
ble16_ConstAlpha  equ 008H
ble16_LastX       equ 00cH
ble16_EDI         equ 010H
ble16_ESI         equ 014H
ble16_EDX         equ 018H
ble16_ECX         equ 01cH
ble16_EBX         equ 020H
ble16_EBP         equ 024H
ble16_RA          equ 028H
ble16_ppixDst     equ 02cH
ble16_ppixSrc     equ 030H
ble16_cx          equ 034H
ble16_Blend       equ 038H

;
; locals
;


        .list



;------------------------------------------------------------------------------;

        .code


_TEXT$01   SEGMENT DWORD USE32 PUBLIC 'CODE'
           ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING


;------------------------------------------------------------------------------;

;------------------------------------------------------------------------------;
; vPixelOver
;
;   Blend source and destination scan line. Source and destination are 32bpp
;   BGRA scan lines.
;
; Entry:
;
;  ppixDst          - pointer to dst scan line
;  ppixSrc          - pointer to src scan line
;  cx               - number of pixels
;  BlendFunction    - BlendFunction, not used
;  pwrMask          - write mask: Set byte to 1 if need to write output
;
; Returns:
;       none
; Registers Destroyed:
;       all
; Calls:
;       None
; History:
;
; WARNING: If call parameters are changed, the ret statement must be fixed
;
;------------------------------------------------------------------------------;
;
;   VOID
;   vPixelOver(
;       ALPHAPIX       *ppixDst,
;       ALPHAPIX       *ppixSrc,
;       LONG           cx,
;       BLENDFUNCTION  BlendFunction,
;       PBYTE          pwrMask
;       )
;   {
;       ALPHAPIX pixSrc;
;       ALPHAPIX pixDst;
;
;       while (cx--)
;       {
;           pixSrc = *ppixSrc;
;
;           if (pixSrc.pix.a != 0)
;           {
;               pixDst = *ppixDst;
;
;               if (pixSrc.pix.a == 255)
;               {
;                   pixDst = pixSrc;
;               }
;               else
;               {
;                   long    SrcTran = 255 - pixSrc->a;
;                   PBYTE   pTable = &pAlphaMulTable[SrcTran * 256];
;
;                   pixDst->r = pixSrc->r + *(pTable + pixDst->r);
;                   pixDst->g = pixSrc->g + *(pTable + pixDst->g);
;                   pixDst->b = pixSrc->b + *(pTable + pixDst->b);
;                   pixDst->a = pixSrc->a + *(pTable + pixDst->a);
;               }
;
;               *pwrMask = 1;
;               *ppixDst = pixDst;
;           }
;
;           pwrMask++;
;           ppixSrc++;
;           ppixDst++;
;       }
;   }
;
;
;

;
; parameters
;



        public  vPixelOver@20

vPixelOver@20 proc near


        ;
        ; use ebp as general register
        ;

        push	ebp
        push	ebx
        push	ecx
        push    edx
        push	edi
        push    esi
        sub     esp,4

        mov     ecx,ovr_cx[esp]         ; ebx = pixel count
        mov     edi,ovr_ppixDst[esp]    ; edi = destination address
        shl     ecx,2                   ; ebx = DWORD offset
        mov     esi,ovr_ppixSrc[esp]    ; esi = source address
        add     ecx,edi                 ; end dst addr
        mov     edx,ovr_pwrMask[esp]    ; edx = pwrMask
        cmp     edi,ecx                 ; end of scan line
        mov     ovr_DstLast[esp],ecx    ; save end scan line
        jz      PixelReturn

PixelLoop:

        mov     ecx,0FFH                ; ecx = 00 00 00 FF     u
        mov     eax,[esi]               ; eax = AA RR GG BB         v
        shr     eax,24                  ; eax = 00 00 00 AA     u
        add     esi,4                   ; inc src pointer           v

        ;
        ; check for alpha == 0 and alpha == 0xff, these
        ; checks allow not writing output pixels that
        ; don't change, but this test decreases performance of the
        ; loop by 10%
        ;

        test    al,al                   ; test for 0            u
        jz      PixelZeroAlpha          ; jump to 0 quick out       v
                                        ;
        cmp     al,0ffH                 ; alpha = 0xff          u
        jz      PixelFFAlpha            ; jump to case ff           v

        sub     ecx,eax                 ; ecx = 00 00 00 255-sA u
        mov     eax,[edi]               ; eax = dA dR dG dB         v

        mov     ebp,eax                 ; ebp = dA dR dG dB     u
        and     eax,0FF00FFFFH          ; eax = dA 00 dG dB         v

        shr     eax,8                   ; eax = 00 dA 00 dG     u
        and     ebp,000FF00FFH          ; ebp = 00 dR 00 dB         v

        imul    ebp,ecx                 ; ebp = dR*sA dB*sA     10 cycle delay
        imul    eax,ecx                 ; eax = dA*sA dG*sG     10 cycles

        add     ebp,0800080H            ; ebp = ( eR) ( eB)     u
        add     eax,0800080H            ; ebp = ( eA) ( eG)         v

        mov     ebx,ebp                 ; ebx = ( eR) ( eB)     u
        mov     ecx,eax                 ; ecx = ( eA) ( eG)         v

        and     ebx,0FF00FFFFH          ; ebx = eR 00 ( eB)     u
        and     ecx,0FF00FFFFH          ; ecx = eA 00 ( eG)         v

        shr     ebx,8                   ; ebx = 00 eR 00 eB     u
        add     edi,4                   ; inc dst pointer           v

        shr     ecx,8                   ; ecx = 00 eA 00 eG     u
        add     ebx,ebp                 ; ebx = ( eR) ( eB)         v

        mov     ebp,[esi-4]             ; ebp = sA sR sG sB         v
        and     ebx,0FF00FFFFH          ; ebx = eR 00 ( eB)     u

        shr     ebx,8                   ; ebx = 00 eR 00 eB     u
        add     ecx,eax                 ; ecx = ( eA) ( eG)         v

        mov     eax,ovr_DstLast[esp]    ;                       u
        and     ecx,0FF00FF00H          ; ecx = eA 00 eG 00         v

        add     ecx,ebp                 ; ecx = AA sR GG sB     u        AA = sA + (1-sA)Da
        inc     edx                     ;                           v

        add     ecx,ebx                 ; ecx = AA RR GG BB     u
        cmp     edi,eax                 ;                           v

        mov     [edi-4],ecx             ; save result           u
        jnz     PixelLoop               ;                           v

        ;
        ; restore stack frame
        ;

PixelReturn:

        add     esp,4
        pop     esi
        pop     edi
        pop     edx
        pop     ecx
        pop     ebx
        pop     ebp
        ret     20


PixelZeroAlpha:

        mov     eax,ovr_DstLast[esp]    ; end scan line
        add     edi,4                   ; inc dst
        mov     BYTE PTR[edx],0         ; set pwrMask
        inc     edx                     ; inc pwrMask

        cmp     edi,eax                 ; dst == dstEnd
        jnz     PixelLoop               ; loop

        jmp     PixelReturn

PixelFFAlpha:

        mov     ecx,ovr_DstLast[esp]    ; end scan line
        mov     eax,[esi-4]             ; eax = dA dR dG dB         v
        mov     [edi],eax               ; save result
        add     edi,4                   ; inc dst pointer       u
        inc     edx                     ; inc pwrMask
        cmp     edi,ecx                 ;
        jnz     PixelLoop

        jmp     PixelReturn




vPixelOver@20 endp


;------------------------------------------------------------------------------;
; vPixelBlend
;
;   Dst = Dst + Alpha * (Src - Dst)
;
; Entry:
;
;  ppixDst          - pointer to dst scan line
;  ppixSrc          - pointer to src scan line
;  cx               - number of pixels
;  BlendFunction    - BlendFunction, not used
;
; Returns:
;       none
; Registers Destroyed:
;       all
; Calls:
;       None
; History:
;
; WARNING: If call parameters are changed, the ret statement must be fixed
;
;------------------------------------------------------------------------------;

;
; parameters
;

        public  vPixelBlend@20

vPixelBlend@20 proc near

        ;
        ; use ebp as general register
        ;

        push	ebp
        push	ebx
        push	ecx
        push    edx
        push	edi
        push    esi
        sub     esp,8


        movzx   eax,BYTE PTR ble_Blend+2[esp]
        mov     ebx,ble_cx[esp]         ; ebx = pixel count
        mov     edi,ble_ppixDst[esp]    ; edi = destination address
        mov     esi,ble_ppixSrc[esp]    ; esi = source address
        lea     edx,[edi + 4 * ebx]     ; edx = last dst address

        cmp     edi,edx                 ; end of scan line
        jz      BlendReturn

        mov     ble_LastX[esp],edx      ; save end x address

BlendLoop:

        mov     ebx,[edi]               ; ebx = D aa rr gg bb
        mov     ecx,[esi]               ; ecx = S aa rr bb bb
        and     ebx,000ff00ffH          ; ebx = D 00 rr 00 bb
        and     ecx,000ff00ffH          ; ecx = S 00 rr 00 bb

        mov     ebp,ebx                 ; ebp = D 00 rr 00 bb
        sub     ecx,ebx                 ; ecx = s 00 rr 00 bb
        imul    ecx,eax                 ; ecx =   rr rr bb bb      u
        shl     ebp,8                   ; ebp = D rr 00 bb 00      u
        mov     edx,[edi]               ; edx = D aa rr gg bb        v
        and     edx,0ff00ff00H          ; edx = D aa 00 gg 00      u
        sub     ebp,ebx                 ; ebp = D rr ee bb ee        v
        shr     edx,8                   ; edx = D 00 aa 00 gg      u
        add     ecx,000800080H          ; ecx =   rr rr bb bb + e    v
        add     ecx,ebp                 ; ecx =   rr rr bb bb      u
        mov     ebp,[esi]               ; ebp = S aa rr gg bb        v
        shr     ebp,8                   ; ebp = S ?? aa rr gg      u
        mov     ebx,ecx                 ; ebx =   rr rr bb bb        v
        and     ecx,0ff00ff00H          ; ecx =   rr 00 bb 00      u
        and     ebp,000ff00ffH          ; ebp = S 00 aa 00 gg        v
        shr     ecx,8                   ; ecx =   00 rr 00 bb      u
        sub     ebp,edx                 ; ebp =   del a del g        v
        add     ebx,ecx                 ; ebx =   rr rr bb bb      u
        mov     ecx,edx                 ; ecx = D 00 aa 00 gg        v
        imul    ebp,eax                 ; ebp = m aa aa gg gg      u
        shl     ecx,8                   ; ecx = D aa 00 gg 00      u
        and     ebx,0FF00FF00H          ; ebx =   rr 00 bb 00        v
        add     ebp,000800080H          ; ebp = m aa aa gg gg      u
        sub     ecx,edx                 ; ecx = D aa 00 gg 00        v
        shr     ebx,8                   ; ebx =   00 rr 00 bb      u
        add     ecx,ebp                 ; ecx = M aa aa gg gg        v
        mov     edx,ecx                 ; edx = M aa aa gg gg      u
        and     ecx,0ff00ff00H          ; ecx = M aa 00 gg 00        v
        shr     ecx,8                   ; ecx = M 00 aa 00 gg      u
        add     esi,4                   ; inc src to next pixel      v
        add     ecx,edx                 ; ecx = M aa aa gg gg      u
        mov     ebp,ble_LastX[esp]      ; ebp = Last X Dst addr      v
        and     ecx,0FF00FF00H          ; ecx = D aa 00 gg 00      u
        add     edi,4                   ; inc dst addr               v
        or      ecx,ebx                 ; ecx = D aa rr gg bb      u
        cmp     edi,ebp                 ;                            v
        mov     [edi-4],ecx             ; store dst pixel          u
        jnz     BlendLoop               ;                            v


        ;
        ; restore stack frame
        ;

BlendReturn:

        add     esp,8
        pop     esi
        pop     edi
        pop     edx
        pop     ecx
        pop     ebx
        pop     ebp
        ret     20

vPixelBlend@20 endp

;------------------------------------------------------------------------------;
; vPixelBlend16_555
;
;   Dst = Dst + Alpha * (Src - Dst)
;
;   Source and destination are 16 bpp 555 format
;
; Entry:
;
;  ppixDst          - pointer to dst scan line
;  ppixSrc          - pointer to src scan line
;  cx               - number of pixels
;  BlendFunction    - BlendFunction, not used
;
; Returns:
;       none
; Registers Destroyed:
;       all
; Calls:
;       None
; History:
;
; WARNING: If call parameters are changed, the ret statement must be fixed
;
;------------------------------------------------------------------------------;

;
; parameters
;

        public  vPixelBlend16_555@20

vPixelBlend16_555@20 proc near

        ;
        ; use ebp as general register
        ;

        push	ebp
        push	ebx
        push	ecx
        push    edx
        push	edi
        push    esi
        sub     esp,16

        movzx   eax,BYTE PTR ble16_Blend+2[esp]
        mov     ebx,ble16_cx[esp]       ; ebx = pixel count
        mov     edi,ble16_ppixDst[esp]  ; edi = destination address
        mov     esi,ble16_ppixSrc[esp]  ; esi = source address
        lea     edx,[edi + 2 * ebx]     ; edx = last dst address

        cmp     edi,edx                 ; end of scan line
        jz      BlendReturn_16

        mov     ble16_LastX[esp],edx    ; save end x address

BlendLoop_16:

        movzx   ebx,WORD PTR[edi]       ; ebx = D 0000 0000 0rrr rrgg gggb bbbb
        movzx   ecx,WORD PTR[esi]       ; ecx = S 0000 0000 0rrr rrgg gggb bbbb

        mov     ble16_tDst[esp],ebx
        mov     ble16_tSrc[esp],ecx

        and     ebx,000007c1fH          ; ebx = D 0000 0000 0rrr rr00 000b bbbb
        and     ecx,000007c1fH          ; ecx = S 0000 0000 0rrr rr00 000b bbbb

        mov     ebp,ebx                 ; ebp = D 0000 0000 0rrr rr00 000b bbbb
        sub     ecx,ebx                 ; ecx = s 0000 0000 0RRR RR00 000B BBBB
        imul    ecx,eax                 ; ecx = M 0000 RRRR Rrrr rrBB BBBb bbbb
        shl     ebp,5                   ; ebp = D 0000 rrrr r000 00bb bbb0 0000
        mov     edx,ble16_tDst[esp]     ; ebx = D 0000 0000 0rrr rrgg gggb bbbb
        and     edx,0000003e0H          ; edx = D 0000 0000 0000 00gg ggg0 0000
        sub     ebp,ebx                 ; ebp = D 0000 RRRR R000 00BB BBB0 0000 D*(32-1)
        shr     edx,5                   ; edx = D 0000 0000 0000 0000 000g gggg NOT NEEDED!
        add     ecx,000004010H          ; ecx = M 0000 RRRR Rrrr rrBB BBBb bbbb + error
        add     ecx,ebp                 ; ecx = M 0000 RRRR Rrrr rrBB BBBb bbbb
        mov     ebp,ble16_tSrc[esp]     ; ecx = S 0000 0000 0rrr rrgg gggb bbbb
        shr     ebp,5                   ; ebp = S 0000 0000 0000 00rr rrrg gggg NOT NEEDED
        mov     ebx,ecx                 ; ebx = M
        and     ecx,0000F83E0H          ; ecx = M 0000 RRRR R000 00BB BBB0 0000
        and     ebp,00000001fH          ; ebp = S 0000 0000 0000 0000 000g gggg
        shr     ecx,5                   ; ecx = M 0000 0000 0RRR RR00 000B BBBB
        sub     ebp,edx                 ; ebp =DG 0000 0000 0000 0000 000g gggg (sG-dG)
        add     ebx,ecx                 ; ebx = M 0000 RRRR Rrrr rrBB BBBb bbbb
        mov     ecx,edx                 ; ecx = D 0000 0000 0000 0000 000g gggg
        imul    ebp,eax                 ; ebp = M 0000 0000 0000 00GG GGGg gggg alpha * (sG-dG)
        shl     ecx,5                   ; ecx = D 0000 0000 0000 00gg ggg0 0000 dG * 32
        and     ebx,0000f83e0H          ; ebx = M 0000 RRRR R000 00BB BBB0 0000
        add     ebp,000004010H          ; ebp = M 0000 0000 0000 00GG GGGg gggg + error
        sub     ecx,edx                 ; ecx = D 0000 0000 0000 00gg ggg0 0000 dG * 31
        shr     ebx,5                   ; ebx = M 0000 0000 0RRR RR00 000B BBBB
        add     ecx,ebp                 ; ecx = M 0000 0000 0000 00GG GGGg gggg
        mov     edx,ecx                 ; edx = M 0000 0000 0000 00GG GGGg gggg
        and     ecx,0000003e0H          ; ecx = M 0000 0000 0000 00GG GGG0 0000 NOT NEEDED
        shr     ecx,5                   ; ecx = M 0000 0000 0000 0000 000G GGGG
        add     esi,2                   ; inc src to next pixel      v
        add     ecx,edx                 ; ecx = M 0000 0000 0000 00GG GGGg gggg
        mov     ebp,ble16_LastX[esp]      ; ebp = Last X Dst addr      v
        and     ecx,0000003e0H          ; ecx = M 0000 0000 0000 00GG GGG0 0000
        add     edi,2                   ; inc dst addr               v
        or      ecx,ebx                 ; ecx = D 0000 0000 0RRR RRGG GGGB BBBB
        cmp     edi,ebp                 ;                            v
        mov     [edi-2],cx              ; store dst pixel          u
        jnz     BlendLoop_16            ;                            v

        ;
        ; restore stack frame
        ;

BlendReturn_16:

        add     esp,16
        pop     esi
        pop     edi
        pop     edx
        pop     ecx
        pop     ebx
        pop     ebp
        ret     20

vPixelBlend16_555@20 endp


;------------------------------------------------------------------------------;
; vPixelBlend16_565
;
;   Dst = Dst + Alpha * (Src - Dst)
;
;   Source and destination are 16 bpp 565 format
;
; Entry:
;
;  ppixDst          - pointer to dst scan line
;  ppixSrc          - pointer to src scan line
;  cx               - number of pixels
;  BlendFunction    - BlendFunction, not used
;
; Returns:
;       none
; Registers Destroyed:
;       all
; Calls:
;       None
; History:
;
; WARNING: If call parameters are changed, the ret statement must be fixed
;
;------------------------------------------------------------------------------;

;
; parameters
;

        public  vPixelBlend16_565@20

vPixelBlend16_565@20 proc near

        ;
        ; use ebp as general register
        ;

        push	ebp
        push	ebx
        push	ecx
        push    edx
        push	edi
        push    esi
        sub     esp,16

        movzx   eax,BYTE PTR ble16_Blend+2[esp]
        mov     ebx,ble16_cx[esp]         ; ebx = pixel count
        mov     edi,ble16_ppixDst[esp]    ; edi = destination address
        mov     esi,ble16_ppixSrc[esp]    ; esi = source address
        lea     edx,[edi + 2 * ebx]     ; edx = last dst address

        cmp     edi,edx                 ; end of scan line
        jz      BlendReturn_16

        mov     ble16_LastX[esp],edx      ; save end x address

BlendLoop_16:

        movzx   ebx,WORD PTR[edi]       ; ebx = D 0000 0000 0rrr rrgg gggb bbbb
        movzx   ecx,WORD PTR[esi]       ; ecx = S 0000 0000 0rrr rrgg gggb bbbb

        mov     ble16_tDst[esp],ebx
        mov     ble16_tSrc[esp],ecx

        and     ebx,00000f81fH          ; ebx = D 0000 0000 0rrr rr00 000b bbbb
        and     ecx,00000f81fH          ; ecx = S 0000 0000 0rrr rr00 000b bbbb

        mov     ebp,ebx                 ; ebp = D 0000 0000 0rrr rr00 000b bbbb
        sub     ecx,ebx                 ; ecx = s 0000 0000 0RRR RR00 000B BBBB
        imul    ecx,eax                 ; ecx = M 0000 RRRR Rrrr rrBB BBBb bbbb
        shl     ebp,5                   ; ebp = D 0000 rrrr r000 00bb bbb0 0000
        mov     edx,ble16_tDst[esp]     ; ebx = D 0000 0000 0rrr rrgg gggb bbbb
        and     edx,0000007e0H          ; edx = D 0000 0000 0000 00gg ggg0 0000
        sub     ebp,ebx                 ; ebp = D 0000 RRRR R000 00BB BBB0 0000 D*(32-1)
        shr     edx,5                   ; edx = D 0000 0000 0000 0000 000g gggg NOT NEEDED!
        add     ecx,000008010H          ; ecx = M 0000 RRRR Rrrr rrBB BBBb bbbb + error
        add     ecx,ebp                 ; ecx = M 0000 RRRR Rrrr rrBB BBBb bbbb
        mov     ebp,ble16_tSrc[esp]     ; ecx = S 0000 0000 0rrr rrgg gggb bbbb
        shr     ebp,5                   ; ebp = S 0000 0000 0000 00rr rrrg gggg NOT NEEDED
        mov     ebx,ecx                 ; ebx = M
        and     ecx,0001f03E0H          ; ecx = M 0000 RRRR R000 00BB BBB0 0000
        and     ebp,00000003fH          ; ebp = S 0000 0000 0000 0000 000g gggg
        shr     ecx,5                   ; ecx = M 0000 0000 0RRR RR00 000B BBBB
        sub     ebp,edx                 ; ebp =DG 0000 0000 0000 0000 000g gggg (sG-dG)
        add     ebx,ecx                 ; ebx = M 0000 RRRR Rrrr rrBB BBBb bbbb
        mov     ecx,edx                 ; ecx = D 0000 0000 0000 0000 000g gggg
        imul    ebp,eax                 ; ebp = M 0000 0000 0000 00GG GGGg gggg alpha * (sG-dG)
        shl     ebp,1                   ; ConstAlpha *2
        shl     ecx,6                   ; ecx = D 0000 0000 0000 00gg ggg0 0000 dG * 32
        and     ebx,0001f03e0H          ; ebx = M 0000 RRRR R000 00BB BBB0 0000
        add     ebp,000000020H          ; ebp = M 0000 0000 0000 00GG GGGg gggg + error
        sub     ecx,edx                 ; ecx = D 0000 0000 0000 00gg ggg0 0000 dG * 31
        shr     ebx,5                   ; ebx = M 0000 0000 0RRR RR00 000B BBBB
        add     ecx,ebp                 ; ecx = M 0000 0000 0000 00GG GGGg gggg
        mov     edx,ecx                 ; edx = M 0000 0000 0000 00GG GGGg gggg
        and     ecx,000000fc0H          ; ecx = M 0000 0000 0000 00GG GGG0 0000 NOT NEEDED
        shr     ecx,6                   ; ecx = M 0000 0000 0000 0000 000G GGGG
        add     esi,2                   ; inc src to next pixel      v
        add     ecx,edx                 ; ecx = M 0000 0000 0000 00GG GGGg gggg
        mov     ebp,ble16_LastX[esp]      ; ebp = Last X Dst addr      v
        and     ecx,000000fc0H          ; ecx = M 0000 0000 0000 00GG GGG0 0000
        add     edi,2                   ; inc dst addr               v
        shr     ecx,1                   ;       D 0000 0000 0000 0GGG GGG0 0000
        or      ecx,ebx                 ; ecx = D 0000 0000 0RRR RRGG GGGB BBBB
        cmp     edi,ebp                 ;                            v
        mov     [edi-2],cx              ; store dst pixel          u
        jnz     BlendLoop_16            ;                            v

        ;
        ; restore stack frame
        ;

BlendReturn_16:

        add     esp,16
        pop     esi
        pop     edi
        pop     edx
        pop     ecx
        pop     ebx
        pop     ebp
        ret     20

vPixelBlend16_565@20 endp



_TEXT$01   ends

        end

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\image\tmp\dib.cxx ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name


Abstract:

   Lingyun Wang

Author:


Enviornment:

   User Mode

Revision History:

--*/

#include "precomp.hxx"
#include <ddraw.h>
#include <ddrawp.h>
#include <ddrawi.h>



/*extern HRESULT DD_Surface_GetSurfaceDesc(LPDIRECTDRAWSURFACE, LPDDSURFACEDESC);

extern HRESULT GetSurfaceFromDC(
        HDC hdc,
        LPDIRECTDRAWSURFACE *ppdds,
        HDC *phdcDriver) ;
*/
#pragma hdrstop

extern PFNTRANSBLT gpfnTransparentImage;
extern PFNTRANSDIB gpfnTransparentDIBImage;

#if (_WIN32_WINNT == 0x400)

PFN_GETSURFACEFROMDC pfnGetSurfaceFromDC = NULL;
PFN_GETSURFACEFROMDC pfnGetSurfaceDesc;

static PALETTEENTRY gapeVgaPalette[16] =
{
    { 0,   0,   0,    0 },
    { 0x80,0,   0,    0 },
    { 0,   0x80,0,    0 },
    { 0x80,0x80,0,    0 },
    { 0,   0,   0x80, 0 },
    { 0x80,0,   0x80, 0 },
    { 0,   0x80,0x80, 0 },
    { 0x80,0x80,0x80, 0 },
    { 0xC0,0xC0,0xC0, 0 },
    { 0xFF,0,   0,    0 },
    { 0,   0xFF,0,    0 },
    { 0xFF,0xFF,0,    0 },
    { 0,   0,   0xFF, 0 },
    { 0xFF,0,   0xFF, 0 },
    { 0,   0xFF,0xFF, 0 },
    { 0xFF,0xFF,0xFF, 0 }
};

/**************************************************************************\
*  Dprintf
*
*
* Arguments:
*
*   szFmt - format string and argrs
*
* Return Value:
*
*   none
*
* History:
*
*
\**************************************************************************/

VOID Dprintf( LPSTR szFmt, ... ) {
    TCHAR szMsg[80];
    DWORD cb;
    va_list marker;

    va_start( marker, szFmt );
    wvsprintf( szMsg, szFmt, marker );
    cb = lstrlen(szMsg);
    szMsg[cb++] = '\r';
    szMsg[cb++] = '\n';
    WriteFile( GetStdHandle( STD_OUTPUT_HANDLE ), szMsg, sizeof(TCHAR) * cb,
		&cb, NULL );

    va_end( marker );

    return;
}


/******************************Public*Routine******************************\
* MyGetSystemPaletteEntries
*
* Internal version of GetSystemPaletteEntries.
*
* GetSystemPaletteEntries fails on some 4bpp devices.  This version
* will detect the 4bpp case and supply the hardcoded 16-color VGA palette.
* Otherwise, it will pass the call on to GDI's GetSystemPaletteEntries.
*
* It is expected that this call will only be called in the 4bpp and 8bpp
* cases as it is not necessary for OpenGL to query the system palette
* for > 8bpp devices.
*
* History:
*  17-Aug-1995 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

static UINT
MyGetSystemPaletteEntries(HDC hdc, UINT iStartIndex, UINT nEntries,
                          LPPALETTEENTRY lppe)
{
    int nDeviceBits;

    nDeviceBits = GetDeviceCaps(hdc, BITSPIXEL) * GetDeviceCaps(hdc, PLANES);

    //
    // Some 4bpp displays will fail the GetSystemPaletteEntries call.
    // So if detected, return the hardcoded table.
    //

    if ( nDeviceBits == 4 )
    {
        if ( lppe )
        {
            nEntries = min(nEntries, (16 - iStartIndex));

            memcpy(lppe, &gapeVgaPalette[iStartIndex],
                   nEntries * sizeof(PALETTEENTRY));
        }
        else
            nEntries = 16;

        return nEntries;
    }
    else
    {
        return GetSystemPaletteEntries(hdc, iStartIndex, nEntries, lppe);
    }
}

/******************************Public*Routine******************************\
* bFillColorTable
*
* Initialize the color table of the BITMAPINFO pointed to by pbmi.  Colors
* are set to the current system palette.
*
* Note: call only valid for displays of 8bpp or less.
*
* Returns:
*   TRUE if successful, FALSE otherwise.
*
* History:
*  23-Jan-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

static BOOL
bFillColorTable(HDC hdc, HPALETTE hpal, BITMAPINFO *pbmi)
{
    BOOL bRet = FALSE;
    BYTE aj[sizeof(PALETTEENTRY) * 256];
    LPPALETTEENTRY lppe = (LPPALETTEENTRY) aj;
    RGBQUAD *prgb = (RGBQUAD *) &pbmi->bmiColors[0];
    ULONG cColors;

    cColors = 1 << pbmi->bmiHeader.biBitCount;

    if ( cColors <= 256 )
    {
        if ( hpal ? GetPaletteEntries(hpal, 0, cColors, lppe)
                  : MyGetSystemPaletteEntries(hdc, 0, cColors, lppe) )
        {
            UINT i;

            for (i = 0; i < cColors; i++)
            {
                prgb[i].rgbRed      = lppe[i].peRed;
                prgb[i].rgbGreen    = lppe[i].peGreen;
                prgb[i].rgbBlue     = lppe[i].peBlue;
                prgb[i].rgbReserved = 0;
            }

            bRet = TRUE;
        }
        else
        {
            //WARNING ("bFillColorTable: MyGetSystemPaletteEntries failed\n");
        }
    }

    return bRet;
}


/******************************Public*Routine******************************\
* bFillBitmapInfoDirect
*
* Fills in the fields of a BITMAPINFO so that we can create a bitmap
* that matches the format of the display.
*
* This is done by creating a compatible bitmap and calling GetDIBits
* to return the color masks.  This is done with two calls.  The first
* call passes in biBitCount = 0 to GetDIBits which will fill in the
* base BITMAPINFOHEADER data.  The second call to GetDIBits (passing
* in the BITMAPINFO filled in by the first call) will return the color
* table or bitmasks, as appropriate.
*
* Returns:
*   TRUE if successful, FALSE otherwise.
*
* History:
*  07-Jun-1995 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL
bFillBitmapInfoDirect(HDC hdc, HPALETTE hpal, BITMAPINFO *pbmi)
{
    HBITMAP hbm;
    BOOL    bRet = FALSE;

    //
    // Create a dummy bitmap from which we can query color format info
    // about the device surface.
    //

    if ((hbm = CreateCompatibleBitmap(hdc, 1, 1)) != NULL)
    {
        pbmi->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);

        //
        // Call first time to fill in BITMAPINFO header.
        //
        GetDIBits(hdc, hbm, 0, 0, NULL, pbmi, DIB_RGB_COLORS);

        if (( pbmi->bmiHeader.biBitCount <= 8 ) || ( pbmi->bmiHeader.biCompression == BI_BITFIELDS ))
        {
            //
            // Call a second time to get the color masks.
            // It's a GetDIBits Win32 "feature".
            //

            GetDIBits(hdc, hbm, 0, pbmi->bmiHeader.biHeight, NULL, pbmi,
                      DIB_RGB_COLORS);
        }

        bRet = TRUE;

        DeleteObject(hbm);
    }
    else
    {
        WARNING("bFillBitmapInfoDirect: CreateCompatibleBitmap failed\n");
    }

    return bRet;
}

/******************************Public*Routine******************************\
* bFillBitmapInfoMemory
*
* Fills in the fields of a BITMAPINFO so that we can create a bitmap
* that matches the format of a memory DC.
*
*
* Returns:
*   TRUE if successful, FALSE otherwise.
*
* History:
*  05-Dec-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
BOOL
bFillBitmapInfoMemory(HDC hdc, HPALETTE hpal, BITMAPINFO *pbmi)
{
    HBITMAP hbm;
    BOOL    bRet = FALSE;

    if ( (hbm = (HBITMAP)GetCurrentObject(hdc, OBJ_BITMAP)) != NULL )
    {
        pbmi->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);

        //
        // Call first time to fill in BITMAPINFO header.
        //
        GetDIBits(hdc, hbm, 0, 0, NULL, pbmi, DIB_RGB_COLORS);

        if (( pbmi->bmiHeader.biBitCount <= 8 )
           || ( pbmi->bmiHeader.biCompression == BI_BITFIELDS ))
        {
                //
                // Call a second time to get the color masks.
                // It's a GetDIBits Win32 "feature".
                //

                GetDIBits(hdc, hbm, 0, pbmi->bmiHeader.biHeight, NULL, pbmi,
                          DIB_RGB_COLORS);
         }

         bRet = TRUE;
    }
    else
    {
        WARNING("bFillBitmapInfoMemory: CreateCompatibleBitmap failed\n");
    }

    return bRet;
}

/******************************Public*Routine******************************\
* bFillDIBSection
*
* Fill in the DIBSection structure for a memory dc
* Fills in the fields of a BITMAPINFO so that we can create a bitmap
* that matches the format of a memory DC.
*
*
* Returns:
*   TRUE if successful, FALSE otherwise.
*
* History:
*  05-Dec-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
BOOL
bFillDIBSection(
    PDIBINFO pDibInfo)
{
    HBITMAP hbm;
    BOOL    bRet = FALSE;
    BOOL    bddraw = FALSE;
    DIBSECTION dib;

    if ( (hbm = (HBITMAP)GetCurrentObject(pDibInfo->hdc, OBJ_BITMAP)) != NULL )
    {
        GetObject (hbm, sizeof(DIBSECTION), &dib);

        //
        // it is a DIBSECTION
        //
        if ((pDibInfo->pvBits = dib.dsBm.bmBits) != NULL)
        {
             //
             // it is a DIBSection, now see if it might be a DD Surface (on WIn95)
             //
			    if (dib.dsBm.bmWidthBytes < dib.dsBm.bmWidth * dib.dsBm.bmBitsPixel/8)
             {
                HMODULE hddrawlib = GetModuleHandleA("ddraw");

                if (hddrawlib)
                {
                    Dprintf("GetModuleHandleA succeed\n");

                    hddrawlib = LoadLibrary (TEXT("ddraw.dll"));

                    Dprintf("LoadLibrary returns %x", hddrawlib);

                    if (hddrawlib)
                        pfnGetSurfaceFromDC = (PFN_GETSURFACEFROMDC)GetProcAddress(
                                                   hddrawlib, "GetSurfaceFromDC");
                }

                //
                // check if it is DIRECTDRAW surface
                //
                HDC hdcDevice;

                if (pfnGetSurfaceFromDC && (pfnGetSurfaceFromDC(pDibInfo->hdc, &pDibInfo->pdds, &hdcDevice) == DD_OK))
                {
                    bddraw = TRUE;

                    Dprintf("pfnGetSurfaceFromDC succeed\n");

                    //pdds->GetSurfaceDesc(&ddsd);
                    //
                    // we need to lock the surface here
                    //
                    if (pDibInfo->pdds->Lock((RECT *)&pDibInfo->rclBounds, &pDibInfo->ddsd, DDLOCK_SURFACEMEMORYPTR, NULL) == DD_OK)
                    {

                       pDibInfo->pvBits = pDibInfo->ddsd.lpSurface;
                       pDibInfo->pvBase = pDibInfo->ddsd.lpSurface;
                       pDibInfo->stride = pDibInfo->ddsd.lPitch;

                       pDibInfo->pbmi->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);

                       pDibInfo->pbmi->bmiHeader.biCompression = BI_RGB;
                       pDibInfo->pbmi->bmiHeader.biPlanes = 1;

                       pDibInfo->pbmi->bmiHeader.biWidth = pDibInfo->ddsd.dwWidth;
                       pDibInfo->pbmi->bmiHeader.biHeight = pDibInfo->ddsd.dwHeight;

                       switch (pDibInfo->ddsd.ddpfPixelFormat.dwRGBBitCount)
                       {
                          case DDBD_1:
                                     pDibInfo->pbmi->bmiHeader.biBitCount = 1;
                                     break;

                          case DDBD_4:
                                     pDibInfo->pbmi->bmiHeader.biBitCount = 4;
                                     break;

                          case DDBD_8:
                                     pDibInfo->pbmi->bmiHeader.biBitCount = 8;
                                     bFillColorTable (pDibInfo->hdc, 0, pDibInfo->pbmi);
                                     break;

                          case DDBD_16:
                                     pDibInfo->pbmi->bmiHeader.biBitCount = 16;
                                     *(DWORD *)&pDibInfo->pbmi->bmiColors[0] = pDibInfo->ddsd.ddpfPixelFormat.dwRBitMask;
                                     *(DWORD *)&pDibInfo->pbmi->bmiColors[1] = pDibInfo->ddsd.ddpfPixelFormat.dwGBitMask;
                                     *(DWORD *)&pDibInfo->pbmi->bmiColors[2] = pDibInfo->ddsd.ddpfPixelFormat.dwBBitMask;
                                     break;

                          case DDBD_24:
                                     pDibInfo->pbmi->bmiHeader.biBitCount = 24;
                                     break;

                          case DDBD_32:
                                     pDibInfo->pbmi->bmiHeader.biBitCount = 32;
                                     break;
                          default:
                                     WARNING("bad bitformat for ddraw surface\n");
                       }

                       pDibInfo->rclClipDC.left = 0;
                       pDibInfo->rclClipDC.top =0;
                       pDibInfo->rclClipDC.right = pDibInfo->ddsd.dwWidth;
                       pDibInfo->rclClipDC.bottom = pDibInfo->ddsd.dwWidth;

                       bRet = TRUE;
                    }
               }

               if (hddrawlib)
               {
                   FreeLibrary(hddrawlib);
               }

             }

             Dprintf ("bddraw = %x\n", bddraw);

             #if 0
             if (bddraw)
             {
                 Dprintf("is a directdraw surf dsbm.bmbits = %x", pDibInfo->pvBits);
                 Dprintf("bmType=%x, bmWidthBytes = %x", dib.dsBm.bmType, dib.dsBm.bmWidthBytes);
                 Dprintf("bmWidth = %x, bmHeight = %x, bmPlanes = %x, bmBitsPixel = %x\n",
                          dib.dsBm.bmWidth, dib.dsBm.bmHeight, dib.dsBm.bmPlanes, dib.dsBm.bmBitsPixel);

                 Dprintf("dsBmh.biSize=%x, biWidth = %x, biHeight = %x\n",
                             dib.dsBmih.biSize, dib.dsBmih.biWidth, dib.dsBmih.biHeight);

                 Dprintf("dsBmh.biPlanes = %x, biBitCount = %x, biCompression = %x, biSizeImage = %x\n",
                          dib.dsBmih.biPlanes, dib.dsBmih.biBitCount, dib.dsBmih.biSizeImage);
             }
             #endif

             if (!bddraw)
             {
                 //
                 // If biHeight is positive, then the bitmap is a bottom-up DIB.
                 // If biHeight is negative, then the bitmap is a top-down DIB.
                 //

                 if ( dib.dsBmih.biHeight > 0 )
                 {
                     pDibInfo->pvBase  = (PVOID) (((int) dib.dsBm.bmBits) + (dib.dsBm.bmWidthBytes *
                                                             (dib.dsBm.bmHeight - 1)));
                     pDibInfo->stride = (ULONG) (-dib.dsBm.bmWidthBytes);
                 }
                 else
                 {
                     pDibInfo->pvBase  = dib.dsBm.bmBits;
                     pDibInfo->stride = dib.dsBm.bmWidthBytes;
                 }

                  //
                  // fill up the BITMAPINFOHEADER
                  //
                  pDibInfo->pbmi->bmiHeader = dib.dsBmih;

                  //
                  // fill up the color table
                  //
                  if ((pDibInfo->pbmi->bmiHeader.biBitCount <= 8) || ( pDibInfo->pbmi->bmiHeader.biCompression == BI_BITFIELDS ))
                  {
                      ULONG count = 1 << pDibInfo->pbmi->bmiHeader.biBitCount;

                      GetDIBits(pDibInfo->hdc, hbm, 0, pDibInfo->pbmi->bmiHeader.biHeight, NULL, pDibInfo->pbmi,
                                  DIB_RGB_COLORS);

                  }

                  //
                  // fill prcl
                  //
                  pDibInfo->rclClipDC.left   = 0;
                  pDibInfo->rclClipDC.top    = 0;
                  pDibInfo->rclClipDC.right  = dib.dsBm.bmWidth;
                  pDibInfo->rclClipDC.bottom = dib.dsBm.bmHeight;

                  if (pDibInfo->rclClipDC.bottom < 0)
                  {
                      pDibInfo->rclClipDC.bottom = -pDibInfo->rclClipDC.bottom;
                  }

                  bRet = TRUE;
             }

        }
        else
        {
            Dprintf("not a dibseciton");
        }
    }
    return(bRet);
}





/******************************Public*Routine******************************\
* bFillBimapInfo
*
* Fill up the BITMAPINFO structure based on the hdc passed in
* and fill up the window(if direct dc) or surface (if memory dc)
* rectangle.
*
* if it's a dibsection, convert DIBSECTION to BITMAPINFO
*
* Returns:
*   BOOLEAN
*
* History:
*  09-Dec-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
BOOL bFillBitmapInfo(
    PDIBINFO pDibInfo

// HDC          hdc,
//    RECTL        *prcl,
//    PBITMAPINFO  pbmi,
//    PVOID        *ppvBits,
//    PVOID        *ppvBase,
//    LONG         *plStride
    )
{
    BOOL bRet = FALSE;

    {
       //
       // fill up a BITMAPINFO structure compatible with the
       // Destination DC and reduce ulWidth and ulHeight if
       // possible
       //
       if (GetObjectType(pDibInfo->hdc) == OBJ_DC)
       {
           //
           // get the destination bitmapinfo struct
           //
           if (bRet = bFillBitmapInfoDirect(pDibInfo->hdc, 0, pDibInfo->pbmi))
           {
              HWND hwnd = WindowFromDC(pDibInfo->hdc);

              if (hwnd)
              {
                  GetClientRect(hwnd,(RECT *)&pDibInfo->rclClipDC);
              }
           }
       }
       else if (GetObjectType(pDibInfo->hdc) == OBJ_MEMDC)
       {
           if (!(bRet = bFillDIBSection (pDibInfo)))
           {
               //
               // if the bitmap selected in the memory dc is NOT
               // a DIBSECTION, call bFillBitmapInfoMemory
               //

               if (bRet = bFillBitmapInfoMemory(pDibInfo->hdc, 0, pDibInfo->pbmi))
               {
                   pDibInfo->rclClipDC.left   = 0;
                   pDibInfo->rclClipDC.top    = 0;
                   pDibInfo->rclClipDC.right  = pDibInfo->pbmi->bmiHeader.biWidth;
                   pDibInfo->rclClipDC.bottom = pDibInfo->pbmi->bmiHeader.biHeight;

                   if (pDibInfo->rclClipDC.bottom < 0)
                   {
                       pDibInfo->rclClipDC.bottom = -pDibInfo->rclClipDC.bottom;
                   }
               }
           }

       }
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* bSameDIBformat
*
* Given two BITMAPINFO structs and compare if they are the same
*
* Returns:
*   VOID
*
* History:
*  09-Dec-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
BOOL bSameDIBformat (
    PBITMAPINFO pbmiDst,
    PBITMAPINFO pbmiSrc)
{
    BOOL bRet = FALSE;

    if ((pbmiDst->bmiHeader.biBitCount == pbmiSrc->bmiHeader.biBitCount) &&
        (pbmiDst->bmiHeader.biCompression == pbmiSrc->bmiHeader.biCompression))
    {
        bRet = TRUE;

        //
        // compare bit Bitfields masks
        //
        if (pbmiDst->bmiHeader.biCompression == BI_BITFIELDS)
        {
           if ((*(DWORD *)&pbmiDst->bmiColors[0] != *(DWORD *)&pbmiSrc->bmiColors[0]) ||
               (*(DWORD *)&pbmiDst->bmiColors[1] != *(DWORD *)&pbmiSrc->bmiColors[1]) ||
               (*(DWORD *)&pbmiDst->bmiColors[2] != *(DWORD *)&pbmiSrc->bmiColors[2]))
           {
               bRet = FALSE;
           }
        }

        //
        // compare color table
        //
        if (pbmiDst->bmiHeader.biBitCount <= 8)
        {
            ULONG cColors = 1 << pbmiDst->bmiHeader.biBitCount;
            ULONG i;

            for (i = 0; i < cColors; i++)
            {
                if ((pbmiDst->bmiColors[i].rgbBlue != pbmiSrc->bmiColors[i].rgbBlue) ||
                    (pbmiDst->bmiColors[i].rgbGreen != pbmiSrc->bmiColors[i].rgbGreen) ||
                    (pbmiDst->bmiColors[i].rgbRed != pbmiSrc->bmiColors[i].rgbRed))

                {
                    return (FALSE);
                }
            }
        }
    }
    return (bRet);
}
/******************************Public*Routine******************************\
* CreateCompatibleDIB
*
* Create a DIB_RGB_COLORS dib section based on the given width/height and pbmi
*
* Returns:
*   Bitmap handle
*
* History:
*  09-Dec-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
HBITMAP CreateCompatibleDIB (
    HDC         hdc,
    ULONG       ulWidth,
    ULONG       ulHeight,
    PVOID       *ppvBits,
    PBITMAPINFO pbmi)
{
    HBITMAP hbm;

    //
    // Change bitmap size to match specified dimensions.
    //
    pbmi->bmiHeader.biWidth = ulWidth;
    pbmi->bmiHeader.biHeight = ulHeight;

    if (pbmi->bmiHeader.biCompression == BI_RGB)
    {
        pbmi->bmiHeader.biSizeImage = 0;
    }
    else
    {
        if ( pbmi->bmiHeader.biBitCount == 16 )
            pbmi->bmiHeader.biSizeImage = ulWidth * ulHeight * 2;
        else if ( pbmi->bmiHeader.biBitCount == 32 )
            pbmi->bmiHeader.biSizeImage = ulWidth * ulHeight * 4;
        else
            pbmi->bmiHeader.biSizeImage = 0;
    }

    pbmi->bmiHeader.biClrUsed = 0;
    pbmi->bmiHeader.biClrImportant = 0;

    hbm = CreateDIBSection(hdc, (PBITMAPINFO)pbmi, DIB_RGB_COLORS, ppvBits, NULL, 0);

    return (hbm);
}

/******************************Public*Routine******************************\
* GetCompatibleDIBInfo
*
* Copies pointer to bitmap origin to ppvBase and bitmap stride to plStride.
* Win32 DIBs can be created bottom-up (the default) with the origin at the
* lower left corner or top-down with the origin at the upper left corner.
* If the bitmap is top-down, *plStride is positive; if bottom-up, *plStride
* us negative.
*
* Also, because of restrictions on the alignment of scan lines the width
* the bitmap is often not the same as the stride (stride is the number of
* bytes between vertically adjacent pixels).
*
* The ppvBase and plStride value returned will allow you to address any
* given pixel (x, y) in the bitmap as follows:
*
* PIXEL *ppix;
*
* ppix = (PIXEL *) (((BYTE *)*ppvBase) + (y * *plStride) + (x * sizeof(PIXEL)));
*
* Returns:
*   TRUE if successful, FALSE otherwise.
*
* History:
*  02-Feb-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL GetCompatibleDIBInfo(HBITMAP hbm, PVOID *ppvBase, LONG *plStride)
{
    BOOL bRet = FALSE;
    DIBSECTION ds;

    //
    // Call GetObject to return a DIBSECTION.  If successful, the
    // bitmap is a DIB section and we can retrieve the pointer to
    // the bitmap bits and other parameters.
    //

    if ( (GetObject(hbm, sizeof(ds), &ds) == sizeof(ds))
         && ds.dsBm.bmBits )
    {
        //!!!dbug -- GDI Bug 19374: bmWidthBytes returns pitch assuming
        //!!!        that DIB scanlines are WORD aligned (as they
        //!!!        are in Win95).  But NT DIBs are DWORD aligned.
        //!!!        When bug if corrected, we can remove this block of
        //!!!        code.
        {
            OSVERSIONINFO osvi;

            osvi.dwOSVersionInfoSize = sizeof(osvi);
            if (GetVersionEx(&osvi))
            {
                if ( osvi.dwPlatformId == VER_PLATFORM_WIN32_NT )
                {
                    ds.dsBm.bmWidthBytes = (ds.dsBm.bmWidthBytes + 3) & ~3;
                }
            }
            else
            {
                return bRet;
            }
        }

        //
        // If biHeight is positive, then the bitmap is a bottom-up DIB.
        // If biHeight is negative, then the bitmap is a top-down DIB.
        //

        if ( ds.dsBmih.biHeight > 0 )
        {
            *ppvBase  = (PVOID) (((int) ds.dsBm.bmBits) + (ds.dsBm.bmWidthBytes * (ds.dsBm.bmHeight - 1)));
            *plStride = (ULONG) (-ds.dsBm.bmWidthBytes);
        }
        else
        {
            *ppvBase  = ds.dsBm.bmBits;
            *plStride = ds.dsBm.bmWidthBytes;
        }

        bRet = TRUE;
    }
    else
    {
        WARNING("GetCompatibleDIBInfo: cannot get pointer to DIBSECTION bmBits\n");
    }

    return bRet;
}

/******************************************************
* bSetupBitmapInfos
*
* Calls bFillBitmapInfo to fill the Dst and Src DIBINFO
*
* 4/4/97 -- by Lingyun Wang [lingyunw]
*******************************************************/
BOOL bSetupBitmapInfos(
    PDIBINFO pDibInfoDst,
    PDIBINFO pDibInfoSrc
    )
{
    BOOL bRet;

    bRet = bFillBitmapInfo (pDibInfoDst);

    //
    // fill up bitmapinfo if it is not coming from TransparentDIBits
    //

    if (bRet && (pDibInfoSrc != NULL))
    {
        if (pDibInfoSrc->hdc != NULL)
        {
            bRet = bFillBitmapInfo (pDibInfoSrc);
        }
        else
        {
            //
            // src is DIB
            //

            pDibInfoSrc->rclClipDC.left   = 0;
            pDibInfoSrc->rclClipDC.right  = pDibInfoSrc->pbmi->bmiHeader.biWidth;
            pDibInfoSrc->rclClipDC.top    = 0;
            pDibInfoSrc->rclClipDC.bottom = pDibInfoSrc->pbmi->bmiHeader.biHeight;

            if (pDibInfoSrc->rclClipDC.bottom < 0)
            {
                pDibInfoSrc->rclClipDC.bottom = -pDibInfoSrc->rclClipDC.bottom;
            }

        }
    }

   return (bRet);

}


/******************************Public*Routine******************************\
* vCopyBitmapInfo
*
* Copy a BITMAPINFO stucture along with its bit masks or colortable
*
* Returns:
*   VOID.
*
* History:
*  16-Dec-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
VOID vCopyBitmapInfo (
    PBITMAPINFO pbmiTo,
    PBITMAPINFO pbmiFrom
    )
{
    *pbmiTo = *pbmiFrom;

    //
    // copy BitFields masks
    //

    if (pbmiFrom->bmiHeader.biCompression == BI_BITFIELDS)
    {
        pbmiTo->bmiColors[0] = pbmiFrom->bmiColors[0];
        pbmiTo->bmiColors[1] = pbmiFrom->bmiColors[1];
        pbmiTo->bmiColors[2] = pbmiFrom->bmiColors[2];
    }
    else
    {
        //
        // copy color table
        //

        ULONG cMaxColors = 1 << pbmiFrom->bmiHeader.biBitCount;
        ULONG cColors = pbmiFrom->bmiHeader.biClrUsed;

        //
        // validate number of colors
        //

        if ((cColors == 0) || (cColors > cMaxColors))
        {
            cColors = cMaxColors;
        }

        if (cColors <= 256)
        {
           UINT i;

           for (i = 0; i < cColors; i++)
           {
               pbmiTo->bmiColors[i] = pbmiFrom->bmiColors[i];
           }
        }
    }

    return;
}

/**************************************************************************\
* vIndexToRGB
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    4/16/1997 -by- Lingyun Wang [lingyunw]
*
\**************************************************************************/

VOID vIndexToRGB (
     RGBQUAD *pIndex,
     RGBQUAD *pColors,
     ULONG   count)
{
    ULONG i;

    if (count > 256)
    {
        WARNING ("vIndexToRGB -- bad count\n");
        return;
    }

    for (i=0; i < count; i++)
    {
        pIndex[i] = pColors[((ULONG *)pIndex)[i]];
    }
    return;
}

#if 1

/******************************Public*Routine******************************\
* vMapPALtoRGB
*
* Given a DIB_PAL_COLORS iusage bmiColors table, convert the indices into RGB
* colors, the bmiColors table will be a DIB_RGB_COLORS table after the convertion.
*
* Returns:
*   VOID.
*
* History:
*  16-Dec-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/

VOID
vMapPALtoRGB(
     PDIBINFO pDibInfoDst,
     PDIBINFO pDibInfoSrc,
     ULONG TransColor)
{
    //
    // only called in DIB API case
    //

    if (pDibInfoSrc->hdc == NULL)
    {
        PBITMAPINFO pbmi = (PBITMAPINFO)LOCALALLOC(sizeof(BITMAPINFO) + sizeof(RGBQUAD) * 255);

        if (pbmi)
        {
            ZeroMemory (pbmi,sizeof(BITMAPINFO) + sizeof(RGBQUAD) * 255);
            vCopyBitmapInfo(pbmi, pDibInfoSrc->pbmi);

            HPALETTE hpalDC = (HPALETTE)GetCurrentObject(pDibInfoDst->hdc,OBJ_PAL);

            if (hpalDC)
            {
                USHORT usNumPaletteEntries = 0;
                DWORD numColors;
                DWORD bmiClrUsed = pDibInfoSrc->pbmi->bmiHeader.biClrUsed;

                int iRet = GetObject(hpalDC,2,&usNumPaletteEntries);

                if ((iRet != 0) && (usNumPaletteEntries != 0))
                {
                    switch (pDibInfoSrc->pbmi->bmiHeader.biBitCount)
                    {
                    case 1:
                        numColors = 2;
                        break;

                    case 4:
                        numColors = 16;
                        if ((bmiClrUsed > 0) &&
                            (bmiClrUsed < 16)
                           )
                        {
                            numColors = bmiClrUsed;
                        }
                        break;

                    case 8:
                        numColors = 256;
                        if ((bmiClrUsed > 0) &&
                            (bmiClrUsed < 256)
                           )
                        {
                            numColors = bmiClrUsed;
                        }
                        break;
                    default:
                        numColors = 0;
                    }

                    if (numColors != 0)
                    {
                        PALETTEENTRY *ppal = (PALETTEENTRY *)LOCALALLOC(sizeof(PALETTEENTRY) * usNumPaletteEntries);

                        if (ppal)
                        {
                            iRet = GetPaletteEntries(hpalDC,0,usNumPaletteEntries,ppal);

                            if (iRet == (int)usNumPaletteEntries)
                            {
                                ULONG   Index;

                                RGBQUAD *pRGB     = (RGBQUAD *)&pbmi->bmiColors[0];
                                PUSHORT pPalIndex = (PUSHORT)&pDibInfoSrc->pbmi->bmiColors[0];

                                //
                                // map PALETTEENTRY to RGBQUAD
                                //

                                for (Index=0;Index<numColors;Index++)
                                {
                                    ULONG CurIndex = pPalIndex[Index];

                                    if (CurIndex > usNumPaletteEntries)
                                    {
                                        CurIndex = CurIndex % usNumPaletteEntries;
                                    }

                                    pRGB[Index].rgbRed      = ppal[CurIndex].peRed;
                                    pRGB[Index].rgbGreen    = ppal[CurIndex].peGreen;
                                    pRGB[Index].rgbBlue     = ppal[CurIndex].peBlue;
                                    pRGB[Index].rgbReserved = ppal[CurIndex].peFlags;
                                }

                                //
                                // swap pbmi in pDibInfoSrc
                                //

                                LOCALFREE(pDibInfoSrc->pbmi);

                                pDibInfoSrc->pbmi = pbmi;
                            }

                            LOCALFREE(ppal);
                        }
                    }
                }
            }
        }
    }

}

#else

/******************************Public*Routine******************************\
* vMapPALtoRGB
*
* Given a DIB_PAL_COLORS iusage bmiColors table, convert the indices into RGB
* colors, the bmiColors table will be a DIB_RGB_COLORS table after the convertion.
*
* Returns:
*   VOID.
*
* History:
*  16-Dec-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/

VOID
vMapPALtoRGB(
     PDIBINFO pDibInfoDst,
     PDIBINFO pDibInfoSrc,
     ULONG TransColor)
{
    HDC         hdc = pDibInfoDst->hdc;
    HDC         hdcMem;
    ULONG       cx = 1 << pDibInfoSrc->pbmi->bmiHeader.biBitCount;
    HBITMAP     hbm;
    PULONG      pBits;
    ULONG       cBytes = sizeof(BITMAPINFO) + sizeof(RGBQUAD) * 2;
    PBITMAPINFO pbmi;
    ULONG       i;
    BYTE        pBytes[256];
    ULONG       ulWidthDst, ulHeightDst, ulWidthSrc, ulHeightSrc;
    HPALETTE    hpalDC;

    pbmi = (PBITMAPINFO)LOCALALLOC(cBytes);

    if (pbmi == NULL)
    {
        WARNING("MapCopy fail to alloc mem\n");
        return ;
    }

    hdcMem = CreateCompatibleDC (hdc);

    if (hdcMem != NULL)
    {
        HPALETTE hpalDC = (HPALETTE)GetCurrentObject(hdc,OBJ_PAL);

        SelectPalette(hdcMem,hpalDC,TRUE);
        RealizePalette(hdcMem);

        pbmi->bmiHeader.biSize            = sizeof(BITMAPINFOHEADER);
        pbmi->bmiHeader.biWidth           = 256;
        pbmi->bmiHeader.biHeight          = 1;
        pbmi->bmiHeader.biPlanes          = 1;
        pbmi->bmiHeader.biBitCount        = 32;
        pbmi->bmiHeader.biCompression     = BI_RGB;
        pbmi->bmiHeader.biSizeImage       = 0;
        pbmi->bmiHeader.biXPelsPerMeter   = 0;
        pbmi->bmiHeader.biYPelsPerMeter   = 0;
        pbmi->bmiHeader.biClrUsed         = 0;
        pbmi->bmiHeader.biClrImportant    = 0;

        //
        // save the original width/height
        //

        ulWidthDst = pDibInfoDst->pbmi->bmiHeader.biWidth;
        ulHeightDst = pDibInfoDst->pbmi->bmiHeader.biHeight;

        pDibInfoDst->pbmi->bmiHeader.biWidth = 256;
        pDibInfoDst->pbmi->bmiHeader.biHeight = 1;

        //
        // create a dib using 32 format
        //

        hbm = CreateDIBSection(hdc, pbmi, DIB_RGB_COLORS, (PVOID *)&pBits, NULL, 0);

        if ((hbm != NULL) && (SelectObject(hdcMem,hbm) != NULL))
        {
            //
            // init pBytes to array of each pixel
            //

            switch (cx)
            {
            case 256:
                for (i=0; i < cx; i++)
                {
                    pBytes[i] = (BYTE)i;
                }
                break;

            case 16:
                pBytes[0] = 0x01;
                pBytes[1] = 0x23;
                pBytes[2] = 0x45;
                pBytes[3] = 0x67;
                pBytes[4] = 0x89;
                pBytes[5] = 0xab;
                pBytes[6] = 0xcd;
                pBytes[7] = 0xef;
                break;

            case 2:
                pBytes[0] = 0x40;
                break;
            }

            ulWidthSrc  = pDibInfoSrc->pbmi->bmiHeader.biWidth;
            ulHeightSrc = pDibInfoSrc->pbmi->bmiHeader.biHeight;

            pDibInfoSrc->pbmi->bmiHeader.biWidth = cx;
            pDibInfoSrc->pbmi->bmiHeader.biHeight = 1;


            if (!SetDIBitsToDevice (hdcMem, 0, 0, cx, 1, 0, 0, 0, 1, pBytes, pDibInfoSrc->pbmi, DIB_PAL_COLORS))
            {
                 //Dprintf("fail to SetDIBitsTodevice HDC=%x\n",hdcMem);
            }


            for (i=0; i < cx; i++)
            {
                pDibInfoSrc->pbmi->bmiColors[i] = ((RGBQUAD *)pBits)[i];
                //Dprintf("i=%x, pBits[i]=%x", i, pBits[i]);
            }

            pDibInfoSrc->pbmi->bmiHeader.biWidth = ulWidthSrc;
            pDibInfoSrc->pbmi->bmiHeader.biHeight = ulHeightSrc;


            pDibInfoDst->pbmi->bmiHeader.biWidth = ulWidthDst;
            pDibInfoDst->pbmi->bmiHeader.biHeight = ulHeightDst;

            pDibInfoSrc->iUsage = DIB_RGB_COLORS;
        }

        DeleteDC (hdcMem);

        if (hbm != NULL)
        {
            DeleteObject(hbm);
        }
    }
}

#endif


/**************************************************************************\
* bGetSrcDIBits:
*
*   Setup SRC DIB surface and retrieve the dibits.
*   Ported from kernel mode
*
* Arguments:
*
*   pDibInfoDst  - information on dest surface
*   pDibInfoSrc  - information on src surfcace
*   ulSourceType - type of src surface needed
*   ulTranColor  - transparent color for TransparentBlt
*
* Return Value:
*
*   Status
*
* History:
*
*    4/16/1997 - by Lingyun Wang [lingyunw]
*
\**************************************************************************/

BOOL
bGetSrcDIBits(
    PDIBINFO pDibInfoDst,
    PDIBINFO pDibInfoSrc,
    ULONG    ulSourceType,
    ULONG    ulTranColor
    )
{
    BOOL bRet  = TRUE;
    LONG DstCx = pDibInfoDst->rclBounds.right  - pDibInfoDst->rclBounds.left;
    LONG DstCy = pDibInfoDst->rclBounds.bottom - pDibInfoDst->rclBounds.top;

    LONG SrcCx = pDibInfoSrc->rclBounds.right  - pDibInfoSrc->rclBounds.left;
    LONG SrcCy = pDibInfoSrc->rclBounds.bottom - pDibInfoSrc->rclBounds.top;

    PVOID       pvBits  = pDibInfoSrc->pvBits;
    PBITMAPINFO pbmi    = NULL;
    HDC         hdcTemp = NULL;
    HBITMAP     hbm;

    LONG   SrcTrimLeft;
    LONG   SrcTrimRight;
    LONG   SrcTrimTop;
    LONG   SrcTrimBottom;

    BOOL bStretch = ((DstCx != SrcCx) || (DstCy != SrcCy));

    SrcTrimLeft   = 0;
    SrcTrimRight  = 0;
    SrcTrimTop    = 0;
    SrcTrimBottom = 0;

    //
    // trim destination bounds rect to surface bounds. Src rect must also
    // be trimmed by same amount (in src space)
    //

    if (pDibInfoDst->rclBoundsTrim.left < pDibInfoDst->rclClipDC.left)
    {
        SrcTrimLeft = pDibInfoDst->rclClipDC.left - pDibInfoDst->rclBoundsTrim.left;
        pDibInfoDst->rclBoundsTrim.left = pDibInfoDst->rclClipDC.left;
    }

    if (pDibInfoDst->rclBoundsTrim.top < pDibInfoDst->rclClipDC.top)
    {
        SrcTrimTop = pDibInfoDst->rclClipDC.top - pDibInfoDst->rclBoundsTrim.top;
        pDibInfoDst->rclBoundsTrim.top = pDibInfoDst->rclClipDC.top;
    }

    if (pDibInfoDst->rclBoundsTrim.right > pDibInfoDst->rclClipDC.right)
    {
        SrcTrimRight = pDibInfoDst->rclBoundsTrim.right - pDibInfoDst->rclClipDC.right;
        pDibInfoDst->rclBoundsTrim.right = pDibInfoDst->rclClipDC.right;
    }

    if (pDibInfoDst->rclBoundsTrim.bottom > pDibInfoDst->rclClipDC.bottom)
    {
        SrcTrimBottom = pDibInfoDst->rclBoundsTrim.bottom - pDibInfoDst->rclClipDC.bottom;
        pDibInfoDst->rclBoundsTrim.bottom = pDibInfoDst->rclClipDC.bottom;
    }

    //
    // does src need to be reduced because of dst
    //

    if (bStretch)
    {
        //
        // convert dst trim to src space and reduce src rect
        //
        // WARNING: ROUNDING
        //

        if ((SrcTrimLeft != 0) || (SrcTrimRight != 0))
        {
            double fDstToSrcX = (double)SrcCx / (double)DstCx;

            //
            // convert dst trim amound to src
            //

            SrcTrimLeft  = (LONG)((double)SrcTrimLeft * fDstToSrcX);
            SrcTrimRight = (LONG)((double)SrcTrimRight * fDstToSrcX);

            pDibInfoSrc->rclBoundsTrim.left  += SrcTrimLeft;
            pDibInfoSrc->rclBoundsTrim.right -= SrcTrimRight;
        }

        if ((SrcTrimTop != 0) || (SrcTrimBottom != 0))
        {
            double fDstToSrcY = (double)SrcCy / (double)DstCy;

            //
            // convert dst trim amound to src
            //

            SrcTrimTop    = (LONG)((double)SrcTrimTop * fDstToSrcY);
            SrcTrimBottom = (LONG)((double)SrcTrimBottom * fDstToSrcY);

            pDibInfoSrc->rclBoundsTrim.top    += SrcTrimTop;
            pDibInfoSrc->rclBoundsTrim.bottom -= SrcTrimBottom;
        }
    }
    else
    {
        //
        // reduce src rect
        //

        if (SrcTrimLeft != 0)
        {
            pDibInfoSrc->rclBoundsTrim.left  += SrcTrimLeft;
        }

        if (SrcTrimRight != 0)
        {
            pDibInfoSrc->rclBoundsTrim.right -= SrcTrimRight;
        }

        if (SrcTrimTop != 0)
        {
            pDibInfoSrc->rclBoundsTrim.top    += SrcTrimTop;
        }

        if (SrcTrimBottom != 0)
        {
            pDibInfoSrc->rclBoundsTrim.bottom -= SrcTrimBottom;
        }
    }

    //
    // Does src still exceed bounds
    //

    SrcTrimLeft   = 0;
    SrcTrimRight  = 0;
    SrcTrimTop    = 0;
    SrcTrimBottom = 0;

    //
    // trim destination bounds rect to surface bounds. Src rect must also
    // be trimmed by same amount (in src space)
    //

    if (pDibInfoSrc->rclBoundsTrim.left < pDibInfoSrc->rclClipDC.left)
    {
        SrcTrimLeft = pDibInfoSrc->rclClipDC.left - pDibInfoSrc->rclBoundsTrim.left;
        pDibInfoSrc->rclBoundsTrim.left = pDibInfoSrc->rclClipDC.left;
    }

    if (pDibInfoSrc->rclBoundsTrim.top < pDibInfoSrc->rclClipDC.top)
    {
        SrcTrimTop = pDibInfoSrc->rclClipDC.top - pDibInfoSrc->rclBoundsTrim.top;
        pDibInfoSrc->rclBoundsTrim.top = pDibInfoSrc->rclClipDC.top;
    }

    if (pDibInfoSrc->rclBoundsTrim.right > pDibInfoSrc->rclClipDC.right)
    {
        SrcTrimRight = pDibInfoSrc->rclBoundsTrim.right - pDibInfoSrc->rclClipDC.right;
        pDibInfoSrc->rclBoundsTrim.right = pDibInfoSrc->rclClipDC.right;
    }

    if (pDibInfoSrc->rclBoundsTrim.bottom > pDibInfoSrc->rclClipDC.bottom)
    {
        SrcTrimBottom = pDibInfoSrc->rclBoundsTrim.bottom - pDibInfoSrc->rclClipDC.bottom;
        pDibInfoSrc->rclBoundsTrim.bottom = pDibInfoSrc->rclClipDC.bottom;
    }

    //
    // does Dst need to be reduced because of Src
    //

    if (bStretch)
    {
        //
        // WARNING: ROUNDING
        //

        if ((SrcTrimLeft != 0) || (SrcTrimRight != 0))
        {
            double fSrcToDstX = (double)DstCx / (double)SrcCx;

            //
            // convert dst trim amound to src
            //

            SrcTrimLeft  = (LONG)((double)SrcTrimLeft * fSrcToDstX);
            SrcTrimRight = (LONG)((double)SrcTrimRight * fSrcToDstX);

            pDibInfoDst->rclBoundsTrim.left  += SrcTrimLeft;
            pDibInfoDst->rclBoundsTrim.right -= SrcTrimRight;
        }

        if ((SrcTrimTop != 0) || (SrcTrimBottom != 0))
        {
            double fSrcToDstY = (double)DstCy / (double)SrcCy;

            //
            // convert dst trim amound to src
            //

            SrcTrimTop    = (LONG)((double)SrcTrimTop * fSrcToDstY);
            SrcTrimBottom = (LONG)((double)SrcTrimBottom * fSrcToDstY);

            pDibInfoDst->rclBoundsTrim.top    += SrcTrimTop;
            pDibInfoDst->rclBoundsTrim.bottom -= SrcTrimBottom;
        }
    }
    else
    {
        //
        // reduce dst rect
        //

        if (SrcTrimLeft != 0)
        {
            pDibInfoDst->rclBoundsTrim.left  += SrcTrimLeft;
        }

        if (SrcTrimRight != 0)
        {
            pDibInfoDst->rclBoundsTrim.right -= SrcTrimRight;
        }

        if (SrcTrimTop != 0)
        {
            pDibInfoDst->rclBoundsTrim.top    += SrcTrimTop;
        }

        if (SrcTrimBottom != 0)
        {
            pDibInfoDst->rclBoundsTrim.bottom -= SrcTrimBottom;
        }
    }

    //
    // check for clipped out Dst and Src
    //

    if (
        (pDibInfoDst->rclBoundsTrim.left < pDibInfoDst->rclBoundsTrim.right)  &&
        (pDibInfoDst->rclBoundsTrim.top  < pDibInfoDst->rclBoundsTrim.bottom) &&
        (pDibInfoSrc->rclBoundsTrim.left < pDibInfoSrc->rclBoundsTrim.right)  &&
        (pDibInfoSrc->rclBoundsTrim.top  < pDibInfoSrc->rclBoundsTrim.bottom)
       )
    {
        //
        // allocate compatible DC and surface
        //

        hdcTemp = CreateCompatibleDC(pDibInfoSrc->hdc);

        if (hdcTemp)
        {
            //
            // copy pDibInfoSrc->pbmi into pbmi
            //

            if (!pDibInfoSrc->hdc)
            {
                ULONG cBytes = sizeof(BITMAPINFO) + sizeof(RGBQUAD) * 255;
                pbmi = (PBITMAPINFO)LOCALALLOC(cBytes);

                if (pbmi != NULL)
                {
                    ZeroMemory (pbmi,cBytes);
                    vCopyBitmapInfo (pbmi, pDibInfoSrc->pbmi);
                }
                else
                {
                    WARNING("bGetSrcDIBits fail to alloc mem\n");
                    bRet = FALSE;
                }
            }

            if (bRet)
            {
                //
                // create temp DIB size of dst rect
                //

                RECTL  rclDstCopy = {
                                     0,
                                     0,
                                     pDibInfoDst->rclBoundsTrim.right  - pDibInfoDst->rclBoundsTrim.left,
                                     pDibInfoDst->rclBoundsTrim.bottom - pDibInfoDst->rclBoundsTrim.top
                                    };

                hbm = CreateCompatibleDIB(hdcTemp,
                                          rclDstCopy.right,
                                          rclDstCopy.bottom,
                                          &pDibInfoSrc->pvBits,
                                          pDibInfoSrc->pbmi);

                if (hbm)
                {
                    pDibInfoSrc->hDIB = hbm;

                    GetCompatibleDIBInfo (hbm, &pDibInfoSrc->pvBase, &pDibInfoSrc->stride);

                    HBITMAP hbmDefault = (HBITMAP)SelectObject (hdcTemp, hbm);

                    ULONG OldMode = SetStretchBltMode(hdcTemp,COLORONCOLOR);

                    //
                    // Stretch data into source temp DIB
                    //
                    //
                    // Blt data into source temp DIB
                    //

                    if (pDibInfoSrc->hdc)
                    {
                        StretchBlt (hdcTemp,
                             0,
                             0,
                             rclDstCopy.right,
                             rclDstCopy.bottom,
                             pDibInfoSrc->hdc,
                             pDibInfoSrc->rclBoundsTrim.left,
                             pDibInfoSrc->rclBoundsTrim.top,
                             pDibInfoSrc->rclBoundsTrim.right  - pDibInfoSrc->rclBoundsTrim.left,
                             pDibInfoSrc->rclBoundsTrim.bottom - pDibInfoSrc->rclBoundsTrim.top,
                             SRCCOPY);
                    }
                    else
                    {

                        //
                        // adjust ySrc to be compatible
                        //

                        LONG cySrc = pDibInfoSrc->rclBoundsTrim.bottom-pDibInfoSrc->rclBoundsTrim.top;
                        LONG ySrc  = pDibInfoSrc->rclClipDC.bottom - pDibInfoSrc->rclBoundsTrim.top - cySrc;

                        StretchDIBits (hdcTemp,
                             0,
                             0,
                             rclDstCopy.right,
                             rclDstCopy.bottom,
                             pDibInfoSrc->rclBoundsTrim.left,
                             ySrc,
                             pDibInfoSrc->rclBoundsTrim.right-pDibInfoSrc->rclBoundsTrim.left,
                             cySrc,
                             pvBits,
                             pbmi,
                             DIB_RGB_COLORS,
                             SRCCOPY);
                    }

                    SetStretchBltMode(hdcTemp,OldMode);

                    SelectObject (hdcTemp, hbmDefault);

                    pDibInfoSrc->rclDIB = rclDstCopy;
                }
                else
                {
                    WARNING ("bGetSrcDIBits -- fail to createcompatibleDIB\n");
                    bRet = FALSE;
                }
            }
        }
        else
        {
            WARNING ("bGetSrcDIBits -- fail to createcompatibledc\n");
            bRet = FALSE;
        }
    }
    else
    {
        //
        // clipped out
        //

        pDibInfoDst->rclBoundsTrim.left = pDibInfoDst->rclBoundsTrim.right  = 0;
        pDibInfoDst->rclBoundsTrim.top  = pDibInfoDst->rclBoundsTrim.bottom = 0;
        pDibInfoSrc->rclBoundsTrim.left = pDibInfoSrc->rclBoundsTrim.right  = 0;
        pDibInfoSrc->rclBoundsTrim.top  = pDibInfoSrc->rclBoundsTrim.bottom = 0;
    }

    if (pbmi)
    {
        LOCALFREE (pbmi);
    }

    if (hdcTemp)
    {
        DeleteDC(hdcTemp);
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* bGetDstDIBits
*
* Setup the destination DIB surface and retrieve the bits
*
* Ported from psSetupDstSurface
*
*
*
* Return Value:
*
*
*
* History:
*
*    4-April-1997 -by- Lingyun Wang [lingyunw]
*
\**************************************************************************/

BOOL
bGetDstDIBits
(
    PDIBINFO pDibInfoDst,
    BOOL    *pbReadable,
    FLONG    flCopyMode
)
{
    HDC  hdc  = pDibInfoDst->hdc;
    BOOL bRet = TRUE;

    //
    // try to clip to dst surface, dst should be clipped in all cases except
    // gradient fill
    //

    if (flCopyMode & (SOURCE_GRADIENT_RECT | SOURCE_GRADIENT_TRI))
    {
        //
        // trim destination bounds rect to surface bounds. Src rect must also
        // be trimmed by same amount (in src space)
        //

        if (pDibInfoDst->rclBoundsTrim.left < pDibInfoDst->rclClipDC.left)
        {
            pDibInfoDst->rclBoundsTrim.left = pDibInfoDst->rclClipDC.left;
        }

        if (pDibInfoDst->rclBoundsTrim.top < pDibInfoDst->rclClipDC.top)
        {
            pDibInfoDst->rclBoundsTrim.top = pDibInfoDst->rclClipDC.top;
        }

        if (pDibInfoDst->rclBoundsTrim.right > pDibInfoDst->rclClipDC.right)
        {
            pDibInfoDst->rclBoundsTrim.right = pDibInfoDst->rclClipDC.right;
        }

        if (pDibInfoDst->rclBoundsTrim.bottom > pDibInfoDst->rclClipDC.bottom)
        {
            pDibInfoDst->rclBoundsTrim.bottom = pDibInfoDst->rclClipDC.bottom;
        }

        //
        // set offset for gradient fill
        //

        pDibInfoDst->ptlGradOffset.x = 0;
        pDibInfoDst->ptlGradOffset.y = 0;

    }

    LONG DstCx = pDibInfoDst->rclBoundsTrim.right  - pDibInfoDst->rclBoundsTrim.left;
    LONG DstCy = pDibInfoDst->rclBoundsTrim.bottom - pDibInfoDst->rclBoundsTrim.top;

    *pbReadable = TRUE;

    if (!pDibInfoDst->pvBits)
    {

        if (pDibInfoDst->rclBounds.left > 0)
        {
            pDibInfoDst->ptlGradOffset.x = pDibInfoDst->rclBounds.left;
        }

        if (pDibInfoDst->rclBounds.top > 0)
        {
            pDibInfoDst->ptlGradOffset.y = pDibInfoDst->rclBounds.top;
        }

        //
        // allocate surface
        //

        HDC hdcTemp = CreateCompatibleDC (hdc);

        if (hdcTemp)
        {
            HBITMAP hbm = CreateCompatibleDIB (hdcTemp,
                                       DstCx,
                                       DstCy,
                                       &pDibInfoDst->pvBits,
                                       pDibInfoDst->pbmi);

            if (hbm != NULL)
            {
                pDibInfoDst->hDIB = hbm;
                GetCompatibleDIBInfo (hbm, &pDibInfoDst->pvBase, &pDibInfoDst->stride);

                HGDIOBJ hret = SelectObject(hdcTemp, hbm);

                if (hret != NULL)
                {
                    RECTL  rclCopy;

                    rclCopy.left   = 0;
                    rclCopy.right  = DstCx;
                    rclCopy.top    = 0;
                    rclCopy.bottom = DstCy;

                    //
                    // gradient rect does not need source bitmap data
                    //

                    if (flCopyMode != SOURCE_GRADIENT_RECT)
                    {
                        bRet = BitBlt(hdcTemp,
                                      0,
                                      0,
                                      DstCx,
                                      DstCy,
                                      pDibInfoDst->hdc,
                                      pDibInfoDst->rclBoundsTrim.left,
                                      pDibInfoDst->rclBoundsTrim.top,
                                      SRCCOPY);
                    }

                    //
                    // adjust dst rect
                    //

                    if (bRet)
                    {
                        pDibInfoDst->rclDIB = rclCopy;
                    }
                }
                else
                {
                    bRet = NULL;
                    WARNING ("bGetDstDIBits -- fail to select compatible DIB\n");
                }

                *pbReadable = bRet;
            }
            else
            {
                bRet = FALSE;
            }

            DeleteDC (hdcTemp);
        }
        else
        {
            WARNING ("bGetDstDIBits -- fail to createcompatibledc\n");
            bRet = FALSE;
        }
    }
    else
    {
        pDibInfoDst->rclDIB = pDibInfoDst->rclClipDC;
    }

    return(bRet);
}



/******************************Public*Routine******************************\
* bDIBGetSrcDIBits
*
* Create or get the source dib bits
*
* Returns:
*   VOID.
*
* History:
*  09-Dec-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
BOOL bDIBGetSrcDIBits (
    PDIBINFO pDibInfoDst,
    PDIBINFO pDibInfoSrc,
    FLONG    flSourceMode,
    ULONG    TransColor
    )
{

    if (pDibInfoSrc->iUsage == DIB_PAL_COLORS)
    {
        vMapPALtoRGB (pDibInfoDst, pDibInfoSrc, 0);
    }

    //pDibInfoSrc->rclDIB = pDibInfoSrc->rclClipDC;

    return (bGetSrcDIBits(pDibInfoDst,pDibInfoSrc,flSourceMode, TransColor));

}

/******************************Public*Routine******************************\
* bDIBInitDIBINFO
*
* Returns:
*   BOOLEAN.
*
* History:
*  09-Dec-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
BOOL
bDIBInitDIBINFO(
          PBITMAPINFO  pbmi,
          CONST VOID * pvBits,
          int          x,
          int          y,
          int          cx,
          int          cy,
          PDIBINFO     pDibInfo)
{
    PVOID p;
    ULONG cBytes = sizeof(BITMAPINFO) + sizeof(RGBQUAD) * 255;
    int bmWidthBytes;
    POINT lpPoints[2];

    p = LOCALALLOC(cBytes);

    if (!p)
    {
        WARNING("fail to alloc mem\n");
        return (FALSE);
    }

    ZeroMemory (p,cBytes);

    //
    // copy the input pbmi
    //

    vCopyBitmapInfo ((PBITMAPINFO)p, pbmi);

    pDibInfo->pbmi = (PBITMAPINFO)p;
    pDibInfo->hdc  = NULL;

    pDibInfo->rclBounds.left   = x;
    pDibInfo->rclBounds.top    = y;
    pDibInfo->rclBounds.right  = x+cx;
    pDibInfo->rclBounds.bottom = y+cy;

    pDibInfo->rclBoundsTrim = pDibInfo->rclBounds;

    pDibInfo->pvBits    = (PVOID)pvBits;
    pDibInfo->iUsage    = DIB_RGB_COLORS;
    pDibInfo->pxlate332 = NULL;

    //
    // align width to WORD boundary
    //

    bmWidthBytes = ((pbmi->bmiHeader.biWidth*pbmi->bmiHeader.biBitCount + 15)>>4)<<1;

    if (pbmi->bmiHeader.biHeight > 0)
    {
        pDibInfo->pvBase  = (PBYTE)pDibInfo->pvBits + bmWidthBytes * (pbmi->bmiHeader.biHeight - 1);
        pDibInfo->stride  = (ULONG) (-bmWidthBytes);
    }
    else
    {
        pDibInfo->pvBase = pDibInfo->pvBits;
        pDibInfo->stride = bmWidthBytes;
    }

    pDibInfo->hDIB   = NULL;

    pDibInfo->pdds = NULL;
    pDibInfo->ddsd.dwSize = sizeof(DDSURFACEDESC);

    return(TRUE);
}

/******************************Public*Routine******************************\
* bInitDIBINFO
*
* Returns:
*   BOOLEAN.
*
* History:
*  09-Dec-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
BOOL
bInitDIBINFO(
          HDC         hdc,
          int         x,
          int         y,
          int         cx,
          int         cy,
          PDIBINFO    pDibInfo)
{
    ULONG cBytes;
    PVOID p;
    POINT lpPoints[2];

    pDibInfo->hdc = hdc;

    pDibInfo->rclBounds.left   = x;
    pDibInfo->rclBounds.top    = y;
    pDibInfo->rclBounds.right  = x+cx;
    pDibInfo->rclBounds.bottom = y+cy;

    //
    // setup rclBounds in device space
    //

    LPtoDP (hdc, (POINT *)&pDibInfo->rclBounds, 2);

    pDibInfo->rclBoundsTrim = pDibInfo->rclBounds;

    //
    // Now operate in MM_TEXT mode
    //

    pDibInfo->Mapmode = SetMapMode(hdc,MM_TEXT);
    SetViewportOrgEx (hdc, 0, 0, &pDibInfo->ViewportOrg);
    SetWindowOrgEx (hdc, 0, 0, &pDibInfo->WindowOrg);


    pDibInfo->pvBits    = NULL;
    pDibInfo->pvBase    = NULL;
    pDibInfo->hDIB      = NULL;
    pDibInfo->iUsage    = DIB_RGB_COLORS;
    pDibInfo->pxlate332 = NULL;

    cBytes = sizeof(BITMAPINFO) + sizeof(RGBQUAD) * 255;

    p = LOCALALLOC(cBytes);

    if (!p)
    {
        WARNING("fail to alloc mem\n");
        return (FALSE);
    }

    ZeroMemory (p,cBytes);

    pDibInfo->pbmi = (PBITMAPINFO)p;

    pDibInfo->pdds = NULL;
    pDibInfo->ddsd.dwSize = sizeof(DDSURFACEDESC);

    return(TRUE);
}

/******************************Public*Routine******************************\
* bSendDIBInfo
*
* Returns:
*   BOOLEAN.
*
* History:
*  09-Dec-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
BOOL
bSendDIBINFO(
    HDC      hdcDst,
    PDIBINFO pDibInfo
    )
{
    BOOL bRet = TRUE;

    if (pDibInfo->hDIB)
    {
        ULONG OldMode = SetStretchBltMode(hdcDst,COLORONCOLOR);

        bRet = SetDIBitsToDevice(hdcDst,
                                 pDibInfo->rclBoundsTrim.left,
                                 pDibInfo->rclBoundsTrim.top,
                                 pDibInfo->rclBoundsTrim.right  - pDibInfo->rclBoundsTrim.left,
                                 pDibInfo->rclBoundsTrim.bottom - pDibInfo->rclBoundsTrim.top,
                                 0,
                                 0,
                                 0,
                                 pDibInfo->rclDIB.bottom - pDibInfo->rclDIB.top,
                                 pDibInfo->pvBits,
                                 pDibInfo->pbmi,
                                 DIB_RGB_COLORS);

        SetStretchBltMode(hdcDst,OldMode);
    }
    return (bRet);
}

/******************************Public*Routine******************************\
* vCleanupDIBInfo
*
* Returns:
*   VOID.
*
* History:
*  09-Dec-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
VOID vCleanupDIBINFO (
     PDIBINFO pDibInfo)
{
    //
    // restore DC map modes
    //

    SetMapMode(pDibInfo->hdc,pDibInfo->Mapmode);
    SetViewportOrgEx (pDibInfo->hdc, pDibInfo->ViewportOrg.x, pDibInfo->ViewportOrg.y, NULL);
    SetWindowOrgEx (pDibInfo->hdc, pDibInfo->WindowOrg.x, pDibInfo->WindowOrg.y, NULL);

    if (pDibInfo->hDIB)
    {
        DeleteObject (pDibInfo->hDIB);
    }

    if (pDibInfo->pbmi)
    {
        LOCALFREE ((PVOID)pDibInfo->pbmi);
    }

    if ((pDibInfo->pxlate332) && (pDibInfo->pxlate332 != gHalftoneColorXlate332))
    {
        LOCALFREE(pDibInfo->pxlate332);
    }

    if (pDibInfo->pdds)
        pDibInfo->pdds->Unlock(pDibInfo->ddsd.lpSurface);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\image\tmp\alphatran.cxx ===
/******************************Module*Header*******************************\
* Module Name: tranblt.cxx
*
* Transparent BLT
*
* Created: 21-Jun-1996
* Author: Mark Enstrom [marke]
*
* Copyright (c) 1996-1999 Microsoft Corporation
\**************************************************************************/
#include "precomp.hxx"

#if !(_WIN32_WINNT >= 0x500)

/******************************Public*Routine******************************\
* Routines to load a pixel and convert it to BGRA representaion for 
* blending operations
*   
* Arguments:
*   
*
*
* Return Value:
*
*
*
* History:
*
*    12/2/1996 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vLoadAndConvert1ToBGRA(
    PULONG   pulDstAddr,
    PBYTE    pSrcAddr,
    LONG     SrcX,
    LONG     SrcCx,
    PVOID    ppalInfo
    )
{
    BYTE   SrcByte;
    LONG   cxUnalignedStart = 7 & (8 - (SrcX & 7));
    PULONG ppal = (PULONG)&((PPALINFO)ppalInfo)->pBitmapInfo->bmiColors[0];

    pSrcAddr = pSrcAddr + (SrcX >> 3);

    cxUnalignedStart = MIN(SrcCx,cxUnalignedStart);

    //
    // unaligned start
    //

    if (cxUnalignedStart)
    {
        LONG iDst = 7 - (SrcX & 0x07); 
        SrcByte = *pSrcAddr;
        pSrcAddr++;

        while (cxUnalignedStart--)
        {
            ULONG ulSrc = ((SrcByte & (1 << iDst)) >> iDst);
    
            ulSrc = ppal[ulSrc] | 0xFF000000;
            *pulDstAddr = ulSrc;
            
            pulDstAddr++;
            SrcCx--;
            iDst--;
        }
    }

    //
    // aligned whole bytes
    //

    while (SrcCx >= 8)
    {
        SrcCx -= 8;

        SrcByte = *pSrcAddr;

        *(pulDstAddr + 0) = (ppal[(SrcByte & 0x80) >> 7] | 0xff000000);
        *(pulDstAddr + 1) = (ppal[(SrcByte & 0x40) >> 6] | 0xff000000);
        *(pulDstAddr + 2) = (ppal[(SrcByte & 0x20) >> 5] | 0xff000000);
        *(pulDstAddr + 3) = (ppal[(SrcByte & 0x10) >> 4] | 0xff000000);
        *(pulDstAddr + 4) = (ppal[(SrcByte & 0x08) >> 3] | 0xff000000);
        *(pulDstAddr + 5) = (ppal[(SrcByte & 0x04) >> 2] | 0xff000000);
        *(pulDstAddr + 6) = (ppal[(SrcByte & 0x02) >> 1] | 0xff000000);
        *(pulDstAddr + 7) = (ppal[(SrcByte & 0x01) >> 0] | 0xff000000);

        pSrcAddr++;
        pulDstAddr+=8;
    }

    //
    // unaligned end
    //

    if (SrcCx)
    {
        BYTE SrcByte = *pSrcAddr;
        LONG iDst    = 7;

        while (SrcCx)
        {
            ULONG ulSrc = ((SrcByte & (1 << iDst)) >> iDst);
    
            ulSrc = ppal[ulSrc] | 0xff000000;
            *pulDstAddr = ulSrc;
            
            pulDstAddr++;
            SrcCx--;
            iDst--;
        }
    }
}

/**************************************************************************\
* vLoadAndConvert4ToBGRA
*   
*   
* Arguments:
*   
*
*
* Return Value:
*
*
*
* History:
*
*    1/22/1997 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vLoadAndConvert4ToBGRA(
    PULONG   pulDstAddr,
    PBYTE    pSrcAddr,
    LONG     SrcX,
    LONG     SrcCx,
    PVOID    ppalInfo
    )
{
    BYTE SrcByte;
    pSrcAddr = pSrcAddr + (SrcX >> 1);
    LONG cxUnalignedStart = 1 & (2 - (SrcX & 1));
    PULONG ppal = (PULONG)&((PPALINFO)ppalInfo)->pBitmapInfo->bmiColors[0];

    cxUnalignedStart = MIN(SrcCx,cxUnalignedStart);

    //
    // unaligned start
    //

    if (cxUnalignedStart)
    {
        SrcByte = *pSrcAddr;
        *pulDstAddr = ppal[SrcByte & 0x0f] | 0xff000000;
        pSrcAddr++;
        pulDstAddr++;
        SrcCx--;
    }

    //
    // aligned whole bytes
    //

    while (SrcCx >= 2)
    {
        SrcCx -= 2;

        SrcByte = *pSrcAddr;

        *(pulDstAddr + 0) = ppal[(SrcByte >> 4)  ] | 0xff000000;
        *(pulDstAddr + 1) = ppal[(SrcByte & 0x0f)] | 0xff000000;

        pSrcAddr++;
        pulDstAddr+=2;
    }

    //
    // unaligned end
    //

    if (SrcCx)
    {
        SrcByte = *pSrcAddr;
        *pulDstAddr = ppal[SrcByte >> 4] | 0xff000000;
    }
}

/**************************************************************************\
* vLoadAndConvert8ToBGRA
*   
*   
* Arguments:
*   
*
*
* Return Value:
*
*
*
* History:
*
*    1/22/1997 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vLoadAndConvert8ToBGRA(
    PULONG   pulDstAddr,
    PBYTE    pSrcAddr,
    LONG     SrcX,
    LONG     SrcCx,
    PVOID    ppalInfo
    )
{
    PBYTE pjSrc = pSrcAddr + SrcX;
    PBYTE pjEnd = pjSrc + SrcCx;

    PULONG ppal = (PULONG)&((PPALINFO)ppalInfo)->pBitmapInfo->bmiColors[0];

    while (pjSrc != pjEnd)
    {
        *pulDstAddr = ppal[*pjSrc] | 0xff000000;

        pulDstAddr++;
        pjSrc++;
    }
}

/**************************************************************************\
* vLoadAndConvertRGB16_565ToBGRA
*   
*   
* Arguments:
*   
*
*
* Return Value:
*
*
*
* History:
*
*    1/22/1997 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vLoadAndConvertRGB16_565ToBGRA(
    PULONG   pulDstAddr,
    PBYTE    pSrcAddr,
    LONG     SrcX,
    LONG     SrcCx,
    PVOID    ppalInfo
    )
{
    PUSHORT pusSrc = (PUSHORT)pSrcAddr + SrcX;
    PUSHORT pusEnd = pusSrc + SrcCx;

    while (pusSrc != pusEnd)
    {
        ALPHAPIX pixIn;
        ALPHAPIX pixOut;

        pixIn.ul = *pusSrc;

        pixOut.pix.r = (BYTE)((pixIn.ul & 0xf800) >> 8);
        pixOut.pix.g = (BYTE)((pixIn.ul & 0x07e0) >> 3);
        pixOut.pix.b = (BYTE)((pixIn.ul & 0x001f) << 3);
        pixOut.pix.a = 0xff;
        *pulDstAddr = pixOut.ul;

        pusSrc++;
        pulDstAddr++;
    }
}

/**************************************************************************\
* vLoadAndConvertRGB16_555ToBGRA
*   
*   
* Arguments:
*   
*
*
* Return Value:
*
*
*
* History:
*
*    1/22/1997 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vLoadAndConvertRGB16_555ToBGRA(
    PULONG   pulDstAddr,
    PBYTE    pSrcAddr,
    LONG     SrcX,
    LONG     SrcCx,
    PVOID    ppalInfo
    )
{
    PUSHORT pusSrc = (PUSHORT)pSrcAddr + SrcX;
    PUSHORT pusEnd = pusSrc + SrcCx;
    while (pusSrc != pusEnd)
    {
        ALPHAPIX pixIn;
        ALPHAPIX pixOut;

        pixIn.ul = *pusSrc;

        pixOut.pix.r = (BYTE)((pixIn.ul & 0x7c00) >> 7);
        pixOut.pix.g = (BYTE)((pixIn.ul & 0x03e0) >> 2);
        pixOut.pix.b = (BYTE)((pixIn.ul & 0x001f) << 3);

        pixOut.pix.a = 0xff;

        *pulDstAddr = pixOut.ul;

        pusSrc++;
        pulDstAddr++;
    }
}

/**************************************************************************\
* vLoadAndConvert16BitfieldsToBGRA
*   
*   
* Arguments:
*   
*
*
* Return Value:
*
*
*
* History:
*
*    1/22/1997 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vLoadAndConvert16BitfieldsToBGRA(
    PULONG   pulDstAddr,
    PBYTE    pSrcAddr,
    LONG     SrcX,
    LONG     SrcCx,
    PVOID    ppalInfo
    )
{
    PUSHORT pusSrc = (PUSHORT)pSrcAddr + SrcX;
    PUSHORT pusEnd = pusSrc + SrcCx;
    while (pusSrc != pusEnd)
    {
        ULONG ulTmp;

        ulTmp = *pusSrc;

        //ulTmp = ppal.ulBitfieldToRGB(ulTmp);

        ulTmp |= 0xff000000;

        *pulDstAddr = ulTmp;

        pusSrc++;
        pulDstAddr++;
    }
}

/**************************************************************************\
* vLoadAndConvertRGB24ToBGRA
*   
*   
* Arguments:
*   
*
*
* Return Value:
*
*
*
* History:
*
*    1/22/1997 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vLoadAndConvertRGB24ToBGRA(
    PULONG   pulDstAddr,
    PBYTE    pSrcAddr,
    LONG     SrcX,
    LONG     SrcCx,
    PVOID    ppalInfo
    )
{
    PBYTE pjSrc = pSrcAddr + 3 * SrcX;
    PBYTE pjEnd = pjSrc    + 3 * SrcCx;

    while (pjSrc != pjEnd)
    {
        ALPHAPIX pixRet;

        pixRet.pix.b = *(((PBYTE)pjSrc));
        pixRet.pix.g = *(((PBYTE)pjSrc)+1);
        pixRet.pix.r = *(((PBYTE)pjSrc)+2);
        pixRet.pix.a = 0xff;

        *pulDstAddr = pixRet.ul;

        pjSrc += 3;
        pulDstAddr++;
    }
}

/**************************************************************************\
* vLoadAndConvertRGB32ToBGRA
*   
*   
* Arguments:
*   
*
*
* Return Value:
*
*
*
* History:
*
*    1/22/1997 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vLoadAndConvertRGB32ToBGRA(
    PULONG   pulDstAddr,
    PBYTE    pSrcAddr,
    LONG     SrcX,
    LONG     SrcCx,
    PVOID    ppalInfo
    )
{
    PULONG pulSrc = (PULONG)pSrcAddr + SrcX;
    PULONG pulEnd = pulSrc + SrcCx;

    while (pulSrc != pulEnd)
    {
        ALPHAPIX pixIn;
        ALPHAPIX pixOut;

        pixIn.ul = *pulSrc;

        pixOut.pix.r = pixIn.pix.b;
        pixOut.pix.g = pixIn.pix.g;
        pixOut.pix.b = pixIn.pix.r;
        pixOut.pix.a = pixIn.pix.a;

        *pulDstAddr = pixOut.ul;

        pulSrc++;
        pulDstAddr++;
    }
}

/**************************************************************************\
* vLoadAndConvert32BitfieldsToBGRA
*   
*   
* Arguments:
*   
*
*
* Return Value:
*
*
*
* History:
*
*    1/22/1997 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vLoadAndConvert32BitfieldsToBGRA(
    PULONG   pulDstAddr,
    PBYTE    pSrcAddr,
    LONG     SrcX,
    LONG     SrcCx,
    PVOID    ppalInfo
    )
{
    PULONG pulSrc = (PULONG)pSrcAddr + SrcX;
    PULONG pulEnd = pulSrc + SrcCx;

    while (pulSrc != pulEnd)
    {
        ULONG ulTmp;

        ulTmp = *pulSrc;

        //ulTmp = ppal.ulBitfieldToRGB(ulTmp);

        *pulDstAddr = ulTmp;

        pulSrc++;
        pulDstAddr++;
    }
}

//
// 
// STORE ROUTINES  
// convert BGRA to RGB332, look up in table
//

#define PALETTE_MATCH(pixIn,ppalInfo)                         \
{                                                             \
    pixIn.ul = ppalInfo->pxlate332[                           \
                    ((pixIn.pix.r & 0xe0))      |             \
                    ((pixIn.pix.g & 0xe0) >> 3) |             \
                    ((pixIn.pix.b & 0xc0) >> 6)];             \
}                                                             \


/**************************************************************************\
* vConvertAndSaveBGRATo1
*   
*   
* Arguments:
*   
*
*
* Return Value:
*
*
*
* History:
*
*    1/22/1997 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vConvertAndSaveBGRATo1(
    PBYTE       pDst,
    PULONG      pulSrc,
    LONG        cx,
    LONG        DstX,
    PVOID       pvpalInfo,
    PBYTE       pWriteMask
    )
{
    PPALINFO ppalInfo = (PPALINFO)pvpalInfo;
    PBYTE pjDst = pDst + (DstX >> 3);
    LONG  iDst  = DstX & 7;

    //
    // unaligned byte
    //

    if (iDst)
    {
        BYTE DstByte     = *pjDst;
        LONG iShift      = 7 - iDst;
        LONG cxUnaligned = iShift + 1;

        cxUnaligned = MIN(cxUnaligned,cx);
        cx -= cxUnaligned;

        while (cxUnaligned--)
        {
            ALPHAPIX  pixIn;

            pixIn.ul = *pulSrc;

            PALETTE_MATCH(pixIn,ppalInfo);

            pixIn.ul = pixIn.ul << iShift;

            DstByte = DstByte & (~(1 << iShift));
            DstByte |= (BYTE)pixIn.ul;
            pulSrc++;
            iShift--;
        }

        *pjDst = DstByte;
        pjDst++;
    }

    //
    // aligned whole bytes
    //

    while (cx >= 8)
    {
        ALPHAPIX  pixIn;
        BYTE DstByte;

        pixIn.ul = *pulSrc;
        PALETTE_MATCH(pixIn,ppalInfo);
        DstByte      = (BYTE)(pixIn.ul << 7);

        pixIn.ul = *(pulSrc+1);
        PALETTE_MATCH(pixIn,ppalInfo);
        DstByte     |= (BYTE)(pixIn.ul << 6);

        pixIn.ul = *(pulSrc+2);
        PALETTE_MATCH(pixIn,ppalInfo);
        DstByte     |= (BYTE)(pixIn.ul << 5);

        pixIn.ul = *(pulSrc+3);
        PALETTE_MATCH(pixIn,ppalInfo);
        DstByte     |= (BYTE)(pixIn.ul << 4);

        pixIn.ul = *(pulSrc+4);
        PALETTE_MATCH(pixIn,ppalInfo);
        DstByte     |= (BYTE)(pixIn.ul << 3);

        pixIn.ul = *(pulSrc+5);
        PALETTE_MATCH(pixIn,ppalInfo);
        DstByte     |= (BYTE)(pixIn.ul << 2);

        pixIn.ul = *(pulSrc+6);
        PALETTE_MATCH(pixIn,ppalInfo);
        DstByte     |= (BYTE)(pixIn.ul << 1);
                       
        pixIn.ul = *(pulSrc+7);
        PALETTE_MATCH(pixIn,ppalInfo);
        DstByte     |= (BYTE)(pixIn.ul << 0);

        *pjDst = DstByte;

        pjDst++;
        pulSrc += 8;
        cx -= 8;
    }

    //
    // unaligned end
    //

    if (cx)
    {
        BYTE iShift = 7;
        BYTE DstByte = *pjDst;

        while (cx--)
        {
            ALPHAPIX  pixIn;

            pixIn.ul = *pulSrc;

            PALETTE_MATCH(pixIn,ppalInfo);

            pixIn.ul = pixIn.ul << iShift;
            DstByte = DstByte & (~(1 << iShift));
            DstByte |= (BYTE)pixIn.ul;
            pulSrc++;
            iShift--;
        }

        *pjDst = DstByte;
    }
}

/**************************************************************************\
* vConvertAndSaveBGRATo4
*   
*   
* Arguments:
*   
*
*
* Return Value:
*
*
*
* History:
*
*    1/22/1997 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vConvertAndSaveBGRATo4(
    PBYTE       pDst,
    PULONG      pulSrc,
    LONG        cx,
    LONG        DstX,
    PVOID       pvpalInfo,
    PBYTE       pWriteMask
    )
{
    PPALINFO ppalInfo = (PPALINFO)pvpalInfo;
    PBYTE pjDst = pDst + (DstX >> 1);
    LONG  iDst  = DstX & 1;

    if (cx == 0)
    {
        return;
    }

    //
    // unaligned byte
    //

    if (iDst)
    {
        BYTE DstByte     = *pjDst;
        ALPHAPIX  pixIn;

        pixIn.ul = *pulSrc;

        PALETTE_MATCH(pixIn,ppalInfo);

        DstByte = (DstByte & 0xf0) | (BYTE)pixIn.ul;

        *pjDst = DstByte;
        pjDst++;
        pulSrc++;
        cx--;
    }

    //
    // aligned whole bytes
    //

    while (cx >= 2)
    {
        BYTE DstByte;
        ALPHAPIX  pixIn;

        pixIn.ul = *pulSrc;
        PALETTE_MATCH(pixIn,ppalInfo);
        DstByte = (BYTE)(pixIn.ul << 4);

        pixIn.ul = *(pulSrc+1);
        PALETTE_MATCH(pixIn,ppalInfo);
        DstByte |= (BYTE)(pixIn.ul);

        *pjDst = DstByte;

        pjDst++;
        pulSrc += 2;
        cx -= 2;
    }

    //
    // unaligned end
    //

    if (cx)
    {
        BYTE DstByte = *pjDst;
        ALPHAPIX  pixIn;

        pixIn.ul = *pulSrc;

        PALETTE_MATCH(pixIn,ppalInfo);

        DstByte = (DstByte & 0x0f) | (BYTE)(pixIn.ul << 4);

        *pjDst = DstByte;
    }
}


/**************************************************************************\
* vConvertAndSaveBGRATo8
*   
*   
* Arguments:
*   
*
*
* Return Value:
*
*
*
* History:
*
*    1/22/1997 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vConvertAndSaveBGRATo8(
    PBYTE       pDst,
    PULONG      pulSrc,
    LONG        cx,
    LONG        DstX,
    PVOID       pvpalInfo,
    PBYTE       pWriteMask
    )
{
    PPALINFO ppalInfo = (PPALINFO)pvpalInfo;
    PBYTE pjDst = (PBYTE)pDst + DstX;
    PBYTE pjEnd = pjDst + cx;

    while (pjDst != pjEnd)
    {
        ALPHAPIX  pixIn;

        if (*pWriteMask)
        {
            pixIn.ul = *pulSrc;
    
            PALETTE_MATCH(pixIn,ppalInfo);
    
            *pjDst = (BYTE)pixIn.ul;
        }

        pWriteMask++;
        pulSrc++;
        pjDst++;
    }
}

/**************************************************************************\
* vConvertAndSaveBGRAToRGB16_565
*   
*   
* Arguments:
*   
*
*
* Return Value:
*
*
*
* History:
*
*    1/22/1997 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vConvertAndSaveBGRAToRGB16_565(
    PBYTE       pjDst,
    PULONG      pulSrc,
    LONG        cx,
    LONG        DstX,
    PVOID       ppalInfo,
    PBYTE       pWriteMask
    )
{
    PUSHORT pusDst = (PUSHORT)pjDst + DstX;
    PUSHORT pusEnd = pusDst + cx;

    while (pusDst != pusEnd)
    {
        ALPHAPIX  pixIn;
        ALPHAPIX  pixOut;

        pixIn.ul = *pulSrc;

        pixOut.ul =    ((pixIn.pix.r & 0xf8) << 8) |
                       ((pixIn.pix.g & 0xfc) << 3) |
                       ((pixIn.pix.b & 0xf8) >> 3);


        *pusDst = (USHORT)pixOut.ul;

        pulSrc++;
        pusDst++;
    }
}

/**************************************************************************\
* vConvertAndSaveBGRAToRGB16_555
*   
*   
* Arguments:
*   
*
*
* Return Value:
*
*
*
* History:
*
*    1/22/1997 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vConvertAndSaveBGRAToRGB16_555(
    PBYTE       pjDst,
    PULONG      pulSrc,
    LONG        cx,
    LONG        DstX,
    PVOID       ppalInfo,
    PBYTE       pWriteMask
    )
{
    PUSHORT pusDst = (PUSHORT)pjDst + DstX;
    PUSHORT pusEnd = pusDst + cx;

    while (pusDst != pusEnd)
    {
        ALPHAPIX  pixIn;
        ALPHAPIX  pixOut;

        pixIn.ul = *pulSrc;

        pixOut.ul =    ((pixIn.pix.r & 0xf8) << 7) |
                       ((pixIn.pix.g & 0xf8) << 2) |
                       ((pixIn.pix.b & 0xf8) >> 3);

        *pusDst = (USHORT)pixOut.ul;

        pulSrc++;
        pusDst++;
    }
}

/**************************************************************************\
* vConvertAndSaveBGRATo16Bitfields
*   
*   
* Arguments:
*   
*
*
* Return Value:
*
*
*
* History:
*
*    1/22/1997 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vConvertAndSaveBGRATo16Bitfields(
    PBYTE       pjDst,
    PULONG      pulSrc,
    LONG        cx,
    LONG        DstX,
    PVOID       ppalInfo,
    PBYTE       pWriteMask
    )
{
    PUSHORT pusDst = (PUSHORT)pjDst + DstX;
    PUSHORT pusEnd = pusDst + cx;

    while (pusDst != pusEnd)
    {
        ALPHAPIX  pixIn;
        ALPHAPIX  pixOut;

        pixIn.ul = *pulSrc;

        pixOut.ul = pixIn.ul; // !!!

        *pusDst = (USHORT)pixOut.ul;

        pulSrc++;
        pusDst++;
    }
}

/**************************************************************************\
* vConvertAndSaveBGRAToRGB24
*   
*   
* Arguments:
*   
*
*
* Return Value:
*
*
*
* History:
*
*    1/22/1997 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vConvertAndSaveBGRAToRGB24(
    PBYTE       pDst,
    PULONG      pulSrc,
    LONG        cx,
    LONG        DstX,
    PVOID       ppalInfo,
    PBYTE       pWriteMask
    )
{
    PBYTE pjDst = (PBYTE)pDst + (3 * DstX);
    PBYTE pjEnd = pjDst + (3 * cx);

    while (pjDst != pjEnd)
    {
        ALPHAPIX  pixIn;

        pixIn.ul = *pulSrc;

        *pjDst     = pixIn.pix.b;
        *(pjDst+1) = pixIn.pix.g;
        *(pjDst+2) = pixIn.pix.r;

        pulSrc++;
        pjDst+=3;
    }
}

/**************************************************************************\
* vConvertAndSaveBGRATo32Bitfields
*   
*   
* Arguments:
*   
*
*
* Return Value:
*
*
*
* History:
*
*    1/22/1997 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vConvertAndSaveBGRATo32Bitfields(
    PBYTE       pjDst,
    PULONG      pulSrc,
    LONG        cx,
    LONG        DstX,
    PVOID       ppalInfo,
    PBYTE       pWriteMask
    )
{
    PULONG pulDst = (PULONG)pjDst + DstX;
    PULONG pulEnd = pulDst + cx;
    while (pulDst != pulEnd)
    {
        ALPHAPIX  pixIn;
        ALPHAPIX  pixOut;

        pixIn.ul = *pulSrc;

        pixOut.ul = pixIn.ul; // !!! 

        *pulDst = pixOut.ul;

        pulSrc++;
        pulDst++;
    }
}

/**************************************************************************\
* vConvertAndSaveBGRAToRGB32
*   
*   
* Arguments:
*   
*
*
* Return Value:
*
*
*
* History:
*
*    1/22/1997 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vConvertAndSaveBGRAToRGB32(
    PBYTE       pjDst,
    PULONG      pulSrc,
    LONG        cx,
    LONG        DstX,
    PVOID       ppalInfo,
    PBYTE       pWriteMask
    )
{
    PULONG pulDst = (PULONG)pjDst + DstX;
    PULONG pulEnd = pulDst + cx;
    while (pulDst != pulEnd)
    {
        ALPHAPIX  pixIn;
        ALPHAPIX  pixOut;

        pixIn.ul = *pulSrc;

        pixOut.pix.r = pixIn.pix.b;
        pixOut.pix.g = pixIn.pix.g;
        pixOut.pix.b = pixIn.pix.r;
        pixOut.pix.a = 0;

        *pulDst = pixOut.ul;

        pulSrc++;
        pulDst++;
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\image\tmp\alphaimg.cxx ===
/******************************Module*Header*******************************\
* Module Name: tranblt.cxx
*
* Transparent BLT
*
* Created: 21-Jun-1996
* Author: Mark Enstrom [marke]
*
* Copyright (c) 1996-1999 Microsoft Corporation
\**************************************************************************/
#include "precomp.hxx"
#pragma hdrstop

#if !(_WIN32_WINNT >= 0x500)

PBYTE pAlphaMulTable;

ALPHAPIX  aPalHalftone[256] =
{
    {0x00,0x00,0x00,0x00},{0x80,0x00,0x00,0x00},{0x00,0x80,0x00,0x00},{0x80,0x80,0x00,0x00},
    {0x00,0x00,0x80,0x00},{0x80,0x00,0x80,0x00},{0x00,0x80,0x80,0x00},{0xc0,0xc0,0xc0,0x00},
    {0xc0,0xdc,0xc0,0x00},{0xa6,0xca,0xf0,0x00},{0x04,0x04,0x04,0x04},{0x08,0x08,0x08,0x04},
    {0x0c,0x0c,0x0c,0x04},{0x11,0x11,0x11,0x04},{0x16,0x16,0x16,0x04},{0x1c,0x1c,0x1c,0x04},
    //10
    {0x22,0x22,0x22,0x04},{0x29,0x29,0x29,0x04},{0x55,0x55,0x55,0x04},{0x4d,0x4d,0x4d,0x04},
    {0x42,0x42,0x42,0x04},{0x39,0x39,0x39,0x04},{0xFF,0x7C,0x80,0x04},{0xFF,0x50,0x50,0x04},
    {0xD6,0x00,0x93,0x04},{0xCC,0xEC,0xFF,0x04},{0xEF,0xD6,0xC6,0x04},{0xE7,0xE7,0xD6,0x04},
    {0xAD,0xA9,0x90,0x04},{0x33,0x00,0x00,0x04},{0x66,0x00,0x00,0x04},{0x99,0x00,0x00,0x04},
    //2
    {0xcc,0x00,0x00,0x04},{0x00,0x33,0x00,0x04},{0x33,0x33,0x00,0x04},{0x66,0x33,0x00,0x04},
    {0x99,0x33,0x00,0x04},{0xcc,0x33,0x00,0x04},{0xff,0x33,0x00,0x04},{0x00,0x66,0x00,0x04},
    {0x33,0x66,0x00,0x04},{0x66,0x66,0x00,0x04},{0x99,0x66,0x00,0x04},{0xcc,0x66,0x00,0x04},
    {0xff,0x66,0x00,0x04},{0x00,0x99,0x00,0x04},{0x33,0x99,0x00,0x04},{0x66,0x99,0x00,0x04},
    //3
    {0x99,0x99,0x00,0x04},{0xcc,0x99,0x00,0x04},{0xff,0x99,0x00,0x04},{0x00,0xcc,0x00,0x04},
    {0x33,0xcc,0x00,0x04},{0x66,0xcc,0x00,0x04},{0x99,0xcc,0x00,0x04},{0xcc,0xcc,0x00,0x04},
    {0xff,0xcc,0x00,0x04},{0x66,0xff,0x00,0x04},{0x99,0xff,0x00,0x04},{0xcc,0xff,0x00,0x04},
    {0x00,0x00,0x33,0x04},{0x33,0x00,0x33,0x04},{0x66,0x00,0x33,0x04},{0x99,0x00,0x33,0x04},
    //4
    {0xcc,0x00,0x33,0x04},{0xff,0x00,0x33,0x04},{0x00,0x33,0x33,0x04},{0x33,0x33,0x33,0x04},
    {0x66,0x33,0x33,0x04},{0x99,0x33,0x33,0x04},{0xcc,0x33,0x33,0x04},{0xff,0x33,0x33,0x04},
    {0x00,0x66,0x33,0x04},{0x33,0x66,0x33,0x04},{0x66,0x66,0x33,0x04},{0x99,0x66,0x33,0x04},
    {0xcc,0x66,0x33,0x04},{0xff,0x66,0x33,0x04},{0x00,0x99,0x33,0x04},{0x33,0x99,0x33,0x04},
    //5
    {0x66,0x99,0x33,0x04},{0x99,0x99,0x33,0x04},{0xcc,0x99,0x33,0x04},{0xff,0x99,0x33,0x04},
    {0x00,0xcc,0x33,0x04},{0x33,0xcc,0x33,0x04},{0x66,0xcc,0x33,0x04},{0x99,0xcc,0x33,0x04},
    {0xcc,0xcc,0x33,0x04},{0xff,0xcc,0x33,0x04},{0x33,0xff,0x33,0x04},{0x66,0xff,0x33,0x04},
    {0x99,0xff,0x33,0x04},{0xcc,0xff,0x33,0x04},{0xff,0xff,0x33,0x04},{0x00,0x00,0x66,0x04},
    //6
    {0x33,0x00,0x66,0x04},{0x66,0x00,0x66,0x04},{0x99,0x00,0x66,0x04},{0xcc,0x00,0x66,0x04},
    {0xff,0x00,0x66,0x04},{0x00,0x33,0x66,0x04},{0x33,0x33,0x66,0x04},{0x66,0x33,0x66,0x04},
    {0x99,0x33,0x66,0x04},{0xcc,0x33,0x66,0x04},{0xff,0x33,0x66,0x04},{0x00,0x66,0x66,0x04},
    {0x33,0x66,0x66,0x04},{0x66,0x66,0x66,0x04},{0x99,0x66,0x66,0x04},{0xcc,0x66,0x66,0x04},
    //7
    {0x00,0x99,0x66,0x04},{0x33,0x99,0x66,0x04},{0x66,0x99,0x66,0x04},{0x99,0x99,0x66,0x04},
    {0xcc,0x99,0x66,0x04},{0xff,0x99,0x66,0x04},{0x00,0xcc,0x66,0x04},{0x33,0xcc,0x66,0x04},
    {0x99,0xcc,0x66,0x04},{0xcc,0xcc,0x66,0x04},{0xff,0xcc,0x66,0x04},{0x00,0xff,0x66,0x04},
    {0x33,0xff,0x66,0x04},{0x99,0xff,0x66,0x04},{0xcc,0xff,0x66,0x04},{0xff,0x00,0xcc,0x04},
    //8
    {0xcc,0x00,0xff,0x04},{0x00,0x99,0x99,0x04},{0x99,0x33,0x99,0x04},{0x99,0x00,0x99,0x04},
    {0xcc,0x00,0x99,0x04},{0x00,0x00,0x99,0x04},{0x33,0x33,0x99,0x04},{0x66,0x00,0x99,0x04},
    {0xcc,0x33,0x99,0x04},{0xff,0x00,0x99,0x04},{0x00,0x66,0x99,0x04},{0x33,0x66,0x99,0x04},
    {0x66,0x33,0x99,0x04},{0x99,0x66,0x99,0x04},{0xcc,0x66,0x99,0x04},{0xff,0x33,0x99,0x04},
    //9
    {0x33,0x99,0x99,0x04},{0x66,0x99,0x99,0x04},{0x99,0x99,0x99,0x04},{0xcc,0x99,0x99,0x04},
    {0xff,0x99,0x99,0x04},{0x00,0xcc,0x99,0x04},{0x33,0xcc,0x99,0x04},{0x66,0xcc,0x66,0x04},
    {0x99,0xcc,0x99,0x04},{0xcc,0xcc,0x99,0x04},{0xff,0xcc,0x99,0x04},{0x00,0xff,0x99,0x04},
    {0x33,0xff,0x99,0x04},{0x66,0xcc,0x99,0x04},{0x99,0xff,0x99,0x04},{0xcc,0xff,0x99,0x04},
    //a
    {0xff,0xff,0x99,0x04},{0x00,0x00,0xcc,0x04},{0x33,0x00,0x99,0x04},{0x66,0x00,0xcc,0x04},
    {0x99,0x00,0xcc,0x04},{0xcc,0x00,0xcc,0x04},{0x00,0x33,0x99,0x04},{0x33,0x33,0xcc,0x04},
    {0x66,0x33,0xcc,0x04},{0x99,0x33,0xcc,0x04},{0xcc,0x33,0xcc,0x04},{0xff,0x33,0xcc,0x04},
    {0x00,0x66,0xcc,0x04},{0x33,0x66,0xcc,0x04},{0x66,0x66,0x99,0x04},{0x99,0x66,0xcc,0x04},
    //b
    {0xcc,0x66,0xcc,0x04},{0xff,0x66,0x99,0x04},{0x00,0x99,0xcc,0x04},{0x33,0x99,0xcc,0x04},
    {0x66,0x99,0xcc,0x04},{0x99,0x99,0xcc,0x04},{0xcc,0x99,0xcc,0x04},{0xff,0x99,0xcc,0x04},
    {0x00,0xcc,0xcc,0x04},{0x33,0xcc,0xcc,0x04},{0x66,0xcc,0xcc,0x04},{0x99,0xcc,0xcc,0x04},
    {0xcc,0xcc,0xcc,0x04},{0xff,0xcc,0xcc,0x04},{0x00,0xff,0xcc,0x04},{0x33,0xff,0xcc,0x04},
    //c
    {0x66,0xff,0x99,0x04},{0x99,0xff,0xcc,0x04},{0xcc,0xff,0xcc,0x04},{0xff,0xff,0xcc,0x04},
    {0x33,0x00,0xcc,0x04},{0x66,0x00,0xff,0x04},{0x99,0x00,0xff,0x04},{0x00,0x33,0xcc,0x04},
    {0x33,0x33,0xff,0x04},{0x66,0x33,0xff,0x04},{0x99,0x33,0xff,0x04},{0xcc,0x33,0xff,0x04},
    {0xff,0x33,0xff,0x04},{0x00,0x66,0xff,0x04},{0x33,0x66,0xff,0x04},{0x66,0x66,0xcc,0x04},
    //d
    {0x99,0x66,0xff,0x04},{0xcc,0x66,0xff,0x04},{0xff,0x66,0xcc,0x04},{0x00,0x99,0xff,0x04},
    {0x33,0x99,0xff,0x04},{0x66,0x99,0xff,0x04},{0x99,0x99,0xff,0x04},{0xcc,0x99,0xff,0x04},
    {0xff,0x99,0xff,0x04},{0x00,0xcc,0xff,0x04},{0x33,0xcc,0xff,0x04},{0x66,0xcc,0xff,0x04},
    {0x99,0xcc,0xff,0x04},{0xcc,0xcc,0xff,0x04},{0xff,0xcc,0xff,0x04},{0x33,0xff,0xff,0x04},
    //e
    {0x66,0xff,0xcc,0x04},{0x99,0xff,0xff,0x04},{0xcc,0xff,0xff,0x04},{0xff,0x66,0x66,0x04},
    {0x66,0xff,0x66,0x04},{0xff,0xff,0x66,0x04},{0x66,0x66,0xff,0x04},{0xff,0x66,0xff,0x04},
    {0x66,0xff,0xff,0x04},{0xA5,0x00,0x21,0x04},{0x5f,0x5f,0x5f,0x04},{0x77,0x77,0x77,0x04},
    {0x86,0x86,0x86,0x04},{0x96,0x96,0x96,0x04},{0xcb,0xcb,0xcb,0x04},{0xb2,0xb2,0xb2,0x04},
    //f
    {0xd7,0xd7,0xd7,0x04},{0xdd,0xdd,0xdd,0x04},{0xe3,0xe3,0xe3,0x04},{0xea,0xea,0xea,0x04},
    {0xf1,0xf1,0xf1,0x04},{0xf8,0xf8,0xf8,0x04},{0xff,0xfb,0xf0,0x00},{0xa0,0xa0,0xa4,0x00},
    {0x80,0x80,0x80,0x00},{0xff,0x00,0x00,0x00},{0x00,0xff,0x00,0x00},{0xff,0xff,0x00,0x00},
    {0x00,0x00,0xff,0x00},{0xff,0x00,0xff,0x00},{0x00,0xff,0xff,0x00},{0xff,0xff,0xff,0x00}
};


//
// translate RGB [3 3 2] into halftone palette index
//

BYTE gHalftoneColorXlate332[] = {
    0x00,0x5f,0x85,0xfc,0x21,0x65,0xa6,0xfc,0x21,0x65,0xa6,0xcd,0x27,0x6b,0x8a,0xcd,
    0x2d,0x70,0x81,0xd3,0x33,0x76,0x95,0xd9,0x33,0x76,0x95,0xd9,0xfa,0x7b,0x9b,0xfe,
    0x1d,0x60,0xa2,0xfc,0x22,0x66,0x86,0xc8,0x22,0x66,0x86,0xc8,0x28,0x6c,0x8b,0xce,
    0x2e,0x71,0x90,0xd4,0x34,0x77,0x96,0xda,0x34,0x77,0x96,0xda,0xfa,0x7c,0x9c,0xdf,
    0x1d,0x60,0xa2,0xc5,0x22,0x66,0x86,0xc8,0x22,0x13,0x86,0xc8,0x28,0x12,0x8b,0xce,
    0x2e,0x71,0x90,0xd4,0x34,0x77,0x96,0xda,0x34,0x77,0x96,0xda,0x39,0x7c,0x9c,0xdf,
    0x1e,0x61,0x87,0xc5,0x23,0x67,0x8c,0xc9,0x23,0x12,0x8c,0xc9,0x29,0x6d,0xae,0xe6,
    0x2f,0x72,0x91,0xd5,0x35,0x97,0x9d,0xdb,0x35,0x97,0x9d,0xdb,0x39,0xe4,0xc0,0xe8,

    0x1f,0x62,0x83,0xc6,0x24,0x68,0x82,0xca,0x24,0x68,0x82,0xca,0x2a,0x6e,0x8d,0xd0,
    0x30,0x73,0x92,0xd6,0x36,0x78,0xf7,0xdc,0x36,0x78,0x98,0xdc,0x3a,0x7d,0x9e,0xe1,
    0x20,0x63,0x84,0x80,0x25,0x69,0x88,0xcb,0x25,0x69,0x88,0xcb,0x2b,0x6f,0x8e,0xd1,
    0x31,0x74,0xf7,0xd7,0x37,0x79,0xef,0x09,0x37,0x79,0x08,0xdd,0x3b,0x7e,0x9f,0xe2,
    0x20,0x63,0x84,0x80,0x25,0x69,0x88,0xcb,0x25,0x69,0x88,0xcb,0x2b,0x6f,0x8e,0xd1,
    0x31,0x74,0x93,0xd7,0x37,0x79,0x99,0xdd,0x37,0x79,0x99,0xdd,0x3b,0x7e,0x9f,0xe2,
    0xf9,0x64,0x89,0xfd,0x26,0x6a,0x8f,0xcc,0x26,0x17,0x8f,0xcc,0x2c,0xe3,0xb1,0xe7,
    0x32,0x75,0x94,0xd8,0x38,0x7a,0x9a,0xde,0x38,0x7a,0x9a,0xde,0xfb,0xe5,0xa0,0xff
    };

/**************************************************************************\
* BLEND MACROS
*   
*   
* Arguments:
*   
*
*
* Return Value:
*
*
*
* History:
*
*    3/11/1997 Mark Enstrom [marke]
*
\**************************************************************************/

#define INT_MULT(a,b,t)                         \
        t = ((a)*(b)) + 0x80;                   \
        t = ((((t) >> 8) + t) >> 8);

#define INT_LERP(a,s,d,t)                       \
        INT_MULT((a),((s)-(d)),t);              \
        t = t + (d);

#define INT_PRELERP(a,s,d,t)                    \
        INT_MULT((a),(d),t);                    \
        t = (s) + (d) - t;


/******************************Public*Routine******************************\
* vPixelGeneralBlend
*       blend scan line of two PIXEL32 values based on BLENDFUNCTION
*
*       This is the general case, arbitrary and non-optimized blend
*       functions
*   
* Arguments:
*   ppixDst        - address of dst pixel
*   ppixSrc        - address of src pixel
*   cx             - number of pixels in scan line
*   BlendFunction  - blend to be done on each pixel
*   pwrMask        - set each byte to 0 for pixel that doesn't
*                    need to be written back to destination
*
* Return Value:
*
*   nont
*
* History:
*
*    10/28/1996 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vPixelGeneralBlend(
    ALPHAPIX       *ppixDst,
    ALPHAPIX       *ppixSrc,
    LONG           cx,
    BLENDFUNCTION  BlendFunction,
    PBYTE          pwrMask
    )
{
    ALPHAPIX pixRet;
    ALPHAPIX pixSrc;
    ALPHAPIX pixDst;
    BYTE  sR,sG,sB,sA;
    BYTE  dR,dG,dB,dA;
    int   iTmp;

    while (cx--)
    {
        pixSrc = *ppixSrc;
        pixDst = *ppixDst;

        switch (BlendFunction.SourceBlend)
        {
        case AC_ZERO:
            sR = 0;
            sG = 0;
            sB = 0;
            sA = 0;
            break;
    
        case AC_ONE:
            sR = pixSrc.pix.r;
            sG = pixSrc.pix.g;
            sB = pixSrc.pix.b;
            sA = pixSrc.pix.a;
            break;

        case AC_SRC_ALPHA:
            if (pixSrc.pix.a == 0)
            {
                sR = 0;
                sG = 0;
                sB = 0;
                sA = 0;
            }
            else if (pixSrc.pix.a == 255)
            {
                sR = pixSrc.pix.r;
                sG = pixSrc.pix.g;
                sB = pixSrc.pix.b;
                sA = 255;
            }
            else
            {
                int Temp;

                INT_MULT(pixSrc.pix.r,pixSrc.pix.a,Temp);
                sR = Temp;

                INT_MULT(pixSrc.pix.g,pixSrc.pix.a,Temp);
                sG = Temp;

                INT_MULT(pixSrc.pix.b,pixSrc.pix.a,Temp);
                sB = Temp;

                INT_MULT(pixSrc.pix.a,pixSrc.pix.a,Temp);
                sA = Temp;
            }
            break;
    
        case AC_DST_COLOR:
        case AC_ONE_MINUS_DST_COLOR:
        {    
            ALPHAPIX paltDst = pixDst;
            int Temp;
    
            if (BlendFunction.SourceBlend == AC_ONE_MINUS_DST_COLOR)
            {
                paltDst.pix.r  = 255 - pixDst.pix.r;
                paltDst.pix.g  = 255 - pixDst.pix.g;
                paltDst.pix.b  = 255 - pixDst.pix.b;
                paltDst.pix.a  = 255 - pixDst.pix.a;
            }

            INT_MULT(pixDst.pix.r,pixSrc.pix.r,Temp);
            sR = Temp;

            INT_MULT(pixDst.pix.g,pixSrc.pix.g,Temp);
            sG = Temp;
    
            INT_MULT(pixDst.pix.b,pixSrc.pix.b,Temp);
            sB = Temp;
    
            INT_MULT(pixDst.pix.a,pixSrc.pix.a,Temp);
            sA = Temp;
    
        }
        break;

        case AC_SRC_OVER:
        case AC_SRC_UNDER:

            WARNING("General blend doesn't operate on OVER and UNDER\n");
            break;

        default:
            RIP("Error in source alpha blend function\n");
        }
    
        //
        // destination blend
        //
    
        switch (BlendFunction.DestinationBlend)
        {
        case AC_ZERO:
            dR = 0;
            dG = 0;
            dB = 0;
            dA = 0;
            break;
    
        case AC_ONE:
            dR = pixDst.pix.r;
            dG = pixDst.pix.g;
            dB = pixDst.pix.b;
            dA = pixDst.pix.a;
            break;
    
        case AC_SRC_ALPHA:
        case AC_ONE_MINUS_SRC_ALPHA:
            {
                BYTE Alpha = pixSrc.pix.a;
                int Temp;

                if (BlendFunction.DestinationBlend == AC_ONE_MINUS_SRC_ALPHA)
                {
                    Alpha = 255 - Alpha;
                }

                INT_MULT(pixDst.pix.r,Alpha,Temp);
                dR = Temp;

                INT_MULT(pixDst.pix.g,Alpha,Temp);
                dG = Temp;

                INT_MULT(pixDst.pix.b,Alpha,Temp);
                dB = Temp;

                INT_MULT(pixDst.pix.a,Alpha,Temp);
                dA = Temp;
            }
            break;
    
        case AC_SRC_COLOR:
        case AC_ONE_MINUS_SRC_COLOR:
        {    
            ALPHAPIX paltSrc = pixSrc;
            int Temp;
    
            if (BlendFunction.DestinationBlend == AC_ONE_MINUS_SRC_COLOR)
            {
                paltSrc.pix.r = 255 - pixSrc.pix.r;
                paltSrc.pix.g = 255 - pixSrc.pix.g;
                paltSrc.pix.b = 255 - pixSrc.pix.b;
                paltSrc.pix.a = 255 - pixSrc.pix.a;
            }
    
            INT_MULT(pixDst.pix.r,paltSrc.pix.r,Temp);
            dR = Temp;

            INT_MULT(pixDst.pix.g,paltSrc.pix.g,Temp);
            dG = Temp; 

            INT_MULT(pixDst.pix.b,paltSrc.pix.b,Temp);
            dB = Temp; 

            INT_MULT(pixDst.pix.a,paltSrc.pix.a,Temp);
            dA = Temp; 
        }
        break;

        case AC_SRC_OVER:
        case AC_SRC_UNDER:

            WARNING("General blend doesn't operate on OVER and UNDER\n");
            break;

        default:
            RIP("Error in source alpha blend function\n");
    
        }
    
        pixRet.pix.r = sR + dR;
        pixRet.pix.g = sG + dG;
        pixRet.pix.b = sB + dB;
        pixRet.pix.a = sA + dA;

        *ppixDst = pixRet;

        ppixSrc++;
        ppixDst++;
    }
}

/**************************************************************************\
* vPixelOver
*   
*   optimized routine used when the blend function is SRC_OVER and the
*   SourceConstantAlpha is 255.
*
*       Dst = Src + (1-SrcAlpha) * Dst
*   
* Arguments:
*   
*   ppixDst        - address of dst pixel
*   ppixSrc        - address of src pixel
*   cx             - number of pixels in scan line
*   BlendFunction  - blend to be done on each pixel
*   pwrMask        - set each byte to 0 for pixel that doesn't need 
*                    to be written to dst
*
* Return Value:
*
*   none
*
* History:
*
*    1/23/1997 Mark Enstrom [marke]
*
\**************************************************************************/

#if !defined(_X86_)

VOID
vPixelOver(
    ALPHAPIX       *ppixDst,
    ALPHAPIX       *ppixSrc,
    LONG           cx,
    BLENDFUNCTION  BlendFunction,
    PBYTE          pwrMask
    )
{
    ALPHAPIX pixSrc;
    ALPHAPIX pixDst;

    while (cx--)
    {
        pixSrc = *ppixSrc;

        if (pixSrc.pix.a != 0)
        {
            pixDst = *ppixDst;

            if (pixSrc.pix.a == 255)
            {
                pixDst = pixSrc;
            }
            else
            {
                //
                // Dst = Src + (1-SrcAlpha) * Dst
                //

                ULONG Multa = 255 - pixSrc.pix.a;
                ULONG _D1_00AA00GG = (pixDst.ul & 0xff00ff00) >> 8;
                ULONG _D1_00RR00BB = (pixDst.ul & 0x00ff00ff);
                
                ULONG _D2_AAAAGGGG = _D1_00AA00GG * Multa + 0x00800080;
                ULONG _D2_RRRRBBBB = _D1_00RR00BB * Multa + 0x00800080;
                
                ULONG _D3_00AA00GG = (_D2_AAAAGGGG & 0xff00ff00) >> 8;
                ULONG _D3_00RR00BB = (_D2_RRRRBBBB & 0xff00ff00) >> 8;
                
                
                ULONG _D4_AA00GG00 = (_D2_AAAAGGGG + _D3_00AA00GG) & 0xFF00FF00;
                ULONG _D4_00RR00BB = ((_D2_RRRRBBBB + _D3_00RR00BB) & 0xFF00FF00) >> 8;
                
                pixDst.ul = pixSrc.ul + _D4_AA00GG00 + _D4_00RR00BB;
            }

            *ppixDst = pixDst;
        }
        else
        {
            *pwrMask = 0;
        }

        pwrMask++;
        ppixSrc++;
        ppixDst++;
    }
}

#endif

/**************************************************************************\
* vPixelBlendOrDissolveOver
*   
*   Blend routine when the blend function is SRC_OVER, but when 
*   SourceConstantAlpah != 255 and The source bitmap does have alpha values
*
*       if SrcAlpha == 255 then
*           (Blend)
*           Dst = Dst + ConstAlpha * (Src - Dst)
*
*       else
*           (Dissolve)
*           Src = Src * ConstAlpha
*           (Over)
*           Dst = Src + (1 - SrcAlpha) Dst       
*   
* Arguments:
*   
*   ppixDst        - address of dst pixel
*   ppixSrc        - address of src pixel
*   cx             - number of pixels in scan line
*   BlendFunction  - blend to be done on each pixel
*   pwrMask        - set each byte to 0 for pixel that doesn't need 
*                    to be written to dst
*
* Return Value:
*
*   None
*
* History:
*
*    3/12/1997 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vPixelBlendOrDissolveOver(
    ALPHAPIX       *ppixDst,
    ALPHAPIX       *ppixSrc,
    LONG           cx,
    BLENDFUNCTION  BlendFunction,
    PBYTE          pwrMask
    )
{
    ALPHAPIX pixSrc;
    ALPHAPIX pixDst;
    BYTE     ConstAlpha = BlendFunction.SourceConstantAlpha;

    while (cx--)
    {
        pixSrc = *ppixSrc;

        if (pixSrc.pix.a != 0)
        {
            pixDst = *ppixDst;

            if (pixSrc.pix.a == 255)
            {
                //
                // Blend: D = sA * S + (1-sA) * D
                //
                // red and blue
                //
        
                ULONG uB00rr00bb = pixDst.ul & 0x00ff00ff;
                ULONG uF00rr00bb = pixSrc.ul & 0x00ff00ff;
        
                ULONG uMrrrrbbbb = ((uB00rr00bb<<8)-uB00rr00bb) + 
                                   (ConstAlpha * (uF00rr00bb - uB00rr00bb)) + 0x00800080;
        
                ULONG uM00rr00bb = (uMrrrrbbbb & 0xff00ff00) >> 8;
        
                ULONG uD00rr00bb = ((uMrrrrbbbb+uM00rr00bb) & 0xff00ff00)>>8;
        
                //
                // alpha and green
                //
        
                ULONG uB00aa00gg = (pixDst.ul >> 8) & 0xff00ff;
                ULONG uF00aa00gg = (pixSrc.ul >> 8) & 0xff00ff;
        
                ULONG uMaaaagggg = ((uB00aa00gg <<8)-uB00aa00gg) +
                                   (ConstAlpha * (uF00aa00gg-uB00aa00gg)) + 0x00800080;
        
                ULONG uM00aa00gg = (uMaaaagggg & 0xff00ff00)>>8;
        
                ULONG uDaa00gg00 = (uMaaaagggg + uM00aa00gg) & 0xff00ff00;
        
                pixDst.ul  = uD00rr00bb + uDaa00gg00;
            }
            else
            {
                //
                // disolve
                //

                ULONG ul_B_00AA00GG = (pixSrc.ul & 0xff00ff00) >> 8;
                ULONG ul_B_00RR00BB = (pixSrc.ul & 0x00ff00ff);
        
                ULONG ul_T_AAAAGGGG = ul_B_00AA00GG * ConstAlpha + 0x00800080;
                ULONG ul_T_RRRRBBBB = ul_B_00RR00BB * ConstAlpha + 0x00800080;
        
                ULONG ul_T_00AA00GG = (ul_T_AAAAGGGG & 0xFF00FF00) >> 8;
                ULONG ul_T_00RR00BB = (ul_T_RRRRBBBB & 0xFF00FF00) >> 8;
        
                ULONG ul_C_AA00GG00 = ((ul_T_AAAAGGGG + ul_T_00AA00GG) & 0xFF00FF00);
                ULONG ul_C_00RR00BB = ((ul_T_RRRRBBBB + ul_T_00RR00BB) & 0xFF00FF00) >> 8;
        
                pixSrc.ul = (ul_C_AA00GG00 | ul_C_00RR00BB);

                //
                // over
                //


                ULONG Multa = 255 - pixSrc.pix.a;
                ULONG _D1_00AA00GG = (pixDst.ul & 0xff00ff00) >> 8;
                ULONG _D1_00RR00BB = (pixDst.ul & 0x00ff00ff);

                ULONG _D2_AAAAGGGG = _D1_00AA00GG * Multa + 0x00800080;
                ULONG _D2_RRRRBBBB = _D1_00RR00BB * Multa + 0x00800080;

                ULONG _D3_00AA00GG = (_D2_AAAAGGGG & 0xff00ff00) >> 8;
                ULONG _D3_00RR00BB = (_D2_RRRRBBBB & 0xff00ff00) >> 8;


                ULONG _D4_AA00GG00 = (_D2_AAAAGGGG + _D3_00AA00GG) & 0xFF00FF00;
                ULONG _D4_00RR00BB = ((_D2_RRRRBBBB + _D3_00RR00BB) & 0xFF00FF00) >> 8;

                pixDst.ul = pixSrc.ul + _D4_AA00GG00 + _D4_00RR00BB;
            }

            *ppixDst = pixDst;
        }
        else
        {
            *pwrMask = 0;
        }

        pwrMask++;
        ppixSrc++;
        ppixDst++;
    }
}

#if !defined(_X86_)

/******************************Public*Routine******************************\
* vPixelBlend
*   
*   Blend function used then BlendFunction is SRC_OVER and 
*   SourceConstantAlpha != 255, and Src image does NOT have
*   it's own alpha channel. (assume 255)
*
*           Dst = Dst + ConstAlpha * (Src - Dst)
*   
* Arguments:
*   
*   ppixDst        - address of dst pixel
*   ppixSrc        - address of src pixel
*   cx             - number of pixels in scan line
*   BlendFunction  - blend to be done on each pixel
*   pwrMask        - set each byte to 0 for pixel that doesn't need 
*                    to be written to dst
*
* Return Value:
*   
*   None
*
* History:
*
*    12/2/1996 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vPixelBlend(
    ALPHAPIX       *ppixDst,
    ALPHAPIX       *ppixSrc,
    LONG           cx,
    BLENDFUNCTION  BlendFunction,
    PBYTE          pwrMask
    )
{
    PULONG   pulSrc = (PULONG)ppixSrc;
    PULONG   pulDst = (PULONG)ppixDst;
    PULONG   pulSrcEnd = pulSrc + cx;
    BYTE     ConstAlpha = BlendFunction.SourceConstantAlpha;

    //
    // Blend: D = sA * S + (1-sA) * D
    //

    while (pulSrc != pulSrcEnd)
    {
        ULONG ulDst = *pulDst;
        ULONG ulSrc = *pulSrc;
        ULONG uB00rr00bb = ulDst & 0x00ff00ff;
        ULONG uF00rr00bb = ulSrc & 0x00ff00ff;

        ULONG uMrrrrbbbb; 
        ULONG uM00rr00bb; 
        ULONG uD00rr00bb; 
        ULONG uB00aa00gg;
        ULONG uF00aa00gg;
        ULONG uMaaaagggg;
        ULONG uM00aa00gg;
        ULONG uDaa00gg00;

        //
        // red and blue
        //

        uB00rr00bb = ulDst & 0x00ff00ff;
        uF00rr00bb = ulSrc & 0x00ff00ff;

        uMrrrrbbbb = ((uB00rr00bb<<8)-uB00rr00bb) + 
                     (ConstAlpha * (uF00rr00bb - uB00rr00bb)) + 0x00800080;

        uM00rr00bb = (uMrrrrbbbb & 0xff00ff00) >> 8;

        uD00rr00bb = ((uMrrrrbbbb+uM00rr00bb) & 0xff00ff00)>>8;

        //
        // alpha and green
        //

        uB00aa00gg = (ulDst >> 8) & 0xff00ff;
        uF00aa00gg = (ulSrc >> 8) & 0xff00ff;

        uMaaaagggg = ((uB00aa00gg <<8)-uB00aa00gg) +
                     (ConstAlpha * (uF00aa00gg-uB00aa00gg)) + 0x00800080;

        uM00aa00gg = (uMaaaagggg & 0xff00ff00)>>8;

        uDaa00gg00 = (uMaaaagggg + uM00aa00gg) & 0xff00ff00;

        *pulDst = uD00rr00bb + uDaa00gg00;

        pulSrc++;
        pulDst++;
    }
}

#endif


#if defined(_X86_)

typedef unsigned __int64 QWORD;

/**************************************************************************
  THIS FUNCTION DOES NOT DO ANY PARAMETER VALIDATION
  DO NOT CALL THIS FUNCTION WITH WIDTH == 0

  This function operates on 32 bit pixels (BGRA) in a row of a bitmap.
  This function performs the following:

  		SrcTran = 255 - pixSrc.a
		pixDst.r = pixSrc.r + (((SrcTran * pixDst.r)+127)/255);
		pixDst.g = pixSrc.g + (((SrcTran * pixDst.g)+127)/255);
		pixDst.b = pixSrc.b + (((SrcTran * pixDst.b)+127)/255);
		pixDst.a = pixSrc.a + (((SrcTran * pixDst.a)+127)/255);

  pDst is assumed to be aligned to a DWORD boundary when passed to this function.
  Step 1:
	Check pDst for QWORD alignment.  If aligned, do Step 2.  If unaligned, do first pixel
	as a DWORD, then do Step 2.
  Step 2:
	QuadAligned
	pDst is QWORD aligned.  If two pixels can be done as a QWORD, do Step 3.  If only one
	pixel left, do as a DWORD.
  Step 3:
	Load two source pixels, S1 and S2.  Get (255 - alpha value) for each source pixel, 255-S1a and 255-S2a.
	Copy 255-S1a as four words into an MMX register.  Copy 255-S2a as four words into an MMX register.
	Load two destination pixels, D1 and D2.  Expand each byte in D1 into four words
	of an MMX register.  If at least four pixels can be done, do Step 4.  If not, jump over
	FourPixelsPerPass and finish doing two pixels at TwoPixelsLeft, Step 5.
  Step 4:
	FourPixelsPerPass
	Expand each byte in D2 into four words of an MMX register.  Multiply each byte
	of D1 by 255-S1a.  Multiply each byte of D2 by 255-S2a.  Add 128 to each intermediate result
	of both pixels.  Copy the results of each pixel into an MMX register.  Shift each result of
	both pixels by 8.  Add the shifted results to the copied results.  Shift these results by 8.
	Pack the results into one MMX register.  Add the packed results to the source pixels.  Store result
	over destination pixels.  Stay in FourPixelsPerPass loop until there are less than four pixels to do.
  Step 5:
    TwoPixelsLeft
	Do same as Step 4 above; but do not loop.
  Step 6:
	OnePixelLeft
	If there is one pixel left (odd number of original pixels) do last pixel as a DWORD.
**************************************************************************/
VOID
mmxPixelOver(
    ALPHAPIX       *pDst,
    ALPHAPIX       *pSrc,
	LONG			Width,
	BLENDFUNCTION	BlendFunction,
	PBYTE			pwrMask)
{
	static QWORD W128 = 0x0080008000800080;
	static QWORD AlphaMask = 0x000000FF000000FF;

	_asm
	{
        mov			esi, pSrc
        mov			edi, pDst
    
        movq		mm7, W128		// |  0  | 128 |  0  | 128 |  0  | 128 |  0  | 128 |
                                    //	This register never changes
        pxor		mm6, mm6		// |  0  |  0  |  0  |  0  |  0  |  0  |  0  |  0  |
                                    //	This register never changes
    
        mov			ecx, Width
                                    // Step 1:
        test		edi, 7			// Test first pixel for QWORD alignment
        jz			QuadAligned		// if unaligned,
    
        jmp			Do1Pixel		// do first pixel only
    
    QuadAligned:					// Step 2:
        mov			eax, ecx		// Save the width in eax for later (see OnePixelLeft:)
        shr			ecx, 1			// Want to do 2 pixels (1 quad) at once, so make ecx even
        test		ecx, ecx		// Make sure there is at least 1 quad to do
        jz			OnePixelLeft	// If we take this jump, width was 1 (aligned) or 2 (unaligned)
    
                                    // Step 3:
        movq		mm0, [esi]		// | S2a | S2r | S2g | S2b | S1a | S1r | S1g | S1b |
        psrld		mm0, 24			// |  0  |  0  | 0 |  S2a  |  0  |  0  | 0 |  S1a  |
        pxor		mm0, AlphaMask	// |  0  |  0  | 0 |255-S2a|  0  |  0  | 0 |255-S1a|
        movq		mm1, mm0		// |  0  |  0  | 0 |255-S2a|  0  |  0  | 0 |255-S1a|
    
        punpcklwd	mm0, mm0		// |     0	   |     0	   |  255-S1a  |  255-S1a  |
        movq		mm2, [edi]		// | D2a | D2r | D2g | D2b | D1a | D1r | D1g | D1b |
        punpckhwd	mm1, mm1		// |     0	   |     0	   |  255-S2a  |  255-S2a  |
        movq		mm3, mm2		// | D2a | D2r | D2g | D2b | D1a | D1r | D1g | D1b |
    
        punpckldq	mm0, mm0		// |  255-S1a  |  255-S1a  |  255-S1a  |  255-S1a  |
        punpckldq	mm1, mm1		// |  255-S2a  |  255-S2a  |  255-S2a  |  255-S2a  |
        punpcklbw	mm2, mm6		// |  0  | D1a |  0  | D1r |  0  | D1g |  0  | D1b |
    
        dec			ecx
        jz			TwoPixelsLeft
    
    FourPixelsPerPass:				// Step 4:
        // Indenting indicates operations on the next set of pixels
        // Within this loop, instructions will pair as shown for the Pentium processor
                                    //	T1 = 255-S1a	T2 = 255-S2a
        punpckhbw	mm3, mm6		// |  0  | D2a |  0  | D2r |  0  | D2g |  0  | D2b |
        pmullw		mm2, mm0		// |   T1*D1a  |   T1*D1r  |   T1*D1g  |   T1*D1b  |
    
        movq		mm0, [esi+8]	// | S2a | S2r | S2g | S2b | S1a | S1r | S1g | S1b |
        pmullw		mm3, mm1		// |   T2*D2a  |   T2*D2r  |   T2*D2g  |   T2*D2b  |
    
        psrld		mm0, 24			// |  0  |  0  | 0 |  S2a  |  0  |  0  | 0 |  S1a  |
        add			esi, 8			// pSrc++;
    
        pxor		mm0, AlphaMask	// |  0  |  0  | 0 |255-S2a|  0  |  0  | 0 |255-S1a|
        paddusw		mm2, mm7		// |T1*D1a+128 |T1*D1r+128 |T1*D1g+128 |T1*D1b+128 |
    
        paddusw		mm3, mm7		// |T2*D2a+128 |T2*D2r+128 |T2*D2g+128 |T2*D2b+128 |
        movq		mm1, mm0		// |  0  |  0  | 0 |255-S2a|  0  |  0  | 0 |255-S1a|
    
        movq		mm4, mm2		// |T1*D1a+128 |T1*D1r+128 |T1*D1g+128 |T1*D1b+128 |
        punpcklwd	mm0, mm0		// |     0	   |     0	   |  255-S1a  |  255-S1a  |
    
        movq		mm5, mm3		// |T2*D2a+128 |T2*D2r+128 |T2*D2g+128 |T2*D2b+128 |
        punpckhwd	mm1, mm1		// |     0	   |     0	   |  255-S2a  |  255-S2a  |
                                    //	TDXx' = TX*DXx+128
        psrlw		mm2, 8			// |  TD1a'>>8 |  TD1r'>>8 |  TD1g'>>8 |  TD1b'>>8 |
    
                                    //  TDXx" = (TX*DXx+128)+(TDXx'>>8)
        psrlw		mm3, 8			// |  TD2a'>>8 |  TD2r'>>8 |  TD2g'>>8 |  TD2b'>>8 |
        paddusw		mm4, mm2		// |  TD1a"    |  TD1r"    |  TD1g"    |  TD1b"    |
    
        paddusw		mm5, mm3		// |  TD2a"    |  TD2r"    |  TD2g"    |  TD2b"    |
        psrlw		mm4, 8			// |  TD1a">>8 |  TD1r">>8 |  TD1g">>8 |  TD1b">>8 |
    
        movq		mm2, [edi+8]	// | D2a | D2r | D2g | D2b | D1a | D1r | D1g | D1b |
        psrlw		mm5, 8			// |  TD2a">>8 |  TD2r">>8 |  TD2g">>8 |  TD2b">>8 |
    
        movq		mm3, mm2		// | D2a | D2r | D2g | D2b | D1a | D1r | D1g | D1b |
        packuswb	mm4, mm5		// |TD2a'"|TD2r'"|TD2g'"|TD2b'"|TD1a'"|TD1r'"|TD1g'"|TD1b'"|  
    
        paddusb		mm4, [esi-8]
        punpckldq	mm0, mm0		// |  255-S1a  |  255-S1a  |  255-S1a  |  255-S1a  |
    
        movq		[edi], mm4
        punpckldq	mm1, mm1		// |  255-S2a  |  255-S2a  |  255-S2a  |  255-S2a  |
    
        punpcklbw	mm2, mm6		// |  0  | D1a |  0  | D1r |  0  | D1g |  0  | D1b |
        add			edi, 8			//	pDst++;
        
        dec			ecx
        jnz			FourPixelsPerPass
    
    TwoPixelsLeft:					// Step 5:
        punpckhbw	mm3, mm6		// |  0  | D2a |  0  | D2r |  0  | D2g |  0  | D2b |
        pmullw		mm2, mm0		// |   T1*D1a  |   T1*D1r  |   T1*D1g  |   T1*D1b  |
        pmullw		mm3, mm1		// |   T2*D2a  |   T2*D2r  |   T2*D2g  |   T2*D2b  |
    
        paddusw		mm2, mm7		// |T1*D1a+128 |T1*D1r+128 |T1*D1g+128 |T1*D1b+128 |
        paddusw		mm3, mm7		// |T2*D2a+128 |T2*D2r+128 |T2*D2g+128 |T2*D2b+128 |
    
        movq		mm4, mm2		// |T1*D1a+128 |T1*D1r+128 |T1*D1g+128 |T1*D1b+128 |
        movq		mm5, mm3		// |T2*D2a+128 |T2*D2r+128 |T2*D2g+128 |T2*D2b+128 |
    
        psrlw		mm2, 8			// |  TD1a'>>8 |  TD1r'>>8 |  TD1g'>>8 |  TD1b'>>8 |
        psrlw		mm3, 8			// |  TD2a'>>8 |  TD2r'>>8 |  TD2g'>>8 |  TD2b'>>8 |
    
        paddusw		mm4, mm2		// |  TD1a"    |  TD1r"    |  TD1g"    |  TD1b"    |
        paddusw		mm5, mm3		// |  TD2a"    |  TD2r"    |  TD2g"    |  TD2b"    |
    
        psrlw		mm4, 8			// |  TD1a">>8 |  TD1r">>8 |  TD1g">>8 |  TD1b">>8 |
        psrlw		mm5, 8			// |  TD2a">>8 |  TD2r">>8 |  TD2g">>8 |  TD2b">>8 |
    
        packuswb	mm4, mm5		// |TD2a'"|TD2r'"|TD2g'"|TD2b'"|TD1a'"|TD1r'"|TD1g'"|TD1b'"|  
    
        paddusb		mm4, [esi]
    
        movq		[edi], mm4
    
        add			edi, 8
        add			esi, 8
    
    OnePixelLeft:				    // Step 6:
        // This tests for 0 or 1 pixel left in row - eax contains real width, not width/2
        // If 0, there were an even number of pixels and we're done
        // If 1, there is an odd number of pixels and we need to do one more
        test		eax, 1	
        jz			Done
    
    Do1Pixel:						// make as a macro if used in asm file
                                    // T = 255-S1x
        movd		mm0, DWORD PTR[esi]		// |  0  |  0  |  0  |  0  | S1a | S1r | S1g | S1b |
        psrld		mm0, 24			// |  0  |  0  |  0  |  0  |  0  |  0  | 0 |  S1a  |
        pxor		mm0, AlphaMask	// |  0  |  0  |  0  | 255 |  0  |  0  | 0 |255-S1a|
        punpcklwd	mm0, mm0		// |     0	   |     0	   |  255-S1a  |  255-S1a  |
        punpckldq	mm0, mm0		// |  255-S1a  |  255-S1a  |  255-S1a  |  255-S1a  |
    
        movd		mm1, [edi]		// |  0  |  0  |  0  |  0  | D1a | D1r | D1g | D1b |
        punpcklbw	mm1, mm6		// |  0  | D1a |  0  | D1r |  0  | D1g |  0  | D1b |
        pmullw		mm0, mm1		// |	 T*D1a |	 T*D1r |	 T*D1g |	 T*D1b |
        paddusw		mm0, mm7		// | T*D1a+128 | T*D1r+128 | T*D1g+128 | T*D1b+128 |
        movq		mm1, mm0		// | T*D1a+128 | T*D1r+128 | T*D1g+128 | T*D1b+128 |
        psrlw		mm0, 8			// |  TD1a'>>8 |  TD1r'>>8 |  TD1g'>>8 |  TD1b'>>8 |
        paddusw		mm0, mm1		// |  TD1a"    |  TD1r"    |  TD1g"    |  TD1b"    |
        psrlw		mm0, 8			// |  TD1a">>8 |  TD1r">>8 |  TD1g">>8 |  TD1b">>8 |
        movd        mm1, [esi]
        packuswb	mm0, mm0		// |TD2a'"|TD2r'"|TD2g'"|TD2b'"|TD1a'"|TD1r'"|TD1g'"|TD1b'"|  
        paddusb		mm0, mm1
        movd		[edi], mm0
        add			edi, 4			//	pDst++;
        add			esi, 4			//	pSrc++;
    
        test		ecx, ecx
        jz			Done			// just processed the last pixel of the row
        dec			ecx
        jmp			QuadAligned		// just processed the first pixel of the row
    
    Done:
        emms						// remove for optimizations, have calling function do emms
	}
}

/**************************************************************************\
* mmxPixelBlendOrDissolveOver
*   
*   Blend routine when the blend function is SRC_OVER, but when 
*   SourceConstantAlpah != 255 and The source bitmap does have alpha values
*
*       if SrcAlpha == 255 then
*
*           Dst = Dst + ConstAlpha * (Src - Dst)
*
*       else
*
*           Src = Src * ConstAlpha
*           Dst = Src + (1 - SrcAlpha) Dst       
*   
* Arguments:
*   
*   ppixDst        - address of dst pixel
*   ppixSrc        - address of src pixel
*   cx             - number of pixels in scan line
*   BlendFunction  - blend to be done on each pixel
*   pwrMask        - set each byte to 0 for pixel that doesn't need 
*                    to be written to dst
*
* Return Value:
*
*   None
*
* History:
*
*    3/12/1997 Mark Enstrom [marke]
*
\**************************************************************************/



/**************************************************************************
  THIS FUNCTION DOES NOT DO ANY PARAMETER VALIDATION
  DO NOT CALL THIS FUNCTION WITH WIDTH == 0

  This function operates on 32 bit pixels (BGRA) in a row of a bitmap.
  This function performs the following:
	first,
  		pixSrc.r = (((ConstAlpha * pixSrc.r)+127)/255);
		pixSrc.g = (((ConstAlpha * pixSrc.g)+127)/255);
		pixSrc.b = (((ConstAlpha * pixSrc.b)+127)/255);
		pixSrc.a = (((ConstAlpha * pixSrc.a)+127)/255);
	then,
  		SrcTran = 255 - pixSrc.a
		pixDst.r = pixSrc.r + (((SrcTran * pixDst.r)+127)/255);
		pixDst.g = pixSrc.g + (((SrcTran * pixDst.g)+127)/255);
		pixDst.b = pixSrc.b + (((SrcTran * pixDst.b)+127)/255);
		pixDst.a = pixSrc.a + (((SrcTran * pixDst.a)+127)/255);

  pDst is assumed to be aligned to a DWORD boundary when passed to this function.
  Step 1:
	Check pDst for QWORD alignment.  If aligned, do Step 2.  If unaligned, do first pixel
	as a DWORD, then do Step 2.
  Step 2:
	QuadAligned
	pDst is QWORD aligned.  If two pixels can be done as a QWORD, do Step 3.  If only one
	pixel left, do as a DWORD.
  Step 3:
	Load two source pixels, S1 and S2, as one QWORD.  Expand S1 and S2 as four words into two MMX registers.
	Multiply each word in S1 and S2 by ConstAlpha.  Add 128 to each result of both pixels.  Copy the results
	of each pixel into an MMX register.  Shift each result of both pixels by 8.  Add the shifted results
	to the copied results.  Shift these results by 8.  Pack the results into one MMX register...this will
	be used later.
	Shift the packed results by 24 to get only the alpha value for each pixel.
  Step 4:
	Get (255 - new alpha value) for each pixel, 255-S1a and 255-S2a.
	Copy 255-S1a as four words into an MMX register.  Copy 255-S2a as four words into an MMX register.
	Load two destination pixels, D1 and D2.  Expand D1 and D2 as four words into two MMX registers.
	Multiply each byte of D1 by 255-S1a.  Multiply each byte of D2 by 255-S2a.  Add 128 to each intermediate
	result of both pixels.  Copy the results of each pixel into an MMX register.  Shift each result of
	both pixels by 8.  Add the shifted results to the copied results.  Shift these results by 8.
	Pack the results into one MMX register.  Add the packed results to the new source pixels saved from
	above.  Store result over destination pixels.  Stay in TwoPixelsAtOnceLoop loop until there is less than
	two pixels to do.
  Step 5:
	OnePixelLeft
	If there is one pixel left (odd number of original pixels) do last pixel as a DWORD.
**************************************************************************/
VOID
mmxPixelBlendOrDissolveOver(
    ALPHAPIX	  *pDst,
    ALPHAPIX	  *pSrc,
	LONG 	       Width,
    BLENDFUNCTION  BlendFunction,
    PBYTE          pwrMask
    )
{
    BYTE    ConstAlpha = BlendFunction.SourceConstantAlpha;
	static QWORD W128 = 0x0080008000800080;
	static QWORD AlphaMask = 0x000000FF000000FF;
	static QWORD Zeros = 0;
	_asm
	{
        mov			esi, pSrc
        mov			edi, pDst
    
        movq		mm7, W128		// This register never changes
        pxor		mm4, mm4		// This register never changes
    
        xor			eax, eax
        mov			al, ConstAlpha	
        movd		mm5, eax		// |		   |		   |		   |		CA |
        punpcklwd	mm5, mm5		// |		   |		   |		CA |		CA |
        punpcklwd	mm5, mm5		// |		CA |		CA |		CA |		CA |
                                    // This register never changes
    
        mov			ecx, Width
                                    // Step 1:
        test		edi, 7			// Test first pixel for QWORD alignment
        jz			QuadAligned		// if unaligned,
    
        jmp			Do1Pixel		// do first pixel only
    
    QuadAligned:					// Step 2:
        mov			eax, ecx		// Save the width in eax for later (see OnePixelLeft:)
        shr			ecx, 1			// Want to do 2 pixels (1 quad) at once, so make ecx even
        test		ecx, ecx		// Make sure there is at least 1 quad to do
        jz			OnePixelLeft	// If we take this jump, width was 1 (aligned) or 2 (unaligned)
    
    TwoPixelsAtOnceLoop:			// Step 3:
        // Within this loop, instructions will pair as shown for the Pentium processor
    
        /* Dissolve
            pixSrc.r = (((ConstAlpha * pixSrc.r)+127)/255);
            pixSrc.g = (((ConstAlpha * pixSrc.g)+127)/255);
            pixSrc.b = (((ConstAlpha * pixSrc.b)+127)/255);
            pixSrc.a = (((ConstAlpha * pixSrc.a)+127)/255);
        */
    
        movq		mm0, [esi]			// | S2a | S2r | S2g | S2b | S1a | S1r | S1g | S1b |
    
        movq		mm1, mm0			// | S2a | S2r | S2g | S2b | S1a | S1r | S1g | S1b |
        punpcklbw	mm0, mm4			// |  0  | S1a |  0  | S1r |  0  | S1g |  0  | S1b |
    
        punpckhbw	mm1, mm4			// |  0  | S2a |  0  | S2r |  0  | S2g |  0  | S2b |
        pmullw		mm0, mm5			// |	CA*S1a |    CA*S1r |	 CA*S1g |	CA*S1b |
    
        add			esi, 8			//	pSrc++;
        pmullw		mm1, mm5			// |	CA*S2a |	CA*S2r |	 CA*S2g |	CA*S2b |
    
        paddusw		mm1, mm7			// |CA*S2a+128 |CA*S2r+128 |CA*S2g+128 |CA*S2b+128 |
        paddusw		mm0, mm7			// |CA*S1a+128 |CA*S1r+128 |CA*S1g+128 |CA*S1b+128 |
    
        movq		mm2, mm0			// |CA*S1a+128 |CA*S1r+128 |CA*S1g+128 |CA*S1b+128 |
        psrlw		mm0, 8				// |  S1a'>>8 |  S1r'>>8 |  S1g'>>8 |  S1b'>>8 |
    
                                    //	S1x' = CA*S1x+128		 S2x' = CA*S2x+128
        movq		mm3, mm1			// |CA*S2a+128 |CA*S2r+128 |CA*S2g+128 |CA*S2b+128 |
        psrlw		mm1, 8				// |  S2a'>>8 |  S2r'>>8 |  S2g'>>8 |  S2b'>>8 |
    
                                    //	S1x" = (CA*S1x+128)>>8  S2x" = (CA*S2x+128)>>8
        paddusw		mm0, mm2			// |  S1a"    |  S1r"    |  S1g"    |  S1b"    |
        paddusw		mm1, mm3			// |  S2a"    |  S2r"    |  S2g"    |  S2b"    |
    
        psrlw		mm0, 8				// |  S1a">>8 |  S1r">>8 |  S1g">>8 |  S1b">>8 |
    
                                    //	SXx'" = ((CA*SXx+128)>>8)>>8)
        psrlw		mm1, 8				// |  S2a">>8 |  S2r">>8 |  S2g">>8 |  S2b">>8 |
        packuswb	mm0, mm1			// |S2a'"|S2r'"|S2g'"|S2b'"|S1a'"|S1r'"|S1g'"|S1b'"|
    
        movq		mm6, mm0
        psrld		mm0, 24				// |  0  |  0  | 0 |  S2a  |  0  |  0  | 0 |  S1a  |
    
        /* Over
            SrcTran = 255 - pixSrc.a
            pixDst.r = pixSrc.r + (((SrcTran * pixDst.r)+128)/255);
            pixDst.g = pixSrc.g + (((SrcTran * pixDst.g)+128)/255);
            pixDst.b = pixSrc.b + (((SrcTran * pixDst.b)+128)/255);
            pixDst.a = pixSrc.a + (((SrcTran * pixDst.a)+128)/255);
        */
                                    // Step 4:
        pxor		mm0, AlphaMask		// |  0  |  0  | 0 |255-S2a|  0  |  0  | 0 |255-S1a|
    
        movq		mm1, mm0			// |  0  |  0  | 0 |255-S2a|  0  |  0  | 0 |255-S1a|
        punpcklwd	mm0, mm0			// |     0	   |     0	   |   255-S1a |   255-S1a |
    
        movq		mm2, [edi]			// | D2a | D2r | D2g | D2b | D1a | D1r | D1g | D1b |
        punpcklwd	mm0, mm0			// |   255-S1a |   255-S1a |   255-S1a |   255-S1a |
    
        movq		mm3, mm2			// | D2a | D2r | D2g | D2b | D1a | D1r | D1g | D1b |
        punpckhwd	mm1, mm1			// |     0	   |     0	   |   255-S2a |   255-S2a |
    
        punpcklwd	mm1, mm1			// |   255-S2a |   255-S2a |   255-S2a |   255-S2a |
    
        punpckhbw	mm3, mm4			// |  0  | D2a |  0  | D2r |  0  | D2g |  0  | D2b |
    
                                    //	T1 = 255-S1a	T2 = 255-S2a
        punpcklbw	mm2, mm4			// |  0  | D1a |  0  | D1r |  0  | D1g |  0  | D1b |
        pmullw		mm1, mm3			// |	T2*D2a |	T2*D2r |	 T2*D2g |	T2*D2b |
    
        add			edi, 8			//	pDst++;
        pmullw		mm0, mm2			// |	T1*D1a |	T1*D1r |	 T1*D1g |	T1*D1b |
    
        paddusw		mm0, mm7			// |T1*D1a+128 |T1*D1r+128 |T1*D1g+128 |T1*D1b+128 |
        paddusw		mm1, mm7			// |T2*D2a+128 |T2*D2r+128 |T2*D2g+128 |T2*D2b+128 |
    
        movq		mm3, mm1			// |T2*D2a+128 |T2*D2r+128 |T2*D2g+128 |T2*D2b+128 |
                                    //  TDXx' = TX*DXx+128
        psrlw		mm1, 8				// |  TD2a'>>8 |  TD2r'>>8 |  TD2g'>>8 |  TD2b'>>8 |
    
        movq		mm2, mm0			// |T1*D1a+128 |T1*D1r+128 |T1*D1g+128 |T1*D1b+128 |
        psrlw		mm0, 8				// |  TD1a'>>8 |  TD1r'>>8 |  TD1g'>>8 |  TD1b'>>8 |
                                    //  TDXx" = (TX*DXx+128)+(TDXx'>>8)
        paddusw		mm1, mm3			// |  TD2a"    |  TD2r"    |  TD2g"    |  TD2b"    |
        paddusw		mm0, mm2			// |  TD1a"    |  TD1r"    |  TD1g"    |  TD1b"    |
    
        psrlw		mm1, 8				// |  TD2a">>8 |  TD2r">>8 |  TD2g">>8 |  TD2b">>8 |
    
        psrlw		mm0, 8				// |  TD1a">>8 |  TD1r">>8 |  TD1g">>8 |  TD1b">>8 |
    
        packuswb	mm0, mm1		// |TD2a'"|TD2r'"|TD2g'"|TD2b'"|TD1a'"|TD1r'"|TD1g'"|TD1b'"|  
                                    //	SXx = SXx'"	TDXx = TDXx'"
        paddusb		mm0, mm6// |S2a+TD2a|S2r+TD2r|S2g+TD2g|S2b+TD2b|S1a+TD1a|S1r+TD1r|S1g+TD1g|S1b+TD1b|
    
        movq		[edi-8], mm0
    
        dec			ecx
        jnz			TwoPixelsAtOnceLoop
    
    OnePixelLeft:					// Step 5:
        // This tests for 0 or 1 pixel left in row - eax contains real width, not width/2
        // If 0, there were an even number of pixels and we're done
        // If 1, there is an odd number of pixels and we need to do one more
        test		eax, 1	
        jz			Done
        
    Do1Pixel:						// make as a macro if used in asm file
    
        /* Dissolve
            pixSrc.r = (((ConstAlpha * pixSrc.r)+127)/255);
            pixSrc.g = (((ConstAlpha * pixSrc.g)+127)/255);
            pixSrc.b = (((ConstAlpha * pixSrc.b)+127)/255);
            pixSrc.a = (((ConstAlpha * pixSrc.a)+127)/255);
        */
    
        movd		mm0, [esi]			// | S2a | S2r | S2g | S2b | S1a | S1r | S1g | S1b |
        punpcklbw	mm0, mm4			// |  0  | S1a |  0  | S1r |  0  | S1g |  0  | S1b |
    
        pmullw		mm0, mm5			// |	CA*S1a |    CA*S1r |	 CA*S1g |	CA*S1b |
        paddusw		mm0, mm7			// |CA*S1a+128 |CA*S1r+128 |CA*S1g+128 |CA*S1b+128 |
        movq		mm2, mm0			// |CA*S1a+128 |CA*S1r+128 |CA*S1g+128 |CA*S1b+128 |
    
                                    //	 S1x' = CA*S1x+128		 S2x' = CA*S2x+128
        psrlw		mm0, 8				// |  S1a'>>8 |  S1r'>>8 |  S1g'>>8 |  S1b'>>8 |
                                    //	 S1x" = (CA*S1x+128)>>8 S2x" = (CA*S2x+128)>>8
        paddusw		mm0, mm2			// |  S1a"    |  S1r"    |  S1g"    |  S1b"    |
        psrlw		mm0, 8				// |  S1a">>8 |  S1r">>8 |  S1g">>8 |  S1b">>8 |
        packuswb	mm0, mm0			// |S2a'"|S2r'"|S2g'"|S2b'"|S1a'"|S1r'"|S1g'"|S1b'"|
        movq		mm6, mm0
        psrld		mm0, 24				// |  0  |  0  | 0 |  S2a  |  0  |  0  | 0 |  S1a  |
    
        /* Over
            SrcTran = 255 - pixSrc.a
            pixDst.r = pixSrc.r + (((SrcTran * pixDst.r)+128)/255);
            pixDst.g = pixSrc.g + (((SrcTran * pixDst.g)+128)/255);
            pixDst.b = pixSrc.b + (((SrcTran * pixDst.b)+128)/255);
            pixDst.a = pixSrc.a + (((SrcTran * pixDst.a)+128)/255);
        */
    
        pxor		mm0, AlphaMask		// |  0  |  0  | 0 |255-S2a|  0  |  0  | 0 |255-S1a|
        punpcklwd	mm0, mm0			// |  0  |  0  |  0  |  0  |  0  |  0  |255-S1a|255-S1a|
        punpckldq	mm0, mm0			// |    255-S1a|    255-S1a|    255-S1a|    255-S1a|
        movd		mm2, [edi]			// |  0  |  0  |  0  |  0  | D1a | D1r | D1g | D1b |
        punpcklbw	mm2, mm4			// |	   D1a |	   D1r |	   D1g |	   D1b |
                                    //	T = 255-S1x
        pmullw		mm0, mm2			// |	 T*D1a |	 T*D1r |	 T*D1g |	 T*D1b |
        paddusw		mm0, mm7			// | T*D1a+128 | T*D1r+128 | T*D1g+128 | T*D1b+128 |
        movq		mm1, mm0			// | T*D1a+128 | T*D1r+128 | T*D1g+128 | T*D1b+128 |
        psrlw		mm0, 8				// |  TD1a'>>8 |  TD1r'>>8 |  TD1g'>>8 |  TD1b'>>8 |
        paddusw		mm0, mm1			// |  TD1a"    |  TD1r"    |  TD1g"    |  TD1b"    |
        psrlw		mm0, 8
        packuswb	mm0, mm0		// |TD2a'"|TD2r'"|TD2g'"|TD2b'"|TD1a'"|TD1r'"|TD1g'"|TD1b'"|  
        paddusb		mm0, mm6  
        movd		[edi], mm0
        add			edi, 4			// pDst++;
        add			esi, 4			// pSrc++;
    
        test		ecx, ecx
        jz			Done			// just processed the last pixel of the row
        dec			ecx
        jmp			QuadAligned		// just processed the first pixel of the row
    
    Done:
        emms						// remove for optimizations, have calling function do emms
	}
}

#endif











































/******************************Public*Routine******************************\
* AlphaScanLineBlend
*
*   Blends source and destionation surfaces one scan line at a time. 
*
*   Allocate a scan line buffer for xlate of src to 32BGRA if needed.
*   Allocate a scan line buffer for xlate of dst to 32BGRA if needed.
*   Blend scan line using blend function from pAlphaDispatch
*   Write scan line back to dst (if needed)
*      
* Arguments:
*   
*   pDst           - pointer to dst surface       
*   pDstRect       - Dst output rect
*   DeltaDst       - dst scan line delat
*   pSrc           - pointer to src surface
*   DeltaSrc       - src scan line delta      
*   pptlSrc        - src offset
*   pxloSrcTo32    - xlateobj from src to 32BGR
*   pxlo32ToDst    - xlateobj from 32BGR to dst
*   palDst         - destination palette
*   palSrc         - source palette
*   pAlphaDispatch - blend data and function pointers
*
* Return Value:
*
*   Status
*
* History:
*
*    10/14/1996 Mark Enstrom [marke]
*
\**************************************************************************/

BOOL
AlphaScanLineBlend(
    PBYTE                    pDst,
    PRECTL                   pDstRect,
    ULONG                    DeltaDst,
    PBYTE                    pSrc,
    ULONG                    DeltaSrc,
    PPOINTL                  pptlSrc,
    PPALINFO                 ppalInfoDst,
    PPALINFO                 ppalInfoSrc,
    PALPHA_DISPATCH_FORMAT   pAlphaDispatch
    )
{
    //
    // get two scanlines of RGBA data, blend pixels, store
    //

    LONG     cx = pDstRect->right - pDstRect->left;
    LONG     cy = pDstRect->bottom - pDstRect->top;
    LONG     ScanBufferWidth = cx * 4;
    LONG     WriteMaskSize    = cx;
    LONG     AllocationSize = 0;
    ULONG    ulSrcBytesPerPixel = pAlphaDispatch->ulSrcBitsPerPixel/8;
    ULONG    ulDstBytesPerPixel = pAlphaDispatch->ulDstBitsPerPixel/8;
    PBYTE    pjSrcTempScanBuffer = NULL;
    PBYTE    pjDstTempScanBuffer = NULL;
    PBYTE    pjAlloc = NULL;
    PBYTE    pjDstTmp;
    PBYTE    pjSrcTmp;
    PBYTE    pWriteMask;

    //
    // calculate destination starting address
    //

    if (ulDstBytesPerPixel)
    {
        pjDstTmp = pDst + ulDstBytesPerPixel * pDstRect->left + DeltaDst * pDstRect->top;
    }
    else if (pAlphaDispatch->ulDstBitsPerPixel == 1)
    {
        pjDstTmp = pDst + pDstRect->left/8 + DeltaDst * pDstRect->top;
    }
    else
    {
        pjDstTmp = pDst + pDstRect->left/2 + DeltaDst * pDstRect->top;
    }

    //
    // calculate source starting address
    //

    if (ulSrcBytesPerPixel)
    {
        pjSrcTmp = pSrc + ulSrcBytesPerPixel * pptlSrc->x + DeltaSrc * pptlSrc->y;
    }
    else if (pAlphaDispatch->ulSrcBitsPerPixel == 1)
    {
        pjSrcTmp = pSrc + pptlSrc->x/8 + DeltaSrc * pptlSrc->y;
    }
    else
    {
        pjSrcTmp = pSrc + pptlSrc->x/2 + DeltaSrc * pptlSrc->y;
    }

    //
    // calculate size of needed scan line buffer
    //

    if (pAlphaDispatch->pfnLoadSrcAndConvert != NULL)
    {
        AllocationSize += ScanBufferWidth;
    }

    if (pAlphaDispatch->pfnLoadDstAndConvert != NULL)
    {
        AllocationSize += ScanBufferWidth;
    }

    AllocationSize += WriteMaskSize;

    //
    // allocate scan line buffer memory
    //

    pWriteMask = (PBYTE)LOCALALLOC(AllocationSize);

    if (pWriteMask == NULL)
    {
        return(FALSE);
    }

    PBYTE pjTemp = pWriteMask + WriteMaskSize;

    if (pAlphaDispatch->pfnLoadSrcAndConvert != NULL)
    {
        pjSrcTempScanBuffer = pjTemp;
        pjTemp    += ScanBufferWidth;
    }

    if (pAlphaDispatch->pfnLoadDstAndConvert != NULL)
    {
        pjDstTempScanBuffer = pjTemp;
    }

    //
    // Blend scan lines
    //

    while (cy--)
    {
        PBYTE pjSource = pjSrcTmp;
        PBYTE pjDest   = pjDstTmp;

        //
        // get src scan line if needed
        //

        if (pjSrcTempScanBuffer)
        {
            (*pAlphaDispatch->pfnLoadSrcAndConvert)(
                                (PULONG)pjSrcTempScanBuffer,
                                pjSrcTmp,
                                0,
                                cx,
                                (PVOID)ppalInfoSrc);

            pjSource = pjSrcTempScanBuffer;
        }

        //
        // get dst scan line if needed
        //

        if (pjDstTempScanBuffer)
        {
            (*pAlphaDispatch->pfnLoadDstAndConvert)(
                                (PULONG)pjDstTempScanBuffer,
                                pjDstTmp,
                                0,
                                cx,
                                (PVOID)ppalInfoDst);

            pjDest = pjDstTempScanBuffer;
        }

        //
        // blend
        //

        memset(pWriteMask,1,WriteMaskSize);

        (*pAlphaDispatch->pfnGeneralBlend)(
                               (PALPHAPIX)pjDest,
                               (PALPHAPIX)pjSource,
                               cx,
                               pAlphaDispatch->BlendFunction,
                               pWriteMask
                               );

        //
        // write buffer back if needed
        //

        if (pjDstTempScanBuffer)
        {
            (*pAlphaDispatch->pfnConvertAndStore)(
                                pjDstTmp,
                                (PULONG)pjDstTempScanBuffer,
                                cx,
                                0,
                                (PVOID)ppalInfoDst,
                                pWriteMask
                                );
        }

        pjDstTmp += DeltaDst;
        pjSrcTmp += DeltaSrc;
    }

    //
    // free any temp buffer memory
    //

    LOCALFREE(pWriteMask);

    return(TRUE);
}

/**************************************************************************\
* bIsHalftonePalette
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    12/19/1996 Mark Enstrom [marke]
*
\**************************************************************************/

BOOL
bIsHalftonePalette(ULONG *pPalette)
{
    BOOL bRet = FALSE;

    if (pPalette)
    {
        ULONG ulIndex;


        for (ulIndex=0;ulIndex<256;ulIndex++)
        {
            ALPHAPIX Pix;
            BYTE     Temp;

            Pix.ul = aPalHalftone[ulIndex].ul;

            //
            // jsut store ht palette in rgbquad!!!
            //

            Temp = Pix.pix.r;
            Pix.pix.r = Pix.pix.b;
            Pix.pix.b = Temp;
            Pix.pix.a = 0;

            if ((pPalette[ulIndex] & 0x00ffffff) != Pix.ul)
            {
                break;
            }
        }
        if (ulIndex == 256)
        {
            bRet = TRUE;
        }
    }
    return(bRet);
}

/**************************************************************************\
* vInitializePalinfo
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    12/19/1996 Mark Enstrom [marke]
*
\**************************************************************************/

BOOL
bInitializePALINFO(
    PPALINFO ppalInfo
    )
{
    //
    // based on pmbi, set palette color flag and set translation
    // routines
    //

    BOOL        bRet = FALSE;
    PBITMAPINFO pbmi = ppalInfo->pBitmapInfo;

    if (pbmi == NULL)
    {
        return(FALSE);
    }

    PULONG pulColors = (PULONG)&pbmi->bmiColors[0];

    ppalInfo->pxlate332 = NULL;

    switch (pbmi->bmiHeader.biBitCount)
    {
    case 1:
        {
            //
            // make color xlate vector
            //

            ULONG NumPalEntries = 2;
            PBYTE pxlate = NULL;

            pxlate = pGenColorXform332((PULONG)(&pbmi->bmiColors[0]),NumPalEntries);

            if (pxlate)
            {
                ppalInfo->flPal     = XPAL_1PAL;
                ppalInfo->pxlate332 = pxlate;
                bRet                = TRUE;
            }
        }

        break;
    case 4:
        {
            //
            // make color xlate vector
            //

            ULONG NumPalEntries = 16;
            PBYTE pxlate = NULL;

            if ((pbmi->bmiHeader.biClrUsed > 0) &&
                (pbmi->bmiHeader.biClrUsed < 16))
            {
               NumPalEntries = pbmi->bmiHeader.biClrUsed;
            }

            pxlate = pGenColorXform332((PULONG)(&pbmi->bmiColors[0]),NumPalEntries);

            if (pxlate)
            {
                ppalInfo->flPal     = XPAL_4PAL;
                ppalInfo->pxlate332 = pxlate;
                bRet                = TRUE;
            }
        }

        break;

    case 8:
        {
            //
            // make color xlate vector
            //

            ULONG NumPalEntries = 256;
            PBYTE pxlate = NULL;

            if ((pbmi->bmiHeader.biClrUsed > 0) &&
                (pbmi->bmiHeader.biClrUsed < 256))
            {
               NumPalEntries = pbmi->bmiHeader.biClrUsed;
            }

            pxlate = pGenColorXform332((PULONG)(&pbmi->bmiColors[0]),NumPalEntries);

            if (pxlate)
            {
                ppalInfo->flPal     = XPAL_8PAL;
                ppalInfo->pxlate332 = pxlate;
                bRet                = TRUE;
            }
        }

        break;

    case 16:

        //
        // look for 565 RGB or 555 RGB
        //

        if (
             (pulColors[0]   == 0xf800) &&
             (pulColors[1]   == 0x07e0) &&
             (pulColors[2]   == 0x001f)
           )
        {
            ppalInfo->flPal                  = XPAL_RGB16_565;
            bRet = TRUE;
        }
        else if (
                  (pulColors[0]  == 0x7c00) &&
                  (pulColors[1]  == 0x03e0) &&
                  (pulColors[2]  == 0x001f)
                )
        {
            ppalInfo->flPal                  = XPAL_RGB16_555;
            bRet = TRUE;
        }
        else
        {
            ppalInfo->flPal                  = XPAL_RGB16_555;
            bRet = TRUE;
        }

        break;

    case 24:
        ppalInfo->flPal                  = XPAL_RGB24;
        bRet = TRUE;
        break;

    case 32:
        if (
             (pbmi->bmiHeader.biCompression == BI_BGRA) ||   // NT 5 only
             (
               (pbmi->bmiHeader.biCompression == BI_BITFIELDS) &&
               (
                 (pulColors[0]   == 0xff0000) &&
                 (pulColors[1]   == 0x00ff00) &&
                 (pulColors[2]   == 0x0000ff)
               ) ||
               (
                 (pulColors[0]   == 0) &&
                 (pulColors[1]   == 0) &&
                 (pulColors[2]   == 0)
               )
             )
           )

        {
            ppalInfo->flPal                  = XPAL_BGRA;
            bRet = TRUE;
        }
        else if (
                  (pbmi->bmiHeader.biCompression == BI_RGB) ||
                  (pbmi->bmiHeader.biCompression == BI_BITFIELDS) &&
                  (
                    (pulColors[0]   == 0x0000ff) &&
                    (pulColors[1]   == 0x00ff00) &&
                    (pulColors[2]   == 0xff0000)
                  )
                )
        {
            ppalInfo->flPal                  = XPAL_RGB32;
            bRet = TRUE;
        }
        else
        {
            ppalInfo->flPal                  = XPAL_RGB32;
            bRet = TRUE;
        }
    }

    return(bRet);
}

/**************************************************************************\
* vCleanupPALINFO
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    2/13/1997 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vCleanupPALINFO(
    PPALINFO ppalInfo
    )
{
    if ((ppalInfo->pxlate332 != NULL) && 
        (ppalInfo->pxlate332 != gHalftoneColorXlate332))
    {
        LOCALFREE(ppalInfo->pxlate332);
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\image\tmp\gradrect.cxx ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name

   trimesh.cxx

Abstract:

    Implement triangle mesh API

Author:

   Mark Enstrom   (marke)  23-Jun-1996

Enviornment:

   User Mode

Revision History:

--*/


#include "precomp.hxx"
#include "dciman.h"
#pragma hdrstop

#if !(_WIN32_WINNT >= 0x500)

VOID
ImgFillMemoryULONG(
    PBYTE pDst,
    ULONG ulPat,
    ULONG cxBytes
    )
{
    PULONG pulDst = (PULONG)pDst;
    PULONG pulEnd = (PULONG)(pDst + ((cxBytes * 4)/4));
    while (pulDst != pulEnd)
    {
        *pulDst = ulPat;
        pulDst++;
    }
}

/**************************************************************************\
*
*   Dither information for 8bpp. This is customized for dithering to
*   the halftone palette [6,6,6] color cube.
*
* History:
*
*    2/24/1997 Mark Enstrom [marke]
*
\**************************************************************************/

BYTE gDitherMatrix16x16Halftone[256] = {
  3, 28,  9, 35,  4, 30, 11, 36,  3, 29, 10, 35,  5, 30, 11, 37,
 41, 16, 48, 22, 43, 17, 49, 24, 42, 16, 48, 22, 43, 18, 50, 24,
  6, 32,  0, 25,  8, 33,  1, 27,  6, 32,  0, 26,  8, 34,  2, 27,
 44, 19, 38, 12, 46, 20, 40, 14, 45, 19, 38, 13, 46, 21, 40, 14,
  5, 31, 12, 37,  4, 29, 10, 36,  6, 31, 12, 38,  4, 30, 10, 36,
 44, 18, 50, 24, 42, 16, 48, 23, 44, 18, 50, 25, 42, 17, 49, 23,
  8, 34,  2, 28,  7, 32,  0, 26,  9, 34,  2, 28,  7, 33,  1, 26,
 47, 21, 40, 15, 45, 20, 39, 13, 47, 22, 41, 15, 46, 20, 39, 14,
  3, 29,  9, 35,  5, 30, 11, 37,  3, 28,  9, 35,  4, 30, 11, 36,
 41, 16, 48, 22, 43, 17, 49, 24, 41, 15, 47, 22, 43, 17, 49, 23,
  6, 32,  0, 25,  8, 33,  1, 27,  6, 31,  0, 25,  7, 33,  1, 27,
 45, 19, 38, 13, 46, 21, 40, 14, 44, 19, 38, 12, 46, 20, 39, 14,
  5, 31, 12, 37,  4, 29, 10, 36,  5, 31, 11, 37,  3, 29, 10, 35,
 44, 18, 50, 25, 42, 17, 49, 23, 43, 18, 50, 24, 42, 16, 48, 23,
  9, 34,  2, 28,  7, 33,  1, 26,  8, 34,  2, 27,  7, 32,  0, 26,
 47, 21, 41, 15, 45, 20, 39, 13, 47, 21, 40, 15, 45, 19, 39, 13
 };

BYTE gDitherMatrix16x16Default[256] = {
    8, 72, 24, 88, 12, 76, 28, 92,  9, 73, 25, 89, 13, 77, 29, 93,
  104, 40,120, 56,108, 44,124, 60,105, 41,121, 57,109, 45,125, 61,
   16, 80,  0, 64, 20, 84,  4, 68, 17, 81,  1, 65, 21, 85,  5, 69,
  112, 48, 96, 32,116, 52,100, 36,113, 49, 97, 33,117, 53,101, 37,
   14, 78, 30, 94, 10, 74, 26, 90, 15, 79, 31, 95, 11, 75, 27, 91,
  110, 46,126, 62,106, 42,122, 58,111, 47,126, 63,107, 43,123, 59,
   22, 86,  6, 70, 18, 82,  2, 66, 23, 87,  7, 71, 19, 83,  3, 67,
  118, 54,102, 38,114, 50, 98, 34,119, 55,103, 39,115, 51, 99, 35,
    9, 73, 25, 89, 13, 77, 29, 93,  8, 72, 24, 88, 12, 76, 28, 92,
  105, 41,121, 57,109, 45,125, 61,104, 40,120, 56,108, 44,124, 60,
   17, 81,  1, 65, 21, 85,  5, 69, 16, 80,  0, 64, 20, 84,  4, 68,
  113, 49, 97, 33,117, 53,101, 37,112, 48, 96, 32,116, 52,100, 36,
   15, 79, 31, 95, 11, 75, 27, 91, 14, 78, 30, 94, 10, 74, 26, 90,
  111, 47,126, 63,107, 43,123, 59,110, 46,126, 62,106, 42,122, 58,
   23, 87,  7, 71, 19, 83,  3, 67, 22, 86,  6, 70, 18, 82,  2, 66,
  119, 55,103, 39,115, 51, 99, 35,118, 54,102, 38,114, 50, 98, 34
  };

/**************************************************************************\
* HalftoneSaturationTable
*
*   This table maps a 8 bit pixel plus a dither error term in the range
*   of 0 to 51 onto a 8 bit pixel. Overflow of up to 31 is considered
*   saturated (255+51 = 255). The level 51 (0x33) is used to map pixels
*   and error values to the halftone palette
*
* History:
*
*    3/4/1997 Mark Enstrom [marke]
*
\**************************************************************************/

BYTE HalftoneSaturationTable[256+64] = {
   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
   0,  0,  0, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51,
  51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51,
  51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51,
  51, 51, 51, 51, 51, 51,102,102,102,102,102,102,102,102,102,102,
 102,102,102,102,102,102,102,102,102,102,102,102,102,102,102,102,
 102,102,102,102,102,102,102,102,102,102,102,102,102,102,102,102,
 102,102,102,102,102,102,102,102,102,153,153,153,153,153,153,153,
 153,153,153,153,153,153,153,153,153,153,153,153,153,153,153,153,
 153,153,153,153,153,153,153,153,153,153,153,153,153,153,153,153,
 153,153,153,153,153,153,153,153,153,153,153,153,204,204,204,204,
 204,204,204,204,204,204,204,204,204,204,204,204,204,204,204,204,
 204,204,204,204,204,204,204,204,204,204,204,204,204,204,204,204,
 204,204,204,204,204,204,204,204,204,204,204,204,204,204,204,255,
 255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
 255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
 255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
 255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255
};

BYTE DefaultSaturationTable[] = {
   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
 128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,
 128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,
 128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,
 128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,
 128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,
 128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,
 128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,
 128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,255,
 255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
 255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
 255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
 255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
 255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
 255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
 255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
 255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255
};


/**************************************************************************\
* vCalcRectOffsets
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    2/14/1997 Mark Enstrom [marke]
*
\**************************************************************************/

BOOL
bCalcGradientRectOffsets(PGRADIENTRECTDATA pGradRect)
{
    LONG yScanTop     = MAX(pGradRect->rclClip.top,pGradRect->rclGradient.top);
    LONG yScanBottom  = MIN(pGradRect->rclClip.bottom,pGradRect->rclGradient.bottom);
    LONG yScanLeft    = MAX(pGradRect->rclClip.left,pGradRect->rclGradient.left);
    LONG yScanRight   = MIN(pGradRect->rclClip.right,pGradRect->rclGradient.right);

    //
    // calc actual widht, check for early out
    //

    pGradRect->ptDraw.x = yScanLeft;
    pGradRect->ptDraw.y = yScanTop;
    pGradRect->szDraw.cx = yScanRight  - yScanLeft;
    pGradRect->szDraw.cy = yScanBottom - yScanTop;

    LONG ltemp = pGradRect->rclClip.left - pGradRect->rclGradient.left;

    if (ltemp <= 0)
    {
        ltemp = 0;
    }

    pGradRect->xScanAdjust  = ltemp;

    ltemp = pGradRect->rclClip.top  - pGradRect->rclGradient.top;

    if (ltemp <= 0)
    {
        ltemp = 0;
    }

    pGradRect->yScanAdjust = ltemp;

    return((pGradRect->szDraw.cx > 0) && (pGradRect->szDraw.cy > 0));
}

/******************************Public*Routine******************************\
* vFillGRectDIB32BGRA
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    11/21/1996 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vFillGRectDIB32BGRA(
    PDIBINFO          pDibInfo,
    PGRADIENTRECTDATA pgData
    )
{
    LONG    lDelta = pDibInfo->stride;
    LONG    cyClip = pgData->szDraw.cy;

    //
    // fill rect with gradient fill. if this is horizontal mode then
    // draw one scan line and replicate in v, if this is vertical mode then
    // draw one vertical stripe and replicate in h
    //

    ULONG Red    = pgData->Red;
    ULONG Green  = pgData->Green;
    ULONG Blue   = pgData->Blue;
    ULONG Alpha  = pgData->Alpha;


    if (pgData->ulMode & GRADIENT_FILL_RECT_H)
    {
        PBYTE    pDst   = (PBYTE)pDibInfo->pvBase + lDelta * pgData->ptDraw.y;

        LONG     dRed   = pgData->dRdX;
        LONG     dGreen = pgData->dGdX;
        LONG     dBlue  = pgData->dBdX;
        LONG     dAlpha = pgData->dAdX;

        //
        // adjust gradient fill for clipped portion
        //

        if (pgData->xScanAdjust > 0)
        {
            Red    += dRed   * (pgData->xScanAdjust);
            Green  += dGreen * (pgData->xScanAdjust);
            Blue   += dBlue  * (pgData->xScanAdjust);
            Alpha  += dAlpha * (pgData->xScanAdjust);
        }

        //
        // draw 1 scan line
        //

        PULONG pulDstX  =  (PULONG)pDst + pgData->ptDraw.x;
        PULONG pulEndX  =  pulDstX + pgData->szDraw.cx;
        PULONG pulScanX =  pulDstX;
        PBYTE  pScan    = (PBYTE)pulDstX;

        while (pulDstX != pulEndX)
        {
            *pulDstX = ((Alpha & 0x00ff0000) <<  8) |
                       ((Red   & 0x00ff0000)      ) |
                       ((Green & 0x00ff0000) >>  8) |
                       ((Blue  & 0x00ff0000) >> 16);

            Red   += dRed;
            Green += dGreen;
            Blue  += dBlue;
            Alpha += dAlpha;

            pulDstX++;
        }

        cyClip--;
        pScan += lDelta;

        //
        // replicate
        //

        while (cyClip-- > 0)
        {
            memcpy(pScan,pulScanX,4*pgData->szDraw.cx);
            pScan += lDelta;
        }
    }
    else
    {
        LONG     dRed   = pgData->dRdY;
        LONG     dGreen = pgData->dGdY;
        LONG     dBlue  = pgData->dBdY;
        LONG     dAlpha = pgData->dAdY;

        //
        // vertical gradient.
        // replicate each x value accross whole scan line
        //

        if (pgData->yScanAdjust > 0)
        {
            Red    +=  dRed   * (pgData->yScanAdjust);
            Green  +=  dGreen * (pgData->yScanAdjust);
            Blue   +=  dBlue  * (pgData->yScanAdjust);
            Alpha  +=  dAlpha * (pgData->yScanAdjust);
        }

        PBYTE    pDst   = (PBYTE)pDibInfo->pvBase + lDelta * pgData->ptDraw.y;

        pDst = pDst + 4 * pgData->ptDraw.x;

        while (cyClip--)
        {
            ULONG ul = ((Alpha & 0x00ff0000) <<  8) |
                       ((Red   & 0x00ff0000)      ) |
                       ((Green & 0x00ff0000) >>  8) |
                       ((Blue  & 0x00ff0000) >> 16);

            ImgFillMemoryULONG(pDst,ul,pgData->szDraw.cx*4);

            Red   += dRed;
            Green += dGreen;
            Blue  += dBlue;
            Alpha += dAlpha;

            pDst += lDelta;
        }
    }
}

/******************************Public*Routine******************************\
* vFillGRectDIB32RGB
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    11/21/1996 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vFillGRectDIB32RGB(
    PDIBINFO          pDibInfo,
    PGRADIENTRECTDATA pgData
    )
{
    LONG    lDelta = pDibInfo->stride;
    LONG    cyClip = pgData->szDraw.cy;

    //
    // fill rect with gradient fill. if this is horizontal mode then
    // draw one scan line and replicate in v, if this is vertical mode then
    // draw one vertical stripe and replicate in h
    //

    ULONG Red    = pgData->Red;
    ULONG Green  = pgData->Green;
    ULONG Blue   = pgData->Blue;

    if (pgData->ulMode & GRADIENT_FILL_RECT_H)
    {
        PBYTE    pDst   = (PBYTE)pDibInfo->pvBase + lDelta * pgData->ptDraw.y;

        LONG     dRed   = pgData->dRdX;
        LONG     dGreen = pgData->dGdX;
        LONG     dBlue  = pgData->dBdX;

        //
        // adjust gradient fill for clipped portion
        //

        if (pgData->xScanAdjust > 0)
        {
            Red    += dRed   * (pgData->xScanAdjust);
            Green  += dGreen * (pgData->xScanAdjust);
            Blue   += dBlue  * (pgData->xScanAdjust);
        }

        //
        // draw 1 scan line
        //

        PULONG pulDstX  =  (PULONG)pDst + pgData->ptDraw.x;
        PULONG pulEndX  =  pulDstX      + pgData->szDraw.cx;
        PULONG pulScanX =  pulDstX;
        PBYTE  pScan    = (PBYTE)pulDstX;

        while (pulDstX != pulEndX)
        {
            *pulDstX =
                       ((Red   & 0x00ff0000)      ) |
                       ((Green & 0x00ff0000) >>  8) |
                       ((Blue  & 0x00ff0000) >> 16);

            Red   += dRed;
            Green += dGreen;
            Blue  += dBlue;

            pulDstX++;
        }

        cyClip--;
        pScan += lDelta;

        //
        // replicate
        //

        while (cyClip-- > 0)
        {
            memcpy(pScan,pulScanX,4*pgData->szDraw.cx);
            pScan += lDelta;
        }
    }
    else
    {
        LONG     dRed   = pgData->dRdY;
        LONG     dGreen = pgData->dGdY;
        LONG     dBlue  = pgData->dBdY;

        //
        // vertical gradient.
        // replicate each x value accross whole scan line
        //

        if (pgData->yScanAdjust > 0)
        {
            Red    +=  dRed   * (pgData->yScanAdjust);
            Green  +=  dGreen * (pgData->yScanAdjust);
            Blue   +=  dBlue  * (pgData->yScanAdjust);
        }

        PBYTE    pDst   = (PBYTE)pDibInfo->pvBase + lDelta * pgData->ptDraw.y;

        pDst = pDst + 4 * pgData->ptDraw.x;

        while (cyClip--)
        {
            ULONG ul = ((Red   & 0x00ff0000)      ) |
                       ((Green & 0x00ff0000) >>  8) |
                       ((Blue  & 0x00ff0000) >> 16);

            ImgFillMemoryULONG(pDst,ul,pgData->szDraw.cx*4);

            Red   += dRed;
            Green += dGreen;
            Blue  += dBlue;

            pDst += lDelta;
        }
    }
}

/******************************Public*Routine******************************\
* vFillGRectDIB24RGB
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    11/21/1996 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vFillGRectDIB24RGB(
    PDIBINFO          pDibInfo,
    PGRADIENTRECTDATA pgData
    )
{
    LONG    lDelta = pDibInfo->stride;
    LONG    cyClip = pgData->szDraw.cy;

    ULONG Red    = pgData->Red;
    ULONG Green  = pgData->Green;
    ULONG Blue   = pgData->Blue;

    //
    // fill rect with gradient fill. if this is horizontal mode then
    // draw one scan line and replicate in v, if this is vertical mode then
    // draw one vertical stripe and replicate in h
    //

    if (pgData->ulMode & GRADIENT_FILL_RECT_H)
    {
        PBYTE  pDst   = (PBYTE)pDibInfo->pvBase +
                                    lDelta * pgData->ptDraw.y +
                                    3 * pgData->ptDraw.x;

        LONG     dRed   = pgData->dRdX;
        LONG     dGreen = pgData->dGdX;
        LONG     dBlue  = pgData->dBdX;

        //
        // adjust gradient fill for clipped portion
        //

        if (pgData->xScanAdjust > 0)
        {
            Red    += dRed   * (pgData->xScanAdjust);
            Green  += dGreen * (pgData->xScanAdjust);
            Blue   += dBlue  * (pgData->xScanAdjust);
        }

        PBYTE  pBuffer = (PBYTE)LOCALALLOC(3 * pgData->szDraw.cx);

        if (pBuffer)
        {
            PBYTE  pDstX  =  pBuffer;
            PBYTE  pLast  =  pDstX + 3 * pgData->szDraw.cx;

            while (pDstX != pLast)
            {
                *pDstX     =  (BYTE)(Blue  >> 16);
                *(pDstX+1) =  (BYTE)(Green >> 16);
                *(pDstX+2) =  (BYTE)(Red   >> 16);

                Red   += dRed;
                Green += dGreen;
                Blue  += dBlue;

                pDstX+=3;
            }

            //
            // Replicate the scan line. It would be much better to write the scan line
            // out to a memory buffer for drawing to a device surface!!!
            //

            while (cyClip--)
            {
                memcpy(pDst,pBuffer,3*pgData->szDraw.cx);
                pDst += lDelta;
            }

            LOCALFREE(pBuffer);
        }
    }
    else
    {
        //
        // vertical gradient.
        // replicate each x value accross whole scan line
        //

        PBYTE    pDst   = (PBYTE)pDibInfo->pvBase + lDelta * pgData->ptDraw.y;

        LONG     dRed   = pgData->dRdY;
        LONG     dGreen = pgData->dGdY;
        LONG     dBlue  = pgData->dBdY;

        //
        // vertical gradient.
        // replicate each x value accross whole scan line
        //

        if (pgData->yScanAdjust > 0)
        {
            Red    +=  dRed   * (pgData->yScanAdjust);
            Green  +=  dGreen * (pgData->yScanAdjust);
            Blue   +=  dBlue  * (pgData->yScanAdjust);
        }

        pDst = pDst + 3 * pgData->ptDraw.x;

        while (cyClip--)
        {
            //
            // fill scan line with solid color
            //

            PBYTE pTemp  = pDst;
            PBYTE pEnd   = pDst + 3 * pgData->szDraw.cx;
            BYTE  jRed   = (BYTE)((Red   & 0x00ff0000) >> 16);
            BYTE  jGreen = (BYTE)((Green & 0x00ff0000) >> 16);
            BYTE  jBlue  = (BYTE)((Blue  & 0x00ff0000) >> 16);

            while (pTemp != pEnd)
            {
                *pTemp     = jBlue;
                *(pTemp+1) = jGreen;
                *(pTemp+2) = jRed;
                pTemp+=3;
            }

            //
            // increment colors for next scan line
            //

            Red   += dRed;
            Green += dGreen;
            Blue  += dBlue;

            //
            // inc pointer to next scan line
            //

            pDst += lDelta;
        }
    }
}

/******************************Public*Routine******************************\
* vFillGRectDIB16_565
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    11/21/1996 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vFillGRectDIB16_565(
    PDIBINFO          pDibInfo,
    PGRADIENTRECTDATA pgData
    )
{
    LONG     lDelta = pDibInfo->stride;
    LONG     cxClip = pgData->szDraw.cx;

    LONG     yScan       = pgData->ptDraw.y;
    LONG     yScanBottom = yScan + pgData->szDraw.cy;

    PBYTE    pDst   = (PBYTE)pDibInfo->pvBase + lDelta * pgData->ptDraw.y;

    LONG     dxRed   = pgData->dRdX;
    LONG     dxGreen = pgData->dGdX;
    LONG     dxBlue  = pgData->dBdX;

    LONG     dyRed   = pgData->dRdY;
    LONG     dyGreen = pgData->dGdY;
    LONG     dyBlue  = pgData->dBdY;

    ULONG    eRed;
    ULONG    eGreen;
    ULONG    eBlue;

    PULONG   pulDither;

    //
    // skip down to left edge
    //

    eRed   = pgData->Red;
    eGreen = pgData->Green;
    eBlue  = pgData->Blue;

    if (pgData->yScanAdjust)
    {
        eRed   += dyRed   * (pgData->yScanAdjust);
        eGreen += dyGreen * (pgData->yScanAdjust);
        eBlue  += dyBlue  * (pgData->yScanAdjust);
    }

    LONG    yDitherOrg = pgData->ptDitherOrg.y;
    LONG    xDitherOrg = pgData->ptDitherOrg.x;

    while(yScan < yScanBottom)
    {
        PUSHORT pusDstX;
        PUSHORT pusDstScanRight,pusDstScanLeft;
        LONG    xScanRight;
        ULONG   Red;
        ULONG   Green;
        ULONG   Blue;

        pulDither = &gulDither32[0] + 4 * ((yScan+yDitherOrg) & 3);

        Red   = eRed;
        Green = eGreen;
        Blue  = eBlue;

        if (pgData->xScanAdjust)
        {
            Red   += dxRed   * (pgData->xScanAdjust);
            Green += dxGreen * (pgData->xScanAdjust);
            Blue  += dxBlue  * (pgData->xScanAdjust);
        }

        pusDstX         = (PUSHORT)pDst + pgData->ptDraw.x;
        pusDstScanRight = pusDstX       + pgData->szDraw.cx;

        while (pusDstX < pusDstScanRight)
        {
            ULONG   ulDither = pulDither[(((ULONG)pusDstX >> 1)+xDitherOrg) & 3];

            ULONG   iRed   = (((Red   >> 3) + ulDither) >> 16);
            ULONG   iGreen = (((Green >> 2) + ulDither) >> 16);
            ULONG   iBlue  = (((Blue  >> 3) + ulDither) >> 16);

            //
            // check for overflow
            //

            if ((iRed | iBlue) & 0x20)
            {
                if (iRed & 0x20)
                {
                    iRed = 0x1f;
                }

                if (iBlue & 0x20)
                {
                    iBlue = 0x1f;
                }
            }

            if (iGreen & 0x40)
            {
                iGreen = 0x3f;
            }

            *pusDstX = rgb565(iRed,iGreen,iBlue);

            pusDstX++;
            Red   += dxRed;
            Green += dxGreen;
            Blue  += dxBlue;
        }

        eRed   += dyRed;
        eGreen += dyGreen;
        eBlue  += dyBlue;
        yScan  ++;
        pDst   += lDelta;
    }
}

/******************************Public*Routine******************************\
* vFillGRectDIB16_555
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    11/21/1996 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vFillGRectDIB16_555(
    PDIBINFO          pDibInfo,
    PGRADIENTRECTDATA pgData
    )
{

    LONG     lDelta = pDibInfo->stride;
    LONG     cxClip = pgData->szDraw.cx;

    LONG     yScan       = pgData->ptDraw.y;
    LONG     yScanBottom = yScan + pgData->szDraw.cy;

    PBYTE    pDst   = (PBYTE)pDibInfo->pvBase + lDelta * pgData->ptDraw.y;

    LONG     dxRed   = pgData->dRdX;
    LONG     dxGreen = pgData->dGdX;
    LONG     dxBlue  = pgData->dBdX;

    LONG     dyRed   = pgData->dRdY;
    LONG     dyGreen = pgData->dGdY;
    LONG     dyBlue  = pgData->dBdY;

    ULONG    eRed;
    ULONG    eGreen;
    ULONG    eBlue;

    PULONG   pulDither;

    //
    // skip down to left edge
    //

    eRed   = pgData->Red;
    eGreen = pgData->Green;
    eBlue  = pgData->Blue;

    if (pgData->yScanAdjust)
    {
        eRed   += dyRed   * (pgData->yScanAdjust);
        eGreen += dyGreen * (pgData->yScanAdjust);
        eBlue  += dyBlue  * (pgData->yScanAdjust);
    }

    LONG    yDitherOrg = pgData->ptDitherOrg.y;
    LONG    xDitherOrg = pgData->ptDitherOrg.x;

    while(yScan < yScanBottom)
    {
        PUSHORT pusDstX;
        PUSHORT pusDstScanRight,pusDstScanLeft;
        LONG    xScanRight;
        ULONG   Red;
        ULONG   Green;
        ULONG   Blue;

        pulDither = &gulDither32[0] + 4 * ((yScan+yDitherOrg) & 3);

        Red   = eRed;
        Green = eGreen;
        Blue  = eBlue;

        if (pgData->xScanAdjust)
        {
            Red   += dxRed   * (pgData->xScanAdjust);
            Green += dxGreen * (pgData->xScanAdjust);
            Blue  += dxBlue  * (pgData->xScanAdjust);
        }

        pusDstX         = (PUSHORT)pDst + pgData->ptDraw.x;
        pusDstScanRight = pusDstX       + pgData->szDraw.cx;

        while (pusDstX < pusDstScanRight)
        {
            ULONG   ulDither = pulDither[(((ULONG)pusDstX >> 1)+xDitherOrg) & 3];

            ULONG   iRed   = (((Red   >> 3) + ulDither) >> 16);
            ULONG   iGreen = (((Green >> 3) + ulDither) >> 16);
            ULONG   iBlue  = (((Blue  >> 3) + ulDither) >> 16);

            //
            // check for overflow
            //

            if ((iRed | iBlue | iGreen) & 0x20)
            {
                if (iRed & 0x20)
                {
                    iRed = 0x1f;
                }

                if (iBlue & 0x20)
                {
                    iBlue = 0x1f;
                }

                if (iGreen & 0x20)
                {
                    iGreen = 0x1f;
                }
            }

            *pusDstX = rgb555(iRed,iGreen,iBlue);

            pusDstX++;
            Red   += dxRed;
            Green += dxGreen;
            Blue  += dxBlue;
        }

        eRed   += dyRed;
        eGreen += dyGreen;
        eBlue  += dyBlue;
        yScan  ++;
        pDst   += lDelta;
    }
}

/******************************Public*Routine******************************\
* vFillGRectDIB8
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    11/21/1996 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vFillGRectDIB8(
    PDIBINFO          pDibInfo,
    PGRADIENTRECTDATA pgData
    )
{
    LONG     lDelta = pDibInfo->stride;
    LONG     cxClip = pgData->szDraw.cx;

    LONG     yScan       = pgData->ptDraw.y;
    LONG     yScanBottom = yScan + pgData->szDraw.cy;

    PBYTE    pDst   = (PBYTE)pDibInfo->pvBase + lDelta * pgData->ptDraw.y;

    LONG     dxRed   = pgData->dRdX;
    LONG     dxGreen = pgData->dGdX;
    LONG     dxBlue  = pgData->dBdX;

    LONG     dyRed   = pgData->dRdY;
    LONG     dyGreen = pgData->dGdY;
    LONG     dyBlue  = pgData->dBdY;

    ULONG    eRed;
    ULONG    eGreen;
    ULONG    eBlue;

    PBYTE    pDitherMatrix;
    PBYTE    pSaturationTable;
    PBYTE    pxlate = pDibInfo->pxlate332;

    //
    // either use default palette or halftone palette dither
    //

    if (pxlate == NULL)
    {
        WARNING("Failed to generate rgb333 xlate table\n");
        return;
    }

    if (pxlate == gHalftoneColorXlate332)
    {
        pDitherMatrix    = gDitherMatrix16x16Halftone;
        pSaturationTable = HalftoneSaturationTable;
    }
    else
    {
        pDitherMatrix    = gDitherMatrix16x16Default;
        pSaturationTable = DefaultSaturationTable;
    }

    //
    // skip down to left edge
    //

    eRed   = pgData->Red;
    eGreen = pgData->Green;
    eBlue  = pgData->Blue;

    if (pgData->yScanAdjust)
    {
        eRed   += dyRed   * (pgData->yScanAdjust);
        eGreen += dyGreen * (pgData->yScanAdjust);
        eBlue  += dyBlue  * (pgData->yScanAdjust);
    }

    LONG    yDitherOrg = pgData->ptDitherOrg.y;
    LONG    xDitherOrg = pgData->ptDitherOrg.x;

    while(yScan < yScanBottom)
    {
        PBYTE   pjDstX;
        PBYTE   pjDstScanRight,pjDstScanLeft;
        LONG    xScanRight;
        ULONG   Red;
        ULONG   Green;
        ULONG   Blue;

        Red   = eRed;
        Green = eGreen;
        Blue  = eBlue;

        if (pgData->xScanAdjust)
        {
            Red   += dxRed   * (pgData->xScanAdjust);
            Green += dxGreen * (pgData->xScanAdjust);
            Blue  += dxBlue  * (pgData->xScanAdjust);
        }

        pjDstX         = pDst + pgData->ptDraw.x;
        pjDstScanRight = pjDstX + cxClip;

        PBYTE pDitherLevel = &pDitherMatrix[(16 * ((yScan+yDitherOrg) & DITHER_8_MASK_Y))];

        while (pjDstX < pjDstScanRight)
        {
            //
            // calculate x component of dither
            //

            ULONG   iRed   = (ULONG)(Red   >> 16);
            ULONG   iGreen = (ULONG)(Green >> 16);
            ULONG   iBlue  = (ULONG)(Blue  >> 16);

            BYTE jDitherMatrix = *(pDitherLevel + (((ULONG)pjDstX + xDitherOrg) & DITHER_8_MASK_X));

            iRed   = pSaturationTable[iRed   + jDitherMatrix];
            iGreen = pSaturationTable[iGreen + jDitherMatrix];
            iBlue  = pSaturationTable[iBlue  + jDitherMatrix];

            BYTE  jIndex;

            GRAD_PALETTE_MATCH(jIndex,pxlate,((BYTE)iRed),((BYTE)iGreen),((BYTE)iBlue));

            *pjDstX = jIndex;

            pjDstX++;
            Red   += dxRed;
            Green += dxGreen;
            Blue  += dxBlue;
        }

        pDst += lDelta;

        //
        // add y color increment
        //

        eRed   += dyRed;
        eGreen += dyGreen;
        eBlue  += dyBlue;
        yScan++;
    }
}

/******************************Public*Routine******************************\
* vFillGRectDIB4
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    11/21/1996 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vFillGRectDIB4(
    PDIBINFO          pDibInfo,
    PGRADIENTRECTDATA pgData
    )
{
    LONG     lDelta = pDibInfo->stride;
    PBYTE    pDst   = (PBYTE)pDibInfo->pvBase + lDelta * pgData->ptDraw.y;
    LONG     cxClip = pgData->szDraw.cx;
    LONG     cyClip = pgData->szDraw.cy;

    LONG     yScan       = pgData->ptDraw.y;
    LONG     yScanBottom = yScan + cyClip;

    LONG     dxRed   = pgData->dRdX;
    LONG     dxGreen = pgData->dGdX;
    LONG     dxBlue  = pgData->dBdX;

    LONG     dyRed   = pgData->dRdY;
    LONG     dyGreen = pgData->dGdY;
    LONG     dyBlue  = pgData->dBdY;

    ULONG    eRed;
    ULONG    eGreen;
    ULONG    eBlue;
    PBYTE    pxlate           = pDibInfo->pxlate332;
    PBYTE    pDitherMatrix    = gDitherMatrix16x16Default;
    PBYTE    pSaturationTable = DefaultSaturationTable;

    //
    // get/build rgb555 to palette table
    //

    if (pxlate == NULL)
    {
        WARNING("Failed to generate rgb333 xlate table\n");
        return;
    }

    //
    // skip down to left edge
    //

    eRed   = pgData->Red;
    eGreen = pgData->Green;
    eBlue  = pgData->Blue;

    if (pgData->yScanAdjust)
    {
        eRed   += dyRed   * (pgData->yScanAdjust);
        eGreen += dyGreen * (pgData->yScanAdjust);
        eBlue  += dyBlue  * (pgData->yScanAdjust);
    }

    LONG    yDitherOrg = pgData->ptDitherOrg.y;
    LONG    xDitherOrg = pgData->ptDitherOrg.x;

    while(yScan < yScanBottom)
    {
        PBYTE   pjDstX;
        LONG    ixDst;

        LONG    cx = cxClip;
        LONG    xScanRight;
        ULONG   Red;
        ULONG   Green;
        ULONG   Blue;

        Red   = eRed;
        Green = eGreen;
        Blue  = eBlue;

        PBYTE pDitherLevel = &pDitherMatrix[(16 * ((yScan+yDitherOrg) & DITHER_8_MASK_Y))];

        if (pgData->xScanAdjust)
        {
            Red   += dxRed   * (pgData->xScanAdjust);
            Green += dxGreen * (pgData->xScanAdjust);
            Blue  += dxBlue  * (pgData->xScanAdjust);
        }

        pjDstX         = pDst + pgData->ptDraw.x/2;
        ixDst          = pgData->ptDraw.x;


        while (cx--)
        {
            //
            // offset into dither array
            //

            BYTE jDitherMatrix = *(pDitherLevel + ((ixDst+xDitherOrg) & DITHER_8_MASK_X));

            ULONG   iRed   = (ULONG)(Red   >> 16);
            ULONG   iGreen = (ULONG)(Green >> 16);
            ULONG   iBlue  = (ULONG)(Blue  >> 16);

            iRed   = pSaturationTable[iRed   + jDitherMatrix];
            iGreen = pSaturationTable[iGreen + jDitherMatrix];
            iBlue  = pSaturationTable[iBlue  + jDitherMatrix];

            BYTE  jIndex;

            GRAD_PALETTE_MATCH(jIndex,pxlate,((BYTE)iRed),((BYTE)iGreen),((BYTE)iBlue));

            if (ixDst & 1)
            {
                *pjDstX = (*pjDstX & 0xf0) | jIndex;
                pjDstX++;
            }
            else
            {
                *pjDstX = (*pjDstX & 0x0f) | (jIndex << 4);
            }

            ixDst++;

            Red   += dxRed;
            Green += dxGreen;
            Blue  += dxBlue;
        }

        pDst += lDelta;

        //
        // add y color increment
        //

        eRed   += dyRed;
        eGreen += dyGreen;
        eBlue  += dyBlue;
        yScan++;
    }
}

/******************************Public*Routine******************************\
* vFillGRectDIB1
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    11/21/1996 Mark Enstrom [marke]
*
\**************************************************************************/
VOID
vFillGRectDIB1(
    PDIBINFO          pDibInfo,
    PGRADIENTRECTDATA pgData
    )
{
    LONG     lDelta = pDibInfo->stride;
    LONG     cxClip = pgData->szDraw.cx;
    LONG     cyClip = pgData->szDraw.cy;
    PBYTE    pDst   = (PBYTE)pDibInfo->pvBase + lDelta * pgData->ptDraw.y;
    LONG     yScan  = pgData->ptDraw.y;
    LONG     yScanBottom = yScan + cyClip;

    LONG     dxRed   = pgData->dRdX;
    LONG     dxGreen = pgData->dGdX;
    LONG     dxBlue  = pgData->dBdX;

    LONG     dyRed   = pgData->dRdY;
    LONG     dyGreen = pgData->dGdY;
    LONG     dyBlue  = pgData->dBdY;

    ULONG    eRed;
    ULONG    eGreen;
    ULONG    eBlue;
    PBYTE    pxlate = pDibInfo->pxlate332;
    PBYTE    pDitherMatrix = gDitherMatrix16x16Default;

    //
    // get/build rgb555 to palette table
    //

    if (pxlate == NULL)
    {
        WARNING("Failed to generate rgb555 xlate table\n");
        return;
    }

    //
    // skip down to left edge
    //

    eRed   = pgData->Red;
    eGreen = pgData->Green;
    eBlue  = pgData->Blue;

    if (pgData->yScanAdjust)
    {
        eRed   += dyRed   * (pgData->yScanAdjust);
        eGreen += dyGreen * (pgData->yScanAdjust);
        eBlue  += dyBlue  * (pgData->yScanAdjust);
    }

    LONG    yDitherOrg = pgData->ptDitherOrg.y;
    LONG    xDitherOrg = pgData->ptDitherOrg.x;

    while(yScan < yScanBottom)
    {
        PBYTE   pjDstX;
        LONG    ixDst;

        LONG    cx = cxClip;
        LONG    xScanLeft  = pgData->ptDraw.x;
        LONG    xScanRight = xScanLeft + cx;
        ULONG   Red;
        ULONG   Green;
        ULONG   Blue;

        Red   = eRed;
        Green = eGreen;
        Blue  = eBlue;

        PBYTE pDitherLevel = &pDitherMatrix[(16 * ((yScan+yDitherOrg) & DITHER_8_MASK_Y))];

        if (pgData->xScanAdjust)
        {
            Red   += dxRed   * (pgData->xScanAdjust);
            Green += dxGreen * (pgData->xScanAdjust);
            Blue  += dxBlue  * (pgData->xScanAdjust);
        }

        pjDstX         = pDst + pgData->ptDraw.x/8;
        ixDst          = pgData->ptDraw.x & 7;

        while (xScanLeft < xScanRight)
        {
            //
            // offset into dither array
            //

            BYTE jDitherMatrix = 2 * (*(pDitherLevel + ((xScanLeft+xDitherOrg) & DITHER_8_MASK_X)));

            ULONG   iRed   = (ULONG)(Red   >> 16);
            ULONG   iGreen = (ULONG)(Green >> 16);
            ULONG   iBlue  = (ULONG)(Blue  >> 16);

            //
            // add dither and saturate. 1bpp non-optimized
            //

            iRed   = iRed   + jDitherMatrix;

            if (iRed >= 255)
            {
                iRed = 255;
            }
            else
            {
                iRed = 0;
            }

            iGreen = iGreen + jDitherMatrix;

            if (iGreen >= 255)
            {
                iGreen = 255;
            }
            else
            {
                iGreen = 0;
            }

            iBlue  = iBlue  + jDitherMatrix;

            if (iBlue >= 255)
            {
                iBlue = 255;
            }
            else
            {
                iBlue = 0;
            }

            BYTE  jIndex;

            //
            // pjVector is known to be identity, so could make new macro for
            // palette_match_1 if perf ever an issue
            //

            GRAD_PALETTE_MATCH(jIndex,pxlate,((BYTE)iRed),((BYTE)iGreen),((BYTE)iBlue));

            LONG iShift  = 7 - ixDst;
            BYTE OrMask = 1 << iShift;
            BYTE AndMask  = ~OrMask;

            jIndex = jIndex << iShift;

            *pjDstX = (*pjDstX & AndMask) | jIndex;

            ixDst++;

            if (ixDst == 8)
            {
                ixDst = 0;
                pjDstX++;
            }

            Red   += dxRed;
            Green += dxGreen;
            Blue  += dxBlue;
            xScanLeft++;
        }

        pDst += lDelta;

        //
        // add y color increment
        //

        eRed   += dyRed;
        eGreen += dyGreen;
        eBlue  += dyBlue;
        yScan++;
    }
}


/******************************Public*Routine******************************\
* pfnGradientRectFillFunction
*
*   look at format to decide if DIBSection should be drawn directly
*
*    32 bpp RGB
*    32 bpp BGR
*    24 bpp
*    16 bpp 565
*    16 bpp 555
*
* Trangles are only filled in high color (no palette) surfaces
*
* Arguments:
*
*   pDibInfo - information about destination surface
*
* Return Value:
*
*   PFN_GRADRECT - triangle filling routine
*
* History:
*
*    12/6/1996 Mark Enstrom [marke]
*
\**************************************************************************/

PFN_GRADRECT
pfnGradientRectFillFunction(
    PDIBINFO pDibInfo
    )
{
    PFN_GRADRECT pfnRet = NULL;

    PULONG pulMasks = (PULONG)&pDibInfo->pbmi->bmiColors[0];

    //
    // 32 bpp RGB
    //

    if (
         (pDibInfo->pbmi->bmiHeader.biBitCount    == 32) &&
         (pDibInfo->pbmi->bmiHeader.biCompression == BI_RGB)
       )
    {
        pfnRet = vFillGRectDIB32BGRA;
    }

    else if (
         (pDibInfo->pbmi->bmiHeader.biBitCount    == 32) &&
         (pDibInfo->pbmi->bmiHeader.biCompression == BI_BITFIELDS) &&
         (pulMasks[0]   == 0xff0000)           &&
         (pulMasks[1]   == 0x00ff00)           &&
         (pulMasks[2]   == 0x0000ff)
       )
    {
        pfnRet = vFillGRectDIB32BGRA;
    }

    else if (
         (pDibInfo->pbmi->bmiHeader.biBitCount    == 32) &&
         (pDibInfo->pbmi->bmiHeader.biCompression == BI_BITFIELDS) &&
         (pulMasks[0]   == 0x0000ff)           &&
         (pulMasks[1]   == 0x00ff00)           &&
         (pulMasks[2]   == 0xff0000)
       )
    {
        pfnRet = vFillGRectDIB32RGB;
    }

    else if (
         (pDibInfo->pbmi->bmiHeader.biBitCount    == 24) &&
         (pDibInfo->pbmi->bmiHeader.biCompression == BI_RGB)
       )
    {
        pfnRet = vFillGRectDIB24RGB;
    }

    //
    // 16 BPP
    //

    else if (
         (pDibInfo->pbmi->bmiHeader.biBitCount    == 16) &&
         (pDibInfo->pbmi->bmiHeader.biCompression == BI_BITFIELDS)
       )
    {

        //
        // 565,555
        //

        if (
             (pulMasks[0]   == 0xf800)           &&
             (pulMasks[1]   == 0x07e0)           &&
             (pulMasks[2]   == 0x001f)
           )
        {
            pfnRet = vFillGRectDIB16_565;
        }
        else if (
            (pulMasks[0]   == 0x7c00)           &&
            (pulMasks[1]   == 0x03e0)           &&
            (pulMasks[2]   == 0x001f)
          )
       {
           pfnRet = vFillGRectDIB16_555;
       }
    }
    else if (
         (pDibInfo->pbmi->bmiHeader.biBitCount    == 8)
       )
    {
        pfnRet = vFillGRectDIB8;
    }
    else if (
         (pDibInfo->pbmi->bmiHeader.biBitCount    == 4)
       )
    {
        pfnRet = vFillGRectDIB4;
    }
    else if (
         (pDibInfo->pbmi->bmiHeader.biBitCount    == 1)
       )
    {
        pfnRet = vFillGRectDIB1;
    }

    return(pfnRet);
}


/**************************************************************************\
* DIBGradientRect
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    2/11/1997 Mark Enstrom [marke]
*
\**************************************************************************/

BOOL
DIBGradientRect(
    HDC            hdc,
    PTRIVERTEX     pVertex,
    ULONG          nVertex,
    PGRADIENT_RECT pMesh,
    ULONG          nMesh,
    ULONG          ulMode,
    PRECTL         prclPhysExt,
    PDIBINFO       pDibInfo,
    PPOINTL        pptlDitherOrg
    )
{
    BOOL          bStatus = TRUE;
    PFN_GRADRECT  pfnGradRect = NULL;
    ULONG         ulIndex;

    pfnGradRect = pfnGradientRectFillFunction(pDibInfo);

    if (pfnGradRect == NULL)
    {
        WARNING("DIBGradientRect:Can't draw to surface\n");
        return(TRUE);
    }

    //
    // work in physical map mode, restore before return
    //

    ULONG OldMode = SetMapMode(hdc,MM_TEXT);

    //
    // fake up scale !!!
    //

    for (ulIndex=0;ulIndex<nVertex;ulIndex++)
    {
        pVertex[ulIndex].x = pVertex[ulIndex].x * 16;
        pVertex[ulIndex].y = pVertex[ulIndex].y * 16;
    }

    //
    // limit rectangle output to clipped output
    //

    LONG dxRect = prclPhysExt->right  - prclPhysExt->left;
    LONG dyRect = prclPhysExt->bottom - prclPhysExt->top;

    //
    // check for clipped out
    //

    if ((dyRect > 0) && (dxRect > 0))
    {
        GRADIENTRECTDATA grData;

        //
        // clip output
        //

        grData.rclClip = *prclPhysExt;
        grData.ptDitherOrg = *pptlDitherOrg;

        for (ulIndex=0;ulIndex<nMesh;ulIndex++)
        {
            ULONG ulRect0 = pMesh[ulIndex].UpperLeft;
            ULONG ulRect1 = pMesh[ulIndex].LowerRight;

            //
            // make sure index are in array
            //

            if (
                 (ulRect0 > nVertex) ||
                 (ulRect1 > nVertex)
               )
            {
                bStatus = FALSE;
                break;
            }

            TRIVERTEX  tvert0 = pVertex[ulRect0];
            TRIVERTEX  tvert1 = pVertex[ulRect1];
            PTRIVERTEX pv0 = &tvert0;
            PTRIVERTEX pv1 = &tvert1;
            PTRIVERTEX pvt;

            //
            // make sure rectangle endpoints are properly ordered
            //

            if (ulMode & GRADIENT_FILL_RECT_H)
            {
                if (pv0->x > pv1->x)
                {
                    SWAP_VERTEX(pv0,pv1,pvt);
                }

                if (pv0->y > pv1->y)
                {
                    //
                    // must swap y
                    //

                    LONG ltemp = pv1->y;
                    pv1->y = pv0->y;
                    pv0->y = ltemp;

                }
            }
            else
            {
                if (pv0->y > pv1->y)
                {
                    SWAP_VERTEX(pv0,pv1,pvt);
                }


                if (pv0->x > pv1->x)
                {
                    //
                    // must swap x
                    //

                    LONG ltemp = pv1->x;
                    pv1->x = pv0->x;
                    pv0->x = ltemp;
                }
            }

            //
            // gradient definition rectangle
            //

            grData.rclGradient.left   = pv0->x >> 4;
            grData.rclGradient.top    = pv0->y >> 4;

            grData.rclGradient.right  = pv1->x >> 4;
            grData.rclGradient.bottom = pv1->y >> 4;

            LONG dxGrad = grData.rclGradient.right  - grData.rclGradient.left;
            LONG dyGrad = grData.rclGradient.bottom - grData.rclGradient.top;

            //
            // make sure this is not an empty rectangle
            //

            if ((dxGrad > 0) && (dyGrad > 0))
            {
                grData.ulMode  = ulMode;

                //
                // calculate color gradients for x and y
                //

                grData.Red   = pv0->Red   << 8;
                grData.Green = pv0->Green << 8;
                grData.Blue  = pv0->Blue  << 8;
                grData.Alpha = pv0->Alpha << 8;

                if (ulMode & GRADIENT_FILL_RECT_H)
                {

                    grData.dRdY = 0;
                    grData.dGdY = 0;
                    grData.dBdY = 0;
                    grData.dAdY = 0;

                    LONG dRed   = (pv1->Red   << 8) - (pv0->Red   << 8);
                    LONG dGreen = (pv1->Green << 8) - (pv0->Green << 8);
                    LONG dBlue  = (pv1->Blue  << 8) - (pv0->Blue  << 8);
                    LONG dAlpha = (pv1->Alpha << 8) - (pv0->Alpha << 8);

                    grData.dRdX = dRed   / dxGrad;
                    grData.dGdX = dGreen / dxGrad;
                    grData.dBdX = dBlue  / dxGrad;
                    grData.dAdX = dAlpha / dxGrad;
                }
                else
                {

                    grData.dRdX = 0;
                    grData.dGdX = 0;
                    grData.dBdX = 0;
                    grData.dAdX = 0;

                    LONG dRed   = (pv1->Red   << 8) - (pv0->Red   << 8);
                    LONG dGreen = (pv1->Green << 8) - (pv0->Green << 8);
                    LONG dBlue  = (pv1->Blue  << 8) - (pv0->Blue  << 8);
                    LONG dAlpha = (pv1->Alpha << 8) - (pv0->Alpha << 8);

                    grData.dRdY = dRed   / dyGrad;
                    grData.dGdY = dGreen / dyGrad;
                    grData.dBdY = dBlue  / dyGrad;
                    grData.dAdY = dAlpha / dyGrad;
                }

                //
                // calculate common offsets
                //

                if (bCalcGradientRectOffsets(&grData))
                {
                    //
                    // call specific drawing routine if output
                    // not totally clipped
                    //

                    (*pfnGradRect)(pDibInfo,&grData);
                }
            }

        }
    }

    SetMapMode(hdc,OldMode);

    return(bStatus);
}

#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\image\tmp\tran.cxx ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name


Abstract:

   Lingyun Wang

Author:


Enviornment:

   User Mode

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

extern PFNTRANSBLT gpfnTransparentBlt;
extern PFNTRANSDIB gpfnTransparentDIBits;

#if (_WIN32_WINNT == 0x400)
typedef struct _LOGPALETTE2
{
    USHORT PalVersion;
    USHORT PalNumEntries;
    PALETTEENTRY palPalEntry[2];
} LOGPALETTE2;

typedef struct _LOGPALETTE16
{
    USHORT PalVersion;
    USHORT PalNumEntries;
    PALETTEENTRY palPalEntry[16];
} LOGPALETTE16;

typedef struct _LOGPALETTE256
{
    USHORT PalVersion;
    USHORT PalNumEntries;
    PALETTEENTRY palPalEntry[256];
} LOGPALETTE256;

/******************************Public*Routine******************************\
* StartPixel
*    Give a scanline pointer and position of a pixel, return the byte address
* of where the pixel is at depending on the format
*
* History:
*  2-Dec-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
PBYTE StartPixel (
    PBYTE pjBits,
    ULONG xStart,
    ULONG iBitmapFormat
)
{
   PBYTE pjStart = pjBits;
    //
    // getting the starting pixel
    //
    switch (iBitmapFormat)
    {
      case 1:
          pjStart = pjBits + (xStart >> 3);
          break;

       case 4:
          pjStart = pjBits + (xStart >> 1);
          break;

       case 8:
          pjStart = pjBits + xStart;
          break;

       case 16:
          pjStart = pjBits + 2*xStart;
          break;

       case 24:
          pjStart = pjBits + 3*xStart;
          break;

       case 32:
          pjStart = pjBits+4*xStart;
          break;

       default:
           WARNING ("Startpixel -- bad iFormatSrc\n");
    }

    return (pjStart);
}


/******************************Public*Routine******************************\
* vTransparentIdentityCopy4
*
* Doing a transparent copy on two same size 4BPP format DIBs
*
* Returns:
*   VOID.
*
* History:
*  09-Dec-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
VOID vTransparentIdentityCopy4 (
     PDIBINFO pDibInfoDst,
     PDIBINFO pDibInfoSrc,
     ULONG   TransColor)
{
     PBYTE   pjDst = (PBYTE)pDibInfoDst->pvBase + pDibInfoDst->stride*pDibInfoDst->rclDIB.top
                            + (pDibInfoDst->rclDIB.left >> 1);
     PBYTE   pjSrc = (PBYTE)pDibInfoSrc->pvBase + pDibInfoSrc->stride*pDibInfoSrc->rclDIB.top
                            + (pDibInfoSrc->rclDIB.left >> 1);
     LONG    cx = pDibInfoDst->rclDIB.right - pDibInfoDst->rclDIB.left;
     LONG    cy = pDibInfoDst->rclDIB.bottom - pDibInfoDst->rclDIB.top;

     PBYTE   pjDstTemp;
     PBYTE   pjSrcTemp;
     LONG    cxTemp;

     BYTE   jSrc=0;
     BYTE   jDst=0;
     LONG   iSrc, iDst;


     while(cy--)
     {
         cxTemp = cx;

         iSrc = pDibInfoSrc->rclDIB.left;
         iDst = pDibInfoDst->rclDIB.left;

         pjSrcTemp = pjSrc;
         pjDstTemp = pjDst;

         while (cxTemp--)
         {
             if (iSrc & 0x00000001)
             {
                 jSrc = *pjSrcTemp & 0x0F;
                 pjSrcTemp++;
             }
             else
             {
                 jSrc = (*pjSrcTemp & 0xF0)>>4;
             }

             iSrc++;

             if (iDst & 0x00000001)
             {
                 if (jSrc != (BYTE)TransColor)
                 {
                     jDst |= jSrc & 0x0F;
                 }
                 else
                 {
                     jDst |= *pjDstTemp & 0x0F;
                 }

                 *pjDstTemp++ = jDst;
                 jDst = 0;
             }
             else
             {
                 if (jSrc != (BYTE)TransColor)
                 {
                     jDst |= (jSrc << 4);
                 }
                 else
                 {
                     jDst |= *pjDstTemp & 0xF0;
                 }
             }

             iDst++;
         }
         pjDst += pDibInfoDst->stride;
         pjSrc += pDibInfoSrc->stride;
     }
}

/******************************Public*Routine******************************\
* vTransparentS4D1
*
* Doing a transparent copy from 4PP to 1BPP
*
* Returns:
*   VOID.
*
* History:
*  09-Dec-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
VOID vTransparentS4D1 (
     PDIBINFO pDibInfoDst,
     PDIBINFO pDibInfoSrc,
     ULONG   TransColor)
{
     PBYTE   pjDst = (PBYTE)pDibInfoDst->pvBase + pDibInfoDst->stride*pDibInfoDst->rclDIB.top
                            + (pDibInfoDst->rclDIB.left >> 3);

     PBYTE   pjSrc = (PBYTE)pDibInfoSrc->pvBase + pDibInfoSrc->stride*pDibInfoSrc->rclDIB.top
                            + (pDibInfoSrc->rclDIB.left >> 1);
     LONG    cx = pDibInfoDst->rclDIB.right - pDibInfoDst->rclDIB.left;
     LONG    cy = pDibInfoDst->rclDIB.bottom - pDibInfoDst->rclDIB.top;
     PBYTE   pjDstTemp;
     PBYTE   pjSrcTemp;
     BYTE    jSrc, jDst;
     LONG    cxTemp;
     BYTE    rgbBlue, rgbGreen, rgbRed;
     LONG    iSrc, iDst;
     LOGPALETTE2 logPal2;
     HPALETTE    hPal;
     LONG    i;
     ULONG   rgbColor;
     BYTE    xlate[16];

     //
     // build up our xlate table
     //
     logPal2.PalVersion    = 0x300;
     logPal2.PalNumEntries = 2;

     for (i = 0; i < 2; i++)
     {
         logPal2.palPalEntry[i].peRed         = pDibInfoDst->pbmi->bmiColors[i].rgbRed;
         logPal2.palPalEntry[i].peGreen       = pDibInfoDst->pbmi->bmiColors[i].rgbGreen;
         logPal2.palPalEntry[i].peBlue        = pDibInfoDst->pbmi->bmiColors[i].rgbBlue;
         logPal2.palPalEntry[i].peFlags       = 0;
     }

     hPal = CreatePalette ((LOGPALETTE *)&logPal2);

     for (i = 0; i<16; i++)
     {
         rgbColor = RGB(pDibInfoSrc->pbmi->bmiColors[i].rgbRed, pDibInfoSrc->pbmi->bmiColors[i].rgbGreen,
                        pDibInfoSrc->pbmi->bmiColors[i].rgbBlue);

         xlate[i] = (BYTE)GetNearestPaletteIndex(hPal, rgbColor);
     }

     while(cy--)
     {
         cxTemp = cx;

         iSrc = pDibInfoSrc->rclDIB.left;
         iDst = pDibInfoDst->rclDIB.left & 0x07;

         pjDstTemp = pjDst;

         jDst = *pjDstTemp >> (8 - iDst);

         pjSrcTemp = pjSrc;

         while (cxTemp--)
         {
             if (iSrc & 0x00000001)
             {
                 jSrc = *pjSrcTemp & 0x0F;
                 pjSrcTemp++;
             }
             else
             {
                 jSrc = (*pjSrcTemp & 0xF0)>>4;
             }

             iSrc++;

             //
             // put one pixel in the dest
             //
             if (jSrc != TransColor)
             {
                jDst |= xlate[jSrc];  //0 OR 1
             }
             else
             {
                jDst |= 1-xlate[jSrc];
             }

             jDst <<1;
             iDst++;

             if (!(iDst & 0x07))
             {
                *(pjDstTemp++) = jDst;
                jDst = 0;
             }
          }

          if (iDst & 0x00000007)
          {
            // We need to build up the last pel correctly.

            BYTE jMask = (BYTE) (0x000000FF >> (iDst & 0x00000007));

            jDst = (BYTE) (jDst << (8 - (iDst & 0x00000007)));

	         *pjDstTemp = (BYTE) ((*pjDstTemp & jMask) | (jDst & ~jMask));
           }

           pjDst += pDibInfoDst->stride;
           pjSrc += pDibInfoSrc->stride;
     }
}

/******************************Public*Routine******************************\
* vTransparentS4D4
*
* Doing a transparent copy from 4PP to 4bpp non identity
*
* Returns:
*   VOID.
*
* History:
*  09-Dec-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
VOID vTransparentS4D4 (
     PDIBINFO pDibInfoDst,
     PDIBINFO pDibInfoSrc,
     ULONG   TransColor)
{
     PBYTE   pjDst = (PBYTE)pDibInfoDst->pvBase + pDibInfoDst->stride*pDibInfoDst->rclDIB.top
                            + (pDibInfoDst->rclDIB.left >> 1);
     PBYTE   pjSrc = (PBYTE)pDibInfoSrc->pvBase + pDibInfoSrc->stride*pDibInfoSrc->rclDIB.top
                            + (pDibInfoSrc->rclDIB.left >> 1);

     LONG    cx = pDibInfoDst->rclDIB.right - pDibInfoDst->rclDIB.left;
     LONG    cy = pDibInfoDst->rclDIB.bottom - pDibInfoDst->rclDIB.top;
     PBYTE   pjDstTemp;
     PBYTE   pjSrcTemp;
     BYTE    jSrc, jDst;
     BYTE    rgbBlue, rgbGreen, rgbRed;
     LONG    iSrc, iDst;
     LOGPALETTE16 logPal16;
     HPALETTE    hPal;
     LONG    i;
     ULONG   cxTemp;
     ULONG   rgbColor;
     BYTE    xlate[16];

     //
     // build up translate table
     //
     logPal16.PalVersion    = 0x300;
     logPal16.PalNumEntries = 16;

     for (i = 0; i < 16; i++)
     {
         logPal16.palPalEntry[i].peRed         = pDibInfoDst->pbmi->bmiColors[i].rgbRed;
         logPal16.palPalEntry[i].peGreen       = pDibInfoDst->pbmi->bmiColors[i].rgbGreen;
         logPal16.palPalEntry[i].peBlue        = pDibInfoDst->pbmi->bmiColors[i].rgbBlue;
         logPal16.palPalEntry[i].peFlags       = 0;
     }

     hPal = CreatePalette ((LOGPALETTE *)&logPal16);

     for (i = 0; i<16; i++)
     {
         rgbColor = RGB(pDibInfoSrc->pbmi->bmiColors[i].rgbRed, pDibInfoSrc->pbmi->bmiColors[i].rgbGreen,
                        pDibInfoSrc->pbmi->bmiColors[i].rgbBlue);

         xlate[i] = (BYTE)GetNearestPaletteIndex(hPal, rgbColor);
     }

     while(cy--)
     {
         cxTemp = cx;

         iSrc = pDibInfoSrc->rclDIB.left;
         iDst = pDibInfoDst->rclDIB.left;

         pjDstTemp = pjDst;
         pjSrcTemp = pjSrc;

         while (cxTemp--)
         {
             if (iSrc & 0x00000001)
             {
                 jSrc = *pjSrcTemp & 0x0F;
                 pjSrcTemp++;
             }
             else
             {
                 jSrc = (*pjSrcTemp & 0xF0)>>4;
             }

             iSrc++;

             if (iDst & 0x00000001)
             {
                 if (jSrc != (BYTE)TransColor)
                 {
                     jDst |= xlate[jSrc] & 0x0F;
                 }
                 else
                 {
                     jDst |= *pjDstTemp & 0x0F;
                 }

                 *pjDstTemp++ = jDst;
                 jDst = 0;
             }
             else
             {
                 if (jSrc != (BYTE)TransColor)
                 {
                     jDst |= (xlate[jSrc] << 4);
                 }
                 else
                 {
                     jDst |= *pjDstTemp & 0xF0;
                 }
             }

             iDst++;
         }

         pjDst += pDibInfoDst->stride;
         pjSrc += pDibInfoSrc->stride;
     }
}

/******************************Public*Routine******************************\
* vTransparentS4D8
*
* Doing a transparent copy from 4PP to 8bpp
*
* Returns:
*   VOID.
*
* History:
*  09-Dec-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
VOID vTransparentS4D8 (
     PDIBINFO pDibInfoDst,
     PDIBINFO pDibInfoSrc,
     ULONG   TransColor)
{
     PBYTE   pjDst = (PBYTE)pDibInfoDst->pvBase + pDibInfoDst->stride*pDibInfoDst->rclDIB.top;
                            + pDibInfoDst->rclDIB.left;
     PBYTE   pjSrc = (PBYTE)pDibInfoSrc->pvBase + pDibInfoSrc->stride*pDibInfoSrc->rclDIB.top
                            + (pDibInfoSrc->rclDIB.left >> 1);
     LONG    cx = pDibInfoDst->rclDIB.right - pDibInfoDst->rclDIB.left;
     LONG    cy = pDibInfoDst->rclDIB.bottom - pDibInfoDst->rclDIB.top;
     PBYTE   pjDstTemp;
     PBYTE   pjSrcTemp;
     BYTE    jSrc;
     LONG    cxTemp;
     BYTE    rgbBlue, rgbGreen, rgbRed;
     LONG    iSrc;
     LOGPALETTE256 logPal256;
     HPALETTE    hPal;
     LONG    i;
     ULONG   rgbColor;
     BYTE    xlate[16];

     logPal256.PalVersion    = 0x300;
     logPal256.PalNumEntries = 256;

     for (i = 0; i < 256; i++)
     {
         logPal256.palPalEntry[i].peRed         = pDibInfoDst->pbmi->bmiColors[i].rgbRed;
         logPal256.palPalEntry[i].peGreen       = pDibInfoDst->pbmi->bmiColors[i].rgbGreen;
         logPal256.palPalEntry[i].peBlue        = pDibInfoDst->pbmi->bmiColors[i].rgbBlue;
         logPal256.palPalEntry[i].peFlags       = 0;
     }

     hPal = CreatePalette ((LOGPALETTE *)&logPal256);

     for (i = 0; i<16; i++)
     {
         rgbColor = RGB(pDibInfoSrc->pbmi->bmiColors[i].rgbRed, pDibInfoSrc->pbmi->bmiColors[i].rgbGreen,
                        pDibInfoSrc->pbmi->bmiColors[i].rgbBlue);

         xlate[i] = (BYTE)GetNearestPaletteIndex(hPal, rgbColor);

         //Dprintf("i=%x, rgbColor = 0x%08x, xlate[i] = %x", i, rgbColor, xlate[i]);
     }

     while(cy--)
     {
         cxTemp = cx;

         iSrc = pDibInfoSrc->rclDIB.left;

         pjDstTemp = pjDst;
         pjSrcTemp = pjSrc;

         while (cxTemp--)
         {
             if (iSrc & 0x00000001)
             {
                 jSrc = *pjSrcTemp & 0x0F;
                 pjSrcTemp++;
             }
             else
             {
                 jSrc = (*pjSrcTemp & 0xF0)>>4;
             }

             iSrc++;

             if (jSrc != (BYTE)TransColor)
             {
                 *pjDstTemp = xlate[jSrc];
             }

             pjDstTemp++;
         }

         pjDst += pDibInfoDst->stride;
         pjSrc += pDibInfoSrc->stride;
     }
}

/******************************Public*Routine******************************\
* vTransparentS4D16
*
* Doing a transparent copy from 4BPP to 16BPP
*
* Returns:
*   VOID.
*
* History:
*  09-Dec-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
VOID vTransparentS4D16 (
     PDIBINFO pDibInfoDst,
     PDIBINFO pDibInfoSrc,
     ULONG   TransColor)
{
     PBYTE   pjDst = (PBYTE)pDibInfoDst->pvBase + pDibInfoDst->stride*pDibInfoDst->rclDIB.top
                            + pDibInfoDst->rclDIB.left*2;
     PBYTE   pjSrc = (PBYTE)pDibInfoSrc->pvBase + pDibInfoSrc->stride*pDibInfoSrc->rclDIB.top
                            + (pDibInfoSrc->rclDIB.left >> 1);

     LONG    cx = pDibInfoDst->rclDIB.right - pDibInfoDst->rclDIB.left;
     LONG    cy = pDibInfoDst->rclDIB.bottom - pDibInfoDst->rclDIB.top;
     PBYTE   pjDstTemp;
     PBYTE   pjSrcTemp;
     BYTE    jSrc;
     LONG    cxTemp;
     BYTE    rgbBlue, rgbGreen, rgbRed;
     LONG    iSrc, iDst;

     while(cy--)
     {
         cxTemp = cx;

         iSrc = pDibInfoSrc->rclDIB.left;
         iDst = pDibInfoDst->rclDIB.left;

         pjDstTemp = pjDst;
         pjSrcTemp = pjSrc;

         while (cxTemp--)
         {
             if (iSrc & 0x00000001)
             {
                 jSrc = *pjSrcTemp & 0x0F;
                 pjSrcTemp++;
             }
             else
             {
                 jSrc = (*pjSrcTemp & 0xF0)>>4;
             }

             iSrc++;

             if (jSrc != (BYTE)TransColor)
             {
                 rgbBlue  = pDibInfoSrc->pbmi->bmiColors[jSrc].rgbBlue;
                 rgbGreen = pDibInfoSrc->pbmi->bmiColors[jSrc].rgbGreen;
                 rgbRed   = pDibInfoSrc->pbmi->bmiColors[jSrc].rgbRed;

                 //
                 // figure out 5-5-5 or 5-6-5
                 //
                 if (pDibInfoDst->pbmi->bmiHeader.biCompression == BI_BITFIELDS)
                 {
                      //5-5-5
                      if (*(DWORD *)&pDibInfoDst->pbmi->bmiColors[1] == 0x03E0)
                      {
                          *(PUSHORT)pjDstTemp = (USHORT)rgbBlue >> 3;
                          *(PUSHORT)pjDstTemp |= (USHORT)(rgbGreen >> 3) << 5;
                          *(PUSHORT)pjDstTemp |= (USHORT)(rgbRed >> 3) << 10;
                      }
                      // 5-6-5
                      else if (*(DWORD *)&pDibInfoDst->pbmi->bmiColors[1] == 0x07E0)
                      {
                          *(PUSHORT)pjDstTemp = (USHORT)rgbBlue >> 3;
                          *(PUSHORT)pjDstTemp |= (USHORT)(rgbGreen >> 2) << 5;
                          *(PUSHORT)pjDstTemp |= (USHORT)(rgbRed >> 3) << 11;
                      }
                      else
                      {
                          WARNING ("unsupported BITFIELDS\n");
                      }
                 }
                 else
                 {
                       *(PUSHORT)pjDstTemp = (USHORT)rgbBlue >> 3;
                       *(PUSHORT)pjDstTemp |= (USHORT)(rgbGreen >> 3) << 5;
                       *(PUSHORT)pjDstTemp |= (USHORT)(rgbRed >> 3) << 10;
                 }
             }

             pjDstTemp += 2;
         }

         pjDst += pDibInfoDst->stride;
         pjSrc += pDibInfoSrc->stride;
     }
}

/******************************Public*Routine******************************\
* vTransparentS4D24
*
* Doing a transparent copy from 4BPP to 24BPP
*
* Returns:
*   VOID.
*
* History:
*  09-Dec-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
VOID vTransparentS4D24 (
     PDIBINFO pDibInfoDst,
     PDIBINFO pDibInfoSrc,
     ULONG   TransColor)
{
     PBYTE   pjDst = (PBYTE)pDibInfoDst->pvBase + pDibInfoDst->stride*pDibInfoDst->rclDIB.top
                            + pDibInfoDst->rclDIB.left*3;
     PBYTE   pjSrc = (PBYTE)pDibInfoSrc->pvBase + pDibInfoSrc->stride*pDibInfoSrc->rclDIB.top
                            + (pDibInfoSrc->rclDIB.left >> 1);

     LONG    cx = pDibInfoDst->rclDIB.right - pDibInfoDst->rclDIB.left;
     LONG    cy = pDibInfoDst->rclDIB.bottom - pDibInfoDst->rclDIB.top;
     PBYTE   pjDstTemp;
     PBYTE   pjSrcTemp;
     LONG    cxTemp;
     BYTE    jSrc;
     LONG    iSrc, iDst;
     BYTE    rgbBlue, rgbGreen, rgbRed;

     while(cy--)
     {
         cxTemp = cx;

         pjDstTemp = pjDst;
         pjSrcTemp = pjSrc;

         iSrc = pDibInfoSrc->rclDIB.left;
         iDst = pDibInfoDst->rclDIB.left;

         while (cxTemp--)
         {
             if (iSrc & 0x00000001)
             {
                 jSrc = *pjSrcTemp & 0x0F;
                 pjSrcTemp++;
             }
             else
             {
                 jSrc = (*pjSrcTemp & 0xF0)>>4;
             }

             iSrc++;

             if (jSrc != (BYTE)TransColor)
             {
                 rgbBlue  = pDibInfoSrc->pbmi->bmiColors[jSrc].rgbBlue;
                 rgbGreen = pDibInfoSrc->pbmi->bmiColors[jSrc].rgbGreen;
                 rgbRed   = pDibInfoSrc->pbmi->bmiColors[jSrc].rgbRed;

                 *(pjDstTemp++) = (BYTE) rgbBlue;
                 *(pjDstTemp++) = (BYTE) rgbGreen;
                 *(pjDstTemp++) = (BYTE) rgbRed;
             }
             else
             {
                 pjDstTemp += 3;
             }
         }

         pjDst += pDibInfoDst->stride;
         pjSrc += pDibInfoSrc->stride;
     }
}

/******************************Public*Routine******************************\
* vTransparentS4D32
*
* Doing a transparent copy from 4BPP to 32BPP
*
* Returns:
*   VOID.
*
* History:
*  09-Dec-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
VOID vTransparentS4D32 (
     PDIBINFO pDibInfoDst,
     PDIBINFO pDibInfoSrc,
     ULONG   TransColor)
{
     PBYTE   pjDst = (PBYTE)pDibInfoDst->pvBase + pDibInfoDst->stride*pDibInfoDst->rclDIB.top
                            + pDibInfoDst->rclDIB.left*4;
     PBYTE   pjSrc = (PBYTE)pDibInfoSrc->pvBase + pDibInfoSrc->stride*pDibInfoSrc->rclDIB.top
                            + (pDibInfoSrc->rclDIB.left >> 1);

     LONG    cx = pDibInfoDst->rclDIB.right - pDibInfoDst->rclDIB.left;
     LONG    cy = pDibInfoDst->rclDIB.bottom - pDibInfoDst->rclDIB.top;
     PBYTE   pjDstTemp;
     PBYTE   pjSrcTemp;
     LONG    cxTemp;
     BYTE    jSrc;
     LONG    iSrc, iDst;
     BYTE    rgbBlue, rgbGreen, rgbRed;

     while(cy--)
     {
         cxTemp = cx;

         pjDstTemp = pjDst;
         pjSrcTemp = pjSrc;
         iSrc = pDibInfoSrc->rclDIB.left;
         iDst = pDibInfoDst->rclDIB.left;

         while (cxTemp--)
         {
             if (iSrc & 0x00000001)
             {
                 jSrc = *pjSrcTemp & 0x0F;
                 pjSrcTemp++;
             }
             else
             {
                 jSrc = (*pjSrcTemp & 0xF0)>>4;
             }

             iSrc++;

             if (jSrc != (BYTE)TransColor)
             {
                 rgbBlue  = pDibInfoSrc->pbmi->bmiColors[jSrc].rgbBlue;
                 rgbGreen = pDibInfoSrc->pbmi->bmiColors[jSrc].rgbGreen;
                 rgbRed   = pDibInfoSrc->pbmi->bmiColors[jSrc].rgbRed;

                 *(PULONG)pjDstTemp = (DWORD) (rgbBlue | (WORD)rgbGreen << 8 | (DWORD)rgbRed << 16);
             }
             pjDstTemp += 4;
         }

         pjDst += pDibInfoDst->stride;
         pjSrc += pDibInfoSrc->stride;
     }
}

/******************************Public*Routine******************************\
* vTransparentS8D16
*
* Doing a transparent copy from 8BPP to 16BPP
*
* Returns:
*   VOID.
*
* History:
*  09-Dec-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
VOID vTransparentS8D16 (
     PDIBINFO pDibInfoDst,
     PDIBINFO pDibInfoSrc,
     ULONG   TransColor)
{
     PBYTE   pjDst = (PBYTE)pDibInfoDst->pvBase + pDibInfoDst->stride*pDibInfoDst->rclDIB.top
                            +  pDibInfoDst->rclDIB.left*2;
     PBYTE   pjSrc = (PBYTE)pDibInfoSrc->pvBase + pDibInfoSrc->stride*pDibInfoSrc->rclDIB.top
                            + pDibInfoSrc->rclDIB.left;

     LONG    cx = pDibInfoDst->rclDIB.right - pDibInfoDst->rclDIB.left;
     LONG    cy = pDibInfoDst->rclDIB.bottom - pDibInfoDst->rclDIB.top;
     PBYTE   pjDstTemp;
     PBYTE   pjSrcTemp;
     BYTE    jSrc;
     LONG    cxTemp;
     BYTE    rgbBlue, rgbGreen, rgbRed;

     while(cy--)
     {
         cxTemp = cx;

         pjDstTemp = pjDst;
         pjSrcTemp = pjSrc;

         while (cxTemp--)
         {
             jSrc = *pjSrcTemp++;

            //
            // put one pixel in the dest
            //
            if (jSrc != (BYTE)TransColor)
            {
                 rgbBlue  = pDibInfoSrc->pbmi->bmiColors[jSrc].rgbBlue;
                 rgbGreen = pDibInfoSrc->pbmi->bmiColors[jSrc].rgbGreen;
                 rgbRed   = pDibInfoSrc->pbmi->bmiColors[jSrc].rgbRed;

                 //
                 // figure out 5-5-5 or 5-6-5
                 //
                 if (pDibInfoDst->pbmi->bmiHeader.biCompression == BI_BITFIELDS)
                 {
                      //5-5-5
                      if (*(DWORD *)&pDibInfoDst->pbmi->bmiColors[1] == 0x03E0)
                      {
                          *(PUSHORT)pjDstTemp = (USHORT)rgbBlue >> 3;
                          *(PUSHORT)pjDstTemp |= (USHORT)(rgbGreen >> 3) << 5;
                          *(PUSHORT)pjDstTemp |= (USHORT)(rgbRed >> 3) << 10;
                      }
                      // 5-6-5
                      else if (*(DWORD *)&pDibInfoDst->pbmi->bmiColors[1] == 0x07E0)
                      {
                          *(PUSHORT)pjDstTemp = (USHORT)rgbBlue >> 3;
                          *(PUSHORT)pjDstTemp |= (USHORT)(rgbGreen >> 2) << 5;
                          *(PUSHORT)pjDstTemp |= (USHORT)(rgbRed >> 3) << 11;
                      }
                      else
                      {
                          WARNING ("unsupported BITFIELDS\n");
                      }
                 }
                 else
                 {
                       *(PUSHORT)pjDstTemp = (USHORT)rgbBlue >> 3;
                       *(PUSHORT)pjDstTemp |= (USHORT)(rgbGreen >> 3) << 5;
                       *(PUSHORT)pjDstTemp |= (USHORT)(rgbRed >> 3) << 10;
                 }
            }

            pjDstTemp += 2;

         }

         pjDst += pDibInfoDst->stride;
         pjSrc += pDibInfoSrc->stride;
     }
}

/******************************Public*Routine******************************\
* vTransparentS8D24
*
* Doing a transparent copy from 8BPP to 16BPP
*
* Returns:
*   VOID.
*
* History:
*  09-Dec-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
VOID vTransparentS8D24 (
     PDIBINFO pDibInfoDst,
     PDIBINFO pDibInfoSrc,
     ULONG   TransColor)
{
     PBYTE   pjDst = (PBYTE)pDibInfoDst->pvBase + pDibInfoDst->stride*pDibInfoDst->rclDIB.top
                            +  pDibInfoDst->rclDIB.left*3;
     PBYTE   pjSrc = (PBYTE)pDibInfoSrc->pvBase + pDibInfoSrc->stride*pDibInfoSrc->rclDIB.top
                            + pDibInfoSrc->rclDIB.left;

     LONG    cx = pDibInfoDst->rclDIB.right - pDibInfoDst->rclDIB.left;
     LONG    cy = pDibInfoDst->rclDIB.bottom - pDibInfoDst->rclDIB.top;
     PBYTE   pjDstTemp;
     PBYTE   pjSrcTemp;
     BYTE    jSrc;
     LONG    cxTemp;
     BYTE    rgbBlue, rgbGreen, rgbRed;

     while(cy--)
     {
         cxTemp = cx;

         pjDstTemp = pjDst;
         pjSrcTemp = pjSrc;

         while (cxTemp--)
         {
             jSrc = *pjSrcTemp++;

             if (jSrc != (BYTE)TransColor)
             {
                 rgbBlue  = pDibInfoSrc->pbmi->bmiColors[jSrc].rgbBlue;
                 rgbGreen = pDibInfoSrc->pbmi->bmiColors[jSrc].rgbGreen;
                 rgbRed   = pDibInfoSrc->pbmi->bmiColors[jSrc].rgbRed;

                 *(pjDstTemp++) = (BYTE) rgbBlue;
                 *(pjDstTemp++) = (BYTE) rgbGreen;
                 *(pjDstTemp++) = (BYTE) rgbRed;
             }
             else
             {
                 pjDstTemp += 3;
             }
         }

         pjDst += pDibInfoDst->stride;
         pjSrc += pDibInfoSrc->stride;
     }
}

/******************************Public*Routine******************************\
* vTransparentS8D32
*
* Doing a transparent copy from 8BPP to 32BPP
*
* Returns:
*   VOID.
*
* History:
*  09-Dec-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
VOID vTransparentS8D32 (
     PDIBINFO pDibInfoDst,
     PDIBINFO pDibInfoSrc,
     ULONG   TransColor)
{
     PBYTE   pjDst = (PBYTE)pDibInfoDst->pvBase + pDibInfoDst->stride*pDibInfoDst->rclDIB.top
                            +  pDibInfoDst->rclDIB.left*4;
     PBYTE   pjSrc = (PBYTE)pDibInfoSrc->pvBase + pDibInfoSrc->stride*pDibInfoSrc->rclDIB.top
                            + pDibInfoSrc->rclDIB.left;
     LONG    cx = pDibInfoDst->rclDIB.right - pDibInfoDst->rclDIB.left;
     LONG    cy = pDibInfoDst->rclDIB.bottom - pDibInfoDst->rclDIB.top;
     PBYTE   pjDstTemp;
     PBYTE   pjSrcTemp;
     BYTE    jSrc;
     LONG    cxTemp;
     BYTE    rgbBlue, rgbGreen, rgbRed;

     while(cy--)
     {
         cxTemp = cx;

         pjDstTemp = pjDst;
         pjSrcTemp = pjSrc;

         while (cxTemp--)
         {
             jSrc = *pjSrcTemp++;

             if (jSrc != (BYTE)TransColor)
             {
                 rgbBlue  = pDibInfoSrc->pbmi->bmiColors[jSrc].rgbBlue;
                 rgbGreen = pDibInfoSrc->pbmi->bmiColors[jSrc].rgbGreen;
                 rgbRed   = pDibInfoSrc->pbmi->bmiColors[jSrc].rgbRed;

                 *(PULONG)pjDstTemp = (DWORD) (rgbBlue | (WORD)rgbGreen << 8 | (DWORD)rgbRed << 16);
             }
             pjDstTemp += 4;
         }

         pjDst += pDibInfoDst->stride;
         pjSrc += pDibInfoSrc->stride;
     }
}




/******************************Public*Routine******************************\
* vTransparentS8D1
*
* Doing a transparent copy from 8BPP to other 1,16,24,32bpp format DIBs
*
* Returns:
*   VOID.
*
* History:
*  09-Dec-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
VOID vTransparentS8D1 (
     PDIBINFO pDibInfoDst,
     PDIBINFO pDibInfoSrc,
     ULONG   TransColor)
{
     PBYTE   pjDst = (PBYTE)pDibInfoDst->pvBase + pDibInfoDst->stride*pDibInfoDst->rclDIB.top;

     pjDst = StartPixel (pjDst, pDibInfoDst->rclDIB.left, pDibInfoDst->pbmi->bmiHeader.biBitCount);

     PBYTE   pjSrc = (PBYTE)pDibInfoSrc->pvBase + pDibInfoSrc->stride*pDibInfoSrc->rclDIB.top
                            + pDibInfoSrc->rclDIB.left;

     LONG    cx = pDibInfoDst->rclDIB.right - pDibInfoDst->rclDIB.left;
     LONG    cy = pDibInfoDst->rclDIB.bottom - pDibInfoDst->rclDIB.top;
     PBYTE   pjDstTemp;
     PBYTE   pjSrcTemp;
     BYTE    jSrc;
     LONG    cxTemp;
     HDC     hdc;
     HBITMAP hbm;
     ULONG   ulWidthDst, ulHeightDst, ulWidthSrc, ulHeightSrc;
     BYTE    pByte[32];
     INT     i, j;
     BYTE    pByteSrc[256];
     LONG    iDst;
     BYTE    jDst;

     //
     // build the color translation table
     //
     hdc = CreateCompatibleDC (pDibInfoDst->hdc);

     //
     // save the original width/height
     //
     ulWidthDst = pDibInfoDst->pbmi->bmiHeader.biWidth;
     ulHeightDst = pDibInfoDst->pbmi->bmiHeader.biHeight;

     pDibInfoDst->pbmi->bmiHeader.biWidth = 256;
     pDibInfoDst->pbmi->bmiHeader.biHeight = 1;

     //
     // Create a 256X1 DIB
     //
     hbm = CreateDIBSection(hdc, (PBITMAPINFO)pDibInfoDst->pbmi, DIB_RGB_COLORS, (PVOID *)&pByte, NULL, 0);

     if (!hdc || !hbm)
     {
         WARNING ("failed to create hdc or hbm\n");
     }

     SelectObject (hdc, hbm);

     for (i = 0; i < 256; i++)
     {
         pByteSrc[i] = i;
     }

     ulWidthSrc = pDibInfoSrc->pbmi->bmiHeader.biWidth;
     ulHeightSrc = pDibInfoSrc->pbmi->bmiHeader.biHeight;

     pDibInfoSrc->pbmi->bmiHeader.biWidth = 256;
     pDibInfoSrc->pbmi->bmiHeader.biHeight = 1;

     SetDIBits(hdc, hbm, 0, 1, pByteSrc, (PBITMAPINFO)pDibInfoSrc->pbmi,pDibInfoSrc->iUsage);

     //
     // retore bitmap width/height
     //
     pDibInfoSrc->pbmi->bmiHeader.biWidth = ulWidthSrc;
     pDibInfoSrc->pbmi->bmiHeader.biHeight = ulHeightSrc;

     pDibInfoDst->pbmi->bmiHeader.biWidth = ulWidthDst;
     pDibInfoDst->pbmi->bmiHeader.biHeight = ulHeightDst;

     //
     // now pByte contains all the 256 color mappings, just need to split them up
     //
     BYTE bTmp = 0;

     while(cy--)
     {
         cxTemp = cx;

         pjDstTemp = pjDst;
         pjSrcTemp = pjSrc;

         iDst = pDibInfoDst->rclDIB.left & 0x07;

         jDst = *pjDstTemp >> (7 - iDst);

         while (cxTemp--)
         {
             jSrc = *pjSrcTemp++;

             //
             // put one pixel in the dest
             //
             bTmp = pByte[jSrc >> 3];
             bTmp >>= 7 - (jSrc & 0x07);

             if (jSrc != TransColor)
             {
                jDst |= bTmp;
             }
             else
             {
                jDst |= 1-bTmp;
             }

             jDst <<= 1;

             iDst++;

             if (!(iDst & 0x07))
             {
                *(pjDstTemp++) = jDst;
                jDst = 0;
             }
         }
         pjDst += pDibInfoDst->stride;
         pjSrc += pDibInfoSrc->stride;
     }
}

/******************************Public*Routine******************************\
* vTransparentS8D4
*
* Doing a transparent copy from 8BPP to other 1,16,24,32bpp format DIBs
*
* Returns:
*   VOID.
*
* History:
*  09-Dec-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
VOID vTransparentS8D4 (
     PDIBINFO pDibInfoDst,
     PDIBINFO pDibInfoSrc,
     ULONG   TransColor)
{
     PBYTE   pjDst = (PBYTE)pDibInfoDst->pvBase + pDibInfoDst->stride*pDibInfoDst->rclDIB.top;

     pjDst = StartPixel (pjDst, pDibInfoDst->rclDIB.left, pDibInfoDst->pbmi->bmiHeader.biBitCount);

     PBYTE   pjSrc = (PBYTE)pDibInfoSrc->pvBase + pDibInfoSrc->stride*pDibInfoSrc->rclDIB.top
                            + pDibInfoSrc->rclDIB.left;

     LONG    cx = pDibInfoDst->rclDIB.right - pDibInfoDst->rclDIB.left;
     LONG    cy = pDibInfoDst->rclDIB.bottom - pDibInfoDst->rclDIB.top;
     PBYTE   pjDstTemp;
     PBYTE   pjSrcTemp;
     BYTE    jSrc;
     LONG    cxTemp;
     HDC     hdc;
     HBITMAP hbm;
     ULONG   ulWidthDst, ulHeightDst, ulWidthSrc, ulHeightSrc;
     BYTE    pByte[128];
     INT     i, j;
     BYTE    xlate[256];
     BYTE    pByteSrc[256];
     LONG    iDst;

     //
     // build the color translation table
     //
     hdc = CreateCompatibleDC (pDibInfoDst->hdc);

     //
     // save the original width/height
     //
     ulWidthDst = pDibInfoDst->pbmi->bmiHeader.biWidth;
     ulHeightDst = pDibInfoDst->pbmi->bmiHeader.biHeight;

     pDibInfoDst->pbmi->bmiHeader.biWidth = 256;
     pDibInfoDst->pbmi->bmiHeader.biHeight = 1;

     //
     // Create a 256X1 DIB
     //
     hbm = CreateDIBSection(hdc, (PBITMAPINFO)pDibInfoDst->pbmi, DIB_RGB_COLORS, (PVOID *)&pByte, NULL, 0);

     if (!hdc || !hbm)
     {
         WARNING ("failed to create hdc or hbm\n");
     }

     SelectObject (hdc, hbm);

     for (i = 0; i < 256; i++)
     {
         pByteSrc[i] = i;
     }

     ulWidthSrc = pDibInfoSrc->pbmi->bmiHeader.biWidth;
     ulHeightSrc = pDibInfoSrc->pbmi->bmiHeader.biHeight;

     pDibInfoSrc->pbmi->bmiHeader.biWidth = 256;
     pDibInfoSrc->pbmi->bmiHeader.biHeight = 1;

     SetDIBits(hdc, hbm, 0, 1, pByteSrc, (PBITMAPINFO)pDibInfoSrc->pbmi,DIB_RGB_COLORS);

     //
     // retore bitmap width/height
     //
     pDibInfoSrc->pbmi->bmiHeader.biWidth = ulWidthSrc;
     pDibInfoSrc->pbmi->bmiHeader.biHeight = ulHeightSrc;

     pDibInfoDst->pbmi->bmiHeader.biWidth = ulWidthDst;
     pDibInfoDst->pbmi->bmiHeader.biHeight = ulHeightDst;

     //
     // now pByte contains all the 256 color mappings, just need to split them up
     //
     j = 0;
     for (i = 0; i < 128; i++)
     {
         xlate[j] = (pByte[i] & 0xF0) >> 4;
         xlate[j++] = pByte[i] & 0x0F;
     }

     BYTE jDst;

     while(cy--)
     {
         cxTemp = cx;

         iDst = pDibInfoDst->rclDIB.left;

         pjDstTemp = pjDst;
         pjSrcTemp = pjSrc;

         while (cxTemp--)
         {
             jSrc = *pjSrcTemp++;

             if (iDst & 0x00000001)
             {
                 if (jSrc != (BYTE)TransColor)
                 {
                     jDst |= (xlate[jSrc] & 0x0F);
                 }
                 else
                 {
                     jDst |= (*pjDstTemp & 0x0F);
                 }

                 *pjDstTemp = jDst;
                 jDst = 0;

                 pjDstTemp++;
             }
             else
             {
                 if (jSrc != (BYTE)TransColor)
                 {
                     jDst |= (xlate[jSrc] & 0x0F)<< 4;
                 }
                 else
                 {
                     jDst |= (*pjDstTemp & 0x0F) << 4;
                 }
             }

             iDst++;
         }

         pjDst += pDibInfoDst->stride;
         pjSrc += pDibInfoSrc->stride;
     }
}


/******************************Public*Routine******************************\
* vTransparentIdentityCopy8
*
* Doing a transparent copy on two same size 8BPP format DIBs
*
* Returns:
*   VOID.
*
* History:
*  09-Dec-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
VOID vTransparentIdentityCopy8 (
     PDIBINFO pDibInfoDst,
     PDIBINFO pDibInfoSrc,
     ULONG   TransColor)
{
     PBYTE   pjDst = (PBYTE)pDibInfoDst->pvBase + pDibInfoDst->stride*pDibInfoDst->rclDIB.top
                            + pDibInfoDst->rclDIB.left;
     PBYTE   pjSrc = (PBYTE)pDibInfoSrc->pvBase + pDibInfoSrc->stride*pDibInfoSrc->rclDIB.top
                            + pDibInfoSrc->rclDIB.left;
     LONG    cx = pDibInfoSrc->rclDIB.right - pDibInfoSrc->rclDIB.left;
     LONG    cy = pDibInfoSrc->rclDIB.bottom - pDibInfoSrc->rclDIB.top;
     PBYTE   pjDstTemp;
     PBYTE   pjSrcTemp;

     LONG   cxTemp;

     while(cy--)
     {
         cxTemp = cx;

         pjDstTemp = pjDst;
         pjSrcTemp = pjSrc;

         while (cxTemp--)
         {
             if (*pjSrcTemp != (BYTE)TransColor)
             {
                 *pjDstTemp = *pjSrcTemp;
             }
             pjDstTemp++;
             pjSrcTemp++;
         }

         pjDst += pDibInfoDst->stride;
         pjSrc += pDibInfoSrc->stride;
     }
}

/******************************Public*Routine******************************\
* vTransparentS8D8
*
* Doing a transparent copy on two same size 8BPP format DIBs
*
* Returns:
*   VOID.
*
* History:
*  09-Dec-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
VOID vTransparentS8D8 (
     PDIBINFO pDibInfoDst,
     PDIBINFO pDibInfoSrc,
     ULONG   TransColor)
{
     PBYTE   pjDst = (PBYTE)pDibInfoDst->pvBase + pDibInfoDst->stride*pDibInfoDst->rclDIB.top
                            + pDibInfoDst->rclDIB.left;
     PBYTE   pjSrc = (PBYTE)pDibInfoSrc->pvBase + pDibInfoSrc->stride*pDibInfoSrc->rclDIB.top
                            + pDibInfoSrc->rclDIB.left;
     LONG    cx = pDibInfoDst->rclDIB.right - pDibInfoDst->rclDIB.left;
     LONG    cy = pDibInfoDst->rclDIB.bottom - pDibInfoDst->rclDIB.top;
     PBYTE   pjDstTemp;
     PBYTE   pjSrcTemp;
     LONG    cxTemp;
     HDC     hdc;
     HBITMAP hbm;
     ULONG   ulWidthDst, ulHeightDst, ulWidthSrc, ulHeightSrc;
     INT     i, j;
     BYTE    pByteSrc[256];
     PBYTE   pxlate;
     LONG    iDst;

     //
     // build the color translation table
     //
     hdc = CreateCompatibleDC (pDibInfoDst->hdc);

     //
     // save the original width/height
     //
     ulWidthDst = pDibInfoDst->pbmi->bmiHeader.biWidth;
     ulHeightDst = pDibInfoDst->pbmi->bmiHeader.biHeight;

     pDibInfoDst->pbmi->bmiHeader.biWidth = 256;
     pDibInfoDst->pbmi->bmiHeader.biHeight = 1;

     //
     // Create a 256X1 DIB
     //
     hbm = CreateDIBSection(hdc, (PBITMAPINFO)pDibInfoDst->pbmi, DIB_RGB_COLORS, (PVOID *)&pxlate, NULL, 0);

     if (!hdc || !hbm)
     {
         WARNING ("failed to create hdc or hbm\n");
     }

     SelectObject (hdc, hbm);

     for (i = 0; i < 256; i++)
     {
         pByteSrc[i] = i;
     }

     ulWidthSrc = pDibInfoSrc->pbmi->bmiHeader.biWidth;
     ulHeightSrc = pDibInfoSrc->pbmi->bmiHeader.biHeight;

     pDibInfoSrc->pbmi->bmiHeader.biWidth = 256;
     pDibInfoSrc->pbmi->bmiHeader.biHeight = 1;

     SetDIBits(hdc, hbm, 0, 1, pByteSrc, (PBITMAPINFO)pDibInfoSrc->pbmi,DIB_RGB_COLORS);

     //
     // retore bitmap width/height
     //
     pDibInfoSrc->pbmi->bmiHeader.biWidth = ulWidthSrc;
     pDibInfoSrc->pbmi->bmiHeader.biHeight = ulHeightSrc;

     pDibInfoDst->pbmi->bmiHeader.biWidth = ulWidthDst;
     pDibInfoDst->pbmi->bmiHeader.biHeight = ulHeightDst;


     while(cy--)
     {
         cxTemp = cx;

         pjDstTemp = pjDst;
         pjSrcTemp = pjSrc;

         while (cxTemp--)
         {
             if (*pjSrcTemp != (BYTE)TransColor)
             {
                 *pjDstTemp = pxlate[*pjSrcTemp];
             }

             pjDstTemp++;
             pjSrcTemp++;
         }

         pjDst += pDibInfoDst->stride;
         pjSrc += pDibInfoSrc->stride;
     }

     DeleteObject (hbm);
     DeleteDC (hdc);
}



#if 0
/******************************Public*Routine******************************\
* vTransparentIdentityCopy16
*
* Doing a transparent copy on two same size 16BPP format DIBs
*
* Returns:
*   VOID.
*
* History:
*  09-Dec-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
VOID vTransparentIdentityCopy16 (
     PDIBINFO pDibInfoDst,
     PDIBINFO pDibInfoSrc,
     ULONG   TransColor)
{
     PUSHORT   pusDst = (PUSHORT)((PBYTE)pDibInfoDst->pvBase + pDibInfoDst->rclDIB.top*pDibInfoDst->stride)
                        + pDibInfoDst->rclDIB.left;
     PUSHORT   pusSrc = (PUSHORT)((PBYTE)pDibInfoSrc->pvBase + pDibInfoSrc->rclDIB.top*pDibInfoDst->stride)
                        + pDibInfoSrc->rclDIB.left;
     LONG      cx = pDibInfoDst->rclDIB.right - pDibInfoDst->rclDIB.left;
     LONG      cy = pDibInfoDst->rclDIB.bottom - pDibInfoDst->rclDIB.top;
     PUSHORT   pusDstTemp;
     PUSHORT   pusSrcTemp;
     LONG      cxTemp;

     while(cy--)
     {
         cxTemp = cx;

         pusDstTemp = pusDst;
         pusSrcTemp = pusSrc;

         while (cxTemp--)
         {
             if (*pusSrcTemp != (USHORT)TransColor)
             {
                 *pusDstTemp = *pusSrcTemp;
             }

             pusDstTemp++;
             pusSrcTemp++;
         }

         pusDst = (PUSHORT)((PBYTE)pusDst + pDibInfoDst->stride);
         pusSrc = (PUSHORT)((PBYTE)pusSrc + pDibInfoSrc->stride);
     }
}

/******************************Public*Routine******************************\
* vTransparentIdentityCopy24
*
* Doing a transparent copy on two same size 8BPP format DIBs
*
* Returns:
*   VOID.
*
* History:
*  09-Dec-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
VOID vTransparentIdentityCopy24 (
     PDIBINFO pDibInfoDst,
     PDIBINFO pDibInfoSrc,
     ULONG   TransColor)
{
     PBYTE   pjDst = (PBYTE)pDibInfoDst->pvBase + pDibInfoDst->stride*pDibInfoDst->rclDIB.top
                            + pDibInfoDst->rclDIB.left*3;
     PBYTE   pjSrc = (PBYTE)pDibInfoSrc->pvBase + pDibInfoSrc->stride*pDibInfoSrc->rclDIB.top
                            + pDibInfoSrc->rclDIB.left*3;
     LONG    cx = pDibInfoDst->rclDIB.right - pDibInfoDst->rclDIB.left;
     LONG    cy = pDibInfoDst->rclDIB.bottom - pDibInfoDst->rclDIB.top;
     PBYTE   pjDstTemp;
     PBYTE   pjSrcTemp;
     ULONG   ulTemp;
     LONG   cxTemp;

     while(cy--)
     {
         cxTemp = cx;

         pjDstTemp = pjDst;
         pjSrcTemp = pjSrc;

         while (cxTemp--)
         {
            ulTemp = (ULONG) *(pjSrcTemp + 2);
            ulTemp = ulTemp << 8;
            ulTemp |= (ULONG) *(pjSrcTemp + 1);
            ulTemp = ulTemp << 8;
            ulTemp |= (ULONG) *pjSrcTemp;

            if (ulTemp != TransColor)
            {
               *(pjDstTemp++) = (BYTE) ulTemp;
               *(pjDstTemp++) = (BYTE) (ulTemp >> 8);
               *(pjDstTemp++) = (BYTE) (ulTemp >> 16);
            }
            else
            {
                pjDstTemp += 3;
            }

            pjSrcTemp += 3;
         }

         pjDst += pDibInfoDst->stride;
         pjSrc += pDibInfoSrc->stride;
     }
}

/******************************Public*Routine******************************\
* vTransparentIdentityCopy32
*
* Doing a transparent copy on two same size 32BPP format DIBs
*
* Returns:
*   VOID.
*
* History:
*  09-Dec-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
VOID vTransparentIdentityCopy32 (
     PDIBINFO pDibInfoDst,
     PDIBINFO pDibInfoSrc,
     ULONG   TransColor)
{
     PULONG   pulDst = (PULONG)((PBYTE)pDibInfoDst->pvBase + pDibInfoDst->stride*pDibInfoDst->rclDIB.top)
                       + pDibInfoDst->rclDIB.left;
     PULONG   pulSrc = (PULONG)((PBYTE)pDibInfoSrc->pvBase + pDibInfoSrc->stride*pDibInfoSrc->rclDIB.top)
                       + pDibInfoSrc->rclDIB.left;
     LONG     cx = pDibInfoDst->rclDIB.right - pDibInfoDst->rclDIB.left;
     LONG     cy = pDibInfoDst->rclDIB.bottom - pDibInfoDst->rclDIB.top;
     PULONG   pulDstTemp;
     PULONG   pulSrcTemp;
     LONG     cxTemp;

     while(cy--)
     {
         cxTemp = cx;

         pulDstTemp = pulDst;
         pulSrcTemp = pulSrc;

         while (cxTemp--)
         {
             // mask off highest byte -- workaround Memphis problem
             if ((*pulSrcTemp & 0x00FFFFFF) != TransColor)
             {
                 *pulDstTemp = *pulSrcTemp;
             }

             pulDstTemp++;
             pulSrcTemp++;
         }

         pulDst = (PULONG)((PBYTE)pulDst + pDibInfoDst->stride);
         pulSrc = (PULONG)((PBYTE)pulSrc + pDibInfoSrc->stride);
     }
}
#endif

/******************************Public*Routine******************************\
* MapTransparentColor
*
* Getting the correct transparent color mapped to the specified DIB format
* by creating a solid brush on the colorref, then PatBlt to a 1X1 DIB, the
* resulting pixel is the mapped transparent color
*
* Returns:
*   VOID.
*
* History:
*  09-Dec-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
DWORD MapTransparentColor(
    PDIBINFO pDibInfo,
    COLORREF Color
    )
{
    HBRUSH hbr, hbrDefault;
    HBITMAP hbm, hbmDefault;
    HDC hdcTemp;
    UINT iUsage;
    PVOID pvBits = NULL;
    DWORD trancolor;
    ULONG ulWidth, ulHeight;

    hdcTemp = CreateCompatibleDC(pDibInfo->hdc);

    hbr = CreateSolidBrush (Color);

    //
    // save the original width/height
    //
    ulWidth = pDibInfo->pbmi->bmiHeader.biWidth;
    ulHeight = pDibInfo->pbmi->bmiHeader.biHeight;

    pDibInfo->pbmi->bmiHeader.biWidth = 1;
    pDibInfo->pbmi->bmiHeader.biHeight = 1;

    //
    // Create a 1X1 DIB
    //
    hbm = CreateDIBSection(hdcTemp, (PBITMAPINFO)pDibInfo->pbmi, DIB_RGB_COLORS, &pvBits, NULL, 0);

    if (hbm && hbr)
    {
        hbmDefault = (HBITMAP)SelectObject (hdcTemp, hbm);
        hbrDefault = (HBRUSH)SelectObject (hdcTemp, hbr);

        PatBlt (hdcTemp, 0, 0, 1, 1, PATCOPY);

        SelectObject (hdcTemp, hbrDefault);
        SelectObject (hdcTemp, hbmDefault);
    }

    if (pvBits)
    {
          switch (pDibInfo->pbmi->bmiHeader.biBitCount)
          {
          case 4:
              trancolor = *(BYTE *)pvBits;
              trancolor = (DWORD)(((BYTE)trancolor) & 0xF0) >>4;
              break;
          case 8:
              trancolor = (DWORD)(*(BYTE *)pvBits);
              trancolor &= 0x000000FF;
              break;
          case 16:
              trancolor = (DWORD)(*(USHORT *)pvBits);
              trancolor &= 0x0000FFFF;
              break;
          case 24:
              trancolor = *(DWORD *)pvBits;
              trancolor &= 0x00FFFFFF;
              break;
          case 32:
              trancolor = *(DWORD *)pvBits;
              trancolor &= 0x00FFFFFF;
              break;
          }
    }

    pDibInfo->pbmi->bmiHeader.biWidth = ulWidth;
    pDibInfo->pbmi->bmiHeader.biHeight = ulHeight;

    //
    // cleanup
    //
    DeleteObject (hbm);
    DeleteObject (hbr);
    DeleteObject(hdcTemp);

    return (trancolor);
}

/******************************Public*Routine******************************\
* DIBMapTransparentColor
*
* Getting the correct transparent color mapped to the specified DIB format
* This is only for DIB_PAL_COLORS passed into transparentDIBits
*
* Returns:
*   VOID.
*
* History:
*  09-Dec-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
DWORD DIBMapTransparentColor(
    PDIBINFO pDibInfoDst,
    PDIBINFO pDibInfoSrc,
    COLORREF Color
    )
{
    HBITMAP hbm, hbmDefault;
    HDC hdcTemp;
    UINT iUsage;
    PVOID pvBits;
    DWORD trancolor;
    ULONG ulWidth, ulHeight;

    hdcTemp = CreateCompatibleDC(pDibInfoDst->hdc);

    //
    // save the original width/height
    //
    ulWidth = pDibInfoDst->pbmi->bmiHeader.biWidth;
    ulHeight = pDibInfoDst->pbmi->bmiHeader.biHeight;

    pDibInfoDst->pbmi->bmiHeader.biWidth = 1;
    pDibInfoDst->pbmi->bmiHeader.biHeight = 1;

    //
    // Create a 1X1 DIB
    //
    hbm = CreateDIBSection(hdcTemp, (PBITMAPINFO)pDibInfoDst->pbmi, DIB_RGB_COLORS, &pvBits, NULL, 0);

    if (hbm)
    {
        hbmDefault = (HBITMAP)SelectObject (hdcTemp, hbm);

        StretchDIBits (hdcTemp,
                       0,
                       0,
                       1,
                       1,
                       0,
                       0,
                       1,
                       1,
                       &Color,
                       pDibInfoSrc->pbmi,
                       pDibInfoSrc->iUsage,
                       SRCCOPY);

        SelectObject (hdcTemp, hbmDefault);
    }

    if (pvBits)
    {
          switch (pDibInfoDst->pbmi->bmiHeader.biBitCount)
          {
          case 4:
              trancolor = *(BYTE *)pvBits;
              trancolor = (DWORD)(((BYTE)trancolor) & 0xF0) >>4;
              break;
          case 8:
              trancolor = (DWORD)(*(BYTE *)pvBits);
              trancolor &= 0x000000FF;
              break;
          case 16:
              trancolor = (DWORD)(*(USHORT *)pvBits);
              trancolor &= 0x0000FFFF;
              break;
          case 24:
              trancolor = *(DWORD *)pvBits;
              trancolor &= 0x00FFFFFF;
              break;
          case 32:
              trancolor = *(DWORD *)pvBits;
              trancolor &= 0x00FFFFFF;
              break;
          }
    }

    pDibInfoDst->pbmi->bmiHeader.biWidth = ulWidth;
    pDibInfoDst->pbmi->bmiHeader.biHeight = ulHeight;

    //
    // cleanup
    //
    DeleteObject (hbm);
    DeleteObject(hdcTemp);

    return (trancolor);
}


/******************************Public*Routine******************************\
* vTransparentMapCopy
*
* Map the Dest surface to 32bpp and does transparent on to that
*
* Returns:
*   VOID.
*
* History:
*  09-Dec-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
VOID vTransparentMapCopy (
     PDIBINFO pDibInfoDst,
     PDIBINFO pDibInfoSrc,
     ULONG TransColor)
{
     HDC hdc = pDibInfoSrc->hdc;
     ULONG cxDst = pDibInfoDst->rclDIB.right - pDibInfoDst->rclDIB.left;
     ULONG cyDst = pDibInfoDst->rclDIB.bottom - pDibInfoDst->rclDIB.top;
     HBITMAP hbm;
     PVOID   pBits;
     ULONG cBytes = sizeof(BITMAPINFO) + sizeof(RGBQUAD) * 255;
     PBITMAPINFO pbmi;
     PVOID p = LOCALALLOC(cBytes);

     if (!p)
     {
        WARNING("MapCopy fail to alloc mem\n");
        return ;
     }

     ZeroMemory (p,cBytes);

     pbmi = (PBITMAPINFO)p;

     vCopyBitmapInfo (pbmi, pDibInfoDst->pbmi);

     hdc = CreateCompatibleDC (hdc);

     pbmi->bmiHeader.biBitCount = 32;

     // create a dib using 32 format
     hbm = CreateCompatibleDIB (hdc, cxDst, cyDst, &pBits, pbmi);

     SetDIBits (hdc, hbm, 0, cyDst, pDibInfoDst->pvBits, pDibInfoDst->pbmi, DIB_RGB_COLORS);

     vCopyBitmapInfo (pDibInfoDst->pbmi,pbmi);

     GetCompatibleDIBInfo (hbm, &pDibInfoDst->pvBase, &pDibInfoDst->stride);

     pDibInfoDst->pvBits = pBits;

     if (pDibInfoSrc->pbmi->bmiHeader.biBitCount == 8)
     {
         vTransparentS8D32 (pDibInfoDst, pDibInfoSrc, TransColor);
     }
     else if (pDibInfoSrc->pbmi->bmiHeader.biBitCount == 4)
     {
         vTransparentS4D32 (pDibInfoDst, pDibInfoSrc, TransColor);
     }

     if (p)
     {
         LOCALFREE (p);
     }
}

/******************************Public*Routine******************************\
* ReadScanLine
*     read the scanline until it hits a transparent color pixel
*
* History:
*  26-Nov-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
ULONG ReadScanLine(
    PBYTE pjSrc,
    ULONG xStart,
    ULONG xEnd,
    ULONG iFormat,
    ULONG TransparentColor)
{
    ULONG  cx = xEnd-xStart;
    ULONG  Shift = (iFormat - 3 > 0) ? iFormat : 1;
    ULONG  iPos;
    ULONG  ulSrc;
    BOOL   bStop = FALSE;

    pjSrc = StartPixel (pjSrc, xStart, iFormat);

    //
    // performance can be improved by breaking this routine into many
    // dealing with different format so that we can save two comparsions
    // for each pixel operation.  But working set size will be large
    //
     iPos = xStart;

     //
     // read one pixel at a time and compare it to the transparent color
     // if it matches the transparent color, come out
     //
     while ((iPos < xEnd) && !bStop)
     {
         //
         // get a pixel from source and compare is to the transparent color
         //
         switch (iFormat)
         {
         case 1:
             ulSrc = *pjSrc & 0x00000001;
             *pjSrc >>= 1;

             if (!(iPos & 0x00000007) )
                 pjSrc++;
             break;

         case 4:
             if (iPos & 0x00000001)
             {
                 ulSrc = *pjSrc & 0x0F;
                 pjSrc++;
             }
             else
             {
                 ulSrc = (*pjSrc & 0xF0)>>4;
             }
             break;

         case 8:
             ulSrc = (ULONG) *pjSrc;
             pjSrc++;
             break;

         case 16:
             ulSrc = (ULONG) *((PUSHORT)pjSrc);
             pjSrc += 2;
             break;

         case 24:
             ulSrc = *(pjSrc + 2);
             ulSrc = ulSrc << 8;
             ulSrc |= (ULONG) *(pjSrc + 1);
             ulSrc = ulSrc << 8;
             ulSrc |= (ULONG) *pjSrc;
             pjSrc += 3;
             break;

          case 32:
             ulSrc = *(PULONG)(pjSrc);
             pjSrc +=4;
             break;

          default:
              WARNING ("vTransparentScan -- bad iFormatSrc\n");
              return(0);

         } /*switch*/

         if (ulSrc == TransparentColor)
             bStop = TRUE;

         iPos++;
    }

    return (iPos);
}

/******************************Public*Routine******************************\
* SkipScanLine
*     read the scanline until it hits a non-transparent color pixel
*
* History:
*  26-Nov-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
ULONG SkipScanLine(
    PBYTE pjSrc,
    ULONG xStart,
    ULONG xEnd,
    ULONG iFormat,
    ULONG TransparentColor)
{
    ULONG  Shift = (iFormat - 3 > 0) ? iFormat : 1;
    ULONG  iPos = xStart;
    ULONG  ulSrc;
    BOOL   bStop = FALSE;

    pjSrc = StartPixel (pjSrc, xStart, iFormat);

    //
    // performance can be improved by breaking this routine into many
    // dealing with different format so that we can save two comparsions
    // for each pixel operation.  But working set size will be large
    //

     //
     // read one pixel at a time and compare it to the transparent color
     // if it matches the transparent color, come out
     //
     while ((iPos < xEnd) && !bStop)
     {
         //
         // get a pixel from source and compare is to the transparent color
         //
         switch (iFormat)
         {
         case 1:
             ulSrc = *pjSrc & 0x00000001;
             *pjSrc >>= 1;

             if (!(iPos & 0x00000007) )
                 pjSrc++;
             break;

         case 4:
             if (iPos & 0x00000001)
             {
                 ulSrc = *pjSrc & 0x0F;
                 pjSrc++;
             }
             else
             {
                 ulSrc = (*pjSrc & 0xF0)>>4;
             }
             break;

         case 8:
             ulSrc = (ULONG) *pjSrc;
             pjSrc++;
             break;

         case 16:
             ulSrc = (ULONG) *((PUSHORT)pjSrc);
             pjSrc += 2;
             break;

         case 24:
             ulSrc = *(pjSrc + 2);
             ulSrc = ulSrc << 8;
             ulSrc |= (ULONG) *(pjSrc + 1);
             ulSrc = ulSrc << 8;
             ulSrc |= (ULONG) *pjSrc;
             pjSrc += 3;
             break;

          case 32:
             ulSrc = *(PULONG)(pjSrc);
             pjSrc +=4;
             break;

          default:
              WARNING ("vTransparentScan -- bad iFormatSrc\n");
              return (0);

         } /*switch*/

         if (ulSrc != TransparentColor)
             bStop = TRUE;

         iPos++;   // move to the next pixel
    }

    return (iPos);
}

/******************************Public*Routine******************************\
* VOID vTransparentCopyScan
*
* Read a scanline at a time and send the non-transparent pixel scans over
*
* History:
*  2-Dec-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/

VOID vTransparentCopyScan (
    PDIBINFO  pDibInfoDst,
    PDIBINFO  pDibInfoSrc,
    ULONG     TransparentColor)
{
    ULONG xStart;
    ULONG cx = pDibInfoSrc->rclDIB.right - pDibInfoSrc->rclDIB.left;
    ULONG cy =  pDibInfoSrc->rclDIB.bottom - pDibInfoSrc->rclDIB.top;
    ULONG xEnd;
    ULONG xSrc;
    ULONG ySrc = pDibInfoSrc->rclDIB.bottom;
    ULONG xDst;
    ULONG yDst = pDibInfoDst->rclBounds.top;
    ULONG xStop, xReStart;

    PBYTE pjSrc = (PBYTE)pDibInfoSrc->pvBase + pDibInfoSrc->rclDIB.top*pDibInfoSrc->stride;

    //
    // we only allow 4bpp,8bpp src for now
    //

    if ((pDibInfoSrc->pbmi->bmiHeader.biBitCount != 4) ||
        (pDibInfoSrc->pbmi->bmiHeader.biBitCount != 8))
    return;

    while (cy--)
    {
       xStart = pDibInfoSrc->rclDIB.left;
       xEnd = xStart + cx;

       xSrc = pDibInfoSrc->rclDIB.left;
       xDst = pDibInfoDst->rclBounds.left;

       while (xStart < xEnd)
       {
           xStop = ReadScanLine((PBYTE)pjSrc,
                                 xStart,
                                 xEnd,
                                 pDibInfoSrc->pbmi->bmiHeader.biBitCount,
                                 TransparentColor);

           if (xStop-1 > xStart)
           {
               //
               // send the partial scan line over
               //
               StretchDIBits (
                          pDibInfoDst->hdc,
                          xDst,
                          yDst,
                          xStop-xStart-1, //width
                          1,
                          xSrc-1,
                          ySrc-1,
                          xStop-xStart-1,
                          1,
                          (PBYTE)pDibInfoSrc->pvBits,
                          pDibInfoSrc->pbmi,
                          DIB_RGB_COLORS,
                          SRCCOPY);

           }

           //get to the next non transparent pixel
           xReStart = SkipScanLine((PBYTE)pjSrc,
                                    xStop-1,
                                    xEnd,
                                    pDibInfoSrc->pbmi->bmiHeader.biBitCount,
                                    TransparentColor);

           xDst = xDst + xReStart-xStart;

           xSrc = xReStart;

           xStart = xReStart;
        }

        pjSrc += pDibInfoSrc->stride;

        ySrc--;
        yDst++;
     }
}


/******************************Public*Routine******************************\
* WinTransparentBlt
*
* Returns:
*   BOOL.
*
* History:
*  09-Dec-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/


BOOL
WinTransparentBlt(
                 HDC   hdcDst,
                 int   xDst,
                 int   yDst,
                 int   cxDst,
                 int   cyDst,
                 HDC   hdcSrc,
                 int   xSrc,
                 int   ySrc,
                 int   cxSrc,
                 int   cySrc,
                 UINT  TransColor
                 )

{
    BOOL bRet = TRUE;
    DIBINFO DibInfoDst, DibInfoSrc;
    PDIBINFO pDibInfoDst, pDibInfoSrc;
    BOOL     bReadable;
    //
    // parameter checking
    //

    if (cxDst < 0 || cyDst < 0 || cxSrc < 0 || cySrc < 0)
    {
        WARNING("bad parameters\n");
        return (FALSE);
    }

    pDibInfoDst = &DibInfoDst;
    ZeroMemory (pDibInfoDst, sizeof(DIBINFO));

    if (!bInitDIBINFO (hdcDst, xDst, yDst, cxDst, cyDst, pDibInfoDst))
        return (FALSE);

    pDibInfoSrc = &DibInfoSrc;
    ZeroMemory (pDibInfoSrc, sizeof(DIBINFO));

    if (!bInitDIBINFO (hdcSrc, xSrc, ySrc, cxSrc, cySrc, pDibInfoSrc))
        return (FALSE);

    bRet = bSetupBitmapInfos (pDibInfoDst, pDibInfoSrc);

    if (bRet)
    {
       TransColor = MapTransparentColor (pDibInfoSrc, TransColor);

       bRet =  bGetSrcDIBits(pDibInfoDst, pDibInfoSrc, SOURCE_TRAN, TransColor);

       if (bRet)
       {
          bRet = bGetDstDIBits (pDibInfoDst, &bReadable, SOURCE_TRAN);

          if (bRet)
          {

             if (bReadable)
             {
                switch (pDibInfoSrc->pbmi->bmiHeader.biBitCount)
                {
                case 4:
                     if (bSameDIBformat(pDibInfoDst->pbmi,pDibInfoSrc->pbmi))
                     {
                         vTransparentIdentityCopy4 (pDibInfoDst, pDibInfoSrc, TransColor);
                     }
                     else if (pDibInfoDst->pbmi->bmiHeader.biBitCount == 4)
                     {
                         vTransparentS4D4 (pDibInfoDst, pDibInfoSrc, TransColor);
                     }
                     else if (pDibInfoDst->pbmi->bmiHeader.biBitCount == 8)
                     {
                         vTransparentS4D8(pDibInfoDst, pDibInfoSrc, TransColor);
                     }
                     else if (pDibInfoDst->pbmi->bmiHeader.biBitCount == 16)
                     {
                         vTransparentS4D16 (pDibInfoDst, pDibInfoSrc, TransColor);
                     }
                     else if (pDibInfoDst->pbmi->bmiHeader.biBitCount == 24)
                     {
                         vTransparentS4D24 (pDibInfoDst, pDibInfoSrc, TransColor);
                     }
                     else if (pDibInfoDst->pbmi->bmiHeader.biBitCount == 32)
                     {
                         vTransparentS4D32 (pDibInfoDst, pDibInfoSrc, TransColor);
                     }
                     else
                     {   //1
                         vTransparentMapCopy (pDibInfoDst, pDibInfoSrc, TransColor);
                     }
                     break;

                case 8:
                     if (bSameDIBformat(pDibInfoDst->pbmi,pDibInfoSrc->pbmi))
                     {
                         vTransparentIdentityCopy8 (pDibInfoDst, pDibInfoSrc, TransColor);
                     }
                     else if (pDibInfoDst->pbmi->bmiHeader.biBitCount == 8)
                     {
                         vTransparentS8D8 (pDibInfoDst, pDibInfoSrc, TransColor);
                     }
                     else if (pDibInfoDst->pbmi->bmiHeader.biBitCount == 16)
                     {
                        vTransparentS8D16 (pDibInfoDst, pDibInfoSrc, TransColor);
                     }
                     else if (pDibInfoDst->pbmi->bmiHeader.biBitCount == 24)
                     {
                        vTransparentS8D24 (pDibInfoDst, pDibInfoSrc, TransColor);
                     }
                     else if (pDibInfoDst->pbmi->bmiHeader.biBitCount == 32)
                     {
                        vTransparentS8D32 (pDibInfoDst, pDibInfoSrc, TransColor);
                     }
                     else
                     {
                        //1, 4
                        vTransparentMapCopy (pDibInfoDst, pDibInfoSrc, TransColor);
                     }
                     break;

                default:
                     WARNING ("src format not currently supported\n");
                     bRet = FALSE;
                     goto CleanUp;
                     break;
                }

                //
                // if we have created a temp destination DIB, send the final result to destination
                //

                bRet = bSendDIBINFO (hdcDst, pDibInfoDst);
             }
             else
             {
              //
              // non-readable dest surface
              //
              vTransparentCopyScan (pDibInfoDst, pDibInfoSrc, TransColor);
             }
          }
          else
          {
              WARNING ("GetSrcDIBits failed\n");
              bRet = FALSE;
          }
       }
    }
    else
    {
        WARNING ("GetDstDIBits failed \n");
        bRet = FALSE;
    }
    //
    // clean up
    //
CleanUp:
    vCleanupDIBINFO (pDibInfoDst);
    vCleanupDIBINFO (pDibInfoSrc);


    return (bRet);
}

/******************************Public*Routine******************************\
* WinTransparentDIBits
*
* Returns:
*   BOOL.
*
* History:
*  09-Dec-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
BOOL
WinTransparentDIBits(
                      HDC   hdcDst,
                      int   xDst,
                      int   yDst,
                      int   cxDst,
                      int   cyDst,
                      CONST VOID * lpBits,
                      CONST BITMAPINFO *lpBitsInfo,
                      UINT  iUsage,
                      int   xSrc,
                      int   ySrc,
                      int   cxSrc,
                      int   cySrc,
                      UINT  TransColor
                      )
{
    BOOL bRet = TRUE;
    DIBINFO DibInfoDst, DibInfoSrc;
    PDIBINFO pDibInfoDst, pDibInfoSrc;
    BOOL bReadable;

    //
    // parameter checking
    //

    if (cxDst < 0 || cyDst < 0)
    {
        WARNING("bad parameters\n");
        return (FALSE);
    }

    pDibInfoDst = &DibInfoDst;
    ZeroMemory (pDibInfoDst, sizeof(DIBINFO));

    if (!bInitDIBINFO (hdcDst, xDst, yDst, cxDst, cyDst, pDibInfoDst))
        return (FALSE);

    pDibInfoSrc = &DibInfoSrc;

    ZeroMemory (pDibInfoSrc, sizeof(DIBINFO));

    if (!bDIBInitDIBINFO ((PBITMAPINFO)lpBitsInfo, lpBits, xSrc, ySrc, cxSrc, cySrc, pDibInfoSrc))
        return (FALSE);

    pDibInfoSrc->iUsage = iUsage;

    bRet = bSetupBitmapInfos (pDibInfoDst, pDibInfoSrc);

    if (bRet)
    {
       // TransColor will only be index
       TransColor = TransColor & 0x00FF;

       bRet = bDIBGetSrcDIBits (pDibInfoDst, pDibInfoSrc, SOURCE_TRAN, TransColor);

       if (bRet)
       {
          bRet = bGetDstDIBits (pDibInfoDst, &bReadable, SOURCE_TRAN);

          if (bRet)
          {

             if (bReadable)
             {
                switch (pDibInfoSrc->pbmi->bmiHeader.biBitCount)
                {
                case 4:
                     if (bSameDIBformat(pDibInfoDst->pbmi,pDibInfoSrc->pbmi))
                     {
                         vTransparentIdentityCopy4 (pDibInfoDst, pDibInfoSrc, TransColor);
                     }
                     else if (pDibInfoDst->pbmi->bmiHeader.biBitCount == 4)
                     {
                         vTransparentS4D4 (pDibInfoDst, pDibInfoSrc, TransColor);
                     }
                     else if (pDibInfoDst->pbmi->bmiHeader.biBitCount == 8)
                     {
                         vTransparentS4D8(pDibInfoDst, pDibInfoSrc, TransColor);
                     }
                     else if (pDibInfoDst->pbmi->bmiHeader.biBitCount == 16)
                     {
                         vTransparentS4D16 (pDibInfoDst, pDibInfoSrc, TransColor);
                     }
                     else if (pDibInfoDst->pbmi->bmiHeader.biBitCount == 24)
                     {
                         vTransparentS4D24 (pDibInfoDst, pDibInfoSrc, TransColor);
                     }
                     else if (pDibInfoDst->pbmi->bmiHeader.biBitCount == 32)
                     {
                         vTransparentS4D32 (pDibInfoDst, pDibInfoSrc, TransColor);
                     }
                     else
                     {   //1
                         vTransparentMapCopy (pDibInfoDst, pDibInfoSrc, TransColor);
                     }
                     break;

                case 8:
                     if (bSameDIBformat(pDibInfoDst->pbmi,pDibInfoSrc->pbmi))
                     {
                         vTransparentIdentityCopy8 (pDibInfoDst, pDibInfoSrc, TransColor);
                     }
                     else if (pDibInfoDst->pbmi->bmiHeader.biBitCount == 8)
                     {
                         vTransparentS8D8 (pDibInfoDst, pDibInfoSrc, TransColor);
                     }
                     else if (pDibInfoDst->pbmi->bmiHeader.biBitCount == 16)
                     {
                        vTransparentS8D16 (pDibInfoDst, pDibInfoSrc, TransColor);
                     }
                     else if (pDibInfoDst->pbmi->bmiHeader.biBitCount == 24)
                     {
                        vTransparentS8D24 (pDibInfoDst, pDibInfoSrc, TransColor);
                     }
                     else if (pDibInfoDst->pbmi->bmiHeader.biBitCount == 32)
                     {
                        vTransparentS8D32 (pDibInfoDst, pDibInfoSrc, TransColor);
                     }
                     else
                     {
                        //1, 4
                        vTransparentMapCopy (pDibInfoDst, pDibInfoSrc, TransColor);
                     }
                     break;

                default:
                     WARNING ("BAD bitmap format\n");
                     bRet = FALSE;
                     goto CleanUp;
                     break;
                }

                //
                // if we have created a temp destination DIB, send the final result to destination
                //

                bRet = bSendDIBINFO (hdcDst, pDibInfoDst);
             }
             else
             {
                  //
                  // non-readable dest surface
                  //
                  vTransparentCopyScan (pDibInfoDst, pDibInfoSrc, TransColor);
             }
          }
          else
          {
              WARNING ("GetSrcDIBits failed\n");
              bRet = FALSE;
          }
       }
    }
    else
    {
        WARNING ("GetDstDIBits failed \n");
        bRet = FALSE;
    }

    //
    // clean up
    //
CleanUp:
    vCleanupDIBINFO (pDibInfoDst);
    vCleanupDIBINFO (pDibInfoSrc);

    return (bRet);
}
#endif

BOOL
TransparentBlt(
                 HDC   hdcDest,
                 int   DstX,
                 int   DstY,
                 int   DstCx,
                 int   DstCy,
                 HDC   hSrc,
                 int   SrcX,
                 int   SrcY,
                 int   SrcCx,
                 int   SrcCy,
                 UINT  Color
                 )
{
    BOOL bRet = FALSE;

    bRet = gpfnTransparentBlt(
                      hdcDest,
                      DstX,
                      DstY,
                      DstCx,
                      DstCy,
                      (HDC)hSrc,
                      SrcX,
                      SrcY,
                      SrcCx,
                      SrcCy,
                      Color
                      );

    return(bRet);
}


BOOL
TransparentDIBits(
    HDC         hdcDest,
    int         DstX,
    int         DstY,
    int         DstCx,
    int         DstCy,
    CONST VOID *lpBits,
    CONST BITMAPINFO *lpBitsInfo,
    UINT        iUsage,
    int         SrcX,
    int         SrcY,
    int         SrcCx,
    int         SrcCy,
    UINT        Color
    )
{
    BOOL bRet = FALSE;

    bRet = gpfnTransparentDIBits(
                      hdcDest,
                      DstX,
                      DstY,
                      DstCx,
                      DstCy,
                      lpBits,
                      lpBitsInfo,
                      iUsage,
                      SrcX,
                      SrcY,
                      SrcCx,
                      SrcCy,
                      Color
                      );
    return(bRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\image\tmp\alpha.cxx ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name

   alpha.cxx

Abstract:

   alpha blending functions

Author:

   Mark Enstrom   (marke)  23-Jun-1996

Enviornment:

   User Mode

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

#if DBG
ULONG DbgAlpha = 0;
#endif

extern PFNALPHABLEND gpfnAlphaBlend;
extern PFNALPHADIB   gpfnAlphaDIB;

#if !(_WIN32_WINNT >= 0x500)

#if defined(_X86_)

ULONG gMMX = 0;

/**************************************************************************\
* IsMMXProcessor
*   
*   
* Arguments:
*   
*
*
* Return Value:
*
*
*
* History:
*
*    4/10/1997 Mark Enstrom [marke]
*
\**************************************************************************/

#define CPUID _asm _emit 0fh _asm _emit 0a2h

BOOL 
bIsMMXProcessor(VOID)
{
    BOOL  retval = TRUE;
    DWORD RegEDX;

    //
    // Find out if procesor supports CPUID
    //
    //
    //__try 
    //{
    //    _asm 
    //    {
    //        mov eax, 1
    //
    //        // code bytes = 0fh,  0a2h   
    //
    //        CPUID                      
    //        mov RegEDX, edx
    //    }
    //} __except(EXCEPTION_EXECUTE_HANDLER) 
    //{ 
    //    retval = FALSE; 
    //}
    //
    //if (retval == FALSE)
    //{   
    //    //
    //    // processor does not support CPUID 
    //    //
    //
    //    return FALSE;        
    //}
    //
    ////
    //// bit 23 is set for MMX technology 
    ////
    //
    //if (RegEDX & 0x800000) 
    //{

        //
        // save and restore fp state around emms!!!
        //

        __try 
        { 
            _asm emms 
        }
        __except(EXCEPTION_EXECUTE_HANDLER) 
        { 
            retval = FALSE; 
        }
    //}
    //else
    //{
    //    //
    //    // processor supports CPUID but does not have MMX technology 
    //    //
    //
    //    return FALSE;        
    //}

    //
    // if retval == 0 here that means the processor has MMX technology but
    // the FP emulation is on so MMX technology is unavailable
    //

   return retval;
}

#endif

/**************************************************************************\
* bDetermineAlphaBlendFunction
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    1/21/1997 Mark Enstrom [marke]
*
\**************************************************************************/

BOOL
bDetermineAlphaBlendFunction(
    CONST DIBINFO          *pdibDst,
    CONST DIBINFO          *pdibSrc,
    PALPHA_DISPATCH_FORMAT  pAlphaDispatch
    )
{
    PULONG pulSrcMask = (PULONG)&pdibSrc->pbmi->bmiColors[0];
    ULONG  ulSrcFlRed;
    ULONG  ulSrcFlGreen;
    ULONG  ulSrcFlBlue;

    PULONG pulDstMask = (PULONG)&pdibDst->pbmi->bmiColors[0];
    ULONG  ulDstFlRed;
    ULONG  ulDstFlGreen;
    ULONG  ulDstFlBlue;

    pAlphaDispatch->pfnGeneralBlend = vPixelGeneralBlend;

    ULONG DstBitPerPixel = pdibDst->pbmi->bmiHeader.biBitCount;
    LONG DstWidth        = pdibDst->pbmi->bmiHeader.biWidth;
    ULONG SrcBitPerPixel = pdibSrc->pbmi->bmiHeader.biBitCount;
    LONG SrcWidth        = pdibSrc->pbmi->bmiHeader.biWidth;

    LONG cxDst = pdibDst->rclDIB.right - pdibDst->rclDIB.left;

    pAlphaDispatch->ulDstBitsPerPixel = DstBitPerPixel;
    pAlphaDispatch->ulSrcBitsPerPixel = SrcBitPerPixel;

    //
    //  does src btimap have alpha
    //

    BOOL bSrcHasAlpha = FALSE;

    if (
         ((pAlphaDispatch->BlendFunction.AlphaFormat & AC_SRC_NO_ALPHA) == 0) &&
         (SrcBitPerPixel ==  32) &&
         (
           (pdibSrc->pbmi->bmiHeader.biCompression == BI_RGB) ||
           (
             (pdibSrc->pbmi->bmiHeader.biCompression == BI_BITFIELDS) &&
             (
               (pulSrcMask[0] == 0xff0000) &&
               (pulSrcMask[1] == 0x00ff00) &&
               (pulSrcMask[2] == 0x0000ff)
             )
           )
         )
       )
    {
        bSrcHasAlpha = TRUE;
    }

    //
    // assume general blend, then try to find special case
    //

    pAlphaDispatch->pfnGeneralBlend = vPixelGeneralBlend;


    if (
         (
           (pAlphaDispatch->BlendFunction.SourceBlend      == AC_SRC_OVER) &&
           (pAlphaDispatch->BlendFunction.DestinationBlend == AC_SRC_OVER)
         ) ||
         (
           (pAlphaDispatch->BlendFunction.SourceBlend      == AC_SRC_UNDER) &&
           (pAlphaDispatch->BlendFunction.DestinationBlend == AC_SRC_UNDER)
         )
       )
    {
        //
        // use "over" optimized blend fucntion
        //

        if (bSrcHasAlpha && (pAlphaDispatch->BlendFunction.SourceConstantAlpha == 255))
        {
            pAlphaDispatch->pfnGeneralBlend = vPixelOver;

            #if defined(_X86_)

                //
                // source and dest alignment must be 8 byte aligned to use mmx
                //

                if (bIsMMXProcessor() && (cxDst >= 8))
                {
                    if (
                        ((DstWidth & 0x07) == 0) &&
                        ((SrcWidth & 0x07) == 0)
                       )
                    {
                        pAlphaDispatch->pfnGeneralBlend = mmxPixelOver;
                        pAlphaDispatch->bUseMMX         = TRUE;
                    }
                }

            #endif
        }
        else
        {
            //
            // if source format doesn't support alpha then use
            // constant src alpha routine
            //

            if (bSrcHasAlpha)
            {
                pAlphaDispatch->pfnGeneralBlend = vPixelBlendOrDissolveOver;

                #if defined(_X86_)

                    //
                    // source and dest alignment must be 8 byte aligned to use mmx
                    //

                    if (bIsMMXProcessor() && (cxDst >= 8))
                    {
                        if (
                            ((DstWidth & 0x07) == 0) &&
                            ((SrcWidth & 0x07) == 0)
                           )
                        {
                            pAlphaDispatch->pfnGeneralBlend = mmxPixelBlendOrDissolveOver;
                            pAlphaDispatch->bUseMMX         = TRUE;
                        }
                    }

                #endif
            }
            else
            {
                pAlphaDispatch->pfnGeneralBlend = vPixelBlend;
            }
        }
    }

    //
    // determine output conversion and storage routines
    //

    switch (DstBitPerPixel)
    {
    case 1:
        pAlphaDispatch->pfnLoadDstAndConvert = vLoadAndConvert1ToBGRA;
        pAlphaDispatch->pfnConvertAndStore   = vConvertAndSaveBGRATo1;
        break;

    case 4:
        pAlphaDispatch->pfnLoadDstAndConvert = vLoadAndConvert4ToBGRA;
        pAlphaDispatch->pfnConvertAndStore   = vConvertAndSaveBGRATo4;
        break;

    case 8:
        pAlphaDispatch->pfnLoadDstAndConvert = vLoadAndConvert8ToBGRA;
        pAlphaDispatch->pfnConvertAndStore   = vConvertAndSaveBGRATo8;
        break;

    case 16:

        if (pdibDst->pbmi->bmiHeader.biCompression == BI_RGB)
        {
            ulDstFlRed   = 0x7c00;
            ulDstFlGreen = 0x03e0;
            ulDstFlBlue  = 0x001f;
        }
        else if (pdibDst->pbmi->bmiHeader.biCompression == BI_BITFIELDS)
        {
            ulDstFlRed   = pulDstMask[0];
            ulDstFlGreen = pulDstMask[1];
            ulDstFlBlue  = pulDstMask[2];
        }
        else
        {
            return(FALSE);
        }

        if (
             (ulDstFlRed   == 0xf800) &&
             (ulDstFlGreen == 0x07e0) &&
             (ulDstFlBlue  == 0x001f)
           )
        {
            pAlphaDispatch->pfnLoadDstAndConvert = vLoadAndConvertRGB16_565ToBGRA;
            pAlphaDispatch->pfnConvertAndStore   = vConvertAndSaveBGRAToRGB16_565;
        }
        else if (
             (ulDstFlRed   == 0x7c00) &&
             (ulDstFlGreen == 0x03e0) &&
             (ulDstFlBlue  == 0x001f)
           )
        {
            pAlphaDispatch->pfnLoadDstAndConvert = vLoadAndConvertRGB16_555ToBGRA;
            pAlphaDispatch->pfnConvertAndStore   = vConvertAndSaveBGRAToRGB16_555;
        }
        else
        {
            return(FALSE);
        }

        break;

    case 24:
        pAlphaDispatch->pfnLoadDstAndConvert = vLoadAndConvertRGB24ToBGRA;
        pAlphaDispatch->pfnConvertAndStore   = vConvertAndSaveBGRAToRGB24;
        break;

    case 32:

        if (pdibDst->pbmi->bmiHeader.biCompression == BI_RGB)
        {
            ulDstFlRed   = 0xff0000;
            ulDstFlGreen = 0x00ff00;
            ulDstFlBlue  = 0x0000ff;
        }
        else if (pdibDst->pbmi->bmiHeader.biCompression == BI_BITFIELDS)
        {
            ulDstFlRed   = pulDstMask[0];
            ulDstFlGreen = pulDstMask[1];
            ulDstFlBlue  = pulDstMask[2];
        }
        else
        {
            return(FALSE);
        }

        if (
                (ulDstFlRed   == 0xff0000) &&
                (ulDstFlGreen == 0x00ff00) &&
                (ulDstFlBlue  == 0x0000ff)
           )
        {
            //
            // assigned to null indicates no conversion needed
            //

            pAlphaDispatch->pfnLoadDstAndConvert = NULL;
            pAlphaDispatch->pfnConvertAndStore   = NULL;
        }
        else if (
                  (ulDstFlRed   == 0x0000ff) &&
                  (ulDstFlGreen == 0x00ff00) &&
                  (ulDstFlBlue  == 0xff0000)
                )
        {
            pAlphaDispatch->pfnLoadDstAndConvert = vLoadAndConvertRGB32ToBGRA;
            pAlphaDispatch->pfnConvertAndStore   = vConvertAndSaveBGRAToRGB32;
        }
        else
        {
            pAlphaDispatch->pfnLoadDstAndConvert = vLoadAndConvert32BitfieldsToBGRA;
            pAlphaDispatch->pfnConvertAndStore   = vConvertAndSaveBGRATo32Bitfields;
        }

        break;
    }

    //
    // determine input load and conversion routine
    //

    switch (SrcBitPerPixel)
    {
    case 1:
        pAlphaDispatch->pfnLoadSrcAndConvert = vLoadAndConvert1ToBGRA;
        break;

    case 4:
        pAlphaDispatch->pfnLoadSrcAndConvert = vLoadAndConvert4ToBGRA;
        break;

    case 8:
        pAlphaDispatch->pfnLoadSrcAndConvert = vLoadAndConvert8ToBGRA;
        break;

    case 16:

        if (pdibSrc->pbmi->bmiHeader.biCompression == BI_RGB)
        {
            ulSrcFlRed   = 0x7c00;
            ulSrcFlGreen = 0x03e0;
            ulSrcFlBlue  = 0x001f;
        }
        else if (pdibSrc->pbmi->bmiHeader.biCompression == BI_BITFIELDS)
        {
            ulSrcFlRed   = pulSrcMask[0];
            ulSrcFlGreen = pulSrcMask[1];
            ulSrcFlBlue  = pulSrcMask[2];
        }
        else
        {
            return(FALSE);
        }

        if (
             (ulSrcFlRed   == 0xf800) &&
             (ulSrcFlGreen == 0x07e0) &&
             (ulSrcFlBlue  == 0x001f)
           )
        {
            pAlphaDispatch->pfnLoadSrcAndConvert = vLoadAndConvertRGB16_565ToBGRA;
        }
        else if (
             (ulSrcFlRed   == 0x7c00) &&
             (ulSrcFlGreen == 0x03e0) &&
             (ulSrcFlBlue  == 0x001f)
           )
        {
            pAlphaDispatch->pfnLoadSrcAndConvert = vLoadAndConvertRGB16_555ToBGRA;
        }
        else
        {
            pAlphaDispatch->pfnLoadSrcAndConvert = vLoadAndConvert16BitfieldsToBGRA;
        }

        break;

    case 24:
        pAlphaDispatch->pfnLoadSrcAndConvert = vLoadAndConvertRGB24ToBGRA;
        break;

    case 32:

        if (pdibSrc->pbmi->bmiHeader.biCompression == BI_RGB)
        {
            ulSrcFlRed   = 0xff0000;
            ulSrcFlGreen = 0x00ff00;
            ulSrcFlBlue  = 0x0000ff;
        }
        else if (pdibSrc->pbmi->bmiHeader.biCompression == BI_BITFIELDS)
        {
            ulSrcFlRed   = pulSrcMask[0];
            ulSrcFlGreen = pulSrcMask[1];
            ulSrcFlBlue  = pulSrcMask[2];
        }
        else
        {
            return(FALSE);
        }

        if (
             (ulSrcFlRed   == 0xff0000) &&
             (ulSrcFlGreen == 0x00ff00) &&
             (ulSrcFlBlue  == 0x0000ff)
           )
        {
            pAlphaDispatch->pfnLoadSrcAndConvert = NULL;
        }
        else if (
                  (ulSrcFlRed   == 0x0000ff) &&
                  (ulSrcFlGreen == 0x00ff00) &&
                  (ulSrcFlBlue  == 0xff0000)
                )
        {
            pAlphaDispatch->pfnLoadSrcAndConvert = vLoadAndConvertRGB32ToBGRA;
        }
        else
        {
            pAlphaDispatch->pfnLoadSrcAndConvert = vLoadAndConvert32BitfieldsToBGRA;
        }

        break;
    }

    //
    // special case 16 bpp vPixelBlend
    //

    if (pAlphaDispatch->pfnGeneralBlend == vPixelBlend)
    {
        if ((pAlphaDispatch->pfnLoadSrcAndConvert == vLoadAndConvertRGB16_555ToBGRA) &&
            (pAlphaDispatch->pfnLoadDstAndConvert == vLoadAndConvertRGB16_555ToBGRA))
        {
            //
            // use direct 16 bpp blend
            //

            pAlphaDispatch->pfnGeneralBlend = vPixelBlend16_555;
            pAlphaDispatch->pfnLoadSrcAndConvert = NULL;
            pAlphaDispatch->pfnLoadDstAndConvert = NULL;
            pAlphaDispatch->pfnConvertAndStore   = NULL;

            //
            // convert blend function from x/255 to y/31
            //

            int ia = pAlphaDispatch->BlendFunction.SourceConstantAlpha;

            ia = (ia * 31 + 128)/255;
            pAlphaDispatch->BlendFunction.SourceConstantAlpha = (BYTE)ia;
        }
        else if ((pAlphaDispatch->pfnLoadSrcAndConvert == vLoadAndConvertRGB16_565ToBGRA) &&
                 (pAlphaDispatch->pfnLoadDstAndConvert == vLoadAndConvertRGB16_565ToBGRA))
        {
            //
            // use direct 16 bpp blend
            //

            pAlphaDispatch->pfnGeneralBlend = vPixelBlend16_565;
            pAlphaDispatch->pfnLoadSrcAndConvert = NULL;
            pAlphaDispatch->pfnLoadDstAndConvert = NULL;
            pAlphaDispatch->pfnConvertAndStore   = NULL;

            //
            // convert blend function from x/255 to y/31
            //

            int ia = pAlphaDispatch->BlendFunction.SourceConstantAlpha;

            ia = (ia * 31 + 128)/255;
            pAlphaDispatch->BlendFunction.SourceConstantAlpha = (BYTE)ia;
        }
    }

    return(TRUE);
}

/******************************Public*Routine******************************\
* WinAlphaDIBBlend
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    12/10/1996 Mark Enstrom [marke]
*
\**************************************************************************/

BOOL
WinAlphaDIBBlend(
    HDC               hdcDst,
    int               DstX,
    int               DstY,
    int               DstCx,
    int               DstCy,
    CONST VOID       *lpBits,
    CONST BITMAPINFO *lpBitsInfo,
    UINT              iUsage,
    int               SrcX,
    int               SrcY,
    int               SrcCx,
    int               SrcCy,
    BLENDFUNCTION     BlendFunction
    )
{
    DIBINFO    dibInfoDst;
    PALINFO    palDst = {NULL,NULL,0};

    PALINFO    palSrc = {NULL,NULL,0};
    DIBINFO    dibInfoSrc;

    BOOL       bRet;
    BOOL       bReadable;
    ALPHA_DISPATCH_FORMAT AlphaDispatch;

    INT OldDstMapMode;

    //
    // init source and dest surface info
    //

    bRet = bInitDIBINFO(hdcDst,DstX,DstY,DstCx,DstCy,&dibInfoDst);

    if (!bRet)
    {
        return(FALSE);
    }

    bRet = bDIBInitDIBINFO((BITMAPINFO *)lpBitsInfo,lpBits,SrcX,SrcY,SrcCx,SrcCy,&dibInfoSrc);

    if (!bRet)
    {
        goto AlphaBlendCleanup;
    }

    //
    // work in MM_TEXT
    //

    OldDstMapMode = SetMapMode(hdcDst,MM_TEXT);

    //
    //
    //

    bSetupBitmapInfos (&dibInfoDst, &dibInfoSrc);

    dibInfoSrc.iUsage = iUsage;

    bRet = bDIBGetSrcDIBits(&dibInfoDst,&dibInfoSrc,SOURCE_ALPHA,0);

    if (!bRet)
    {
        goto AlphaBlendCleanup;
    }

    bRet = bGetDstDIBits(&dibInfoDst,&bReadable,SOURCE_ALPHA);

    if ((!bRet) || (!bReadable) || (dibInfoDst.rclClipDC.left == dibInfoDst.rclClipDC.right))
    {
        goto AlphaBlendCleanup;
    }

    //
    // determine alpha routine
    //

    AlphaDispatch.BlendFunction = BlendFunction;

    bRet = bDetermineAlphaBlendFunction(&dibInfoDst,&dibInfoSrc,&AlphaDispatch);

    if (bRet)
    {
        //
        // initialize palette translate objects
        //

        palSrc.pBitmapInfo = dibInfoSrc.pbmi;
        palDst.pBitmapInfo = dibInfoDst.pbmi;

        bRet = bInitializePALINFO(&palSrc);

        if (!bRet)
        {
            goto AlphaBlendCleanup;
        }

        bRet = bInitializePALINFO(&palDst);

        if (!bRet)
        {
            goto AlphaBlendCleanup;
        }

        //
        // call alpha blending routine
        //

        bRet = AlphaScanLineBlend( (PBYTE)dibInfoDst.pvBase,
                               (PRECTL)&dibInfoDst.rclDIB,
                               dibInfoDst.stride,
                               (PBYTE)dibInfoSrc.pvBase,
                               dibInfoSrc.stride,
                               (PPOINTL)&dibInfoSrc.rclDIB,
                               &palDst,
                               &palSrc,
                               &AlphaDispatch
                               );

        bRet = bSendDIBINFO(hdcDst,&dibInfoDst);
    }

    //
    // release any temp storage
    //

AlphaBlendCleanup:

    vCleanupDIBINFO(&dibInfoDst);
    vCleanupDIBINFO(&dibInfoSrc);
    vCleanupPALINFO(&palSrc);
    vCleanupPALINFO(&palDst);

    SetMapMode(hdcDst,OldDstMapMode);

    return(bRet);
}

/******************************Public*Routine******************************\
* WinAlphaBlend
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    12/10/1996 Mark Enstrom [marke]
*
\**************************************************************************/

BOOL
WinAlphaBlend(
    HDC           hdcDst,
    int           DstX,
    int           DstY,
    int           DstCx,
    int           DstCy,
    HDC           hdcSrc,
    int           SrcX,
    int           SrcY,
    int           SrcCx,
    int           SrcCy,
    BLENDFUNCTION BlendFunction
    )
{
    DIBINFO    dibInfoDst;
    PALINFO    palDst = {NULL,NULL,0};

    PALINFO    palSrc = {NULL,NULL,0};
    DIBINFO    dibInfoSrc;

    BOOL       bRet;
    BOOL       bReadable;
    ALPHA_DISPATCH_FORMAT AlphaDispatch;

    INT OldSrcMapMode,OldDstMapMode;

    //
    // init source and dest surface info
    //

    bRet = bInitDIBINFO(hdcDst,DstX,DstY,DstCx,DstCy,&dibInfoDst);

    if (!bRet)
    {
        return(FALSE);
    }

    bRet = bInitDIBINFO(hdcSrc,SrcX,SrcY,SrcCx,SrcCy,&dibInfoSrc);

    if (!bRet)
    {
        goto AlphaBlendCleanup;
    }

    //
    // Now operate in MM_TEXT mode
    //

    OldSrcMapMode = SetMapMode(hdcSrc,MM_TEXT);

    if (hdcSrc != hdcDst)
    {
        OldDstMapMode = SetMapMode(hdcDst,MM_TEXT);
    }

    bSetupBitmapInfos(&dibInfoDst,&dibInfoSrc);

    //
    // get access to src surface or temp DIB
    //

    bRet = bGetSrcDIBits(&dibInfoDst,&dibInfoSrc,SOURCE_ALPHA, 0);

    if (!bRet)
    {
        goto AlphaBlendCleanup;
    }

    //
    // get access to Dst surface or temp DIB
    //

    bRet = bGetDstDIBits(&dibInfoDst,&bReadable,SOURCE_ALPHA);

    if ((!bRet) || (!bReadable) || (dibInfoDst.rclBounds.left == dibInfoDst.rclBounds.right))
    {
        goto AlphaBlendCleanup;
    }

    //
    // check and simplify blend
    //

    if (
        (BlendFunction.SourceBlend      == AC_ONE) &&
        (BlendFunction.DestinationBlend == AC_ONE_MINUS_SRC_ALPHA)
       )
    {
        BlendFunction.SourceBlend         = AC_SRC_OVER;
        BlendFunction.DestinationBlend    = AC_SRC_OVER;
        BlendFunction.SourceConstantAlpha = (BYTE)255;
    }

    if (
         (BlendFunction.SourceBlend == AC_SRC_OVER)      ||
         (BlendFunction.SourceBlend == AC_SRC_UNDER)     ||
         (BlendFunction.DestinationBlend == AC_SRC_OVER) ||
         (BlendFunction.DestinationBlend == AC_SRC_UNDER)
       )
    {
        //
        // for over and under blend functions, blend functions
        // must be the same
        //

        if (BlendFunction.SourceBlend != BlendFunction.DestinationBlend)
        {
            WARNING("Illegal blend function\n");
            bRet = FALSE;
        }
    }

    AlphaDispatch.BlendFunction = BlendFunction;

    //
    // determine alpha routine
    //

    bRet = bDetermineAlphaBlendFunction(&dibInfoDst,&dibInfoSrc,&AlphaDispatch);

    if (!bRet)
    {
        goto AlphaBlendCleanup;
    }

    //
    // initialize palette translate objects
    //

    palSrc.pBitmapInfo = dibInfoSrc.pbmi;
    palDst.pBitmapInfo = dibInfoDst.pbmi;

    bRet = bInitializePALINFO(&palSrc);

    if (!bRet)
    {
        goto AlphaBlendCleanup;
    }

    bRet = bInitializePALINFO(&palDst);

    if (!bRet)
    {
        goto AlphaBlendCleanup;
    }

    //
    // call alpha blending routine
    //

    bRet = AlphaScanLineBlend( (PBYTE)dibInfoDst.pvBase,
                           (PRECTL)&dibInfoDst.rclDIB,
                           dibInfoDst.stride,
                           (PBYTE)dibInfoSrc.pvBase,
                           dibInfoSrc.stride,
                           (PPOINTL)&dibInfoSrc.rclDIB,
                           &palDst,
                           &palSrc,
                           &AlphaDispatch
                           );
    //
    // write results to screen if needed
    //

    bRet = bSendDIBINFO(hdcDst,&dibInfoDst);

    //
    // release any temp storage
    //

AlphaBlendCleanup:

    vCleanupPALINFO(&palDst);
    vCleanupPALINFO(&palSrc);
    vCleanupDIBINFO(&dibInfoDst);
    vCleanupDIBINFO(&dibInfoSrc);

    //
    // restore DC map modes
    //

    SetMapMode(hdcSrc,OldSrcMapMode);

    if (hdcSrc != hdcDst)
    {
        SetMapMode(hdcDst,OldDstMapMode);
    }

    return(bRet);
}

#endif

/******************************Public*Routine******************************\
* AlphaImage
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    12/3/1996 Mark Enstrom [marke]
*
\**************************************************************************/

BOOL
AlphaBlend(
    HDC           hdcDest,
    int           DstX,
    int           DstY,
    int           DstCx,
    int           DstCy,
    HDC           hSrc,
    int           SrcX,
    int           SrcY,
    int           SrcCx,
    int           SrcCy,
    BLENDFUNCTION BlendFunction
    )
{
    BOOL bRet;

    bRet = gpfnAlphaBlend(hdcDest,DstX,DstY,DstCx,DstCy,hSrc,SrcX,SrcY,SrcCx,SrcCy,BlendFunction);

    return(bRet);
}

/******************************Public*Routine******************************\
* AlphaDIBImage
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    12/3/1996 Mark Enstrom [marke]
*
\**************************************************************************/

BOOL
AlphaDIBBlend(
    HDC               hdcDest,
    int               DstX,
    int               DstY,
    int               DstCx,
    int               DstCy,
    CONST VOID       *lpBits,
    CONST BITMAPINFO *lpBitsInfo,
    UINT              iUsage,
    int               SrcX,
    int               SrcY,
    int               SrcCx,
    int               SrcCy,
    BLENDFUNCTION     BlendFunction
    )
{
    BOOL bRet;
    BOOL bSrcHasAlpha = FALSE;

    //
    // simple validation
    //

    if ((lpBits == NULL) || (lpBitsInfo == NULL))
    {
        return(FALSE);
    }

    //
    // no COREHEADERs
    //

    if (lpBitsInfo->bmiHeader.biSize < sizeof(BITMAPINFOHEADER))
    {
        return(FALSE);
    }

    //
    // check and simplify blend, try to quick out to EngStretchBlt
    //

    if (
        (BlendFunction.SourceBlend      == AC_ONE) &&
        (BlendFunction.DestinationBlend == AC_ONE_MINUS_SRC_ALPHA)
       )
    {
        BlendFunction.SourceBlend         = AC_SRC_OVER;
        BlendFunction.DestinationBlend    = AC_SRC_OVER;
        BlendFunction.SourceConstantAlpha = (BYTE)255;
    }

    //
    // check for quick out
    //

    if (
         (BlendFunction.SourceBlend == AC_SRC_OVER)      ||
         (BlendFunction.DestinationBlend == AC_SRC_OVER)
       )
    {
        PULONG pulMask = (PULONG)((PBYTE)lpBitsInfo + sizeof(BITMAPINFOHEADER));

        //
        // for over and under blend functions, blend functions
        // must be the same
        //

        if (BlendFunction.SourceBlend != BlendFunction.DestinationBlend)
        {
            WARNING1("Illegal blend function\n");
            return(FALSE);
        }

        if (
             (lpBitsInfo->bmiHeader.biBitCount == 32) &&
             (
               (lpBitsInfo->bmiHeader.biCompression == BI_RGB) ||
               (
                 (lpBitsInfo->bmiHeader.biCompression == BI_BITFIELDS) &&
                 (
                   (pulMask[0] == 0xff0000) &&
                   (pulMask[1] == 0x00ff00) &&
                   (pulMask[2] == 0x0000ff)
                 )
               )
             )
           )
        {
            bSrcHasAlpha = TRUE;
        }

        //
        // check for quick out.  !!! should add check for surface
        // format != 32bpp BGR
        //

        if (
             (BlendFunction.SourceConstantAlpha == 255) &&
             ( !bSrcHasAlpha ||
               (BlendFunction.AlphaFormat & AC_SRC_NO_ALPHA)
             )
           )
        {
            bRet = StretchDIBits(
                                 hdcDest,
                                 DstX,
                                 DstY,
                                 DstCx,
                                 DstCy,
                                 SrcX,
                                 SrcY,
                                 SrcCx,
                                 SrcCy,
                                 lpBits,
                                 lpBitsInfo,
                                 iUsage,
                                 SRCCOPY);

            return(bRet);
        }
    }

    bRet = gpfnAlphaDIB(
                      hdcDest,
                      DstX,
                      DstY,
                      DstCx,
                      DstCy,
                      lpBits,
                      lpBitsInfo,
                      iUsage,
                      SrcX,
                      SrcY,
                      SrcCx,
                      SrcCy,
                      BlendFunction
                      );
    return(bRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\image\tmp\dllinit.cxx ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name

   dllinit.cxx

Abstract:



Author:

   Mark Enstrom   (marke)  23-Jun-1996

Enviornment:

   User Mode

Revision History:

--*/

#include "precomp.hxx"
#pragma hdrstop

INT                gbCheckHandleLevel = 0;
OSVERSIONINFO    Win32VersionInformation;

PFNTRANSBLT gpfnTransparentBlt;
PFNTRANSDIB gpfnTransparentDIBits;
PFNGRFILL   gpfnGradientFill;
PFNALPHABLEND gpfnAlphaBlend;
PFNALPHADIB   gpfnAlphaDIB;
//PFN_GETSURFACEFROMDC pfnGetSurfaceFromDC;

extern "C" {
BOOLEAN
DllInitialize(
    PVOID pvDllHandle,
    ULONG ulReason,
    PCONTEXT pcontext
    );
}


/*++

Routine Description:



Arguments



Return Value



--*/


BOOLEAN
DllInitialize(
    PVOID pvDllHandle,
    ULONG ulReason,
    PCONTEXT pcontext)
{
    NTSTATUS status = 0;
    INT i;
    BOOLEAN  fServer;
    PTEB pteb = NtCurrentTeb();
    BOOL bRet = TRUE;
    HMODULE hlib, hddrawlib;

    switch (ulReason)
    {
    case DLL_PROCESS_ATTACH:

        //
        // determine os version
        //

        Win32VersionInformation.dwOSVersionInfoSize = sizeof(Win32VersionInformation);

        if (!GetVersionEx(&Win32VersionInformation))
        {
            //
            // default win95
            //

            Win32VersionInformation.dwPlatformId = VER_PLATFORM_WIN32_WINDOWS;
        }

        //
        // resolve API enrty points
        //

        #if !(_WIN32_WINNT >= 0x500)
        hlib=LoadLibrary (TEXT("gdi32.dll"));

        gpfnTransparentBlt = (PFNTRANSBLT)GetProcAddress (hlib, "GdiTransparentBlt");
        if (!gpfnTransparentBlt)
        {
            gpfnTransparentBlt = WinTransparentBlt;
        }

        gpfnTransparentDIBits = (PFNTRANSDIB)GetProcAddress (hlib, "GdiTransparentDIBits");
        if (!gpfnTransparentDIBits)
        {
            gpfnTransparentDIBits = WinTransparentDIBits;
        }

        gpfnGradientFill = (PFNGRFILL)GetProcAddress (hlib, "GdiGradientFill");
        if (!gpfnGradientFill)
        {
            gpfnGradientFill = WinGradientFill;
        }

        gpfnAlphaBlend = (PFNALPHABLEND)GetProcAddress (hlib, "GdiAlphaBlend");
        if (!gpfnAlphaBlend)
        {
            gpfnAlphaBlend = WinAlphaBlend;
        }

        gpfnAlphaDIB = (PFNALPHADIB)GetProcAddress (hlib, "GdiAlphaDIBBlend");
        if (!gpfnAlphaDIB)
        {
            gpfnAlphaDIB = WinAlphaDIBBlend;
        }

        FreeLibrary(hlib);

        //hddrawlib = GetModuleHandleA("ddraw");

        //pfnGetSurfaceFromDC = (PFN_GETSURFACEFROMDC)GetProcAddress(hddrawlib, "GetSurfaceFromDC");

        #else
            gpfnTransparentBlt = GdiTransparentBlt;
            gpfnTransparentDIBits = GdiTransparentDIBits;
            gpfnGradientFill = GdiGradientFill;
            gpfnAlphaBlend = GdiAlphaBlend;
            gpfnAlphaDIB = GdiAlphaDIBBlend;
        #endif

        #if 0
            gpfnAlphaDIB = WinAlphaDIBBlend;
            gpfnAlphaBlend = WinAlphaBlend;
            gpfnGradientFill = WinGradientFill;
            gpfnTransparentDIBits = WinTransparentDIBits;
            gpfnTransparentBlt = WinTransparentBlt;
        #endif

    case DLL_THREAD_ATTACH:
        break;

   case DLL_PROCESS_DETACH:
   case DLL_THREAD_DETACH:
        break;

    }

    return(bRet);

    pvDllHandle;
    pcontext;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\image\tmp\tricalc.cxx ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name

   trimesh.cxx

Abstract:

    Implement triangle mesh API

Author:

   Mark Enstrom   (marke)  23-Jun-1996

Enviornment:

   User Mode

Revision History:

--*/


#include "precomp.hxx"
#include "dciman.h"
#pragma hdrstop

#if !(_WIN32_WINNT >= 0x500)

//
// temp global
//

HBITMAP hbmDefault;


#if DBG
ULONG   DbgRecord = 0;
#endif

/******************************Public*Routine******************************\
* vHorizontalLine
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    11/20/1996 Mark Enstrom [marke]
*
\**************************************************************************/

inline
VOID
vHorizontalLine(
    PTRIVERTEX    pv1,
    PTRIVERTEX    pv2,
    PTRIANGLEDATA ptData,
    PTRIDDA       ptridda
    )
{
    LONG yPosition = ptridda->N0 >> 4;
    LONG yIndex    = yPosition - ptData->rcl.top;

    ptridda->L = ptridda->M0 >> 4;

    #if DBG
    if (DbgRecord >= 1)
    {
       DbgPrint("vCalculateLine:Horizontal Line: L = 0x%lx, yIndex = 0x%lx\n",ptridda->L,yIndex);
    }
    #endif


    if ((yPosition >= ptData->rcl.top) &&
       (yPosition < ptData->rcl.bottom))
    {
       //
       // find left edge
       //

       if (pv1->x <= pv2->x)
       {
            //
            // left edge
            // !!! is the check necessary? overlap from another
            // line segment.
            //

            ptData->TriEdge[yIndex].xLeft = pv1->x     >> 4;
            ptData->TriEdge[yIndex].Red   = pv1->Red   << 8;
            ptData->TriEdge[yIndex].Green = pv1->Green << 8;
            ptData->TriEdge[yIndex].Blue  = pv1->Blue  << 8;
            ptData->TriEdge[yIndex].Alpha = pv1->Alpha << 8;

            //
            // right edge
            //

            ptData->TriEdge[yIndex].xRight = pv2->x >> 4;
       }
       else
       {
            //
            // left edge
            //

            ptData->TriEdge[yIndex].xLeft = pv2->x     >> 4;
            ptData->TriEdge[yIndex].Red   = pv2->Red   << 8;
            ptData->TriEdge[yIndex].Green = pv2->Green << 8;
            ptData->TriEdge[yIndex].Blue  = pv2->Blue  << 8;
            ptData->TriEdge[yIndex].Alpha = pv2->Alpha << 8;

            //
            // right edge
            //

            ptData->TriEdge[yIndex].xRight = pv1->x >> 4;
        }
    }
}

/******************************Public*Routine******************************\
* vLeftEdgeDDA
*
*   Run line DDA down a left edge of the triangle recording left edge
*   position and color
*
* Arguments:
*
*   NumScanLines
*   yIndex
*   Red
*   Green
*   Blue
*   Alpha
*   L
*   Rb
*
* Return Value:
*
*   None
*
* History:
*
*    11/20/1996 Mark Enstrom [marke]
*
\**************************************************************************/

inline
VOID
vLeftEdgeDDA(
     PTRIANGLEDATA ptData,
     PTRIDDA       ptridda
     )
{
    LONG NumScanLines = ptridda->NumScanLines;
    LONG yIndex       = ptridda->yIndex;
    LONG Red          = ptridda->Red;
    LONG Green        = ptridda->Green;
    LONG Blue         = ptridda->Blue;
    LONG Alpha        = ptridda->Alpha;
    LONG L            = ptridda->L;
    LONG Rb           = ptridda->Rb;

    #if DBG
    if (DbgRecord >= 1)
    {
        DbgPrint("vLeftEdgeDDA:Scan yIndex = %li\n",yIndex);
    }
    #endif

    // Scan all lines, only record lines contained by
    // the clipping in ptData->rcl (y)

    while (NumScanLines--)
    {

        #if DBG
        if (DbgRecord >= 3)
        {
            DbgPrint("vCalculateLine:Scan yIndex = %li\n",yIndex);
            DbgPrint("vCalculateLine:L           = %li\n",L);
            DbgPrint("vCalculateLine:Rb          = %li\n",Rb);
        }
        #endif

        // record left edge

        if (yIndex >= 0)
        {
            ptData->TriEdge[yIndex].xLeft = L;
            ptData->TriEdge[yIndex].Red   = Red;
            ptData->TriEdge[yIndex].Green = Green;
            ptData->TriEdge[yIndex].Blue  = Blue;
            ptData->TriEdge[yIndex].Alpha = Alpha;
        }

        // inc y by one scan line, inc x(L) by integer step
        // and inc error term by dR

        yIndex++;
        L  += ptridda->dL;
        Rb -= ptridda->dR;

        // inc color components by y and integer x components

        Red   += (ptridda->dxyRed);
        Green += (ptridda->dxyGreen);
        Blue  += (ptridda->dxyBlue);
        Alpha += (ptridda->dxyAlpha);

        // check for DDA error term overflow, add one
        // more step in x if true, and correct error term

        if (Rb < 0)
        {
            // DDA

            L     += ptridda->Linc;
            Rb    += ptridda->dN;

            // inc color components

            Red   += ptData->dRdX;
            Green += ptData->dGdX;
            Blue  += ptData->dBdX;
            Alpha += ptData->dAdX;
        }
    }
}

/******************************Public*Routine******************************\
* vRightEdgeDDA
*
*   Run the line DDA along the right edge of the triangle recording right
*   edge position
*
* Arguments:
*
*   NumScanLines
*   yIndex
*   Red
*   Green
*   Blue
*   Alpha
*   L
*   Rb
*
* Return Value:
*
*   None
*
* History:
*
*    11/25/1996 Mark Enstrom [marke]
*
\**************************************************************************/

inline
VOID
vRightEdgeDDA(
     PTRIANGLEDATA ptData,
     PTRIDDA       ptridda
     )
{
    LONG NumScanLines = ptridda->NumScanLines;
    LONG yIndex       = ptridda->yIndex;
    LONG Red          = ptridda->Red;
    LONG Green        = ptridda->Green;
    LONG Blue         = ptridda->Blue;
    LONG Alpha        = ptridda->Alpha;
    LONG L            = ptridda->L;
    LONG Rb           = ptridda->Rb;

    // Scan all lines, only record lines contained by
    // the clipping in ptData->rcl (y)

    #if DBG
    if (DbgRecord >= 1)
    {
        DbgPrint("vRightEdgeDDA:Scan yIndex = %li\n",yIndex);
    }
    #endif

    while (ptridda->NumScanLines--)
    {
        #if DBG
        if (DbgRecord >= 3)
        {
            DbgPrint("vCalculateLine:Scan yIndex = %li\n",yIndex);
            DbgPrint("vCalculateLine:L           = %li\n",L);
            DbgPrint("vCalculateLine:Rb          = %li\n",Rb);
        }
        #endif

        // record left, right edge

        if (yIndex >= 0)
        {
            ptData->TriEdge[yIndex].xRight = L;
        }

        // inc y by one scan line, inc x(L) by integer step
        // and inc error term by dR

        yIndex++;
        L  += ptridda->dL;
        Rb -= ptridda->dR;

        // inc color components by y and integer x components

        Red   += (ptridda->dxyRed);
        Green += (ptridda->dxyGreen);
        Blue  += (ptridda->dxyBlue);
        Alpha += (ptridda->dxyAlpha);

        // check for DDA error term overflow, add one
        // more step in x if true, and correct error term

        if (Rb < 0)
        {
            // DDA

            L     += ptridda->Linc;
            Rb    += ptridda->dN;

            // inc color components

            Red   += ptData->dRdX;
            Green += ptData->dGdX;
            Blue  += ptData->dBdX;
            Alpha += ptData->dAdX;
        }
    }
}

/******************************Public*Routine******************************\
* vCalulateLine
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    11/20/1996 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vCalculateLine(
    PTRIVERTEX      pv1,
    PTRIVERTEX      pv2,
    PTRIANGLEDATA   ptData,
    BOOL            bLeftEdge
    )
{
    TRIDDA tridda;

    //
    // initial y component
    //

    tridda.dxyRed   = ptData->dRdY;
    tridda.dxyGreen = ptData->dGdY;
    tridda.dxyBlue  = ptData->dBdY;
    tridda.dxyAlpha = ptData->dAdY;

    #if DBG
    if (DbgRecord >= 1)
    {
        DbgPrint("vCalculateLine:\n");
        DbgPrint("vCalculateLine:pv1.x    = %li, pv1.y = %li\n",pv1->x,pv1->y);
        DbgPrint("vCalculateLine:pv1->Red = 0x%lx, pv1->Green = 0x%lx, pv1->Blue = 0x%lx\n",
                            pv1->Red,pv1->Green,pv1->Blue);
        DbgPrint("vCalculateLine:pv2.x    = %li, pv2.y = %li\n",pv2->x,pv2->y);
        DbgPrint("vCalculateLine:pv2->Red = 0x%lx, pv2->Green = 0x%lx, pv2->Blue = 0x%lx\n",
                            pv2->Red,pv2->Green,pv2->Blue);
    }
    #endif

    //
    // Arrange lines, must run in positive delta y.
    // !!! what other effect of swap is there? !!!
    //

    if (pv2->y >= pv1->y)
    {
        tridda.dN      = pv2->y - pv1->y;
        tridda.dM      = pv2->x - pv1->x;
        tridda.N0      = pv1->y;
        tridda.M0      = pv1->x;
        tridda.Red     = pv1->Red   << 8;
        tridda.Green   = pv1->Green << 8;
        tridda.Blue    = pv1->Blue  << 8;
        tridda.Alpha   = pv1->Alpha << 8;
    }
    else
    {
        tridda.dN       = pv1->y - pv2->y;
        tridda.dM       = pv1->x - pv2->x;
        tridda.N0       = pv2->y;
        tridda.M0       = pv2->x;
        tridda.Red      = pv2->Red   << 8;
        tridda.Green    = pv2->Green << 8;
        tridda.Blue     = pv2->Blue  << 8;
        tridda.Alpha    = pv2->Alpha << 8;
        tridda.dxyRed   = -tridda.dxyRed;
        tridda.dxyGreen = -tridda.dxyGreen;
        tridda.dxyBlue  = -tridda.dxyBlue;
        tridda.dxyAlpha = -tridda.dxyAlpha;
    }

    //
    // Check for horizontal line, dN == 0 is a horizontal line.
    // In this case just record the end points.
    //

    if (tridda.dN == 0)
    {
        vHorizontalLine(pv1,pv2,ptData,&tridda);
    }
    else
    {
        //
        // this is as cryptic as ASM at the moment
        //

        LONG l0,Frac;

        tridda.Linc = 1;

        //
        // yIndex is the offset into the edge array for
        // the current line
        //

        tridda.yIndex = (tridda.N0 >> 4) - ptData->y0;

        tridda.NumScanLines = (tridda.dN >> 4);

        LONG NMax   = (tridda.N0 >> 4) + tridda.NumScanLines;

        //
        // make sure scan lines do not overrun buffer due to
        // clipping
        //

        if (
            ((tridda.N0 >> 4) > ptData->rcl.bottom) ||
            (NMax < ptData->rcl.top)
           )
        {
            // nothing to draw
            return;
        }
        else if (NMax > ptData->rcl.bottom)
        {
            tridda.NumScanLines = tridda.NumScanLines - (NMax - ptData->rcl.bottom);
        }

        tridda.j = tridda.N0 >> 4;

        tridda.C = ((LONGLONG)tridda.M0 * (LONGLONG)tridda.dN) - ((LONGLONG)tridda.N0 * (LONGLONG)tridda.dM) -1;

        tridda.C = (tridda.C >> 4) + tridda.dN;

        LONGLONG LongL;

        if (tridda.dM > 0)
        {
            tridda.dL = tridda.dM / tridda.dN;
            tridda.dR = tridda.dM - tridda.dL * tridda.dN;
        }
        else if (tridda.dM < 0)
        {
            // negative divide

            LONG dLQ,dLR;

            tridda.dM = -tridda.dM;

            dLQ = (tridda.dM - 1) / tridda.dN;
            dLR = tridda.dM - 1 - (dLQ * tridda.dN);
            tridda.dL  = -(dLQ + 1);
            tridda.dR  = tridda.dN - dLR - 1;
        }
        else
        {
            // dM = 0
            tridda.dL = 0;
            tridda.dR = 0;
        }

        l0 = tridda.j * tridda.dL;
        LongL  = tridda.j * tridda.dR + tridda.C;

        if (LongL > 0)
        {
            Frac = (LONG)(LongL/tridda.dN);            // integer portion
        }
        else if (LongL < 0)
        {
            LONG Q = (LONG)((-LongL - 1)/tridda.dN);
            Frac = -(Q + 1);
        }
        else
        {
            Frac = 0;
        }

        tridda.R  = (LONG)(LongL - (Frac * tridda.dN));
        tridda.L  = l0 + Frac;
        tridda.Rb = tridda.dN - tridda.R - 1;

        //
        // Calculate color steps for dx !!! could it be more expensive !!!
        //

        if (tridda.dL != 0)
        {
            tridda.dxyRed   = tridda.dxyRed   + (LONG)((ptData->dRdXA * tridda.dL) / ptData->Area);
            tridda.dxyGreen = tridda.dxyGreen + (LONG)((ptData->dGdXA * tridda.dL) / ptData->Area);
            tridda.dxyBlue  = tridda.dxyBlue  + (LONG)((ptData->dBdXA * tridda.dL) / ptData->Area);
            tridda.dxyAlpha = tridda.dxyAlpha + (LONG)((ptData->dAdXA * tridda.dL) / ptData->Area);
        }

        #if DBG
        if (DbgRecord >= 1)
        {
            LONG CL = (LONG)tridda.C;
            LONG CH = (LONG)(tridda.C/4294967296);
            DbgPrint("vCalculateLine:Normal Line\n");
            DbgPrint("vCalculateLine:N0        = %li\n",tridda.N0);
            DbgPrint("vCalculateLine:dN        = %li\n",tridda.dN);
            DbgPrint("vCalculateLine:M0        = %li\n",tridda.M0);
            DbgPrint("vCalculateLine:dM        = %li\n",tridda.dM);
            DbgPrint("vCalculateLine:C         = %08lx %08lx\n",CH,CL);
            DbgPrint("vCalculateLine:Frac      = %li\n",Frac);
            DbgPrint("vCalculateLine:l0        = %li\n",l0);
            DbgPrint("vCalculateLine:L         = %li\n",tridda.L);
            DbgPrint("vCalculateLine:dL        = %li\n",tridda.dL);
            DbgPrint("vCalculateLine:R         = %li\n",tridda.R);
            DbgPrint("vCalculateLine:dR        = %li\n",tridda.dR);
            DbgPrint("vCalculateLine:Rb        = %li\n",tridda.Rb);
            DbgPrint("vCalculateLine:dxyRed    = 0x%lx\n",tridda.dxyRed);
            DbgPrint("vCalculateLine:dxyGreen  = 0x%lx\n",tridda.dxyGreen);
            DbgPrint("vCalculateLine:dxyBlue   = 0x%lx\n",tridda.dxyBlue);
            DbgPrint("vCalculateLine:dxyAlpha  = 0x%lx\n",tridda.dxyAlpha);


        }
        #endif

        //
        // left or right edge
        //

        if (bLeftEdge)
        {
            vLeftEdgeDDA(ptData,&tridda);
        }
        else
        {
            vRightEdgeDDA(ptData,&tridda);
        }
    }
}

/******************************Public*Routine******************************\
* vCalulateColorGradient
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    11/20/1996 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vCalulateColorGradient(
    PTRIVERTEX      pv0,
    PTRIVERTEX      pv1,
    PTRIVERTEX      pv2,
    LONG            C0,
    LONG            C1,
    LONG            C2,
    PLONGLONG       pArea,
    PLONGLONG       pGradXA,
    PLONG           pGradX,
    PLONG           pGradY
    )
{
    LONG dCdX = 0;
    LONG dCdY = 0;
    LONGLONG t1,t2,t3,tAll;

    C0 = C0 << 8;
    C1 = C1 << 8;
    C2 = C2 << 8;

    //
    // dY
    //

    t1   = - ((LONGLONG)C0 * (LONGLONG)(pv2->x - pv1->x));
    t2   = - ((LONGLONG)C1 * (LONGLONG)(pv0->x - pv2->x));
    t3   = - ((LONGLONG)C2 * (LONGLONG)(pv1->x - pv0->x));
    tAll = 16 * (t1 + t2 + t3);

    if (tAll > 0)
    {
        dCdY = (LONG)(tAll / *pArea);
    }
    else if (tAll < 0)
    {
        tAll = -tAll;
        dCdY = (LONG)((tAll - 1) / *pArea);
        dCdY = -(dCdY + 1);
    }

    *pGradY = dCdY;

    //
    // Divide by area to get single step x. Keep undivided
    // value around to calc multiple integer step in x
    //


    t1   = - ((LONGLONG)C0 * (LONGLONG)(pv2->y - pv1->y));
    t2   = - ((LONGLONG)C1 * (LONGLONG)(pv0->y - pv2->y));
    t3   = - ((LONGLONG)C2 * (LONGLONG)(pv1->y - pv0->y));
    tAll = t1;
    tAll += t2;
    tAll += t3;
    tAll *= 16;

    *pGradXA = tAll;

    dCdX = 0;

    if (tAll > 0)
    {
        dCdX = (LONG)(tAll / *pArea);
    }
    else if (tAll < 0)
    {
        tAll = -tAll;
        dCdX = (LONG)((tAll - 1) / *pArea);
        dCdX = -(dCdX + 1);
    }

    *pGradX = dCdX;
}

/******************************Public*Routine******************************\
* vCalculateTriangle
*
*   Calculate color gradients, then scan the three lines that make up the
*   triangle. Fill out a structure that can later be used to fill in the
*   interior of the triangle.
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    17-Jul-1996 -by- Mark Enstrom [marke]
*
\**************************************************************************/

BOOL
bCalculateTriangle(
    PTRIVERTEX      pv0,
    PTRIVERTEX      pv1,
    PTRIVERTEX      pv2,
    PTRIANGLEDATA   ptData
    )
{
    LONG index;

    #if DBG
    if (DbgRecord >= 1)
    {
        DbgPrint("vCalculateTriangle:\n");
        DbgPrint("vCalculateTriangle:rcl = [%li,%li] to [%li,%li]\n",
                            ptData->rcl.left,
                            ptData->rcl.top,
                            ptData->rcl.right,
                            ptData->rcl.bottom
                            );
        DbgPrint("vCalculateTriangle:pv0.x = %li, pv0.y = %li\n",pv0->x,pv0->y);
        DbgPrint("vCalculateTriangle:pv0->Red = 0x%lx, pv0->Green = 0x%lx, pv0->Blue = 0x%lx\n",
                            pv0->Red,pv0->Green,pv0->Blue);
        DbgPrint("vCalculateTriangle:pv1.x = %li, pv1.y = %li\n",pv1->x,pv1->y);
        DbgPrint("vCalculateTriangle:pv1->Red = 0x%lx, pv1->Green = 0x%lx, pv1->Blue = 0x%lx\n",
                            pv1->Red,pv1->Green,pv1->Blue);
        DbgPrint("vCalculateTriangle:pv2.x = %li, pv2.y = %li\n",pv2->x,pv2->y);
        DbgPrint("vCalculateTriangle:pv2->Red = 0x%lx, pv2->Green = 0x%lx, pv2->Blue = 0x%lx\n",
                            pv2->Red,pv2->Green,pv2->Blue);

    }
    #endif

    //
    // calc area, color gradients in x,y
    //
    // area = (v2-v0) X (v1 - v2)
    //

    LONGLONG v12x = pv1->x - pv2->x;
    LONGLONG v12y = pv1->y - pv2->y;

    LONGLONG v02x = pv0->x - pv2->x;
    LONGLONG v02y = pv0->y - pv2->y;

    LONGLONG Area = (v12y * v02x) - (v12x * v02y);
    ptData->Area = Area;

    #if DBG
    if (DbgRecord >= 1)
    {
        LONG AreaL = (LONG)Area;
        LONG AreaH = (LONG)(Area/4294967296);
        DbgPrint("vCalculateTriangle:v12x = %lx\n",v12x);
        DbgPrint("vCalculateTriangle:v12y = %lx\n",v12y);
        DbgPrint("vCalculateTriangle:v02x = %lx\n",v02x);
        DbgPrint("vCalculateTriangle:v02y = %lx\n",v02y);
        DbgPrint("vCalculateTriangle:Area = %lx %lx\n",AreaH,AreaL);
    }
    #endif

    //
    // if area is zero then this is a degenerate triangle
    //

    if (Area == 0)
    {
        return(FALSE);
    }

    //
    // calc min and max drawing y
    //

    ptData->y0   = MAX((pv0->y >> 4),ptData->rcl.top);
    LONG MaxY    = (MAX(pv1->y,pv2->y)) >> 4;
    ptData->y1   = MIN(MaxY,ptData->rcl.bottom);

    //
    // calculate color gradients for each color. There is a little redundant
    // work here with calculation of deltas. Should make this one call or
    // do it in place.
    //

    vCalulateColorGradient(pv0,pv1,pv2,pv0->Red  ,pv1->Red  ,pv2->Red  ,&Area,&ptData->dRdXA,&ptData->dRdX,&ptData->dRdY);
    vCalulateColorGradient(pv0,pv1,pv2,pv0->Green,pv1->Green,pv2->Green,&Area,&ptData->dGdXA,&ptData->dGdX,&ptData->dGdY);
    vCalulateColorGradient(pv0,pv1,pv2,pv0->Blue ,pv1->Blue ,pv2->Blue ,&Area,&ptData->dBdXA,&ptData->dBdX,&ptData->dBdY);
    vCalulateColorGradient(pv0,pv1,pv2,pv0->Alpha,pv1->Alpha,pv2->Alpha,&Area,&ptData->dAdXA,&ptData->dAdX,&ptData->dAdY);

    #if DBG
    if (DbgRecord >= 1)
    {
        DbgPrint("vCalculateTriangle:dRdx = 0x%lx,dRdy = 0x%lx\n",ptData->dRdX,ptData->dRdY);
        DbgPrint("vCalculateTriangle:dGdx = 0x%lx,dGdy = 0x%lx\n",ptData->dGdX,ptData->dGdY);
        DbgPrint("vCalculateTriangle:dBdx = 0x%lx,dBdy = 0x%lx\n",ptData->dBdX,ptData->dBdY);
        DbgPrint("vCalculateTriangle:dAdx = 0x%lx,dAdy = 0x%lx\n",ptData->dAdX,ptData->dAdY);
    }
    #endif

    //
    // draw lines into data array
    //

    vCalculateLine(pv0,pv1,ptData,FALSE);
    vCalculateLine(pv1,pv2,ptData,(pv1->y > pv2->y));
    vCalculateLine(pv2,pv0,ptData,TRUE);

    return(TRUE);
}

/**************************************************************************\
* bCalculateTriangle
*   
*   
* Arguments:
*   
*
*
* Return Value:
*
*
*
* History:
*
*    2/12/1997 Mark Enstrom [marke]
*
\**************************************************************************/

BYTE
GetNearestEntry(
        PULONG   prgbIn,
        ULONG    ulNumEntries,
        ALPHAPIX MatchColor
        )
{
    LONG   lError = MAX_INT;
    ULONG  ulBest = 0;
    ULONG  ulIndex;
    LPRGBQUAD prgb = (LPRGBQUAD)prgbIn;

    for (ulIndex=0;ulIndex<ulNumEntries;ulIndex++)
    {
        LONG eRed   = (LONG)(MatchColor.pix.r - prgb->rgbRed);
        LONG eGreen = (LONG)(MatchColor.pix.g - prgb->rgbGreen);
        LONG eBlue  = (LONG)(MatchColor.pix.b - prgb->rgbBlue);

        eRed = eRed*eRed + eGreen*eGreen + eBlue*eBlue;

        if (eRed < lError)
        {
            lError = eRed;
            ulBest = ulIndex;
        }

        prgb++;
    }

    return((BYTE)ulBest);
}


/**************************************************************************\
* GenColorXform332
*   
*   
* Arguments:
*   
*
*
* Return Value:
*
*
*
* History:
*
*    2/12/1997 Mark Enstrom [marke]
*
\**************************************************************************/
PBYTE
pGenColorXform332(
    PULONG ppalIn,
    ULONG  ulNumEntries
    )
{
    ASSERTGDI((ppalIn != NULL),"pGenColorXform332 called with NULL input palette\n");
    ASSERTGDI((ulNumEntries <= 256),"pGenColorXform332 called with invalid ulNumEntries\n");

    if ((ppalIn == NULL) || (ulNumEntries > 256))
    {
        return(FALSE);
    }

    //
    // check for halftone palette
    //

    if (ulNumEntries == 256)
    {
        if (bIsHalftonePalette(ppalIn))
        {
            return(gHalftoneColorXlate332);
        }
    }

    //
    // allocate and generate color lookup table
    //

    PBYTE pxlate = (PBYTE)LOCALALLOC(256);

    if (pxlate)
    {
        PBYTE pXlateTable = pxlate;

        //
        // generate color xlate from RGB 332 to palette
        //
    
        BYTE Red[8]   = {0,37,73,110,146,183,219,255};
        BYTE Green[8] = {0,37,73,110,146,183,219,255};
        BYTE Blue[4]  = {0,85,171,255};
    
        //
        // ppalOut must be a 256 entry table
        //
    
        ULONG    ulB,ulG,ulR;
        ALPHAPIX Pixel;
    
        for (ulR = 0;ulR<8;ulR++)
        {
            Pixel.pix.r = Red[ulR];
    
            for (ulG = 0;ulG<8;ulG++)
            {
                Pixel.pix.g = Green[ulG];
    
                for (ulB = 0;ulB<4;ulB++)
                {
                    Pixel.pix.b = Blue[ulB];
                    *pXlateTable++ = GetNearestEntry(ppalIn,ulNumEntries,Pixel);
                }
            }
        }
    }

    return(pxlate);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\inc\dbgext.h ===
/******************************Module*Header*******************************\
* Module Name: dbgext.h
*
* Created: 10-Sep-1993 08:36:42
* Author:  Eric Kutter [erick]
*
* Copyright (c) 1993-1999 Microsoft Corporation
*
* Dependencies:
*
* common macros for debugger extensions
*
*
\**************************************************************************/


/**************************************************************************\
 *
 * GetAddress - symbol of another module
 *
\**************************************************************************/

#define GetAddress(dst, src)                                                    \
try {                                                                           \
    char *pj = (char *)(src);                                                   \
/* if it is NTSD, don't want the trailing & */                                  \
    if ((lpExtensionApis->nSize < sizeof(WINDBG_EXTENSION_APIS)) &&             \
        (*pj == '&'))                                                           \
    {                                                                           \
        pj++;                                                                   \
    }                                                                           \
    *((ULONG *) &dst) = EvalExpression(pj);                                                   \
} except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ?                    \
            EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH) {            \
    Print("NTSD: Access violation on \"%s\", switch to server context\n", src); \
    return;                                                                     \
}

#define GetValue(dst,src)                                                       \
    GetAddress(dst,src)                                                         \
    if (TRUE || lpExtensionApis->nSize < sizeof(WINDBG_EXTENSION_APIS))                 \
    {                                                                           \
        move(dst,dst);                                                          \
    }

/**************************************************************************\
 *
 * move(dst, src ptr)
 *
\**************************************************************************/

#define move(dst, src)                                              \
try {                                                               \
    if (lpExtensionApis->nSize >= sizeof(WINDBG_EXTENSION_APIS))    \
    {                                                               \
        (*lpExtensionApis->lpReadProcessMemoryRoutine)(             \
             (DWORD) (src), &(dst), sizeof(dst), NULL);             \
    } else                                                          \
    {                                                               \
        NtReadVirtualMemory(hCurrentProcess, (LPVOID) (src), &(dst), sizeof(dst), NULL);\
    }                                                               \
                                                                    \
} except (EXCEPTION_EXECUTE_HANDLER) {                              \
    Print("exception in move()\n");                                 \
    return;                                                         \
}

/**************************************************************************\
 *
 * move2(dst ptr, src ptr, num bytes)
 *
\**************************************************************************/

#define move2(dst, src,bytes)                                       \
try {                                                               \
    if (lpExtensionApis->nSize >= sizeof(WINDBG_EXTENSION_APIS))    \
    {                                                               \
        (*lpExtensionApis->lpReadProcessMemoryRoutine)(             \
             (DWORD) (src), (dst), (bytes), NULL);                  \
    } else                                                          \
    {                                                               \
        NtReadVirtualMemory(hCurrentProcess, (LPVOID) (src), (dst), (bytes), NULL);\
    }                                                               \
                                                                    \
} except (EXCEPTION_EXECUTE_HANDLER) {                              \
    Print("exception in move2()\n");                                \
    return;                                                         \
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\image\tmp\trimesh.cxx ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name

   trimesh.cxx

Abstract:

    Implement triangle mesh API

Author:

   Mark Enstrom   (marke)  23-Jun-1996

Enviornment:

   User Mode

Revision History:

--*/


#include "precomp.hxx"
#include "dciman.h"
#pragma hdrstop

extern PFNGRFILL gpfnGradientFill;

#if !(_WIN32_WINNT >= 0x500)

/**************************************************************************\
*   gulDither32 - 4-4 dither matrix
*
*
* History:
*
*    1/31/1997 Mark Enstrom [marke]
*
\**************************************************************************/

ULONG gulDither32[] =
{
    0x00000000,
    0x00008000,
    0x00002000,
    0x0000a000,

    0x0000c000,
    0x00004000,
    0x0000e000,
    0x00006000,

    0x00003000,
    0x0000b000,
    0x00001000,
    0x00009000,

    0x0000f000,
    0x00007000,
    0x0000d000,
    0x00005000
};

/******************************Public*Routine******************************\
* vFillTriDIBUnreadable
*
*   If a surface can't be read, draw triangle to a scan line, then call
*   SetDIBitsToDevice on each scan line
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    11/21/1996 Mark Enstrom [marke]
*
\**************************************************************************/


VOID
vFillTriDIBUnreadable(
    PDIBINFO      pDibInfo,
    PTRIANGLEDATA ptData
    )
{
    LONG     lDelta = pDibInfo->stride;
    LONG     yScan  = ptData->y0;
    LONG     yScanBottom;
    LONG     cxClip = ptData->rcl.right - ptData->rcl.left;
    PTRIEDGE pEdge  = &ptData->TriEdge[0];
    LONG     dRed   = ptData->dRdX;
    LONG     dGreen = ptData->dGdX;
    LONG     dBlue  = ptData->dBdX;
    LONG     dAlpha = ptData->dAdX;
    ULONG    Red;
    ULONG    Green;
    ULONG    Blue;
    ULONG    Alpha;
    BITMAPINFO bmi;

    bmi.bmiHeader.biSize            = sizeof(BITMAPINFOHEADER);
    bmi.bmiHeader.biWidth           = cxClip;
    bmi.bmiHeader.biHeight          = 1;
    bmi.bmiHeader.biPlanes          = 1;
    bmi.bmiHeader.biBitCount        = 32;
    bmi.bmiHeader.biCompression     = BI_RGB;
    bmi.bmiHeader.biSizeImage       = 0;
    bmi.bmiHeader.biXPelsPerMeter   = 0;
    bmi.bmiHeader.biYPelsPerMeter   = 0;
    bmi.bmiHeader.biClrUsed         = 0;
    bmi.bmiHeader.biClrImportant    = 0;

    PBYTE pDst = (PBYTE)LOCALALLOC(4 * cxClip);

    if (pDst == NULL)
    {
        return;
    }

    yScanBottom = MIN(ptData->rcl.bottom,ptData->y1);

    while(yScan < yScanBottom)
    {
        PULONG pulDstX;
        PULONG pulDstScanRight,pulDstScanLeft;
        LONG   xScanRight;
        LONG   xScanLeft;

        Red   = pEdge->Red;
        Green = pEdge->Green;
        Blue  = pEdge->Blue;
        Alpha = pEdge->Alpha;

        xScanLeft  = MAX(pEdge->xLeft,ptData->rcl.left);
        xScanRight = MIN(pEdge->xRight,ptData->rcl.right);

        if (xScanLeft < xScanRight)
        {
            pulDstX           = (PULONG)pDst + xScanLeft  - ptData->rcl.left;
            pulDstScanRight   = (PULONG)pDst + xScanRight - ptData->rcl.left;

            //
            // skip span from left edge scan to left edge clip rect
            //

            LONG GradientLeft = ptData->rcl.left - pEdge->xLeft;

            if (GradientLeft > 0)
            {
                Red   += dRed   * GradientLeft;
                Green += dGreen * GradientLeft;
                Blue  += dBlue  * GradientLeft;
                Alpha += dAlpha * GradientLeft;
            }

            //
            // fill span within clipping boundary
            //

            while (pulDstX < pulDstScanRight)
            {
                *pulDstX = ((Alpha & 0x00ff0000) <<  8) |
                           ((Red   & 0x00ff0000)      ) |
                           ((Green & 0x00ff0000) >>  8) |
                           ((Blue  & 0x00ff0000) >> 16);

                pulDstX++;
                Red   += dRed;
                Green += dGreen;
                Blue  += dBlue;
                Alpha += dAlpha;
            }

            //
            // write span to device
            //

            SetDIBitsToDevice(pDibInfo->hdc,
                              xScanLeft,
                              yScan,
                              xScanRight-xScanLeft,
                              1,
                              xScanLeft-ptData->rcl.left,
                              0,
                              0,
                              1,
                              pDst,
                              &bmi,
                              DIB_RGB_COLORS
                              );
        }

        pEdge++;
        yScan++;
    }
}

/******************************Public*Routine******************************\
* vFillTriDIB32BGRA
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    11/21/1996 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vFillTriDIB32BGRA(
    PDIBINFO      pDibInfo,
    PTRIANGLEDATA ptData
    )
{
    LONG     lDelta = pDibInfo->stride;
    LONG     yScan  = ptData->y0;
    LONG     yScanBottom;
    PBYTE    pDst   = (PBYTE)pDibInfo->pvBase + lDelta * yScan;
    PTRIEDGE pEdge  = &ptData->TriEdge[0];
    LONG     dRed   = ptData->dRdX;
    LONG     dGreen = ptData->dGdX;
    LONG     dBlue  = ptData->dBdX;
    LONG     dAlpha = ptData->dAdX;
    ULONG    Red;
    ULONG    Green;
    ULONG    Blue;
    ULONG    Alpha;

    yScanBottom = MIN(ptData->rcl.bottom,ptData->y1);

    while(yScan < yScanBottom)
    {
        PULONG pulDstX;
        PULONG pulDstScanRight,pulDstScanLeft;

        Red   = pEdge->Red;
        Green = pEdge->Green;
        Blue  = pEdge->Blue;
        Alpha = pEdge->Alpha;

        LONG xScanLeft  = MAX(pEdge->xLeft,ptData->rcl.left);
        LONG xScanRight = MIN(pEdge->xRight,ptData->rcl.right);

        if (xScanLeft < xScanRight)
        {
            pulDstX         = (PULONG)pDst + xScanLeft;
            pulDstScanRight = (PULONG)pDst + xScanRight;

            //
            // skip pixels from left edge to left clip, while
            // incrementing gradient
            //

            LONG GradientLeft = ptData->rcl.left - pEdge->xLeft;

            if (GradientLeft > 0)
            {
                Red   += dRed   * GradientLeft;
                Green += dGreen * GradientLeft;
                Blue  += dBlue  * GradientLeft;
                Alpha += dAlpha * GradientLeft;
            }

            //
            // fill span
            //

            while (pulDstX < pulDstScanRight)
            {
                *pulDstX = ((Alpha & 0x00ff0000) <<  8) |
                           ((Red   & 0x00ff0000)      ) |
                           ((Green & 0x00ff0000) >>  8) |
                           ((Blue  & 0x00ff0000) >> 16);

                pulDstX++;
                Red   += dRed;
                Green += dGreen;
                Blue  += dBlue;
                Alpha += dAlpha;
            }
        }

        pDst += lDelta;
        pEdge++;
        yScan++;
    }
}

/******************************Public*Routine******************************\
* vFillTriDIB32RGB
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    11/21/1996 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vFillTriDIB32RGB(
    PDIBINFO      pDibInfo,
    PTRIANGLEDATA ptData
    )
{
    LONG     lDelta = pDibInfo->stride;
    LONG     yScan  = ptData->y0;
    LONG     yScanBottom;
    PBYTE    pDst   = (PBYTE)pDibInfo->pvBase + lDelta * yScan;
    PTRIEDGE pEdge  = &ptData->TriEdge[0];
    LONG     dRed   = ptData->dRdX;
    LONG     dGreen = ptData->dGdX;
    LONG     dBlue  = ptData->dBdX;
    ULONG    Red;
    ULONG    Green;
    ULONG    Blue;

    yScanBottom = MIN(ptData->rcl.bottom,ptData->y1);

    while(yScan < yScanBottom)
    {
        PULONG pulDstX;
        PULONG pulDstScanRight,pulDstScanLeft;

        Red   = pEdge->Red;
        Green = pEdge->Green;
        Blue  = pEdge->Blue;

        LONG xScanLeft  = MAX(pEdge->xLeft,ptData->rcl.left);
        LONG xScanRight = MIN(pEdge->xRight,ptData->rcl.right);

        if (xScanLeft < xScanRight)
        {
            pulDstX           = (PULONG)pDst + xScanLeft;
            pulDstScanRight   = (PULONG)pDst + xScanRight;

            //
            // skip pixels from left edge to left clip, while
            // incrementing gradient
            //

            LONG GradientLeft = ptData->rcl.left - pEdge->xLeft;

            if (GradientLeft > 0)
            {
                Red   += dRed   * GradientLeft;
                Green += dGreen * GradientLeft;
                Blue  += dBlue  * GradientLeft;
            }

            //
            // fill scan
            //

            while (pulDstX < pulDstScanRight)
            {
                *pulDstX = ((Red   & 0x00ff0000))       |
                           ((Green & 0x00ff0000) >>  8) |
                           ((Blue  & 0x00ff0000) >> 16);

                pulDstX++;
                Red   += dRed;
                Green += dGreen;
                Blue  += dBlue;
            }
        }

        pDst += lDelta;
        pEdge++;
        yScan++;
    }
}

/******************************Public*Routine******************************\
* vFillTriDIB24RGB
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    11/21/1996 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vFillTriDIB24RGB(
    PDIBINFO      pDibInfo,
    PTRIANGLEDATA ptData
    )
{
    LONG     lDelta = pDibInfo->stride;
    LONG     yScan  = ptData->y0;
    LONG     yScanBottom;
    PBYTE    pDst   = (PBYTE)pDibInfo->pvBase + lDelta * yScan;
    PTRIEDGE pEdge  = &ptData->TriEdge[0];
    LONG     dRed   = ptData->dRdX;
    LONG     dGreen = ptData->dGdX;
    LONG     dBlue  = ptData->dBdX;
    ULONG    Red;
    ULONG    Green;
    ULONG    Blue;

    yScanBottom = MIN(ptData->rcl.bottom,ptData->y1);

    while(yScan < yScanBottom)
    {
        PBYTE pDstX;
        PBYTE pDstScanRight;

        Red   = pEdge->Red;
        Green = pEdge->Green;
        Blue  = pEdge->Blue;

        LONG xScanLeft  = MAX(pEdge->xLeft,ptData->rcl.left);
        LONG xScanRight = MIN(pEdge->xRight,ptData->rcl.right);

        if (xScanLeft < xScanRight)
        {
            pDstX             = pDst + 3 * xScanLeft;
            pDstScanRight     = pDst + 3 * xScanRight;

            //
            // skip pixels from left edge to left clip, while
            // incrementing gradient
            //

            LONG GradientLeft = ptData->rcl.left - pEdge->xLeft;

            if (GradientLeft > 0)
            {
                Red   += dRed   * GradientLeft;
                Green += dGreen * GradientLeft;
                Blue  += dBlue  * GradientLeft;
            }

            while (pDstX < pDstScanRight)
            {
                *pDstX     = (BYTE)((Blue  & 0x00ff0000) >> 16);
                *(pDstX+1) = (BYTE)((Green & 0x00ff0000) >> 16);
                *(pDstX+2) = (BYTE)((Red   & 0x00ff0000) >> 16);

                Red   += dRed;
                Green += dGreen;
                Blue  += dBlue;

                pDstX+=3;
            }
        }

        pDst += lDelta;
        pEdge++;
        yScan++;
    }
}

/******************************Public*Routine******************************\
* vFillDIB16_565
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    11/21/1996 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vFillTriDIB16_565(
    PDIBINFO      pDibInfo,
    PTRIANGLEDATA ptData
    )
{
    LONG     lDelta = pDibInfo->stride;
    LONG     yScan  = ptData->y0;
    LONG     yScanBottom;
    PBYTE    pDst   = (PBYTE)pDibInfo->pvBase + lDelta * yScan;
    PTRIEDGE pEdge  = &ptData->TriEdge[0];
    LONG     dRed   = ptData->dRdX;
    LONG     dGreen = ptData->dGdX;
    LONG     dBlue  = ptData->dBdX;
    ULONG    Red;
    ULONG    Green;
    ULONG    Blue;
    PULONG   pulDither;

    yScanBottom = MIN(ptData->rcl.bottom,ptData->y1);

    LONG    yDitherOrg = ptData->ptDitherOrg.y;
    LONG    xDitherOrg = ptData->ptDitherOrg.x;

    while(yScan < yScanBottom)
    {
        PUSHORT pusDstX;
        PUSHORT pusDstScanRight;

        pulDither = &gulDither32[0] + 4 * ((yScan+yDitherOrg) & 3);

        Red   = pEdge->Red;
        Green = pEdge->Green;
        Blue  = pEdge->Blue;

        LONG xScanLeft  = MAX(pEdge->xLeft,ptData->rcl.left);
        LONG xScanRight = MIN(pEdge->xRight,ptData->rcl.right);

        if (xScanLeft < xScanRight)
        {
            pusDstX           = (PUSHORT)pDst + xScanLeft;
            pusDstScanRight   = (PUSHORT)pDst + xScanRight;

            //
            // skip pixels from left edge to left clip, while
            // incrementing gradient
            //

            LONG GradientLeft = ptData->rcl.left - pEdge->xLeft;

            if (GradientLeft > 0)
            {
                Red   += dRed   * GradientLeft;
                Green += dGreen * GradientLeft;
                Blue  += dBlue  * GradientLeft;
            }

            //
            // Gradient fill scan line with dither
            //

            while (pusDstX < pusDstScanRight)
            {
                ULONG   ulDither = pulDither[(((ULONG)pusDstX >> 1)+xDitherOrg) & 3];

                BYTE   iRed   = (BYTE)(((Red   >> 3) + ulDither) >> 16);
                BYTE   iGreen = (BYTE)(((Green >> 2) + ulDither) >> 16);
                BYTE   iBlue  = (BYTE)(((Blue  >> 3) + ulDither) >> 16);

                //
                // check for overflow
                //

                if (((iRed | iBlue) & 0xe0) || (iGreen & 0xc0))
                {
                    if (iRed & 0xe0)
                    {
                        iRed = 0x1f;
                    }

                    if (iBlue & 0xe0)
                    {
                        iBlue = 0x1f;
                    }

                    if (iGreen & 0xc0)
                    {
                        iGreen = 0x3f;
                    }
                }

                *pusDstX = rgb565(iRed,iGreen,iBlue);

                pusDstX++;
                Red   += dRed;
                Green += dGreen;
                Blue  += dBlue;
            }
        }

        pDst += lDelta;
        pEdge++;
        yScan++;
    }
}

/******************************Public*Routine******************************\
* vFillTriDIB16_555
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    11/21/1996 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vFillTriDIB16_555(
    PDIBINFO      pDibInfo,
    PTRIANGLEDATA ptData
    )
{
    LONG     lDelta = pDibInfo->stride;
    LONG     yScan  = ptData->y0;
    LONG     yScanBottom;
    PBYTE    pDst   = (PBYTE)pDibInfo->pvBase + lDelta * yScan;
    PTRIEDGE pEdge  = &ptData->TriEdge[0];
    LONG     dRed   = ptData->dRdX;
    LONG     dGreen = ptData->dGdX;
    LONG     dBlue  = ptData->dBdX;
    ULONG    Red;
    ULONG    Green;
    ULONG    Blue;
    PULONG   pulDither;

    yScanBottom = MIN(ptData->rcl.bottom,ptData->y1);

    LONG    yDitherOrg = ptData->ptDitherOrg.y;
    LONG    xDitherOrg = ptData->ptDitherOrg.x;

    while(yScan < yScanBottom)
    {
        PUSHORT pusDstX;
        PUSHORT pusDstScanRight;

        pulDither = &gulDither32[0] + 4 * ((yScan+yDitherOrg) & 3);

        Red   = pEdge->Red;
        Green = pEdge->Green;
        Blue  = pEdge->Blue;

        LONG xScanLeft  = MAX(pEdge->xLeft,ptData->rcl.left);
        LONG xScanRight = MIN(pEdge->xRight,ptData->rcl.right);

        if (xScanLeft < xScanRight)
        {
            pusDstX           = (PUSHORT)pDst + xScanLeft;
            pusDstScanRight   = (PUSHORT)pDst + xScanRight;

            //
            // skip pixels from left edge to left clip, while
            // incrementing gradient
            //

            LONG GradientLeft = ptData->rcl.left - pEdge->xLeft;

            if (GradientLeft > 0)
            {
                Red   += dRed   * GradientLeft;
                Green += dGreen * GradientLeft;
                Blue  += dBlue  * GradientLeft;
            }

            //
            // Gradient fill scan line with dither
            //

            while (pusDstX < pusDstScanRight)
            {
                ULONG   ulDither = pulDither[(((ULONG)pusDstX >> 1)+xDitherOrg) & 3];

                BYTE   iRed   = (BYTE)(((Red   >> 3) + ulDither) >> 16);
                BYTE   iGreen = (BYTE)(((Green >> 3) + ulDither) >> 16);
                BYTE   iBlue  = (BYTE)(((Blue  >> 3) + ulDither) >> 16);

                //
                // check for overflow
                //

                if ((iRed | iBlue | iGreen) & 0xe0)
                {
                    if (iRed & 0xe0)
                    {
                        iRed = 0x1f;
                    }

                    if (iBlue & 0xe0)
                    {
                        iBlue = 0x1f;
                    }

                    if (iGreen & 0xe0)
                    {
                        iGreen = 0x1f;
                    }
                }

                *pusDstX = rgb555(iRed,iGreen,iBlue);

                pusDstX++;
                Red   += dRed;
                Green += dGreen;
                Blue  += dBlue;
            }
        }

        pDst += lDelta;
        pEdge++;
        yScan++;
    }
}

/******************************Public*Routine******************************\
* vFillDIB8
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    11/21/1996 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vFillTriDIB8(
    PDIBINFO      pDibInfo,
    PTRIANGLEDATA ptData
    )
{
    LONG     lDelta = pDibInfo->stride;
    LONG     yScan  = ptData->y0;
    LONG     yScanBottom;
    PBYTE    pDst   = (PBYTE)pDibInfo->pvBase + lDelta * yScan;
    PTRIEDGE pEdge  = &ptData->TriEdge[0];
    LONG     dRed   = ptData->dRdX;
    LONG     dGreen = ptData->dGdX;
    LONG     dBlue  = ptData->dBdX;
    ULONG    Red;
    ULONG    Green;
    ULONG    Blue;
    PBYTE    pxlate = pDibInfo->pxlate332;
    PBYTE    pDitherMatrix;
    PBYTE    pSaturationTable;

    //
    // get/build rgb to palette table
    //

    if (pxlate == NULL)
    {
        WARNING("vTriFillDIB8:Failed to generate rgb555 xlate table\n");
        return;
    }

    //
    // either use default palette or halftone palette dither
    //

    if (pxlate == gHalftoneColorXlate332)
    {
        pDitherMatrix    = gDitherMatrix16x16Halftone;
        pSaturationTable = HalftoneSaturationTable;
    }
    else
    {
        pDitherMatrix    = gDitherMatrix16x16Default;
        pSaturationTable = DefaultSaturationTable;
    }


    //
    // scan from top to bottom of triangle scan lines
    //

    yScanBottom = MIN(ptData->rcl.bottom,ptData->y1);

    LONG    yDitherOrg = ptData->ptDitherOrg.y;
    LONG    xDitherOrg = ptData->ptDitherOrg.x;

    while(yScan < yScanBottom)
    {
        PBYTE   pjDstX;
        PBYTE   pjDstScanRight,pjDstScanLeft;

        Red   = pEdge->Red;
        Green = pEdge->Green;
        Blue  = pEdge->Blue;

        LONG xScanLeft  = MAX(pEdge->xLeft,ptData->rcl.left);
        LONG xScanRight = MIN(pEdge->xRight,ptData->rcl.right);

        PBYTE pDitherLevel = &pDitherMatrix[(16 * ((yScan+yDitherOrg) & DITHER_8_MASK_Y))];

        if (xScanLeft < xScanRight)
        {
            pjDstX            = pDst + xScanLeft;
            pjDstScanRight    = pDst + xScanRight;

            //
            // skip pixels from left edge to left clip, while
            // incrementing gradient
            //

            LONG GradientLeft = ptData->rcl.left - pEdge->xLeft;

            if (GradientLeft > 0)
            {
                Red   += dRed   * GradientLeft;
                Green += dGreen * GradientLeft;
                Blue  += dBlue  * GradientLeft;
            }

            //
            // gradient fill scan with dither
            //

            while (pjDstX < pjDstScanRight)
            {
                //
                // offset into dither array
                //

                BYTE jDitherMatrix = *(pDitherLevel + (((ULONG)pjDstX+xDitherOrg) & DITHER_8_MASK_X));

                ULONG   iRed   = (ULONG)((Red   >> 16) & 0xff);
                ULONG   iGreen = (ULONG)((Green >> 16) & 0xff);
                ULONG   iBlue  = (ULONG)((Blue  >> 16) & 0xff);

                iRed   = pSaturationTable[iRed   + jDitherMatrix];
                iGreen = pSaturationTable[iGreen + jDitherMatrix];
                iBlue  = pSaturationTable[iBlue  + jDitherMatrix];

                BYTE  jIndex;

                GRAD_PALETTE_MATCH(jIndex,pxlate,((BYTE)iRed),((BYTE)iGreen),((BYTE)iBlue));

                *pjDstX = jIndex;

                pjDstX++;
                Red   += dRed;
                Green += dGreen;
                Blue  += dBlue;
            }
        }

        pDst += lDelta;
        pEdge++;
        yScan++;
    }
}

/******************************Public*Routine******************************\
* vFillDIB4
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    11/21/1996 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vFillTriDIB4(
    PDIBINFO      pDibInfo,
    PTRIANGLEDATA ptData
    )
{
    LONG     lDelta = pDibInfo->stride;
    LONG     yScan  = ptData->y0;
    LONG     yScanBottom;
    PBYTE    pDst   = (PBYTE)pDibInfo->pvBase + lDelta * yScan;
    PTRIEDGE pEdge  = &ptData->TriEdge[0];
    LONG     dRed   = ptData->dRdX;
    LONG     dGreen = ptData->dGdX;
    LONG     dBlue  = ptData->dBdX;
    ULONG    Red;
    ULONG    Green;
    ULONG    Blue;
    PBYTE    pDitherMatrix    = gDitherMatrix16x16Default;
    PBYTE    pSaturationTable = DefaultSaturationTable;
    PBYTE    pxlate           = pDibInfo->pxlate332;

    if (pxlate == NULL)
    {
        WARNING("Failed to generate rgb555 xlate table\n");
        return;
    }

    yScanBottom = MIN(ptData->rcl.bottom,ptData->y1);

    LONG    yDitherOrg = ptData->ptDitherOrg.y;
    LONG    xDitherOrg = ptData->ptDitherOrg.x;

    while(yScan < yScanBottom)
    {
        PBYTE   pjDstX;
        LONG    iDstX;

        Red   = pEdge->Red;
        Green = pEdge->Green;
        Blue  = pEdge->Blue;

        LONG xScanLeft  = MAX(pEdge->xLeft,ptData->rcl.left);
        LONG xScanRight = MIN(pEdge->xRight,ptData->rcl.right);

        PBYTE pDitherLevel = &pDitherMatrix[(16 * ((yScan+yDitherOrg) & DITHER_8_MASK_Y))];

        if (xScanLeft < xScanRight)
        {
            pjDstX            = pDst + (xScanLeft/2);
            iDstX             = xScanLeft & 1;

            //
            // skip pixels from left edge to left clip, while
            // incrementing gradient
            //

            LONG GradientLeft = ptData->rcl.left - pEdge->xLeft;

            if (GradientLeft > 0)
            {
                Red   += dRed   * GradientLeft;
                Green += dGreen * GradientLeft;
                Blue  += dBlue  * GradientLeft;
            }

            //
            // fill scan line with dither
            //

            PALETTEENTRY palEntry;
            palEntry.peFlags = 2;

            while (xScanLeft < xScanRight)
            {
                //
                // offset into dither array
                //

                BYTE jDitherMatrix = *(pDitherLevel + ((xScanLeft+xDitherOrg) & DITHER_8_MASK_X));

                ULONG   iRed   = (ULONG)((Red   >> 16) & 0xff);
                ULONG   iGreen = (ULONG)((Green >> 16) & 0xff);
                ULONG   iBlue  = (ULONG)((Blue  >> 16) & 0xff);

                iRed   = pSaturationTable[iRed   + jDitherMatrix];
                iGreen = pSaturationTable[iGreen + jDitherMatrix];
                iBlue  = pSaturationTable[iBlue  + jDitherMatrix];

                BYTE  jIndex;

                GRAD_PALETTE_MATCH(jIndex,pxlate,((BYTE)iRed),((BYTE)iGreen),((BYTE)iBlue));

                //
                // write nibble
                //

                if (iDstX)
                {
                    iDstX = 0;
                    *pjDstX = (*pjDstX & 0xf0) | jIndex;
                    pjDstX++;
                }
                else
                {
                    *pjDstX = (*pjDstX & 0x0f) | (jIndex << 4);
                    iDstX = 1;
                }

                xScanLeft++;
                Red   += dRed;
                Green += dGreen;
                Blue  += dBlue;
            }
        }

        pDst += lDelta;
        pEdge++;
        yScan++;
    }
}

/******************************Public*Routine******************************\
* vFillDIB1
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    11/21/1996 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vFillTriDIB1(
    PDIBINFO      pDibInfo,
    PTRIANGLEDATA ptData
    )
{
    LONG     lDelta = pDibInfo->stride;
    LONG     yScan  = ptData->y0;
    LONG     yScanBottom;
    PBYTE    pDst   = (PBYTE)pDibInfo->pvBase + lDelta * yScan;
    PTRIEDGE pEdge  = &ptData->TriEdge[0];
    LONG     dRed   = ptData->dRdX;
    LONG     dGreen = ptData->dGdX;
    LONG     dBlue  = ptData->dBdX;
    ULONG    Red;
    ULONG    Green;
    ULONG    Blue;
    PBYTE    pxlate        = pDibInfo->pxlate332;
    PBYTE    pDitherMatrix = gDitherMatrix16x16Default;

    //
    // must have palette xlate
    //

    if (pxlate == NULL)
    {
        WARNING("Failed to generate rgb555 xlate table\n");
        return;
    }

    yScanBottom = MIN(ptData->rcl.bottom,ptData->y1);

    LONG    yDitherOrg = ptData->ptDitherOrg.y;
    LONG    xDitherOrg = ptData->ptDitherOrg.x;

    while(yScan < yScanBottom)
    {
        PBYTE   pjDstX;
        LONG    iDstX;

        LONG    ScanRight;
        LONG    ScanLeft;
        LONG    xScan;

        Red   = pEdge->Red;
        Green = pEdge->Green;
        Blue  = pEdge->Blue;

        LONG xScanLeft  = MAX(pEdge->xLeft,ptData->rcl.left);
        LONG xScanRight = MIN(pEdge->xRight,ptData->rcl.right);

        PBYTE pDitherLevel = &pDitherMatrix[(16 * ((yScan+yDitherOrg) & DITHER_8_MASK_Y))];

        if (xScanLeft < xScanRight)
        {
            pjDstX         = pDst + (xScanLeft/8);
            iDstX          = xScanLeft & 7;

            //
            // skip clipped out portion of scan line whille
            // running color gradient
            //

            LONG GradientLeft = ptData->rcl.left - pEdge->xLeft;

            if (GradientLeft > 0)
            {
                Red   += dRed   * GradientLeft;
                Green += dGreen * GradientLeft;
                Blue  += dBlue  * GradientLeft;
            }

            PALETTEENTRY palEntry;
            palEntry.peFlags = 2;

            while (xScanLeft < xScanRight)
            {
                //
                // offset into dither array
                //

                BYTE jDitherMatrix = 2 * (*(pDitherLevel + ((xScanLeft+xDitherOrg) & DITHER_8_MASK_X)));

                ULONG   iRed   = (ULONG)((Red   >> 16) & 0xff);
                ULONG   iGreen = (ULONG)((Green >> 16) & 0xff);
                ULONG   iBlue  = (ULONG)((Blue  >> 16) & 0xff);

                //
                // add dither and saturate. 1bpp non-optimized
                //

                iRed   = iRed   + jDitherMatrix;

                if (iRed >= 255)
                {
                    iRed = 255;
                }
                else
                {
                    iRed = 0;
                }

                iGreen = iGreen + jDitherMatrix;

                if (iGreen >= 255)
                {
                    iGreen = 255;
                }
                else
                {
                    iGreen = 0;
                }

                iBlue  = iBlue  + jDitherMatrix;

                if (iBlue >= 255)
                {
                    iBlue = 255;
                }
                else
                {
                    iBlue = 0;
                }

                BYTE  jIndex;

                //
                // pjVector is known to be identity, so could make new macro for
                // palette_match_1 if perf ever an issue
                //

                GRAD_PALETTE_MATCH(jIndex,pxlate,((BYTE)iRed),((BYTE)iGreen),((BYTE)iBlue));

                //
                // write bit (!!! completely and totally non-optimized)
                //

                LONG iShift = 7 - iDstX;
                BYTE OrMask = 1 << iShift;
                BYTE AndMask  = ~OrMask;

                jIndex = jIndex << iShift;

                *pjDstX = (*pjDstX & AndMask) | jIndex;

                iDstX++;

                if (iDstX == 8)
                {
                    iDstX = 0;
                    pjDstX++;
                }

                xScanLeft++;
                Red   += dRed;
                Green += dGreen;
                Blue  += dBlue;
            }
        }

        pDst += lDelta;
        pEdge++;
        yScan++;
    }
}


/******************************Public*Routine******************************\
* DIBTriangleMesh
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    12/4/1996 Mark Enstrom [marke]
*
\**************************************************************************/

BOOL
DIBTriangleMesh(
    HDC                hdc,
    PTRIVERTEX         pVertex,
    ULONG              nVertex,
    PGRADIENT_TRIANGLE pMesh,
    ULONG              nMesh,
    ULONG              ulMode,
    PRECTL             prclPhysExt,
    PDIBINFO           pDibInfo,
    PPOINTL            pptlDitherOrg,
    BOOL               bReadable
    )
{
    BOOL          bStatus = TRUE;
    RECTL         rclDst;
    RECTL         rclDstWk;
    ULONG         ulIndex;
    PTRIANGLEDATA ptData = NULL;
    PULONG        pulDIB = NULL;
    PFN_TRIFILL   pfnTriFill = NULL;

    pfnTriFill = pfnTriangleFillFunction(pDibInfo,bReadable);

    if (pfnTriFill == NULL)
    {
        WARNING("DIBTriangleMesh:Can't draw to surface\n");
        return(TRUE);
    }

    //
    // work in physical map mode, restore before return
    //

    ULONG OldMode = SetMapMode(hdc,MM_TEXT);

    //
    // fake up scale !!!
    //

    for (ulIndex=0;ulIndex<nVertex;ulIndex++)
    {
        pVertex[ulIndex].x = pVertex[ulIndex].x * 16;
        pVertex[ulIndex].y = pVertex[ulIndex].y * 16;
    }

    //
    // limit recorded triangle to clipped output
    //

    LONG   dxTri = prclPhysExt->right  - prclPhysExt->left;
    LONG   dyTri = prclPhysExt->bottom - prclPhysExt->top;

    //
    // check for clipped out
    //

    if ((dyTri > 0) && (dxTri > 0))
    {
        //
        // allocate structure to hold scan line data for all triangles
        // drawn during this call
        //

        ptData = (PTRIANGLEDATA)LOCALALLOC(sizeof(TRIANGLEDATA) + (dyTri-1) * sizeof(TRIEDGE));

        if (ptData != NULL)
        {
            //
            // draw each triangle
            //

            ptData->rcl      = *prclPhysExt;
            ptData->DrawMode = ulMode;
            ptData->ptDitherOrg = *pptlDitherOrg;

            for (ulIndex=0;ulIndex<nMesh;ulIndex++)
            {
                ULONG ulTri1 = pMesh[ulIndex].Vertex1;
                ULONG ulTri2 = pMesh[ulIndex].Vertex2;
                ULONG ulTri3 = pMesh[ulIndex].Vertex3;

                //
                // make sure index are in array
                //

                if (
                     (ulTri1 > nVertex) ||
                     (ulTri2 > nVertex) ||
                     (ulTri3 > nVertex)
                   )
                {
                    bStatus = FALSE;
                    break;
                }

                PTRIVERTEX pv0 = &pVertex[ulTri1];
                PTRIVERTEX pv1 = &pVertex[ulTri2];
                PTRIVERTEX pv2 = &pVertex[ulTri3];
                PTRIVERTEX pvt;

                if (pv0->y > pv1->y)
                {
                    SWAP_VERTEX(pv0,pv1,pvt);
                }

                if (pv1->y > pv2->y)
                {
                    SWAP_VERTEX(pv1,pv2,pvt);
                }

                if (pv0->y > pv1->y)
                {
                    SWAP_VERTEX(pv0,pv1,pvt);
                }

                if (pv2->x > pv1->x)
                {
                    SWAP_VERTEX(pv1,pv2,pvt);
                }

                //
                // record triangle
                //

                bStatus = bCalculateTriangle(pv0,pv1,pv2,ptData);

                if (bStatus)
                {
                    //
                    // draw scan lines
                    //

                    (*pfnTriFill)(pDibInfo,ptData);
                }
            }
        }
        else
        {
            DbgPrint("DIBTriangleMesh:Failed alloc   \n");
            bStatus = FALSE;
        }

        //
        // cleanup
        //

        if (ptData)
        {
            LOCALFREE(ptData);
        }

        if (pulDIB)
        {
            LOCALFREE(pulDIB);
        }
    }

    SetMapMode(hdc,OldMode);

    return(bStatus);
}


/******************************Public*Routine******************************\
* vCalcMeshExtent
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    12/3/1996 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vCalcMeshExtent(
    PTRIVERTEX  pVertex,
    ULONG       nVertex,
    RECTL       *prclExt
    )
{
    ULONG ulIndex;
    LONG xmin = MAX_INT;
    LONG xmax = MIN_INT;
    LONG ymin = MAX_INT;
    LONG ymax = MIN_INT;

    for (ulIndex = 0;ulIndex < nVertex;ulIndex++)
    {
        if (pVertex[ulIndex].x < xmin)
        {
            xmin = pVertex[ulIndex].x;
        }

        if (pVertex[ulIndex].x > xmax)
        {
            xmax = pVertex[ulIndex].x;
        }

        if (pVertex[ulIndex].y < ymin)
        {
            ymin = pVertex[ulIndex].y;
        }

        if (pVertex[ulIndex].y > ymax)
        {
            ymax = pVertex[ulIndex].y;
        }
    }

    prclExt->left   = xmin;
    prclExt->right  = xmax;
    prclExt->top    = ymin;
    prclExt->bottom = ymax;
}

/******************************Public*Routine******************************\
* bConvertVertexToPhysical
*   !!! slow way to convert.
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    12/4/1996 Mark Enstrom [marke]
*
\**************************************************************************/

BOOL
bConvertVertexToPhysical(
    HDC        hdc,
    PTRIVERTEX pVertex,
    ULONG      nVertex,
    PTRIVERTEX pPhysVert)
{
    ULONG ulIndex;

    for (ulIndex = 0;ulIndex<nVertex;ulIndex++)
    {
        POINT pt;

        pt.x = pVertex[ulIndex].x;
        pt.y = pVertex[ulIndex].y;

        if (!LPtoDP(hdc,&pt,1))
        {
            return(FALSE);
        }

        pPhysVert[ulIndex].x     = pt.x;
        pPhysVert[ulIndex].y     = pt.y;
        pPhysVert[ulIndex].Red   = pVertex[ulIndex].Red;
        pPhysVert[ulIndex].Green = pVertex[ulIndex].Green;
        pPhysVert[ulIndex].Blue  = pVertex[ulIndex].Blue;
        pPhysVert[ulIndex].Alpha = pVertex[ulIndex].Alpha;
    }

    return(TRUE);
}

/******************************Public*Routine******************************\
* bGetRectRegionFromDC
*
*   Use DCI to get the rectanglular region from a HDC. If the clipping is
*   more complex then 1 rectangle then return false.
*
* Arguments:
*
*   hdc     - destination DC
*   prcClip - Clip Rect, fill out if RECT clipping
*
* Return Value:
*
*   TRUE if clip rect was filled
*
* History:
*
*    12/6/1996 Mark Enstrom [marke]
*
\**************************************************************************/

BOOL
bGetRectRegionFromDC(
    HDC     hdc,
    PRECT   prcClip
    )
{
    //
    // visible region
    //

    BOOL      bRet = FALSE;
    DWORD     dwSize = 0;
    LPRGNDATA lpRgnData = NULL;

    //
    // init clip rect to NULL
    //

    dwSize = GetDCRegionData(hdc,dwSize,lpRgnData);

    if (dwSize)
    {
        lpRgnData = (LPRGNDATA)LOCALALLOC(dwSize);

        if (lpRgnData)
        {
            dwSize = GetDCRegionData(hdc,dwSize,lpRgnData);

            if (dwSize)
            {
                if (lpRgnData->rdh.nCount == 1)
                {
                    bRet   = TRUE;
                    *prcClip = lpRgnData->rdh.rcBound;
                }
            }
            LOCALFREE(lpRgnData);
        }
    }
    return(bRet);
}

/******************************Public*Routine******************************\
* pfnTriangleFillFunction
*
*   look at format to decide if DIBSection should be drawn directly
*
*    32 bpp RGB
*    32 bpp BGR
*    24 bpp
*    16 bpp 565
*    16 bpp 555
*
* Trangles are only filled in high color (no palette) surfaces
*
* Arguments:
*
*   pDibInfo - information about destination surface
*
* Return Value:
*
*   PFN_TRIFILL - triangle filling routine
*
* History:
*
*    12/6/1996 Mark Enstrom [marke]
*
\**************************************************************************/

PFN_TRIFILL
pfnTriangleFillFunction(
    PDIBINFO pDibInfo,
    BOOL bReadable
    )
{
    PFN_TRIFILL pfnRet = NULL;

    PULONG pulMasks = (PULONG)&pDibInfo->pbmi->bmiColors[0];

    //
    // 32 bpp RGB
    //

    if (!bReadable)
    {
        pfnRet = vFillTriDIBUnreadable;
    }
    else if (
         (pDibInfo->pbmi->bmiHeader.biBitCount    == 32) &&
         (pDibInfo->pbmi->bmiHeader.biCompression == BI_RGB)
       )
    {
        pfnRet = vFillTriDIB32BGRA;
    }

    else if (
         (pDibInfo->pbmi->bmiHeader.biBitCount    == 32) &&
         (pDibInfo->pbmi->bmiHeader.biCompression == BI_BITFIELDS) &&
         (pulMasks[0]   == 0xff0000)           &&
         (pulMasks[1]   == 0x00ff00)           &&
         (pulMasks[2]   == 0x0000ff)
       )
    {
        pfnRet = vFillTriDIB32BGRA;
    }

    else if (
         (pDibInfo->pbmi->bmiHeader.biBitCount    == 32) &&
         (pDibInfo->pbmi->bmiHeader.biCompression == BI_BITFIELDS) &&
         (pulMasks[0]   == 0x0000ff)           &&
         (pulMasks[1]   == 0x00ff00)           &&
         (pulMasks[2]   == 0xff0000)
       )
    {
        pfnRet = vFillTriDIB32RGB;
    }

    else if (
         (pDibInfo->pbmi->bmiHeader.biBitCount    == 24) &&
         (pDibInfo->pbmi->bmiHeader.biCompression == BI_RGB)
       )
    {
        pfnRet = vFillTriDIB24RGB;
    }

    //
    // 16 BPP
    //

    else if (
         (pDibInfo->pbmi->bmiHeader.biBitCount    == 16) &&
         (pDibInfo->pbmi->bmiHeader.biCompression == BI_BITFIELDS)
       )
    {

        //
        // 565,555
        //

        if (
             (pulMasks[0]   == 0xf800)           &&
             (pulMasks[1]   == 0x07e0)           &&
             (pulMasks[2]   == 0x001f)
           )
        {
            pfnRet = vFillTriDIB16_565;
        }
        else if (
            (pulMasks[0]   == 0x7c00)           &&
            (pulMasks[1]   == 0x03e0)           &&
            (pulMasks[2]   == 0x001f)
          )
       {
           pfnRet = vFillTriDIB16_555;
       }
    }
    else if (pDibInfo->pbmi->bmiHeader.biBitCount    == 8)
    {
        pfnRet = vFillTriDIB8;
    }
    else if (pDibInfo->pbmi->bmiHeader.biBitCount    == 4)
    {
        pfnRet = vFillTriDIB4;
    }
    else if (pDibInfo->pbmi->bmiHeader.biBitCount    == 1)
    {
        pfnRet = vFillTriDIB1;
    }

    return(pfnRet);
}

/******************************Public*Routine******************************\
* WinTriangleMesh
*   win95 emulation
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    12/3/1996 Mark Enstrom [marke]
*
\**************************************************************************/

BOOL
WinGradientFill(
    HDC         hdc,
    PTRIVERTEX  pLogVertex,
    ULONG       nVertex,
    PVOID       pMesh,
    ULONG       nMesh,
    ULONG       ulMode
    )
{

    //
    // If the DC has a DIBSection selected, then draw direct to DIBSECTION.
    // else copy the rectangle needed from the dst to a 32bpp temp buffer,
    // draw into the buffer, then bitblt to dst.
    //
    // calc extents for drawing
    //
    // convert extents and points to physical
    //
    // if no global then
    //      create memory DC with dibsection of correct size
    // copy dst into dibsection (if can't make clipping)
    // draw physical into dibsection
    // copy dibsection to destination
    //

    PBYTE       pDIB;
    RECTL       rclPhysExt;
    RECTL       rclLogExt;
    PRECTL      prclClip;
    BOOL        bStatus = FALSE;
    PFN_TRIFILL pfnTriFill;
    DIBINFO     dibInfoDst;
    PALINFO     palDst;
    ULONG       ulDIBMode = SOURCE_GRADIENT_TRI;
    BOOL        bReadable;
    POINTL      ptlDitherOrg = {0,0};

    //
    // validate params and buffers
    //

    if (ulMode & (GRADIENT_FILL_RECT_H | GRADIENT_FILL_RECT_V))
    {
        //
        // if threre is only 1 rect, don't bother reading destination
        // bits
        //

        //
        // !!! make repeated calls in case nMesh != 1 to avoid
        // reading surface???
        //

        if (nMesh == 1)
        {
            ulDIBMode        = SOURCE_GRADIENT_RECT;
        }
    }
    else if (!(ulMode & GRADIENT_FILL_TRIANGLE))
    {
        WARNING("Invalid mode in call to GradientFill\n");
        // !!! set last error
        return(FALSE);
    }

    PTRIVERTEX  pPhysVertex = (PTRIVERTEX)LOCALALLOC(nVertex * sizeof(TRIVERTEX));

    if (pPhysVertex != NULL)
    {
        //
        // convert to physical
        //

        bStatus = bConvertVertexToPhysical(hdc,pLogVertex,nVertex,pPhysVertex);

        if (bStatus)
        {
            //
            // get logical extents
            //

            vCalcMeshExtent(pLogVertex,nVertex,&rclLogExt);

            //
            // convert to physical extents
            //

            rclPhysExt = rclLogExt;

            LPtoDP(hdc,(LPPOINT)&rclPhysExt,2);

            //
            // Set DIB information, convert to physical
            //

            bStatus = bInitDIBINFO(hdc,
                                rclLogExt.left,
                                rclLogExt.top,
                                rclLogExt.right  - rclLogExt.left,
                                rclLogExt.bottom - rclLogExt.top,
                                &dibInfoDst);

            if (bStatus)
            {
                //
                // get a destination DIB. For RECT Mode, the destination is not read.
                //

                bSetupBitmapInfos(&dibInfoDst, NULL);

                bStatus = bGetDstDIBits(&dibInfoDst, &bReadable,ulDIBMode);

                if (!((!bStatus) || (dibInfoDst.rclClipDC.left == dibInfoDst.rclClipDC.right)))
                {
                    ULONG ulIndex;

                    //
                    // if 1,4,8 format then allocate rgb332 to palette xlate
                    //

                    ULONG    BitCount = dibInfoDst.pbmi->bmiHeader.biBitCount;

                    if (BitCount <= 8)
                    {
                        ULONG    NumPalEntries;
                        PBYTE    pxlate = NULL;

                        switch (BitCount)
                        {
                        case 1:
                            NumPalEntries = 2;
                            break;

                        case 4:
                            NumPalEntries = 16;

                            if ((dibInfoDst.pbmi->bmiHeader.biClrUsed > 0) &&
                                (dibInfoDst.pbmi->bmiHeader.biClrUsed < 16))
                            {
                               NumPalEntries = dibInfoDst.pbmi->bmiHeader.biClrUsed;
                            }
                            break;
                        case 8:
                            NumPalEntries = 256;

                            if ((dibInfoDst.pbmi->bmiHeader.biClrUsed > 0) &&
                                (dibInfoDst.pbmi->bmiHeader.biClrUsed < 256))
                            {
                               NumPalEntries = dibInfoDst.pbmi->bmiHeader.biClrUsed;
                            }
                            break;
                        }

                        pxlate = pGenColorXform332((PULONG)(&dibInfoDst.pbmi->bmiColors[0]),NumPalEntries);

                        dibInfoDst.pxlate332 = pxlate;

                        if (pxlate == NULL)
                        {

                            WARNING("Failed to allocate xlate\n");
                            bStatus = FALSE;
                        }
                    }

                    if (bStatus)
                    {
                        if (dibInfoDst.hDIB)
                        {
                            //
                            // if temp surface has been allocated,
                            // subtract origin from points
                            //

                            for (ulIndex=0;ulIndex<nVertex;ulIndex++)
                            {                                     
                                pPhysVertex[ulIndex].x -= dibInfoDst.ptlGradOffset.x;
                                pPhysVertex[ulIndex].y -= dibInfoDst.ptlGradOffset.y;
                            }

                            //
                            // clipping now in relation to temp DIB
                            //

                            rclPhysExt = dibInfoDst.rclDIB;

                            //
                            // adjust dither org
                            //

                            ptlDitherOrg.x = dibInfoDst.rclBounds.left;
                            ptlDitherOrg.y = dibInfoDst.rclBounds.top;
                        }
                        else
                        {
                            //
                            // clip extents to destination clip rect
                            //

                            if (rclPhysExt.left < dibInfoDst.rclClipDC.left)
                            {
                                rclPhysExt.left = dibInfoDst.rclClipDC.left;
                            }

                            if (rclPhysExt.right > dibInfoDst.rclClipDC.right)
                            {
                                rclPhysExt.right = dibInfoDst.rclClipDC.right;
                            }

                            if (rclPhysExt.top < dibInfoDst.rclClipDC.top)
                            {
                                rclPhysExt.top = dibInfoDst.rclClipDC.top;
                            }

                            if (rclPhysExt.bottom > dibInfoDst.rclClipDC.bottom)
                            {
                                rclPhysExt.bottom = dibInfoDst.rclClipDC.bottom;
                            }
                        }

                        if (
                             (ulMode &  (GRADIENT_FILL_RECT_H | GRADIENT_FILL_RECT_V))
                           )
                        {
                            //
                            // draw gradient rectangles
                            //

                            bStatus = DIBGradientRect(hdc,pPhysVertex,nVertex,(PGRADIENT_RECT)pMesh,nMesh,ulMode,&rclPhysExt,&dibInfoDst,&ptlDitherOrg);
                        }
                        else if (ulMode == GRADIENT_FILL_TRIANGLE)
                        {
                            //
                            // draw triangles
                            //

                            bStatus = DIBTriangleMesh(hdc,pPhysVertex,nVertex,(PGRADIENT_TRIANGLE)pMesh,nMesh,ulMode,&rclPhysExt,&dibInfoDst,&ptlDitherOrg,bReadable);
                        }

                        //
                        // copy output to final dest if needed
                        //

                        if (bStatus && bReadable)
                        {
                            bStatus = bSendDIBINFO (hdc,&dibInfoDst);
                        }
                    }
                }
            }

            vCleanupDIBINFO(&dibInfoDst);
        }

        LOCALFREE(pPhysVertex);
    }
    else
    {
        bStatus = FALSE;
    }

    //
    //
    //

    return(bStatus);
}

#endif

/******************************Public*Routine******************************\
* TriangleMesh
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    12/3/1996 Mark Enstrom [marke]
*
\**************************************************************************/

BOOL
GradientFill(
    HDC         hdc,
    PTRIVERTEX  pVertex,
    ULONG       nVertex,
    PVOID       pMesh,
    ULONG       nMesh,
    ULONG       ulMode
    )
{
    BOOL bRet;

    bRet = gpfnGradientFill(hdc,
                            pVertex,
                            nVertex,
                            pMesh,
                            nMesh,
                            ulMode
                            );
    return(bRet);
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\inc\exehdr.h ===
/******************************Module*Header*******************************\
* Module Name: exehdr.h
*
* (Brief description)
*
* Created: 08-May-1991 13:42:33
* Author: Bodin Dresevic [BodinD]
*
* Copyright (c) 1990-1999 Microsoft Corporation
*
*  Description
*
*      Data structure definitions for the DOS 4.0/Windows 2.0
*      executable file format.
*
*  Modification History
*
*      84/08/17        Pete Stewart    Initial version
*      84/10/17        Pete Stewart    Changed some constants to match OMF
*      84/10/23        Pete Stewart    Updates to match .EXE format revision
*      84/11/20        Pete Stewart    Substantial .EXE format revision
*      85/01/09        Pete Stewart    Added constants ENEWEXE and ENEWHDR
*      85/01/10        Steve Wood      Added resource definitions
*      85/03/04        Vic Heller      Reconciled Windows and DOS 4.0 versions
*      85/03/07        Pete Stewart    Added movable entry count
*      85/04/01        Pete Stewart    Segment alignment field, error bit
*****
*	90/11/28   Lindsay Harris: copied & trimmed from DOS version
*****
*  Wed 08-May-1991 -by- Bodin Dresevic [BodinD]
* update:
*   made changes necessary to make the code portable, offsets et.c
*
\**************************************************************************/



#define EMAGIC          0x5A4D          // Old magic number
#define ENEWEXE         sizeof(struct exe_hdr)
                                        // Value of E_LFARLC for new .EXEs
#define ENEWHDR         0x003C          // Offset in old hdr. of ptr. to new
#define ERESWDS         0x0010          // No. of reserved words in header
#define ECP             0x0004          // Offset in struct of E_CP
#define ECBLP           0x0002          // Offset in struct of E_CBLP
#define EMINALLOC       0x000A          // Offset in struct of E_MINALLOC

#ifdef DEBUGOFFSETS

// this is the original definition of the structure that I used to compute
// the offsets given below, assuming that the 16 bit compiler puts no padding
// between the fields. It turns out that this assumption is correct
// so that when the file is written to the disk the fields are indeed
// laid out at the offsets computed below

typedef  struct exe_hdr                          // DOS 1, 2, 3 .EXE header
{
    unsigned short      e_magic;        // Magic number
    unsigned short      e_cblp;         // Bytes on last page of file
    unsigned short      e_cp;           // Pages in file
    unsigned short      e_crlc;         // Relocations
    unsigned short      e_cparhdr;      // Size of header in paragraphs
    unsigned short      e_minalloc;     // Minimum extra paragraphs needed
    unsigned short      e_maxalloc;     // Maximum extra paragraphs needed
    unsigned short      e_ss;           // Initial (relative) SS value
    unsigned short      e_sp;           // Initial SP value
    unsigned short      e_csum;         // Checksum
    unsigned short      e_ip;           // Initial IP value
    unsigned short      e_cs;           // Initial (relative) CS value
    unsigned short      e_lfarlc;       // File address of relocation table
    unsigned short      e_ovno;         // Overlay number
    unsigned short      e_res[ERESWDS]; // Reserved words
    long                e_lfanew;       // File address of new exe header
} EXE_HDR;

#endif // DEBUGOFFSETS

// the only structure fileds used by our code are

//    unsigned short      e_magic;        // Magic number
//    long                e_lfanew;       // File address of new exe header

// these are offsets how the fiels of this structure are laid out in the file

#define OFF_e_magic           0     // unsigned short Magic number
#define OFF_e_cblp            2     // unsigned short Bytes on last page of file
#define OFF_e_cp              4     // unsigned short Pages in file
#define OFF_e_crlc            6     // unsigned short Relocations
#define OFF_e_cparhdr         8     // unsigned short Size of header in paragraphs
#define OFF_e_minalloc        10    // unsigned short Minimum extra paragraphs needed
#define OFF_e_maxalloc        12    // unsigned short Maximum extra paragraphs needed
#define OFF_e_ss              14    // unsigned short Initial (relative) SS value
#define OFF_e_sp              16    // unsigned short Initial SP value
#define OFF_e_csum            18    // unsigned short Checksum
#define OFF_e_ip              20    // unsigned short Initial IP value
#define OFF_e_cs              22    // unsigned short Initial (relative) CS value
#define OFF_e_lfarlc          24    // unsigned short File address of relocation table
#define OFF_e_ovno            26    // unsigned short Overlay number
#define OFF_e_res             28    // unsigned short Reserved words, 16 of then 60 = 28 + 32
#define OFF_e_lfanew          60    // long           File address of new exe header

#define CJ_EXE_HDR            64

// ************** stuff associated with new exe hdr ********************

#define NEMAGIC         0x454E          // New magic number
#define NERESBYTES      0


#ifdef DEBUGOFFSETS


typedef  struct new_exe                          // New .EXE header
{
    unsigned short int  ne_magic;       // Magic number NE_MAGIC
    char                ne_ver;         // Version number
    char                ne_rev;         // Revision number
    unsigned short int  ne_enttab;      // Offset of Entry Table
    unsigned short int  ne_cbenttab;    // Number of bytes in Entry Table
    long                ne_crc;         // Checksum of whole file
    unsigned short int  ne_flags;       // Flag word
    unsigned short int  ne_autodata;    // Automatic data segment number
    unsigned short int  ne_heap;        // Initial heap allocation
    unsigned short int  ne_stack;       // Initial stack allocation
    long                ne_csip;        // Initial CS:IP setting
    long                ne_sssp;        // Initial SS:SP setting
    unsigned short int  ne_cseg;        // Count of file segments
    unsigned short int  ne_cmod;        // Entries in Module Reference Table
    unsigned short int  ne_cbnrestab;   // Size of non-resident name table
    unsigned short int  ne_segtab;      // Offset of Segment Table
    unsigned short int  ne_rsrctab;     // Offset of Resource Table
    unsigned short int  ne_restab;      // Offset of resident name table
    unsigned short int  ne_modtab;      // Offset of Module Reference Table
    unsigned short int  ne_imptab;      // Offset of Imported Names Table
    long                ne_nrestab;     // Offset of Non-resident Names Table
    unsigned short int  ne_cmovent;     // Count of movable entries
    unsigned short int  ne_align;       // Segment alignment shift count
    unsigned short int  ne_cres;        // Count of resource segments
    unsigned char	ne_exetyp;	// Target Operating system
    unsigned char	ne_flagsothers;	// Other .EXE flags
    unsigned short int  ne_pretthunks;  // offset to return thunks
    unsigned short int  ne_psegrefbytes;// offset to segment ref. bytes
    unsigned short int  ne_swaparea;    // Minimum code swap area size
    unsigned short int  ne_expver;      // Expected Windows version number
} NEW_EXE;

#endif // DEBUGOFFSETS


// the only structure fileds used by our code are

//    unsigned short int  ne_magic;       // Magic number NE_MAGIC
//    unsigned short int  ne_rsrctab;     // Offset of Resource Table
//    long                ne_restab;      // Offset of resident Names Table

// offsets from beg of the structure as the data is laid out on the disk

#define OFF_ne_magic        0     // unsigned short Magic number NE_MAGIC
#define OFF_ne_ver          2     // char           Version number
#define OFF_ne_rev          3     // char           Revision number
#define OFF_ne_enttab       4     // unsigned short Offset of Entry Table
#define OFF_ne_cbenttab     6     // unsigned short Number of bytes in Entry Table
#define OFF_ne_crc          8     // long           Checksum of whole file
#define OFF_ne_flags        12    // unsigned short Flag word
#define OFF_ne_autodata     14    // unsigned short Automatic data segment number
#define OFF_ne_heap         16    // unsigned short Initial heap allocation
#define OFF_ne_stack        18    // unsigned short Initial stack allocation
#define OFF_ne_csip         20    // long           Initial CS:IP setting
#define OFF_ne_sssp         24    // long           Initial SS:SP setting
#define OFF_ne_cseg         28    // unsigned short Count of file segments
#define OFF_ne_cmod         30    // unsigned short Entries in Module Reference Table
#define OFF_ne_cbnrestab    32    // unsigned short Size of non-resident name table
#define OFF_ne_segtab       34    // unsigned short Offset of Segment Table
#define OFF_ne_rsrctab      36    // unsigned short Offset of Resource Table
#define OFF_ne_restab       38    // unsigned short Offset of resident name table
#define OFF_ne_modtab       40    // unsigned short Offset of Module Reference Table
#define OFF_ne_imptab       42    // unsigned short Offset of Imported Names Table
#define OFF_ne_nrestab      44    // long           Offset of Non-resident Names Table
#define OFF_ne_cmovent      48    // unsigned short Count of movable entries
#define OFF_ne_align        50    // unsigned short Segment alignment shift count
#define OFF_ne_cres         52    // unsigned short Count of resource segments
#define OFF_ne_exetyp	    54    // unsigned char  Target Operating system
#define OFF_ne_flagsothers  55    // unsigned char  Other .EXE flags
#define OFF_ne_pretthunks   56    // unsigned short offset to return thunks
#define OFF_ne_psegrefbytes 58    // unsigned short offset to segment ref. bytes
#define OFF_ne_swaparea     60    // unsigned short Minimum code swap area size
#define OFF_ne_expver       62    // unsigned short Expected Windows version number


#define CJ_NEW_EXE          64

// Resource type or name string

typedef  struct rsrc_string
{
    char rs_len;            // number of bytes in string
    char rs_string[ 1 ];    // text of string
} RSRC_STRING;


// Resource type information block

#ifdef DEBUGOFFSETS

typedef struct rsrc_typeinfo
{
    unsigned short rt_id;
    unsigned short rt_nres;
    long           rt_proc;
} RSRC_TYPEINFO;

#endif // DEBUGOFFSETS

#define OFF_rt_id     0  //    unsigned short
#define OFF_rt_nres   2  //    unsigned short
#define OFF_rt_proc   4  //    long

#define CJ_TYPEINFO   8

// the only rt_id that we are interested in is the
// one for *.fnt files, RT_FNT, RT_FDIR for font directories
// and RT_PSZ, string resource with a *.ttf file name in an
// fot file. RT_DONTKNOW exhists in fon files but I do not
// know what it corresponds to

#define RT_FDIR     0x8007
#define RT_FNT      0X8008
#define RT_DONTKNOW 0x800h
#define RT_PSZ      0X80CC

// rn_id's that are allowed for certain types of rt_id's
// as I have found them in fot files [bodind]

#define RN_ID_FDIR  0x002c
#define RN_ID_PSZ   0x8001


#ifdef DEBUGOFFSETS

// Resource name information block

typedef struct rsrc_nameinfo
{
// The following two fields must be shifted left by the value of
// the rs_align field to compute their actual value.  This allows
// resources to be larger than 64k, but they do not need to be
// aligned on 512 byte boundaries, the way segments are

    unsigned short rn_offset;   // file offset to resource data
    unsigned short rn_length;   // length of resource data
    unsigned short rn_flags;    // resource flags
    unsigned short rn_id;       // resource name id
    unsigned short rn_handle;   // If loaded, then global handle
    unsigned short rn_usage;    // Initially zero.  Number of times
                                // the handle for this resource has
                                // been given out
} RSRC_NAMEINFO;

#endif // DEBUGOFFSETS


#define OFF_rn_offset   0        //  unsigned short
#define OFF_rn_length   2        //  unsigned short
#define OFF_rn_flags    4        //  unsigned short
#define OFF_rn_id       6        //  unsigned short
#define OFF_rn_handle   8        //  unsigned short
#define OFF_rn_usage    10       //  unsigned short

#define CJ_NAMEINFO   12


#define RSORDID     0x8000      // if high bit of ID set then integer id
                                // otherwise ID is offset of string from
                                // the beginning of the resource table

                                // Ideally these are the same as the
                                // corresponding segment flags
#define RNMOVE      0x0010      // Moveable resource
#define RNPURE      0x0020      // Pure (read-only) resource
#define RNPRELOAD   0x0040      // Preloaded resource
#define RNDISCARD   0x1000      // Discard bit for resource

#define RNLOADED    0x0004      // True if handler proc return handle

#ifdef DEBUGOFFSETS

// Resource table

typedef struct new_rsrc
{
    unsigned short rs_align;    // alignment shift count for resources
    RSRC_TYPEINFO  rs_typeinfo; // Really an array of these
} NEW_RSRC;

#endif // DEBUGOFFSETS

// Target operating systems:  Possible values of ne_exetyp field

#define NE_UNKNOWN	0	// Unknown (any "new-format" OS)
#define NE_OS2		1	// Microsoft/IBM OS/2 (default)
#define NE_WINDOWS	2	// Microsoft Windows
#define NE_DOS4 	3	// Microsoft MS-DOS 4.x
#define NE_DEV386	4	// Microsoft Windows 386
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\inc\fot16.h ===
/******************************Module*Header*******************************\
* Module Name: fot16.h
*
* structures for accessing font resources within 16 bit fon dlls
*
* Created: 08-May-1991 13:12:57
* Author: Bodin Dresevic [BodinD]
*
* Copyright (c) 1990-1999 Microsoft Corporation
*
\**************************************************************************/

//
//   The main structure for manipulating the resource data.  One of these
//  is created when access is required to a resource,  and it is destroyed
//  when the resource is no longer required.


typedef  struct                 // wrd
{
    PVOID     pvView;           // view of the mapped *.fot file
    ULONG     cjView;           // size of the view

// stuff referring to general resources

    PTRDIFF   dpNewExe;     // Base address of new header in file
    ULONG     ulShift;      // Shift factor for resource info
    PTRDIFF   dpResTab;     // Offset in file of resource table (first RSRC_TYPEINFO struct)
    ULONG     cjResTab;     // Bytes  in file to store for above

// font directory location and size

    PBYTE pjHdr;
    ULONG cjHdr;

// ttf file name  location and size

    PSZ   pszNameTTF;
    ULONG cchNameTTF;

} WINRESDATA,  *PWINRESDATA;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\inc\gdisplp.h ===
/******************************Module*Header*******************************\
* Module Name: gdisplp.h
*
* Copyright (c) 1995-1999 Microsoft Corporation
\**************************************************************************/

BOOL
WINAPI
GetPrinterDriverW(
    HANDLE  hPrinter,
    LPWSTR   pEnvironment,
    DWORD   Level,
    LPBYTE  pDriverInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
);

#define GetPrinterDriver  GetPrinterDriverW

BOOL
WINAPI
AbortPrinter(
   HANDLE   hPrinter
);

BOOL
WINAPI
EndDocPrinter(
   HANDLE   hPrinter
);

typedef struct _PRINTER_DEFAULTSW{
    LPWSTR        pDatatype;
    LPDEVMODEW pDevMode;
    ACCESS_MASK DesiredAccess;
} PRINTER_DEFAULTSW, *PPRINTER_DEFAULTSW, *LPPRINTER_DEFAULTSW;

typedef struct _DOC_INFO_1W {
    LPWSTR    pDocName;
    LPWSTR    pOutputFile;
    LPWSTR    pDatatype;
} DOC_INFO_1W, *PDOC_INFO_1W, *LPDOC_INFO_1W;


BOOL
WINAPI
OpenPrinterW(
   LPWSTR    pPrinterName,
   LPHANDLE phPrinter,
   LPPRINTER_DEFAULTSW pDefault
);

#define OpenPrinter  OpenPrinterW

BOOL
WINAPI
ClosePrinter(
    HANDLE hPrinter
);

BOOL
WINAPI
EndPagePrinter(
   HANDLE   hPrinter
);

DWORD
WINAPI
StartDocPrinterW(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pDocInfo
);

#define StartDocPrinter  StartDocPrinterW

BOOL
WINAPI
ResetPrinterW(
   HANDLE   hPrinter,
   LPVOID pDefault
);

#define ResetPrinter  ResetPrinterW

BOOL
WINAPI
StartPagePrinter(
    HANDLE  hPrinter
);


typedef struct _DRIVER_INFO_5W {
    DWORD   cVersion;
    LPWSTR    pName;                    // QMS 810
    LPWSTR    pEnvironment;             // Win32 x86
    LPWSTR    pDriverPath;              // c:\drivers\pscript.dll
    LPWSTR    pDataFile;                // c:\drivers\QMS810.PPD
    LPWSTR    pConfigFile;              // c:\drivers\PSCRPTUI.DLL
    DWORD     dwDriverAttributes;       // driver attributes (like UMPD/KMPD)
    DWORD     dwConfigVersion;          // version number of the config file since reboot
    DWORD     dwDriverVersion;          // version number of the driver file since reboot
} DRIVER_INFO_5W, *PDRIVER_INFO_5W, *LPDRIVER_INFO_5W;

typedef struct _DRIVER_INFO_3W {
    DWORD   cVersion;
    LPWSTR    pName;                    // QMS 810
    LPWSTR    pEnvironment;             // Win32 x86
    LPWSTR    pDriverPath;              // c:\drivers\pscript.dll
    LPWSTR    pDataFile;                // c:\drivers\QMS810.PPD
    LPWSTR    pConfigFile;              // c:\drivers\PSCRPTUI.DLL
    LPWSTR    pHelpFile;                // c:\drivers\PSCRPTUI.HLP
    LPWSTR    pDependentFiles;          // PSCRIPT.DLL\0QMS810.PPD\0PSCRIPTUI.DLL\0PSCRIPTUI.HLP\0PSTEST.TXT\0\0
    LPWSTR    pMonitorName;             // "PJL monitor"
    LPWSTR    pDefaultDataType;         // "EMF"
} DRIVER_INFO_3W, *PDRIVER_INFO_3W, *LPDRIVER_INFO_3W;

typedef struct _DRIVER_INFO_2W {
    DWORD   cVersion;
    LPWSTR    pName;              // QMS 810
    LPWSTR    pEnvironment;       // Win32 x86
    LPWSTR    pDriverPath;        // c:\drivers\pscript.dll
    LPWSTR    pDataFile;          // c:\drivers\QMS810.PPD
    LPWSTR    pConfigFile;        // c:\drivers\PSCRPTUI.DLL
} DRIVER_INFO_2W, *PDRIVER_INFO_2W, *LPDRIVER_INFO_2W;

typedef struct _DRIVER_INFO_1W {
    LPWSTR    pName;              // QMS 810
} DRIVER_INFO_1W, *PDRIVER_INFO_1W, *LPDRIVER_INFO_1W;


typedef struct _FORM_INFO_1W {
    DWORD   Flags;
    LPWSTR  pName;
    SIZEL   Size;
    RECTL   ImageableArea;
} FORM_INFO_1W, *PFORM_INFO_1W, *LPFORM_INFO_1W;

typedef struct _PRINTER_INFO_1W {
    DWORD   Flags;
    LPWSTR  pDescription;
    LPWSTR  pName;
    LPWSTR  pComment;
} PRINTER_INFO_1W, *PPRINTER_INFO_1W, *LPPRINTER_INFO_1W;

typedef struct _PRINTER_INFO_2W {
    LPWSTR    pServerName;
    LPWSTR    pPrinterName;
    LPWSTR    pShareName;
    LPWSTR    pPortName;
    LPWSTR    pDriverName;
    LPWSTR    pComment;
    LPWSTR    pLocation;
    LPDEVMODEW pDevMode;
    LPWSTR    pSepFile;
    LPWSTR    pPrintProcessor;
    LPWSTR    pDatatype;
    LPWSTR    pParameters;
    PSECURITY_DESCRIPTOR pSecurityDescriptor;
    DWORD   Attributes;
    DWORD   Priority;
    DWORD   DefaultPriority;
    DWORD   StartTime;
    DWORD   UntilTime;
    DWORD   Status;
    DWORD   cJobs;
    DWORD   AveragePPM;
} PRINTER_INFO_2W, *PPRINTER_INFO_2W, *LPPRINTER_INFO_2W;

typedef struct _PRINTER_INFO_3 {
    PSECURITY_DESCRIPTOR pSecurityDescriptor;
} PRINTER_INFO_3, *PPRINTER_INFO_3, *LPPRINTER_INFO_3;

typedef struct _PRINTER_INFO_4W {
    LPWSTR  pPrinterName;
    LPWSTR  pServerName;
    DWORD   Attributes;
} PRINTER_INFO_4W, *PPRINTER_INFO_4W, *LPPRINTER_INFO_4W;

typedef struct _PRINTER_INFO_5W {
    LPWSTR  pPrinterName;
    LPWSTR  pPortName;
    DWORD   Attributes;
    DWORD   DeviceNotSelectedTimeout;
    DWORD   TransmissionRetryTimeout;
} PRINTER_INFO_5W, *PPRINTER_INFO_5W, *LPPRINTER_INFO_5W;


#define PRINTER_ACCESS_USE          0x00000008
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\inc\hmgshare.h ===
/******************************Module*Header*******************************\
* Module Name: hmgshare.h
*
*   Define shared dc attributes
*
* Created: 13-Apr-1995
* Author: Mark Enstrom [marke]
*
* Copyright (c) 1995-1999 Microsoft Corporation
\**************************************************************************/

/******************************WOW64***NOTE********************************\
* Note: Win32k Memory shared with User-Mode and Wow64
*
* For Wow64 (Win32 apps on Win64) we build a 32-bit version
* of user32.dll & gdi32.dll which can run against the 64-bit kernel
* with no changes to the 64-bit kernel code.
*
* For the 32 on 64 bit dlls all data structures which are shared with
* win32k must be 64-bit. These data structures include the shared
* sections, as well as the GDI TEB Batch.
* These shared data structures are now declared so that they can be
* built as 32 bit in a 32 bit dll, 64 bit in a 64 bit dll, and now
* 64 bit in a 32 bit dll.
*
* The following rules should be followed when declaring
* shared data structures:
*
*     Pointers in shared data structures use the KPTR_MODIFIER in their
*     declaration.
*
*     Handles in shared data structures are declared KHxxx.
*
*     xxx_PTR changes to KERNEL_xxx_PTR.
*
*     Pointers to basic types are declared as KPxxx;
*
* Also on Wow64 every thread has both a 32-bit TEB and a 64-bit TEB.
* GetCurrentTeb() returns the current 32-bit TEB while the kernel
* will allways reference the 64-bit TEB.
*
* All client side references to shared data in the TEB should use
* the new GetCurrentTebShared() macro which returns the 64-bit TEB
* for Wow64 builds and returns GetCurrentTeb() for regular builds.
* The exception to this rule is LastErrorValue, which should allways
* be referenced through GetCurrentTeb().
*
* Ex:
*
* DECLARE_HANDLE(HFOO);
*
* typedef struct _MY_STRUCT * KPTR_MODIFIER   PMPTR;
*
* struct _SHARED_STRUCT
* {
*     struct _SHARED_STRUCT *   pNext;
*     PMPTR                     pmptr;
*     HFOO                      hFoo;
*     UINT_PTR                  cb;
*     PBYTE                     pb;
*     PVOID                     pv;
*
*     DWORD                     dw;
*     USHORT                    us;
* } SHARED_STRUCT;
*
*
* Changes to:
*
*
* DECLARE_HANDLE(HFOO);
* DECLARE_KHANDLE(HFOO);
*
* typedef struct _MY_STRUCT *PMPTR;
*
* struct _SHARED_STRUCT
* {
*     struct _SHARED_STRUCT * KPTR_MODIFIER   pNext;
*     PMPTR                     pmptr;
*     KHFOO                     hFoo;
*     KERNEL_UINT_PTR           cb;
*     KPBYTE                    pb;
*     KERNEL_PVOID              pv;
*
*     DWORD                     dw;
*     USHORT                    us;
* } SHARED_STRUCT;
\***************************************************************************/

#ifndef GDIFLAGS_ONLY   // used for gdikdx

#include <w32wow64.h>

//Sundown: offsetof generates truncation warnings in 64bit environment
#undef offsetof
#define offsetof(c,f)      FIELD_OFFSET(c,f)

/*********************************Structure********************************\
*
* RGNATTR
*
* Description:
*
*   As an accelerator, this rectangular region is kept in the DC and
*   represents either a NULL region, a rectangular region, or hte bounding
*   box of a complex region. This can be used for a trivial reject clip test.
*
* Fields:
*
*   Flags  - state flags
*       NULLREGION      - drawing is allowed anywhere, no trivial clip
*       SIMPLEREGION    - Rect is the clip region
*       COMPLEXREGION   - Rect is the bounding box of a complex clip region
*       ERROR           - this information may not be used
*
*   LRFlags             - valid and dirty flags
*
*       Rect            - clip rectangle or bounding rectangle when in use
*
\**************************************************************************/

#endif  // GDIFLAGS_ONLY used for gdikdx

#define RREGION_INVALID ERROR

//
// ExtSelectClipRgn iMode extra flag for batching
//

#define REGION_NULL_HRGN 0X8000000

#ifndef GDIFLAGS_ONLY   // used for gdikdx

typedef struct _RGNATTR
{
    ULONG  AttrFlags;
    ULONG  Flags;
    RECTL  Rect;
} RGNATTR,*PRGNATTR;

/*******************************STRUCTURE**********************************\
* BRUSHATTR
*
* Fields:
*
*   lbColor - Color from CreateSolidBrush
*   lflag   - Brush operation flags
*
*      CACHED             - Set only when brush is cached on PEB
*      TO_BE_DELETED      - Set only after DelteteBrush Called in kernel
*                           when reference count of brush > 1, this will
*                           cause the brush to be deleted via lazy delete
*                           when it is selected out later.
*      NEW_COLOR          - Set when color changes (retrieve cached brush)
*      ATTR_CANT_SELECT   - Set when user calls DeleteObject(hbrush),
*                           brush is marked so can't be seleced in user
*                           mode. Not deleted until kernel mode DeleteBrush.
*                           This is not currently implemented.
*
* History:
*
*    6-Feb-1996 -by- Mark Enstrom [marke]
*
\**************************************************************************/

typedef struct _BRUSHATTR
{
    ULONG     AttrFlags;
    COLORREF  lbColor;
} BRUSHATTR,*PBRUSHATTR;

#endif  // GDIFLAGS_ONLY used for gdikdx

//
// Common flags for dealing with RGN/BRUSH ATTR memory
//

#define ATTR_CACHED             0x00000001
#define ATTR_TO_BE_DELETED      0x00000002
#define ATTR_NEW_COLOR          0x00000004
#define ATTR_CANT_SELECT        0x00000008
#define ATTR_RGN_VALID          0x00000010
#define ATTR_RGN_DIRTY          0x00000020

#ifndef GDIFLAGS_ONLY   // used for gdikdx

//
// Define a union so these objects can be managed together
//

typedef union _OBJECTATTR
{
    SINGLE_LIST_ENTRY   List;
    RGNATTR             Rgnattr;
    BRUSHATTR           Brushattr;
}OBJECTATTR,*POBJECTATTR;


/**************************************************************************\
 *
 * XFORM related structures and macros
 *
\**************************************************************************/

//
// These types are used to get things right when C code is passing C++
// defined transform data around.
//

typedef struct _MATRIX_S
{
    EFLOAT_S    efM11;
    EFLOAT_S    efM12;
    EFLOAT_S    efM21;
    EFLOAT_S    efM22;
    EFLOAT_S    efDx;
    EFLOAT_S    efDy;
    FIX         fxDx;
    FIX         fxDy;
    FLONG       flAccel;
} MATRIX_S;

#endif  // GDIFLAGS_ONLY used for gdikdx

//
// status and dirty flags
//

#define DIRTY_FILL              0x00000001
#define DIRTY_LINE              0x00000002
#define DIRTY_TEXT              0x00000004
#define DIRTY_BACKGROUND        0x00000008
#define DIRTY_CHARSET           0x00000010
#define SLOW_WIDTHS             0x00000020
#define DC_CACHED_TM_VALID      0x00000040
#define DISPLAY_DC              0x00000080
#define DIRTY_PTLCURRENT        0x00000100
#define DIRTY_PTFXCURRENT       0x00000200
#define DIRTY_STYLESTATE        0x00000400
#define DC_PLAYMETAFILE         0x00000800
#define DC_BRUSH_DIRTY          0x00001000      // cached brush
#define DC_PEN_DIRTY            0x00002000
#define DC_DIBSECTION           0x00004000
#define DC_LAST_CLIPRGN_VALID   0x00008000
#define DC_PRIMARY_DISPLAY      0x00010000
#define DIRTY_COLORTRANSFORM    0x00020000
#define ICM_BRUSH_TRANSLATED    0x00040000
#define ICM_PEN_TRANSLATED      0x00080000
#define DIRTY_COLORSPACE        0x00100000
#define BATCHED_DRAWING         0x00200000
#define BATCHED_TEXT            0x00400000

#ifndef GDIFLAGS_ONLY   // used for gdikdx

#define CLEAR_CACHED_TEXT(pdcattr)  (pdcattr->ulDirty_ &= ~(SLOW_WIDTHS))


#define DIRTY_BRUSHES  (DIRTY_FILL+DIRTY_LINE+DIRTY_TEXT+DIRTY_BACKGROUND)


#define USER_XFORM_DIRTY(pdcattr) (pdcattr->flXform & (PAGE_XLATE_CHANGED | PAGE_EXTENTS_CHANGED | WORLD_XFORM_CHANGED))

#endif  // GDIFLAGS_ONLY used for gdikdx


/**************************************************************************\
 *
 * ICM related structures and macros
 *
\**************************************************************************/

//
// ICM flags
//
// DC_ATTR.lIcmMode
//
// 0x0 000 0 0 00
//   |   | | |  + Current ICM Mode  (kernel/user)
//   |   | | + Requested ICM Mode   (kernel/user)
//   |   | + ICM Mode context       (user only)
//   |   + not used
//   + Destination color type       (kernel/user)

#define DC_ICM_USERMODE_FLAG         0x0000F000

//
// Current ICM mode flags.
//
#define DC_ICM_OFF                   0x00000000
#define DC_ICM_HOST                  0x00000001
#define DC_ICM_DEVICE                0x00000002
#define DC_ICM_OUTSIDEDC             0x00000004
#define DC_ICM_METAFILING_ON         0x00000008
#define DC_ICM_LAZY_CORRECTION       0x00000010 // alt mode (preserved through icm mode change)
#define DC_ICM_DEVICE_CALIBRATE      0x00000020 // alt mode (preserved through icm mode change)
#define DC_ICM_MODE_MASK             0x000000FF
#define DC_ICM_ALT_MODE_MASK         0x000000F0

#ifndef GDIFLAGS_ONLY   // used for gdikdx

#define ICM_MODE(x)         ((x) & DC_ICM_MODE_MASK)
#define ICM_ALT_MODE(x)     ((x) & DC_ICM_ALT_MODE_MASK)

#define IS_ICM_DEVICE(x)    ((x) & DC_ICM_DEVICE)
#define IS_ICM_HOST(x)      ((x) & DC_ICM_HOST)
#define IS_ICM_INSIDEDC(x)  ((x) & (DC_ICM_DEVICE|DC_ICM_HOST))
#define IS_ICM_OUTSIDEDC(x) ((x) & DC_ICM_OUTSIDEDC)
#define IS_ICM_ON(x)        ((x) & (DC_ICM_DEVICE|DC_ICM_HOST|DC_ICM_OUTSIDEDC))

#define IS_ICM_METAFILING_ON(x)    ((x) & DC_ICM_METAFILING_ON)
#define IS_ICM_LAZY_CORRECTION(x)  ((x) & DC_ICM_LAZY_CORRECTION)
#define IS_ICM_DEVICE_CALIBRATE(x) ((x) & DC_ICM_DEVICE_CALIBRATE)

#endif  // GDIFLAGS_ONLY used for gdikdx
//
// Request ICM mode flags
//
#define REQ_ICM_OFF                  0x00000000
#define REQ_ICM_HOST                 0x00000100
#define REQ_ICM_DEVICE               0x00000200
#define REQ_ICM_OUTSIDEDC            0x00000400

#ifndef GDIFLAGS_ONLY   // used for gdikdx

#define REQ_ICM_MODE(x)       ((x) & 0x00000F00)

#define IS_ICM_DEVICE_REQUESTED(x)  ((x) & REQ_ICM_DEVICE)

//
// Convert Request mode to current ICM mode flags.
//
#define ICM_REQ_TO_MODE(x) ((REQ_ICM_MODE((x))) >> 8)

#endif  // GDIFLAGS_ONLY used for gdikdx

//
// Context mode for ICM.
//
#define CTX_ICM_HOST                 0x00001000 // Host ICM
#define CTX_ICM_DEVICE               0x00002000 // Device ICM
#define CTX_ICM_METAFILING_OUTSIDEDC 0x00004000 // Metfiling outside DC ICM mode
#define CTX_ICM_PROOFING             0x00008000 // Proofing mode

#ifndef GDIFLAGS_ONLY   // used for gdikdx

#define SET_HOST_ICM_DEVMODE(x)     ((x) |= CTX_ICM_HOST)
#define SET_DEVICE_ICM_DEVMODE(x)   ((x) |= CTX_ICM_DEVICE)
#define SET_ICM_PROOFING(x)         ((x) |= CTX_ICM_PROOFING)

#define CLEAR_ICM_PROOFING(x)       ((x) &= ~CTX_ICM_PROOFING)

#define IS_DEVICE_ICM_DEVMODE(x)    ((x) & CTX_ICM_DEVICE)
#define IS_ICM_PROOFING(x)          ((x) & CTX_ICM_PROOFING)

#endif  // GDIFLAGS_ONLY used for gdikdx
//
// Destination Color Type
//
#define DC_ICM_CMYK_COLOR            0x10000000
#define DC_ICM_RGB_COLOR             0x20000000
#define DC_ICM_COLORTYPE_MASK        0xF0000000


#ifndef GDIFLAGS_ONLY   // used for gdikdx

#define DC_ICM_32BITS_COLOR         (DC_ICM_CMYK_COLOR)

#define IS_32BITS_COLOR(x) ((x) & DC_ICM_32BITS_COLOR)
#define IS_CMYK_COLOR(x)   ((x) & DC_ICM_CMYK_COLOR)

#define GET_COLORTYPE(x)   ((x) & DC_ICM_COLORTYPE_MASK)
#define CLEAR_COLORTYPE(x) ((x) &= ~DC_ICM_COLORTYPE_MASK)

/******************************Structure***********************************\
*
* DC_ATTR: This structure provides a common DC area visible both by in kernel
* and user mode. Since elements in the DC_ATTR are visible and modifiable
* in user-mode, data that must be kept safe must be stored in the kernel
* private DC structure.
*
\**************************************************************************/

typedef struct _DC_ATTR
{
    //
    // local dc info
    //

    KERNEL_PVOID pvLDC;

    //
    // General Purpose Dirty Flags for brushes, fonts, etc.
    //

    ULONG       ulDirty_;

    //
    // brush handle selected into DCATTR, not neccessarily selected
    // into DC
    //

    KHANDLE     hbrush;
    KHANDLE     hpen;

    //
    // *** Attribute Bundles ***
    //
    // When ICM is enabled,
    //  + cr____Clr color is corrected to DC's color space.
    //  + ul____Clr keeps original (un-corrected) color.
    //

    COLORREF    crBackgroundClr;    // Set/GetBkColor
    ULONG       ulBackgroundClr;    // Set/GetBkColor client attr
    COLORREF    crForegroundClr;    // Set/GetTextColor
    ULONG       ulForegroundClr;    // Set/GetTextColor client attr

    //
    // *** DC Brush color
    //
    // When ICM is enabled,
    //  + cr____Clr color is corrected to DC's color space.
    //  + ul____Clr keeps original (un-corrected) color.
    //

    COLORREF    crDCBrushClr;       // Set/GetDCBrushColor client attr
    ULONG       ulDCBrushClr;       // Set/GetDCBrushColor client attr
    COLORREF    crDCPenClr;         // Set/GetDCPenColor
    ULONG       ulDCPenClr;         // Set/GetDCPenColor client attr

    //
    // *** Misc. Attrs.
    //

    DWORD       iCS_CP;             // LOWORD: code page HIWORD charset
    int         iGraphicsMode;      // Set/GetGraphicsMode
    BYTE        jROP2;              // Set/GetROP2
    BYTE        jBkMode;            // TRANSPARENT/OPAQUE
    BYTE        jFillMode;          // ALTERNATE/WINDING
    BYTE        jStretchBltMode;    // BLACKONWHITE/WHITEONBLACK/
                                    //   COLORONCOLOR/HALFTONE
    POINTL      ptlCurrent;         // Current position in logical coordinates
                                    //   (invalid if DIRTY_PTLCURRENT set)
    POINTL      ptfxCurrent;        // Current position in device coordinates
                                    //   (invalid if DIRTY_PTFXCURRENT set)

    //
    // original values set by app
    //

    LONG        lBkMode;
    LONG        lFillMode;
    LONG        lStretchBltMode;

    FLONG       flFontMapper;           // Font mapper flags

    //
    // *** ICM attributes
    //

    LONG             lIcmMode;         // Currnt ICM mode (DC_ICM_xxxx)
    KHANDLE          hcmXform;         // Handle of Current Color Transform
    KHCOLORSPACE     hColorSpace;      // Handle of Source Color Space
    KERNEL_ULONG_PTR dwDIBColorSpace;  // Identifier of DIB Color Space Data (when DIB selected)
                                       // Sundown: dwDIBColorSpace actually takes a pointer in,
                                       //          change from DWORD to ULONG_PTR
    COLORREF         IcmBrushColor;    // ICM-ed color for the brush selected in this DCATTR (Solid or Hatch)
    COLORREF         IcmPenColor;      // ICM-ed color for the pen selected in this DCATTR
    KERNEL_PVOID     pvICM;            // Pointer to client-side ICM information

    //
    // *** Text attributes
    //

    FLONG       flTextAlign;
    LONG        lTextAlign;
    LONG        lTextExtra;         // Inter-character spacing
    LONG        lRelAbs;            // Moved over from client side
    LONG        lBreakExtra;
    LONG        cBreak;

    KHANDLE     hlfntNew;          // Log font selected into DC

    //
    // Transform data.
    //

    MATRIX_S    mxWtoD;                 // World to Device Transform.
    MATRIX_S    mxDtoW;                 // Device to World.
    MATRIX_S    mxWtoP;                 // World transform
    EFLOAT_S    efM11PtoD;              // efM11 of the Page transform
    EFLOAT_S    efM22PtoD;              // efM22 of the Page transform
    EFLOAT_S    efDxPtoD;               // efDx of the Page transform
    EFLOAT_S    efDyPtoD;               // efDy of the Page transform
    INT         iMapMode;               // Map mode
    DWORD       dwLayout;               // Layout orientation bits.
    LONG        lWindowOrgx;            // The logical x window origin.
    POINTL      ptlWindowOrg;           // Window origin.
    SIZEL       szlWindowExt;           // Window extents.
    POINTL      ptlViewportOrg;         // Viewport origin.
    SIZEL       szlViewportExt;         // Viewport extents.
    FLONG       flXform;                // Flags for transform component.
    SIZEL       szlVirtualDevicePixel;  // Virtual device size in pels.
    SIZEL       szlVirtualDeviceMm;     // Virtual device size in mm's.
    SIZEL       szlVirtualDevice;       // Virtual device size

    POINTL      ptlBrushOrigin;         // Alignment origin for brushes

    //
    // dc regions
    //

    RGNATTR     VisRectRegion;

} DC_ATTR,*PDC_ATTR;


//
// conditional system definitions
//

#if !defined(_NTOSP_) && !defined(_USERKDX_)
typedef struct _W32THREAD * KPTR_MODIFIER PW32THREAD;
typedef ULONG W32PID;
DECLARE_HANDLE(HOBJ);
DECLARE_KHANDLE(HOBJ);
#endif

/*****************************Struct***************************************\
*
* BASEOBJECT
*
* Description:
*
*   Each GDI object has a BASEOBJECT at the beggining of the object. This
*   enables fast references to the handle and back to the entry.
*
* Fields:
*
*   hHmgr           - object handle
*   ulShareCount    - the shared reference count on the object
*   cExclusiveLock  - object exclusive lock count
*   BaseFlags       - flags representing state of underlying memory
*   tid             - thread id of exclusive lock owner
*
* Note:
*
*   Most of the BASEOBJECT represents state logically associated with the
*   object.  When objects are swapped (for example, when doing a realloc
*   to grow the object), the BASEOBJECT is swapped to preserve the handle
*   and locking information.
*
*   However, the BaseFlags field was added as an optimization to allow
*   allocation from a "lookaside" list of preallocated objects.  The
*   BaseFlags field is metadata associated with the memory containing
*   an object; it is not associated with the object itself.
*
*   Current BASEOBJECT swapping code "unswaps" the BaseFlags so that it
*   always remains associated with the memory, not the object.
*
*   If flags are added to BaseFlags, they must not represent object state.
*   If it is necessary to add such flags, the BaseFlags field could be
*   reduced to a BYTE field and a new BYTE flags field can be added to
*   represent state that is associated with the object.
*
*   Currently, BASEOBJECT swapping code is in HmgSwapLockedHandleContents
*   and RGNOBJ::bSwap (hmgrapi.cxx and rgnobj.cxx, respectively).
*
\**************************************************************************/

// BASEOBJECT FLAGS

//
// Due to the read-modify-write cycle and the fact that the Alpha can
// load and store a minimum of 32bit values, setting BaseFlags requires
// an InterlockedCompareExchange loop so that it doesn't interfere with the
// cExclusiveLock.
//
// HMGR_LOOKASIDE_ALLOC_FLAG is a 'static' flag - it doesn't change after
// it is set on object allocation. If anyone adds a 'dynamic' flag they
// should probably restructure BASEOBJECT to use a DWORD for the BaseFlags and
// a DWORD for the cExclusiveLock.
//
// If anyone restructures BASEOBJECT they'll have to rewrite all the code
// that uses cExclusiveLock and BaseFlags.
// This includes:
// INC_EXCLUSIVE_REF_CNT and DEC_EXCLUSIVE_REF_CNT
// RGNOBJ::bSwap
//
// Also if anyone adds fields to BASEOBJECT they need to go and fix RGNOBJ::bSwap
// to also copy those fields.
//
//

#endif  // GDIFLAGS_ONLY used for gdikdx

#define HMGR_LOOKASIDE_ALLOC_FLAG       0x8000

#ifndef GDIFLAGS_ONLY   // used for gdikdx

typedef struct _BASEOBJECT
{
    KHANDLE             hHmgr;
    ULONG               ulShareCount;
    USHORT              cExclusiveLock;
    USHORT              BaseFlags;
    PW32THREAD          Tid;
} BASEOBJECT, * KPTR_MODIFIER POBJ;

/*****************************Struct***************************************\
*
* OBJECTOWNER
*
* Description:
*
*   This object is used for shared and exclusive object ownership
*
* Fields for shared Object:
*
*   Pid   : 31
*   Lock  :  1
*
\**************************************************************************/

//
// The lock and the Pid share the same DWORD.
//
// It seems that this is safe from the word tearing problem on the Alpha architecture
// due to the fact that we always use the InterlockedCompareExchange loop for
// the Lock and we require that the lock is set when setting the Pid.
//

typedef struct _OBJECTOWNER_S
{
    ULONG   Lock:1;
    W32PID  Pid_Shifted:31;  // The lowest two bits of the PID are
                             // reserved for application use.  However,
                             // the second bit is used by the
                             // OBJECT_OWNER_xxxx constants and so we
                             // use 31 bits for the Pid_Shifted field.
                             // WARNING:  do not access this field directly,
                             // but rather via the macros below.
}OBJECTOWNER_S,*POBJECTOWNER_S;

#endif  // GDIFLAGS_ONLY used for gdikdx

// Note:  when accessing the Pid_Shifted field the compiler will shift the
// value by one bit to account for the field being only in the upper 31
// bits of the OBJECTOWNER_S structure.  For example, if the OBJECTOWNER_S
// is 8, the Pid_Shifted would be only 4.  However, since we are really
// interested in the upper 31 bits of the PID, this shifting is not
// appropriate (we need masking instead).  I'm not aware of any compiler
// primitives that will accomplish this and will use the macros below
// instead.

#define LOCK_MASK 0x00000001
#define PID_MASK  0xfffffffe

#define PID_BITS 0xfffffffc  // The actual bits used by the PID

#ifndef GDIFLAGS_ONLY   // used for gdikdx

#define OBJECTOWNER_PID(ObjectOwner)                                          \
    ((W32PID) ((ObjectOwner).ulObj & PID_MASK))

#define SET_OBJECTOWNER_PID(ObjectOwner, Pid)                                 \
    ((ObjectOwner).ulObj) = ((ObjectOwner).ulObj & LOCK_MASK) | ((Pid) & PID_MASK);

typedef union _OBJECTOWNER
{
    OBJECTOWNER_S   Share;
    ULONG           ulObj;
}OBJECTOWNER,*POBJECTOWNER;

typedef UCHAR OBJTYPE;

typedef union _EINFO
{
    POBJ      pobj;               // Pointer to object
    HOBJ     hFree;              // Next entry in free list
} EINFO;

#endif  // GDIFLAGS_ONLY used for gdikdx

/*****************************Struct***************************************\
*
* ENTRY
*
* Description:
*
*   This object is allocated for each entry in the handle manager and
*   keeps track of object owners, reference counts, pointers, and handle
*   objt and iuniq
*
* Fields:
*
*   einfo       - pointer to object or next free handle
*   ObjectOwner - lock object
*   ObjectInfo  - Object Type, Unique and flags
*   pUser       - Pointer to user-mode data
*
\**************************************************************************/

// entry.Flags flags

#define HMGR_ENTRY_UNDELETABLE  0x0001
#define HMGR_ENTRY_LAZY_DEL     0x0002
#define HMGR_ENTRY_INVALID_VIS    0x0004
#define HMGR_ENTRY_LOOKASIDE_ALLOC 0x0010

#ifndef GDIFLAGS_ONLY   // used for gdikdx

typedef struct _ENTRY
{
    EINFO       einfo;
    OBJECTOWNER ObjectOwner;
    USHORT      FullUnique;
    OBJTYPE     Objt;
    UCHAR       Flags;
    KERNEL_PVOID pUser;
} ENTRY, *PENTRY;

typedef union _PENTOBJ
{
    PENTRY pent;
    POBJ   pobj;
} PENTOBJ;

#endif  // GDIFLAGS_ONLY used for gdikdx

//
// status flags used by metafile in user and kernel
//

#define MRI_ERROR       0
#define MRI_NULLBOX     1
#define MRI_OK          2

/*******************************STRUCTURE**********************************\
* GDIHANDLECACHE
*
*   Cache common handle types, when a handle with user mode attributes is
*   deleted, an attempt is made to cache the handle on memory accessable
*   in user mode.
*
* Fields:
*
*   Lock - CompareExchange used to gain ownership
*   pCacheEntr[] - array of offsets to types
*   ulBuffer     - buffer for storage of all handle cache entries
*
*
* History:
*
*    30-Jan-1996 -by- Mark Enstrom [marke]
*
\**************************************************************************/


//
// defined cached handle types
//

#define GDI_CACHED_HADNLE_TYPES 4

#define CACHE_BRUSH_ENTRIES  10
#define CACHE_PEN_ENTRIES     8
#define CACHE_REGION_ENTRIES  8
#define CACHE_LFONT_ENTRIES   1

#ifndef GDIFLAGS_ONLY   // used for gdikdx

typedef enum _HANDLECACHETYPE
{
    BrushHandle,
    PenHandle,
    RegionHandle,
    LFontHandle
}HANDLECACHETYPE,*PHANDLECACHETYPE;



typedef struct _GDIHANDLECACHE
{
    KERNEL_PVOID    Lock;
    ULONG           ulNumHandles[GDI_CACHED_HADNLE_TYPES];
    KHANDLE         Handle[CACHE_BRUSH_ENTRIES  +
                           CACHE_PEN_ENTRIES    +
                           CACHE_REGION_ENTRIES +
                           CACHE_LFONT_ENTRIES];
}GDIHANDLECACHE,*PGDIHANDLECACHE;


/*********************************MACRO************************************\
*  Lock handle cache by placing -1 into lock variable using cmp-exchange
*
* Arguments:
*
*   p       - handle cache pointer
*   uLock   - Thread specific lock ID (TEB or THREAD)
*   bStatus - Lock status
*
* History:
*
*    22-Feb-1996 -by- Mark Enstrom [marke]
*
\**************************************************************************/

#if defined(BUILD_WOW6432)
KERNEL_PVOID
InterlockedCompareExchangeKernelPointer(
     KERNEL_PVOID *Destination,
     KERNEL_PVOID Exchange,
     KERNEL_PVOID Compare
     );
#else
#define InterlockedCompareExchangeKernelPointer InterlockedCompareExchangePointer
#endif

#define LOCK_HANDLE_CACHE(p,uLock,bStatus)                  \
{                                                           \
    KERNEL_PVOID OldLock  = p->Lock;                        \
    bStatus = FALSE;                                        \
                                                            \
    if (OldLock ==      NULL)                               \
    {                                                       \
        if (InterlockedCompareExchangeKernelPointer(        \
                   &p->Lock,                                \
                   uLock,                                   \
                   OldLock) == OldLock)                     \
        {                                                   \
            bStatus = TRUE;                                 \
        }                                                   \
    }                                                       \
}


/*********************************MACRO************************************\
* unlock locked structure by writing null back to lock variable
*
* Arguments:
*
*   p - pointer to handle cache
*
* Return Value:
*
*   none
*
* History:
*
*    22-Feb-1996 -by- Mark Enstrom [marke]
*
\**************************************************************************/

#if defined(BUILD_WOW6432) && defined(_X86_)

/* It is assumed that p->Lock will be updated atomically.  This is true for alpha,
   but it is not true for the 32bit x86 dll on wow64 since Lock is a 64bit quantity
   which requires 2 mov instructions.  So call InterlockedCompareExchangeKernelPointer
   to set it.
*/

#define UNLOCK_HANDLE_CACHE(p)                              \
   InterlockedCompareExchangeKernelPointer(&p->Lock, NULL, p->Lock);

#else

#define UNLOCK_HANDLE_CACHE(p)                              \
{                                                           \
    p->Lock = NULL;                                         \
}

#endif

#endif  // GDIFLAGS_ONLY used for gdikdx

/******************************Struct**************************************\
* CFONT
*
* Client side realized font.  Contains widths of all ANSI characters.
*
* We keep a free list of CFONT structures for fast allocation.  The
* reference count counts pointers to this structure from all LDC and
* LOCALFONT structures.  When this count hits zero, the CFONT is freed.
*
* The only "inactive" CFONTs that we keep around are those referenced by
* the LOCALFONT.
*
* (In the future we could expand this to contain UNICODE info as well.)
*
*  Mon 11-Jun-1995 00:36:14 -by- Gerrit van Wingerden [gerritv]
* Addapted for kernel mode
*  Sun 10-Jan-1993 00:36:14 -by- Charles Whitmer [chuckwh]
* Wrote it.
\**************************************************************************/

#define CFONT_COMPLETE          0x0001
#define CFONT_EMPTY             0x0002
#define CFONT_DBCS              0x0004
#define CFONT_CACHED_METRICS    0x0008  // we have cached the metrics
#define CFONT_CACHED_AVE        0x0010  // we have cached the average width
#define CFONT_CACHED_WIDTHS     0x0020  // if off, no widths have been computed
#define CFONT_PUBLIC            0x0040  // if public font in public cache
#define CFONT_CACHED_RI         0x0080  // if off, RealizationInfo (RI) has not been cached

#ifndef GDIFLAGS_ONLY   // used for gdikdx

#define DEC_CFONT_REF(pcf)  {if (!((pcf)->fl & CFONT_PUBLIC)) --(pcf)->cRef;}
#define INC_CFONT_REF(pcf)  {ASSERTGDI(!((pcf)->fl & CFONT_PUBLIC),"pcfLocate - public font error\n");++(pcf)->cRef;}

typedef struct _CFONT * KPTR_MODIFIER PCFONT;
typedef struct _CFONT
{
    PCFONT          pcfNext;
    KHFONT          hf;
    ULONG           cRef;               // Count of all pointers to this CFONT.
    FLONG           fl;
    LONG            lHeight;            // Precomputed logical height.

// The following are keys to match when looking for a mapping.

    KHDC            hdc;                // HDC of realization.  0 for display.
    EFLOAT_S        efM11;              // efM11 of WtoD of DC of realization
    EFLOAT_S        efM22;              // efM22 of WtoD of DC of realization

    EFLOAT_S        efDtoWBaseline;     // Precomputed back transform.  (FXtoL)
    EFLOAT_S        efDtoWAscent;       // Precomputed back transform.  (FXtoL)

// various extra width info

    WIDTHDATA       wd;

// Font info flags.

    FLONG       flInfo;

// The width table.

    USHORT          sWidth[256];        // Widths in pels.

// other usefull cached info

    ULONG           ulAveWidth;         // bogus average used by USER
    TMW_INTERNAL    tmw;                // cached metrics

#ifdef LANGPACK
// RealizationInfo for this font
    REALIZATION_INFO ri ;
#endif

	LONG			timeStamp;			// to check if cached realization info is updated            			

} CFONT;

/*******************************STRUCTURE**********************************\
*
*   This structure controls the address for allocating and mapping the
*   global shared handle table and device caps (primary display) that
*   is mapped read-only into all user mode processes
*
* Fields:
*
*  aentryHmgr - Handle table
*  DevCaps    - Cached primary display device caps
*
\**************************************************************************/

#define MAX_PUBLIC_CFONT 16

typedef struct _GDI_SHARED_MEMORY
{
    ENTRY   aentryHmgr[MAX_HANDLE_COUNT];
    DEVCAPS DevCaps;
    ULONG   iDisplaySettingsUniqueness;
#ifdef LANGPACK
    DWORD   dwLpkShapingDLLs;
#endif
    CFONT   acfPublic[MAX_PUBLIC_CFONT];
    LONG	timeStamp;

} GDI_SHARED_MEMORY, *PGDI_SHARED_MEMORY;

/***********************************Structure******************************\
*
* GDI TEB Batching
*
* Contains the data structures and constants used for the batching of
* GDI calls to avoid kernel mode transition costs.
*
* History:
*    20-Oct-1995 -by- Mark Enstrom [marke]
*
\**************************************************************************/

typedef enum _BATCH_TYPE
{
    BatchTypePatBlt,
    BatchTypePolyPatBlt,
    BatchTypeTextOut,
    BatchTypeTextOutRect,
    BatchTypeSetBrushOrg,
    BatchTypeSelectClip,
    BatchTypeSelectFont,
    BatchTypeDeleteBrush,
    BatchTypeDeleteRegion
} BATCH_TYPE,*PBATCH_TYPE;

typedef struct _BATCHCOMMAND
{
    USHORT  Length;
    USHORT  Type;
}BATCHCOMMAND,*PBATCHCOMMAND;

typedef struct _BATCHDELETEBRUSH
{
    USHORT  Length;
    USHORT  Type;
    KHBRUSH hbrush;
}BATCHDELETEBRUSH,*PBATCHDELETEBRUSH;

typedef struct _BATCHDELETEREGION
{
    USHORT  Length;
    USHORT  Type;
    KHRGN   hregion;
}BATCHDELETEREGION,*PBATCHDELETEREGION;

typedef struct _BATCHSETBRUSHORG
{
    USHORT  Length;
    USHORT  Type;
    int     x;
    int     y;
}BATCHSETBRUSHORG,*PBATCHSETBRUSHORG;

typedef struct _BATCHPATBLT
{
    USHORT   Length;
    USHORT   Type;
    LONG     x;
    LONG     y;
    LONG     cx;
    LONG     cy;
    KHBRUSH  hbr;
    ULONG    rop4;
    ULONG    TextColor;
    ULONG    BackColor;
    COLORREF DCBrushColor;
    COLORREF IcmBrushColor;
    POINTL   ptlViewportOrg;
    ULONG    ulTextColor;
    ULONG    ulBackColor;
    ULONG    ulDCBrushColor;
}BATCHPATBLT,*PBATCHPATBLT;


typedef struct _BATCHPOLYPATBLT
{
    USHORT  Length;
    USHORT  Type;
    ULONG   rop4;
    ULONG   Mode;
    ULONG   Count;
    ULONG   TextColor;
    ULONG   BackColor;
    COLORREF DCBrushColor;
    ULONG   ulTextColor;
    ULONG   ulBackColor;
    ULONG   ulDCBrushColor;
    POINTL   ptlViewportOrg;
    //
    // Variable length buffer for POLYPATBLT struct.  Must be naturally
    // aligned.
    //
    KERNEL_PVOID ulBuffer[1];
}BATCHPOLYPATBLT,*PBATCHPOLYPATBLT;

typedef struct _BATCHTEXTOUT
{
    USHORT  Length;
    USHORT  Type;
    ULONG   TextColor;
    ULONG   BackColor;
    ULONG   BackMode;
    ULONG   ulTextColor;
    ULONG   ulBackColor;
    LONG    x;
    LONG    y;
    ULONG   fl;
    RECTL   rcl;
    DWORD   dwCodePage;
    ULONG   cChar;
    ULONG   PdxOffset;
    KHANDLE hlfntNew;
    UINT    flTextAlign;
    POINTL   ptlViewportOrg;

    //
    // variable length buffer for WCHAR and pdx data
    //

    ULONG   ulBuffer[1];
}BATCHTEXTOUT,*PBATCHTEXTOUT;

typedef struct _BATCHTEXTOUTRECT
{
    USHORT  Length;
    USHORT  Type;
    ULONG   BackColor;
    ULONG   fl;
    RECTL   rcl;
    POINTL   ptlViewportOrg;
    ULONG   ulBackColor;
}BATCHTEXTOUTRECT,*PBATCHTEXTOUTRECT;

typedef struct _BATCHSELECTCLIP
{
    USHORT  Length;
    USHORT  Type;
    int     iMode;
    RECTL   rclClip;
}BATCHSELECTCLIP,*PBATCHSELECTCLIP;

typedef struct _BATCHSELECTFONT
{
    USHORT  Length;
    USHORT  Type;
    KHANDLE hFont;
}BATCHSELECTFONT,*PBATCHSELECTFONT;



//
// GDI_BATCH_BUFFER_SIZE is space (IN BYTES) in TEB allocated
// for GDI batching
//

#if defined(_GDIPLUS_)

    #define GDI_BATCH_SIZE 0

#else

    #define GDI_BATCH_SIZE 4 * GDI_BATCH_BUFFER_SIZE

#endif

//
// Image32 data
//

typedef enum _IMAGE_TYPE
{
    Image_Alpha,
    Image_AlphaDIB,
    Image_Transparent,
    Image_TransparentDIB,
    Image_Stretch,
    Image_StretchDIB
}IMAGE_TYPE,*PIMAGE_TYPE;

#endif  // GDIFLAGS_ONLY used for gdikdx

// these strings are included in both gre\mapfile.c and client\output.c
// so we put them here so that we can manage the changes from
// the unified place.

//
// This rubbish comment is in win95 sources. I leave it here for reference
// [bodind]
//

//
// this static data goes away as soon as we get the correct functionality in
// NLS. (its in build 162, use it in buid 163)
//

#define NCHARSETS      16
#define CHARSET_ARRAYS                                                      \
UINT nCharsets = NCHARSETS;                                                 \
UINT charsets[] = {                                                         \
      ANSI_CHARSET,   SHIFTJIS_CHARSET, HANGEUL_CHARSET, JOHAB_CHARSET,     \
      GB2312_CHARSET, CHINESEBIG5_CHARSET, HEBREW_CHARSET,                  \
      ARABIC_CHARSET, GREEK_CHARSET,       TURKISH_CHARSET,                 \
      BALTIC_CHARSET, EASTEUROPE_CHARSET,  RUSSIAN_CHARSET, THAI_CHARSET,   \
      VIETNAMESE_CHARSET, SYMBOL_CHARSET};                                  \
UINT codepages[] ={ 1252, 932, 949, 1361,                                   \
                    936,  950, 1255, 1256,                                  \
                    1253, 1254, 1257, 1250,                                 \
                    1251, 874 , 1258, 42};                                  \
DWORD fs[] = { FS_LATIN1,      FS_JISJAPAN,    FS_WANSUNG, FS_JOHAB,        \
               FS_CHINESESIMP, FS_CHINESETRAD, FS_HEBREW,  FS_ARABIC,       \
               FS_GREEK,       FS_TURKISH,     FS_BALTIC,  FS_LATIN2,       \
               FS_CYRILLIC,    FS_THAI,        FS_VIETNAMESE, FS_SYMBOL };

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\inc\fontcs.h ===
/******************************Module*Header*******************************\
* Module Name: fontcs.h
*
* Copyright (c) 1997-1999 Microsoft Corporation
\**************************************************************************/

#define FONT_SERVER_BUFFER_SIZE 0xFFF00

typedef double Align;

#define HEAP_RESERVE 0x100000
#define HEAP_COMMIT  0x10000
#define HEAP_FREE    0x1000

#define ROUNDUP(x,y) ((y)*(((x)+(y)-1)/(y)))

#define SBRK_ERR (char*)(-1)

typedef union _HEADER {
    struct {
        DWORD Tag;
        union _HEADER *pNext;
        unsigned cUnits;
        unsigned cUnused;
    };
    Align x;
} HEADER;

typedef union _HEAP_OBJECT {
    struct {
        unsigned  FreeAlign;
        unsigned  CommitAlign;
            char *pLinearBase;
        unsigned  iFree;
        unsigned  iUncommitted;
        unsigned  iUnreserved;
          HEADER *pFree;     // pointer to free HEADER block
          HEADER  AllocBase; // base HEADER structure for allocation
    };
    Align x;
} HEAP_OBJECT;

typedef enum _DRVPROCID {
    IdEnableDriver         =  0,
    IdEnablePDEV           =  1,
    IdDisablePDEV          =  2,
    IdCompletePDEV         =  3,
    IdQueryFont            =  4,
    IdQueryFontTree        =  5,
    IdQueryFontData        =  6,
    IdDestroyFont          =  7,
    IdQueryFontCaps        =  8,
    IdLoadFontFile         =  9,
    IdUnloadFontFile       = 10,
    IdQueryFontFile        = 11,
    IdQueryAdvanceWidths   = 12,
    IdFree                 = 13,
    IdQueryTrueTypeTable   = 14,
    IdQueryTrueTypeOutline = 15,
    IdGetTrueTypeFile      = 16,
    IdEscape               = 17
} DRVPROCID;

typedef enum _DRIVER_ID {
    BogusDriverId       =   0,
    TrueTypeDriverId    =   1,
    ATMDriverId         =   2
} DRIVER_ID;

typedef union _PROXYMSG {
    struct {
        DRIVER_ID DriverId;                     // 1=TrueType,2=ATM,...
        DRVPROCID ProcId;
         unsigned cjThis;                       // includes header
         struct {
             int bVerbose  : 1;                 // for debugging
             int bException: 1;
         } Flags;
        union {
            struct {
                         BOOL  ReturnValue   ;
                        ULONG  iEngineVersion;
                        ULONG  cj            ;
                DRVENABLEDATA *pded          ;
            } EnableDriver_;
            struct {
                  DHPDEV  ReturnValue   ;
                DEVMODEW *pdm           ;
                  LPWSTR  pwszLogAddress;
                   ULONG  cPat          ;
                   HSURF *phsurfPatterns;
                   ULONG  cjCaps        ;
                   ULONG *pGdiInfo      ;
                   ULONG  cjDevInfo     ;
                 DEVINFO *pdi           ;
                    HDEV  hdev          ;
                  LPWSTR  pwszDeviceName;
                  HANDLE  hDriver       ;
            } EnablePDEV_;
            struct {
                DHPDEV dhpdev;
            } DisablePDEV_;
            struct {
                DHPDEV dhpdev;
                  HDEV hdev  ;
            } CompletePDEV_;
            struct {
                IFIMETRICS *ReturnValue;
                    DHPDEV  dhpdev     ;
                     ULONG  iFile      ;
                     ULONG  iFace      ;
                     ULONG *pid        ;
            } QueryFont_;
            struct {
                 PVOID  ReturnValue ;
                DHPDEV  dhpdev      ;
                 ULONG  iFile       ;
                 ULONG  iFace       ;
                 ULONG  iMode       ;
                 ULONG *pid         ;
            } QueryFontTree_;
            struct {
                     LONG  ReturnValue;
                   DHPDEV  dhpdev     ;
                  FONTOBJ *pfo        ;
                    ULONG  iMode      ;
                   HGLYPH  hg         ;
                GLYPHDATA *pgd        ;
                    PVOID  pv         ;
                    ULONG  cjSize     ;
            } QueryFontData_;
            struct {
                FONTOBJ *pfo;
            } DestroyFont_;
            struct {
                 LONG  ReturnValue;
                ULONG  culCaps    ;
                ULONG *pulCaps    ;
            } QueryFontCaps_;
            struct {
                ULONG  ReturnValue;
                ULONG  cFiles     ;
                ULONG *piFile     ;
                PVOID *ppvView    ;
                ULONG *pcjView    ;
                DESIGNVECTOR *pdv ;
                ULONG  ulLangID   ;
            } LoadFontFile_;
            struct {
                 BOOL ReturnValue;
                ULONG iFile      ;
            } UnloadFontFile_;
            struct {
                 LONG  ReturnValue;
                ULONG  iFile      ;
                ULONG  ulMode     ;
                ULONG  cjBuf      ;
                ULONG *pulBuf     ;
            } QueryFontFile_;
            struct {
                   BOOL  ReturnValue;
                 DHPDEV  dhpdev     ;
                FONTOBJ *pfo        ;
                  ULONG  iMode      ;
                 HGLYPH *phg        ;
                  PVOID  pvWidths   ;
                  ULONG  cGlyphs    ;
            } QueryAdvanceWidths_;
            struct {
                PVOID pv;
                ULONG id;
            } Free_;
            struct {
                   LONG   ReturnValue;
                  ULONG   iFile      ;
                  ULONG   ulFont     ;
                  ULONG   ulTag      ;
                PTRDIFF   dpStart    ;
                  ULONG   cjBuf      ;
                   BYTE  *pjBuf      ;
                   BYTE **ppjTable   ;
                  ULONG  *pcjTable   ;
            } QueryTrueTypeTable_;
            struct {
                           LONG  ReturnValue ;
                         DHPDEV  dhpdev      ;
                        FONTOBJ *pfo         ;
                         HGLYPH  hglyph      ;
                           BOOL  bMetricsOnly;
                      GLYPHDATA *pgldt       ;
                          ULONG  cjBuf       ;
                TTPOLYGONHEADER *ppoly       ;
            } QueryTrueTypeOutline_;
            struct {
                PVOID  ReturnValue;
                ULONG  iFile      ;
                ULONG *pcj        ;
            } GetTrueTypeFile_;
            struct {
                    ULONG  ReturnValue;
                  SURFOBJ *pso        ;
                    ULONG  iEsc       ;
                    ULONG  cjIn       ;
                    PVOID  pvIn       ;
                    ULONG  cjOut      ;
                    PVOID  pvOut      ;
            } Escape_;
        };
         ULONG  LastError;
        USHORT  OemCodePage;
        USHORT  AnsiCodePage;
         PVOID  pToBeFreed;
         ULONG  idToBeFreed;
      unsigned  cjScratch;
          char *pScratch;
    };
    char InitialIdentifier[32];
    double x;       // forces double alignment of the entire PROXYMSG
} PROXYMSG;

typedef struct _FXOBJ {
    FONTOBJ fo;
    XFORML  xform;
    ULONG   i;
} FXOBJ;

//
// The STATE structure describes the state of the CLIENT SERVER mechanism
//

typedef struct _STATE {
    unsigned  SizeOfBuffer;   // size of user mode buffer = pMsg->cjThis
    DRIVER_ID DriverId;       // Identifies specific user mode driver
    PROXYMSG *pMsg;           // pointer to message buffer
    struct {
        unsigned DontCallServer : 1;
    } flags;
} STATE;

#define PSTATE(p) ((STATE*)(p)->pvConsumer)

#define UMFD_TAG 'dfmu'

typedef enum _PATH_PROC_TYPE {
      isMoveTo       = 0
    , isPolyLineTo   = 1
    , isPolyBezierTo = 2
    , isCloseFigure  = 3
} PATH_PROC_TYPE;

typedef union _PATH_RECORD {
    struct {
         union _PATH_RECORD *pNext;
             PATH_PROC_TYPE  Type;
                      ULONG  Count;
    };
    double x;
} PATH_RECORD;

//
// POINTFIX* POINTER_TO_FIRST_POINT(PATH_RECORD*)
//
// Returns a pointer to the first POINTFIX structure immediately
// following the PATH_RECORD structure
//

#define POINTER_TO_FIRST_POINT(p) ((POINTFIX*)((PATH_RECORD*)(p)+1))

typedef union _PATH_HEADER {
    struct {
        PATHOBJ  Object;
       PROXYMSG *pMsg;
       unsigned  BytesRemaining; // bytes available for allocation
    PATH_RECORD *pLast;          // pointer to last allocated record
    PATH_RECORD *pNext;          // pointer to next available address
    };
    double x;
} PATH_HEADER;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\inc\ht.h ===
/*++

Copyright (c) 1990-1999  Microsoft Corporation


Module Name:

    ht.h


Abstract:

    This module contains all the public defines, constants, structures and
    functions declarations for accessing the DLL.

Author:

    15-Jan-1991 Tue 21:13:21 created  -by-  Daniel Chou (danielc)

[Environment:]

    GDI Device Driver - Halftone.


[Notes:]


Revision History:

    29-Oct-1991 Tue 14:33:43 updated  -by-  Daniel Chou (danielc)

        1) Change HALFTONEPATTERN data structure.

            a) 'Flags' field from WORD to BYTE
            b) 'MaximumHTDensityIndex' from WORD to BYTE
            c) Change the field order.

        2) Remove ReferenceWhite/ReferenceBlack from HTCOLORADJUSTMENT data
           structure.

        3)

--*/

#ifndef _HT_
#define _HT_

//
// For compilers that don't support nameless unions
//

#ifndef DUMMYUNIONNAME
#ifdef NONAMELESSUNION
#define DUMMYUNIONNAME      u
#define DUMMYUNIONNAME2     u2
#define DUMMYUNIONNAME3     u3
#define DUMMYUNIONNAME4     u4
#else
#define DUMMYUNIONNAME
#define DUMMYUNIONNAME2
#define DUMMYUNIONNAME3
#define DUMMYUNIONNAME4
#endif
#endif



#ifndef far
#define far
#endif

#ifndef FAR
#define FAR     far
#endif

typedef CHAR FAR                *LPCHAR;
typedef SHORT FAR               *LPSHORT;
typedef UINT FAR                *LPUINT;

//
// The DECI4/UDECI4 is a special number used in halftone DLL, this number
// just like regular short, unsigned short number, except it using lower
// four decimal digits as right side of the decimal point, that is
// 10000 is as 1.0000, and -12345 will be -1.2345.
//

typedef short               DECI4;
typedef unsigned short      UDECI4;
typedef DECI4 FAR           *PDECI4;
typedef UDECI4 FAR          *PUDECI4;

#define DECI4_0             (DECI4)0
#define DECI4_1             (DECI4)10000
#define DECI4_Neg1          (DECI4)-10000
#define UDECI4_0            (UDECI4)0
#define UDECI4_1            (UDECI4)10000


#define SIZE_BYTE           sizeof(BYTE)
#define SIZE_CHAR           sizeof(CHAR)
#define SIZE_WORD           sizeof(WORD)
#define SIZE_SHORT          sizeof(SHORT)
#define SIZE_LONG           sizeof(LONG)
#define SIZE_DWORD          sizeof(DWORD)
#define SIZE_UINT           sizeof(UINT)
#define SIZE_INT            sizeof(INT)
#define SIZE_UDECI4         sizeof(UDECI4)
#define SIZE_DECI4          sizeof(DECI4)

#define COUNT_ARRAY(array)  (sizeof(array) / sizeof(array[0]))

#define B_BITPOS(x)         ((BYTE)(1 << (x)))
#define W_BITPOS(x)         ((WORD)(1 << (x)))
#define DW_BITPOS(x)        ((DWORD)(1 << (x)))
#define BIT_IF(b,t)         (((t)) ? (b) : ((b)-(b)))
#define SET_BIT(x,b)        ((x) |= (b))
#define CLR_BIT(x,b)        ((x) &= ~(b))
#define INV_BIT(x,b)        ((x) ^= (b))
#define HAS_BIT(x,b)        ((x) & (b))


//
// The following are the error return values for the HTHalftoneBitmap() call.
//

#define HTERR_WRONG_VERSION_HTINITINFO      -1
#define HTERR_INSUFFICIENT_MEMORY           -2
#define HTERR_CANNOT_DEALLOCATE_MEMORY      -3
#define HTERR_COLORTABLE_TOO_BIG            -4
#define HTERR_QUERY_SRC_BITMAP_FAILED       -5
#define HTERR_QUERY_DEST_BITMAP_FAILED      -6
#define HTERR_QUERY_SRC_MASK_FAILED         -7
#define HTERR_SET_DEST_BITMAP_FAILED        -8
#define HTERR_INVALID_SRC_FORMAT            -9
#define HTERR_INVALID_SRC_MASK_FORMAT       -10
#define HTERR_INVALID_DEST_FORMAT           -11
#define HTERR_INVALID_DHI_POINTER           -12
#define HTERR_SRC_MASK_BITS_TOO_SMALL       -13
#define HTERR_INVALID_HTPATTERN_INDEX       -14
#define HTERR_INVALID_HALFTONE_PATTERN      -15
#define HTERR_HTPATTERN_SIZE_TOO_BIG        -16
#define HTERR_NO_SRC_COLORTRIAD             -17
#define HTERR_INVALID_COLOR_TABLE           -18
#define HTERR_INVALID_COLOR_TYPE            -29
#define HTERR_INVALID_COLOR_TABLE_SIZE      -20
#define HTERR_INVALID_PRIMARY_SIZE          -21
#define HTERR_INVALID_PRIMARY_VALUE_MAX     -22
#define HTERR_INVALID_PRIMARY_ORDER         -23
#define HTERR_INVALID_COLOR_ENTRY_SIZE      -24
#define HTERR_INVALID_FILL_SRC_FORMAT       -25
#define HTERR_INVALID_FILL_MODE_INDEX       -26
#define HTERR_INVALID_STDMONOPAT_INDEX      -27
#define HTERR_INVALID_DEVICE_RESOLUTION     -28
#define HTERR_INVALID_TONEMAP_VALUE         -29
#define HTERR_NO_TONEMAP_DATA               -30
#define HTERR_TONEMAP_VALUE_IS_SINGULAR     -31
#define HTERR_INVALID_BANDRECT              -32
#define HTERR_STRETCH_RATIO_TOO_BIG         -33
#define HTERR_CHB_INV_COLORTABLE_SIZE       -34
#define HTERR_HALFTONE_INTERRUPTTED         -35
#define HTERR_NO_SRC_HTSURFACEINFO          -36
#define HTERR_NO_DEST_HTSURFACEINFO         -37
#define HTERR_8BPP_PATSIZE_TOO_BIG          -38
#define HTERR_16BPP_555_PATSIZE_TOO_BIG     -39
#define HTERR_INVALID_ABINFO                -40
#define HTERR_INTERNAL_ERRORS_START         -10000


#define COLOR_TYPE_RGB          0
#define COLOR_TYPE_XYZ          1
#define COLOR_TYPE_YIQ          2
#define COLOR_TYPE_MAX          2

#define PRIMARY_ORDER_123       0
#define PRIMARY_ORDER_132       1
#define PRIMARY_ORDER_213       2
#define PRIMARY_ORDER_231       3
#define PRIMARY_ORDER_321       4
#define PRIMARY_ORDER_312       5
#define PRIMARY_ORDER_MAX       5

#define PRIMARY_ORDER_RGB       PRIMARY_ORDER_123
#define PRIMARY_ORDER_RBG       PRIMARY_ORDER_132
#define PRIMARY_ORDER_GRB       PRIMARY_ORDER_213
#define PRIMARY_ORDER_GBR       PRIMARY_ORDER_231
#define PRIMARY_ORDER_BGR       PRIMARY_ORDER_321
#define PRIMARY_ORDER_BRG       PRIMARY_ORDER_312

#define PRIMARY_ORDER_CMY       PRIMARY_ORDER_123
#define PRIMARY_ORDER_CYM       PRIMARY_ORDER_132
#define PRIMARY_ORDER_MCY       PRIMARY_ORDER_213
#define PRIMARY_ORDER_MYC       PRIMARY_ORDER_231
#define PRIMARY_ORDER_YMC       PRIMARY_ORDER_321
#define PRIMARY_ORDER_YCM       PRIMARY_ORDER_312

#define PRIMARY_ORDER_XYZ       PRIMARY_ORDER_123
#define PRIMARY_ORDER_XZY       PRIMARY_ORDER_132
#define PRIMARY_ORDER_YXZ       PRIMARY_ORDER_213
#define PRIMARY_ORDER_YZX       PRIMARY_ORDER_231
#define PRIMARY_ORDER_ZYX       PRIMARY_ORDER_321
#define PRIMARY_ORDER_ZXY       PRIMARY_ORDER_312

#define PRIMARY_ORDER_YIQ       PRIMARY_ORDER_123
#define PRIMARY_ORDER_YQI       PRIMARY_ORDER_132
#define PRIMARY_ORDER_IYQ       PRIMARY_ORDER_213
#define PRIMARY_ORDER_IQY       PRIMARY_ORDER_231
#define PRIMARY_ORDER_QIY       PRIMARY_ORDER_321
#define PRIMARY_ORDER_QYI       PRIMARY_ORDER_312

//
// COLORTRIAD
//
//  This data structure describe the source color informations
//
//  Type                - One of the following type may be specified.
//
//                          COLOR_TYPE_RGB  - primaries are RGB.
//                          COLOR_TYPE_XYZ  - primaries are CIE XYZ.
//                          COLOR_TYPE_YIQ  - primaries are NTSC YIQ.
//
//  BytesPerPrimary     - Specified how many bytes used per primary color, it
//                        must be one of the following
//
//                          1 - BYTE
//                          2 - WORD
//                          4 - DWORD
//
//                        All 3 primaries must be consecutive in memory.
//
//  BytesPerEntry       - Specified how many bytes used for color table entry,
//                        each entry specified 3 primaries colors.
//
//  PrimaryOrder        - The primaries order in the color table, it can be
//                        one of the defined PRIMARY_ORDER_abc, for each entry
//                        in the memory it defined as
//
//                          PRIMARY_ORDER_abc
//                                        |||
//                                        ||+-- highest memory location
//                                        ||
//                                        |+--- middle
//                                        |
//                                        +---- Lowest memory location
//
//                        All 3 primaries must be consecutive in memory.
//
//  PrimaryValueMax     - The maximum value for the primary color, this is used
//                        to nomalized the input colors, for example a 8-bit
//                        RGB color table will specified 255.
//
//  ColorTableEntries   - Total entries of the color table pointed by the
//                        pColorTable.
//
//  pColorTable         - Pointer to the start of color table, the size of the
//                        this color table must at least (BytesPerEntry *
//                        ColorTableEntries).
//
//                        If the first primary color in the color table entry
//                        is not at first byte of the pColorTable, then caller
//                        must specified the pColorTable at first primary
//                        color. (pColorTable += Offset(first primary).
//
//

typedef struct _COLORTRIAD {
    BYTE    Type;
    BYTE    BytesPerPrimary;
    BYTE    BytesPerEntry;
    BYTE    PrimaryOrder;
    LONG    PrimaryValueMax;
    DWORD   ColorTableEntries;
    LPVOID  pColorTable;
} COLORTRIAD, FAR *PCOLORTRIAD;


//
// HTSURFACEINFO
//
//  This data structure describe the the input/output surface in order for
//  halftone function to render the output, this data structure only used for
//  the memory device.
//
//  hSurface                - This is 32-bits handle which will be passed back
//                            to the caller's callback function.
//
//  Flags                   - One or more following flags may be defined
//
//                              HTSIF_SCANLINES_TOPDOWN
//
//                                  This flag is ignored
//
//  SurfaceFormat           - Following formats are defined
//
//                              BMF_1BPP
//
//                                  1-bit per pel format, this is the index
//                                  number (0 or 1) for the color table/palette.
//
//                              BMF_4BPP
//
//                                  4-bit per pel and pack two pels to a byte
//                                  starting from high nibble (bit 4-7) format,
//                                  this is the index number (0-7) for the
//                                  color table/palette. (ONLY LOW 3 bits of
//                                  the nibble is used)
//
//                              BMF_4BPP_VGA16
//
//                                  4-bit per pel and pack two pels to a byte
//                                  starting from high nibble (bit 4-7) format,
//                                  this is the index number (0-15) for the
//                                  standard VGA 16 colors table/palette.
//
//                                  The different from BMF_4BPP is this indices
//                                  are fixed to standard VGA 16 colors as
//
//                                      Index#  Colors      Lightness
//                                      ---------------------------------
//                                          0   Black         0%
//                                          1   Red          50%
//                                          2   Green        50%
//                                          3   Yellow       50%
//                                          4   Blue         50%
//                                          5   Magenata     50%
//                                          6   Cyan         50%
//                                          7   Gray         50%
//                                          8   Gray         75%
//                                          9   Red         100%
//                                         10   Green       100%
//                                         11   Yellow      100%
//                                         12   Blue        100%
//                                         13   Magenata    100%
//                                         14   Cyan        100%
//                                         15   White       100%
//
//                                  Notice that the color order is
//
//                                  Bit 2 = Blue, Bit 1 = Green, Bit 0 = Red
//
//                                  This format can only be used as destination
//                                  surface, when used as destination surface
//                                  the halftone dll automatically set it to
//                                  USE_ADDITIVE_PRIMS and set the primaries
//                                  order as PRIMARY_ORDER_BGR.
//
//                              BMF_8BPP
//
//                                  8-bit per pel format (1 byte each), this is
//                                  the index number (0-255) for the color
//                                  table/palette.  The format is not allowed
//                                  for the destination surface.
//
//                              BMF_8BPP_VGA256
//
//                                  8-bit per pel format (1 byte each), this is
//                                  the index number (0-255) for the color
//                                  table/palette.
//
//                                  The different from BMF_8BPP is this indices
//                                  are fixed to halftone special colors.
//
//                                  The color table (palette) is defined by
//                                  halftone.dll, the display should call
//                                  HT_Get8BPPFormatPalette() api call to get
//                                  the current palette used by the halftone.
//
//                                  The HT_GetBPPFormatPalette() will only need
//                                  to called once until next time the display
//                                  caliberation occurred.
//
//                                  Halftone.dll will not used all 256 colors
//                                  in the system palette, it will leave some
//                                  20 or more entries for the system colors.
//
//                              BMF_16BPP
//
//                                  16-bit per pel format (16 bits each), this
//                                  is the index number (0-65535) for the color
//                                  table/palette.  The format is not allowed
//                                  for the destination surface.
//
//                              BMF_16BPP_555
//
//                                  16-bit per pel format (only 15 bits used),
//                                  each primary occupy 5 bits, the layout of
//                                  bits as follow
//
//                                      bit 10-15   - Primary A
//                                      bit  5- 9   - Primary B
//                                      bit  0- 4   - Primary C
//
//                                  The order of the Primary A, B and C is
//                                  specfied by PRIMARY_ORDER_xxx.
//
//                                  for each primary there are 32 gradations,
//                                  and halftone.dll output is assume to be
//                                  linear. (non-gamma corrected), this format
//                                  only allowed for destination surface.
//
//                              BMF_24BPP
//
//                                  24-bit per pel format (8-bit per color),
//                                  the order of RGB color stored in the source
//                                  bitmap or color table.
//
//                              BMF_32BPP
//
//                                  Same as BMF_24BPP but with extra byte
//                                  packing, if the extra byte is packed at
//                                  begining (the first color is starting from
//                                  second byte of that 4 bytes) then caller
//                                  must set the pColorTable = pColorTable + 1
//                                  or set pPlane = pPlane + 1, to skip first
//                                  unused byte.
//
//                              NOTE: Allowed source formats are
//
//                                      1) BMF_1BPP
//                                      2) BMF_4BPP
//                                      3) BMF_8BPP
//                                      4) BMF_16BPP
//                                      5) BMF_24BPP
//                                      6) BMF_32BPP
//
//                                    Allowed destination formats are
//
//                                      1) BMF_1BPP
//                                      2) BMF_4BPP
//                                      3) BMF_4BPP_VGA16
//                                      4) BMF_8BPP_VGA256
//                                      5) BMF_16BPP_555
//
//                                    Any other mismatch cause error returned.
//
//  ScanLineAlignBytes      - Total bytes needed to aligned for each scan line
//                            in the surface bitmap, it can be any unsigned
//                            8-bit number, the common ones are defined as
//
//                                  BMF_ALIGN_BYTE      ( 8-bit aligned)
//                                  BMF_ALIGN_WORD      (16-bit aligned)
//                                  BMF_ALIGN_DWORD     (32-bit aligned)
//                                  BMF_ALIGN_QWORD     (64-bit aligned)
//
//  Width                   - The width of the surface in pels.
//
//  Height                  - The height of the surface in scan lines.
//
//  ScanLineDelta           - Specified scan lines Delta in bytes, this member
//                            indicate how many bytes to be added for advanced
//                            to next scan line
//
//  pPlane                  - This pointer points to the first scan line in
//                            the defined surface, Scan #0 that is.
//
//  pColorTriad             - Pointe to the COLORTRIAD data structure to
//                            specified the source color table, this pointer
//                            only examined by the halftone.dll for source
//                            surface.
//


#if !defined( BMF_DEVICE ) &&     \
    !defined( BMF_1BPP   ) &&     \
    !defined( BMF_4BPP   ) &&     \
    !defined( BMF_8BPP   ) &&     \
    !defined( BMF_16BPP  ) &&     \
    !defined( BMF_24BPP  ) &&     \
    !defined( BMF_32BPP  )

#define BMF_1BPP                        1
#define BMF_4BPP                        2
#define BMF_8BPP                        3
#define BMF_16BPP                       4
#define BMF_24BPP                       5
#define BMF_32BPP                       6

#endif

#define BMF_4BPP_VGA16                  255
#define BMF_8BPP_VGA256                 254
#define BMF_16BPP_555                   253
#define BMF_16BPP_565                   252
#define BMF_HT_LAST                     BMF_16BPP_565


//
// Following are common used alignment bytes for the bitmap
//

#define BMF_ALIGN_BYTE      1                   //  8 bits = 1 byte
#define BMF_ALIGN_WORD      2                   // 16 bits = 2 bytes
#define BMF_ALIGN_DWORD     4                   // 32 bits = 4 bytes
#define BMF_ALIGN_QWORD     8                   // 64 bits = 8 bytes





#define HTSIF_SCANLINES_TOPDOWN         W_BITPOS(0)


typedef struct _HTSURFACEINFO {
    ULONG_PTR   hSurface;
    WORD        Flags;
    BYTE        SurfaceFormat;
    BYTE        ScanLineAlignBytes;
    LONG        Width;
    LONG        Height;
    LONG        ScanLineDelta;
    LPBYTE      pPlane;
    PCOLORTRIAD pColorTriad;
    } HTSURFACEINFO;

typedef HTSURFACEINFO   FAR *PHTSURFACEINFO;


//
// HTCALLBACKPARAMS
//
//  This is structure is used durning the bitmap halftone process to obtains
//  the source or destination bitmap surface pointers.
//
//
//  hSurface                - This is the handle which passed to the
//                            halftone DLL, durning the HTHalftoneBitmap() call,
//                            (in HTSURFACEINFO data structure) it may be
//                            handle to source or destination depends on the
//                            nature of the callback.
//
//  CallBackMode            - Specified the nature of the callback.
//
//                              HTCALLBACK_QUERY_SRC
//
//                                  The callback is quering the source bitmap
//                                  pointer.
//
//                              HTCALLBACK_QUERY_SRC_MASK
//
//                                  The callback is quering the source mask
//                                  bitmap pointer.
//
//                              HTCALLBACK_QUERY_DEST
//
//                                  The callback is quering the destination
//                                  bitmap pointer(s).
//
//                              HTCALLBACK_SET_DEST
//
//                                  The callback is used to release halftoned
//                                  destination.   It will called in following
//                                  conditions:
//
//                                      1) Before HTCALLBACK_QUERY_DEST call
//                                         except for the very first query
//                                         destination.
//
//                                      2) After the halftone process is
//                                         completed.  This give the chance for
//                                         the caller to process the last
//                                         halftoned destination block.
//
//  SurfaceFormat           - This is the surface format specified in the
//                            original HTSURFACEINFO.
//
//  Flags                   - This is the copy of HTSURFACEINFO.Flags.
//
//  BytesPerScanLine        - This is the total bytes per scan line for the
//                            surface bitmap which computed by the halftone
//                            DLL according to the 'ScanLineAlignBytes' in the
//                            HTSURFACEINFO data structure, it can be used by
//                            the caller to calculate source/destination
//                            pointers information.
//
//  ScanStart               - Requested starting scan line number, the scan
//                            lines are number from 0 up, this number will
//                            guaranteed has following propertites:
//
//                              1) It always greater than or equal to zero.
//                              2) It will never greater than or equal to the
//                                 'height' field specified in the
//                                 HTSURFACEINFO.
//
//                                 NOTE: for banding destination surface it
//                                       will never greater than or equal to
//                                       the (rclBand.bottom - rclBand.top).
//
//                              3) The scan line number 0 always refer to the
//                                 physical lowest bitmap memory location
//                                 regardless HTSIF_SCANLINES_TOPDOWN flag set
//                                 or not, durning callback the caller only
//                                 need to compute array like bitmap buffer,
//                                 halftone DLL will compute the correct
//                                 ScanStart if the bitmap is not TOPDOWN.
//
//  ScanCount               - Total scan lines requested starting from
//                            ScanStart, this number will guaranteed has
//                            following propertites:
//
//                              1) It always greater than zero.
//                              2) Never greater then the MaximumQueryScanLines
//                                 specified for the surface (in HTSURFACEINFO
//                                 data structure).
//
//                                 NOTE: for banding destination surface it
//                                       will never greater than the
//                                       (rclBand.bottom - rclBand.top).
//
//                            NOTE: 1) ScanStart/ScanCount
//
//                                     If the flags HTSURFACEINFO data
//                                     structure HTSIF_SCANLINES_TOPDOWN is not
//                                     specified then halftone DLL automatically
//                                     calculate the correct ScanStart/ScanCount
//                                     for read/write the up-side-down bitmap.
//
//                                     For example:
//
//                                     If the surface bitmap is up-side-down
//                                     type DIB) and has 100 scan lines height
//                                     (scan line #99 is the top of the bitmap),
//                                     if halftone DLL need to get to scan line
//                                     10-14 (Start from scan line 10 and 5
//                                     lines) then halftone DLL will flip Y,
//                                     and passed ScanStart = 85 and ScanCount
//                                     = 5, but if the HTSIF_SCANLINES_TOPDOWN
//                                     flag is set (Non DIB type format) then
//                                     callback parameters will then be
//                                     ScanStart = 10 and ScanCount = 5.
//
//                                  2) The ScanStart for the callback function
//                                     always consider the lowest bitmap in the
//                                     memory as scan line 0, that is when
//                                     callback fucntion received control, it
//                                     only need to consider the ScanStart as
//                                     physical scan line location which the
//                                     Scan line #0 always starting from lowest
//                                     bitmap memory location.
//
//                                  3) The width of the destination buffer is
//                                     considered as 'Width' field specified
//                                     for the destination HTSURFACEINFO, if
//                                     destination is BANDed (horizontal or
//                                     vertical) then its width is computed as
//                                     Band.right - Band.left. and the result
//                                     always Band.left/Band.top aligned.
//
//                                  4) If caller return 'ScanCount' diff from
//                                     the one requested then caller must check
//
//                                      HTSIF_SCANLINES_TOPDOWN flag is SET
//
//                                          1. Process 'ScanStart' and
//                                             'ScanCount' fields as normal.
//
//                                          2. Set New ScanCount to passed
//                                             callback data structure.
//                                             (ie. HTCallBackParam.ScanCount)
//
//
//                                      HTSIF_SCANLINES_TOPDOWN flag is CLEAR
//
//                                          1. Re-compute 'ScanStart' before
//                                             compute pPlane as
//
//                                             ScanStart = ScanStart -
//                                                         (NewScanCount -
//                                                          RequsetedScanCount)
//
//                                          2. Process 'ScanStart' and
//                                             'ScanCount' fields as normal.
//
//                                          3. Set New ScanStart to passed
//                                             callback data structure.
//                                             (ie. HTCallBackParam.ScanStart)
//
//                                          4. Set New ScanCount to passed
//                                             callback data structure.
//                                             (ie. HTCallBackParam.ScanCount)
//
//                                      The returned new 'ScanCount' must not
//                                      greater then the 'RemainedSize' field.
//
//  MaximumQueryScanLines   - This is the copy of the MaximumQueryScanLines
//                            field from the HTSURFACEINFO data structure which
//                            passed to the the HT_HaltoneBitmap() calls.
//                            Depends on the nature of the callback, it may be
//                            source or destination.
//
//                            NOTE: for banding surface, it will be limited to
//                                  (rclBand.bottom - rclBand.top) if it is
//                                  greater than that number.
//
//  RemainedSize            - This field specified how many scan lines remained
//                            to be queried, the remainded scan lines are not
//                            include current call.
//
//  pPlane                  - pointer points to the begining of first plane of
//                            the surface.  If the callback is quering the
//                            source then this is the only pointer which need
//                            to be updated by the callback function.
//
//                              NOTE: The pPlane must points to the first byte
//                                    of the 'ScanStart' scan line number.
//
//  Field(s) returned from callback
//
//  1) HTCALLBACK_QUERY_SRC         - pPlane (Options: ScanStart/ScanCount)
//  2) HTCALLBACK_QUERY_SRC_MASK    - pPlane (Options: ScanStart/ScanCount)
//  2) HTCALLBACK_QUERY_DEST        - pPlane (Options: ScanStart/ScanCount)
//  4) HTCALLBACK_SET_DEST          - none.
//


#define HTCALLBACK_QUERY_SRC            0
#define HTCALLBACK_QUERY_SRC_MASK       1
#define HTCALLBACK_QUERY_DEST           2
#define HTCALLBACK_SET_DEST             3
#define HTCALLBACK_MODE_MAX             HTCALLBACK_SET_DEST

typedef struct _HTCALLBACKPARAMS {
    ULONG_PTR    hSurface;
    BYTE        CallBackMode;
    BYTE        SurfaceFormat;
    WORD        Flags;
    LONG        BytesPerScanLine;
    LONG        ScanStart;
    WORD        ScanCount;
    WORD        MaximumQueryScanLines;
    LONG        RemainedSize;
    LPBYTE      pPlane;
    } HTCALLBACKPARAMS;

typedef HTCALLBACKPARAMS    FAR *PHTCALLBACKPARAMS;


//
// _HTCALLBACKFUNC
//
//  The callback function is used to obtain the source and/destination bitmap
//  surface durning the halftone process, the halftone DLL will using call
//  back function is following sequences.
//
//      1) Callback to obtain block of the source bitmap, it depensds on
//         the maximum query scan lines limit by the caller. (in HTSURFACEINFO)
//
//      3) Callback to obtain block of the destination bitmap, it depends on
//         the maximum query scan lines limit by the caller. (in HTSURFACEINFO)
//
//      4) Repeat 1), 2), 3) until destination maximum queried scan lines are
//         processed then callback to the caller to release the processed
//         destination.
//
//      5) Repat 1), 2), 3) and 4) unitil all source/destination scan lines are
//         processed.
//
//  The return value of the callback is a boolean value, if false the halftone
//  processed is interrupted and an erro code is returned, if callback function
//  return true then halftone DLL assume that all queried scan lines are
//  reachable by the return pointer (in the HTCALLBACKPARAMS data structure).
//
//  NOTE: 1) If the callback function query for 100 lines and return value is
//           ture then there must all 100 scan lines can be accessable by the
//           halftone dll through the pointer(s).
//
//        2) If the caller has all the bitmap in the memory it should set the
//           maximum query scan lines count to the bitmap height to reduced the
//           callback calls.
//
//        3) If the caller do not need to released the halftoned destination
//           then it should not set the HTCBPF_NEED_SET_DEST_CALLBACK flag
//           to reduces callback calls.
//
// The callback function must be
//
//  1) Must return a 16-bit 'BOOLEAN' (TRUE/FALSE)
//  2) Must 32-bit far function
//  3) _loadds if you using your data segment at all from callback fuction
//

typedef BOOL (APIENTRY *_HTCALLBACKFUNC)(PHTCALLBACKPARAMS pHTCBParams);
#define HTCALLBACKFUNCTION  BOOL APIENTRY


//
// HALFTONEPATTERN
//
//  The HALFTONEPATTERN data structure is used to describe the halftone
//  pattern which will be used by a particular device, if the device choosed
//  to used halftone DLL's default pattern then following data structure will
//  be automatically calculated by the halftone DLL.
//
//  Flags                   - Various halftone flags for the cell, can be one
//                            of the following:
//
//  Width                   - Specified the width of the pattern in pels, this
//                            field must not greater than MAX_HTPATTERN_WIDTH.
//
//  Height                  - Specified the Width of the pattern in scan line,
//                            this field only must not greater than
//                            MAX_HTPATTERN_HEIGHT.
//
//  pHTPatA
//  pHTPatB
//  pHTPatC                 - Specified caller defined pattern. The data items
//                            points by these pointer must have minimum of
//                            (Width * Height) bytes.
//
//                            These are the pointers to BYTE array contains
//                            threshold data, the size of the array must be
//                            'Width * Height' in bytes.  The data in the
//                            array should range from 1 to 255, a zero (0)
//                            indicate the pixel location is ignored.
//
//                            All thresholds values are indicate additive
//                            intensities, a zero indicate black pixel always.
//                            a 255 threshold value indicate the pixel always
//                            turn on to white.
//
//                            Halftone DLL use this thresholds array with
//                            device X, Y, PEL resolution and specified input/
//                            output relationship to compute color
//                            transformation
//


#define MAX_HTPATTERN_WIDTH         256
#define MAX_HTPATTERN_HEIGHT        256

//
// Following are the predefined halftone pattern sizes for 'HTPatternIndex'
//

#define HTPAT_SIZE_2x2              0
#define HTPAT_SIZE_2x2_M            1
#define HTPAT_SIZE_4x4              2
#define HTPAT_SIZE_4x4_M            3
#define HTPAT_SIZE_6x6              4
#define HTPAT_SIZE_6x6_M            5
#define HTPAT_SIZE_8x8              6
#define HTPAT_SIZE_8x8_M            7
#define HTPAT_SIZE_10x10            8
#define HTPAT_SIZE_10x10_M          9
#define HTPAT_SIZE_12x12            10
#define HTPAT_SIZE_12x12_M          11
#define HTPAT_SIZE_14x14            12
#define HTPAT_SIZE_14x14_M          13
#define HTPAT_SIZE_16x16            14
#define HTPAT_SIZE_16x16_M          15
#define HTPAT_SIZE_SUPERCELL        16
#define HTPAT_SIZE_SUPERCELL_M      17
#define HTPAT_SIZE_USER             18
#define HTPAT_SIZE_MAX_INDEX        HTPAT_SIZE_USER
#define HTPAT_SIZE_DEFAULT          HTPAT_SIZE_SUPERCELL_M


typedef struct _HALFTONEPATTERN {
    WORD    cbSize;
    WORD    Flags;
    WORD    Width;
    WORD    Height;
    LPBYTE  pHTPatA;
    LPBYTE  pHTPatB;
    LPBYTE  pHTPatC;
    } HALFTONEPATTERN, FAR *PHALFTONEPATTERN;


//
// CIECOORD
//
//  This data structure defined a C.I.E color space coordinate point, the
//  coordinate is in DECI4 format.
//
//  x   - x coordinate in C.I.E color space
//
//  y   - y coordinate in C.I.E color space.
//
//  Y   - The liminance for the color
//
//

#define CIE_x_MIN   (UDECI4)10
#define CIE_x_MAX   (UDECI4)8000
#define CIE_y_MIN   (UDECI4)10
#define CIE_y_MAX   (UDECI4)8500

typedef struct _CIECOORD {
    UDECI4  x;
    UDECI4  y;
    UDECI4  Y;
    } CIECOORD;

typedef CIECOORD FAR *PCIECOORD;


//
// CIEINFO
//
//  This data structure describe the red, green, blue, cyan, magenta, yellow
//  and alignment white coordinate in the C.I.E color space plus the Luminance
//  factor, these are used to calculate the C.I.E. transform matrix and its
//  inversion.
//
//  Red             - Red primary color in CIRCOORD format.
//
//  Green           - Green primary color in CIRCOORD format.
//
//  Blue            - Blue primary color in CIRCOORD format.
//
//  Cyan            - Cyan primary color in CIRCOORD format.
//
//  Magenta         - Magenta primary color in CIRCOORD format.
//
//  Yellow          - Yellow primary color in CIRCOORD format.
//
//  AlignmentWhite  - Alignment white in CIECOORD format.
//


typedef struct _CIEINFO {
    CIECOORD    Red;
    CIECOORD    Green;
    CIECOORD    Blue;
    CIECOORD    Cyan;
    CIECOORD    Magenta;
    CIECOORD    Yellow;
    CIECOORD    AlignmentWhite;
    } CIEINFO;

typedef CIEINFO FAR *PCIEINFO;

//
// SOLIDDYESINFO
//
//  This data structure specified device cyan, magenta and yellow dyes
//  concentration.
//
//  MagentaInCyanDye    - Mangenta component proportion in Cyan dye.
//
//  YellowInCyanDye     - Yellow component proportion in Cyan dye.
//
//  CyanInMagentaDye    - Cyan component proportion in Magenta dye.
//
//  YellowInMagentaDye  - Yellow component proportion in Magenta dye.
//
//  CyanInYellowDye     - Yellow component proportion in Cyan dye.
//
//  MagentaInYellowDye  - Magenta component proportion in Cyan dye.
//
//      NOTE: all fields in this data structure is UDECI4 number, range from
//            UDECI4_0 to UDECI_4, ie,; 0.0 to 1.0, this a inpurity proportion
//            percentge in primary dye, for example a MagentaInCyanDye=1200
//            mean a 0.12% of magenta component is in device Cyan dye.
//

typedef struct _SOLIDDYESINFO {
    UDECI4  MagentaInCyanDye;
    UDECI4  YellowInCyanDye;
    UDECI4  CyanInMagentaDye;
    UDECI4  YellowInMagentaDye;
    UDECI4  CyanInYellowDye;
    UDECI4  MagentaInYellowDye;
    } SOLIDDYESINFO, FAR *PSOLIDDYESINFO;


//
// HTCOLORADJUSTMENT
//
//  This data structure is a collection of the device color adjustments, it
//  can be changed at any calls.
//
//  Flags                       - CLRADJF_NEGATIVE
//
//                                  Produced negative picture
//
//                                CLRADJF_LOG_FILTER
//
//                                  Specified a relative logarithm should
//                                  used to calculate the final density.
//
//  IlluminantIndex             - Specified the default illuminant of the light
//                                source which the object will be view under.
//                                The predefined value has ILLUMINANT_xxxx
//                                form.
//
//  RedPowerGamma               - The n-th power applied to the red color
//                                before any other color tramsformations,
//                                this is an UDECI4 value.
//
//                                  For example if the RED = 0.8 (DECI4=8000)
//                                  and the RedPowerGammaAdjustment = 0.7823
//                                  (DECI4 = 7823) then the red is equal to
//
//                                         0.7823
//                                      0.8        = 0.8398
//
//  GreenPowerGamma             - The n-th power applied to the green color
//                                before any other color transformations, this
//                                is an UDECI4 value.
//
//  BluePowerGamma              - The n-th power applied to the blue color
//                                before any other color transformations, this
//                                is an UDECI4 value.
//
//                      NOTE: RedPowerGamma/GreenPowerGamma/BluePoweGamma are
//                            UDECI4 values and range from 100 to 65535 if any
//                            one of these values is less than 100 (0.01) then
//                            halftone dll automatically set all power gamma
//                            adjustments to selected default.
//
//  ReferenceBlack              - The black shadow reference for the colors
//                                passed to the halftone dll,  if a color's
//                                lightness is darker than the reference black
//                                then halftone dll will treated as completed
//                                blackness and render it with device maximum
//                                density.
//
//  ReferenceWhite              - The white hightlight reference for the colors
//                                passed to the halftone dll, if a color's
//                                lightness is lighter than the reference white
//                                then halftone will treated as a specular
//                                hightlight and redner with device maximum
//                                intensity.
//
//                      NOTE:   ReferenceBlack Range:  0.0000 - 0.4000
//                              ReferenceWhite Range:  0.6000 - 1.0000
//
//  Contrast                    - Primary color contrast adjustment, this is
//                                a SHORT number range from -100 to 100, this
//                                is the black to white ratio, -100 is the
//                                lowest contrast, 100 is the highest and 0
//                                indicate no adjustment.
//
//  Brightness                  - The brightness adjustment, this is a SHORT
//                                number range from -100 to 100, the brightness
//                                is adjusted by apply to change the overall
//                                saturations for the image, -100 is lowest
//                                brightness, 100 is the hightest and a zero
//                                indicate no adjustment.
//
//  Colorfulness                - The primary color are so adjusted that it
//                                will either toward or away from black/white
//                                colors, this is a SHORT number range from
//                                -100 to 100.  -100 has less colorful, 100 is
//                                most colorfull, and a zero indicate no
//                                adjustment.
//
//  RedGreenTint                - Tint adjustment between Red/Green primary
//                                color, the value is a SHORT range from -100
//                                to 100, it adjust color toward Red if number
//                                is positive, adjust toward Green if number
//                                is negative, and a zero indicate no
//                                adjustment.
//
//  NOTE: For Contrast/Brightness/Colorfulness/RedGreenTint adjustments, if its
//        value is outside of the range (-100 to 100) then halftone DLL
//        automatically set its to selected default value.
//

#ifndef _WINGDI_

// in WinGDI.H
//
// The following are predefined alignment white for 'IlluminantIndex'.
//
// If ILLUMINANT_DEFAULT is specified
//
//  1) if pDeviceCIEInfo is NULL or pDeviceCIEInfo->Red.x eqaul to 0 then
//     halftone DLL automatically choosed approx. illuminant for the output
//     device.
//
//  2) if pDeviceCIEInfo is NOT null and pDeviceCIEInf->Red.x not equal to 0
//     then the 'White' field is used as illuminant alignment white.
//
// If other ILLUMINANT_xxxx is specified it will be used as alignment white
// even pDeviceCIEInfo is not null.
//
// If the IlluminantIndex is > ILLUMINANT_MAX_INDEX then halftone DLL will
// automatically choosed approx. illuminant even pDeviceCIEInfo is not NULL.
//

#define ILLUMINANT_DEVICE_DEFAULT   0
#define ILLUMINANT_A                1
#define ILLUMINANT_B                2
#define ILLUMINANT_C                3
#define ILLUMINANT_D50              4
#define ILLUMINANT_D55              5
#define ILLUMINANT_D65              6
#define ILLUMINANT_D75              7
#define ILLUMINANT_F2               8
#define ILLUMINANT_MAX_INDEX        ILLUMINANT_F2

#define ILLUMINANT_TUNGSTEN         ILLUMINANT_A
#define ILLUMINANT_DAYLIGHT         ILLUMINANT_C
#define ILLUMINANT_FLUORESCENT      ILLUMINANT_F2
#define ILLUMINANT_NTSC             ILLUMINANT_C

#endif


#define MIN_COLOR_ADJ               COLOR_ADJ_MIN
#define MAX_COLOR_ADJ               COLOR_ADJ_MAX
#define MIN_POWER_GAMMA             RGB_GAMMA_MIN

#define NTSC_POWER_GAMMA            (UDECI4)22000

//
// The following is the default value
//


#define REFLECT_DENSITY_DEFAULT     REFLECT_DENSITY_LOG
#define ILLUMINANT_DEFAULT          0
#define HT_DEF_RGB_GAMMA            UDECI4_1
#define REFERENCE_WHITE_DEFAULT     UDECI4_1
#define REFERENCE_BLACK_DEFAULT     UDECI4_0
#define CONTRAST_ADJ_DEFAULT        0
#define BRIGHTNESS_ADJ_DEFAULT      0
#define COLORFULNESS_ADJ_DEFAULT    0
#define REDGREENTINT_ADJ_DEFAULT    0


#define CLRADJF_NEGATIVE            CA_NEGATIVE
#define CLRADJF_LOG_FILTER          CA_LOG_FILTER

#define CLRADJF_FLAGS_MASK          (CLRADJF_NEGATIVE       |   \
                                     CLRADJF_LOG_FILTER)

#ifndef _WINGDI_

//
// In WinGDI.H
//

#define REFERENCE_WHITE_MIN         (UDECI4)6000
#define REFERENCE_WHITE_MAX         UDECI4_1

#define REFERENCE_BLACK_MIN         UDECI4_0
#define REFERENCE_BLACK_MAX         (UDECI4)4000

typedef struct  tagCOLORADJUSTMENT {
    WORD   caSize;
    WORD   caFlags;
    WORD   caIlluminantIndex;
    WORD   caRedGamma;
    WORD   caGreenGamma;
    WORD   caBlueGamma;
    WORD   caReferenceBlack;
    WORD   caReferenceWhite;
    SHORT  caContrast;
    SHORT  caBrightness;
    SHORT  caColorfulness;
    SHORT  caRedGreenTint;
} COLORADJUSTMENT, *PCOLORADJUSTMENT, FAR *LPCOLORADJUSTMENT;

#endif

#define HTCOLORADJUSTMENT COLORADJUSTMENT
typedef HTCOLORADJUSTMENT *PHTCOLORADJUSTMENT;

//
// HTINITINFO
//
//  This data structure is a collection of the device characteristics and
//  will used by the halftone DLL to carry out the color composition for the
//  designated device.
//
//  Version                 - Specified the version number of HTINITINFO data
//                            structure. for this version it should set to the
//                            HTINITINFO_VERSION
//
//  Flags                   - Various flag defined the initialization
//                            requirements.
//
//                              HIF_SQUARE_DEVICE_PEL
//
//                                  Specified that the device pel is square
//                                  rather then round object.  this only make
//                                  differences when the field
//                                  'PelResolutionRatio' is greater than 0.01
//                                  and it is not 1.0000.
//
//                              HIF_HAS_BLACK_DYE
//
//                                  Indicate the device has separate black dye
//                                  instead of mix cyan/magenta/yellow dyes to
//                                  procduced black, this flag will be ignored
//                                  if HIF_ADDITIVE_PRIMS is defined.
//
//                              HIF_ADDITIVE_PRIMS
//
//                                  Specified that final device primaries are
//                                  additively, that is adding device primaries
//                                  will produce lighter result. (this is true
//                                  for monitor devices and certainly false for
//                                  the reflect devices such as printers).
//
//                              HIF_USE_8BPP_BITMASK
//
//                                  Specified use CMYBitMask8BPP field is used,
//                                  when destination surface is BMF_8BPP_VGA256
//                                  see CMYBitMask8BPP field for more detail
//
//                              HIF_INVERT_8BPP_BITMASK_IDX
//                                  Render the 8bpp mask mode with inversion of
//                                  its indices.  This is implemented for fix
//                                  Windows GDI rop problem, it will render as
//                                  RGB additive indices.  The caller must
//                                  do a inversion of final image's Indices
//                                  (Idx = ~Idx or Idx ^= 0xFF) to get the
//                                  correct CMY332 data.   When this bit is
//                                  set, the HT_Get8BPPMaskPalette must have
//                                  its pPaletteEntry[0] Initialized to as
//
//                                      pPaletteEntry[0].peRed   = 'R';
//                                      pPaletteEntry[0].peGreen = 'G';
//                                      pPaletteEntry[0].peBlue  = 'B';
//                                      pPaletteEntry[0].peFlags = '0';
//
//                                  to indicate that a RGB indices inverted
//                                  palette should be returned and not the
//                                  standard CMY palette (Index 0 is white and
//                                  Index 255 is black).
//
//                                  The inverted palette has is first entry as
//                                  BLACK and last entry as WHITE
//
//                                      pPaletteEntry[0].peRed   = 0x00;
//                                      pPaletteEntry[0].peGreen = 0x00;
//                                      pPaletteEntry[0].peBlue  = 0x00;
//                                      pPaletteEntry[0].peFlags = 0x00;
//
//                                  Notice that this setting WILL NOT work on
//                                  earlier version of halftone (Windows 2000
//                                  and earlier), so the caller must check the
//                                  OS version or check the returned palette
//                                  to ensure that first palette entry is
//                                  BLACk rather than WHITE.   If first
//                                  entries is WHITE after initialized to
//                                  'R', 'G', 'B', '0' then this is a older
//                                  version of system that does not recongnized
//                                  the initialzed value. In this case the
//                                  caller should not invert (Idx ^= 0xFF) the
//                                  halftoned imaged indices when render it
//                                  to the devices, because the halftone
//                                  images in this case is CMY based already.
//
//
//  HTPatternIndex          - Default halftone pattern index number, the
//                            indices is predefine as HTPAT_SIZE_xxxx, this
//                            field only used if pHTalftonePattern pointer is
//                            not NULL.
//
//  DevicePowerGamma        - This field is used to adjust halftone pattern
//                            cell's gamma, the gamma applied to all the rgb
//                            colors, see gamma description in
//                            HTCOLORADJUSTMENT above.
//
//  HTCallBackFunction      - a 32-bit pointer to the caller supplied callback
//                            function which used by the halftone DLL to
//                            obtained the source/destination bitmap pointer
//                            durning the halftone process, if this pointer is
//                            NULL then halftone dll assume that caller does
//                            not need any callback and generate an error if a
//                            callback is needed.
//
//  pHalftonePattern        - pointer to HALFTONEPATTERN data structure, see
//                            descriptions above, if this pointer is NULL then
//                            halftone using HTPatternIndex field to select
//                            default halftone dll's pattern.
//
//  pInputRGBInfo           - Specified input's rgb color' coordinates within
//                            the C.I.E. color spaces.  If this pointer is NULL
//                            or pInputRGBInfo->Red.x is 0 (UDECI4_0) then it
//                            default using NTSC standard to convert the input
//                            colors.
//
//  pDeviceCIEInfo          - Specified device primary color coordinates within
//                            the C.I.E. color space, see CIEINFO data
//                            structure, if the pointer is NULL or
//                            pDeviceCIEInfo->Red.x is 0 (UDECI4_0) then
//                            halftone DLL choose the default for the output
//                            device.
//
//  pDeviceSolidDyesInfo    - Specified device solid dyes concentrations, this
//                            field will be ignored if HIF_ADDITIVE_PRIMS flag
//                            is defined, if HIF_ADDITIVE_PRIMS is not set and
//                            this pointer is NULL then halftone dll choose
//                            approximate default for the output device.
//
//  DeviceResXDPI           - Specified the device horizontal (x direction)
//                            resolution in 'dots per inch' measurement.
//
//  DeviceResYDPI           - Specified the device vertical (y direction)
//                            resolution in 'dots per inch' measurement.
//
//  DevicePelsDPI           - Specified the device pel/dot/nozzle diameter
//                            (if rounded) or width/height (if squared) in
//                            'dots per inch' measurement.
//
//                            This value is measure as if each pel only touch
//                            each other at edge of the pel.
//
//                            If this value is 0, then it assume that each
//                            device pel is rectangular shape and has
//                            DeviceResXDPI in X direction and DeviceResYDPI
//                            in Y direction.
//
//  DefHTColorAdjustment    - Specified the default color adjustment for
//                            this device.  see HTCOLORADJUSTMENT data
//                            structure above for detail.
//
//  DeviceRGamma
//  DeviceGGamma
//  DeviceBGamma            - Red, Green, Blue gammas for the device
//
//  CMYBitMask8BPP          - only used for the BMF_8BPP_VGA256 destination
//                            surface.  It indicate the how the device surface
//                            color are translated, when HTF_USE_8BPP_BITMASK
//                            bit is turn on, this byte is the CYAN. MAGENTA
//                            YELLOW dye levels indicator.
//
//                            This byte indicate how many levels for each cyan,
//                            magenta and yellow color, and this is how the
//                            halftone write to the destination surface.
//
//
//                              Bit     7 6 5 4 3 2 1 0
//                                      |   | |   | | |
//                                      +---+ +---+ +=+
//                                        |     |    |
//                                        |     |    +-- Yellow 0-3 (4 levels)
//                                        |     |
//                                        |     +-- Magenta 0-7 (8 levels)
//                                        |
//                                        +-- Cyan 0-7 (8 levels)
//
//
//                             The maximum in the bits configuration is 3:3:2,
//                             Other invalid combination generate different
//                             output as
//
//                              0   - Indicate a gray scale output, the output
//                                    byte is a 0-255 of 256 levels gray
//
//                              1   - a 5x5x5 cube output, each cyan, magenta
//                                    and yellow color are 0-4 of 5 levels and
//                                    each color is in 25% increment.
//
//                              2   - a 6x6x6 cube output, each cyan, magenta
//                                    and yellow color are 0-5 of 6 levels and
//                                    each color is in 20% increment.
//
//                              Other value that have 0 level in one of cyan,
//                              magenta or yellow will generate an error.
//
//                              To obtain a palette for each of configuration
//                              you can call HT_Get8BPPMaskPalette()
//


#define HTINITINFO_VERSION2         (DWORD)0x48546902   // 'HTi\02'
#define HTINITINFO_VERSION          (DWORD)0x48546903   // 'HTi\03'

#define HTINITINFO_V3_CB_EXTRA      8


#define HIF_SQUARE_DEVICE_PEL       0x0001
#define HIF_HAS_BLACK_DYE           0x0002
#define HIF_ADDITIVE_PRIMS          0x0004
#define HIF_USE_8BPP_BITMASK        0x0008
#define HIF_INK_HIGH_ABSORPTION     0x0010
#define HIF_INK_ABSORPTION_INDICES  0x0060
#define HIF_DO_DEVCLR_XFORM         0x0080
#define HIF_USED_BY_DDI             0x0100
#define HIF_PRINT_DRAFT_MODE        0x0200
#define HIF_INVERT_8BPP_BITMASK_IDX 0x0400

#define HIF_BIT_MASK                (HIF_SQUARE_DEVICE_PEL          |   \
                                     HIF_HAS_BLACK_DYE              |   \
                                     HIF_ADDITIVE_PRIMS             |   \
                                     HIF_USE_8BPP_BITMASK           |   \
                                     HIF_INK_HIGH_ABSORPTION        |   \
                                     HIF_INK_ABSORPTION_INDICES     |   \
                                     HIF_DO_DEVCLR_XFORM            |   \
                                     HIF_PRINT_DRAFT_MODE           |   \
                                     HIF_INVERT_8BPP_BITMASK_IDX)

#define HIF_INK_ABSORPTION_IDX0     0x0000
#define HIF_INK_ABSORPTION_IDX1     0x0020
#define HIF_INK_ABSORPTION_IDX2     0x0040
#define HIF_INK_ABSORPTION_IDX3     0x0060

#define HIF_HIGHEST_INK_ABSORPTION  (HIF_INK_HIGH_ABSORPTION    |   \
                                     HIF_INK_ABSORPTION_IDX3)
#define HIF_HIGHER_INK_ABSORPTION   (HIF_INK_HIGH_ABSORPTION    |   \
                                     HIF_INK_ABSORPTION_IDX2)
#define HIF_HIGH_INK_ABSORPTION     (HIF_INK_HIGH_ABSORPTION    |   \
                                     HIF_INK_ABSORPTION_IDX1)
#define HIF_NORMAL_INK_ABSORPTION   HIF_INK_ABSORPTION_IDX0
#define HIF_LOW_INK_ABSORPTION      (HIF_INK_ABSORPTION_IDX1)
#define HIF_LOWER_INK_ABSORPTION    (HIF_INK_ABSORPTION_IDX2)
#define HIF_LOWEST_INK_ABSORPTION   (HIF_INK_ABSORPTION_IDX3)


#define HTBITMASKPALRGB_DW          (DWORD)'0BGR'
#define SET_HTBITMASKPAL2RGB(pPal)  (*((LPDWORD)(pPal)) = HTBITMASKPALRGB_DW)
#define IS_HTBITMASKPALRGB(pPal)    (*((LPDWORD)(pPal)) == (DWORD)0)


//
// This defined the minimum acceptable device resolutions
//

#define MIN_DEVICE_DPI              12

typedef struct _HTINITINFO {
    DWORD               Version;
    WORD                Flags;
    WORD                HTPatternIndex;
    _HTCALLBACKFUNC     HTCallBackFunction;
    PHALFTONEPATTERN    pHalftonePattern;
    PCIEINFO            pInputRGBInfo;
    PCIEINFO            pDeviceCIEInfo;
    PSOLIDDYESINFO      pDeviceSolidDyesInfo;
    UDECI4              DevicePowerGamma;
    WORD                DeviceResXDPI;
    WORD                DeviceResYDPI;
    WORD                DevicePelsDPI;
    HTCOLORADJUSTMENT   DefHTColorAdjustment;
    UDECI4              DeviceRGamma;
    UDECI4              DeviceGGamma;
    UDECI4              DeviceBGamma;
    BYTE                CMYBitMask8BPP;
    BYTE                bReserved;
    } HTINITINFO, FAR *PHTINITINFO;

//
// BITBLTPARAMS
//
//  This data structure is used when calling the HT_HalftoneBitmap(), it
//  defined where to halftone from the source bitmap to the destination
//  bitmap.
//
//  Flags           - Various flags defined how the source, destination and
//                    source mask should be calculated.
//
//                      BBPF_HAS_DEST_CLIPRECT
//
//                          Indicate that there is a clipping
//                          rectangle for the destination and it is
//                          specified by DestClipXLeft, DestClipXRight,
//                          DestClipYTop and DestClipYBottom
//
//                      BBPF_USE_ADDITIVE_PRIMS
//
//                          Specified if the halftone result will be
//                          using Red/Green/Blue primary color or
//                          using Cyan/Magenta/Yellow primary color, depends
//                          on the destination surface format as
//
//                          BMF_1BPP:
//
//                                  Additive Prims: 0=Black, 1=White
//                              Substractive Prims: 0=White, 1=Black
//
//                          BMF_4BPP_VGA16:
//
//                              Always using RED, GREEN, BLUE primaries, and
//                              ignored this flag.
//
//                          BMF_4BPP:
//
//                                  Additive Prims: RED, GREEN. BLUE
//                              Substractive Prims: CYAN, MAGENTA, YELLOW
//
//                              The order of the RGB, or CMY is specified by
//                              DestPrimaryOrder field. (see below)
//
//                          BMF_8BPP_VGA256:
//                          BMF_16BPP_555:
//                          BMF_16BPP_565:
//                          BMF_24BPP:
//                          BMF_32BPP:
//
//                              Always using RED, GREEN, BLUE primaries, and
//                              ignored this flag.
//
//                      BBPF_NEGATIVE_DEST
//
//                          Invert the final destination surface, so
//                          after the halftone it just the negative
//                          result from the source.
//
//                      BBPF_INVERT_SRC_MASK
//
//                          Invert the source mask bits before using
//                          it, this in effect make mask bit 0 (off)
//                          for copy the source and mask bit 1 (on)
//                          for preserved the destination.
//
//                      BBPF_HAS_BANDRECT
//
//                          Set to specified that rclBand RECTL data structrue
//                          should be used to compute for the caller's
//                          destination bitmap buffer.
//
//                          If this flag is not set then halftone dll assumed
//                          the caller's bitmap buffer is same width/height
//                          as specified in the destination HTSURFACEINFO.
//
//                      BBPF_BW_ONLY
//
//                          Produced monochrome version of the output even the
//                          destination is the color device.
//
//                      BBPF_TILE_SRC
//
//                          Tilt the source to destination and source bitmap
//                          when this bit is set the source mask is ignored.
//
//                      BBPF_ICM_ON
//
//                          When set, the halftone will use the input color
//                          directly without any modification
//
//                      BBPF_NO_ANTIALIASING
//
//                          Turn off anti-aliasing when halftone
//
//
//  DestPrimaryOrder- Specified destination primary color order, it can be
//                    either PRIMARY_ORDER_RGB or PRIMARY_ORDER_CMY group, it
//                    depends on the surface format has following meaning.
//
//                      BMF_1BPP:
//
//                          This field is ignored.
//
//                      BMF_4BPP_VGA16:
//
//                          This field automatically set to PRIMARY_ORDER_BGR
//                          by the halftone DLL.
//
//                      BMF_4BPP:
//
//                          for each byte there are two indices entries, and
//                          for each nibble has following meaning, notice that
//                          bit 3/7 always set to 0, the index number only
//                          range from 0 to 7.
//
//                          PRIMARY_ORDER_abc
//                                        |||
//                                        ||+-- bit 0/4
//                                        ||
//                                        |+--- bit 1/5
//                                        |
//                                        +---- bit 2/7
//
//                      BMF_8BPP_VGA256:
//
//                          This field is ignored, the palette entries and its
//                          order is defined by halftone DLL at run time, the
//                          caller should get the palette for the VGA256
//                          surface through HT_Get8BPPFormatPalette() API call.
//
//                      BMF_16BPP_555:
//
//                          PRIMARY_ORDER_abc
//                                        |||
//                                        ||+-- bit 0-4   (5 bits)
//                                        ||
//                                        |+--- bit 5-9   (5 bits)
//                                        |
//                                        +---- bit 10-14 (5 bits)
//
//                      BMF_16BPP_565:
//
//                          This field is ignored, it alway assume BGR as
//                          shown below
//
//                          PRIMARY_ORDER_BGR
//                                        |||
//                                        ||+-- bit 0-4   (5 bits)
//                                 