       ; release interrupt spin lock

;
; If interrupt logging is enabled, then log the interrupt.
;

        cmp     qword ptr TrTimeStamp[rbp], 0 ; check if interrupt logging enabled
        je      short KiID20            ; if e, interrupt logging not enabled
        mov     r8, TrTimeStamp[rbp]    ; set initial time stamp value
        mov     edx, TRUE               ; set interrupt return value
        mov     rcx, TrP5[rbp]          ; set interrupt service routine address
        call    PerfInfoLogInterrupt    ; log interrupt

KiID20: EXIT_INTERRUPT                  ; do EOI, lower IRQL, and restore state

        NESTED_END KiInterruptDispatch, _TEXT$00

        subttl  "Interrupt Dispatch, With Last Branch Control"
;++
;
; Routine Description:
;
;   This routine is entered as the result of an interrupt being generated
;   via a vector that is connected to an interrupt object. Its function is
;   to save the last branch control MSR, disable last branch recording, and
;   directly call the specified interrupt service routine.
;
;   This routine is identical to interrupt dispatch except that no spinlock
;   is taken.
;
;   N.B. On entry rbp and rsi have been saved on the stack.
;
;   N.B. This routine is only executed on EM64T based systems.
;
; Arguments:
;
;   rbp - Supplies a pointer to the interrupt object.
;
; Return Value:
;
;   None.
;
;--

        NESTED_ENTRY KiInterruptDispatchLBControl, _TEXT$00, KiInterruptHandler

        .pushframe code                 ; mark machine frame
        .pushreg rbp                    ; mark nonvolatile register push

        GENERATE_INTERRUPT_FRAME <>, <>, <>, <LBranch> ; generate interrupt frame

;
; N.B. It is possible for a interrupt to occur at an IRQL that is lower
;      than the current IRQL. This happens when the IRQL raised and at
;      the same time an interrupt request is granted.
;

        movzx   ecx, byte ptr InIrql[rsi] ; set interrupt IRQL

        ENTER_INTERRUPT <NoEOI>         ; raise IRQL and enable interrupts

        lea     rax, (-128)[rbp]        ; set trap frame address
        mov     InTrapFrame[rsi], rax   ;

;
; If interrupt logging is enabled, then store the initial time stamp value.
;

        mov     rax, gs:[PcPerfGlobalGroupMask]; get global mask address
        test    rax, rax                ; test if logging enabled
        mov     qword ptr TrTimeStamp[rbp], 0 ; clear time stamp value
        je      short KiLB10            ; if e, logging not enabled
        test    qword ptr PERF_INTERRUPT_OFFSET[rax], PERF_INTERRUPT_FLAG ; check flag
        jz      short KiLB10            ; if z, interrupt logging not enabled
        rdtsc                           ; read time stamp counter
        shl     rdx, 32                 ; combine low and high parts
        or      rax, rdx                ;
        mov     TrTimeStamp[rbp], rax   ; save starting time stamp value
        mov     rax, InServiceRoutine[rsi] ; save interrupt service routine address
        mov     TrP5[rbp], rax          ;

;
; Dispatch interrupt.
;

KiLB10: mov     rcx, rsi                ; set address of interrupt object
        mov     rdx, InServiceContext[rsi] ; set service context
        call    qword ptr InServiceRoutine[rsi] ; call interrupt service routine

;
; If interrupt logging is enabled, then log the interrupt.
;

        cmp     qword ptr TrTimeStamp[rbp], 0 ; check if interrupt logging enabled
        je      short KiLB20            ; if e, interrupt logging not enabled
        mov     r8, TrTimeStamp[rbp]    ; set initial time stamp value
        mov     edx, TRUE               ; set interrupt return value
        mov     rcx, TrP5[rbp]          ; set interrupt service routine address
        call    PerfInfoLogInterrupt    ; log interrupt

KiLB20: EXIT_INTERRUPT <>, <>, <>, <>, <LBranch> ; do EOI, lower IRQL, and restore state

        NESTED_END KiInterruptDispatchLBControl, _TEXT$00

        subttl  "Interrupt Dispatch, No Lock"
;++
;
; Routine Description:
;
;   This routine is entered as the result of an interrupt being generated
;   via a vector that is connected to an interrupt object. Its function is
;   to directly call the specified interrupt service routine.
;
;   This routine is identical to interrupt dispatch except that no spinlock
;   is taken.
;
;   N.B. On entry rbp and rsi have been saved on the stack.
;
; Arguments:
;
;   rbp - Supplies a pointer to the interrupt object.
;
; Return Value:
;
;   None.
;
;--

        NESTED_ENTRY KiInterruptDispatchNoLock, _TEXT$00, KiInterruptHandler

        .pushframe code                 ; mark machine frame
        .pushreg rbp                    ; mark nonvolatile register push

        GENERATE_INTERRUPT_FRAME        ; generate interrupt frame

;
; N.B. It is possible for a interrupt to occur at an IRQL that is lower
;      than the current IRQL. This happens when the IRQL raised and at
;      the same time an interrupt request is granted.
;

        movzx   ecx, byte ptr InIrql[rsi] ; set interrupt IRQL

        ENTER_INTERRUPT <NoEOI>         ; raise IRQL and enable interrupts

        lea     rax, (-128)[rbp]        ; set trap frame address
        mov     InTrapFrame[rsi], rax   ;

;
; If interrupt logging is enabled, then store the initial time stamp value.
;

        mov     rax, gs:[PcPerfGlobalGroupMask]; get global mask address
        test    rax, rax                ; test if logging enabled
        mov     qword ptr TrTimeStamp[rbp], 0 ; clear time stamp value
        je      short KiNL10            ; if e, logging not enabled
        test    qword ptr PERF_INTERRUPT_OFFSET[rax], PERF_INTERRUPT_FLAG ; check flag
        jz      short KiNL10            ; if z, interrupt logging not enabled
        rdtsc                           ; read time stamp counter
        shl     rdx, 32                 ; combine low and high parts
        or      rax, rdx                ;
        mov     TrTimeStamp[rbp], rax   ; save starting time stamp value
        mov     rax, InServiceRoutine[rsi] ; save interrupt service routine address
        mov     TrP5[rbp], rax          ;

;
; Dispatch interrupt.
;

KiNL10: mov     rcx, rsi                ; set address of interrupt object
        mov     rdx, InServiceContext[rsi] ; set service context
        call    qword ptr InServiceRoutine[rsi] ; call interrupt service routine

;
; If interrupt logging is enabled, then log the interrupt.
;

        cmp     qword ptr TrTimeStamp[rbp], 0 ; check if interrupt logging enabled
        je      short KiNL20            ; if e, interrupt logging not enabled
        mov     r8, TrTimeStamp[rbp]    ; set initial time stamp value
        mov     edx, TRUE               ; set interrupt return value
        mov     rcx, TrP5[rbp]          ; set interrupt service routine address
        call    PerfInfoLogInterrupt    ; log interrupt

KiNL20: EXIT_INTERRUPT                  ; do EOI, lower IRQL, and restore state

        NESTED_END KiInterruptDispatchNoLock, _TEXT$00

        subttl  "Interrupt Dispatch, No EOI"
;++
;
; Routine Description:
;
;   This routine is entered as the result of an interrupt being generated
;   via a vector that is connected to an interrupt object. Its function is
;   to directly call the specified interrupt service routine.
;
;   This routine is identical to KiInterruptDispatchNolock except that no 
;   EOI is performed.
;
;   N.B. On entry rbp and rsi have been saved on the stack.
;
; Arguments:
;
;   rbp - Supplies a pointer to the interrupt object.
;
; Return Value:
;
;   None.
;
;--

        NESTED_ENTRY KiInterruptDispatchNoEOI, _TEXT$00, KiInterruptHandler

        .pushframe code                 ; mark machine frame
        .pushreg rbp                    ; mark nonvolatile register push

        GENERATE_INTERRUPT_FRAME        ; generate interrupt frame

;
; N.B. It is possible for a interrupt to occur at an IRQL that is lower
;      than the current IRQL. This happens when the IRQL raised and at
;      the same time an interrupt request is granted.
;

        movzx   ecx, byte ptr InIrql[rsi] ; set interrupt IRQL

        ENTER_INTERRUPT <NoEOI>         ; raise IRQL and enable interrupts

        lea     rax, (-128)[rbp]        ; set trap frame address
        mov     InTrapFrame[rsi], rax   ;

;
; If interrupt logging is enabled, then store the initial time stamp value.
;

        mov     rax, gs:[PcPerfGlobalGroupMask]; get global mask address
        test    rax, rax                ; test if logging enabled
        mov     qword ptr TrTimeStamp[rbp], 0 ; clear time stamp value
        je      short KiNE10            ; if e, logging not enabled
        test    qword ptr PERF_INTERRUPT_OFFSET[rax], PERF_INTERRUPT_FLAG ; check flag
        jz      short KiNE10            ; if z, interrupt logging not enabled
        rdtsc                           ; read time stamp counter
        shl     rdx, 32                 ; combine low and high parts
        or      rax, rdx                ;
        mov     TrTimeStamp[rbp], rax   ; save starting time stamp value
        mov     rax, InServiceRoutine[rsi] ; save interrupt service routine address
        mov     TrP5[rbp], rax          ;

;
; Dispatch interrupt.
;

KiNE10: mov     rcx, rsi                ; set address of interrupt object
        mov     rdx, InServiceContext[rsi] ; set service context
        call    qword ptr InServiceRoutine[rsi] ; call interrupt service routine

;
; If interrupt logging is enabled, then log the interrupt.
;

        cmp     qword ptr TrTimeStamp[rbp], 0 ; check if interrupt logging enabled
        je      short KiNE20            ; if e, interrupt logging not enabled
        mov     r8, TrTimeStamp[rbp]    ; set initial time stamp value
        mov     edx, TRUE               ; set interrupt return value
        mov     rcx, TrP5[rbp]          ; set interrupt service routine address
        call    PerfInfoLogInterrupt    ; log interrupt

KiNE20: EXIT_INTERRUPT <NoEOI>          ; lower IRQL, and restore state

        NESTED_END KiInterruptDispatchNoEOI, _TEXT$00

        subttl  "Interrupt Template"
;++
;
; Routine Description:
;
;   This routine is a template that is copied into each interrupt object.
;   Its function is to save volatile machine state, compute the interrupt
;   object address, and transfer control to the appropriate interrupt
;   dispatcher.
;
;   N.B. Interrupts are disabled on entry to this routine.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    N.B. Control does not return to this routine. The respective interrupt
;         dispatcher dismisses the interrupt directly.
;
;--

        LEAF_ENTRY KiInterruptTemplate, _TEXT$00

        push    rax                     ; push dummy vector number
        push    rbp                     ; save nonvolatile register
        lea     rbp, KiInterruptTemplate - InDispatchCode ; get interrupt object address
        jmp     qword ptr InDispatchAddress[rbp] ; finish in common code

        LEAF_END KiInterruptTemplate, _TEXT$00

        subttl  "Spurious Interrupt Template"
;++
;
; Routine Description:
;
;   This routine is a template that is copied into the spurious interrupt
;   objects.  Its function is to immediately iret.
;
;   N.B. Interrupts are disabled on entry to this routine.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    None.
;
;--

        LEAF_ENTRY KiSpuriousInterruptTemplate, _TEXT$00

;
; N.B. KINTERRUPT.ServiceCount and KINTERRUPT.DispatchCount are treated as a
; single quadword field and a 64-bit increment is performed.
;

        db      048h, 0FFh, 005h
        dd      InServiceCount - (InDispatchCode + 7)

        iretq

        LEAF_END KiSpuriousInterruptTemplate, _TEXT$00


        subttl  "Unexpected Interrupt Code"
;++
;
; RoutineDescription:
;
;   An entry in the following table is generated for each vector that can
;   receive an unexpected interrupt. Each entry in the table contains code
;   to push the vector number on the stack and then jump to common code to
;   process the unexpected interrupt.
;
; Arguments:
;
;    None.
;
;--

        NESTED_ENTRY KiUnexpectedInterrupt, _TEXT$00

        .pushframe code                 ; mark machine frame
        .pushreg rbp                    ; mark nonvolatile register push

        GENERATE_INTERRUPT_FRAME <Vector>  ; generate interrupt frame

        mov     ecx, eax                ; compute interrupt IRQL
        shr     ecx, 4                  ;

        ENTER_INTERRUPT <NoEOI>         ; raise IRQL and enable interrupts

        EXIT_INTERRUPT                  ; do EOI, lower IRQL, and restore state

        NESTED_END KiUnexpectedInterrupt, _TEXT$00

        end
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ke\amd64\misc.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    misc.c

Abstract:

    This module implements machine dependent miscellaneous kernel functions.

--*/

#include "ki.h"

PKPRCB
KeQueryPrcbAddress (
    __in ULONG Number
    )

/*++

Routine Description:

    This function returns the processor block address for the specified
    processor number.

Arguments:

    Number - Supplies the number of the processor.

Return Value:

    The processor block address for the specified processor.

--*/

{
    ASSERT(Number <= (ULONG)KeNumberProcessors);

    return KiProcessorBlock[Number];
}

VOID
KeRestoreProcessorSpecificFeatures (
    VOID
    )

/*++

Routine Description:

    Restore processor specific features.  This routine is called
    when processors have been restored to a powered on state to
    restore those things which are not part of the processor's
    "normal" context which may have been lost.  For example, this
    routine is called when a system is resumed from hibernate or
    suspend.

Arguments:

    None.

Return Value:

    None.

--*/

{

    CPU_INFO InformationExtended;

    // 
    // Restore the page attribute table for the current processor.
    // 

    KiSetPageAttributesTable();

    //
    // Check for fast floating/save restore and, if present, enable for the
    // current processor.
    //

    KiCpuId(0x80000001, 0, &InformationExtended);
    if ((InformationExtended.Edx & XHF_FFXSR) != 0) {
        WriteMSR(MSR_EFER, ReadMSR(MSR_EFER) | MSR_FFXSR);
    }

    return;
}

VOID
KeSaveStateForHibernate (
    __out PKPROCESSOR_STATE ProcessorState
    )

/*++

Routine Description:

    Saves all processor-specific state that must be preserved
    across an S4 state (hibernation).

Arguments:

    ProcessorState - Supplies the KPROCESSOR_STATE where the current CPU's
        state is to be saved.

Return Value:

    None.

--*/

{

    //
    // Save processor specific state for hibernation.
    //

    RtlCaptureContext(&ProcessorState->ContextFrame);
    ProcessorState->SpecialRegisters.MsrGsBase = ReadMSR(MSR_GS_BASE);
    ProcessorState->SpecialRegisters.MsrGsSwap = ReadMSR(MSR_GS_SWAP);
    ProcessorState->SpecialRegisters.MsrStar = ReadMSR(MSR_STAR);
    ProcessorState->SpecialRegisters.MsrLStar = ReadMSR(MSR_LSTAR);
    ProcessorState->SpecialRegisters.MsrCStar = ReadMSR(MSR_CSTAR);
    ProcessorState->SpecialRegisters.MsrSyscallMask = ReadMSR(MSR_SYSCALL_MASK);
    ProcessorState->ContextFrame.Rip = (ULONG_PTR)_ReturnAddress();
    ProcessorState->ContextFrame.Rsp = (ULONG_PTR)&ProcessorState;
    KiSaveProcessorControlState(ProcessorState);
    return;
}

VOID
KiProcessNMI (
    IN PKTRAP_FRAME TrapFrame,
    IN PKEXCEPTION_FRAME ExceptionFrame
    )

/*++

Routine Description:

    This function processes a nonmaskable interrupt (NMI).

    N.B. This function is called from the NMI trap routine with interrupts
         disabled.

Arguments:

    TrapFrame - Supplies a pointer to a trap frame.

    ExceptionFrame - Supplies a pointer to an exception frame.

Return Value:

    None.

--*/

{
    static LONG64 NmiInProgress = 0;
    ULONG Number;

    //
    // First check for a pending freeze execution request from another
    // processor.
    //

#if !defined(NT_UP)

    if (KiCheckForFreezeExecution(TrapFrame, ExceptionFrame) != FALSE) {
        return;
    }

#endif

    //
    // Return immediately if this processor is already processing an NMI.
    //

    Number = KeGetCurrentPrcb()->Number;
    if (InterlockedBitTestAndSet64(&NmiInProgress, Number) != FALSE) {
        return;
    }

    //
    // Process NMI callback functions.
    //
    // If no callback function handles the NMI, then let the HAL handle it.
    //

    if (KiHandleNmi() == FALSE) {
        KiAcquireSpinLockCheckForFreeze(&KiNMILock, TrapFrame, ExceptionFrame);
        KeBugCheckActive = TRUE;
        HalHandleNMI(NULL);
        KeBugCheckActive = FALSE;
        KeReleaseSpinLockFromDpcLevel(&KiNMILock);
    }

    InterlockedBitTestAndReset64(&NmiInProgress, Number);

    return;
}

#if !defined(NT_UP)

VOID
KiWaitForReboot (
    VOID
    )

/*++

Routine Description:

    Frozen processors are resumed to this routine in the event that
    a .reboot is being processed.

Arguments:

    None.

Return Value:

    Never returns.

--*/

{
    while (TRUE) {
        NOTHING;
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ke\amd64\miscs.asm ===
title  "Miscellaneous Functions"
;++
;
; Copyright (c) Microsoft Corporation. All rights reserved. 
;
; You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
; If you do not agree to the terms, do not use the code.
;
;
; Module Name:
;
;   miscs.asm
;
; Abstract:
;
;   This module implements machine dependent miscellaneous kernel functions.
;
;--

include ksamd64.inc

        extern  KiContinueEx:proc
        extern  KiExceptionExit:proc
        extern  KiRaiseException:proc

        subttl  "Continue Execution System Service"
;++
;
; NTSTATUS
; NtContinue (
;     IN PCONTEXT ContextRecord,
;     IN BOOLEAN TestAlert
;     )
;
; Routine Description:
;
;   This routine is called as a system service to continue execution after
;   an exception has occurred. Its function is to transfer information from
;   the specified context record into the trap frame that was built when the
;   system service was executed, and then exit the system as if an exception
;   had occurred.
;
; Arguments:
;
;   ContextRecord (rcx) - Supplies a pointer to a context record.
;
;   TestAlert (dl) - Supplies a boolean value that specifies whether alert
;       should be tested for the previous processor mode.
;
; Implicit Arguments:
;
;   rbp - Supplies the address of a trap frame.
;
; Return Value:
;
;   Normally there is no return from this routine. However, if the specified
;   context record is misaligned or is not accessible, then the appropriate
;   status code is returned.
;
;--

        NESTED_ENTRY NtContinue, _TEXT$00

        GENERATE_EXCEPTION_FRAME        ; generate exception frame

;
; Copy context to kernel frames or bypass for user APC.
;
; N.B. The context record and test alert arguments are in the same
;      registers.
;

        mov     r8, rsp                 ; set exception frame address
        lea     r9, (-128)[rbp]         ; set trap frame address
        call    KiContinueEx            ; transfer context to kernel frames

;
; If the return status is less than or equal to zero, then return via the
; system service dispatcher. Otherwise, return via exception exit.
;

        test    eax, eax                ; test return status value
        jle     short KiCO10            ; if le, return via service dispatcher

;
; Return via exception exit.
;
; If the legacy stated is switched, then restore the legacy floating state.
;
; N.B. If the legacy state is restored, then xmm6-xmm15 are also restored
;      with potentially incorrect values. Fortunately, exception exit will
;      restore these registers with their proper value before returning to
;      the user.
;
; N.B. The below code uses an unusual sequence to transfer control. This
;      instruction sequence is required to avoid detection as an epilogue.
;
                                                                          
        mov     rcx, gs:[PcCurrentThread] ; get current thread address
        test    byte ptr TrSegCs[rbp], MODE_MASK ; test if previous mode kernel
        jnz     short KiCO05            ; if nz, previous mode user
        mov     rdx, TrTrapFrame[rbp]   ; restore previous trap frame address
        mov     ThTrapFrame[rcx], rdx   ;
        mov     dl, TrPreviousMode[rbp] ; restore thread previous mode
        mov     ThPreviousMode[rcx], dl ;
KiCO05: lea     rcx, KiExceptionExit    ; get address of exception exit
        jmp     rcx                     ; finish in common code

;
; Return via the system service dispatcher.
;
; N.B. The nonvolatile state in the exception frame is not restored since
;      the state is not used in this function.
;

KiCO10: add     rsp, (KEXCEPTION_FRAME_LENGTH - (1 * 8)) ; deallocate stack frame
        ret                             ; return

        NESTED_END NtContinue, _TEXT$00

        subttl  "Raise Exception System Service"
;++
;
; NTSTATUS
; NtRaiseException (
;     IN PEXCEPTION_RECORD ExceptionRecord,
;     IN PCONTEXT ContextRecord,
;     IN BOOLEAN FirstChance
;     )
;
; Routine Description:
;
;   This routine is called as a system service to raise an exception. Its
;   function is to transfer information from the specified context record
;   into the trap frame that was built when the system service was executed.
;   The exception may be raised as a first or second chance exception.
;
; Arguments:
;
;   ExceptionRecord (rcx) - Supplies a pointer to an exception record.
;
;   ContextRecord (rdx) - Supplies a pointer to a context record.
;
;   FirstChance (r8b) - Supplies a boolean value that specifies whether
;       this is the first (TRUE) or second chance (FALSE) for dispatching
;       the exception.
;
; Implicit Arguments:
;
;   rbp - Supplies a pointer to a trap frame.
;
; Return Value:
;
;   Normally there is no return from this routine. However, if the specified
;   context record or exception record is misaligned or is not accessible,
;   then the appropriate status code is returned.
;
;--

        NESTED_ENTRY NtRaiseException, _TEXT$00

        GENERATE_EXCEPTION_FRAME        ; generate exception frame

;
; Record the address of the caller in a place that won't be overwritten
; by the following context to k-frames.
;

        mov     rax, TrRip[rbp]         ; copy fault address to preserved entry
        mov     TrFaultAddress[rbp], rax ;

;
; Call the raise exception kernel routine which will marshall the arguments
; and then call the exception dispatcher.
;

        mov     ExP5[rsp], r8b          ; set first chance parameter
        mov     r8, rsp                 ; set exception frame address
        lea     r9, (-128)[rbp]         ; set trap frame address
        call    KiRaiseException        ; call raise exception routine

;
; If the kernel raise exception routine returns success, then exit via the
; exception exit code. Otherwise, return to the system service dispatcher.
;

        test    eax, eax                ; test if service failed
        jnz     short KiRE20            ; if nz, service failed

;
; Exit via the exception exit code which will restore the machine state.
;
; N.B. The below code uses an unusual sequence to transfer control. This
;      instruction sequence is required to avoid detection as an epilogue.
;

        test    byte ptr TrSegCs[rbp], MODE_MASK ; test if previous mode kernel
        jnz     short KiRE10            ; if nz, previous mode user
        mov     rbx, gs:[PcCurrentThread] ; get current thread address
        mov     rdx, TrTrapFrame[rbp]   ; restore previous trap frame address
        mov     ThTrapFrame[rbx], rdx   ;
        mov     dl, TrPreviousMode[rbp] ; restore thread previous mode
        mov     ThPreviousMode[rbx], dl ;
KiRE10: lea     rcx, KiExceptionExit    ; get address of exception exit
        jmp     rcx                     ; finish in common code

;
; The context or exception record is misaligned or not accessible, or the
; exception was not handled.
;

KiRE20: RESTORE_EXCEPTION_STATE         ; restore exception state/deallocate

        ret                             ; return

        NESTED_END NtRaiseException, _TEXT$00

;++
;
; ULONG
; KiDivide6432 (
;     IN ULONG64 Dividend,
;     IN ULONG Divisor
;     );
;
; Routine Description:
;
;   This routine performs a divide operation with a dividend of exactly
;   64 bits, a divisor of exactly 32 bits, and a quotient of exactly 32
;   bits.
;
; Arguments:
;
;   Dividend - Supplies a 64-bit unsigned dividend.
;
;   Divisor - Supplies a 32-bit unsigned divisor.
;
; Return Value:
;
;   Returns the 32-bit unsigned quotient.
;
;-- 

        LEAF_ENTRY KiDivide6432, INIT

        mov     eax, ecx                ; set low 32-bits of dividend
        mov     r8, rdx                 ; save 32-bit divisor
        shr     rcx, 32                 ; set high 32-bits of dividend
        mov     edx, ecx                ;
        div     r8d                     ; perform 64/32 to 32 divide
        ret                             ;

        LEAF_END KiDivide6432, INIT

        end
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ke\amd64\procstat.asm ===
title  "Processor State Save Restore"
;++
;
; Copyright (c) Microsoft Corporation. All rights reserved. 
;
; You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
; If you do not agree to the terms, do not use the code.
;
;
; Module Name:
;
;   procstat.asm
;
; Abstract:
;
;   This module implements routines to save and restore processor control
;   state.
;
;--

include ksamd64.inc

        altentry KiBugCheckReturn

        extern  KeBugCheck2:proc
        extern  KxContextToKframes:proc
        extern  KiHardwareTrigger:dword
        extern  RtlCaptureContext:proc

        subttl  "BugCheck"
;++
;
; VOID
; KeBugCheck (
;     __in ULONG BugCheckCode
;     )
;
; Routine Description:
;
;   This routine calls extended bugcheck to crash the system in a controlled
;   manner.
;
; Arguments:
;
;   BugCheckCode (rcx) - BugCheck code.
;
; Return Value:
;
;   None - function does not return.
;
;--

BcFrame struct
        P1Home  dq ?                    ; parameter home addresses
        P2Home  dq ?                    ;
        P3Home  dq ?                    ;
        P4Home  dq ?                    ;
        P5Home  dq ?                    ;
BcFrame ends

        NESTED_ENTRY KeBugCheck, _TEXT$00

        alloc_stack (sizeof BcFrame)    ; allocate stack frame 

        END_PROLOGUE

        ALTERNATE_ENTRY KiBugCheckReturn

        call KeBugCheckEx               ; bugcheck system - not return
        nop                             ; fill - do not remove

        NESTED_END KeBugCheck, _TEXT$00

        subttl  "BugCheck 3"
;++
;
; VOID
; KeBugCheck3 (
;     __in ULONG BugCheckCode,
;     __in ULONG_PTR P1,
;     __in ULONG_PTR P2,
;     __in ULONG_PTR P3
;     )
;
; Routine Description:
;
;   This routine calls extended bugcheck to crash the system in a controlled
;   manner.
;
;   This routine differs from KeBugCheckEx in that the fourth bugcheck
;   parameter is not used and presumed zero.
;
; Arguments:
;
;   BugCheckCode (rcx) - BugCheck code.
;
;   P1, P2 and P3 - Bugcheck parameters
;
; Return Value:
;
;   None - function does not return.
;
;--

BcFrame struct
        P1Home  dq ?                    ; parameter home addresses
        P2Home  dq ?                    ;
        P3Home  dq ?                    ;
        P4Home  dq ?                    ;
        P5Home  dq ?                    ;
BcFrame ends

        NESTED_ENTRY KiBugCheck3, _TEXT$00

        alloc_stack (sizeof BcFrame)    ; allocate stack frame 

        END_PROLOGUE

        mov     BcFrame.P5Home[rsp], 0
        call    KeBugCheckEx            ; bugcheck system - not return

        nop                             ; fill - do not remove

        NESTED_END KiBugCheck3, _TEXT$00


        subttl "BugCheck Extended"
;++
;
; VOID
; KeBugCheckEx (
;     __in ULONG BugCheckCode,
;     __in ULONG_PTR P1,
;     __in ULONG_PTR P2,
;     __in ULONG_PTR P3,
;     __in ULONG_PTR P4
;     )
;
; Routine Description:
;
;   This routine restores the context and control state of the current 
;   processor and passes control to KeBugCheck2.
;
; Arguments:
;
;   BugCheckCode (rcx) - BugCheck code.
;
;   P1, P2, P3 and P4 - BugCheck parameters.
;
; Return Value:
;
;   None - function does not return.
;
;--

BeFrame struct
        P1Home  dq ?                    ; parameter home addresses
        P2Home  dq ?                    ;
        P3Home  dq ?                    ;
        P4Home  dq ?                    ;
        P5Home  dq ?                    ;
        P6Home  dq ?                    ;
        Flags   dq ?                    ;
BeFrame ends

        NESTED_ENTRY KeBugCheckEx, _TEXT$00

        mov     P1Home[rsp], rcx        ; save argument registers
        mov     P2Home[rsp], rdx        ;
        mov     P3Home[rsp], r8         ;
        mov     P4Home[rsp], r9         ;

        push_eflags                     ; save processor flags
        alloc_stack (sizeof BeFrame - 8) ; allocate stack frame 

        END_PROLOGUE

;
; Capture Processor context and control state
;

        cli                             ; disable interrupts
        mov     rcx, gs:[PcCurrentPrcb] ; get current PRCB address
        add     rcx, PbProcessorState + PsContextFrame ; set context address
        call    RtlCaptureContext       ; capture processor context
        mov     rcx, gs:[PcCurrentPrcb] ; get current PRCB address
        add     rcx, PbProcessorState   ; set address of processor state
        call    KiSaveProcessorControlState; save processor control state

;
; Update register values in captured context to their state at the entry 
; of BugCheck function.
;

        mov     r10, gs:[PcCurrentPrcb] ; get current PRCB address
        add     r10, PbProcessorState + PsContextFrame ; point to context frame
        mov     rax, P1Home + (sizeof BeFrame)[rsp] ; get saved rcx
        mov     CxRcx[r10], rax         ; update rcx in context frame
        mov     rax, BeFrame.Flags[rsp] ; get saved flags
        mov     CxEFlags[r10], rax      ; update rflag in context frame
        lea     rax, KiBugCheckReturn + 5 ; get return address of KeBugCheck
        cmp     rax, (sizeof BeFrame)[rsp] ; identify caller by return address
        jnz     short KeBC10            ; if nz, caller is not KeBugCheck
        lea     r8, (sizeof BeFrame) + (sizeof BcFrame) + 8[rsp] 
                                        ; calculate rsp at entry of KeBugCheck
        lea     r9, KeBugCheck          ; get the entry point of KeBugCheck
        jmp     short KeBC20            ; 
KeBC10: lea     r8, (sizeof BeFrame)[rsp] ; calculate rsp at entry of KeBugCheckEx
        lea     r9, KeBugCheckEx        ; get the entry point of KeBugCheckEx
KeBC20: mov     CxRsp[r10], r8          ; update rsp in context frame
        mov     CxRip[r10], r9          ; update rip in context frame
        
;
; Raise IRQL and enable interrupt as appropriate.
;

        CurrentIrql                     ; get current IRQL 

        mov     gs:[PcDebuggerSavedIRQL], al ; save current IRQL
        cmp     al, DISPATCH_LEVEL      ; check if IRQL is less than dispatch
        jge     short KeBC30            ; if ge, don't bother to raise
        mov     ecx, DISPATCH_LEVEL     ; raise to DISPATCH_LEVEL

        SetIrql                         ; set IRQL

KeBC30: mov     rax, BeFrame.Flags[rsp] ; get saved flags
        and     rax, EFLAGS_IF_MASK     ; check previous interrupt state 
        jz      short KeBC40            ; if z, interrupt was disabled
        sti                             ; enable interrupt
KeBC40:
   lock inc KiHardwareTrigger           ; assert lock to avoid speculative read

;
; Pass control to KeBugCheck2
;

        mov     rcx, P1Home + (sizeof BeFrame)[rsp] ; get saved bugcheck code
        mov     qword ptr BeFrame.P6Home[rsp], 0  ; set parameter 6 to NULL
        lea     rax, KiBugCheckReturn + 5; get return address of KeBugCheck
        cmp     rax, (sizeof BeFrame)[rsp] ; identify caller by return address
        jz      short KeBC50            ; if z, caller is KeBugCheck
        mov     rax, (5 * 8) + (sizeof BeFrame)[rsp] ; get parameter 5
        mov     BeFrame.P5Home[rsp], rax; set parameter 5
        mov     r9,  P4Home + (sizeof BeFrame)[rsp] ; restore parameter 4
        mov     r8,  P3Home + (sizeof BeFrame)[rsp] ; restore parameter 3
        mov     rdx, P2Home + (sizeof BeFrame)[rsp] ; restore parameter 2
        call    KeBugCheck2             ; bugcheck system - not return
        nop                             ; fill - do not remove
                                        ;
KeBC50: mov     qword ptr Beframe.P5Home[rsp], 0  ; set parameter 5 to 0
        xor     r9d, r9d                ; set parameter 4 to 0
        xor     r8d, r8d                ; set parameter 3 to 0
        xor     edx, edx                ; set parameter 2 to 0
        call    KeBugCheck2             ; bugcheck system - not return
        nop                             ; fill - do not remove

        NESTED_END KeBugCheckEx, _TEXT$00

        subttl "Context To Kernel Frame"
;++
;
; VOID
; KeContextToKframes (
;     IN OUT PKTRAP_FRAME TrapFrame,
;     IN OUT PKEXCEPTION_FRAME ExceptionFrame,
;     IN PCONTEXT ContextRecord,
;     IN ULONG ContextFlags,
;     IN KPROCESSOR_MODE PreviousMode
;     )
;
; Routine Description:
;
;    This function saves the current non-volatile XMM state, performs a
;    context to kernel frames operation, then restores the non-volatile
;    XMM state.
;
; Arguments:
;
;    TrapFrame (rcx) - Supplies a pointer to a trap frame that receives the
;        volatile context from the context record.
;
;    ExceptionFrame (rdx) - Supplies a pointer to an exception frame that
;        receives the nonvolatile context from the context record.
;
;    ContextRecord (r8) - Supplies a pointer to a context frame that contains
;        the context that is to be copied into the trap and exception frames.
;
;    ContextFlags (r9) - Supplies the set of flags that specify which parts
;        of the context frame are to be copied into the trap and exception
;        frames.
;
;    PreviousMode (32[rsp]) - Supplies the processor mode for which the
;        exception and trap frames are being built.
;
; Return Value:
;
;    None.
;
;--

KfFrame struct
        P1Home  dq ?                    ; parameter home addresses
        P2Home  dq ?                    ;
        P3Home  dq ?                    ;
        P4Home  dq ?                    ;
        P5Home  dq ?                    ;
        OldIrql dd ?                    ; previous IRQL
        Fill1   dd ?                    ; fill
        SavedXmm6 db 16 dup (?)         ; saved nonvolatile floating registers
        SavedXmm7 db 16 dup (?)         ;
        SavedXmm8 db 16 dup (?)         ;
        SavedXmm9 db 16 dup (?)         ;
        SavedXmm10 db 16 dup (?)        ;
        SavedXmm11 db 16 dup (?)        ;
        SavedXmm12 db 16 dup (?)        ;
        SavedXmm13 db 16 dup (?)        ;
        SavedXmm14 db 16 dup (?)        ;
        SavedXmm15 db 16 dup (?)        ;
        Fill2   dq ?                    ; fill
KfFrame ends

        NESTED_ENTRY KeContextToKframes, _TEXT$00

        alloc_stack (sizeof KfFrame)    ; allocate stack frame
        save_xmm128 xmm6, KfFrame.SavedXmm6 ; save nonvolatile floating registers
        save_xmm128 xmm7, KfFrame.SavedXmm7 ;
        save_xmm128 xmm8, KfFrame.SavedXmm8 ;
        save_xmm128 xmm9, KfFrame.SavedXmm9 ;
        save_xmm128 xmm10, KfFrame.SavedXmm10 ;
        save_xmm128 xmm11, KfFrame.SavedXmm11 ;
        save_xmm128 xmm12, KfFrame.SavedXmm12 ;
        save_xmm128 xmm13, KfFrame.SavedXmm13 ;
        save_xmm128 xmm14, KfFrame.SavedXmm14 ;
        save_xmm128 xmm15, KfFrame.SavedXmm15 ;

        END_PROLOGUE

        mov     rax, cr8                ; get current IRQL
        mov     KfFrame.OldIrql[rsp], eax ; save current IRQL
        cmp     eax, APC_LEVEL          ; check if above or equal to APC level
        jae     short KfCS10            ; if ae, above or equal APC level
        mov     eax, APC_LEVEL          ; raise IRQL to APC level
        mov     cr8, rax                ;
KfCS10: mov     r10, (5 * 8) + (sizeof KfFrame)[rsp] ; get parameter 5
        mov     KfFrame.P5Home[rsp], r10 ; set parameter 5
        mov     rax, dr7                ; access debug register
        call    KxContextToKframes      ; perform a context to kernel frames
        test    rax, rax                ; test if legacy floating switched
        jz      short KfCS20            ; if z, legacy floating not switched

;
; N.B. The following legacy restore also restores the nonvolatile floating
;      registers xmm6-xmm15 with potentially incorrect values. Fortunately,
;      these registers are restored to their proper value shortly thereafter.
;

        fxrstor [rax]                   ; restore legacy floating state
KfCS20: cmp     KfFrame.OldIrql[rsp], APC_LEVEL ; check if lower IRQL required
        jae     short KfCS30            ; if ae, lower IRQL not necessary
        mov     eax, KfFrame.OldIrql[rsp] ; lower IRQL to previous level
        mov     cr8, rax                ;
KfCS30: movdqa  xmm6, KfFrame.SavedXmm6[rsp] ; restore nonvolatile floating registers
        movdqa  xmm7, KfFrame.SavedXmm7[rsp] ;
        movdqa  xmm8, KfFrame.SavedXmm8[rsp] ;
        movdqa  xmm9, KfFrame.SavedXmm9[rsp] ;
        movdqa  xmm10, KfFrame.SavedXmm10[rsp] ;
        movdqa  xmm11, KfFrame.SavedXmm11[rsp] ;
        movdqa  xmm12, KfFrame.SavedXmm12[rsp] ;
        movdqa  xmm13, KfFrame.SavedXmm13[rsp] ;
        movdqa  xmm14, KfFrame.SavedXmm14[rsp] ;
        movdqa  xmm15, KfFrame.SavedXmm15[rsp] ;
        add     rsp, (sizeof KfFrame)   ; deallocate stack frame
        ret                             ; return

        NESTED_END KeContextToKframes, _TEXT$00

        subttl  "Save Initial Processor Control State"
;++
;
; KiSaveInitialProcessorControlState (
;     PKPROCESSOR_STATE ProcessorState
;     );
;
; Routine Description:
;
;   This routine saves the initial control state of the current processor.
;
;   N.B. The debug register state is not saved.
;
; Arguments:
;
;   ProcessorState (rcx) - Supplies a pointer to a processor state structure.
;
; Return Value:
;
;    None.
;
;--

        LEAF_ENTRY KiSaveInitialProcessorControlState, _TEXT$00

        mov     rax, cr0                ; save processor control state
        mov     PsCr0[rcx], rax         ;
        mov     rax, cr2                ;
        mov     PsCr2[rcx], rax         ;
        mov     rax, cr3                ;
        mov     PsCr3[rcx], rax         ;
        mov     rax, cr4                ;
        mov     PsCr4[rcx], rax         ;
        mov     rax, cr8                ;
        mov     PsCr8[rcx], rax         ;

        sgdt    fword ptr PsGdtr[rcx]   ; save GDTR
        sidt    fword ptr PsIdtr[rcx]   ; save IDTR

        str     word ptr PsTr[rcx]      ; save TR
        sldt    word ptr PsLdtr[rcx]    ; save LDTR

        stmxcsr dword ptr PsMxCsr[rcx]  ; save XMM control/status
        ret                             ; return

        LEAF_END KiSaveInitialProcessorControlState, _TEXT$00

        subttl  "Restore Processor Control State"
;++
;
; KiRestoreProcessorControlState (
;     VOID
;     );
;
; Routine Description:
;
;   This routine restores the control state of the current processor.
;
; Arguments:
;
;   ProcessorState (rcx) - Supplies a pointer to a processor state structure.
;
; Return Value:
;
;   None.
;
;--

        LEAF_ENTRY KiRestoreProcessorControlState, _TEXT$00

        mov     rax, PsCr0[rcx]         ; restore processor control registers
        mov     cr0, rax                ;
        mov     rax, PsCr3[rcx]         ;
        mov     cr3, rax                ;
        mov     rax, PsCr4[rcx]         ;
        mov     cr4, rax                ;
        mov     rax, PsCr8[rcx]         ;
        mov     cr8, rax                ;

        lgdt    fword ptr PsGdtr[rcx]   ; restore GDTR
        lidt    fword ptr PsIdtr[rcx]   ; restore IDTR

;
; Force the TSS descriptor into a non-busy state so no fault will occur when
; TR is loaded.
;

	movzx	eax, word ptr PsTr[rcx] ; get TSS selector
	add	rax, PsGdtr + 2[rcx]	; compute TSS GDT entry address
	and	byte ptr 5[rax], NOT 2  ; clear busy bit
        ltr     word ptr PsTr[rcx]      ; restore TR

	xor     eax, eax                ; load a NULL selector into the ldt
	lldt	ax                      ;

        ldmxcsr dword ptr PsMxCsr[rcx]  ; restore XMM control/status

;
; Restore debug control state.
;

        xor     edx, edx                ; restore debug registers
        mov     dr7, rdx                ;
        mov     rax, PsKernelDr0[rcx]   ;
        mov     rdx, PsKernelDr1[rcx]   ;
        mov     dr0, rax                ;
        mov     dr1, rdx                ;
        mov     rax, PsKernelDr2[rcx]   ;
        mov     rdx, PsKernelDr3[rcx]   ;
        mov     dr2, rax                ;
        mov     dr3, rdx                ;
        mov     rdx, PsKernelDr7[rcx]   ;
        xor     eax, eax                ;
        mov     dr6, rax                ;
        mov     dr7, rdx                ;
        cmp     byte ptr gs:[PcCpuVendor], CPU_AMD ; check if AMD processor
        jne     short KiRC30            ; if ne, not authentic AMD processor

;
; The host processor is an authentic AMD processor.
;
; Check if branch tracing or last branch capture is enabled.
;

        test    dx, DR7_TRACE_BRANCH    ; test for trace branch enable
        jz      short KiRC10            ; if z, trace branch not enabled
        or      eax, MSR_DEBUG_CRL_BTF  ; set trace branch enable
KiRC10: test    dx, DR7_LAST_BRANCH     ; test for last branch enable
        jz      short KiRC20            ; if z, last branch not enabled
        or      eax, MSR_DEBUG_CTL_LBR  ; set last branch enable
KiRC20: test    eax, eax                ; test for extended debug enables
        jz      short KiRC30            ; if z, no extended debug enables
        mov     r8d, eax                ; save extended debug enables
        mov     ecx, MSR_DEGUG_CTL      ; set debug control MSR number
        rdmsr                           ; set extended debug control
        and     eax, not (MSR_DEBUG_CTL_LBR or MSR_DEBUG_CRL_BTF) ;
        or      eax, r8d                ;
        wrmsr                           ;
KiRC30: ret                             ; return

        LEAF_END KiRestoreProcessorControlState, _TEXT$00

        subttl  "Save Processor Control State"
;++
;
; KiSaveProcessorControlState (
;     PKPROCESSOR_STATE ProcessorState
;     );
;
; Routine Description:
;
;   This routine saves the control state of the current processor.
;
; Arguments:
;
;   ProcessorState (rcx) - Supplies a pointer to a processor state structure.
;
; Return Value:
;
;    None.
;
;--

        LEAF_ENTRY KiSaveProcessorControlState, _TEXT$00

        mov     rax, cr0                ; save processor control state
        mov     PsCr0[rcx], rax         ;
        mov     rax, cr2                ;
        mov     PsCr2[rcx], rax         ;
        mov     rax, cr3                ;
        mov     PsCr3[rcx], rax         ;
        mov     rax, cr4                ;
        mov     PsCr4[rcx], rax         ;
        mov     rax, cr8                ;
        mov     PsCr8[rcx], rax         ;

        sgdt    fword ptr PsGdtr[rcx]   ; save GDTR
        sidt    fword ptr PsIdtr[rcx]   ; save IDTR

        str     word ptr PsTr[rcx]      ; save TR
        sldt    word ptr PsLdtr[rcx]    ; save LDTR

        stmxcsr dword ptr PsMxCsr[rcx]  ; save XMM control/status

;
; Save debug control state.
;

        mov     rax, dr0                ; save debug registers
        mov     rdx, dr1                ;
        mov     PsKernelDr0[rcx], rax   ;
        mov     PsKernelDr1[rcx], rdx   ;
        mov     rax, dr2                ;
        mov     rdx, dr3                ;
        mov     PsKernelDr2[rcx], rax   ;
        mov     PsKernelDr3[rcx], rdx   ;
        mov     rax, dr6                ;
        mov     rdx, dr7                ;
        mov     PsKernelDr6[rcx], rax   ;
        mov     PsKernelDr7[rcx], rdx   ;
        xor     eax, eax                ;
        mov     dr7, rax                ;
        cmp     byte ptr gs:[PcCpuVendor], CPU_AMD ; check if AMD processor
        jne     short KiSC10            ; if ne, not authentic AMD processor

;
; The host processor is an authentic AMD processor.
;
; Check if branch tracing or last branch capture is enabled.
;

        test    dx, DR7_TRACE_BRANCH or DR7_LAST_BRANCH ; test for extended enables
        jz      short KiSC10            ; if z, extended debugging not enabled
        mov     r8, rcx                 ; save processor state address
        mov     ecx, MSR_LAST_BRANCH_FROM ; save last branch information
        rdmsr                           ;
        mov     PsLastBranchFromRip[r8], eax ;
        mov     PsLastBranchFromRip + 4[r8], edx ;
        mov     ecx, MSR_LAST_BRANCH_TO ;
        rdmsr                           ;
        mov     PsLastBranchToRip[r8], eax ;
        mov     PsLastBranchToRip + 4[r8], edx ;
        mov     ecx, MSR_LAST_EXCEPTION_FROM ;
        rdmsr                           ;
        mov     PsLastExceptionFromRip[r8], eax ;
        mov     PsLastExceptionFromRip + 4[r8], edx ;
        mov     ecx, MSR_LAST_EXCEPTION_TO ;
        rdmsr                           ;
        mov     PsLastExceptionToRip[r8], eax ;
        mov     PsLastExceptionToRip + 4[r8], edx ;
        mov     ecx, MSR_DEGUG_CTL      ; clear extended debug control
        rdmsr                           ;
        and     eax, not (MSR_DEBUG_CTL_LBR or MSR_DEBUG_CRL_BTF) ; 
        wrmsr                           ; 
KiSC10: ret                             ; return

        LEAF_END KiSaveProcessorControlState, _TEXT$00

        subttl  "Restore Debug Register State"
;++
;
; VOID
; KiRestoreDebugRegisterState (
;     VOID
;     );
;
; Routine Description:
;
;    This routine is executed on a transition from kernel mode to user mode
;    and restores the debug register state.
;
;    N.B. This routine is used for both trap/interrupt and system service
;         exit.
;
; Arguments:
;
;    None.
;
; Implicit Arguments:
;
;    rbp  - Supplies a pointer to a trap frame.
;
; Return Value:
;
;    None.
;
;--

        LEAF_ENTRY KiRestoreDebugRegisterState, _TEXT$00

        xor     edx, edx                ; clear register
        mov     dr7, rdx                ; clear control before loading
        mov     rax, TrDr0[rbp]         ; restore user debug registers
        mov     rdx, TrDr1[rbp]         ;
        mov     dr0, rax                ;
        mov     dr1, rdx                ;
        mov     rax, TrDr2[rbp]         ;
        mov     rdx, TrDr3[rbp]         ;
        mov     dr2, rax                ;
        mov     dr3, rdx                ;
        mov     rdx, TrDr7[rbp]         ;
        xor     eax, eax                ;
        mov     dr6, rax                ;
        mov     dr7, rdx                ;
        cmp     byte ptr gs:[PcCpuVendor], CPU_AMD ; check if AMD processor
        jne     short KiRD30            ; if ne, not authentic AMD processor

;
; The host processor is an authentic AMD processor.
;
; Check if branch tracing or last branch capture is enabled.
;

        test    dx, DR7_TRACE_BRANCH    ; test for trace branch enable
        jz      short KiRD10            ; if z, trace branch not enabled
        or      eax, MSR_DEBUG_CRL_BTF  ; set trace branch enable
KiRD10: test    dx, DR7_LAST_BRANCH     ; test for last branch enable
        jz      short KiRD20            ; if z, last branch not enabled
        or      eax, MSR_DEBUG_CTL_LBR  ; set last branch enable
KiRD20: test    eax, eax                ; test for extended debug enables
        jz      short KiRD30            ; if z, no extended debug enables
        mov     r8d, eax                ; save extended debug enables
        mov     ecx, MSR_DEGUG_CTL      ; set extended debug control
        rdmsr                           ;
        and     eax, not (MSR_DEBUG_CTL_LBR or MSR_DEBUG_CRL_BTF) ;
        or      eax, r8d                ;
        wrmsr                           ; 
KiRD30: ret                             ; return

        LEAF_END KiRestoreDebugRegisterState, _TEXT$00

        subttl  "Save Debug Register State"
;++
;
; VOID
; KiSaveDebugRegisterState (
;     VOID
;     );
;
; Routine Description:
;
;    This routine is called on a transition from user mode to kernel mode
;    when user debug registers are active. It saves the user debug registers
;    and loads the kernel debug register state.
;
; Arguments:
;
;    None.
;
; Implicit Arguments:
;
;    rbp - Supplies a pointer to a trap frame.
;   
; Return Value:
;
;    None.
;
;--

        LEAF_ENTRY KiSaveDebugRegisterState, _TEXT$00

        mov     r9, gs:[PcSelf]         ; get PCR address
        mov     rax, dr0                ; save user debug registers
        mov     rdx, dr1                ;
        mov     TrDr0[rbp], rax         ;
        mov     TrDr1[rbp], rdx         ;
        mov     rax, dr2                ;
        mov     rdx, dr3                ;
        mov     TrDr2[rbp], rax         ;
        mov     TrDr3[rbp], rdx         ;
        mov     rax, dr6                ;
        mov     rdx, dr7                ;
        mov     TrDr6[rbp], rax         ;
        mov     TrDr7[rbp], rdx         ;
        xor     eax, eax                ;
        mov     dr7, rax                ;
        cmp     byte ptr gs:[PcCpuVendor], CPU_AMD ; check if AMD processor
        jne     short KiSD10            ; if ne, not authentic AMD processor

;
; The host processor is an authentic AMD processor.
;
; Check if branch tracing or last branch capture is enabled.
;

        test    dx, DR7_TRACE_BRANCH or DR7_LAST_BRANCH ; test for extended enables
        jz      short KiSD10            ; if z, not extended debug enables
        mov     ecx, MSR_LAST_BRANCH_FROM ; save last branch information
        rdmsr                           ;
        mov     TrLastBranchFromRip[rbp], eax ;
        mov     TrLastBranchFromRip + 4[rbp], edx ;
        mov     ecx, MSR_LAST_BRANCH_TO ;
        rdmsr                           ;
        mov     TrLastBranchToRip[rbp], eax ;
        mov     TrLastBranchToRip + 4[rbp], edx ;
        mov     ecx, MSR_LAST_EXCEPTION_FROM ;
        rdmsr                           ;
        mov     TrLastExceptionFromRip[rbp], eax ;
        mov     TrLastExceptionFromRip + 4[rbp], edx ;
        mov     ecx, MSR_LAST_EXCEPTION_TO ;
        rdmsr                           ;
        mov     TrLastExceptionToRip[rbp], eax ;
        mov     TrLastExceptionToRip + 4[rbp], edx ;
        mov     ecx, MSR_DEGUG_CTL      ; Clear extended debug control
        rdmsr                           ;
        and     eax, not (MSR_DEBUG_CTL_LBR or MSR_DEBUG_CRL_BTF) ; 
        wrmsr                           ; 
KiSD10: test    word ptr PcKernelDr7[r9], DR7_ACTIVE ; test if debug enabled
        jz      short KiSD40            ; if z, debug not enabled
        mov     rax, PcKernelDr0[r9]    ; set debug registers
        mov     rdx, PcKernelDr1[r9]    ;
        mov     dr0, rax                ;
        mov     dr1, rdx                ;
        mov     rax, PcKernelDr2[r9]    ;
        mov     rdx, PcKernelDr3[r9]    ;
        mov     dr2, rax                ;
        mov     dr3, rdx                ;
        mov     rdx, PcKernelDr7[r9]    ;
        xor     eax, eax                ;
        mov     dr6, rax                ;
        mov     dr7, rdx                ;
        cmp     byte ptr gs:[PcCpuVendor], CPU_AMD ; check if AMD processor
        jne     short KiSD40            ; if ne, not authentic AMD processor

;
; The host processor is an authentic AMD processor.
;
; Check if branch tracing or last branch capture is enabled.
;

        test    dx, DR7_TRACE_BRANCH    ; test for trace branch enable
        jz      short KiSD20            ; if z, trace branch not enabled
        or      eax, MSR_DEBUG_CRL_BTF  ; set trace branch enable
KiSD20: test    dx, DR7_LAST_BRANCH     ; test for last branch enable
        jz      short KiSD30            ; if z, last branch not enabled
        or      eax, MSR_DEBUG_CTL_LBR  ; set last branch enable
KiSD30: test    eax, eax                ; test for extended debug enables
        jz      short KiSD40            ; if z, no extended debug enables
        mov     r8d, eax                ; save extended debug enables
        mov     ecx, MSR_DEGUG_CTL      ; set extended debug control
        rdmsr                           ;
        and     eax, not (MSR_DEBUG_CTL_LBR or MSR_DEBUG_CRL_BTF) ;
        or      eax, r8d                ; 
        wrmsr                           ; 
KiSD40: ret                             ; return

        LEAF_END KiSaveDebugRegisterState, _TEXT$00

        subttl  "Get Current Stack Pointer"
;++
;
; ULONG64
; KeGetCurrentStackPointer (
;     VOID
;     );
;
; Routine Description:
;
;   This function returns the caller's stack pointer.
;
; Arguments:
;
;   None.
;
; Return Value:
;
;   The callers stack pointer is returned as the function value.
;
;--

        LEAF_ENTRY KeGetCurrentStackPointer, _TEXT$00

        lea     rax, 8[rsp]             ; get callers stack pointer
        ret                             ;

        LEAF_END KeGetCurrentStackPointer, _TEXT$00
        
        subttl  "Save Legacy Floating Point State"
;++
;
; VOID
; KeSaveLegacyFloatingPointState (
;     PXMM_SAVE_AREA32 NpxFrame
;     );
;
; Routine Description:
;
;   This routine saves the legacy floating state for the current thread.
;
; Arguments:
;
;   NpxFrame (rcx) - Supplies the address of the legacy floating save area.
;
; Return Value:
;
;   None.
;
;--

        LEAF_ENTRY KeSaveLegacyFloatingPointState, _TEXT$00

        fxsave  [rcx]                   ; save legacy floating state
        ret                             ;

        LEAF_END KeSaveLegacyFloatingPointState, _TEXT$00
        
        end
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ke\amd64\pat.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    pat.c

Abstract:

    This module initializes the page attributes table.

--*/

#include "ki.h"

#pragma alloc_text(PAGELK, KiSetPageAttributesTable)

VOID
KiSetPageAttributesTable (
    VOID
    )

/*++

Routine Description:

    This function initializes the page attribute table for the current
    processor. The page attribute table is set up to provide write back,
    write combining, uncacheable/stronly order, and uncacheable/weakly
    ordered.

    PAT_Entry   PAT Index   PCD PWT     Memory Type

    0            0           0   0       WB
    1            0           0   1       WC *
    2            0           1   0       WEAK_UC
    3            0           1   1       STRONG_UC
    4            1           0   0       WB
    5            1           0   1       WC *
    6            1           1   0       WEAK_UC
    7            1           1   1       STRONG_UC

    N.B. The caller must have the PAGELK code locked before calling this
         function.

  Arguments:

    None.

Return Value:

    None.

--*/

{

    PAT_ATTRIBUTES Attributes;

    //
    // Initialize the page attribute table.
    //

    Attributes.hw.Pat[0] = PAT_TYPE_WB;
    Attributes.hw.Pat[1] = PAT_TYPE_USWC;
    Attributes.hw.Pat[2] = PAT_TYPE_WEAK_UC;
    Attributes.hw.Pat[3] = PAT_TYPE_STRONG_UC;
    Attributes.hw.Pat[4] = PAT_TYPE_WB;
    Attributes.hw.Pat[5] = PAT_TYPE_USWC;
    Attributes.hw.Pat[6] = PAT_TYPE_WEAK_UC;
    Attributes.hw.Pat[7] = PAT_TYPE_STRONG_UC;

    //
    // Invalidate the cache on the current processor, write the page attributes
    // table, and invalidate the cache a second time.
    //

    WritebackInvalidate();
    WriteMSR(MSR_PAT, Attributes.QuadPart);
    WritebackInvalidate();
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ke\amd64\spinlock.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    spinlock.c

Abstract:

    This module implements the platform specific functions for acquiring
    and releasing spin locks.

--*/

#include "ki.h"

VOID
KiAcquireSpinLockCheckForFreeze (
    IN PKSPIN_LOCK SpinLock,
    IN PKTRAP_FRAME TrapFrame,
    IN PKEXCEPTION_FRAME ExceptionFrame
    )

/*++

Routine Description:

    This function acquires a spin lock from while at high priority.
    While the lock is not available, a check is made to see if another
    processor has requested this processor to freeze execution.
    
    N.B. This function must be called with IRQL at or above DISPATCH
         level, or with interrupts disabled.

Arguments:

    SpinLock - Supplies a pointer to a spin lock.

    TrapFrame - Supplies a pointer to a trap frame.

    ExceptionFrame - Supplies a pointer to an exception frame.

Return Value:

    None.

--*/

{

#if !defined(NT_UP)

    //
    // Attempt to acquire the queued spin lock.
    //
    // If the previous value of the spinlock is NULL, then the lock has
    // been acquired. Otherwise wait for lock ownership to be granted
    // while checking for a freeze request.
    //

    do {
        if (KxTryToAcquireSpinLock(SpinLock) != FALSE) {
            break;
        }

        do {

            //
            // Check for freeze request while waiting for spin lock to
            // become free.
            //

            KiCheckForFreezeExecution(TrapFrame, ExceptionFrame);
        } while (*(volatile LONG64 *)SpinLock != 0);

    } while (TRUE);

#else

        UNREFERENCED_PARAMETER(SpinLock);
        UNREFERENCED_PARAMETER(TrapFrame);
        UNREFERENCED_PARAMETER(ExceptionFrame);

#endif

    return;
}

DECLSPEC_NOINLINE
ULONG64
KxWaitForSpinLockAndAcquire (
    __inout PKSPIN_LOCK SpinLock
    )

/*++

Routine Description:

    This function is called when the first attempt to acquire a spin lock
    fails. A spin loop is executed until the spin lock is free and another
    attempt to acquire is made. If the attempt fails, then another wait
    for the spin lock to become free is initiated.

Arguments:

    SpinLock - Supplies the address of a spin lock.

Return Value:

    The number of wait loops that were executed.

--*/

{

    ULONG64 SpinCount = 0;

#if DBG

    LONG64 Thread = (LONG64)KeGetCurrentThread() + 1;

#endif

    //
    // Wait for spin lock to become free.
    //

    do {
        do {
            KeYieldProcessor();
        } while (*(volatile LONG64 *)SpinLock != 0);

#if DBG

    } while (InterlockedCompareExchange64((LONG64 *)SpinLock, Thread, 0) != 0);

#else

    } while(InterlockedBitTestAndSet64((LONG64 *)SpinLock, 0));

#endif

    return SpinCount;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ke\amd64\start.asm ===
title  "System Startup"
;++
;
; Copyright (c) Microsoft Corporation. All rights reserved. 
;
; You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
; If you do not agree to the terms, do not use the code.
;
;
; Module Name:
;
;   start.asm
;
; Abstract:
;
;   This module implements the code necessary to initially startup the NT
;   system on an AMD64 system.
;
;--

include ksamd64.inc

        extern  KdInitSystem:proc
        extern  KeLoaderBlock:qword
        extern  KiBarrierWait:dword
        extern  KiIdleLoop:proc
        extern  KiInitializeBootStructures:proc
        extern  KiInitializeKernel:proc
        extern  KiInitialPCR:byte
        extern  __security_cookie:qword
        extern  __security_cookie_complement:qword

TotalFrameLength EQU (KERNEL_STACK_CONTROL_LENGTH + KEXCEPTION_FRAME_LENGTH + KSWITCH_FRAME_LENGTH)

        subttl  "System Startup"
;++
;
; Routine Description:
;
;   This routine is called at system startup to perform early initialization
;   and to initialize the kernel debugger. This allows breaking into the
;   kernel debugger very early during system startup. After kernel debugger
;   initialization, kernel initialization is performed. On return from kernel
;   initialization the idle loop is entered. The idle loop begins execution
;   and immediately finds the system startup (phase 1) thread ready to run.
;   Phase 1 initialization is performed and all other processors are started.
;   As each process starts it also passes through the system startup code, but
;   it does not initialization the kernel debugger.
;
; Arguments:
;
;   LoaderBlock (rcx) - Supplies a pointer to the loader block.
;
; Implicit Arguments:
;
;   When the system starts up the loader has done some initialization. In
;   particular all structures have at least been zeroed and the GDT and
;   TSS have been completely initialized.
;
;   The loader block has been reformatted by the loader into a 64-bit loader
;   block and all pertinent fields have been filled in.
;
;   The address of the PRCB is passed in the loader block (only for processors
;   other than zero).
;
;   The address of the idle thread and idle process are passed in the loader
;   block (only for processors other than zero).
;
;   The GDT and IDT address and limits are contained in the gdtr and idtr
;   registers.
;
;   The address of the TSS must be extraced from the appropriate GDT entry
;   and stored in the PCR.
;
;   The stack register (RSP) is loaded with the idle thread stack and the
;   kernel stack field of the loader block contains the address of the DPC
;   stack.
;
; Return Value:
;
;   None - function does not return.
;
;--

SsFrame struct
        P1Home  dq ?                    ;
        P2Home  dq ?                    ;
        P3Home  dq ?                    ;
        P4Home  dq ?                    ;
        P5      dq ?                    ; parameter 5
        P6      dq ?                    ; parameter 6
        SavedR15 dq ?                   ; saved nonvolatile register
SsFrame ends

        NESTED_ENTRY KiSystemStartup, INIT

        alloc_stack (sizeof SsFrame)    ; allocate stack frame
        mov     SsFrame.SavedR15[rsp], r15 ; save nonvolatile register
        set_frame r15, 0                ; set frame register

        END_PROLOGUE

;
; Save the address of the loader block.
;
; N.B. This is the same address for all processors.
;

        mov     KeLoaderBlock, rcx      ; save loader block address

;
; Initialize PCR self address and the current PRCB address.
;

        mov     rdx, LpbPrcb[rcx]       ; get specified PRCB address
        lea     rax, KiInitialPCR + PcPrcb ; get builtin PRCB address
        test    rdx, rdx                ; test if PRCB address specified
        cmovz   rdx, rax                ; if z, set builtin PRCB address
        mov     LpbPrcb[rcx], rdx       ; set loader block PRCB address
        mov     r8, rdx                 ; copy PRCB address
        sub     rdx, PcPrcb             ; compute PCR address
        mov     PcSelf[rdx], rdx        ; set PCR self address
        mov     PcCurrentPrcb[rdx], r8  ; set current PRCB address

;
; Initialize kernel special registers and the address of the GDT, TSS, and
; IDT in the PRCB and PCR.
;
; N.B. The debug registers are zeroed in the PRCB.
;

        mov     r8, cr0                 ; save CR0
        mov     PcCr0[rdx], r8          ;
        mov     r8, cr2                 ; save CR2
        mov     PcCr2[rdx], r8          ;
        mov     r8, cr3                 ; save CR3
        mov     PcCr3[rdx], r8          ;
        mov     r8, cr4                 ; save CR4
        mov     PcCr4[rdx], r8          ;

        sgdt    PcGdtrLimit[rdx]        ; save GDT limit and base
        mov     r8, PcGdtrBase[rdx]     ; set GDT base address
        mov     PcGdt[rdx], r8          ;
        sidt    PcIdtrLimit[rdx]        ; save IDT limit and base
        mov     r9, PcIdtrBase[rdx]     ; set IDT base address
        mov     PcIdt[rdx], r9          ;

        str     word ptr PcTr[rdx]      ; save TR selector
        sldt    word ptr PcLdtr[rdx]    ; save LDT selector

        mov     dword ptr PcMxCsr[rdx], INITIAL_MXCSR ; set initial MXCSR
        ldmxcsr PcMxCsr[rdx]            ;

;
; Set canonical selector values (note CS, GS, and SS are already set).
;

        mov     ax, KGDT64_R3_DATA or RPL_MASK ;
        mov     ds, ax                  ;
        mov     es, ax                  ;
        mov     ax, KGDT64_R3_CMTEB or RPL_MASK ;
        mov     fs, ax                  ;

;
; Load a NULL selector into the LDT.
;

        xor     eax, eax                ; set NULL selector for LDT
        lldt    ax                      ; 

;
; Extract TSS address from GDT entry and store in PCR.
;

        mov     ax, KGDT64_SYS_TSS + KgdtBaseLow[r8] ; set low 16-bits
        mov     PcTss[rdx], ax          ;
        mov     al, KGDT64_SYS_TSS + KgdtBaseMiddle[r8] ; set middle 8-bits
        mov     PcTss + 2[rdx], al      ;
        mov     al, KGDT64_SYS_TSS + KgdtBaseHigh[r8] ; set high 8-bits
        mov     PcTss + 3[rdx], al      ;
        mov     eax, KGDT64_SYS_TSS +KgdtBaseUpper[r8] ; set upper 32-bits
        mov     PcTss + 4[rdx], eax     ;

;
; Initialize the GS base and swap addresses.
;

        mov     eax, edx                ; set low 32-bits of address
        shr     rdx, 32                 ; set high 32-bits of address
        mov     ecx, MSR_GS_BASE        ; get GS base address MSR number
        wrmsr                           ; write GS base address
        mov     ecx, MSR_GS_SWAP        ; get GS swap base MSR number
        wrmsr                           ; write GS swap base address

;
; Initialize boot structures.
;

        mov     rcx, KeLoaderBlock      ; set loader block address
        call    KiInitializeBootStructures ; initialize boot structures

;
; Initialize the kernel debugger if this is processor zero.
;

        xor     ecx, ecx                ; set phase to 0
        mov     rdx, KeLoaderBlock      ; set loader block address
        call    KdInitSystem            ; initialize debugger

;
; Raise IRQL to high level and initialize the kernel.
;

        mov     ecx, HIGH_LEVEL         ; set high IRQL

        SetIrql                         ;

;
; Reserve space for idle thread stack initialization.
;
; N.B. This reservation ensures that the initialization of the thread stack
;      does not overwrite any information on the current stack which is the
;      same stack.
;

        sub     rsp, TotalFrameLength   ; allocate stack

;
; Initialize kernel.
;
; N.B. Kernel initialization is called with interupts disabled at IRQL
;      HIGH_LEVEL and returns with interrupt enabled at IRQL DISPATCH_LEVEL.
;

        mov     rax, KeLoaderBlock      ; set loader block address
        mov     rcx, LpbProcess[rax]    ; set idle process address
        mov     rdx, LpbThread[rax]     ; set idle thread address
        mov     r8, gs:[PcTss]          ; set idle stack address
        mov     r8, TssRsp0[r8]         ;
        mov     gs:[PcRspBase], r8      ; set initial stack address in PRCB
        mov     r9, LpbPrcb[rax]        ; set PRCB address
        mov     r10b, PbNumber[r9]      ; set processor number
        mov     SsFrame.P5[rsp], r10    ;
        mov     SsFrame.P6[rsp], rax    ; set loader block address
        call    KiInitializeKernel      ; Initialize kernel

;
; If processor zero is being initialized, then save the GS cookie value.
;

        cmp     byte ptr gs:[PcNumber], 0 ; check for processor zero
        jne     short @f                ; if ne, not processor zero
        rdtsc                           ; read time stamp counter
        shl     rdx, 32                 ; merge low and high part
        or      rax, rdx                ;
        mov     rdx, rax                ; copy result and rotate
        ror     rdx, 49                 ;
        xor     rax, rdx                ; randomize upper bits
        rol     rax, 16                 ; clear high work of result
        mov     ax, 0                   ;
        ror     rax, 16                 ;
        mov     __security_cookie, rax  ; save GS cookie value
        not     rax                     ; complement cookie value
        mov     __security_cookie_complement, rax ; save GS complement value

;
; Reset stack to include only the space for the legacy NPX state.
;

@@:     mov     rcx, gs:[PcRspBase]     ; get idle stack address
        lea     rsp, (-KERNEL_STACK_CONTROL_LENGTH)[rcx] ; deallocate stack space

;
; Set the wait IRQL for the idle thread.
;

        mov     rcx, gs:[PcCurrentThread] ; get current thread address
        mov     byte ptr ThWaitIrql[rcx], DISPATCH_LEVEL ; set wait IRQL

;
; In a multiprocessor system the boot processor proceeds directly into the
; idle loop. As other processors start executing, however, they do not enter
; the idle loop directly - they spin until all processors have been started
; and the boot master allows them to proceed.
;

ifndef NT_UP

KiSS20: cmp     KiBarrierWait, 0        ; check if barrier set

        Yield                           ; yield processor execution

        jnz     short KiSS20            ; if nz, barrier set

endif

        call    KiIdleLoop              ; enter idle loop - no return

        NESTED_END KisystemStartup, INIT

        end
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ke\amd64\sysstubs.asm ===
;++
;
; Copyright (c) Microsoft Corporation. All rights reserved. 
;
; You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
; If you do not agree to the terms, do not use the code.
;
; Module Name:
;
;   sysstubs.asm
;
; Abstract:
;
;   This module implements the system service dispatch stub procedures.
;
;--

include ksamd64.inc

STUBS_BEGIN1 macro t
        title   t
        endm

STUBS_BEGIN2 macro t
        endm

STUBS_BEGIN3 macro t
        endm

STUBS_BEGIN4 macro t
        endm

STUBS_BEGIN5 macro t
        endm

STUBS_BEGIN6 macro t
        endm

STUBS_BEGIN7 macro t
        endm

STUBS_BEGIN8 macro t
        endm

STUBS_END macro t
        end
        endm

SYSSTUBS_ENTRY1 macro ServiceNumber, Name, NumArgs
        extern  KiServiceInternal:proc
        extern  KiServiceLinkage:proc
        NESTED_ENTRY Zw&Name, _TEXT$00,, NoPad

if DBG

        mov     8[rsp], rcx             ; save argument register
        mov     16[rsp], rdx            ;
        mov     24[rsp], r8             ;
        mov     32[rsp], r9             ;

endif

        mov	rax, rsp		; save stack address
        cli                             ; disable interrupts
        sub     rsp, 16                 ; alignment and dummy SS selector
        push    rax                     ; save previous stack pointer
        pushfq                          ; push EFLAGS on stack
        push    KGDT64_R0_CODE          ; push CS selector
        lea     rax, KiServiceLinkage   ; push service linkage RIP
        push    rax                     ; push return address
        mov     eax, ServiceNumber      ; set service number
        jmp     KiServiceInternal       ; finish in service dispatcher
        push_frame                      ; mark machine frame push
        END_PROLOGUE
        NESTED_END Zw&Name, _TEXT$00
        endm

SYSSTUBS_ENTRY2 macro ServiceNumber, Name, NumArgs
        endm

SYSSTUBS_ENTRY3 macro ServiceNumber, Name, NumArgs
        endm

SYSSTUBS_ENTRY4 macro ServiceNumber, Name, NumArgs
        endm

SYSSTUBS_ENTRY5 macro ServiceNumber, Name, NumArgs
        endm

SYSSTUBS_ENTRY6 macro ServiceNumber, Name, NumArgs
        endm

SYSSTUBS_ENTRY7 macro ServiceNumber, Name, NumArgs
        endm

SYSSTUBS_ENTRY8 macro ServiceNumber, Name, NumArgs
        endm


USRSTUBS_ENTRY1 macro ServiceNumber, Name, NumArgs
        altentry Nt&Name
        endm

USRSTUBS_ENTRY2 macro ServiceNumber, Name, NumArgs

ifidn <Name>, <QuerySystemTime>

        extern RtlQuerySystemTime:proc

endif

        LEAF_ENTRY Zw&Name, _TEXT$00, NoPad
        ALTERNATE_ENTRY Nt&Name

if DBG

        mov     8[rsp], rcx
        mov     16[rsp], rdx
        mov     24[rsp], r8
        mov     32[rsp], r9

endif

ifidn <Name>, <QuerySystemTime>

        jmp     RtlQuerySystemTime

else

        mov     r10, rcx
        mov     eax, ServiceNumber
        syscall
        ret

endif

        LEAF_END Zw&Name, _TEXT$00
        endm

USRSTUBS_ENTRY3 macro ServiceNumber, Name, NumArgs
        endm

USRSTUBS_ENTRY4 macro ServiceNumber, Name, NumArgs
        endm

USRSTUBS_ENTRY5 macro ServiceNumber, Name, NumArgs
        endm

USRSTUBS_ENTRY6 macro ServiceNumber, Name, NumArgs
        endm

USRSTUBS_ENTRY7 macro ServiceNumber, Name, NumArgs
        endm

USRSTUBS_ENTRY8 macro ServiceNumber, Name, NumArgs
        endm

        STUBS_BEGIN1 <"System Service Stub Procedures">
        STUBS_BEGIN2 <"System Service Stub Procedures">
        STUBS_BEGIN3 <"System Service Stub Procedures">
        STUBS_BEGIN4 <"System Service Stub Procedures">
        STUBS_BEGIN5 <"System Service Stub Procedures">
        STUBS_BEGIN6 <"System Service Stub Procedures">
        STUBS_BEGIN7 <"System Service Stub Procedures">
        STUBS_BEGIN8 <"System Service Stub Procedures">
SYSSTUBS_ENTRY1  0, MapUserPhysicalPagesScatter, 0 
SYSSTUBS_ENTRY2  0, MapUserPhysicalPagesScatter, 0 
SYSSTUBS_ENTRY3  0, MapUserPhysicalPagesScatter, 0 
SYSSTUBS_ENTRY4  0, MapUserPhysicalPagesScatter, 0 
SYSSTUBS_ENTRY5  0, MapUserPhysicalPagesScatter, 0 
SYSSTUBS_ENTRY6  0, MapUserPhysicalPagesScatter, 0 
SYSSTUBS_ENTRY7  0, MapUserPhysicalPagesScatter, 0 
SYSSTUBS_ENTRY8  0, MapUserPhysicalPagesScatter, 0 
SYSSTUBS_ENTRY1  1, WaitForSingleObject, 0 
SYSSTUBS_ENTRY2  1, WaitForSingleObject, 0 
SYSSTUBS_ENTRY3  1, WaitForSingleObject, 0 
SYSSTUBS_ENTRY4  1, WaitForSingleObject, 0 
SYSSTUBS_ENTRY5  1, WaitForSingleObject, 0 
SYSSTUBS_ENTRY6  1, WaitForSingleObject, 0 
SYSSTUBS_ENTRY7  1, WaitForSingleObject, 0 
SYSSTUBS_ENTRY8  1, WaitForSingleObject, 0 
SYSSTUBS_ENTRY1  2, CallbackReturn, 0 
SYSSTUBS_ENTRY2  2, CallbackReturn, 0 
SYSSTUBS_ENTRY3  2, CallbackReturn, 0 
SYSSTUBS_ENTRY4  2, CallbackReturn, 0 
SYSSTUBS_ENTRY5  2, CallbackReturn, 0 
SYSSTUBS_ENTRY6  2, CallbackReturn, 0 
SYSSTUBS_ENTRY7  2, CallbackReturn, 0 
SYSSTUBS_ENTRY8  2, CallbackReturn, 0 
SYSSTUBS_ENTRY1  3, ReadFile, 5 
SYSSTUBS_ENTRY2  3, ReadFile, 5 
SYSSTUBS_ENTRY3  3, ReadFile, 5 
SYSSTUBS_ENTRY4  3, ReadFile, 5 
SYSSTUBS_ENTRY5  3, ReadFile, 5 
SYSSTUBS_ENTRY6  3, ReadFile, 5 
SYSSTUBS_ENTRY7  3, ReadFile, 5 
SYSSTUBS_ENTRY8  3, ReadFile, 5 
SYSSTUBS_ENTRY1  4, DeviceIoControlFile, 6 
SYSSTUBS_ENTRY2  4, DeviceIoControlFile, 6 
SYSSTUBS_ENTRY3  4, DeviceIoControlFile, 6 
SYSSTUBS_ENTRY4  4, DeviceIoControlFile, 6 
SYSSTUBS_ENTRY5  4, DeviceIoControlFile, 6 
SYSSTUBS_ENTRY6  4, DeviceIoControlFile, 6 
SYSSTUBS_ENTRY7  4, DeviceIoControlFile, 6 
SYSSTUBS_ENTRY8  4, DeviceIoControlFile, 6 
SYSSTUBS_ENTRY1  5, WriteFile, 5 
SYSSTUBS_ENTRY2  5, WriteFile, 5 
SYSSTUBS_ENTRY3  5, WriteFile, 5 
SYSSTUBS_ENTRY4  5, WriteFile, 5 
SYSSTUBS_ENTRY5  5, WriteFile, 5 
SYSSTUBS_ENTRY6  5, WriteFile, 5 
SYSSTUBS_ENTRY7  5, WriteFile, 5 
SYSSTUBS_ENTRY8  5, WriteFile, 5 
SYSSTUBS_ENTRY1  6, RemoveIoCompletion, 1 
SYSSTUBS_ENTRY2  6, RemoveIoCompletion, 1 
SYSSTUBS_ENTRY3  6, RemoveIoCompletion, 1 
SYSSTUBS_ENTRY4  6, RemoveIoCompletion, 1 
SYSSTUBS_ENTRY5  6, RemoveIoCompletion, 1 
SYSSTUBS_ENTRY6  6, RemoveIoCompletion, 1 
SYSSTUBS_ENTRY7  6, RemoveIoCompletion, 1 
SYSSTUBS_ENTRY8  6, RemoveIoCompletion, 1 
SYSSTUBS_ENTRY1  7, ReleaseSemaphore, 0 
SYSSTUBS_ENTRY2  7, ReleaseSemaphore, 0 
SYSSTUBS_ENTRY3  7, ReleaseSemaphore, 0 
SYSSTUBS_ENTRY4  7, ReleaseSemaphore, 0 
SYSSTUBS_ENTRY5  7, ReleaseSemaphore, 0 
SYSSTUBS_ENTRY6  7, ReleaseSemaphore, 0 
SYSSTUBS_ENTRY7  7, ReleaseSemaphore, 0 
SYSSTUBS_ENTRY8  7, ReleaseSemaphore, 0 
SYSSTUBS_ENTRY1  8, ReplyWaitReceivePort, 0 
SYSSTUBS_ENTRY2  8, ReplyWaitReceivePort, 0 
SYSSTUBS_ENTRY3  8, ReplyWaitReceivePort, 0 
SYSSTUBS_ENTRY4  8, ReplyWaitReceivePort, 0 
SYSSTUBS_ENTRY5  8, ReplyWaitReceivePort, 0 
SYSSTUBS_ENTRY6  8, ReplyWaitReceivePort, 0 
SYSSTUBS_ENTRY7  8, ReplyWaitReceivePort, 0 
SYSSTUBS_ENTRY8  8, ReplyWaitReceivePort, 0 
SYSSTUBS_ENTRY1  9, ReplyPort, 0 
SYSSTUBS_ENTRY2  9, ReplyPort, 0 
SYSSTUBS_ENTRY3  9, ReplyPort, 0 
SYSSTUBS_ENTRY4  9, ReplyPort, 0 
SYSSTUBS_ENTRY5  9, ReplyPort, 0 
SYSSTUBS_ENTRY6  9, ReplyPort, 0 
SYSSTUBS_ENTRY7  9, ReplyPort, 0 
SYSSTUBS_ENTRY8  9, ReplyPort, 0 
SYSSTUBS_ENTRY1  10, SetInformationThread, 0 
SYSSTUBS_ENTRY2  10, SetInformationThread, 0 
SYSSTUBS_ENTRY3  10, SetInformationThread, 0 
SYSSTUBS_ENTRY4  10, SetInformationThread, 0 
SYSSTUBS_ENTRY5  10, SetInformationThread, 0 
SYSSTUBS_ENTRY6  10, SetInformationThread, 0 
SYSSTUBS_ENTRY7  10, SetInformationThread, 0 
SYSSTUBS_ENTRY8  10, SetInformationThread, 0 
SYSSTUBS_ENTRY1  11, SetEvent, 0 
SYSSTUBS_ENTRY2  11, SetEvent, 0 
SYSSTUBS_ENTRY3  11, SetEvent, 0 
SYSSTUBS_ENTRY4  11, SetEvent, 0 
SYSSTUBS_ENTRY5  11, SetEvent, 0 
SYSSTUBS_ENTRY6  11, SetEvent, 0 
SYSSTUBS_ENTRY7  11, SetEvent, 0 
SYSSTUBS_ENTRY8  11, SetEvent, 0 
SYSSTUBS_ENTRY1  12, Close, 0 
SYSSTUBS_ENTRY2  12, Close, 0 
SYSSTUBS_ENTRY3  12, Close, 0 
SYSSTUBS_ENTRY4  12, Close, 0 
SYSSTUBS_ENTRY5  12, Close, 0 
SYSSTUBS_ENTRY6  12, Close, 0 
SYSSTUBS_ENTRY7  12, Close, 0 
SYSSTUBS_ENTRY8  12, Close, 0 
SYSSTUBS_ENTRY1  13, QueryObject, 1 
SYSSTUBS_ENTRY2  13, QueryObject, 1 
SYSSTUBS_ENTRY3  13, QueryObject, 1 
SYSSTUBS_ENTRY4  13, QueryObject, 1 
SYSSTUBS_ENTRY5  13, QueryObject, 1 
SYSSTUBS_ENTRY6  13, QueryObject, 1 
SYSSTUBS_ENTRY7  13, QueryObject, 1 
SYSSTUBS_ENTRY8  13, QueryObject, 1 
SYSSTUBS_ENTRY1  14, QueryInformationFile, 1 
SYSSTUBS_ENTRY2  14, QueryInformationFile, 1 
SYSSTUBS_ENTRY3  14, QueryInformationFile, 1 
SYSSTUBS_ENTRY4  14, QueryInformationFile, 1 
SYSSTUBS_ENTRY5  14, QueryInformationFile, 1 
SYSSTUBS_ENTRY6  14, QueryInformationFile, 1 
SYSSTUBS_ENTRY7  14, QueryInformationFile, 1 
SYSSTUBS_ENTRY8  14, QueryInformationFile, 1 
SYSSTUBS_ENTRY1  15, OpenKey, 0 
SYSSTUBS_ENTRY2  15, OpenKey, 0 
SYSSTUBS_ENTRY3  15, OpenKey, 0 
SYSSTUBS_ENTRY4  15, OpenKey, 0 
SYSSTUBS_ENTRY5  15, OpenKey, 0 
SYSSTUBS_ENTRY6  15, OpenKey, 0 
SYSSTUBS_ENTRY7  15, OpenKey, 0 
SYSSTUBS_ENTRY8  15, OpenKey, 0 
SYSSTUBS_ENTRY1  16, EnumerateValueKey, 2 
SYSSTUBS_ENTRY2  16, EnumerateValueKey, 2 
SYSSTUBS_ENTRY3  16, EnumerateValueKey, 2 
SYSSTUBS_ENTRY4  16, EnumerateValueKey, 2 
SYSSTUBS_ENTRY5  16, EnumerateValueKey, 2 
SYSSTUBS_ENTRY6  16, EnumerateValueKey, 2 
SYSSTUBS_ENTRY7  16, EnumerateValueKey, 2 
SYSSTUBS_ENTRY8  16, EnumerateValueKey, 2 
SYSSTUBS_ENTRY1  17, FindAtom, 0 
SYSSTUBS_ENTRY2  17, FindAtom, 0 
SYSSTUBS_ENTRY3  17, FindAtom, 0 
SYSSTUBS_ENTRY4  17, FindAtom, 0 
SYSSTUBS_ENTRY5  17, FindAtom, 0 
SYSSTUBS_ENTRY6  17, FindAtom, 0 
SYSSTUBS_ENTRY7  17, FindAtom, 0 
SYSSTUBS_ENTRY8  17, FindAtom, 0 
SYSSTUBS_ENTRY1  18, QueryDefaultLocale, 0 
SYSSTUBS_ENTRY2  18, QueryDefaultLocale, 0 
SYSSTUBS_ENTRY3  18, QueryDefaultLocale, 0 
SYSSTUBS_ENTRY4  18, QueryDefaultLocale, 0 
SYSSTUBS_ENTRY5  18, QueryDefaultLocale, 0 
SYSSTUBS_ENTRY6  18, QueryDefaultLocale, 0 
SYSSTUBS_ENTRY7  18, QueryDefaultLocale, 0 
SYSSTUBS_ENTRY8  18, QueryDefaultLocale, 0 
SYSSTUBS_ENTRY1  19, QueryKey, 1 
SYSSTUBS_ENTRY2  19, QueryKey, 1 
SYSSTUBS_ENTRY3  19, QueryKey, 1 
SYSSTUBS_ENTRY4  19, QueryKey, 1 
SYSSTUBS_ENTRY5  19, QueryKey, 1 
SYSSTUBS_ENTRY6  19, QueryKey, 1 
SYSSTUBS_ENTRY7  19, QueryKey, 1 
SYSSTUBS_ENTRY8  19, QueryKey, 1 
SYSSTUBS_ENTRY1  20, QueryValueKey, 2 
SYSSTUBS_ENTRY2  20, QueryValueKey, 2 
SYSSTUBS_ENTRY3  20, QueryValueKey, 2 
SYSSTUBS_ENTRY4  20, QueryValueKey, 2 
SYSSTUBS_ENTRY5  20, QueryValueKey, 2 
SYSSTUBS_ENTRY6  20, QueryValueKey, 2 
SYSSTUBS_ENTRY7  20, QueryValueKey, 2 
SYSSTUBS_ENTRY8  20, QueryValueKey, 2 
SYSSTUBS_ENTRY1  21, AllocateVirtualMemory, 2 
SYSSTUBS_ENTRY2  21, AllocateVirtualMemory, 2 
SYSSTUBS_ENTRY3  21, AllocateVirtualMemory, 2 
SYSSTUBS_ENTRY4  21, AllocateVirtualMemory, 2 
SYSSTUBS_ENTRY5  21, AllocateVirtualMemory, 2 
SYSSTUBS_ENTRY6  21, AllocateVirtualMemory, 2 
SYSSTUBS_ENTRY7  21, AllocateVirtualMemory, 2 
SYSSTUBS_ENTRY8  21, AllocateVirtualMemory, 2 
SYSSTUBS_ENTRY1  22, QueryInformationProcess, 1 
SYSSTUBS_ENTRY2  22, QueryInformationProcess, 1 
SYSSTUBS_ENTRY3  22, QueryInformationProcess, 1 
SYSSTUBS_ENTRY4  22, QueryInformationProcess, 1 
SYSSTUBS_ENTRY5  22, QueryInformationProcess, 1 
SYSSTUBS_ENTRY6  22, QueryInformationProcess, 1 
SYSSTUBS_ENTRY7  22, QueryInformationProcess, 1 
SYSSTUBS_ENTRY8  22, QueryInformationProcess, 1 
SYSSTUBS_ENTRY1  23, WaitForMultipleObjects32, 1 
SYSSTUBS_ENTRY2  23, WaitForMultipleObjects32, 1 
SYSSTUBS_ENTRY3  23, WaitForMultipleObjects32, 1 
SYSSTUBS_ENTRY4  23, WaitForMultipleObjects32, 1 
SYSSTUBS_ENTRY5  23, WaitForMultipleObjects32, 1 
SYSSTUBS_ENTRY6  23, WaitForMultipleObjects32, 1 
SYSSTUBS_ENTRY7  23, WaitForMultipleObjects32, 1 
SYSSTUBS_ENTRY8  23, WaitForMultipleObjects32, 1 
SYSSTUBS_ENTRY1  24, WriteFileGather, 5 
SYSSTUBS_ENTRY2  24, WriteFileGather, 5 
SYSSTUBS_ENTRY3  24, WriteFileGather, 5 
SYSSTUBS_ENTRY4  24, WriteFileGather, 5 
SYSSTUBS_ENTRY5  24, WriteFileGather, 5 
SYSSTUBS_ENTRY6  24, WriteFileGather, 5 
SYSSTUBS_ENTRY7  24, WriteFileGather, 5 
SYSSTUBS_ENTRY8  24, WriteFileGather, 5 
SYSSTUBS_ENTRY1  25, SetInformationProcess, 0 
SYSSTUBS_ENTRY2  25, SetInformationProcess, 0 
SYSSTUBS_ENTRY3  25, SetInformationProcess, 0 
SYSSTUBS_ENTRY4  25, SetInformationProcess, 0 
SYSSTUBS_ENTRY5  25, SetInformationProcess, 0 
SYSSTUBS_ENTRY6  25, SetInformationProcess, 0 
SYSSTUBS_ENTRY7  25, SetInformationProcess, 0 
SYSSTUBS_ENTRY8  25, SetInformationProcess, 0 
SYSSTUBS_ENTRY1  26, CreateKey, 3 
SYSSTUBS_ENTRY2  26, CreateKey, 3 
SYSSTUBS_ENTRY3  26, CreateKey, 3 
SYSSTUBS_ENTRY4  26, CreateKey, 3 
SYSSTUBS_ENTRY5  26, CreateKey, 3 
SYSSTUBS_ENTRY6  26, CreateKey, 3 
SYSSTUBS_ENTRY7  26, CreateKey, 3 
SYSSTUBS_ENTRY8  26, CreateKey, 3 
SYSSTUBS_ENTRY1  27, FreeVirtualMemory, 0 
SYSSTUBS_ENTRY2  27, FreeVirtualMemory, 0 
SYSSTUBS_ENTRY3  27, FreeVirtualMemory, 0 
SYSSTUBS_ENTRY4  27, FreeVirtualMemory, 0 
SYSSTUBS_ENTRY5  27, FreeVirtualMemory, 0 
SYSSTUBS_ENTRY6  27, FreeVirtualMemory, 0 
SYSSTUBS_ENTRY7  27, FreeVirtualMemory, 0 
SYSSTUBS_ENTRY8  27, FreeVirtualMemory, 0 
SYSSTUBS_ENTRY1  28, ImpersonateClientOfPort, 0 
SYSSTUBS_ENTRY2  28, ImpersonateClientOfPort, 0 
SYSSTUBS_ENTRY3  28, ImpersonateClientOfPort, 0 
SYSSTUBS_ENTRY4  28, ImpersonateClientOfPort, 0 
SYSSTUBS_ENTRY5  28, ImpersonateClientOfPort, 0 
SYSSTUBS_ENTRY6  28, ImpersonateClientOfPort, 0 
SYSSTUBS_ENTRY7  28, ImpersonateClientOfPort, 0 
SYSSTUBS_ENTRY8  28, ImpersonateClientOfPort, 0 
SYSSTUBS_ENTRY1  29, ReleaseMutant, 0 
SYSSTUBS_ENTRY2  29, ReleaseMutant, 0 
SYSSTUBS_ENTRY3  29, ReleaseMutant, 0 
SYSSTUBS_ENTRY4  29, ReleaseMutant, 0 
SYSSTUBS_ENTRY5  29, ReleaseMutant, 0 
SYSSTUBS_ENTRY6  29, ReleaseMutant, 0 
SYSSTUBS_ENTRY7  29, ReleaseMutant, 0 
SYSSTUBS_ENTRY8  29, ReleaseMutant, 0 
SYSSTUBS_ENTRY1  30, QueryInformationToken, 1 
SYSSTUBS_ENTRY2  30, QueryInformationToken, 1 
SYSSTUBS_ENTRY3  30, QueryInformationToken, 1 
SYSSTUBS_ENTRY4  30, QueryInformationToken, 1 
SYSSTUBS_ENTRY5  30, QueryInformationToken, 1 
SYSSTUBS_ENTRY6  30, QueryInformationToken, 1 
SYSSTUBS_ENTRY7  30, QueryInformationToken, 1 
SYSSTUBS_ENTRY8  30, QueryInformationToken, 1 
SYSSTUBS_ENTRY1  31, RequestWaitReplyPort, 0 
SYSSTUBS_ENTRY2  31, RequestWaitReplyPort, 0 
SYSSTUBS_ENTRY3  31, RequestWaitReplyPort, 0 
SYSSTUBS_ENTRY4  31, RequestWaitReplyPort, 0 
SYSSTUBS_ENTRY5  31, RequestWaitReplyPort, 0 
SYSSTUBS_ENTRY6  31, RequestWaitReplyPort, 0 
SYSSTUBS_ENTRY7  31, RequestWaitReplyPort, 0 
SYSSTUBS_ENTRY8  31, RequestWaitReplyPort, 0 
SYSSTUBS_ENTRY1  32, QueryVirtualMemory, 2 
SYSSTUBS_ENTRY2  32, QueryVirtualMemory, 2 
SYSSTUBS_ENTRY3  32, QueryVirtualMemory, 2 
SYSSTUBS_ENTRY4  32, QueryVirtualMemory, 2 
SYSSTUBS_ENTRY5  32, QueryVirtualMemory, 2 
SYSSTUBS_ENTRY6  32, QueryVirtualMemory, 2 
SYSSTUBS_ENTRY7  32, QueryVirtualMemory, 2 
SYSSTUBS_ENTRY8  32, QueryVirtualMemory, 2 
SYSSTUBS_ENTRY1  33, OpenThreadToken, 0 
SYSSTUBS_ENTRY2  33, OpenThreadToken, 0 
SYSSTUBS_ENTRY3  33, OpenThreadToken, 0 
SYSSTUBS_ENTRY4  33, OpenThreadToken, 0 
SYSSTUBS_ENTRY5  33, OpenThreadToken, 0 
SYSSTUBS_ENTRY6  33, OpenThreadToken, 0 
SYSSTUBS_ENTRY7  33, OpenThreadToken, 0 
SYSSTUBS_ENTRY8  33, OpenThreadToken, 0 
SYSSTUBS_ENTRY1  34, QueryInformationThread, 1 
SYSSTUBS_ENTRY2  34, QueryInformationThread, 1 
SYSSTUBS_ENTRY3  34, QueryInformationThread, 1 
SYSSTUBS_ENTRY4  34, QueryInformationThread, 1 
SYSSTUBS_ENTRY5  34, QueryInformationThread, 1 
SYSSTUBS_ENTRY6  34, QueryInformationThread, 1 
SYSSTUBS_ENTRY7  34, QueryInformationThread, 1 
SYSSTUBS_ENTRY8  34, QueryInformationThread, 1 
SYSSTUBS_ENTRY1  35, OpenProcess, 0 
SYSSTUBS_ENTRY2  35, OpenProcess, 0 
SYSSTUBS_ENTRY3  35, OpenProcess, 0 
SYSSTUBS_ENTRY4  35, OpenProcess, 0 
SYSSTUBS_ENTRY5  35, OpenProcess, 0 
SYSSTUBS_ENTRY6  35, OpenProcess, 0 
SYSSTUBS_ENTRY7  35, OpenProcess, 0 
SYSSTUBS_ENTRY8  35, OpenProcess, 0 
SYSSTUBS_ENTRY1  36, SetInformationFile, 1 
SYSSTUBS_ENTRY2  36, SetInformationFile, 1 
SYSSTUBS_ENTRY3  36, SetInformationFile, 1 
SYSSTUBS_ENTRY4  36, SetInformationFile, 1 
SYSSTUBS_ENTRY5  36, SetInformationFile, 1 
SYSSTUBS_ENTRY6  36, SetInformationFile, 1 
SYSSTUBS_ENTRY7  36, SetInformationFile, 1 
SYSSTUBS_ENTRY8  36, SetInformationFile, 1 
SYSSTUBS_ENTRY1  37, MapViewOfSection, 6 
SYSSTUBS_ENTRY2  37, MapViewOfSection, 6 
SYSSTUBS_ENTRY3  37, MapViewOfSection, 6 
SYSSTUBS_ENTRY4  37, MapViewOfSection, 6 
SYSSTUBS_ENTRY5  37, MapViewOfSection, 6 
SYSSTUBS_ENTRY6  37, MapViewOfSection, 6 
SYSSTUBS_ENTRY7  37, MapViewOfSection, 6 
SYSSTUBS_ENTRY8  37, MapViewOfSection, 6 
SYSSTUBS_ENTRY1  38, AccessCheckAndAuditAlarm, 7 
SYSSTUBS_ENTRY2  38, AccessCheckAndAuditAlarm, 7 
SYSSTUBS_ENTRY3  38, AccessCheckAndAuditAlarm, 7 
SYSSTUBS_ENTRY4  38, AccessCheckAndAuditAlarm, 7 
SYSSTUBS_ENTRY5  38, AccessCheckAndAuditAlarm, 7 
SYSSTUBS_ENTRY6  38, AccessCheckAndAuditAlarm, 7 
SYSSTUBS_ENTRY7  38, AccessCheckAndAuditAlarm, 7 
SYSSTUBS_ENTRY8  38, AccessCheckAndAuditAlarm, 7 
SYSSTUBS_ENTRY1  39, UnmapViewOfSection, 0 
SYSSTUBS_ENTRY2  39, UnmapViewOfSection, 0 
SYSSTUBS_ENTRY3  39, UnmapViewOfSection, 0 
SYSSTUBS_ENTRY4  39, UnmapViewOfSection, 0 
SYSSTUBS_ENTRY5  39, UnmapViewOfSection, 0 
SYSSTUBS_ENTRY6  39, UnmapViewOfSection, 0 
SYSSTUBS_ENTRY7  39, UnmapViewOfSection, 0 
SYSSTUBS_ENTRY8  39, UnmapViewOfSection, 0 
SYSSTUBS_ENTRY1  40, ReplyWaitReceivePortEx, 1 
SYSSTUBS_ENTRY2  40, ReplyWaitReceivePortEx, 1 
SYSSTUBS_ENTRY3  40, ReplyWaitReceivePortEx, 1 
SYSSTUBS_ENTRY4  40, ReplyWaitReceivePortEx, 1 
SYSSTUBS_ENTRY5  40, ReplyWaitReceivePortEx, 1 
SYSSTUBS_ENTRY6  40, ReplyWaitReceivePortEx, 1 
SYSSTUBS_ENTRY7  40, ReplyWaitReceivePortEx, 1 
SYSSTUBS_ENTRY8  40, ReplyWaitReceivePortEx, 1 
SYSSTUBS_ENTRY1  41, TerminateProcess, 0 
SYSSTUBS_ENTRY2  41, TerminateProcess, 0 
SYSSTUBS_ENTRY3  41, TerminateProcess, 0 
SYSSTUBS_ENTRY4  41, TerminateProcess, 0 
SYSSTUBS_ENTRY5  41, TerminateProcess, 0 
SYSSTUBS_ENTRY6  41, TerminateProcess, 0 
SYSSTUBS_ENTRY7  41, TerminateProcess, 0 
SYSSTUBS_ENTRY8  41, TerminateProcess, 0 
SYSSTUBS_ENTRY1  42, SetEventBoostPriority, 0 
SYSSTUBS_ENTRY2  42, SetEventBoostPriority, 0 
SYSSTUBS_ENTRY3  42, SetEventBoostPriority, 0 
SYSSTUBS_ENTRY4  42, SetEventBoostPriority, 0 
SYSSTUBS_ENTRY5  42, SetEventBoostPriority, 0 
SYSSTUBS_ENTRY6  42, SetEventBoostPriority, 0 
SYSSTUBS_ENTRY7  42, SetEventBoostPriority, 0 
SYSSTUBS_ENTRY8  42, SetEventBoostPriority, 0 
SYSSTUBS_ENTRY1  43, ReadFileScatter, 5 
SYSSTUBS_ENTRY2  43, ReadFileScatter, 5 
SYSSTUBS_ENTRY3  43, ReadFileScatter, 5 
SYSSTUBS_ENTRY4  43, ReadFileScatter, 5 
SYSSTUBS_ENTRY5  43, ReadFileScatter, 5 
SYSSTUBS_ENTRY6  43, ReadFileScatter, 5 
SYSSTUBS_ENTRY7  43, ReadFileScatter, 5 
SYSSTUBS_ENTRY8  43, ReadFileScatter, 5 
SYSSTUBS_ENTRY1  44, OpenThreadTokenEx, 1 
SYSSTUBS_ENTRY2  44, OpenThreadTokenEx, 1 
SYSSTUBS_ENTRY3  44, OpenThreadTokenEx, 1 
SYSSTUBS_ENTRY4  44, OpenThreadTokenEx, 1 
SYSSTUBS_ENTRY5  44, OpenThreadTokenEx, 1 
SYSSTUBS_ENTRY6  44, OpenThreadTokenEx, 1 
SYSSTUBS_ENTRY7  44, OpenThreadTokenEx, 1 
SYSSTUBS_ENTRY8  44, OpenThreadTokenEx, 1 
SYSSTUBS_ENTRY1  45, OpenProcessTokenEx, 0 
SYSSTUBS_ENTRY2  45, OpenProcessTokenEx, 0 
SYSSTUBS_ENTRY3  45, OpenProcessTokenEx, 0 
SYSSTUBS_ENTRY4  45, OpenProcessTokenEx, 0 
SYSSTUBS_ENTRY5  45, OpenProcessTokenEx, 0 
SYSSTUBS_ENTRY6  45, OpenProcessTokenEx, 0 
SYSSTUBS_ENTRY7  45, OpenProcessTokenEx, 0 
SYSSTUBS_ENTRY8  45, OpenProcessTokenEx, 0 
SYSSTUBS_ENTRY1  46, QueryPerformanceCounter, 0 
SYSSTUBS_ENTRY2  46, QueryPerformanceCounter, 0 
SYSSTUBS_ENTRY3  46, QueryPerformanceCounter, 0 
SYSSTUBS_ENTRY4  46, QueryPerformanceCounter, 0 
SYSSTUBS_ENTRY5  46, QueryPerformanceCounter, 0 
SYSSTUBS_ENTRY6  46, QueryPerformanceCounter, 0 
SYSSTUBS_ENTRY7  46, QueryPerformanceCounter, 0 
SYSSTUBS_ENTRY8  46, QueryPerformanceCounter, 0 
SYSSTUBS_ENTRY1  47, EnumerateKey, 2 
SYSSTUBS_ENTRY2  47, EnumerateKey, 2 
SYSSTUBS_ENTRY3  47, EnumerateKey, 2 
SYSSTUBS_ENTRY4  47, EnumerateKey, 2 
SYSSTUBS_ENTRY5  47, EnumerateKey, 2 
SYSSTUBS_ENTRY6  47, EnumerateKey, 2 
SYSSTUBS_ENTRY7  47, EnumerateKey, 2 
SYSSTUBS_ENTRY8  47, EnumerateKey, 2 
SYSSTUBS_ENTRY1  48, OpenFile, 2 
SYSSTUBS_ENTRY2  48, OpenFile, 2 
SYSSTUBS_ENTRY3  48, OpenFile, 2 
SYSSTUBS_ENTRY4  48, OpenFile, 2 
SYSSTUBS_ENTRY5  48, OpenFile, 2 
SYSSTUBS_ENTRY6  48, OpenFile, 2 
SYSSTUBS_ENTRY7  48, OpenFile, 2 
SYSSTUBS_ENTRY8  48, OpenFile, 2 
SYSSTUBS_ENTRY1  49, DelayExecution, 0 
SYSSTUBS_ENTRY2  49, DelayExecution, 0 
SYSSTUBS_ENTRY3  49, DelayExecution, 0 
SYSSTUBS_ENTRY4  49, DelayExecution, 0 
SYSSTUBS_ENTRY5  49, DelayExecution, 0 
SYSSTUBS_ENTRY6  49, DelayExecution, 0 
SYSSTUBS_ENTRY7  49, DelayExecution, 0 
SYSSTUBS_ENTRY8  49, DelayExecution, 0 
SYSSTUBS_ENTRY1  50, QueryDirectoryFile, 7 
SYSSTUBS_ENTRY2  50, QueryDirectoryFile, 7 
SYSSTUBS_ENTRY3  50, QueryDirectoryFile, 7 
SYSSTUBS_ENTRY4  50, QueryDirectoryFile, 7 
SYSSTUBS_ENTRY5  50, QueryDirectoryFile, 7 
SYSSTUBS_ENTRY6  50, QueryDirectoryFile, 7 
SYSSTUBS_ENTRY7  50, QueryDirectoryFile, 7 
SYSSTUBS_ENTRY8  50, QueryDirectoryFile, 7 
SYSSTUBS_ENTRY1  51, QuerySystemInformation, 0 
SYSSTUBS_ENTRY2  51, QuerySystemInformation, 0 
SYSSTUBS_ENTRY3  51, QuerySystemInformation, 0 
SYSSTUBS_ENTRY4  51, QuerySystemInformation, 0 
SYSSTUBS_ENTRY5  51, QuerySystemInformation, 0 
SYSSTUBS_ENTRY6  51, QuerySystemInformation, 0 
SYSSTUBS_ENTRY7  51, QuerySystemInformation, 0 
SYSSTUBS_ENTRY8  51, QuerySystemInformation, 0 
SYSSTUBS_ENTRY1  52, OpenSection, 0 
SYSSTUBS_ENTRY2  52, OpenSection, 0 
SYSSTUBS_ENTRY3  52, OpenSection, 0 
SYSSTUBS_ENTRY4  52, OpenSection, 0 
SYSSTUBS_ENTRY5  52, OpenSection, 0 
SYSSTUBS_ENTRY6  52, OpenSection, 0 
SYSSTUBS_ENTRY7  52, OpenSection, 0 
SYSSTUBS_ENTRY8  52, OpenSection, 0 
SYSSTUBS_ENTRY1  53, QueryTimer, 1 
SYSSTUBS_ENTRY2  53, QueryTimer, 1 
SYSSTUBS_ENTRY3  53, QueryTimer, 1 
SYSSTUBS_ENTRY4  53, QueryTimer, 1 
SYSSTUBS_ENTRY5  53, QueryTimer, 1 
SYSSTUBS_ENTRY6  53, QueryTimer, 1 
SYSSTUBS_ENTRY7  53, QueryTimer, 1 
SYSSTUBS_ENTRY8  53, QueryTimer, 1 
SYSSTUBS_ENTRY1  54, FsControlFile, 6 
SYSSTUBS_ENTRY2  54, FsControlFile, 6 
SYSSTUBS_ENTRY3  54, FsControlFile, 6 
SYSSTUBS_ENTRY4  54, FsControlFile, 6 
SYSSTUBS_ENTRY5  54, FsControlFile, 6 
SYSSTUBS_ENTRY6  54, FsControlFile, 6 
SYSSTUBS_ENTRY7  54, FsControlFile, 6 
SYSSTUBS_ENTRY8  54, FsControlFile, 6 
SYSSTUBS_ENTRY1  55, WriteVirtualMemory, 1 
SYSSTUBS_ENTRY2  55, WriteVirtualMemory, 1 
SYSSTUBS_ENTRY3  55, WriteVirtualMemory, 1 
SYSSTUBS_ENTRY4  55, WriteVirtualMemory, 1 
SYSSTUBS_ENTRY5  55, WriteVirtualMemory, 1 
SYSSTUBS_ENTRY6  55, WriteVirtualMemory, 1 
SYSSTUBS_ENTRY7  55, WriteVirtualMemory, 1 
SYSSTUBS_ENTRY8  55, WriteVirtualMemory, 1 
SYSSTUBS_ENTRY1  56, CloseObjectAuditAlarm, 0 
SYSSTUBS_ENTRY2  56, CloseObjectAuditAlarm, 0 
SYSSTUBS_ENTRY3  56, CloseObjectAuditAlarm, 0 
SYSSTUBS_ENTRY4  56, CloseObjectAuditAlarm, 0 
SYSSTUBS_ENTRY5  56, CloseObjectAuditAlarm, 0 
SYSSTUBS_ENTRY6  56, CloseObjectAuditAlarm, 0 
SYSSTUBS_ENTRY7  56, CloseObjectAuditAlarm, 0 
SYSSTUBS_ENTRY8  56, CloseObjectAuditAlarm, 0 
SYSSTUBS_ENTRY1  57, DuplicateObject, 3 
SYSSTUBS_ENTRY2  57, DuplicateObject, 3 
SYSSTUBS_ENTRY3  57, DuplicateObject, 3 
SYSSTUBS_ENTRY4  57, DuplicateObject, 3 
SYSSTUBS_ENTRY5  57, DuplicateObject, 3 
SYSSTUBS_ENTRY6  57, DuplicateObject, 3 
SYSSTUBS_ENTRY7  57, DuplicateObject, 3 
SYSSTUBS_ENTRY8  57, DuplicateObject, 3 
SYSSTUBS_ENTRY1  58, QueryAttributesFile, 0 
SYSSTUBS_ENTRY2  58, QueryAttributesFile, 0 
SYSSTUBS_ENTRY3  58, QueryAttributesFile, 0 
SYSSTUBS_ENTRY4  58, QueryAttributesFile, 0 
SYSSTUBS_ENTRY5  58, QueryAttributesFile, 0 
SYSSTUBS_ENTRY6  58, QueryAttributesFile, 0 
SYSSTUBS_ENTRY7  58, QueryAttributesFile, 0 
SYSSTUBS_ENTRY8  58, QueryAttributesFile, 0 
SYSSTUBS_ENTRY1  59, ClearEvent, 0 
SYSSTUBS_ENTRY2  59, ClearEvent, 0 
SYSSTUBS_ENTRY3  59, ClearEvent, 0 
SYSSTUBS_ENTRY4  59, ClearEvent, 0 
SYSSTUBS_ENTRY5  59, ClearEvent, 0 
SYSSTUBS_ENTRY6  59, ClearEvent, 0 
SYSSTUBS_ENTRY7  59, ClearEvent, 0 
SYSSTUBS_ENTRY8  59, ClearEvent, 0 
SYSSTUBS_ENTRY1  60, ReadVirtualMemory, 1 
SYSSTUBS_ENTRY2  60, ReadVirtualMemory, 1 
SYSSTUBS_ENTRY3  60, ReadVirtualMemory, 1 
SYSSTUBS_ENTRY4  60, ReadVirtualMemory, 1 
SYSSTUBS_ENTRY5  60, ReadVirtualMemory, 1 
SYSSTUBS_ENTRY6  60, ReadVirtualMemory, 1 
SYSSTUBS_ENTRY7  60, ReadVirtualMemory, 1 
SYSSTUBS_ENTRY8  60, ReadVirtualMemory, 1 
SYSSTUBS_ENTRY1  61, OpenEvent, 0 
SYSSTUBS_ENTRY2  61, OpenEvent, 0 
SYSSTUBS_ENTRY3  61, OpenEvent, 0 
SYSSTUBS_ENTRY4  61, OpenEvent, 0 
SYSSTUBS_ENTRY5  61, OpenEvent, 0 
SYSSTUBS_ENTRY6  61, OpenEvent, 0 
SYSSTUBS_ENTRY7  61, OpenEvent, 0 
SYSSTUBS_ENTRY8  61, OpenEvent, 0 
SYSSTUBS_ENTRY1  62, AdjustPrivilegesToken, 2 
SYSSTUBS_ENTRY2  62, AdjustPrivilegesToken, 2 
SYSSTUBS_ENTRY3  62, AdjustPrivilegesToken, 2 
SYSSTUBS_ENTRY4  62, AdjustPrivilegesToken, 2 
SYSSTUBS_ENTRY5  62, AdjustPrivilegesToken, 2 
SYSSTUBS_ENTRY6  62, AdjustPrivilegesToken, 2 
SYSSTUBS_ENTRY7  62, AdjustPrivilegesToken, 2 
SYSSTUBS_ENTRY8  62, AdjustPrivilegesToken, 2 
SYSSTUBS_ENTRY1  63, DuplicateToken, 2 
SYSSTUBS_ENTRY2  63, DuplicateToken, 2 
SYSSTUBS_ENTRY3  63, DuplicateToken, 2 
SYSSTUBS_ENTRY4  63, DuplicateToken, 2 
SYSSTUBS_ENTRY5  63, DuplicateToken, 2 
SYSSTUBS_ENTRY6  63, DuplicateToken, 2 
SYSSTUBS_ENTRY7  63, DuplicateToken, 2 
SYSSTUBS_ENTRY8  63, DuplicateToken, 2 
SYSSTUBS_ENTRY1  64, Continue, 0 
SYSSTUBS_ENTRY2  64, Continue, 0 
SYSSTUBS_ENTRY3  64, Continue, 0 
SYSSTUBS_ENTRY4  64, Continue, 0 
SYSSTUBS_ENTRY5  64, Continue, 0 
SYSSTUBS_ENTRY6  64, Continue, 0 
SYSSTUBS_ENTRY7  64, Continue, 0 
SYSSTUBS_ENTRY8  64, Continue, 0 
SYSSTUBS_ENTRY1  65, QueryDefaultUILanguage, 0 
SYSSTUBS_ENTRY2  65, QueryDefaultUILanguage, 0 
SYSSTUBS_ENTRY3  65, QueryDefaultUILanguage, 0 
SYSSTUBS_ENTRY4  65, QueryDefaultUILanguage, 0 
SYSSTUBS_ENTRY5  65, QueryDefaultUILanguage, 0 
SYSSTUBS_ENTRY6  65, QueryDefaultUILanguage, 0 
SYSSTUBS_ENTRY7  65, QueryDefaultUILanguage, 0 
SYSSTUBS_ENTRY8  65, QueryDefaultUILanguage, 0 
SYSSTUBS_ENTRY1  66, QueueApcThread, 1 
SYSSTUBS_ENTRY2  66, QueueApcThread, 1 
SYSSTUBS_ENTRY3  66, QueueApcThread, 1 
SYSSTUBS_ENTRY4  66, QueueApcThread, 1 
SYSSTUBS_ENTRY5  66, QueueApcThread, 1 
SYSSTUBS_ENTRY6  66, QueueApcThread, 1 
SYSSTUBS_ENTRY7  66, QueueApcThread, 1 
SYSSTUBS_ENTRY8  66, QueueApcThread, 1 
SYSSTUBS_ENTRY1  67, YieldExecution, 0 
SYSSTUBS_ENTRY2  67, YieldExecution, 0 
SYSSTUBS_ENTRY3  67, YieldExecution, 0 
SYSSTUBS_ENTRY4  67, YieldExecution, 0 
SYSSTUBS_ENTRY5  67, YieldExecution, 0 
SYSSTUBS_ENTRY6  67, YieldExecution, 0 
SYSSTUBS_ENTRY7  67, YieldExecution, 0 
SYSSTUBS_ENTRY8  67, YieldExecution, 0 
SYSSTUBS_ENTRY1  68, AddAtom, 0 
SYSSTUBS_ENTRY2  68, AddAtom, 0 
SYSSTUBS_ENTRY3  68, AddAtom, 0 
SYSSTUBS_ENTRY4  68, AddAtom, 0 
SYSSTUBS_ENTRY5  68, AddAtom, 0 
SYSSTUBS_ENTRY6  68, AddAtom, 0 
SYSSTUBS_ENTRY7  68, AddAtom, 0 
SYSSTUBS_ENTRY8  68, AddAtom, 0 
SYSSTUBS_ENTRY1  69, CreateEvent, 1 
SYSSTUBS_ENTRY2  69, CreateEvent, 1 
SYSSTUBS_ENTRY3  69, CreateEvent, 1 
SYSSTUBS_ENTRY4  69, CreateEvent, 1 
SYSSTUBS_ENTRY5  69, CreateEvent, 1 
SYSSTUBS_ENTRY6  69, CreateEvent, 1 
SYSSTUBS_ENTRY7  69, CreateEvent, 1 
SYSSTUBS_ENTRY8  69, CreateEvent, 1 
SYSSTUBS_ENTRY1  70, QueryVolumeInformationFile, 1 
SYSSTUBS_ENTRY2  70, QueryVolumeInformationFile, 1 
SYSSTUBS_ENTRY3  70, QueryVolumeInformationFile, 1 
SYSSTUBS_ENTRY4  70, QueryVolumeInformationFile, 1 
SYSSTUBS_ENTRY5  70, QueryVolumeInformationFile, 1 
SYSSTUBS_ENTRY6  70, QueryVolumeInformationFile, 1 
SYSSTUBS_ENTRY7  70, QueryVolumeInformationFile, 1 
SYSSTUBS_ENTRY8  70, QueryVolumeInformationFile, 1 
SYSSTUBS_ENTRY1  71, CreateSection, 3 
SYSSTUBS_ENTRY2  71, CreateSection, 3 
SYSSTUBS_ENTRY3  71, CreateSection, 3 
SYSSTUBS_ENTRY4  71, CreateSection, 3 
SYSSTUBS_ENTRY5  71, CreateSection, 3 
SYSSTUBS_ENTRY6  71, CreateSection, 3 
SYSSTUBS_ENTRY7  71, CreateSection, 3 
SYSSTUBS_ENTRY8  71, CreateSection, 3 
SYSSTUBS_ENTRY1  72, FlushBuffersFile, 0 
SYSSTUBS_ENTRY2  72, FlushBuffersFile, 0 
SYSSTUBS_ENTRY3  72, FlushBuffersFile, 0 
SYSSTUBS_ENTRY4  72, FlushBuffersFile, 0 
SYSSTUBS_ENTRY5  72, FlushBuffersFile, 0 
SYSSTUBS_ENTRY6  72, FlushBuffersFile, 0 
SYSSTUBS_ENTRY7  72, FlushBuffersFile, 0 
SYSSTUBS_ENTRY8  72, FlushBuffersFile, 0 
SYSSTUBS_ENTRY1  73, ApphelpCacheControl, 0 
SYSSTUBS_ENTRY2  73, ApphelpCacheControl, 0 
SYSSTUBS_ENTRY3  73, ApphelpCacheControl, 0 
SYSSTUBS_ENTRY4  73, ApphelpCacheControl, 0 
SYSSTUBS_ENTRY5  73, ApphelpCacheControl, 0 
SYSSTUBS_ENTRY6  73, ApphelpCacheControl, 0 
SYSSTUBS_ENTRY7  73, ApphelpCacheControl, 0 
SYSSTUBS_ENTRY8  73, ApphelpCacheControl, 0 
SYSSTUBS_ENTRY1  74, CreateProcessEx, 5 
SYSSTUBS_ENTRY2  74, CreateProcessEx, 5 
SYSSTUBS_ENTRY3  74, CreateProcessEx, 5 
SYSSTUBS_ENTRY4  74, CreateProcessEx, 5 
SYSSTUBS_ENTRY5  74, CreateProcessEx, 5 
SYSSTUBS_ENTRY6  74, CreateProcessEx, 5 
SYSSTUBS_ENTRY7  74, CreateProcessEx, 5 
SYSSTUBS_ENTRY8  74, CreateProcessEx, 5 
SYSSTUBS_ENTRY1  75, CreateThread, 4 
SYSSTUBS_ENTRY2  75, CreateThread, 4 
SYSSTUBS_ENTRY3  75, CreateThread, 4 
SYSSTUBS_ENTRY4  75, CreateThread, 4 
SYSSTUBS_ENTRY5  75, CreateThread, 4 
SYSSTUBS_ENTRY6  75, CreateThread, 4 
SYSSTUBS_ENTRY7  75, CreateThread, 4 
SYSSTUBS_ENTRY8  75, CreateThread, 4 
SYSSTUBS_ENTRY1  76, IsProcessInJob, 0 
SYSSTUBS_ENTRY2  76, IsProcessInJob, 0 
SYSSTUBS_ENTRY3  76, IsProcessInJob, 0 
SYSSTUBS_ENTRY4  76, IsProcessInJob, 0 
SYSSTUBS_ENTRY5  76, IsProcessInJob, 0 
SYSSTUBS_ENTRY6  76, IsProcessInJob, 0 
SYSSTUBS_ENTRY7  76, IsProcessInJob, 0 
SYSSTUBS_ENTRY8  76, IsProcessInJob, 0 
SYSSTUBS_ENTRY1  77, ProtectVirtualMemory, 1 
SYSSTUBS_ENTRY2  77, ProtectVirtualMemory, 1 
SYSSTUBS_ENTRY3  77, ProtectVirtualMemory, 1 
SYSSTUBS_ENTRY4  77, ProtectVirtualMemory, 1 
SYSSTUBS_ENTRY5  77, ProtectVirtualMemory, 1 
SYSSTUBS_ENTRY6  77, ProtectVirtualMemory, 1 
SYSSTUBS_ENTRY7  77, ProtectVirtualMemory, 1 
SYSSTUBS_ENTRY8  77, ProtectVirtualMemory, 1 
SYSSTUBS_ENTRY1  78, QuerySection, 1 
SYSSTUBS_ENTRY2  78, QuerySection, 1 
SYSSTUBS_ENTRY3  78, QuerySection, 1 
SYSSTUBS_ENTRY4  78, QuerySection, 1 
SYSSTUBS_ENTRY5  78, QuerySection, 1 
SYSSTUBS_ENTRY6  78, QuerySection, 1 
SYSSTUBS_ENTRY7  78, QuerySection, 1 
SYSSTUBS_ENTRY8  78, QuerySection, 1 
SYSSTUBS_ENTRY1  79, ResumeThread, 0 
SYSSTUBS_ENTRY2  79, ResumeThread, 0 
SYSSTUBS_ENTRY3  79, ResumeThread, 0 
SYSSTUBS_ENTRY4  79, ResumeThread, 0 
SYSSTUBS_ENTRY5  79, ResumeThread, 0 
SYSSTUBS_ENTRY6  79, ResumeThread, 0 
SYSSTUBS_ENTRY7  79, ResumeThread, 0 
SYSSTUBS_ENTRY8  79, ResumeThread, 0 
SYSSTUBS_ENTRY1  80, TerminateThread, 0 
SYSSTUBS_ENTRY2  80, TerminateThread, 0 
SYSSTUBS_ENTRY3  80, TerminateThread, 0 
SYSSTUBS_ENTRY4  80, TerminateThread, 0 
SYSSTUBS_ENTRY5  80, TerminateThread, 0 
SYSSTUBS_ENTRY6  80, TerminateThread, 0 
SYSSTUBS_ENTRY7  80, TerminateThread, 0 
SYSSTUBS_ENTRY8  80, TerminateThread, 0 
SYSSTUBS_ENTRY1  81, ReadRequestData, 2 
SYSSTUBS_ENTRY2  81, ReadRequestData, 2 
SYSSTUBS_ENTRY3  81, ReadRequestData, 2 
SYSSTUBS_ENTRY4  81, ReadRequestData, 2 
SYSSTUBS_ENTRY5  81, ReadRequestData, 2 
SYSSTUBS_ENTRY6  81, ReadRequestData, 2 
SYSSTUBS_ENTRY7  81, ReadRequestData, 2 
SYSSTUBS_ENTRY8  81, ReadRequestData, 2 
SYSSTUBS_ENTRY1  82, CreateFile, 7 
SYSSTUBS_ENTRY2  82, CreateFile, 7 
SYSSTUBS_ENTRY3  82, CreateFile, 7 
SYSSTUBS_ENTRY4  82, CreateFile, 7 
SYSSTUBS_ENTRY5  82, CreateFile, 7 
SYSSTUBS_ENTRY6  82, CreateFile, 7 
SYSSTUBS_ENTRY7  82, CreateFile, 7 
SYSSTUBS_ENTRY8  82, CreateFile, 7 
SYSSTUBS_ENTRY1  83, QueryEvent, 1 
SYSSTUBS_ENTRY2  83, QueryEvent, 1 
SYSSTUBS_ENTRY3  83, QueryEvent, 1 
SYSSTUBS_ENTRY4  83, QueryEvent, 1 
SYSSTUBS_ENTRY5  83, QueryEvent, 1 
SYSSTUBS_ENTRY6  83, QueryEvent, 1 
SYSSTUBS_ENTRY7  83, QueryEvent, 1 
SYSSTUBS_ENTRY8  83, QueryEvent, 1 
SYSSTUBS_ENTRY1  84, WriteRequestData, 2 
SYSSTUBS_ENTRY2  84, WriteRequestData, 2 
SYSSTUBS_ENTRY3  84, WriteRequestData, 2 
SYSSTUBS_ENTRY4  84, WriteRequestData, 2 
SYSSTUBS_ENTRY5  84, WriteRequestData, 2 
SYSSTUBS_ENTRY6  84, WriteRequestData, 2 
SYSSTUBS_ENTRY7  84, WriteRequestData, 2 
SYSSTUBS_ENTRY8  84, WriteRequestData, 2 
SYSSTUBS_ENTRY1  85, OpenDirectoryObject, 0 
SYSSTUBS_ENTRY2  85, OpenDirectoryObject, 0 
SYSSTUBS_ENTRY3  85, OpenDirectoryObject, 0 
SYSSTUBS_ENTRY4  85, OpenDirectoryObject, 0 
SYSSTUBS_ENTRY5  85, OpenDirectoryObject, 0 
SYSSTUBS_ENTRY6  85, OpenDirectoryObject, 0 
SYSSTUBS_ENTRY7  85, OpenDirectoryObject, 0 
SYSSTUBS_ENTRY8  85, OpenDirectoryObject, 0 
SYSSTUBS_ENTRY1  86, AccessCheckByTypeAndAuditAlarm, 12 
SYSSTUBS_ENTRY2  86, AccessCheckByTypeAndAuditAlarm, 12 
SYSSTUBS_ENTRY3  86, AccessCheckByTypeAndAuditAlarm, 12 
SYSSTUBS_ENTRY4  86, AccessCheckByTypeAndAuditAlarm, 12 
SYSSTUBS_ENTRY5  86, AccessCheckByTypeAndAuditAlarm, 12 
SYSSTUBS_ENTRY6  86, AccessCheckByTypeAndAuditAlarm, 12 
SYSSTUBS_ENTRY7  86, AccessCheckByTypeAndAuditAlarm, 12 
SYSSTUBS_ENTRY8  86, AccessCheckByTypeAndAuditAlarm, 12 
SYSSTUBS_ENTRY1  87, QuerySystemTime, 0 
SYSSTUBS_ENTRY2  87, QuerySystemTime, 0 
SYSSTUBS_ENTRY3  87, QuerySystemTime, 0 
SYSSTUBS_ENTRY4  87, QuerySystemTime, 0 
SYSSTUBS_ENTRY5  87, QuerySystemTime, 0 
SYSSTUBS_ENTRY6  87, QuerySystemTime, 0 
SYSSTUBS_ENTRY7  87, QuerySystemTime, 0 
SYSSTUBS_ENTRY8  87, QuerySystemTime, 0 
SYSSTUBS_ENTRY1  88, WaitForMultipleObjects, 1 
SYSSTUBS_ENTRY2  88, WaitForMultipleObjects, 1 
SYSSTUBS_ENTRY3  88, WaitForMultipleObjects, 1 
SYSSTUBS_ENTRY4  88, WaitForMultipleObjects, 1 
SYSSTUBS_ENTRY5  88, WaitForMultipleObjects, 1 
SYSSTUBS_ENTRY6  88, WaitForMultipleObjects, 1 
SYSSTUBS_ENTRY7  88, WaitForMultipleObjects, 1 
SYSSTUBS_ENTRY8  88, WaitForMultipleObjects, 1 
SYSSTUBS_ENTRY1  89, SetInformationObject, 0 
SYSSTUBS_ENTRY2  89, SetInformationObject, 0 
SYSSTUBS_ENTRY3  89, SetInformationObject, 0 
SYSSTUBS_ENTRY4  89, SetInformationObject, 0 
SYSSTUBS_ENTRY5  89, SetInformationObject, 0 
SYSSTUBS_ENTRY6  89, SetInformationObject, 0 
SYSSTUBS_ENTRY7  89, SetInformationObject, 0 
SYSSTUBS_ENTRY8  89, SetInformationObject, 0 
SYSSTUBS_ENTRY1  90, CancelIoFile, 0 
SYSSTUBS_ENTRY2  90, CancelIoFile, 0 
SYSSTUBS_ENTRY3  90, CancelIoFile, 0 
SYSSTUBS_ENTRY4  90, CancelIoFile, 0 
SYSSTUBS_ENTRY5  90, CancelIoFile, 0 
SYSSTUBS_ENTRY6  90, CancelIoFile, 0 
SYSSTUBS_ENTRY7  90, CancelIoFile, 0 
SYSSTUBS_ENTRY8  90, CancelIoFile, 0 
SYSSTUBS_ENTRY1  91, TraceEvent, 0 
SYSSTUBS_ENTRY2  91, TraceEvent, 0 
SYSSTUBS_ENTRY3  91, TraceEvent, 0 
SYSSTUBS_ENTRY4  91, TraceEvent, 0 
SYSSTUBS_ENTRY5  91, TraceEvent, 0 
SYSSTUBS_ENTRY6  91, TraceEvent, 0 
SYSSTUBS_ENTRY7  91, TraceEvent, 0 
SYSSTUBS_ENTRY8  91, TraceEvent, 0 
SYSSTUBS_ENTRY1  92, PowerInformation, 1 
SYSSTUBS_ENTRY2  92, PowerInformation, 1 
SYSSTUBS_ENTRY3  92, PowerInformation, 1 
SYSSTUBS_ENTRY4  92, PowerInformation, 1 
SYSSTUBS_ENTRY5  92, PowerInformation, 1 
SYSSTUBS_ENTRY6  92, PowerInformation, 1 
SYSSTUBS_ENTRY7  92, PowerInformation, 1 
SYSSTUBS_ENTRY8  92, PowerInformation, 1 
SYSSTUBS_ENTRY1  93, SetValueKey, 2 
SYSSTUBS_ENTRY2  93, SetValueKey, 2 
SYSSTUBS_ENTRY3  93, SetValueKey, 2 
SYSSTUBS_ENTRY4  93, SetValueKey, 2 
SYSSTUBS_ENTRY5  93, SetValueKey, 2 
SYSSTUBS_ENTRY6  93, SetValueKey, 2 
SYSSTUBS_ENTRY7  93, SetValueKey, 2 
SYSSTUBS_ENTRY8  93, SetValueKey, 2 
SYSSTUBS_ENTRY1  94, CancelTimer, 0 
SYSSTUBS_ENTRY2  94, CancelTimer, 0 
SYSSTUBS_ENTRY3  94, CancelTimer, 0 
SYSSTUBS_ENTRY4  94, CancelTimer, 0 
SYSSTUBS_ENTRY5  94, CancelTimer, 0 
SYSSTUBS_ENTRY6  94, CancelTimer, 0 
SYSSTUBS_ENTRY7  94, CancelTimer, 0 
SYSSTUBS_ENTRY8  94, CancelTimer, 0 
SYSSTUBS_ENTRY1  95, SetTimer, 3 
SYSSTUBS_ENTRY2  95, SetTimer, 3 
SYSSTUBS_ENTRY3  95, SetTimer, 3 
SYSSTUBS_ENTRY4  95, SetTimer, 3 
SYSSTUBS_ENTRY5  95, SetTimer, 3 
SYSSTUBS_ENTRY6  95, SetTimer, 3 
SYSSTUBS_ENTRY7  95, SetTimer, 3 
SYSSTUBS_ENTRY8  95, SetTimer, 3 
SYSSTUBS_ENTRY1  96, AcceptConnectPort, 2 
SYSSTUBS_ENTRY2  96, AcceptConnectPort, 2 
SYSSTUBS_ENTRY3  96, AcceptConnectPort, 2 
SYSSTUBS_ENTRY4  96, AcceptConnectPort, 2 
SYSSTUBS_ENTRY5  96, AcceptConnectPort, 2 
SYSSTUBS_ENTRY6  96, AcceptConnectPort, 2 
SYSSTUBS_ENTRY7  96, AcceptConnectPort, 2 
SYSSTUBS_ENTRY8  96, AcceptConnectPort, 2 
SYSSTUBS_ENTRY1  97, AccessCheck, 4 
SYSSTUBS_ENTRY2  97, AccessCheck, 4 
SYSSTUBS_ENTRY3  97, AccessCheck, 4 
SYSSTUBS_ENTRY4  97, AccessCheck, 4 
SYSSTUBS_ENTRY5  97, AccessCheck, 4 
SYSSTUBS_ENTRY6  97, AccessCheck, 4 
SYSSTUBS_ENTRY7  97, AccessCheck, 4 
SYSSTUBS_ENTRY8  97, AccessCheck, 4 
SYSSTUBS_ENTRY1  98, AccessCheckByType, 7 
SYSSTUBS_ENTRY2  98, AccessCheckByType, 7 
SYSSTUBS_ENTRY3  98, AccessCheckByType, 7 
SYSSTUBS_ENTRY4  98, AccessCheckByType, 7 
SYSSTUBS_ENTRY5  98, AccessCheckByType, 7 
SYSSTUBS_ENTRY6  98, AccessCheckByType, 7 
SYSSTUBS_ENTRY7  98, AccessCheckByType, 7 
SYSSTUBS_ENTRY8  98, AccessCheckByType, 7 
SYSSTUBS_ENTRY1  99, AccessCheckByTypeResultList, 7 
SYSSTUBS_ENTRY2  99, AccessCheckByTypeResultList, 7 
SYSSTUBS_ENTRY3  99, AccessCheckByTypeResultList, 7 
SYSSTUBS_ENTRY4  99, AccessCheckByTypeResultList, 7 
SYSSTUBS_ENTRY5  99, AccessCheckByTypeResultList, 7 
SYSSTUBS_ENTRY6  99, AccessCheckByTypeResultList, 7 
SYSSTUBS_ENTRY7  99, AccessCheckByTypeResultList, 7 
SYSSTUBS_ENTRY8  99, AccessCheckByTypeResultList, 7 
SYSSTUBS_ENTRY1  100, AccessCheckByTypeResultListAndAuditAlarm, 12 
SYSSTUBS_ENTRY2  100, AccessCheckByTypeResultListAndAuditAlarm, 12 
SYSSTUBS_ENTRY3  100, AccessCheckByTypeResultListAndAuditAlarm, 12 
SYSSTUBS_ENTRY4  100, AccessCheckByTypeResultListAndAuditAlarm, 12 
SYSSTUBS_ENTRY5  100, AccessCheckByTypeResultListAndAuditAlarm, 12 
SYSSTUBS_ENTRY6  100, AccessCheckByTypeResultListAndAuditAlarm, 12 
SYSSTUBS_ENTRY7  100, AccessCheckByTypeResultListAndAuditAlarm, 12 
SYSSTUBS_ENTRY8  100, AccessCheckByTypeResultListAndAuditAlarm, 12 
SYSSTUBS_ENTRY1  101, AccessCheckByTypeResultListAndAuditAlarmByHandle, 13 
SYSSTUBS_ENTRY2  101, AccessCheckByTypeResultListAndAuditAlarmByHandle, 13 
SYSSTUBS_ENTRY3  101, AccessCheckByTypeResultListAndAuditAlarmByHandle, 13 
SYSSTUBS_ENTRY4  101, AccessCheckByTypeResultListAndAuditAlarmByHandle, 13 
SYSSTUBS_ENTRY5  101, AccessCheckByTypeResultListAndAuditAlarmByHandle, 13 
SYSSTUBS_ENTRY6  101, AccessCheckByTypeResultListAndAuditAlarmByHandle, 13 
SYSSTUBS_ENTRY7  101, AccessCheckByTypeResultListAndAuditAlarmByHandle, 13 
SYSSTUBS_ENTRY8  101, AccessCheckByTypeResultListAndAuditAlarmByHandle, 13 
SYSSTUBS_ENTRY1  102, AddBootEntry, 0 
SYSSTUBS_ENTRY2  102, AddBootEntry, 0 
SYSSTUBS_ENTRY3  102, AddBootEntry, 0 
SYSSTUBS_ENTRY4  102, AddBootEntry, 0 
SYSSTUBS_ENTRY5  102, AddBootEntry, 0 
SYSSTUBS_ENTRY6  102, AddBootEntry, 0 
SYSSTUBS_ENTRY7  102, AddBootEntry, 0 
SYSSTUBS_ENTRY8  102, AddBootEntry, 0 
SYSSTUBS_ENTRY1  103, AddDriverEntry, 0 
SYSSTUBS_ENTRY2  103, AddDriverEntry, 0 
SYSSTUBS_ENTRY3  103, AddDriverEntry, 0 
SYSSTUBS_ENTRY4  103, AddDriverEntry, 0 
SYSSTUBS_ENTRY5  103, AddDriverEntry, 0 
SYSSTUBS_ENTRY6  103, AddDriverEntry, 0 
SYSSTUBS_ENTRY7  103, AddDriverEntry, 0 
SYSSTUBS_ENTRY8  103, AddDriverEntry, 0 
SYSSTUBS_ENTRY1  104, AdjustGroupsToken, 2 
SYSSTUBS_ENTRY2  104, AdjustGroupsToken, 2 
SYSSTUBS_ENTRY3  104, AdjustGroupsToken, 2 
SYSSTUBS_ENTRY4  104, AdjustGroupsToken, 2 
SYSSTUBS_ENTRY5  104, AdjustGroupsToken, 2 
SYSSTUBS_ENTRY6  104, AdjustGroupsToken, 2 
SYSSTUBS_ENTRY7  104, AdjustGroupsToken, 2 
SYSSTUBS_ENTRY8  104, AdjustGroupsToken, 2 
SYSSTUBS_ENTRY1  105, AlertResumeThread, 0 
SYSSTUBS_ENTRY2  105, AlertResumeThread, 0 
SYSSTUBS_ENTRY3  105, AlertResumeThread, 0 
SYSSTUBS_ENTRY4  105, AlertResumeThread, 0 
SYSSTUBS_ENTRY5  105, AlertResumeThread, 0 
SYSSTUBS_ENTRY6  105, AlertResumeThread, 0 
SYSSTUBS_ENTRY7  105, AlertResumeThread, 0 
SYSSTUBS_ENTRY8  105, AlertResumeThread, 0 
SYSSTUBS_ENTRY1  106, AlertThread, 0 
SYSSTUBS_ENTRY2  106, AlertThread, 0 
SYSSTUBS_ENTRY3  106, AlertThread, 0 
SYSSTUBS_ENTRY4  106, AlertThread, 0 
SYSSTUBS_ENTRY5  106, AlertThread, 0 
SYSSTUBS_ENTRY6  106, AlertThread, 0 
SYSSTUBS_ENTRY7  106, AlertThread, 0 
SYSSTUBS_ENTRY8  106, AlertThread, 0 
SYSSTUBS_ENTRY1  107, AllocateLocallyUniqueId, 0 
SYSSTUBS_ENTRY2  107, AllocateLocallyUniqueId, 0 
SYSSTUBS_ENTRY3  107, AllocateLocallyUniqueId, 0 
SYSSTUBS_ENTRY4  107, AllocateLocallyUniqueId, 0 
SYSSTUBS_ENTRY5  107, AllocateLocallyUniqueId, 0 
SYSSTUBS_ENTRY6  107, AllocateLocallyUniqueId, 0 
SYSSTUBS_ENTRY7  107, AllocateLocallyUniqueId, 0 
SYSSTUBS_ENTRY8  107, AllocateLocallyUniqueId, 0 
SYSSTUBS_ENTRY1  108, AllocateUserPhysicalPages, 0 
SYSSTUBS_ENTRY2  108, AllocateUserPhysicalPages, 0 
SYSSTUBS_ENTRY3  108, AllocateUserPhysicalPages, 0 
SYSSTUBS_ENTRY4  108, AllocateUserPhysicalPages, 0 
SYSSTUBS_ENTRY5  108, AllocateUserPhysicalPages, 0 
SYSSTUBS_ENTRY6  108, AllocateUserPhysicalPages, 0 
SYSSTUBS_ENTRY7  108, AllocateUserPhysicalPages, 0 
SYSSTUBS_ENTRY8  108, AllocateUserPhysicalPages, 0 
SYSSTUBS_ENTRY1  109, AllocateUuids, 0 
SYSSTUBS_ENTRY2  109, AllocateUuids, 0 
SYSSTUBS_ENTRY3  109, AllocateUuids, 0 
SYSSTUBS_ENTRY4  109, AllocateUuids, 0 
SYSSTUBS_ENTRY5  109, AllocateUuids, 0 
SYSSTUBS_ENTRY6  109, AllocateUuids, 0 
SYSSTUBS_ENTRY7  109, AllocateUuids, 0 
SYSSTUBS_ENTRY8  109, AllocateUuids, 0 
SYSSTUBS_ENTRY1  110, AreMappedFilesTheSame, 0 
SYSSTUBS_ENTRY2  110, AreMappedFilesTheSame, 0 
SYSSTUBS_ENTRY3  110, AreMappedFilesTheSame, 0 
SYSSTUBS_ENTRY4  110, AreMappedFilesTheSame, 0 
SYSSTUBS_ENTRY5  110, AreMappedFilesTheSame, 0 
SYSSTUBS_ENTRY6  110, AreMappedFilesTheSame, 0 
SYSSTUBS_ENTRY7  110, AreMappedFilesTheSame, 0 
SYSSTUBS_ENTRY8  110, AreMappedFilesTheSame, 0 
SYSSTUBS_ENTRY1  111, AssignProcessToJobObject, 0 
SYSSTUBS_ENTRY2  111, AssignProcessToJobObject, 0 
SYSSTUBS_ENTRY3  111, AssignProcessToJobObject, 0 
SYSSTUBS_ENTRY4  111, AssignProcessToJobObject, 0 
SYSSTUBS_ENTRY5  111, AssignProcessToJobObject, 0 
SYSSTUBS_ENTRY6  111, AssignProcessToJobObject, 0 
SYSSTUBS_ENTRY7  111, AssignProcessToJobObject, 0 
SYSSTUBS_ENTRY8  111, AssignProcessToJobObject, 0 
SYSSTUBS_ENTRY1  112, CancelDeviceWakeupRequest, 0 
SYSSTUBS_ENTRY2  112, CancelDeviceWakeupRequest, 0 
SYSSTUBS_ENTRY3  112, CancelDeviceWakeupRequest, 0 
SYSSTUBS_ENTRY4  112, CancelDeviceWakeupRequest, 0 
SYSSTUBS_ENTRY5  112, CancelDeviceWakeupRequest, 0 
SYSSTUBS_ENTRY6  112, CancelDeviceWakeupRequest, 0 
SYSSTUBS_ENTRY7  112, CancelDeviceWakeupRequest, 0 
SYSSTUBS_ENTRY8  112, CancelDeviceWakeupRequest, 0 
SYSSTUBS_ENTRY1  113, CompactKeys, 0 
SYSSTUBS_ENTRY2  113, CompactKeys, 0 
SYSSTUBS_ENTRY3  113, CompactKeys, 0 
SYSSTUBS_ENTRY4  113, CompactKeys, 0 
SYSSTUBS_ENTRY5  113, CompactKeys, 0 
SYSSTUBS_ENTRY6  113, CompactKeys, 0 
SYSSTUBS_ENTRY7  113, CompactKeys, 0 
SYSSTUBS_ENTRY8  113, CompactKeys, 0 
SYSSTUBS_ENTRY1  114, CompareTokens, 0 
SYSSTUBS_ENTRY2  114, CompareTokens, 0 
SYSSTUBS_ENTRY3  114, CompareTokens, 0 
SYSSTUBS_ENTRY4  114, CompareTokens, 0 
SYSSTUBS_ENTRY5  114, CompareTokens, 0 
SYSSTUBS_ENTRY6  114, CompareTokens, 0 
SYSSTUBS_ENTRY7  114, CompareTokens, 0 
SYSSTUBS_ENTRY8  114, CompareTokens, 0 
SYSSTUBS_ENTRY1  115, CompleteConnectPort, 0 
SYSSTUBS_ENTRY2  115, CompleteConnectPort, 0 
SYSSTUBS_ENTRY3  115, CompleteConnectPort, 0 
SYSSTUBS_ENTRY4  115, CompleteConnectPort, 0 
SYSSTUBS_ENTRY5  115, CompleteConnectPort, 0 
SYSSTUBS_ENTRY6  115, CompleteConnectPort, 0 
SYSSTUBS_ENTRY7  115, CompleteConnectPort, 0 
SYSSTUBS_ENTRY8  115, CompleteConnectPort, 0 
SYSSTUBS_ENTRY1  116, CompressKey, 0 
SYSSTUBS_ENTRY2  116, CompressKey, 0 
SYSSTUBS_ENTRY3  116, CompressKey, 0 
SYSSTUBS_ENTRY4  116, CompressKey, 0 
SYSSTUBS_ENTRY5  116, CompressKey, 0 
SYSSTUBS_ENTRY6  116, CompressKey, 0 
SYSSTUBS_ENTRY7  116, CompressKey, 0 
SYSSTUBS_ENTRY8  116, CompressKey, 0 
SYSSTUBS_ENTRY1  117, ConnectPort, 4 
SYSSTUBS_ENTRY2  117, ConnectPort, 4 
SYSSTUBS_ENTRY3  117, ConnectPort, 4 
SYSSTUBS_ENTRY4  117, ConnectPort, 4 
SYSSTUBS_ENTRY5  117, ConnectPort, 4 
SYSSTUBS_ENTRY6  117, ConnectPort, 4 
SYSSTUBS_ENTRY7  117, ConnectPort, 4 
SYSSTUBS_ENTRY8  117, ConnectPort, 4 
SYSSTUBS_ENTRY1  118, CreateDebugObject, 0 
SYSSTUBS_ENTRY2  118, CreateDebugObject, 0 
SYSSTUBS_ENTRY3  118, CreateDebugObject, 0 
SYSSTUBS_ENTRY4  118, CreateDebugObject, 0 
SYSSTUBS_ENTRY5  118, CreateDebugObject, 0 
SYSSTUBS_ENTRY6  118, CreateDebugObject, 0 
SYSSTUBS_ENTRY7  118, CreateDebugObject, 0 
SYSSTUBS_ENTRY8  118, CreateDebugObject, 0 
SYSSTUBS_ENTRY1  119, CreateDirectoryObject, 0 
SYSSTUBS_ENTRY2  119, CreateDirectoryObject, 0 
SYSSTUBS_ENTRY3  119, CreateDirectoryObject, 0 
SYSSTUBS_ENTRY4  119, CreateDirectoryObject, 0 
SYSSTUBS_ENTRY5  119, CreateDirectoryObject, 0 
SYSSTUBS_ENTRY6  119, CreateDirectoryObject, 0 
SYSSTUBS_ENTRY7  119, CreateDirectoryObject, 0 
SYSSTUBS_ENTRY8  119, CreateDirectoryObject, 0 
SYSSTUBS_ENTRY1  120, CreateEventPair, 0 
SYSSTUBS_ENTRY2  120, CreateEventPair, 0 
SYSSTUBS_ENTRY3  120, CreateEventPair, 0 
SYSSTUBS_ENTRY4  120, CreateEventPair, 0 
SYSSTUBS_ENTRY5  120, CreateEventPair, 0 
SYSSTUBS_ENTRY6  120, CreateEventPair, 0 
SYSSTUBS_ENTRY7  120, CreateEventPair, 0 
SYSSTUBS_ENTRY8  120, CreateEventPair, 0 
SYSSTUBS_ENTRY1  121, CreateIoCompletion, 0 
SYSSTUBS_ENTRY2  121, CreateIoCompletion, 0 
SYSSTUBS_ENTRY3  121, CreateIoCompletion, 0 
SYSSTUBS_ENTRY4  121, CreateIoCompletion, 0 
SYSSTUBS_ENTRY5  121, CreateIoCompletion, 0 
SYSSTUBS_ENTRY6  121, CreateIoCompletion, 0 
SYSSTUBS_ENTRY7  121, CreateIoCompletion, 0 
SYSSTUBS_ENTRY8  121, CreateIoCompletion, 0 
SYSSTUBS_ENTRY1  122, CreateJobObject, 0 
SYSSTUBS_ENTRY2  122, CreateJobObject, 0 
SYSSTUBS_ENTRY3  122, CreateJobObject, 0 
SYSSTUBS_ENTRY4  122, CreateJobObject, 0 
SYSSTUBS_ENTRY5  122, CreateJobObject, 0 
SYSSTUBS_ENTRY6  122, CreateJobObject, 0 
SYSSTUBS_ENTRY7  122, CreateJobObject, 0 
SYSSTUBS_ENTRY8  122, CreateJobObject, 0 
SYSSTUBS_ENTRY1  123, CreateJobSet, 0 
SYSSTUBS_ENTRY2  123, CreateJobSet, 0 
SYSSTUBS_ENTRY3  123, CreateJobSet, 0 
SYSSTUBS_ENTRY4  123, CreateJobSet, 0 
SYSSTUBS_ENTRY5  123, CreateJobSet, 0 
SYSSTUBS_ENTRY6  123, CreateJobSet, 0 
SYSSTUBS_ENTRY7  123, CreateJobSet, 0 
SYSSTUBS_ENTRY8  123, CreateJobSet, 0 
SYSSTUBS_ENTRY1  124, CreateKeyedEvent, 0 
SYSSTUBS_ENTRY2  124, CreateKeyedEvent, 0 
SYSSTUBS_ENTRY3  124, CreateKeyedEvent, 0 
SYSSTUBS_ENTRY4  124, CreateKeyedEvent, 0 
SYSSTUBS_ENTRY5  124, CreateKeyedEvent, 0 
SYSSTUBS_ENTRY6  124, CreateKeyedEvent, 0 
SYSSTUBS_ENTRY7  124, CreateKeyedEvent, 0 
SYSSTUBS_ENTRY8  124, CreateKeyedEvent, 0 
SYSSTUBS_ENTRY1  125, CreateMailslotFile, 4 
SYSSTUBS_ENTRY2  125, CreateMailslotFile, 4 
SYSSTUBS_ENTRY3  125, CreateMailslotFile, 4 
SYSSTUBS_ENTRY4  125, CreateMailslotFile, 4 
SYSSTUBS_ENTRY5  125, CreateMailslotFile, 4 
SYSSTUBS_ENTRY6  125, CreateMailslotFile, 4 
SYSSTUBS_ENTRY7  125, CreateMailslotFile, 4 
SYSSTUBS_ENTRY8  125, CreateMailslotFile, 4 
SYSSTUBS_ENTRY1  126, CreateMutant, 0 
SYSSTUBS_ENTRY2  126, CreateMutant, 0 
SYSSTUBS_ENTRY3  126, CreateMutant, 0 
SYSSTUBS_ENTRY4  126, CreateMutant, 0 
SYSSTUBS_ENTRY5  126, CreateMutant, 0 
SYSSTUBS_ENTRY6  126, CreateMutant, 0 
SYSSTUBS_ENTRY7  126, CreateMutant, 0 
SYSSTUBS_ENTRY8  126, CreateMutant, 0 
SYSSTUBS_ENTRY1  127, CreateNamedPipeFile, 10 
SYSSTUBS_ENTRY2  127, CreateNamedPipeFile, 10 
SYSSTUBS_ENTRY3  127, CreateNamedPipeFile, 10 
SYSSTUBS_ENTRY4  127, CreateNamedPipeFile, 10 
SYSSTUBS_ENTRY5  127, CreateNamedPipeFile, 10 
SYSSTUBS_ENTRY6  127, CreateNamedPipeFile, 10 
SYSSTUBS_ENTRY7  127, CreateNamedPipeFile, 10 
SYSSTUBS_ENTRY8  127, CreateNamedPipeFile, 10 
SYSSTUBS_ENTRY1  128, CreatePagingFile, 0 
SYSSTUBS_ENTRY2  128, CreatePagingFile, 0 
SYSSTUBS_ENTRY3  128, CreatePagingFile, 0 
SYSSTUBS_ENTRY4  128, CreatePagingFile, 0 
SYSSTUBS_ENTRY5  128, CreatePagingFile, 0 
SYSSTUBS_ENTRY6  128, CreatePagingFile, 0 
SYSSTUBS_ENTRY7  128, CreatePagingFile, 0 
SYSSTUBS_ENTRY8  128, CreatePagingFile, 0 
SYSSTUBS_ENTRY1  129, CreatePort, 1 
SYSSTUBS_ENTRY2  129, CreatePort, 1 
SYSSTUBS_ENTRY3  129, CreatePort, 1 
SYSSTUBS_ENTRY4  129, CreatePort, 1 
SYSSTUBS_ENTRY5  129, CreatePort, 1 
SYSSTUBS_ENTRY6  129, CreatePort, 1 
SYSSTUBS_ENTRY7  129, CreatePort, 1 
SYSSTUBS_ENTRY8  129, CreatePort, 1 
SYSSTUBS_ENTRY1  130, CreateProcess, 4 
SYSSTUBS_ENTRY2  130, CreateProcess, 4 
SYSSTUBS_ENTRY3  130, CreateProcess, 4 
SYSSTUBS_ENTRY4  130, CreateProcess, 4 
SYSSTUBS_ENTRY5  130, CreateProcess, 4 
SYSSTUBS_ENTRY6  130, CreateProcess, 4 
SYSSTUBS_ENTRY7  130, CreateProcess, 4 
SYSSTUBS_ENTRY8  130, CreateProcess, 4 
SYSSTUBS_ENTRY1  131, CreateProfile, 5 
SYSSTUBS_ENTRY2  131, CreateProfile, 5 
SYSSTUBS_ENTRY3  131, CreateProfile, 5 
SYSSTUBS_ENTRY4  131, CreateProfile, 5 
SYSSTUBS_ENTRY5  131, CreateProfile, 5 
SYSSTUBS_ENTRY6  131, CreateProfile, 5 
SYSSTUBS_ENTRY7  131, CreateProfile, 5 
SYSSTUBS_ENTRY8  131, CreateProfile, 5 
SYSSTUBS_ENTRY1  132, CreateSemaphore, 1 
SYSSTUBS_ENTRY2  132, CreateSemaphore, 1 
SYSSTUBS_ENTRY3  132, CreateSemaphore, 1 
SYSSTUBS_ENTRY4  132, CreateSemaphore, 1 
SYSSTUBS_ENTRY5  132, CreateSemaphore, 1 
SYSSTUBS_ENTRY6  132, CreateSemaphore, 1 
SYSSTUBS_ENTRY7  132, CreateSemaphore, 1 
SYSSTUBS_ENTRY8  132, CreateSemaphore, 1 
SYSSTUBS_ENTRY1  133, CreateSymbolicLinkObject, 0 
SYSSTUBS_ENTRY2  133, CreateSymbolicLinkObject, 0 
SYSSTUBS_ENTRY3  133, CreateSymbolicLinkObject, 0 
SYSSTUBS_ENTRY4  133, CreateSymbolicLinkObject, 0 
SYSSTUBS_ENTRY5  133, CreateSymbolicLinkObject, 0 
SYSSTUBS_ENTRY6  133, CreateSymbolicLinkObject, 0 
SYSSTUBS_ENTRY7  133, CreateSymbolicLinkObject, 0 
SYSSTUBS_ENTRY8  133, CreateSymbolicLinkObject, 0 
SYSSTUBS_ENTRY1  134, CreateTimer, 0 
SYSSTUBS_ENTRY2  134, CreateTimer, 0 
SYSSTUBS_ENTRY3  134, CreateTimer, 0 
SYSSTUBS_ENTRY4  134, CreateTimer, 0 
SYSSTUBS_ENTRY5  134, CreateTimer, 0 
SYSSTUBS_ENTRY6  134, CreateTimer, 0 
SYSSTUBS_ENTRY7  134, CreateTimer, 0 
SYSSTUBS_ENTRY8  134, CreateTimer, 0 
SYSSTUBS_ENTRY1  135, CreateToken, 9 
SYSSTUBS_ENTRY2  135, CreateToken, 9 
SYSSTUBS_ENTRY3  135, CreateToken, 9 
SYSSTUBS_ENTRY4  135, CreateToken, 9 
SYSSTUBS_ENTRY5  135, CreateToken, 9 
SYSSTUBS_ENTRY6  135, CreateToken, 9 
SYSSTUBS_ENTRY7  135, CreateToken, 9 
SYSSTUBS_ENTRY8  135, CreateToken, 9 
SYSSTUBS_ENTRY1  136, CreateWaitablePort, 1 
SYSSTUBS_ENTRY2  136, CreateWaitablePort, 1 
SYSSTUBS_ENTRY3  136, CreateWaitablePort, 1 
SYSSTUBS_ENTRY4  136, CreateWaitablePort, 1 
SYSSTUBS_ENTRY5  136, CreateWaitablePort, 1 
SYSSTUBS_ENTRY6  136, CreateWaitablePort, 1 
SYSSTUBS_ENTRY7  136, CreateWaitablePort, 1 
SYSSTUBS_ENTRY8  136, CreateWaitablePort, 1 
SYSSTUBS_ENTRY1  137, DebugActiveProcess, 0 
SYSSTUBS_ENTRY2  137, DebugActiveProcess, 0 
SYSSTUBS_ENTRY3  137, DebugActiveProcess, 0 
SYSSTUBS_ENTRY4  137, DebugActiveProcess, 0 
SYSSTUBS_ENTRY5  137, DebugActiveProcess, 0 
SYSSTUBS_ENTRY6  137, DebugActiveProcess, 0 
SYSSTUBS_ENTRY7  137, DebugActiveProcess, 0 
SYSSTUBS_ENTRY8  137, DebugActiveProcess, 0 
SYSSTUBS_ENTRY1  138, DebugContinue, 0 
SYSSTUBS_ENTRY2  138, DebugContinue, 0 
SYSSTUBS_ENTRY3  138, DebugContinue, 0 
SYSSTUBS_ENTRY4  138, DebugContinue, 0 
SYSSTUBS_ENTRY5  138, DebugContinue, 0 
SYSSTUBS_ENTRY6  138, DebugContinue, 0 
SYSSTUBS_ENTRY7  138, DebugContinue, 0 
SYSSTUBS_ENTRY8  138, DebugContinue, 0 
SYSSTUBS_ENTRY1  139, DeleteAtom, 0 
SYSSTUBS_ENTRY2  139, DeleteAtom, 0 
SYSSTUBS_ENTRY3  139, DeleteAtom, 0 
SYSSTUBS_ENTRY4  139, DeleteAtom, 0 
SYSSTUBS_ENTRY5  139, DeleteAtom, 0 
SYSSTUBS_ENTRY6  139, DeleteAtom, 0 
SYSSTUBS_ENTRY7  139, DeleteAtom, 0 
SYSSTUBS_ENTRY8  139, DeleteAtom, 0 
SYSSTUBS_ENTRY1  140, DeleteBootEntry, 0 
SYSSTUBS_ENTRY2  140, DeleteBootEntry, 0 
SYSSTUBS_ENTRY3  140, DeleteBootEntry, 0 
SYSSTUBS_ENTRY4  140, DeleteBootEntry, 0 
SYSSTUBS_ENTRY5  140, DeleteBootEntry, 0 
SYSSTUBS_ENTRY6  140, DeleteBootEntry, 0 
SYSSTUBS_ENTRY7  140, DeleteBootEntry, 0 
SYSSTUBS_ENTRY8  140, DeleteBootEntry, 0 
SYSSTUBS_ENTRY1  141, DeleteDriverEntry, 0 
SYSSTUBS_ENTRY2  141, DeleteDriverEntry, 0 
SYSSTUBS_ENTRY3  141, DeleteDriverEntry, 0 
SYSSTUBS_ENTRY4  141, DeleteDriverEntry, 0 
SYSSTUBS_ENTRY5  141, DeleteDriverEntry, 0 
SYSSTUBS_ENTRY6  141, DeleteDriverEntry, 0 
SYSSTUBS_ENTRY7  141, DeleteDriverEntry, 0 
SYSSTUBS_ENTRY8  141, DeleteDriverEntry, 0 
SYSSTUBS_ENTRY1  142, DeleteFile, 0 
SYSSTUBS_ENTRY2  142, DeleteFile, 0 
SYSSTUBS_ENTRY3  142, DeleteFile, 0 
SYSSTUBS_ENTRY4  142, DeleteFile, 0 
SYSSTUBS_ENTRY5  142, DeleteFile, 0 
SYSSTUBS_ENTRY6  142, DeleteFile, 0 
SYSSTUBS_ENTRY7  142, DeleteFile, 0 
SYSSTUBS_ENTRY8  142, DeleteFile, 0 
SYSSTUBS_ENTRY1  143, DeleteKey, 0 
SYSSTUBS_ENTRY2  143, DeleteKey, 0 
SYSSTUBS_ENTRY3  143, DeleteKey, 0 
SYSSTUBS_ENTRY4  143, DeleteKey, 0 
SYSSTUBS_ENTRY5  143, DeleteKey, 0 
SYSSTUBS_ENTRY6  143, DeleteKey, 0 
SYSSTUBS_ENTRY7  143, DeleteKey, 0 
SYSSTUBS_ENTRY8  143, DeleteKey, 0 
SYSSTUBS_ENTRY1  144, DeleteObjectAuditAlarm, 0 
SYSSTUBS_ENTRY2  144, DeleteObjectAuditAlarm, 0 
SYSSTUBS_ENTRY3  144, DeleteObjectAuditAlarm, 0 
SYSSTUBS_ENTRY4  144, DeleteObjectAuditAlarm, 0 
SYSSTUBS_ENTRY5  144, DeleteObjectAuditAlarm, 0 
SYSSTUBS_ENTRY6  144, DeleteObjectAuditAlarm, 0 
SYSSTUBS_ENTRY7  144, DeleteObjectAuditAlarm, 0 
SYSSTUBS_ENTRY8  144, DeleteObjectAuditAlarm, 0 
SYSSTUBS_ENTRY1  145, DeleteValueKey, 0 
SYSSTUBS_ENTRY2  145, DeleteValueKey, 0 
SYSSTUBS_ENTRY3  145, DeleteValueKey, 0 
SYSSTUBS_ENTRY4  145, DeleteValueKey, 0 
SYSSTUBS_ENTRY5  145, DeleteValueKey, 0 
SYSSTUBS_ENTRY6  145, DeleteValueKey, 0 
SYSSTUBS_ENTRY7  145, DeleteValueKey, 0 
SYSSTUBS_ENTRY8  145, DeleteValueKey, 0 
SYSSTUBS_ENTRY1  146, DisplayString, 0 
SYSSTUBS_ENTRY2  146, DisplayString, 0 
SYSSTUBS_ENTRY3  146, DisplayString, 0 
SYSSTUBS_ENTRY4  146, DisplayString, 0 
SYSSTUBS_ENTRY5  146, DisplayString, 0 
SYSSTUBS_ENTRY6  146, DisplayString, 0 
SYSSTUBS_ENTRY7  146, DisplayString, 0 
SYSSTUBS_ENTRY8  146, DisplayString, 0 
SYSSTUBS_ENTRY1  147, EnumerateBootEntries, 0 
SYSSTUBS_ENTRY2  147, EnumerateBootEntries, 0 
SYSSTUBS_ENTRY3  147, EnumerateBootEntries, 0 
SYSSTUBS_ENTRY4  147, EnumerateBootEntries, 0 
SYSSTUBS_ENTRY5  147, EnumerateBootEntries, 0 
SYSSTUBS_ENTRY6  147, EnumerateBootEntries, 0 
SYSSTUBS_ENTRY7  147, EnumerateBootEntries, 0 
SYSSTUBS_ENTRY8  147, EnumerateBootEntries, 0 
SYSSTUBS_ENTRY1  148, EnumerateDriverEntries, 0 
SYSSTUBS_ENTRY2  148, EnumerateDriverEntries, 0 
SYSSTUBS_ENTRY3  148, EnumerateDriverEntries, 0 
SYSSTUBS_ENTRY4  148, EnumerateDriverEntries, 0 
SYSSTUBS_ENTRY5  148, EnumerateDriverEntries, 0 
SYSSTUBS_ENTRY6  148, EnumerateDriverEntries, 0 
SYSSTUBS_ENTRY7  148, EnumerateDriverEntries, 0 
SYSSTUBS_ENTRY8  148, EnumerateDriverEntries, 0 
SYSSTUBS_ENTRY1  149, EnumerateSystemEnvironmentValuesEx, 0 
SYSSTUBS_ENTRY2  149, EnumerateSystemEnvironmentValuesEx, 0 
SYSSTUBS_ENTRY3  149, EnumerateSystemEnvironmentValuesEx, 0 
SYSSTUBS_ENTRY4  149, EnumerateSystemEnvironmentValuesEx, 0 
SYSSTUBS_ENTRY5  149, EnumerateSystemEnvironmentValuesEx, 0 
SYSSTUBS_ENTRY6  149, EnumerateSystemEnvironmentValuesEx, 0 
SYSSTUBS_ENTRY7  149, EnumerateSystemEnvironmentValuesEx, 0 
SYSSTUBS_ENTRY8  149, EnumerateSystemEnvironmentValuesEx, 0 
SYSSTUBS_ENTRY1  150, ExtendSection, 0 
SYSSTUBS_ENTRY2  150, ExtendSection, 0 
SYSSTUBS_ENTRY3  150, ExtendSection, 0 
SYSSTUBS_ENTRY4  150, ExtendSection, 0 
SYSSTUBS_ENTRY5  150, ExtendSection, 0 
SYSSTUBS_ENTRY6  150, ExtendSection, 0 
SYSSTUBS_ENTRY7  150, ExtendSection, 0 
SYSSTUBS_ENTRY8  150, ExtendSection, 0 
SYSSTUBS_ENTRY1  151, FilterToken, 2 
SYSSTUBS_ENTRY2  151, FilterToken, 2 
SYSSTUBS_ENTRY3  151, FilterToken, 2 
SYSSTUBS_ENTRY4  151, FilterToken, 2 
SYSSTUBS_ENTRY5  151, FilterToken, 2 
SYSSTUBS_ENTRY6  151, FilterToken, 2 
SYSSTUBS_ENTRY7  151, FilterToken, 2 
SYSSTUBS_ENTRY8  151, FilterToken, 2 
SYSSTUBS_ENTRY1  152, FlushInstructionCache, 0 
SYSSTUBS_ENTRY2  152, FlushInstructionCache, 0 
SYSSTUBS_ENTRY3  152, FlushInstructionCache, 0 
SYSSTUBS_ENTRY4  152, FlushInstructionCache, 0 
SYSSTUBS_ENTRY5  152, FlushInstructionCache, 0 
SYSSTUBS_ENTRY6  152, FlushInstructionCache, 0 
SYSSTUBS_ENTRY7  152, FlushInstructionCache, 0 
SYSSTUBS_ENTRY8  152, FlushInstructionCache, 0 
SYSSTUBS_ENTRY1  153, FlushKey, 0 
SYSSTUBS_ENTRY2  153, FlushKey, 0 
SYSSTUBS_ENTRY3  153, FlushKey, 0 
SYSSTUBS_ENTRY4  153, FlushKey, 0 
SYSSTUBS_ENTRY5  153, FlushKey, 0 
SYSSTUBS_ENTRY6  153, FlushKey, 0 
SYSSTUBS_ENTRY7  153, FlushKey, 0 
SYSSTUBS_ENTRY8  153, FlushKey, 0 
SYSSTUBS_ENTRY1  154, FlushVirtualMemory, 0 
SYSSTUBS_ENTRY2  154, FlushVirtualMemory, 0 
SYSSTUBS_ENTRY3  154, FlushVirtualMemory, 0 
SYSSTUBS_ENTRY4  154, FlushVirtualMemory, 0 
SYSSTUBS_ENTRY5  154, FlushVirtualMemory, 0 
SYSSTUBS_ENTRY6  154, FlushVirtualMemory, 0 
SYSSTUBS_ENTRY7  154, FlushVirtualMemory, 0 
SYSSTUBS_ENTRY8  154, FlushVirtualMemory, 0 
SYSSTUBS_ENTRY1  155, FlushWriteBuffer, 0 
SYSSTUBS_ENTRY2  155, FlushWriteBuffer, 0 
SYSSTUBS_ENTRY3  155, FlushWriteBuffer, 0 
SYSSTUBS_ENTRY4  155, FlushWriteBuffer, 0 
SYSSTUBS_ENTRY5  155, FlushWriteBuffer, 0 
SYSSTUBS_ENTRY6  155, FlushWriteBuffer, 0 
SYSSTUBS_ENTRY7  155, FlushWriteBuffer, 0 
SYSSTUBS_ENTRY8  155, FlushWriteBuffer, 0 
SYSSTUBS_ENTRY1  156, FreeUserPhysicalPages, 0 
SYSSTUBS_ENTRY2  156, FreeUserPhysicalPages, 0 
SYSSTUBS_ENTRY3  156, FreeUserPhysicalPages, 0 
SYSSTUBS_ENTRY4  156, FreeUserPhysicalPages, 0 
SYSSTUBS_ENTRY5  156, FreeUserPhysicalPages, 0 
SYSSTUBS_ENTRY6  156, FreeUserPhysicalPages, 0 
SYSSTUBS_ENTRY7  156, FreeUserPhysicalPages, 0 
SYSSTUBS_ENTRY8  156, FreeUserPhysicalPages, 0 
SYSSTUBS_ENTRY1  157, GetContextThread, 0 
SYSSTUBS_ENTRY2  157, GetContextThread, 0 
SYSSTUBS_ENTRY3  157, GetContextThread, 0 
SYSSTUBS_ENTRY4  157, GetContextThread, 0 
SYSSTUBS_ENTRY5  157, GetContextThread, 0 
SYSSTUBS_ENTRY6  157, GetContextThread, 0 
SYSSTUBS_ENTRY7  157, GetContextThread, 0 
SYSSTUBS_ENTRY8  157, GetContextThread, 0 
SYSSTUBS_ENTRY1  158, GetCurrentProcessorNumber, 0 
SYSSTUBS_ENTRY2  158, GetCurrentProcessorNumber, 0 
SYSSTUBS_ENTRY3  158, GetCurrentProcessorNumber, 0 
SYSSTUBS_ENTRY4  158, GetCurrentProcessorNumber, 0 
SYSSTUBS_ENTRY5  158, GetCurrentProcessorNumber, 0 
SYSSTUBS_ENTRY6  158, GetCurrentProcessorNumber, 0 
SYSSTUBS_ENTRY7  158, GetCurrentProcessorNumber, 0 
SYSSTUBS_ENTRY8  158, GetCurrentProcessorNumber, 0 
SYSSTUBS_ENTRY1  159, GetDevicePowerState, 0 
SYSSTUBS_ENTRY2  159, GetDevicePowerState, 0 
SYSSTUBS_ENTRY3  159, GetDevicePowerState, 0 
SYSSTUBS_ENTRY4  159, GetDevicePowerState, 0 
SYSSTUBS_ENTRY5  159, GetDevicePowerState, 0 
SYSSTUBS_ENTRY6  159, GetDevicePowerState, 0 
SYSSTUBS_ENTRY7  159, GetDevicePowerState, 0 
SYSSTUBS_ENTRY8  159, GetDevicePowerState, 0 
SYSSTUBS_ENTRY1  160, GetPlugPlayEvent, 0 
SYSSTUBS_ENTRY2  160, GetPlugPlayEvent, 0 
SYSSTUBS_ENTRY3  160, GetPlugPlayEvent, 0 
SYSSTUBS_ENTRY4  160, GetPlugPlayEvent, 0 
SYSSTUBS_ENTRY5  160, GetPlugPlayEvent, 0 
SYSSTUBS_ENTRY6  160, GetPlugPlayEvent, 0 
SYSSTUBS_ENTRY7  160, GetPlugPlayEvent, 0 
SYSSTUBS_ENTRY8  160, GetPlugPlayEvent, 0 
SYSSTUBS_ENTRY1  161, GetWriteWatch, 3 
SYSSTUBS_ENTRY2  161, GetWriteWatch, 3 
SYSSTUBS_ENTRY3  161, GetWriteWatch, 3 
SYSSTUBS_ENTRY4  161, GetWriteWatch, 3 
SYSSTUBS_ENTRY5  161, GetWriteWatch, 3 
SYSSTUBS_ENTRY6  161, GetWriteWatch, 3 
SYSSTUBS_ENTRY7  161, GetWriteWatch, 3 
SYSSTUBS_ENTRY8  161, GetWriteWatch, 3 
SYSSTUBS_ENTRY1  162, ImpersonateAnonymousToken, 0 
SYSSTUBS_ENTRY2  162, ImpersonateAnonymousToken, 0 
SYSSTUBS_ENTRY3  162, ImpersonateAnonymousToken, 0 
SYSSTUBS_ENTRY4  162, ImpersonateAnonymousToken, 0 
SYSSTUBS_ENTRY5  162, ImpersonateAnonymousToken, 0 
SYSSTUBS_ENTRY6  162, ImpersonateAnonymousToken, 0 
SYSSTUBS_ENTRY7  162, ImpersonateAnonymousToken, 0 
SYSSTUBS_ENTRY8  162, ImpersonateAnonymousToken, 0 
SYSSTUBS_ENTRY1  163, ImpersonateThread, 0 
SYSSTUBS_ENTRY2  163, ImpersonateThread, 0 
SYSSTUBS_ENTRY3  163, ImpersonateThread, 0 
SYSSTUBS_ENTRY4  163, ImpersonateThread, 0 
SYSSTUBS_ENTRY5  163, ImpersonateThread, 0 
SYSSTUBS_ENTRY6  163, ImpersonateThread, 0 
SYSSTUBS_ENTRY7  163, ImpersonateThread, 0 
SYSSTUBS_ENTRY8  163, ImpersonateThread, 0 
SYSSTUBS_ENTRY1  164, InitializeRegistry, 0 
SYSSTUBS_ENTRY2  164, InitializeRegistry, 0 
SYSSTUBS_ENTRY3  164, InitializeRegistry, 0 
SYSSTUBS_ENTRY4  164, InitializeRegistry, 0 
SYSSTUBS_ENTRY5  164, InitializeRegistry, 0 
SYSSTUBS_ENTRY6  164, InitializeRegistry, 0 
SYSSTUBS_ENTRY7  164, InitializeRegistry, 0 
SYSSTUBS_ENTRY8  164, InitializeRegistry, 0 
SYSSTUBS_ENTRY1  165, InitiatePowerAction, 0 
SYSSTUBS_ENTRY2  165, InitiatePowerAction, 0 
SYSSTUBS_ENTRY3  165, InitiatePowerAction, 0 
SYSSTUBS_ENTRY4  165, InitiatePowerAction, 0 
SYSSTUBS_ENTRY5  165, InitiatePowerAction, 0 
SYSSTUBS_ENTRY6  165, InitiatePowerAction, 0 
SYSSTUBS_ENTRY7  165, InitiatePowerAction, 0 
SYSSTUBS_ENTRY8  165, InitiatePowerAction, 0 
SYSSTUBS_ENTRY1  166, IsSystemResumeAutomatic, 0 
SYSSTUBS_ENTRY2  166, IsSystemResumeAutomatic, 0 
SYSSTUBS_ENTRY3  166, IsSystemResumeAutomatic, 0 
SYSSTUBS_ENTRY4  166, IsSystemResumeAutomatic, 0 
SYSSTUBS_ENTRY5  166, IsSystemResumeAutomatic, 0 
SYSSTUBS_ENTRY6  166, IsSystemResumeAutomatic, 0 
SYSSTUBS_ENTRY7  166, IsSystemResumeAutomatic, 0 
SYSSTUBS_ENTRY8  166, IsSystemResumeAutomatic, 0 
SYSSTUBS_ENTRY1  167, ListenPort, 0 
SYSSTUBS_ENTRY2  167, ListenPort, 0 
SYSSTUBS_ENTRY3  167, ListenPort, 0 
SYSSTUBS_ENTRY4  167, ListenPort, 0 
SYSSTUBS_ENTRY5  167, ListenPort, 0 
SYSSTUBS_ENTRY6  167, ListenPort, 0 
SYSSTUBS_ENTRY7  167, ListenPort, 0 
SYSSTUBS_ENTRY8  167, ListenPort, 0 
SYSSTUBS_ENTRY1  168, LoadDriver, 0 
SYSSTUBS_ENTRY2  168, LoadDriver, 0 
SYSSTUBS_ENTRY3  168, LoadDriver, 0 
SYSSTUBS_ENTRY4  168, LoadDriver, 0 
SYSSTUBS_ENTRY5  168, LoadDriver, 0 
SYSSTUBS_ENTRY6  168, LoadDriver, 0 
SYSSTUBS_ENTRY7  168, LoadDriver, 0 
SYSSTUBS_ENTRY8  168, LoadDriver, 0 
SYSSTUBS_ENTRY1  169, LoadKey, 0 
SYSSTUBS_ENTRY2  169, LoadKey, 0 
SYSSTUBS_ENTRY3  169, LoadKey, 0 
SYSSTUBS_ENTRY4  169, LoadKey, 0 
SYSSTUBS_ENTRY5  169, LoadKey, 0 
SYSSTUBS_ENTRY6  169, LoadKey, 0 
SYSSTUBS_ENTRY7  169, LoadKey, 0 
SYSSTUBS_ENTRY8  169, LoadKey, 0 
SYSSTUBS_ENTRY1  170, LoadKey2, 0 
SYSSTUBS_ENTRY2  170, LoadKey2, 0 
SYSSTUBS_ENTRY3  170, LoadKey2, 0 
SYSSTUBS_ENTRY4  170, LoadKey2, 0 
SYSSTUBS_ENTRY5  170, LoadKey2, 0 
SYSSTUBS_ENTRY6  170, LoadKey2, 0 
SYSSTUBS_ENTRY7  170, LoadKey2, 0 
SYSSTUBS_ENTRY8  170, LoadKey2, 0 
SYSSTUBS_ENTRY1  171, LoadKeyEx, 0 
SYSSTUBS_ENTRY2  171, LoadKeyEx, 0 
SYSSTUBS_ENTRY3  171, LoadKeyEx, 0 
SYSSTUBS_ENTRY4  171, LoadKeyEx, 0 
SYSSTUBS_ENTRY5  171, LoadKeyEx, 0 
SYSSTUBS_ENTRY6  171, LoadKeyEx, 0 
SYSSTUBS_ENTRY7  171, LoadKeyEx, 0 
SYSSTUBS_ENTRY8  171, LoadKeyEx, 0 
SYSSTUBS_ENTRY1  172, LockFile, 6 
SYSSTUBS_ENTRY2  172, LockFile, 6 
SYSSTUBS_ENTRY3  172, LockFile, 6 
SYSSTUBS_ENTRY4  172, LockFile, 6 
SYSSTUBS_ENTRY5  172, LockFile, 6 
SYSSTUBS_ENTRY6  172, LockFile, 6 
SYSSTUBS_ENTRY7  172, LockFile, 6 
SYSSTUBS_ENTRY8  172, LockFile, 6 
SYSSTUBS_ENTRY1  173, LockProductActivationKeys, 0 
SYSSTUBS_ENTRY2  173, LockProductActivationKeys, 0 
SYSSTUBS_ENTRY3  173, LockProductActivationKeys, 0 
SYSSTUBS_ENTRY4  173, LockProductActivationKeys, 0 
SYSSTUBS_ENTRY5  173, LockProductActivationKeys, 0 
SYSSTUBS_ENTRY6  173, LockProductActivationKeys, 0 
SYSSTUBS_ENTRY7  173, LockProductActivationKeys, 0 
SYSSTUBS_ENTRY8  173, LockProductActivationKeys, 0 
SYSSTUBS_ENTRY1  174, LockRegistryKey, 0 
SYSSTUBS_ENTRY2  174, LockRegistryKey, 0 
SYSSTUBS_ENTRY3  174, LockRegistryKey, 0 
SYSSTUBS_ENTRY4  174, LockRegistryKey, 0 
SYSSTUBS_ENTRY5  174, LockRegistryKey, 0 
SYSSTUBS_ENTRY6  174, LockRegistryKey, 0 
SYSSTUBS_ENTRY7  174, LockRegistryKey, 0 
SYSSTUBS_ENTRY8  174, LockRegistryKey, 0 
SYSSTUBS_ENTRY1  175, LockVirtualMemory, 0 
SYSSTUBS_ENTRY2  175, LockVirtualMemory, 0 
SYSSTUBS_ENTRY3  175, LockVirtualMemory, 0 
SYSSTUBS_ENTRY4  175, LockVirtualMemory, 0 
SYSSTUBS_ENTRY5  175, LockVirtualMemory, 0 
SYSSTUBS_ENTRY6  175, LockVirtualMemory, 0 
SYSSTUBS_ENTRY7  175, LockVirtualMemory, 0 
SYSSTUBS_ENTRY8  175, LockVirtualMemory, 0 
SYSSTUBS_ENTRY1  176, MakePermanentObject, 0 
SYSSTUBS_ENTRY2  176, MakePermanentObject, 0 
SYSSTUBS_ENTRY3  176, MakePermanentObject, 0 
SYSSTUBS_ENTRY4  176, MakePermanentObject, 0 
SYSSTUBS_ENTRY5  176, MakePermanentObject, 0 
SYSSTUBS_ENTRY6  176, MakePermanentObject, 0 
SYSSTUBS_ENTRY7  176, MakePermanentObject, 0 
SYSSTUBS_ENTRY8  176, MakePermanentObject, 0 
SYSSTUBS_ENTRY1  177, MakeTemporaryObject, 0 
SYSSTUBS_ENTRY2  177, MakeTemporaryObject, 0 
SYSSTUBS_ENTRY3  177, MakeTemporaryObject, 0 
SYSSTUBS_ENTRY4  177, MakeTemporaryObject, 0 
SYSSTUBS_ENTRY5  177, MakeTemporaryObject, 0 
SYSSTUBS_ENTRY6  177, MakeTemporaryObject, 0 
SYSSTUBS_ENTRY7  177, MakeTemporaryObject, 0 
SYSSTUBS_ENTRY8  177, MakeTemporaryObject, 0 
SYSSTUBS_ENTRY1  178, MapUserPhysicalPages, 0 
SYSSTUBS_ENTRY2  178, MapUserPhysicalPages, 0 
SYSSTUBS_ENTRY3  178, MapUserPhysicalPages, 0 
SYSSTUBS_ENTRY4  178, MapUserPhysicalPages, 0 
SYSSTUBS_ENTRY5  178, MapUserPhysicalPages, 0 
SYSSTUBS_ENTRY6  178, MapUserPhysicalPages, 0 
SYSSTUBS_ENTRY7  178, MapUserPhysicalPages, 0 
SYSSTUBS_ENTRY8  178, MapUserPhysicalPages, 0 
SYSSTUBS_ENTRY1  179, ModifyBootEntry, 0 
SYSSTUBS_ENTRY2  179, ModifyBootEntry, 0 
SYSSTUBS_ENTRY3  179, ModifyBootEntry, 0 
SYSSTUBS_ENTRY4  179, ModifyBootEntry, 0 
SYSSTUBS_ENTRY5  179, ModifyBootEntry, 0 
SYSSTUBS_ENTRY6  179, ModifyBootEntry, 0 
SYSSTUBS_ENTRY7  179, ModifyBootEntry, 0 
SYSSTUBS_ENTRY8  179, ModifyBootEntry, 0 
SYSSTUBS_ENTRY1  180, ModifyDriverEntry, 0 
SYSSTUBS_ENTRY2  180, ModifyDriverEntry, 0 
SYSSTUBS_ENTRY3  180, ModifyDriverEntry, 0 
SYSSTUBS_ENTRY4  180, ModifyDriverEntry, 0 
SYSSTUBS_ENTRY5  180, ModifyDriverEntry, 0 
SYSSTUBS_ENTRY6  180, ModifyDriverEntry, 0 
SYSSTUBS_ENTRY7  180, ModifyDriverEntry, 0 
SYSSTUBS_ENTRY8  180, ModifyDriverEntry, 0 
SYSSTUBS_ENTRY1  181, NotifyChangeDirectoryFile, 5 
SYSSTUBS_ENTRY2  181, NotifyChangeDirectoryFile, 5 
SYSSTUBS_ENTRY3  181, NotifyChangeDirectoryFile, 5 
SYSSTUBS_ENTRY4  181, NotifyChangeDirectoryFile, 5 
SYSSTUBS_ENTRY5  181, NotifyChangeDirectoryFile, 5 
SYSSTUBS_ENTRY6  181, NotifyChangeDirectoryFile, 5 
SYSSTUBS_ENTRY7  181, NotifyChangeDirectoryFile, 5 
SYSSTUBS_ENTRY8  181, NotifyChangeDirectoryFile, 5 
SYSSTUBS_ENTRY1  182, NotifyChangeKey, 6 
SYSSTUBS_ENTRY2  182, NotifyChangeKey, 6 
SYSSTUBS_ENTRY3  182, NotifyChangeKey, 6 
SYSSTUBS_ENTRY4  182, NotifyChangeKey, 6 
SYSSTUBS_ENTRY5  182, NotifyChangeKey, 6 
SYSSTUBS_ENTRY6  182, NotifyChangeKey, 6 
SYSSTUBS_ENTRY7  182, NotifyChangeKey, 6 
SYSSTUBS_ENTRY8  182, NotifyChangeKey, 6 
SYSSTUBS_ENTRY1  183, NotifyChangeMultipleKeys, 8 
SYSSTUBS_ENTRY2  183, NotifyChangeMultipleKeys, 8 
SYSSTUBS_ENTRY3  183, NotifyChangeMultipleKeys, 8 
SYSSTUBS_ENTRY4  183, NotifyChangeMultipleKeys, 8 
SYSSTUBS_ENTRY5  183, NotifyChangeMultipleKeys, 8 
SYSSTUBS_ENTRY6  183, NotifyChangeMultipleKeys, 8 
SYSSTUBS_ENTRY7  183, NotifyChangeMultipleKeys, 8 
SYSSTUBS_ENTRY8  183, NotifyChangeMultipleKeys, 8 
SYSSTUBS_ENTRY1  184, OpenEventPair, 0 
SYSSTUBS_ENTRY2  184, OpenEventPair, 0 
SYSSTUBS_ENTRY3  184, OpenEventPair, 0 
SYSSTUBS_ENTRY4  184, OpenEventPair, 0 
SYSSTUBS_ENTRY5  184, OpenEventPair, 0 
SYSSTUBS_ENTRY6  184, OpenEventPair, 0 
SYSSTUBS_ENTRY7  184, OpenEventPair, 0 
SYSSTUBS_ENTRY8  184, OpenEventPair, 0 
SYSSTUBS_ENTRY1  185, OpenIoCompletion, 0 
SYSSTUBS_ENTRY2  185, OpenIoCompletion, 0 
SYSSTUBS_ENTRY3  185, OpenIoCompletion, 0 
SYSSTUBS_ENTRY4  185, OpenIoCompletion, 0 
SYSSTUBS_ENTRY5  185, OpenIoCompletion, 0 
SYSSTUBS_ENTRY6  185, OpenIoCompletion, 0 
SYSSTUBS_ENTRY7  185, OpenIoCompletion, 0 
SYSSTUBS_ENTRY8  185, OpenIoCompletion, 0 
SYSSTUBS_ENTRY1  186, OpenJobObject, 0 
SYSSTUBS_ENTRY2  186, OpenJobObject, 0 
SYSSTUBS_ENTRY3  186, OpenJobObject, 0 
SYSSTUBS_ENTRY4  186, OpenJobObject, 0 
SYSSTUBS_ENTRY5  186, OpenJobObject, 0 
SYSSTUBS_ENTRY6  186, OpenJobObject, 0 
SYSSTUBS_ENTRY7  186, OpenJobObject, 0 
SYSSTUBS_ENTRY8  186, OpenJobObject, 0 
SYSSTUBS_ENTRY1  187, OpenKeyedEvent, 0 
SYSSTUBS_ENTRY2  187, OpenKeyedEvent, 0 
SYSSTUBS_ENTRY3  187, OpenKeyedEvent, 0 
SYSSTUBS_ENTRY4  187, OpenKeyedEvent, 0 
SYSSTUBS_ENTRY5  187, OpenKeyedEvent, 0 
SYSSTUBS_ENTRY6  187, OpenKeyedEvent, 0 
SYSSTUBS_ENTRY7  187, OpenKeyedEvent, 0 
SYSSTUBS_ENTRY8  187, OpenKeyedEvent, 0 
SYSSTUBS_ENTRY1  188, OpenMutant, 0 
SYSSTUBS_ENTRY2  188, OpenMutant, 0 
SYSSTUBS_ENTRY3  188, OpenMutant, 0 
SYSSTUBS_ENTRY4  188, OpenMutant, 0 
SYSSTUBS_ENTRY5  188, OpenMutant, 0 
SYSSTUBS_ENTRY6  188, OpenMutant, 0 
SYSSTUBS_ENTRY7  188, OpenMutant, 0 
SYSSTUBS_ENTRY8  188, OpenMutant, 0 
SYSSTUBS_ENTRY1  189, OpenObjectAuditAlarm, 8 
SYSSTUBS_ENTRY2  189, OpenObjectAuditAlarm, 8 
SYSSTUBS_ENTRY3  189, OpenObjectAuditAlarm, 8 
SYSSTUBS_ENTRY4  189, OpenObjectAuditAlarm, 8 
SYSSTUBS_ENTRY5  189, OpenObjectAuditAlarm, 8 
SYSSTUBS_ENTRY6  189, OpenObjectAuditAlarm, 8 
SYSSTUBS_ENTRY7  189, OpenObjectAuditAlarm, 8 
SYSSTUBS_ENTRY8  189, OpenObjectAuditAlarm, 8 
SYSSTUBS_ENTRY1  190, OpenProcessToken, 0 
SYSSTUBS_ENTRY2  190, OpenProcessToken, 0 
SYSSTUBS_ENTRY3  190, OpenProcessToken, 0 
SYSSTUBS_ENTRY4  190, OpenProcessToken, 0 
SYSSTUBS_ENTRY5  190, OpenProcessToken, 0 
SYSSTUBS_ENTRY6  190, OpenProcessToken, 0 
SYSSTUBS_ENTRY7  190, OpenProcessToken, 0 
SYSSTUBS_ENTRY8  190, OpenProcessToken, 0 
SYSSTUBS_ENTRY1  191, OpenSemaphore, 0 
SYSSTUBS_ENTRY2  191, OpenSemaphore, 0 
SYSSTUBS_ENTRY3  191, OpenSemaphore, 0 
SYSSTUBS_ENTRY4  191, OpenSemaphore, 0 
SYSSTUBS_ENTRY5  191, OpenSemaphore, 0 
SYSSTUBS_ENTRY6  191, OpenSemaphore, 0 
SYSSTUBS_ENTRY7  191, OpenSemaphore, 0 
SYSSTUBS_ENTRY8  191, OpenSemaphore, 0 
SYSSTUBS_ENTRY1  192, OpenSymbolicLinkObject, 0 
SYSSTUBS_ENTRY2  192, OpenSymbolicLinkObject, 0 
SYSSTUBS_ENTRY3  192, OpenSymbolicLinkObject, 0 
SYSSTUBS_ENTRY4  192, OpenSymbolicLinkObject, 0 
SYSSTUBS_ENTRY5  192, OpenSymbolicLinkObject, 0 
SYSSTUBS_ENTRY6  192, OpenSymbolicLinkObject, 0 
SYSSTUBS_ENTRY7  192, OpenSymbolicLinkObject, 0 
SYSSTUBS_ENTRY8  192, OpenSymbolicLinkObject, 0 
SYSSTUBS_ENTRY1  193, OpenThread, 0 
SYSSTUBS_ENTRY2  193, OpenThread, 0 
SYSSTUBS_ENTRY3  193, OpenThread, 0 
SYSSTUBS_ENTRY4  193, OpenThread, 0 
SYSSTUBS_ENTRY5  193, OpenThread, 0 
SYSSTUBS_ENTRY6  193, OpenThread, 0 
SYSSTUBS_ENTRY7  193, OpenThread, 0 
SYSSTUBS_ENTRY8  193, OpenThread, 0 
SYSSTUBS_ENTRY1  194, OpenTimer, 0 
SYSSTUBS_ENTRY2  194, OpenTimer, 0 
SYSSTUBS_ENTRY3  194, OpenTimer, 0 
SYSSTUBS_ENTRY4  194, OpenTimer, 0 
SYSSTUBS_ENTRY5  194, OpenTimer, 0 
SYSSTUBS_ENTRY6  194, OpenTimer, 0 
SYSSTUBS_ENTRY7  194, OpenTimer, 0 
SYSSTUBS_ENTRY8  194, OpenTimer, 0 
SYSSTUBS_ENTRY1  195, PlugPlayControl, 0 
SYSSTUBS_ENTRY2  195, PlugPlayControl, 0 
SYSSTUBS_ENTRY3  195, PlugPlayControl, 0 
SYSSTUBS_ENTRY4  195, PlugPlayControl, 0 
SYSSTUBS_ENTRY5  195, PlugPlayControl, 0 
SYSSTUBS_ENTRY6  195, PlugPlayControl, 0 
SYSSTUBS_ENTRY7  195, PlugPlayControl, 0 
SYSSTUBS_ENTRY8  195, PlugPlayControl, 0 
SYSSTUBS_ENTRY1  196, PrivilegeCheck, 0 
SYSSTUBS_ENTRY2  196, PrivilegeCheck, 0 
SYSSTUBS_ENTRY3  196, PrivilegeCheck, 0 
SYSSTUBS_ENTRY4  196, PrivilegeCheck, 0 
SYSSTUBS_ENTRY5  196, PrivilegeCheck, 0 
SYSSTUBS_ENTRY6  196, PrivilegeCheck, 0 
SYSSTUBS_ENTRY7  196, PrivilegeCheck, 0 
SYSSTUBS_ENTRY8  196, PrivilegeCheck, 0 
SYSSTUBS_ENTRY1  197, PrivilegeObjectAuditAlarm, 2 
SYSSTUBS_ENTRY2  197, PrivilegeObjectAuditAlarm, 2 
SYSSTUBS_ENTRY3  197, PrivilegeObjectAuditAlarm, 2 
SYSSTUBS_ENTRY4  197, PrivilegeObjectAuditAlarm, 2 
SYSSTUBS_ENTRY5  197, PrivilegeObjectAuditAlarm, 2 
SYSSTUBS_ENTRY6  197, PrivilegeObjectAuditAlarm, 2 
SYSSTUBS_ENTRY7  197, PrivilegeObjectAuditAlarm, 2 
SYSSTUBS_ENTRY8  197, PrivilegeObjectAuditAlarm, 2 
SYSSTUBS_ENTRY1  198, PrivilegedServiceAuditAlarm, 1 
SYSSTUBS_ENTRY2  198, PrivilegedServiceAuditAlarm, 1 
SYSSTUBS_ENTRY3  198, PrivilegedServiceAuditAlarm, 1 
SYSSTUBS_ENTRY4  198, PrivilegedServiceAuditAlarm, 1 
SYSSTUBS_ENTRY5  198, PrivilegedServiceAuditAlarm, 1 
SYSSTUBS_ENTRY6  198, PrivilegedServiceAuditAlarm, 1 
SYSSTUBS_ENTRY7  198, PrivilegedServiceAuditAlarm, 1 
SYSSTUBS_ENTRY8  198, PrivilegedServiceAuditAlarm, 1 
SYSSTUBS_ENTRY1  199, PulseEvent, 0 
SYSSTUBS_ENTRY2  199, PulseEvent, 0 
SYSSTUBS_ENTRY3  199, PulseEvent, 0 
SYSSTUBS_ENTRY4  199, PulseEvent, 0 
SYSSTUBS_ENTRY5  199, PulseEvent, 0 
SYSSTUBS_ENTRY6  199, PulseEvent, 0 
SYSSTUBS_ENTRY7  199, PulseEvent, 0 
SYSSTUBS_ENTRY8  199, PulseEvent, 0 
SYSSTUBS_ENTRY1  200, QueryBootEntryOrder, 0 
SYSSTUBS_ENTRY2  200, QueryBootEntryOrder, 0 
SYSSTUBS_ENTRY3  200, QueryBootEntryOrder, 0 
SYSSTUBS_ENTRY4  200, QueryBootEntryOrder, 0 
SYSSTUBS_ENTRY5  200, QueryBootEntryOrder, 0 
SYSSTUBS_ENTRY6  200, QueryBootEntryOrder, 0 
SYSSTUBS_ENTRY7  200, QueryBootEntryOrder, 0 
SYSSTUBS_ENTRY8  200, QueryBootEntryOrder, 0 
SYSSTUBS_ENTRY1  201, QueryBootOptions, 0 
SYSSTUBS_ENTRY2  201, QueryBootOptions, 0 
SYSSTUBS_ENTRY3  201, QueryBootOptions, 0 
SYSSTUBS_ENTRY4  201, QueryBootOptions, 0 
SYSSTUBS_ENTRY5  201, QueryBootOptions, 0 
SYSSTUBS_ENTRY6  201, QueryBootOptions, 0 
SYSSTUBS_ENTRY7  201, QueryBootOptions, 0 
SYSSTUBS_ENTRY8  201, QueryBootOptions, 0 
SYSSTUBS_ENTRY1  202, QueryDebugFilterState, 0 
SYSSTUBS_ENTRY2  202, QueryDebugFilterState, 0 
SYSSTUBS_ENTRY3  202, QueryDebugFilterState, 0 
SYSSTUBS_ENTRY4  202, QueryDebugFilterState, 0 
SYSSTUBS_ENTRY5  202, QueryDebugFilterState, 0 
SYSSTUBS_ENTRY6  202, QueryDebugFilterState, 0 
SYSSTUBS_ENTRY7  202, QueryDebugFilterState, 0 
SYSSTUBS_ENTRY8  202, QueryDebugFilterState, 0 
SYSSTUBS_ENTRY1  203, QueryDirectoryObject, 3 
SYSSTUBS_ENTRY2  203, QueryDirectoryObject, 3 
SYSSTUBS_ENTRY3  203, QueryDirectoryObject, 3 
SYSSTUBS_ENTRY4  203, QueryDirectoryObject, 3 
SYSSTUBS_ENTRY5  203, QueryDirectoryObject, 3 
SYSSTUBS_ENTRY6  203, QueryDirectoryObject, 3 
SYSSTUBS_ENTRY7  203, QueryDirectoryObject, 3 
SYSSTUBS_ENTRY8  203, QueryDirectoryObject, 3 
SYSSTUBS_ENTRY1  204, QueryDriverEntryOrder, 0 
SYSSTUBS_ENTRY2  204, QueryDriverEntryOrder, 0 
SYSSTUBS_ENTRY3  204, QueryDriverEntryOrder, 0 
SYSSTUBS_ENTRY4  204, QueryDriverEntryOrder, 0 
SYSSTUBS_ENTRY5  204, QueryDriverEntryOrder, 0 
SYSSTUBS_ENTRY6  204, QueryDriverEntryOrder, 0 
SYSSTUBS_ENTRY7  204, QueryDriverEntryOrder, 0 
SYSSTUBS_ENTRY8  204, QueryDriverEntryOrder, 0 
SYSSTUBS_ENTRY1  205, QueryEaFile, 5 
SYSSTUBS_ENTRY2  205, QueryEaFile, 5 
SYSSTUBS_ENTRY3  205, QueryEaFile, 5 
SYSSTUBS_ENTRY4  205, QueryEaFile, 5 
SYSSTUBS_ENTRY5  205, QueryEaFile, 5 
SYSSTUBS_ENTRY6  205, QueryEaFile, 5 
SYSSTUBS_ENTRY7  205, QueryEaFile, 5 
SYSSTUBS_ENTRY8  205, QueryEaFile, 5 
SYSSTUBS_ENTRY1  206, QueryFullAttributesFile, 0 
SYSSTUBS_ENTRY2  206, QueryFullAttributesFile, 0 
SYSSTUBS_ENTRY3  206, QueryFullAttributesFile, 0 
SYSSTUBS_ENTRY4  206, QueryFullAttributesFile, 0 
SYSSTUBS_ENTRY5  206, QueryFullAttributesFile, 0 
SYSSTUBS_ENTRY6  206, QueryFullAttributesFile, 0 
SYSSTUBS_ENTRY7  206, QueryFullAttributesFile, 0 
SYSSTUBS_ENTRY8  206, QueryFullAttributesFile, 0 
SYSSTUBS_ENTRY1  207, QueryInformationAtom, 1 
SYSSTUBS_ENTRY2  207, QueryInformationAtom, 1 
SYSSTUBS_ENTRY3  207, QueryInformationAtom, 1 
SYSSTUBS_ENTRY4  207, QueryInformationAtom, 1 
SYSSTUBS_ENTRY5  207, QueryInformationAtom, 1 
SYSSTUBS_ENTRY6  207, QueryInformationAtom, 1 
SYSSTUBS_ENTRY7  207, QueryInformationAtom, 1 
SYSSTUBS_ENTRY8  207, QueryInformationAtom, 1 
SYSSTUBS_ENTRY1  208, QueryInformationJobObject, 1 
SYSSTUBS_ENTRY2  208, QueryInformationJobObject, 1 
SYSSTUBS_ENTRY3  208, QueryInformationJobObject, 1 
SYSSTUBS_ENTRY4  208, QueryInformationJobObject, 1 
SYSSTUBS_ENTRY5  208, QueryInformationJobObject, 1 
SYSSTUBS_ENTRY6  208, QueryInformationJobObject, 1 
SYSSTUBS_ENTRY7  208, QueryInformationJobObject, 1 
SYSSTUBS_ENTRY8  208, QueryInformationJobObject, 1 
SYSSTUBS_ENTRY1  209, QueryInformationPort, 1 
SYSSTUBS_ENTRY2  209, QueryInformationPort, 1 
SYSSTUBS_ENTRY3  209, QueryInformationPort, 1 
SYSSTUBS_ENTRY4  209, QueryInformationPort, 1 
SYSSTUBS_ENTRY5  209, QueryInformationPort, 1 
SYSSTUBS_ENTRY6  209, QueryInformationPort, 1 
SYSSTUBS_ENTRY7  209, QueryInformationPort, 1 
SYSSTUBS_ENTRY8  209, QueryInformationPort, 1 
SYSSTUBS_ENTRY1  210, QueryInstallUILanguage, 0 
SYSSTUBS_ENTRY2  210, QueryInstallUILanguage, 0 
SYSSTUBS_ENTRY3  210, QueryInstallUILanguage, 0 
SYSSTUBS_ENTRY4  210, QueryInstallUILanguage, 0 
SYSSTUBS_ENTRY5  210, QueryInstallUILanguage, 0 
SYSSTUBS_ENTRY6  210, QueryInstallUILanguage, 0 
SYSSTUBS_ENTRY7  210, QueryInstallUILanguage, 0 
SYSSTUBS_ENTRY8  210, QueryInstallUILanguage, 0 
SYSSTUBS_ENTRY1  211, QueryIntervalProfile, 0 
SYSSTUBS_ENTRY2  211, QueryIntervalProfile, 0 
SYSSTUBS_ENTRY3  211, QueryIntervalProfile, 0 
SYSSTUBS_ENTRY4  211, QueryIntervalProfile, 0 
SYSSTUBS_ENTRY5  211, QueryIntervalProfile, 0 
SYSSTUBS_ENTRY6  211, QueryIntervalProfile, 0 
SYSSTUBS_ENTRY7  211, QueryIntervalProfile, 0 
SYSSTUBS_ENTRY8  211, QueryIntervalProfile, 0 
SYSSTUBS_ENTRY1  212, QueryIoCompletion, 1 
SYSSTUBS_ENTRY2  212, QueryIoCompletion, 1 
SYSSTUBS_ENTRY3  212, QueryIoCompletion, 1 
SYSSTUBS_ENTRY4  212, QueryIoCompletion, 1 
SYSSTUBS_ENTRY5  212, QueryIoCompletion, 1 
SYSSTUBS_ENTRY6  212, QueryIoCompletion, 1 
SYSSTUBS_ENTRY7  212, QueryIoCompletion, 1 
SYSSTUBS_ENTRY8  212, QueryIoCompletion, 1 
SYSSTUBS_ENTRY1  213, QueryMultipleValueKey, 2 
SYSSTUBS_ENTRY2  213, QueryMultipleValueKey, 2 
SYSSTUBS_ENTRY3  213, QueryMultipleValueKey, 2 
SYSSTUBS_ENTRY4  213, QueryMultipleValueKey, 2 
SYSSTUBS_ENTRY5  213, QueryMultipleValueKey, 2 
SYSSTUBS_ENTRY6  213, QueryMultipleValueKey, 2 
SYSSTUBS_ENTRY7  213, QueryMultipleValueKey, 2 
SYSSTUBS_ENTRY8  213, QueryMultipleValueKey, 2 
SYSSTUBS_ENTRY1  214, QueryMutant, 1 
SYSSTUBS_ENTRY2  214, QueryMutant, 1 
SYSSTUBS_ENTRY3  214, QueryMutant, 1 
SYSSTUBS_ENTRY4  214, QueryMutant, 1 
SYSSTUBS_ENTRY5  214, QueryMutant, 1 
SYSSTUBS_ENTRY6  214, QueryMutant, 1 
SYSSTUBS_ENTRY7  214, QueryMutant, 1 
SYSSTUBS_ENTRY8  214, QueryMutant, 1 
SYSSTUBS_ENTRY1  215, QueryOpenSubKeys, 0 
SYSSTUBS_ENTRY2  215, QueryOpenSubKeys, 0 
SYSSTUBS_ENTRY3  215, QueryOpenSubKeys, 0 
SYSSTUBS_ENTRY4  215, QueryOpenSubKeys, 0 
SYSSTUBS_ENTRY5  215, QueryOpenSubKeys, 0 
SYSSTUBS_ENTRY6  215, QueryOpenSubKeys, 0 
SYSSTUBS_ENTRY7  215, QueryOpenSubKeys, 0 
SYSSTUBS_ENTRY8  215, QueryOpenSubKeys, 0 
SYSSTUBS_ENTRY1  216, QueryOpenSubKeysEx, 0 
SYSSTUBS_ENTRY2  216, QueryOpenSubKeysEx, 0 
SYSSTUBS_ENTRY3  216, QueryOpenSubKeysEx, 0 
SYSSTUBS_ENTRY4  216, QueryOpenSubKeysEx, 0 
SYSSTUBS_ENTRY5  216, QueryOpenSubKeysEx, 0 
SYSSTUBS_ENTRY6  216, QueryOpenSubKeysEx, 0 
SYSSTUBS_ENTRY7  216, QueryOpenSubKeysEx, 0 
SYSSTUBS_ENTRY8  216, QueryOpenSubKeysEx, 0 
SYSSTUBS_ENTRY1  217, QueryPortInformationProcess, 0 
SYSSTUBS_ENTRY2  217, QueryPortInformationProcess, 0 
SYSSTUBS_ENTRY3  217, QueryPortInformationProcess, 0 
SYSSTUBS_ENTRY4  217, QueryPortInformationProcess, 0 
SYSSTUBS_ENTRY5  217, QueryPortInformationProcess, 0 
SYSSTUBS_ENTRY6  217, QueryPortInformationProcess, 0 
SYSSTUBS_ENTRY7  217, QueryPortInformationProcess, 0 
SYSSTUBS_ENTRY8  217, QueryPortInformationProcess, 0 
SYSSTUBS_ENTRY1  218, QueryQuotaInformationFile, 5 
SYSSTUBS_ENTRY2  218, QueryQuotaInformationFile, 5 
SYSSTUBS_ENTRY3  218, QueryQuotaInformationFile, 5 
SYSSTUBS_ENTRY4  218, QueryQuotaInformationFile, 5 
SYSSTUBS_ENTRY5  218, QueryQuotaInformationFile, 5 
SYSSTUBS_ENTRY6  218, QueryQuotaInformationFile, 5 
SYSSTUBS_ENTRY7  218, QueryQuotaInformationFile, 5 
SYSSTUBS_ENTRY8  218, QueryQuotaInformationFile, 5 
SYSSTUBS_ENTRY1  219, QuerySecurityObject, 1 
SYSSTUBS_ENTRY2  219, QuerySecurityObject, 1 
SYSSTUBS_ENTRY3  219, QuerySecurityObject, 1 
SYSSTUBS_ENTRY4  219, QuerySecurityObject, 1 
SYSSTUBS_ENTRY5  219, QuerySecurityObject, 1 
SYSSTUBS_ENTRY6  219, QuerySecurityObject, 1 
SYSSTUBS_ENTRY7  219, QuerySecurityObject, 1 
SYSSTUBS_ENTRY8  219, QuerySecurityObject, 1 
SYSSTUBS_ENTRY1  220, QuerySemaphore, 1 
SYSSTUBS_ENTRY2  220, QuerySemaphore, 1 
SYSSTUBS_ENTRY3  220, QuerySemaphore, 1 
SYSSTUBS_ENTRY4  220, QuerySemaphore, 1 
SYSSTUBS_ENTRY5  220, QuerySemaphore, 1 
SYSSTUBS_ENTRY6  220, QuerySemaphore, 1 
SYSSTUBS_ENTRY7  220, QuerySemaphore, 1 
SYSSTUBS_ENTRY8  220, QuerySemaphore, 1 
SYSSTUBS_ENTRY1  221, QuerySymbolicLinkObject, 0 
SYSSTUBS_ENTRY2  221, QuerySymbolicLinkObject, 0 
SYSSTUBS_ENTRY3  221, QuerySymbolicLinkObject, 0 
SYSSTUBS_ENTRY4  221, QuerySymbolicLinkObject, 0 
SYSSTUBS_ENTRY5  221, QuerySymbolicLinkObject, 0 
SYSSTUBS_ENTRY6  221, QuerySymbolicLinkObject, 0 
SYSSTUBS_ENTRY7  221, QuerySymbolicLinkObject, 0 
SYSSTUBS_ENTRY8  221, QuerySymbolicLinkObject, 0 
SYSSTUBS_ENTRY1  222, QuerySystemEnvironmentValue, 0 
SYSSTUBS_ENTRY2  222, QuerySystemEnvironmentValue, 0 
SYSSTUBS_ENTRY3  222, QuerySystemEnvironmentValue, 0 
SYSSTUBS_ENTRY4  222, QuerySystemEnvironmentValue, 0 
SYSSTUBS_ENTRY5  222, QuerySystemEnvironmentValue, 0 
SYSSTUBS_ENTRY6  222, QuerySystemEnvironmentValue, 0 
SYSSTUBS_ENTRY7  222, QuerySystemEnvironmentValue, 0 
SYSSTUBS_ENTRY8  222, QuerySystemEnvironmentValue, 0 
SYSSTUBS_ENTRY1  223, QuerySystemEnvironmentValueEx, 1 
SYSSTUBS_ENTRY2  223, QuerySystemEnvironmentValueEx, 1 
SYSSTUBS_ENTRY3  223, QuerySystemEnvironmentValueEx, 1 
SYSSTUBS_ENTRY4  223, QuerySystemEnvironmentValueEx, 1 
SYSSTUBS_ENTRY5  223, QuerySystemEnvironmentValueEx, 1 
SYSSTUBS_ENTRY6  223, QuerySystemEnvironmentValueEx, 1 
SYSSTUBS_ENTRY7  223, QuerySystemEnvironmentValueEx, 1 
SYSSTUBS_ENTRY8  223, QuerySystemEnvironmentValueEx, 1 
SYSSTUBS_ENTRY1  224, QueryTimerResolution, 0 
SYSSTUBS_ENTRY2  224, QueryTimerResolution, 0 
SYSSTUBS_ENTRY3  224, QueryTimerResolution, 0 
SYSSTUBS_ENTRY4  224, QueryTimerResolution, 0 
SYSSTUBS_ENTRY5  224, QueryTimerResolution, 0 
SYSSTUBS_ENTRY6  224, QueryTimerResolution, 0 
SYSSTUBS_ENTRY7  224, QueryTimerResolution, 0 
SYSSTUBS_ENTRY8  224, QueryTimerResolution, 0 
SYSSTUBS_ENTRY1  225, RaiseException, 0 
SYSSTUBS_ENTRY2  225, RaiseException, 0 
SYSSTUBS_ENTRY3  225, RaiseException, 0 
SYSSTUBS_ENTRY4  225, RaiseException, 0 
SYSSTUBS_ENTRY5  225, RaiseException, 0 
SYSSTUBS_ENTRY6  225, RaiseException, 0 
SYSSTUBS_ENTRY7  225, RaiseException, 0 
SYSSTUBS_ENTRY8  225, RaiseException, 0 
SYSSTUBS_ENTRY1  226, RaiseHardError, 2 
SYSSTUBS_ENTRY2  226, RaiseHardError, 2 
SYSSTUBS_ENTRY3  226, RaiseHardError, 2 
SYSSTUBS_ENTRY4  226, RaiseHardError, 2 
SYSSTUBS_ENTRY5  226, RaiseHardError, 2 
SYSSTUBS_ENTRY6  226, RaiseHardError, 2 
SYSSTUBS_ENTRY7  226, RaiseHardError, 2 
SYSSTUBS_ENTRY8  226, RaiseHardError, 2 
SYSSTUBS_ENTRY1  227, RegisterThreadTerminatePort, 0 
SYSSTUBS_ENTRY2  227, RegisterThreadTerminatePort, 0 
SYSSTUBS_ENTRY3  227, RegisterThreadTerminatePort, 0 
SYSSTUBS_ENTRY4  227, RegisterThreadTerminatePort, 0 
SYSSTUBS_ENTRY5  227, RegisterThreadTerminatePort, 0 
SYSSTUBS_ENTRY6  227, RegisterThreadTerminatePort, 0 
SYSSTUBS_ENTRY7  227, RegisterThreadTerminatePort, 0 
SYSSTUBS_ENTRY8  227, RegisterThreadTerminatePort, 0 
SYSSTUBS_ENTRY1  228, ReleaseKeyedEvent, 0 
SYSSTUBS_ENTRY2  228, ReleaseKeyedEvent, 0 
SYSSTUBS_ENTRY3  228, ReleaseKeyedEvent, 0 
SYSSTUBS_ENTRY4  228, ReleaseKeyedEvent, 0 
SYSSTUBS_ENTRY5  228, ReleaseKeyedEvent, 0 
SYSSTUBS_ENTRY6  228, ReleaseKeyedEvent, 0 
SYSSTUBS_ENTRY7  228, ReleaseKeyedEvent, 0 
SYSSTUBS_ENTRY8  228, ReleaseKeyedEvent, 0 
SYSSTUBS_ENTRY1  229, RemoveProcessDebug, 0 
SYSSTUBS_ENTRY2  229, RemoveProcessDebug, 0 
SYSSTUBS_ENTRY3  229, RemoveProcessDebug, 0 
SYSSTUBS_ENTRY4  229, RemoveProcessDebug, 0 
SYSSTUBS_ENTRY5  229, RemoveProcessDebug, 0 
SYSSTUBS_ENTRY6  229, RemoveProcessDebug, 0 
SYSSTUBS_ENTRY7  229, RemoveProcessDebug, 0 
SYSSTUBS_ENTRY8  229, RemoveProcessDebug, 0 
SYSSTUBS_ENTRY1  230, RenameKey, 0 
SYSSTUBS_ENTRY2  230, RenameKey, 0 
SYSSTUBS_ENTRY3  230, RenameKey, 0 
SYSSTUBS_ENTRY4  230, RenameKey, 0 
SYSSTUBS_ENTRY5  230, RenameKey, 0 
SYSSTUBS_ENTRY6  230, RenameKey, 0 
SYSSTUBS_ENTRY7  230, RenameKey, 0 
SYSSTUBS_ENTRY8  230, RenameKey, 0 
SYSSTUBS_ENTRY1  231, ReplaceKey, 0 
SYSSTUBS_ENTRY2  231, ReplaceKey, 0 
SYSSTUBS_ENTRY3  231, ReplaceKey, 0 
SYSSTUBS_ENTRY4  231, ReplaceKey, 0 
SYSSTUBS_ENTRY5  231, ReplaceKey, 0 
SYSSTUBS_ENTRY6  231, ReplaceKey, 0 
SYSSTUBS_ENTRY7  231, ReplaceKey, 0 
SYSSTUBS_ENTRY8  231, ReplaceKey, 0 
SYSSTUBS_ENTRY1  232, ReplyWaitReplyPort, 0 
SYSSTUBS_ENTRY2  232, ReplyWaitReplyPort, 0 
SYSSTUBS_ENTRY3  232, ReplyWaitReplyPort, 0 
SYSSTUBS_ENTRY4  232, ReplyWaitReplyPort, 0 
SYSSTUBS_ENTRY5  232, ReplyWaitReplyPort, 0 
SYSSTUBS_ENTRY6  232, ReplyWaitReplyPort, 0 
SYSSTUBS_ENTRY7  232, ReplyWaitReplyPort, 0 
SYSSTUBS_ENTRY8  232, ReplyWaitReplyPort, 0 
SYSSTUBS_ENTRY1  233, RequestDeviceWakeup, 0 
SYSSTUBS_ENTRY2  233, RequestDeviceWakeup, 0 
SYSSTUBS_ENTRY3  233, RequestDeviceWakeup, 0 
SYSSTUBS_ENTRY4  233, RequestDeviceWakeup, 0 
SYSSTUBS_ENTRY5  233, RequestDeviceWakeup, 0 
SYSSTUBS_ENTRY6  233, RequestDeviceWakeup, 0 
SYSSTUBS_ENTRY7  233, RequestDeviceWakeup, 0 
SYSSTUBS_ENTRY8  233, RequestDeviceWakeup, 0 
SYSSTUBS_ENTRY1  234, RequestPort, 0 
SYSSTUBS_ENTRY2  234, RequestPort, 0 
SYSSTUBS_ENTRY3  234, RequestPort, 0 
SYSSTUBS_ENTRY4  234, RequestPort, 0 
SYSSTUBS_ENTRY5  234, RequestPort, 0 
SYSSTUBS_ENTRY6  234, RequestPort, 0 
SYSSTUBS_ENTRY7  234, RequestPort, 0 
SYSSTUBS_ENTRY8  234, RequestPort, 0 
SYSSTUBS_ENTRY1  235, RequestWakeupLatency, 0 
SYSSTUBS_ENTRY2  235, RequestWakeupLatency, 0 
SYSSTUBS_ENTRY3  235, RequestWakeupLatency, 0 
SYSSTUBS_ENTRY4  235, RequestWakeupLatency, 0 
SYSSTUBS_ENTRY5  235, RequestWakeupLatency, 0 
SYSSTUBS_ENTRY6  235, RequestWakeupLatency, 0 
SYSSTUBS_ENTRY7  235, RequestWakeupLatency, 0 
SYSSTUBS_ENTRY8  235, RequestWakeupLatency, 0 
SYSSTUBS_ENTRY1  236, ResetEvent, 0 
SYSSTUBS_ENTRY2  236, ResetEvent, 0 
SYSSTUBS_ENTRY3  236, ResetEvent, 0 
SYSSTUBS_ENTRY4  236, ResetEvent, 0 
SYSSTUBS_ENTRY5  236, ResetEvent, 0 
SYSSTUBS_ENTRY6  236, ResetEvent, 0 
SYSSTUBS_ENTRY7  236, ResetEvent, 0 
SYSSTUBS_ENTRY8  236, ResetEvent, 0 
SYSSTUBS_ENTRY1  237, ResetWriteWatch, 0 
SYSSTUBS_ENTRY2  237, ResetWriteWatch, 0 
SYSSTUBS_ENTRY3  237, ResetWriteWatch, 0 
SYSSTUBS_ENTRY4  237, ResetWriteWatch, 0 
SYSSTUBS_ENTRY5  237, ResetWriteWatch, 0 
SYSSTUBS_ENTRY6  237, ResetWriteWatch, 0 
SYSSTUBS_ENTRY7  237, ResetWriteWatch, 0 
SYSSTUBS_ENTRY8  237, ResetWriteWatch, 0 
SYSSTUBS_ENTRY1  238, RestoreKey, 0 
SYSSTUBS_ENTRY2  238, RestoreKey, 0 
SYSSTUBS_ENTRY3  238, RestoreKey, 0 
SYSSTUBS_ENTRY4  238, RestoreKey, 0 
SYSSTUBS_ENTRY5  238, RestoreKey, 0 
SYSSTUBS_ENTRY6  238, RestoreKey, 0 
SYSSTUBS_ENTRY7  238, RestoreKey, 0 
SYSSTUBS_ENTRY8  238, RestoreKey, 0 
SYSSTUBS_ENTRY1  239, ResumeProcess, 0 
SYSSTUBS_ENTRY2  239, ResumeProcess, 0 
SYSSTUBS_ENTRY3  239, ResumeProcess, 0 
SYSSTUBS_ENTRY4  239, ResumeProcess, 0 
SYSSTUBS_ENTRY5  239, ResumeProcess, 0 
SYSSTUBS_ENTRY6  239, ResumeProcess, 0 
SYSSTUBS_ENTRY7  239, ResumeProcess, 0 
SYSSTUBS_ENTRY8  239, ResumeProcess, 0 
SYSSTUBS_ENTRY1  240, SaveKey, 0 
SYSSTUBS_ENTRY2  240, SaveKey, 0 
SYSSTUBS_ENTRY3  240, SaveKey, 0 
SYSSTUBS_ENTRY4  240, SaveKey, 0 
SYSSTUBS_ENTRY5  240, SaveKey, 0 
SYSSTUBS_ENTRY6  240, SaveKey, 0 
SYSSTUBS_ENTRY7  240, SaveKey, 0 
SYSSTUBS_ENTRY8  240, SaveKey, 0 
SYSSTUBS_ENTRY1  241, SaveKeyEx, 0 
SYSSTUBS_ENTRY2  241, SaveKeyEx, 0 
SYSSTUBS_ENTRY3  241, SaveKeyEx, 0 
SYSSTUBS_ENTRY4  241, SaveKeyEx, 0 
SYSSTUBS_ENTRY5  241, SaveKeyEx, 0 
SYSSTUBS_ENTRY6  241, SaveKeyEx, 0 
SYSSTUBS_ENTRY7  241, SaveKeyEx, 0 
SYSSTUBS_ENTRY8  241, SaveKeyEx, 0 
SYSSTUBS_ENTRY1  242, SaveMergedKeys, 0 
SYSSTUBS_ENTRY2  242, SaveMergedKeys, 0 
SYSSTUBS_ENTRY3  242, SaveMergedKeys, 0 
SYSSTUBS_ENTRY4  242, SaveMergedKeys, 0 
SYSSTUBS_ENTRY5  242, SaveMergedKeys, 0 
SYSSTUBS_ENTRY6  242, SaveMergedKeys, 0 
SYSSTUBS_ENTRY7  242, SaveMergedKeys, 0 
SYSSTUBS_ENTRY8  242, SaveMergedKeys, 0 
SYSSTUBS_ENTRY1  243, SecureConnectPort, 5 
SYSSTUBS_ENTRY2  243, SecureConnectPort, 5 
SYSSTUBS_ENTRY3  243, SecureConnectPort, 5 
SYSSTUBS_ENTRY4  243, SecureConnectPort, 5 
SYSSTUBS_ENTRY5  243, SecureConnectPort, 5 
SYSSTUBS_ENTRY6  243, SecureConnectPort, 5 
SYSSTUBS_ENTRY7  243, SecureConnectPort, 5 
SYSSTUBS_ENTRY8  243, SecureConnectPort, 5 
SYSSTUBS_ENTRY1  244, SetBootEntryOrder, 0 
SYSSTUBS_ENTRY2  244, SetBootEntryOrder, 0 
SYSSTUBS_ENTRY3  244, SetBootEntryOrder, 0 
SYSSTUBS_ENTRY4  244, SetBootEntryOrder, 0 
SYSSTUBS_ENTRY5  244, SetBootEntryOrder, 0 
SYSSTUBS_ENTRY6  244, SetBootEntryOrder, 0 
SYSSTUBS_ENTRY7  244, SetBootEntryOrder, 0 
SYSSTUBS_ENTRY8  244, SetBootEntryOrder, 0 
SYSSTUBS_ENTRY1  245, SetBootOptions, 0 
SYSSTUBS_ENTRY2  245, SetBootOptions, 0 
SYSSTUBS_ENTRY3  245, SetBootOptions, 0 
SYSSTUBS_ENTRY4  245, SetBootOptions, 0 
SYSSTUBS_ENTRY5  245, SetBootOptions, 0 
SYSSTUBS_ENTRY6  245, SetBootOptions, 0 
SYSSTUBS_ENTRY7  245, SetBootOptions, 0 
SYSSTUBS_ENTRY8  245, SetBootOptions, 0 
SYSSTUBS_ENTRY1  246, SetContextThread, 0 
SYSSTUBS_ENTRY2  246, SetContextThread, 0 
SYSSTUBS_ENTRY3  246, SetContextThread, 0 
SYSSTUBS_ENTRY4  246, SetContextThread, 0 
SYSSTUBS_ENTRY5  246, SetContextThread, 0 
SYSSTUBS_ENTRY6  246, SetContextThread, 0 
SYSSTUBS_ENTRY7  246, SetContextThread, 0 
SYSSTUBS_ENTRY8  246, SetContextThread, 0 
SYSSTUBS_ENTRY1  247, SetDebugFilterState, 0 
SYSSTUBS_ENTRY2  247, SetDebugFilterState, 0 
SYSSTUBS_ENTRY3  247, SetDebugFilterState, 0 
SYSSTUBS_ENTRY4  247, SetDebugFilterState, 0 
SYSSTUBS_ENTRY5  247, SetDebugFilterState, 0 
SYSSTUBS_ENTRY6  247, SetDebugFilterState, 0 
SYSSTUBS_ENTRY7  247, SetDebugFilterState, 0 
SYSSTUBS_ENTRY8  247, SetDebugFilterState, 0 
SYSSTUBS_ENTRY1  248, SetDefaultHardErrorPort, 0 
SYSSTUBS_ENTRY2  248, SetDefaultHardErrorPort, 0 
SYSSTUBS_ENTRY3  248, SetDefaultHardErrorPort, 0 
SYSSTUBS_ENTRY4  248, SetDefaultHardErrorPort, 0 
SYSSTUBS_ENTRY5  248, SetDefaultHardErrorPort, 0 
SYSSTUBS_ENTRY6  248, SetDefaultHardErrorPort, 0 
SYSSTUBS_ENTRY7  248, SetDefaultHardErrorPort, 0 
SYSSTUBS_ENTRY8  248, SetDefaultHardErrorPort, 0 
SYSSTUBS_ENTRY1  249, SetDefaultLocale, 0 
SYSSTUBS_ENTRY2  249, SetDefaultLocale, 0 
SYSSTUBS_ENTRY3  249, SetDefaultLocale, 0 
SYSSTUBS_ENTRY4  249, SetDefaultLocale, 0 
SYSSTUBS_ENTRY5  249, SetDefaultLocale, 0 
SYSSTUBS_ENTRY6  249, SetDefaultLocale, 0 
SYSSTUBS_ENTRY7  249, SetDefaultLocale, 0 
SYSSTUBS_ENTRY8  249, SetDefaultLocale, 0 
SYSSTUBS_ENTRY1  250, SetDefaultUILanguage, 0 
SYSSTUBS_ENTRY2  250, SetDefaultUILanguage, 0 
SYSSTUBS_ENTRY3  250, SetDefaultUILanguage, 0 
SYSSTUBS_ENTRY4  250, SetDefaultUILanguage, 0 
SYSSTUBS_ENTRY5  250, SetDefaultUILanguage, 0 
SYSSTUBS_ENTRY6  250, SetDefaultUILanguage, 0 
SYSSTUBS_ENTRY7  250, SetDefaultUILanguage, 0 
SYSSTUBS_ENTRY8  250, SetDefaultUILanguage, 0 
SYSSTUBS_ENTRY1  251, SetDriverEntryOrder, 0 
SYSSTUBS_ENTRY2  251, SetDriverEntryOrder, 0 
SYSSTUBS_ENTRY3  251, SetDriverEntryOrder, 0 
SYSSTUBS_ENTRY4  251, SetDriverEntryOrder, 0 
SYSSTUBS_ENTRY5  251, SetDriverEntryOrder, 0 
SYSSTUBS_ENTRY6  251, SetDriverEntryOrder, 0 
SYSSTUBS_ENTRY7  251, SetDriverEntryOrder, 0 
SYSSTUBS_ENTRY8  251, SetDriverEntryOrder, 0 
SYSSTUBS_ENTRY1  252, SetEaFile, 0 
SYSSTUBS_ENTRY2  252, SetEaFile, 0 
SYSSTUBS_ENTRY3  252, SetEaFile, 0 
SYSSTUBS_ENTRY4  252, SetEaFile, 0 
SYSSTUBS_ENTRY5  252, SetEaFile, 0 
SYSSTUBS_ENTRY6  252, SetEaFile, 0 
SYSSTUBS_ENTRY7  252, SetEaFile, 0 
SYSSTUBS_ENTRY8  252, SetEaFile, 0 
SYSSTUBS_ENTRY1  253, SetHighEventPair, 0 
SYSSTUBS_ENTRY2  253, SetHighEventPair, 0 
SYSSTUBS_ENTRY3  253, SetHighEventPair, 0 
SYSSTUBS_ENTRY4  253, SetHighEventPair, 0 
SYSSTUBS_ENTRY5  253, SetHighEventPair, 0 
SYSSTUBS_ENTRY6  253, SetHighEventPair, 0 
SYSSTUBS_ENTRY7  253, SetHighEventPair, 0 
SYSSTUBS_ENTRY8  253, SetHighEventPair, 0 
SYSSTUBS_ENTRY1  254, SetHighWaitLowEventPair, 0 
SYSSTUBS_ENTRY2  254, SetHighWaitLowEventPair, 0 
SYSSTUBS_ENTRY3  254, SetHighWaitLowEventPair, 0 
SYSSTUBS_ENTRY4  254, SetHighWaitLowEventPair, 0 
SYSSTUBS_ENTRY5  254, SetHighWaitLowEventPair, 0 
SYSSTUBS_ENTRY6  254, SetHighWaitLowEventPair, 0 
SYSSTUBS_ENTRY7  254, SetHighWaitLowEventPair, 0 
SYSSTUBS_ENTRY8  254, SetHighWaitLowEventPair, 0 
SYSSTUBS_ENTRY1  255, SetInformationDebugObject, 1 
SYSSTUBS_ENTRY2  255, SetInformationDebugObject, 1 
SYSSTUBS_ENTRY3  255, SetInformationDebugObject, 1 
SYSSTUBS_ENTRY4  255, SetInformationDebugObject, 1 
SYSSTUBS_ENTRY5  255, SetInformationDebugObject, 1 
SYSSTUBS_ENTRY6  255, SetInformationDebugObject, 1 
SYSSTUBS_ENTRY7  255, SetInformationDebugObject, 1 
SYSSTUBS_ENTRY8  255, SetInformationDebugObject, 1 
SYSSTUBS_ENTRY1  256, SetInformationJobObject, 0 
SYSSTUBS_ENTRY2  256, SetInformationJobObject, 0 
SYSSTUBS_ENTRY3  256, SetInformationJobObject, 0 
SYSSTUBS_ENTRY4  256, SetInformationJobObject, 0 
SYSSTUBS_ENTRY5  256, SetInformationJobObject, 0 
SYSSTUBS_ENTRY6  256, SetInformationJobObject, 0 
SYSSTUBS_ENTRY7  256, SetInformationJobObject, 0 
SYSSTUBS_ENTRY8  256, SetInformationJobObject, 0 
SYSSTUBS_ENTRY1  257, SetInformationKey, 0 
SYSSTUBS_ENTRY2  257, SetInformationKey, 0 
SYSSTUBS_ENTRY3  257, SetInformationKey, 0 
SYSSTUBS_ENTRY4  257, SetInformationKey, 0 
SYSSTUBS_ENTRY5  257, SetInformationKey, 0 
SYSSTUBS_ENTRY6  257, SetInformationKey, 0 
SYSSTUBS_ENTRY7  257, SetInformationKey, 0 
SYSSTUBS_ENTRY8  257, SetInformationKey, 0 
SYSSTUBS_ENTRY1  258, SetInformationToken, 0 
SYSSTUBS_ENTRY2  258, SetInformationToken, 0 
SYSSTUBS_ENTRY3  258, SetInformationToken, 0 
SYSSTUBS_ENTRY4  258, SetInformationToken, 0 
SYSSTUBS_ENTRY5  258, SetInformationToken, 0 
SYSSTUBS_ENTRY6  258, SetInformationToken, 0 
SYSSTUBS_ENTRY7  258, SetInformationToken, 0 
SYSSTUBS_ENTRY8  258, SetInformationToken, 0 
SYSSTUBS_ENTRY1  259, SetIntervalProfile, 0 
SYSSTUBS_ENTRY2  259, SetIntervalProfile, 0 
SYSSTUBS_ENTRY3  259, SetIntervalProfile, 0 
SYSSTUBS_ENTRY4  259, SetIntervalProfile, 0 
SYSSTUBS_ENTRY5  259, SetIntervalProfile, 0 
SYSSTUBS_ENTRY6  259, SetIntervalProfile, 0 
SYSSTUBS_ENTRY7  259, SetIntervalProfile, 0 
SYSSTUBS_ENTRY8  259, SetIntervalProfile, 0 
SYSSTUBS_ENTRY1  260, SetIoCompletion, 1 
SYSSTUBS_ENTRY2  260, SetIoCompletion, 1 
SYSSTUBS_ENTRY3  260, SetIoCompletion, 1 
SYSSTUBS_ENTRY4  260, SetIoCompletion, 1 
SYSSTUBS_ENTRY5  260, SetIoCompletion, 1 
SYSSTUBS_ENTRY6  260, SetIoCompletion, 1 
SYSSTUBS_ENTRY7  260, SetIoCompletion, 1 
SYSSTUBS_ENTRY8  260, SetIoCompletion, 1 
SYSSTUBS_ENTRY1  261, SetLdtEntries, 2 
SYSSTUBS_ENTRY2  261, SetLdtEntries, 2 
SYSSTUBS_ENTRY3  261, SetLdtEntries, 2 
SYSSTUBS_ENTRY4  261, SetLdtEntries, 2 
SYSSTUBS_ENTRY5  261, SetLdtEntries, 2 
SYSSTUBS_ENTRY6  261, SetLdtEntries, 2 
SYSSTUBS_ENTRY7  261, SetLdtEntries, 2 
SYSSTUBS_ENTRY8  261, SetLdtEntries, 2 
SYSSTUBS_ENTRY1  262, SetLowEventPair, 0 
SYSSTUBS_ENTRY2  262, SetLowEventPair, 0 
SYSSTUBS_ENTRY3  262, SetLowEventPair, 0 
SYSSTUBS_ENTRY4  262, SetLowEventPair, 0 
SYSSTUBS_ENTRY5  262, SetLowEventPair, 0 
SYSSTUBS_ENTRY6  262, SetLowEventPair, 0 
SYSSTUBS_ENTRY7  262, SetLowEventPair, 0 
SYSSTUBS_ENTRY8  262, SetLowEventPair, 0 
SYSSTUBS_ENTRY1  263, SetLowWaitHighEventPair, 0 
SYSSTUBS_ENTRY2  263, SetLowWaitHighEventPair, 0 
SYSSTUBS_ENTRY3  263, SetLowWaitHighEventPair, 0 
SYSSTUBS_ENTRY4  263, SetLowWaitHighEventPair, 0 
SYSSTUBS_ENTRY5  263, SetLowWaitHighEventPair, 0 
SYSSTUBS_ENTRY6  263, SetLowWaitHighEventPair, 0 
SYSSTUBS_ENTRY7  263, SetLowWaitHighEventPair, 0 
SYSSTUBS_ENTRY8  263, SetLowWaitHighEventPair, 0 
SYSSTUBS_ENTRY1  264, SetQuotaInformationFile, 0 
SYSSTUBS_ENTRY2  264, SetQuotaInformationFile, 0 
SYSSTUBS_ENTRY3  264, SetQuotaInformationFile, 0 
SYSSTUBS_ENTRY4  264, SetQuotaInformationFile, 0 
SYSSTUBS_ENTRY5  264, SetQuotaInformationFile, 0 
SYSSTUBS_ENTRY6  264, SetQuotaInformationFile, 0 
SYSSTUBS_ENTRY7  264, SetQuotaInformationFile, 0 
SYSSTUBS_ENTRY8  264, SetQuotaInformationFile, 0 
SYSSTUBS_ENTRY1  265, SetSecurityObject, 0 
SYSSTUBS_ENTRY2  265, SetSecurityObject, 0 
SYSSTUBS_ENTRY3  265, SetSecurityObject, 0 
SYSSTUBS_ENTRY4  265, SetSecurityObject, 0 
SYSSTUBS_ENTRY5  265, SetSecurityObject, 0 
SYSSTUBS_ENTRY6  265, SetSecurityObject, 0 
SYSSTUBS_ENTRY7  265, SetSecurityObject, 0 
SYSSTUBS_ENTRY8  265, SetSecurityObject, 0 
SYSSTUBS_ENTRY1  266, SetSystemEnvironmentValue, 0 
SYSSTUBS_ENTRY2  266, SetSystemEnvironmentValue, 0 
SYSSTUBS_ENTRY3  266, SetSystemEnvironmentValue, 0 
SYSSTUBS_ENTRY4  266, SetSystemEnvironmentValue, 0 
SYSSTUBS_ENTRY5  266, SetSystemEnvironmentValue, 0 
SYSSTUBS_ENTRY6  266, SetSystemEnvironmentValue, 0 
SYSSTUBS_ENTRY7  266, SetSystemEnvironmentValue, 0 
SYSSTUBS_ENTRY8  266, SetSystemEnvironmentValue, 0 
SYSSTUBS_ENTRY1  267, SetSystemEnvironmentValueEx, 1 
SYSSTUBS_ENTRY2  267, SetSystemEnvironmentValueEx, 1 
SYSSTUBS_ENTRY3  267, SetSystemEnvironmentValueEx, 1 
SYSSTUBS_ENTRY4  267, SetSystemEnvironmentValueEx, 1 
SYSSTUBS_ENTRY5  267, SetSystemEnvironmentValueEx, 1 
SYSSTUBS_ENTRY6  267, SetSystemEnvironmentValueEx, 1 
SYSSTUBS_ENTRY7  267, SetSystemEnvironmentValueEx, 1 
SYSSTUBS_ENTRY8  267, SetSystemEnvironmentValueEx, 1 
SYSSTUBS_ENTRY1  268, SetSystemInformation, 0 
SYSSTUBS_ENTRY2  268, SetSystemInformation, 0 
SYSSTUBS_ENTRY3  268, SetSystemInformation, 0 
SYSSTUBS_ENTRY4  268, SetSystemInformation, 0 
SYSSTUBS_ENTRY5  268, SetSystemInformation, 0 
SYSSTUBS_ENTRY6  268, SetSystemInformation, 0 
SYSSTUBS_ENTRY7  268, SetSystemInformation, 0 
SYSSTUBS_ENTRY8  268, SetSystemInformation, 0 
SYSSTUBS_ENTRY1  269, SetSystemPowerState, 0 
SYSSTUBS_ENTRY2  269, SetSystemPowerState, 0 
SYSSTUBS_ENTRY3  269, SetSystemPowerState, 0 
SYSSTUBS_ENTRY4  269, SetSystemPowerState, 0 
SYSSTUBS_ENTRY5  269, SetSystemPowerState, 0 
SYSSTUBS_ENTRY6  269, SetSystemPowerState, 0 
SYSSTUBS_ENTRY7  269, SetSystemPowerState, 0 
SYSSTUBS_ENTRY8  269, SetSystemPowerState, 0 
SYSSTUBS_ENTRY1  270, SetSystemTime, 0 
SYSSTUBS_ENTRY2  270, SetSystemTime, 0 
SYSSTUBS_ENTRY3  270, SetSystemTime, 0 
SYSSTUBS_ENTRY4  270, SetSystemTime, 0 
SYSSTUBS_ENTRY5  270, SetSystemTime, 0 
SYSSTUBS_ENTRY6  270, SetSystemTime, 0 
SYSSTUBS_ENTRY7  270, SetSystemTime, 0 
SYSSTUBS_ENTRY8  270, SetSystemTime, 0 
SYSSTUBS_ENTRY1  271, SetThreadExecutionState, 0 
SYSSTUBS_ENTRY2  271, SetThreadExecutionState, 0 
SYSSTUBS_ENTRY3  271, SetThreadExecutionState, 0 
SYSSTUBS_ENTRY4  271, SetThreadExecutionState, 0 
SYSSTUBS_ENTRY5  271, SetThreadExecutionState, 0 
SYSSTUBS_ENTRY6  271, SetThreadExecutionState, 0 
SYSSTUBS_ENTRY7  271, SetThreadExecutionState, 0 
SYSSTUBS_ENTRY8  271, SetThreadExecutionState, 0 
SYSSTUBS_ENTRY1  272, SetTimerResolution, 0 
SYSSTUBS_ENTRY2  272, SetTimerResolution, 0 
SYSSTUBS_ENTRY3  272, SetTimerResolution, 0 
SYSSTUBS_ENTRY4  272, SetTimerResolution, 0 
SYSSTUBS_ENTRY5  272, SetTimerResolution, 0 
SYSSTUBS_ENTRY6  272, SetTimerResolution, 0 
SYSSTUBS_ENTRY7  272, SetTimerResolution, 0 
SYSSTUBS_ENTRY8  272, SetTimerResolution, 0 
SYSSTUBS_ENTRY1  273, SetUuidSeed, 0 
SYSSTUBS_ENTRY2  273, SetUuidSeed, 0 
SYSSTUBS_ENTRY3  273, SetUuidSeed, 0 
SYSSTUBS_ENTRY4  273, SetUuidSeed, 0 
SYSSTUBS_ENTRY5  273, SetUuidSeed, 0 
SYSSTUBS_ENTRY6  273, SetUuidSeed, 0 
SYSSTUBS_ENTRY7  273, SetUuidSeed, 0 
SYSSTUBS_ENTRY8  273, SetUuidSeed, 0 
SYSSTUBS_ENTRY1  274, SetVolumeInformationFile, 1 
SYSSTUBS_ENTRY2  274, SetVolumeInformationFile, 1 
SYSSTUBS_ENTRY3  274, SetVolumeInformationFile, 1 
SYSSTUBS_ENTRY4  274, SetVolumeInformationFile, 1 
SYSSTUBS_ENTRY5  274, SetVolumeInformationFile, 1 
SYSSTUBS_ENTRY6  274, SetVolumeInformationFile, 1 
SYSSTUBS_ENTRY7  274, SetVolumeInformationFile, 1 
SYSSTUBS_ENTRY8  274, SetVolumeInformationFile, 1 
SYSSTUBS_ENTRY1  275, ShutdownSystem, 0 
SYSSTUBS_ENTRY2  275, ShutdownSystem, 0 
SYSSTUBS_ENTRY3  275, ShutdownSystem, 0 
SYSSTUBS_ENTRY4  275, ShutdownSystem, 0 
SYSSTUBS_ENTRY5  275, ShutdownSystem, 0 
SYSSTUBS_ENTRY6  275, ShutdownSystem, 0 
SYSSTUBS_ENTRY7  275, ShutdownSystem, 0 
SYSSTUBS_ENTRY8  275, ShutdownSystem, 0 
SYSSTUBS_ENTRY1  276, SignalAndWaitForSingleObject, 0 
SYSSTUBS_ENTRY2  276, SignalAndWaitForSingleObject, 0 
SYSSTUBS_ENTRY3  276, SignalAndWaitForSingleObject, 0 
SYSSTUBS_ENTRY4  276, SignalAndWaitForSingleObject, 0 
SYSSTUBS_ENTRY5  276, SignalAndWaitForSingleObject, 0 
SYSSTUBS_ENTRY6  276, SignalAndWaitForSingleObject, 0 
SYSSTUBS_ENTRY7  276, SignalAndWaitForSingleObject, 0 
SYSSTUBS_ENTRY8  276, SignalAndWaitForSingleObject, 0 
SYSSTUBS_ENTRY1  277, StartProfile, 0 
SYSSTUBS_ENTRY2  277, StartProfile, 0 
SYSSTUBS_ENTRY3  277, StartProfile, 0 
SYSSTUBS_ENTRY4  277, StartProfile, 0 
SYSSTUBS_ENTRY5  277, StartProfile, 0 
SYSSTUBS_ENTRY6  277, StartProfile, 0 
SYSSTUBS_ENTRY7  277, StartProfile, 0 
SYSSTUBS_ENTRY8  277, StartProfile, 0 
SYSSTUBS_ENTRY1  278, StopProfile, 0 
SYSSTUBS_ENTRY2  278, StopProfile, 0 
SYSSTUBS_ENTRY3  278, StopProfile, 0 
SYSSTUBS_ENTRY4  278, StopProfile, 0 
SYSSTUBS_ENTRY5  278, StopProfile, 0 
SYSSTUBS_ENTRY6  278, StopProfile, 0 
SYSSTUBS_ENTRY7  278, StopProfile, 0 
SYSSTUBS_ENTRY8  278, StopProfile, 0 
SYSSTUBS_ENTRY1  279, SuspendProcess, 0 
SYSSTUBS_ENTRY2  279, SuspendProcess, 0 
SYSSTUBS_ENTRY3  279, SuspendProcess, 0 
SYSSTUBS_ENTRY4  279, SuspendProcess, 0 
SYSSTUBS_ENTRY5  279, SuspendProcess, 0 
SYSSTUBS_ENTRY6  279, SuspendProcess, 0 
SYSSTUBS_ENTRY7  279, SuspendProcess, 0 
SYSSTUBS_ENTRY8  279, SuspendProcess, 0 
SYSSTUBS_ENTRY1  280, SuspendThread, 0 
SYSSTUBS_ENTRY2  280, SuspendThread, 0 
SYSSTUBS_ENTRY3  280, SuspendThread, 0 
SYSSTUBS_ENTRY4  280, SuspendThread, 0 
SYSSTUBS_ENTRY5  280, SuspendThread, 0 
SYSSTUBS_ENTRY6  280, SuspendThread, 0 
SYSSTUBS_ENTRY7  280, SuspendThread, 0 
SYSSTUBS_ENTRY8  280, SuspendThread, 0 
SYSSTUBS_ENTRY1  281, SystemDebugControl, 2 
SYSSTUBS_ENTRY2  281, SystemDebugControl, 2 
SYSSTUBS_ENTRY3  281, SystemDebugControl, 2 
SYSSTUBS_ENTRY4  281, SystemDebugControl, 2 
SYSSTUBS_ENTRY5  281, SystemDebugControl, 2 
SYSSTUBS_ENTRY6  281, SystemDebugControl, 2 
SYSSTUBS_ENTRY7  281, SystemDebugControl, 2 
SYSSTUBS_ENTRY8  281, SystemDebugControl, 2 
SYSSTUBS_ENTRY1  282, TerminateJobObject, 0 
SYSSTUBS_ENTRY2  282, TerminateJobObject, 0 
SYSSTUBS_ENTRY3  282, TerminateJobObject, 0 
SYSSTUBS_ENTRY4  282, TerminateJobObject, 0 
SYSSTUBS_ENTRY5  282, TerminateJobObject, 0 
SYSSTUBS_ENTRY6  282, TerminateJobObject, 0 
SYSSTUBS_ENTRY7  282, TerminateJobObject, 0 
SYSSTUBS_ENTRY8  282, TerminateJobObject, 0 
SYSSTUBS_ENTRY1  283, TestAlert, 0 
SYSSTUBS_ENTRY2  283, TestAlert, 0 
SYSSTUBS_ENTRY3  283, TestAlert, 0 
SYSSTUBS_ENTRY4  283, TestAlert, 0 
SYSSTUBS_ENTRY5  283, TestAlert, 0 
SYSSTUBS_ENTRY6  283, TestAlert, 0 
SYSSTUBS_ENTRY7  283, TestAlert, 0 
SYSSTUBS_ENTRY8  283, TestAlert, 0 
SYSSTUBS_ENTRY1  284, TranslateFilePath, 0 
SYSSTUBS_ENTRY2  284, TranslateFilePath, 0 
SYSSTUBS_ENTRY3  284, TranslateFilePath, 0 
SYSSTUBS_ENTRY4  284, TranslateFilePath, 0 
SYSSTUBS_ENTRY5  284, TranslateFilePath, 0 
SYSSTUBS_ENTRY6  284, TranslateFilePath, 0 
SYSSTUBS_ENTRY7  284, TranslateFilePath, 0 
SYSSTUBS_ENTRY8  284, TranslateFilePath, 0 
SYSSTUBS_ENTRY1  285, UnloadDriver, 0 
SYSSTUBS_ENTRY2  285, UnloadDriver, 0 
SYSSTUBS_ENTRY3  285, UnloadDriver, 0 
SYSSTUBS_ENTRY4  285, UnloadDriver, 0 
SYSSTUBS_ENTRY5  285, UnloadDriver, 0 
SYSSTUBS_ENTRY6  285, UnloadDriver, 0 
SYSSTUBS_ENTRY7  285, UnloadDriver, 0 
SYSSTUBS_ENTRY8  285, UnloadDriver, 0 
SYSSTUBS_ENTRY1  286, UnloadKey, 0 
SYSSTUBS_ENTRY2  286, UnloadKey, 0 
SYSSTUBS_ENTRY3  286, UnloadKey, 0 
SYSSTUBS_ENTRY4  286, UnloadKey, 0 
SYSSTUBS_ENTRY5  286, UnloadKey, 0 
SYSSTUBS_ENTRY6  286, UnloadKey, 0 
SYSSTUBS_ENTRY7  286, UnloadKey, 0 
SYSSTUBS_ENTRY8  286, UnloadKey, 0 
SYSSTUBS_ENTRY1  287, UnloadKey2, 0 
SYSSTUBS_ENTRY2  287, UnloadKey2, 0 
SYSSTUBS_ENTRY3  287, UnloadKey2, 0 
SYSSTUBS_ENTRY4  287, UnloadKey2, 0 
SYSSTUBS_ENTRY5  287, UnloadKey2, 0 
SYSSTUBS_ENTRY6  287, UnloadKey2, 0 
SYSSTUBS_ENTRY7  287, UnloadKey2, 0 
SYSSTUBS_ENTRY8  287, UnloadKey2, 0 
SYSSTUBS_ENTRY1  288, UnloadKeyEx, 0 
SYSSTUBS_ENTRY2  288, UnloadKeyEx, 0 
SYSSTUBS_ENTRY3  288, UnloadKeyEx, 0 
SYSSTUBS_ENTRY4  288, UnloadKeyEx, 0 
SYSSTUBS_ENTRY5  288, UnloadKeyEx, 0 
SYSSTUBS_ENTRY6  288, UnloadKeyEx, 0 
SYSSTUBS_ENTRY7  288, UnloadKeyEx, 0 
SYSSTUBS_ENTRY8  288, UnloadKeyEx, 0 
SYSSTUBS_ENTRY1  289, UnlockFile, 1 
SYSSTUBS_ENTRY2  289, UnlockFile, 1 
SYSSTUBS_ENTRY3  289, UnlockFile, 1 
SYSSTUBS_ENTRY4  289, UnlockFile, 1 
SYSSTUBS_ENTRY5  289, UnlockFile, 1 
SYSSTUBS_ENTRY6  289, UnlockFile, 1 
SYSSTUBS_ENTRY7  289, UnlockFile, 1 
SYSSTUBS_ENTRY8  289, UnlockFile, 1 
SYSSTUBS_ENTRY1  290, UnlockVirtualMemory, 0 
SYSSTUBS_ENTRY2  290, UnlockVirtualMemory, 0 
SYSSTUBS_ENTRY3  290, UnlockVirtualMemory, 0 
SYSSTUBS_ENTRY4  290, UnlockVirtualMemory, 0 
SYSSTUBS_ENTRY5  290, UnlockVirtualMemory, 0 
SYSSTUBS_ENTRY6  290, UnlockVirtualMemory, 0 
SYSSTUBS_ENTRY7  290, UnlockVirtualMemory, 0 
SYSSTUBS_ENTRY8  290, UnlockVirtualMemory, 0 
SYSSTUBS_ENTRY1  291, VdmControl, 0 
SYSSTUBS_ENTRY2  291, VdmControl, 0 
SYSSTUBS_ENTRY3  291, VdmControl, 0 
SYSSTUBS_ENTRY4  291, VdmControl, 0 
SYSSTUBS_ENTRY5  291, VdmControl, 0 
SYSSTUBS_ENTRY6  291, VdmControl, 0 
SYSSTUBS_ENTRY7  291, VdmControl, 0 
SYSSTUBS_ENTRY8  291, VdmControl, 0 
SYSSTUBS_ENTRY1  292, WaitForDebugEvent, 0 
SYSSTUBS_ENTRY2  292, WaitForDebugEvent, 0 
SYSSTUBS_ENTRY3  292, WaitForDebugEvent, 0 
SYSSTUBS_ENTRY4  292, WaitForDebugEvent, 0 
SYSSTUBS_ENTRY5  292, WaitForDebugEvent, 0 
SYSSTUBS_ENTRY6  292, WaitForDebugEvent, 0 
SYSSTUBS_ENTRY7  292, WaitForDebugEvent, 0 
SYSSTUBS_ENTRY8  292, WaitForDebugEvent, 0 
SYSSTUBS_ENTRY1  293, WaitForKeyedEvent, 0 
SYSSTUBS_ENTRY2  293, WaitForKeyedEvent, 0 
SYSSTUBS_ENTRY3  293, WaitForKeyedEvent, 0 
SYSSTUBS_ENTRY4  293, WaitForKeyedEvent, 0 
SYSSTUBS_ENTRY5  293, WaitForKeyedEvent, 0 
SYSSTUBS_ENTRY6  293, WaitForKeyedEvent, 0 
SYSSTUBS_ENTRY7  293, WaitForKeyedEvent, 0 
SYSSTUBS_ENTRY8  293, WaitForKeyedEvent, 0 
SYSSTUBS_ENTRY1  294, WaitHighEventPair, 0 
SYSSTUBS_ENTRY2  294, WaitHighEventPair, 0 
SYSSTUBS_ENTRY3  294, WaitHighEventPair, 0 
SYSSTUBS_ENTRY4  294, WaitHighEventPair, 0 
SYSSTUBS_ENTRY5  294, WaitHighEventPair, 0 
SYSSTUBS_ENTRY6  294, WaitHighEventPair, 0 
SYSSTUBS_ENTRY7  294, WaitHighEventPair, 0 
SYSSTUBS_ENTRY8  294, WaitHighEventPair, 0 
SYSSTUBS_ENTRY1  295, WaitLowEventPair, 0 
SYSSTUBS_ENTRY2  295, WaitLowEventPair, 0 
SYSSTUBS_ENTRY3  295, WaitLowEventPair, 0 
SYSSTUBS_ENTRY4  295, WaitLowEventPair, 0 
SYSSTUBS_ENTRY5  295, WaitLowEventPair, 0 
SYSSTUBS_ENTRY6  295, WaitLowEventPair, 0 
SYSSTUBS_ENTRY7  295, WaitLowEventPair, 0 
SYSSTUBS_ENTRY8  295, WaitLowEventPair, 0 

STUBS_END
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ke\amd64\runtime.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    runtime.c

Abstract:

    This module implements code to update runtime, perform quantum end
    processing, and perform DPC moderation processing.

--*/

#include "ki.h"

VOID
KeUpdateRunTime (
    IN PKTRAP_FRAME TrapFrame,
    IN LONG Increment
    )

/*++

Routine Description:

    This routine is called as the result of the interval timer interrupt on
    all processors in the system. Its function is update the per processor
    tick count, update the runtime of the current thread, update the runtime
    of the current thread's process, perform DPC moderation, and decrement
    the current thread quantum if a full tick has expired. This routine also
    performs real time scheduling quantum end and next interval processing.
 
    N.B. This routine is executed on all processors in a multiprocessor
         system.

Arguments:

    TrapFrame - Supplies the address of a trap frame.

    Increment - Supplies the time increment value in 100 nanosecond units.

Return Value:

    None.

--*/

{

    PKPRCB Prcb;
    PKTHREAD Thread;

    //
    // If the clock tick should be skipped, then clear the skip flag and
    // return.
    //

    Prcb = KeGetCurrentPrcb();

#if DBG

    if (Prcb->SkipTick != FALSE) {
        Prcb->SkipTick = FALSE;
        return;
    }

#endif

    //
    // Update the tick count offset and check if a full tick has expired.
    //

    if ((Prcb->TickOffset -= Increment) <= 0) {

        //
        // Update the appropriate time counter based on previous mode, IRQL,
        // and whether there is currently a DPC active.
        //

        Prcb->TickOffset += KeMaximumIncrement;
        Thread = KeGetCurrentThread();
        if ((TrapFrame->SegCs & MODE_MASK) == 0) {

            //
            // Update the total time spent in kernel mode.
            //
            // If the interrupt nesting level is one and a DPC routine is
            // active, then update the DPC time. Otherwise, if the interrupt
            // nesting level is greater than one, then update the interrupt
            // time. Otherwise, update the current thread kernel time.
            //

            Prcb->KernelTime += 1;
            if ((Prcb->NestingLevel == 1) && (Prcb->DpcRoutineActive != FALSE)) {
                Prcb->DpcTime += 1;

                //
                // If the kernel debugger is enabled and the time spent in
                // the current DPC exceeds the system DPC time out limit,
                // then print a warning message and break into the debugger.
                //

#if DBG

                if ((KdDebuggerEnabled != 0) &
                    ((Prcb->DebugDpcTime += 1) >= KiDPCTimeout)) {
            
                    DbgPrint("*** DPC execution time exceeds system limit\n");
                    DbgPrint("    This is NOT a break in update time\n");
                    DbgPrint("    This is an ERROR in a DPC routine\n");
                    DbgPrint("    Perform a stack trace to find the culprit\n"); 
                    DbgBreakPoint();
                    Prcb->DebugDpcTime = 0;
                }

#endif

            } else if (Prcb->NestingLevel > 1) {
                Prcb->InterruptTime += 1;

            } else {
                Thread->KernelTime += 1;
            }

        } else {

            //
            // Update the total time spent in user mode.
            //

            Prcb->UserTime += 1;
            Thread->UserTime += 1;
        }

        //
        // Update the DPC request rate which is computed as the average of
        // the previous rate and the current rate.
        //

        Prcb->DpcRequestRate += (Prcb->DpcData[DPC_NORMAL].DpcCount - Prcb->DpcLastCount);
        Prcb->DpcRequestRate >>= 1;
        Prcb->DpcLastCount = Prcb->DpcData[DPC_NORMAL].DpcCount;

        //
        // If the current DPC queue depth is not zero, a DPC routine is not
        // active, and a DPC interrupt has not been requested, then request
        // a dispatch interrupt, decrement the maximum DPC queue depth, and
        // reset the threshold counter if appropriate. Otherwise, count down
        // the adjustment threshold and if the count reaches zero, then
        // increment the maximum DPC queue depth, but not above the initial
        // value and reset the adjustment threshold value.
        //

        if ((Prcb->DpcData[DPC_NORMAL].DpcQueueDepth != 0) &&
            (Prcb->DpcRoutineActive == FALSE) &&
            (Prcb->DpcInterruptRequested == FALSE)) {

            KiRequestSoftwareInterrupt(DISPATCH_LEVEL);
            Prcb->AdjustDpcThreshold = KiAdjustDpcThreshold;

            //
            // If the DPC request rate is less than the ideal rate and the
            // DPC queue depth is not one, then decrement the maximum queue
            // depth.
            //

            if ((Prcb->DpcRequestRate < KiIdealDpcRate) &&
                (Prcb->MaximumDpcQueueDepth != 1)) {

                Prcb->MaximumDpcQueueDepth -= 1;
            }

        } else {
            if ((Prcb->AdjustDpcThreshold -= 1) == 0) {
                Prcb->AdjustDpcThreshold = KiAdjustDpcThreshold;
                if (Prcb->MaximumDpcQueueDepth != KiMaximumDpcQueueDepth) {
                    Prcb->MaximumDpcQueueDepth += 1;
                }
            }
        }

        //
        // If the current thread is not the idle thread, then decrement the
        // thread quantum.
        //
        // If the thread quantum is exhausted, then set the quantum end true
        // and request a dispatch interrupt on the current processor.
        //

        if ((Thread != Prcb->IdleThread) &&
            ((Thread->Quantum -= CLOCK_QUANTUM_DECREMENT) <= 0)) {

            Prcb->QuantumEnd = TRUE;
            KiRequestSoftwareInterrupt(DISPATCH_LEVEL);
        }

        //
        // If the debugger is enabled, check if a break is requested.
        //
        // N.B. A poll break in attempt only occurs on each processor when
        //      the poll slot matches the current processor number.
        //
    
        if (KdDebuggerEnabled != FALSE) {
            if (Prcb->PollSlot == Prcb->Number) {
                KdCheckForDebugBreak();
            }
    
            Prcb->PollSlot += 1;
            if (Prcb->PollSlot == KeNumberProcessors) {
                Prcb->PollSlot = 0;
            }
        }
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ke\amd64\profint.asm ===
title  "Profile Interrupt"
;++
;
; Copyright (c) Microsoft Corporation. All rights reserved. 
;
; You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
; If you do not agree to the terms, do not use the code.
;
;
; Module Name:
;
;   profint.asm
;
; Abstract:
;
;   This module implements the architecture dependent code necessary to
;   process the profile interrupt.
;
;--

include ksamd64.inc

        extern  KiProfileListHead:qword
        extern  KiProfileLock:qword
        extern  PerfProfileInterrupt:proc

        subttl  "Profile Interrupt"
;++
;
; VOID
; KeProfileInterruptWithSource (
;     IN PKTRAP_FRAME TrapFrame,
;     IN KPROFILE_SOURCE ProfileSource
;     )
;
; Routine Description:
;
;   This routine is executed in response to an interrupt generated by one
;   of the profile sources. Its function is to process the system and process
;   profile lists and update bucket hit counters.
;
; Arguments:
;
;   TrapFrame (rcx) - Supplies the address of a trap frame.
;
;   ProfileSource (rdx) - Supplies the source of profile interrupt.
;
; Return Value:
;
;    None.
;
;--

PiFrame struct
        P1Home  dq ?                    ; parameter home addresses
        P2Home  dq ?                    ;
        P3Home  dq ?                    ;
        P4Home  dq ?                    ;
        Source  dq ?                    ; interrupt source home address
        ListHead dq ?                   ; list head address home address
        TrapFrame dq ?                  ; saved trap frame
PiFrame ends

        NESTED_ENTRY KeProfileInterruptWithSource, _TEXT$00

        alloc_stack (sizeof PiFrame)    ; allocate stack frame

        END_PROLOGUE

        mov     PiFrame.TrapFrame[rsp], rcx; save trap frame
        mov     PiFrame.Source[rsp], rdx; save interrupt source

;
; Check for profile logging.
;

        mov     rax, gs:[PcPerfGlobalGroupMask]; get global mask address
        test    rax, rax                ; test if logging enabled
        je      short KePI10            ; if e, logging not enabled
        test    dword ptr PERF_PROFILE_OFFSET[rax], PERF_PROFILE_FLAG ; check flag
        jz      short KePI10            ; if z, profile events not enabled
        xchg    rcx, rdx                ; exchange source and trap frame address
        mov     rdx, TrRip + 128[rdx]   ; set profile interrupt address
        call    PerfProfileInterrupt

KePI10: AcquireSpinLock KiProfileLock   ; acquire profile spin lock

        mov     rcx, PiFrame.TrapFrame[rsp] ; set trap frame
        mov     rdx, PiFrame.Source[rsp]; set interrupt source
        mov     r8, gs:[PcCurrentThread]; get current thread address
        mov     r8, ThApcState + AsProcess[r8] ; get current process address
        add     r8, PrProfileListHead   ; compute profile listhead address
        call    KiProcessProfileList    ; process profile list
        mov     rcx, PiFrame.TrapFrame[rsp] ; set trap frame
        mov     rdx, PiFrame.Source[rsp]; set interrupt source
        lea     r8, KiProfileListHead   ; get system profile listhead address
        call    KiProcessProfileList    ; process profile list

        ReleaseSpinLock KiProfileLock   ; release spin lock

        add     rsp, (sizeof PiFrame)   ; deallocate stack frame
        ret                             ; return

        NESTED_END KeProfileInterruptWithSource, _TEXT$00

        subttl  "Process Profile List"
;++
;
; VOID
; KiProcessProfileList (
;     IN PKTRAP_FRAME TrapFrame,
;     IN KPROFILE_SOURCE Source,
;     IN PLIST_ENTRY ListHead
;     )
;
; Routine Description:
;
;   This routine processes a profile list.
;
; Arguments:
;
;   TrapFrame (rcx) - Supplies the address of a trap frame.
;
;   Source (dx) - Supplies the source of profile interrupt.
;
;   ListHead (r8) - Supplies a pointer to a profile list.
;
; Return Value:
;
;    None.
;
;--

        LEAF_ENTRY KiProcessProfileList, _TEXT$00

        movzx   eax, dx                 ; save profile source
        mov     rdx, LsFlink[r8]        ; get first entry address
        cmp     rdx, r8                 ; check if list is empty
        je      short KiPP30            ; if e, list is empty
        mov     r9, gs:[PcSetMember]    ; get processor set member
        mov     r10, TrRip + 128[rcx]   ; get profile interrupt address

;
; Process list entry.
;

KiPP10: cmp     ax, (PfSource - PfProfileListEntry)[rdx] ; check for source match
        jne     short KiPP20            ; if ne, source mismatch
        cmp     r10, (PfRangeBase - PfProfileListEntry)[rdx] ; check if below base
        jb      short KiPP20            ; if b, address below base
        cmp     r10, (PfRangeLimit - PfProfileListEntry)[rdx] ; check if above limit
        jae     short KiPP20            ; if ae, address above limit
        test    r9, (PfAffinity - PfProfileListEntry)[rdx] ; check if in set
        jz      short KiPP20            ; if z, processor not in set
        movzx   ecx, byte ptr (PfBucketShift - PfProfileListEntry)[rdx] ; get shift count
        mov     r11, r10                ; compute offset into profile buffer
        sub     r11, (PfRangeBase - PfProfileListEntry)[rdx] ;
        shr     r11, cl                 ;
        and     r11, NOT 3              ;
        mov     rcx, (PfBuffer - PfProfileListEntry)[rdx] ; get profile buffer address
        inc     dword ptr [r11][rcx]    ; increment profile bucket
KiPP20: mov     rdx, LsFlink[rdx]         ; get next entry address
        cmp     rdx, r8                 ; check if end of list
        jne     short KiPP10            ; if ne, not end of list
KiPP30: ret                             ; return

        LEAF_END KiProcessProfileList, _TEXT$00

        end
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ke\amd64\queuelock.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    spinlock.c

Abstract:

    This module implements the platform specific functions for acquiring
    and releasing spin locks.

--*/

#include "ki.h"

DECLSPEC_NOINLINE
PKSPIN_LOCK_QUEUE
KxWaitForLockChainValid (
    __inout PKSPIN_LOCK_QUEUE LockQueue
    )

/*++

Routine Description:

    This function is called when the attempt to release a queued spin lock
    fails. A spin loop is executed to wait until the next owner fills in
    the next pointer in the specified lock queue entry.

Arguments:

    LockQueue - Supplies the address of a lock queue entry.

Return Value;

    The address of the next lock queue entry is returned as the function
    value.

--*/

{

    PKSPIN_LOCK_QUEUE NextQueue;

    //
    // Wait for lock chain to become valid.
    //

    do {
        KeYieldProcessor();
    } while ((NextQueue = LockQueue->Next) == NULL);

    return NextQueue;
}

DECLSPEC_NOINLINE
ULONG64
KxWaitForLockOwnerShip (
    __inout PKSPIN_LOCK_QUEUE LockQueue,
    __inout PKSPIN_LOCK_QUEUE TailQueue
    )

/*++

Routine Description:

Arguments:

    LockQueue - Supplies the address of the lock queue entry that is now
        the last entry in the lock queue.

    TailQueue - Supplies the address of the previous last entry in the lock
        queue.

Return Value:

    The number of wait loops that were executed.

--*/

{

    ULONG64 SpinCount;

    //
    // Set the wait bit in the acquiring lock queue entry and set the next
    // lock queue entry in the last lock queue entry.
    //

    *((ULONG64 volatile *)&LockQueue->Lock) |= LOCK_QUEUE_WAIT;
    TailQueue->Next = LockQueue;

    //
    // Wait for lock ownership to be passed.
    //

    SpinCount = 0;
    do {
        KeYieldProcessor();
    } while ((*((ULONG64 volatile *)&LockQueue->Lock) & LOCK_QUEUE_WAIT) != 0);

    KeMemoryBarrier();
    return SpinCount;
}

__forceinline
VOID
KxAcquireQueuedSpinLock (
    __inout PKSPIN_LOCK_QUEUE LockQueue,
    __inout PKSPIN_LOCK SpinLock
    )

/*++

Routine Description:

    This function acquires a queued spin lock at the current IRQL.

Arguments:

    LockQueue - Supplies a pointer to a spin lock queue.

    SpinLock - Supplies a pointer to the spin lock associated with the lock
        queue.

Return Value:

    None.

--*/

{

    //
    // Insert the specified lock queue entry at the end of the lock queue
    // list. If the list was previously empty, then lock ownership is
    // immediately granted. Otherwise, wait for ownership of the lock to
    // be granted.
    //

#if !defined(NT_UP)

    PKSPIN_LOCK_QUEUE TailQueue;

    TailQueue = InterlockedExchangePointer((PVOID *)SpinLock, LockQueue);
    if (TailQueue != NULL) {
        KxWaitForLockOwnerShip(LockQueue, TailQueue);
    }

#else

    UNREFERENCED_PARAMETER(LockQueue);
    UNREFERENCED_PARAMETER(SpinLock);

#endif

    return;
}

__forceinline
LOGICAL
KxTryToAcquireQueuedSpinLock (
    __inout PKSPIN_LOCK_QUEUE LockQueue,
    __inout PKSPIN_LOCK SpinLock
    )

/*++

Routine Description:

    This function attempts to acquire the specified queued spin lock at
    the current IRQL.

Arguments:

    LockQueue - Supplies a pointer to a spin lock queue.

    SpinLock - Supplies a pointer to the spin lock associated with the lock
        queue.

Return Value:

    A value of TRUE is returned is the specified queued spin lock is
    acquired. Otherwise, a value of FALSE is returned.

--*/

{

    //
    // Insert the specified lock queue entry at the end of the lock queue
    // list iff the lock queue list is currently empty. If the lock queue
    // was empty, then lock ownership is granted and TRUE is returned.
    // Otherwise, FALSE is returned.
    //

#if !defined(NT_UP)

    if ((ReadForWriteAccess(SpinLock) != 0) ||
        (InterlockedCompareExchangePointer((PVOID *)SpinLock,
                                                  LockQueue,
                                                  NULL) != NULL)) {

        KeYieldProcessor();
        return FALSE;

    }

#else

    UNREFERENCED_PARAMETER(LockQueue);
    UNREFERENCED_PARAMETER(SpinLock);

#endif

    return TRUE;
}

__forceinline
VOID
KxReleaseQueuedSpinLock (
    __inout PKSPIN_LOCK_QUEUE LockQueue
    )

/*++

Routine Description:

    The function release a queued spin lock at the current IRQL.

Arguments:

    LockQueue - Supplies a pointer to a spin lock queue.

Return Value:

    None.

--*/

{

    //
    // Attempt to release the lock. If the lock queue is not empty, then wait
    // for the next entry to be written in the lock queue entry and then grant
    // ownership of the lock to the next lock queue entry.
    //

#if !defined(NT_UP)

    PKSPIN_LOCK_QUEUE NextQueue;

    NextQueue = ReadForWriteAccess(&LockQueue->Next);
    if (NextQueue == NULL) {
        if (InterlockedCompareExchangePointer((PVOID *)LockQueue->Lock,
                                              NULL,
                                              LockQueue) == LockQueue) {
            return;
        }

        NextQueue = KxWaitForLockChainValid(LockQueue);
    }

    ASSERT(((ULONG64)NextQueue->Lock & LOCK_QUEUE_WAIT) != 0);

    InterlockedXor64((LONG64 volatile *)&NextQueue->Lock, LOCK_QUEUE_WAIT);
    LockQueue->Next = NULL;

#else

    UNREFERENCED_PARAMETER(LockQueue);

#endif

    return;
}

#undef KeAcquireQueuedSpinLock

KIRQL
KeAcquireQueuedSpinLock (
    __in KSPIN_LOCK_QUEUE_NUMBER Number
    )

/*++

Routine Description:

    This function raises IRQL to DISPATCH_LEVEL and acquires the specified
    numbered queued spin lock.

Arguments:

    Number  - Supplies the queued spin lock number.

Return Value:

    The previous IRQL is returned as the function value.

--*/

{

    PKSPIN_LOCK_QUEUE LockQueue;
    KIRQL OldIrql;
    PKSPIN_LOCK SpinLock;

    //
    // Raise IRQL to DISPATCH_LEVEL and acquire the specified queued spin
    // lock.
    //

    OldIrql = KfRaiseIrql(DISPATCH_LEVEL);
    LockQueue = &KiGetLockQueue()[Number];
    SpinLock = LockQueue->Lock;
    KxAcquireQueuedSpinLock(LockQueue, SpinLock);
    return OldIrql;
}

#undef KeAcquireQueuedSpinLockRaiseToSynch

KIRQL
KeAcquireQueuedSpinLockRaiseToSynch (
    __in KSPIN_LOCK_QUEUE_NUMBER Number
    )

/*++

Routine Description:

    This function raises IRQL to SYNCH_LEVEL and acquires the specified
    numbered queued spin lock.

Arguments:

    Number - Supplies the queued spinlock number.

Return Value:

    The previous IRQL is returned as the function value.

--*/

{

    PKSPIN_LOCK_QUEUE LockQueue;
    KIRQL OldIrql;
    PKSPIN_LOCK SpinLock;

    //
    // Raise IRQL to SYNCH_LEVEL and acquire the specified queued spin
    // lock.
    //

    OldIrql = KfRaiseIrql(SYNCH_LEVEL);
    LockQueue = &KiGetLockQueue()[Number];
    SpinLock = LockQueue->Lock;
    KxAcquireQueuedSpinLock(LockQueue, SpinLock);
    return OldIrql;
}

#undef KeAcquireQueuedSpinLockAtDpcLevel

VOID
KeAcquireQueuedSpinLockAtDpcLevel (
    __inout PKSPIN_LOCK_QUEUE LockQueue
    )

/*++

Routine Description:

    This function acquires the specified queued spin lock at the current IRQL.

Arguments:

    LockQueue - Supplies a pointer to the lock queue entry for the specified
        queued spin lock.

Return Value:

    None.

--*/

{

    //
    // Acquire the specified queued spin lock at the current IRQL.
    //

    KxAcquireQueuedSpinLock(LockQueue, LockQueue->Lock);
    return;
}

#undef KeTryToAcquireQueuedSpinLock

LOGICAL
KeTryToAcquireQueuedSpinLock (
    __in KSPIN_LOCK_QUEUE_NUMBER Number,
    __out PKIRQL OldIrql
    )

/*++

Routine Description:

    This function raises IRQL to DISPATCH_LEVEL and attempts to acquire the
    specified numbered queued spin lock. If the spin lock is already owned,
    then IRQL is restored to its previous value and FALSE is returned.
    Otherwise, the spin lock is acquired and TRUE is returned.

Arguments:

    Number - Supplies the queued spinlock number.

    OldIrql - Supplies a pointer to the variable to receive the old IRQL.

Return Value:

    If the spin lock is acquired a value TRUE is returned. Otherwise, FALSE
    is returned as the function value.

--*/

{
    PKSPIN_LOCK_QUEUE LockQueue;
    PKSPIN_LOCK SpinLock;

    //
    // Try to acquire the specified queued spin lock at DISPATCH_LEVEL.
    //

    *OldIrql = KfRaiseIrql(DISPATCH_LEVEL);
    LockQueue = &KiGetLockQueue()[Number];
    SpinLock = LockQueue->Lock;
    if (KxTryToAcquireQueuedSpinLock(LockQueue, SpinLock) == FALSE) {
        KeLowerIrql(*OldIrql);
        return FALSE;

    }

    return TRUE;
}

#undef KeTryToAcquireQueuedSpinLockRaiseToSynch

LOGICAL
KeTryToAcquireQueuedSpinLockRaiseToSynch (
    __in  KSPIN_LOCK_QUEUE_NUMBER Number,
    __out PKIRQL OldIrql
    )

/*++

Routine Description:

    This function raises IRQL to SYNCH_LEVEL and attempts to acquire the
    specified numbered queued spin lock. If the spin lock is already owned,
    then IRQL is restored to its previous value and FALSE is returned.
    Otherwise, the spin lock is acquired and TRUE is returned.

Arguments:

    Number - Supplies the queued spinlock number.

    OldIrql - Supplies a pointer to the variable to receive the old IRQL.

Return Value:

    If the spin lock is acquired a value TRUE is returned. Otherwise, FALSE
    is returned as the function value.

--*/

{

    PKSPIN_LOCK_QUEUE LockQueue;
    PKSPIN_LOCK SpinLock;

    //
    // Try to acquire the specified queued spin lock at SYNCH_LEVEL.
    //

    *OldIrql = KfRaiseIrql(SYNCH_LEVEL);
    LockQueue = &KiGetLockQueue()[Number];
    SpinLock = LockQueue->Lock;
    if (KxTryToAcquireQueuedSpinLock(LockQueue, SpinLock) == FALSE) {
        KeLowerIrql(*OldIrql);
        return FALSE;

    }

    return TRUE;
}

#undef KeTryToAcquireQueuedSpinLockAtRaisedIrql

LOGICAL
KeTryToAcquireQueuedSpinLockAtRaisedIrql (
    __inout PKSPIN_LOCK_QUEUE LockQueue
    )

/*++

Routine Description:

    This function attempts to acquire the specified queued spin lock at the
    current IRQL.

Arguments:

    LockQueue - Supplies a pointer to a lock queue entry.

Return Value:

    If the spin lock is acquired a value TRUE is returned as the function
    value. Otherwise, FALSE is returned as the function value.

--*/

{

    //
    // Try to acquire the specified queued spin lock at the current IRQL.
    //

    return KxTryToAcquireQueuedSpinLock(LockQueue, LockQueue->Lock);
}

#undef KeReleaseQueuedSpinLock

VOID
KeReleaseQueuedSpinLock (
    __in KSPIN_LOCK_QUEUE_NUMBER Number,
    __in KIRQL OldIrql
    )

/*++

Routine Description:

    This function releases a numbered queued spin lock and lowers the IRQL to
    its previous value.

Arguments:

    Number - Supplies the queued spinlock number.

    OldIrql  - Supplies the previous IRQL value.

Return Value:

    None.

--*/

{

    //
    // Release the specified queued spin lock and lower IRQL.
    //

    KxReleaseQueuedSpinLock(&KiGetLockQueue()[Number]);
    KeLowerIrql(OldIrql);
    return;
}

#undef KeReleaseQueuedSpinLockFromDpcLevel

VOID
KeReleaseQueuedSpinLockFromDpcLevel (
    __inout PKSPIN_LOCK_QUEUE LockQueue
    )

/*

Routine Description:

    This function releases a queued spinlock from the current IRQL.

Arguments:

    LockQueue - Supplies a pointer to a lock queue entry.

Return Value:

    None.

--*/

{

    //
    // Release the specified queued spin lock at the current IRQL.
    //

    KxReleaseQueuedSpinLock(LockQueue);
    return;
}

VOID
KeAcquireInStackQueuedSpinLock (
    __inout PKSPIN_LOCK SpinLock,
    __out PKLOCK_QUEUE_HANDLE LockHandle
    )

/*++

Routine Description:

    This function raises IRQL to DISPATCH_LEVEL and acquires the specified
    in stack queued spin lock.

Arguments:

    SpinLock - Supplies the home address of the queued spin lock.

    LockHandle - Supplies the address of a lock queue handle.

Return Value:

    None.

--*/

{

    //
    // Raise IRQL to DISPATCH_LEVEL and acquire the specified in stack
    // queued spin lock.
    //

#if !defined(NT_UP)

    LockHandle->LockQueue.Lock = SpinLock;
    LockHandle->LockQueue.Next = NULL;

#else

    UNREFERENCED_PARAMETER(SpinLock);

#endif

    LockHandle->OldIrql = KfRaiseIrql(DISPATCH_LEVEL);
    KxAcquireQueuedSpinLock(&LockHandle->LockQueue, SpinLock);
    return;
}

VOID
KeAcquireInStackQueuedSpinLockRaiseToSynch (
    __inout PKSPIN_LOCK SpinLock,
    __out PKLOCK_QUEUE_HANDLE LockHandle
    )

/*++

Routine Description:

    This functions raises IRQL to SYNCH_LEVEL and acquires the specified
    in stack queued spin lock.

Arguments:

    SpinLock - Supplies the home address of the queued spin lock.

    LockHandle - Supplies the address of a lock queue handle.

Return Value:

    None.

--*/

{

    //
    // Raise IRQL to SYNCH_LEVEL and acquire the specified in stack
    // queued spin lock.
    //

#if !defined(NT_UP)

    LockHandle->LockQueue.Lock = SpinLock;
    LockHandle->LockQueue.Next = NULL;

#else

    UNREFERENCED_PARAMETER(SpinLock);

#endif    

    LockHandle->OldIrql = KfRaiseIrql(SYNCH_LEVEL);
    KxAcquireQueuedSpinLock(&LockHandle->LockQueue, SpinLock);
    return;
}

VOID
KeAcquireInStackQueuedSpinLockAtDpcLevel (
    __inout PKSPIN_LOCK SpinLock,
    __out PKLOCK_QUEUE_HANDLE LockHandle
    )

/*++

Routine Description:

    This function acquires the specified in stack queued spin lock at the
    current IRQL.

Arguments:

    SpinLock - Supplies a pointer to thehome address of a spin lock.

    LockHandle - Supplies the address of a lock queue handle.

Return Value:

    None.

--*/

{

    //
    // Acquire the specified in stack queued spin lock at the current
    // IRQL.
    //

#if !defined(NT_UP)

    LockHandle->LockQueue.Lock = SpinLock;
    LockHandle->LockQueue.Next = NULL;

#else

    UNREFERENCED_PARAMETER(SpinLock);

#endif

    KxAcquireQueuedSpinLock(&LockHandle->LockQueue, SpinLock);
    return;
}

VOID
KeReleaseInStackQueuedSpinLock (
    __in PKLOCK_QUEUE_HANDLE LockHandle
    )

/*++

Routine Description:

    This function releases an in stack queued spin lock and lowers the IRQL
    to its previous value.

Arguments:

    LockHandle - Supplies the address of a lock queue handle.

Return Value:

    None.

--*/

{

    //
    // Release the specified in stack queued spin lock and lower IRQL.
    //

    KxReleaseQueuedSpinLock(&LockHandle->LockQueue);
    KeLowerIrql(LockHandle->OldIrql);
    return;
}

VOID
KeReleaseInStackQueuedSpinLockFromDpcLevel (
    __in PKLOCK_QUEUE_HANDLE LockHandle
    )

/*++

Routine Description:

    This function releases an in stack queued spinlock at the current IRQL.

Arguments:

   LockHandle - Supplies a pointer to lock queue handle.

Return Value:

    None.

--*/

{

    //
    // Release the specified in stack queued spin lock at the current IRQL.
    //

    KxReleaseQueuedSpinLock(&LockHandle->LockQueue);
    return;
}

KIRQL
KiAcquireDispatcherLockRaiseToSynch (
    VOID
    )

/*++

Routine Description:

    This function raises IRQL to SYNCH_LEVEL and acquires the dispatcher
    database queued spin lock.

Arguments:

    None.

Return Value:

    The previous IRQL is returned as the function value.

--*/

{

    PKSPIN_LOCK_QUEUE LockQueue;
    KIRQL OldIrql;
    PKSPIN_LOCK SpinLock;

    //
    // Raise IRQL to SYNCH_LEVEL and acquire the dispatcher database queued
    // spin lock.
    //

    OldIrql = KfRaiseIrql(SYNCH_LEVEL);
    LockQueue = &KiGetLockQueue()[LockQueueDispatcherLock];
    SpinLock = LockQueue->Lock;
    KxAcquireQueuedSpinLock(LockQueue, SpinLock);
    return OldIrql;
}

VOID
KiAcquireDispatcherLockAtSynchLevel (
    VOID
    )

/*++

Routine Description:

    This function acquires the dispatcher database queued spin lock at the
    current IRQL.

Arguments:

    None.

Return Value:

    None.

--*/

{

    PKSPIN_LOCK_QUEUE LockQueue;
    PKSPIN_LOCK SpinLock;

    //
    // Acquire the dispatcher database queued spin lock at the current IRQL.
    //

    LockQueue = &KiGetLockQueue()[LockQueueDispatcherLock];
    SpinLock = LockQueue->Lock;
    KxAcquireQueuedSpinLock(LockQueue, SpinLock);
    return;
}

VOID
KiReleaseDispatcherLockFromSynchLevel (
    VOID
    )

/*

Routine Description:

    This function releases the dispatcher database queued spinlock from the
    current IRQL.

Arguments:

    None.

Return Value:

    None.

--*/

{

    //
    // Release the dispatcher databsse queued spin lock at the current IRQL.
    //

    KxReleaseQueuedSpinLock(&KiGetLockQueue()[LockQueueDispatcherLock]);
    return;
}

LOGICAL
KiTryToAcquireDispatcherLockRaiseToSynch (
    __out PKIRQL OldIrql
    )

/*++

Routine Description:

    This function raises IRQL to SYNCH_LEVEL and attempts to acquire the
    dispatcher database spin lock. If the dispatcher database lock is
    already owned, then IRQL is restored to its previous value and FALSE
    is returned. Otherwise, the dispatcher database lock is acquired and
    TRUE is returned.

Arguments:

    OldIrql - Supplies a pointer to the variable to receive the old IRQL.

Return Value:

    If the dispatcher database lock is acquired a value TRUE is returned.
    Otherwise, FALSE is returned as the function value.

--*/

{

    PKSPIN_LOCK_QUEUE LockQueue;
    PKSPIN_LOCK SpinLock;

    //
    // Try to acquire the dispatcher database queued spin lock at SYNCH_LEVEL.
    //

    *OldIrql = KfRaiseIrql(SYNCH_LEVEL);
    LockQueue = &KiGetLockQueue()[LockQueueDispatcherLock];
    SpinLock = LockQueue->Lock;
    if (KxTryToAcquireQueuedSpinLock(LockQueue, SpinLock) == FALSE) {
        KeLowerIrql(*OldIrql);
        return FALSE;

    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ke\amd64\zero.asm ===
title  "Zero Page"
;++
;
; Copyright (c) Microsoft Corporation. All rights reserved. 
;
; You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
; If you do not agree to the terms, do not use the code.
;
;
; Module Name:
;
;   zero.asm
;
; Abstract:
;
;   This module implements the architecture dependent code necessary to
;   zero pages of memory in the fastest possible way.
;
;--

include ksamd64.inc

        subttl  "Zero Single Page"
;++
;
; VOID
; KeZeroSinglePage (
;     IN PVOID PageBase
;     )
;
; Routine Description:
;
;   This routine zeros the specified page of memory using normal moves.
;
; Arguments:
;
;   PageBase (rcx) - Supplies the address of the pages to zero.
;
; Return Value:
;
;    None.
;
;--

        LEAF_ENTRY KeZeroSinglePage, _TEXT$00

        xor     eax, eax                ; clear register
        mov     edx, PAGE_SIZE / 64     ; set number of 64 byte blocks

        align   16

KiZP10: mov     [rcx], rax              ; zero 64-byte block
        mov     8[rcx], rax             ;
        mov     16[rcx], rax            ;
        add     rcx, 64                 ; advance to next block
        mov     (24 - 64)[rcx], rax     ;
        mov     (32 - 64)[rcx], rax     ;
        dec     edx                     ; decrement loop count
        mov     (40 - 64)[rcx], rax     ;
        mov     (48 - 64)[rcx], rax     ;
        mov     (56 - 64)[rcx], rax     ;
        jnz     short KiZP10            ; if nz, more bytes to zero
        ret                             ; return

        LEAF_END KeZeroSinglePage, _TEXT$00

        subttl  "Zero Pages"
;++
;
; VOID
; KeZeroPages (
;     IN PVOID PageBase,
;     IN SIZE_T NumberOfBytes
;     )
;
; Routine Description:
;
;   This routine zeros the specified pages of memory using nontemporal moves.
;
; Arguments:
;
;   PageBase (rcx) - Supplies the address of the pages to zero.
;
;   NumberOfBytes (rdx) - Supplies the number of bytes to zero.  Always a PAGE_SIZE multiple.
;
; Return Value:
;
;    None.
;
;--

        LEAF_ENTRY KeZeroPages, _TEXT$00

        xor     eax, eax                ; clear register
        shr     rdx, 7                  ; number of 128 byte chunks (loop count)

        align   16

KiZS10: movnti  [rcx], rax              ; zero 128-byte block
        movnti  [rcx +  8], rax         ;
        movnti  [rcx + 16], rax         ;
        movnti  [rcx + 24], rax         ;
        movnti  [rcx + 32], rax         ;
        movnti  [rcx + 40], rax         ;
        movnti  [rcx + 48], rax         ;
        movnti  [rcx + 56], rax         ;
        add     rcx, 128                ; advance to next block
        movnti  [rcx - 64], rax         ;
        movnti  [rcx - 56], rax         ;
        movnti  [rcx - 48], rax         ;
        movnti  [rcx - 40], rax         ;
        movnti  [rcx - 32], rax         ;
        movnti  [rcx - 24], rax         ;
        movnti  [rcx - 16], rax         ;
        movnti  [rcx -  8], rax         ;
        dec     rdx                     ; decrement loop count
        jnz     short KiZS10            ; if nz, more bytes to zero
   lock or      byte ptr [rsp], 0       ; flush data to memory
        ret                             ; return

        LEAF_END KeZeroPages, _TEXT$00

;++
;
; VOID
; KeCopyPage (
;     IN PVOID Destination,
;     IN PVOID Source
;     )
;
; Routine Description:
;
;   This routine copies a page of memory using nontemporal moves.
;
; Arguments:
;
;   Destination (rcx) - Supplies the address of the target page.
;
;   Source (rdx) - Supplies the address of the source page.
;
; Return Value:
;
;    None.
;
;--

        LEAF_ENTRY KeCopyPage, _TEXT$00

;
; Set rcx and rdx to the end of their respective pages
;

        add     rcx, PAGE_SIZE
        add     rdx, PAGE_SIZE

;
; Load the entire source page into the L0 cache
;

        mov     rax, -PAGE_SIZE

        align   16

KiCP10: prefetchnta [rdx + rax + 64 * 0]
        prefetchnta [rdx + rax + 64 * 1]
        prefetchnta [rdx + rax + 64 * 2]
        prefetchnta [rdx + rax + 64 * 3]
        add     rax, 64*4
        jnz     short KiCP10

;
; Now copy from L0 cache to the target
;

        mov     rax, -PAGE_SIZE

        align   16

KiCP20: movdqa  xmm0, [rdx + rax + 16 * 0]
        movdqa  xmm1, [rdx + rax + 16 * 1]
        movdqa  xmm2, [rdx + rax + 16 * 2]
        movdqa  xmm3, [rdx + rax + 16 * 3]
        movntdq [rcx + rax + 16 * 0], xmm0
        movntdq [rcx + rax + 16 * 1], xmm1
        movntdq [rcx + rax + 16 * 2], xmm2
        movntdq [rcx + rax + 16 * 3], xmm3
        add     rax, 16*4
        jnz     short KiCP20
        sfence
        ret

        LEAF_END KeCopyPage, _TEXT$00

        end
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ke\amd64\thredini.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    thredini.c

Abstract:

    This module implements the machine dependent function to set the initial
    context and data alignment handling mode for a process or thread object.

--*/

#include "ki.h"

VOID
KiInitializeContextThread (
    IN PKTHREAD Thread,
    IN PKSYSTEM_ROUTINE SystemRoutine,
    IN PKSTART_ROUTINE StartRoutine OPTIONAL,
    IN PVOID StartContext OPTIONAL,
    IN PCONTEXT ContextRecord OPTIONAL
    )

/*++

Routine Description:

    This function initializes the machine dependent context of a thread
    object.

    N.B. This function does not check if context record is accessible.
         It is assumed the the caller of this routine is either prepared
         to handle access violations or has probed and copied the context
         record as appropriate.

Arguments:

    Thread - Supplies a pointer to a dispatcher object of type thread.

    SystemRoutine - Supplies a pointer to the system function that is to be
        called when the thread is first scheduled for execution.

    StartRoutine - Supplies an optional pointer to a function that is to be
        called after the system has finished initializing the thread. This
        parameter is specified if the thread is a system thread and will
        execute totally in kernel mode.

    StartContext - Supplies an optional pointer to a data structure that
        will be passed to the StartRoutine as a parameter. This parameter
        is specified if the thread is a system thread and will execute
        totally in kernel mode.

    ContextRecord - Supplies an optional pointer a context record which
        contains the initial user mode state of the thread. This parameter
        is specified if the thread will execute in user mode.

Return Value:

    None.

--*/

{

    CONTEXT ContextFrame;
    PKEXCEPTION_FRAME ExFrame;
    ULONG64 InitialStack;
    PXMM_SAVE_AREA32 NpxFrame;
    PKSTART_FRAME SfFrame;
    PKERNEL_STACK_CONTROL StackControl;
    PKSWITCH_FRAME SwFrame;
    PKTRAP_FRAME TrFrame;

    //
    // Allocate a legacy floating point save area at the base of the thread
    // stack and record the initial stack as this address. All threads have
    // a legacy floating point save are to avoid special cases in the context
    // switch code.
    //

    InitialStack = (ULONG64)Thread->InitialStack;
    NpxFrame = (PXMM_SAVE_AREA32)(InitialStack - KERNEL_STACK_CONTROL_LENGTH);
    RtlZeroMemory(NpxFrame, KERNEL_STACK_CONTROL_LENGTH);

    //
    // Initialize the current kernel stack segment descriptor in the kernel
    // stack control area. This descriptor is used to control kernel stack
    // expansion from drivers.
    //
    // N.B. The previous stack segment descriptor is zeroed.
    //

    StackControl = (PKERNEL_STACK_CONTROL)NpxFrame;
    StackControl->Current.StackBase = InitialStack;
    StackControl->Current.ActualLimit = InitialStack - KERNEL_STACK_SIZE;

    //
    // If a context record is specified, then initialize a trap frame, and
    // an exception frame with the specified user mode context.
    //
    // N.B. The initial context of a thread cannot set the debug or floating
    //      state.
    //

    if (ARGUMENT_PRESENT(ContextRecord)) {
        ContextFrame = *ContextRecord;
        ContextRecord = &ContextFrame;
        ContextRecord->ContextFlags &= ~(CONTEXT_DEBUG_REGISTERS | CONTEXT_FLOATING_POINT);
        ContextRecord->ContextFlags |= CONTEXT_CONTROL;

        //
        // Allocate a trap frame, an exception frame, and a context switch
        // frame.
        //

        TrFrame = (PKTRAP_FRAME)(((ULONG64)NpxFrame - KTRAP_FRAME_LENGTH));
        ExFrame = (PKEXCEPTION_FRAME)(((ULONG64)TrFrame - KEXCEPTION_FRAME_LENGTH));
        SwFrame = (PKSWITCH_FRAME)(((ULONG64)ExFrame - KSWITCH_FRAME_LENGTH));

        //
        // Set CS and SS for user mode 64-bit execution in the machine frame.
        //

        ContextRecord->SegCs = KGDT64_R3_CODE | RPL_MASK;
        ContextRecord->SegSs = KGDT64_R3_DATA | RPL_MASK;

        //
        // The main entry point for the user thread will be jumped to via a
        // continue operation from the user APC dispatcher. Therefore, the
        // user stack must be initialized to an 8 mod 16 boundary.
        //
        // In addition, we must have room for the home addresses for the
        // first four parameters.
        //

        ContextRecord->Rsp =
            (ContextRecord->Rsp & ~STACK_ROUND) - ((4 * 8) + 8);

        //
        // Zero the exception and trap frames and copy information from the
        // specified context frame to the trap and exception frames.
        //
        // N.B. The function that performs the context to kernel frames does
        //      not initialize the legacy floating context.
        //

        RtlZeroMemory(ExFrame, sizeof(KEXCEPTION_FRAME));
        RtlZeroMemory(TrFrame, sizeof(KTRAP_FRAME));
        KxContextToKframes(TrFrame,
                           ExFrame,
                           ContextRecord,
                           ContextRecord->ContextFlags,
                           UserMode);

        //
        // Initialize user thread startup information.
        //

        ExFrame->P1Home = (ULONG64)StartContext;
        ExFrame->P2Home = (ULONG64)StartRoutine;
        ExFrame->P3Home = (ULONG64)SystemRoutine;
        ExFrame->Return = (ULONG64)KiStartUserThreadReturn;

        //
        // Initialize start address.
        //

        SwFrame->Return = (ULONG64)KiStartUserThread;

        //
        // Set the initial legacy floating point control/tag word state and
        // the XMM control/status state.
        //

        NpxFrame->ControlWord = INITIAL_FPCSR;
        NpxFrame->MxCsr = INITIAL_MXCSR;
        TrFrame->MxCsr = INITIAL_MXCSR;

        //
        // Set legacy floating point state to switch.
        //

        Thread->NpxState = LEGACY_STATE_SWITCH;

        //
        // Set the saved previous processor mode in the thread object.
        //

        Thread->PreviousMode = UserMode;

    } else {

        //
        // Allocate an exception frame and a context switch frame.
        //

        TrFrame = NULL;
        SfFrame = (PKSTART_FRAME)(((ULONG64)NpxFrame - KSTART_FRAME_LENGTH));
        SwFrame = (PKSWITCH_FRAME)(((ULONG64)SfFrame - KSWITCH_FRAME_LENGTH));

        //
        // Initialize the system thread start frame.
        //

        SfFrame->P1Home = (ULONG64)StartContext;
        SfFrame->P2Home = (ULONG64)StartRoutine;
        SfFrame->P3Home = (ULONG64)SystemRoutine;
        SfFrame->Return = 0;

        //
        // Initialize start address.
        //

        SwFrame->Return = (ULONG64)KiStartSystemThread;

        //
        // Set legacy floating point state to unused.
        //

        Thread->NpxState = LEGACY_STATE_UNUSED;

        //
        // Set the previous mode in thread object to kernel.
        //

        Thread->PreviousMode = KernelMode;
    }

    //
    // Initialize context switch frame and set thread start up parameters.
    //

    SwFrame->ApcBypass = APC_LEVEL;
    SwFrame->Rbp = (ULONG64)TrFrame + 128;

    //
    // Set the initial kernel stack pointer.
    //

    Thread->InitialStack = (PVOID)NpxFrame;
    Thread->KernelStack = SwFrame;
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ke\amd64\threadbg.asm ===
title  "Thread Startup"
;++
;
; Copyright (c) Microsoft Corporation. All rights reserved. 
;
; You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
; If you do not agree to the terms, do not use the code.
;
;
; Module Name:
;
;    threadbg.asm
;
; Abstract:
;
;    This module implements the code necessary to startup a thread in kernel
;    mode.
;
; Environment:
;
;    IRQL APC_LEVEL.
;
;--

include ksamd64.inc

        altentry KiStartSystemThread
        altentry KiStartUserThread
        altentry KiStartUserThreadReturn

        extern  KeBugCheck:proc
        extern  KiExceptionExit:proc
        extern  KiSaveDebugRegisterState:proc

        subttl  "System Thread Startup"
;++
;
; Routine Description:
;
;   This routine is called to start a system thread. This function calls the
;   initial thread procedure after having extracted the startup parameters
;   from the specified start frame. If control returns from the initial
;   thread procedure, then a bugcheck will occur.
;
; Implicit Arguments:
;
;   N.B. This function begins execution at its alternate entry point with
;        a start frame on the stack. This frame contains the start context,
;        the start routine, and the system routine.
;
; Return Value:
;
;    None - no return.
;
;--

        NESTED_ENTRY KxStartSystemThread, _TEXT$00

        .allocstack (KSTART_FRAME_LENGTH - 8) ; allocate stack frame

        END_PROLOGUE

        ALTERNATE_ENTRY KiStartSystemThread

        mov     ecx, APC_LEVEL          ; set IRQL to APC level

        SetIrql                         ; 

        mov     rdx, SfP1Home[rsp]      ; get startup context parameter
        mov     rcx, SfP2Home[rsp]      ; get startup routine address
        call    qword ptr SfP3Home[rsp] ; call system routine
        mov     rcx, NO_USER_MODE_CONTEXT ; set bugcheck parameter
        call    KeBugCheck              ; call bugcheck - no return
        nop                             ; do not remove

        NESTED_END KxStartSystemThread, _TEXT$00

        subttl  "User Thread Startup"
;++
;
; Routine Description:
;
;   This routine is called to start a user thread. This function calls the
;   initial thread procedure after having extracted the startup parameters
;   from the specified exception frame. If control returns from the initial
;   thread routine, then the user mode context is restored and control is
;   transferred to the exception exit code.
;
; Implicit Arguments:
;
;   N.B. This function begins execution with a trap frame and an exception
;        frame on the stack that represents the user mode context. The start
;        context, start routine, and the system routine parameters are stored
;        in the exception record.
;
; Return Value:
;
;    None.
;
;--

        NESTED_ENTRY KyStartUserThread, _TEXT$00

        GENERATE_TRAP_FRAME             ; generate trap frame

        call    KxStartUserThread       ; call dummy startup routine

        ALTERNATE_ENTRY KiStartUserThreadReturn

        nop                             ; do not remove

        NESTED_END KyStartUserThread, _TEXT$00


        NESTED_ENTRY KxStartUserThread, _TEXT$00

        GENERATE_EXCEPTION_FRAME        ; generate exception frame

        ALTERNATE_ENTRY KiStartUserThread

        mov     ecx, APC_LEVEL          ; set IRQL to APC level

        SetIrql                         ; 

        mov     rdx, ExP1Home[rsp]      ; get startup context parameter
        mov     rcx, ExP2Home[rsp]      ; get startup  routine address
        call    qword ptr ExP3Home[rsp] ; call system routine

;
; N.B. The below code uses an unusual sequence to transfer control. This
;      instruction sequence is required to avoid detection as an epilogue.
;

        lea     rcx, KiExceptionExit    ; get address of exception exit
        jmp     rcx                     ; finish in common code

        NESTED_END KxStartUserThread, _TEXT$00

        end
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ke\amd64\systable.asm ===
;++
;
; Copyright (c) Microsoft Corporation. All rights reserved. 
;
; You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
; If you do not agree to the terms, do not use the code.
;
; Module Name:
;
;   systable.asm
;
; Abstract:
;
;   This module implements the system service dispatch table.
;
;--

include ksamd64.inc

TABLE_ERROR macro t
.err    ; Maximum number of in-memory system service arguments exceeded.
        endm

TABLE_BEGIN1 macro t
        title   t
        endm

TABLE_BEGIN2 macro t
_TEXT$00 segment page 'code'
        endm

TABLE_BEGIN3 macro t
        endm

TABLE_BEGIN4 macro t
        public  KiServiceTable
KiServiceTable label qword
        endm

TABLE_BEGIN5 macro t
        endm

TABLE_BEGIN6 macro t
        endm

TABLE_BEGIN7 macro t
        endm

TABLE_BEGIN8 macro t
        endm


TABLE_ENTRY macro l,bias,numargs
.erre   numargs le 14
        extrn   Nt&l:proc
        dq      offset Nt&l+numargs
        endm

TABLE_END macro n
        public  KiServiceLimit
KiServiceLimit label dword
        dd     n + 1
        endm

ARGTBL_BEGIN macro
        endm

ARGTBL_ENTRY macro e0, e1, e2, e3, e4, e5, e6, e7
        endm

ARGTBL_END macro
_TEXT$00 ends
        end
        endm

        TABLE_BEGIN1 <"System Service Dispatch Table">
        TABLE_BEGIN2 <"System Service Dispatch Table">
        TABLE_BEGIN3 <"System Service Dispatch Table">
        TABLE_BEGIN4 <"System Service Dispatch Table">
        TABLE_BEGIN5 <"System Service Dispatch Table">
        TABLE_BEGIN6 <"System Service Dispatch Table">
        TABLE_BEGIN7 <"System Service Dispatch Table">
        TABLE_BEGIN8 <"System Service Dispatch Table">
TABLE_ENTRY  MapUserPhysicalPagesScatter, 0, 0 
TABLE_ENTRY  WaitForSingleObject, 0, 0 
TABLE_ENTRY  CallbackReturn, 0, 0 
TABLE_ENTRY  ReadFile, 1, 5 
TABLE_ENTRY  DeviceIoControlFile, 1, 6 
TABLE_ENTRY  WriteFile, 1, 5 
TABLE_ENTRY  RemoveIoCompletion, 1, 1 
TABLE_ENTRY  ReleaseSemaphore, 0, 0 
TABLE_ENTRY  ReplyWaitReceivePort, 0, 0 
TABLE_ENTRY  ReplyPort, 0, 0 
TABLE_ENTRY  SetInformationThread, 0, 0 
TABLE_ENTRY  SetEvent, 0, 0 
TABLE_ENTRY  Close, 0, 0 
TABLE_ENTRY  QueryObject, 1, 1 
TABLE_ENTRY  QueryInformationFile, 1, 1 
TABLE_ENTRY  OpenKey, 0, 0 
TABLE_ENTRY  EnumerateValueKey, 1, 2 
TABLE_ENTRY  FindAtom, 0, 0 
TABLE_ENTRY  QueryDefaultLocale, 0, 0 
TABLE_ENTRY  QueryKey, 1, 1 
TABLE_ENTRY  QueryValueKey, 1, 2 
TABLE_ENTRY  AllocateVirtualMemory, 1, 2 
TABLE_ENTRY  QueryInformationProcess, 1, 1 
TABLE_ENTRY  WaitForMultipleObjects32, 1, 1 
TABLE_ENTRY  WriteFileGather, 1, 5 
TABLE_ENTRY  SetInformationProcess, 0, 0 
TABLE_ENTRY  CreateKey, 1, 3 
TABLE_ENTRY  FreeVirtualMemory, 0, 0 
TABLE_ENTRY  ImpersonateClientOfPort, 0, 0 
TABLE_ENTRY  ReleaseMutant, 0, 0 
TABLE_ENTRY  QueryInformationToken, 1, 1 
TABLE_ENTRY  RequestWaitReplyPort, 0, 0 
TABLE_ENTRY  QueryVirtualMemory, 1, 2 
TABLE_ENTRY  OpenThreadToken, 0, 0 
TABLE_ENTRY  QueryInformationThread, 1, 1 
TABLE_ENTRY  OpenProcess, 0, 0 
TABLE_ENTRY  SetInformationFile, 1, 1 
TABLE_ENTRY  MapViewOfSection, 1, 6 
TABLE_ENTRY  AccessCheckAndAuditAlarm, 1, 7 
TABLE_ENTRY  UnmapViewOfSection, 0, 0 
TABLE_ENTRY  ReplyWaitReceivePortEx, 1, 1 
TABLE_ENTRY  TerminateProcess, 0, 0 
TABLE_ENTRY  SetEventBoostPriority, 0, 0 
TABLE_ENTRY  ReadFileScatter, 1, 5 
TABLE_ENTRY  OpenThreadTokenEx, 1, 1 
TABLE_ENTRY  OpenProcessTokenEx, 0, 0 
TABLE_ENTRY  QueryPerformanceCounter, 0, 0 
TABLE_ENTRY  EnumerateKey, 1, 2 
TABLE_ENTRY  OpenFile, 1, 2 
TABLE_ENTRY  DelayExecution, 0, 0 
TABLE_ENTRY  QueryDirectoryFile, 1, 7 
TABLE_ENTRY  QuerySystemInformation, 0, 0 
TABLE_ENTRY  OpenSection, 0, 0 
TABLE_ENTRY  QueryTimer, 1, 1 
TABLE_ENTRY  FsControlFile, 1, 6 
TABLE_ENTRY  WriteVirtualMemory, 1, 1 
TABLE_ENTRY  CloseObjectAuditAlarm, 0, 0 
TABLE_ENTRY  DuplicateObject, 1, 3 
TABLE_ENTRY  QueryAttributesFile, 0, 0 
TABLE_ENTRY  ClearEvent, 0, 0 
TABLE_ENTRY  ReadVirtualMemory, 1, 1 
TABLE_ENTRY  OpenEvent, 0, 0 
TABLE_ENTRY  AdjustPrivilegesToken, 1, 2 
TABLE_ENTRY  DuplicateToken, 1, 2 
TABLE_ENTRY  Continue, 0, 0 
TABLE_ENTRY  QueryDefaultUILanguage, 0, 0 
TABLE_ENTRY  QueueApcThread, 1, 1 
TABLE_ENTRY  YieldExecution, 0, 0 
TABLE_ENTRY  AddAtom, 0, 0 
TABLE_ENTRY  CreateEvent, 1, 1 
TABLE_ENTRY  QueryVolumeInformationFile, 1, 1 
TABLE_ENTRY  CreateSection, 1, 3 
TABLE_ENTRY  FlushBuffersFile, 0, 0 
TABLE_ENTRY  ApphelpCacheControl, 0, 0 
TABLE_ENTRY  CreateProcessEx, 1, 5 
TABLE_ENTRY  CreateThread, 1, 4 
TABLE_ENTRY  IsProcessInJob, 0, 0 
TABLE_ENTRY  ProtectVirtualMemory, 1, 1 
TABLE_ENTRY  QuerySection, 1, 1 
TABLE_ENTRY  ResumeThread, 0, 0 
TABLE_ENTRY  TerminateThread, 0, 0 
TABLE_ENTRY  ReadRequestData, 1, 2 
TABLE_ENTRY  CreateFile, 1, 7 
TABLE_ENTRY  QueryEvent, 1, 1 
TABLE_ENTRY  WriteRequestData, 1, 2 
TABLE_ENTRY  OpenDirectoryObject, 0, 0 
TABLE_ENTRY  AccessCheckByTypeAndAuditAlarm, 1, 12 
TABLE_ENTRY  QuerySystemTime, 0, 0 
TABLE_ENTRY  WaitForMultipleObjects, 1, 1 
TABLE_ENTRY  SetInformationObject, 0, 0 
TABLE_ENTRY  CancelIoFile, 0, 0 
TABLE_ENTRY  TraceEvent, 0, 0 
TABLE_ENTRY  PowerInformation, 1, 1 
TABLE_ENTRY  SetValueKey, 1, 2 
TABLE_ENTRY  CancelTimer, 0, 0 
TABLE_ENTRY  SetTimer, 1, 3 
TABLE_ENTRY  AcceptConnectPort, 1, 2 
TABLE_ENTRY  AccessCheck, 1, 4 
TABLE_ENTRY  AccessCheckByType, 1, 7 
TABLE_ENTRY  AccessCheckByTypeResultList, 1, 7 
TABLE_ENTRY  AccessCheckByTypeResultListAndAuditAlarm, 1, 12 
TABLE_ENTRY  AccessCheckByTypeResultListAndAuditAlarmByHandle, 1, 13 
TABLE_ENTRY  AddBootEntry, 0, 0 
TABLE_ENTRY  AddDriverEntry, 0, 0 
TABLE_ENTRY  AdjustGroupsToken, 1, 2 
TABLE_ENTRY  AlertResumeThread, 0, 0 
TABLE_ENTRY  AlertThread, 0, 0 
TABLE_ENTRY  AllocateLocallyUniqueId, 0, 0 
TABLE_ENTRY  AllocateUserPhysicalPages, 0, 0 
TABLE_ENTRY  AllocateUuids, 0, 0 
TABLE_ENTRY  AreMappedFilesTheSame, 0, 0 
TABLE_ENTRY  AssignProcessToJobObject, 0, 0 
TABLE_ENTRY  CancelDeviceWakeupRequest, 0, 0 
TABLE_ENTRY  CompactKeys, 0, 0 
TABLE_ENTRY  CompareTokens, 0, 0 
TABLE_ENTRY  CompleteConnectPort, 0, 0 
TABLE_ENTRY  CompressKey, 0, 0 
TABLE_ENTRY  ConnectPort, 1, 4 
TABLE_ENTRY  CreateDebugObject, 0, 0 
TABLE_ENTRY  CreateDirectoryObject, 0, 0 
TABLE_ENTRY  CreateEventPair, 0, 0 
TABLE_ENTRY  CreateIoCompletion, 0, 0 
TABLE_ENTRY  CreateJobObject, 0, 0 
TABLE_ENTRY  CreateJobSet, 0, 0 
TABLE_ENTRY  CreateKeyedEvent, 0, 0 
TABLE_ENTRY  CreateMailslotFile, 1, 4 
TABLE_ENTRY  CreateMutant, 0, 0 
TABLE_ENTRY  CreateNamedPipeFile, 1, 10 
TABLE_ENTRY  CreatePagingFile, 0, 0 
TABLE_ENTRY  CreatePort, 1, 1 
TABLE_ENTRY  CreateProcess, 1, 4 
TABLE_ENTRY  CreateProfile, 1, 5 
TABLE_ENTRY  CreateSemaphore, 1, 1 
TABLE_ENTRY  CreateSymbolicLinkObject, 0, 0 
TABLE_ENTRY  CreateTimer, 0, 0 
TABLE_ENTRY  CreateToken, 1, 9 
TABLE_ENTRY  CreateWaitablePort, 1, 1 
TABLE_ENTRY  DebugActiveProcess, 0, 0 
TABLE_ENTRY  DebugContinue, 0, 0 
TABLE_ENTRY  DeleteAtom, 0, 0 
TABLE_ENTRY  DeleteBootEntry, 0, 0 
TABLE_ENTRY  DeleteDriverEntry, 0, 0 
TABLE_ENTRY  DeleteFile, 0, 0 
TABLE_ENTRY  DeleteKey, 0, 0 
TABLE_ENTRY  DeleteObjectAuditAlarm, 0, 0 
TABLE_ENTRY  DeleteValueKey, 0, 0 
TABLE_ENTRY  DisplayString, 0, 0 
TABLE_ENTRY  EnumerateBootEntries, 0, 0 
TABLE_ENTRY  EnumerateDriverEntries, 0, 0 
TABLE_ENTRY  EnumerateSystemEnvironmentValuesEx, 0, 0 
TABLE_ENTRY  ExtendSection, 0, 0 
TABLE_ENTRY  FilterToken, 1, 2 
TABLE_ENTRY  FlushInstructionCache, 0, 0 
TABLE_ENTRY  FlushKey, 0, 0 
TABLE_ENTRY  FlushVirtualMemory, 0, 0 
TABLE_ENTRY  FlushWriteBuffer, 0, 0 
TABLE_ENTRY  FreeUserPhysicalPages, 0, 0 
TABLE_ENTRY  GetContextThread, 0, 0 
TABLE_ENTRY  GetCurrentProcessorNumber, 0, 0 
TABLE_ENTRY  GetDevicePowerState, 0, 0 
TABLE_ENTRY  GetPlugPlayEvent, 0, 0 
TABLE_ENTRY  GetWriteWatch, 1, 3 
TABLE_ENTRY  ImpersonateAnonymousToken, 0, 0 
TABLE_ENTRY  ImpersonateThread, 0, 0 
TABLE_ENTRY  InitializeRegistry, 0, 0 
TABLE_ENTRY  InitiatePowerAction, 0, 0 
TABLE_ENTRY  IsSystemResumeAutomatic, 0, 0 
TABLE_ENTRY  ListenPort, 0, 0 
TABLE_ENTRY  LoadDriver, 0, 0 
TABLE_ENTRY  LoadKey, 0, 0 
TABLE_ENTRY  LoadKey2, 0, 0 
TABLE_ENTRY  LoadKeyEx, 0, 0 
TABLE_ENTRY  LockFile, 1, 6 
TABLE_ENTRY  LockProductActivationKeys, 0, 0 
TABLE_ENTRY  LockRegistryKey, 0, 0 
TABLE_ENTRY  LockVirtualMemory, 0, 0 
TABLE_ENTRY  MakePermanentObject, 0, 0 
TABLE_ENTRY  MakeTemporaryObject, 0, 0 
TABLE_ENTRY  MapUserPhysicalPages, 0, 0 
TABLE_ENTRY  ModifyBootEntry, 0, 0 
TABLE_ENTRY  ModifyDriverEntry, 0, 0 
TABLE_ENTRY  NotifyChangeDirectoryFile, 1, 5 
TABLE_ENTRY  NotifyChangeKey, 1, 6 
TABLE_ENTRY  NotifyChangeMultipleKeys, 1, 8 
TABLE_ENTRY  OpenEventPair, 0, 0 
TABLE_ENTRY  OpenIoCompletion, 0, 0 
TABLE_ENTRY  OpenJobObject, 0, 0 
TABLE_ENTRY  OpenKeyedEvent, 0, 0 
TABLE_ENTRY  OpenMutant, 0, 0 
TABLE_ENTRY  OpenObjectAuditAlarm, 1, 8 
TABLE_ENTRY  OpenProcessToken, 0, 0 
TABLE_ENTRY  OpenSemaphore, 0, 0 
TABLE_ENTRY  OpenSymbolicLinkObject, 0, 0 
TABLE_ENTRY  OpenThread, 0, 0 
TABLE_ENTRY  OpenTimer, 0, 0 
TABLE_ENTRY  PlugPlayControl, 0, 0 
TABLE_ENTRY  PrivilegeCheck, 0, 0 
TABLE_ENTRY  PrivilegeObjectAuditAlarm, 1, 2 
TABLE_ENTRY  PrivilegedServiceAuditAlarm, 1, 1 
TABLE_ENTRY  PulseEvent, 0, 0 
TABLE_ENTRY  QueryBootEntryOrder, 0, 0 
TABLE_ENTRY  QueryBootOptions, 0, 0 
TABLE_ENTRY  QueryDebugFilterState, 0, 0 
TABLE_ENTRY  QueryDirectoryObject, 1, 3 
TABLE_ENTRY  QueryDriverEntryOrder, 0, 0 
TABLE_ENTRY  QueryEaFile, 1, 5 
TABLE_ENTRY  QueryFullAttributesFile, 0, 0 
TABLE_ENTRY  QueryInformationAtom, 1, 1 
TABLE_ENTRY  QueryInformationJobObject, 1, 1 
TABLE_ENTRY  QueryInformationPort, 1, 1 
TABLE_ENTRY  QueryInstallUILanguage, 0, 0 
TABLE_ENTRY  QueryIntervalProfile, 0, 0 
TABLE_ENTRY  QueryIoCompletion, 1, 1 
TABLE_ENTRY  QueryMultipleValueKey, 1, 2 
TABLE_ENTRY  QueryMutant, 1, 1 
TABLE_ENTRY  QueryOpenSubKeys, 0, 0 
TABLE_ENTRY  QueryOpenSubKeysEx, 0, 0 
TABLE_ENTRY  QueryPortInformationProcess, 0, 0 
TABLE_ENTRY  QueryQuotaInformationFile, 1, 5 
TABLE_ENTRY  QuerySecurityObject, 1, 1 
TABLE_ENTRY  QuerySemaphore, 1, 1 
TABLE_ENTRY  QuerySymbolicLinkObject, 0, 0 
TABLE_ENTRY  QuerySystemEnvironmentValue, 0, 0 
TABLE_ENTRY  QuerySystemEnvironmentValueEx, 1, 1 
TABLE_ENTRY  QueryTimerResolution, 0, 0 
TABLE_ENTRY  RaiseException, 0, 0 
TABLE_ENTRY  RaiseHardError, 1, 2 
TABLE_ENTRY  RegisterThreadTerminatePort, 0, 0 
TABLE_ENTRY  ReleaseKeyedEvent, 0, 0 
TABLE_ENTRY  RemoveProcessDebug, 0, 0 
TABLE_ENTRY  RenameKey, 0, 0 
TABLE_ENTRY  ReplaceKey, 0, 0 
TABLE_ENTRY  ReplyWaitReplyPort, 0, 0 
TABLE_ENTRY  RequestDeviceWakeup, 0, 0 
TABLE_ENTRY  RequestPort, 0, 0 
TABLE_ENTRY  RequestWakeupLatency, 0, 0 
TABLE_ENTRY  ResetEvent, 0, 0 
TABLE_ENTRY  ResetWriteWatch, 0, 0 
TABLE_ENTRY  RestoreKey, 0, 0 
TABLE_ENTRY  ResumeProcess, 0, 0 
TABLE_ENTRY  SaveKey, 0, 0 
TABLE_ENTRY  SaveKeyEx, 0, 0 
TABLE_ENTRY  SaveMergedKeys, 0, 0 
TABLE_ENTRY  SecureConnectPort, 1, 5 
TABLE_ENTRY  SetBootEntryOrder, 0, 0 
TABLE_ENTRY  SetBootOptions, 0, 0 
TABLE_ENTRY  SetContextThread, 0, 0 
TABLE_ENTRY  SetDebugFilterState, 0, 0 
TABLE_ENTRY  SetDefaultHardErrorPort, 0, 0 
TABLE_ENTRY  SetDefaultLocale, 0, 0 
TABLE_ENTRY  SetDefaultUILanguage, 0, 0 
TABLE_ENTRY  SetDriverEntryOrder, 0, 0 
TABLE_ENTRY  SetEaFile, 0, 0 
TABLE_ENTRY  SetHighEventPair, 0, 0 
TABLE_ENTRY  SetHighWaitLowEventPair, 0, 0 
TABLE_ENTRY  SetInformationDebugObject, 1, 1 
TABLE_ENTRY  SetInformationJobObject, 0, 0 
TABLE_ENTRY  SetInformationKey, 0, 0 
TABLE_ENTRY  SetInformationToken, 0, 0 
TABLE_ENTRY  SetIntervalProfile, 0, 0 
TABLE_ENTRY  SetIoCompletion, 1, 1 
TABLE_ENTRY  SetLdtEntries, 1, 2 
TABLE_ENTRY  SetLowEventPair, 0, 0 
TABLE_ENTRY  SetLowWaitHighEventPair, 0, 0 
TABLE_ENTRY  SetQuotaInformationFile, 0, 0 
TABLE_ENTRY  SetSecurityObject, 0, 0 
TABLE_ENTRY  SetSystemEnvironmentValue, 0, 0 
TABLE_ENTRY  SetSystemEnvironmentValueEx, 1, 1 
TABLE_ENTRY  SetSystemInformation, 0, 0 
TABLE_ENTRY  SetSystemPowerState, 0, 0 
TABLE_ENTRY  SetSystemTime, 0, 0 
TABLE_ENTRY  SetThreadExecutionState, 0, 0 
TABLE_ENTRY  SetTimerResolution, 0, 0 
TABLE_ENTRY  SetUuidSeed, 0, 0 
TABLE_ENTRY  SetVolumeInformationFile, 1, 1 
TABLE_ENTRY  ShutdownSystem, 0, 0 
TABLE_ENTRY  SignalAndWaitForSingleObject, 0, 0 
TABLE_ENTRY  StartProfile, 0, 0 
TABLE_ENTRY  StopProfile, 0, 0 
TABLE_ENTRY  SuspendProcess, 0, 0 
TABLE_ENTRY  SuspendThread, 0, 0 
TABLE_ENTRY  SystemDebugControl, 1, 2 
TABLE_ENTRY  TerminateJobObject, 0, 0 
TABLE_ENTRY  TestAlert, 0, 0 
TABLE_ENTRY  TranslateFilePath, 0, 0 
TABLE_ENTRY  UnloadDriver, 0, 0 
TABLE_ENTRY  UnloadKey, 0, 0 
TABLE_ENTRY  UnloadKey2, 0, 0 
TABLE_ENTRY  UnloadKeyEx, 0, 0 
TABLE_ENTRY  UnlockFile, 1, 1 
TABLE_ENTRY  UnlockVirtualMemory, 0, 0 
TABLE_ENTRY  VdmControl, 0, 0 
TABLE_ENTRY  WaitForDebugEvent, 0, 0 
TABLE_ENTRY  WaitForKeyedEvent, 0, 0 
TABLE_ENTRY  WaitHighEventPair, 0, 0 
TABLE_ENTRY  WaitLowEventPair, 0, 0 

TABLE_END 295 

ARGTBL_BEGIN
ARGTBL_ENTRY 0,0,0,20,24,20,4,0 
ARGTBL_ENTRY 0,0,0,0,0,4,4,0 
ARGTBL_ENTRY 8,0,0,4,8,8,4,4 
ARGTBL_ENTRY 20,0,12,0,0,0,4,0 
ARGTBL_ENTRY 8,0,4,0,4,24,28,0 
ARGTBL_ENTRY 4,0,0,20,4,0,0,8 
ARGTBL_ENTRY 8,0,28,0,0,4,24,4 
ARGTBL_ENTRY 0,12,0,0,4,0,8,8 
ARGTBL_ENTRY 0,0,4,0,0,4,4,12 
ARGTBL_ENTRY 0,0,20,16,0,4,4,0 
ARGTBL_ENTRY 0,8,28,4,8,0,48,0 
ARGTBL_ENTRY 4,0,0,0,4,8,0,12 
ARGTBL_ENTRY 8,16,28,28,48,52,0,0 
ARGTBL_ENTRY 8,0,0,0,0,0,0,0 
ARGTBL_ENTRY 0,0,0,0,0,16,0,0 
ARGTBL_ENTRY 0,0,0,0,0,16,0,40 
ARGTBL_ENTRY 0,4,16,20,4,0,0,36 
ARGTBL_ENTRY 4,0,0,0,0,0,0,0 
ARGTBL_ENTRY 0,0,0,0,0,0,0,8 
ARGTBL_ENTRY 0,0,0,0,0,0,0,0 
ARGTBL_ENTRY 0,12,0,0,0,0,0,0 
ARGTBL_ENTRY 0,0,0,0,24,0,0,0 
ARGTBL_ENTRY 0,0,0,0,0,20,24,32 
ARGTBL_ENTRY 0,0,0,0,0,32,0,0 
ARGTBL_ENTRY 0,0,0,0,0,8,4,0 
ARGTBL_ENTRY 0,0,0,12,0,20,0,4 
ARGTBL_ENTRY 4,4,0,0,4,8,4,0 
ARGTBL_ENTRY 0,0,20,4,4,0,0,4 
ARGTBL_ENTRY 0,0,8,0,0,0,0,0 
ARGTBL_ENTRY 0,0,0,0,0,0,0,0 
ARGTBL_ENTRY 0,0,0,20,0,0,0,0 
ARGTBL_ENTRY 0,0,0,0,0,0,0,4 
ARGTBL_ENTRY 0,0,0,0,4,8,0,0 
ARGTBL_ENTRY 0,0,0,4,0,0,0,0 
ARGTBL_ENTRY 0,0,4,0,0,0,0,0 
ARGTBL_ENTRY 0,8,0,0,0,0,0,0 
ARGTBL_ENTRY 0,4,0,0,0,0,0,0 

ARGTBL_END
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ke\amd64\trap.asm ===
title  "Trap Processing"
;++
;
; Copyright (c) Microsoft Corporation. All rights reserved. 
;
; You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
; If you do not agree to the terms, do not use the code.
;
;
; Module Name:
;
;   trap.asm
;
; Abstract:
;
;   This module implements the code necessary to field and process AMD64
;   trap conditions.
;
;--

include ksamd64.inc

        altentry KiExceptionExit
        altentry KiSystemServiceCopyEnd
        altentry KiSystemServiceCopyStart
        altentry KiSystemServiceExit
        altentry KiSystemServiceGdiTebAccess
        altentry KiSystemServiceRepeat
        altentry KiSystemServiceStart

        extern  ExpInterlockedPopEntrySListEnd:proc
        extern  ExpInterlockedPopEntrySListFault:byte
        extern  ExpInterlockedPopEntrySListResume:proc
        extern  KdpOweBreakpoint:byte
        extern  KdSetOwedBreakpoints:proc
        extern  KeBugCheckEx:proc
        extern  KeGdiFlushUserBatch:qword
        extern  KeServiceDescriptorTableShadow:qword
        extern  KiCheckForSListAddress:proc
        extern  KiCodePatchCycle:dword
        extern  KiConvertToGuiThread:proc
        extern  KiDispatchException:proc
        extern  KiDpcInterruptBypass:proc
        extern  KiIdleSummary:qword
        extern  KiInitiateUserApc:proc
        extern  KiPrefetchRetry:byte
        extern  KiPreprocessInvalidOpcodeFault:proc
        extern  KiPreprocessKernelAccessFault:proc
        extern  KiProcessNMI:proc
        extern  KiProcessorBlock:qword
        extern  KiRestoreDebugRegisterState:proc
        extern  KiSaveDebugRegisterState:proc
        extern  KiSaveProcessorState:proc
        extern  MmAccessFault:proc
        extern  MmUserProbeAddress:qword
        extern  RtlUnwindEx:proc
        extern  PsWatchEnabled:byte
        extern  PsWatchWorkingSet:proc
        extern  __imp_HalHandleMcheck:qword
        extern  __imp_HalRequestSoftwareInterrupt:qword

;
; Define special macros to align trap entry points on cache line boundaries.
;
; N.B. This will only work if all functions in this module are declared with
;      these macros.
;

TRAP_ENTRY macro Name, Handler

_TEXT$10 segment page 'CODE'

        align   64

        public  Name

ifb <Handler>

Name    proc    frame

else

Name    proc    frame:Handler

endif

        endm

TRAP_END macro Name

Name    endp

_TEXT$10 ends

        endm

        subttl  "Divide Error Fault"
;++
;
; Routine Description:
;
;   This routine is entered as the result of an attempted division by zero
;   or the result of an attempted division does not fit in the destination
;   operand (i.e., the largest negative number divided by minus one).
;
;   N.B. The two possible conditions that can cause this exception are not
;        separated and the exception is reported as a divide by zero.
;
; Arguments:
;
;   The standard exception frame is pushed by hardware on the kernel stack.
;   There is no error code for this exception.
;
; Disposition:
;
;   A standard trap frame is constructed on the kernel stack, the exception
;   parameters are loaded into registers, and the exception is dispatched via
;   common code.
;
;--

        TRAP_ENTRY KiDivideErrorFault

        GENERATE_TRAP_FRAME <>, <PatchCycle> ; generate trap frame

        mov     ecx, KI_EXCEPTION_INTEGER_DIVIDE_BY_ZERO ; set exception code
        xor     edx, edx                ; set number of parameters
        mov     r8, TrRip[rbp]          ; set exception address
        call    KiExceptionDispatch     ; dispatch exception - no return
        nop                             ; fill - do not remove

        TRAP_END KiDivideErrorFault

        subttl  "Debug Trap Or Fault"
;++
;
; Routine Description:
;
;   This routine is entered as the result of a debug trap or fault. The
;   following conditions cause entry to this routine:
;
;   1. Instruction fetch breakpoint fault.
;   2. Data read or write breakpoint trap.
;   3. I/O read or write breakpoint trap.
;   4. General detect condition fault (in-circuit emulator).
;   5. Single step trap (TF set).
;   6. Task switch trap (not possible on this system).
;   7. Execution of an int 1 instruction.
;
; Arguments:
;
;   The standard exception frame is pushed by hardware on the kernel stack.
;   There is no error code for this exception.
;
; Disposition:
;
;   A standard trap frame is constructed on the kernel stack, the exception
;   parameters are loaded into registers, and the exception is dispatched via
;   common code.
;
;--

        TRAP_ENTRY KiDebugTrapOrFault

        GENERATE_TRAP_FRAME             ; generate trap frame

        xor     edx, edx                ; set number of parameters
        test    dword ptr TrEflags[rbp], EFLAGS_TF_MASK ; test if TF is set
        jz      short KiDT30            ; if z, TF not set
        cmp     byte ptr gs:[PcCpuVendor], CPU_AMD ; check if AMD processor
        jne     short KiDT30            ; if ne, not authentic AMD processor

;
; The host processor is an authentic AMD processor.
;
; Check if branch tracing and last branch capture is enabled.
;

        test    byte ptr TrSegCs[rbp], MODE_MASK ; test if previous mode user
        jnz     short KiDT10            ; if nz, previous mode user

;
; Previous mode was kernel - the debug registers have not yet been saved.
;

        mov     rax, dr7                ; get debug control register
        test    ax, DR7_TRACE_BRANCH    ; test if trace branch set
        jz      short KiDT30            ; if z, trace branch not set
        test    ax, DR7_LAST_BRANCH     ; test if last branch set
        jz      short KiDT30            ; if z, last branch not set
        mov     ecx, MSR_LAST_BRANCH_FROM ; get last branch information
        rdmsr                           ;
        mov     r9d, eax                ;
        shl     rdx, 32                 ;
        or      r9, rdx                 ;
        mov     ecx, MSR_LAST_BRANCH_TO ;
        rdmsr                           ;
        mov     r10d, eax               ;
        shl     rdx, 32                 ;
        or      r10, rdx                ;
        jmp     short KiDT20            ; finish in common code


;
; Previous mode was user - the debug registers are saved in the trap frame.
;

KiDT10: test    word ptr TrDr7[rbp], DR7_TRACE_BRANCH ; test if trace branch set
        jz      short KiDT30            ; if z, trace branch not set
        test    word ptr TrDr7[rbp], DR7_LAST_BRANCH ; test if last branch set
        jz      short KiDT30            ; if z, last branch not set
        mov     r9, TrLastBranchFromRip[rbp] ; set last RIP parameters
        mov     r10, TrLastBranchToRip[rbp] ;
KiDT20: mov     edx, 2                  ; set number of parameters
KiDT30: mov     ecx, STATUS_SINGLE_STEP ; set exception code
        and     dword ptr TrEflags[rbp], NOT EFLAGS_TF_MASK ; reset the TF bit
        mov     r8, TrRip[rbp]          ; set exception address
        call    KiExceptionDispatch     ; dispatch exception - no return
        nop                             ; fill - do not remove

        TRAP_END KiDebugTrapOrFault

        subttl  "Nonmaskable Interrupt"
;++
;
; Routine Description:
;
;   This routine is entered as the result of a nonmaskable interrupt. A
;   switch to the panic stack occurs before the exception frame is pushed
;   on the stack.
;
;   N.B. This routine executes on the panic stack.
;
; Arguments:
;
;   The standard exception frame is pushed by hardware on the kernel stack.
;   There is no error code for this exception.
;
; Disposition:
;
;   A standard trap frame is constructed on the kernel stack and the NMI is
;   processed. If a return to this routine occurs, then the NMI was handled.
;
;--

        TRAP_ENTRY KiNmiInterrupt

        .pushframe                      ; mark machine frame

        alloc_stack 8                   ; allocate dummy vector
        push_reg rbp                    ; save nonvolatile register

        GENERATE_INTERRUPT_FRAME <>, <Direct>, <Nmi> ; generate interrupt frame

        mov     ecx, HIGH_LEVEL         ; set IRQL value

        ENTER_INTERRUPT <NoEOI>, <NoCount>, <Nmi> ; enter interrupt

;
; Check to determine if a recursive non-maskable interrupt has occured. This
; can happen when an SMI interrupts an NMI in progress, unmasking NMIs, and a
; second NMI is pending.
;

        lea     rax, KTRAP_FRAME_LENGTH[rsp] ; get base stack address
        cmp     rax, TrRsp[rbp]         ; check if within range
        jbe     KiNi10                  ; if be, old stack above base
        sub     rax, NMI_STACK_SIZE     ; compute stack limit
        cmp     rax, TrRsp[rbp]         ; check if within range
        jbe     KiNi20                  ; if be, old stack in range

KiNi10: call    KxNmiInterrupt          ; call secondary routine

        EXIT_INTERRUPT <NoEOI>, <NoCount>, <Direct>, <Nmi> ; restore trap state and exit

;
; A recursive non-maskable interrupt has occured.
;

KiNi20: xor     r10, r10                ; clear bugcheck parameters
        xor     r9, r9                  ;
        xor     r8, r8                  ;
        xor     edx, edx                ;
        mov     ecx, RECURSIVE_NMI      ; set bugcheck code
        call    KiBugCheckDispatch      ; bugcheck system - no return
        nop                             ; fill - do not remove

        TRAP_END KiNmiInterrupt

;
; This routine generates an exception frame, then processes the NMI.
;

        TRAP_ENTRY KxNmiInterrupt

        GENERATE_EXCEPTION_FRAME        ; generate exception frame

        lea     rcx, (-128)[rbp]        ; set trap frame address
        mov     rdx, rsp                ; set exception frame address
        call    KiSaveProcessorState    ; save processor state
        lea     rcx, (-128)[rbp]        ; set trap frame address
        mov     rdx, rsp                ; set exception frame address
        call    KiProcessNMI            ; process NMI

        RESTORE_EXCEPTION_STATE         ; restore exception state/deallocate

        ret                             ; return

        TRAP_END KxNmiInterrupt


        subttl  "Breakpoint Trap"
;++
;
; Routine Description:
;
;   This routine is entered as the result of the execution of an int 3
;   instruction.
;
; Arguments:
;
;   The standard exception frame is pushed by hardware on the kernel stack.
;   There is no error code for this exception.
;
; Disposition:
;
;   A standard trap frame is constructed on the kernel stack, the exception
;   parameters are loaded into registers, and the exception is dispatched via
;   common code.
;
;--

        TRAP_ENTRY KiBreakpointTrap

        GENERATE_TRAP_FRAME             ; generate trap frame

        mov     ecx, STATUS_BREAKPOINT  ; set exception code
        mov     edx, 1                  ; set number of parameters
        mov     r8, TrRip[rbp]          ; set exception address
        dec     r8                      ;
        mov     r9d, BREAKPOINT_BREAK   ; set parameter 1 value
        call    KiExceptionDispatch     ; dispatch exception - no return
        nop                             ; fill - do not remove

        TRAP_END KiBreakpointTrap

        subttl  "Overflow Trap"
;++
;
; Routine Description:
;
;   This routine is entered as the result of the execution of an into
;   instruction when the OF flag is set.
;
; Arguments:
;
;   The standard exception frame is pushed by hardware on the kernel stack.
;   There is no error code for this exception.
;
; Disposition:
;
;   A standard trap frame is constructed on the kernel stack, the exception
;   parameters are loaded into registers, and the exception is dispatched via
;   common code.
;
;--

        TRAP_ENTRY KiOverflowTrap

        GENERATE_TRAP_FRAME             ; generate trap frame

        mov     ecx, STATUS_INTEGER_OVERFLOW ; set exception code
        xor     edx, edx                ; set number of parameters
        mov     r8, TrRip[rbp]          ; set exception address
        dec     r8                      ;
        call    KiExceptionDispatch     ; dispatch exception - no return
        nop                             ; fill - do not remove

        TRAP_END KiOverflowTrap

        subttl  "Bound Fault"
;++
;
; Routine Description:
;
;   This routine is entered as the result of the execution of a bound
;   instruction and when the bound range is exceeded.
;
; Arguments:
;
;   The standard exception frame is pushed by hardware on the kernel stack.
;   There is no error code for this exception.
;
; Disposition:
;
;   A standard trap frame is constructed on the kernel stack, the exception
;   parameters are loaded into registers, and the exception is dispatched via
;   common code.
;
;--

        TRAP_ENTRY KiBoundFault

        GENERATE_TRAP_FRAME             ; generate trap frame

        mov     ecx, STATUS_ARRAY_BOUNDS_EXCEEDED ; set exception code
        xor     edx, edx                ; set number of parameters
        mov     r8, TrRip[rbp]          ; set exception address
        call    KiExceptionDispatch     ; dispatch exception - no return
        nop                             ; fill - do not remove

        TRAP_END KiBoundFault

        subttl  "Invalid Opcode Fault"
;++
;
; Routine Description:
;
;   This routine is entered as the result of the execution of an invalid
;   instruction.
;
; Arguments:
;
;   The standard exception frame is pushed by hardware on the kernel stack.
;   There is no error code for this exception.
;
; Disposition:
;
;   A standard trap frame is constructed on the kernel stack, the exception
;   parameters are loaded into registers, and the exception is dispatched via
;   common code.
;
;--

        TRAP_ENTRY KiInvalidOpcodeFault

        GENERATE_TRAP_FRAME <>, <PatchCycle> ; generate trap frame

        mov     rcx, rsp                ; set trap frame address
        call    KiPreprocessInvalidOpcodeFault ; check for opcode emulation
        or      eax, eax                ; test if opcode emulated
        jnz     short KiIO10            ; if nz, opcode emulated
        mov     ecx, KI_EXCEPTION_INVALID_OP ; set exception code
        xor     edx, edx                ; set number of parameters
        mov     r8, TrRip[rbp]          ; set exception address
        call    KiExceptionDispatch     ; dispatch exception - no return
        nop                             ; fill - do not remove

KiIO10: RESTORE_TRAP_STATE <Volatile>   ; restore trap state and exit

        TRAP_END KiInvalidOpcodeFault

        subttl  "NPX Not Available Fault"
;++
;
; Routine Description:
;
;   This routine is entered as the result of the numeric coprocessor not
;   being available for one of the following conditions:
;
;   1. A floating point instruction was executed and EM is set in CR0 -
;       this condition should never happen since EM will never be set.
;
;   2. A floating point instruction was executed and the TS flag is set
;       in CR0 - this condition should never happen since TS will never
;       be set.
;
;   3. A WAIT of FWAIT instruction was executed and the MP and TS flags
;       are set in CR0 - this condition should never occur since neither
;       TS nor MP will ever be set.
;
;   N.B. The NPX state should always be available.
;
; Arguments:
;
;   The standard exception frame is pushed by hardware on the kernel stack.
;   There is no error code for this exception.
;
; Disposition:
;
;   A standard trap frame is constructed on the kernel stack and bugcheck
;   is called.
;
;--

        TRAP_ENTRY KiNpxNotAvailableFault

        GENERATE_TRAP_FRAME             ; generate trap frame

        mov     r10, TrRip[rbp]         ; set parameter 5 to exception address
        mov     r9, cr4                 ; set parameter 4 to control register 4
        mov     r8, cr0                 ; set parameter 3 to control register 0
        mov     edx, EXCEPTION_NPX_NOT_AVAILABLE ; set unexpected trap number
        mov     ecx, UNEXPECTED_KERNEL_MODE_TRAP ; set bugcheck code
        call    KiBugCheckDispatch      ; bugcheck system - no return
        nop                             ; fill - do not remove

        TRAP_END KiNpxNotAvailableFault

        subttl  "Double Fault Abort"
;++
;
; Routine Description:
;
;   This routine is entered as the result of the generation of a second
;   exception while another exception is being generated. A switch to the
;   panic stack occurs before the exception frame is pushed on the stack.
;
;   N.B. This routine executes on the panic stack.
;
; Arguments:
;
;   The standard exception frame is pushed by hardware on the new stack.
;   There is no error code for this exception.
;
; Disposition:
;
;   A standard trap frame is constructed on the kernel stack and bugcheck
;   is called.
;
;--

        TRAP_ENTRY KiDoubleFaultAbort

        GENERATE_TRAP_FRAME <ErrorCode> ; generate trap frame

        mov     r10, TrRip[rbp]         ; set parameter 5 to exception address
        mov     r9, cr4                 ; set parameter 4 to control register 4
        mov     r8, cr0                 ; set parameter 3 to control register 0
        mov     edx, EXCEPTION_DOUBLE_FAULT ; set unexpected trap number
        mov     ecx, UNEXPECTED_KERNEL_MODE_TRAP ; set bugcheck code
        call    KiBugCheckDispatch      ; bugcheck system - no return
        nop                             ; fill - do not remove

        TRAP_END KiDoubleFaultAbort

        subttl  "NPX Segment Overrrun Abort"
;++
;
; Routine Description:
;
;   This routine is entered as the result of a hardware failure since this
;   vector is obsolete.
;
; Arguments:
;
;   The standard exception frame is pushed by hardware on the new stack.
;   There is no error code for this exception.
;
; Disposition:
;
;   This trap should never occur and the system is shutdown via a call to
;   bugcheck.
;
;--

        TRAP_ENTRY KiNpxSegmentOverrunAbort

        GENERATE_TRAP_FRAME             ; generate trap frame

        mov     r10, TrRip[rbp]         ; set parameter 5 to exception address
        mov     r9, cr4                 ; set parameter 4 to control register 4
        mov     r8, cr0                 ; set parameter 3 to control register 0
        mov     edx, EXCEPTION_NPX_OVERRUN ; set unexpected trap number
        mov     ecx, UNEXPECTED_KERNEL_MODE_TRAP ; set bugcheck code
        call    KiBugCheckDispatch      ; bugcheck system - no return
        nop                             ; fill - do not remove

        TRAP_END KiNpxSegmentOverrunAbort

        subttl  "Invalid TSS Fault"
;++
;
; Routine Description:
;
;   This routine is entered as the result of a hardware or software failure
;   since there is no task switching in 64-bit mode and 32-bit code does not
;   have any task state segments.
;
; Arguments:
;
;   The standard exception frame is pushed by hardware on the new stack.
;   The segment selector index for the segment descriptor that caused the
;   violation is pushed as the error code.
;
; Disposition:
;
;   A standard trap frame is constructed on the kernel stack and bugcheck
;   is called.
;
;--

        TRAP_ENTRY KiInvalidTssFault

        GENERATE_TRAP_FRAME <ErrorCode> ; generate trap frame

        mov     r10, TrRip[rbp]         ; set parameter 5 to exception address
        mov     r9d, TrErrorCode[rbp]   ; set parameter 4 to selector index
        mov     r8, cr0                 ; set parameter 3 to control register 0
        mov     edx, EXCEPTION_INVALID_TSS ; set unexpected trap number
        mov     ecx, UNEXPECTED_KERNEL_MODE_TRAP ; set bugcheck code
        call    KiBugCheckDispatch      ; bugcheck system - no return
        nop                             ; fill - do not remove

        TRAP_END KiInvalidTssFault

        subttl  "Segment Not Present Fault"
;++
;
; Routine Description:
;
;   This routine is entered as the result of a segment not present (P bit 0)
;   fault. This fault can only occur in legacy 32-bit code.
;
; Arguments:
;
;   The standard exception frame is pushed by hardware on the new stack.
;   The segment selector index for the segment descriptor that is not
;   present is pushed as the error code.
;
; Disposition:
;
;   A standard trap frame is constructed. If the previous mode is user,
;   then the exception parameters are loaded into registers and the exception
;   is dispatched via common code. Otherwise, bugcheck is called.
;
;--

        TRAP_ENTRY KiSegmentNotPresentFault

        GENERATE_TRAP_FRAME <ErrorCode> ; generate trap frame

        mov     r8, TrRip[rbp]          ; get exception address
        test    byte ptr TrSegCs[rbp], MODE_MASK ; test if previous mode user
        jz      short KiSN10            ; if z, previous mode not user

;
; The previous mode was user.
;

        mov     ecx, STATUS_ACCESS_VIOLATION ; set exception code
        mov     edx, 2                  ; set number of parameters
        mov     r9d, TrErrorCode[rbp]   ; set parameter 1 value
        or      r9d, RPL_MASK           ;
        and     r9d, 0ffffh             ;
        xor     r10, r10                ; set parameter 2 value
        call    KiExceptionDispatch     ; dispatch exception - no return

;
; The previous mode was kernel.
;

KiSN10: mov     r10, r8                 ; set parameter 5 to exception address
        mov     r9d, TrErrorCode[rbp]   ; set parameter 4 to selector index
        mov     r8, cr0                 ; set parameter 3 to control register 0
        mov     edx, EXCEPTION_SEGMENT_NOT_PRESENT ; set unexpected trap number
        mov     ecx, UNEXPECTED_KERNEL_MODE_TRAP ; set bugcheck code
        call    KiBugCheckDispatch      ; bugcheck system - no return
        nop                             ; fill - do not remove

        TRAP_END KiSegmentNotPresentFault

        subttl  "Stack Fault"
;++
;
; Routine Description:
;
;   This routine is entered as the result of a stack fault. This fault can
;   only occur in legacy 32-bit code.
;
; Arguments:
;
;   The standard exception frame is pushed by hardware on the new stack.
;   The segment selector index for the segment descriptor that caused the
;   exception is pushed as the error code.
;
; Disposition:
;
;   A standard trap frame is constructed. If the previous mode is user,
;   then the exception parameters are loaded into registers and the exception
;   is dispatched via common code. Otherwise, bugcheck is called.
;
;--

        TRAP_ENTRY KiStackFault

        GENERATE_TRAP_FRAME <ErrorCode> ; generate trap frame

        mov     r8, TrRip[rbp]          ; get exception address
        test    byte ptr TrSegCs[rbp], MODE_MASK ; test if previous mode user
        jz      short KiSF10            ; if z, previous mode not user

;
; The previous mode was user.
;

        mov     ecx, STATUS_ACCESS_VIOLATION ; set exception code
        mov     edx, 2                  ; set number of parameters
        mov     r9d, TrErrorCode[rbp]   ; set parameter 1 value
        or      r9d, RPL_MASK           ;
        and     r9d, 0ffffh             ;
        xor     r10, r10                ; set parameter 2 value
        call    KiExceptionDispatch     ; dispatch exception - no return

;
; The previous mode was kernel.
;

KiSF10: mov     r10, r8                 ; set parameter 5 to exception address
        mov     r9d, TrErrorCode[rbp]   ; set parameter 4 to selector index
        mov     r8, cr0                 ; set parameter 3 to control register 0
        mov     edx, EXCEPTION_STACK_FAULT ; set unexpected trap number
        mov     ecx, UNEXPECTED_KERNEL_MODE_TRAP ; set bugcheck code
        call    KiBugCheckDispatch      ; bugcheck system - no return
        nop                             ; fill - do not remove

        TRAP_END KiStackFault

        subttl  "General Protection Fault"
;++
;
; Routine Description:
;
;   This routine is entered as the result of a general protection violation.
;
; Arguments:
;
;   The standard exception frame is pushed by hardware on the kernel stack.
;   The segment selector index for the segment descriptor that caused the
;   exception, the IDT vector number for the descriptor that caused the
;   exception, or zero is pushed as the error code.
;
; Disposition:
;
;   A standard trap frame is constructed on the kernel stack, the exception
;   parameters are loaded into registers, and the exception is dispatched via
;   common code.
;
;--

        TRAP_ENTRY KiGeneralProtectionFault

        GENERATE_TRAP_FRAME <ErrorCode>, <PatchCycle> ; generate trap frame

        mov     ecx, KI_EXCEPTION_GP_FAULT ; set GP fault internal code
        mov     edx, 2                  ; set number of parameters
        mov     r9d, TrErrorCode[rbp]   ; set parameter 1 to error code
        and     r9d, 0ffffh             ;
        xor     r10, r10                ; set parameter 2 value
        mov     r8, TrRip[rbp]          ; set exception address
        call    KiExceptionDispatch     ; dispatch exception - no return
        nop                             ; fill - do not remove

        TRAP_END KiGeneralProtectionFault       

        subttl  "Page Fault"
;++
;
; Routine Description:
;
;   This routine is entered as the result of a page fault which can occur
;   because of the following reasons:
;
;   1. The referenced page is not present.
;
;   2. The referenced page does not allow the requested access.
;
; Arguments:
;
;   A standard exception frame is pushed by hardware on the kernel stack.
;   A special format error code is pushed which specifies the cause of the
;   page fault as not present, read/write access denied, from user/kernel
;   mode, and attempting to set reserved bits.
;
; Disposition:
;
;   A standard trap frame is constructed on the kernel stack and memory
;   management is called to resolve the page fault. If memory management
;   successfully resolves the page fault, then working set information is
;   recorded, owed breakpoints are inserted, and execution is continued.
;
;   If the page fault occurred at an IRQL greater than APC_LEVEL, then the
;   system is shut down via a call to bugcheck. Otherwise, an appropriate
;   exception is raised.
;
;--

        TRAP_ENTRY KiPageFault

        GENERATE_TRAP_FRAME <Virtual>, <PatchCycle>, <SaveGSSwap> ; generate trap frame

;
; The registers eax and rcx are loaded with the error code and the virtual
; address of the fault respectively when the trap frame is generated.
;

        shr     eax, 1                  ; isolate load/store and i/d indicators
        and     eax, 09h                ;

;
; Save the load/store indicator and the faulting virtual address in the
; exception record in case an exception is raised.
;

        mov     TrFaultIndicator[rbp], al ; save load/store indicator
        mov     TrFaultAddress[rbp], rcx ; save fault address
        lea     r9, (-128)[rbp]         ; set trap frame address
        mov     r8b, TrSegCs[rbp]       ; isolate previous mode
        and     r8b, MODE_MASK          ;
        mov     rdx, rcx                ; set faulting virtual address
        movzx   ecx, al                 ; set load/store indicator
        jnz     short KiPF05            ; if nz, previous mode user
        cmp     KiPrefetchRetry, 0      ; check if prefetch retry required
        je      short KiPF05            ; if e, prefetch retry not required
        test    al, EXCEPTION_EXECUTE_FAULT ; test is execution fault
        jnz     short KiPF05            ; if nz, execution fault
        call    KiPreprocessKernelAccessFault ; preprocess fault
        test    eax, eax                ; check for instruction retry
        jge     KiPF60                  ; if ge, retry instruction
        lea     r9, (-128)[rbp]         ; set trap frame address
        mov     r8b, TrSegCs[rbp]       ; isolate previous mode
        and     r8b, MODE_MASK          ;
        mov     rdx, TrFaultAddress[rbp]; set faulting virtual address
        movzx   ecx, BYTE PTR TrFaultIndicator[rbp] ; set load/store indicator

KiPF05: call    MmAccessFault           ; attempt to resolve page fault
        test    eax, eax                ; test for successful completion
        jl      short KiPF20            ; if l, not successful completion

;
; If watch working set is enabled, then record working set information.
;

        cmp     PsWatchEnabled, 0       ; check if working set watch enabled
        je      short KiPF10            ; if e, working set watch not enabled
        mov     r8, TrFaultAddress[rbp] ; set fault address
        mov     rdx, TrRip[rbp]         ; set exception address
        mov     ecx, eax                ; set completion status
        call    PsWatchWorkingSet       ; record working set information

;
; If the debugger has any breakpoints that should be inserted, then attempt
; to insert them now.
;

KiPF10: cmp     KdpOweBreakPoint, 0     ; check if breakpoints are owed
        je      KiPF60                  ; if e, no owed breakpoints
        call    KdSetOwedBreakpoints    ; notify the debugger of new page
        jmp     KiPF60                  ; finish in common code

;
; Check if a 32-bit user mode program reloaded the segment register GS and
; wiped out the GS base address.
;

KiPF20: test    byte ptr TrSegCs[rbp], MODE_MASK ; test if previous mode user
        jz      short KiPF25            ; if z, previous mode not user
        cmp     word ptr TrSegCs[rbp], (KGDT64_R3_CODE or RPL_MASK) ; check for 64-bit mode
        jne     short KiPF23            ; if ne, not running in 64-bit mode
        mov     r8, gs:[PcTeb]          ; get current TEB address
        cmp     r8, TrGsSwap[rbp]       ; check for user TEB address match
        je      short KiPF25            ; if e, user TEB address match
        mov     ecx, MSR_GS_SWAP        ; set GS swap MSR number
        mov     eax, r8d                ; set low user TEB address
        shr     r8, 32                  ; set high user TEB address
        mov     edx, r8d                ; 
        wrmsr                           ; write user TEB base address
        jmp     KiPF60                  ; finish is common code

;
; Check if the 32-bit program attempted a reference outside the 32-bit address
; space.
;

KiPF23: mov     rcx, TrFaultAddress[rbp] ; get fault address
        shr     rcx, 32                 ; isolate upper address bits
        jnz     KiPF60                  ; if nz, high address bits set

;
; Memory management failed to resolve the fault.
;
; STATUS_IN_PAGE_ERROR | 0x10000000 is a special status that indicates a
;       page fault at IRQL greater than APC level. This status causes a
;       bugcheck.
;
; The following status values can be raised:
;
; STATUS_ACCESS_VIOLATION
; STATUS_GUARD_PAGE_VIOLATION
; STATUS_STACK_OVERFLOW
;
; All other status values are sconverted to:
;
; STATUS_IN_PAGE_ERROR
;

KiPF25: mov     ecx, eax                ; set status code
        mov     edx, 2                  ; set number of parameters
        cmp     ecx, STATUS_IN_PAGE_ERROR or 10000000h ; check for bugcheck code
        je      short KiPF40            ; if e, bugcheck code returned
        cmp     ecx, STATUS_ACCESS_VIOLATION ; check for status values
        je      short KiPF28            ; if e, raise exception with internal code
        cmp     ecx, STATUS_GUARD_PAGE_VIOLATION ; check for status code
        je      short KiPF30            ; if e, raise exception with code
        cmp     ecx, STATUS_STACK_OVERFLOW ; check for status code
        je      short KiPF30            ; if e, raise exception with code
        mov     ecx, STATUS_IN_PAGE_ERROR ; convert all other status codes
        mov     edx, 3                  ; set number of parameters
        mov     r11d, eax               ; set parameter 3 to real status value
        jmp     KiPF30

KiPF28: mov     ecx, KI_EXCEPTION_ACCESS_VIOLATION ; set internal code

;
; Set virtual address, load/store and i/d indicators, exception address, and
; dispatch the exception.
;

KiPF30: mov     r10, TrFaultAddress[rbp] ; set fault address
        movzx   r9, byte ptr TrFaultIndicator[rbp] ; set load/store indicator
        mov     r8, TrRip[rbp]          ; set exception address
        call    KiExceptionDispatch     ; dispatch exception - no return

;
; A page fault occurred at an IRQL that was greater than APC_LEVEL. Set bugcheck
; parameters and join common code.
;

KiPF40: CurrentIrql                     ; get current IRQL

        mov     r10, TrRip[rbp]         ; set parameter 5 to exception address
        movzx   r9, byte ptr TrFaultIndicator[rbp] ; set load/store indicator
        and     eax, 0ffh               ; isolate current IRQL
        mov     r8, rax                 ;
        mov     rdx, TrFaultAddress[rbp] ; set fault address
        mov     ecx, IRQL_NOT_LESS_OR_EQUAL ; set bugcheck code
        call    KiBugCheckDispatch      ; bugcheck system - no return

;
; If the page fault occured within the kernel pop entry SLIST code, then reset
; RIP if necessary to avoid an SLIST sequence wrap attack.
;
; Make sure that IRQL is greater than passive level to block a set context
; operations.
;

KiPF60: lea     rax, ExpInterlockedPopEntrySListResume ; get SLIST resume address
        cmp     rax, TrRip[rbp]         ; check resume address is above RIP
        jae     KiPF70                  ; if ae, resume address above RIP
        lea     rax, ExpInterlockedPopEntrySListEnd ; get SLIST end address
        cmp     rax, TrRip[rbp]         ; check end address is below RIP
        jb      short KiPF70            ; if b, end address below RIP

        CurrentIrql                     ; get Current IRQL

        or      eax, eax                ; test is IRQL is passive level
        mov     TrP5[rbp], eax          ; save current IRQL
        jne     short KiPF65            ; if ne, IRQL is above passive level
        mov     ecx, APC_LEVEL          ; get APC level

        SetIrql                         ; set IRQL to APC level

KiPF65: lea     rcx, (-128)[rbp]        ; set trap frame address
        call    KiCheckForSListAddress  ; check RIP and reset if necessary
        mov     ecx, TrP5[rbp]          ; get previous IRQL value
        or      ecx, ecx                ; test if IRQL was raised
        jne     short KiPF70            ; if nz, IRQL was not raised

        SetIrql                         ; set IRQL to previous value

;
; Test if a user APC should be delivered and exit exception.
;

KiPF70: RESTORE_TRAP_STATE <Volatile>   ; restore trap state and exit

        TRAP_END KiPageFault

        subttl  "Legacy Floating Error"
;++
;
; Routine Description:
;
;   This routine is entered as the result of a legacy floating point fault.
;
; Arguments:
;
;   The standard exception frame is pushed by hardware on the kernel stack.
;   There is no error code for this exception.
;
; Disposition:
;
;   A standard trap frame is constructed on the kernel stack. If the previous
;   mode is user, then reason for the exception is determine, the exception
;   parameters are loaded into registers, and the exception is dispatched via
;   common code. Otherwise, bugcheck is called.
;
;--

        TRAP_ENTRY KiFloatingErrorFault

        GENERATE_TRAP_FRAME             ; generate trap frame

        test    byte ptr TrSegCs[rbp], MODE_MASK ; check if previous mode user
        jz      KiFE30                  ; if z,  previous mode not user

;
; The previous mode was user mode.
;

        fnstcw  TrErrorCode[rbp]        ; store floating control word
        fnstsw  ax                      ; store floating status word
        mov     cx, TrErrorCode[rbp]    ; get control word
        and     cx, FSW_ERROR_MASK      ; isolate masked exceptions
        not     cx                      ; compute enabled exceptions
        and     ax, cx                  ; isolate exceptions
        mov     ecx, STATUS_FLOAT_INVALID_OPERATION ; set exception code
        xor     r9, r9                  ; set first exception parameter
        mov     edx, 1                  ; set number of parameters
        mov     r8, TrRip[rbp]          ; set exception address
        test    al, FSW_INVALID_OPERATION ; test for invalid operation
        jz      short KiFE10            ; if z, non invalid operation
        test    al, FSW_STACK_FAULT     ; test is caused by stack fault
        jz      short KiFE20            ; if z, not caused by stack fault
        mov     ecx, STATUS_FLOAT_STACK_CHECK ; set exception code
        jmp     short KiFE20            ; finish in common code

KiFE10: mov     ecx, STATUS_FLOAT_DIVIDE_BY_ZERO ; set exception code
        test    al, FSW_ZERO_DIVIDE     ; test for divide by zero
        jnz     short KiFE20            ; if nz, divide by zero
        mov     ecx, STATUS_FLOAT_INVALID_OPERATION ; set exception code
        test    al, FSW_DENORMAL        ; test if denormal operand
        jnz     short KiFE20            ; if nz, denormal operand
        mov     ecx, STATUS_FLOAT_OVERFLOW ; set exception code
        test    al, FSW_OVERFLOW        ; test if overflow
        jnz     short KiFE20            ; if nz, overflow
        mov     ecx, STATUS_FLOAT_UNDERFLOW ; set exception code
        test    al, FSW_UNDERFLOW       ; test if underflow
        jnz     short KiFE20            ; if nz, underflow
        mov     ecx, STATUS_FLOAT_INEXACT_RESULT ; set exception code
        test    al, FSW_PRECISION       ; test for inexact result
        jz      short KiFE30            ; if z, not inexact result

KiFE20: call    KiExceptionDispatch     ; dispatch exception - no return

;
; The previous mode was kernel mode or the cause of the exception is unknown.
;

KiFE30: mov     edx, EXCEPTION_NPX_ERROR; set unexpected trap number
        mov     r10, TrRip[rbp]         ; set parameter 5 to exception address
        mov     r9, cr4                 ; set parameter 4 to control register 4
        mov     r8, cr0                 ; set parameter 3 to control register 0
        mov     ecx, UNEXPECTED_KERNEL_MODE_TRAP ; set bugcheck code
        call    KiBugCheckDispatch      ; bugcheck system - no return
        nop                             ; fill - do not remove

        TRAP_END KiFloatingErrorFault

        subttl  "Alignment Fault"
;++
;
; Routine Description:
;
;   This routine is entered as the result of an attempted access to unaligned
;   data.
;
; Arguments:
;
;   The standard exception frame is pushed by hardware on the kernel stack.
;   An error error code of zero is pushed on the stack.
;
; Disposition:
;
;   A standard trap frame is constructed on the kernel stack, the exception
;   parameters are loaded into registers, and the exception is dispatched via
;   common code.
;
;--

        TRAP_ENTRY KiAlignmentFault

        GENERATE_TRAP_FRAME <ErrorCode> ; generate trap frame

        mov     ecx, STATUS_DATATYPE_MISALIGNMENT ; set exception code
        xor     edx, edx                ; set number of parameters
        mov     r8, TrRip[rbp]          ; set exception address
        call    KiExceptionDispatch     ; dispatch exception - no return
        nop                             ; fill - do not remove

        TRAP_END KiAlignmentFault

        subttl  "Machine Check Abort"
;++
;
; Routine Description:
;
;   This routine is entered as the result of a machine check. A switch to
;   the machine check stack occurs before the exception frame is pushed on
;   the stack.
;
; Arguments:
;
;   The standard exception frame is pushed by hardware on the kernel stack.
;   There is no error code for this exception.
;
; Disposition:
;
;   A standard trap and exception frame are constructed on the kernel stack
;   and the HAL is called to determine if the machine check abort is fatal.
;   If the HAL call returns, then system operation is continued.
;
;--

        TRAP_ENTRY KiMcheckAbort

	.pushframe			; mark machine frame

	alloc_stack 8			; allocate dummy vector
	push_reg rbp			; save nonvolatile register

	GENERATE_INTERRUPT_FRAME <>, <Direct> ; generate interrupt frame

        mov     ecx, HIGH_LEVEL         ; set IRQL value

        ENTER_INTERRUPT <NoEoi>, <NoCount> ; raise IRQL and enable interrupts

;
; Check to determine if a recursive machine check has occurred. This can
; happen when machine check in progress is cleared and another machine
; check exception occurs before a complete exit from the below code can
; be performed.
;

        lea     rax, KTRAP_FRAME_LENGTH[rsp] ; get base stack address
        cmp     rax, TrRsp[rbp]         ; check if with range
        jbe     short KiMC10            ; if be, old stack above base
        sub     rax, KERNEL_MCA_EXCEPTION_STACK_SIZE ; compute limit stack address
        cmp     rax, TrRsp[rbp]         ; check if with range
        jbe     KiMC20                  ; if be, old stack in range

KiMC10: call    KxMcheckAbort           ; call secondary routine

;
; Clear machine check in progress.
;
; N.B. This is done very late to ensure that the window whereby a recursive
;      machine can occur is as small as possible. A recursive machine check
;      reloads the machine stack pointer from the TSS and overwrites any
;      information previously on the stack.
;

        xor     eax, eax                ; clear machine check in progress
        xor     edx, edx                ;
        mov     ecx, MSR_MCG_STATUS     ;
        wrmsr                           ;

        EXIT_INTERRUPT <NoEoi>, <NoCount>, <Direct> ; lower IRQL and restore state

;
; A recursive machine check exception has occurred.
;
;

KiMC20: xor     r10,r10                 ; clear bugcheck parameters
        xor     r9, r9                  ;
        xor     r8, r8                  ;
        xor     edx, edx                ;
        mov     ecx, RECURSIVE_MACHINE_CHECK ; set bugcheck code
        call    KiBugCheckDispatch      ; bugcheck system - no return
        nop                             ; fill - do not remove

        TRAP_END KiMcheckAbort

;
; This routine generates an exception frame, then calls the HAL to process
; the machine check.
;

        TRAP_ENTRY KxMcheckAbort

        GENERATE_EXCEPTION_FRAME        ; generate exception frame

        lea     rcx, (-128)[rbp]        ; set trap frame address
        mov     rdx, rsp                ; set exception frame address
        call    __imp_HalHandleMcheck   ; give HAL a chance to handle mcheck

        RESTORE_EXCEPTION_STATE         ; restore exception state/deallocate

        ret                             ; return

        TRAP_END KxMcheckAbort

        subttl  "XMM Floating Error"
;++
;
; Routine Description:
;
;   This routine is entered as the result of a XMM floating point fault.
;
; Arguments:
;
;   The standard exception frame is pushed by hardware on the kernel stack.
;   There is no error code for this exception.
;
; Disposition:
;
;   A standard trap frame is constructed on the kernel stack, mode is user,
;   then reason for the exception is determine, the exception parameters are
;   loaded into registers, and the exception is dispatched via common code.
;   If no reason can be determined for the exception, then bugcheck is called.
;
;--

        TRAP_ENTRY KiXmmException

        GENERATE_TRAP_FRAME <MxCsr>     ; generate trap frame

        mov     cx, ax                  ; shift enables into position
        shr     cx, XSW_ERROR_SHIFT     ;
        and     cx, XSW_ERROR_MASK      ; isolate masked exceptions
        not     cx                      ; compute enabled exceptions
        movzx   r10d, ax                ; set second exception parameter
        and     ax, cx                  ; isolate exceptions
        mov     edx, 2                  ; set number of parameters
        mov     r8, TrRip[rbp]          ; set exception address
        xor     r9, r9                  ; set first exception parameter
        cmp     word ptr TrSegCs[rbp], KGDT64_R3_CMCODE or RPL_MASK ; legacy code?
        je      short KiXE15            ; if e, legacy code

;
; The XMM exception occurred in 64-bit code.
;

        mov     ecx, STATUS_FLOAT_INVALID_OPERATION ; set exception code
        test    al, XSW_INVALID_OPERATION ; test for invalid operation
        jnz     short KiXE10            ; if z, invalid operation
        mov     ecx, STATUS_FLOAT_DIVIDE_BY_ZERO ; set exception code
        test    al, XSW_ZERO_DIVIDE     ; test for divide by zero
        jnz     short KiXE10            ; if nz, divide by zero
        mov     ecx, STATUS_FLOAT_INVALID_OPERATION ; set exception code
        test    al, XSW_DENORMAL        ; test if denormal operand
        jnz     short KiXE10            ; if nz, denormal operand
        mov     ecx, STATUS_FLOAT_OVERFLOW ; set exception code
        test    al, XSW_OVERFLOW        ; test if overflow
        jnz     short KiXE10            ; if nz, overflow
        mov     ecx, STATUS_FLOAT_UNDERFLOW ; set exception code
        test    al, XSW_UNDERFLOW       ; test if underflow
        jnz     short KiXE10            ; if nz, underflow
        mov     ecx, STATUS_FLOAT_INEXACT_RESULT ; set exception code
        test    al, XSW_PRECISION       ; test for inexact result
        jz      short KiXE20            ; if z, not inexact result

KiXE10: call    KiExceptionDispatch     ; dispatch exception - no return

;
; The XMM exception occurred in legacy 32-bit code
;

KiXE15: mov     ecx, STATUS_FLOAT_MULTIPLE_TRAPS ; set exception code
        test    al, XSW_INVALID_OPERATION ; test for invalid operation
        jnz     short KiXE10            ; if z, invalid operation
        test    al, XSW_ZERO_DIVIDE     ; test for divide by zero
        jnz     short KiXE10            ; if nz, divide by zero
        test    al, XSW_DENORMAL        ; test if denormal operand
        jnz     short KiXE10            ; if nz, denormal operand
        mov     ecx, STATUS_FLOAT_MULTIPLE_FAULTS ; set exception code
        test    al, XSW_OVERFLOW        ; test if overflow
        jnz     short KiXE10            ; if nz, overflow
        test    al, XSW_UNDERFLOW       ; test if underflow
        jnz     short KiXE10            ; if nz, underflow
        test    al, XSW_PRECISION       ; test for inexact result
        jnz     short KiXE10            ; if nz, inexact result
        
;
; The cause of the exception is unknown.
;

KiXE20: mov     r10, TrRip[rbp]         ; set parameter 5 to exception address
        mov     r9, cr4                 ; set parameter 4 to control register 4
        mov     r8, cr0                 ; set parameter 3 to control register 0
        mov     edx, EXCEPTION_NPX_OVERRUN  ; set unexpected trap number
        mov     ecx, UNEXPECTED_KERNEL_MODE_TRAP ; set bugcheck code
        call    KiBugCheckDispatch      ; bugcheck system - no return
        nop                             ; fill - do not remove

        TRAP_END KiXmmException

        subttl  "Raise Assertion Trap"
;++
;
; Routine Description:
;
;   This routine is entered as the result of the execution of an int 2c
;   instruction.
;
; Arguments:
;
;   None.
;
; Disposition:
;
;   A standard trap frame is constructed on the kernel stack, the exception
;   arguments are loaded into registers, and the exception is dispatched via
;   common code.
;
;--

        TRAP_ENTRY KiRaiseAssertion

        sub     qword ptr MfRip[rsp], 2 ; convert trap to fault 

        GENERATE_TRAP_FRAME             ; generate trap frame

        mov     ecx, STATUS_ASSERTION_FAILURE ; set exception code
        xor     edx, edx                ; set number of parameters
        mov     r8, TrRip[rbp]          ; set exception address
        call    KiExceptionDispatch     ; dispatch exception - no return
        nop                             ; fill - do not remove

        TRAP_END KiRaiseAssertion

        subttl  "Debug Service Trap"
;++
;
; Routine Description:
;
;   This routine is entered as the result of the execution of an int 2d
;   instruction.
;
; Arguments:
;
;   The standard exception frame is pushed by hardware on the kernel stack.
;   There is no error code for this exception.
;
; Disposition:
;
;   A standard trap frame is constructed on the kernel stack, the exception
;   arguments are loaded into registers, and the exception is dispatched via
;   common code.
;
;--

        TRAP_ENTRY KiDebugServiceTrap

        inc     qword ptr MfRip[rsp]    ; increment past int 3 instruction

        GENERATE_TRAP_FRAME             ; generate trap frame

        mov     ecx, STATUS_BREAKPOINT  ; set exception code
        mov     edx, 1                  ; set number of parameters
        mov     r9, TrRax[rbp]          ; set parameter 1 value
        mov     r8, TrRip[rbp]          ; set exception address
        call    KiExceptionDispatch     ; dispatch exception - no return
        nop                             ; fill - do not remove

        TRAP_END KiDebugServiceTrap

        subttl  "System Service Call 32-bit"
;++
;
; Routine Description:
;
;   This routine gains control when a system call instruction is executed
;   from 32-bit mode. System service calls from 32-bit code are not supported
;   and this exception is turned into an invalid opcode fault.
;
;   N.B. This routine is never entered from kernel mode and it executed with
;        interrupts disabled.
;
; Arguments:
;
;   The standard exception frame is pushed on the stack.
;
; Return Value:
;
;   A standard trap frame is constructed on the kernel stack, the exception
;   parameters are loaded into registers, and the exception is dispatched via
;   common code.
;
;--

        TRAP_ENTRY KiSystemCall32

        swapgs                          ; swap GS base to kernel PCR
        mov     gs:[PcUserRsp], rsp     ; save user stack pointer
        mov     rsp, gs:[PcRspBase]     ; set kernel stack pointer
        push    KGDT64_R3_DATA or RPL_MASK ; push 32-bit SS selector
        push    gs:[PcUserRsp]          ; push user stack pointer
        push    r11                     ; push previous EFLAGS
        push    KGDT64_R3_CMCODE or RPL_MASK ; push dummy 32-bit CS selector
        push    rcx                     ; push return address
        swapgs                          ; swap GS base to user TEB

        GENERATE_TRAP_FRAME             ; generate trap frame

        mov     ecx, STATUS_ILLEGAL_INSTRUCTION ; set exception code
        xor     edx, edx                ; set number of parameters
        mov     r8, TrRip[rbp]          ; set exception address
        call    KiExceptionDispatch     ; dispatch exception - no return
        nop                             ; fill - do not remove

        TRAP_END KiSystemCall32

        subttl  "System Service Exception Handler"
;++
;
; EXCEPTION_DISPOSITION
; KiSystemServiceHandler (
;    IN PEXCEPTION_RECORD ExceptionRecord,
;    IN PVOID EstablisherFrame,
;    IN OUT PCONTEXT ContextRecord,
;    IN OUT PDISPATCHER_CONTEXT DispatcherContext
;    )
;
; Routine Description:
;
;   This routine is the exception handler for the system service dispatcher.
;
;   If an unwind is being performed and the system service dispatcher is
;   the target of the unwind, then an exception occured while attempting
;   to copy the user's in-memory argument list. Control is transferred to
;   the system service exit by return a continue execution disposition
;   value.
;
;   If an unwind is being performed and the previous mode is user, then
;   bugcheck is called to crash the system. It is not valid to unwind
;   out of a system service into user mode.
;
;   If an unwind is being performed and the previous mode is kernel, then
;   the previous mode field from the trap frame is restored to the thread
;   object.
;
;   If an exception is being raised and the exception PC is the address
;   of the system service dispatcher in-memory argument copy code, then an
;   unwind to the system service exit code is initiated.
;
;   If an exception is being raised and the exception PC is not within
;   the range of the system service dispatcher, and the previous mode is
;   not user, then a continue search disposition value is returned. Otherwise,
;   a system service has failed to handle an exception and bugcheck is
;   called. It is invalid for a system service not to handle all exceptions
;   that can be raised in the service.
;
; Arguments:
;
;   ExceptionRecord (rcx) - Supplies a pointer to an exception record.
;
;   EstablisherFrame (rdx) - Supplies the frame pointer of the establisher
;       of this exception handler.
;
;   ContextRecord (r8) - Supplies a pointer to a context record.
;
;   DispatcherContext (r9) - Supplies a pointer to  the dispatcher context
;       record.
;
; Return Value:
;
;   If bugcheck is called, there is no return from this routine and the
;   system is crashed. If an exception occured while attempting to copy
;   the user in-memory argument list, then there is no return from this
;   routine, and unwind is called. Otherwise, ExceptionContinueSearch is
;   returned as the function value.
;
;--

ShFrame struct
        P1Home  dq ?                    ; parameter home addresses
        P2Home  dq ?                    ;
        P3Home  dq ?                    ;
        P4Home  dq ?                    ;
        P5Home  dq ?                    ;
        P6Home  dq ?                    ;
        Fill    dq ?                    ;
ShFrame ends

        TRAP_ENTRY KiSystemServiceHandler

        alloc_stack (sizeof ShFrame)    ; allocate stack frame

        END_PROLOGUE

        test    dword ptr ErExceptionFlags[rcx], EXCEPTION_UNWIND ; test for unwind
        jnz     KiSH30                  ; if nz, unwind in progress

;
; An exception is in progress.
;
; If the exception PC is the address of the GDI TEB access, then call unwind
; to transfer control to the system service exit code. Otherwise, check if
; the exception PC is the address of the in memory argument copy code for
; the system service dispatcher. If the exception PC is within the range of
; the in memory copy code, then call unwind to transfer control to the
; system service exit code. Otherwise, check if the previous mode is user
; or kernel mode.
;

        lea     rax, KiSystemServiceGdiTebAccess ; get GDI TEB access address
        cmp     rax, ErExceptionAddress[rcx] ; check if address match
        je      short KiSH05            ; if e, address match
        lea     rax, KiSystemServiceCopyStart ; get copy code start address
        cmp     rax, ErExceptionAddress[rcx] ; check if address in range
        ja      short KiSH10            ; if a, address not is range
        lea     rax, KiSystemServiceCopyEnd ; get copy code end address
        cmp     rax, ErExceptionAddress[rcx] ; check if address match
        jbe     short KiSH10            ; if be, address not in range

;
; The exception was raised by the system service dispatcher GDI TEB access
; code or the argument copy code. Unwind to the system service exit with the
; exception status code as the return value.
;

KiSH05: and     ShFrame.P6Home[rsp], 0  ; clear address of history table
        mov     ShFrame.P5Home[rsp], r8 ; set address of context record
        mov     r9d, ErExceptionCode[rcx] ; set return value
        mov     r8, rcx                 ; set address of exception record
        mov     rcx, rdx                ; set target frame address
        lea     rdx, KiSystemServiceExit ; set target IP address
        call    RtlUnwindEx             ; unwind - no return

;
; If the previous mode was kernel mode, then the continue the search for an
; exception handler. Otherwise, bugcheck the system.
;

KiSH10: mov     rax, gs:[PcCurrentThread] ; get current thread address
        cmp     byte ptr ThPreviousMode[rax], KernelMode ; check for kernel mode
        je      short KiSH20            ; if e, previous mode kernel

;
; Previous mode is user mode - bugcheck the system.
;

        xor     r10, r10                ; zero parameter 5
        mov     r9, r8                  ; set context record address
        mov     r8, ErExceptionAddress[rcx] ; set exception address
        mov     edx, ErExceptionCode[rcx] ; set exception code 
        mov     ecx, SYSTEM_SERVICE_EXCEPTION ; set bugcheck code
        call    KiBugCheckDispatch      ; bugcheck system - no return

;
; Previous mode is kernel mode - continue search for a handler.
;

KiSH20: mov     eax, ExceptionContinueSearch ; set return value
        add     rsp, sizeof ShFrame     ; deallocate stack frame
        ret                             ; return

;
; An unwind is in progress.
;
; If a target unwind is being performed, then continue the unwind operation.
; Otherwise, check if the previous mode is user or kernel mode.
;

KiSH30: test    dword ptr ErExceptionFlags[rcx], EXCEPTION_TARGET_UNWIND ; test for target unwind
        jnz     short KiSH20            ; if nz, target unwind in progress

;
; If the previous mode was kernel mode, then restore the previous mode and
; continue the unwind operation. Otherwise, bugcheck the system.
;

        mov     rax, gs:[PcCurrentThread] ; get current thread address
        cmp     byte ptr ThPreviousMode[rax], KernelMode ; check for kernel mode
        je      short KiSH40            ; if e, previous mode kernel

;
; Previous mode was user mode - bugcheck the system.
;

        mov     ecx, SYSTEM_UNWIND_PREVIOUS_USER ; set bugcheck code
        call    KiBugCheckDispatch      ; bugcheck system - no return

;
; Previous mode is kernel mode - restore previous mode and continue unwind
; operation.
;

KiSH40: mov     rcx, ThTrapFrame[rax]   ; get current trap frame address
        mov     rdx, TrTrapFrame + 128[rcx] ; restore previous trap frame address
        mov     ThTrapFrame[rax], rdx   ;
        mov     dl, TrPreviousMode + 128[rcx] ; restore previous mode
        mov     ThPreviousMode[rax], dl ; 
        jmp     short KiSH20            ; finish in common code

        TRAP_END KiSystemServiceHandler

        subttl  "System Service Internal"
;++
;
; VOID
; KiServiceInternal (
;     VOID
;     )
;
; Routine Description:
;
;   This function is called to provide the linkage between an internally
;   called system service and the system service dispatcher.
;
;   N.B. It is known that the previous mode was kernel and interrupts are
;        disabled.
;
; Arguments:
;
;   eax - Supplies the system service number.
;
;   rcx, rdx, r8, and r9 supply the service register arguments.
;
; Return value:
;
;   None.
;
;--

        TRAP_ENTRY KiServiceInternal

        push_frame                      ; mark machine frame
        alloc_stack 8                   ; allocate dummy error code
        push_reg rbp                    ; save standard register
        alloc_stack (KTRAP_FRAME_LENGTH - (7 * 8)) ; allocate fixed frame
        set_frame rbp, 128              ; set frame pointer
        mov     TrRbx[rbp], rbx         ; save nonvolatile registers
        .savereg rbx, (TrRbx + 128)     ;
        mov     TrRdi[rbp], rdi         ;
        .savereg rdi, (TrRdi + 128)     ;
        mov     TrRsi[rbp], rsi         ;
        .savereg rsi, (TrRsi + 128)     ;

        END_PROLOGUE

        sti                             ; enable interrupts
        mov     rbx, gs:[PcCurrentThread] ; get current thread address
        prefetchw ThTrapFrame[rbx]      ; prefetch with write intent
        movzx   edi, byte ptr ThPreviousMode[rbx] ; save previous mode in trap frame
        mov     TrPreviousMode[rbp], dil ;
        mov     byte ptr ThPreviousMode[rbx], KernelMode ; set thread previous mode
        mov     r10, ThTrapFrame[rbx]   ; save previous frame pointer address
        mov     TrTrapFrame[rbp], r10   ;

;        
; N.B. The below code uses an unusual sequence to transfer control. This
;      instruction sequence is required to avoid detection as an epilogue.
;

        lea     r11, KiSystemServiceStart ; get address of service start
        jmp     r11                     ; finish in common code

        TRAP_END  KiServiceInternal

        subttl  "System Service Call 64-bit"
;++
;
; Routine Description:
;
;   This routine gains control when a system call instruction is executed
;   from 64-bit mode. The specified system service is executed by locating
;   its routine address in system service dispatch table and calling the
;   specified function.
;
;   N.B. This routine is never entered from kernel mode and it executed with
;        interrupts disabled.
;
; Arguments:
;
;   eax - Supplies the system service number.
;
; Return Value:
;
;   eax - System service status code.
;
;   r10, rdx, r8, and r9 - Supply the first four system call arguments.
;
;   rcx - Supplies the RIP of the system call.
;
;   r11 - Supplies the previous EFLAGS.
;
;--

        TRAP_ENTRY KiSystemCall64, KiSystemServiceHandler

        swapgs                          ; swap GS base to kernel PCR
        mov     gs:[PcUserRsp], rsp     ; save user stack pointer
        mov     rsp, gs:[PcRspBase]     ; set kernel stack pointer
        push    KGDT64_R3_DATA or RPL_MASK ; push dummy SS selector
        push    gs:[PcUserRsp]          ; push user stack pointer
        push    r11                     ; push previous EFLAGS
        push    KGDT64_R3_CODE or RPL_MASK ; push dummy 64-bit CS selector
        push    rcx                     ; push return address
        mov     rcx, r10                ; set first argument value

        push_frame                      ; mark machine frame
        alloc_stack 8                   ; allocate dummy error code
        push_reg rbp                    ; save standard register
        alloc_stack (KTRAP_FRAME_LENGTH - (7 * 8)) ; allocate fixed frame
        set_frame rbp, 128              ; set frame pointer
        mov     TrRbx[rbp], rbx         ; save nonvolatile registers
        .savereg rbx, (TrRbx + 128)     ;
        mov     TrRdi[rbp], rdi         ;
        .savereg rdi, (TrRdi + 128)     ;
        mov     TrRsi[rbp], rsi         ;
        .savereg rsi, (TrRsi + 128)     ;

        END_PROLOGUE

        mov     byte ptr TrExceptionActive[rbp], 2 ; set service active
        mov     rbx, gs:[PcCurrentThread] ; get current thread address
        prefetchw ThTrapFrame[rbx]      ; prefetch with write intent
        stmxcsr TrMxCsr[rbp]            ; save current MXCSR
        ldmxcsr gs:[PcMxCsr]            ; set default MXCSR
        test    byte ptr ThDebugActive[rbx], TRUE ; test if debug enabled
        mov     word ptr TrDr7[rbp], 0  ; assume debug not enabled
        jz      short KiSS05            ; if z, debug not enabled
        mov     TrRax[rbp], rax         ; save service argument registers
        mov     TrRcx[rbp], rcx         ;
        mov     TrRdx[rbp], rdx         ;
        mov     TrR8[rbp], r8           ;
        mov     TrR9[rbp], r9           ;
        call    KiSaveDebugRegisterState ; save user debug registers
        mov     rax, TrRax[rbp]         ; restore service argument registers
        mov     rcx, TrRcx[rbp]         ;
        mov     rdx, TrRdx[rbp]         ;
        mov     r8, TrR8[rbp]           ;
        mov     r9, TrR9[rbp]           ;

        align   16

KiSS05: sti                             ; enable interrupts

if DBG

        cmp     byte ptr ThPreviousMode[rbx], UserMode ; check previous mode
        je      short @f                ; if e, previous mode set to user
        int     3                       ;
@@:                                     ;

endif

;
; Dispatch system service.
;
;   eax - Supplies the system service number.
;   rbx - Supplies the current thread address.
;   rcx - Supplies the first argument if present.
;   rdx - Supplies the second argument if present.
;   r8 - Supplies the third argument if present.
;   r9 - Supplies the fourth argument if present.
;

        ALTERNATE_ENTRY KiSystemServiceStart

        mov     ThTrapFrame[rbx], rsp   ; set current frame pointer address
        mov     edi, eax                ; copy system service number
        shr     edi, SERVICE_TABLE_SHIFT ; isolate service table number
        and     edi, SERVICE_TABLE_MASK ;
        and     eax, SERVICE_NUMBER_MASK ; isolate service table offset

;
; Repeat system service after attempt to convert to GUI thread.
;

        ALTERNATE_ENTRY KiSystemServiceRepeat

;
; If the specified system service number is not within range, then attempt
; to convert the thread to a GUI thread and retry the service dispatch.
;

        mov     r10, ThServiceTable + ThBase[rbx + rdi] ; get table base address
        cmp     eax, ThServiceTable + ThLimit[rbx + rdi] ; check if valid service
        jae     KiSS50                  ; if ae, not valid service
        movsxd  r11, dword ptr [r10 + rax * 4] ; get system service offset
        add     r10, r11                ; add table base to 

;
; If the service is a GUI service and the GDI user batch queue is not empty,
; then flush the GDI user batch queue.
;

        cmp     edi, SERVICE_TABLE_TEST ; check if GUI service
        jne     short KiSS10            ; if ne, not GUI service
        mov     r11, ThTeb[rbx]         ; get user TEB address

        ALTERNATE_ENTRY KiSystemServiceGdiTebAccess

        cmp     dword ptr TeGdiBatchCount[r11], 0 ; check batch queue depth
        je      short KiSS10            ; if e, batch queue empty
        mov     TrRcx[rbp], rcx         ; save system service arguments
        mov     TrRdx[rbp], rdx         ;
        mov     rbx, r8                 ;
        mov     rdi, r9                 ;
        mov     rsi, r10                ; save system service address
        call    KeGdiFlushUserBatch     ; call flush GDI user batch routine
        mov     rcx, TrRcx[rbp]         ; restore system service arguments
        mov     rdx, TrRdx[rbp]         ;
        mov     r8, rbx                 ;
        mov     r9, rdi                 ;
        mov     r10, rsi                ; restore system service address

;
; Check if system service has any in memory arguments.
;

        align   16

KiSS10: mov     eax, r10d               ; isolate number of in memory arguments
        and     eax, 15                 ;
        jz      KiSS30                  ; if z, no in memory arguments
        sub     r10, rax                ; compute actual function address
        shl     eax, 3                  ; compute argument bytes for dispatch
        lea     rsp, (-14 * 8)[rsp]     ; allocate stack argument area
        lea     rdi, (3 * 8)[rsp]       ; compute copy destination address
        mov     rsi, TrRsp[rbp]         ; get previous stack address
        lea     rsi, (4 * 8)[rsi]       ; compute copy source address
        test    byte ptr TrSegCs[rbp], MODE_MASK ; check if previous mode user
        jz      short KiSS20            ; if z, previous mode kernel
        cmp     rsi, MmUserProbeAddress ; check if source address in range
        cmovae  rsi, MmUserProbeAddress ; if ae, reset copy source address

;
; The following code is very carefully optimized so there is exactly 8 bytes
; of code for each argument move.
;
; N.B. The source and destination registers are biased by 8 bytes.
;
; N.B. Four additional arguments are specified in registers.
;

        align   16

KiSS20: lea     r11, KiSystemServiceCopyEnd ; get copy ending address
        sub     r11, rax                ; substract number of bytes to copy
        jmp     r11                     ; 

        align   16

        ALTERNATE_ENTRY KiSystemServiceCopyStart

        mov     rax, 112[rsi]           ; copy fourteenth argument
        mov     112[rdi], rax           ;
        mov     rax, 104[rsi]           ; copy thirteenth argument
        mov     104[rdi], rax           ;
        mov     rax, 96[rsi]            ; copy twelfth argument
        mov     96[rdi], rax            ;
        mov     rax, 88[rsi]            ; copy eleventh argument
        mov     88[rdi], rax            ;
        mov     rax, 80[rsi]            ; copy tenth argument
        mov     80[rdi], rax            ;
        mov     rax, 72[rsi]            ; copy nineth argument
        mov     72[rdi], rax            ;
        mov     rax, 64[rsi]            ; copy eighth argument
        mov     64[rdi], rax            ;
        mov     rax, 56[rsi]            ; copy seventh argument
        mov     56[rdi], rax            ;
        mov     rax, 48[rsi]            ; copy sixth argument
        mov     48[rdi], rax            ;
        mov     rax, 40[rsi]            ; copy fifth argument
        mov     40[rdi], rax            ;
        mov     rax, 32[rsi]            ; copy fourth argument
        mov     32[rdi], rax            ;
        mov     rax, 24[rsi]            ; copy third argument
        mov     24[rdi], rax            ;
        mov     rax, 16[rsi]            ; copy second argument
        mov     16[rdi], rax            ;
        mov     rax, 8[rsi]             ; copy first argument
        mov     8[rdi], rax             ;

        ALTERNATE_ENTRY KiSystemServiceCopyEnd

;
; Call system service.
;

KiSS30:                                 ;

        call    r10                     ; call system service
        inc     dword ptr gs:[PcSystemCalls] ; increment number of system calls

;
; System service exit.
;
;   eax - Supplies the system service status.
;
;   rbp - Supplies the address of the trap frame.
;
; N.B. It is possible that the values of rsi, rdi, and rbx have been destroyed
;      and, therefore, they cannot be used in the system service exit sequence.
;      This can happen on a failed attempt to raise an exception via a system
;      service.
;

        ALTERNATE_ENTRY KiSystemServiceExit

        mov     rbx, TrRbx[rbp]         ; restore extra registers
        mov     rdi, TrRdi[rbp]         ;
        mov     rsi, TrRsi[rbp]         ;
        test    byte ptr TrSegCs[rbp], MODE_MASK ; test if previous mode user
        jz      KiSS40                  ; if z, previous mode not user

;
; Check if the current IRQL is above passive level.
;

if DBG

        xor     r9, r9                  ; clear parameter value
        mov     r8, cr8                 ; get current IRQL
        or      r8, r8                  ; check if IRQL is passive level
        mov     ecx, IRQL_GT_ZERO_AT_SYSTEM_SERVICE ; set bugcheck code
        jnz     short KiSS33            ; if nz, IRQL not passive level

;
; Check if kernel APCs are disabled or a process is attached.
;

        mov     rcx, gs:[PcCurrentThread] ; get current thread address
        movzx   r8d, byte ptr ThApcStateIndex[rcx] ; get APC state index
        mov     r9d, ThCombinedApcDisable[rcx] ; get kernel APC disable
        or      r9d, r9d                ; check if kernel APCs disabled
        jnz     short KiSS32            ; if nz, Kernel APCs disabled
        or      r8d, r8d                ; check if process attached
        jz      short KiSS37            ; if z, process not attached
KiSS32: mov     ecx, APC_INDEX_MISMATCH ; set bugcheck code
KiSS33: mov     rdx, TrRip[rbp]         ; set system call address
        mov     r10, rbp                ; set trap frame address
        call    KiBugCheckDispatch      ; bugcheck system - no return

endif

KiSS37: RESTORE_TRAP_STATE <Service>    ; restore trap state/exit to user mode

KiSS40: mov     rcx, gs:[PcCurrentThread] ; get current thread address
        mov     rdx, TrTrapFrame[rbp]   ; restore previous trap frame address
        mov     ThTrapFrame[rcx], rdx   ;
        mov     dl, TrPreviousMode[rbp] ; restore previous mode
        mov     ThPreviousMode[rcx], dl ;

        RESTORE_TRAP_STATE <Kernel>     ; restore trap state/exit to kernel mode

;
; The specified system service number is not within range. Attempt to convert
; the thread to a GUI thread if the specified system service is a GUI service
; and the thread has not already been converted to a GUI thread.
;
; N.B. Convert to GUI thread will not overwrite the parameter home area.
;

KiSS50: cmp     edi, SERVICE_TABLE_TEST ; check if GUI service
        jne     KiSS60                  ; if ne, not GUI service
        mov     TrP1Home[rbp], eax      ; save system service number
        mov     TrP2Home[rbp], rcx      ; save system service arguments
        mov     TrP3Home[rbp], rdx      ;
        mov     TrP4Home[rbp], r8       ;
        mov     TrP5[rbp], r9           ;
        call    KiConvertToGuiThread    ; attempt to convert to GUI thread
        or      eax, eax                ; check if service was successful
        mov     eax, TrP1Home[rbp]      ; restore system service number
        mov     rcx, TrP2Home[rbp]      ; restore system service arguments
        mov     rdx, TrP3Home[rbp]      ;
        mov     r8, TrP4Home[rbp]       ;
        mov     r9, TrP5[rbp]           ;
        mov     ThTrapFrame[rbx], rsp   ; set current frame pointer address
        jz      KiSystemServiceRepeat   ; if z, successful conversion to GUI

;
; The conversion to a GUI thread failed. The correct return value is encoded
; in a byte table indexed by the service number that is at the end of the
; service address table. The encoding is as follows:
;
;   0 - return 0.
;   -1 - return -1.
;   1 - return status code.
;

        lea     rdi, KeServiceDescriptorTableShadow + SdLength ;
        mov     esi, SdLimit[rdi]       ; get service table limit
        mov     rdi, SdBase[rdi]        ; get service table base
        lea     rdi, [rdi + rsi * 4]    ; get ending service table address
        movsx   eax, byte ptr [rdi + rax] ; get status byte value
        or      eax, eax                ; check for 0 or - 1
        jle     KiSystemServiceExit     ; if le, return status byte value
KiSS60: mov     eax, STATUS_INVALID_SYSTEM_SERVICE ; set return status
        jmp     KiSystemServiceExit     ; finish in common code

        TRAP_END KiSystemCall64

        subttl  "Common Bugcheck Dispatch"
;++
;
; Routine Description:
;
;   This routine allocates an exception frame on stack, saves nonvolatile
;   machine state, and calls the system bugcheck code.
;
;   N.B. It is the responsibility of the caller to initialize the exception
;        record.
;
; Arguments:
;
;   ecx - Supplies the bugcheck code.
;
;   rdx to r10 - Supplies the bugcheck parameters.
;
; Return Value:
;
;    There is no return from this function.
;
;--

        TRAP_ENTRY KiBugCheckDispatch

        GENERATE_EXCEPTION_FRAME        ; generate exception frame

        mov     ExP5[rsp], r10          ; save parameter 5
        call    KeBugCheckEx            ; bugcheck system - not return
        nop                             ; fill - do not remove

        TRAP_END KiBugCheckDispatch

        subttl  "Common Exception Dispatch"
;++
;
; Routine Description:
;
;   This routine allocates an exception frame on stack, saves nonvolatile
;   machine state, and calls the system exception dispatcher.
;
;   N.B. It is the responsibility of the caller to initialize the exception
;        record.
;
; Arguments:
;
;   ecx - Supplies the exception code.
;
;   edx - Supplies the number of parameters.
;
;   r8 - Supplies the exception address.
;
;   r9 - r11 - Supply the exception  parameters.
;
;   rbp - Supplies a pointer to the trap frame.
;
;   rsp - Supplies a pointer to the trap frame.
;
; Return Value:
;
;    There is no return from this function.
;
;--

        TRAP_ENTRY KiExceptionDispatch

        GENERATE_EXCEPTION_FRAME        ; generate exception frame

        lea     rax, ExExceptionRecord[rsp] ; get exception record address
        mov     ErExceptionCode[rax], ecx ; set exception code
        xor     ecx, ecx                ;
        mov     dword ptr ErExceptionFlags[rax], ecx ; clear exception flags
        mov     ErExceptionRecord[rax], rcx ; clear exception record address
        mov     ErExceptionAddress[rax], r8 ; set exception address
        mov     ErNumberParameters[rax], edx ; set number of parameters
        mov     ErExceptionInformation[rax], r9 ; set exception parameters
        mov     ErExceptionInformation + 8[rax], r10 ;
        mov     ErExceptionInformation + 16[rax], r11 ;
        mov     r9b, TrSegCs[rbp]       ; isolate previous mode
        and     r9b, MODE_MASK          ;
        mov     byte ptr ExP5[rsp], TRUE ; set first chance parameter
        lea     r8, (-128)[rbp]         ; set trap frame address
        mov     rdx, rsp                ; set exception frame address
        mov     rcx, rax                ; set exception record address
        call    KiDispatchException     ; dispatch exception

        subttl  "Common Exception Exit"
;++
;
; Routine Description:
;
;   This routine is called to exit an exception.
;
;   N.B. This transfer of control occurs from:
;
;        1. a fall through from above.
;        2. the exit from a continue system service.
;        3. the exit form a raise exception system service.
;        4. the exit into user mode from thread startup.
;
;   N.B. Control is transferred to this code via a jump.
;
; Arguments:
;
;   rbp - Supplies the address of the trap frame.
;
;   rsp - Supplies the address of the exception frame.
;
; Return Value:
;
;   Function does not return.
;
;--

        ALTERNATE_ENTRY KiExceptionExit

        RESTORE_EXCEPTION_STATE <NoPop> ; restore exception state/deallocate

        RESTORE_TRAP_STATE <Volatile>   ; restore trap state and exit

        TRAP_END KiExceptionDispatch

        subttl  "System Service Linkage"
;++
;
; VOID
; KiServiceLinkage (
;     VOID
;     )
;
; Routine Description:
;
;   This is a dummay function that only exists to make trace back through
;   a kernel mode to kernel mode system call work.
; Arguments:
;
;   None.
;
; Return value:
;
;   None.
;
;--

        TRAP_ENTRY KiServiceLinkage

        .allocstack 0

        END_PROLOGUE

        ret                             ;

        TRAP_END  KiServiceLinkage

        end
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ke\i386\abiosa.asm ===
title  "Abios Support Assembly Routines"
;++
;
; Copyright (c) Microsoft Corporation. All rights reserved. 
;
; You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
; If you do not agree to the terms, do not use the code.
;
;
; Module Name:
;
;    abiosa.asm
;
; Abstract:
;
;    This module implements assembly code for ABIOS support.
;
;--
.386p
        .xlist
include ks386.inc
include callconv.inc                    ; calling convention macros
include i386\kimacro.inc
include irqli386.inc
        .list

extrn   _DbgPrint:proc

extrn _KiStack16GdtEntry:DWORD

;
; This should be either 0 or 1, if it's greater than 1, then we've re-entered the BIOS.
;
extrn _KiInBiosCall:DWORD
extrn _FlagState:DWORD
extrn _KiBiosFrame:DWORD

OPERAND_OVERRIDE        equ     66h
ADDRESS_OVERRIDE        equ     67h
KGDT_CDA16              equ     0E8h

LocalStack                              equ     16          ; 4 DWORDS of slop for PnPBioses.

if DBG
extrn  KiBiosReenteredAssert:DWORD
endif

; Macro change note:
;
;   This macro pair used to do an unconditional sti coming back from the 16-bit
;   side, this potentially caused problems in APM. Now we save and restore the
;   flag state
;

;++
;
;   STACK32_TO_STACK16
;
;   Macro Description:
;
;       This macro remaps current 32bit stack to 16bit stack.
;
;   Arguments:
;
;       None.
;
;--

STACK32_TO_STACK16      macro

        pushfd
        mov     ecx,[esp]
        mov     _FlagState,ecx
        popfd
        mov     eax, PCR[PcPrcbData+PbCurrentThread] ; get current thread address
        mov     eax, [eax]+ThStackLimit ; get thread stack base
        mov     edx, eax
        mov     ecx, _KiStack16GdtEntry
        mov     word ptr [ecx].KgdtBaseLow, ax
        shr     eax, 16
        mov     byte ptr [ecx].KgdtBaseMid, al
        mov     byte ptr [ecx].KgdtBaseHi, ah
        cli
        sub     esp, edx
        mov     eax, KGDT_STACK16
        mov     ss, ax

;
; NOTE that we MUST leave interrupts remain off.
; We'll turn it back on after we switch to 16 bit code.
;

endm

;++
;
;   STACK16_TO_STACK32
;
;   Macro Description:
;
;       This macro remaps current 32bit stack to 16bit stack.
;
;   Arguments:
;
;       None.
;
;--

STACK16_TO_STACK32      macro   Stack32

        db      OPERAND_OVERRIDE
        db      ADDRESS_OVERRIDE
        mov     eax, PCR[PcPrcbData+PbCurrentThread] ; get current thread address
        db      OPERAND_OVERRIDE
        db      ADDRESS_OVERRIDE
        mov     eax, [eax]+ThStackLimit ; get thread stack limit
        cli
        db      OPERAND_OVERRIDE
        add     esp, eax
        db      OPERAND_OVERRIDE
        mov     eax, KGDT_R0_DATA
        mov     ss, ax
        db      OPERAND_OVERRIDE
        db      ADDRESS_OVERRIDE
        push ds:_FlagState
        db      OPERAND_OVERRIDE
        popfd
endm

COPY_CALL_FRAME macro FramePtr

        mov     [FramePtr].TsEax,eax
        mov     [FramePtr].TsEbx,ebx
        mov     [FramePtr].TsEcx,ecx
        mov     [FramePtr].TsEdx,edx
        mov     [FramePtr].TsEsi,esi
        mov     [FramePtr].TsEdi,edi
        mov     [FramePtr].TsEbp,ebp
        mov     [FramePtr].TsHardwareEsp,esp
        mov     [FramePtr].TsSegFs,fs
        mov     [FramePtr].TsSegCs,cs
endm
        page ,132
        subttl  "Abios Support Code"
_TEXT   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

;
; BBT cannot instrument code between this label and BBT_Exclude_Selector_Code_End
;
        public  _BBT_Exclude_Selector_Code_Begin
_BBT_Exclude_Selector_Code_Begin  equ     $
        int 3


;++
; ULONG
; KiAbiosGetGdt (
;     VOID
;     )
;
; Routine Description:
;
;     This routine returns the starting address of GDT of current processor.
;
; Arguments:
;
;     None.
;
; Return Value:
;
;     return Pcr->GDT
;
;--

cPublicProc _KiAbiosGetGdt,0

        mov     eax, PCR[PcGdt]
        stdRET    _KiAbiosGetGdt

stdENDP _KiAbiosGetGdt

;++
; VOID
; KiI386CallAbios(
;     IN KABIOS_POINTER AbiosFunction,
;     IN KABIOS_POINTER DeviceBlockPointer,
;     IN KABIOS_POINTER FunctionTransferTable,
;     IN KABIOS_POINTER RequestBlock
;     )
;
; Routine Description:
;
;     This function invokes ABIOS service function for device driver.  This
;     routine is executing at DIAPTCH_LEVEL to prevent context swapping.
;
;     N.B. We arrive here from the Ke386AbiosCall with a 32bit CS. That is,
;     we're executing the code with cs:eip where cs contains a selector for a
;     32bit flat segment. We want to get to a 16bit cs. That is, cs:ip.
;     The reason is that ABIOS is running at 16 bit segment.
;     Before we can call ABIOS service we must load ss and cs segment
;     registers with selectors for 16bit segments.  We start by pushing a far
;     pointer to a label in the macro and then doing a retf. This allows us
;     to fall through to the next instruction, but we're now executing
;     through cs:ip with a 16bit CS. Then, we remap our 32-bit stack to 16-bit
;     stack.
;
; Arguments:
;
;     AbiosFunction - a 16:16 pointer to the abios service function.
;
;     DeviceBlockPointer - a 16:16 pointer to Device Block.
;
;     FunctionTransferTable - a 16:16 pointer to Function Transfer Table.
;
;     RequestBlock - a 16:16 pointer to device driver's request block.
;
; Return Value:
;
;     None.
;--

KacAbiosFunction        equ     [ebp + 8]
KacDeviceBlock          equ     [ebp + 12]
KacFunctionTable        equ     [ebp + 16]
KacRequestBlock         equ     [ebp + 20]

cPublicProc _KiI386CallAbios,4

;
; We're using a 32bit CS:EIP - go to a 16bit CS:IP
; Note the base of KiAbiosCallSelector is the flat address of _KiI386AbiosCall
; routine.
;

        push    ebp
        mov     ebp, esp
        push    ebx

        COPY_CALL_FRAME _KiBiosFrame
        sub     esp,LocalStack          ; After C style frame
        CurrentIrql                             ; Local Variable
        push    eax                             ; Local Variable

        cmp     al, DISPATCH_LEVEL              ; Is irql > Dispatch_level?
        jae     short Kac00

; Raise to Dispatch Level
        RaiseIrql DISPATCH_LEVEL
        mov     [esp], al

Kac00:

;
; Set up parameters on stack before remapping stack.
;

        push    word ptr KGDT_CDA16             ; CDA anchor selector
        push    KacRequestBlock                 ; Request Block
        push    KacFunctionTable                ; Func transfer table
        push    KacDeviceBlock                  ; Device Block
        mov     ebx, KacAbiosFunction           ; (ebx)-> Abios Entry

;
; Remap current stack to 16:16 stack.  The base of the 16bit stack selector is
; the base of current kernel stack.
;

        inc     _KiInBiosCall                         ; Set the 'In Bios' flag
if DBG
        cmp   _KiInBiosCall,2
        jb  @F
        push    offset FLAT:KiBiosReenteredAssert
        call    _dbgPrint
        add     esp, 4
@@:
endif

        STACK32_TO_STACK16                      ; Switch to 16bit stack
        push    word ptr KGDT_CODE16
        push    word ptr (offset FLAT:Kac40 - offset FLAT:_KiI386CallAbios@16)
        push    KGDT_CODE16
        push    offset FLAT:Kac30 - offset FLAT:_KiI386CallAbios@16
        retf

Kac30:

;
; Stack switching (from 32 to 16) turns interrupt off.  We must turn it
; back on.
;

        sti
        push    bx                              ; Yes, BX not EBX!
        retf
Kac40:
        add     esp, 14                         ; pop out all the parameters

        STACK16_TO_STACK32                      ; switch back to 32 bit stack

;
; Pull callers flat return address off stack and push the
; flat code selector followed by the return offset, then
; execute a far return and we'll be back in the 32-bit code space.
;

        db      OPERAND_OVERRIDE
        push    KGDT_R0_CODE
        db      OPERAND_OVERRIDE
        push    offset FLAT:Kac50
        db      OPERAND_OVERRIDE
        retf
Kac50:
        pop     ecx                             ; [ecx] = OldIrql
        pop     ebx                             ; restore ebx
        cmp     cl, DISPATCH_LEVEL
        jae     short Kac60

        LowerIrql cl

Kac60:

        dec     _KiInBiosCall                          ;Clear 'In Bios' Flag

        add     esp,LocalStack                           ; subtract off the scratch space
        pop     ebp
        stdRET    _KiI386CallAbios

stdENDP _KiI386CallAbios


;; ********************************************************
;;
;; BEGIN - power_management
;;
;;

;++
; VOID
; KeI386Call16BitFunction (
;     IN OUT PCONTEXT Regs
;     )
;
; Routine Description:
;
;     This function calls the 16 bit function specified in the Regs.
;
; Parameters:
;
;     Regs - supplies a pointer to register context to call 16 function.
;
;   NOTE: Caller must be at DPC_LEVEL
;
;--

cPublicProc _KeI386Call16BitFunction,1

    ;  verify CurrentIrql
    ;  verify context flags

        push    ebp                             ; save nonvolatile registers
        push    ebx
        push    esi
        push    edi
        mov     ebx, dword ptr [esp + 20]       ; (ebx)-> Context

        COPY_CALL_FRAME _KiBiosFrame

        sub     esp,LocalStack          ; After prolog

        inc    _KiInBiosCall                         ; Set the 'In Bios' flag
if DBG
        cmp   _KiInBiosCall,2
        jb  @F
        push    offset FLAT:KiBiosReenteredAssert
        call    _dbgPrint
        add     esp, 4
@@:
endif

;
; We're using a 32bit CS:EIP - go to a 16bit CS:IP
; Note the base of KiAbiosCallSelector is the flat address of _KiI386AbiosCall
; routine.
;

;
; Remap current stack to 16:16 stack.  The base of the 16bit stack selector is
; the base of current kernel stack.
;

        STACK32_TO_STACK16                      ; Switch to 16bit stack
    ;
    ; Push return address from 16 bit function call to kernel
    ;

        push    word ptr KGDT_CODE16
        push    word ptr (offset FLAT:Kbf40 - offset FLAT:_KiI386CallAbios@16)

        ;
        ; Load context to call with
        ;

        push    word ptr [ebx].CsEFlags
        push    word ptr [ebx].CsSegCs
        push    word ptr [ebx].CsEip

        mov     eax, [ebx].CsEax
        mov     ecx, [ebx].CsEcx
        mov     edx, [ebx].CsEdx
        mov     edi, [ebx].CsEdi
        mov     esi, [ebx].CsEsi
        mov     ebp, [ebx].CsEbp
        push    [ebx].CsSegGs
        push    [ebx].CsSegFs
        push    [ebx].CsSegEs
        push    [ebx].CsSegDs
        mov     ebx, [ebx].CsEbx
        pop     ds
        pop     es
        pop     fs
        pop     gs

    ;
    ; Switch to 16bit CS
    ;
        push    KGDT_CODE16
        push    offset FLAT:Kbf30 - offset FLAT:_KiI386CallAbios@16
        retf

Kbf30:
    ;
    ; "call" to 16 bit function
    ;
        iretd

Kbf40:
    ;
    ; Push some of the returned context which will be needed to
    ; switch back to the 32 bit SS & CS.
    ;
        db      OPERAND_OVERRIDE
        push    ds

        db      OPERAND_OVERRIDE
        push    es

        db      OPERAND_OVERRIDE
        push    fs

        db      OPERAND_OVERRIDE
        push    gs

        db      OPERAND_OVERRIDE
        push    eax

        db      OPERAND_OVERRIDE
        pushfd

        db      OPERAND_OVERRIDE
        mov     eax, KGDT_R0_PCR
        mov     fs, ax

        db      OPERAND_OVERRIDE
        mov     eax, KGDT_R3_DATA OR RPL_MASK
        mov     ds, ax
        mov     es, ax

        xor     eax, eax

    ;
    ; Switch back to 32 bit stack
    ;

        STACK16_TO_STACK32

;
; Push the flat code selector followed by the return offset, then
; execute a far return and we'll be back in the 32-bit code space.
;


        db      OPERAND_OVERRIDE
        push    KGDT_R0_CODE
        db      OPERAND_OVERRIDE
        push    offset FLAT:Kbf50
        db      OPERAND_OVERRIDE
        retf

Kbf50:
    ;
    ; Return resulting context
    ;

        mov     eax, dword ptr [esp+44+LocalStack]     ; (eax) = Context Record
        pop     [eax].CsEflags
        pop     [eax].CsEax
        pop     [eax].CsSegGs
        pop     [eax].CsSegFs
        pop     [eax].CsSegEs
        pop     [eax].CsSegDs

        mov     [eax].CsEbx, ebx
        mov     [eax].CsEcx, ecx
        mov     [eax].CsEdx, edx
        mov     [eax].CsEdi, edi
        mov     [eax].CsEsi, esi
        mov     [eax].CsEbp, ebp

;
; Restore regs & return
;
        dec     _KiInBiosCall                         ; Clear  the 'In Bios' flag

        add     esp,LocalStack                                          ;remove scratch space
        pop     edi
        pop     esi
        pop     ebx
        pop     ebp
        stdRET    _KeI386Call16BitFunction

stdENDP _KeI386Call16BitFunction

;++
; USHORT
; KeI386Call16BitCStyleFunction (
;     IN ULONG EntryOffset,
;     IN ULONG EntrySelector,
;     IN PUCHAR Parameters,
;     IN ULONG Size
;     )
;
; Routine Description:
;
;     This function calls the 16 bit function which supports C style calling convention.
;
; Parameters:
;
;     EntryOffset and EntrySelector - specifies the entry point of the 16 bit function.
;
;     Parameters - supplies a pointer to a parameter block which will be
;         passed to 16 bit function as parameters.
;
;     Size - supplies the size of the parameter block.
;
;   NOTE: Caller must be at DPC_LEVEL
;
; Returned Value:
;
;     AX returned by 16 bit function.
;
;--

cPublicProc _KeI386Call16BitCStyleFunction,4

;
;  verify CurrentIrql
;  verify context flags
;

        push    ebp                             ; save nonvolatile registers
        push    ebx
        push    esi
        push    edi

        COPY_CALL_FRAME _KiBiosFrame

        inc     _KiInBiosCall                         ; Set the 'In Bios' flag
if DBG
        cmp   _KiInBiosCall,2
        jb  @F
        push    offset FLAT:KiBiosReenteredAssert
        call    _dbgPrint
        add     esp, 4
@@:
endif

        mov     edi, esp
        sub     esp,LocalStack          ;  now, add in some scratch space
        mov     esi, dword ptr [esp + LocalStack +28]       ; (esi)->BiosParameters
        or         esi, esi
        jz         short @f

        mov    ecx, [esp + LocalStack +32]                 ; (ecx) = parameter size
        sub    esp, ecx                        ; allocate space on TOS to copy parameters

        mov   edi, esp
        rep     movsb                           ; (edi)-> Top of nonvolatile reg save area
        add    edi, LocalStack           ; edi now points to original stack

@@:

;
; We're using a 32bit CS:EIP - go to a 16bit CS:IP
; Note the base of KiAbiosCallSelector is the flat address of _KiI386AbiosCall
; routine.
;

;
; Remap current stack to 16:16 stack.  The base of the 16bit stack selector is
; the base of current kernel stack.
;

        STACK32_TO_STACK16                      ; Switch to 16bit stack

;
; Push return address from 16 bit function call to kernel
;

        push    word ptr KGDT_CODE16
        push    word ptr (offset FLAT:Kbfex40 - offset FLAT:_KiI386CallAbios@16)

        push    word ptr 0200h                  ; flags
        push    word ptr [edi + 24 ]             ; entry selector
        push    word ptr [edi + 20 ]             ; entry offset

;
; Switch to 16bit CS
;
        push    KGDT_CODE16
        push    offset FLAT:Kbfex30 - offset FLAT:_KiI386CallAbios@16
        retf

Kbfex30:
;
; "call" to 16 bit function
;
        iretd

Kbfex40:
;
; Save return value.
;

        db      OPERAND_OVERRIDE
        push    eax

;
; Restore Flat mode segment registers.
;

        db      OPERAND_OVERRIDE
        mov     eax, KGDT_R0_PCR
        mov     fs, ax

        db      OPERAND_OVERRIDE
        mov     eax, KGDT_R3_DATA OR RPL_MASK
        mov     ds, ax
        mov     es, ax

        xor     eax, eax

;
; Switch back to 32 bit stack
;

        STACK16_TO_STACK32

;
; Push the flat code selector followed by the return offset, then
; execute a far return and we'll be back in the 32-bit code space.
;


        db      OPERAND_OVERRIDE
        push    KGDT_R0_CODE
        db      OPERAND_OVERRIDE
        push    offset FLAT:Kbfex50
        db      OPERAND_OVERRIDE
        retf

Kbfex50:
        pop     eax

;
; Restore regs & return
;
        dec    _KiInBiosCall                         ; Clear  the 'In Bios' flag

        mov     esp, edi                                 ; Also removes the scratch space!
        pop     edi
        pop     esi
        pop     ebx
        pop     ebp
        stdRET    _KeI386Call16BitCStyleFunction

stdENDP _KeI386Call16BitCStyleFunction

;
; BBT cannot instrument code between BBT_Exclude_Selector_Code_Begin and this label
;

        public  _BBT_Exclude_Selector_Code_End
_BBT_Exclude_Selector_Code_End  equ     $
        int 3

;;
;; END - power_management
;;
;; ********************************************************


        public  _KiEndOfCode16
_KiEndOfCode16  equ     $



_TEXT   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ke\i386\abios.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    abios.h

Abstract:

    This module contains the i386 kernel ABIOS specific header file.

--*/

//
// Define public portion of the ABIOS Device Block
//

typedef struct _KDEVICE_BLOCK {
    USHORT Length;
    UCHAR Revision;
    UCHAR SecondDeviceId;
    USHORT LogicalId;
    USHORT DeviceId;
    USHORT NumberExclusivePortPairs;
    USHORT NumberCommonPortPairs;
} KDEVICE_BLOCK, *PKDEVICE_BLOCK; 


typedef struct _KABIOS_POINTER {
    USHORT Offset;
    USHORT Selector;
} KABIOS_POINTER, *PKABIOS_POINTER;

#pragma pack(1)

//
// ABIOS Function Transfer Table definition
//

typedef struct _KFUNCTION_TRANSFER_TABLE {
    KABIOS_POINTER CommonRoutine[3];
    USHORT FunctionCount;
    USHORT Reserved;
    KABIOS_POINTER SpecificRoutine;
} KFUNCTION_TRANSFER_TABLE, *PKFUNCTION_TRANSFER_TABLE;


//
// ABIOS Commom Data Area definitions
//

typedef struct _KDB_FTT_SECTION {
    KABIOS_POINTER DeviceBlock;
    KABIOS_POINTER FunctionTransferTable;
} KDB_FTT_SECTION, *PKDB_FTT_SECTION;

typedef struct _KCOMMON_DATA_AREA {
    USHORT DataPointer0Offset;
    USHORT NumberLids;
    ULONG Reserved;
    PKDB_FTT_SECTION DbFttPointer;
} KCOMMON_DATA_AREA, *PKCOMMON_DATA_AREA;

#pragma pack()

//
// Available GDT Entry
//

typedef struct _KFREE_GDT_ENTRY {
    struct _KFREE_GDT_ENTRY *Flink;
    ULONG BaseMid : 8;
    ULONG Type : 5;
    ULONG Dpl : 2;
    ULONG Present : 1;
    ULONG LimitHi : 4;
    ULONG Sys : 1;
    ULONG Reserved_0 : 1;
    ULONG Default_Big : 1;
    ULONG Granularity : 1;
    ULONG BaseHi : 8;
} KFREE_GDT_ENTRY, *PKFREE_GDT_ENTRY;

//
// Logical Id table entry
//

typedef struct _KLID_TABLE_ENTRY {
    ULONG Owner;
    ULONG OwnerCount;
} KLID_TABLE_ENTRY, *PKLID_TABLE_ENTRY;

#define LID_NO_SPECIFIC_OWNER  0xffffffff
#define NUMBER_LID_TABLE_ENTRIES 1024

//
// Macro to extract the high byte of a short offset
//

#define HIGHBYTE(l) ((UCHAR)(((USHORT)(l)>>8) & 0xff))

//
// Macro to extract the low byte of a short offset
//

#define LOWBYTE(l) ((UCHAR)(l))

//
// The following selectors are reserved for 16 bit stack, code and 
// ABIOS Common Data Area.
//

#define KGDT_STACK16 0xf8
#define KGDT_CODE16 0xf0
#define KGDT_CDA16  0xe8         
#define KGDT_GDT_ALIAS 0x70

//
// Misc. definitions
//

#define RESERVED_GDT_ENTRIES  28

//
// External references
//

extern PKFREE_GDT_ENTRY KiAbiosGdtStart;
extern PKFREE_GDT_ENTRY KiAbiosGdtEnd;
extern PUCHAR KiEndOfCode16;
extern ULONG KiStack16GdtEntry;

extern 
VOID
KiI386CallAbios(
    IN KABIOS_POINTER AbiosFunction,
    IN KABIOS_POINTER DeviceBlockPointer,
    IN KABIOS_POINTER FunctionTransferTable,
    IN KABIOS_POINTER RequestBlock
    );

VOID
KiInitializeAbiosGdtEntry (
    OUT PKGDTENTRY GdtEntry,
    IN ULONG Base,
    IN ULONG Limit,
    IN USHORT Type
    );

extern
ULONG
KiAbiosGetGdt (
    VOID
    );
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ke\i386\abiosc.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    abiosc.c

Abstract:

    This module implements ABIOS support C routines for i386 NT.

Environment:

    FLAT mode.

--*/

#include "ki.h"
#pragma hdrstop
#include "abios.h"

extern PKCOMMON_DATA_AREA KiCommonDataArea;
extern BOOLEAN KiAbiosPresent;

//
// The reason of having these variables defined in here is to isolate
// ABIOS from current system.
//

//
// KiNumberFreeSelectors defines the number of available selectors for
// ABIOS specific drivers.  This number should be the same across all
// the processors.
//

static USHORT KiNumberFreeSelectors = 0;

//
// KiFreeGdtListHead points to the head of free GDT list on the processor 0.
//

static PKFREE_GDT_ENTRY KiFreeGdtListHead = 0L;

//
// Logica Id Table to control the ownership of logical Id.
//

PKLID_TABLE_ENTRY KiLogicalIdTable;

//
// KiAbiosGdt[] defines the Starting address of GDT for each processor.
//

ULONG KiAbiosGdt[MAXIMUM_PROCESSORS];

//
// SpinLock for accessing GDTs
//

KSPIN_LOCK KiAbiosGdtLock;

//
// Spinlock for accessing Logical Id Table
//

KSPIN_LOCK KiAbiosLidTableLock;

//
// KiStack16GdtEntry defines the address of the gdt entry for 16 bit stack.
//

ULONG KiStack16GdtEntry;

VOID
KiInitializeAbiosGdtEntry (
    OUT PKGDTENTRY GdtEntry,
    IN ULONG Base,
    IN ULONG Limit,
    IN USHORT Type
    )

/*++

Routine Description:

    This function initializes a GDT entry for abios specific code.  Base,
    Limit, and Type (code, data) are set according to parameters.  All other
    fields of the entry are set to match standard system values.

    N.B. The BIG and GRANULARITY are always set to 0.

Arguments:

    GdtEntry - GDT descriptor to be filled in.

    Base - Linear address of the first byte mapped by the selector.

    Limit - Size of the selector in BYTE.

    Type - Code or Data.  All code selectors are marked readable,
            all data selectors are marked writeable.

Return Value:

    Pointer to the GDT entry.

--*/

{
    GdtEntry->LimitLow = (USHORT)(Limit & 0xffff);
    GdtEntry->BaseLow = (USHORT)(Base & 0xffff);
    GdtEntry->HighWord.Bytes.BaseMid = (UCHAR)((Base & 0xff0000) >> 16);
    GdtEntry->HighWord.Bits.Type = Type;
    GdtEntry->HighWord.Bits.Dpl = 0;
    GdtEntry->HighWord.Bits.Pres = 1;
    GdtEntry->HighWord.Bits.LimitHi = (Limit & 0xf0000) >> 16;
    GdtEntry->HighWord.Bits.Sys = 0;
    GdtEntry->HighWord.Bits.Reserved_0 = 0;
    GdtEntry->HighWord.Bits.Default_Big = 0;
    GdtEntry->HighWord.Bits.Granularity = 0;
    GdtEntry->HighWord.Bytes.BaseHi = (UCHAR)((Base & 0xff000000) >> 24);
}

ULONG
KiI386SelectorBase (
    IN USHORT Selector
    )

/*++

Routine Description:

    This function returns the base address of the specified GDT selector.

Arguments:

    Selector - Supplies the desired selector.

Return Value:

    SelectorBase - Return the base address of the specified selector;
                   (return -1L if invalid selector)


--*/

{
    PKGDTENTRY GdtEntry;


    GdtEntry = (PKGDTENTRY)(KiAbiosGetGdt() + Selector);
    if (GdtEntry->HighWord.Bits.Pres) {
        return ((ULONG)GdtEntry->BaseLow |
                (ULONG)GdtEntry->HighWord.Bytes.BaseMid << 16 |
                (ULONG)GdtEntry->HighWord.Bytes.BaseHi << 24);
    } else {
        return (ULONG)(-1L);
    }
}

NTSTATUS
KeI386GetLid(
    IN USHORT DeviceId,
    IN USHORT RelativeLid,
    IN BOOLEAN SharedLid,
    IN PDRIVER_OBJECT DriverObject,
    OUT PUSHORT LogicalId
    )

/*++

Routine Description:

    This function searches Device Blocks and Common Data Area for the
    Logical Id matching the specified Device Id.

    N.B. To speed the search, this routine ASSUMES that
    the LIDs with the same Device ID always appear consecutively in the
    Common Data Area.  IBM ABIOS doc does not explicitly specify this.
    But from the way ABIOS initializes Device Block and Function Transfer
    Table, I think the assumption is true.

Arguments:

    DeviceId - Desired Device Id.

    RelativeLid - Specifies the Nth logical Id for this device Id.  A value
                  of 0 indicates the first available Lid.

    SharedLid - A boolean value indicates if it is a shared or exclusively
                owned logical Id.

    DriverObject - Supplies a 32-bit flat pointer of the requesting device
                driver's driver object.  The DriverObject is used to establish
                the ownership of the desired LID.

    LogicalId - A pointer to a variable which will receive the Lid.

Return Value:

    STATUS_SUCCESS - If the requested LID is available.

    STATUS_ABIOS_NOT_PRESENT - If there is no ABIOS support in the system.

    STATUS_ABIOS_LID_NOT_EXIST - If the specified LID does not exist.

    STATUS_ABIOS_LID_ALREADY_OWNED - If the caller requests an exclusively
                                     owned LID.

--*/

{
    PKDB_FTT_SECTION CdaPointer;
    PKDEVICE_BLOCK DeviceBlock;
    USHORT Lid, RelativeLidCount = 1;
    ULONG Owner;
    USHORT Increment;
    KIRQL OldIrql;
    NTSTATUS Status;

    if (!KiAbiosPresent) {
        return STATUS_ABIOS_NOT_PRESENT;
    }

    if (SharedLid) {
        Owner = LID_NO_SPECIFIC_OWNER;
        Increment = 1;
    } else {
        Owner = (ULONG)DriverObject;
        Increment = 0;
    }

    //
    // If the Logical Id Table hasn't been created yet, create it now.
    //
    if (KiLogicalIdTable==NULL) {
        KiLogicalIdTable = ExAllocatePoolWithTag(NonPagedPool,
                                          NUMBER_LID_TABLE_ENTRIES *
                                          sizeof(KLID_TABLE_ENTRY),
                                          '  eK');
        if (KiLogicalIdTable == NULL) {
            return(STATUS_NO_MEMORY);
        }
        RtlZeroMemory(KiLogicalIdTable, NUMBER_LID_TABLE_ENTRIES*sizeof(KLID_TABLE_ENTRY));
    }

    //
    // For each Lid defined in Common Data Area, we check if it has non
    // empty device block and function transfer table.  If yes, we proceed
    // to check the device id.  Otherwise, we skip the Lid.
    //

    CdaPointer = (PKDB_FTT_SECTION)KiCommonDataArea + 2;
    Status = STATUS_ABIOS_LID_NOT_EXIST;

    ExAcquireSpinLock(&KiAbiosLidTableLock, &OldIrql);

    for (Lid = 2; Lid < KiCommonDataArea->NumberLids; Lid++) {
        if (CdaPointer->DeviceBlock.Selector != 0 &&
            CdaPointer->FunctionTransferTable.Selector != 0) {

            DeviceBlock = (PKDEVICE_BLOCK)(KiI386SelectorBase(
                                               CdaPointer->DeviceBlock.Selector)
                                           + (CdaPointer->DeviceBlock.Offset));
            if (DeviceBlock->DeviceId == DeviceId) {
                if (RelativeLid == RelativeLidCount || RelativeLid == 0) {
                    if (KiLogicalIdTable[Lid].Owner == 0L) {
                        KiLogicalIdTable[Lid].Owner = Owner;
                        KiLogicalIdTable[Lid].OwnerCount += Increment;
                        *LogicalId = Lid;
                        Status = STATUS_SUCCESS;
                    } else if (KiLogicalIdTable[Lid].Owner == LID_NO_SPECIFIC_OWNER) {
                        if (SharedLid) {
                            *LogicalId = Lid;
                            KiLogicalIdTable[Lid].OwnerCount += Increment;
                            Status = STATUS_SUCCESS;
                        } else {
                            Status = STATUS_ABIOS_LID_ALREADY_OWNED;
                        }
                    } else if (KiLogicalIdTable[Lid].Owner == (ULONG)DriverObject) {
                        *LogicalId = Lid;
                        Status = STATUS_SUCCESS;
                    } else if (RelativeLid != 0) {
                        Status = STATUS_ABIOS_LID_ALREADY_OWNED;
                    }
                    break;
                } else {
                    RelativeLidCount++;
                }
            }
        }
        CdaPointer++;
    }

    ExReleaseSpinLock(&KiAbiosLidTableLock, OldIrql);
    return Status;
}

NTSTATUS
KeI386ReleaseLid(
    IN USHORT LogicalId,
    IN PDRIVER_OBJECT DriverObject
    )

/*++

Routine Description:

    This function releases a logical Id.  This routine is called at ABIOS
    device driver destallation or termination.

Arguments:

    LogicalId - Logical Id to be released.

    DriverObject - Supplies a 32-bit flat pointer of the requesting device
                driver's driver object.  The DriverObject is used to check
                the ownership of the specified LID.

Return Value:

    STATUS_SUCCESS - If the requested LID is released.

    STATUS_ABIOS_NOT_PRESENT - If there is no ABIOS support in the system.

    STATUS_ABIOS_NOT_LID_OWNER - If the caller does not own the LID.

--*/

{
    KIRQL OldIrql;
    NTSTATUS Status;

    if (!KiAbiosPresent) {
        return STATUS_ABIOS_NOT_PRESENT;
    }

    ExAcquireSpinLock(&KiAbiosLidTableLock, &OldIrql);

    if (KiLogicalIdTable[LogicalId].Owner == (ULONG)DriverObject) {
        KiLogicalIdTable[LogicalId].Owner = 0L;
        Status = STATUS_SUCCESS;
    } else if (KiLogicalIdTable[LogicalId].Owner == LID_NO_SPECIFIC_OWNER) {
        KiLogicalIdTable[LogicalId].OwnerCount--;
        if (KiLogicalIdTable[LogicalId].OwnerCount == 0L) {
            KiLogicalIdTable[LogicalId].Owner = 0L;
        }
        Status = STATUS_SUCCESS;
    } else {
        Status = STATUS_ABIOS_NOT_LID_OWNER;
    }

    ExReleaseSpinLock(&KiAbiosLidTableLock, OldIrql);

    return Status;
}

NTSTATUS
KeI386AbiosCall(
    IN USHORT LogicalId,
    IN PDRIVER_OBJECT DriverObject,
    IN PUCHAR RequestBlock,
    IN USHORT EntryPoint
    )

/*++

Routine Description:

    This function calls an ABIOS service routine on behave of device driver
    using Operating System Transfer Convention.

Arguments:

    LogicalId - Logical Id for the call.

    DriverObject - Supplies a 32-bit flat pointer of the requesting device
                driver's driver object.  The DriverObject is used to verify
                the ownership of the desired LID.

    RequestBlock - A 16:16 (selector:offset) pointer to the request block.

    EntryPoint - Specifies which ABIOS entry point:

                 0 - Start Routine
                 1 - Interrupt Routine
                 2 - Timeout Routine

Return Value:

    STATUS_SUCCESS - If no error.

    STATUS_ABIOS_NOT_PRESENT - If there is no ABIOS support in the system.

    STATUS_ABIOS_INVALID_COMMAND - if the specified entry point is not supported.

    STATUS_ABIOS_INVALID_LID - If the Lid specified is invalid.

    STATUS_ABIOS_NOT_LID_OWNER - If the caller does not own this Lid.

    (Note that the request specific ABIOS returned code is in RequestBlock.)

--*/

{

    KABIOS_POINTER FuncTransferTable;
    KABIOS_POINTER DeviceBlock;
    KABIOS_POINTER AbiosFunction;
    PKFUNCTION_TRANSFER_TABLE FttPointer;

    if (!KiAbiosPresent) {
        return STATUS_ABIOS_NOT_PRESENT;
    }

    if (LogicalId >= KiCommonDataArea->NumberLids) {
        return STATUS_ABIOS_INVALID_LID;
    } else if (KiLogicalIdTable[LogicalId].Owner != (ULONG)DriverObject &&
               KiLogicalIdTable[LogicalId].Owner != LID_NO_SPECIFIC_OWNER) {
        return STATUS_ABIOS_NOT_LID_OWNER;
    } else if (EntryPoint > 2) {
        return STATUS_ABIOS_INVALID_COMMAND;
    }

    FuncTransferTable = ((PKDB_FTT_SECTION)KiCommonDataArea + LogicalId)->
                                               FunctionTransferTable;
    DeviceBlock = ((PKDB_FTT_SECTION)KiCommonDataArea + LogicalId)->DeviceBlock;
    FttPointer = (PKFUNCTION_TRANSFER_TABLE)(KiI386SelectorBase(FuncTransferTable.Selector) +
                                             (ULONG)FuncTransferTable.Offset);
    AbiosFunction = FttPointer->CommonRoutine[EntryPoint];
    KiI386CallAbios(AbiosFunction,
                    DeviceBlock,
                    FuncTransferTable,
                    *(PKABIOS_POINTER)&RequestBlock
                    );

    return STATUS_SUCCESS;
}

NTSTATUS
KeI386AllocateGdtSelectors(
    OUT PUSHORT SelectorArray,
    IN USHORT NumberOfSelectors
    )

/*++

Routine Description:

    This function allocates a set of GDT selectors for a device driver to use.
    Usually this allocation is performed at device driver initialization time
    to reserve the selectors for later use.

Arguments:

    SelectorArray - Supplies a pointer to an array of USHORT to be filled
                    in with the GDT selectors allocated.

    NumberOfSelectors - Specifies the number of selectors to be allocated.

Return Value:

    STATUS_SUCCESS - If the requested selectors are allocated.

    STATUS_ABIOS_SELECTOR_NOT_AVAILABLE - if system can not allocate the number
                               of selectors requested.

--*/

{
    PKFREE_GDT_ENTRY GdtEntry;
    KIRQL OldIrql;

    if (KiNumberFreeSelectors >= NumberOfSelectors) {
        ExAcquireSpinLock(&KiAbiosGdtLock, &OldIrql);

        //
        // The Free Gdt link list is maintained on Processor 0's GDT ONLY.
        // Because the 'selector' is an offset to the beginning of GDT and
        // it should be the same across all the processors.
        //

        KiNumberFreeSelectors = KiNumberFreeSelectors - NumberOfSelectors;
        GdtEntry = KiFreeGdtListHead;
        while (NumberOfSelectors != 0) {
            *SelectorArray++ = (USHORT)((ULONG)GdtEntry - KiAbiosGdt[0]);
            GdtEntry = GdtEntry->Flink;
            NumberOfSelectors--;
        }
        KiFreeGdtListHead = GdtEntry;
        ExReleaseSpinLock(&KiAbiosGdtLock, OldIrql);
        return STATUS_SUCCESS;
    } else {
        return STATUS_ABIOS_SELECTOR_NOT_AVAILABLE;
    }
}

NTSTATUS
KeI386ReleaseGdtSelectors(
    OUT PUSHORT SelectorArray,
    IN USHORT NumberOfSelectors
    )

/*++

Routine Description:

    This function releases a set of GDT selectors for a device driver.
    Usually this function is called at device driver termination or
    deinstallation time.

Arguments:

    SelectorArray - Supplies a pointer to an array of USHORT selectors
                    to be freed.

    NumberOfSelectors - Specifies the number of selectors to be released.

Return Value:

    STATUS_SUCCESS - If the requested LID is released.

--*/
{
    PKFREE_GDT_ENTRY GdtEntry;
    KIRQL OldIrql;
    ULONG Gdt;

    ExAcquireSpinLock(&KiAbiosGdtLock, &OldIrql);

    //
    // The Free Gdt link list is maintained on Processor 0's GDT ONLY.
    // Because the 'selector' is an offset to the beginning of GDT and
    // it should be the same across all the processors.
    //

    KiNumberFreeSelectors = KiNumberFreeSelectors + NumberOfSelectors;
    Gdt = KiAbiosGdt[0];
    while (NumberOfSelectors != 0) {
        GdtEntry = (PKFREE_GDT_ENTRY)(Gdt + *SelectorArray++);
        GdtEntry->Flink = KiFreeGdtListHead;
        KiFreeGdtListHead = GdtEntry;
        NumberOfSelectors--;
    }
    ExReleaseSpinLock(&KiAbiosGdtLock, OldIrql);
    return STATUS_SUCCESS;
}

NTSTATUS
KeI386FlatToGdtSelector(
    IN ULONG SelectorBase,
    IN USHORT Length,
    IN USHORT Selector
    )

/*++

Routine Description:

    This function converts a 32-bit flat address to a GDT selector-offset
    pair.  The segment set up is always 16-bit ring 0 data segment.

Arguments:

    SelectorBase - Supplies 32 bit flat address to be set as the base address
                   of the desired selector.

    Length - Supplies the Length of the segment.  The Length is a 16 bit value
             and zero means 64KB.

    Selector - Supplies the selector to be set up.

Return Value:

    STATUS_SUCCESS - If the requested LID is released.

    STATUS_ABIOS_NOT_PRESENT - If there is no ABIOS support in the system.

    STATUS_ABIOS_INVALID_SELECTOR - If the selector supplied is invalid.


--*/

{
    PKGDTENTRY GdtEntry, GdtEntry1;
    KIRQL OldIrql;
    ULONG i;

    if (!KiAbiosPresent) {
        return STATUS_ABIOS_NOT_PRESENT;
    }
    if (Selector < RESERVED_GDT_ENTRIES * sizeof(KGDTENTRY)) {
        return STATUS_ABIOS_INVALID_SELECTOR;
    } else {
        ExAcquireSpinLock(&KiAbiosGdtLock, &OldIrql);
        GdtEntry = (PKGDTENTRY)(KiAbiosGdt[0] + Selector);
        GdtEntry->LimitLow = (USHORT)(Length - 1);
        GdtEntry->BaseLow = LOWWORD(SelectorBase);
        GdtEntry->HighWord.Bytes.BaseMid = LOWBYTE(HIGHWORD(SelectorBase));
        GdtEntry->HighWord.Bytes.BaseHi = HIGHBYTE(HIGHWORD(SelectorBase));
        GdtEntry->HighWord.Bits.Pres = 1;
        GdtEntry->HighWord.Bits.Type = TYPE_DATA;
        GdtEntry->HighWord.Bits.Dpl = DPL_SYSTEM;
        for (i = 1; i < (ULONG)KeNumberProcessors; i++) {
            GdtEntry1 = (PKGDTENTRY)(KiAbiosGdt[i] + Selector);
            *GdtEntry1 = *GdtEntry;
        }
        ExReleaseSpinLock(&KiAbiosGdtLock, OldIrql);
        return STATUS_SUCCESS;
    }
}

VOID
Ki386InitializeGdtFreeList (
    PKFREE_GDT_ENTRY EndOfGdt
    )

/*++

Routine Description:

    This function initializes gdt free list by linking all the unused gdt
    entries to a free list.

Arguments:

    EndOfGdt - Supplies the ending address of desired GDT.

Return Value:

    None.

--*/
{
    PKFREE_GDT_ENTRY GdtEntry;

    GdtEntry = EndOfGdt - 1;
    KiFreeGdtListHead = (PKFREE_GDT_ENTRY)0;
    while (GdtEntry != (PKFREE_GDT_ENTRY)KiAbiosGetGdt() +
                        RESERVED_GDT_ENTRIES - 1) {
        if (GdtEntry->Present == 0) {
            GdtEntry->Flink = KiFreeGdtListHead;
            KiFreeGdtListHead = GdtEntry;
            KiNumberFreeSelectors++;
        }
        GdtEntry--;
    }
}

VOID
KiInitializeAbios (
    IN UCHAR Processor
    )

/*++

Routine Description:

    This function initializes gdt free list and sets up selector for
    KiI386AbiosCall (16-bit code).

Arguments:

    Processor - the processor who performs the initialization.

Return Value:

    None.

--*/

{

    ULONG GdtLength;
    PKGDTENTRY AliasGdtSelectorEntry;
    PKFREE_GDT_ENTRY EndOfGdt;

    //
    // First check if abios is recognized by osloader.
    //

    KiCommonDataArea = KeLoaderBlock->u.I386.CommonDataArea;

    //
    // NOTE For now we want to disable ABIOS support on MP.
    //

    if (KiCommonDataArea == NULL || Processor != 0) {
        KiAbiosPresent = FALSE;
    } else {
        KiAbiosPresent = TRUE;
    }

    //
    // Initialize the spinlocks for accessing GDTs and Lid Table.
    //

    KeInitializeSpinLock( &KiAbiosGdtLock );
    KeInitializeSpinLock( &KiAbiosLidTableLock );

    //
    // Determine the starting and ending addresses of GDT.
    //

    KiAbiosGdt[Processor] = KiAbiosGetGdt();

    AliasGdtSelectorEntry = (PKGDTENTRY)(KiAbiosGetGdt() + KGDT_GDT_ALIAS);
    GdtLength = 1 + (ULONG)(AliasGdtSelectorEntry->LimitLow) +
                (ULONG)(AliasGdtSelectorEntry->HighWord.Bits.LimitHi << 16);
    EndOfGdt = (PKFREE_GDT_ENTRY)(KiAbiosGetGdt() + GdtLength);

    //
    // Prepare selector for 16 bit stack segment
    //

    KiStack16GdtEntry = KiAbiosGetGdt() + KGDT_STACK16;

    KiInitializeAbiosGdtEntry(
                (PKGDTENTRY)KiStack16GdtEntry,
                0L,
                0xffff,
                TYPE_DATA
                );

    //
    // Establish the addressability of Common Data Area selector.
    //

    KiInitializeAbiosGdtEntry(
                (PKGDTENTRY)(KiAbiosGetGdt() + KGDT_CDA16),
                (ULONG)KiCommonDataArea,
                0xffff,
                TYPE_DATA
                );

    //
    // Set up 16-bit code selector for KiI386AbiosCall
    //

    KiInitializeAbiosGdtEntry(
                (PKGDTENTRY)(KiAbiosGetGdt() + KGDT_CODE16),
                (ULONG)&KiI386CallAbios,
                (ULONG)&KiEndOfCode16 - (ULONG)&KiI386CallAbios - 1,
                0x18                   // TYPE_CODE
                );

    //
    // Link all the unused GDT entries to our GDT free list.
    //

    if (Processor == 0) {
        Ki386InitializeGdtFreeList(EndOfGdt);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ke\i386\biosc.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    abiosc.c

Abstract:

    This module implements ROM BIOS support C routines for i386 NT.

--*/
#include "ki.h"
#pragma hdrstop
#include "vdmntos.h"


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,Ke386CallBios)
#endif


//
// Never change these equates without checking biosa.asm
//

#define V86_CODE_ADDRESS    0x10000
#define INT_OPCODE          0xcd
#define V86_BOP_OPCODE      0xfec4c4
#define V86_STACK_POINTER   0x1ffe
#define IOPM_OFFSET         FIELD_OFFSET(KTSS, IoMaps[0].IoMap)
#define VDM_TIB_ADDRESS     0x12000
#define INT_10_TEB          0x13000

//
// External References
//

PVOID Ki386IopmSaveArea;
VOID
Ki386SetupAndExitToV86Code (
   PVOID ExecutionAddress
   );


NTSTATUS
Ke386CallBios (
    IN ULONG BiosCommand,
    IN OUT PCONTEXT BiosArguments
    )

/*++

Routine Description:

    This function invokes specified ROM BIOS code by executing
    "INT BiosCommand."  Before executing the BIOS code, this function
    will setup VDM context, change stack pointer ...etc.  If for some reason
    the operation fails, a status code will be returned.  Otherwise, this
    function always returns success regardless of the result of the BIOS
    call.

    N.B. This implementation relies on the fact that the direct
         I/O access operations between apps are serialized by win user.

Arguments:

    BiosCommand - Supplies which ROM BIOS function to invoke.

    BiosArguments - Supplies a pointer to the context which will be used
                    to invoke ROM BIOS.

Return Value:

    NTSTATUS code to specify the failure.

--*/

{

    PVDM_TIB VdmTib;
    PUCHAR BaseAddress = (PUCHAR)V86_CODE_ADDRESS;
    PTEB UserInt10Teb = (PTEB)INT_10_TEB;
    PKTSS Tss;
    PKPROCESS Process;
    PKTHREAD Thread;
    USHORT OldIopmOffset, OldIoMapBase;
    PVDM_PROCESS_OBJECTS VdmObjects;
    ULONG   ContextLength;
    UCHAR ThreadDebugActiveMask;

    //
    // Map in ROM BIOS area to perform the int 10 code
    //

    try {

        RtlZeroMemory(UserInt10Teb, sizeof(TEB));

        //
        // Write "Int BiosCommand; bop" to reserved user space (0x1000).
        // Later control will transfer to the user space to execute
        // these two instructions.
        //

        *BaseAddress++ = INT_OPCODE;
        *BaseAddress++ = (UCHAR)BiosCommand;
        *(PULONG)BaseAddress = V86_BOP_OPCODE;

        //
        // Set up Vdm(v86) context to execute the int BiosCommand
        // instruction by copying user supplied context to VdmContext
        // and updating the control registers to predefined values.
        //

        //
        // We want to use a constant number for the int10.
        //
        // Create a fake TEB so we can switch the thread to it while we
        // do an int10
        //

        UserInt10Teb->Vdm = (PVOID)VDM_TIB_ADDRESS;
        VdmTib = (PVDM_TIB)VDM_TIB_ADDRESS;
        RtlZeroMemory(VdmTib, sizeof(VDM_TIB));
        VdmTib->Size = sizeof(VDM_TIB);

        *FIXED_NTVDMSTATE_LINEAR_PC_AT = 0;

        //
        // extended registers are never going to matter to
        //  an Int10 call, so only copy the old part of the
        //  context record.
        //
        ContextLength = FIELD_OFFSET(CONTEXT, ExtendedRegisters);

        RtlCopyMemory(&(VdmTib->VdmContext), BiosArguments, ContextLength);
        VdmTib->VdmContext.SegCs = (ULONG)BaseAddress >> 4;
        VdmTib->VdmContext.SegSs = (ULONG)BaseAddress >> 4;
        VdmTib->VdmContext.Eip = 0;
        VdmTib->VdmContext.Esp = 2 * PAGE_SIZE - sizeof(ULONG);
        VdmTib->VdmContext.EFlags |= EFLAGS_V86_MASK | EFLAGS_INTERRUPT_MASK;
        VdmTib->VdmContext.ContextFlags = CONTEXT_FULL;

    } except (EXCEPTION_EXECUTE_HANDLER) {

        return GetExceptionCode();
    }

    //
    // The vdm kernel code finds the Tib by looking at a pointer cached in
    // kernel memory, which was probed at Vdm creation time.  Since the
    // creation semantics for this vdm are peculiar, we do something similar
    // here.
    //

    //
    // We never get here on a process that is a real vdm.  If we do,
    // bad things will happen  (pool leak, failure to execute dos and
    // windows apps).
    //

    ASSERT(PsGetCurrentProcess()->VdmObjects == NULL);

    VdmObjects = ExAllocatePoolWithTag (NonPagedPool,
                                        sizeof(VDM_PROCESS_OBJECTS),
                                        '  eK'
                                        );

    //
    // Since we are doing this on behalf of CSR not a user process, we aren't
    // charging quota.
    //

    if (VdmObjects == NULL) {
        return STATUS_NO_MEMORY;
    }

    //
    // We are only initializing the VdmTib pointer, because that's the only
    // part of the VdmObjects we use for ROM calls.  We aren't set up
    // to simulate interrupts, or any of the other stuff that would be done
    // in a conventional vdm
    //

    RtlZeroMemory( VdmObjects, sizeof(VDM_PROCESS_OBJECTS));

    VdmObjects->VdmTib = VdmTib;

    PsGetCurrentProcess()->VdmObjects = VdmObjects;
    PS_SET_BITS(&PsGetCurrentProcess()->Flags, PS_PROCESS_FLAGS_VDM_ALLOWED);

    //
    // Since we are going to v86 mode and accessing some I/O ports, we
    // need to make sure the IopmOffset is set correctly across context
    // swap and the I/O bit map has all the bits cleared.
    // N.B.  This implementation assumes that there is only one full
    //       screen DOS app and the io access between full screen DOS
    //       app and the server code is serialized by win user.  That
    //       means even we change the IOPM, the full screen dos app won't
    //       be able to run on this IOPM.
    //     * In another words, IF THERE IS
    //     * MORE THAN ONE FULL SCREEN DOS APPS, THIS CODE IS BROKEN.*
    //
    // NOTE This code works on the assumption that winuser serializes
    //      direct I/O access operations.
    //

    //
    // Call the bios from the processor which booted the machine.
    //

    Thread = KeGetCurrentThread();
    KeSetSystemAffinityThread(1);
    Tss = KeGetPcr()->TSS;

    //
    // Save away the original IOPM bit map and clear all the IOPM bits
    // to allow v86 int 10 code to access ALL the io ports.
    //

    //
    // Make sure there are at least 2 IOPM maps.
    //

    ASSERT(KeGetPcr()->GDT[KGDT_TSS / 8].LimitLow >= (0x2000 + IOPM_OFFSET - 1));
    RtlCopyMemory (Ki386IopmSaveArea,
                   (PVOID)&Tss->IoMaps[0].IoMap,
                   PAGE_SIZE * 2
                   );
    RtlZeroMemory ((PVOID)&Tss->IoMaps[0].IoMap, PAGE_SIZE * 2);

    Process = Thread->ApcState.Process;
    OldIopmOffset = Process->IopmOffset;
    OldIoMapBase = Tss->IoMapBase;
    Process->IopmOffset = (USHORT)(IOPM_OFFSET);      // Set Process IoPmOffset before
    Tss->IoMapBase = (USHORT)(IOPM_OFFSET);           // updating Tss IoMapBase

    //
    // The context setup for the BIOS will not have valid debug registers
    // in it, don't try to load them.
    //

    ThreadDebugActiveMask = (UCHAR) Thread->Header.DebugActive;
    Thread->Header.DebugActive = (BOOLEAN) 0;

    //
    // Call ASM routine to switch stack to exit to v86 mode to
    // run Int BiosCommand.
    //

    Ki386SetupAndExitToV86Code(UserInt10Teb);

    //
    // After we return from v86 mode, the control comes here.
    //
    // Restore Thread's DebugActive flag.
    //

    Thread->Header.DebugActive = (BOOLEAN) ThreadDebugActiveMask;

    //
    // Restore old IOPM
    //

    RtlCopyMemory ((PVOID)&Tss->IoMaps[0].IoMap,
                   Ki386IopmSaveArea,
                   PAGE_SIZE * 2
                   );

    Process->IopmOffset = OldIopmOffset;
    Tss->IoMapBase = OldIoMapBase;

    //
    // Restore old affinity for current thread.
    //

    KeRevertToUserAffinityThread();

    //
    // Copy 16 bit vdm context back to caller.
    //
    // Extended register state is not going to matter,
    // so copy only the old part of the context record.
    //

    ContextLength = FIELD_OFFSET(CONTEXT, ExtendedRegisters);
    RtlCopyMemory(BiosArguments, &(VdmTib->VdmContext), ContextLength);
    BiosArguments->ContextFlags = CONTEXT_FULL;

    //
    // Free the pool used for the VdmTib pointer
    //

    PsGetCurrentProcess()->VdmObjects = NULL;
    PS_CLEAR_BITS(&PsGetCurrentProcess()->Flags, PS_PROCESS_FLAGS_VDM_ALLOWED);

    ExFreePool(VdmObjects);

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ke\i386\allproc.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    allproc.c

Abstract:

    This module allocates and initializes kernel resources required
    to start a new processor, and passes a complete process_state
    structure to the hal to obtain a new processor.  This is done
    for every processor.

Environment:

    Kernel mode only.
    Phase 1 of bootup

--*/


#include "ki.h"
#include "pool.h"

extern BOOLEAN KiSMTProcessorsPresent;

#ifdef NT_UP

VOID
KeStartAllProcessors (
    VOID
    )
{
        // UP Build - this function is a nop
}

#else

static VOID
KiCloneDescriptor (
   IN PKDESCRIPTOR  pSrcDescriptorInfo,
   IN PKDESCRIPTOR  pDestDescriptorInfo,
   IN PVOID         Base
   );

static VOID
KiCloneSelector (
   IN ULONG    SrcSelector,
   IN PKGDTENTRY    pNGDT,
   IN PKDESCRIPTOR  pDestDescriptor,
   IN PVOID         Base
   );

PKPRCB
KiInitProcessorState (
   PKPROCESSOR_STATE  pProcessorState,
   PVOID               PerProcessorAllocation,
   ULONG               NewProcessorNumber,
   UCHAR               NodeNumber,
   ULONG               IdtOffset,
   ULONG               GdtOffset,
   PVOID            *ppStack,
   PVOID            *ppDpcStack
   );

BOOLEAN
KiInitProcessor (
   ULONG    NewProcessorNumber,
   PUCHAR  pNodeNumber,
   ULONG    IdtOffset,
   ULONG    GdtOffset,
   SIZE_T   ProcessorDataSize
   );

VOID
KiAdjustSimultaneousMultiThreadingCharacteristics(
    VOID
    );

VOID
KiProcessorStart(
    VOID
    );

BOOLEAN
KiStartWaitAcknowledge(
    VOID
    );

VOID 
KiSetHaltedNmiandDoubleFaultHandler(
    VOID
    );

VOID
KiDummyNmiHandler (
    VOID
    );

VOID
KiDummyDoubleFaultHandler(
    VOID
    );

VOID
KiClearBusyBitInTssDescriptor(
       IN ULONG DescriptorOffset
     );

VOID
KiHaltThisProcessor(
    VOID
    ) ;

#if defined(KE_MULTINODE)

NTSTATUS
KiNotNumaQueryProcessorNode(
    IN ULONG ProcessorNumber,
    OUT PUSHORT Identifier,
    OUT PUCHAR Node
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, KiNotNumaQueryProcessorNode)
#endif

#endif

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,KeStartAllProcessors)
#ifndef NT_UP
#pragma alloc_text(INIT,KiInitProcessorState)
#endif
#pragma alloc_text(INIT,KiCloneDescriptor)
#pragma alloc_text(INIT,KiCloneSelector)
#pragma alloc_text(INIT,KiAllProcessorsStarted)
#pragma alloc_text(INIT,KiAdjustSimultaneousMultiThreadingCharacteristics)
#pragma alloc_text(INIT,KiStartWaitAcknowledge)
#endif

enum {
    KcStartContinue,
    KcStartWait,
    KcStartGetId,
    KcStartDoNotStart,
    KcStartCommandError = 0xff
} KiProcessorStartControl = KcStartContinue;

ULONG KiProcessorStartData[4];

ULONG KiBarrierWait = 0;

#if defined(KE_MULTINODE)

PHALNUMAQUERYPROCESSORNODE KiQueryProcessorNode = KiNotNumaQueryProcessorNode;

//
// Statically preallocate enough KNODE structures to allow MM
// to allocate pages by node during system initialization.  As
// processors are brought online, real KNODE structures are
// allocated in the appropriate memory for the node.
//
// This statically allocated set will be deallocated once the
// system is initialized.
//

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg("INITDATA")
#endif

KNODE KiNodeInit[MAXIMUM_CCNUMA_NODES];

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg()
#endif

#endif

#define ROUNDUP16(x)        (((x)+15) & ~15)

PKPRCB
KiInitProcessorState(
    PKPROCESSOR_STATE  pProcessorState,
    PVOID               PerProcessorAllocation,
    ULONG               NewProcessorNumber,
    UCHAR               NodeNumber,
    ULONG               IdtOffset,
    ULONG               GdtOffset,
    PVOID             *ppStack,
    PVOID             *ppDpcStack
    )
/*++

Routine Description:

    Called to initialize processor state during p0 bootup.

Return value:

    Prcb for new processor

--*/
{
    KDESCRIPTOR         Descriptor;
    KDESCRIPTOR         TSSDesc, DFTSSDesc, NMITSSDesc, PCRDesc;
    PKGDTENTRY          pGDT;
    PUCHAR              pThreadObject;
    PULONG              pTopOfStack;
    PKTSS               pTSS;
    PUCHAR              Base;
    PKPRCB              NewPrcb;

    ULONG               xCr0, xCr3, xEFlags;

    Base = (PUCHAR)PerProcessorAllocation;

    //
    // Give the new processor its own GDT.
    //

    _asm {
        sgdt    Descriptor.Limit
    }

    KiCloneDescriptor (&Descriptor,
                       &pProcessorState->SpecialRegisters.Gdtr,
                       Base + GdtOffset);

    pGDT = (PKGDTENTRY) pProcessorState->SpecialRegisters.Gdtr.Base;


    //
    // Give new processor its own IDT.
    //

    _asm {
        sidt    Descriptor.Limit
    }
    KiCloneDescriptor (&Descriptor,
                       &pProcessorState->SpecialRegisters.Idtr,
                       Base + IdtOffset);


    //
    // Give new processor its own TSS and PCR.
    //

    KiCloneSelector (KGDT_R0_PCR, pGDT, &PCRDesc, Base);
    RtlZeroMemory (Base, ROUNDUP16(sizeof(KPCR)));
    Base += ROUNDUP16(sizeof(KPCR));

    KiCloneSelector (KGDT_TSS, pGDT, &TSSDesc, Base);
    Base += ROUNDUP16(sizeof(KTSS));

    //
    // Idle Thread thread object.
    //

    pThreadObject = Base;
    RtlZeroMemory(Base, sizeof(ETHREAD));
    Base += ROUNDUP16(sizeof(ETHREAD));

    //
    // NMI TSS and double-fault TSS & stack.
    //

    KiCloneSelector (KGDT_DF_TSS, pGDT, &DFTSSDesc, Base);
    Base += ROUNDUP16(FIELD_OFFSET(KTSS, IoMaps));

    KiCloneSelector (KGDT_NMI_TSS, pGDT, &NMITSSDesc, Base);
    Base += ROUNDUP16(FIELD_OFFSET(KTSS, IoMaps));

    Base += DOUBLE_FAULT_STACK_SIZE;

    pTSS = (PKTSS)DFTSSDesc.Base;
    pTSS->Esp0 = (ULONG)Base;
    pTSS->Esp  = (ULONG)Base;

    pTSS = (PKTSS)NMITSSDesc.Base;
    pTSS->Esp0 = (ULONG)Base;
    pTSS->Esp  = (ULONG)Base;

    //
    // Set other SpecialRegisters in processor state.
    //

    _asm {
        mov     eax, cr0
        and     eax, NOT (CR0_AM or CR0_WP)
        mov     xCr0, eax
        mov     eax, cr3
        mov     xCr3, eax

        pushfd
        pop     eax
        mov     xEFlags, eax
        and     xEFlags, NOT EFLAGS_INTERRUPT_MASK
    }

    pProcessorState->SpecialRegisters.Cr0 = xCr0;
    pProcessorState->SpecialRegisters.Cr3 = xCr3;
    pProcessorState->ContextFrame.EFlags = xEFlags;


    pProcessorState->SpecialRegisters.Tr  = KGDT_TSS;
    pGDT[KGDT_TSS>>3].HighWord.Bytes.Flags1 = 0x89;

    //
    // Encode the processor number into the segment limit of the TEB
    // 6 bits in total. 4 in the high and 2 in the low limit.
    //
    pGDT[KGDT_R3_TEB>>3].LimitLow = (USHORT)((NewProcessorNumber&0x3)<<(16-2));
    pGDT[KGDT_R3_TEB>>3].HighWord.Bits.LimitHi = (NewProcessorNumber>>2);

#if defined(_X86PAE_)
    pProcessorState->SpecialRegisters.Cr4 = CR4_PAE;
#endif

    //
    // Allocate a DPC stack, idle thread stack and ThreadObject for
    // the new processor.
    //

    *ppStack = MmCreateKernelStack (FALSE, NodeNumber);
    *ppDpcStack = MmCreateKernelStack (FALSE, NodeNumber);

    //
    // Setup context - push variables onto new stack.
    //

    pTopOfStack = (PULONG) *ppStack;
    pTopOfStack[-1] = (ULONG) KeLoaderBlock;
    pProcessorState->ContextFrame.Esp = (ULONG) (pTopOfStack-2);
    pProcessorState->ContextFrame.Eip = (ULONG) KiSystemStartup;

    pProcessorState->ContextFrame.SegCs = KGDT_R0_CODE;
    pProcessorState->ContextFrame.SegDs = KGDT_R3_DATA;
    pProcessorState->ContextFrame.SegEs = KGDT_R3_DATA;
    pProcessorState->ContextFrame.SegFs = KGDT_R0_PCR;
    pProcessorState->ContextFrame.SegSs = KGDT_R0_DATA;


    //
    // Initialize new processor's PCR & Prcb.
    //

    KiInitializePcr (
        (ULONG)       NewProcessorNumber,
        (PKPCR)       PCRDesc.Base,
        (PKIDTENTRY)  pProcessorState->SpecialRegisters.Idtr.Base,
        (PKGDTENTRY)  pProcessorState->SpecialRegisters.Gdtr.Base,
        (PKTSS)       TSSDesc.Base,
        (PKTHREAD)    pThreadObject,
        (PVOID)       *ppDpcStack
    );

    NewPrcb = ((PKPCR)(PCRDesc.Base))->Prcb;

    //
    // Assume new processor will be the first processor in its
    // SMT set.   (Right choice for non SMT processors, adjusted
    // later if not correct).
    //

    NewPrcb->MultiThreadSetMaster = NewPrcb;

#if defined(KE_MULTINODE)

    //
    // If this is the first processor on this node, use the
    // space allocated for KNODE as the KNODE.
    //

    if (KeNodeBlock[NodeNumber] == &KiNodeInit[NodeNumber]) {
        Node = (PKNODE)Base;
        *Node = KiNodeInit[NodeNumber];
        KeNodeBlock[NodeNumber] = Node;
    }
    Base += ROUNDUP16(sizeof(KNODE));

    NewPrcb->ParentNode = Node;

#else

    NewPrcb->ParentNode = KeNodeBlock[0];

#endif

    ASSERT(((PUCHAR)PerProcessorAllocation + GdtOffset) == Base);

    //
    //  Adjust LoaderBlock so it has the next processors state
    //

    KeLoaderBlock->KernelStack = (ULONG) pTopOfStack;
    KeLoaderBlock->Thread = (ULONG) pThreadObject;
    KeLoaderBlock->Prcb = (ULONG) NewPrcb;


    //
    // Get CPUID(1) info from the starting processor.
    //

    KiProcessorStartData[0] = 1;
    KiProcessorStartControl = KcStartGetId;

    return NewPrcb;
}



VOID
KeStartAllProcessors (
    VOID
    )
/*++

Routine Description:

    Called by p0 during phase 1 of bootup.  This function implements
    the x86 specific code to contact the hal for each system processor.

Arguments:

Return Value:

    All available processors are sent to KiSystemStartup.

--*/
{
    KDESCRIPTOR         Descriptor;
    ULONG               NewProcessorNumber;
    SIZE_T              ProcessorDataSize;
    UCHAR               NodeNumber = 0;
    ULONG               IdtOffset;
    ULONG               GdtOffset;

#if defined(KE_MULTINODE)

    USHORT              ProcessorId;
    PKNODE              Node;
    NTSTATUS            Status;

#endif

    //
    // Do not start additional processors if the RELOCATEPHYSICAL loader
    // switch has been specified.
    // 

    if (KeLoaderBlock->LoadOptions != NULL) {
        if (strstr(KeLoaderBlock->LoadOptions, "RELOCATEPHYSICAL") != NULL) {
            return;
        }
    }

    //
    // If the boot processor has PII spec A27 errata (also present in
    // early Pentium Pro chips), then use only one processor to avoid
    // unpredictable eflags corruption.
    //
    // Note this only affects some (but not all) chips @ 333Mhz and below.
    //

    if (!(KeFeatureBits & KF_WORKING_PTE)) {
        return;
    }

#if defined(KE_MULTINODE)

    //
    // In the unlikely event that processor 0 is not on node
    // 0, fix it.
    //

    if (KeNumberNodes > 1) {
        Status = KiQueryProcessorNode(0,
                                      &ProcessorId,
                                      &NodeNumber);

        if (NT_SUCCESS(Status)) {

            //
            // Adjust the data structures to reflect that P0 is not on Node 0.
            //

            if (NodeNumber != 0) {

                ASSERT(KeNodeBlock[0] == &KiNode0);
                KeNodeBlock[0]->ProcessorMask &= ~1;
                KiNodeInit[0] = *KeNodeBlock[0];
                KeNodeBlock[0] = &KiNodeInit[0];

                KiNode0 = *KeNodeBlock[NodeNumber];
                KeNodeBlock[NodeNumber] = &KiNode0;
                KeNodeBlock[NodeNumber]->ProcessorMask |= 1;
            }
        }
    }

#endif

    //
    // Calculate the size of the per processor data.  This includes
    //   PCR (+PRCB)
    //   TSS
    //   Idle Thread Object
    //   NMI TSS
    //   Double Fault TSS
    //   Double Fault Stack
    //   GDT
    //   IDT
    //
    // If this is a multinode system, the KNODE structure is allocated
    // as well.   It isn't very big so we waste a few bytes for
    // processors that aren't the first in a node.
    //
    // A DPC and Idle stack are also allocated but these are done
    // separately.
    //

    ProcessorDataSize = ROUNDUP16(sizeof(KPCR))                 +
                        ROUNDUP16(sizeof(KTSS))                 +
                        ROUNDUP16(sizeof(ETHREAD))              +
                        ROUNDUP16(FIELD_OFFSET(KTSS, IoMaps))   +
                        ROUNDUP16(FIELD_OFFSET(KTSS, IoMaps))   +
                        ROUNDUP16(DOUBLE_FAULT_STACK_SIZE);

#if defined(KE_MULTINODE)

    ProcessorDataSize += ROUNDUP16(sizeof(KNODE));

#endif

    //
    // Add sizeof GDT
    //

    GdtOffset = ProcessorDataSize;
    _asm {
        sgdt    Descriptor.Limit
    }
    ProcessorDataSize += Descriptor.Limit + 1;

    //
    // Add sizeof IDT
    //

    IdtOffset = ProcessorDataSize;
    _asm {
        sidt    Descriptor.Limit
    }
    ProcessorDataSize += Descriptor.Limit + 1;

    //
    // Set barrier that will prevent any other processor from entering the
    // idle loop until all processors have been started.
    //

    KiBarrierWait = 1;

    //
    // Loop asking the HAL for the next processor.   Stop when the
    // HAL says there aren't any more.
    //

    for (NewProcessorNumber = 1;
         NewProcessorNumber < MAXIMUM_PROCESSORS;
         NewProcessorNumber++) {

        if (! KiInitProcessor(NewProcessorNumber, &NodeNumber, IdtOffset, GdtOffset, ProcessorDataSize) ) {
            break;
        }

        KiProcessorStartControl = KcStartContinue;

#if defined(KE_MULTINODE)

        Node->ProcessorMask |= 1 << NewProcessorNumber;

#endif

        //
        // Wait for processor to initialize in kernel, then loop for another.
        //

        while (*((volatile ULONG *) &KeLoaderBlock->Prcb) != 0) {
            KeYieldProcessor();
        }
    }

    //
    // All processors have been started.
    //

    KiAllProcessorsStarted();

    //
    // Reset and synchronize the performance counters of all processors, by
    // applying a null adjustment to the interrupt time.
    //

    KeAdjustInterruptTime (0);

    //
    // Allow all processors that were started to enter the idle loop and
    // begin execution.
    //

    KiBarrierWait = 0;
}



static VOID
KiCloneSelector (
   IN ULONG    SrcSelector,
   IN PKGDTENTRY    pNGDT,
   IN PKDESCRIPTOR  pDestDescriptor,
   IN PVOID         Base
   )

/*++

Routine Description:

    Makes a copy of the current selector's data, and updates the new
    GDT's linear address to point to the new copy.

Arguments:

    SrcSelector     -   Selector value to clone
    pNGDT           -   New gdt table which is being built
    DescDescriptor  -   descriptor structure to fill in with resulting memory
    Base            -   Base memory for the new descriptor.

Return Value:

    None.

--*/

{
    KDESCRIPTOR Descriptor;
    PKGDTENTRY  pGDT;
    ULONG       CurrentBase;
    ULONG       NewBase;
    ULONG       Limit;

    _asm {
        sgdt    fword ptr [Descriptor.Limit]    ; Get GDT's addr
    }

    pGDT   = (PKGDTENTRY) Descriptor.Base;
    pGDT  += SrcSelector >> 3;
    pNGDT += SrcSelector >> 3;

    CurrentBase = pGDT->BaseLow | (pGDT->HighWord.Bits.BaseMid << 16) |
                 (pGDT->HighWord.Bits.BaseHi << 24);

    Descriptor.Base  = CurrentBase;
    Descriptor.Limit = pGDT->LimitLow;
    if (pGDT->HighWord.Bits.Granularity & GRAN_PAGE) {
        Limit = (Descriptor.Limit << PAGE_SHIFT) - 1;
        Descriptor.Limit = (USHORT) Limit;
        ASSERT (Descriptor.Limit == Limit);
    }

    KiCloneDescriptor (&Descriptor, pDestDescriptor, Base);
    NewBase = pDestDescriptor->Base;

    pNGDT->BaseLow = (USHORT) NewBase & 0xffff;
    pNGDT->HighWord.Bits.BaseMid = (UCHAR) (NewBase >> 16) & 0xff;
    pNGDT->HighWord.Bits.BaseHi  = (UCHAR) (NewBase >> 24) & 0xff;
}



static VOID
KiCloneDescriptor (
   IN PKDESCRIPTOR  pSrcDescriptor,
   IN PKDESCRIPTOR  pDestDescriptor,
   IN PVOID         Base
   )

/*++

Routine Description:

    Makes a copy of the specified descriptor, and supplies a return
    descriptor for the new copy

Arguments:

    pSrcDescriptor  - descriptor to clone
    pDescDescriptor - the cloned descriptor
    Base            - Base memory for the new descriptor.

Return Value:

    None.

--*/
{
    ULONG   Size;

    Size = pSrcDescriptor->Limit + 1;
    pDestDescriptor->Limit = (USHORT) Size -1;
    pDestDescriptor->Base  = (ULONG)  Base;

    RtlCopyMemory(Base, (PVOID)pSrcDescriptor->Base, Size);
}


VOID
KiAdjustSimultaneousMultiThreadingCharacteristics(
    VOID
    )

/*++

Routine Description:

    This routine is called (possibly while the dispatcher lock is held)
    after processors are added to or removed from the system.   It runs
    thru the PRCBs for each processor in the system and adjusts scheduling
    data.

Arguments:

    None.

Return Value:

    None.

--*/

{
    ULONG ProcessorNumber;
    ULONG BuddyNumber;
    KAFFINITY ProcessorSet;
    PKPRCB Prcb;
    PKPRCB BuddyPrcb;
    ULONG ApicMask;
    ULONG ApicId;

    if (!KiSMTProcessorsPresent) {

        //
        // Nobody doing SMT, nothing to do.
        //

        return;
    }

    for (ProcessorNumber = 0;
         ProcessorNumber < (ULONG)KeNumberProcessors;
         ProcessorNumber++) {

        Prcb = KiProcessorBlock[ProcessorNumber];

        //
        // Skip processors which are not present or which do not
        // support Simultaneous Multi Threading.
        //

        if ((Prcb == NULL) ||
            (Prcb->LogicalProcessorsPerPhysicalProcessor == 1)) {
            continue;
        }

        //
        // Find all processors with the same physical processor APIC ID.
        // The APIC ID for the physical processor is the upper portion
        // of the APIC ID, the number of bits in the lower portion is
        // log 2 (number logical processors per physical rounded up to
        // a power of 2).
        //

        ApicId = Prcb->InitialApicId;

        //
        // Round number of logical processors up to a power of 2
        // then subtract one to get the logical processor apic mask.
        //

        ASSERT(Prcb->LogicalProcessorsPerPhysicalProcessor);
        ApicMask = Prcb->LogicalProcessorsPerPhysicalProcessor;

        ApicMask = ApicMask + ApicMask - 1;
        KeFindFirstSetLeftMember(ApicMask, &ApicMask);
        ApicMask = ~((1 << ApicMask) - 1);

        ApicId &= ApicMask;

        ProcessorSet = 1 << Prcb->Number;

        //
        // Examine each remaining processor to see if it is part of
        // the same set.
        //

        for (BuddyNumber = ProcessorNumber + 1;
             BuddyNumber < (ULONG)KeNumberProcessors;
             BuddyNumber++) {

            BuddyPrcb = KiProcessorBlock[BuddyNumber];

            //
            // Skip not present, not SMT.
            //

            if ((BuddyPrcb == NULL) ||
                (BuddyPrcb->LogicalProcessorsPerPhysicalProcessor == 1)) {
                continue;
            }

            //
            // Does this processor have the same ID as the one
            // we're looking for?
            //

            if (((BuddyPrcb->InitialApicId & ApicMask) != ApicId) ||
                (BuddyPrcb->ParentNode != Prcb->ParentNode)) {

                continue;
            }

            //
            // Match.
            //

            ASSERT(Prcb->LogicalProcessorsPerPhysicalProcessor ==
                   BuddyPrcb->LogicalProcessorsPerPhysicalProcessor);

            ProcessorSet |= 1 << BuddyPrcb->Number;
            BuddyPrcb->MultiThreadProcessorSet |= ProcessorSet;
        }

        Prcb->MultiThreadProcessorSet |= ProcessorSet;
    }
}


VOID
KiAllProcessorsStarted(
    VOID
    )

/*++

Routine Description:

    This routine is called once all processors in the system
    have been started.

Arguments:

    None.

Return Value:

    None.

--*/

{

    ULONG i;
    PKPRCB Prcb;
    PKNODE ParentNode;

    //
    // If the system contains Simultaneous Multi Threaded processors,
    // adjust grouping information now that each processor is started.
    //

    KiAdjustSimultaneousMultiThreadingCharacteristics();

#if defined(KE_MULTINODE)

    //
    // Make sure there are no references to the temporary nodes
    // used during initialization.
    //

    for (i = 0; i < KeNumberNodes; i++) {
        if (KeNodeBlock[i] == &KiNodeInit[i]) {

            //
            // No processor started on this node so no new node
            // structure has been allocated.   This is possible
            // if the node contains only memory or IO busses.  At
            // this time we need to allocate a permanent node
            // structure for the node.
            //

            KeNodeBlock[i] = ExAllocatePoolWithTag(NonPagedPool,
                                                   sizeof(KNODE),
                                                   '  eK');
            if (KeNodeBlock[i]) {
                *KeNodeBlock[i] = KiNodeInit[i];
            }
        }

        //
        // Set the node number.
        //

        KeNodeBlock[i]->NodeNumber = (UCHAR)i;
    }

    for (i = KeNumberNodes; i < MAXIMUM_CCNUMA_NODES; i++) {
        KeNodeBlock[i] = NULL;
    }

#endif

    //
    // Copy the node color and shifted color to the PRCB of each processor.
    //

    for (i = 0; i < (ULONG)KeNumberProcessors; i += 1) {
        Prcb = KiProcessorBlock[i];
        ParentNode = Prcb->ParentNode;
        Prcb->NodeColor = ParentNode->Color;
        Prcb->NodeShiftedColor = ParentNode->MmShiftedColor;
        Prcb->SecondaryColorMask = MmSecondaryColorMask;
    }

    if (KeNumberNodes == 1) {

        //
        // For Non NUMA machines, Node 0 gets all processors.
        //

        KeNodeBlock[0]->ProcessorMask = KeActiveProcessors;
    }
}

#if defined(KE_MULTINODE)

NTSTATUS
KiNotNumaQueryProcessorNode(
    IN ULONG ProcessorNumber,
    OUT PUSHORT Identifier,
    OUT PUCHAR Node
    )

/*++

Routine Description:

    This routine is a stub used on non NUMA systems to provide a
    consistent method of determining the NUMA configuration rather
    than checking for the presence of multiple nodes inline.

Arguments:

    ProcessorNumber supplies the system logical processor number.
    Identifier      supplies the address of a variable to receive
                    the unique identifier for this processor.
    NodeNumber      supplies the address of a variable to receive
                    the number of the node this processor resides on.

Return Value:

    Returns success.

--*/

{
    *Identifier = (USHORT)ProcessorNumber;
    *Node = 0;
    return STATUS_SUCCESS;
}

#endif

VOID
KiProcessorStart(
    VOID
    )

/*++

Routine Description:

    
    This routine is a called when a processor begins execution.
    It is used to pass processor characteristic information to 
    the boot processor and to control the starting or non-starting
    of this processor.

Arguments:

    None.

Return Value:

    None.

--*/

{
    while (TRUE) {
        switch (KiProcessorStartControl) {

        case KcStartContinue:
            return;

        case KcStartWait:
            KeYieldProcessor();
            break;

        case KcStartGetId:
            CPUID(KiProcessorStartData[0],
                  &KiProcessorStartData[0],
                  &KiProcessorStartData[1],
                  &KiProcessorStartData[2],
                  &KiProcessorStartData[3]);
            KiProcessorStartControl = KcStartWait;
            break;

        case KcStartDoNotStart:

            //
            // The boot processor has determined that this processor
            // should NOT be started.
            //
            // Acknowledge the command so the boot processor will
            // continue, disable interrupts (should already be 
            // the case here) and HALT the processor.
            //

            KiProcessorStartControl = KcStartWait;
            KiSetHaltedNmiandDoubleFaultHandler();
            _disable();
            while(1) {
                _asm { hlt };
            }

        default:

            //
            // Not much we can do with unknown commands.
            //

            KiProcessorStartControl = KcStartCommandError;
            break;
        }
    }
}

BOOLEAN
KiStartWaitAcknowledge(
    VOID
    )
{
    while (KiProcessorStartControl != KcStartWait) {
        if (KiProcessorStartControl == KcStartCommandError) {
            return FALSE;
        }
        KeYieldProcessor();
    }
    return TRUE;
}

VOID 
KiSetHaltedNmiandDoubleFaultHandler(
    VOID
    )

/*++

Routine Description:

    
    This routine is a called before the application processor that is not
    going to be started is put into halt. It is used to hook a dummy Nmi and 
    double fault handler.


Arguments:

    None.

Return Value:

    None.
--*/
{
    PKPCR Pcr;
    PKGDTENTRY GdtPtr;
    ULONG TssAddr;
   
    Pcr = KeGetPcr();
       
    GdtPtr  = (PKGDTENTRY)&(Pcr->GDT[Pcr->IDT[IDT_NMI_VECTOR].Selector >> 3]);
    TssAddr = (((GdtPtr->HighWord.Bits.BaseHi << 8) +
                 GdtPtr->HighWord.Bits.BaseMid) << 16) + GdtPtr->BaseLow;
    ((PKTSS)TssAddr)->Eip = (ULONG)KiDummyNmiHandler;


    GdtPtr  = (PKGDTENTRY)&(Pcr->GDT[Pcr->IDT[IDT_DFH_VECTOR].Selector >> 3]);
    TssAddr = (((GdtPtr->HighWord.Bits.BaseHi << 8) +
                   GdtPtr->HighWord.Bits.BaseMid) << 16) + GdtPtr->BaseLow;
    ((PKTSS)TssAddr)->Eip = (ULONG)KiDummyDoubleFaultHandler;

    return;

}


VOID
KiDummyNmiHandler (
    VOID
    )

/*++

Routine Description:

    This is the dummy handler that is executed by the processor
    that is not started. We are just being paranoid about clearing
    the busy bit for the NMI and Double Fault Handler TSS.


Arguments:

    None.

Return Value:

    Does not return
--*/
{
    KiClearBusyBitInTssDescriptor(NMI_TSS_DESC_OFFSET);
    KiHaltThisProcessor();


}



VOID
KiDummyDoubleFaultHandler(
    VOID
    )

/*++

Routine Description:

    This is the dummy handler that is executed by the processor
    that is not started. We are just being paranoid about clearing
    the busy bit for the NMI and Double Fault Handler TSS.


Arguments:

    None.

Return Value:

    Does not return
--*/
{
    KiClearBusyBitInTssDescriptor(DF_TSS_DESC_OFFSET);
    KiHaltThisProcessor();
}



VOID
KiClearBusyBitInTssDescriptor(
       IN ULONG DescriptorOffset
       )  
/*++

Routine Description:

    Called to clear busy bit in descriptor from the NMI and double
    Fault Handlers
    

Arguments:

    None.

Return Value:

    None.
--*/
{
    PKPCR Pcr;
    PKGDTENTRY GdtPtr;
    Pcr = KeGetPcr();
    GdtPtr =(PKGDTENTRY)(Pcr->GDT);
    GdtPtr =(PKGDTENTRY)((ULONG)GdtPtr + DescriptorOffset);
    GdtPtr->HighWord.Bytes.Flags1 = 0x89; // 32bit. dpl=0. present, TSS32, not busy

}


VOID
KiHaltThisProcessor(
    VOID
) 

/*++

Routine Description:

  After Clearing the busy bit (just being paranoid here) we halt
  this processor. 

Arguments:

    None.

Return Value:

    None.
--*/
{

    while(1) {
        _asm {
               hlt 
        }
    }
}
#endif      // !NT_UP
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ke\i386\callback.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    callback.c

Abstract:

    This module implements user mode call back services.

--*/

#include "ki.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text (PAGE, KeUserModeCallback)
#endif


NTSTATUS
KeUserModeCallback (
    IN ULONG ApiNumber,
    IN PVOID InputBuffer,
    IN ULONG InputLength,
    OUT PVOID *OutputBuffer,
    IN PULONG OutputLength
    )

/*++

Routine Description:

    This function call out from kernel mode to a user mode function.

Arguments:

    ApiNumber - Supplies the API number.

    InputBuffer - Supplies a pointer to a structure that is copied
        to the user stack.

    InputLength - Supplies the length of the input structure.

    Outputbuffer - Supplies a pointer to a variable that receives
        the address of the output buffer.

    Outputlength - Supplies a pointer to a variable that receives
        the length of the output buffer.

Return Value:

    If the callout cannot be executed, then an error status is
    returned. Otherwise, the status returned by the callback function
    is returned.

--*/

{

    ULONG Length;
    ULONG NewStack;
    ULONG OldStack;
    NTSTATUS Status;
    PULONG UserStack;
    ULONG GdiBatchCount;
    PEXCEPTION_REGISTRATION_RECORD ExceptionList;
    PTEB Teb;

    ASSERT(KeGetPreviousMode() == UserMode);
    ASSERT(KeGetCurrentThread()->ApcState.KernelApcInProgress == FALSE);
    
    //
    // Get the user mode stack pointer and attempt to copy input buffer
    // to the user stack.
    //

    UserStack = KiGetUserModeStackAddress ();
    OldStack = *UserStack;
    
    try {

        //
        // Compute new user mode stack address, probe for writability,
        // and copy the input buffer to the user stack. Leave space for an
        // (doubleword-aligned) exception handler at the top of the callback 
        // stack frame.
        //

        C_ASSERT (__alignof (ULONG) == __alignof (EXCEPTION_REGISTRATION_RECORD));
     
        NewStack = (OldStack - InputLength) & ~(__alignof(EXCEPTION_REGISTRATION_RECORD) - 1);
        Length = 4*sizeof(ULONG) + sizeof(EXCEPTION_REGISTRATION_RECORD);
        ProbeForWrite ((PCHAR)(NewStack - Length), Length + InputLength, sizeof(CHAR));
        RtlCopyMemory ((PVOID)NewStack, InputBuffer, InputLength);
 
        //
        // Push arguments onto user stack. Note space remains for the exception
        // registration record following the callback function arguments.
        //

        NewStack -= Length;
        *((PULONG)NewStack) = 0;
        *(((PULONG)NewStack) + 1) = ApiNumber;
        *(((PULONG)NewStack) + 2) = (ULONG)(NewStack+Length);
        *(((PULONG)NewStack) + 3) = (ULONG)InputLength;

        //
        // Save the exception list in case another handler is defined during
        // the callout.
        //

        Teb = (PTEB) KeGetCurrentThread()->Teb;
        ExceptionList = Teb->NtTib.ExceptionList;

        //
        // Call user mode.
        //

        *UserStack = NewStack;
        Status = KiCallUserMode(OutputBuffer, OutputLength);

        //
        // Restore the exception list, unless a user mode unwind is in progress.
        //

        if (Status != STATUS_CALLBACK_POP_STACK) {
            Teb->NtTib.ExceptionList = ExceptionList;
        } else {

            //
            // In this case, make the restore of the user stack pointer effectively
            // a NOP.
            //

            OldStack = *UserStack;
        }

        //
        // If an exception occurs during the probe of the user stack, then
        // always handle the exception and return the exception code as the
        // status value.
        //

    } except (EXCEPTION_EXECUTE_HANDLER) {
        return GetExceptionCode ();
    }

    //
    // When returning from user mode, any drawing done to the GDI TEB
    // batch must be flushed.  If the TEB cannot be accessed then blindly
    // flush the GDI batch anyway.
    //

    GdiBatchCount = 1;

    try {
        GdiBatchCount = Teb->GdiBatchCount;
    } except (EXCEPTION_EXECUTE_HANDLER) {
        NOTHING;
    }

    if (GdiBatchCount > 0) {

        //
        // call GDI batch flush routine
        //

        *UserStack -= 256;
        KeGdiFlushUserBatch ();
    }

    *UserStack = OldStack;
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ke\i386\apcuser.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    apcuser.c

Abstract:

    This module implements the machine dependent code necessary to initialize
    a user mode APC.

Environment:

    IRQL APC_LEVEL.

--*/

#include "ki.h"



VOID
KiInitializeUserApc (
    IN PKEXCEPTION_FRAME ExceptionFrame,
    IN PKTRAP_FRAME TrapFrame,
    IN PKNORMAL_ROUTINE NormalRoutine,
    IN PVOID NormalContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )

/*++

Routine Description:

    This function is called to initialize the context for a user mode APC.

Arguments:

    ExceptionFrame - Supplies a pointer to an exception frame.

    TrapFrame - Supplies a pointer to a trap frame.

    NormalRoutine - Supplies a pointer to the user mode APC routine.

    NormalContext - Supplies a pointer to the user context for the APC
        routine.

    SystemArgument1 - Supplies the first system supplied value.

    SystemArgument2 - Supplies the second system supplied value.

Return Value:

    None.

--*/

{

    EXCEPTION_RECORD ExceptionRecord;
    CONTEXT ContextFrame;
    LONG Length;
    ULONG UserStack, TopOfStack;
    PKAPC_RECORD ApcRecord;

    //
    // APCs are not defined for V86 mode; however, it is possible a
    // thread is trying to set it's context to V86 mode - this isn't
    // going to work, but we don't want to crash the system so we
    // check for the possibility before hand.
    //

    if (TrapFrame->EFlags & EFLAGS_V86_MASK) {
        return ;
    }

    //
    // Move machine state from trap and exception frames to the context frame.
    //

    ContextFrame.ContextFlags = CONTEXT_FULL | CONTEXT_DEBUG_REGISTERS;
    KeContextFromKframes(TrapFrame, ExceptionFrame, &ContextFrame);

    //
    // Transfer the context information to the user stack, initialize the
    // APC routine parameters, and modify the trap frame so execution will
    // continue in user mode at the user mode APC dispatch routine.
    //


    try {        
        C_ASSERT (CONTEXT_ALIGN >= __alignof(EXCEPTION_REGISTRATION_RECORD));
        C_ASSERT (CONTEXT_ALIGN >= __alignof(KAPC_RECORD));

        ASSERT ((TrapFrame->SegCs & MODE_MASK) != KernelMode); // Assert usermode frame

        //
        // Compute length of context record and new aligned user stack pointer.
        // Make sure to include space for a double-word aligned exception registration
        // record as well. For compatibility the exception registration must follow the 
        // context record.
        //

        TopOfStack = (ContextFrame.Esp & ~(__alignof(EXCEPTION_REGISTRATION_RECORD)-1));
        Length = CONTEXT_ALIGNED_SIZE + sizeof(KAPC_RECORD);
        UserStack = ((TopOfStack - sizeof (EXCEPTION_REGISTRATION_RECORD)) & ~CONTEXT_ROUND) - 
            Length;

        //
        // Probe user stack area for writability and then transfer the context 
        // record to the user stack. Note the minimum alignment is used as
        // the above code ensures the proper alignment of the addresses.
        //

        ProbeForWrite ((PCHAR)UserStack, TopOfStack-UserStack, 1);
        NT_ASSERT (((ULONG_PTR)(UserStack + sizeof(KAPC_RECORD)) & CONTEXT_ROUND) == 0);
        RtlCopyMemory ((PULONG)(UserStack + sizeof(KAPC_RECORD)),
                     &ContextFrame, sizeof(CONTEXT));

        //
        // Force correct R3 selectors into TrapFrame.
        //

        TrapFrame->SegCs = SANITIZE_SEG(KGDT_R3_CODE, UserMode);
        TrapFrame->HardwareSegSs = SANITIZE_SEG(KGDT_R3_DATA, UserMode);
        TrapFrame->SegDs = SANITIZE_SEG(KGDT_R3_DATA, UserMode);
        TrapFrame->SegEs = SANITIZE_SEG(KGDT_R3_DATA, UserMode);
        TrapFrame->SegFs = SANITIZE_SEG(KGDT_R3_TEB, UserMode);
        TrapFrame->SegGs = 0;
        TrapFrame->EFlags = SANITIZE_FLAGS( ContextFrame.EFlags, UserMode );

        //
        // If thread is supposed to have IOPL, then force it on in eflags
        //

        if (KeGetCurrentThread()->Iopl) {
            TrapFrame->EFlags |= (EFLAGS_IOPL_MASK & -1);  // IOPL = 3
        }

        //
        // Set the address of the user APC routine, the APC parameters, the
        // new frame pointer, and the new stack pointer in the current trap
        // frame. Set the continuation address so control will be transferred
        // to the user APC dispatcher.
        //

        TrapFrame->HardwareEsp = UserStack;
        TrapFrame->Eip = (ULONG)KeUserApcDispatcher;
        TrapFrame->ErrCode = 0;

        ApcRecord = (PKAPC_RECORD)UserStack;
        ApcRecord->NormalRoutine = NormalRoutine;
        ApcRecord->NormalContext = NormalContext;
        ApcRecord->SystemArgument1 = SystemArgument1;
        ApcRecord->SystemArgument2 = SystemArgument2;
    } except (KiCopyInformation(&ExceptionRecord,
                                (GetExceptionInformation())->ExceptionRecord)) {

        //
        // Lower the IRQL to PASSIVE_LEVEL, set the exception address to
        // the current program address, and raise an exception by calling
        // the exception dispatcher.
        //
        // N.B. The IRQL is lowered to PASSIVE_LEVEL to allow APC interrupts
        //      during the dispatching of the exception. The current thread
        //      will be terminated during the dispatching of the exception,
        //      but lowering of the IRQL is required to enable the debugger
        //      to obtain the context of the current thread.
        //

        KeLowerIrql(PASSIVE_LEVEL);
        ExceptionRecord.ExceptionAddress = (PVOID)(TrapFrame->Eip);
        KiDispatchException(&ExceptionRecord,
                            ExceptionFrame,
                            TrapFrame,
                            UserMode,
                            TRUE);

    }
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ke\i386\callout.asm ===
title  "Call Out to User Mode"
;++
;
; Copyright (c) Microsoft Corporation. All rights reserved. 
;
; You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
; If you do not agree to the terms, do not use the code.
;
;
; Module Name:
;
;    callout.asm
;
; Abstract:
;
;    This module implements the code necessary to call out from kernel
;    mode to user mode.
;
;--

.386p
        .xlist
include ks386.inc
include i386\kimacro.inc
include callconv.inc
include irqli386.inc
        .list

        extrn   _KiServiceExit:PROC
        extrn   _KeUserCallbackDispatcher:DWORD

        EXTRNP  _KeBugCheck2,6
        EXTRNP  _MmGrowKernelStack,1

_TEXT   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:FLAT, FS:NOTHING, GS:NOTHING

        page ,132
        subttl  "Call User Mode Function"
;++
;
; NTSTATUS
; KiCallUserMode (
;    IN PVOID *Outputbuffer,
;    IN PULONG OutputLength
;    )
;
; Routine Description:
;
;    This function calls a user mode function from kernel mode.
;
;    N.B. This function calls out to user mode and the NtCallbackReturn
;        function returns back to the caller of this function. Therefore,
;        the stack layout must be consistent between the two routines.
;
; Arguments:
;
;    OutputBuffer - Supplies a pointer to the variable that receives
;        the address of the output buffer.
;
;    OutputLength - Supplies a pointer to a variable that receives
;        the length of the output buffer.
;
; Return Value:
;
;    The final status of the call out function is returned as the status
;    of the function.
;
;    N.B. This function does not return to its caller. A return to the
;        caller is executed when a NtCallbackReturn system service is
;        executed.
;
;    N.B. This function does return to its caller if a kernel stack
;         expansion is required and the attempted expansion fails.
;
;--

;
; To support the debugger, the callback stack frame is now defined in i386.h.
; If the stack frame is changed, i386.h must be updated and geni386
; rebuilt and run, then rebuild this file and ntos\kd.
;
; The FPO record below must also be updated to correctly represent
; the stack frame.
;

cPublicProc _KiCallUserMode, 2

.FPO (3, 2, 4, 4, 0, 0)

;
; Save nonvolatile registers.
;

        push    ebp                     ; save nonvolatile registers
        push    ebx                     ;
        push    esi                     ;
        push    edi                     ;

        mov     ebx,PCR[PcPrcbData + PbCurrentThread] ; get current thread address

;
; Check if the current IRQL is above passive level.
;

if DBG

        CurrentIrql                     ; get current IRQL
        or      al,al                   ; check if IRQL is passive level
        jz      short Kcb00             ; if z, IRQL at passive level
        stdCall _KeBugCheck2,<IRQL_GT_ZERO_AT_SYSTEM_SERVICE,0,eax,0,0,0>

;
; Check if kernel APCs are disabled or a process is attached.
;

Kcb00:  movzx   eax,byte ptr[ebx]+ThApcStateIndex ; get APC state index
        mov     edx,[ebx]+ThCombinedApcDisable ; get kernel APC disable
        or      eax,eax                ; check if process attached
        jne     short Kcb05            ; if ne, process is attached
        or      edx,edx                ; check if kernel APCs disabled
        jz      short Kcb07            ; if z, kernel APCs enabled
Kcb05:  stdCall _KeBugCheck2,<APC_INDEX_MISMATCH,0,eax,edx,0,0>

endif

;
; Check if sufficient room is available on the kernel stack for another
; system call.
;

Kcb07:  lea     eax,[esp]-KERNEL_LARGE_STACK_COMMIT ; compute bottom address
        cmp     eax,[ebx]+ThStackLimit  ; check if limit exceeded
        jae     short Kcb10             ; if ae, limit not exceeded
        stdCall _MmGrowKernelStack,<esp> ; attempt to grow kernel stack
        or      eax, eax                ; check for successful completion
        jne     Kcb20                   ; if ne, attempt to grow failed

;
; Get the address of the current thread and save the previous trap frame
; and callback stack addresses in the current frame. Also save the new
; callback stack address in the thread object.
;

Kcb10:  push    [ebx].ThCallbackStack   ; save callback stack address
        mov     edx,[ebx].ThTrapFrame   ; get current trap frame address
        push    edx                     ; save trap frame address
        mov     esi,[ebx].ThInitialStack ; get initial stack address
        push    esi                     ; save initial stack address
        mov     [ebx].ThCallbackStack,esp ; save callback stack address

KcbPrologEnd: ; help for the debugger

;
; Copy the numeric save area from the previous save area to the new save
; area and establish a new initial kernel stack.
;
; Make sure that the destination NPX Save area is 16-byte aligned
; as required by fxsave\fxrstor
;

        and     esp, 0fffffff0h         ;
        mov     edi,esp                 ; set new initial stack address
        sub     esp,NPX_FRAME_LENGTH    ; compute destination NPX save area
        sub     esi,NPX_FRAME_LENGTH    ; compute source NPX save area
        cli                             ; disable interrupts
        mov     ecx,[esi].FpControlWord ; copy NPX state to new frame
        mov     [esp].FpControlWord,ecx ;
        mov     ecx,[esi].FpStatusWord  ;
        mov     [esp].FpStatusWord,ecx  ;
        mov     ecx,[esi].FpTagWord     ;
        mov     [esp].FpTagWord,ecx     ;
        mov     ecx,[esi].FxMXCsr       ;
        mov     [esp].FxMXCsr,ecx       ;
        mov     ecx,[esi].FpCr0NpxState ;
        mov     [esp].FpCr0NpxState,ecx ;
        mov     esi,PCR[PcTss]          ; get address of task switch segment
        mov     [ebx].ThInitialStack,edi ; reset initial stack address
        mov     ecx, esp                ;
        sub     esp,TsV86Gs - TsHardwareSegSs ; bias for missing V86 fields

.errnz (EFLAGS_V86_MASK AND 0FF00FFFFh)

        test    byte ptr [edx]+TsEFlags+2,EFLAGS_V86_MASK/010000h  ; is this a V86 frame?
        jne     @f
        mov     ecx, esp                ; Use adjusted esp (normal case)
@@:     mov     [esi].TssEsp0,ecx       ; set kernel entry stack address

;
; Construct a trap frame to facilitate the transfer into user mode via
; the standard system call exit.
;

        sub     esp,TsHardwareSegSs + 4 ; allocate trap frame
        mov     ebp,esp                 ; set address of trap frame
        mov     ecx,(TsHardwareSegSs - TsSegFs + 4) / 4; set repeat count
        lea     edi,[esp].TsSegFs       ; set destination address
        lea     esi,[edx].TsSegFs       ; set source address
        rep     movsd                   ; copy trap information

        mov     edi, [edx].TsDr7                ; Fetch control register
        test    edi, (NOT DR7_RESERVED_MASK)    ; Do we need to restore Debug reg?
        mov     [esp].TsDr7, edi                ; Save away Dr7
        jnz     short Kcb18                     ; Yes, go save them.

Kcb15:  mov     eax,_KeUserCallbackDispatcher ; st address of callback dispatcher
        mov     [esp].TsEip,eax         ;
        mov     eax,PCR[PcExceptionList] ; get current exception list
        mov     [esp].TsExceptionList,eax ; set previous exception list
        mov     eax,[edx].TsPreviousPreviousMode ; get previous mode
        mov     [esp].TsPreviousPreviousMode,eax ; set previous mode
        sti                             ; enable interrupts

        SET_DEBUG_DATA                  ; set system call debug data for exit

        jmp     _KiServiceExit          ; exit through service dispatch

Kcb18:
        mov     ecx,(TsDr6 - TsDr0 + 4) / 4; set repeat count
        lea     edi,[esp].TsDr0         ; set destination address
        lea     esi,[edx].TsDr0         ; set source address
        rep     movsd                   ; copy trap information
        jmp     short Kcb15

;
; An attempt to grow the kernel stack failed.
;

Kcb20:  pop     edi                     ; restore nonvolitile register
        pop     esi                     ;
        pop     ebx                     ;
        pop     ebp                     ;
        stdRET  _KiCallUserMode

stdENDP _KiCallUserMode

        page ,132
        subttl  "Switch Kernel Stack"
;++
;
; PVOID
; KeSwitchKernelStack (
;    IN PVOID StackBase,
;    IN PVOID StackLimit
;    )
;
; Routine Description:
;
;    This function switches to the specified large kernel stack.
;
;    N.B. This function can ONLY be called when there are no variables
;        in the stack that refer to other variables in the stack, i.e.,
;        there are no pointers into the stack.
;
; Arguments:
;
;    StackBase (esp + 4) - Supplies a pointer to the base of the new kernel
;        stack.
;
;    StackLimit (esp + 8) - Supplies a pointer to the limit of the new kernel
;        stack.
;
; Return Value:
;
;    The old kernel stack is returned as the function value.
;
;--

SsStkBs equ     4                       ; new kernel stack base address
SsStkLm equ     8                       ; new kernel stack limit address

cPublicProc _KeSwitchKernelStack, 2

;
; Save the address of the new stack and copy the old stack to the new
; stack.
;

        push    esi                     ; save string move registers
        push    edi                     ;
        mov     edx,PCR[PcPrcbData + PbCurrentThread] ; get current thread address
        mov     edi,[esp]+SsStkBs + 8   ; get new kernel stack base address
        mov     ecx,[edx].ThStackBase   ; get current stack base address
        sub     ebp,ecx                 ; relocate the callers frame pointer
        add     ebp,edi                 ;
        mov     eax,[edx].ThTrapFrame   ; relocate the current trap frame address
        sub     eax,ecx                 ;
        add     eax,edi                 ;
        mov     [edx].ThTrapFrame,eax   ;
        sub     ecx,esp                 ; compute length of copy
        sub     edi,ecx                 ; set destination address of copy
        mov     esi,esp                 ; set source address of copy
        push    edi                     ; save new stack pointer address
        rep     movsb                   ; copy old stack to new stack
        pop     edi                     ; restore new stack pointer address

;
; Switch to the new kernel stack and return the address of the old kernel
; stack.
;

        mov     eax,[edx].ThStackBase   ; get old kernel stack base address
        mov     ecx,[esp]+SsStkBs + 8   ; get new kernel stack base address
        mov     esi,[esp]+SsStkLm + 8   ; get new kernel stack limit address
        cli                             ; disable interrupts
        mov     [edx].ThStackBase,ecx   ; set new kernel stack base address
        mov     [edx].ThStackLimit,esi  ; set new kernel stack limit address
        mov     byte ptr [edx].ThLargeStack, 1 ; set large stack TRUE
        mov     [edx].ThInitialStack,ecx ; set new initial stack address
        mov     esi,[edx].ThTrapFrame   ; Get current trap frame address
        mov     edx,PCR[PcTss]          ; get address of task switch segment
.errnz (EFLAGS_V86_MASK AND 0FF00FFFFh)
        test    byte ptr [esi]+TsEFlags+2,EFLAGS_V86_MASK/010000h  ; is this a V86 frame?
        lea     ecx, dword ptr [ecx-NPX_FRAME_lENGTH]    ; compute NPX save area address
        jne     @f
        sub     ecx,TsV86Gs - TsHardwareSegSs ; bias for missing V86 fields
@@:     mov     [edx].TssEsp0,ecx       ; set kernel entry stack address
        mov     esp,edi                 ; set new stack pointer address
        sti                             ;
        pop     edi                     ; restore string move registers
        pop     esi                     ;
        stdRET  _KeSwitchKernelStack

stdENDP _KeSwitchKernelStack

        page ,132
        subttl  "Get User Mode Stack Address"
;++
;
; PULONG
; KiGetUserModeStackAddress (
;    VOID
;    )
;
; Routine Description:
;
;    This function returns the address of the user stack address in the
;    current trap frame.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    The address of the user stack address.
;
;--

cPublicProc _KiGetUserModeStackAddress, 0

        mov     eax,PCR[PcPrcbData + PbCurrentThread] ; get current thread address
        mov     eax,[eax].ThTrapFrame   ; get current trap frame address
        lea     eax,[eax].TsHardwareEsp ; get address of stack address
        stdRET  _KiGetUserModeStackAddress

stdENDP _KiGetUserModeStackAddress

        page ,132
        subttl  "Return from User Mode Callback"
;++
;
; NTSTATUS
; NtCallbackReturn (
;    IN PVOID OutputBuffer OPTIONAL,
;    IN ULONG OutputLength,
;    IN NTSTATUS Status
;    )
;
; Routine Description:
;
;    This function returns from a user mode callout to the kernel
;    mode caller of the user mode callback function.
;
;    N.B. This function returns to the function that called out to user
;        mode and the KiCallUserMode function calls out to user mode.
;        Therefore, the stack layout must be consistent between the
;        two routines.
;
; Arguments:
;
;    OutputBuffer - Supplies an optional pointer to an output buffer.
;
;    OutputLength - Supplies the length of the output buffer.
;
;    Status - Supplies the status value returned to the caller of the
;        callback function.
;
; Return Value:
;
;    If the callback return cannot be executed, then an error status is
;    returned. Otherwise, the specified callback status is returned to
;    the caller of the callback function.
;
;    N.B. This function returns to the function that called out to user
;         mode is a callout is currently active.
;
;--

cPublicProc _NtCallbackReturn, 3

        mov     eax,PCR[PcPrcbData + PbCurrentThread] ; get current thread address
        mov     ecx,[eax].ThCallbackStack ; get callback stack address
        test    ecx, ecx
        je      CbExit                    ; if zero, no callback stack present

;
; Restore the current exception list from the saved exception list in the
; current trap frame, restore the trap frame and callback stack addresses,
; store the output buffer address and length, and set the service status.
;

        mov     ebx, [eax].ThTrapFrame   ; get current trap frame address
        mov     edx, [ebx].TsExceptionList ; get saved exception list address
        mov     PCR[PcExceptionList], edx ; restore exception list address
        mov     edi, [esp] + 4           ; get output buffer address
        mov     esi, [esp] + 8           ; get output buffer length
        mov     ebp, [esp] + 12          ; get callout service status
        mov     ebx, [ecx].CuOutBf       ; get address to store output buffer
        mov     [ebx], edi               ; store output buffer address
        mov     ebx, [ecx].CuOutLn       ; get address to store output length
        mov     [ebx], esi               ; store output buffer length
        mov     ebx, [ecx]               ; get previous initial stack address
        cli                             ; disable interrupt
        mov     esi, [eax].ThInitialStack ; get source NPX save area address
        mov     [eax].ThInitialStack, ebx ; restore initial stack address
        sub     esi, NPX_FRAME_LENGTH    ; compute source NPX save area
        sub     ebx, NPX_FRAME_LENGTH    ; compute destination NPX save area
        mov     edx,[esi].FpControlWord ; copy NPX state to previous frame
        mov     [ebx].FpControlWord, edx ;
        mov     edx, [esi].FpStatusWord  ;
        mov     [ebx].FpStatusWord, edx  ;
        mov     edx, [esi].FpTagWord     ;
        mov     [ebx].FpTagWord, edx     ;
        mov     edx, [esi].FxMXCsr       ;
        mov     [ebx].FxMXCsr, edx       ;
        mov     edx, [esi].FpCr0NpxState ;
        mov     [ebx].FpCr0NpxState, edx ;
        cmp     ebp, STATUS_CALLBACK_POP_STACK
        mov     edi, [ecx].CuTrFr        ; Fetch address of previous trap frame
        jz      short _NtCbCopyTrapFrame
_NtCbCopyTrapFrameRet:
        and     dword ptr [edi].TsDr7, 0 ; Assume original trap frame has no debug registers active
        test    byte ptr [eax].ThDebugActive, 0ffh 
        jne     short _NtCbGetDebugRegs
_NtCbGetDebugRet:        
        mov     edx, PCR[PcTss]          ; Get address of task switch segment
        lea     esp, [ecx].CuCbStk      ; Trim stack back to callback frame
.errnz (EFLAGS_V86_MASK AND 0FF00FFFFh)
        test    byte ptr [edi]+TsEFlags+2, EFLAGS_V86_MASK/010000h  ; is this a V86 frame?
        jne     @f
        sub     ebx, TsV86Gs - TsHardwareSegSs ; bias for missing V86 fields
@@:
        mov     [edx].TssEsp0, ebx       ; restore kernel entry stack address
        mov     [eax].ThTrapFrame, edi  ; restore current trap frame address
        sti                             ; enable interrupts
        pop     [eax].ThCallbackStack   ; restore callback stack address
        mov     eax, ebp                 ; set callback service status
        
;
; Restore nonvolatile registers, clean call parameters from stack, and
; return to callback caller.
;

        pop     edi                     ; restore nonvolatile registers
        pop     esi                     ;
        pop     ebx                     ;
        pop     ebp                     ;
        pop     edx                     ; save return address
        add     esp, 8                   ; remove parameters from stack
        jmp     edx                     ; return to callback caller

;
; edi - previous trap frame [in/out]
; ecx - callback stack [in/out]
; eax - current thread [in/out]
; esi/edx: available
;

_NtCbCopyTrapFrame:
        mov     ecx, (TsV86Es-TsSegFs)/4 
        mov     esi, [eax].ThTrapFrame   ; trap frame for this system call
.errnz (EFLAGS_V86_MASK AND 0FF00FFFFh)
        test    byte ptr [esi]+TsEFlags+2, EFLAGS_V86_MASK/010000h
        mov     edx, edi
        lea     edi, [edi].TsSegFs
        jz      short @f
        add     ecx, (KTRAP_FRAME_LENGTH-TsV86Es)/4
@@:     lea     esi, [esi].TsSegFs
        rep     movsd                    ; copy the relevant parts of the frame
        mov     ecx, [eax].ThCallbackStack
        mov     edi, edx                 ; restores ecx, edi
        jmp     _NtCbCopyTrapFrameRet

_NtCbGetDebugRegs:

;
; Copy debug registers from current frame to original frame.
;
        mov     esi, [eax].ThTrapFrame  ; Get current trap frame
        mov     edx, [esi].TsDr0
        mov     [edi].TsDr0, edx
        mov     edx, [esi].TsDr1
        mov     [edi].TsDr1, edx
        mov     edx, [esi].TsDr2
        mov     [edi].TsDr2, edx
        mov     edx, [esi].TsDr3
        mov     [edi].TsDr3, edx
        mov     edx, [esi].TsDr6
        mov     [edi].TsDr6, edx
        mov     edx, [esi].TsDr7
        mov     [edi].TsDr7, edx
        jmp     _NtCbGetDebugRet

;
; No callback is currently active.
;

CbExit: mov     eax, STATUS_NO_CALLBACK_ACTIVE ; set service status
        stdRET  _NtCallBackReturn

stdENDP _NtCallbackReturn

_TEXT   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ke\i386\cpu.asm ===
title  "Processor type and stepping detection"
;++
;
; Copyright (c) Microsoft Corporation. All rights reserved. 
;
; You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
; If you do not agree to the terms, do not use the code.
;
;
; Module Name:
;
;    cpu.asm
;
; Abstract:
;
;    This module implements the assembly code necessary to determine
;    cpu type and stepping information.
;
; Environment:
;
;    80x86
;
;--

        .xlist
include i386\cpu.inc
include ks386.inc
include callconv.inc
include mac386.inc
        .list

;
; constant for i386 32-bit multiplication test
;

MULTIPLIER            equ     00000081h
MULTIPLICAND          equ     0417a000h
RESULT_HIGH           equ     00000002h
RESULT_LOW            equ     0fe7a000h

;
; Constants for Floating Point test
;

REALLONG_LOW          equ     00000000
REALLONG_HIGH         equ     3FE00000h
PSEUDO_DENORMAL_LOW   equ     00000000h
PSEUDO_DENORMAL_MID   equ     80000000h
PSEUDO_DENORMAL_HIGH  equ     0000h

;
; Constants for GenuineIntel cpuid.0 vendor string
;
CPUID_0_INTEL_EBX	  equ	  0756e6547h
CPUID_0_INTEL_EDX	  equ	  049656e69h
CPUID_0_INTEL_ECX	  equ	  06c65746eh


.586p

INIT    SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING


;++
;
; USHORT
; KiSetProcessorType (
;    VOID
;    )
;
; Routine Description:
;
;    This function determines type of processor (80486, 80386),
;    and it's corresponding stepping.  The results are saved in
;    the current processor's PRCB.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    Prcb->CpuType
;       3, 4, 5, ...    3 = 386, 4 = 486, etc..
;
;    Prcb->CpuStep is encoded as follows:
;       lower byte as stepping #
;       upper byte as stepping letter (0=a, 1=b, 2=c, ...)
;
;    (ax) = x86h or 0 if unrecognized processor.
;
;--
cPublicProc _KiSetProcessorType,0

        mov     byte ptr PCR[PcPrcbData.PbCpuID], 0

        push    edi
        push    esi
        push    ebx                     ; Save C registers
        mov     eax, cr0
        push    eax
        pushfd                          ; save Cr0 & flags

        pop     ebx                     ; Get flags into eax
        push    ebx                     ; Save original flags

        mov     ecx, ebx
        xor     ecx, EFLAGS_ID          ; flip ID bit
        push    ecx
        popfd                           ; load it into flags
        pushfd                          ; re-save flags
        pop     ecx                     ; get flags into eax
        cmp     ebx, ecx                ; did bit stay flipped?
        jne     short cpu_has_cpuid     ; Yes, go use CPUID

cpuid_unsupported:
        pop     ebx                     ; Get flags into eax
        push    ebx                     ; Save original flags

        mov     ecx, ebx
        xor     ecx, EFLAGS_AC          ; flip AC bit
        push    ecx
        popfd                           ; load it into flags
        pushfd                          ; re-save flags
        pop     ecx                     ; get flags into eax
        cmp     ebx, ecx                ; did bit stay flipped?
        je      short cpu_is_386        ; No, then this is a 386

cpu_is_486:
        mov     byte ptr PCR[PcPrcbData.PbCpuType], 4h    ; Save CPU Type
        call    Get486Stepping
        jmp     cpu_save_stepping

cpu_is_386:
        mov     byte ptr PCR[PcPrcbData.PbCpuType], 3h    ; Save CPU Type
        call    Get386Stepping
        jmp     cpu_save_stepping

cpu_has_cpuid:
        or      ebx, EFLAGS_ID
        push    ebx
        popfd                           ; Make sure ID bit is set

        mov     ecx, PCR[PcIdt]         ; Address of IDT
        push    dword ptr [ecx+30h]     ; Save Trap06 handler incase
        push    dword ptr [ecx+34h]     ; the CPUID instruction faults

        mov     eax, offset CpuIdTrap6Handler
        mov     word ptr [ecx+30h], ax  ; Set LowWord
        shr     eax, 16
        mov     word ptr [ecx+36h], ax  ; Set HighWord

        mov     eax, 0                  ; argument to CPUID
        cpuid                           ; Uses eax, ebx, ecx, edx

        mov     ecx, PCR[PcIdt]         ; Address of IDT
        pop     dword ptr [ecx+34h]     ; restore trap6 handler
        pop     dword ptr [ecx+30h]

        cmp     eax, 1                  ; make sure level 1 is supported
        jc      short cpuid_unsupported ; no, then punt


        ; Get the family and stepping (cpuid fn=1).  If processor family
        ; is less than 0xf, the format returned is as below:
        ; 3          2         1          
        ; 10987654321098765432109876543210
        ; --------------------------------
        ;                   ppffffmmmmssss
        ; where
        ;    pp = Processor Type 
        ;  ffff = Family
        ;  mmmm = Model
        ;  ssss = Stepping
        ;
        ; This is transformed and saved in the PRCB as
        ; 
        ; PRCB->CpuStep = 0000mmmm0000ssss                v v
        ;     ->CpuID   = 00000001                        | | v
        ;     ->CpuType = 0000ffff                        | | | v
        ;                                                 | | | |
        ; ie the dword that contains all this looks like 0M0S010F
        ;


        ; If the processor family is 0xf or greater, the format returned is:
        ;  3         2         1          
        ; 10987654321098765432109876543210
        ; --------------------------------
        ; RRRRFFFFFFFFMMMMRRppffffmmmmssss
        ; where
        ;    pp = Processor Type 
        ;  ffff = Family
        ;  mmmm = Model
        ;  ssss = Stepping
        ;  MMMM = Extended Model
        ;  FFFFFFFF = Extended Family
        ;  RRRR, RR = Reserved
         
        ; This is transformed and saved in the PRCB as
        ; 
        ; PRCB->CpuStep = EEEEEEEE0000ssss                v v
        ;     ->CpuID   = 00000001                        | | v
        ;     ->CpuType = XXXXXXXX                        | | | v
        ;                                                 | | | |
        ; ie the dword that contains all this looks like EE0S01XX
        ;
        ; where
        ; EEEEEEEE = ((MMMM) << 4)8 bits + (mmmm)zero extended 8 bits
        ; XXXXXXXX = (FFFFFFFF) + (ffff)zero extended 8 bits

        ; The value for Extended Family cannot go beyond F0H inorder to support
        ; a maximum value of FFH for the final Family value(XXXXXXXX).

        ; The maximum value of Extended Model is FH and the maximum value for 
        ; the final Model value(EEEEEEEE) is FFH
        ;
        ;
        ; If the processor vendor is GenuineIntel and Family=6,then Extended Model 
        ; field is valid and Extended Family is reserved. 
        ; 
        mov     eax, 0                  ; get the vendor string
        cpuid

        cmp     ebx, CPUID_0_INTEL_EBX
        jne     short cpu_non_genuineintel

        cmp     ecx, CPUID_0_INTEL_ECX
        jne     short cpu_non_genuineintel

        cmp     edx, CPUID_0_INTEL_EDX
        jne     short cpu_non_genuineintel


        ;
        ; GenuineIntel, check for Family=6
        ;
        mov     eax, 1                  ; get the family and stepping
        cpuid

        mov     ebx, eax
        mov     edx, eax
        mov     ecx, eax                

        and     edx, 0F00h              ; get the Family
        cmp     edx, 0600h              ; (edx) = 00000000000000000000ffff00000000 
        jne     short cpu_not_family_6  ; Family not 6

                                        ; Family 6, ExtendedModel is valid
        and     ebx, 0F00h              ; (bh) = CpuType
        jmp     short extended_model


cpu_non_genuineintel:

        mov     eax, 1                  ; get the family and stepping
        cpuid

        mov     ebx, eax
        mov     edx, eax                
        mov     ecx, eax

        and     edx, 0F00h              ; get the Family

cpu_not_family_6:
        cmp     edx, 0F00h              ; (edx) = 00000000000000000000ffff00000000 
        jne     short cpu_not_extended  ; Family less than F
    
        and     ebx, 0FF00000h          ; (ebx) = 0000FFFFFFFF00000000000000000000  
        shr     ebx, 12                 ; (ebx) = 0000000000000000FFFFFFFF00000000
        add     ebx, edx                ; (ebx) = 0000000000000000XXXXXXXX00000000

extended_model:
        mov     ah, al                  ; (eax) = RRRRFFFFFFFFMMMMmmmmssssmmmmssss 
        shr     eax, 4                  ; (eax) = 0000RRRRFFFFFFFFMMMMmmmmssssmmmm
        mov     al, cl                  ; (eax) = 0000RRRRFFFFFFFFMMMMmmmmmmmmssss
        and     eax, 0FF0Fh             ; (eax) = 0000000000000000EEEEEEEE0000ssss

        jmp     short cpu_save_signature

cpu_not_extended:
        and     eax, 0F0h               ; (eax) = Model
        shl     eax, 4
        mov     al, bl
        and     eax, 0F0Fh              ; (eax) = Model[15:8] | Step[7:0]

        and     ebx, 0F00h              ; (bh) = CpuType

cpu_save_signature:
        mov     byte ptr PCR[PcPrcbData.PbCpuID], 1       ; Has ID support
        mov     byte ptr PCR[PcPrcbData.PbCpuType], bh    ; Save CPU Type

cpu_save_stepping:
        mov     word ptr PCR[PcPrcbData.PbCpuStep], ax    ; Save CPU Stepping
        popfd                                   ; Restore flags
        pop     eax
        mov     cr0, eax
        pop     ebx
        pop     esi
        pop     edi
        stdRET  _KiSetProcessorType

cpuid_trap:
        mov     ecx, PCR[PcIdt]         ; Address of IDT
        pop     dword ptr [ecx+34h]     ; restore trap6 handler
        pop     dword ptr [ecx+30h]
        jmp     cpuid_unsupported       ; Go get processor information

stdENDP _KiSetProcessorType

;++
;
; BOOLEAN
; CpuIdTrap6 (
;    VOID
;    )
;
; Routine Description:
;
;    Temporary int 6 handler - assumes the cause of the exception was the
;    attempted CPUID instruction.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    none.
;
;--

CpuIdTrap6Handler   proc

        mov     [esp].IretEip,offset cpuid_trap
        iretd

CpuIdTrap6Handler  endp


;++
;
; USHORT
; Get386Stepping (
;    VOID
;    )
;
; Routine Description:
;
;    This function determines cpu stepping for i386 CPU stepping.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    [ax] - Cpu stepping.
;           0 = A, 1 = B, 2 = C, ...
;
;--

        public  Get386Stepping
Get386Stepping  proc

        call    MultiplyTest            ; Perform multiplication test
        jnc     short G3s00             ; if nc, muttest is ok
        mov     ax, 0
        ret
G3s00:
        call    Check386B0              ; Check for B0 stepping
        jnc     short G3s05             ; if nc, it's B1/later
        mov     ax, 100h                ; It is B0/earlier stepping
        ret

G3s05:
        call    Check386D1              ; Check for D1 stepping
        jc      short G3s10             ; if c, it is NOT D1
        mov     ax, 301h                ; It is D1/later stepping
        ret

G3s10:
        mov     ax, 101h                ; assume it is B1 stepping
        ret

Get386Stepping  endp

;++
;
; USHORT
; Get486Stepping (
;    VOID
;    )
;
; Routine Description:
;
;    This function determines cpu stepping for i486 CPU type.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    [ax] - Cpu stepping.  For example, [ax] = D0h for D0 stepping.
;
;--

        public  Get486Stepping
Get486Stepping          proc

        call    Check486AStepping       ; Check for A stepping
        jnc     short G4s00             ; if nc, it is NOT A stepping

        mov     ax, 0                   ; set to A stepping
        ret

G4s00:  call    Check486BStepping       ; Check for B stepping
        jnc     short G4s10             ; if nc, it is NOT a B stepping

        mov     ax, 100h                ; set to B stepping
        ret

;
; Before we test for 486 C/D step, we need to make sure NPX is present.
; Because the test uses FP instruction to do the detection.
;
G4s10:
        call    _KiIsNpxPresent         ; Check if cpu has coprocessor support?
        or      ax, ax
        jz      short G4s15             ; it is actually 486sx

        call    Check486CStepping       ; Check for C stepping
        jnc     short G4s20             ; if nc, it is NOT a C stepping
G4s15:
        mov     ax, 200h                ; set to C stepping
        ret

G4s20:  mov     ax, 300h                ; Set to D stepping
        ret

Get486Stepping          endp

;++
;
; BOOLEAN
; Check486AStepping (
;    VOID
;    )
;
; Routine Description:
;
;    This routine checks for 486 A Stepping.
;
;    It takes advantage of the fact that on the A-step of the i486
;    processor, the ET bit in CR0 could be set or cleared by software,
;    but was not used by the hardware.  On B or C -step, ET bit in CR0
;    is now hardwired to a "1" to force usage of the 386 math coprocessor
;    protocol.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    Carry Flag clear if B or later stepping.
;    Carry Flag set if A or earlier stepping.
;
;--
        public  Check486AStepping
Check486AStepping       proc    near
        mov     eax, cr0                ; reset ET bit in cr0
        and     eax, NOT CR0_ET
        mov     cr0, eax

        mov     eax, cr0                ; get cr0 back
        test    eax, CR0_ET             ; if ET bit still set?
        jnz     short cas10             ; if nz, yes, still set, it's NOT A step
        stc
        ret

cas10:  clc
        ret
Check486AStepping       endp

;++
;
; BOOLEAN
; Check486BStepping (
;    VOID
;    )
;
; Routine Description:
;
;    This routine checks for 486 B Stepping.
;
;    On the i486 processor, the "mov to/from DR4/5" instructions were
;    aliased to "mov to/from DR6/7" instructions.  However, the i486
;    B or earlier steps generate an Invalid opcode exception when DR4/5
;    are used with "mov to/from special register" instruction.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    Carry Flag clear if C or later stepping.
;    Carry Flag set if B stepping.
;
;--
        public  Check486BStepping
Check486BStepping       proc

        push    ebx

        mov     ebx, PCR[PcIdt]           ; Address of IDT
        push    dword ptr [ebx+30h]
        push    dword ptr [ebx+34h]     ; Save Trap06 handler

        mov     eax, offset Temporary486Int6
        mov     word ptr [ebx+30h], ax  ; Set LowWord
        shr     eax, 16
        mov     word ptr [ebx+36h], ax  ; Set HighWord

c4bs50: db      0fh, 21h, 0e0h          ; mov eax, DR4
        nop
        nop
        nop
        nop
        nop
        clc                             ; it is C step
        jmp     short c4bs70
c4bs60: stc                             ; it's B step
c4bs70: pop     dword ptr [ebx+34h]     ; restore old int 6 vector
        pop     dword ptr [ebx+30h]

        pop     ebx
        ret

        ret

Check486BStepping       endp

;++
;
; BOOLEAN
; Temporary486Int6 (
;    VOID
;    )
;
; Routine Description:
;
;    Temporary int 6 handler - assumes the cause of the exception was the
;    attempted execution of an mov to/from DR4/5 instruction.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    none.
;
;--

Temporary486Int6        proc

        mov     [esp].IretEIp,offset c4bs60 ; set EIP to stc instruction
        iretd

Temporary486Int6        endp

;++
;
; BOOLEAN
; Check486CStepping (
;    VOID
;    )
;
; Routine Description:
;
;    This routine checks for 486 C Stepping.
;
;    This routine takes advantage of the fact that FSCALE produces
;    wrong result with Denormal or Pseudo-denormal operand on 486
;    C and earlier steps.
;
;    If the value contained in ST(1), second location in the floating
;    point stack, is between 1 and 11, and the value in ST, top of the
;    floating point stack, is either a pseudo-denormal number or a
;    denormal number with the underflow exception unmasked, the FSCALE
;    instruction produces an incorrect result.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    Carry Flag clear if D or later stepping.
;    Carry Flag set if C stepping.
;
;--

FpControl       equ     [ebp - 2]
RealLongSt1     equ     [ebp - 10]
PseudoDenormal  equ     [ebp - 20]
FscaleResult    equ     [ebp - 30]

        public  Check486CStepping
Check486CStepping       proc

        push    ebp
        mov     ebp, esp
        sub     esp, 30                 ; Allocate space for temp real variables

        mov     eax, cr0                ; Don't trap while doing math
        and     eax, NOT (CR0_ET+CR0_MP+CR0_TS+CR0_EM)
        mov     cr0, eax

;
; Initialize the local FP variables to predefined values.
; RealLongSt1 = 1.0 * (2 ** -1) = 0.5 in normalized double precision FP form
; PseudoDenormal =  a unsupported format by IEEE.
;                   Sign bit = 0
;                   Exponent = 000000000000000B
;                   Significand = 100000...0B
; FscaleResult = The result of FSCALE instruction.  Depending on 486 step,
;                the value will be different:
;                Under C and earlier steps, 486 returns the original value
;                in ST as the result.  The correct returned value should be
;                original significand and an exponent of 0...01.
;

        mov     dword ptr RealLongSt1, REALLONG_LOW
        mov     dword ptr RealLongSt1 + 4, REALLONG_HIGH
        mov     dword ptr PseudoDenormal, PSEUDO_DENORMAL_LOW
        mov     dword ptr PseudoDenormal + 4, PSEUDO_DENORMAL_MID
        mov     word ptr PseudoDenormal + 8, PSEUDO_DENORMAL_HIGH

.387
        fnstcw  FpControl               ; Get FP control word
        fwait
        or      word ptr FpControl, 0FFh ; Mask all the FP exceptions
        fldcw   FpControl               ; Set FP control

        fld     qword ptr RealLongSt1   ; 0 < ST(1) = RealLongSt1 < 1
        fld     tbyte ptr PseudoDenormal; Denormalized operand. Note, i486
                                        ; won't report denormal exception
                                        ; on 'FLD' instruction.
                                        ; ST(0) = Extended Denormalized operand
        fscale                          ; try to trigger 486Cx errata
        fstp    tbyte ptr FscaleResult  ; Store ST(0) in FscaleResult
        cmp     word ptr FscaleResult + 8, PSEUDO_DENORMAL_HIGH
                                        ; Is Exponent changed?
        jz      short c4ds00            ; if z, no, it is C step
        clc
        jmp     short c4ds10
c4ds00: stc
c4ds10: mov     esp, ebp
        pop     ebp
        ret

Check486CStepping       endp

;++
;
; BOOLEAN
; Check386B0 (
;    VOID
;    )
;
; Routine Description:
;
;    This routine checks for 386 B0 or earlier stepping.
;
;    It takes advantage of the fact that the bit INSERT and
;    EXTRACT instructions that existed in B0 and earlier versions of the
;    386 were removed in the B1 stepping.  When executed on the B1, INSERT
;    and EXTRACT cause an int 6 (invalid opcode) exception.  This routine
;    can therefore discriminate between B1/later 386s and B0/earlier 386s.
;    It is intended to be used in sequence with other checks to determine
;    processor stepping by exercising specific bugs found in specific
;    steppings of the 386.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    Carry Flag clear if B1 or later stepping
;    Carry Flag set if B0 or prior
;
;--

Check386B0      proc

        push    ebx

        mov     ebx, PCR[PcIdt]           ; Address of IDT
        push    dword ptr [ebx+30h]
        push    dword ptr [ebx+34h]     ; Save Trap06 handler

        mov     eax, offset TemporaryInt6
        mov     word ptr [ebx+30h], ax  ; Set LowWord
        shr     eax, 16
        mov     word ptr [ebx+36h], ax  ; Set HighWord


;
; Attempt execution of Extract Bit String instruction.  Execution on
; B0 or earlier with length (CL) = 0 will return 0 into the destination
; (CX in this case).  Execution on B1 or later will fail either due to
; taking the invalid opcode trap, or if the opcode is valid, we don't
; expect CX will be zeroed by any new instruction supported by newer
; steppings.  The dummy int 6 handler will clears the Carry Flag and
; returns execution to the appropriate label.  If the instruction
; actually executes, CX will *probably* remain unchanged in any new
; stepping that uses the opcode for something else.  The nops are meant
; to handle newer steppings with an unknown instruction length.
;

        xor     eax,eax
        mov     edx,eax
        mov     ecx,0ff00h              ; Extract length (CL) == 0, (CX) != 0

b1c50:  db      0fh, 0a6h, 0cah         ; xbts cx,dx,ax,cl
        nop
        nop
        nop
        nop
        nop
        stc                             ; assume B0
        jecxz    short b1c70            ; jmp if B0
b1c60:  clc
b1c70:  pop     dword ptr [ebx+34h]     ; restore old int 6 vector
        pop     dword ptr [ebx+30h]

        pop     ebx
        ret

Check386B0      endp

;++
;
; BOOLEAN
; TemporaryInt6 (
;    VOID
;    )
;
; Routine Description:
;
;    Temporary int 6 handler - assumes the cause of the exception was the
;    attempted execution of an XTBS instruction.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    none.
;
;--

TemporaryInt6    proc

        mov     [esp].IretEip,offset b1c60 ; set IP to clc instruction
        iretd

TemporaryInt6   endp

;++
;
; BOOLEAN
; Check386D1 (
;    VOID
;    )
;
; Routine Description:
;
;    This routine checks for 386 D1 Stepping.
;
;    It takes advantage of the fact that on pre-D1 386, if a REPeated
;    MOVS instruction is executed when single-stepping is enabled,
;    a single step trap is taken every TWO moves steps, but should
;    occur each move step.
;
;    NOTE: This routine cannot distinguish between a D0 stepping and a D1
;    stepping.  If a need arises to make this distinction, this routine
;    will need modification.  D0 steppings will be recognized as D1.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    Carry Flag clear if D1 or later stepping
;    Carry Flag set if B1 or prior
;
;--

Check386D1      proc
        push    ebx

        mov     ebx, PCR[PcIdt]           ; Address of IDT
        push    dword ptr [ebx+08h]
        push    dword ptr [ebx+0ch]     ; Save Trap01 handler

        mov     eax, offset TemporaryInt1
        mov     word ptr [ebx+08h], ax  ; Set LowWord
        shr     eax, 16
        mov     word ptr [ebx+0eh], ax  ; Set HighWord

;
; Attempt execution of rep movsb instruction with the Trace Flag set.
; Execution on B1 or earlier with length (CX) > 1 will trace over two
; iterations before accepting the trace trap.  Execution on D1 or later
; will accept the trace trap after a single iteration.  The dummy int 1
; handler will return execution to the instruction following the movsb
; instruction.  Examination of (CX) will reveal the stepping.
;

        sub     esp,4                   ; make room for target of movsb
        mov     esi, offset TemporaryInt1 ; (ds:esi) -> some present data
        mov     edi,esp
        mov     ecx,2                   ; 2 iterations
        pushfd
        or      dword ptr [esp], EFLAGS_TF
        popfd                           ; cause a single step trap
        rep movsb

d1c60:  add     esp,4                   ; clean off stack
        pop     dword ptr [ebx+0ch]     ; restore old int 1 vector
        pop     dword ptr [ebx+08h]
        stc                             ; assume B1
        jecxz   short d1cx              ; jmp if <= B1
        clc                             ; else clear carry to indicate >= D1
d1cx:
        pop     ebx
        ret

Check386D1      endp

;++
;
; BOOLEAN
; TemporaryInt1 (
;    VOID
;    )
;
; Routine Description:
;
;    Temporary int 1 handler - assumes the cause of the exception was
;    trace trap at the above rep movs instruction.
;
; Arguments:
;
;    (esp)->eip of trapped instruction
;           cs  of trapped instruction
;           eflags of trapped instruction
;
;--

TemporaryInt1   proc

        and     [esp].IretEFlags,not EFLAGS_TF ; clear caller's Trace Flag
        mov     [esp].IretEip,offset d1c60     ; set IP to next instruction
        iretd

TemporaryInt1   endp

;++
;
; BOOLEAN
; MultiplyTest (
;    VOID
;    )
;
; Routine Description:
;
;    This routine checks the 386 32-bit multiply instruction.
;    The reason for this check is because some of the i386 fail to
;    perform this instruction.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    Carry Flag clear on success
;    Carry Flag set on failure
;
;--
;

MultiplyTest    proc

        xor     cx,cx                   ; 64K times is a nice round number
mlt00:  push    cx
        call    Multiply                ; does this chip's multiply work?
        pop     cx
        jc      short mltx              ; if c, No, exit
        loop    mlt00                   ; if nc, YEs, loop to try again
        clc
mltx:
        ret

MultiplyTest    endp

;++
;
; BOOLEAN
; Multiply (
;    VOID
;    )
;
; Routine Description:
;
;    This routine performs 32-bit multiplication test which is known to
;    fail on bad 386s.
;
;    Note, the supplied pattern values must be used for consistent results.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    Carry Flag clear on success.
;    Carry Flag set on failure.
;
;--

Multiply        proc

        mov     ecx, MULTIPLIER
        mov     eax, MULTIPLICAND
        mul     ecx

        cmp     edx, RESULT_HIGH        ; Q: high order answer OK ?
        stc                             ; assume failure
        jnz     short mlpx              ;   N: exit with error

        cmp     eax, RESULT_LOW         ; Q: low order answer OK ?
        stc                             ; assume failure
        jnz     short mlpx              ;   N: exit with error

        clc                             ; indicate success
mlpx:
        ret

Multiply        endp

;++
;
; BOOLEAN
; KiIsNpxPresent(
;     VOID
;     );
;
; Routine Description:
;
;     This routine determines if there is any Numeric coprocessor
;     present.
;
;     Note that we do NOT determine its type (287, 387).
;     This code is extracted from Intel book.
;
; Arguments:
;
;     None.
;
; Return:
;
;     TRUE - If NPX is present.  Else a value of FALSE is returned.
;     Sets CR0 NPX bits accordingly.
;
;--

cPublicProc _KiIsNpxPresent,0

        push    ebp                     ; Save caller's bp
        mov     eax, cr0
        and     eax, NOT (CR0_ET+CR0_MP+CR0_TS+CR0_EM)
        mov     cr0, eax
        xor     edx, edx
.287
        fninit                          ; Initialize NPX
        mov     ecx, 5A5A5A5Ah          ; Put non-zero value
        push    ecx                     ;   into the memory we are going to use
        mov     ebp, esp
        fnstsw  word ptr [ebp]          ; Retrieve status - must use non-wait
        cmp     byte ptr [ebp], 0       ; All bits cleared by fninit?
        jne     Inp10

        or      eax, CR0_ET
        mov     edx, 1

        cmp     PCR[PcPrcbData.PbCpuType], 3h
        jbe     Inp10

        or      eax, CR0_NE

Inp10:
        or      eax, CR0_EM+CR0_TS      ; During Kernel Initialization set
                                        ; the EM bit
        mov     cr0, eax
        pop     eax                     ; clear scratch value
        pop     ebp                     ; Restore caller's bp
        mov     eax, edx
        stdRet  _KiIsNpxPresent


stdENDP _KiIsNpxPresent


;++
;
; VOID
; CPUID (
;     ULONG   InEax,
;     PULONG  OutEax,
;     PULONG  OutEbx,
;     PULONG  OutEcx,
;     PULONG  OutEdx
;     );
;
; Routine Description:
;
;   Executes the CPUID instruction and returns the registers from it
;
;   Only available at INIT time
;
; Arguments:
;
; Return Value:
;
;--
cPublicProc _CPUID,5

    push    ebx
    push    esi

    mov     eax, [esp+12]

    cpuid

    mov     esi, [esp+16]   ; return EAX
    mov     [esi], eax

    mov     esi, [esp+20]   ; return EBX
    mov     [esi], ebx

    mov     esi, [esp+24]   ; return ECX
    mov     [esi], ecx

    mov     esi, [esp+28]   ; return EDX
    mov     [esi], edx

    pop     esi
    pop     ebx

    stdRET  _CPUID

stdENDP _CPUID

INIT    ENDS

_TEXT   SEGMENT DWORD PUBLIC 'CODE'      ; Put IdleLoop in text section
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

;++
;
; LONGLONG
; RDTSC (
;       VOID
;     );
;
; Routine Description:
;
; Arguments:
;
; Return Value:
;
;--
cPublicProc _RDTSC
    rdtsc
    stdRET  _RDTSC

stdENDP _RDTSC

;++
;
; ULONGLONG
; FASTCALL
; RDMSR (
;   IN ULONG MsrRegister
;   );
;
; Routine Description:
;
; Arguments:
;
; Return Value:
;
;--
cPublicFastCall RDMSR, 1
    rdmsr
    fstRET  RDMSR
fstENDP RDMSR


;++
;
; VOID
; WRMSR (
;   IN ULONG MsrRegister
;   IN LONGLONG MsrValue
;   );
;
; Routine Description:
;
; Arguments:
;
; Return Value:
;
;--
cPublicProc _WRMSR, 3
    mov     ecx, [esp+4]
    mov     eax, [esp+8]
    mov     edx, [esp+12]
    wrmsr
    stdRET  _WRMSR
stdENDP _WRMSR

;++
;
; VOID
; KeYieldProcessor (
;   VOID
;   );
;
; Routine Description:
;
;   Yields a thread of the processor
;
; Arguments:
;
; Return Value:
;
;--
cPublicProc _KeYieldProcessor
    YIELD
    stdRET _KeYieldProcessor
stdENDP _KeYieldProcessor

_TEXT   ENDS
        END
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ke\i386\clockint.asm ===
title  "Interval Clock Interrupt"
;++
;
; Copyright (c) Microsoft Corporation. All rights reserved. 
;
; You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
; If you do not agree to the terms, do not use the code.
;
;
; Module Name:
;
;    clockint.asm
;
; Abstract:
;
;    This module implements the code necessary to field and process the
;    interval clock interrupt.
;
;--

.586p
        .xlist
KERNELONLY  equ     1
include ks386.inc
include callconv.inc                    ; calling convention macros
include i386\kimacro.inc
include mac386.inc
        .list

        EXTRNP  Kei386EoiHelper
        EXTRNP  HalRequestSoftwareInterrupt,1,IMPORT,FASTCALL
        EXTRNP  _HalEndSystemInterrupt,2,IMPORT
        extern  _ExpInterlockedPopEntrySListEnd@0:PROC
        extrn   _ExpInterlockedPopEntrySListResume@0:PROC
        extrn   _KeTimeIncrement:DWORD
        extrn   _KeMaximumIncrement:DWORD
        extrn   _KeTickCount:DWORD
        extrn   _KeTimeAdjustment:DWORD
        extrn   _KiAdjustDpcThreshold:DWORD
        EXTRNP  KiCheckForSListAddress,1,,FASTCALL
        extrn   _KiIdealDpcRate:DWORD
        extrn   _KiMaximumDpcQueueDepth:DWORD
        extrn   _KiTickOffset:DWORD
        extrn   _KiTimerTableListHead:DWORD
        extrn   _KiProfileListHead:DWORD
        extrn   _KiProfileLock:DWORD
        extrn   _KiProfileInterval:DWORD
        extrn   _KdDebuggerEnabled:BYTE
        EXTRNP  _DbgBreakPoint
        EXTRNP  _DbgBreakPointWithStatus,1
        EXTRNP  _KdPollBreakIn
        EXTRNP  _KiDeliverApc,3
        extrn   _KeI386MachineType:DWORD
        extrn   _PPerfGlobalGroupMask:DWORD
        EXTRNP  PerfProfileInterrupt,2,,FASTCALL

if DBG
        extrn   _DbgPrint:near
        extrn   _KiDPCTimeout:DWORD
        extrn   _MsgDpcTimeout:BYTE
endif

_DATA   SEGMENT  DWORD PUBLIC 'DATA'
public  ProfileCount
ProfileCount    DD      0

_DATA   ends

        page ,132
        subttl  "Update System Time"

_TEXT$00   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING
;++
;
; VOID
; KeUpdateSystemTime (
;       IN KIRQL PreviousIrql,
;       IN KTRAP_FRAME TrapFrame
;       )
;
; Routine Description:
;
;    This routine is entered as the result of an interrupt generated by CLOCK2.
;    Its function is to update the system time and check to determine if a timer
;    has expired.
;
;    N.B. This routine is executed on a single processor in a multiprocessor
;       system. The remainder of the processors only execute the quantum end
;       and runtime update code.
;
;    N.B. This routine is not called, but directly jumped to.  Thus, there
;       is no return address.  It returns via the INTERRUPT_EXIT macro.
;
; Arguments:
;
;    PreviousIrql   (esp)   - supplies previous irql of system
;
;    HardwareVector (esp+4) - supplies hardware vector for EndSystemInterrupt
;
;    TrapFrame      (esp+8) - supplies base of trap frame
;
;    EAX is the TimeIncrement value
;
;    EBP is a pointer to the trap frame
;
;
; Environment:
;
;    IRQL = CLOCK_LEVEL
;
; Return Value:
;
;    None.
;
;--
cPublicProc _KeUpdateSystemTime     ,0

.FPO (2, 0, 0, 0, 0, 1) ; treat params as locals since functions is JMPed too

if DBG
        cmp     byte ptr PCR[PcPrcbData+PbSkipTick], 0
        jnz     kust_skiptick
endif

;
; Update interrupt time.
;
; N.B. The interrupt time is updated in a very strict manner so that an
;      interlock does not have to be used in an MP system to read time.
;

        mov     ecx,USER_SHARED_DATA    ; get address of user shared data
        mov     edi,[ecx].UsInterruptTime+0 ; get low interrupt time
        mov     esi,[ecx].UsInterruptTime+4 ; get high interrupt time
        add     edi,eax                 ; add time increment
        adc     esi,0                   ; propagate carry
        mov     [ecx].UsInterruptTime+8,esi ; store high 2 interrupt time
        mov     [ecx].UsInterruptTime+0,edi ; store low interrupt time
        mov     [ecx].UsInterruptTime+4,esi ; store high 1 interrupt time

ifndef NT_UP

   lock sub     _KiTickOffset,eax       ; subtract time increment

else

        sub     _KiTickOffset,eax       ; subtract time increment

endif

        mov     eax,_KeTickCount+0      ; get low tick count
        mov     ebx,eax                 ; copy low tick count
        jg      kust10                  ; if greater, not complete tick

;
; Update system time.
;
; N.B. The system time is updated in a very strict manner so that an
;      interlock does not have to be used in an MP system to read time.
;

        mov     ebx,USER_SHARED_DATA    ; get address of user shared data
        mov     ecx,[ebx].UsSystemTime+0 ; get low system time
        mov     edx,[ebx].UsSystemTime+4 ; get high system time
        add     ecx,_KeTimeAdjustment   ; add time increment
        adc     edx,0                   ; propagate carry
        mov     [ebx].UsSystemTime+8,edx ; store high 2 system time
        mov     [ebx].UsSystemTime+0,ecx ; store low system time
        mov     [ebx].UsSystemTime+4,edx ; store high 1 system time
        mov     ebx,eax                 ; restore low tick count

;
; Update tick count.
;
; N.B. The tick count is updated in a very strict manner so that an
;      interlock does not have to be used in an MP system to read count.
;

        mov     ecx,eax                 ; copy low tick count
        mov     edx,_KeTickCount+4      ; get high tick count
        add     ecx,1                   ; increment tick count
        adc     edx,0                   ; propagate carry
        mov     _KeTickCount+8,edx      ; store high 2 tick count
        mov     _KeTickCount+0,ecx      ; store low tick count
        mov     _KeTickCount+4,edx      ; store high 1 tick count
        mov     USERDATA[UsTickCount]+8, edx ; store USD high 2 tick count
        mov     USERDATA[UsTickCount]+0, ecx ; store USD low tick count
        mov     USERDATA[UsTickCount]+4, edx ; store USD high 1 tick count

;
; Check to determine if a timer has expired.
; (edi:esi) = KiInterruptTime
; (eax) = KeTickCount.LowPart
; (ebx) = KeTickCount.LowPart
;

        .errnz  (TIMER_ENTRY_SIZE - 16)

        and     eax,TIMER_TABLE_SIZE-1  ; isolate current hand value
        shl     eax, 4                  ; compute timer entry offset
        cmp     esi,[eax]+_KiTimerTableListHead+TtTime+4 ; compare high due time 
        jb      short kust5             ; if below, timer has not expired
        ja      short kust15            ; if above, timer has expired
        cmp     edi,[eax]+_KiTimerTableListHead+TtTime ; compare low due time
        jae     short kust15            ; if above or equal, timer has expired
kust5:  inc     ebx                     ; advance hand value to next entry
        mov     eax, ebx                ;

;
; Check to determine if a timer has expired.
; (edi:esi) = KiInterruptTime
; (eax) = bucket
; (ebx) = KeTickCount.LowPart
;

kust10: and     eax,TIMER_TABLE_SIZE-1  ; isolate current hand value
        shl     eax, 4                  ; compute timer entry offset
        cmp     esi,[eax]+_KiTimerTableListHead+TtTime+4 ; compare high due time 
        jb      kustxx                  ; if below, timer has not expired
        ja      short kust15            ; if above, timer has expired
        cmp     edi,[eax]+_KiTimerTableListHead+TtTime ; compare low due time
        jb      kustxx                  ; if below, timer has not expired
kust15:                                 ;

;
; Timer has expired, put timer expiration DPC in the current processor's DPC
; queue.
;
; (ebx) = KeTickCount.LowPart
;

        mov     ecx,PCR[PcPrcb]         ; get processor control block address
        cmp     dword ptr [ecx]+PbTimerRequest, 0 ; check if expiration active
        jne     short kustxx            ; if ne, expiration already active
        mov     [ecx]+PbTimerRequest, esp ; set timer request
        mov     [ecx]+PbTimerHand, ebx  ; set timer hand value
        mov     ecx, DISPATCH_LEVEL     ; request dispatch interrupt
        fstCall HalRequestSoftwareInterrupt ;

;
; If the debugger is enabled, check if a break is requested.
;

kustxx: cmp     _KdDebuggerEnabled, 0   ; check if a debugger is enabled
        jnz     short kust45            ;if nz, debugger is enabled

kust30: cmp     _KiTickOffset,0         ; check if full tick
        jg      short Kust40            ; if not less, not a full tick

        mov     eax,_KeMaximumIncrement ; get maximum time increment
        add     _KiTickOffset,eax       ; add maximum tine to residue

;
; call KeUpdateRunTime to do the actual work
;

; TOS const PreviousIrql
        push    [esp]
        call    _KeUpdateRunTime@4

;
; Do interrupt exit processing
;

        INTERRUPT_EXIT

kust40:
        inc     dword ptr PCR[PcPrcbData+PbInterruptCount]
        INTERRUPT_EXIT

kust45: stdCall _KdPollBreakIn
        or      al,al
        jz      short kust30
        stdCall _DbgBreakPointWithStatus,<DBG_STATUS_CONTROL_C>
        jmp     short kust30

if DBG

kust_skiptick:
        mov     byte ptr PCR[PcPrcbData+PbSkipTick], 0
        jmp     short kust40

endif

stdENDP _KeUpdateSystemTime


        page ,132
        subttl  "Update Thread and Process Runtime"
;++
;
; Routine Description:
;
;    This routines does the actual work to update the runtime of the current
;    thread, update the runtime of the current thread's process, and
;    decrement the current thread's quantum.
;
;    It also updates the system global counters for user and kernel mode time.
;
;    It increments InterruptCount so that clock ticks get counted as
;    interrupts.
;
; Arguments:
;
;    esp+4 constant PreviousIrql
;
;    ebp MUST point to the machine state frame.
;
; Return Value:
;
;    None.
;
;--

cPublicProc _KeUpdateRunTime   ,1
cPublicFpo 1, 1

        mov     eax, PCR[PcSelfPcr]
if DBG
        cmp     byte ptr [eax]+PcPrcbData+PbSkipTick, 0
        jnz     kutp_skiptick
endif
        push    ebx                     ; we will destroy ebx
        inc     dword ptr [eax]+PcPrcbData+PbInterruptCount
        mov     ebx, [eax]+PcPrcbData+PbCurrentThread ; (ebx)->current thread
        mov     ecx, ThApcState+AsProcess[ebx]
                                        ; (ecx)->current thread's process

        test    dword ptr [ebp]+TsEFlags,EFLAGS_V86_MASK
        jne     Kutp20                  ; if ne, user mode

        test    byte ptr [ebp]+TsSegCs, MODE_MASK ; test if prev mode was kernel
        jne     Kutp20                  ; if ne, user mode

;
; Update the total time spent in kernel mode
;

        inc     dword ptr [eax].PcPrcbData.PbKernelTime
        cmp     byte ptr [esp+8], DISPATCH_LEVEL
        jc      short Kutp4             ; OldIrql<2, then kernel
        ja      short Kutp3             ; OldIrql>2, then interrupt

        cmp     byte ptr PCR[PcPrcbData.PbDpcRoutineActive], 0
        jz      short Kutp4             ; Executing Dpc?, no then thread time

        inc     dword ptr [eax].PcPrcbData.PbDpcTime
if DBG
;
; Check for dpcs which run for too long
;

        inc     dword ptr [eax].PcPrcbData.PbDebugDpcTime
        mov     edx, _KiDPCTimeout
        cmp     dword ptr [eax].PcPrcbData.PbDebugDpcTime, edx
        jc      Kutp50                  ; Jump if not over limit

;
; Dpc time has exceeded the allowed quanta
;

        push    offset FLAT:_MsgDpcTimeout ; push message address
        call    _DbgPrint               ; print debug message
        add     esp, 1 * 4              ; remove arguments from stack

        cmp     _KdDebuggerEnabled, 0   ; check if debugger enabled
        je      short Kutp6             ; if eq, no debugger, continue
        stdCall _DbgBreakPoint          ; break into debugger

Kutp6:  mov     eax, PCR[PcSelfPcr]     ; restore PCR address
        mov     dword ptr [eax].PcPrcbData.PbDebugDpcTime, 0 ; Reset Time
endif
        jmp     Kutp50

ALIGN 4
Kutp3:
;
; Update the time spent at interrupt time for this processor
;

        inc     dword ptr [eax].PcPrcbData.PbInterruptTime
        jmp     Kutp50

ALIGN 4
Kutp4:

;
; Update the time spent in kernel mode for the current thread and the current
; thread's process.
;
        inc     dword ptr [ebx]+ThKernelTime
        jmp     Kutp50


;
; Update total time spent in user mode
;

ALIGN 4
Kutp20:
        inc     dword ptr [eax].PcPrcbData.PbUserTime
;
; Update the time spend in user mode for the current thread and the current
; thread's process.
;

        inc     dword ptr [ebx]+ThUserTime

;
; Update the DPC request rate which is computed as the average between
; the previous rate and the current rate.
;

ALIGN 4
Kutp50: mov     ecx, [eax].PcPrcbData.PbDpcCount ; get current DPC count
        mov     edx, [eax].PcPrcbData.PbDpcLastCount ; get last DPC count
        mov     [eax].PcPrcbData.PbDpcLastCount, ecx ; set last DPC count
        sub     ecx, edx                ; compute count during interval
        add     ecx, [eax].PcPrcbData.PbDpcRequestRate ; compute sum
        shr     ecx, 1                  ; average current and last
        mov     [eax].PcPrcbData.PbDpcRequestRate, ecx ; set new DPC request rate

;
; If the current DPC queue depth is not zero, a DPC routine is not active,
; and a DPC interrupt has not been requested, then request a dispatch
; interrupt, decrement the maximum DPC queue depth, and reset the threshold
; counter if appropriate.
;

        cmp     dword ptr [eax].PcPrcbData.PbDpcQueueDepth, 0 ; check queue depth
        je      short Kutp53            ; if eq, DPC queue depth is zero
        cmp     byte ptr [eax].PcPrcbData.PbDpcRoutineActive, 0 ; check if DPC active
        jne     short Kutp53            ; if ne, DPC routine active
        cmp     byte ptr [eax].PcPrcbData.PbDpcInterruptRequested, 0 ; check if interrupt
        jne     short Kutp53            ; if ne, DPC routine active
        mov     ecx, DISPATCH_LEVEL     ; request a dispatch interrupt
        fstCall HalRequestSoftwareInterrupt ;
        mov     eax, PCR[PcSelfPcr]     ; restore address of current PCR
        mov     ecx, [eax].PcPrcbData.PbDpcRequestRate ; get DPC request rate
        mov     edx, _KiAdjustDpcThreshold ; reset initial threshold counter
        mov     [eax].PcPrcbData.PbAdjustDpcThreshold, edx ;
        cmp     ecx, _KiIdealDpcRate    ; test if current rate less than ideal
        jge     short Kutp55            ; if ge, rate greater or equal ideal
        cmp     [eax].PcPrcbData.PbMaximumDpcQueueDepth, 1 ; check if depth one
        je      short Kutp55            ; if eq, maximum depth is one
        dec     dword ptr [eax].PcPrcbData.PbMaximumDpcQueueDepth ; decrement depth
        jmp     short Kutp55            ;

;
; The DPC queue is empty or a DPC routine is active or a DPC interrupt
; has been requested. Count down the adjustment threshold and if the
; count reaches zero, then increment the maximum DPC queue depth, but
; no above the initial value and reset the adjustment threshold value.
;

Kutp53: dec     dword ptr [eax].PcPrcbData.PbAdjustDpcThreshold ; decrement threshold
        jnz     short Kutp55            ; if nz, threshold not zero
        mov     ecx, _KiAdjustDpcThreshold ; reset initial threshold counter
        mov     [eax].PcprcbData.PbAdjustDpcThreshold, ecx ;
        mov     ecx, _KiMaximumDpcQueueDepth ; get maximum DPC queue depth
        cmp     ecx, [eax].PcPrcbData.PbMaximumDpcQueueDepth ; check depth
        je      short Kutp55            ; if eq, already a maximum level
        inc     dword ptr [eax].PcPrcbData.PbMaximumDpcQueueDepth ; increment maximum depth

;
; Decrement current thread quantum and check to determine if a quantum end
; has occurred.
;

ALIGN 4
Kutp55: sub     byte ptr [ebx]+ThQuantum, CLOCK_QUANTUM_DECREMENT ; decrement quantum
        jg      Kutp75                      ; if > 0, time remaining on quantum

;
; Set quantum end flag and initiate a dispatcher interrupt on the current
; processor.
;

        cmp     ebx,[eax].PcPrcbData.PbIdleThread ; check if idle thread
        jz      Kutp75                      ; if z, then idle thread
        mov     byte ptr [eax].PcPrcbData.PbQuantumEnd, 1 ; set quantum end indicator
        mov     ecx, DISPATCH_LEVEL         ; request dispatch interrupt
        fstCall HalRequestSoftwareInterrupt ;
Kutp75:                                     ;
        pop     ebx                         ;
        stdRET    _KeUpdateRunTime          ;

if DBG
kutp_skiptick:
        mov     byte ptr [eax]+PcPrcbData+PbSkipTick, 0
        stdRET    _KeUpdateRunTime
endif

stdENDP _KeUpdateRunTime


;++
;
;   PROFILING SUPPORT
;
;--


;++
;
; VOID
; KeProfileInterrupt (
;       IN PKTRAP_FRAME TrapFrame,
;       )
;
; Routine Description:
;
;    This procedure is the ISR for the profile sampling interrupt,
;    which for x86 machines is driven off the 8254 timer1 channel 0.
;
;    The procedure scans the list of profile objects, looking for those
;    which match the address space and return program counter captured
;    at entry.  For each object that does match, the counter in its
;    profile buffer matching the bucket the PC falls into is computed,
;    and that counter is incremented.
;
;    N.B. This routine is executed on all processors in a multiprocess
;       system.
;
; Arguments:
;
;    Return Address (esp)
;
;    TrapFrame (esp+4) - supplies pointer to profile trap frame
;
; Environment:
;
;    IRQL = KiProfileIrql
;
;
; Return Value:
;
;    None.
;
;    WARNING: Uses ALL registers
;
;--

cPublicProc _KeProfileInterrupt ,1
;
; rearrange arguments to pass a source of 0 to KeProfileInterruptWithSource
;
        pop     eax     ; return code in eax
        pop     ebx     ; trap frame in ebx
        push    0       ; push source of 0 (ProfileTime)
        push    ebx     ; push trap frame
        push    eax     ; push return address
        jmp     short   _KeProfileInterruptWithSource@8
stdENDP _KeProfileInterrupt

;++
;
; VOID
; KeProfileInterruptWithSource (
;       IN PKTRAP_FRAME TrapFrame,
;       IN KPROFILE_SOURCE ProfileSource
;       )
;
; Routine Description:
;
;    This procedure is the ISR for the multiple-source profile interrupt.
;
;    Since no x86 HAL currently implements any source other than the
;    clock interrupt, this routine is just a stub that calls KeProfileInterrupt
;
; Arguments:
;
;    Return Address (esp)
;
;    TrapFrame (esp+4) - supplies pointer to profile trap frame
;
;    ProfileSource (esp+8) - supplies source of profile interrupt
;
; Environment:
;
;    IRQL = KiProfileIrql
;
;
; Return Value:
;
;    None.
;
;    WARNING: Uses ALL registers
;
;--
cPublicProc _KeProfileInterruptWithSource,2

kipieip         equ     <dword ptr [ebp+TsEip]>
kipsegcs        equ     <word ptr [ebp+TsSegCs]>
kipeflags       equ     <dword ptr [ebp+TsEFlags]>

        mov     ebp, dword ptr [esp+4]  ; (ebp)-> trap frame
        inc     dword ptr PCR[PcPrcbData+PbInterruptCount]

        cmp     _PPerfGlobalGroupMask, 0 ; check if event tracing is on
        je      short kipi03

        ;; add profile interrupt to perfinfo
        mov        ecx, [esp+8]
        mov        edx,kipieip
        fstCall    PerfProfileInterrupt
        mov     ebp, dword ptr [esp+4]  ; (ebp)-> trap frame

;
; Reset EIP if it is found to be within the kernel interlocked pop entry slist
; code.  Otherwise profile objects (queued by the user) could be used to corrupt
; a kernel slist.
;

kipi03:
        cmp     kipieip, offset FLAT:_ExpInterlockedPopEntrySListResume@0
        jb      kipi04
        cmp     kipieip, offset FLAT:_ExpInterlockedPopEntrySListEnd@0
        ja      kipi04
        mov     ecx, ebp
        fstCall KiCheckForSListAddress

kipi04:

ifndef NT_UP
        lea     eax,_KiProfileLock
kipi05: ACQUIRE_SPINLOCK    eax,kipi96
endif

;
;   Update profile data
;
;   NOTE:
;   System and Process update loops are duplicates, to avoid overhead
;   of call instruction in what could be very high freq. interrupt.
;   be sure to update both loops for changes.
;
;   NOTE:
;   The process loop contains code to update segment profile objects.
;   This code is not present in the system loop, because we do not
;   allow attachment of profile objects for non-flat segments on a
;   system wide basis.
;
;   NOTE:
;   Profiling in V86 mode is handled by converting the CS:IP value to
;   a linear address (CS<<4 + IP)
;

        inc     ProfileCount            ; total number of hits

;
;   Update system profile entries
;

        mov     ebx, kipieip
        mov     edx,offset FLAT:_KiProfileListHead
        mov     esi,[edx].LsFlink       ; (esi) -> profile object
ifndef NT_UP
        mov     edi, PCR[PcSetMember]   ; (edi) = current processor
endif
        mov     ecx, [esp+8]            ; (cx) = profile source
        cmp     esi,edx
        je      kipi30                  ; end of system list, go do process

;
;   (ebx) = sample program counter
;   (esi) -> profile object
;

ALIGN 4
kipi10: cmp     ebx,[esi+PfRangeBase-PfProfileListEntry]    ; >= base?
        jb      kipi20                                      ; no, skip entry
        cmp     ebx,[esi+PfRangeLimit-PfProfileListEntry]   ; < limit?
        jae     kipi20                                      ; no, skip entry
        cmp     cx,word ptr [esi+PfSource-PfProfileListEntry]       ; == source?
        jne     kipi20                                      ; no, skip entry
ifndef NT_UP
        test    edi,[esi+PfAffinity-PfProfileListEntry]     ; affinity match?
        jz      kipi20                                      ; no, skip entry
endif

;
;   RangeBase <= program counter < RangeLimit, we have a hit
;

        sub     ebx,[esi+PfRangeBase-PfProfileListEntry]    ; (ebx) = offset in profile range
        mov     cl,[esi+PfBucketShift-PfProfileListEntry]
        shr     ebx,cl
        and     ebx,NOT 3               ; (ebx) = offset of counter for bucket
        mov     edi,[esi+PfBuffer-PfProfileListEntry] ; (edi) -> buffer
        inc     dword ptr [edi+ebx]     ; record hit
        mov     ebx, kipieip            ; (ebx) = sample pc
        mov     ecx, [esp+8]            ; (cx) = profile source
ifndef NT_UP
        mov     edi, PCR[PcSetMember]   ; (edi) = current processor
endif


;
;   Go to next entry
;

ALIGN 4
kipi20: mov     esi,[esi].LsFlink       ; (esi) -> profile object
        cmp     esi,edx
        jne     kipi10                  ; not end of list, repeat


;
;   Update process profile entries
;   (ebx) = sample program counter
;

ALIGN 4
kipi30: mov     eax,PCR[PcPrcbData+PbCurrentThread] ; (eax)-> current thread
        mov     eax,ThApcState+AsProcess[eax]       ; (eax)-> current process
        lea     edx,[eax]+PrProfileListHead         ; (edx)-> listhead
        mov     esi,[edx].LsFlink                   ; (esi)-> profile object
        cmp     esi,edx
        je      kipi60                              ; process list end, return

;
;   Check for 16 bitness
;
        movzx   ecx,word ptr kipsegcs
        test    kipeflags,EFLAGS_V86_MASK
        jnz     kipi100                             ; convert cs:ip to linear

        cmp     cx,KGDT_R0_CODE
        je      short kipi40

        cmp     cx,KGDT_R3_CODE or RPL_MASK
        jne     kipi110

;
;   (ebx) = sample program counter
;   (esi) -> profile object
;

ALIGN 4
kipi40: cmp     [esi+PfSegment-PfProfileListEntry],word ptr 0 ; flat object?
        jne     kipi50                                      ; no, skip entry
        cmp     ebx,[esi+PfRangeBase-PfProfileListEntry]    ; >= base?
        jb      kipi50                                      ; no, skip entry
        cmp     ebx,[esi+PfRangeLimit-PfProfileListEntry]   ; < limit?
        jae     kipi50                                      ; no, skip entry
        mov     ecx, [esp+8]                                ; (cx) = profile source
        cmp     cx,word ptr [esi+PfSource-PfProfileListEntry]       ; == source?
        jne     kipi50                                      ; no, skip entry
ifndef NT_UP
        mov     edi,PCR[PcSetMember]                        ; (edi) = set member
        test    edi,[esi+PfAffinity-PfProfileListEntry]     ; affinity match?
        jz      kipi50                                      ; no, skip entry
endif


;
;   RangeBase <= program counter < RangeLimit, we have a hit
;

        sub     ebx,[esi+PfRangeBase-PfProfileListEntry]    ; (ebx) = offset in profile range
        mov     cl,[esi+PfBucketShift-PfProfileListEntry]
        shr     ebx,cl
        and     ebx,NOT 3               ; (ebx) = offset of counter for bucket
        mov     edi,[esi+PfBuffer-PfProfileListEntry] ; (edi) -> buffer
        inc     dword ptr [edi+ebx]     ; record hit
        mov     ebx, kipieip            ; (ebx) = sample pc
        mov     ecx, [esp+8]                                ; (cx) = profile source

;
;   Go to next entry
;

ALIGN 4
kipi50: mov     esi,[esi].LsFlink       ; (esi) -> profile object
        cmp     esi,edx
        jne     kipi40                  ; not end of list, repeat

ALIGN 4
kipi60:

ifndef  NT_UP
        lea     eax,_KiProfileLock
        RELEASE_SPINLOCK    eax
endif
        stdRet  _KeProfileInterruptWithSource

ifndef NT_UP
ALIGN 4
kipi96: SPIN_ON_SPINLOCK    eax,kipi05,,DbgMp
endif

ALIGN 4
kipi100:
        shl     ecx,4                   ; segment -> paragraph
        add     ebx,ecx                 ; paragraph offset -> linear
        jmp     kipi40

;
;   Update segment profile objects
;

;
;   (ebx) = sample program counter
;   (esi) -> profile object
;

ALIGN 4
kipi110:
        cmp     [esi+PfSegment-PfProfileListEntry],ecx      ; This segment?
        jne     kipi120                                     ; no, skip entry
        cmp     ebx,[esi+PfRangeBase-PfProfileListEntry]    ; >= base?
        jb      kipi120                                     ; no, skip entry
        cmp     ebx,[esi+PfRangeLimit-PfProfileListEntry]   ; < limit?
        jae     kipi120                                     ; no, skip entry
        mov     ecx, [esp+8]                                ; (cx) = profile source
        cmp     cx,word ptr [esi+PfSource-PfProfileListEntry]       ; == source?
        jne     kipi120                                     ; no, skip entry
ifndef NT_UP
        mov     edi,PCR[PcSetMember]                        ; (edi) = set member
        test    edi,[esi+PfAffinity-PfProfileListEntry]     ; affinity match?
        jnz     kipi120                                     ; no, skip entry
endif

;
;   RangeBase <= program counter < RangeLimit, we have a hit
;

        sub     ebx,[esi+PfRangeBase-PfProfileListEntry]    ; (ebx) = offset in profile range
        mov     cl,[esi+PfBucketShift-PfProfileListEntry]
        shr     ebx,cl
        and     ebx,NOT 3               ; (ebx) = offset of counter for bucket
        mov     edi,[esi+PfBuffer-PfProfileListEntry] ; (edi) -> buffer
        inc     dword ptr [edi+ebx]     ; record hit
        mov     ebx, kipieip            ; (ebx) = sample pc
        mov     cx,kipsegcs             ; ecx = sample cs

;
;   Go to next entry
;

ALIGN 4
kipi120:
        mov     esi,[esi].LsFlink       ; (esi) -> profile object
        cmp     esi,edx
        jne     kipi110                 ; not end of list, repeat

        jmp     kipi60

stdENDP _KeProfileInterruptWithSource
_TEXT$00   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ke\i386\emv86.asm ===
title  "Vdm Instuction Emulation"
;++
;
; Copyright (c) Microsoft Corporation. All rights reserved. 
;
; You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
; If you do not agree to the terms, do not use the code.
;
;
; Module Name:
;
;    emv86.asm
;
; Abstract:
;
;    This module contains the routines for emulating instructions and
;    faults from v86 mode.
;
;--
.386p
        .xlist
include ks386.inc
include i386\kimacro.inc
include mac386.inc
include i386\mi.inc
include callconv.inc
include ..\..\vdm\i386\vdm.inc
include vdmtib.inc
include irqli386.inc
        .list

        extrn   VdmOpcode0f:proc
        extrn   _DbgPrint:proc
        extrn   _KeI386VirtualIntExtensions:dword
        EXTRNP  _Ki386VdmDispatchIo,5
        EXTRNP  _Ki386VdmDispatchStringIo,8
        EXTRNP  _KiDispatchException,5
        EXTRNP  _Ki386VdmReflectException,1
        EXTRNP  _VdmEndExecution,2
        EXTRNP  _VdmDispatchBop,1
        EXTRNP  _VdmPrinterStatus,3
        EXTRNP  _VdmPrinterWriteData, 3
        EXTRNP  _VdmDispatchInterrupts,2
        EXTRNP  _KeBugCheck,1
        EXTRNP  _VdmSkipNpxInstruction,4
        EXTRNP  _VdmFetchBop1,1
        EXTRNP _Ki386AdjustEsp0,1

ifdef VDMDBG
        EXTRNP  _VdmTraceEvent,4
endif

        extrn   _ExVdmOpcodeDispatchCounts:dword
        extrn   OpcodeIndex:byte
        extrn   _VdmUserCr0MapIn:byte

        extrn   _MmUserProbeAddress:DWORD


        page ,132

ifdef VDMDBG
%out Debugging version
endif

;   Force assume into place

_PAGE   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME DS:NOTHING, ES:NOTHING, SS:NOTHING, FS:NOTHING, GS:NOTHING
_PAGE   ENDS

_TEXT$00   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME DS:NOTHING, ES:NOTHING, SS:NOTHING, FS:NOTHING, GS:NOTHING
_TEXT$00   ENDS

PAGEDATA   SEGMENT  DWORD PUBLIC 'DATA'

;
;  Instruction emulation emulates the following instructions.
;  The emulation affects the noted user mode registers.
;
;
;  In V86 mode, the following instruction are emulated in the kernel
;
;    Registers  (E)Flags (E)SP  SS  CS
;       PUSHF      X       X
;       POPF       X       X
;       INTnn      X       X         X
;       INTO       X       X         X
;       IRET       X       X         X
;       CLI        X
;       STI        X
;
;
;       INSB
;       INSW
;       OUTSB
;       OUTSW
;       INBimm
;       INWimm
;       OUTBimm
;       OUTWimm
;       INB
;       INW
;       OUTB
;       OUTW
;
;  WARNING What do we do about 32 bit io instructions??


;       OpcodeDispatchV86 - table of routines used to emulate instructions
;                           in v86 mode.

        public OpcodeDispatchV86
dtBEGIN OpcodeDispatchV86,OpcodeInvalidV86
        dtS    VDM_INDEX_0F              , Opcode0FV86
        dtS    VDM_INDEX_ESPrefix        , OpcodeESPrefixV86
        dtS    VDM_INDEX_CSPrefix        , OpcodeCSPrefixV86
        dtS    VDM_INDEX_SSPrefix        , OpcodeSSPrefixV86
        dtS    VDM_INDEX_DSPrefix        , OpcodeDSPrefixV86
        dtS    VDM_INDEX_FSPrefix        , OpcodeFSPrefixV86
        dtS    VDM_INDEX_GSPrefix        , OpcodeGSPrefixV86
        dtS    VDM_INDEX_OPER32Prefix    , OpcodeOPER32PrefixV86
        dtS    VDM_INDEX_ADDR32Prefix    , OpcodeADDR32PrefixV86
        dtS    VDM_INDEX_INSB            , OpcodeINSBV86
        dtS    VDM_INDEX_INSW            , OpcodeINSWV86
        dtS    VDM_INDEX_OUTSB           , OpcodeOUTSBV86
        dtS    VDM_INDEX_OUTSW           , OpcodeOUTSWV86
        dtS    VDM_INDEX_PUSHF           , OpcodePUSHFV86
        dtS    VDM_INDEX_POPF            , OpcodePOPFV86
        dtS    VDM_INDEX_INTnn           , OpcodeINTnnV86
        dtS    VDM_INDEX_INTO            , OpcodeINTOV86
        dtS    VDM_INDEX_IRET            , OpcodeIRETV86
        dts    VDM_INDEX_NPX             , OpcodeNPXV86
        dtS    VDM_INDEX_INBimm          , OpcodeINBimmV86
        dtS    VDM_INDEX_INWimm          , OpcodeINWimmV86
        dtS    VDM_INDEX_OUTBimm         , OpcodeOUTBimmV86
        dtS    VDM_INDEX_OUTWimm         , OpcodeOUTWimmV86
        dtS    VDM_INDEX_INB             , OpcodeINBV86
        dtS    VDM_INDEX_INW             , OpcodeINWV86
        dtS    VDM_INDEX_OUTB            , OpcodeOUTBV86
        dtS    VDM_INDEX_OUTW            , OpcodeOUTWV86
        dtS    VDM_INDEX_LOCKPrefix      , OpcodeLOCKPrefixV86
        dtS    VDM_INDEX_REPNEPrefix     , OpcodeREPNEPrefixV86
        dtS    VDM_INDEX_REPPrefix       , OpcodeREPPrefixV86
        dtS    VDM_INDEX_CLI             , OpcodeCLIV86
        dtS    VDM_INDEX_STI             , OpcodeSTIV86
        dtS    VDM_INDEX_HLT             , OpcodeHLTV86
dtEND   MAX_VDM_INDEX

PAGEDATA   ENDS

_PAGE   SEGMENT DWORD USE32 PUBLIC 'CODE'
        ASSUME DS:NOTHING, ES:NOTHING, SS:FLAT, FS:NOTHING, GS:NOTHING

        page   ,132
        subttl "Overide Prefix Macro"
;++
;
;   Routine Description:
;
;       This macro generates the code for handling override prefixes
;       The routine name generated is OpcodeXXXXPrefix, where XXXX is
;       the name used in the macro invocation.  The code will set the
;       PREFIX_XXXX bit in the Prefix flags.
;
;   Arguments
;       name = name of prefix
;       esi = address of reg info
;       edx = opcode
;
;   Returns
;       user mode Eip advanced
;       eax advanced
;       edx contains next byte of opcode
;
;   NOTE: This routine exits by dispatching through the table again.
;--
opPrefix macro name
        public Opcode&name&PrefixV86
Opcode&name&PrefixV86 proc

        or      ebx,PREFIX_&name


ifdef VDMDBG
_DATA segment
Msg&name&Prefix db 'NTVDM: Encountered override prefix &name& %lx at '
                db 'address %lx', 0ah, 0dh, 0
_DATA ends

        push    [ebp].TsEip
        push    [ebp].TsSegCs
        push    offset FLAT:Msg&name&Prefix
        call    _DbgPrint
        add     esp,12

endif

        jmp     OpcodeGenericPrefixV86   ; dispatch to next handler

Opcode&name&PrefixV86 endp
endm

irp prefix, <ES, CS, SS, DS, FS, GS, OPER32, ADDR32, LOCK, REPNE, REP>

        opPrefix prefix

endm

        page   ,132
        subttl "Instruction Emulation Dispatcher for V86"
;++
;
;   Routine Description:
;
;       This routine dispatches to the opcode specific emulation routine,
;       based on the first byte of the opcode.  Two byte opcodes, and prefixes
;       result in another level of dispatching, from the handling routine.
;       This code is called at APC_LEVEL to prevent modifications to the
;       trap frame from NtSetContextThread.
;
;   Arguments:
;
;       [esp+4] = pointer to trap frame
;
;   Returns:
;
;       EAX = 0 failure
;             1 success

cPublicProc _Ki386DispatchOpcodeV86,1

        push    ebp
        mov     ebp, [esp+8]
        movzx   esi,word ptr [ebp].TsSegCs
        shl     esi,4
        and     dword ptr [ebp].TsEip, 0FFFFH
        and     dword ptr [ebp].TsHardwareEsp, 0FFFFH
        add     esi,[ebp].TsEip
        ;
        ; Probe and fetch the first byte from the instruction stream.
        ; Since we should be at APC_LEVEL here the trap frame can't be
        ; modified by the set context code. We don't have to capture.
        ;
        stdCall _VdmFetchBop1, <esi>
        movzx   edx, OpcodeIndex[eax]   ;get opcode index

        mov     edi,1
        xor     ebx,ebx

        ; All handler routines will get the following on entry
        ; ebx -> prefix flags
        ; ebp -> trap frame
        ; cl  -> byte at the faulting address
        ; interrupts enabled and Irql at APC level
        ; esi -> address of faulting instruction
        ; edi -> instruction length count
        ; All handler routines return
        ; EAX = 0 for failure
        ; EAX = 1 for success

if DEVL
        inc     _ExVdmOpcodeDispatchCounts[edx * type _ExVdmOpcodeDispatchCounts]
endif
ifdef VDMDBG
        pushad
        stdCall _VdmTraceEvent, <VDMTR_KERNEL_OP_V86,ecx,0,ebp>
        popad
endif
        call    dword ptr OpcodeDispatchV86[edx * type OpcodeDispatchV86]
        pop     ebp
        stdRet  _Ki386DispatchOpcodeV86

stdENDP _Ki386DispatchOpcodeV86


        page   ,132
        subttl "Invalid Opcode Handler"
;++
;
;   Routine Description:
;
;       This routine emulates an invalid opcode.  It prints the invalid
;       opcode message, and causes a GP fault to be reflected to the
;       debuger
;
;   Arguments:
;       EBX -> prefix flags
;       EBP -> trap frame
;       CL  -> byte at the faulting address
;       interrupts disabled
;       ESI -> address of faulting instruction
;       EDI -> instruction length count
;
;   Returns:
;       EAX = 0 for failure
;       EAX = 1 for success
;
;   All registers can be trashed except ebp/esp.
;

        public OpcodeInvalidV86
OpcodeInvalidV86 proc

        xor     eax,eax                 ; ret fail
        ret

OpcodeInvalidV86 endp


        page   ,132
        subttl "Generic Prefix Handler"
;++
;
;   Routine Description:
;
;       This routine handles the generic portion of all of the prefixes,
;       and dispatches the next byte of the opcode.
;
;   Arguments:
;
;       EBX -> prefix flags
;       EBP -> trap frame
;       CL  -> byte at the faulting address
;       interrupts disabled
;       ESI -> address of faulting instruction
;       EDI -> instruction length count
;
;   Returns:
;       EAX = 0 for failure
;       EAX = 1 for success
;
;   All registers can be trashed except ebp/esp.
;

        public OpcodeGenericPrefixV86
OpcodeGenericPrefixV86 proc

        inc     esi
        inc     edi
        movzx   ecx, byte ptr [esi]
        movzx   edx, OpcodeIndex[ecx]   ;get opcode index
if DEVL
        inc     _ExVdmOpcodeDispatchCounts[edx * type _ExVdmOpcodeDispatchCounts]
endif
        jmp     OpcodeDispatchV86[edx * type OpcodeDispatchV86]

OpcodeGenericPrefixV86 endp


        page   ,132
        subttl "Byte string in Opcode Handler"
;++
;
;   Routine Description:
;
;       This routine emulates an INSB opcode.  Currently, it prints
;       a message, and ignores the instruction.
;
;   Arguments:
;       EBX -> prefix flags
;       EBP -> trap frame
;       CL  -> byte at the faulting address
;       interrupts disabled
;       ESI -> address of faulting instruction
;       EDI -> instruction length count
;
;   Returns:
;       EAX = 0 for failure
;       EAX = 1 for success
;
;   All registers can be trashed except ebp/esp.
;
;  WARNING size override?  ds override?

        public OpcodeINSBV86
OpcodeINSBV86 proc

        push    ebp                     ; trap frame
        push    edi                     ; size of insb
        movzx   eax,word ptr [ebp].TsV86Es
        shl     eax,16
        movzx   ecx,word ptr [ebp].TsEdi
        or      eax,ecx
        push    eax                     ; address
        mov     eax,1
        xor     ecx, ecx
        test    ebx,PREFIX_REP          ; prefixREP
        jz      oisb20

        mov     ecx, 1
        movzx   eax,word ptr [ebp].TsEcx
oisb20:
        push    eax                     ; number of io ops
        push    TRUE                    ; read op
        push    ecx                     ; REP prefix ?
        push    1                       ; byte op
        movzx   eax,word ptr [ebp].TsEdx
        push    eax                     ; port number

        ; Ki386VdmDispatchStringIo enables interrupts
        call    _Ki386VdmDispatchStringIo@32 ; use retval
        ret

OpcodeINSBV86 endp

        page   ,132
        subttl "Word String In Opcode Handler"
;++
;
;   Routine Description:
;
;       This routine emulates an INSW opcode.  Currently, it prints
;       a message, and ignores the instruction.
;
;   Arguments:
;
;       EBX -> prefix flags
;       EBP -> trap frame
;       CL  -> byte at the faulting address
;       interrupts disabled
;       ESI -> address of faulting instruction
;       EDI -> instruction length count
;
;   Returns:
;       EAX = 0 for failure
;       EAX = 1 for success
;
;   All registers can be trashed except ebp/esp.
;

        public OpcodeINSWV86
OpcodeINSWV86 proc

        push    ebp                     ; trap frame
        push    edi                     ; size of insw
        movzx   eax,word ptr [ebp].TsV86Es
        shl     eax,16
        movzx   ecx,word ptr [ebp].TsEdi
        or      eax,ecx
        push    eax                     ; address
        mov     eax,1
        xor     ecx, ecx
        test    ebx,PREFIX_REP          ; prefixREP
        jz      oisw20

        mov     ecx, 1
        movzx   eax,word ptr [ebp].TsEcx
oisw20:
        push    eax                     ; number of io ops
        push    TRUE                    ; read op
        push    ecx                     ; REP prefix ?
        push    2                       ; word op
        movzx   eax,word ptr [ebp].TsEdx
        push    eax                     ; port number

        ; Ki386VdmDispatchStringIo enables interrupts
        call    _Ki386VdmDispatchStringIo@32 ; use retval
        ret

OpcodeINSWV86 endp

        page   ,132
        subttl "Byte String Out Opcode Handler"
;++
;
;   Routine Description:
;
;       This routine emulates an OUTSB opcode.  Currently, it prints
;       a message, and ignores the instruction.
;
;   Arguments:
;
;       EBX -> prefix flags
;       EBP -> trap frame
;       CL  -> byte at the faulting address
;       interrupts disabled
;       ESI -> address of faulting instruction
;       EDI -> instruction length count
;
;   Returns:
;       EAX = 0 for failure
;       EAX = 1 for success
;
;   All registers can be trashed except ebp/esp.
;

        public OpcodeOUTSBV86
OpcodeOUTSBV86 proc

        push    ebp                     ; trap frame
        push    edi                     ; size of outsb
        movzx   eax,word ptr [ebp].TsV86Ds
        shl     eax,16
        movzx   ecx,word ptr [ebp].TsEsi
        or      eax,ecx
        push    eax                     ; address
        mov     eax,1
        xor     ecx, ecx
        test    ebx,PREFIX_REP          ; prefixREP
        jz      oosb20

        mov     ecx, 1
        movzx   eax,word ptr [ebp].TsEcx
oosb20:
        push    eax                     ; number of io ops
        push    FALSE                   ; write op
        push    ecx                     ; REP prefix ?
        push    1                       ; byte op
        movzx   eax,word ptr [ebp].TsEdx
        push    eax                     ; port number

        ; Ki386VdmDispatchStringIo enables interrupts
        call    _Ki386VdmDispatchStringIo@32 ; use retval
        ret

OpcodeOUTSBV86 endp

        page   ,132
        subttl "Word String Out Opcode Handler"
;++
;
;   Routine Description:
;
;       This routine emulates an OUTSW opcode.  Currently, it prints
;       a message, and ignores the instruction
;
;   Arguments:
;
;       EBX -> prefix flags
;       EBP -> trap frame
;       CL  -> byte at the faulting address
;       interrupts disabled
;       ESI -> address of faulting instruction
;       EDI -> instruction length count
;
;   Returns:
;       EAX = 0 for failure
;       EAX = 1 for success
;
;   All registers can be trashed except ebp/esp.
;

        public OpcodeOUTSWV86
OpcodeOUTSWV86 proc

        push    ebp                     ; trap frame
        push    edi                     ; size of outsw
        movzx   eax,word ptr [ebp].TsV86Ds
        shl     eax,16
        movzx   ecx,word ptr [ebp].TsEsi
        or      eax,ecx
        push    eax                     ; address

        mov     eax,1
        xor     ecx, ecx
        test    ebx,PREFIX_REP          ; prefixREP
        jz      oosw20

        mov     ecx, 1
        movzx   eax,word ptr [ebp].TsEcx
oosw20:
        push    eax                     ; number of io ops
        push    FALSE                   ; write op
        push    ecx                     ; REP prefix ?
        push    2                       ; word op
        movzx   eax,word ptr [ebp].TsEdx
        push    eax                     ; port number

        ; Ki386VdmDispatchStringIo enables interrupts
        call    _Ki386VdmDispatchStringIo@32 ; use retval
        ret

OpcodeOUTSWV86 endp

        page   ,132
        subttl "PUSHF Opcode Handler"
;++
;
;   Routine Description:
;
;       This routine emulates an PUSHF opcode.  Currently, it prints
;       a message, and simulates the instruction.
;
;       Get SS
;       shift left 4
;       get SP
;       subtract 2
;       get flags
;       put in virtual interrupt flag
;       put on stack
;       update sp
;
;   Arguments:
;       EBX -> prefix flags
;       EBP -> trap frame
;       CL  -> byte at the faulting address
;       interrupts disabled
;       ESI -> address of faulting instruction
;       EDI -> instruction length count
;
;   Returns:
;       EAX = 0 for failure
;       EAX = 1 for success
;
;   All registers can be trashed except ebp/esp.
;
        public OpcodePUSHFV86
OpcodePUSHFV86 proc

        test    _KeI386VirtualIntExtensions, dword ptr V86_VIRTUAL_INT_EXTENSIONS
        jz      short puf00

        mov     eax,dword ptr [ebp].TsEFlags
        lea     ecx,ds:FIXED_NTVDMSTATE_LINEAR
        or      dword ptr [ecx], VDM_VIRTUAL_INTERRUPTS
        test    eax, EFLAGS_VIF         ; Is vif on
        jnz     short puf03

        and     dword ptr [ecx], NOT VDM_VIRTUAL_INTERRUPTS
        and     eax, NOT EFLAGS_INTERRUPT_MASK
        jmp     short puf03

puf00:
        lea     eax,ds:FIXED_NTVDMSTATE_LINEAR

        mov     edx,dword ptr [ebp].TsEFlags
        mov     eax, dword ptr [eax]         ; get virtual int flag
        and     edx,NOT EFLAGS_INTERRUPT_MASK
        and     eax,VDM_VIRTUAL_INTERRUPTS OR VDM_VIRTUAL_AC OR VDM_VIRTUAL_NT
        or      eax,edx
        or      eax,EFLAGS_IOPL_MASK
puf03:
        movzx   ecx,word ptr [ebp].TsHardwareSegSS
        movzx   edx,word ptr [ebp].TsHardwareEsp
        shl     ecx,4
        sub     dx,2

        test    ebx,PREFIX_OPER32               ; check operand size
        jnz     puf10

        mov     [ecx + edx],ax
puf05:
        mov     word ptr [ebp].TsHardwareEsp,dx ; update client esp
        add     dword ptr [ebp].TsEip,edi

        mov     eax, ds:FIXED_NTVDMSTATE_LINEAR
        test    eax, VDM_VIRTUAL_INTERRUPTS
        jz      short @f

        test    eax, VDM_INTERRUPT_PENDING
        jz      short @f

        call    VdmDispatchIntAck
@@:
        mov     eax,1
        ret

puf10:  sub     dx,2
        mov     [ecx + edx],eax
        jmp     puf05

OpcodePUSHFV86 endp

        page   ,132
        subttl "POPF Opcode Handler"
;++
;
;   Routine Description:
;
;       This routine emulates an POPF opcode.  Currently, it prints
;       a message, and returns to the monitor.
;
;   Arguments:
;       EBX -> prefix flags
;       EBP -> trap frame
;       CL  -> byte at the faulting address
;       interrupts disabled
;       ESI -> address of faulting instruction
;       EDI -> instruction length count
;
;   Returns:
;       EAX = 0 for failure
;       EAX = 1 for success
;
;   All registers can be trashed except ebp/esp.
;

        public OpcodePOPFV86
OpcodePOPFV86 proc

if DBG
        ; Mods to the trap frame need to be protected from thread context changes
        CurrentIrql
        cmp      al, APC_LEVEL
        jge      @f
        int      3
@@:
endif


        lea     eax,ds:FIXED_NTVDMSTATE_LINEAR      ; get pointer to VDM State
        mov     ecx,[ebp].TsHardwareSegSS
        movzx   edx,word ptr [ebp].TsHardwareEsp
        shl     ecx,4
        mov     ecx,[ecx + edx]          ; get flags from stack => ecx
        add     edx,4
        test    ebx,PREFIX_OPER32        ; check operand size
        jnz     pof10
        and     ecx,0ffffh               ; only lower 16 bit for 16bit code
        sub     edx,2
pof10:
        mov     [ebp].TsHardwareEsp,edx

        and     ecx, NOT EFLAGS_IOPL_MASK
        mov     ebx,ecx                  ; [ebx]=[ecx]=user EFLAGS - IOPL
        and     ebx, NOT EFLAGS_NT_MASK  ; [ebx]=user eflags - iopl - NT
        and     ecx, (EFLAGS_INTERRUPT_MASK OR EFLAGS_ALIGN_CHECK OR EFLAGS_NT_MASK)

        ; [ecx]=IF + AC + NT of User eflgs
        ; [ebx]=User eflgs - IOPL - NT

        test    _KeI386VirtualIntExtensions, dword ptr V86_VIRTUAL_INT_EXTENSIONS
        jz      short pof15

        and     ebx, NOT (EFLAGS_VIP + EFLAGS_VIF)
                                         ; [ebx]=UserFlg -IOPL - NT - VIP - VIF
        test    ebx, EFLAGS_INTERRUPT_MASK
        jz      short @f

        or      ebx, EFLAGS_VIF          ; [ebx]=UserFlg-IOPL-NT-VIP+VIF
@@:
        or      ebx, (EFLAGS_INTERRUPT_MASK OR EFLAGS_V86_MASK) ;[ebx]=UserFlg-IOPL-NT-VIP+VIF+IF
        push    eax
        mov     eax, [ebp].TsEFlags
        push    eax
        and     eax, EFLAGS_VIP
        or      eax, ebx
        mov     [ebp].TsEFlags, eax
        jmp     short pof20

pof15:
        push    eax
        or      ebx, (EFLAGS_INTERRUPT_MASK OR EFLAGS_V86_MASK)
        push   [ebp].TsEFlags
        mov     [ebp].TsEFlags, ebx
pof20:  
if DBG
	test	ebx, EFLAGS_V86_MASK	; Subset of value written to EFLAGs
	jnz	short @f
	int	3			; Should be set along this path!
@@:
endif
;
; It suffices to check whether V86 was present in the previous EFLAGS
; (as V86 is being enabled at this time).
;
.errnz (EFLAGS_V86_MASK AND 0FF00FFFFh)
        test    byte ptr [esp].TsEFlags+2,EFLAGS_V86_MASK/010000h
        lea     esp, [esp+4]
        jnz	@f
        stdCall _Ki386AdjustEsp0, <ebp>
@@:
        pop     eax
        MPLOCK and [eax],NOT (EFLAGS_INTERRUPT_MASK OR EFLAGS_ALIGN_CHECK OR EFLAGS_NT_MASK)
        MPLOCK or [eax],ecx
        add     dword ptr [ebp].TsEip,edi

        mov     eax,dword ptr [eax]
        test    eax,VDM_INTERRUPT_PENDING
        jz      pof25

        test    eax,VDM_VIRTUAL_INTERRUPTS
        jz      pof25

        call    VdmDispatchIntAck

pof25:
        mov     eax,1                    ; handled
        ret
OpcodePOPFV86 endp

        page   ,132
        subttl "INTnn Opcode Handler"
;++
;
;   Routine Description:
;
;       This routine emulates an INTnn opcode.  It retrieves the handler
;       from the IVT, pushes the current cs:ip and flags on the stack,
;       and dispatches to the handler.
;
;   Arguments:
;       EBX -> prefix flags
;       EBP -> trap frame
;       CL  -> byte at the faulting address
;       interrupts disabled
;       ESI -> address of faulting instruction
;       EDI -> instruction length count
;
;   Returns:
;       EAX = 0 for failure
;       EAX = 1 for success
;
;   All registers can be trashed except ebp/esp.
;

        public OpcodeINTnnV86
OpcodeINTnnV86 proc

;
; Int nn in v86 mode always disables interrupts
;

        mov     edx,[ebp].TsEflags

        lea     eax,ds:FIXED_NTVDMSTATE_LINEAR   ; get pointer to VDM State
        mov     ecx,dword ptr [eax]       ;[ecx]=vdmstate
        MPLOCK and [eax],NOT VDM_VIRTUAL_INTERRUPTS

        mov     eax, edx
        and     eax, NOT EFLAGS_INTERRUPT_MASK
.errnz (EFLAGS_INTERRUPT_MASK - VDM_VIRTUAL_INTERRUPTS)
        and     ecx, VDM_VIRTUAL_INTERRUPTS OR VDM_VIRTUAL_AC

        ; [edx]=eflags
        ; [eax]=eflgs-if
        ; [ecx]=IF + AC of vdmstate

        test    _KeI386VirtualIntExtensions, dword ptr V86_VIRTUAL_INT_EXTENSIONS
        jz      short oinnv15

        ;
        ;VIF extension is enabled, we should migrate EFLAGS_VIF instead of
        ;VDM_VIRTUAL_INTERRUPT to the iret frame eflags IF.
        ;When VIF extension is enabled, RI_BIT_MASK is turned on. This in turn,
        ;redirects the FCLI/FSTI macro to execute cli/sti directly instead
        ;of simulation. Without this, we might disable v86 mode interrupt
        ;without the applications knowing it.
        ;

        and     ecx, VDM_VIRTUAL_AC         ;keep VDM_VIRTUAL_AC only
        or      eax, ecx                    ;[eax]=eflags + ac -if
        mov     ecx, edx
        and     ecx, EFLAGS_VIF
.errnz  ((EFLAGS_VIF SHR 10) - EFLAGS_INTERRUPT_MASK)
        ror     ecx, 10                     ;VIF -> IF
oinnv15:
        or      eax, ecx                    ;[eax]=eflags +ac +if

oinnv20:
        and     edx,NOT (EFLAGS_NT_MASK OR EFLAGS_TF_MASK OR EFLAGS_VIF)
        mov     [ebp].TsEflags,edx

        or      eax, EFLAGS_IOPL_MASK
        movzx   ecx,word ptr [ebp].TsHardwareSegSS
        shl     ecx,4
        movzx   edx,word ptr [ebp].TsHardwareEsp    ; ecx+edx is user stack
        sub     dx,2
        mov     word ptr [ecx+edx],ax       ; push flags
        mov     ax,word ptr [ebp].TsSegCS
        sub     dx,2
        mov     word ptr [ecx+edx],ax       ; push cs
        movzx   eax,word ptr [ebp].TsEip
        add     eax, edi
        inc     eax
        sub     dx,2
        mov     word ptr [ecx+edx],ax       ; push ip
        mov     [ebp].TsHardwareEsp,dx      ; update sp on trap frame

        inc     esi
        movzx   ecx,byte ptr [esi]          ; ecx is int#

        ;
        ; Check if this is a v86 interrupt which must be reflected to a PM handler
        ;

        push    ecx
        call    oinnvuserrefs               ; do user refs under a try/except block
        or      eax, eax
        pop     ecx
        je      short oinnv30

        ;
        ; Encode interrupt number in cs
        ;

        mov     eax,ebx
        shr     eax,16                      ; bop cs
        sub     eax,ecx                     ; new cs
        shl     ecx,4
        add     ebx,ecx                     ; new ip
        jmp     short oinnv40
oinnv30:
        ;
        ; Not hooked, just pick up new vector from RM IVT
        ;

        mov     ebx,[ecx*4]
        mov     eax,ebx
        shr     eax,16                      ; new cs
oinnv40:
        mov     word ptr [ebp].TsEip,bx
        test    dword ptr [ebp]+TsEFlags,EFLAGS_V86_MASK
        jnz     @f
        or      ax, RPL_MASK
        cmp     ax, 8
        jae     @f
        mov     ax, KGDT_R3_CODE OR RPL_MASK
@@:
        mov     [ebp].TsSegCs,ax            ; cs:ip on trap frame is updated

        mov     eax,1
        ret

OpcodeINTnnV86 endp

oinnvuserrefs proc
        push    ebp
        push    offset oinnvuserrefs_fault  ; Set Handler address
        push    PCR[PcExceptionList]        ; Set next pointer
        mov     PCR[PcExceptionList],esp    ; Link us on

        mov     eax,PCR[PcTeb]
        mov     eax,[eax].TeVdm             ; get pointer to VdmTib
        cmp     eax, _MmUserProbeAddress    ; Probe the TeVdm
        jae     short oinnvuserrefs_fault_resume

        mov     ebx,[eax].VtInterruptTable  ;
        cmp     ebx, 0                      ; there is no interrupt table
        je      short oinnvuserrefs_fault_resume  ; so, don't reflect it.

        lea     ebx,[ebx + ecx*8]
        cmp     ebx, _MmUserProbeAddress    ; Probe the TeVdm
        jae     short oinnvuserrefs_fault_resume

        test    [ebx].ViFlags, VDM_INT_HOOKED    ; need to reflect to PM?
        jz      short oinnvuserrefs_fault_resume

        lea     ebx,[eax].VtDpmiInfo        ; point to DpmiInfo
        mov     ebx,[ebx].VpDosxRmReflector ; bop to reflect to PM
        mov     eax, 1
        pop     PCR[PcExceptionList]        ; Remove our exception handle
        add     esp, 4                      ; clear stack
        pop     ebp
        ret

oinnvuserrefs_fault_resume:
        pop     PCR[PcExceptionList]        ; Remove our exception handle
        add     esp, 4                      ; clear stack
        pop     ebp
        xor     eax, eax
        ret
oinnvuserrefs endp

oinnvuserrefs_fault proc
;
; WARNING: Here we directly unlink the exception handler from the
; exception registration chain.  NO unwind is performed.  We can take
; this short cut because we know that our handler is a leaf-node.
;

        mov     esp, [esp+8]            ; (esp)-> ExceptionList
        jmp     oinnvuserrefs_fault_resume
oinnvuserrefs_fault endp



        page   ,132
        subttl "INTO Opcode Handler"
;++
;
;   Routine Description:
;
;       This routine emulates an INTO opcode.  Currently, it prints
;       a message, and reflects a GP fault to the debugger.
;
;   Arguments:
;       EBX -> prefix flags
;       EBP -> trap frame
;       CL  -> byte at the faulting address
;       interrupts disabled
;       ESI -> address of faulting instruction
;       EDI -> instruction length count
;
;   Returns:
;       EAX = 0 for failure
;       EAX = 1 for success
;
;   All registers can be trashed except ebp/esp.
;

        public OpcodeINTOV86
OpcodeINTOV86 proc

        xor     eax,eax                 ; ret fail
        ret

OpcodeINTOV86 endp

        page   ,132
        subttl "IRET Opcode Handler"
;++
;
;   Routine Description:
;
;       This routine emulates an IRET opcode.  It retrieves the flags,
;       and new instruction pointer from the stack and puts them into
;       the user context.
;
;
;   Arguments:
;       EBX -> prefix flags
;       EBP -> trap frame
;       CL  -> byte at the faulting address
;       interrupts disabled
;       ESI -> address of faulting instruction
;       EDI -> instruction length count
;
;   Returns:
;       EAX = 0 for failure
;       EAX = 1 for success
;
;   All registers can be trashed except ebp/esp.
;
;

        public OpcodeIRETV86
OpcodeIRETV86 proc

if DBG
        ; Mods to the trap frame need to be protected from thread context changes
        CurrentIrql
        cmp      al, APC_LEVEL
        jge      @f
        int      3
@@:
endif


        lea     eax,ds:FIXED_NTVDMSTATE_LINEAR
        movzx   ecx,word ptr [ebp].TsHardwareSegSS
        movzx   edx,word ptr [ebp].TsHardwareEsp    ; ecx+edx is user stack
        shl     ecx,4
        add     ecx,edx
        test    ebx,PREFIX_OPER32
        jnz     irt50                               ; normally not

        movzx   edi,word ptr [ecx]                  ; get ip value
        mov     [ebp].TsEip,edi
        movzx   esi,word ptr [ecx+2]                ; get cs value
        add     edx,6
        movzx   ebx,word ptr [ecx+4]                ; get flag value
        mov     [ebp].TsHardwareEsp,edx             ; update sp on trap frame
        ;
        ; No validation of SegCs is needed as the V86 bit is always set.
        ;
        mov     [ebp].TsSegCs,esi

irt10:  ; [ebx]=UserFlgs
        and     ebx, NOT (EFLAGS_IOPL_MASK OR EFLAGS_NT_MASK OR EFLAGS_VIP OR EFLAGS_VIF)
        mov     ecx,ebx  ; [ecx]=[ebx]=UserFlgs - IOPL - NT - VIP - VIF

        test    _KeI386VirtualIntExtensions, dword ptr V86_VIRTUAL_INT_EXTENSIONS
        jz      short irt15

        or      ebx, EFLAGS_VIF
        test    ebx, EFLAGS_INTERRUPT_MASK
        jnz     irt15

        and     ebx, NOT EFLAGS_VIF
        ; [ebx] = UserFlgs - IOPL - NT - VIP

irt15:
        push    eax
        or      ebx, (EFLAGS_V86_MASK OR EFLAGS_INTERRUPT_MASK)
        mov     eax, dword ptr [ebp].TsEFlags
        push    eax
        and     eax, EFLAGS_VIP
        or      eax, ebx                  ; update flags in trap frame
        mov     dword ptr [ebp].TsEFlags, eax
        pop     ebx
        test    ebx, EFLAGS_V86_MASK
        jne     @f
        push    ecx
        push    edx
        stdCall _Ki386AdjustEsp0, <ebp>
        pop     edx
        pop     ecx
@@:
        pop     eax
        and     ecx, EFLAGS_INTERRUPT_MASK
        MPLOCK and [eax],NOT VDM_VIRTUAL_INTERRUPTS
        MPLOCK or [eax],ecx
        mov     ebx,[eax]


        ; at this point esi is the cs and edi is the ip where v86 mode
        ; will return. Now we will check if this returning instruction
        ; is a bop. if so we will directly dispatch the bop from here
        ; saving a full round trip. This will be really helpful to
        ; com apps.

        shl     esi,4
        add     esi,edi
        cmp     esi, _MmUserProbeAddress            ; Probe 32 bit value
        jbe     @f
        mov     esi, _MmUserProbeAddress
@@:     mov     ax, word ptr [esi]
        cmp     ax, 0c4c4h
        je      irtbop

        test    ebx,VDM_INTERRUPT_PENDING
        jz      short irt25

        test    ebx,VDM_VIRTUAL_INTERRUPTS
        jz      short irt25

        call    VdmDispatchIntAck       ; VdmDispatchIntAck enables interrupts

irt25:
        mov     eax,1                   ; handled
        ret

        ; ireting to a bop
irtbop:
        stdCall _VdmDispatchBop, <ebp>

        jmp     short irt25

irt50:
        mov     edi, [ecx]                          ; get ip value
        mov     [ebp].TsEip,edi
        movzx   esi,word ptr [ecx+4]                ; get cs value
        add     edx,12
        mov     ebx, [ecx+8]                        ; get flag value
        mov     [ebp].TsSegCs,esi
        mov     [ebp].TsHardwareEsp,edx             ; update sp on trap frame
        jmp     irt10                               ; rejoin the common path

OpcodeIRETV86 endp


        page   ,132
        subttl "In Byte Immediate Opcode Handler"
;++
;
;   Routine Description:
;
;       This routine emulates an in byte immediate opcode.  Currently, it
;       prints a message, and ignores the instruction.
;
;   Arguments:
;       EBX -> prefix flags
;       EBP -> trap frame
;       CL  -> byte at the faulting address
;       interrupts disabled
;       ESI -> address of faulting instruction
;       EDI -> instruction length count
;
;   Returns:
;       EAX = 0 for failure
;       EAX = 1 for success
;
;   All registers can be trashed except ebp/esp.
;

        public OpcodeINBimmV86
OpcodeINBimmV86 proc

        inc     esi
        inc     edi
        movzx   ecx,byte ptr [esi]

        ; Ki386VdmDispatchIo enables interrupts
        stdCall   _Ki386VdmDispatchIo, <ecx, 1, TRUE, edi, ebp>
        ret

OpcodeINBimmV86 endp

        page   ,132
        subttl "Word In Immediate Opcode Handler"
;++
;
;   Routine Description:
;
;       This routine emulates an in word immediate opcode.  Currently, it
;       prints a message, and ignores the instruction.
;
;   Arguments:
;       EAX -> pointer to vdm state in DOS arena
;       EBX -> prefix flags
;       EBP -> trap frame
;       CL  -> byte at the faulting address
;       interrupts disabled
;       ESI -> address of faulting instruction
;       EDI -> instruction length count
;
;   Returns:
;       EAX = 0 for failure
;       EAX = 1 for success
;
;   All registers can be trashed except ebp/esp.
;

        public OpcodeINWimmV86
OpcodeINWimmV86 proc

        inc     esi
        inc     edi
        movzx   ecx,byte ptr [esi]
; edi - instruction size
; TRUE - read op
; 2 - word op
; ecx - port number
        ; Ki386VdmDispatchIo enables interrupts
        stdCall   _Ki386VdmDispatchIo, <ecx, 2, TRUE, edi, ebp>

        ret

OpcodeINWimmV86 endp

        page   ,132
        subttl "Out Byte Immediate Opcode Handler"
;++
;
;   Routine Description:
;
;       This routine emulates an invalid opcode.  Currently, it prints
;       a message, and ignores the instruction.
;
;   Arguments:
;       EAX -> pointer to vdm state in DOS arena
;       EBX -> prefix flags
;       EBP -> trap frame
;       CL  -> byte at the faulting address
;       interrupts disabled
;       ESI -> address of faulting instruction
;       EDI -> instruction length count
;
;   Returns:
;       EAX = 0 for failure
;       EAX = 1 for success
;
;   All registers can be trashed except ebp/esp.
;

        public OpcodeOUTBimmV86
OpcodeOUTBimmV86 proc

        inc     edi
        inc     esi
        movzx   ecx,byte ptr [esi]
; edi - instruction size
; FALSE - write op
; 1 - byte op
; ecx - port #
        ; Ki386VdmDispatchIo enables interrupts
        stdCall   _Ki386VdmDispatchIo, <ecx, 1, FALSE, edi, ebp>

        ret

OpcodeOUTBimmV86 endp

        page   ,132
        subttl "Out Word Immediate Opcode Handler"
;++
;
;   Routine Description:
;
;       This routine emulates an out word immediate opcode.  Currently,
;       it prints a message, and ignores the instruction.
;
;   Arguments:
;       EAX -> pointer to vdm state in DOS arena
;       EBX -> prefix flags
;       EBP -> trap frame
;       CL  -> byte at the faulting address
;       interrupts disabled
;       ESI -> address of faulting instruction
;       EDI -> instruction length count
;
;   Returns:
;       EAX = 0 for failure
;       EAX = 1 for success
;
;   All registers can be trashed except ebp/esp.
;
;

        public OpcodeOUTWimmV86
OpcodeOUTWimmV86 proc

        inc     esi
        inc     edi
        movzx   ecx,byte ptr [esi]
; edi - instruction size
; FALSE - write op
; 2 - word op
; ecx - port number
        ; Ki386VdmDispatchIo enables interrupts
        stdCall   _Ki386VdmDispatchIo, <ecx, 2, FALSE, edi, ebp>

        ret

OpcodeOUTWimmV86 endp

        page   ,132
        subttl "INB Opcode Handler"
;++
;
;   Routine Description:
;
;       This routine emulates an INB opcode.  Currently, it prints
;       a message, and ignores the instruction.
;
;   Arguments:
;       EAX -> pointer to vdm state in DOS arena
;       EBX -> prefix flags
;       EBP -> trap frame
;       CL  -> byte at the faulting address
;       interrupts disabled
;       ESI -> address of faulting instruction
;       EDI -> instruction length count
;
;   Returns:
;       EAX = 0 for failure
;       EAX = 1 for success
;
;   All registers can be trashed except ebp/esp.
;

        public OpcodeINBV86
OpcodeINBV86 proc

        movzx   ebx,word ptr [ebp].TsEdx


; edi - instruction size
; TRUE - read op
; 1 - byte op
; ebx - port number

        cmp     ebx, 3bdh
        jz      oib_prt1
        cmp     ebx, 379h
        jz      oib_prt1
        cmp     ebx, 279h
        jz      oib_prt1

oib_reflect:
        ; Ki386VdmDispatchIo enables interrupts
        stdCall   _Ki386VdmDispatchIo, <ebx, 1, TRUE, edi, ebp>
        ret

oib_prt1:
        ; call printer status routine with port number, size, trap frame
        stdCall _VdmPrinterStatus, <ebx, edi, ebp>
        or      al,al
        jz      short oib_reflect
        ret

OpcodeINBV86 endp

        page   ,132
        subttl "INW Opcode Handler"
;++
;
;   Routine Description:
;
;       This routine emulates an INW opcode.  Currently, it prints
;       a message, and ignores the instruction.
;
;   Arguments:
;       EAX -> pointer to vdm state in DOS arena
;       EBX -> prefix flags
;       EBP -> trap frame
;       CL  -> byte at the faulting address
;       interrupts disabled
;       ESI -> address of faulting instruction
;       EDI -> instruction length count
;
;   Returns:
;       EAX = 0 for failure
;       EAX = 1 for success
;
;   All registers can be trashed except ebp/esp.
;
;

        public OpcodeINWV86
OpcodeINWV86 proc

        movzx   ebx,word ptr [ebp].TsEdx

; edi - instruction size
; TRUE - read operation
; 2 - word op
; ebx - port number
        ; Ki386VdmDispatchIo enables interrupts
        stdCall   _Ki386VdmDispatchIo, <ebx, 2, TRUE, edi, ebp>

        ret
OpcodeINWV86 endp

        page   ,132
        subttl "OUTB Opcode Handler"
;++
;
;   Routine Description:
;
;       This routine emulates an OUTB opcode.  Currently, it prints
;       a message, and ignores the instruction.
;
;   Arguments:
;       EAX -> pointer to vdm state in DOS arena
;       EBX -> prefix flags
;       EBP -> trap frame
;       CL  -> byte at the faulting address
;       interrupts disabled
;       ESI -> address of faulting instruction
;       EDI -> instruction length count
;
;   Returns:
;       EAX = 0 for failure
;       EAX = 1 for success
;
;   All registers can be trashed except ebp/esp.
;
;

        public OpcodeOUTBV86
OpcodeOUTBV86 proc

        movzx   ebx,word ptr [ebp].TsEdx

        cmp     ebx, 3bch
        jz      oob_prt1
        cmp     ebx, 378h
        jz      oob_prt1
        cmp     ebx, 278h
        jz      oob_prt1

oob_reflect:

; edi - instruction size
; FALSE - write op
; 1 - byte op
; ebx - port number
        ; Ki386VdmDispatchIo enables interrupts
        stdCall   _Ki386VdmDispatchIo, <ebx, 1, FALSE, edi, ebp>

        ret
oob_prt1:
        ; call printer write data routine with port number, size, trap frame
        stdCall _VdmPrinterWriteData, <ebx, edi, ebp>
        or      al,al
        jz      short oob_reflect
                                        ;al already has TRUE
        ret
OpcodeOUTBV86 endp

        page   ,132
        subttl "OUTW Opcode Handler"
;++
;
;   Routine Description:
;
;       This routine emulates an OUTW opcode.  Currently, it prints
;       a message, and ignores the instruction.
;
;   Arguments:
;       EAX -> pointer to vdm state in DOS arena
;       EBX -> prefix flags
;       EBP -> trap frame
;       CL  -> byte at the faulting address
;       interrupts disabled
;       ESI -> address of faulting instruction
;       EDI -> instruction length count
;
;   Returns:
;       EAX = 0 for failure
;       EAX = 1 for success
;
;   All registers can be trashed except ebp/esp.
;
;

        public OpcodeOUTWV86
OpcodeOUTWV86 proc

        movzx   ebx,word ptr [ebp].TsEdx
; edi - instruction size
; FALSE - write op
; 2 - word op
; ebx - port #
        ; Ki386VdmDispatchIo enables interrupts
        stdCall   _Ki386VdmDispatchIo, <ebx, 2, FALSE, edi, ebp>

        ret

OpcodeOUTWV86 endp


        page   ,132
        subttl "CLI Opcode Handler"
;++
;
;   Routine Description:
;
;       This routine emulates an CLI opcode.  Currently, it prints
;       a message, and clears the virtual interrupt flag in the VdmTeb.
;
;   Arguments:
;       EAX -> pointer to vdm state in DOS arena
;       EBX -> prefix flags
;       EBP -> trap frame
;       CL  -> byte at the faulting address
;       interrupts disabled
;       ESI -> address of faulting instruction
;       EDI -> instruction length count
;
;   Returns:
;       EAX = 0 for failure
;       EAX = 1 for success
;
;   All registers can be trashed except ebp/esp.
;
;

        public OpcodeCLIV86
OpcodeCLIV86 proc
        lea     eax,ds:FIXED_NTVDMSTATE_LINEAR
        test    _KeI386VirtualIntExtensions, dword ptr V86_VIRTUAL_INT_EXTENSIONS
        jz      short oc50

        mov     edx, [ebp].TsEFlags       ; redundant code.  Just in case
        mov     eax,dword ptr [eax]
        and     edx, EFLAGS_VIF + EFLAGS_VIP
        cmp     edx, EFLAGS_VIF + EFLAGS_VIP
        jnz     short oc40

        test    eax,VDM_INTERRUPT_PENDING
        jz      short oc40

        call    VdmDispatchIntAck
        mov     eax,1
        ret

oc40:   lea     eax,ds:FIXED_NTVDMSTATE_LINEAR
oc50:   MPLOCK and dword ptr [eax],NOT VDM_VIRTUAL_INTERRUPTS
        add     dword ptr [ebp].TsEip,edi

        mov     eax,1
        ret

OpcodeCLIV86 endp

        page   ,132
        subttl "STI Opcode Handler"
;++
;
;   Routine Description:
;
;       This routine emulates an STI opcode.  Currently, it prints
;       a message, and sets the virtual interrupt flag in the VDM teb.
;
;   Arguments:
;       EAX -> pointer to vdm state in DOS arena
;       EBX -> prefix flags
;       EBP -> trap frame
;       CL  -> byte at the faulting address
;       interrupts disabled
;       ESI -> address of faulting instruction
;       EDI -> instruction length count
;
;   Returns:
;       EAX = 0 for failure
;       EAX = 1 for success
;
;   All registers can be trashed except ebp/esp.
;
;

        public OpcodeSTIV86
OpcodeSTIV86 proc

        lea     eax,ds:FIXED_NTVDMSTATE_LINEAR      ; get pointer to VDM State
        test    _KeI386VirtualIntExtensions, dword ptr V86_VIRTUAL_INT_EXTENSIONS
        jz      short os10

        or      [ebp].TsEFlags, dword ptr EFLAGS_VIF

os10:   MPLOCK or dword ptr [eax],EFLAGS_INTERRUPT_MASK
os20:   add     dword ptr [ebp].TsEip,edi
        mov     eax,dword ptr [eax]
        test    eax,VDM_INTERRUPT_PENDING
        jz      short os30

        call    VdmDispatchIntAck
os30:   mov     eax,1
        ret

OpcodeSTIV86 endp


;
;  If we get here, we have executed an NPX instruction in user mode
;  with the emulator installed.  If the EM bit was not set in CR0, the
;  app really wanted to execute the instruction for detection purposes.
;  In this case, we need to clear the TS bit, and restart the instruction.
;  Otherwise we need to reflect the exception
;
;
; Reginfo structure
;

    public Opcode0FV86
Opcode0FV86 proc

RI      equ     [ebp - REGINFOSIZE]

        push    ebp
        mov     ebp,esp
        sub     esp,REGINFOSIZE
        push    esi
        push    edi


        ; Initialize RegInfo
do10:   mov     esi,[ebp]


        ; initialize rest of the trap from which was'nt initialized for
        ; v86 mode
        mov     eax, [esi].TsV86Es
        mov     [esi].TsSegEs,eax
        mov     eax, [esi].TsV86Ds
        mov     [esi].TsSegDs,eax
        mov     eax, [esi].TsV86Fs
        mov     [esi].TsSegFs,eax
        mov     eax, [esi].TsV86Gs
        mov     [esi].TsSegGs,eax

        mov     RI.RiTrapFrame,esi
        mov     eax,[esi].TsHardwareSegSs
        mov     RI.RiSegSs,eax
        mov     eax,[esi].TsHardwareEsp
        mov     RI.RiEsp,eax
        mov     eax,[esi].TsEFlags
        mov     RI.RiEFlags,eax
        mov     eax,[esi].TsSegCs
        mov     RI.RiSegCs,eax
        mov     eax,[esi].TsEip
        dec     edi
        add     eax,edi                 ; for prefixes
        mov     RI.RiEip,eax

        mov     RI.RiPrefixFlags,ebx
        lea     esi,RI

        CsToLinearV86
        call    VdmOpcode0f                             ; enables interrupts

        test    eax,0FFFFh
        jz      do20

        mov     edi,RI.RiTrapFrame
        mov     eax,RI.RiEip                            ; advance eip
        mov     [edi].TsEip,eax
do19:   mov     eax,1
do20:
        pop     edi
        pop     esi
        mov     esp,ebp
        pop     ebp
        ret

Opcode0FV86 endp


;++
;
;   Routine Description: VdmDispatchIntAck
;       pushes stack arguments for VdmDispatchInterrupts
;       and invokes VdmDispatchInterrupts
;
;       Expects VDM_INTERRUPT_PENDING, and VDM_VIRTUAL_INTERRUPTS
;
;   Arguments:
;       EBP -> trap frame
;
;   Returns:
;       nothing
;
;
        public VdmDispatchIntAck
VdmDispatchIntAck proc
        push    ebp
        push    offset diafault             ; Set Handler address
        push    PCR[PcExceptionList]        ; Set next pointer
        mov     PCR[PcExceptionList],esp    ; Link us on

        test    ds:FIXED_NTVDMSTATE_LINEAR, VDM_INT_HARDWARE ; check interrupt int
        mov     eax,PCR[PcTeb]
        mov     eax,[eax].TeVdm             ; get pointer to VdmTib
        jz      short dia20

        cmp     eax, _MmUserProbeAddress    ; check if user address
        jae     short dia10                 ; if ae, then not user address


        pop     PCR[PcExceptionList]        ; Remove our exception handle
        add     esp, 4                      ; clear stack
        pop     ebp
        ;
        ; dispatch hardware int directly from kernel
        ;
        stdCall _VdmDispatchInterrupts, <ebp, eax>  ; TrapFrame, VdmTib
        ret

dia10:
        pop     PCR[PcExceptionList]        ; Remove our exception handle
        add     esp, 4                      ; clear stack
        pop     ebp
        ret


        ;
        ; Switch to monitor context to dispatch timer int
        ;
dia20:
        cmp     eax, _MmUserProbeAddress    ; check if user address
        jae     dia10                       ; if ae, then not user address

        mov     dword ptr [eax].VtEIEvent,VdmIntAck ;
        mov     dword ptr [eax].VtEIInstSize,0
        mov     dword ptr [eax].VtEiIntAckInfo,0

        pop     PCR[PcExceptionList]        ; Remove our exception handle

        add     esp, 4                      ; clear stack
        pop     ebp

        stdCall _VdmEndExecution, <ebp, eax>        ; TrapFrame, VdmTib
        ret
VdmDispatchIntAck endp


diafault proc

;
; WARNING: Here we directly unlink the exception handler from the
; exception registration chain.  NO unwind is performed.  We can take
; this short cut because we know that our handler is a leaf-node.
;

        mov     esp, [esp+8]                ; (esp)-> ExceptionList
        pop     PCR[PcExceptionList]        ; Remove our exception handle
        add     esp, 4                      ; clear stack
        pop     ebp
        ret
diafault endp




        public vdmDebugPoint
vdmDebugPoint proc
        ret
vdmDebugPoint endp



        page   ,132
        subttl "HLT Opcode Handler"
;++
;
;   Routine Description:
;
;       This routine emulates an HLT opcode.  If the halt instruction is
;       followed by the magic number (to be found in a crackerjack box),
;       we use the hlt + magic number as a prefix, and emulate the following
;       instruction.  This allows code running in segmented protected mode to
;       access the virtual interrupt flag.
;
;   Arguments:
;       EAX -> pointer to vdm state in DOS arena
;       EBX -> prefix flags
;       EBP -> trap frame
;       CL  -> byte at the faulting address
;       interrupts disabled
;       ESI -> address of faulting instruction
;       EDI -> instruction length count
;
;   Returns:
;       EAX = 0 for failure
;       EAX = 1 for success
;
;   All registers can be trashed except ebp/esp.
;

        public OpcodeHLTV86
OpcodeHLTV86 proc

        add     dword ptr [ebp].TsEip,edi
        mov     eax,1
        ret

OpcodeHLTV86 endp

_PAGE   ends

_TEXT$00   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME DS:NOTHING, ES:NOTHING, SS:NOTHING, FS:NOTHING, GS:NOTHING

        subttl "NPX Opcode Handler"
;++
;
;   Routine Description:
;
;       This routine emulates all NPX opcodes, when the system
;       has the R3 emulator installed and the c86 apps takes a
;       trap07.
;
;   Arguments:
;       EBX -> prefix flags
;       EBP -> trap frame
;       CL  -> byte at the faulting address
;       ESI -> address of faulting instruction
;       EDI -> instruction length count
;
;   Returns:
;       EAX = 0 for failure
;       EAX = 1 for success
;
;   All registers can be trashed except ebp/esp.
;   moved from emv86.asm as it must be non-pageable

    public OpcodeNPXV86
OpcodeNPXV86 proc
        mov     edx, PCR[PcPrcbData+PbCurrentThread] ; get current thread
        mov     edx, [edx].ThInitialStack
        mov     edx, [edx].FpCr0NpxState-NPX_FRAME_LENGTH
        test    edx, CR0_EM             ; Does app want NPX traps?
        jnz     short onp40

    ; MP bit can never be set while the EM bit is cleared, so we know
    ; the faulting instruction is not an FWAIT

onp30:  and     ebx, PREFIX_ADDR32
        stdCall _VdmSkipNpxInstruction, <ebp, ebx, esi, edi>
        or      al, al                  ; was it handled?
        jnz     short onp60             ; no, go raise exception to app

onp40:  stdCall _Ki386VdmReflectException, <7>  ; trap #

onp60:  mov     eax,1
        ret


OpcodeNPXV86 endp


;++ KiVdmSetUserCR0
;
;       eax
;
        public KiVdmSetUserCR0
KiVdmSetUserCR0 proc

        and     eax, CR0_MP OR CR0_EM       ; Sanitize parameter
        shr     eax, 1
        movzx   eax, _VdmUserCr0MapIn[eax]

        push    ebp                         ; Pass current Ebp to handler
        push    offset scr_fault            ; Set Handler address
        push    PCR[PcExceptionList]        ; Set next pointer
        mov     PCR[PcExceptionList],esp    ; Link us on

        mov     edx,PCR[PcTeb]
        mov     edx,[edx].TeVdm             ; get pointer to VdmTib
        cmp     edx, _MmUserProbeAddress    ; probe the pointer
        jbe     short @f

        mov     edx, _MmUserProbeAddress    ; make us AV
@@:     mov     [edx].VtVdmContext.CsFloatSave.FpCtxtCr0NpxState, eax

scr10:  pop     PCR[PcExceptionList]        ; Remove our exception handle

        mov     ebx, PCR[PcPrcbData + PbCurrentThread]  ; (ebx) = current thread
        add     esp, 4                      ; Remove Exception Handler
        pop     ebp                         ; restore ebp.

        mov     edx, [ebx].ThInitialStack    ; Get fp save area
        sub     edx, NPX_FRAME_LENGTH

scr20:  cli                                 ; sync with context swap
        and     [edx].FpCr0NpxState, NOT (CR0_MP+CR0_EM+CR0_PE)
        or      [edx].FpCr0NpxState,eax     ; set fp save area bits

        mov     eax,cr0
        and     eax, NOT (CR0_MP+CR0_EM+CR0_TS) ; turn off bits we will change
        or      al, [ebx].ThNpxState        ; set scheduler bits
        or      eax,[edx].FpCr0NpxState     ; set user's bits
        mov     cr0,eax
        sti
        ret
KiVdmSetUserCR0 endp

scr_fault proc
;
; WARNING: Here we directly unlink the exception handler from the
; exception registration chain.  NO unwind is performed.  We can take
; this short cut because we know that our handler is a leaf-node.
;

        mov     esp, [esp+8]            ; (esp)-> ExceptionList
        jmp     short scr10
scr_fault endp



_TEXT$00   ENDS

        end
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ke\i386\cpu.inc ===
;++
;
; Copyright (c) Microsoft Corporation. All rights reserved. 
;
; You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
; If you do not agree to the terms, do not use the code.
;
;
;   Module Name:
;
;       cpu.inc
;
;   Abstract:
;
;       This module contains the assembly structures and definitions
;       for INTEL 80x86 CPU specifiec information.  This include file
;       is mainly used by CPU.ASM to determine CPU type and stepping
;       number.
;
;--

;
; The following equates define the control bits of CR0 register
;

CR0_AM          equ     40000h
CR0_ET          equ     00010h

;
; The following equates define the control bits of EFALGS register
;

EFLAGS_AC       equ     40000h
EFLAGS_VM       equ     20000h
EFLAGS_RF       equ     10000h
EFLAGS_NF       equ     4000h
EFLAGS_IOPL     equ     3000h
EFLAGS_IF       equ     200h
EFLAGS_TF       equ     100h
EFLAGS_ID       equ     200000h

;
; Define the iret frame
;

IretFrame       struc

IretEip        dd      0
IretCs         dd      0
IretEFlags     dd      0

IretFrame       ends

;
; Misc. definitions
;

ADDRESS_OVERRIDE        equ     67h
OPERAND_OVERRIDE        equ     66h
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ke\i386\emxcptn.asm ===
page    78,132
;
; Copyright (c) Microsoft Corporation. All rights reserved. 
;
; You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
; If you do not agree to the terms, do not use the code.
;
;
; Module Name:
;
;   ke\i386\emxcptn.asm
;
; Abstract:
;       Module to support getting/setting context to and from the R3
;       emulator.
;

        .386p
_TEXT   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING


;;*******************************************************************************
;;
;;   Include some more macros and constants.
;;
;;*******************************************************************************
;

NT386   equ     1

        include ks386.inc
        include em387.inc               ; Emulator TEB data layout
        include callconv.inc
        include irqli386.inc

        EXTRNP  _KeBugCheck,1
        EXTRNP  _RtlRaiseStatus,1
        extrn   _Ki387RoundModeTable:dword


        subttl  _KiEm87StateToNpxFrame
        page

;*** _KiEm87StateToNpxFrames
;
;  Translates the R3 emulators state to the NpxFrame
;
;  Returns TRUE if NpxFrame successfully completed.
;   else FALSE
;
;  Warning: This function can only be called at Irql 0 with interrupts
;  enabled.  It is intended to be called only to deal with R3 exceptions
;  when the emulator is being used.
;
;  Revision History:
;
;
;*******************************************************************************

cPublicProc _KiEm87StateToNpxFrame, 1
        push    ebp
        mov     ebp, esp
        push    ebx                     ; Save C runtime variables
        push    edi
        push    esi

        push    esp                     ; Pass current Esp to handler
        push    offset stnpx_30         ; Set Handler address
        push    PCR[PcExceptionList]    ; Set next pointer
        mov     PCR[PcExceptionList],esp ; Link us on

if DBG
        pushfd                              ; Sanity check
        pop     ecx                         ; make sure interrupts are enabled
        test    ecx, EFLAGS_INTERRUPT_MASK
        jz      short stnpx_err

        CurrentIrql                     ; Sanity check
        cmp     al, DISPATCH_LEVEL          ; make sure Irql is below DPC level
        jnc     short stnpx_err
endif

        xor     eax, eax                ; set FALSE

        mov     ebx,PCR[PcPrcbData+PbCurrentThread]
        mov     ebx,[ebx]+ThApcState+AsProcess
        cmp     dword ptr [ebx]+PrVdmObjects,0 ; is this a vdm process?
        jne     short stnpx_10               ; Yes, then not supported

        mov     ebx, PCR[PcTeb]         ; R3 Teb
        cmp     [ebx].Einstall, 0       ; Initialized?
        je      short stnpx_10          ; No, then don't return NpxFrame

        test    [ebx].CURErr, Summary   ; Completed?
        jz      short stnpx_10          ; No, then don't return NpxFrame

        mov     esi, [ebp+8]            ; (esi) = NpxFrame
        call    SaveState

        mov     eax, 1                  ; Return TRUE
stnpx_10:
        pop     PCR[PcExceptionList]    ; Remove our exception handle
        add     esp, 8                  ; clear stack
        pop     esi
        pop     edi
        pop     ebx
        pop     ebp
        stdRET  _KiEm87StateToNpxFrame

if DBG
stnpx_err:
        stdCall _KeBugCheck <IRQL_NOT_LESS_OR_EQUAL>
endif
_KiEm87StateToNpxFrame ENDP

stnpx_30 proc
;
; WARNING: Here we directly unlink the exception handler from the
; exception registration chain.  NO unwind is performed.  We can take
; this short cut because we know that our handler is a leaf-node.
;

        mov     esp, [esp+8]            ; (esp)-> ExceptionList
        xor     eax, eax                ; Return FALSE
        jmp     short stnpx_10
stnpx_30 endp

;*** SaveEnv
;
;
;   ARGUMENTS
;
;       (esi) = NpxFrame
;       (ebx) = PcTeb
;
;
;   DESCRIPTION
;

SaveEnv:
        xor     ax,ax
        mov     [esi].reserved1,ax
        mov     [esi].reserved2,ax
        mov     [esi].reserved3,ax
        mov     [esi].reserved4,ax
        mov     [esi].reserved5,ax
        mov     ax,[ebx].ControlWord
        mov     [esi].E32_ControlWord,ax
        call    GetEMSEGStatusWord
        mov     [esi].E32_StatusWord,ax
        call    GetTagWord
        mov     [esi].E32_TagWord,ax
        mov     ax,cs
        mov     [esi].E32_CodeSeg,ax    ; NOTE: Not R0 code & stack
        mov     ax,ss
        mov     [esi].E32_DataSeg,ax
        mov     eax,[ebx].PrevCodeOff
        mov     [esi].E32_CodeOff,eax
        mov     eax,[ebx].PrevDataOff
        mov     [esi].E32_DataOff,eax
        ret


;*** SaveState -
;
;   ARGUMENTS
;       (esi) = where to store environment
;       (ebx) = PcTeb
;
;   DESCRIPTION
;
;   REGISTERS
;       Destroys ALL, but EBX
;

SaveState:                              ; Enter here for debugger save state
        mov     dword ptr [esi].FpCr0NpxState, CR0_EM

        call    SaveEnv
        add     esi,size Env80x87_32    ;Skip over environment
        mov     ebp,NumLev              ;Save entire stack
        mov     edi,[ebx].CURstk
ss_loop:
        mov     eax,[ebx+edi].ExpSgn
        call    StoreTempReal           ;in emstore.asm
        add     esi,10

        mov     edi,[ebx].CURstk
;;;     NextStackElem   edi,SaveState
        cmp     edi,INITstk
        jae     short ss_wrap
        add     edi,Reg87Len
ss_continue:
        mov     [ebx].CURstk,edi
        dec     ebp
        jnz     short ss_loop
        ret
ss_wrap:
        mov     edi, BEGstk
        jmp     short ss_continue


;***    GetTagWord - figures out what the tag word is from the numeric stack
;                  and returns the value of the tag word in ax.
;
;   ARGUMENTS
;       (ebx) = PcTeb
;

GetTagWord:
        push    esi
        xor     eax, eax
        mov     ecx, NumLev             ; get tags for regs. 0, 7 - 1
        mov     esi, INITstk
GetTagLoop:
        mov     dh, [ebx+esi].bTag      ; The top 2 bits of Tag are the X87 tag bits.
        shld    ax, dx, 2
        sub     esi, Reg87Len
        loop    GetTagLoop
        rol     ax, 2                   ; This moves Tag(0) into the low 2 bits
        pop     esi
        ret


;***    GetEMSEGStatusWord
;
; User status word returned in ax.
; Uses status word in per-thread data area, otherwise
;   identical to GetStatusWord
;
;   ARGUMENTS
;       (ebx) = PcTeb

GetEMSEGStatusWord:
        mov     eax, [ebx].CURstk
        sub     eax, BEGstk

        ;
        ; Make sure the 'div' won't overflowed.
        ;

        cmp     eax, Reg87Len * (NumLev + 2)
        ja      short @f

        mov     dl,Reg87Len
        div     dl
        inc     eax
        and     eax, 7                  ; eax is now the stack number
        shl     ax, 11
        or      ax, [ebx].StatusWord    ; or in the rest of the status word.
        ret
@@:
        mov     eax, STATUS_INTEGER_OVERFLOW
        stdCall _RtlRaiseStatus, <eax>
        ret                             ; Should never come here ...

;***  StoreTempReal
;
;
;   ARGUMENTS
;       ??
;       (ebx) = PcTeb
;

StoreTempReal:
        mov     edx,[ebx+edi].lManHi
        mov     edi,[ebx+edi].lManLo
;mantissa in edx:edi, exponent in high eax, sign in ah bit 7, tag in al
;memory destination is esi
        mov     ecx,eax                 ;get copy of sign and tag
        shr     ecx,16                  ;Bring exponent down
        cmp     al,bTAG_ZERO
        jz      short StoreIEEE80       ;Skip bias if zero
        add     ecx,IexpBias-TexpBias   ;Correct bias
        cmp     al,bTAG_DEN
        jz      short Denorm80
StoreIEEE80:
        and     eax,bSign shl 8
        or      ecx,eax                 ;Combine sign with exponent
        mov     [esi],edi
        mov     [esi+4],edx
        mov     [esi+8],cx
        ret

Denorm80:
;Must change it to a denormal
        dec     ecx
        neg     ecx                     ;Use as shift count
        cmp     cl,32                   ;Long shift?
        jae     LongDenorm
        shrd    edi,edx,cl
        shr     edx,cl
        xor     ecx,ecx                 ;Exponent is zero
        jmp     short StoreIEEE80

LongDenorm:
;edi must be zero if we have 32 bits to shift
        xchg    edx,edi                 ;32-bit right shift
        shr     edi,cl                  ;shift count is modulo-32
        xor     ecx,ecx                 ;Exponent is zero
        jmp     short StoreIEEE80


;****************************************************
;****************************************************
;****************************************************
;****************************************************


;*** _KiNpxFrameToEm87State
;
;  Translates the NpxFrame to the R3 emulators state
;
;  Returns TRUE if NpxFrame state successfully transferred.
;   else FALSE
;
;  Warning: This function can only be called at Irql 0 with interrupts
;  enabled.  It is intended to be called only to deal with R3 exceptions
;  when the emulator is being used.
;
;  Revision History:
;
;
;*******************************************************************************

cPublicProc _KiNpxFrameToEm87State, 1
        push    ebp
        mov     ebp, esp
        push    ebx                     ; Save C runtime variables
        push    edi
        push    esi

        push    esp                     ; Pass current Esp to handler
        push    offset npxts_30         ; Set Handler address
        push    PCR[PcExceptionList]    ; Set next pointer
        mov     PCR[PcExceptionList],esp  ; Link us on

if DBG
        pushfd                              ; Sanity check
        pop     ecx                         ; make sure interrupts are enabled
        test    ecx, EFLAGS_INTERRUPT_MASK
        jz      short npxts_err

        CurrentIrql                     ; Sanity check
        cmp     al, DISPATCH_LEVEL          ; make sure Irql is below DPC level
        jnc     short npxts_err
endif

        xor     eax, eax                ; set FALSE

        mov     ebx,PCR[PcPrcbData+PbCurrentThread]
        mov     ebx,[ebx]+ThApcState+AsProcess
        cmp     dword ptr [ebx]+PrVdmObjects,0 ; is this a vdm process?
        jne     short npxts_10               ; Yes, then not supported

        mov     ebx, PCR[PcTeb]         ; R3 Teb
        cmp     [ebx].Einstall, 0       ; Initialized?
        je      short npxts_10          ; No, then don't set NpxFrame

        mov     esi, [ebp+8]            ; (esi) = NpxFrame
        call    StorState
        or      [ebx].CURErr, Summary   ; Set completed

        mov     eax, 1                  ; Return TRUE
npxts_10:
        pop     PCR[PcExceptionList]    ; Remove our exception handle
        add     esp, 8                  ; clear stack
        pop     esi
        pop     edi
        pop     ebx
        pop     ebp
        stdRet  _KiNpxFrameToEm87State

if DBG
npxts_err:
        stdCall _KeBugCheck <IRQL_NOT_LESS_OR_EQUAL>
endif
_KiNpxFrameToEm87State ENDP

npxts_30 proc
;
; WARNING: Here we directly unlink the exception handler from the
; exception registration chain.  NO unwind is performed.  We can take
; this short cut because we know that our handler is a leaf-node.
;

        mov     esp, [esp+8]            ; (esp)-> ExceptionList
        xor     eax, eax                ; Return FALSE
        jmp     short npxts_10
        ret
npxts_30 endp



;*** StorState - emulate FRSTOR  [address]
;
;   ARGUMENTS
;       (esi)  = where to get the environment
;       (ebx)  = PcTeb
;
;
;   DESCRIPTION
;           This routine emulates an 80387 FRSTOR (restore state)

StorState:
;First we set up the status word so that [CURstk] is initialized.
;The floating-point registers are stored in logical ST(0) - ST(7) order,
;not physical register order.  We don't do a full load of the environment
;because we're not ready to use the tag word yet.

        mov     ax, [esi].E32_StatusWord
        call    SetEmStatusWord         ;Initialize [CURstk]
        add     esi,size Env80x87_32    ;Skip over environment

;Load of temp real has one difference from real math chip: it is an invalid
;operation to load an unsupported format.  By ensuring the exception is
;masked, we will convert unsupported format to Indefinite.  Note that the
;mask and [CURerr] will be completely restored by the FLDENV at the end.

        mov     [ebx].CWmask,3FH        ;Mask off invalid operation exception
        mov     edi,[ebx].CURstk
        mov     ebp,NumLev
FrstorLoadLoop:
        push    esi
        call    LoadTempReal            ;In emload.asm
        pop     esi
        add     esi,10          ;Point to next temp real
;;;     NextStackElem   edi,Frstor
        cmp     edi,INITstk
        jae     short fr_wrap
        add     edi,Reg87Len
fr_continue:
        dec     ebp
        jnz     short FrstorLoadLoop
        sub     esi,NumLev*10+size Env80x87_32  ;Point to start of env.
;
; Stor Environment
; (esi) = where to get environment
; (ebx) = PcTeb
;

        mov     ax, [esi].E32_StatusWord
        call    SetEmStatusWord                 ; set up status word
        mov     ax, [esi].E32_ControlWord
        call    SetControlWord
        mov     ax, [esi].E32_TagWord
        call    UseTagWord

        mov     eax, [esi].E32_CodeOff
        mov     [ebx].PrevCodeOff, eax
        mov     eax, [esi].E32_DataOff
        mov     [ebx].PrevDataOff, eax
        ret

fr_wrap:
        mov     edi, BEGstk
        jmp     short fr_continue


;***    SetEmStatusWord -
;
; Given user status word in ax, set into emulator.
; Destroys ebx only.


SetEmStatusWord:
        and     ax,7F7FH
        mov     cx,ax
        and     cx,3FH                  ; set up CURerr in case user
        mov     [ebx].CURerr,cl         ; wants to force an exception
        mov     ecx, eax
        and     ecx, not (7 shl 11)     ; remove stack field.
        mov     [ebx].StatusWord, cx

        sub     ah, 8                   ; adjust for emulator's stack layout
        and     ah, 7 shl 3
        mov     al, ah
        shr     ah, 1
        add     al, ah                  ; stack field * 3 * 4
.erre   Reg87Len eq 12
        and     eax, 255                ; eax is now 12*stack number
        add     eax, BEGstk
        mov     [ebx].CURstk, eax
        ret

SetControlWord:
        and     ax,0F3FH                ; Limit to valid values
        mov     [ebx].ControlWord, ax   ; Store in the emulated control word
        not     al                      ;Flip mask bits for fast compare
        and     al,3FH                  ;Limit to valid mask bits
        mov     [ebx].ErrMask,al
        and     eax,(RoundControl + PrecisionControl) shl 8
.erre   RoundControl eq 1100B
.erre   PrecisionControl eq 0011B
        shr     eax,6                   ;Put PC and RC in bits 2-5
        mov     ecx,_Ki387RoundModeTable
        mov     ecx,[ecx+eax]           ;Get correct RoundMode vector
        mov     [ebx].RoundMode,ecx
        mov     [ebx].SavedRoundMode,ecx
        and     eax,RoundControl shl (8-6)      ;Mask off precision control
        mov     ecx,_Ki387RoundModeTable
        mov     ecx,[ecx+(eax+PC64 shl (8-6))];Get correct RoundMode vector
        mov     [ebx].TransRound,ecx    ;Round mode w/o precision
        ret


;***    UseTagWord - Set up tags using tag word from environment
;
;       ARGUMENTS
;              ax - should contain the tag word
;
;       Destroys ax,bx,cx,dx,di

UseTagWord:
        ror     ax, 2                   ; mov Tag(0) into top bits of ax
        mov     edi,INITstk
        mov     ecx, NumLev
UseTagLoop:
        mov     dl,bTAG_EMPTY
        cmp     ah, 0c0h                ;Is register to be tagged Empty?
        jae     short SetTag            ;Yes, go mark it
        mov     dl,[ebx+edi].bTag       ;Get current tag
        cmp     dl,bTAG_EMPTY           ;Is register currently Empty?
        je      short SetTagNotEmpty    ;If so, go figure out tag for it
SetTag:
        mov     [ebx+edi].bTag,dl
UseTagLoopCheck:
        sub     edi, Reg87Len
        shl     eax, 2
        loop    UseTagLoop
        ret

SetTagEmpty:
        mov     [ebx+edi].bTag, bTAG_EMPTY
        jmp     short UseTagLoopCheck

SetTagNotEmpty:
;Register is currently tagged empty, but new tag word says it is not empty.
;Figure out a new tag for it.  The rules are:
;
;1. Everything is either normalized or zero--unnormalized formats cannot
;get in.  So if the high half mantissa is zero, the number is zero.
;
;2. Although the exponent bias is different, NANs and Infinities are in
;standard IEEE format - exponent is TexpMax, mantissa indicates NAN vs.
;infinity (mantissa for infinity is 800..000H).
;
;3. Denormals have an exponent less than TexpMin.
;
;4. If the low half of the mantissa is zero, it is tagged bTAG_SNGL
;
;5. Everything else is bTAG_VALID

        cmp     [ebx+edi].lManHi, 0
        mov     dl,bTAG_ZERO            ;Try zero first
        jz      short SetTag            ;Is mantissa zero?
        mov     edx,[ebx+edi].ExpSgn
        mov     dl,bTAG_DEN
        cmp     edx,TexpMin shl 16      ;Is it denormal?
        jl      short SetTag
        cmp     [ebx+edi].lManLo,0      ;Is low half zero?
.erre   bTAG_VALID eq 1
.erre   bTAG_SNGL eq 0
        setnz   dl                      ;if low half==0 then dl=0 else dl=1
        cmp     edx,TexpMax shl 16      ;Is it NAN or Infinity?
        jl      short SetTag            ;If not, it's valid
.erre   (bTAG_VALID - bTAG_SNGL) shl TAG_SHIFT eq (bTAG_NAN - bTAG_INF)
        shl     dl,TAG_SHIFT
        add     dl,bTAG_INF - bTAG_SNGL
;If the low bits were zero we have just changed bTAG_SNGL to bTAG_INF
;If the low bits weren't zero, we changed bTAG_VALID to bTAG_NAN
;See if infinity is really possible: is high half 80..00H?
        cmp     [ebx+edi].lManHi,1 shl 31   ;Is it infinity?
        jz      short SetTag            ;Store tag for infinity or NAN
        mov     dl,bTAG_NAN
        jmp     short SetTag


;***    LoadTempReal
;
;
;

LoadTempReal:
        mov     ebx,[esi+4]             ;Get high half of mantissa
        mov     cx,[esi+8]              ;Get exponent and sign
        mov     esi,[esi]               ;Get low half of mantissa
        mov     eax,ecx
        and     ch,7FH                  ;Mask off sign bit
        shl     ecx,16                  ;Move exponent to high end
        mov     ch,ah                   ;Restore sign
        jz      short ZeroOrDenorm80
;Check for unsupported format: unnormals (MSB not set)
        or      ebx,ebx
        jns     short Unsupported
        sub     ecx,(IexpBias-TexpBias) shl 16  ;Correct the bias
        cmp     ecx,TexpMax shl 16
        jge     short NANorInf80
SetupTag:
        or      esi,esi                 ;Any bits in low half?
.erre   bTAG_VALID eq 1
.erre   bTAG_SNGL eq 0
        setnz   cl                      ;if low half==0 then cl=0 else cl=1
        jmp     short SaveStack

NANorInf80:
        mov     cl,bTAG_NAN
        cmp     ebx,1 shl 31            ;Only 1 bit set means infinity
        jnz     short SaveStack
        or      esi,esi
        jnz     short SaveStack
        mov     cl,bTAG_INF
        jmp     short SaveStack

ZeroOrDenorm80:
;Exponent is zero. Number is either zero or denormalized
        or      ebx,ebx
        jnz     short ShortNorm80       ;Are top 32 bits zero?
        or      esi,esi                 ;Are low 32 bits zero too?
        jnz     LongNorm80
        mov     cl,bTAG_ZERO
        jmp     short SaveStack

;This code accepts and works correctly with pseudo-denormals (MSB already set)
LongNorm80:
        xchg    ebx,esi                 ;Shift up 32 bits
        sub     ecx,32 shl 16           ;Correct exponent
ShortNorm80:
        add     ecx,(TexpBias-IexpBias+1-31) shl 16     ;Fix up bias
        bsr     edx,ebx                 ;Scan for MSB
;Bit number in edx ranges from 0 to 31
        mov     cl,dl
        not     cl                      ;Convert bit number to shift count
        shld    ebx,esi,cl
        shl     esi,cl
        shl     edx,16                  ;Move exp. adjustment to high end
        add     ecx,edx                 ;Adjust exponent
        jmp     short SetUpTag

SaveStack:
        mov     eax, PCR[PcTeb]
        mov     [eax].CURstk,edi
        mov     [eax+edi].lManLo,esi
        mov     [eax+edi].lManHi,ebx
        mov     [eax+edi].ExpSgn,ecx
        mov     ebx, eax                ; (ebx) = PcTeb
        ret

Unsupported:
        mov     ebx, PCR[PcTeb]
        or      [ebx].CURerr,Invalid    ; (assume it's masked?)
        mov     [ebx+edi].lManLo,0
        mov     [ebx+edi].lManHi,0C0000000H
        mov     [ebx+edi].ExpSgn,TexpMax shl 16 + bSign shl 8 + bTAG_NAN
        mov     [ebx].CURstk,edi        ;Update top of stack
        ret

_TEXT   ENDS
END
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ke\i386\ctxswap.asm ===
title  "Context Swap"
;++
;
; Copyright (c) Microsoft Corporation. All rights reserved. 
;
; You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
; If you do not agree to the terms, do not use the code.
;
;
; Module Name:
;
;    ctxswap.asm
;
; Abstract:
;
;    This module implements the code necessary to field the dispatch
;    interrupt and to perform kernel initiated context switching.
;
;--

.586p
        .xlist
include ks386.inc
include i386\kimacro.inc
include mac386.inc
include callconv.inc
include irqli386.inc
FPOFRAME macro a, b
.FPO ( a, b, 0, 0, 0, 0 )
endm
        .list

        EXTRNP  KefAcquireSpinLockAtDpcLevel,1,,FASTCALL
        EXTRNP  KefReleaseSpinLockFromDpcLevel,1,,FASTCALL

        EXTRNP  HalClearSoftwareInterrupt,1,IMPORT,FASTCALL
        EXTRNP  HalRequestSoftwareInterrupt,1,IMPORT,FASTCALL

ifndef NT_UP

        EXTRNP  KiIdleSchedule,1,,FASTCALL

endif

        EXTRNP  KiCheckForSListAddress,1,,FASTCALL
        EXTRNP  KiQueueReadyThread,2,,FASTCALL
        EXTRNP  KiRetireDpcList,1,,FASTCALL
        EXTRNP  _KiQuantumEnd,0
        EXTRNP  _KeBugCheckEx,5

        extrn   _KiTrap13:PROC
        extrn   _KeFeatureBits:DWORD

        extrn   __imp__KeRaiseIrqlToSynchLevel@0:DWORD

        extrn   _KiIdleSummary:DWORD
        
        EXTRNP  WmiTraceContextSwap,2,,FASTCALL

if DBG
        extrn   _KdDebuggerEnabled:BYTE
        EXTRNP  _DbgBreakPoint,0
        EXTRNP  _KdPollBreakIn,0
        extrn   _DbgPrint:near
        extrn   _MsgDpcTrashedEsp:BYTE
        extrn   _MsgDpcTimeout:BYTE
        extrn   _KiDPCTimeout:DWORD
endif


_TEXT$00   SEGMENT PARA PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

cPublicFastCall KiRDTSC, 1
        rdtsc                   ; read the timestamp counter
        mov     [ecx], eax      ; return the low 32 bits
        mov     [ecx+4], edx    ; return the high 32 bits
        fstRET  KiRDTSC
fstENDP KiRDTSC

        page ,132
        subttl  "Swap Context"
;++
;
; BOOLEAN
; KiSwapContext (
;    IN PKTHREAD OldThread
;    IN PKTHREAD NewThread
;    )
;
; Routine Description:
;
;    This function is a small wrapper, callable from C code, that marshalls
;    arguments and calls the actual swap context routine.
;
; Arguments:
;
;    OldThread (ecx) - Supplies the address of the old thread
;    NewThread (edx) - Supplies the address of the new thread.
;
; Return Value:
;
;    If a kernel APC is pending, then a value of TRUE is returned. Otherwise,
;    a value of FALSE is returned.
;
;--

cPublicFastCall KiSwapContext, 2
.fpo (0, 0, 0, 4, 1, 0)

;
; N.B. The following registers MUST be saved such that ebp is saved last.
;      This is done so the debugger can find the saved ebp for a thread
;      that is not currently in the running state.
;

        sub     esp, 4*4
        mov     [esp+12], ebx           ; save registers
        mov     [esp+8], esi            ;
        mov     [esp+4], edi            ;
        mov     [esp+0], ebp            ;
        mov     ebx, PCR[PcSelfPcr]     ; set address of PCR
        mov     edi, ecx                ; set old thread address
        mov     esi, edx                ; set next thread address
        movzx   ecx, byte ptr [edi].ThWaitirql ; set APC interrupt bypass disable

        call    SwapContext             ; swap context
        mov     ebp, [esp+0]            ; restore registers
        mov     edi, [esp+4]            ;
        mov     esi, [esp+8]            ;
        mov     ebx, [esp+12]           ;
        add     esp, 4*4                ;
        fstRET  KiSwapContext           ;

fstENDP KiSwapContext

        page ,132
        subttl  "Dispatch Interrupt"
;++
;
; Routine Description:
;
;    This routine is entered as the result of a software interrupt generated
;    at DISPATCH_LEVEL. Its function is to process the Deferred Procedure Call
;    (DPC) list, and then perform a context switch if a new thread has been
;    selected for execution on the processor.
;
;    This routine is entered at IRQL DISPATCH_LEVEL with the dispatcher
;    database unlocked. When a return to the caller finally occurs, the
;    IRQL remains at DISPATCH_LEVEL, and the dispatcher database is still
;    unlocked.
;
; Arguments:
;
;    None
;
; Implicit Arguments:
;
;    ecx - Supplies the address of an optional trap frame.
;
; Return Value:
;
;    None.
;
;--

        align 16
cPublicProc _KiDispatchInterrupt ,0
cPublicFpo 0, 0

;
; Check if an SLIST pop operation is being interrupted and reset EIP as
; necessary.
;
; N.B. ecx is already loaded.
;

        test    ecx, ecx                ; check for NULL trap frame
        jz      short @f                ; if z, trap frame NULL
        fstCall KiCheckForSListAddress  ; check SLIST addresses
@@:                                     ; reference label

;
; Disable interrupts and check if there is any work in the DPC list
; of the current processor.
;

        mov     ebx, PCR[PcSelfPcr]     ; get address of PCR
kdi00:  cli                             ; disable interrupts
        mov     eax, [ebx]+PcPrcbData+PbDpcQueueDepth ; get DPC queue depth
        or      eax, [ebx]+PcPrcbData+PbTimerRequest ; merge timer request

ifndef NT_UP

        or      eax, [ebx]+PcPrcbData+PbDeferredReadyListHead ; merge deferred list head

endif

        jz      short kdi40             ; if z, no DPC's or timers to process
        push    ebp                     ; save register

;
; Exceptions occurring in DPCs are unrelated to any exception handlers
; in the interrupted thread.  Terminate the exception list.
;

        push    [ebx].PcExceptionList
        mov     [ebx].PcExceptionList, EXCEPTION_CHAIN_END

;
; Switch to the DPC stack for this processor.
;

        mov     edx, esp
        mov     esp, [ebx].PcPrcbData.PbDpcStack
        push    edx

.fpo (0, 0, 0, 1, 1, 0)

        mov     ecx, [ebx].PcPrcb       ; get current PRCB address
        fstCall KiRetireDpcList         ; process the current DPC list

;
; Switch back to the current thread stack, restore the exception list
; and saved EBP.
;

        pop     esp
        pop     [ebx].PcExceptionList
        pop     ebp 
.fpo (0, 0, 0, 0, 0, 0)

;
; Check to determine if quantum end is requested.
;
; N.B. If a new thread is selected as a result of processing the quantum
;      end request, then the new thread is returned with the dispatcher
;      database locked. Otherwise, NULL is returned with the dispatcher
;      database unlocked.
;

kdi40:  sti                             ; enable interrupts
        cmp     byte ptr [ebx].PcPrcbData.PbQuantumEnd, 0 ; quantum end requested
        jne     kdi90                   ; if neq, quantum end request

;
; Check to determine if a new thread has been selected for execution on this
; processor.
;

        cmp     dword ptr [ebx].PcPrcbData.PbNextThread, 0 ; check if next thread
        je      kdi70                   ; if eq, then no new thread

;
; N.B. The following registers MUST be saved such that ebp is saved last.
;      This is done so the debugger can find the saved ebp for a thread
;      that is not currently in the running state.
;

.fpo (0, 0, 0, 3, 1, 0)

        sub     esp, 3*4
        mov     [esp+8], esi            ; save registers
        mov     [esp+4], edi            ;
        mov     [esp+0], ebp            ;
        mov     edi, [ebx].PcPrcbData.PbCurrentThread ; get current thread address (as old thread)

;
; Raise IRQL to SYNCH level, set context swap busy for the old thread, and
; acquire the current PRCB lock.
;

ifndef NT_UP

        call    dword ptr [__imp__KeRaiseIrqlToSynchLevel@0] ; raise IRQL to SYNCH
        mov     byte ptr [edi].ThSwapBusy, 1 ; set context swap busy
        lea     ecx, [ebx].PcPrcbData.PbPrcbLock ; get PRCB lock address
   lock bts     dword ptr [ecx], 0      ; try to acquire PRCB lock
        jnc     short kdi50             ; if nc, PRCB lock acquired
        fstCall KefAcquireSpinLockAtDpcLevel ; acquire current PRCB lock

endif

;
; Get the next thread address, set the thread state to running, queue the old
; running thread, and swap context to the next thread.
;

kdi50:  mov     esi, [ebx].PcPrcbData.PbNextThread ; get next thread address
        and     dword ptr [ebx].PcPrcbData.PbNextThread, 0 ; clear next thread address
        mov     [ebx].PcPrcbData.PbCurrentThread, esi ; set current thread address
        mov     byte ptr [esi]+ThState, Running ; set thread state to running
        mov     byte ptr [edi].ThWaitReason, WrDispatchInt  ; set wait reason
        mov     ecx, edi                ; set address of curent thread
        lea     edx, [ebx].PcPrcbData   ; set address of PRCB
        fstCall KiQueueReadyThread      ; ready thread for execution
        mov     cl, APC_LEVEL           ; set APC interrupt bypass disable
        call    SwapContext             ; swap context
        mov     ebp, [esp+0]            ; restore registers
        mov     edi, [esp+4]            ;
        mov     esi, [esp+8]            ;
        add     esp, 3*4
kdi70:  stdRET  _KiDispatchInterrupt    ; return

;
; Process quantum end event.
;
; N.B. If the quantum end code returns a NULL value, then no next thread
;      has been selected for execution. Otherwise, a next thread has been
;      selected and the source thread lock has been acquired.
;

kdi90:  mov     byte ptr [ebx].PcPrcbData.PbQuantumEnd, 0 ; clear quantum end indicator
        stdCall _KiQuantumEnd           ; process quantum end
        stdRET  _KiDispatchInterrupt    ; return

stdENDP _KiDispatchInterrupt

        page ,132
        subttl  "Swap Context to Next Thread"
;++
;
; Routine Description:
;
;    This routine is called to swap context from one thread to the next.
;    It swaps context, flushes the data, instruction, and translation
;    buffer caches, restores nonvolatile integer registers, and returns
;    to its caller.
;
;    N.B. It is assumed that the caller (only callers are within this
;         module) saved the nonvolatile registers, ebx, esi, edi, and
;         ebp. This enables the caller to have more registers available.
;
; Arguments:
;
;    cl - APC interrupt bypass disable (zero enable, nonzero disable).
;    edi - Address of previous thread.
;    esi - Address of next thread.
;    ebx - Address of PCR.
;
; Return value:
;
;    al - Kernel APC pending.
;    ebx - Address of PCR.
;    esi - Address of current thread object.
;
;--

;
;   NOTE:   The ES: override on the move to ThState is part of the
;           lazy-segment load system.  It assures that ES has a valid
;           selector in it, thus preventing us from propagating a bad
;           ES across a context switch.
;
;           Note that if segments, other than the standard flat segments,
;           with limits above 2 gig exist, neither this nor the rest of
;           lazy segment loads are reliable.
;
; Note that ThState must be set before the dispatcher lock is released
; to prevent KiSetPriorityThread from seeing a stale value.
;

ifndef NT_UP

        public  _ScPatchFxb
        public  _ScPatchFxe

endif

        public  SwapContext

        align   16

SwapContext     proc

;
; Save the APC disable flag.
;
        push    ecx                     ; save APC bypass disable
cPublicFpo 0, 1

;
; Wait for context to be swapped for the target thread.
;

ifndef NT_UP

sc00:   cmp     byte ptr [esi].ThSwapBusy, 0 ; check if context swap busy
        je      short sc01              ; if e, context swap idle
        YIELD                           ; yield execution for SMT system
        jmp     short sc00              ;

endif

;
; Increment the number of context switches on this processor.
;
; N.B. This increment is done here is force the cache block containing the
;      context switch count into the cache as write exclusive. There are
;      several other references to this cache block in the following code.
;

sc01:   inc     es:dword ptr [ebx]+PcContextSwitches ; processor count

;
; Save the thread exception list head.
;

        push    [ebx]+PcExceptionList   ; save thread exception list head

cPublicFpo 0, 2

;
; Check for context swap logging.
;

        cmp     [ebx]+PcPerfGlobalGroupMask, 0 ; check if logging enable
        jne     sc92                    ; If not, then check if we are enabled
sc03:

ifndef NT_UP

if DBG

        mov     cl, [esi]+ThNextProcessor ; get current processor number
        cmp     cl, [ebx]+PcPrcbData+PbNumber ; same as running processor?
        jne     sc_error2               ; if ne, processor number mismatch

endif

endif

;
; On a uniprocessor system the NPX state is swapped in a lazy manner.
; If a thread whose state is not in the coprocessor attempts to perform
; a coprocessor operation, the current NPX state is swapped out (if needed),
; and the new state is swapped in during the fault.  (KiTrap07)
;
; On a multiprocessor system we still fault in the NPX state on demand, but
; we save the state when the thread switches out (assuming the NPX state
; was loaded).  This is because it could be difficult to obtain the thread's
; NPX in the trap handler if it was loaded into a different processor's
; coprocessor.
;

        mov     ebp, cr0                ; get current CR0
        mov     edx, ebp                ;

ifndef NT_UP

        cmp     byte ptr [edi]+ThNpxState, NPX_STATE_LOADED ; check if NPX state
        je      sc_save_npx_state       ; if e, NPX state not loaded

endif

;
; Save the old stack pointer and compute the new stack limits.
;

sc05:   mov     [edi]+ThKernelStack, esp ; save old kernel stack pointer
        mov     eax, [esi]+ThInitialStack ; get new initial stack pointer


;
; (eax) = Initial Stack
; (ebx) = PCR
; (edi) = OldThread
; (esi) = NewThread
; (ebp) = Current CR0
; (edx) = Current CR0
;

.errnz (NPX_STATE_NOT_LOADED - CR0_TS - CR0_MP)
.errnz (NPX_STATE_LOADED - 0)

ifdef NT_UP
;
; On UP systems floating point state might be being changed by an ISR so we
; block interrupts.
;
        cli
endif
        movzx   ecx, byte ptr [esi]+ThNpxState ; new NPX state is (or is not) loaded
        and     edx, NOT (CR0_MP+CR0_EM+CR0_TS) ; clear thread settable NPX bits
        or      ecx, edx                ; or in new thread's cr0
        or      ecx, [eax]+FpCr0NpxState-NPX_FRAME_LENGTH ; merge new thread settable state
        cmp     ebp, ecx                ; check if old and new CR0 match
        jne     sc_reload_cr0           ; if ne, change in CR0
sc06:

ifdef NT_UP
        sti
endif

if DBG
        mov     eax, [esi]+ThKernelStack ; set new stack pointer
        cmp     esi, dword ptr [eax-4]
        je      @f
        int     3
@@:
        xchg    esp, eax
        mov     [eax-4], edi             ; Save thread address on stack below stack pointer
else
        mov     esp, [esi]+ThKernelStack ; set new stack pointer
endif


;
; Check if the old process is the same as the new process.
;

        mov     ebp, [esi].ThApcState.AsProcess ; get old process address
        mov     eax, [edi].ThApcState.AsProcess ; get old process address
        cmp     ebp, eax                        ; check if process match
        jz      short sc23                      ; if z, process match

;
; Set the processor bit in the new process and clear the old.
;

ifndef NT_UP

        mov     ecx, [ebx]+PcSetMemberCopy ; get processor set member
   lock xor     [ebp]+PrActiveProcessors, ecx ; set bit in new processor set
   lock xor     [eax]+PrActiveProcessors, ecx ; clear bit in old processor set

if DBG

        test    [ebp]+PrActiveProcessors, ecx ; test if bit set in new set
        jz      sc_error5               ; if z, bit not set in new set
        test    [eax]+PrActiveProcessors, ecx ; test if bit clear in old set
        jnz     sc_error4               ; if nz, bit not clear in old set
endif

endif

;
; LDT switch, If either the target or source process have an LDT we need to
; load the ldt
;

        mov     ecx, [ebp]+PrLdtDescriptor
        or      ecx, [eax]+PrLdtDescriptor
        jnz     sc_load_ldt             ; if nz, LDT limit
sc_load_ldt_ret:

;
; Load the new CR3 and as a side effect flush non-global TB entries.
;

        mov     eax, [ebp]+PrDirectoryTableBase ; get new directory base
        mov     cr3, eax                ; and flush TB


;
; Set context swap idle for the old thread.
;

sc23:                                   ;

ifndef NT_UP

        and     byte ptr [edi].ThSwapBusy, 0 ; clear old thread swap busy

endif

        xor     eax, eax
        mov     gs, eax

;
; Set the TEB descriptor to point to the thread TEB and set the TEB address
; in the PCR. The es override here is to force lazy segment loading to occur.
;
        mov     eax, [esi]+ThTeb        ; get user TEB address
        mov     [ebx]+PcTeb, eax        ; set user TEB address
        mov     ecx, [ebx]+PcGdt        ; get GDT address
        mov     [ecx]+(KGDT_R3_TEB+KgdtBaseLow), ax ;
        shr     eax, 16                 ;
        mov     [ecx]+(KGDT_R3_TEB+KgdtBaseMid), al ;
        mov     [ecx]+(KGDT_R3_TEB+KgdtBaseHi), ah ;

;
; Adjust the initial stack address, if necessary, and store in the TSS so V86
; mode threads and 32 bit threads can share a common trapframe structure and
; the NPX save area will be accessible in the same manner on all threads.
;

        mov     eax, [esi].ThInitialStack ; get initial stack address
        sub     eax, NPX_FRAME_LENGTH
.errnz (EFLAGS_V86_MASK AND 0FF00FFFFh)
        test    byte ptr [eax] - KTRAP_FRAME_LENGTH + TsEFlags + 2, EFLAGS_V86_MASK / 10000h
        jnz     short sc24              ; if nz, V86 frame, no adjustment
        sub     eax, TsV86Gs - TsHardwareSegSs ; bias for missing fields
sc24:   mov     ecx, [ebx]+PcTssCopy    ; get TSS address
        mov     [ecx]+TssEsp0, eax      ; set initial kernel stack address

;
; Set the IOPM map offset value.
;
; N.B. This may be a redundant load of this value if the process did not
;      change during the context switch. However, always reloading this
;      value saves several instructions under the context swap lock.
;

        mov     ax, [ebp]+PrIopmOffset  ; set IOPM offset
        mov     [ecx]+TssIoMapBase, ax  ;
;
; Update context switch counters.
;

        inc     dword ptr [esi]+ThContextSwitches ; thread count

;
; Restore thread exception list head and get APC bypass disable.
;

        pop     [ebx].PcExceptionList   ; restore thread exception list head
        pop     ecx                     ; get APC bypass disable

;
; Check if an attempt is being made to context switch while in a DPC routine.
;

        cmp     byte ptr [ebx]+PcPrcbData+PbDpcRoutineActive, 0 ; check if DPC active
        jne     sc91                    ; bugcheck if DPC active.

;
; If the new thread has a kernel mode APC pending, then request an APC
; interrupt.
;

        cmp     byte ptr [esi].ThApcState.AsKernelApcPending, 0 ; APC pending?
        jne     short sc80              ; if ne, kernel APC pending
        xor     eax, eax                ; set return value
        ret                             ; return

;
; The new thread has an APC interrupt pending.
;
; If the the special APC disable count is nonzero, then return no kernel APC
; pending. An APC will be requested when the special APC disable count reaches
; zero. 
;
; If APC interrupt bypass is not enabled, then request a software interrupt
; at APC_LEVEL and return no kernel APC pending. Otherwise, return kernel APC
; pending.
;

sc80:   cmp     word ptr [esi].ThSpecialApcDisable, 0 ; check if special APC disable
        jne     short sc90              ; if ne, special APC disable
        test    cl, cl                  ; test for APC bypass disable
        jz      short sc90              ; if z, APC bypass enabled
        mov     cl, APC_LEVEL           ; request software interrupt level
        fstCall HalRequestSoftwareInterrupt ;
        or      eax, esp                ; clear ZF flag
sc90:   setz    al                      ; set return value
        ret                             ; return


;
; Set for new LDT value
;

sc_load_ldt:
        mov     eax, [ebp+PrLdtDescriptor] ;
        test    eax, eax
        je      @f
        mov     ecx, [ebx]+PcGdt        ; get GDT address
        mov     [ecx+KGDT_LDT], eax     ;
        mov     eax, [ebp+PrLdtDescriptor+4] ;
        mov     [ecx+KGDT_LDT+4], eax   ;

;
; Set up int 21 descriptor of IDT.  If the process does not have an Ldt, it
; should never make any int 21 calls.  If it does, an exception is generated. If
; the process has an Ldt, we need to update int21 entry of LDT for the process.
; Note the Int21Descriptor of the process may simply indicate an invalid
; entry.  In which case, the int 21 will be trapped to the kernel.
;

        mov     ecx, [ebx]+PcIdt        ;
        mov     eax, [ebp+PrInt21Descriptor] ;
        mov     [ecx+21h*8], eax        ;
        mov     eax, [ebp+PrInt21Descriptor+4] ;
        mov     [ecx+21h*8+4], eax      ;
        mov     eax, KGDT_LDT
@@:     lldt    ax
        jmp     sc_load_ldt_ret

;
; Cr0 has changed (ie, floating point processor present), load the new value.
;

sc_reload_cr0:

if DBG

        test    byte ptr [esi]+ThNpxState, NOT (CR0_TS+CR0_MP)
        jnz     sc_error                ;
        test    dword ptr [eax]+FpCr0NpxState-NPX_FRAME_LENGTH, NOT (CR0_PE+CR0_MP+CR0_EM+CR0_TS)
        jnz     sc_error3               ;

endif

        mov     cr0,ecx                 ; set new CR0 NPX state
        jmp     sc06

;
; Save coprocessor's current context.  FpCr0NpxState is the current thread's
; CR0 state.  The following bits are valid: CR0_MP, CR0_EM, CR0_TS.  MVDMs
; may set and clear MP & EM as they please and the settings will be reloaded
; on a context switch (but they will not be saved from CR0 to Cr0NpxState).
; The kernel sets and clears TS as required.
;
; (ebp) = Current CR0
; (edx) = Current CR0
;

ifndef NT_UP

sc_save_npx_state:
        and     edx, NOT (CR0_MP+CR0_EM+CR0_TS) ; we need access to the NPX state

        mov     ecx, [edi].ThInitialStack        ; get NPX save save area address
        sub     ecx, NPX_FRAME_LENGTH

        cmp     ebp, edx                        ; Does CR0 need reloading?
        je      short sc_npx10

        mov     cr0, edx                        ; set new cr0
        mov     ebp, edx                        ; (ebp) = (edx) = current cr0 state

sc_npx10:

;
; The fwait following the fnsave is to make sure that the fnsave has stored the
; data into the save area before this coprocessor state could possibly be
; context switched in and used on a different (co)processor.  I've added the
; clocks from when the dispatcher lock is released and don't believe it's a
; possibility.  I've also timed the impact this fwait seems to have on a 486
; when performing lots of numeric calculations.  It appears as if there is
; nothing to wait for after the fnsave (although the 486 manual says there is)
; and therefore the calculation time far outweighed the 3clk fwait and it
; didn't make a noticable difference.
;

;
; If FXSR feature is NOT present on the processor, the fxsave instruction is
; patched at boot time to start using fnsave instead
;

_ScPatchFxb:
;       fxsave  [ecx]                   ; save NPX state
        db      0FH, 0AEH, 01
_ScPatchFxe:

        mov     byte ptr [edi]+ThNpxState, NPX_STATE_NOT_LOADED ; set no NPX state
        mov     dword ptr [ebx].PcPrcbData+PbNpxThread, 0  ; clear npx owner
        jmp     sc05
endif

;
; This code is out of line to optimize the normal case with tracing is off.
;

sc92:   mov     eax, [ebx]+PcPerfGlobalGroupMask ; Load the ptr into eax
        cmp     eax, 0                  ; catch race condition on pointer here
        jz      sc03                    ; instead of above in mainline code
        mov     edx, esi                ; pass the new ETHREAD object
        mov     ecx, edi                ; pass the old ETHREAD object
        test    dword ptr [eax+PERF_CONTEXTSWAP_OFFSET], PERF_CONTEXTSWAP_FLAG
        jz      sc03                    ; return if our flag is not set

        fstCall WmiTraceContextSwap     ; call the Wmi context swap trace
        jmp     sc03                    ;

;
; A context switch was attempted while executing a DPC - bugcheck.
;

.fpo (2, 0, 0, 0, 0, 0)
sc91:
        mov     eax, [edi]+ThInitialStack ; get the old stack so it can
                                          ; be saved in the minidump
        stdCall _KeBugCheckEx <ATTEMPTED_SWITCH_FROM_DPC, edi, esi, eax, 0>
        ret                             ; return

if DBG
sc_error5:  int 3
sc_error4:  int 3
sc_error3:  int 3
sc_error2:  int 3
sc_error:   int 3
endif

SwapContext     endp

        page , 132
        subttl "Flush EntireTranslation Buffer"
;++
;
; VOID
; KeFlushCurrentTb (
;     )
;
; Routine Description:
;
;     This function flushes the entire translation buffer (TB) on the current
;     processor and also flushes the data cache if an entry in the translation
;     buffer has become invalid.
;
; Arguments:
;
; Return Value:
;
;     None.
;
;--

cPublicProc _KeFlushCurrentTb ,0

ktb00:  mov     eax, cr3                ; (eax) = directory table base
        mov     cr3, eax                ; flush TLB
        stdRET    _KeFlushCurrentTb

ktb_gb: mov     eax, cr4                ; *** see Ki386EnableGlobalPage ***
        and     eax, not CR4_PGE        ; This FlushCurrentTb version gets copied into
        mov     cr4, eax                ; ktb00 at initialization time if needed.
        or      eax, CR4_PGE
        mov     cr4, eax
ktb_eb: stdRET    _KeFlushCurrentTb

stdENDP _KeFlushCurrentTb
        ;;
        ;; moved KiFlushDcache below KeFlushCurrentTb for BBT purposes.  BBT
        ;; needs an end label to treat KeFlushCurrentTb as data and to keep together.
        ;;
        page , 132
        subttl "Flush Data Cache"
;++
;
; VOID
; KiFlushDcache (
;     )
;
; VOID
; KiFlushIcache (
;     )
;
; Routine Description:
;
;   This routine does nothing on i386 and i486 systems.   Why?  Because
;   (a) their caches are completely transparent,  (b) they don't have
;   instructions to flush their caches.
;
; Arguments:
;
;     None.
;
; Return Value:
;
;     None.
;
;--

cPublicProc _KiFlushDcache  ,0
cPublicProc _KiFlushIcache  ,0

        stdRET    _KiFlushIcache

stdENDP _KiFlushIcache
stdENDP _KiFlushDcache


_TEXT$00   ends

INIT    SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

;++
;
; VOID
; Ki386EnableGlobalPage (
;     IN volatile PLONG Number
;     )
;
; /*++
;
; Routine Description:
;
;     This routine enables the global page PDE/PTE support in the system,
;     and stalls until complete and them sets the current processor's cr4
;     register to enable global page support.
;
; Arguments:
;
;     Number - Supplies a pointer to the count of the number of processors in
;     the configuration.
;
; Return Value:
;
;     None.
;--

cPublicProc _Ki386EnableGlobalPage,1
        push    esi
        push    edi
        push    ebx

        mov     edx, [esp+16]           ; pointer to Number
        pushfd
        cli

;
; Wait for all processors
;
        lock dec dword ptr [edx]        ; count down
egp10:  YIELD
        cmp     dword ptr [edx], 0      ; wait for all processors to signal
        jnz     short egp10

        cmp     byte ptr PCR[PcNumber], 0 ; processor 0?
        jne     short egp20

;
; Install proper KeFlushCurrentTb function.
;

        mov     edi, ktb00
        mov     esi, ktb_gb
        mov     ecx, ktb_eb - ktb_gb + 1
        rep movsb

        mov     byte ptr [ktb_eb], 0

;
; Wait for P0 to signal that proper flush TB handlers have been installed
;
egp20:  cmp     byte ptr [ktb_eb], 0
        jnz     short egp20

;
; Flush TB, and enable global page support
; (note load of CR4 is explicitly done before the load of CR3
; to work around P6 step B0 errata 11)
;
        mov     eax, cr4
        and     eax, not CR4_PGE        ; should not be set, but let's be safe
        mov     ecx, cr3
        mov     cr4, eax

        mov     cr3, ecx                ; Flush TB

        or      eax, CR4_PGE            ; enable global TBs
        mov     cr4, eax
        popfd
        pop     ebx
        pop     edi
        pop     esi

        stdRET  _Ki386EnableGlobalPage
stdENDP _Ki386EnableGlobalPage

;++
;
; VOID
; Ki386EnableDE (
;     IN volatile PLONG Number
;     )
;
; /*++
;
; Routine Description:
;
;     This routine sets DE bit in CR4 to enable IO breakpoints
;
; Arguments:
;
;     Number - Supplies a pointer to the count of the number of processors in
;     the configuration.
;
; Return Value:
;
;     None.
;--

cPublicProc _Ki386EnableDE,1

        mov     eax, cr4
        or      eax, CR4_DE
        mov     cr4, eax

        stdRET  _Ki386EnableDE
stdENDP _Ki386EnableDE


;++
;
; VOID
; Ki386EnableFxsr (
;     IN volatile PLONG Number
;     )
;
; /*++
;
; Routine Description:
;
;     This routine sets OSFXSR bit in CR4 to indicate that OS supports
;     FXSAVE/FXRSTOR for use during context switches
;
; Arguments:
;
;     Number - Supplies a pointer to the count of the number of processors in
;     the configuration.
;
; Return Value:
;
;     None.
;--

cPublicProc _Ki386EnableFxsr,1

        mov     eax, cr4
        or      eax, CR4_FXSR
        mov     cr4, eax

        stdRET  _Ki386EnableFxsr
stdENDP _Ki386EnableFxsr


;++
;
; VOID
; Ki386EnableXMMIExceptions (
;     IN volatile PLONG Number
;     )
;
; /*++
;
; Routine Description:
;
;     This routine installs int 19 XMMI unmasked Numeric Exception handler
;     and sets OSXMMEXCPT bit in CR4 to indicate that OS supports
;     unmasked Katmai New Instruction technology exceptions.
;
; Arguments:
;
;     Number - Supplies a pointer to count of the number of processors in
;     the configuration.
;
; Return Value:
;
;     None.
;--

cPublicProc _Ki386EnableXMMIExceptions,1


        ;Set up IDT for INT19
        mov     ecx,PCR[PcIdt]              ;Get IDT address
        lea     eax, [ecx] + 098h           ;XMMI exception is int 19
        mov     byte ptr [eax + 5], 08eh    ;P=1,DPL=0,Type=e
        mov     word ptr [eax + 2], KGDT_R0_CODE ;Kernel code selector
        mov     edx, offset FLAT:_KiTrap13  ;Address of int 19 handler
        mov     ecx,edx
        mov     word ptr [eax],cx           ;addr moves into low byte
        shr     ecx,16
        mov     word ptr [eax + 6],cx       ;addr moves into high byte
        ;Enable XMMI exception handling
        mov     eax, cr4
        or      eax, CR4_XMMEXCPT
        mov     cr4, eax

        stdRET  _Ki386EnableXMMIExceptions
stdENDP _Ki386EnableXMMIExceptions


;++
;
; VOID
; Ki386EnableCurrentLargePage (
;     IN ULONG IdentityAddr,
;     IN ULONG IdentityCr3
;     )
;
; /*++
;
; Routine Description:
;
;     This routine enables the large page PDE support in the processor.
;
; Arguments:
;
;     IdentityAddr - Supplies the linear address of the beginning of this
;     function where (linear == physical).
;
;     IdentityCr3 - Supplies a pointer to the temporary page directory and
;     page tables that provide both the kernel (virtual ->physical) and
;     identity (linear->physical) mappings needed for this function.
;
; Return Value:
;
;     None.
;--

public _Ki386EnableCurrentLargePageEnd
cPublicProc _Ki386EnableCurrentLargePage,2
        mov     ecx,[esp]+4             ; (ecx)-> IdentityAddr
        mov     edx,[esp]+8             ; (edx)-> IdentityCr3
        pushfd                          ; save current IF state
        cli                             ; disable interrupts

        mov     eax, cr3                ; (eax)-> original Cr3
        mov     cr3, edx                ; load Cr3 with Identity mapping

        sub     ecx, offset _Ki386EnableCurrentLargePage
        add     ecx, offset _Ki386LargePageIdentityLabel
        jmp     ecx                     ; jump to (linear == physical)

_Ki386LargePageIdentityLabel:
        mov    ecx, cr0
        and    ecx, NOT CR0_PG          ; clear PG bit to disable paging
        mov    cr0, ecx                 ; disable paging
        jmp    $+2
        mov     edx, cr4
        or      edx, CR4_PSE            ; enable Page Size Extensions
        mov     cr4, edx
        mov     edx, offset OriginalMapping
        or      ecx, CR0_PG             ; set PG bit to enable paging
        mov     cr0, ecx                ; enable paging
        jmp     edx                     ; Return to original mapping.

OriginalMapping:
        mov     cr3, eax                ; restore original Cr3
        popfd                           ; restore interrupts to previous

        stdRET  _Ki386EnableCurrentLargePage

_Ki386EnableCurrentLargePageEnd:

stdENDP _Ki386EnableCurrentLargePage

INIT    ends

_TEXT$00   SEGMENT PARA PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

        page , 132
        subttl "Swap Process"
;++
;
; VOID
; KiSwapProcess (
;     IN PKPROCESS NewProcess,
;     IN PKPROCESS OldProcess
;     )
;
; Routine Description:
;
;     This function swaps the address space to another process by flushing
;     the data cache, the instruction cache, the translation buffer, and
;     establishes a new directory table base.
;
;     It also swaps in the LDT and IOPM of the new process.  This is necessary
;     to avoid bogus mismatches in SwapContext.
;
;     NOTE: keep in sync with process switch part of SwapContext
;
; Arguments:
;
;     Process - Supplies a pointer to a control object of type process.
;
; Return Value:
;
;     None.
;
;--

cPublicProc _KiSwapProcess  ,2
cPublicFpo 2, 0

        mov     edx,[esp]+4             ; (edx)-> New process
        mov     eax,[esp]+8             ; (eax)-> Old Process

;
; Set the processor number in the new process and clear it in the old.
;

ifndef NT_UP

        mov     ecx, PCR[PcSetMember]
   lock xor     [edx]+PrActiveProcessors,ecx ; set bit in new processor set
   lock xor     [eax]+PrActiveProcessors,ecx ; clear bit in old processor set

if DBG

        test    [edx]+PrActiveProcessors,ecx ; test if bit set in new set
        jz      kisp_error1             ; if z, bit not set in new set
        test    [eax]+PrActiveProcessors,ecx ; test if bit clear in old set
        jnz     kisp_error              ; if nz, bit not clear in old set

endif

endif

;
;   Change LDT, If either the source or target process has an LDT we need to
;   load the new one.
;

        mov     ecx, [edx]+PrLdtDescriptor
        or      ecx, [eax]+PrLdtDescriptor
        jnz     kisp_load_ldt           ; if nz, LDT limit
kisp_load_ldt_ret:                      ; if nz, LDT limit

;
; Load the new CR3 and as a side effect flush non-global TB entries.
;

        mov     eax,[edx]+PrDirectoryTableBase
        mov     cr3,eax

        mov     ecx,PCR[PcTssCopy]      ; (ecx)-> TSS

;
;   Clear gs so it can't leak across processes
;

        xor     eax,eax                         ; assume ldtr is to be NULL
        mov     gs,ax                           ; Clear gs.  (also workarounds

;
;   Change IOPM
;

        mov     ax,[edx]+PrIopmOffset
        mov     [ecx]+TssIoMapBase,ax

        stdRET    _KiSwapProcess

kisp_load_ldt:

;
;   Edit LDT descriptor
;

        mov     eax,[edx+PrLdtDescriptor]
        test    eax, eax
        je      @f
        mov     ecx,PCR[PcGdt]
        mov     [ecx+KGDT_LDT],eax
        mov     eax,[edx+PrLdtDescriptor+4]
        mov     [ecx+KGDT_LDT+4],eax

;
;   Set up int 21 descriptor of IDT.  If the process does not have Ldt, it
;   should never make any int 21 call.  If it does, an exception is generated.
;   If the process has Ldt, we need to update int21 entry of LDT for the process.
;   Note the Int21Descriptor of the process may simply indicate an invalid
;   entry.  In which case, the int 21 will be trapped to the kernel.
;

        mov     ecx, PCR[PcIdt]
        mov     eax, [edx+PrInt21Descriptor]
        mov     [ecx+21h*8], eax
        mov     eax, [edx+PrInt21Descriptor+4]
        mov     [ecx+21h*8+4], eax

        mov     eax,KGDT_LDT                    ;@@32-bit op to avoid prefix
@@:     lldt    ax
        jmp     kisp_load_ldt_ret

if DBG
kisp_error1: int 3
kisp_error:  int 3
endif

stdENDP _KiSwapProcess

        page ,132
        subttl  "Idle Loop"
;++
;
; VOID
; KiIdleLoop(
;     VOID
;     )
;
; Routine Description:
;
;    This routine continuously executes the idle loop and never returns.
;
; Arguments:
;
;    ebx - Address of the current processor's PCR.
;
; Return value:
;
;    None - routine never returns.
;
;--

cPublicFastCall KiIdleLoop  ,0
cPublicFpo 0, 0

if DBG

        xor     edi, edi                ; reset poll breakin counter

endif

        jmp     short kid20             ; Skip HalIdleProcessor on first iteration

;
; There are no entries in the DPC list and a thread has not been selected
; for execution on this processor. Call the HAL so power managment can be
; performed.
;
; N.B. The HAL is called with interrupts disabled. The HAL will return
;      with interrupts enabled.
;
; N.B. Use a call instruction instead of a push-jmp, as the call instruction
;      executes faster and won't invalidate the processor's call-return stack
;      cache.
;

kid10:  lea     ecx, [ebx].PcPrcbData.PbPowerState
        call    dword ptr [ecx].PpIdleFunction      ; (ecx) = Arg0

;
; Give the debugger an opportunity to gain control on debug systems.
;
; N.B. On an MP system the lowest numbered idle processor is the only
;      processor that polls for a breakin request.
;

kid20:

if DBG
ifndef NT_UP

        mov     eax, _KiIdleSummary     ; get idle summary
        mov     ecx, [ebx].PcSetMember  ; get set member
        dec     ecx                     ; compute right bit mask
        and     eax, ecx                ; check if any lower bits set
        jnz     short CheckDpcList      ; if nz, not lowest numbered

endif

        dec     edi                     ; decrement poll counter
        jg      short CheckDpcList      ; if g, not time to poll

        POLL_DEBUGGER                   ; check if break in requested
endif

kid30:

if DBG

ifndef NT_UP

        mov     edi, 20 * 1000          ; set breakin poll interval

else

        mov     edi, 100                ; UP idle loop has a HLT in it

endif

endif

CheckDpcList0:                          ;
        YIELD

;
; Disable interrupts and check if there is any work in the DPC list of the
; current processor or a target processor.
;

CheckDpcList:

;
; N.B. The following code enables interrupts for a few cycles, then
;      disables them again for the subsequent DPC and next thread
;      checks.
;

        sti                             ; enable interrupts
        nop                             ;
        nop                             ;
        cli                             ; disable interrupts

;
; Process the deferred procedure call list for the current processor.
;

        mov     eax, [ebx]+PcPrcbData+PbDpcQueueDepth ; get DPC queue depth
        or      eax, [ebx]+PcPrcbData+PbTimerRequest ; merge timer request

ifndef NT_UP

        or      eax, [ebx]+PcPrcbData+PbDeferredReadyListHead ; merge deferred list head

endif

        jz      short CheckNextThread   ; if z, no DPC's or timers to process
        mov     cl, DISPATCH_LEVEL      ; set interrupt level
        fstCall HalClearSoftwareInterrupt ; clear software interrupt
        lea     ecx, [ebx].PcPrcbData   ; set current PRCB address
        fstCall KiRetireDpcList         ; process the current DPC list

if DBG

        xor     edi, edi                ; clear breakin poll interval

endif

;
; Check if a thread has been selected to run on the current processor.
;

CheckNextThread:                        ;
        cmp     dword ptr [ebx].PcPrcbData.PbNextThread, 0 ; thread selected?

ifdef NT_UP

        je      short kid10             ; if eq, no thread selected

else

        je      kid40                   ; if eq, no thread selected.

endif

;
; Raise IRQL to synchronization level and enable interrupts.
;

ifndef NT_UP

        RaiseIrql SYNCH_LEVEL, NoOld    ; raise IRQL to synchronization level

endif

        sti                             ; enable interrupts
        mov     edi, [ebx].PcPrcbData.PbCurrentThread ; get idle thread address

;
; Set context swap busy for idle thread and acquire the PRCB lock.
;

ifndef NT_UP

        mov     byte ptr [edi].ThSwapBusy, 1 ; set context swap busy
   lock bts     dword ptr [ebx].PcPrcbData.PbPrcbLock, 0 ; try to acquire PRCB Lock
        jnc     short kid33             ; if nc, PRCB lock acquired
        lea     ecx, [ebx].PcPrcbData.PbPrcbLock ; get PRCB lock address
        fstCall KefAcquireSpinLockAtDpcLevel ; acquire current PRCB lock

endif

;
; If a thread had been scheduled for this processor but was removed from
; eligibility (e.g., an affinity change), then the new thread could be the
; idle thread.
;

kid33:  mov     esi, [ebx].PcPrcbData.PbNextThread ; get next thread address

ifndef NT_UP
                                        
        cmp     esi, edi                ; check if idle thread
        je      short kisame            ; if e, processor idle again

endif

        and     dword ptr [ebx].PcPrcbData.PbNextThread, 0 ; clear next thread
        mov     [ebx].PcPrcbData.PbCurrentThread, esi ; set new thread address
        mov     byte  ptr [esi]+ThState, Running ; set thread state running

;
; Clear idle schedule since a new thread has been selected for execution on
; this processor and release the PRCB lock.
;

ifndef NT_UP

        and     byte ptr [ebx].PcPrcbData.PbIdleSchedule, 0 ; clear idle schedule
        and     dword ptr [ebx].PcPrcbData.PbPrcbLock, 0 ; release current PRCB lock

endif

kid35:                                  ;

        mov     ecx, APC_LEVEL          ; set APC bypass disable
        call    SwapContext             ; swap context

ifndef NT_UP

        LowerIrql DISPATCH_LEVEL        ; lower IRQL to dispatch level

endif

        jmp     kid30                   ;

;
; The new thread is the Idle thread (same as old thread).  This can happen
; rarely when a thread scheduled for this processor is made unable to run
; on this processor. As this processor has again been marked idle, other
; processors may unconditionally assign new threads to this processor.
;

ifndef NT_UP

kisame: and     dword ptr [ebx].PcPrcbData.PbNextThread, 0 ; clear next thread
        and     dword ptr [ebx].PcPrcbData.PbPrcbLock, 0 ; release current PRCB lock
        and     byte ptr [edi].ThSwapBusy, 0 ; set idle thread context swap idle
        jmp     kid30                   ;

;
; Call idle schedule if requested.
;

kid40:  cmp     byte ptr [ebx].PcPrcbData.PbIdleSchedule, 0 ; check if idle schedule
        je      kid10                   ; if e, idle schedule not requested
        sti                             ; enable interrupts
        lea     ecx, [ebx].PcPrcbData   ; get current PRCB address
        fstCall KiIdleSchedule          ; attempt to schedule thread
        test    eax, eax                ; test if new thread schedule
        mov     esi, eax                ; set new thread address
        mov     edi, [ebx].PcPrcbData.PbIdleThread ; get idle thread address
        jnz     short kid35             ; if nz, new thread scheduled
        jmp     kid30                   ;

endif

fstENDP KiIdleLoop

ifdef DBGMP
cPublicProc _KiPollDebugger,0
cPublicFpo 0,3
        push    eax
        push    ecx
        push    edx
        POLL_DEBUGGER
        pop     edx
        pop     ecx
        pop     eax
        stdRET    _KiPollDebugger
stdENDP _KiPollDebugger

endif

        page , 132
        subttl "Adjust TSS ESP0 value"
;++
;
; VOID
; KiAdjustEsp0 (
;     IN PKTRAP_FRAME TrapFrame
;     )
;
; Routine Description:
;
;     This routine puts the appropriate ESP0 value in the esp0 field of the
;     TSS.  This allows protect mode and V86 mode to use the same stack
;     frame.  The ESP0 value for protected mode is 16 bytes lower than
;     for V86 mode to compensate for the missing segment registers.
;
; Arguments:
;
;     TrapFrame - Supplies a pointer to the TrapFrame.
;
; Return Value:
;
;     None.
;
;--
cPublicProc _Ki386AdjustEsp0 ,1

if DBG

        ;
        ; Make sure we are not called when the trap frame can be
        ; edited by a SetContextThread.
        ;

        CurrentIrql
        cmp     al, APC_LEVEL
        jge     @f
        int     3
@@:

endif

        mov     eax, PCR[PcPrcbData.PbCurrentThread] ; get current thread address
        mov     edx, [esp + 4]          ; edx -> trap frame
        mov     eax, [eax]+ThInitialStack ; eax = base of stack
        test    dword ptr [edx]+TsEFlags, EFLAGS_V86_MASK ; is this a V86 frame?
        jnz     short ae10              ; if nz, V86 frame
        sub     eax, TsV86Gs - TsHardwareSegSS ; compensate for missing regs
ae10:   sub     eax, NPX_FRAME_LENGTH   ; 
        pushfd                          ; Make sure we don't move
        cli                             ; processors while we do this
        mov     edx, PCR[PcTssCopy]     ;
        mov     [edx]+TssEsp0, eax      ; set Esp0 value
        popfd                           ;

        stdRET    _Ki386AdjustEsp0

stdENDP _Ki386AdjustEsp0


_TEXT$00   ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ke\i386\flush.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    flush.c

Abstract:

    This module implements i386 machine dependent kernel functions to flush
    the data and instruction caches and to stall processor execution.

--*/

#include "ki.h"

//
// Prototypes
//

VOID
KiInvalidateAllCachesTarget (
    IN PKIPI_CONTEXT SignalDone,
    IN PVOID Parameter1,
    IN PVOID Parameter2,
    IN PVOID Parameter3
    );

extern ULONG KeI386CpuType;

BOOLEAN
KeInvalidateAllCaches (
    VOID
    )

/*++

Routine Description:

    This function writes back and invalidates the cache on all processors
    in the host configuration.

Arguments:

    None.

Return Value:

    TRUE if the invalidation was done, FALSE otherwise.

--*/

{

#ifndef NT_UP

    KIRQL OldIrql;
    PKPRCB Prcb;
    KAFFINITY TargetProcessors;

#endif

    //
    // Support for wbinvd on Pentium based platforms is vendor dependent.
    // Check for family first and support on Pentium Pro based platforms
    // onward.
    //

    if (KeI386CpuType < 6 ) {
        return FALSE;
    }

    //
    // Raise IRQL and compute target set of processors.
    //


#ifndef NT_UP

    //
    // Synchronize with other IPI functions which may stall
    //

    OldIrql = KeRaiseIrqlToSynchLevel();
    KeAcquireSpinLockAtDpcLevel (&KiReverseStallIpiLock);

    Prcb = KeGetCurrentPrcb();
    TargetProcessors = KeActiveProcessors & ~Prcb->SetMember;

    //
    // If any target processors are specified, then send writeback
    // invalidate packet to the target set of processors.
    //

    if (TargetProcessors != 0) {
        KiIpiSendSynchronousPacket(Prcb,
                                   TargetProcessors,
                                   KiInvalidateAllCachesTarget,
                                   (PVOID)&Prcb->ReverseStall,
                                   NULL,
                                   NULL);

        KiIpiStallOnPacketTargets(TargetProcessors);
    }

#endif

    //
    // All target processors have written back and invalidated caches and
    // are waiting to proceed. Write back invalidate current cache and
    // then continue the execution of target processors.
    //

    _asm {
        ;
        ; wbinvd
        ;

        _emit 0Fh
        _emit 09h
    }

    //
    // Wait until all target processors have finished and completed packet.
    //

#ifndef NT_UP

    if (TargetProcessors != 0) {
        Prcb->ReverseStall += 1;
    }

    //
    // Drop reverse IPI lock and Lower IRQL to its previous value.
    //

    KeReleaseSpinLockFromDpcLevel (&KiReverseStallIpiLock);

    KeLowerIrql(OldIrql);

#endif

    return TRUE;
}

#if !defined(NT_UP)

VOID
KiInvalidateAllCachesTarget (
    IN PKIPI_CONTEXT SignalDone,
    IN PVOID Proceed,
    IN PVOID Parameter2,
    IN PVOID Parameter3
    )

/*++

Routine Description:

    This is the target function for writing back and invalidating the cache.

Arguments:

    SignalDone - Supplies a pointer to a variable that is cleared when the
        requested operation has been performed.

    Proceed - pointer to flag to synchronize with

  Return Value:

    None.

--*/

{

    UNREFERENCED_PARAMETER (Parameter2);
    UNREFERENCED_PARAMETER (Parameter3);

    //
    // Write back invalidate current cache
    //

    _asm {
        ;
        ; wbinvd
        ;

        _emit 0Fh
        _emit 09h

    }

    KiIpiSignalPacketDoneAndStall (SignalDone, Proceed);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ke\i386\exceptn.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    exceptn.c

Abstract:

    This module implement the code necessary to dispatch exceptions to the
    proper mode and invoke the exception dispatcher.

--*/

#include "ki.h"
#include "kix86.h"

#define FN_BITS_PER_TAGWORD     16
#define FN_TAG_EMPTY            0x3
#define FN_TAG_MASK             0x3
#define FX_TAG_VALID            0x1
#define NUMBER_OF_FP_REGISTERS  8
#define BYTES_PER_FP_REGISTER   10
#define BYTES_PER_FX_REGISTER   16

extern UCHAR VdmUserCr0MapIn[];
extern BOOLEAN KeI386FxsrPresent;
extern BOOLEAN KeI386XMMIPresent;

BOOLEAN
KiCheckForAtlThunk (
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN PCONTEXT Context
    );

VOID
Ki386AdjustEsp0(
    IN PKTRAP_FRAME TrapFrame
    );

BOOLEAN
KiEm87StateToNpxFrame(
    OUT PFLOATING_SAVE_AREA NpxFrmae
    );

BOOLEAN
KiNpxFrameToEm87State(
    IN PFLOATING_SAVE_AREA NpxFrmae
    );

ULONG
KiEspFromTrapFrame(
    IN PKTRAP_FRAME TrapFrame
    )

/*++

Routine Description:

    This routine fetches the correct esp from a trapframe, accounting
    for whether the frame is a user or kernel mode frame, and whether
    it has been edited.

Arguments:

    TrapFrame - Supplies a pointer to a trap frame from which volatile context
        should be copied into the context record.

Return Value:

    Value of Esp.

--*/

{
    if (((TrapFrame->SegCs & MODE_MASK) != KernelMode) ||
         (TrapFrame->EFlags & EFLAGS_V86_MASK)) {

        //  User mode frame, real value of Esp is always in HardwareEsp.

        return TrapFrame->HardwareEsp;

    } else {

        if ((TrapFrame->SegCs & FRAME_EDITED) == 0) {

            //  Kernel mode frame which has had esp edited,
            //  value of Esp is in TempEsp.

            return TrapFrame->TempEsp;

        } else {

            //  Kernel mode frame has has not had esp edited, compute esp.

            return (ULONG)&TrapFrame->HardwareEsp;
        }
    }
}

VOID
KiEspToTrapFrame(
    IN PKTRAP_FRAME TrapFrame,
    IN ULONG Esp
    )

/*++

Routine Description:

    This routine sets the specified value Esp into the trap frame,
    accounting for whether the frame is a user or kernel mode frame,
    and whether it has been edited before.

Arguments:

    TrapFrame - Supplies a pointer to a trap frame from which volatile context
        should be copied into the context record.

    Esp - New value for Esp.

Return Value:

    None.

--*/
{
    ULONG   OldEsp;
    KIRQL   OldIrql;

    //
    // Raise to at least APC_LEVEL so we can test SegCs and EFLAGS
    // as an atomic operation since NtSetContextThread may modify these.
    //
    OldIrql = KeGetCurrentIrql ();
    if (OldIrql < APC_LEVEL) {
        KeRaiseIrql (APC_LEVEL, &OldIrql);
    }

    OldEsp = KiEspFromTrapFrame(TrapFrame);

    if (((TrapFrame->SegCs & MODE_MASK) != KernelMode) ||
         (TrapFrame->EFlags & EFLAGS_V86_MASK)) {

        //
        //  User mode trap frame
        //

        TrapFrame->HardwareEsp = Esp;

    } else {

        //
        //  Kernel mode esp can't be lowered or iret emulation will fail
        //

        if (Esp < OldEsp)
            KeBugCheckEx(SET_OF_INVALID_CONTEXT,
                         Esp, OldEsp, (ULONG_PTR)TrapFrame, 0);

        //
        //  Edit frame, setting edit marker as needed.
        //

        if ((TrapFrame->SegCs & FRAME_EDITED) == 0) {

            //  Kernel frame that has already been edited,
            //  store value in TempEsp.

            TrapFrame->TempEsp = Esp;

        } else {

            //  Kernel frame for which Esp is being edited first time.
            //  Save real SegCs, set marked in SegCs, save Esp value.

            if (OldEsp != Esp) {

                TrapFrame->TempSegCs = TrapFrame->SegCs;
                TrapFrame->SegCs = TrapFrame->SegCs & ~FRAME_EDITED;
                TrapFrame->TempEsp = Esp;
            }
        }
    }

    //
    // Restore original IRQL
    //
    if (OldIrql < APC_LEVEL) {
        KeLowerIrql (OldIrql);
    }
}

ULONG
KiSegSsFromTrapFrame(
    IN PKTRAP_FRAME TrapFrame
    )

/*++

Routine Description:

    This routine fetches the correct ss from a trapframe, accounting
    for whether the frame is a user or kernel mode frame.

Arguments:

    TrapFrame - Supplies a pointer to a trap frame from which volatile context
        should be copied into the context record.

Return Value:

    Value of SegSs.

--*/

{
    if (TrapFrame->EFlags & EFLAGS_V86_MASK){
        return TrapFrame->HardwareSegSs;
    } else if ((TrapFrame->SegCs & MODE_MASK) != KernelMode) {

        //
        // It's user mode.  The HardwareSegSs contains R3 data selector.
        //

        return TrapFrame->HardwareSegSs | RPL_MASK;
    } else {
        return KGDT_R0_DATA;
    }
}

VOID
KiSegSsToTrapFrame(
    IN PKTRAP_FRAME TrapFrame,
    IN ULONG SegSs
    )

/*++

Routine Description:

    It turns out that in a flat system there are only two legal values
    for SS.  Therefore, this procedure forces the appropriate one
    of those values to be used.  The legal SS value is a function of
    which CS value is already set.

Arguments:

    TrapFrame - Supplies a pointer to a trap frame from which volatile context
        should be copied into the context record.

    SegSs - value of SS caller would like to set.

Return Value:

    Nothing.

--*/

{
    SegSs &= SEGMENT_MASK;  // Throw away the high order trash bits

    if (TrapFrame->EFlags & EFLAGS_V86_MASK) {
        TrapFrame->HardwareSegSs = SegSs;
    } else if ((TrapFrame->SegCs & MODE_MASK) == UserMode) {

        //
        // If user mode, we simply put SegSs to trapframe.  If the SegSs
        // is a bogus value.  The trap0d handler will be able to detect
        // this and handle it appropriately.
        //

        TrapFrame->HardwareSegSs = SegSs | RPL_MASK;
    }

    //
    //  else {
    //      The frame is a kernel mode frame, which does not have
    //      a place to store SS.  Therefore, do nothing.
    //
}

VOID
KeContextFromKframes (
    __in PKTRAP_FRAME TrapFrame,
    __in PKEXCEPTION_FRAME ExceptionFrame,
    __inout PCONTEXT ContextFrame
    )

/*++

Routine Description:

    This routine moves the selected contents of the specified trap and exception frames
    frames into the specified context frame according to the specified context
    flags.

Arguments:

    TrapFrame - Supplies a pointer to a trap frame from which volatile context
        should be copied into the context record.

    ExceptionFrame - Supplies a pointer to an exception frame from which context
        should be copied into the context record. This argument is ignored since
        there is no exception frame on NT386.

    ContextFrame - Supplies a pointer to the context frame that receives the
        context copied from the trap and exception frames.

Return Value:

    None.

--*/

{

    PFX_SAVE_AREA NpxFrame;
    BOOLEAN StateSaved;
    ULONG i;
    struct _FPSaveBuffer {
        UCHAR               Buffer[15];
        FLOATING_SAVE_AREA  SaveArea;
    } FloatSaveBuffer;
    PFLOATING_SAVE_AREA PSaveArea;
    KIRQL OldIrql;

    UNREFERENCED_PARAMETER( ExceptionFrame );

    //
    // This routine is called at both PASSIVE_LEVEL by exception dispatch
    // and at APC_LEVEL by NtSetContextThread. We raise to APC_LEVEL to
    // make the trap frame capture atomic.
    //
    OldIrql = KeGetCurrentIrql ();
    if (OldIrql < APC_LEVEL) {
        KeRaiseIrql (APC_LEVEL, &OldIrql);
    }

    //
    // Set control information if specified.
    //

    if ((ContextFrame->ContextFlags & CONTEXT_CONTROL) == CONTEXT_CONTROL) {

        //
        // Set registers ebp, eip, cs, eflag, esp and ss.
        //

        ContextFrame->Ebp = TrapFrame->Ebp;
        ContextFrame->Eip = TrapFrame->Eip;

        if (((TrapFrame->SegCs & FRAME_EDITED) == 0) &&
            ((TrapFrame->EFlags & EFLAGS_V86_MASK) == 0)) {
            ContextFrame->SegCs = TrapFrame->TempSegCs & SEGMENT_MASK;
        } else {
            ContextFrame->SegCs = TrapFrame->SegCs & SEGMENT_MASK;
        }
        ContextFrame->EFlags = TrapFrame->EFlags;
        ContextFrame->SegSs = KiSegSsFromTrapFrame(TrapFrame);
        ContextFrame->Esp = KiEspFromTrapFrame(TrapFrame);
    }

    //
    // Set segment register contents if specified.
    //

    if ((ContextFrame->ContextFlags & CONTEXT_SEGMENTS) == CONTEXT_SEGMENTS) {

        //
        // Set segment registers gs, fs, es, ds.
        //
        // These values are junk most of the time, but useful
        // for debugging under certain conditions.  Therefore,
        // we report whatever was in the frame.
        //
        if (TrapFrame->EFlags & EFLAGS_V86_MASK) {
            ContextFrame->SegGs = TrapFrame->V86Gs & SEGMENT_MASK;
            ContextFrame->SegFs = TrapFrame->V86Fs & SEGMENT_MASK;
            ContextFrame->SegEs = TrapFrame->V86Es & SEGMENT_MASK;
            ContextFrame->SegDs = TrapFrame->V86Ds & SEGMENT_MASK;
        }
        else {
            if (TrapFrame->SegCs == KGDT_R0_CODE) {
                //
                // Trap frames created from R0_CODE traps do not save
                // the following selectors.  Set them in the frame now.
                //

                TrapFrame->SegGs = 0;
                TrapFrame->SegFs = KGDT_R0_PCR;
                TrapFrame->SegEs = KGDT_R3_DATA | RPL_MASK;
                TrapFrame->SegDs = KGDT_R3_DATA | RPL_MASK;
            }

            ContextFrame->SegGs = TrapFrame->SegGs & SEGMENT_MASK;
            ContextFrame->SegFs = TrapFrame->SegFs & SEGMENT_MASK;
            ContextFrame->SegEs = TrapFrame->SegEs & SEGMENT_MASK;
            ContextFrame->SegDs = TrapFrame->SegDs & SEGMENT_MASK;
        }

    }

    //
    // Set integer register contents if specified.
    //

    if ((ContextFrame->ContextFlags & CONTEXT_INTEGER) == CONTEXT_INTEGER) {

        //
        // Set integer registers edi, esi, ebx, edx, ecx, eax
        //

        ContextFrame->Edi = TrapFrame->Edi;
        ContextFrame->Esi = TrapFrame->Esi;
        ContextFrame->Ebx = TrapFrame->Ebx;
        ContextFrame->Ecx = TrapFrame->Ecx;
        ContextFrame->Edx = TrapFrame->Edx;
        ContextFrame->Eax = TrapFrame->Eax;
    }

    if (((ContextFrame->ContextFlags & CONTEXT_EXTENDED_REGISTERS) ==
        CONTEXT_EXTENDED_REGISTERS) &&
        ((TrapFrame->SegCs & MODE_MASK) == UserMode)) {

        //
        // This is the base TrapFrame, and the NpxFrame is on the base
        // of the kernel stack, just above it in memory.
        //

        NpxFrame = (PFX_SAVE_AREA)(TrapFrame + 1);

        if (KeI386NpxPresent) {
            KiFlushNPXState (NULL);
            RtlCopyMemory( (PVOID)&(ContextFrame->ExtendedRegisters[0]),
                           (PVOID)&(NpxFrame->U.FxArea),                    
                           MAXIMUM_SUPPORTED_EXTENSION
                         );
        }
    }

    //
    // Fetch floating register contents if requested, and type of target
    // is user.  (system frames have no fp state, so ignore request)
    //
    if ( ((ContextFrame->ContextFlags & CONTEXT_FLOATING_POINT) ==
          CONTEXT_FLOATING_POINT) &&
         ((TrapFrame->SegCs & MODE_MASK) == UserMode)) {

        //
        // This is the base TrapFrame, and the NpxFrame is on the base
        // of the kernel stack, just above it in memory.
        //

        NpxFrame = (PFX_SAVE_AREA)(TrapFrame + 1);

        if (KeI386NpxPresent) {

            //
            // Force the coprocessors state to the save area and copy it
            // to the context frame.
            //

            if (KeI386FxsrPresent == TRUE) {

                //
                // FP state save was done using fxsave. Get the save
                // area in fnsave format
                //
                // Save area must be 16 byte aligned so we cushion it with
                // 15 bytes (in the locals declaration above) and round
                // down to align.
                //

                ULONG_PTR Temp;
                Temp = (ULONG_PTR)&FloatSaveBuffer.SaveArea;
                Temp &= ~0xf;
                PSaveArea = (PFLOATING_SAVE_AREA)Temp;
                KiFlushNPXState (PSaveArea);
            } else {

                PSaveArea = (PFLOATING_SAVE_AREA)&(NpxFrame->U.FnArea);
                KiFlushNPXState (NULL);

            }

            ContextFrame->FloatSave.ControlWord   = PSaveArea->ControlWord;
            ContextFrame->FloatSave.StatusWord    = PSaveArea->StatusWord;
            ContextFrame->FloatSave.TagWord       = PSaveArea->TagWord;
            ContextFrame->FloatSave.ErrorOffset   = PSaveArea->ErrorOffset;
            ContextFrame->FloatSave.ErrorSelector = PSaveArea->ErrorSelector;
            ContextFrame->FloatSave.DataOffset    = PSaveArea->DataOffset;
            ContextFrame->FloatSave.DataSelector  = PSaveArea->DataSelector;
            ContextFrame->FloatSave.Cr0NpxState   = NpxFrame->Cr0NpxState;

            for (i = 0; i < SIZE_OF_80387_REGISTERS; i++) {
                ContextFrame->FloatSave.RegisterArea[i] = PSaveArea->RegisterArea[i];
            }

        } else {

            //
            // The 80387 is being emulated by the R3 emulator.
            // ** The only time the Npx state is ever obtained or set is
            // ** for userlevel handling.  Current Irql must be 0 or 1.
            // Go slurp the emulator's R3 data and generate the
            // floating point context
            //

            StateSaved = KiEm87StateToNpxFrame(&ContextFrame->FloatSave);
            if (StateSaved) {
                ContextFrame->FloatSave.Cr0NpxState = NpxFrame->Cr0NpxState;
            } else {

                //
                // The floatingpoint state can not be determined.
                // Remove the floatingpoint flag from the context frame flags.
                //

                ContextFrame->ContextFlags &= (~CONTEXT_FLOATING_POINT) | CONTEXT_i386;
            }
        }
    }

    //
    // Fetch Dr register contents if requested.
    //

    if ((ContextFrame->ContextFlags & CONTEXT_DEBUG_REGISTERS) ==
        CONTEXT_DEBUG_REGISTERS) {
         
        //
        // Care is now taken to ensure that the DebugActive/Dr7 value is set on
        // any valid set of a legal DR value, ensuring the values on the kernel
        // stack cannot become trash.
        //

        if ((TrapFrame->Dr7 & ~DR7_RESERVED_MASK) != 0) {
            ContextFrame->Dr0 = TrapFrame->Dr0;
            ContextFrame->Dr1 = TrapFrame->Dr1;
            ContextFrame->Dr2 = TrapFrame->Dr2;
            ContextFrame->Dr3 = TrapFrame->Dr3;
            ContextFrame->Dr6 = TrapFrame->Dr6;
            ContextFrame->Dr7 = KiUpdateDr7 (TrapFrame->Dr7);
        } else {
            ContextFrame->Dr0 = 0;
            ContextFrame->Dr1 = 0;
            ContextFrame->Dr2 = 0;
            ContextFrame->Dr3 = 0;
            ContextFrame->Dr6 = 0;
            ContextFrame->Dr7 = 0;
        }
    }

    //
    // Lower IRQL if we had to raise it
    //
    if (OldIrql < APC_LEVEL) {
        KeLowerIrql (OldIrql);
    }
}

VOID
KeContextToKframes (
    __inout PKTRAP_FRAME TrapFrame,
    __inout PKEXCEPTION_FRAME ExceptionFrame,
    __in PCONTEXT ContextFrame,
    __in ULONG ContextFlags,
    __in KPROCESSOR_MODE PreviousMode
    )

/*++

Routine Description:

    This routine moves the selected contents of the specified context frame into
    the specified trap and exception frames according to the specified context
    flags.

Arguments:

    TrapFrame - Supplies a pointer to a trap frame that receives the volatile
        context from the context record.

    ExceptionFrame - Supplies a pointer to an exception frame that receives
        the nonvolatile context from the context record. This argument is
        ignored since there is no exception frame on NT386.

    ContextFrame - Supplies a pointer to a context frame that contains the
        context that is to be copied into the trap and exception frames.

    ContextFlags - Supplies the set of flags that specify which parts of the
        context frame are to be copied into the trap and exception frames.

    PreviousMode - Supplies the processor mode for which the trap and exception
        frames are being built.

Return Value:

    None.

--*/

{

    PFX_SAVE_AREA     NpxFrame;
    ULONG i;
    ULONG j;
    ULONG TagWord;
    BOOLEAN StateSaved;
    BOOLEAN ModeChanged;
    KIRQL   OldIrql;
#if DBG
    PKPCR   Pcr;
#endif
#if DBG
    KIRQL   OldIrql2;
#endif

    UNREFERENCED_PARAMETER( ExceptionFrame );

    //
    // This routine is called at both PASSIVE_LEVEL by exception dispatch
    // and at APC_LEVEL by NtSetContextThread. We raise to APC_LEVEL to
    // make the trap frame modifications atomic.
    //
    OldIrql = KeGetCurrentIrql ();
    if (OldIrql < APC_LEVEL) {
        KeRaiseIrql (APC_LEVEL, &OldIrql);
    }

    //
    // Set control information if specified.
    //

    if ((ContextFlags & CONTEXT_CONTROL) == CONTEXT_CONTROL) {

        if ((ContextFrame->EFlags & EFLAGS_V86_MASK) !=
            (TrapFrame->EFlags & EFLAGS_V86_MASK)) {
            ModeChanged = TRUE;
        } else {
            ModeChanged = FALSE;
        }


        //
        // Set registers eflag, ebp, eip, cs, esp and ss.
        // Eflags is set first, so that the auxiliary routines
        // can check the v86 bit to determine as well as cs, to
        // determine if the frame is kernel or user mode. (v86 mode cs
        // can have any value)
        //

        TrapFrame->EFlags = SANITIZE_FLAGS(ContextFrame->EFlags, PreviousMode);
        TrapFrame->Ebp = ContextFrame->Ebp;
        TrapFrame->Eip = ContextFrame->Eip;
        if (TrapFrame->EFlags & EFLAGS_V86_MASK) {
            TrapFrame->SegCs = ContextFrame->SegCs;
        } else {
            TrapFrame->SegCs = SANITIZE_SEG(ContextFrame->SegCs, PreviousMode);
            if (PreviousMode != KernelMode && TrapFrame->SegCs < 8) {

                //
                // If user mode and the selector value is less than 8, we
                // know it is an invalid selector.  Set it to flat user
                // mode selector.  Another reason we need to check for this
                // is that any cs value less than 8 causes our exit kernel
                // macro to treat its exit trap frame as an edited frame.
                //

                TrapFrame->SegCs = KGDT_R3_CODE | RPL_MASK;
            }
        }


        KiSegSsToTrapFrame(TrapFrame, ContextFrame->SegSs);
        KiEspToTrapFrame(TrapFrame, ContextFrame->Esp);
        if (ModeChanged) {
            Ki386AdjustEsp0(TrapFrame);             // realign esp0 in the tss
        }
    }

    //
    // Set segment register contents if specified.
    //

    if ((ContextFlags & CONTEXT_SEGMENTS) == CONTEXT_SEGMENTS) {

        //
        // Set segment registers gs, fs, es, ds.
        //

        //
        // There's only one legal value for DS and ES, so simply set it.
        // This allows KeContextFromKframes to report the real values in
        // the frame. (which are junk most of the time, but sometimes useful
        // for debugging.)
        // Only 2 legal values for FS, let either one be set.
        // Force GS to be 0 to deal with entry via SysCall and exit
        // via exception.
        //
        // For V86 mode, the FS, GS, DS, and ES registers must be properly
        // set from the supplied context.
        //

        if (TrapFrame->EFlags & EFLAGS_V86_MASK) {
            TrapFrame->V86Fs = ContextFrame->SegFs;
            TrapFrame->V86Es = ContextFrame->SegEs;
            TrapFrame->V86Ds = ContextFrame->SegDs;
            TrapFrame->V86Gs = ContextFrame->SegGs;
        } else if (((TrapFrame->SegCs & MODE_MASK) == KernelMode)) {

            //
            // set up the standard selectors
            //

            TrapFrame->SegFs = SANITIZE_SEG(ContextFrame->SegFs, PreviousMode);
            TrapFrame->SegEs = KGDT_R3_DATA | RPL_MASK;
            TrapFrame->SegDs = KGDT_R3_DATA | RPL_MASK;
            TrapFrame->SegGs = 0;
        } else {

            //
            // If user mode, we simply return whatever left in context frame
            // and let trap 0d handle it (if later we trap while popping the
            // trap frame.) V86 mode also get handled here.
            //

            TrapFrame->SegFs = ContextFrame->SegFs;
            TrapFrame->SegEs = ContextFrame->SegEs;
            TrapFrame->SegDs = ContextFrame->SegDs;
            if (TrapFrame->SegCs == (KGDT_R3_CODE | RPL_MASK)) {
                TrapFrame->SegGs = 0;
            } else {
                TrapFrame->SegGs = ContextFrame->SegGs;
            }
        }
    }
    //
    // Set integer registers contents if specified.
    //

    if ((ContextFlags & CONTEXT_INTEGER) == CONTEXT_INTEGER) {

        //
        // Set integer registers edi, esi, ebx, edx, ecx, eax.
        //
        //  Can NOT call RtlCopyMemory here because the regs aren't
        //  contiguous in pusha frame, and we don't want to export
        //  bits of junk into context record.
        //

        TrapFrame->Edi = ContextFrame->Edi;
        TrapFrame->Esi = ContextFrame->Esi;
        TrapFrame->Ebx = ContextFrame->Ebx;
        TrapFrame->Ecx = ContextFrame->Ecx;
        TrapFrame->Edx = ContextFrame->Edx;
        TrapFrame->Eax = ContextFrame->Eax;

    }

    //
    // Set extended register contents if requested, and type of target
    // is user.  (system frames have no extended state, so ignore request)
    //

    if (((ContextFlags & CONTEXT_EXTENDED_REGISTERS) == CONTEXT_EXTENDED_REGISTERS) &&
        ((TrapFrame->SegCs & MODE_MASK) == UserMode)) {

        //
        // This is the base TrapFrame, and the NpxFrame is on the base
        // of the kernel stack, just above it in memory.
        //

        NpxFrame = (PFX_SAVE_AREA)(TrapFrame + 1);

        if (KeI386NpxPresent) {
            KiFlushNPXState (NULL);
            RtlCopyMemory( (PVOID)&(NpxFrame->U.FxArea),
                      (PVOID)&(ContextFrame->ExtendedRegisters[0]),
                           MAXIMUM_SUPPORTED_EXTENSION
                         );
            //
            // Make sure only valid floating state bits are moved to Cr0NpxState.
            //

            NpxFrame->Cr0NpxState &= ~(CR0_EM | CR0_MP | CR0_TS);

            //
            // Make sure all reserved bits are clear in MXCSR so we don't get a GP
            // fault when doing an FRSTOR on this state.
            //
            NpxFrame->U.FxArea.MXCsr = SANITIZE_MXCSR(NpxFrame->U.FxArea.MXCsr);

            //
            // Only let VDMs turn on the EM bit.  The kernel can't do
            // anything for FLAT apps
            //
            if (PsGetCurrentProcess()->VdmObjects != NULL) {
                NpxFrame->Cr0NpxState |= ContextFrame->FloatSave.Cr0NpxState &
                                      (CR0_EM | CR0_MP);
            }
        }
    }

    //
    // Set floating register contents if requested, and type of target
    // is user.  (system frames have no fp state, so ignore request)
    //

    if (((ContextFlags & CONTEXT_FLOATING_POINT) == CONTEXT_FLOATING_POINT) &&
        ((TrapFrame->SegCs & MODE_MASK) == UserMode)) {

        //
        // This is the base TrapFrame, and the NpxFrame is on the base
        // of the kernel stack, just above it in memory.
        //

        NpxFrame = (PFX_SAVE_AREA)(TrapFrame + 1);

        if (KeI386NpxPresent) {

            //
            // Set coprocessor stack, control and status registers
            //

            KiFlushNPXState (NULL);

            if (KeI386FxsrPresent == TRUE) {

                //
                // Restore FP state in the fxrstor format
                //

                NpxFrame->U.FxArea.ControlWord   =
                                    (USHORT)ContextFrame->FloatSave.ControlWord;
                NpxFrame->U.FxArea.StatusWord    =
                                    (USHORT)ContextFrame->FloatSave.StatusWord;

                //
                // Construct the tag word from fnsave format to fxsave format
                //

                NpxFrame->U.FxArea.TagWord = 0; // Mark every register invalid

                TagWord = ContextFrame->FloatSave.TagWord;

                for (i = 0; i < FN_BITS_PER_TAGWORD; i+=2) {

                    if (((TagWord >> i) & FN_TAG_MASK) != FN_TAG_EMPTY) {

                        //
                        // This register is valid
                        //

                        NpxFrame->U.FxArea.TagWord |= (FX_TAG_VALID << (i/2));
                    }
                }

                NpxFrame->U.FxArea.ErrorOffset   =
                                        ContextFrame->FloatSave.ErrorOffset;
                NpxFrame->U.FxArea.ErrorSelector =
                               (ContextFrame->FloatSave.ErrorSelector & 0xFFFF);
                NpxFrame->U.FxArea.ErrorOpcode =
                    (USHORT)((ContextFrame->FloatSave.ErrorSelector >> 16) & 0xFFFF);
                NpxFrame->U.FxArea.DataOffset    =
                                ContextFrame->FloatSave.DataOffset;
                NpxFrame->U.FxArea.DataSelector  =
                                ContextFrame->FloatSave.DataSelector;

                //
                // Fxrstor format has each FP register in 128 bits (16 bytes)
                // where as fnsave saves each FP register in 80 bits (10 bytes)
                //
                RtlZeroMemory ((PVOID)&NpxFrame->U.FxArea.RegisterArea[0],
                               SIZE_OF_FX_REGISTERS
                              );

                for (i = 0; i < NUMBER_OF_FP_REGISTERS; i++) {
                    for (j = 0; j < BYTES_PER_FP_REGISTER; j++) {
                        NpxFrame->U.FxArea.RegisterArea[i*BYTES_PER_FX_REGISTER+j] =
                                ContextFrame->FloatSave.RegisterArea[i*BYTES_PER_FP_REGISTER+j];
                    }
                }

            } else {
                NpxFrame->U.FnArea.ControlWord   =
                                        ContextFrame->FloatSave.ControlWord;
                NpxFrame->U.FnArea.StatusWord    =
                                        ContextFrame->FloatSave.StatusWord;
                NpxFrame->U.FnArea.TagWord       =
                                        ContextFrame->FloatSave.TagWord;
                NpxFrame->U.FnArea.ErrorOffset   =
                                        ContextFrame->FloatSave.ErrorOffset;
                NpxFrame->U.FnArea.ErrorSelector =
                                        ContextFrame->FloatSave.ErrorSelector;
                NpxFrame->U.FnArea.DataOffset    =
                                        ContextFrame->FloatSave.DataOffset;
                NpxFrame->U.FnArea.DataSelector  =
                                        ContextFrame->FloatSave.DataSelector;

                for (i = 0; i < SIZE_OF_80387_REGISTERS; i++) {
                    NpxFrame->U.FnArea.RegisterArea[i] =
                            ContextFrame->FloatSave.RegisterArea[i];
                }

            }

            //
            // Make sure only valid floating state bits are moved to Cr0NpxState.
            //

            NpxFrame->Cr0NpxState &= ~(CR0_EM | CR0_MP | CR0_TS);

            //
            // Only let VDMs turn on the EM bit.  The kernel can't do
            // anything for FLAT apps
            //
            if (PsGetCurrentProcess()->VdmObjects != NULL) {
                NpxFrame->Cr0NpxState |= ContextFrame->FloatSave.Cr0NpxState &
                                      (CR0_EM | CR0_MP);
            }

        } else {

            if (PsGetCurrentProcess()->VdmObjects != NULL) {

                //
                // This is a special hack to allow SetContext for VDMs to
                // turn on/off it's CR0_EM bit.
                //

                NpxFrame->Cr0NpxState &= ~(CR0_MP | CR0_TS | CR0_EM | CR0_PE);
                NpxFrame->Cr0NpxState |=
                    VdmUserCr0MapIn[ContextFrame->FloatSave.Cr0NpxState & (CR0_EM | CR0_MP)];

            } else {

                //
                // The 80387 is being emulated by the R3 emulator.
                // ** The only time the Npx state is ever obtained or set is
                // ** for userlevel handling.  Current Irql must be 0 or 1.
                // And the context being set must be for the current thread.
                // Go smash the floatingpoint context into the R3 emulator's
                // data area.
                //
#if DBG
                OldIrql2 = KeRaiseIrqlToSynchLevel();
                Pcr = KeGetPcr();
                ASSERT (Pcr->Prcb->CurrentThread->Teb == Pcr->NtTib.Self);
                KeLowerIrql (OldIrql2);
#endif

                StateSaved = KiNpxFrameToEm87State(&ContextFrame->FloatSave);
                if (StateSaved) {

                    //
                    // Make sure only valid floating state bits are moved to
                    // Cr0NpxState.  Since we are emulating, don't allow
                    // resetting CR0_EM.
                    //

                    NpxFrame->Cr0NpxState &= ~(CR0_MP | CR0_TS);
                    NpxFrame->Cr0NpxState |=
                        ContextFrame->FloatSave.Cr0NpxState & CR0_MP;
                }
            }
        }
    }

    //
    // Set debug register state if specified.  If previous mode is user
    // mode (i.e. it's a user frame we're setting) and if effect will be to
    // cause any debug register to obtain a valid value, then mark 
    // the thread and the Dr7 field accordingly.
    //

    if ((ContextFlags & CONTEXT_DEBUG_REGISTERS) == CONTEXT_DEBUG_REGISTERS) {
        UCHAR NewMask;
        ULONG Index;
        ULONG DrValue;

        NewMask = 0;

        //
        // Process debug registers Dr0-Dr3, Dr6, and finally Dr7.
        //
        
        for (Index = 0; Index <=3; Index += 1) {
            DrValue = SANITIZE_DRADDR (*((PULONG)((ULONG_PTR)ContextFrame + 
                KiDebugRegisterContextOffsets[Index])), PreviousMode);
            
            if ((*((PULONG)((ULONG_PTR)TrapFrame + KiDebugRegisterTrapOffsets[Index])) = DrValue) != 0)
            {
                NewMask |= DR_MASK (Index);
            }
        }
        
        if ((TrapFrame->Dr6 = SANITIZE_DR6 (ContextFrame->Dr6, PreviousMode)) != 0) {
            NewMask |= DR_MASK (6);
        }

        TrapFrame->Dr7 = SANITIZE_DR7(ContextFrame->Dr7, PreviousMode);
        (VOID) KiRecordDr7 (&TrapFrame->Dr7, &NewMask);

        if (PreviousMode != KernelMode) {
            KeGetCurrentThread()->Header.DebugActive = (BOOLEAN) NewMask;
        }
    }

    //
    // If thread is supposed to have IOPL, then force it on in eflags
    //
    if (KeGetCurrentThread()->Iopl) {
        TrapFrame->EFlags |= (EFLAGS_IOPL_MASK & -1);  // IOPL = 3
    }

    //
    // Lower IRQL if we had to raise it
    //
    if (OldIrql < APC_LEVEL) {
        KeLowerIrql (OldIrql);
    }

    return;
}

VOID
KiDispatchException (
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN PKEXCEPTION_FRAME ExceptionFrame,
    IN PKTRAP_FRAME TrapFrame,
    IN KPROCESSOR_MODE PreviousMode,
    IN BOOLEAN FirstChance
    )

/*++

Routine Description:

    This function is called to dispatch an exception to the proper mode and
    to cause the exception dispatcher to be called. If the previous mode is
    kernel, then the exception dispatcher is called directly to process the
    exception. Otherwise the exception record, exception frame, and trap
    frame contents are copied to the user mode stack. The contents of the
    exception frame and trap are then modified such that when control is
    returned, execution will commense in user mode in a routine which will
    call the exception dispatcher.

Arguments:

    ExceptionRecord - Supplies a pointer to an exception record.

    ExceptionFrame - Supplies a pointer to an exception frame. For NT386,
        this should be NULL.

    TrapFrame - Supplies a pointer to a trap frame.

    PreviousMode - Supplies the previous processor mode.

    FirstChance - Supplies a boolean value that specifies whether this is
        the first (TRUE) or second (FALSE) chance for the exception.

Return Value:

    None.

--*/

{
    CONTEXT ContextFrame;
    EXCEPTION_RECORD ExceptionRecord1, ExceptionRecord2;
    LONG Length;
    ULONG UserStack1;
    ULONG UserStack2;

    //
    // Move machine state from trap and exception frames to a context frame,
    // and increment the number of exceptions dispatched.
    //

    KeGetCurrentPrcb()->KeExceptionDispatchCount += 1;
    ContextFrame.ContextFlags = CONTEXT_FULL | CONTEXT_DEBUG_REGISTERS;

    if ((PreviousMode == UserMode) || KdDebuggerEnabled) {
        //
        // For usermode exceptions always try to dispatch the floating
        // point state.  This allows exception handlers & debuggers to
        // examine/edit the npx context if required.  Plus it allows
        // exception handlers to use fp instructions without destroying
        // the npx state at the time of the exception.
        //
        // Note: If there's no 80387, ContextTo/FromKFrames will use the
        // emulator's current state.  If the emulator can not give the
        // current state, then the context_floating_point bit will be
        // turned off by ContextFromKFrames.
        //

        ContextFrame.ContextFlags |= CONTEXT_FLOATING_POINT;
        if (KeI386XMMIPresent) {
            ContextFrame.ContextFlags |= CONTEXT_EXTENDED_REGISTERS;
        }
    }

    KeContextFromKframes(TrapFrame, ExceptionFrame, &ContextFrame);

    //
    // if it is BREAK_POINT exception, we subtract 1 from EIP and report
    // the updated EIP to user.  This is because Cruiser requires EIP
    // points to the int 3 instruction (not the instruction following int 3).
    // In this case, BreakPoint exception is fatal. Otherwise we will step
    // on the int 3 over and over again, if user does not handle it
    //
    // if the BREAK_POINT occured in V86 mode, the debugger running in the
    // VDM will expect CS:EIP to point after the exception (the way the
    // processor left it.  this is also true for protected mode dos
    // app debuggers.  We will need a way to detect this.
    //
    //

    switch (ExceptionRecord->ExceptionCode) {
        case STATUS_BREAKPOINT:
            ContextFrame.Eip--;
            break;

        case KI_EXCEPTION_ACCESS_VIOLATION:
            ExceptionRecord->ExceptionCode = STATUS_ACCESS_VIOLATION;
            if (PreviousMode == UserMode) {
                if (KiCheckForAtlThunk(ExceptionRecord,&ContextFrame) != FALSE) {
                    goto Handled1;
                }

                if ((SharedUserData->ProcessorFeatures[PF_NX_ENABLED] == TRUE) &&
                    (ExceptionRecord->ExceptionInformation [0] == EXCEPTION_EXECUTE_FAULT)) {
                    
                    if (((KeFeatureBits & KF_GLOBAL_32BIT_EXECUTE) != 0) ||
                        (PsGetCurrentProcess()->Pcb.Flags.ExecuteEnable != 0) ||
                        (((KeFeatureBits & KF_GLOBAL_32BIT_NOEXECUTE) == 0) &&
                         (PsGetCurrentProcess()->Pcb.Flags.ExecuteDisable == 0))) {
                        ExceptionRecord->ExceptionInformation [0] = 0;
                    }
                }
            }
            break;
    }

    //
    // Select the method of handling the exception based on the previous mode.
    //

    ASSERT ((
             !((PreviousMode == KernelMode) &&
             (ContextFrame.EFlags & EFLAGS_V86_MASK))
           ));

    if (PreviousMode == KernelMode) {

        //
        // Previous mode was kernel.
        //
        // If the kernel debugger is active, then give the kernel debugger the
        // first chance to handle the exception. If the kernel debugger handles
        // the exception, then continue execution. Else attempt to dispatch the
        // exception to a frame based handler. If a frame based handler handles
        // the exception, then continue execution.
        //
        // If a frame based handler does not handle the exception,
        // give the kernel debugger a second chance, if it's present.
        //
        // If the exception is still unhandled, call KeBugCheck().
        //

        if (FirstChance == TRUE) {

            if ((KiDebugRoutine != NULL) &&
               (((KiDebugRoutine) (TrapFrame,
                                   ExceptionFrame,
                                   ExceptionRecord,
                                   &ContextFrame,
                                   PreviousMode,
                                   FALSE)) != FALSE)) {

                goto Handled1;
            }

            // Kernel debugger didn't handle exception.

            if (RtlDispatchException(ExceptionRecord, &ContextFrame) == TRUE) {
                goto Handled1;
            }
        }

        //
        // This is the second chance to handle the exception.
        //

        if ((KiDebugRoutine != NULL) &&
            (((KiDebugRoutine) (TrapFrame,
                                ExceptionFrame,
                                ExceptionRecord,
                                &ContextFrame,
                                PreviousMode,
                                TRUE)) != FALSE)) {

            goto Handled1;
        }

        KeBugCheckEx(
            KERNEL_MODE_EXCEPTION_NOT_HANDLED,
            ExceptionRecord->ExceptionCode,
            (ULONG)ExceptionRecord->ExceptionAddress,
            (ULONG)TrapFrame,
            0);

    } else {

        //
        // Previous mode was user.
        //
        // If this is the first chance and the current process has a debugger
        // port, then send a message to the debugger port and wait for a reply.
        // If the debugger handles the exception, then continue execution. Else
        // transfer the exception information to the user stack, transition to
        // user mode, and attempt to dispatch the exception to a frame based
        // handler. If a frame based handler handles the exception, then continue
        // execution with the continue system service. Else execute the
        // NtRaiseException system service with FirstChance == FALSE, which
        // will call this routine a second time to process the exception.
        //
        // If this is the second chance and the current process has a debugger
        // port, then send a message to the debugger port and wait for a reply.
        // If the debugger handles the exception, then continue execution. Else
        // if the current process has a subsystem port, then send a message to
        // the subsystem port and wait for a reply. If the subsystem handles the
        // exception, then continue execution. Else terminate the process.
        //


        if (FirstChance == TRUE) {

            //
            // This is the first chance to handle the exception.
            //

            if ((KiDebugRoutine != NULL)  &&
                ((PsGetCurrentProcess()->DebugPort == NULL &&
                  !KdIgnoreUmExceptions) ||
                 (KdIsThisAKdTrap(ExceptionRecord, &ContextFrame, UserMode)))) {
                //
                // Now dispatch the fault to the kernel debugger.
                //

                if ((((KiDebugRoutine) (TrapFrame,
                                        ExceptionFrame,
                                        ExceptionRecord,
                                        &ContextFrame,
                                        PreviousMode,
                                        FALSE)) != FALSE)) {

                    goto Handled1;
                }
            }

            if (DbgkForwardException(ExceptionRecord, TRUE, FALSE)) {
                goto Handled2;
            }

            //
            // Transfer exception information to the user stack, transition
            // to user mode, and attempt to dispatch the exception to a frame
            // based handler.

            ExceptionRecord1.ExceptionCode = 0; // satisfy no_opt compilation

        repeat:
            try {

                //
                // If the SS segment is not 32 bit flat, there is no point
                // to dispatch exception to frame based exception handler.
                //

                if (TrapFrame->HardwareSegSs != (KGDT_R3_DATA | RPL_MASK) ||
                    TrapFrame->EFlags & EFLAGS_V86_MASK ) {
                    ExceptionRecord2.ExceptionCode = STATUS_ACCESS_VIOLATION;
                    ExceptionRecord2.ExceptionFlags = 0;
                    ExceptionRecord2.NumberParameters = 0;
                    ExRaiseException(&ExceptionRecord2);
                }

                //
                // Compute length of context record and new aligned user stack
                // pointer.
                //

                UserStack1 = (ContextFrame.Esp & ~CONTEXT_ROUND) - CONTEXT_ALIGNED_SIZE;

                //
                // Probe user stack area for writability and then transfer the
                // context record to the user stack.
                //

                ProbeForWrite((PCHAR)UserStack1, CONTEXT_ALIGNED_SIZE, CONTEXT_ALIGN);
                RtlCopyMemory((PULONG)UserStack1, &ContextFrame, sizeof(CONTEXT));

                //
                // Compute length of exception record and new aligned stack
                // address.
                //

                Length = (sizeof(EXCEPTION_RECORD) - (EXCEPTION_MAXIMUM_PARAMETERS -
                         ExceptionRecord->NumberParameters) * sizeof(ULONG) +3) &
                         (~3);
                UserStack2 = UserStack1 - Length;

                //
                // Probe user stack area for writeability and then transfer the
                // context record to the user stack area.
                // N.B. The probing length is Length+8 because there are two
                //      arguments need to be pushed to user stack later.
                //

                ProbeForWrite((PCHAR)(UserStack2 - 8), Length + 8, sizeof(ULONG));
                RtlCopyMemory((PULONG)UserStack2, ExceptionRecord, Length);

                //
                // Push address of exception record, context record to the
                // user stack.  They are the two parameters required by
                // _KiUserExceptionDispatch.
                //

                *(PULONG)(UserStack2 - sizeof(ULONG)) = UserStack1;
                *(PULONG)(UserStack2 - 2*sizeof(ULONG)) = UserStack2;

                //
                // Set new stack pointer to the trap frame.
                //

                KiSegSsToTrapFrame(TrapFrame, KGDT_R3_DATA);
                KiEspToTrapFrame(TrapFrame, (UserStack2 - sizeof(ULONG)*2));

                //
                // Force correct R3 selectors into TrapFrame.
                //

                TrapFrame->SegCs = SANITIZE_SEG(KGDT_R3_CODE, PreviousMode);
                TrapFrame->SegDs = SANITIZE_SEG(KGDT_R3_DATA, PreviousMode);
                TrapFrame->SegEs = SANITIZE_SEG(KGDT_R3_DATA, PreviousMode);
                TrapFrame->SegFs = SANITIZE_SEG(KGDT_R3_TEB, PreviousMode);
                TrapFrame->SegGs = 0;

                //
                // Set the address of the exception routine that will call the
                // exception dispatcher and then return to the trap handler.
                // The trap handler will restore the exception and trap frame
                // context and continue execution in the routine that will
                // call the exception dispatcher.
                //

                TrapFrame->Eip = (ULONG)KeUserExceptionDispatcher;
                return;

            } except (KiCopyInformation(&ExceptionRecord1,
                        (GetExceptionInformation())->ExceptionRecord)) {

                //
                // If the exception is a stack overflow, then attempt
                // to raise the stack overflow exception. Otherwise,
                // the user's stack is not accessible, or is misaligned,
                // and second chance processing is performed.
                //

                if (ExceptionRecord1.ExceptionCode == STATUS_STACK_OVERFLOW) {
                    ExceptionRecord1.ExceptionAddress = ExceptionRecord->ExceptionAddress;
                    RtlCopyMemory((PVOID)ExceptionRecord,
                                  &ExceptionRecord1, sizeof(EXCEPTION_RECORD));
                    goto repeat;
                }
            }
        }

        //
        // This is the second chance to handle the exception.
        //

        if (DbgkForwardException(ExceptionRecord, TRUE, TRUE)) {
            goto Handled2;
        } else if (DbgkForwardException(ExceptionRecord, FALSE, TRUE)) {
            goto Handled2;
        } else {
            ZwTerminateProcess(NtCurrentProcess(), ExceptionRecord->ExceptionCode);
            KeBugCheckEx(
                KERNEL_MODE_EXCEPTION_NOT_HANDLED,
                ExceptionRecord->ExceptionCode,
                (ULONG)ExceptionRecord->ExceptionAddress,
                (ULONG)TrapFrame,
                0);
        }
    }

    //
    // Move machine state from context frame to trap and exception frames and
    // then return to continue execution with the restored state.
    //

Handled1:

    KeContextToKframes(TrapFrame, ExceptionFrame, &ContextFrame,
                       ContextFrame.ContextFlags, PreviousMode);

    //
    // Exception was handled by the debugger or the associated subsystem
    // and state was modified, if necessary, using the get state and set
    // state capabilities. Therefore the context frame does not need to
    // be transferred to the trap and exception frames.
    //

Handled2:
    return;
}

ULONG
KiCopyInformation (
    IN OUT PEXCEPTION_RECORD ExceptionRecord1,
    IN PEXCEPTION_RECORD ExceptionRecord2
    )

/*++

Routine Description:

    This function is called from an exception filter to copy the exception
    information from one exception record to another when an exception occurs.

Arguments:

    ExceptionRecord1 - Supplies a pointer to the destination exception record.

    ExceptionRecord2 - Supplies a pointer to the source exception record.

Return Value:

    A value of EXCEPTION_EXECUTE_HANDLER is returned as the function value.

--*/

{

    //
    // Copy one exception record to another and return value that causes
    // an exception handler to be executed.
    //

    RtlCopyMemory((PVOID)ExceptionRecord1,
                  (PVOID)ExceptionRecord2,
                  sizeof(EXCEPTION_RECORD));

    return EXCEPTION_EXECUTE_HANDLER;
}

NTSTATUS
KeRaiseUserException(
    IN NTSTATUS ExceptionCode
    )

/*++

Routine Description:

    This function causes an exception to be raised in the calling thread's user-mode
    context. It does this by editing the trap frame the kernel was entered with to
    point to trampoline code that raises the requested exception.

Arguments:

    ExceptionCode - Supplies the status value to be used as the exception
        code for the exception that is to be raised.

Return Value:

    The status value that should be returned by the caller.

--*/

{
    PKTHREAD Thread;
    PKTRAP_FRAME TrapFrame;
    PTEB Teb;
    ULONG PreviousEsp;

    Thread = KeGetCurrentThread();
    TrapFrame = Thread->TrapFrame;
    if (TrapFrame == NULL || ((TrapFrame->SegCs & MODE_MASK) != UserMode)) {
        return ExceptionCode;
    }

    Teb = (PTEB)Thread->Teb;

    //
    // In order to create the correct call stack, we push the old return
    // address onto the stack. The status code to be raised is passed
    // in the TEB.
    //

    try {
        Teb->ExceptionCode = ExceptionCode;

        PreviousEsp = KiEspFromTrapFrame (TrapFrame) - sizeof (ULONG);

        ProbeForWriteSmallStructure ((PLONG)PreviousEsp, sizeof (LONG), sizeof (UCHAR));
        *(PLONG)PreviousEsp = TrapFrame->Eip;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        return(ExceptionCode);
    }

    KiEspToTrapFrame (TrapFrame, PreviousEsp);

    TrapFrame->Eip = (ULONG)KeRaiseUserExceptionDispatcher;

    return ExceptionCode;
}


BOOLEAN
KiCheckForAtlThunk (
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN PCONTEXT Context
    )

/*++

Routine Description:

    This routine will determine whether an access violation was raised due to
    an attempt to execute an ATL thunk in a no-execute, non-stack area.

    If so, the thunk will be emulated and execution resumed.

Arguments:

    ExceptionRecord - Supplies a pointer to an exception record.

    Context - Supplies a pointer to a context frame.

Return Value:

    TRUE - Context was updated to reflect the emulated ATL thunk, resume
           execution.

    FALSE - Not an ATL thunk, continue raising the exception.

--*/

{
    ULONG faultIndicator;

    //
    // Interested only in an instruction fetch fault.
    // 

    faultIndicator = ExceptionRecord->ExceptionInformation[0];
    if ((faultIndicator & 0x8) == 0) {
        return FALSE;
    }

    //
    // Where the fault address is the instruction
    // 

    if (ExceptionRecord->ExceptionInformation[1] != Context->Eip) {
        return FALSE;
    }

    if (KiEmulateAtlThunk(&Context->Eip,
                          &Context->Esp,
                          &Context->Eax,
                          &Context->Ecx,
                          &Context->Edx)) {

        return TRUE;
    } else {
        return FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ke\i386\i386init.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    i386init.c

Abstract:

    This module contains code to manipulate i386 hardware structures used
    only by the kernel.

--*/

#include    "ki.h"

VOID
KiInitializeMachineType (
    VOID
    );

#pragma alloc_text(INIT,KiInitializeMachineType)

KIRQL   KiProfileIrql = PROFILE_LEVEL;
ULONG   KeI386MachineType = 0;
BOOLEAN KeI386NpxPresent;
BOOLEAN KeI386FxsrPresent;
ULONG   KeI386ForceNpxEmulation;
ULONG   KiMXCsrMask;
ULONG   KeI386CpuType;
ULONG   KeI386CpuStep;
PVOID   Ki387RoundModeTable;    // R3 emulators RoundingMode vector table
ULONG   KiBootFeatureBits;

ULONG KiInBiosCall = FALSE;
ULONG FlagState = 0;                    // bios calls shouldn't automatically turn interrupts back on.

KTRAP_FRAME KiBiosFrame;

#if DBG
UCHAR   MsgDpcTrashedEsp[] = "\n*** DPC routine %lx trashed ESP\n";
UCHAR   MsgDpcTimeout[]    = "\n*** DPC routine > 1 sec --- This is not a break in KeUpdateSystemTime\n";
UCHAR   MsgISRTimeout[]    = "\n*** ISR at %lx took over .5 second\n";

ULONG   KiISRTimeout       = 55;
#endif
UCHAR   MsgISROverflow[]    = "\n*** ISR at %lx appears to have an interrupt storm\n";
USHORT  KiISROverflow      = 30000;

VOID
KiInitializeMachineType (
    VOID
    )

/*++

Routine Description:

    This function initializes machine type, i.e. MCA, ABIOS, ISA
    or EISA.
    N.B.  This is a temporary routine.  machine type:
          Byte 0 - Machine Type, ISA, EISA or MCA
          Byte 1 - CPU type, i386 or i486
          Byte 2 - Cpu Step, A or B ... etc.
          Highest bit indicates if NPX is present.

Arguments:

    None.

Return Value:

    None.

--*/

{
    KeI386MachineType = KeLoaderBlock->u.I386.MachineType & 0x000ff;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ke\i386\i386pcr.asm ===
title  "I386 PCR"
;++
;
; Copyright (c) Microsoft Corporation. All rights reserved. 
;
; You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
; If you do not agree to the terms, do not use the code.
;
;
; Module Name:
;
;    i386pcr.asm
;
; Abstract:
;
;    This module implements routines for accessing and initializing the pcr.
;
; Environment:
;
;    Kernel mode, early init of first processor.
;
;--

.386p
        .xlist
include ks386.inc
include callconv.inc                    ; calling convention macros
        .list

;
;   NOTE - This definition of PCR gives us 2 instructions to get to some
;       variables that need to be addressable in one instruction.  Any
;       such variable (such as current thread) must be accessed via its
;       own access procedure (see below), NOT by KeGetPcr()->PbCurrentThread.
;       (This is only an issue on MP machines.)
;

_TEXT$00   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

;++
;
; PKTHREAD
; KeGetCurrentThread()
;
; Return Value:
;
;   Pointer to current Thread object.
;
;--
cPublicProc ___KeGetCurrentThread   ,0

        mov     eax,PCR[PcPrcbData+PbCurrentThread]
        stdRET    ___KeGetCurrentThread

stdENDP ___KeGetCurrentThread


;++
;
; KPROCESSOR_MODE
; KeGetPreviousMode()
;
; Return Value:
;
;   PreviousMode of current thread.
;
;--
cPublicProc _KeGetPreviousMode

        mov     eax,PCR[PcPrcbData+PbCurrentThread] ; (eax) -> Thread
        movzx   eax,byte ptr [eax]+ThPreviousMode   ; (eax) = PreviousMode
        stdRET    _KeGetPreviousMode

stdENDP _KeGetPreviousMode


;++
;
; BOOLEAN
; KeIsExecutingDpc(
;       VOID
;       );
;
; Return Value:
;
;   Value of flag which indicates whether we're executing in DPC context
;
;--

cPublicProc ___KeIsExecutingDpc   ,0

        movzx     eax, byte ptr PCR[PcPrcbData.PbDpcRoutineActive]
        stdRET    ___KeIsExecutingDpc

stdENDP ___KeIsExecutingDpc


;++
;
; VOID
; GetMachineBootPointers(
;       )
;
; Routine Description:
;
;   This routine is called at system startup to extract the address of
;   the PCR and machine control values.  It is useful only for the P0
;   case where the boot loader must already init the machine before it
;   turns on paging and calls us.
;
;   Pcr address is extracted from the base of KGDT_R0_PCR.
;
;   Gdt and Idt are extracted from the machine GDTR and IDTR.
;
;   TSS is derived from the TSR and related descriptor.
;
; Arguments:
;
;   None.
;
; Return Value:
;
;
;   (edi) -> gdt
;   (esi) -> pcr
;   (edx) -> tss
;   (eax) -> idt
;
;--

cPublicProc GetMachineBootPointers

        push    ebp
        mov     ebp,esp
        sub     esp,8

        sgdt    fword ptr [ebp-8]
        mov     edi,[ebp-6]             ; (edi) = gdt address

        mov     cx,fs
        and     cx,(NOT RPL_MASK)
        movzx   ecx,cx
        add     ecx,edi                 ; (ecx) -> pcr descriptor

        mov     dh,[ecx+KgdtBaseHi]
        mov     dl,[ecx+KgdtBaseMid]
        shl     edx,16
        mov     dx,[ecx+KgdtBaseLow]    ; (edx) -> pcr
        mov     esi,edx                 ; (esi) -> pcr

        str     cx
        movzx   ecx,cx
        add     ecx,edi                 ; (ecx) -> TSS descriptor

        mov     dh,[ecx+KgdtBaseHi]
        mov     dl,[ecx+KgdtBaseMid]
        shl     edx,16
        mov     dx,[ecx+KgdtBaseLow]    ; (edx) -> TSS

        sidt    fword ptr [ebp-8]
        mov     eax,[ebp-6]             ; (eax) -> Idt

        mov     esp,ebp
        pop     ebp
        stdRET    GetMachineBootPointers

stdENDP GetMachineBootPointers

_TEXT$00   ENDS
        end
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ke\i386\int.asm ===
title  "Trap Processing"
;++
;
; Copyright (c) Microsoft Corporation. All rights reserved. 
;
; You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
; If you do not agree to the terms, do not use the code.
;
;
; Module Name:
;
;    int.asm
;
; Abstract:
;
;    This module implements the code necessary to field and process i386
;    interrupt.
;
;--

.386p
        .xlist
include ks386.inc
include i386\kimacro.inc
include callconv.inc
        .list

;
; Interrupt flag bit maks for EFLAGS
;

EFLAGS_IF                       equ     200H
EFLAGS_SHIFT                    equ     9

_TEXT   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:FLAT, FS:NOTHING, GS:NOTHING

; NOTE  This routine is never actually called on standard x86 hardware,
;       because passive level doesn't actually exist.  It's here to
;       fill out the portable skeleton.
;
; The following code is called when a passive release occurs and there is
; no interrupt to process.
;

cPublicProc _KiPassiveRelease       ,0
        stdRET    _KiPassiveRelease                             ; cReturn
stdENDP _KiPassiveRelease


        page ,132
        subttl  "Disable Processor Interrupts"
;++
;
; BOOLEAN
; KeDisableInterrupts(
;    VOID
;    )
;
; Routine Description:
;
;    This routine disables interrupts at the processor level.  It does not
;    edit the PICS or adjust IRQL, it is for use in the debugger only.
;
; Arguments:
;
;    None
;
; Return Value:
;
;    (eax) = !0 if interrupts were on, 0 if they were off
;
;--

cPublicProc _KeDisableInterrupts    ,0
cPublicFpo 0, 0
        pushfd
        pop     eax
        and     eax,EFLAGS_IF               ; (eax) = the interrupt bit
        shr     eax,EFLAGS_SHIFT            ; low bit of (eax) == interrupt bit
        cli
        stdRET    _KeDisableInterrupts

stdENDP _KeDisableInterrupts

_TEXT   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ke\i386\instemul.asm ===
title  "Vdm Instuction Emulation"
;++
;
; Copyright (c) Microsoft Corporation. All rights reserved. 
;
; You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
; If you do not agree to the terms, do not use the code.
;
;
; Module Name:
;
;    instemul.asm
;
; Abstract:
;
;    This module contains the routines for emulating instructions and
;    faults to a VDM.
;
;--
.386p
        .xlist
include ks386.inc
include i386\kimacro.inc
include mac386.inc
include i386\mi.inc
include callconv.inc
include ..\..\vdm\i386\vdm.inc
include vdmtib.inc
include irqli386.inc
        .list

        extrn   VdmOpcode0f:proc
        extrn   OpcodeNPXV86:proc
        extrn   VdmDispatchIntAck:proc   ;; only OpcodeSti uses this
ifdef VDMDBG
        EXTRNP  _VdmTraceEvent,4
endif
        extrn   CommonDispatchException:proc ;; trap.asm
        extrn   _DbgPrint:proc
        extrn   _KeI386VirtualIntExtensions:dword
        extrn   _MmHighestUserAddress:dword
        EXTRNP  _Ki386GetSelectorParameters,4
        EXTRNP  _Ki386VdmDispatchIo,5
        EXTRNP  _Ki386VdmDispatchStringIo,8
        EXTRNP  _KiDispatchException,5
        EXTRNP  _VdmPrinterStatus,3
        EXTRNP  _VdmPrinterWriteData, 3
        EXTRNP  _VdmClearPMCliTimeStamp, 0
        EXTRNP  _VdmSetPMCliTimeStamp, 1
        extrn   _MmUserProbeAddress:DWORD
        EXTRNP  _VdmFetchULONG,1
        EXTRNP  _Ki386AdjustEsp0,1

        page ,132

ifdef VDMDBG
%out Debugging version
endif

;
;   Force assume into place
;

_PAGE   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME DS:NOTHING, ES:NOTHING, SS:NOTHING, FS:NOTHING, GS:NOTHING
_PAGE   ENDS

_TEXT$00   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:NOTHING, ES:NOTHING, SS:NOTHING, FS:NOTHING, GS:NOTHING
_TEXT$00   ENDS

PAGECONST   SEGMENT  DWORD PUBLIC 'DATA'


;
;  Instruction emulation emulates the following instructions.
;  The emulation affects the noted user mode registers.
;
;  In protected mode, the following instructions are emulated in the kernel
;
;    Registers  (E)Flags (E)SP  SS  CS
;       INTnn      X       X     X   X
;       INTO       X       X     X   X
;       CLI        X
;       STI        X
;
;  The following instructions are always emulated by reflection to the
;  Usermode VDM monitor
;
;       INSB
;       INSW
;       OUTSB
;       OUTSW
;       INBimm
;       INWimm
;       OUTBimm
;       OUTWimm
;       INB
;       INW
;       OUTB
;       OUTW
;
;  WARNING What do we do about 32 bit io instructions??


;
;       OpcodeIndex - packed 1st level table to index OpcodeDispatch table
;
        public OpcodeIndex
diBEGIN OpcodeIndex,VDM_INDEX_Invalid
        dtI      0fh, VDM_INDEX_0F
        dtI      26h, VDM_INDEX_ESPrefix
        dtI      2eh, VDM_INDEX_CSPrefix
        dtI      36h, VDM_INDEX_SSPrefix
        dtI      3eh, VDM_INDEX_DSPrefix
        dtI      64h, VDM_INDEX_FSPrefix
        dtI      65h, VDM_INDEX_GSPrefix
        dtI      66h, VDM_INDEX_OPER32Prefix
        dtI      67h, VDM_INDEX_ADDR32Prefix
        dtI      6ch, VDM_INDEX_INSB
        dtI      6dh, VDM_INDEX_INSW
        dtI      6eh, VDM_INDEX_OUTSB
        dtI      6fh, VDM_INDEX_OUTSW
        dtI      9bh, VDM_INDEX_NPX
        dtI      9ch, VDM_INDEX_PUSHF
        dtI      9dh, VDM_INDEX_POPF
        dtI     0cdh, VDM_INDEX_INTnn
        dtI     0ceh, VDM_INDEX_INTO
        dtI     0cfh, VDM_INDEX_IRET
        dtI     0d8h, VDM_INDEX_NPX
        dtI     0d9h, VDM_INDEX_NPX
        dtI     0dah, VDM_INDEX_NPX
        dtI     0dbh, VDM_INDEX_NPX
        dtI     0dch, VDM_INDEX_NPX
        dtI     0ddh, VDM_INDEX_NPX
        dtI     0deh, VDM_INDEX_NPX
        dtI     0dfh, VDM_INDEX_NPX
        dtI     0e4h, VDM_INDEX_INBimm
        dtI     0e5h, VDM_INDEX_INWimm
        dtI     0e6h, VDM_INDEX_OUTBimm
        dtI     0e7h, VDM_INDEX_OUTWimm
        dtI     0ech, VDM_INDEX_INB
        dtI     0edh, VDM_INDEX_INW
        dtI     0eeh, VDM_INDEX_OUTB
        dtI     0efh, VDM_INDEX_OUTW
        dtI     0f0h, VDM_INDEX_LOCKPrefix
        dtI     0f2h, VDM_INDEX_REPNEPrefix
        dtI     0f3h, VDM_INDEX_REPPrefix
        dtI     0f4h, VDM_INDEX_HLT
        dtI     0fah, VDM_INDEX_CLI
        dtI     0fbh, VDM_INDEX_STI
diEND   NUM_OPCODE

;
;       OpcodeDispatch - table of routines used to emulate instructions
;

        public OpcodeDispatch
dtBEGIN OpcodeDispatch,OpcodeInvalid
        dtS     VDM_INDEX_0F          , Opcode0F
        dtS     VDM_INDEX_ESPrefix    , OpcodeESPrefix
        dtS     VDM_INDEX_CSPrefix    , OpcodeCSPrefix
        dtS     VDM_INDEX_SSPrefix    , OpcodeSSPrefix
        dtS     VDM_INDEX_DSPrefix    , OpcodeDSPrefix
        dtS     VDM_INDEX_FSPrefix    , OpcodeFSPrefix
        dtS     VDM_INDEX_GSPrefix    , OpcodeGSPrefix
        dtS     VDM_INDEX_OPER32Prefix, OpcodeOPER32Prefix
        dtS     VDM_INDEX_ADDR32Prefix, OpcodeADDR32Prefix
        dtS     VDM_INDEX_INSB        , OpcodeINSB
        dtS     VDM_INDEX_INSW        , OpcodeINSW
        dtS     VDM_INDEX_OUTSB       , OpcodeOUTSB
        dtS     VDM_INDEX_OUTSW       , OpcodeOUTSW
        dtS     VDM_INDEX_INTnn       , OpcodeINTnn
        dtS     VDM_INDEX_INTO        , OpcodeINTO
        dtS     VDM_INDEX_INBimm      , OpcodeINBimm
        dtS     VDM_INDEX_INWimm      , OpcodeINWimm
        dtS     VDM_INDEX_OUTBimm     , OpcodeOUTBimm
        dtS     VDM_INDEX_OUTWimm     , OpcodeOUTWimm
        dtS     VDM_INDEX_INB         , OpcodeINB
        dtS     VDM_INDEX_INW         , OpcodeINW
        dtS     VDM_INDEX_OUTB        , OpcodeOUTB
        dtS     VDM_INDEX_OUTW        , OpcodeOUTW
        dtS     VDM_INDEX_LOCKPrefix  , OpcodeLOCKPrefix
        dtS     VDM_INDEX_REPNEPrefix , OpcodeREPNEPrefix
        dtS     VDM_INDEX_REPPrefix   , OpcodeREPPrefix
        dtS     VDM_INDEX_CLI         , OpcodeCLI
        dtS     VDM_INDEX_STI         , OpcodeSTI
dtEND   MAX_VDM_INDEX

PAGECONST   ENDS

PAGEDATA   SEGMENT  DWORD PUBLIC 'DATA'

        public  _ExVdmOpcodeDispatchCounts,_ExVdmSegmentNotPresent
_ExVdmOpcodeDispatchCounts dd      MAX_VDM_INDEX dup(0)
_ExVdmSegmentNotPresent    dd      0

PAGEDATA   ENDS

_PAGE   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:NOTHING, ES:NOTHING, SS:FLAT, FS:NOTHING, GS:NOTHING

        page   ,132
        subttl "Overide Prefix Macro"
;++
;
;   Routine Description:
;
;       This macro generates the code for handling override prefixes
;       The routine name generated is OpcodeXXXXPrefix, where XXXX is
;       the name used in the macro invocation.  The code will set the
;       PREFIX_XXXX bit in the Prefix flags.
;
;   Arguments
;       name = name of prefix
;       EBP -> trap frame
;       EBX -> prefix flags, BL = instruction length count
;       ECX -> byte at the faulting address
;       EDX -> pointer to vdm state in DOS arena
;       ESI -> Reginfo struct
;       EDI -> address of faulting instruction
;
;   Returns
;       user mode Eip advanced
;       eax advanced
;       edx contains next byte of opcode
;
;   NOTE: This routine exits by dispatching through the table again.
;--
opPrefix macro name
        public Opcode&name&Prefix
Opcode&name&Prefix proc

        or      [esi].RiPrefixFlags,PREFIX_&name
        jmp     OpcodeGenericPrefix     ; dispatch to next handler

Opcode&name&Prefix endp
endm

irp prefix, <ES, CS, SS, DS, FS, GS, OPER32, ADDR32, LOCK, REPNE, REP>

        opPrefix prefix

endm

        page   ,132
        subttl "Instruction Emulation Dispatcher"
;++
;
;   Routine Description:
;
;       This routine dispatches to the opcode specific emulation routine,
;       based on the first byte of the opcode.  Two byte opcodes, and prefixes
;       result in another level of dispatching, from the handling routine.
;
;   Arguments:
;
;       [esp+4] = pointer to trap frame
;
;   Returns:
;
;       Nothing
;
;

cPublicProc _Ki386DispatchOpcode,1

        push    ebp
        mov     ebp, [esp+8]
        sub     esp,REGINFOSIZE
        mov     esi, esp                        ; scratch area

        CsToLinearPM [ebp].TsSegCs, doerr       ; initialize reginfo

        mov     edi,[ebp].TsEip                 ; get fault instruction address
        cmp     edi,[esi].RiCsLimit             ; check eip
        ja      doerr

        add     edi,[esi].RiCsBase
        cmp     edi, _MmUserProbeAddress
        ja      doerr

        movzx   ecx,byte ptr [edi]              ; get faulting opcode

        mov     eax,ecx
        and     eax,0F8h                                ; check for npx instr
        cmp     eax,0D8h
        je      do30                                    ; dispatch

        movzx   eax, OpcodeIndex[ecx]
        mov     ebx,1                           ; length count, flags

        ; All handler routines will get the following on entry
        ; ebp -> trap frame
        ; ebx -> prefix flags, instruction length count
        ; ecx -> byte at the faulting address
        ; edx -> pointer to vdm state in DOS arena
        ; interrupts enabled and Irql at APC level
        ; edi -> address of faulting instruction
        ; esi -> reginfo struct
        ; All handler routines will return
        ; EAX = 0 for failure
        ; EAX = 1 for success
if DEVL
        inc     _ExVdmOpcodeDispatchCounts[eax * type _ExVdmOpcodeDispatchCounts]
endif
ifdef VDMDBG
        pushad
        stdCall _VdmTraceEvent, <VDMTR_KERNEL_OP_PM,ecx,0,ebp>
        popad
endif

        call    OpcodeDispatch[eax * type OpcodeDispatch]
do20:
        add     esp,REGINFOSIZE
        pop     ebp
        stdRET  _Ki386DispatchOpcode

doerr:  xor     eax,eax
        jmp     do20

        ;
        ; If we get here, we have executed an NPX instruction in user mode
        ; with the emulator installed.  If the EM bit was not set in CR0, the
        ; app really wanted to execute the instruction for detection purposes.
        ; In this case, we need to clear the TS bit, and restart the instruction.
        ; Otherwise we need to reflect the exception
        ;
do30:
        call OpcodeNPXV86
        jmp  short do20

stdENDP _Ki386DispatchOpcode


        page   ,132
        subttl "Invalid Opcode Handler"
;++
;
;   Routine Description:
;
;       This routine causes a GP fault to be reflected to the vdm
;
;   Arguments:
;       EBP -> trap frame
;       EBX -> prefix flags, BL = instruction length count
;       ECX -> byte at the faulting address
;       EDX -> pointer to vdm state in DOS arena
;       ESI -> Reginfo struct
;       EDI -> address of faulting instruction
;
;   Returns:
;
;       nothing
;

        public OpcodeInvalid
OpcodeInvalid proc
        xor     eax,eax                 ; ret fail
        ret

OpcodeInvalid endp


        page   ,132
        subttl "Generic Prefix Handler"
;++
;
;   Routine Description:
;
;       This routine handles the generic portion of all of the prefixes,
;       and dispatches the next byte of the opcode.
;
;   Arguments:
;       EBP -> trap frame
;       EBX -> prefix flags, BL = instruction length count
;       ECX -> byte at the faulting address
;       EDX -> pointer to vdm state in DOS arena
;       ESI -> Reginfo struct
;       EDI -> address of faulting instruction
;
;   Returns:
;
;       user mode Eip advanced
;       edx contains next byte of opcode
;

        public OpcodeGenericPrefix
OpcodeGenericPrefix proc

        inc     edi                             ; increment eip
        inc     ebx                             ; increment size
        cmp     bl, 128                         ; set arbitrary inst size limit
        ja      ogperr                          ; in case of pointless prefixes

        mov     eax,edi                         ; current linear address
        sub     eax,[esi].RiCsBase              ; make address eip
        cmp     eax,[esi].RiCsLimit             ; check eip
        ja      ogperr

        cmp     edi, [_MmHighestUserAddress]
        ja      ogperr

        mov     cl,byte ptr [edi]               ; get next opcode

        movzx   eax, OpcodeIndex[ecx]
if DEVL
        inc     _ExVdmOpcodeDispatchCounts[eax * type _ExVdmOpcodeDispatchCounts]
endif
        jmp     OpcodeDispatch[eax * type OpcodeDispatch]

ogperr:
        xor     eax,eax             ; opcode was NOT handled
        ret

OpcodeGenericPrefix endp


        page   ,132
        subttl "0F Opcode Handler"
;++
;
;   Routine Description:
;
;       This routine emulates a 0Fh opcode.
;
;   Arguments:
;       EBP -> trap frame
;       EBX -> prefix flags, BL = instruction length count
;       ECX -> byte at the faulting address
;       EDX -> pointer to vdm state in DOS arena
;       ESI -> Reginfo struct
;       EDI -> address of faulting instruction
;
;   Returns:
;
;       nothing
;

        public Opcode0F
Opcode0F proc

        mov     eax,[ebp].TsEip                 ; get fault instruction address
        mov     [esi].RiEip,eax
        mov     [esi].RiTrapFrame,ebp
        mov     [esi].RiPrefixFlags,ebx
        mov     eax,dword ptr [ebp].TsEFlags
        mov     [esi].RiEFlags,eax

        call    VdmOpcode0F                     ; enables interrupts
        test    eax,0FFFFh
        jz      o0f20

        mov     eax,[esi].RiEip
        mov     [ebp].TsEip,eax
        mov     eax,1
o0f20:
        ret

Opcode0F endp

        page   ,132
        subttl "Byte string in Opcode Handler"
;++
;
;   Routine Description:
;
;       This routine emulates an INSB opcode.
;
;   Arguments:
;       EBP -> trap frame
;       EBX -> prefix flags, BL = instruction length count
;       ECX -> byte at the faulting address
;       EDX -> pointer to vdm state in DOS arena
;       ESI -> Reginfo struct
;       EDI -> address of faulting instruction
;
;   Returns:
;
;       nothing
;
;  WARNING what to do about size override?  ds override?

        public OpcodeINSB
OpcodeINSB proc

        push    ebp                          ; Trap Frame
        push    ebx                          ; size of insb

        movzx   eax,word ptr [ebp].TsSegEs
        shl     eax,16
        ; WARNING no support for 32bit edi
        mov     ax,word ptr [ebp].TsEdi      ; don't support 32bit'ness
        push    eax                          ; address

        xor     eax, eax
        mov     ecx,1
        test    ebx,PREFIX_REP
        jz      @f

        mov     eax, 1
        ; WARNING no support for 32bit ecx
        movzx   ecx,word ptr [ebp].TsEcx
@@:

        push    ecx                          ; number of io ops
        push    TRUE                         ; read op
        push    eax                          ; REP prefix
        push    1                            ; byte op
        movzx   edx,word ptr [ebp].TsEdx
        push    edx                          ; port number
        call    _Ki386VdmDispatchStringIo@32 ; use retval

        ret

OpcodeINSB endp

        page   ,132
        subttl "Word String In Opcode Handler"
;++
;
;   Routine Description:
;
;       This routine emulates an INSW opcode.
;
;   Arguments:
;       EBP -> trap frame
;       EBX -> prefix flags, BL = instruction length count
;       ECX -> byte at the faulting address
;       EDX -> pointer to vdm state in DOS arena
;       ESI -> Reginfo struct
;       EDI -> address of faulting instruction
;
;   Returns:
;
;       nothing
;

        public OpcodeINSW
OpcodeINSW proc

        push    ebp                             ; Trap frame
        push    ebx                             ; sizeof insw

        movzx   eax,word ptr [ebp].TsSegEs
        shl     eax,16
        ; WARNING no support for 32bit edi
        mov     ax,word ptr [ebp].TsEdi
        push    eax                             ; address

        xor     eax, eax
        mov     ecx,1
        test    ebx,PREFIX_REP
        jz      @f

        mov     eax, 1
        ; WARNING no support for 32bit ecx
        movzx   ecx,word ptr [ebp].TsEcx
@@:
        movzx   edx,word ptr [ebp].TsEdx
        push    ecx                             ; number of io ops
        push    TRUE                            ; read op
        push    eax                             ; REP prefix
        push    2                               ; word size
        push    edx                             ; port number
        call    _Ki386VdmDispatchStringIo@32 ; use retval

        ret

OpcodeINSW endp

        page   ,132
        subttl "Byte String Out Opcode Handler"
;++
;
;   Routine Description:
;
;       This routine emulates an OUTSB opcode.
;
;   Arguments:
;       EBP -> trap frame
;       EBX -> prefix flags, BL = instruction length count
;       ECX -> byte at the faulting address
;       EDX -> pointer to vdm state in DOS arena
;       ESI -> Reginfo struct
;       EDI -> address of faulting instruction
;
;   Returns:
;
;       nothing
;

        public OpcodeOUTSB
OpcodeOUTSB proc

        push    ebp                           ; Trap Frame
        push    ebx                           ; size of outsb

        movzx   eax,word ptr [ebp].TsSegDs
        shl     eax,16
        ; WARNING don't support 32bit'ness, esi
        mov     ax,word ptr [ebp].TsEsi
        push    eax                           ; address

        xor     eax, eax
        mov     ecx,1
        test    ebx,PREFIX_REP
        jz      @f

        mov     eax, 1
        ; WARNING don't support 32bit'ness ecx
        movzx   ecx,word ptr [ebp].TsEcx
@@:
        movzx   edx,word ptr [ebp].TsEdx
        push    ecx                           ; number of io ops
        push    FALSE                         ; write op
        push    eax                           ; REP prefix
        push    1                             ; byte op
        push    edx                           ; port number
        call    _Ki386VdmDispatchStringIo@32 ; use retval

        ret

OpcodeOUTSB endp

        page   ,132
        subttl "Word String Out Opcode Handler"
;++
;
;   Routine Description:
;
;       This routine emulates an OUTSW opcode.
;
;   Arguments:
;       EBP -> trap frame
;       EBX -> prefix flags, BL = instruction length count
;       ECX -> byte at the faulting address
;       EDX -> pointer to vdm state in DOS arena
;       ESI -> Reginfo struct
;       EDI -> address of faulting instruction
;
;   Returns:
;
;       nothing
;

        public OpcodeOUTSW
OpcodeOUTSW proc

        push    ebp                               ; Trap Frame
        push    ebx                               ; size of outsb

        movzx   eax,word ptr [ebp].TsSegDs
        shl     eax,16
        ; WARNING don't support 32bit'ness esi
        mov     ax,word ptr [ebp].TsEsi
        push    eax                               ; address

        xor     eax, eax
        mov     ecx,1
        test    ebx,PREFIX_REP
        jz      @f

        mov     eax, 1
        ; WARNING don't support 32bit'ness ecx
        movzx   ecx,word ptr [ebp].TsEcx
@@:
        movzx   edx,word ptr [ebp].TsEdx

        push    ecx                               ; number of io ops
        push    FALSE                             ; write op
        push    eax                               ; REP prefix
        push    2                                 ; byte op
        push    edx                               ; port number
        call    _Ki386VdmDispatchStringIo@32 ; use retval

        ret

OpcodeOUTSW endp

        page   ,132
        subttl "INTnn Opcode Handler"
;++
;
;   Routine Description:
;
;       This routine emulates an INTnn opcode.  It retrieves the handler
;       from the IVT, pushes the current cs:ip and flags on the stack,
;       and dispatches to the handler.
;
;   Arguments:
;       EBP -> trap frame
;       EBX -> prefix flags, BL = instruction length count
;       ECX -> byte at the faulting address
;       EDX -> pointer to vdm state in DOS arena
;       ESI -> Reginfo struct
;       EDI -> address of faulting instruction
;
;   Returns:
;
;       Current CS:IP on user stack
;       RiCs:RiEip -> handler from IVT
;

        public OpcodeINTnn
OpcodeINTnn proc

        mov     eax, ds:FIXED_NTVDMSTATE_LINEAR
        and     eax, (VDM_INTERRUPT_PENDING + VDM_VIRTUAL_INTERRUPTS)
        cmp     eax, (VDM_INTERRUPT_PENDING + VDM_VIRTUAL_INTERRUPTS)
        jnz     short oi10

        call    VdmDispatchIntAck
        jmp     oi99

oi10:
        mov     eax,dword ptr [ebp].TsEFlags
        call    GetVirtualBits                   ; set interrupt flag
        mov     [esi].RiEFlags,eax
        movzx   eax,word ptr [ebp].TsHardwareSegSs
        call    SsToLinear
        test    al,0FFh
        jz      oinerr

        inc     edi                             ; point to int #
        mov     eax,edi                         ; current linear address
        sub     eax,[esi].RiCsBase              ; make address eip
        cmp     eax,[esi].RiCsLimit             ; check eip
        ja      oinerr

        cmp     edi, [_MmHighestUserAddress]
        ja      oinerr

        movzx   ecx,byte ptr [edi]              ; get int #
        inc     eax                             ; inc past end of instruction
        mov     [esi].RiEip,eax                 ; save for pushint's benefit
        call    PushInt                         ; will return retcode in al
        test    al,0FFh
        jz      oinerr                          ; error!

        mov     eax,[esi].RiEsp
        mov     [ebp].TsHardwareEsp,eax
        mov     ax,word ptr [esi].RiSegCs
        or      ax, 7                           ; R3 LDT selectors only
        cmp     ax, 8
        jge     short @f
        test    dword ptr [esi].RiEFlags, EFLAGS_V86_MASK
        jnz     short @f
        mov     ax, KGDT_R3_DATA OR RPL_MASK
@@:     mov     word ptr [ebp].TsSegCs,ax
        mov     eax,[esi].RiEFlags
        push    [ebp].TsEFlags
        mov     [ebp].TsEFlags,eax
        ;
        ; Here we directly enable INT on TrapFrame.  This may break Kei386IOPLAllowed.
        ; Eventually, if we decide to support Kei386IoplAllowed.  We need to make it work
        ; first.  Today, it does NOT work.  We should remove the IOPL allowed stuff.
        ;
        or      dword ptr [ebp].TsEFlags, EFLAGS_INTERRUPT_MASK
        xor     eax, [esp]
        test    eax, EFLAGS_V86_MASK
        pop     eax
        je      short @f
        stdCall _Ki386AdjustEsp0, <ebp>
@@:     mov     eax,[esi].RiEip
        mov     [ebp].TsEip,eax
oi99:
        mov     eax,1
        ret

oinerr:
        xor     eax,eax
        ret


OpcodeINTnn endp

        page   ,132
        subttl "INTO Opcode Handler"
;++
;
;   Routine Description:
;
;       This routine emulates an INTO opcode.
;
;   Arguments:
;       EBP -> trap frame
;       EBX -> prefix flags, BL = instruction length count
;       ECX -> byte at the faulting address
;       EDX -> pointer to vdm state in DOS arena
;       ESI -> Reginfo struct
;       EDI -> address of faulting instruction
;
;   Returns:
;
;       nothing
;

        public OpcodeINTO
OpcodeINTO proc

        xor     eax,eax
        ret

OpcodeINTO endp


        page   ,132
        subttl "In Byte Immediate Opcode Handler"
;++
;
;   Routine Description:
;
;       This routine emulates an in byte immediate opcode.
;
;   Arguments:
;       EBP -> trap frame
;       EBX -> prefix flags, BL = instruction length count
;       ECX -> byte at the faulting address
;       EDX -> pointer to vdm state in DOS arena
;       ESI -> Reginfo struct
;       EDI -> address of faulting instruction
;
;   Returns:
;
;       nothing
;

        public OpcodeINBimm
OpcodeINBimm proc

        inc     ebx                             ; length count
        inc     edi
        mov     eax,edi                         ; current linear address
        sub     eax,[esi].RiCsBase              ; make address eip
        cmp     eax,[esi].RiCsLimit             ; check eip
        ja      oibi20

        cmp     edi, [_MmHighestUserAddress]
        ja      oibi20

        movzx   ecx,byte ptr [edi]

; (eax) = inst. size
; read op
; I/O size = 1
; (ecx) = port number

        stdCall   _Ki386VdmDispatchIo, <ecx, 1, TRUE, ebx, ebp>
        ret
oibi20:
        xor     eax, eax                        ; not handled
        ret

OpcodeINBimm endp

        page   ,132
        subttl "Word In Immediate Opcode Handler"
;++
;
;   Routine Description:
;
;       This routine emulates an in word immediate opcode.
;
;   Arguments:
;       EBP -> trap frame
;       EBX -> prefix flags, BL = instruction length count
;       ECX -> byte at the faulting address
;       EDX -> pointer to vdm state in DOS arena
;       ESI -> Reginfo struct
;       EDI -> address of faulting instruction
;
;   Returns:
;
;       nothing
;

        public OpcodeINWimm
OpcodeINWimm proc

        inc     ebx                             ; length count
        inc     edi
        mov     eax,edi                         ; current linear address
        sub     eax,[esi].RiCsBase              ; make address eip
        cmp     eax,[esi].RiCsLimit             ; check eip
        ja      oiwi20

        cmp     edi, [_MmHighestUserAddress]
        ja      oiwi20

        movzx   ecx,byte ptr [edi]

; TRUE - read op
; 2 - word op
; ecx - port number
        stdCall   _Ki386VdmDispatchIo, <ecx, 2, TRUE, ebx, ebp>
        ret
oiwi20:
        xor     eax, eax                        ; not handled
        ret

OpcodeINWimm endp

        page   ,132
        subttl "Out Byte Immediate Opcode Handler"
;++
;
;   Routine Description:
;
;       This routine emulates an invalid opcode.
;
;   Arguments:
;       EBP -> trap frame
;       EBX -> prefix flags, BL = instruction length count
;       ECX -> byte at the faulting address
;       EDX -> pointer to vdm state in DOS arena
;       ESI -> Reginfo struct
;       EDI -> address of faulting instruction
;
;   Returns:
;
;       nothing
;

        public OpcodeOUTBimm
OpcodeOUTBimm proc

        inc     ebx                             ; length count
        inc     edi
        mov     eax,edi                         ; current linear address
        sub     eax,[esi].RiCsBase              ; make address eip
        cmp     eax,[esi].RiCsLimit             ; check eip
        ja      oobi20

        cmp     edi, [_MmHighestUserAddress]
        ja      oobi20

        movzx   ecx,byte ptr [edi]

; FALSE - write op
; 1 - byte op
; ecx - port #

        stdCall   _Ki386VdmDispatchIo, <ecx, 1, FALSE, ebx, ebp>
        ret
oobi20:
        xor     eax, eax                        ; not handled
        ret

OpcodeOUTBimm endp

        page   ,132
        subttl "Out Word Immediate Opcode Handler"
;++
;
;   Routine Description:
;
;       This routine emulates an out word immediate opcode.
;
;   Arguments:
;       EBP -> trap frame
;       EBX -> prefix flags, BL = instruction length count
;       ECX -> byte at the faulting address
;       EDX -> pointer to vdm state in DOS arena
;       ESI -> Reginfo struct
;       EDI -> address of faulting instruction
;
;   Returns:
;
;       nothing
;

        public OpcodeOUTWimm
OpcodeOUTWimm proc

        inc     ebx                             ; length count
        inc     edi
        mov     eax,edi                         ; current linear address
        sub     eax,[esi].RiCsBase              ; make address eip
        cmp     eax,[esi].RiCsLimit             ; check eip
        ja      oowi20

        cmp     edi, [_MmHighestUserAddress]
        ja      oowi20

        movzx   ecx,byte ptr [edi]

; FALSE - write op
; 2 - word op
; ecx - port number
        stdCall   _Ki386VdmDispatchIo, <ecx, 2, FALSE, ebx, ebp>
        ret

oowi20:
        xor     eax, eax                        ; not handled
        ret

OpcodeOUTWimm endp

        page   ,132
        subttl "INB Opcode Handler"
;++
;
;   Routine Description:
;
;       This routine emulates an INB opcode.
;
;   Arguments:
;       EBP -> trap frame
;       EBX -> prefix flags, BL = instruction length count
;       ECX -> byte at the faulting address
;       EDX -> pointer to vdm state in DOS arena
;       ESI -> Reginfo struct
;       EDI -> address of faulting instruction
;
;   Returns:
;
;       nothing
;

        public OpcodeINB
OpcodeINB proc

        movzx   eax,word ptr [ebp].TsEdx

; TRUE - read op
; 1 - byte op
; eax - port number

        cmp     eax, 3bdh
        jz      oib_prt1
        cmp     eax, 379h
        jz      oib_prt1
        cmp     eax, 279h
        jz      oib_prt1

oib_reflect:
        stdCall   _Ki386VdmDispatchIo, <eax, 1, TRUE, ebx, ebp>
        ret

oib_prt1:
        ; call printer status routine with port number, size, trap frame
        movzx   ebx, bl                     ;clear prefix flags
        push    eax
        stdCall _VdmPrinterStatus, <eax, ebx, ebp>
        or      al,al
        pop     eax
        jz      short oib_reflect
        mov     al, 1
        ret

OpcodeINB endp

        page   ,132
        subttl "INW Opcode Handler"
;++
;
;   Routine Description:
;
;       This routine emulates an INW opcode.
;
;   Arguments:
;       EBP -> trap frame
;       EBX -> prefix flags, BL = instruction length count
;       ECX -> byte at the faulting address
;       EDX -> pointer to vdm state in DOS arena
;       ESI -> Reginfo struct
;       EDI -> address of faulting instruction
;
;   Returns:
;
;       nothing
;

        public OpcodeINW
OpcodeINW proc

        movzx   eax,word ptr [ebp].TsEdx

; TRUE - read operation
; 2 - word op
; eax - port number
        stdCall   _Ki386VdmDispatchIo, <eax, 2, TRUE, ebx, ebp>
        ret

OpcodeINW endp

        page   ,132
        subttl "OUTB Opcode Handler"
;++
;
;   Routine Description:
;
;       This routine emulates an OUTB opcode.
;
;   Arguments:
;       EBP -> trap frame
;       EBX -> prefix flags, BL = instruction length count
;       ECX -> byte at the faulting address
;       EDX -> pointer to vdm state in DOS arena
;       ESI -> Reginfo struct
;       EDI -> address of faulting instruction
;
;   Returns:
;
;       nothing
;

        public OpcodeOUTB
OpcodeOUTB proc

        movzx   eax,word ptr [ebp].TsEdx

        cmp     eax, 03BCh
        je      short oob_printerVDD
        cmp     eax, 0378h
        je      short oob_printerVDD
        cmp     eax, 0278h
        jz      short oob_printerVDD

oob_reflect:
; FALSE - write op
; 1 - byte op
; eax - port number
        stdCall   _Ki386VdmDispatchIo, <eax, 1, FALSE, ebx, ebp>
        ret

oob_printerVDD:
        movzx   ebx, bl                   ; instruction size
        push    eax                       ; save port address
        stdCall _VdmPrinterWriteData, <eax, ebx, ebp>
        or      al,al                     ;
        pop     eax
        jz      short oob_reflect
        mov     al, 1
        ret

OpcodeOUTB endp

        page   ,132
        subttl "OUTW Opcode Handler"
;++
;
;   Routine Description:
;
;       This routine emulates an OUTW opcode.
;
;   Arguments:
;       EBP -> trap frame
;       EBX -> prefix flags, BL = instruction length count
;       ECX -> byte at the faulting address
;       EDX -> pointer to vdm state in DOS arena
;       ESI -> Reginfo struct
;       EDI -> address of faulting instruction
;
;   Returns:
;
;       nothing
;

        public OpcodeOUTW
OpcodeOUTW proc

        movzx   eax,word ptr [ebp].TsEdx

; FALSE - write op
; 2 - word op
; edi - port #
        stdCall   _Ki386VdmDispatchIo, <eax, 2, FALSE, ebx, ebp>
        ret

OpcodeOUTW endp

        page   ,132
        subttl "CLI Opcode Handler"
;++
;
;   Routine Description:
;
;       This routine emulates an CLI opcode. It clears the virtual
;       interrupt flag in the VdmTeb.
;
;   Arguments:
;       EBP -> trap frame
;       EBX -> prefix flags, BL = instruction length count
;       ECX -> byte at the faulting address
;       EDX -> pointer to vdm state in DOS arena
;       ESI -> Reginfo struct
;       EDI -> address of faulting instruction
;
;   Returns:
;
;       nothing
;

        public OpcodeCLI
OpcodeCLI proc

        mov     eax, ds:FIXED_NTVDMSTATE_LINEAR
        and     eax, (VDM_INTERRUPT_PENDING + VDM_VIRTUAL_INTERRUPTS)
        cmp     eax, (VDM_INTERRUPT_PENDING + VDM_VIRTUAL_INTERRUPTS)
        jnz     short oc50

        call    VdmDispatchIntAck
        jmp     short oc99

oc50:
        mov     eax,[ebp].TsEFlags
        and     eax,NOT EFLAGS_INTERRUPT_MASK
        call    SetVirtualBits
        inc     dword ptr [ebp].TsEip
        stdCall _VdmSetPMCliTimeStamp, <0>
oc99:
        mov     eax,1
        ret

OpcodeCLI endp

        page   ,132
        subttl "STI Opcode Handler"
;++
;
;   Routine Description:
;
;       This routine emulates an STI opcode.  It sets the virtual
;       interrupt flag in the VDM teb.
;
;   Arguments:
;       EBP -> trap frame
;       EBX -> prefix flags, BL = instruction length count
;       ECX -> byte at the faulting address
;       EDX -> pointer to vdm state in DOS arena
;       ESI -> Reginfo struct
;       EDI -> address of faulting instruction
;
;   Returns:
;
;       nothing
;

        public OpcodeSTI
OpcodeSTI proc

        stdCall _VdmClearPMCliTimeStamp
        mov     eax,[ebp].TsEFlags
        or      eax,EFLAGS_INTERRUPT_MASK
        call    SetVirtualBits
        inc     dword ptr [ebp].TsEip
        mov     eax, ds:FIXED_NTVDMSTATE_LINEAR
        test    eax,VDM_INTERRUPT_PENDING
        jz      os10

        call    VdmDispatchIntAck
os10:
        mov     eax,1
        ret

OpcodeSTI endp

        page   ,132
        subttl "Check Vdm Flags"
;++
;
;   Routine Description:
;
;       This routine checks the flags that are going to be used for the
;       dos or windows application.
;
;   Arguments:
;
;       ecx = EFlags to be set
;       esi = address of reg info
;
;   Returns:
;
;       ecx = fixed flags
;

CheckVdmFlags proc

        mov     eax,[esi].RiEFlags
        and     eax,EFLAGS_V86_MASK

        ;
        ; [eax] = V86 mode bit
        ; [ecx] = Flags to be fixed
        ;

        test    eax,EFLAGS_V86_MASK             ; Is V86 Mode?
        jz      short cvf10                     ; No, enable IF

        test    _KeI386VirtualIntExtensions, V86_VIRTUAL_INT_EXTENSIONS
        jz      short cvf10

        ;
        ; Convert EFLAGS_INTERRUPT_MASK to VIF flags
        ;

        mov     edx, ecx
        and     edx,EFLAGS_INTERRUPT_MASK
        shl     edx,0ah
        or      eax,edx

cvf10:  or      ecx,EFLAGS_INTERRUPT_MASK
cvf20:  and     ecx,NOT (EFLAGS_IOPL_MASK OR EFLAGS_NT_MASK OR EFLAGS_V86_MASK OR EFLAGS_VIF OR EFLAGS_VIP)
        or      ecx,eax                 ; restore original v86 bit
        ret

CheckVdmFlags endp

        page   ,132
        subttl "Get Virtual Interrupt Flag"
;++
;
;   Routine Description:
;
;       This routine correctly gets the VDMs virtual interrupt flag and
;       puts it into an EFlags image to be put on the stack.
;
;   Arguments:
;
;       eax = EFlags value
;
;   Returns:
;
;       eax = EFlags value with correct setting for IF
;
;   Uses:
;       ecx
;
        public GetVirtualBits
GetVirtualBits proc

        push    ebp
        push    edx
        push    ebx
        push    esi
        push    edi


        test    eax, EFLAGS_V86_MASK
        jz      short gvb10

        test    _KeI386VirtualIntExtensions, V86_VIRTUAL_INT_EXTENSIONS
        jz      short gvb10

        mov     ecx,eax
        and     ecx,EFLAGS_VIF
        shr     ecx,0ah                         ; mov vif to if posn
        and     eax,NOT EFLAGS_INTERRUPT_MASK
        or      eax,ecx

        call    gvbGetFixedStateLinear          ; after return [ecx] = content of 0x417
        and     ecx,VDM_VIRTUAL_AC
        and     eax,NOT EFLAGS_ALIGN_CHECK
        or      eax,ecx
        jmp     short gbvexit

gvb10:  and     eax,NOT EFLAGS_INTERRUPT_MASK
        call    gvbGetFixedStateLinear          ; after return [ecx] = content of 0x417
        and     ecx,VDM_VIRTUAL_INTERRUPTS OR VDM_VIRTUAL_AC
        or      eax,ecx                         ; put virtual int flag into flags
gbvexit:
        or      eax,EFLAGS_IOPL_MASK            ; make it look like a 386

        pop     edi
        pop     esi
        pop     ebx
        pop     edx
        pop     ebp
        ret

gvbGetFixedStateLinear:
        push    eax
        push    offset GetVirtualBits_Handler
        push    PCR[PcExceptionList]
        mov     PCR[PcExceptionList], esp
        mov     ecx, ds:FIXED_NTVDMSTATE_LINEAR

gvbexit1:
        pop     PCR[PcExceptionList]
        add     esp, 4                  ; pop out except handler
        pop     eax
        ret
GetVirtualBits endp

GetVirtualBits_Handler proc
        mov     esp, [esp+8]            ; (esp)-> ExceptionList
        xor     ecx, ecx
        jmp     gvbexit1
GetVirtualBits_Handler endp



        page   ,132
        subttl "Set Virtual Interrupt Flag"
;++
;
;   Routine Description:
;
;       This routine correctly sets the VDMs virtual interrupt flag.
;
;   Arguments:
;
;       eax = EFlags value
;
;   Returns:
;
;       Virtual interrupt flag set
;

SetVirtualBits proc
Flags   equ [ebp - 4]

        ;
        ; IMPORTANT: save ALL the non-volatile registers in case of exception
        ;

        push    ebp
        push    edx
        push    ebx
        push    esi
        push    edi

        push    offset SetVirtualBits_Handler
        push    PCR[PcExceptionList]
        mov     PCR[PcExceptionList], esp
        mov     ebp,esp
        sub     esp,4

        mov     Flags,eax
        lea     edx,ds:FIXED_NTVDMSTATE_LINEAR
        and     eax,EFLAGS_INTERRUPT_MASK ; isolate int flag
        MPLOCK and [edx],NOT VDM_VIRTUAL_INTERRUPTS
        MPLOCK or [edx],eax             ; place virtual int flag value

svb20:
        ; WARNING 32 bit support!
        test    ebx,PREFIX_OPER32
        jz      short svb30             ; 16 bit instr

        mov     eax,Flags
        and     eax,EFLAGS_ALIGN_CHECK
        MPLOCK  and     dword ptr [edx],NOT EFLAGS_ALIGN_CHECK
        MPLOCK  or      [edx],eax
svb30:
        mov     esp,ebp
svbexit:
        pop     PCR[PcExceptionList]    ; Remove handler
        lea     esp, [esp+4]
        pop     edi
        pop     esi
        pop     ebx
        pop     edx
        pop     ebp
        ret
SetVirtualBits endp

SetVirtualBits_Handler proc
        mov     esp, [esp+8]            ; (esp)-> ExceptionList
        jmp     svbexit
SetVirtualBits_Handler endp


        page   ,132
        subttl "Reflect Exception to a Vdm"
;++
;
;   Routine Description:
;
;       This routine reflects an exception to a VDM.  It uses the information
;       in the trap frame to determine what exception to reflect, and updates
;       the trap frame with the new CS, EIP, SS, and SP values
;
;   Arguments:
;
;       ebp -> Trap frame
;       ss:esp + 4 = trap number
;
;   Returns
;
;       Nothing
;
;   Notes:
;       Interrupts are enabled upon entry, Irql is at APC level
;       This routine may not preserve all of the non-volatile registers if
;       a fault occurs.
;
cPublicProc _Ki386VdmReflectException,1

RI      equ     [ebp - REGINFOSIZE]

        ;
        ; First make sure this is for us to handle
        ;

        mov     eax,PCR[PcPrcbData+PbCurrentThread]
        mov     eax,[eax]+ThApcState+AsProcess
        cmp     dword ptr [eax]+PrVdmObjects,0 ; is this a vdm process?
        jne     short @f

        xor     eax, eax                    ; not handled

        stdRET  _Ki386VdmReflectException

@@:
        push    ebp
        mov     ebp,esp
        sub     esp,REGINFOSIZE

        pushad

        lea     esi,ds:FIXED_NTVDMSTATE_LINEAR

        ;
        ; Look to see if the debugger wants exceptions
        ;
        stdCall _VdmFetchULONG, <esi>
        test    eax,VDM_BREAK_EXCEPTIONS
        jz      vredbg                          ; no, check for debug events

        mov     ebx,DBG_STACKFAULT
        cmp     word ptr [ebp + 8],0ch          ; stack fault?
        jz      @f                              ; yes, check dbg flag
        mov     ebx,DBG_GPFAULT
        cmp     word ptr [ebp + 8],0dh          ; gp fault?
        jne     vredbg                          ; no, continue

@@:
        test    eax,VDM_USE_DBG_VDMEVENT
        jnz     vrexc_event
        jmp     vrexcd                          ; reflect the exception to 32

        ;
        ; Look to see if the debugger wants debug events
        ;
vredbg:
        test    eax,VDM_BREAK_DEBUGGER
        jz      vrevdm                          ; no debug events, reflect to vdm

        mov     ebx,DBG_SINGLESTEP
        cmp     word ptr [ebp + 8],1
        jnz     @f
        test    eax,VDM_USE_DBG_VDMEVENT
        jnz     vrexc_event
        jmp     vrexc1

@@:
        mov     ebx,DBG_BREAK
        cmp     word ptr [ebp + 8],3
        jnz     vrevdm
        test    eax,VDM_USE_DBG_VDMEVENT
        jnz     vrexc_event
        jmp     vrexc3

        ;
        ; Reflect the exception to the VDM
        ;
vrevdm:
        mov     esi,[ebp]
        cmp     word ptr [esi].TsSegCs, KGDT_R3_CODE OR RPL_MASK  ; int sim after fault?
        je      vre28
if DEVL
        cmp     word ptr [ebp + 8],11
        jne     @f
        inc     _ExVdmSegmentNotPresent
@@:
endif

if DBG
        CurrentIrql
        cmp      al, APC_LEVEL
        jge      @f
        int      3
@@:
endif

        mov     RI.RiTrapFrame,esi
        mov     eax,[esi].TsHardwareSegSs
        mov     RI.RiSegSs,eax
        mov     eax,[esi].TsHardwareEsp
        mov     RI.RiEsp,eax
        mov     eax,[esi].TsEFlags
        mov     RI.RiEFlags,eax
        mov     eax,[esi].TsEip
        mov     RI.RiEip,eax
        mov     eax,[esi].TsSegCs
        mov     RI.RiSegCs,eax
        lea     esi,RI
        call    CsToLinear                      ; uses eax as selector
        test    al,0FFh
        jz      vrerr

        mov     eax,[esi].RiSegSs
        call    SsToLinear
        test    al,0FFh
        jz      vrerr

        mov     ecx,[ebp + 8]
        call    PushException
        test    al,0FFh
        jz      vrerr

        mov     esi,RI.RiTrapFrame
        mov     eax,RI.RiEsp
        mov     [esi].TsHardwareEsp,eax
        xor     bl, bl                           ; R3 mask. 0 on V86 mode
        test    dword ptr [esi].TsEFlags, EFLAGS_V86_MASK ;
        jnz     @F                               ;
        mov     bl, 7                            ; protected mode, R3 LDT selectors only
@@:
        mov     eax,RI.RiSegSs
        or      al, bl
        mov     [esi].TsHardwareSegSs,eax
        mov     eax,RI.RiEFlags
        push    [esi].TsEFlags
        mov     [esi].TsEFlags,eax
        xor     eax, [esp]
        test    eax, EFLAGS_V86_MASK
        pop     eax
        je      @f
        stdCall _Ki386AdjustEsp0, <esi>
@@:

        mov     eax,RI.RiSegCs
        or      al, bl
        cmp     eax, 8
        jae     short @f
        test    dword ptr [esi].TsEFlags, EFLAGS_V86_MASK ;
        jnz     short @f                               ;
        mov     eax, KGDT_R3_CODE OR RPL_MASK
@@:     mov     [esi].TsSegCs,eax
        mov     eax,RI.RiEip
        mov     [esi].TsEip,eax
        cmp     word ptr [ebp + 8],1
        jne     vre28
        and     dword ptr [esi].TsEFlags, NOT EFLAGS_TF_MASK

vre28:
        popad
        mov     eax,1                           ; handled

vre30:
        mov     esp,ebp
        pop     ebp
        stdRET  _Ki386VdmReflectException

vrerr:
        popad
        xor     eax,eax
        jmp     vre30

vrexc1:
        mov     eax, [ebp]
        and     dword ptr [eax]+TsEflags, not EFLAGS_TF_MASK
        mov     eax, [ebp]+TsEip        ; (eax)-> faulting instruction
        stdCall _VdmDispatchException <[ebp],STATUS_SINGLE_STEP,eax,0,0,0,0>
        jmp     vre28

vrexc3:
        mov     eax,BREAKPOINT_BREAK
        mov     ebx, [ebp]
        mov     ebx, [ebx]+TsEip
        dec     ebx                     ; (eax)-> int3 instruction
        stdCall _VdmDispatchException <[ebp],STATUS_BREAKPOINT,ebx,3,eax,ecx,edx>
        jmp     vre28

vrexcd:
        mov     eax, [ebp]
        mov     eax, [eax]+TsEip
        stdCall _VdmDispatchException <[ebp],STATUS_ACCESS_VIOLATION,eax,2,0,-1,0>
        jmp     vre28

vrexc_event:
        mov     eax, [ebp]
        cmp     ebx, DBG_SINGLESTEP
        jnz     vrexc_event2
        and     dword ptr [eax]+TsEflags, not EFLAGS_TF_MASK
vrexc_event2:
        mov     eax, [eax]+TsEip
        stdCall _VdmDispatchException <[ebp],STATUS_VDM_EVENT,eax,1,ebx,0,0>
        jmp     vre28


stdENDP _Ki386VdmReflectException


        page   ,132
        subttl "Reflect Segment Not Present Exception to a Vdm"
;++
;
;   Routine Description:
;
;       This routine reflects an TRAP B to a VDM.  It uses the information
;       in the trap frame to determine what exception to reflect, and updates
;       the trap frame with the new CS, EIP, SS, and SP values
;
;   Arguments:
;
;       ebp -> Trap frame
;
;   Returns
;
;       0 is returned if the reflection fails.
;

cPublicProc _Ki386VdmSegmentNotPresent,0

        mov     edi,PCR[PcTeb]
        mov     ecx,VDM_FAULT_HANDLER_SIZE * 0Bh

        ;
        ; Set up an exception handler in case we fault
        ; during the user-space accesses below.
        ;

        push    ebp
        push    offset FLAT:VdmSegNotPres_ExceptionHandler
                                        ; set up exception registration record
        push    PCR[PcExceptionList]
        mov     PCR[PcExceptionList], esp

        mov     edi,[edi].TeVdm
        xor     ebx, ebx
        cmp     edi, _MmUserProbeAddress     ; probe the TeVdm
        jae     short reflect

        lea     esi,[edi].VtDpmiInfo         ; (esi)->dpmi info struct
        mov     edi, [edi].VtFaultTable      ;
        lea     edi,[edi+ecx]                ; (edi)->FaultHandler
        cmp     edi, _MmUserProbeAddress     ; probe the table address
        jae     short reflect

        cmp     word ptr [esi].VpLockCount, 0 ; switching stacks?
        jz      short seg_not_pres           ; yes, we can handle it
                                             ; no, let normal code check
                                             ; for stack faults

reflect:

        ;
        ; WARNING: Here we directly unlink the exception handler from the
        ; exception registration chain.  NO unwind is performed.
        ;

        pop     PCR[PcExceptionList]

        add     esp, 4                  ; pop out except handler
        pop     ebp

        ;
        ; Reflect the failure (or exception) back to the usermode ntvdm
        ; to handle.
        ;

        pop     eax                          ; (eax) = return addr
        push    0bh
        push    eax
        jmp     _Ki386VdmReflectException

reflect_1:

        add     esp, REGINFOSIZE + 4            ; plus the "push esi" 4 bytes
        jmp     short reflect

seg_not_pres:
if DEVL
        inc     _ExVdmSegmentNotPresent
endif
        inc     word ptr [esi].VpLockCount

        ;
        ; (esi)->dpmi info struct
        ; (edi)->FaultHandler
        ; (ebp)->TrapFrame
        ;
        ; save stuff just like SwitchToHandlerStack does
        ;

        mov     eax, [ebp].TsEip
        mov     [esi].VpSaveEip, eax
        mov     eax, [ebp].TsHardwareEsp
        mov     [esi].VpSaveEsp, eax
        mov     ax, [ebp].TsHardwareSegSs
        mov     [esi].VpSaveSsSelector, ax

        movzx   eax,word ptr [esi].VpSsSelector ; (eax) = PM stack selector
        sub     esp, REGINFOSIZE             ; allocate reginfo table on stack
        push    esi                          ; save dpmi info
        mov     esi, esp
        add     esi, 4                       ; (esi)->RegInfo
        mov     ecx, dword ptr [ebp].TsEFlags
        mov     [esi].RiEFlags,ecx           ; initialize the  reginfo table
        call    SsToLinear                   ; with eax and esi
        test    al,0FFh                      ; is al == 0?
        jz      short reflect_1              ; yes, failed

        mov     ebx, [esi].RiSsBase          ; (ebx) = Base of PM Stack
        pop     esi                          ; (esi)->dpmi info
        add     esp, REGINFOSIZE             ; remove RegInfo from stack
        cmp     ebx, _MmUserProbeAddress     ; probe the PM stack base addr
        jae     short reflect                ;   make sure it is not Kmode addr

        mov     eax, [ebp].TsEFlags
        call    GetVirtualBits               ; (eax) = app's eflags
        push    esi
        mov     edx, 0fe0h                   ; dpmistack offset (per win31)
        test    word ptr [esi].VpFlags, 1    ; 32-bit frame?
        jz      short @f

        sub     edx, 8 * 4
        add     edx, ebx
        mov     esi, [ebp].TsHardwareEsp
        mov     ecx, [ebp].TsHardwareSegSs
        mov     [edx + 20], eax              ; push flags
        mov     [edx + 24], esi              ; put esp on new stack
        mov     [edx + 28], ecx              ; put ss on new stack
        mov     ecx, [ebp].TsSegCs
        mov     eax, [ebp].TsEip
        mov     esi, [ebp].TsErrCode
        mov     [edx + 16], ecx              ; push cs
        mov     [edx + 12], eax              ; push ip
        mov     [edx + 8], esi               ; push error code
        pop     esi
        mov     ecx, [esi].VpDosxFaultIretD
        mov     eax, ecx
        shr     eax, 16
        and     ecx, 0ffffh
        mov     [edx + 4], eax               ; push fault iret seg
        mov     [edx], ecx                   ; push fault iret offset
        jmp     short vsnp_update
@@:
        sub     edx, 8 * 2
        add     edx, ebx
        mov     esi, [ebp].TsHardwareEsp
        mov     ecx, [ebp].TsHardwareSegSs
        mov     [edx + 10], ax               ; push flags
        mov     [edx + 12], si               ; put esp on new stack
        mov     [edx + 14], cx               ; put ss on new stack
        mov     ecx, [ebp].TsSegCs
        mov     eax, [ebp].TsEip
        mov     esi, [ebp].TsErrCode
        mov     [edx + 8], cx                ; push cs
        mov     [edx + 6], ax                ; push ip
        mov     [edx + 4], si                ; push error code
        pop     esi
        mov     ecx, [esi].VpDosxFaultIret
        mov     eax, ecx
        shr     eax, 16
        mov     [edx + 2], ax                ; push fault iret seg
        mov     [edx], cx                    ; push fault iret offset

vsnp_update:
        mov     eax,[edi].VfEip
        sub     edx, ebx
        mov     cx, word ptr [edi].VfCsSelector
        mov     bx, word ptr [esi].VpSsSelector
        test    dword ptr [edi].VfFlags, VDM_INT_INT_GATE
        jz      short @f

        lea     esi,ds:FIXED_NTVDMSTATE_LINEAR
        MPLOCK and      [esi],NOT VDM_VIRTUAL_INTERRUPTS
        and     dword ptr [ebp].TsEflags, 0FFF7FFFFH ; clear VIF
@@:
        or      cx, 7                       ; R3 LDT selectors only
        or      bx, 7                       ; R3 LDT selectors only
        test    dword ptr [ebp]+TsEFlags,EFLAGS_V86_MASK
        jnz     short @f

        cmp     cx, 8
        jge     short @f

        mov     cx, KGDT_R3_CODE OR RPL_MASK
@@:     mov     [ebp].TsSegCs, cx
        mov     [ebp].TsEip, eax
        mov     [ebp].TsHardwareEsp,edx
        mov     [ebp].TsHardwareSegSs,bx

        ;
        ; WARNING: Here we directly unlink the exception handler from the
        ; exception registration chain.  NO unwind is performed.
        ;

        pop     PCR[PcExceptionList]

        add     esp, 4                  ; pop out except handler
        pop     ebp

        mov     eax, 1
        stdRET    _Ki386VdmSegmentNotPresent


stdENDP _Ki386VdmSegmentNotPresent

        ;
        ;   Error and exception blocks for Ki386VdmSegmentNoPresent
        ;

VdmSegNotPres_ExceptionHandler proc
        ;
        ; WARNING: Here we directly unlink the exception handler from the
        ; exception registration chain.  NO unwind is performed.
        ;

        mov     esp, [esp+8]            ; (esp)-> ExceptionList
        jmp     reflect
VdmSegNotPres_ExceptionHandler endp
	

        page   ,132
        subttl "Dispatch UserMode Exception to a Vdm"
;++
;
;   Routine Description:
;
;   Dispatches exception for vdm from in the kernel, by invoking
;   CommonDispatchException.
;
;   Arguments: See CommonDispatchException for parameter description
;
;   VOID
;   VdmDispatchException(
;        PKTRAP_FRAME TrapFrame,
;        NTSTATUS     ExcepCode,
;        PVOID        ExcepAddr,
;        ULONG        NumParms,
;        ULONG        Parm1,
;        ULONG        Parm2,
;        ULONG        Parm3
;        )
;
;   Returns
;
;       Nothing
;
;   Notes:
;
;       This routine may not preserve all of the non-volatile registers if
;       a fault occurs.
;
cPublicProc _VdmDispatchException,7

TrapFrame equ [ebp+8]
ExcepCode equ [ebp+12]
ExcepAddr equ [ebp+16]
NumParms  equ [ebp+20]
Parm1     equ [ebp+24]
Parm2     equ [ebp+28]
Parm3     equ [ebp+32]

        push    ebp
        mov     ebp,esp
        pushad

        LowerIrql 0                 ; lower irql to 0
                                    ; allow APCs and debuggers in!

        mov    eax, ExcepCode
        mov    ebx, ExcepAddr
        mov    ecx, NumParms
        mov    edx, Parm1
        mov    esi, Parm2
        mov    edi, Parm3
        mov    ebp, TrapFrame
        call   CommonDispatchException

        popad
        pop    ebp

        stdRET  _VdmDispatchException

stdENDP _VdmDispatchException




        page   ,132
        subttl "Push Interrupt frame on user stack"
;++
;
;   Routine Description:
;
;       This routine pushes an interrupt frame on the user stack
;
;   Arguments:
;
;       ecx = interrupt #
;       esi = address of reg info
;   Returns:
;
;       interrupt frame pushed on stack
;       reg info updated
;
        public PushInt
PushInt proc

        push    ebx
        push    edi

;
; Handle dispatching interrupts directly to the handler, rather than
; to the dos extender
;
        ;
        ; Get the information on the interrupt handler
        ;
        .errnz (VDM_INTERRUPT_HANDLER_SIZE - 8)
        mov     eax,PCR[PcTeb]

        ;
        ; Set up an exception handler in case we fault
        ; during the user-space accesses below.
        ; Note, we must preserve esi if exception does occur, all non-volatile registers are destroyed
        ;

        push    esi
        push    ebp
        push    offset FLAT:PushIntExceptionHandler     ; set up exception registration record
        push    PCR[PcExceptionList]
        mov     PCR[PcExceptionList], esp


        mov     eax,[eax].TbVdm
        cmp     eax, _MmUserProbeAddress
        jae     pierr

        mov     eax, [eax].VtInterruptTable
        lea     eax,[eax + ecx*8]
        cmp     eax, _MmUserProbeAddress
        jae     pierr

        ;
        ; Get SP
        ;
        mov     edi,[ebp].TsHardwareEsp
        test    [esi].RiSsFlags,SEL_TYPE_BIG
        jnz     short @f

        movzx   edi,di                          ; zero high bits for 64k stack

        ;
        ; Update SP
        ;
@@:     test    [eax].ViFlags,dword ptr VDM_INT_32
        jz      short @f

        ;
        ; 32 bit iret frame
        ;
        cmp     edi,12                          ; enough space on stack?
        jb      pierr                           ; no, go fault

        sub     edi,12
        mov     [esi].RiEsp,edi
        jmp     short pi130

        ;
        ; 16 bit iret frame
        ;
@@:     cmp     edi,6                           ; enough space on stack?
        jb      pierr                           ; no, go fault

        sub     edi,6
        mov     [esi].RiEsp,edi

        ;
        ; Check limit
        ;
pi130:  test    [esi].RiSsFlags,SEL_TYPE_ED
        jz      short pi140

        ;
        ; Expand down, Sp must be above limit
        ;
        cmp     edi,[esi].RiSsLimit
        jna     pierr

        jmp     short pi150

        ;
        ; Normal, Sp must be below limit
        ;
pi140:  cmp     edi,[esi].RiSsLimit
        jnb     pierr

        ;
        ; Get base of ss
        ;
pi150:  mov     ebx,[esi].RiSsBase
        test    [eax].ViFlags,dword ptr VDM_INT_32
        jz      short pi160

        ;
        ; "push" 32 bit iret frame
        ;
        mov     edx,[esi].RiEip
        mov     [edi + ebx],edx
        mov     dx,word ptr [ebp].TsSegCs
        mov     [edi + ebx] + 4,edx
        push    eax
        mov     eax,[esi].RiEFlags
        call    GetVirtualBits

        mov     [edi + ebx] + 8,eax
        pop     eax
        jmp     short pi170

        ;
        ; push 16 bit iret frame
        ;
pi160:  mov     dx,word ptr [esi].RiEip
        mov     [edi + ebx],dx
        mov     dx,word ptr [ebp].TsSegCs
        mov     [edi + ebx] + 2,dx
        push    eax
        mov     eax,[esi].RiEFlags
        call    GetVirtualBits

        mov     [edi + ebx] + 4,ax
        pop     eax

        ;
        ; Update CS and IP
        ;
pi170:  mov     ebx,eax                                 ; save int info
        mov     dx,[eax].ViCsSelector
        mov     word ptr [esi].RiSegCs,dx
        mov     edx,[eax].ViEip
        mov     [esi].RiEip,edx

        movzx   eax, word ptr [esi].RiSegCs
        call    CsToLinear                      ; uses eax as selector

        test    al,0ffh
        jnz     short pi175

        ;
        ; Check for destination not present
        ;
        test    [esi].RiCsFlags,SEL_TYPE_NP
        jz      pierr

        mov     al,0ffh                         ; succeeded
        jmp     short pi180

        ;
        ; Check handler address
        ;
pi175:  mov     edx,[esi].RiEip
        cmp     edx,[esi].RiCsLimit
        jnb     short pierr

        ;
        ; Turn off the trap flag
        ;
pi180:  and     [esi].RiEFlags,NOT EFLAGS_TF_MASK

        ;
        ; Turn off virtual interrupts if necessary
        ;
        test    [ebx].ViFlags,dword ptr VDM_INT_INT_GATE
        ; n.b. We know al is non-zero, because we succeeded in cstolinear
        jz      short pi80

pi75:   lea     ebx,ds:FIXED_NTVDMSTATE_LINEAR
        MPLOCK and [ebx], NOT EFLAGS_INTERRUPT_MASK

pi80:   and     [esi].RiEFlags,NOT (EFLAGS_IOPL_MASK OR EFLAGS_NT_MASK OR EFLAGS_V86_MASK)
        or      [esi].RiEFlags,EFLAGS_INTERRUPT_MASK

pi90:

        ;
        ; WARNING: Here we directly unlink the exception handler from the
        ; exception registration chain.  NO unwind is performed.
        ;

        pop     PCR[PcExceptionList]
        add     esp, 4                  ; pop out except handler
        pop     ebp
        pop     esi

        pop     edi
        pop     ebx
        ret

pierr:  xor     eax,eax
        jmp     short pi90

PushInt endp

PushIntExceptionHandler proc
        mov     esp, [esp+8]            ; (esp)-> ExceptionList
        xor     eax,eax
        jmp     pi90
PushIntExceptionHandler endp	

        page   ,132
        subttl "Convert CS Segment or selector to linear address"
;++
;
;   Routine Description:
;
;       Convert CS segment or selector to linear address as appropriate
;       for the current user mode processor mode.
;
;   Arguments:
;
;       esi = reg info
;
;   Returns:
;
;       reg info updated
;
        public CsToLinear
CsToLinear proc

        test    [esi].RiEFlags,EFLAGS_V86_MASK
        jz      ctl10

        shl     eax,4
        mov     [esi].RiCsBase,eax
        mov     [esi].RiCsLimit,0FFFFh
        mov     [esi].RiCsFlags,0
        mov     eax,1
        ret


ctl10:
        push    edx                             ; WARNING volatile regs!!!
        lea     edx,[esi].RiCsLimit
        push    edx
        lea     edx,[esi].RiCsBase
        push    edx
        lea     edx,[esi].RiCsFlags
        push    edx
        push    eax                             ; push selector

        call    _Ki386GetSelectorParameters@16
        pop     edx

        or      al,al
        jz      ctlerr

        test    [esi].RiCsFlags,SEL_TYPE_EXECUTE
        jz      ctlerr

        test    [esi].RiCsFlags,SEL_TYPE_2GIG
        jz      ctl30

        ; Correct limit value for granularity
        shl     [esi].RiCsLimit,12
        or      [esi].RiCsLimit,0FFFh
ctl30:
        mov     eax,1
        ret

ctlerr: xor     eax,eax
        ret

CsToLinear endp


        page   ,132
        subttl "Verify that EIP is still valid"
;++
;
;   Routine Description:
;
;       Verify that Eip is still valid and put it into the trap frame
;
;   Arguments:
;
;       esi = address of reg info
;
;   Returns:
;
;
        public CheckEip
CheckEip proc
        mov     eax,[esi].RiEip
        test    [esi].RiEFlags,EFLAGS_V86_MASK
        jz      ce20

        and     eax,[esi].RiCsLimit
        mov     [esi].RiEip,eax
        jmp     ce40

ce20:   cmp     eax,[esi].RiCsLimit
        ja      ceerr
ce40:   mov     eax,1
ce50:   ret

ceerr:  xor     eax,eax
        jmp     ce50

CheckEip endp

        page   ,132
        subttl "Convert Ss Segment or selector to linear address"
;++
;
;   Routine Description:
;
;       Convert Ss segment or selector to linear address as appropriate
;       for the current user mode processor mode.
;
;   Arguments:
;
;       eax = selector to convert
;       esi = address of reg info
;
;   Returns:
;
;       reg info updated
;
        public SsToLinear
SsToLinear proc

        test    [esi].RiEFlags,EFLAGS_V86_MASK
        jz      stl10

        shl     eax,4
        mov     [esi].RiSsBase,eax
        mov     [esi].RiSsLimit,0FFFFh
        mov     [esi].RiSsFlags,0
        mov     eax,1
        ret

stl10:  push    ecx
        lea     ecx,[esi].RiSsLimit
        push    ecx
        lea     ecx,[esi].RiSsBase
        push    ecx
        lea     ecx,[esi].RiSsFlags
        push    ecx
        push    eax                             ;selector

        call    _Ki386GetSelectorParameters@16
        pop     ecx

        or      al,al
        jz      stlerr

        test    [esi].RiSsFlags,SEL_TYPE_WRITE
        jz      stlerr

        test    [esi].RiSsFlags,SEL_TYPE_2GIG
        jz      stl30

        ; Correct limit value for granularity

        mov     eax,[esi].RiSsLimit
        shl     eax,12
        or      eax,0FFFh
        mov     [esi].RiSsLimit,eax
stl30:
        mov     eax,1
stl40:  ret

stlerr: xor     eax,eax
        jmp     stl40

SsToLinear endp

        page   ,132
        subttl "Verify that Esp is still valid"
;++
;
;   Routine Description:
;
;       Verify that Esp is still valid
;
;   Arguments:
;
;       ecx = # of bytes needed for stack frame
;       esi = address of reg info
;
;   Returns:
;
;
;
        public CheckEsp
CheckEsp proc
        mov     eax,[esi].RiEsp
        test    [esi].RiEFlags,EFLAGS_V86_MASK
        jz      cs20

        and     eax,[esi].RiSsLimit
        mov     [esi].RiEsp,eax
        jmp     cs40

cs20:   test    [esi].RiSsFlags,SEL_TYPE_BIG
        jnz     cs25

        and     eax,0FFFFh                      ; only use 16 bit for 16 bit
cs25:
        cmp     ecx, eax                        ; StackOffset > SP?
        ja      cserr                           ; yes error
        dec     eax                             ; make limit checks work
        test    [esi].RiSsFlags,SEL_TYPE_ED     ; Expand down?
        jz      cs30                            ; jif no

;
;       Expand Down
;
        sub     eax, ecx                        ; New SP
        cmp     eax,[esi].RiSsLimit             ; NewSp < Limit?
        jb      cserr
        jmp     cs40

;
;       Not Expand Down
;
cs30:   cmp     eax,[esi].RiSsLimit
        ja      cserr

cs40:   mov     eax,1
cs50:   ret


cserr:  xor     eax,eax
        jmp     cs50

CheckEsp endp

        page   ,132
        subttl "Switch to protected mode interrupt stack"
;++
;
;   Routine Description:
;
;       Switch to protected mode interrupt handler stack
;
;   Arguments:
;
;       ecx = interrupt number
;       esi = address of reg info
;       edi = address of PM Stack info
;
;   Returns:
;
;       reg info updated
;
        public SwitchToHandlerStack
SwitchToHandlerStack proc

;
; We must preserve non-volatile registers across exception
;

        push    ebx
        push    esi
        push    edi

;
; Install exception handler
;

        push    ebp
        push    offset SwitchToHandlerStack_fault ; Set Handler address
        push    PCR[PcExceptionList]        ; Set next pointer
        mov     PCR[PcExceptionList],esp    ; Link us on

        cmp     word ptr [edi].VpLockCount, 0   ; already switched?
        jnz     short @f                        ; yes

        mov     eax, [esi].RiEip
        mov     [edi].VpSaveEip, eax
        mov     eax, [esi].RiEsp
        mov     [edi].VpSaveEsp, eax
        mov     eax, [esi].RiSegSs
        mov     [edi].VpSaveSsSelector, ax

        movzx   eax,word ptr [edi].VpSsSelector

        pop     PCR[PcExceptionList]        ; Remove our exception handle
        add     esp, 4                      ; clear stack
        pop     ebp

        mov     [esi].RiSegSs,eax
        mov     dword ptr [esi].RiEsp,1000h     ; dpmi stack offset

        movzx   eax, word ptr [esi].RiSegSs
        push    ecx
        call    SsToLinear                      ; compute new base
        pop     ecx
        test    al,0FFh
        jz      short shserr

        push    ebp
        push    offset SwitchToHandlerStack_fault ; Set Handler address
        push    PCR[PcExceptionList]        ; Set next pointer
        mov     PCR[PcExceptionList],esp    ; Link us on

@@:
        inc     word ptr [edi].VpLockCount      ; maintain lock count

        pop     PCR[PcExceptionList]        ; Remove our exception handle
        add     esp, 4                      ; clear stack
        pop     ebp

        mov     eax,1
        jmp     short shsexit

shserr:
        xor     eax,eax
shsexit:
        pop     edi
        pop     esi
        pop     ebx
        ret
SwitchToHandlerStack endp

SwitchToHandlerStack_fault proc
        mov     esp, [esp+8]
        pop     PCR[PcExceptionList]        ; Remove our exception handle
        add     esp, 4                      ; clear stack
        pop     ebp
        jmp     short shserr
SwitchToHandlerStack_fault endp


        page   ,132
        subttl "Get protected mode interrupt handler address"
;++
;
;   Routine Description:
;
;       Get the address of the interrupt handler for the specified interrupt
;
;   Arguments:
;
;       ecx = interrupt number
;       esi = address of reg info
;
;   Returns:
;
;       reg info updated
;
        public GetHandlerAddress
GetHandlerAddress proc

        push    ebp
        push    ebx
        push    esi
        push    edi
        push    ecx
        push    edx

        push    offset GetHandlerAddress_fault  ; Set Handler address
        push    PCR[PcExceptionList]            ; Set next pointer
        mov     PCR[PcExceptionList],esp        ; Link us on

        mov     eax,VDM_FAULT_HANDLER_SIZE
        mul     ecx
        mov     edi,PCR[PcTeb]
        mov     edi,[edi].TeVdm
        cmp     edi, _MmUserProbeAddress        ; Probe the VMD structure
        jae     short GetHandlerAddress_fault_resume

        mov     edi,[edi].VtFaultTable
        cmp     edi, _MmUserProbeAddress
        jae     short GetHandlerAddress_fault_resume

        movzx   ecx,word ptr [edi + eax].VfCsSelector
        mov     [esi].RiSegCs,ecx
        mov     ecx,[edi + eax].VfEip
        mov     [esi].RiEip,ecx
        mov     eax,1

        jmp     short GetHandlerAddress_Exit

GetHandlerAddress_fault_resume:
        xor     eax, eax
GethandlerAddress_Exit:
        pop     PCR[PcExceptionList]        ; Remove our exception handle

        add     esp, 4                      ; clear stack

        pop     edx
        pop     ecx
        pop     edi
        pop     esi
        pop     ebx
        pop     ebp
        ret
	
GetHandlerAddress endp

GetHandlerAddress_fault proc
        mov     esp, [esp+8]
        jmp     short GetHandlerAddress_fault_resume
GetHandlerAddress_fault endp

        page   ,132
        subttl "Push processor exception"
;++
;
;   Routine Description:
;
;       Update the stack and registers to emulate the specified exception
;
;   Arguments:
;
;       ecx = interrupt number
;       esi = address of reg info
;
;   Returns:
;
;       reg info updated
;
        public PushException
PushException Proc

        push    ebx
        push    edi
        push    esi

        test    [esi].RiEflags,EFLAGS_V86_MASK
        jz      pe40

;
; Push V86 mode exception
;
        cmp     ecx, 7                  ; device not available fault
        ja      peerr                   ; per win3.1, no exceptions
                                        ; above 7 for v86 mode
        mov     edx,[esi].RiEsp
        mov     ebx,[esi].RiSsBase
        and     edx,0FFFFh              ; only use a 16 bit sp
        sub     dx,2
        mov     eax,[esi].RiEFlags
        push    ecx
        call    GetVirtualBits
        pop     ecx
;
; Install exception handler
;
        push    ebp
        push    esp                         ; Pass current Esp to handler
        push    offset perr_fault           ; Set Handler address
        push    PCR[PcExceptionList]        ; Set next pointer
        mov     PCR[PcExceptionList],esp    ; Link us on

        mov     [ebx+edx],ax            ; push flags
        sub     dx,2
        mov     ax,word ptr [esi].RiSegCs
        mov     [ebx+edx],ax            ; push cs
        sub     dx,2
        mov     ax,word ptr [esi].RiEip
        mov     [ebx+edx],ax            ; push ip

        mov     eax,[ecx*4]             ; get new cs:ip value
        pop     PCR[PcExceptionList]        ; Remove our exception handle
        add     esp, 8                      ; clear stack
        pop     ebp

        push    eax
        movzx   eax,ax
        mov     [esi].RiEip,eax
        pop     eax
        shr     eax,16
        mov     [esi].RiSegCs,eax
        mov     word ptr [esi].RiEsp,dx
        jmp     pe60

;
; Push PM exception
;
pe40:
        push    [esi].RiEsp                     ; save for stack frame
        push    [esi].RiSegSs

;
; Install exception handler
;
        push    ebp
        push    esp                         ; Pass current Esp to handler
        push    offset perr1_fault          ; Set Handler address
        push    PCR[PcExceptionList]        ; Set next pointer
        mov     PCR[PcExceptionList],esp    ; Link us on

        mov     edi,PCR[PcTeb]
        mov     edi, [edi].TeVdm


        pop     PCR[PcExceptionList]        ; Remove our exception handle
        add     esp, 8                      ; clear stack
        pop     ebp

        cmp     edi, _MmUserProbeAddress
        jae     peerr1
        lea     edi,[edi].VtDpmiInfo
        call    SwitchToHandlerStack
        test    al,0FFh
        jz      peerr1                          ; pop off stack and exit

        sub     [esi].RiEsp, 20h                ; win31 undocumented feature

        mov     ebx,[esi].RiSsBase
        mov     edx,[esi].RiEsp
        test    [esi].RiSsFlags,SEL_TYPE_BIG
        jnz     short @f
        movzx   edx,dx                          ; zero high bits for 64k stack
@@:

;
; Install exception handler
;
        push    ebp
        push    esp                         ; Pass current Esp to handler
        push    offset perr1_fault           ; Set Handler address
        push    PCR[PcExceptionList]        ; Set next pointer
        mov     PCR[PcExceptionList],esp    ; Link us on

        test    word ptr [edi].VpFlags, 1   ; 32 bit app?

        pop     PCR[PcExceptionList]        ; Remove our exception handle

        lea     esp, [esp+8]                ; clear stack
        pop     ebp

        jnz     pe45                        ; yes

;
;       push 16-bit frame
;
        push    ecx
        mov     ecx, 8*2                        ; room for 8 words?
        call    CheckEsp
        pop     ecx
        test    al,0FFh
        jz      peerr1                          ; pop off stack and exit

        sub     edx,8*2
        mov     [esi].RiEsp,edx

;
; Install exception handler
;
        push    ebp
        push    esp                         ; Pass current Esp to handler
        push    offset perr1_fault           ; Set Handler address
        push    PCR[PcExceptionList]        ; Set next pointer
        mov     PCR[PcExceptionList],esp    ; Link us on

        mov     eax, [esp+4*4]
        mov     [ebx+edx+14], ax
        mov     eax, [esp+4*5]
        mov     [ebx+edx+12], ax

        pop     PCR[PcExceptionList]        ; Remove our exception handle
        lea     esp, [esp+8]                ; clear stack
        pop     ebp
        lea     esp, [esp+8]                ; clear stack

        mov     eax,[esi].RiEFlags
        push    ecx
        call    GetVirtualBits
        pop     ecx

;
; Install exception handler
;
        push    ebp
        push    esp                         ; Pass current Esp to handler
        push    offset perr_fault           ; Set Handler address
        push    PCR[PcExceptionList]        ; Set next pointer
        mov     PCR[PcExceptionList],esp    ; Link us on

        mov     [ebx+edx+10],ax                 ; push flags
        movzx   eax,word ptr [esi].RiSegCs
        mov     [ebx+edx+8],ax                  ; push cs
        mov     eax,[esi].RiEip
        mov     [ebx+edx+6],ax                  ; push ip
        mov     eax,RI.RiTrapFrame
        mov     eax,[eax].TsErrCode
        mov     [ebx+edx+4],ax                  ; push error code
        mov     eax,[edi].VpDosxFaultIret
        mov     [ebx+edx],eax                   ; push iret address

        pop     PCR[PcExceptionList]        ; Remove our exception handle

        add     esp, 8                      ; clear stack
        pop     ebp

        jmp     pe50
pe45:
;
;       push 32-bit frame
;
        push    ecx
        mov     ecx, 8*4                        ; room for 8 dwords?
        call    CheckEsp
        pop     ecx
        test    al,0FFh
        jz      peerr1                          ; pop off stack and exit

        sub     edx,8*4
        mov     [esi].RiEsp,edx

        push    ebp
        push    esp                         ; Pass current Esp to handler
        push    offset perr1_fault           ; Set Handler address
        push    PCR[PcExceptionList]        ; Set next pointer
        mov     PCR[PcExceptionList],esp    ; Link us on

        mov     eax, [esp+4*4]
        mov     [ebx+edx+28], eax
        mov     eax, [esp+4*5]
        mov     [ebx+edx+24], eax

        pop     PCR[PcExceptionList]        ; Remove our exception handle

        add     esp, 8                      ; clear stack
        pop     ebp
        lea     esp, [esp+8]                ; drop ss etc

        mov     eax,[esi].RiEFlags
        push    ecx
        call    GetVirtualBits
        pop     ecx

        push    ebp
        push    esp                         ; Pass current Esp to handler
        push    offset perr_fault           ; Set Handler address
        push    PCR[PcExceptionList]        ; Set next pointer
        mov     PCR[PcExceptionList],esp    ; Link us on

        mov     [ebx+edx+20],eax                ; push flags
        movzx   eax,word ptr [esi].RiSegCs
        mov     [ebx+edx+16],eax                ; push cs
        mov     eax,[esi].RiEip
        mov     [ebx+edx+12],eax                ; push ip
        mov     eax,RI.RiTrapFrame
        mov     eax,[eax].TsErrCode
        mov     [ebx+edx+8],eax                 ; push error code
        mov     eax,[edi].VpDosxFaultIretD
        shr     eax, 16
        mov     [ebx+edx+4],eax                 ; push iret seg
        mov     eax,[edi].VpDosxFaultIretD
        and     eax, 0ffffh
        mov     [ebx+edx],eax                   ; push iret offset

        pop     PCR[PcExceptionList]        ; Remove our exception handle

        add     esp, 8                      ; clear stack
        pop     ebp

pe50:
        call    GetHandlerAddress
        test    al,0FFh
        jz      peerr

pe60:   push    ecx
        movzx   eax,word ptr [esi].RiSegCs
        call    CsToLinear                      ; uses eax as selector
        pop     ecx
        test    al,0FFh
        jz      peerr

        mov     eax,[esi].RiEip
        cmp     eax,[esi].RiCsLimit
        ja      peerr

        mov     eax,VDM_FAULT_HANDLER_SIZE
        push    edx
        mul     ecx
        pop     edx

        push    ebp
        push    esp                         ; Pass current Esp to handler
        push    offset perr_fault           ; Set Handler address
        push    PCR[PcExceptionList]        ; Set next pointer
        mov     PCR[PcExceptionList],esp    ; Link us on

        mov     edi,PCR[PcTeb]
        mov     edi,[edi].TbVdm

        cmp     edi, _MmUserProbeAddress
        jb      @f
        mov     edi, _MmUserProbeAddress
@@:     mov     edi,[edi].VtFaultTable
        add     edi,eax
        cmp     edi, _MmUserProbeAddress
        jb      @f
        mov     edi, _MmUserProbeAddress
@@:     mov     eax,[esi].RiEFlags  ;WARNING 16 vs 32
        test    dword ptr [edi].VfFlags,VDM_INT_INT_GATE

        pop     PCR[PcExceptionList]        ; Remove our exception handle

        lea     esp, [esp+8]                ; clear stack
        pop     ebp

        jz      pe70

        and     eax,NOT (EFLAGS_INTERRUPT_MASK OR EFLAGS_TF_MASK)
        push    eax
        xor     ebx, ebx                ;  clear prefix flags
        call    SetVirtualBits
        pop     eax
pe70:   push    ecx
        mov     ecx,eax
        call    CheckVdmFlags
        and     ecx,NOT EFLAGS_TF_MASK
        mov     [esi].RiEFlags,ecx
        pop     ecx
        mov     eax,1                   ; success
pe80:   pop     esi
        pop     edi
        pop     ebx
        ret

peerr1: add     esp, 8                  ;throw away esp, ss
peerr:  xor     eax,eax
        jmp     pe80

PushException endp

perr1_fault proc
        mov     esp, [esp+8]                ; (esp)-> ExceptionList
        pop     PCR[PcExceptionList]        ; Remove our exception handle
        add     esp, 8                      ; clear stack
        pop     ebp
        jmp     peerr1
perr1_fault endp	

perr_fault proc
        mov     esp, [esp+8]                ; (esp)-> ExceptionList
        pop     PCR[PcExceptionList]        ; Remove our exception handle
        add     esp, 8                      ; clear stack
        pop     ebp
        jmp     peerr
perr_fault endp	

_PAGE   ends


_TEXT$00   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME DS:NOTHING, ES:NOTHING, SS:FLAT, FS:NOTHING, GS:NOTHING

;
; Non-pageable code
;

        page   ,132
        subttl "Ipi worker for enabling Pentium extensions"
;++
;
;   Routine Description:
;
;       This routine sets or resets the VME bit in CR4 for each processor
;
;   Arguments:
;
;       [esp + 4] -- 1 if VME is to be set, 0 if it is to be reset
;   Returns:
;
;       0
;
cPublicProc _Ki386VdmEnablePentiumExtentions, 1

Enable equ [ebp + 8]
        push    ebp
        mov     ebp,esp
;
;       Ensure we do not get an interrupt in here.  We may
;       be called at IPI_LEVEL - 1 by KiIpiGenericCall.
;
        pushf
        cli

;       mov     eax,cr4
        db      0fh, 020h,0e0h

        test    Enable,1
        je      vepe20

        or      eax,CR4_VME
        jmp     vepe30

vepe20: and     eax,NOT CR4_VME

;       mov     cr4,eax
vepe30: db      0fh,022h,0e0h

        popf
        xor     eax,eax

        mov     esp,ebp
        pop     ebp
        stdRET _Ki386VdmEnablePentiumExtentions
stdENDP _Ki386VdmEnablePentiumExtentions

_TEXT$00 ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ke\i386\intobj.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    intobj.c

Abstract:

    This module implements the kernel interrupt object. Functions are provided
    to initialize, connect, and disconnect interrupt objects.

--*/

#include "ki.h"

//
// Data used for interrupt timing, aka, long ISR trapping.
// The initial value for KiIsrTscLimit is to prevent the trap from
// firing until a reasonable value is determined.
//

ULONGLONG KiIsrTscLimit = 0xFFFFFFFFFFFFFFFF;
ULONG KiTimeLimitDpcMicroseconds;
ULONG KiTimeLimitIsrMicroseconds;

//
//  Externs from trap.asm used to compute and set handlers for unexpected
//  hardware interrupts.
//

extern  ULONG   KiStartUnexpectedRange(VOID);
extern  ULONG   KiEndUnexpectedRange(VOID);
extern  ULONG   KiUnexpectedEntrySize;


VOID
KiInterruptDispatch2ndLvl(
    VOID
    );

VOID
KiChainedDispatch2ndLvl(
    VOID
    );

typedef enum {
    NoConnect,
    NormalConnect,
    ChainConnect,
    UnknownConnect
} CONNECT_TYPE, *PCONNECT_TYPE;

typedef struct {
    CONNECT_TYPE            Type;
    PKINTERRUPT             Interrupt;
    PKINTERRUPT_ROUTINE     NoDispatch;
    PKINTERRUPT_ROUTINE     InterruptDispatch;
    PKINTERRUPT_ROUTINE     FloatingDispatch;
    PKINTERRUPT_ROUTINE     ChainedDispatch;
    PKINTERRUPT_ROUTINE    *FlatDispatch;
} DISPATCH_INFO, *PDISPATCH_INFO;


VOID
KiGetVectorInfo (
    IN  ULONG                Vector,
    OUT PDISPATCH_INFO       DispatchInfo
    );

VOID
KiConnectVectorAndInterruptObject (
    IN PKINTERRUPT Interrupt,
    IN CONNECT_TYPE Type
    );

VOID
KeInitializeInterrupt (
    __out PKINTERRUPT Interrupt,
    __in PKSERVICE_ROUTINE ServiceRoutine,
    __in_opt PVOID ServiceContext,
    __out_opt PKSPIN_LOCK SpinLock,
    __in ULONG Vector,
    __in KIRQL Irql,
    __in KIRQL SynchronizeIrql,
    __in KINTERRUPT_MODE InterruptMode,
    __in BOOLEAN ShareVector,
    __in CCHAR ProcessorNumber,
    __in BOOLEAN FloatingSave
    )

/*++

Routine Description:

    This function initializes a kernel interrupt object. The service routine,
    service context, spin lock, vector, IRQL, SynchronizeIrql, and floating
    context save flag are initialized.

Arguments:

    Interrupt - Supplies a pointer to a control object of type interrupt.

    ServiceRoutine - Supplies a pointer to a function that is to be
        executed when an interrupt occurs via the specified interrupt
        vector.

    ServiceContext - Supplies a pointer to an arbitrary data structure which is
        to be passed to the function specified by the ServiceRoutine parameter.

    SpinLock - Supplies a pointer to an executive spin lock.

    Vector - Supplies the index of the entry in the Interrupt Dispatch Table
        that is to be associated with the ServiceRoutine function.

    Irql - Supplies the request priority of the interrupting source.

    SynchronizeIrql - The request priority that the interrupt should be
        synchronized with.

    InterruptMode - Supplies the mode of the interrupt; LevelSensitive or

    ShareVector - Supplies a boolean value that specifies whether the
        vector can be shared with other interrupt objects or not.  If FALSE
        then the vector may not be shared, if TRUE it may be.
        Latched.

    ProcessorNumber - Supplies the number of the processor to which the
        interrupt will be connected.

    FloatingSave - Supplies a boolean value that determines whether the
        floating point registers and pipe line are to be saved before calling
        the ServiceRoutine function.

Return Value:

    None.

--*/

{

    LONG Index;
    PULONG pl;
    PULONG NormalDispatchCode;

    //
    // Initialize standard control object header.
    //

    Interrupt->Type = InterruptObject;
    Interrupt->Size = sizeof(KINTERRUPT);

    //
    // Initialize the address of the service routine,
    // the service context, the address of the spin lock, the vector
    // number, the IRQL of the interrupting source, the Irql used for
    // synchronize execution, the interrupt mode, the processor
    // number, and the floating context save flag.
    //

    Interrupt->ServiceRoutine = ServiceRoutine;
    Interrupt->ServiceContext = ServiceContext;

    if (ARGUMENT_PRESENT(SpinLock)) {
        Interrupt->ActualLock = SpinLock;
    } else {
        KeInitializeSpinLock (&Interrupt->SpinLock);
        Interrupt->ActualLock = &Interrupt->SpinLock;
    }

    Interrupt->Vector = Vector;
    Interrupt->Irql = Irql;
    Interrupt->SynchronizeIrql = SynchronizeIrql;
    Interrupt->Mode = InterruptMode;
    Interrupt->ShareVector = ShareVector;
    Interrupt->Number = ProcessorNumber;
    Interrupt->FloatingSave = FloatingSave;

    //
    // Initialize fields for the interrupt storm detection. Set these
    // to -1 so that the first time through the interrupt dispatch they
    // will be reset correctly.
    //
    Interrupt->TickCount = (ULONG)-1;
    Interrupt->DispatchCount = (ULONG)-1;

    //
    // Copy the interrupt dispatch code template into the interrupt object
    // and edit the machine code stored in the structure (please see
    // _KiInterruptTemplate in intsup.asm.)  Finally, flush the dcache
    // on all processors that the current thread can
    // run on to ensure that the code is actually in memory.
    //

    NormalDispatchCode = &(Interrupt->DispatchCode[0]);

    pl = NormalDispatchCode;

    for (Index = 0; Index < NORMAL_DISPATCH_LENGTH; Index += 1) {
        *NormalDispatchCode++ = KiInterruptTemplate[Index];
    }

    //
    // The following two instructions set the address of current interrupt
    // object the the NORMAL dispatching code.
    //

    pl = (PULONG)((PUCHAR)pl + ((PUCHAR)&KiInterruptTemplateObject -
                                (PUCHAR)KiInterruptTemplate) -4); 
    *pl = (ULONG)Interrupt;

    KeSweepDcache(FALSE);

    //
    // Set the connected state of the interrupt object to FALSE.
    //

    Interrupt->Connected = FALSE;
    return;
}

BOOLEAN
KeConnectInterrupt (
    __inout PKINTERRUPT Interrupt
    )

/*++

Routine Description:

    This function connects an interrupt object to the interrupt vector
    specified by the interrupt object. If the interrupt object is already
    connected, or an attempt is made to connect to an interrupt that cannot
    be connected, then a value of FALSE is returned. Else the specified
    interrupt object is connected to the interrupt vector, the connected
    state is set to TRUE, and TRUE is returned as the function value.

Arguments:

    Interrupt - Supplies a pointer to a control object of type interrupt.

Return Value:

    If the interrupt object is already connected or an attempt is made to
    connect to an interrupt vector that cannot be connected, then a value
    of FALSE is returned. Else a value of TRUE is returned.

--*/

{
    DISPATCH_INFO DispatchInfo;
    BOOLEAN Connected;
    BOOLEAN ConnectError;
    BOOLEAN Enabled;
    KIRQL Irql;
    CCHAR Number;
    KIRQL OldIrql;
    ULONG Vector;

    //
    // If the interrupt object is already connected, the interrupt vector
    // number is invalid, an attempt is being made to connect to a vector
    // that cannot be connected, the interrupt request level is invalid, or
    // the processor number is invalid, then do not connect the interrupt
    // object. Else connect interrupt object to the specified vector and
    // establish the proper interrupt dispatcher.
    //

    Connected = FALSE;
    ConnectError = FALSE;
    Irql = Interrupt->Irql;
    Number = Interrupt->Number;
    Vector = Interrupt->Vector;
    if ( !((Irql > HIGH_LEVEL) ||
           (Number >= KeNumberProcessors) ||
           (Interrupt->SynchronizeIrql < Irql) ||
           (Interrupt->FloatingSave)    // R0 x87 usage not supported on x86
          )
       ) {

        //
        //
        // Set system affinity to the specified processor.
        //

        KeSetSystemAffinityThread((KAFFINITY)(1<<Number));

        //
        // Raise IRQL to dispatcher level and lock dispatcher database.
        //

        KiLockDispatcherDatabase(&OldIrql);

        //
        // Is interrupt object already connected?
        //

        if (!Interrupt->Connected) {

            //
            // Determine interrupt dispatch vector
            //

            KiGetVectorInfo (
                Vector,
                &DispatchInfo
                );

            //
            // If dispatch vector is not connected, then connect it
            //

            if (DispatchInfo.Type == NoConnect) {
                Connected = TRUE;
                Interrupt->Connected = TRUE;

                //
                // Connect interrupt dispatch to interrupt object dispatch code
                //

                InitializeListHead(&Interrupt->InterruptListEntry);
                KiConnectVectorAndInterruptObject (Interrupt, NormalConnect);

                //
                // Enabled system vector
                //

                Enabled = HalEnableSystemInterrupt(Vector, Irql, Interrupt->Mode);
                if (!Enabled) {
                    ConnectError = TRUE;
                }


            } else if (DispatchInfo.Type != UnknownConnect &&
                       Interrupt->ShareVector  &&
                       DispatchInfo.Interrupt->ShareVector  &&
                       DispatchInfo.Interrupt->Mode == Interrupt->Mode) {

                //
                // Vector is already connected as sharable.  New vector is sharable
                // and modes match.  Chain new vector.
                //

                Connected = TRUE;
                Interrupt->Connected = TRUE;

                ASSERT (Irql <= SYNCH_LEVEL);

                //
                // If not already using chained dispatch handler, set it up
                //

                if (DispatchInfo.Type != ChainConnect) {
                    KiConnectVectorAndInterruptObject (DispatchInfo.Interrupt, ChainConnect);
                }

                //
                // Add to tail of chained dispatch
                //

                InsertTailList(
                    &DispatchInfo.Interrupt->InterruptListEntry,
                    &Interrupt->InterruptListEntry
                    );

            }
        }

        //
        // Unlock dispatcher database and lower IRQL to its previous value.
        //

        KiUnlockDispatcherDatabase(OldIrql);

        //
        // Set system affinity back to the original value.
        //

        KeRevertToUserAffinityThread();
    }

    if (Connected  &&  ConnectError) {
#if DBG
        DbgPrint ("HalEnableSystemInterrupt failed\n");
#endif
        KeDisconnectInterrupt (Interrupt);
        Connected = FALSE;
    }

    //
    // Return whether interrupt was connected to the specified vector.
    //

    return Connected;
}

BOOLEAN
KeDisconnectInterrupt (
    __inout PKINTERRUPT Interrupt
    )

/*++

Routine Description:

    This function disconnects an interrupt object from the interrupt vector
    specified by the interrupt object. If the interrupt object is not
    connected, then a value of FALSE is returned. Else the specified interrupt
    object is disconnected from the interrupt vector, the connected state is
    set to FALSE, and TRUE is returned as the function value.

Arguments:

    Interrupt - Supplies a pointer to a control object of type interrupt.

Return Value:

    If the interrupt object is not connected, then a value of FALSE is
    returned. Else a value of TRUE is returned.

--*/

{

    DISPATCH_INFO DispatchInfo;
    BOOLEAN Connected;
    PKINTERRUPT Interrupty;
    KIRQL Irql;
    KIRQL OldIrql;
    ULONG Vector;

    //
    // Set system affinity to the specified processor.
    //

    KeSetSystemAffinityThread((KAFFINITY)(1<<Interrupt->Number));

    //
    // Raise IRQL to dispatcher level and lock dispatcher database.
    //

    KiLockDispatcherDatabase(&OldIrql);

    //
    // If the interrupt object is connected, then disconnect it from the
    // specified vector.
    //

    Connected = Interrupt->Connected;
    if (Connected) {
        Irql = Interrupt->Irql;
        Vector = Interrupt->Vector;

        //
        // If the specified interrupt vector is not connected to the chained
        // interrupt dispatcher, then disconnect it by setting its dispatch
        // address to the unexpected interrupt routine. Else remove the
        // interrupt object from the interrupt chain. If there is only
        // one entry remaining in the list, then reestablish the dispatch
        // address.
        //

        //
        // Determine interrupt dispatch vector
        //

        KiGetVectorInfo (
            Vector,
            &DispatchInfo
            );


        //
        // Is dispatch a chained handler?
        //

        if (DispatchInfo.Type == ChainConnect) {

            ASSERT (Irql <= SYNCH_LEVEL);

            //
            // Is interrupt being removed from head?
            //

            if (Interrupt == DispatchInfo.Interrupt) {

                //
                // Update next interrupt object to be head
                //

                DispatchInfo.Interrupt = CONTAINING_RECORD(
                                               DispatchInfo.Interrupt->InterruptListEntry.Flink,
                                               KINTERRUPT,
                                               InterruptListEntry
                                               );

                KiConnectVectorAndInterruptObject (DispatchInfo.Interrupt, ChainConnect);
            }

            //
            // Remove interrupt object
            //

            RemoveEntryList(&Interrupt->InterruptListEntry);

            //
            // If there's only one interrupt object left on this vector,
            // determine proper interrupt dispatcher
            //

            Interrupty = CONTAINING_RECORD(
                                DispatchInfo.Interrupt->InterruptListEntry.Flink,
                                KINTERRUPT,
                                InterruptListEntry
                                );

            if (DispatchInfo.Interrupt == Interrupty) {
                KiConnectVectorAndInterruptObject (Interrupty, NormalConnect);
            }

        } else {

            //
            // Removing last interrupt object from the vector.  Disable the
            // vector, and set it to unconnected
            //

            HalDisableSystemInterrupt(Interrupt->Vector, Irql);
            KiConnectVectorAndInterruptObject (Interrupt, NoConnect);
        }


        KeSweepIcache(TRUE);
        Interrupt->Connected = FALSE;
    }

    //
    // Unlock dispatcher database and lower IRQL to its previous value.
    //

    KiUnlockDispatcherDatabase(OldIrql);

    //
    // Set system affinity back to the original value.
    //

    KeRevertToUserAffinityThread();

    //
    // Return whether interrupt was disconnected from the specified vector.
    //

    return Connected;
}

VOID
KiGetVectorInfo (
    IN  ULONG                Vector,
    OUT PDISPATCH_INFO       DispatchInfo
    )
{
    PKINTERRUPT_ROUTINE Dispatch;
    ULONG CurrentDispatch;
    ULONG DispatchType;
    UCHAR IDTEntry;

    //
    // Get second level dispatch point
    //


    DispatchType = HalSystemVectorDispatchEntry (
                        Vector,
                        &DispatchInfo->FlatDispatch,
                        &DispatchInfo->NoDispatch
                        );

    //
    // Get vector info
    //

    switch (DispatchType) {
        case 0:
            //
            // Primary dispatch
            //

            IDTEntry = HalVectorToIDTEntry(Vector);
            DispatchInfo->NoDispatch = (PKINTERRUPT_ROUTINE) (((ULONG) &KiStartUnexpectedRange) +
                                     (IDTEntry - PRIMARY_VECTOR_BASE) * KiUnexpectedEntrySize);

            DispatchInfo->InterruptDispatch = KiInterruptDispatch;
            DispatchInfo->FloatingDispatch = KiFloatingDispatch;
            DispatchInfo->ChainedDispatch = KiChainedDispatch;
            DispatchInfo->FlatDispatch = NULL;

            CurrentDispatch = (ULONG) KiReturnHandlerAddressFromIDT(Vector);
            DispatchInfo->Interrupt = CONTAINING_RECORD (
                                        CurrentDispatch,
                                        KINTERRUPT,
                                        DispatchCode
                                        );
            break;

        case 1:
            //
            // Secondary dispatch.
            //

            DispatchInfo->InterruptDispatch = KiInterruptDispatch2ndLvl;
            DispatchInfo->FloatingDispatch = KiInterruptDispatch2ndLvl;
            DispatchInfo->ChainedDispatch = KiChainedDispatch2ndLvl;

            CurrentDispatch = (ULONG) *DispatchInfo->FlatDispatch;
            DispatchInfo->Interrupt = (PKINTERRUPT) ( (PUCHAR) CurrentDispatch -
                                            (PUCHAR) KiInterruptTemplate +
                                            (PUCHAR) &KiInterruptTemplate2ndDispatch
                                            );
            break;

        default:
            // Other values reserved
            KeBugCheck (MISMATCHED_HAL);
    }


    //
    // Determine dispatch type
    //

    if (((PKINTERRUPT_ROUTINE) CurrentDispatch) == DispatchInfo->NoDispatch) {

        //
        // Is connected to the NoDispatch function
        //

        DispatchInfo->Type = NoConnect;

    } else {
        Dispatch = DispatchInfo->Interrupt->DispatchAddress;

        if (Dispatch == DispatchInfo->ChainedDispatch) {
            //
            // Is connected to the chained handler
            //

            DispatchInfo->Type = ChainConnect;

        } else if (Dispatch == DispatchInfo->InterruptDispatch ||
                   Dispatch == DispatchInfo->FloatingDispatch) {
            //
            // If connection to the non-chained handler
            //

            DispatchInfo->Type = NormalConnect;

        } else {

            //
            // Unknown connection
            //

            DispatchInfo->Type = UnknownConnect;
#if DBG
            DbgPrint ("KiGetVectorInfo not understood\n");
#endif
        }
    }
}

VOID
KiConnectVectorAndInterruptObject (
    IN PKINTERRUPT Interrupt,
    IN CONNECT_TYPE Type
    )
{
    PKINTERRUPT_ROUTINE DispatchAddress;
    DISPATCH_INFO DispatchInfo;
    PULONG pl;

    //
    // Get current connect info
    //

    KiGetVectorInfo (
        Interrupt->Vector,
        &DispatchInfo
        );

    //
    // If disconnecting, set vector to NoDispatch
    //

    if (Type == NoConnect) {

        DispatchAddress = DispatchInfo.NoDispatch;

    } else {

        //
        // Set interrupt objects dispatch for new type
        //

        DispatchAddress = DispatchInfo.ChainedDispatch;

        if (Type == NormalConnect) {
            DispatchAddress = DispatchInfo.InterruptDispatch;
            if (Interrupt->FloatingSave) {
                DispatchAddress = DispatchInfo.FloatingDispatch;
            }
        }

        Interrupt->DispatchAddress = DispatchAddress;

        //
        // Set interrupt objects dispatch code to kernel dispatcher
        //

        pl = &(Interrupt->DispatchCode[0]);
        pl = (PULONG)((PUCHAR)pl +
                    ((PUCHAR)&KiInterruptTemplateDispatch -
                     (PUCHAR)KiInterruptTemplate) -4); 

        *pl = (ULONG)DispatchAddress-(ULONG)((PUCHAR)pl+4);

        //
        // Set dispatch vector to proper address dispatch code location
        //

        if (DispatchInfo.FlatDispatch) {

            //
            // Connect to flat dispatch
            //

            DispatchAddress = (PKINTERRUPT_ROUTINE) (ULONG_PTR)
                    ((PUCHAR) &(Interrupt->DispatchCode[0]) +
                     ((PUCHAR) &KiInterruptTemplate2ndDispatch -
                      (PUCHAR) KiInterruptTemplate));

        } else {

            //
            // Connect to enter_all dispatch
            //

            DispatchAddress = (PKINTERRUPT_ROUTINE) (ULONG_PTR) &Interrupt->DispatchCode;
        }
    }


    if (DispatchInfo.FlatDispatch) {

        //
        // Connect to flat dispatch
        //

        *DispatchInfo.FlatDispatch = DispatchAddress;

    } else {

        //
        // Connect to IDT
        //

        KiSetHandlerAddressToIDT (Interrupt->Vector, DispatchAddress);
    }
}

VOID
FASTCALL
KiTimedChainedDispatch2ndLvl(
    PKINTERRUPT Interrupt
    )

/*++

Routine Description:

    This function performs the same function as KiChainedDispatch2ndLvl
    except that it is written in C instead of assembly code and includes
    code for timing ISRs.

    I'd be interested in seeing some benchmarks to show if the assembly
    code is actually faster.    The Acquire/Release spinlock could be
    inlined fairly easily.

Arguments:

    Interrupt - Supplies a pointer to a control object of type interrupt.

Return Value:

    None.

--*/

{
    BOOLEAN Handled = FALSE;
    PVOID ListEnd = &Interrupt->InterruptListEntry.Flink;
    //
    //BEGINTIMING

    PKPRCB Prcb = KeGetCurrentPrcb();
    ULONGLONG StartTimeHigher;
    ULONGLONG StartTime;
    ULONGLONG TimeHigher;
    ULONGLONG ElapsedTime;

    //BEGINTIMINGend


    //
    // For each interrupt on this chain.
    //

    do {

        //
        // If the current IRQL (IRQL raised to by nature of taking this
        // interrupt) is not equal to the Synchronization IRQL required
        // for this interrupt, raise to the appropriate level.
        //

        if (Interrupt->Irql != Interrupt->SynchronizeIrql) {
            KfRaiseIrql(Interrupt->SynchronizeIrql);
        }

        //BEGINTIMING

        StartTimeHigher = Prcb->IsrTime;
        StartTime = RDTSC();

        //BEGINTIMINGend

        //
        // Acquire the interrupt lock.
        //

        KiAcquireSpinLock(Interrupt->ActualLock);

        //
        // Call the Interrupt Service Routine.
        //

        Handled |= Interrupt->ServiceRoutine(Interrupt,
                                             Interrupt->ServiceContext);

        //
        // Release the interrupt lock.
        //

        KiReleaseSpinLock(Interrupt->ActualLock);

        //ENDTIMING

        //
        // ElapsedTime is time since we started looking at this element
        // on the chain.  (ie the current interrupt object).
        //

        ElapsedTime = RDTSC() - StartTime;

        //
        // TimeHigher is the amount Prcb->IsrTime has increased since we
        // begin servicing this interrupt object, ie the amount of time
        // spent in higher level ISRs.
        //

        TimeHigher = Prcb->IsrTime - StartTimeHigher;

        //
        // Adjust ElapsedTime to time spent on this interrupt object, excluding 
        // higher level ISRs.
        //

        ElapsedTime -= TimeHigher;
        if (ElapsedTime > KiIsrTscLimit) {

            //
            // If there is a debugger attached, breakin.   Otherwise do nothing.
            // N.B. bugchecking is another possibility.
            //

            if (KdDebuggerEnabled) {
                DbgPrint("KE; ISR time limit exceeded (intobj %p)\n",
                         Interrupt);
                DbgBreakPoint();
            }
        }

        //
        // Update time spent processing interrupts.   This doesn't need 
        // to be atomic as it doesn't matter if it's a little bit lossy.
        // (Though a simple atomic add would do, it's per processor and
        // at IRQL > DISPATCH_LEVEL so it doesn't need to be locked).
        //

        Prcb->IsrTime += ElapsedTime;

        //ENDTIMINGend

        //
        // If IRQL was raised, lower to the previous level.
        //

        if (Interrupt->Irql != Interrupt->SynchronizeIrql) {
            KfLowerIrql(Interrupt->Irql);
        }

        if ((Handled != FALSE) &&
            (Interrupt->Mode == LevelSensitive)) {

            //
            // The interrupt has been handled.
            //

            return;
        }

        //
        // If this is the last entry on the chain, get out, otherwise
        // advance to the next entry.
        //

        if (Interrupt->InterruptListEntry.Flink == ListEnd) {
            ASSERT(Interrupt->Mode != LevelSensitive);

            //
            // We should only get to the end of the list if
            // (a) interrupts are on this chain are level sensitive and
            //     no ISR handled the request.   This is a system fatal
            //     condition, or,
            // (b) the chain has edge triggered interrupts in which case
            //     we must run the chain repeatedly until no ISR services
            //     the request.
            //
            // Question:  Do we actually have chained edge triggered
            //            interrupts anymore?
            //

            if (Handled == FALSE) {
                break;
            }
        }
        Interrupt = CONTAINING_RECORD(Interrupt->InterruptListEntry.Flink,
                                      KINTERRUPT,
                                      InterruptListEntry);
    } while (TRUE);
}

VOID
FASTCALL
KiTimedInterruptDispatch (
    PKINTERRUPT Interrupt
    )

/*++

Routine Description:

    This function is a wrapper for the guts of KiDispatchInterrupt.  It
    is called when the system has been patched to time interrupts.

Arguments:

    Interrupt - Supplies a pointer to a control object of type interrupt.

Return Value:

    None.

--*/

{
    //BEGINTIMING

    PKPRCB Prcb = KeGetCurrentPrcb();
    ULONGLONG StartTimeHigher = Prcb->IsrTime;
    ULONGLONG StartTime = RDTSC();
    ULONGLONG TimeHigher;
    ULONGLONG ElapsedTime;

    //BEGINTIMINGend

    //
    // Acquire the interrupt lock.
    //

    KiAcquireSpinLock(Interrupt->ActualLock);

    //
    // Call the Interrupt Service Routine.
    //

    Interrupt->ServiceRoutine(Interrupt,
                              Interrupt->ServiceContext);

    //
    // Release the interrupt lock.
    //

    KiReleaseSpinLock(Interrupt->ActualLock);

    //ENDTIMING

    //
    // ElapsedTime is time since we entered this routine.
    //

    ElapsedTime = RDTSC() - StartTime;

    //
    // TimeHigher is the amount Prcb->IsrTime has increased since we
    // entered this routine, ie the amount of time spent in higher level
    // ISRs.
    //

    TimeHigher = Prcb->IsrTime - StartTimeHigher;

    //
    // Adjust ElapsedTime to time spent in this routine, excluding 
    // higher level ISRs.
    //

    ElapsedTime -= TimeHigher;
    if (ElapsedTime > KiIsrTscLimit) {

        //
        // If there is a debugger attached, breakin.   Otherwise do nothing.
        // N.B. bugchecking is another possibility.
        //

        if (KdDebuggerEnabled) {
            DbgPrint("KE; ISR time limit exceeded (intobj %p)\n", Interrupt);
            DbgBreakPoint();
        }
    }

    //
    // Update time spent processing interrupts.   This doesn't need 
    // to be atomic as it doesn't matter if it's a little bit lossy.
    // (Though a simple atomic add would do, it's per processor and
    // at IRQL > DISPATCH_LEVEL so it doesn't need to be locked).
    //

    Prcb->IsrTime += ElapsedTime;

    //ENDTIMINGend
}

//
// KiInitializeInterruptTimers but not KiInitializeInterruptTimersDpc
// should be in the INIT section.
//

typedef struct {
    KTIMER SampleTimer;
    KDPC Dpc;
    ULONGLONG InitialTime;
}  KISRTIMERINIT, *PKISRTIMERINIT;

PKISRTIMERINIT KiIsrTimerInit;

VOID
KiInitializeInterruptTimersDpc (
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )

/*++

Routine Description:

    This DPC is run twice on timer expiration.  The time between 
    runs us used to determine the frequency of the processor's 
    Time Stamp Counter (TSC) in order to calculate a TSC delta
    equivalent to the ISR timeout value which is in microseconds.

Arguments:

    Dpc - Supplies a pointer to a DPC object - not used.

    DeferredContext - Supplies the DPC context - not used.

    SystemArgument1 - Supplies the first system argument - note used.

    SystemArgument2 - Supplies the second system argument - note used.

Return Value:

    None.

--*/

{
    ULONGLONG Delta;

    UNREFERENCED_PARAMETER(Dpc);
    UNREFERENCED_PARAMETER(DeferredContext);
    UNREFERENCED_PARAMETER(SystemArgument1);
    UNREFERENCED_PARAMETER(SystemArgument2);

    if (KiIsrTscLimit == 0xFFFFFFFFFFFFFFFF) {

        //
        // First pass.   Get starting TSC value.
        //

        KiIsrTimerInit->InitialTime = RDTSC();
        KiIsrTscLimit = 0xFFFFFFFFFFFFFFFE;

    } else {

        //
        // Second pass.  Get ending TSC value, cancel the periodic
        // timer controlling this DPC and free the memory associated
        // with the timer and the DPC.
        //

        Delta = RDTSC() - KiIsrTimerInit->InitialTime;

        KeCancelTimer(&KiIsrTimerInit->SampleTimer);
        ExFreePool(KiIsrTimerInit);

        //
        // Delta is now the number of TSC clock ticks that occured in
        // 10 seconds.  We choose such a large number to minimize error.
        //
        // Calculate the number of TSC clock ticks in KiTimeLimitIsrMicroseconds
        // microseconds.
        //

        Delta *= KiTimeLimitIsrMicroseconds;
        Delta /= (10 * 1000 * 1000);
        KiIsrTscLimit = Delta;
    }
}

VOID
KiInitializeInterruptTimers(
    VOID
    )
{
    LARGE_INTEGER DueTime;
    

    //
    // If not timing ISRs, nothing to do.
    //

    if (KiTimeLimitIsrMicroseconds == 0) {
        return;
    }

    //
    // The kernel is initialized.   Use a timer to determine the amount
    // the Time Stamp Counter advances by in 10 seconds, then use that 
    // result to set the ISR time limit.
    //

    if ((KeFeatureBits & KF_RDTSC) == 0) {

        //
        // Processor doesn't support the RDTSC instruction, don't attempt
        // to time ISRs.
        //

        return;
    }

    KiIsrTimerInit = ExAllocatePoolWithTag(NonPagedPool,
                                           sizeof(*KiIsrTimerInit),
                                           '  eK');

    if (KiIsrTimerInit == NULL) {

        //
        // Couldn't allocate memory for timer?  Skip ISR timing.
        //

        return;
    }

    KeInitializeTimerEx(&KiIsrTimerInit->SampleTimer, SynchronizationTimer);
    KeInitializeDpc(&KiIsrTimerInit->Dpc, &KiInitializeInterruptTimersDpc, NULL);

    //
    // Relative time in 100 nanoseconds = 10 seconds.
    //

    DueTime.QuadPart = -(10 * 10 * 1000 * 1000);
    KeSetTimerEx(&KiIsrTimerInit->SampleTimer,
                 DueTime,                       // 
                 10000,                         // repeat in 10 seconds.
                 &KiIsrTimerInit->Dpc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ke\i386\gdtsup.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    gdtsup.c

Abstract:

    This module implements interfaces that support manipulation of i386 GDTs.
    These entry points only exist on i386 machines.

--*/

#include "ki.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGELK, KeI386SetGdtSelector)
#pragma alloc_text(PAGE, Ke386GetGdtEntryThread)
#endif

VOID
Ke386GetGdtEntryThread(
    IN PKTHREAD Thread,
    IN ULONG Offset,
    IN PKGDTENTRY Descriptor
    )
/*++

Routine Description:

    This routine returns the contents of an entry in the GDT.  If the
    entry is thread specific, the entry for the specified thread is
    created and returned (KGDT_LDT, and KGDT_R3_TEB).  If the selector
    is processor dependent, the entry for the current processor is
    returned (KGDT_R0_PCR).

Arguments:

    Thread -- Supplies a pointer to the thread to return the entry for.

    Offset -- Supplies the offset in the Gdt.  This value must be 0
        mod 8.

    Descriptor -- Returns the contents of the Gdt descriptor

Return Value:

    None.

--*/

{
    PKGDTENTRY Gdt;
    PKPROCESS Process;

    //
    // If the entry is out of range, don't return anything
    //

    if (Offset >= KGDT_NUMBER * sizeof(KGDTENTRY)) {
        return ;
    }

    if (Offset == KGDT_LDT) {

        //
        // Materialize Ldt selector
        //

        Process = Thread->Process;
        RtlCopyMemory( Descriptor,
            &(Process->LdtDescriptor),
            sizeof(KGDTENTRY)
            );

    } else {

        //
        // Copy Selector from Ldt
        //
        // N.B. We will change the base later, if it is KGDT_R3_TEB
        //


        Gdt = KiPcr()->GDT;

        RtlCopyMemory(Descriptor, (PCHAR)Gdt + Offset, sizeof(KGDTENTRY));

        //
        // if it is the TEB selector, fix the base
        //

        if (Offset == KGDT_R3_TEB) {
            Descriptor->BaseLow = (USHORT)((ULONG)(Thread->Teb) & 0xFFFF);
            Descriptor->HighWord.Bytes.BaseMid =
                (UCHAR) ( ( (ULONG)(Thread->Teb) & 0xFF0000L) >> 16);
            Descriptor->HighWord.Bytes.BaseHi =
                (CHAR)  ( ( (ULONG)(Thread->Teb) & 0xFF000000L) >> 24);
        }
    }

    return ;
}

NTSTATUS
KeI386SetGdtSelector (
    ULONG       Selector,
    PKGDTENTRY  GdtValue
    )
/*++

Routine Description:

    Sets a GDT entry obtained via KeI386AllocateGdtSelectors to the supplied
    GdtValue.

Arguments:

    Selector - Which GDT to set

    GdtValue - GDT value to set into GDT

Return Value:

    status code

--*/
{
    KAFFINITY       TargetSet;
    PKPRCB          Prcb;
    PKPCR           Pcr;
    PKGDTENTRY      GdtEntry;
    ULONG           GdtIndex, BitNumber;

    PAGED_CODE ();

    //
    // Verify GDT entry passed, and it's above the kernel GDT values
    //

    GdtIndex = Selector >> 3;
    if ((Selector & 0x7) != 0  || GdtIndex < KGDT_NUMBER) {
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Set GDT entry in each processor's GDT
    //

    TargetSet = KeActiveProcessors;
    while (TargetSet != 0) {
        KeFindFirstSetLeftAffinity(TargetSet, &BitNumber);
        ClearMember(BitNumber, TargetSet);

        Prcb = KiProcessorBlock[BitNumber];
        Pcr  = CONTAINING_RECORD (Prcb, KPCR, PrcbData);
        GdtEntry = Pcr->GDT + GdtIndex;

        // set it
        *GdtEntry = *GdtValue;
    }

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ke\i386\flushtb.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    tbflush.c

Abstract:

    This module implements machine dependent functions to flush
    the translation buffers in an Intel x86 system.

--*/

#include "ki.h"

VOID
KiFlushTargetEntireTb (
    IN PKIPI_CONTEXT SignalDone,
    IN PVOID Parameter1,
    IN PVOID Parameter2,
    IN PVOID Parameter3
    );

VOID
KiFlushTargetProcessTb (
    IN PKIPI_CONTEXT SignalDone,
    IN PVOID Parameter1,
    IN PVOID Parameter2,
    IN PVOID Parameter3
    );

VOID
KiFlushTargetMultipleTb (
    IN PKIPI_CONTEXT SignalDone,
    IN PVOID Parameter1,
    IN PVOID Parameter2,
    IN PVOID Parameter3
    );

VOID
KiFlushTargetSingleTb (
    IN PKIPI_CONTEXT SignalDone,
    IN PVOID Parameter1,
    IN PVOID Parameter2,
    IN PVOID Parameter3
    );

VOID
KxFlushEntireTb (
    VOID
    )

/*++

Routine Description:

    This function flushes the entire translation buffer on all processors.

Arguments:

    None.

Return Value:

    None.

--*/

{

    KIRQL OldIrql;

#if !defined(NT_UP)

    PKPRCB Prcb;
    KAFFINITY TargetProcessors;

#endif

    //
    // Compute the target set of processors and send the flush entire
    // parameters to the target processors, if any, for execution.
    //

    OldIrql = KeRaiseIrqlToSynchLevel();
    KiSetTbFlushTimeStampBusy();

#if !defined(NT_UP)

    Prcb = KeGetCurrentPrcb();
    TargetProcessors = KeActiveProcessors & ~Prcb->SetMember;

    //
    // Send packet to target processors.
    //

    if (TargetProcessors != 0) {
        KiIpiSendPacket(TargetProcessors,
                        KiFlushTargetEntireTb,
                        NULL,
                        NULL,
                        NULL);

        IPI_INSTRUMENT_COUNT (Prcb->Number, FlushEntireTb);
    }

#endif

    //
    // Flush TB on current processor.
    //

    KeFlushCurrentTb();

    //
    // Wait until all target processors have finished and complete packet.
    //

#if !defined(NT_UP)

    if (TargetProcessors != 0) {
        KiIpiStallOnPacketTargets(TargetProcessors);
    }

#endif

    //
    // Clear the TB time stamp busy.
    //

    KiClearTbFlushTimeStampBusy();

    //
    // Lower IRQL to previous level.
    //

    KeLowerIrql(OldIrql);
    return;
}

#if !defined(NT_UP)

VOID
KiFlushTargetEntireTb (
    IN PKIPI_CONTEXT SignalDone,
    IN PVOID Parameter1,
    IN PVOID Parameter2,
    IN PVOID Parameter3
    )

/*++

Routine Description:

    This is the target function for flushing the entire TB.

Arguments:

    SignalDone - Supplies a pointer to a variable that is cleared when the
        requested operation has been performed.

    Parameter1 - Parameter3 - Not used.

Return Value:

    None.

--*/

{

    UNREFERENCED_PARAMETER(Parameter1);
    UNREFERENCED_PARAMETER(Parameter2);
    UNREFERENCED_PARAMETER(Parameter3);

    //
    // Flush the entire TB on the current processor.
    //

    KiIpiSignalPacketDone(SignalDone);
    KeFlushCurrentTb();
    return;
}

VOID
KeFlushProcessTb (
    VOID
    )

/*++

Routine Description:

    This function flushes the non-global translation buffer on all processors
    that are currently running threads which are child of the current process.

Arguments:

    None.

Return Value:

    None.

--*/

{

    KIRQL OldIrql;
    PKPRCB Prcb;
    PKPROCESS Process;
    KAFFINITY TargetProcessors;

    //
    // Compute the target set of processors, disable context switching,
    // and send the flush entire parameters to the target processors,
    // if any, for execution.
    //

    OldIrql = KeRaiseIrqlToSynchLevel();
    Prcb = KeGetCurrentPrcb();
    Process = Prcb->CurrentThread->ApcState.Process;
    TargetProcessors = Process->ActiveProcessors;
    TargetProcessors &= ~Prcb->SetMember;

    //
    // Send packet to target processors.
    //

    if (TargetProcessors != 0) {
        KiIpiSendPacket(TargetProcessors,
                        KiFlushTargetProcessTb,
                        NULL,
                        NULL,
                        NULL);

        IPI_INSTRUMENT_COUNT (Prcb->Number, FlushEntireTb);
    }

    //
    // Flush TB on current processor.
    //

    KiFlushProcessTb();

    //
    // Wait until all target processors have finished and complete packet.
    //

    if (TargetProcessors != 0) {
        KiIpiStallOnPacketTargets(TargetProcessors);
    }

    //
    // Lower IRQL and unlock as appropriate.
    //

    KeLowerIrql(OldIrql);
    return;
}

VOID
KiFlushTargetProcessTb (
    IN PKIPI_CONTEXT SignalDone,
    IN PVOID Parameter1,
    IN PVOID Parameter2,
    IN PVOID Parameter3
    )

/*++

Routine Description:

    This is the target function for flushing the non-global TB.

Arguments:

    SignalDone - Supplies a pointer to a variable that is cleared when the
        requested operation has been performed.

    Parameter1 - Parameter3 - Not used.

Return Value:

    None.

--*/

{

    UNREFERENCED_PARAMETER(Parameter1);
    UNREFERENCED_PARAMETER(Parameter2);
    UNREFERENCED_PARAMETER(Parameter3);

    //
    // Flush the non-global TB on the current processor.
    //

    KiIpiSignalPacketDone(SignalDone);
    KiFlushProcessTb();
    return;
}

VOID
KeFlushMultipleTb (
    IN ULONG Number,
    IN PVOID *Virtual,
    IN BOOLEAN AllProcessors
    )

/*++

Routine Description:

    This function flushes multiple entries from the translation buffer
    on all processors that are currently running threads which are
    children of the current process or flushes a multiple entries from
    the translation buffer on all processors in the host configuration.

Arguments:

    Number - Supplies the number of TB entries to flush.

    Virtual - Supplies a pointer to an array of virtual addresses that
        are within the pages whose translation buffer entries are to be
        flushed.

    AllProcessors - Supplies a boolean value that determines which
        translation buffers are to be flushed.

Return Value:

    The previous contents of the specified page table entry is returned
    as the function value.

--*/

{

    PVOID *End;
    KIRQL OldIrql;
    PKPRCB Prcb;
    PKPROCESS Process;
    KAFFINITY TargetProcessors;

    ASSERT(Number != 0);

    End = Virtual + Number; 

    //
    // Compute target set of processors.
    //

    OldIrql = KeRaiseIrqlToSynchLevel();
    Prcb = KeGetCurrentPrcb();
    if (AllProcessors != FALSE) {
        TargetProcessors = KeActiveProcessors;

    } else {
        Process = Prcb->CurrentThread->ApcState.Process;
        TargetProcessors = Process->ActiveProcessors;
    }

    TargetProcessors &= ~Prcb->SetMember;

    //
    // If any target processors are specified, then send a flush multiple
    // packet to the target set of processors.
    //

    if (TargetProcessors != 0) {
        KiIpiSendPacket(TargetProcessors,
                        KiFlushTargetMultipleTb,
                        NULL,
                        (PVOID)End,
                        (PVOID)Virtual);

        IPI_INSTRUMENT_COUNT (Prcb->Number, FlushMultipleTb);
    }

    //
    // Flush the specified entries from the TB on the current processor.
    //

    do {
        KiFlushSingleTb(*Virtual);
        Virtual += 1;
    } while (Virtual < End);

    //
    // Wait until all target processors have finished and complete packet.
    //

    if (TargetProcessors != 0) {
        KiIpiStallOnPacketTargets(TargetProcessors);
    }

    //
    // Lower IRQL to its previous level.
    //

    KeLowerIrql(OldIrql);
    return;
}

VOID
KiFlushTargetMultipleTb (
    IN PKIPI_CONTEXT SignalDone,
    IN PVOID Parameter1,
    IN PVOID End,
    IN PVOID Virtual
    )

/*++

Routine Description:

    This is the target function for flushing multiple TB entries.

Arguments:

    SignalDone - Supplies a pointer to a variable that is cleared when the
        requested operation has been performed.

    Parameter1 - Not used.

    End - Supplies the a pointer to the ending address of the virtual
        address array.

    Virtual - Supplies a pointer to an array of virtual addresses that
        are within the pages whose translation buffer entries are to be
        flushed.

Return Value:

    None.

--*/

{

    PVOID *xEnd;
    PVOID *xVirtual;

    UNREFERENCED_PARAMETER(Parameter1);

    //
    // Flush the specified entries from the TB on the current processor and
    // signal pack done.
    //

    xEnd = (PVOID *)End;
    xVirtual = (PVOID *)Virtual;
    do {
        KiFlushSingleTb(*xVirtual);
        xVirtual += 1;
    } while (xVirtual < xEnd);

    KiIpiSignalPacketDone(SignalDone);
    return;
}

VOID
FASTCALL
KeFlushSingleTb (
    IN PVOID Virtual,
    IN BOOLEAN AllProcessors
    )

/*++

Routine Description:

    This function flushes a single entry from translation buffer (TB) on all
    processors that are currently running threads which are child of the current
    process or flushes the entire translation buffer on all processors in the
    host configuration.

Arguments:

    Virtual - Supplies a virtual address that is within the page whose
        translation buffer entry is to be flushed.

    AllProcessors - Supplies a boolean value that determines which translation
        buffers are to be flushed.

Return Value:

    Returns the contents of the PtePointer before the new value
    is stored.

--*/

{

    KIRQL OldIrql;
    PKPRCB Prcb;
    PKPROCESS Process;
    KAFFINITY TargetProcessors;

    //
    // Compute target set of processors.
    //

    OldIrql = KeRaiseIrqlToSynchLevel();
    Prcb = KeGetCurrentPrcb();
    if (AllProcessors != FALSE) {
        TargetProcessors = KeActiveProcessors;

    } else {
        Process = Prcb->CurrentThread->ApcState.Process;
        TargetProcessors = Process->ActiveProcessors;
    }

    TargetProcessors &= ~Prcb->SetMember;

    //
    // If any target processors are specified, then send a flush single
    // packet to the target set of processors.
    //

    if (TargetProcessors != 0) {
        KiIpiSendPacket(TargetProcessors,
                        KiFlushTargetSingleTb,
                        NULL,
                        (PVOID)Virtual,
                        NULL);

        IPI_INSTRUMENT_COUNT(Prcb->Number, FlushSingleTb);
    }

    //
    // Flush the specified entry from the TB on the current processor.
    //

    KiFlushSingleTb(Virtual);

    //
    // Wait until all target processors have finished and complete packet.
    //

    if (TargetProcessors != 0) {
        KiIpiStallOnPacketTargets(TargetProcessors);
    }

    //
    // Lower IRQL to its previous level.
    //

    KeLowerIrql(OldIrql);
    return;
}

VOID
KiFlushTargetSingleTb (
    IN PKIPI_CONTEXT SignalDone,
    IN PVOID Parameter1,
    IN PVOID VirtualAddress,
    IN PVOID Parameter3
    )

/*++

Routine Description:

    This is the target function for flushing a single TB entry.

Arguments:

    SignalDone Supplies a pointer to a variable that is cleared when the
        requested operation has been performed.

    Parameter1 - Not used.

    Virtual - Supplies a virtual address that is within the page whose
        translation buffer entry is to be flushed.

    Parameter3 - Not used.

Return Value:

    None.

--*/

{

    UNREFERENCED_PARAMETER(Parameter1);
    UNREFERENCED_PARAMETER(Parameter3);

    //
    // Flush a single entry from the TB on the current processor.
    //

    KiIpiSignalPacketDone(SignalDone);
    KiFlushSingleTb(VirtualAddress);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ke\i386\iopm.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    iopm.c

Abstract:

    This module implements interfaces that support manipulation of i386
    i/o access maps (IOPMs).

    These entry points only exist on i386 machines.

--*/

#include "ki.h"

//
// Our notion of alignment is different, so force use of ours
//

#undef  ALIGN_UP
#undef  ALIGN_DOWN
#define ALIGN_DOWN(address,amt) ((ULONG)(address) & ~(( amt ) - 1))
#define ALIGN_UP(address,amt) (ALIGN_DOWN( (address + (amt) - 1), (amt) ))

//
// Note on synchronization:
//
//  IOPM edits are always done by code running at DPC level on
//  the processor whose TSS (map) is being edited.
//
//  IOPM only affects user mode code.  User mode code can never interrupt
//  DPC level code, therefore, edits and user code never race.
//


//
// Define a structure to hold the map change info we pass to DPC's
//

typedef struct _MAPINFO {
    PVOID MapSource;
    PKPROCESS Process;
    ULONG MapNumber;
    USHORT MapOffset;
} MAPINFO, *PMAPINFO;

//
// Define forward referenced function prototypes.
//

VOID
KiSetIoMap(
    PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

VOID
KiLoadIopmOffset(
    IN PKIPI_CONTEXT SignalDone,
    IN PVOID Parameter1,
    IN PVOID Parameter2,
    IN PVOID Parameter3
    );

BOOLEAN
Ke386SetIoAccessMap (
    ULONG MapNumber,
    PKIO_ACCESS_MAP IoAccessMap
    )

/*++

Routine Description:

    The specified i/o access map will be set to match the
    definition specified by IoAccessMap (i.e. enable/disable
    those ports) before the call returns.  The change will take
    effect on all processors.

    Ke386SetIoAccessMap does not give any process enhanced I/O
    access, it merely defines a particular access map.

Arguments:

    MapNumber - Number of access map to set.  Map 0 is fixed.

    IoAccessMap - Pointer to bitvector (64K bits, 8K bytes) which
           defines the specified access map.  Must be in
           non-paged pool.

Return Value:

    TRUE if successful.  FALSE if failure (attempt to set a map
    which does not exist, attempt to set map 0)

--*/

{
    MAPINFO MapInfo;

    //
    // Reject illegal requests
    //

    if ((MapNumber > IOPM_COUNT) || (MapNumber == IO_ACCESS_MAP_NONE)) {
        return FALSE;
    }

    MapInfo.MapSource = IoAccessMap;
    MapInfo.MapNumber = MapNumber;
    MapInfo.Process   = KeGetCurrentThread()->ApcState.Process;

    KeGenericCallDpc (KiSetIoMap,
                      &MapInfo);

    return TRUE;
}

VOID
KiSetIoMap(
    PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )
/*++

Routine Description:

    copy the specified map into this processor's TSS.
    This procedure runs at IPI level.

Arguments:

    Dpc - DPC used to initiate this call
    DeferredContext - Context
    SystemArgument1 - System context, Used to signal completion of this call
    SystemArgument2 - System context

Return Value:

    none

--*/

{

    PKPROCESS CurrentProcess;
    PKPCR Pcr;
    PKPRCB Prcb;
    PVOID pt;
    PMAPINFO MapInfo;

    UNREFERENCED_PARAMETER (Dpc);
    UNREFERENCED_PARAMETER (SystemArgument2);

    MapInfo = DeferredContext;

    //
    // Copy the IOPM map and load the map for the current process.
    // We only do this if the current process is running on this processor.
    //

    Pcr = KiPcr ();
    Prcb = Pcr->Prcb;
    CurrentProcess = Prcb->CurrentThread->ApcState.Process;

    pt = &(Pcr->TSS->IoMaps[MapInfo->MapNumber-1].IoMap);
    RtlCopyMemory (pt, MapInfo->MapSource, IOPM_SIZE);
    Pcr->TSS->IoMapBase = CurrentProcess->IopmOffset;

    //
    // Signal that all processing has been done
    //

    KeSignalCallDpcDone (SystemArgument1);

    return;
}

BOOLEAN
Ke386QueryIoAccessMap (
    ULONG MapNumber,
    PKIO_ACCESS_MAP IoAccessMap
    )

/*++

Routine Description:

    The specified i/o access map will be dumped into the buffer.
    map 0 is a constant, but will be dumped anyway.

Arguments:

    MapNumber - Number of access map to set.  map 0 is fixed.

    IoAccessMap - Pointer to buffer (64K bits, 8K bytes) which
           is to receive the definition of the access map.
           Must be in non-paged pool.

Return Value:

    TRUE if successful.  FALSE if failure (attempt to query a map
    which does not exist)

--*/

{

    ULONG i;
    PVOID Map;
    KIRQL OldIrql;
    PUCHAR p;

    //
    // Reject illegal requests
    //

    if (MapNumber > IOPM_COUNT) {
        return FALSE;
    }


    //
    // Copy out the map
    //

    if (MapNumber == IO_ACCESS_MAP_NONE) {

        //
        // no access case, simply return a map of all 1s
        //

        p = (PUCHAR)IoAccessMap;
        for (i = 0; i < IOPM_SIZE; i++) {
            p[i] = (UCHAR)-1;
        }

    } else {

        //
        // Raise to DISPATCH_LEVEL to obtain read access to the structure
        //

        KeRaiseIrql (DISPATCH_LEVEL, &OldIrql);

        //
        // normal case, just copy the bits
        //

        Map = (PVOID)&(KiPcr ()->TSS->IoMaps[MapNumber-1].IoMap);
        RtlCopyMemory ((PVOID)IoAccessMap, Map, IOPM_SIZE);

        //
        // Restore IRQL.
        //

        KeLowerIrql (OldIrql);
    }

    return TRUE;
}

BOOLEAN
Ke386IoSetAccessProcess (
    PKPROCESS Process,
    ULONG MapNumber
    )
/*++

Routine Description:

    Set the i/o access map which controls user mode i/o access
    for a particular process.

Arguments:

    Process - Pointer to kernel process object describing the
    process which for which a map is to be set.

    MapNumber - Number of the map to set.  Value of map is
    defined by Ke386IoSetAccessProcess.  Setting MapNumber
    to IO_ACCESS_MAP_NONE will disallow any user mode i/o
    access from the process.

Return Value:

    TRUE if success, FALSE if failure (illegal MapNumber)

--*/

{
    MAPINFO MapInfo;
    USHORT MapOffset;

    //
    // Reject illegal requests
    //

    if (MapNumber > IOPM_COUNT) {
        return FALSE;
    }

    MapOffset = KiComputeIopmOffset (MapNumber);

    //
    // Do the update on all processors at DISPATCH_LEVEL
    //

    MapInfo.Process   = Process;
    MapInfo.MapOffset = MapOffset;

    KeGenericCallDpc (KiLoadIopmOffset,
                      &MapInfo);

    return TRUE;
}

VOID
KiLoadIopmOffset(
    PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )

/*++

Routine Description:

    Edit IopmBase of Tss to match that of currently running process.

Arguments:

    Dpc - DPC used to initiate this call
    DeferredContext - Context
    SystemArgument1 - System context, Used to signal completion of this call
    SystemArgument2 - System context

Return Value:

    none

--*/

{
    PKPCR Pcr;
    PKPRCB Prcb;
    PKPROCESS CurrentProcess;
    PMAPINFO MapInfo;

    UNREFERENCED_PARAMETER (Dpc);
    UNREFERENCED_PARAMETER (SystemArgument2);

    //
    // Update IOPM field in TSS from current process
    //

    MapInfo = DeferredContext;

    Pcr = KiPcr ();
    Prcb = Pcr->Prcb;
    CurrentProcess = Prcb->CurrentThread->ApcState.Process;

    //
    // Set the process IOPM offset first so its available to all.
    // Any context swaps after this point will pick up the new value
    // This store may occur multiple times but that doesn't matter
    //
    MapInfo->Process->IopmOffset = MapInfo->MapOffset;

    Pcr->TSS->IoMapBase = CurrentProcess->IopmOffset;

    //
    // Signal that all processing has been done
    //

    KeSignalCallDpcDone (SystemArgument1);
    return;
}

VOID
Ke386SetIOPL(
    VOID
    )

/*++

Routine Description:

    Gives IOPL to the specified process.

    All threads created from this point on will get IOPL.  The current
    process will get IOPL.  Must be called from context of thread and
    process that are to have IOPL.

    Iopl (to be made a boolean) in KPROCESS says all
    new threads to get IOPL.

    Iopl (to be made a boolean) in KTHREAD says given
    thread to get IOPL.

    N.B.    If a kernel mode only thread calls this procedure, the
            result is (a) pointless and (b) will break the system.

Arguments:

    None.

Return Value:

    None.

--*/

{

    PKTHREAD    Thread;
    PKPROCESS   Process2;
    PKTRAP_FRAME    TrapFrame;
    CONTEXT     Context;

    //
    // get current thread and Process2, set flag for IOPL in both of them
    //

    Thread = KeGetCurrentThread();
    Process2 = Thread->ApcState.Process;

    Process2->Iopl = 1;
    Thread->Iopl = 1;

    //
    // Force IOPL to be on for current thread
    //

    TrapFrame = (PKTRAP_FRAME)((PUCHAR)Thread->InitialStack -
                ALIGN_UP(sizeof(KTRAP_FRAME),KTRAP_FRAME_ALIGN) -
                sizeof(FX_SAVE_AREA));

    Context.ContextFlags = CONTEXT_CONTROL;
    KeContextFromKframes(TrapFrame,
                         NULL,
                         &Context);

    Context.EFlags |= (EFLAGS_IOPL_MASK & -1);  // IOPL == 3

    KeContextToKframes(TrapFrame,
                       NULL,
                       &Context,
                       CONTEXT_CONTROL,
                       UserMode);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ke\i386\kernlini.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    kernlini.c

Abstract:

    This module contains the code to initialize the kernel data structures
    and to initialize the idle thread, its process, and the processor control
    block.

    For the i386, it also contains code to initialize the PCR.

--*/

#include "ki.h"
#include "fastsys.inc"

#pragma warning(disable:4725)  // instruction may be inaccurate on some Pentiums

#define TRAP332_GATE 0xEF00

VOID
KiSetProcessorType(
    VOID
    );

VOID
KiSetCR0Bits(
    VOID
    );

BOOLEAN
KiIsNpxPresent(
    VOID
    );

VOID
KiI386PentiumLockErrataFixup (
    VOID
    );

VOID
KiInitializeDblFaultTSS(
    IN PKTSS Tss,
    IN ULONG Stack,
    IN PKGDTENTRY TssDescriptor
    );

VOID
KiInitializeTSS2 (
    IN PKTSS Tss,
    IN PKGDTENTRY TssDescriptor
    );

VOID
KiSwapIDT (
    VOID
    );

VOID
KeSetup80387OrEmulate (
    IN PVOID *R3EmulatorTable
    );

VOID
KiGetCacheInformation(
    VOID
    );

ULONG
KiGetCpuVendor(
    VOID
    );

ULONG
KiGetFeatureBits (
    VOID
    );

NTSTATUS
KiMoveRegTree(
    HANDLE  Source,
    HANDLE  Dest
    );

VOID
Ki386EnableDE (
    IN volatile PLONG Number
    );

VOID
Ki386EnableFxsr (
    IN volatile PLONG Number
    );


VOID
Ki386EnableXMMIExceptions (
    IN volatile PLONG Number
    );


VOID
Ki386EnableGlobalPage (
    IN volatile PLONG Number
    );

BOOLEAN
KiInitMachineDependent (
    VOID
    );

VOID
KiInitializeMTRR (
    IN BOOLEAN LastProcessor
    );

VOID
KiInitializePAT (
    VOID
    );

VOID
KiAmdK6InitializeMTRR(
    VOID
    );

VOID
KiRestoreFastSyscallReturnState(
    VOID
    );

#pragma alloc_text(INIT,KiInitializeKernel)
#pragma alloc_text(INIT,KiInitializePcr)
#pragma alloc_text(INIT,KiInitializeDblFaultTSS)
#pragma alloc_text(INIT,KiInitializeTSS2)
#pragma alloc_text(INIT,KiSwapIDT)
#pragma alloc_text(INIT,KeSetup80387OrEmulate)
#pragma alloc_text(INIT,KiGetFeatureBits)
#pragma alloc_text(INIT,KiGetCacheInformation)
#pragma alloc_text(INIT,KiGetCpuVendor)
#pragma alloc_text(INIT,KiMoveRegTree)
#pragma alloc_text(INIT,KiInitMachineDependent)
#pragma alloc_text(INIT,KiI386PentiumLockErrataFixup)

BOOLEAN KiI386PentiumLockErrataPresent = FALSE;
BOOLEAN KiIgnoreUnexpectedTrap07 = FALSE;

ULONG KiFastSystemCallDisable;
ULONG KiXMMIZeroingEnable;

extern PVOID Ki387RoundModeTable;
extern PVOID Ki386IopmSaveArea;
extern ULONG KeI386ForceNpxEmulation;
extern WCHAR CmDisabledFloatingPointProcessor[];
extern CHAR CmpCyrixID[];
extern CHAR CmpIntelID[];
extern CHAR CmpAmdID[];
extern CHAR CmpTransmetaID[];
extern CHAR CmpCentaurID[];
extern CHAR CmpRiseID[];
extern BOOLEAN KiFastSystemCallIsIA32;
extern ULONG KiTimeLimitIsrMicroseconds;
extern BOOLEAN KiSMTProcessorsPresent;

//
// Declare routines who's addresses are taken but that are not otherwise
// referenced in this module.
//

VOID FASTCALL KiTimedChainedDispatch2ndLvl(PVOID);
VOID FASTCALL KiTimedInterruptDispatch(PVOID);
VOID KiChainedDispatch2ndLvl(VOID);

//
// Declare KiGetInterruptDispatchPatchAddresses.
//

VOID
KiGetInterruptDispatchPatchAddresses(
    PULONG_PTR Address1,
    PULONG_PTR Address2
    );

#ifndef NT_UP
extern PVOID ScPatchFxb;
extern PVOID ScPatchFxe;
#endif

typedef enum {
    CPU_NONE,
    CPU_INTEL,
    CPU_AMD,
    CPU_CYRIX,
    CPU_TRANSMETA,
    CPU_CENTAUR,
    CPU_RISE,
    CPU_UNKNOWN
} CPU_VENDORS;


//
// If this processor does XMMI, take advantage of it.  Default is
// no XMMI.
//

BOOLEAN KeI386XMMIPresent;

//
// Define prototypes and static initialization for the fast zero
// page routines.
//

VOID
FASTCALL
KiZeroPages (
    IN PVOID PageBase,
    IN SIZE_T NumberOfBytes
    );

VOID
FASTCALL
KiXMMIZeroPages (
    IN PVOID PageBase,
    IN SIZE_T NumberOfBytes
    );

VOID
FASTCALL
KiXMMIZeroPagesNoSave (
    IN PVOID PageBase,
    IN SIZE_T NumberOfBytes
    );

KE_ZERO_PAGE_ROUTINE KeZeroPages = KiZeroPages;
KE_ZERO_PAGE_ROUTINE KeZeroPagesFromIdleThread = KiZeroPages;

//
// Line size of the d-cache closest to the processor.   Used by machine
// dependent prefetch routines.  Default to 32.
//

ULONG KePrefetchNTAGranularity = 32;

VOID
FASTCALL
RtlPrefetchMemoryNonTemporal(
    PVOID   Memory,
    SIZE_T  Length
    );


//
// The following spinlock is for compatiblity with 486 systems that don't
// have a cmpxchg8b instruction and therefore need to synchronize using a
// spinlock.  NOTE: This spinlock should be initialized on x86 systems.
//

ULONG Ki486CompatibilityLock;

//
// Profile vars
//

extern KIDTENTRY IDT[];

#if defined(_X86PAE_)

FORCEINLINE
VOID
KiEnableNXSupport (
    VOID
    )

/*++

Routine Description:

    This function enables NX support on the current processor.

Arguments:

    None.

Return Value:

    None.

--*/

{

    ULONG Temp;

    //
    // Enable NX support in the extended function enable register.
    //

    Temp = (ULONG)RDMSR(0xc0000080);
    Temp |= 0x800;
    WRMSR(0xc0000080, (ULONGLONG)Temp);

    //
    // Set memory management control values.
    //

    KeErrorMask = 0x9;
    MmPaeErrMask = 0x8;
    MmPaeMask = 0x8000000000000000UI64;

    //
    // Set NX enabled in user shared page.
    //

    SharedUserData->ProcessorFeatures[PF_NX_ENABLED] = TRUE;
    return;
}

#endif

VOID
KiInitializeKernel (
    IN PKPROCESS Process,
    IN PKTHREAD Thread,
    IN PVOID IdleStack,
    IN PKPRCB Prcb,
    IN CCHAR Number,
    PLOADER_PARAMETER_BLOCK LoaderBlock
    )

/*++

Routine Description:

    This function gains control after the system has been bootstrapped and
    before the system has been initialized. Its function is to initialize
    the kernel data structures, initialize the idle thread and process objects,
    initialize the processor control block, call the executive initialization
    routine, and then return to the system startup routine. This routine is
    also called to initialize the processor specific structures when a new
    processor is brought on line.

Arguments:

    Process - Supplies a pointer to a control object of type process for
        the specified processor.

    Thread - Supplies a pointer to a dispatcher object of type thread for
        the specified processor.

    IdleStack - Supplies a pointer the base of the real kernel stack for
        idle thread on the specified processor.

    Prcb - Supplies a pointer to a processor control block for the specified
        processor.

    Number - Supplies the number of the processor that is being
        initialized.

    LoaderBlock - Supplies a pointer to the loader parameter block.

Return Value:

    None.

--*/

{
    ULONG DirectoryTableBase[2];
    PVOID DpcStack;
    KIRQL OldIrql;
    PKPCR Pcr;
    BOOLEAN NpxFlag;

#if !defined(NT_UP)

    BOOLEAN FxsrPresent;
    BOOLEAN XMMIPresent;

#endif

    ULONG FeatureBits;

#if defined(KE_MULTINODE)

    LONG  Index;

#endif

    KiSetProcessorType();
    KiSetCR0Bits();
    NpxFlag = KiIsNpxPresent();
    Pcr = KeGetPcr();

    //
    // Initialize processor's PowerState
    //

    PoInitializePrcb(Prcb);

    //
    // Check for unsupported processor revision
    //

    if (Prcb->CpuType == 3) {
        KeBugCheckEx(UNSUPPORTED_PROCESSOR,0x386,0,0,0);
    }

    //
    // Get the processor FeatureBits for this processor.
    //

    FeatureBits = KiGetFeatureBits();

    //
    // Enable no execute protection if the host processor supports the
    // feature and it is enabled via a loader option.
    //
    // N.B. If no execute protection is enabled, then other processors
    //      are enabled in the HAL during their startup.
    //
    // N.B. LoadOptions is upcased by the loader.
    //

    SharedUserData->NXSupportPolicy = NX_SUPPORT_POLICY_OPTIN;
    if (strstr(KeLoaderBlock->LoadOptions, "NOEXECUTE=ALWAYSON") != NULL) {
        SharedUserData->NXSupportPolicy = NX_SUPPORT_POLICY_ALWAYSON;
        FeatureBits |= KF_GLOBAL_32BIT_NOEXECUTE;

    } else if (strstr(KeLoaderBlock->LoadOptions, "NOEXECUTE=OPTOUT") != NULL) {
        SharedUserData->NXSupportPolicy = NX_SUPPORT_POLICY_OPTOUT;
        FeatureBits |= KF_GLOBAL_32BIT_NOEXECUTE;

    } else if (strstr(KeLoaderBlock->LoadOptions, "NOEXECUTE=OPTIN") != NULL) {
        FeatureBits |= KF_GLOBAL_32BIT_NOEXECUTE;

    } else if (strstr(KeLoaderBlock->LoadOptions, "NOEXECUTE=ALWAYSOFF") != NULL) {
        SharedUserData->NXSupportPolicy = NX_SUPPORT_POLICY_ALWAYSOFF;
        FeatureBits |= KF_GLOBAL_32BIT_EXECUTE;

    } else if (strstr(KeLoaderBlock->LoadOptions, "NOEXECUTE") != NULL) {
        FeatureBits |= KF_GLOBAL_32BIT_NOEXECUTE;

    } else if (strstr(KeLoaderBlock->LoadOptions, "EXECUTE") != NULL) {
        SharedUserData->NXSupportPolicy = NX_SUPPORT_POLICY_ALWAYSOFF;
        FeatureBits |= KF_GLOBAL_32BIT_EXECUTE;
    }


#if defined (_X86PAE_)

    if ((FeatureBits & KF_NOEXECUTE) == 0) {
        FeatureBits &= ~KF_GLOBAL_32BIT_NOEXECUTE;
    }

    if ((FeatureBits & KF_GLOBAL_32BIT_NOEXECUTE) != 0) {
        KiEnableNXSupport();
    }

#endif

    Prcb->FeatureBits = FeatureBits;

    //
    // Do one time initialization of the ProcessorControlSpace in the PRCB
    // so local kernel debugger can get things like the GDT.
    //

    KiSaveProcessorControlState(&Prcb->ProcessorState);

    //
    // Get processor Cache Size information.
    //

    KiGetCacheInformation();

    //
    // Initialize the per processor lock data.
    //

    KiInitSpinLocks(Prcb, Number);

    //
    // If the initial processor is being initialized, then initialize the
    // per system data structures.
    //

    if (Number == 0) {

        //
        // Set default node.  Used in non-multinode systems and in
        // multinode systems until the node topology is available.
        //

        KeNodeBlock[0] = &KiNode0;

#if defined(KE_MULTINODE)

        for (Index = 1; Index < MAXIMUM_CCNUMA_NODES; Index++) {

            //
            // Set temporary node.
            //

            KeNodeBlock[Index] = &KiNodeInit[Index];
        }

#endif

        Prcb->ParentNode = KeNodeBlock[0];
        KeNodeBlock[0]->ProcessorMask = Prcb->SetMember;

        //
        // Initial setting for global Cpu & Stepping levels
        //

        KeI386NpxPresent = NpxFlag;
        KeI386CpuType = Prcb->CpuType;
        KeI386CpuStep = Prcb->CpuStep;

        KeProcessorArchitecture = PROCESSOR_ARCHITECTURE_INTEL;
        KeProcessorLevel = (USHORT)Prcb->CpuType;
        if (Prcb->CpuID == 0) {
            KeProcessorRevision = 0xFF00 |
                                  (((Prcb->CpuStep >> 4) + 0xa0 ) & 0x0F0) |
                                  (Prcb->CpuStep & 0xf);
        } else {
            KeProcessorRevision = Prcb->CpuStep;
        }

        KeFeatureBits = FeatureBits;
        KeI386FxsrPresent = ((KeFeatureBits & KF_FXSR) ? TRUE:FALSE);
        KeI386XMMIPresent = ((KeFeatureBits & KF_XMMI) ? TRUE:FALSE);

        //
        // As of Windows XP, cmpxchg8b is a required instruction.
        //

        if ((KeFeatureBits & KF_CMPXCHG8B) == 0) {

            ULONG Vendor[3];

            //
            // Argument 1:
            //   bits 31-24: Unique value for missing feature.
            //   bits 23-0 : Family/Model/Stepping (this could compress).
            //
            // Arguments 2 thru 4:
            //   Vendor Id string.
            //

            RtlCopyMemory(Vendor, Prcb->VendorString, sizeof(Vendor));
            KeBugCheckEx(UNSUPPORTED_PROCESSOR,
                         (1 << 24 )     // rev this for other required features
                          | (Prcb->CpuType << 16) | Prcb->CpuStep,
                         Vendor[0],
                         Vendor[1],
                         Vendor[2]);
        }

        //
        // Lower IRQL to APC level.
        //

        KeLowerIrql(APC_LEVEL);

        //
        // Initialize kernel internal spinlocks
        //

        KeInitializeSpinLock(&KiFreezeExecutionLock);

        //
        // Initialize 486 compatibility lock
        //

        KeInitializeSpinLock(&Ki486CompatibilityLock);

#if !defined(NT_UP)

        //
        // Set this processor as the master (ie first found) processor
        // in this SMT set (whether or not it is actually SMT).
        //

        Prcb->MultiThreadSetMaster = Prcb;

        //
        // During Text Mode setup, it is possible the system is
        // running with an MP kernel and a UP HAL.  On X86 systems,
        // spinlocks are implemented in both the kernel and the HAL
        // with the verisons that alter IRQL in the HAL.   If the
        // HAL is UP, it will not actually acquire/release locks
        // while the MP kernel will which will cause the system to
        // hang (or crash).   As this can only occur during text
        // mode setup, we will detect the situation and disable
        // the kernel only versions of queued spinlocks if the HAL
        // is UP (and the kernel MP).
        //
        // We need to patch 3 routines, two of them are void and
        // the other returns a boolean (must be true (and ZF must be
        // clear) in a UP case).
        //
        // Determine if the HAL us UP by acquiring the dispatcher
        // lock and examining it to see if the HAL actually did
        // anything to it.
        //

        OldIrql = KfAcquireSpinLock(&Ki486CompatibilityLock);
        if (Ki486CompatibilityLock == 0) {

            //
            // KfAcquireSpinLock is in the HAL and it did not
            // change the value of the lock.  This is a UP HAL.
            //

            extern UCHAR KeTryToAcquireQueuedSpinLockAtRaisedIrqlUP;
            PUCHAR PatchTarget, PatchSource;
            UCHAR Byte;

            #define RET 0xc3

            *(PUCHAR)(ULONG_PTR)(KeAcquireQueuedSpinLockAtDpcLevel) = RET;
            *(PUCHAR)(ULONG_PTR)(KeReleaseQueuedSpinLockFromDpcLevel) = RET;

            //
            // Copy the UP version of KeTryToAcquireQueuedSpinLockAtRaisedIrql
            // over the top of the MP version.
            //

            PatchSource = (PUCHAR)(ULONG_PTR)&(KeTryToAcquireQueuedSpinLockAtRaisedIrqlUP);
            PatchTarget = (PUCHAR)(ULONG_PTR)(KeTryToAcquireQueuedSpinLockAtRaisedIrql);

            do {
                Byte = *PatchSource++;
                *PatchTarget++ = Byte;
            } while (Byte != RET);

            #undef RET
        }

        KeReleaseSpinLock(&Ki486CompatibilityLock, OldIrql);

#endif

        //
        // Performance architecture independent initialization.
        //

        KiInitSystem();

        //
        // Initialize idle thread process object and then set:
        //
        //      1. all the quantum values to the maximum possible.
        //      2. the process in the balance set.
        //      3. the active processor mask to the specified process.
        //

        DirectoryTableBase[0] = 0;
        DirectoryTableBase[1] = 0;
        InitializeListHead(&KiProcessListHead);
        KeInitializeProcess(Process,
                            (KPRIORITY)0,
                            (KAFFINITY)(0xffffffff),
                            &DirectoryTableBase[0],
                            FALSE);

        Process->QuantumReset = MAXCHAR;

#if !defined(NT_UP)

    } else {

        //
        // Adjust global cpu setting to represent lowest of all processors
        //

        FxsrPresent = ((FeatureBits & KF_FXSR) ? TRUE:FALSE);
        if (FxsrPresent != KeI386FxsrPresent) {

            //
            // FXSR support must be available on all processors or on none
            //

            KeBugCheckEx(MULTIPROCESSOR_CONFIGURATION_NOT_SUPPORTED, KF_FXSR, 0, 0, 0);
        }

        XMMIPresent = ((FeatureBits & KF_XMMI) ? TRUE:FALSE);
        if (XMMIPresent != KeI386XMMIPresent) {

            //
            // XMMI support must be available on all processors or on none
            //

            KeBugCheckEx(MULTIPROCESSOR_CONFIGURATION_NOT_SUPPORTED, KF_XMMI, 0, 0, 0);
        }

        if (NpxFlag != KeI386NpxPresent) {

            //
            // NPX support must be available on all processors or on none
            //

            KeBugCheckEx(MULTIPROCESSOR_CONFIGURATION_NOT_SUPPORTED, 0x387, 0, 0, 0);
        }

        if ((ULONG)(Prcb->CpuType) != KeI386CpuType) {

            if ((ULONG)(Prcb->CpuType) < KeI386CpuType) {

                //
                // What is the lowest CPU type
                //

                KeI386CpuType = (ULONG)Prcb->CpuType;
                KeProcessorLevel = (USHORT)Prcb->CpuType;
            }
        }

        if ((KiBootFeatureBits & KF_CMPXCHG8B)  &&  !(FeatureBits & KF_CMPXCHG8B)) {

            //
            // cmpxchg8b must be available on all processors, if installed at boot
            //

            KeBugCheckEx(MULTIPROCESSOR_CONFIGURATION_NOT_SUPPORTED, KF_CMPXCHG8B, 0, 0, 0);
        }

        if ((KeFeatureBits & KF_GLOBAL_PAGE)  &&  !(FeatureBits & KF_GLOBAL_PAGE)) {

            //
            // Global page support must be available on all processors, if on boot processor
            //

            KeBugCheckEx(MULTIPROCESSOR_CONFIGURATION_NOT_SUPPORTED, KF_GLOBAL_PAGE, 0, 0, 0);
        }

        if ((KeFeatureBits & KF_PAT)  &&  !(FeatureBits & KF_PAT)) {

            //
            // PAT must be available on all processors, if on boot processor
            //

            KeBugCheckEx(MULTIPROCESSOR_CONFIGURATION_NOT_SUPPORTED, KF_PAT, 0, 0, 0);
        }

        if ((KeFeatureBits & KF_MTRR)  &&  !(FeatureBits & KF_MTRR)) {

            //
            // MTRR must be available on all processors, if on boot processor
            //

            KeBugCheckEx(MULTIPROCESSOR_CONFIGURATION_NOT_SUPPORTED, KF_MTRR, 0, 0, 0);
        }

        if ((KeFeatureBits & KF_NOEXECUTE) && !(FeatureBits & KF_NOEXECUTE)) {

            //
            // KF_NOEXECUTE must be available on all processors, if on
            // boot processor.
            // 

            KeBugCheckEx(MULTIPROCESSOR_CONFIGURATION_NOT_SUPPORTED,
                         KF_NOEXECUTE,
                         0,
                         0,
                         0);
        }

        if ((KeFeatureBits & KF_FAST_SYSCALL) != (FeatureBits & KF_FAST_SYSCALL)) {

            //
            // If this feature is not available on all processors
            // don't use it at all.
            //

            KiFastSystemCallDisable = 1;
        }

        if ((KeFeatureBits & KF_XMMI64) != (FeatureBits & KF_XMMI64)) {

            //
            // If not all processors support Streaming SIMD Extensions
            // 64bit FP don't use it at all.
            //

            KeFeatureBits &= ~KF_XMMI64;
        }

        //
        // Use lowest stepping value
        //

        if (Prcb->CpuStep < KeI386CpuStep) {
            KeI386CpuStep = Prcb->CpuStep;
            if (Prcb->CpuID == 0) {
                KeProcessorRevision = 0xFF00 |
                                      ((Prcb->CpuStep >> 8) + 'A') |
                                      (Prcb->CpuStep & 0xf);
            } else {
                KeProcessorRevision = Prcb->CpuStep;
            }
        }

        //
        // Use subset of all NT feature bits available on each processor
        //

        KeFeatureBits &= FeatureBits;

        //
        // Lower IRQL to DISPATCH level.
        //

        KeLowerIrql(DISPATCH_LEVEL);

#endif

    }

    //
    // Update processor features
    //

    SharedUserData->ProcessorFeatures[PF_MMX_INSTRUCTIONS_AVAILABLE] =
        (KeFeatureBits & KF_MMX) ? TRUE : FALSE;

    SharedUserData->ProcessorFeatures[PF_COMPARE_EXCHANGE_DOUBLE] =
        (KeFeatureBits & KF_CMPXCHG8B) ? TRUE : FALSE;

    SharedUserData->ProcessorFeatures[PF_XMMI_INSTRUCTIONS_AVAILABLE] =
        ((KeFeatureBits & KF_FXSR) && (KeFeatureBits & KF_XMMI)) ? TRUE : FALSE;

    SharedUserData->ProcessorFeatures[PF_XMMI64_INSTRUCTIONS_AVAILABLE] =
        ((KeFeatureBits & KF_FXSR) && (KeFeatureBits & KF_XMMI64)) ? TRUE : FALSE;

    SharedUserData->ProcessorFeatures[PF_3DNOW_INSTRUCTIONS_AVAILABLE] =
        (KeFeatureBits & KF_3DNOW) ? TRUE : FALSE;

    SharedUserData->ProcessorFeatures[PF_RDTSC_INSTRUCTION_AVAILABLE] =
        (KeFeatureBits & KF_RDTSC) ? TRUE : FALSE;

    //
    // Initialize idle thread object and then set:
    //
    //      1. the initial kernel stack to the specified idle stack.
    //      2. the next processor number to the specified processor.
    //      3. the thread priority to the highest possible value.
    //      4. the state of the thread to running.
    //      5. the thread affinity to the specified processor.
    //      6. the specified processor member in the process active processors
    //          set.
    //

    KeInitializeThread(Thread, (PVOID)((ULONG)IdleStack),
                       (PKSYSTEM_ROUTINE)NULL, (PKSTART_ROUTINE)NULL,
                       (PVOID)NULL, (PCONTEXT)NULL, (PVOID)NULL, Process);
    Thread->NextProcessor = Number;
    Thread->Priority = HIGH_PRIORITY;
    Thread->State = Running;
    Thread->Affinity = (KAFFINITY)(1<<Number);
    Thread->WaitIrql = DISPATCH_LEVEL;
    SetMember(Number, Process->ActiveProcessors);

    //
    // Initialize the processor block. (Note that some fields have been
    // initialized at KiInitializePcr().
    //

    Prcb->CurrentThread = Thread;
    Prcb->NextThread = (PKTHREAD)NULL;
    Prcb->IdleThread = Thread;

    //
    // call the executive initialization routine.
    //

    try {
        ExpInitializeExecutive(Number, LoaderBlock);

    } except(KeBugCheckEx(PHASE0_EXCEPTION,
                          (ULONG)GetExceptionCode(),
                          (ULONG_PTR)GetExceptionInformation(),
                          0,0), EXCEPTION_EXECUTE_HANDLER) {
        ; // should never get here
    }

    //
    // If the initial processor is being initialized, then compute the
    // timer table reciprocal value and reset the PRCB values for the
    // controllable DPC behavior in order to reflect any registry
    // overrides.
    //

    if (Number == 0) {
        KiTimeIncrementReciprocal = KeComputeReciprocal((LONG)KeMaximumIncrement,
                                                        &KiTimeIncrementShiftCount);

        Prcb->MaximumDpcQueueDepth = KiMaximumDpcQueueDepth;
        Prcb->MinimumDpcRate = KiMinimumDpcRate;
        Prcb->AdjustDpcThreshold = KiAdjustDpcThreshold;

        //
        // Processor 0's DPC stack was temporarily allocated on
        // the Double Fault Stack, switch to a proper kernel
        // stack now.
        //

        DpcStack = MmCreateKernelStack(FALSE, 0);
        if (DpcStack == NULL) {
            KeBugCheckEx(NO_PAGES_AVAILABLE, 1, 0, 0, 0);
        }

        Prcb->DpcStack = DpcStack;

        //
        // Allocate 8k IOPM bit map saved area to allow BiosCall swap
        // bit maps.
        //

        Ki386IopmSaveArea = ExAllocatePoolWithTag(PagedPool,
                                                  PAGE_SIZE * 2,
                                                  '  eK');
        if (Ki386IopmSaveArea == NULL) {
            KeBugCheckEx(NO_PAGES_AVAILABLE, 2, PAGE_SIZE * 2, 0, 0);
        }
    }

    //
    // Set the priority of the specified idle thread to zero, set appropriate
    // member in KiIdleSummary and return to the system start up routine.
    //

    KeRaiseIrql(DISPATCH_LEVEL, &OldIrql);
    KeSetPriorityThread(Thread, (KPRIORITY)0);

    //
    // if a thread has not been selected to run on the current processors,
    // check to see if there are any ready threads; otherwise add this
    // processors to the IdleSummary
    //

    KiAcquirePrcbLock(Prcb);
    if (Prcb->NextThread == NULL) {
        SetMember(Number, KiIdleSummary);
    }

    KiReleasePrcbLock(Prcb);
    KeRaiseIrql(HIGH_LEVEL, &OldIrql);

    //
    // This processor has initialized
    //

    LoaderBlock->Prcb = (ULONG)NULL;
    return;
}

VOID
KiInitializePcr (
    IN ULONG Processor,
    IN PKPCR    Pcr,
    IN PKIDTENTRY Idt,
    IN PKGDTENTRY Gdt,
    IN PKTSS Tss,
    IN PKTHREAD Thread,
    IN PVOID DpcStack
    )

/*++

Routine Description:

    This function is called to initialize the PCR for a processor.  It
    simply stuffs values into the PCR.  (The PCR is not initialized statically
    because the number varies with the number of processors.)

    Note that each processor has its own IDT, GDT, and TSS as well as PCR!

Arguments:

    Processor - Processor whose PCR to initialize.

    Pcr - Linear address of PCR.

    Idt - Linear address of i386 IDT.

    Gdt - Linear address of i386 GDT.

    Tss - Linear address (NOT SELECTOR!) of the i386 TSS.

    Thread - Dummy thread object to use very early on.

Return Value:

    None.

--*/

{

    //
    // set version values
    //

    Pcr->MajorVersion = PCR_MAJOR_VERSION;
    Pcr->MinorVersion = PCR_MINOR_VERSION;
    Pcr->PrcbData.MajorVersion = PRCB_MAJOR_VERSION;
    Pcr->PrcbData.MinorVersion = PRCB_MINOR_VERSION;
    Pcr->PrcbData.BuildType = 0;

#if DBG

    Pcr->PrcbData.BuildType |= PRCB_BUILD_DEBUG;

#endif

#ifdef NT_UP

    Pcr->PrcbData.BuildType |= PRCB_BUILD_UNIPROCESSOR;

#endif

#if defined (_X86PAE_)

    if (Processor == 0) {

        //
        //  PAE feature must be initialized prior to the first HAL call.
        //

        SharedUserData->ProcessorFeatures[PF_PAE_ENABLED] = TRUE;
    }

#endif

    //
    //  Basic addressing fields
    //

    Pcr->SelfPcr = Pcr;
    Pcr->Prcb = &(Pcr->PrcbData);

    //
    //  Thread control fields
    //

    Pcr->NtTib.ExceptionList = EXCEPTION_CHAIN_END;
    Pcr->NtTib.StackBase = NULL;
    Pcr->PerfGlobalGroupMask = NULL;
    Pcr->NtTib.Self = NULL;
    Pcr->PrcbData.CurrentThread = Thread;

    //
    // Init Prcb.Number and ProcessorBlock such that Ipi will work
    // as early as possible.
    //

    Pcr->PrcbData.Number = (UCHAR)Processor;
    Pcr->PrcbData.SetMember = 1 << Processor;
    KiProcessorBlock[Processor] = Pcr->Prcb;
    Pcr->Irql = 0;

    //
    //  Machine structure addresses
    //

    Pcr->GDT = Gdt;
    Pcr->IDT = Idt;
    Pcr->TSS = Tss;
    Pcr->TssCopy = Tss;
    Pcr->PrcbData.DpcStack = DpcStack;

    //
    // Initially, set this processor as only member of SMT set.
    //

    Pcr->PrcbData.MultiThreadProcessorSet = Pcr->PrcbData.SetMember;
    return;
}

VOID
KiInitializeTSS (
    IN PKTSS Tss
    )

/*++

Routine Description:

    This function is called to initialize the TSS for a processor.
    It will set the static fields of the TSS.  (ie Those fields that
    the part reads, and for which NT uses constant values.)

    The dynamic fields (Esp0 and CR3) are set in the context swap
    code.

Arguments:

    Tss - Linear address of the Task State Segment.

Return Value:

    None.

--*/

{

    //
    //  Set IO Map base address to indicate no IO map present.
    //
    // N.B. -1 does not seem to be a valid value for the map base.  If this
    //      value is used, byte immediate in's and out's will actually go
    //      the hardware when executed in V86 mode.

    Tss->IoMapBase = KiComputeIopmOffset(IO_ACCESS_MAP_NONE);

    //
    //  Set flags to 0, which in particular disables traps on task switches.
    //

    Tss->Flags = 0;

    //
    //  Set LDT and Ss0 to constants used by NT.
    //

    Tss->LDT = 0;
    Tss->Ss0 = KGDT_R0_DATA;
    return;
}

VOID
KiInitializeTSS2 (
    IN PKTSS Tss,
    IN PKGDTENTRY TssDescriptor
    )

/*++

Routine Description:

    Do part of TSS init we do only once.

Arguments:

    Tss - Linear address of the Task State Segment.

    TssDescriptor - Linear address of the descriptor for the TSS.

Return Value:

    None.

--*/

{

    PUCHAR  p;
    ULONG   i;
    ULONG   j;

    //
    // Set limit for TSS
    //

    if (TssDescriptor != NULL) {
        TssDescriptor->LimitLow = sizeof(KTSS) - 1;
        TssDescriptor->HighWord.Bits.LimitHi = 0;
    }

    //
    // Initialize IOPMs
    //

    for (i = 0; i < IOPM_COUNT; i++) {
        p = (PUCHAR)(Tss->IoMaps[i].IoMap);

        for (j = 0; j < PIOPM_SIZE; j++) {
            p[j] = (UCHAR)-1;
        }
    }

    //
    // Initialize Software Interrupt Direction Maps
    //

    for (i = 0; i < IOPM_COUNT; i++) {
        p = (PUCHAR)(Tss->IoMaps[i].DirectionMap);
        for (j = 0; j < INT_DIRECTION_MAP_SIZE; j++) {
            p[j] = 0;
        }
        // dpmi requires special case for int 2, 1b, 1c, 23, 24
        p[0] = 4;
        p[3] = 0x18;
        p[4] = 0x18;
    }

    //
    // Initialize the map for IO_ACCESS_MAP_NONE
    //

    p = (PUCHAR)(Tss->IntDirectionMap);
    for (j = 0; j < INT_DIRECTION_MAP_SIZE; j++) {
        p[j] = 0;
    }

    //
    // dpmi requires special case for int 2, 1b, 1c, 23, 24
    //

    p[0] = 4;
    p[3] = 0x18;
    p[4] = 0x18;

    return;
}

VOID
KiSwapIDT (
    VOID
    )

/*++

Routine Description:

    This function is called to edit the IDT.  It swaps words of the address
    and access fields around into the format the part actually needs.
    This allows for easy static init of the IDT.

    Note that this procedure edits the current IDT.

Arguments:

    None.

Return Value:

    None.

--*/

{

    LONG    Index;
    USHORT Temp;

    //
    // Rearrange the entries of IDT to match i386 interrupt gate structure
    //

    for (Index = 0; Index <= MAXIMUM_IDTVECTOR; Index += 1) {
        Temp = IDT[Index].Selector;
        IDT[Index].Selector = IDT[Index].ExtendedOffset;
        IDT[Index].ExtendedOffset = Temp;
    }
}

ULONG
KiGetCpuVendor (
    VOID
    )

/*++

Routine Description:

    (Try to) Determine the manufacturer of this processor based on
    data returned by the CPUID instruction (if present).

Arguments:

    None.

Return Value:

    One of the members of the enumeration CPU_VENDORS (defined above).

--*/

{

    PKPRCB Prcb;
    ULONG  Junk;
    ULONG  Buffer[4];

    Prcb = KeGetCurrentPrcb();
    Prcb->VendorString[0] = 0;

    if (!Prcb->CpuID) {
        return CPU_NONE;
    }

    CPUID(0, &Junk, Buffer+0, Buffer+2, Buffer+1);
    Buffer[3] = 0;

    //
    // Copy vendor string to Prcb for debugging (ensure it's NULL
    // terminated).
    //

    RtlCopyMemory(
        Prcb->VendorString,
        Buffer,
        sizeof(Prcb->VendorString) - 1);

    Prcb->VendorString[sizeof(Prcb->VendorString) - 1] = '\0';
    if (strcmp((PCHAR)Buffer, CmpIntelID) == 0) {
        return CPU_INTEL;

    } else if (strcmp((PCHAR)Buffer, CmpAmdID) == 0) {
        return CPU_AMD;

    } else if (strcmp((PCHAR)Buffer, CmpCyrixID) == 0) {
        return CPU_CYRIX;

    } else if (strcmp((PCHAR)Buffer, CmpTransmetaID) == 0) {
        return CPU_TRANSMETA;

    } else if (strcmp((PCHAR)Buffer, CmpCentaurID) == 0) {
        return CPU_CENTAUR;

    } else if (strcmp((PCHAR)Buffer, CmpRiseID) == 0) {
        return CPU_RISE;
    }

    return CPU_UNKNOWN;
}

ULONG
KiGetFeatureBits (
    VOID
    )

/*++

Routine Description:

    Examine the processor specific feature bits to determine the
    Windows supported features supported by this processor.

Arguments:

    None.

Return Value:

    Returns a Windows normalized set of processor features.

--*/

{

    ULONG           Junk;
    ULONG           Temp;
    ULONG           ProcessorFeatures;
    ULONG           NtBits;
    ULONG           ExtendedProcessorFeatures;
    ULONG           ProcessorSignature;
    ULONG           CpuVendor;
    PKPRCB          Prcb;
    BOOLEAN         ExtendedCPUIDSupport = TRUE;

    Prcb = KeGetCurrentPrcb();
    NtBits = KF_WORKING_PTE;

    //
    // Determine the processor type
    //

    CpuVendor = KiGetCpuVendor();

    //
    // If this processor does not support the CPUID instruction,
    // don't try to use it.
    //

    if (CpuVendor == CPU_NONE) {
        return NtBits;
    }

    //
    // Determine which NT compatible features are present
    //

    CPUID (1, &ProcessorSignature, &Temp, &Junk, &ProcessorFeatures);

    //
    // CPUID(1) now returns information in EBX.  On the grounds that
    // the low functions are supposed to be standard, we record the
    // information regardless of processor vendor even though it may
    // be 0 or undefined on older implementations.
    //

    Prcb->InitialApicId = (UCHAR)(Temp >> 24);

    //
    // AMD specific stuff
    //

    if (CpuVendor == CPU_AMD) {

        //
        // Check for K5 and above.
        //

        if ((ProcessorSignature & 0x0F00) >= 0x0500) {

            if ((ProcessorSignature & 0x0F00) == 0x0500) {

                switch (ProcessorSignature & 0x00F0) {

                case 0x0010: // K5 Model 1

                    //
                    // for K5 Model 1 stepping 0 or 1 don't set global page
                    //

                    if ((ProcessorSignature & 0x000F) > 0x03) {

                        //
                        // K5 Model 1 stepping 2 or greater
                        //

                        break;
                    }

                    //
                    // K5 Model 1 stepping 0 or 1, FALL THRU.
                    //

                case 0x0000:        // K5 Model 0

                    //
                    // for K5 Model 0 or model unknown don't set global page
                    //

                    ProcessorFeatures &= ~0x2000;
                    break;

                case 0x0080:        // K6 Model 8 (K6-2)

                    //
                    // All steppings >= 8 support MTRRs.
                    //

                    if ((ProcessorSignature & 0x000F) >= 0x8) {
                        NtBits |= KF_AMDK6MTRR;
                    }
                    break;

                case 0x0090:        // K6 Model 9 (K6-3)

                    NtBits |= KF_AMDK6MTRR;
                    break;

                default:            // anything else, nothing to do.

                    break;
                }
            }

        } else {

            //
            // Less than family 5, don't set GLOBAL PAGE, LARGE
            // PAGE or CMOV.  (greater than family 5 will have the
            // bits set correctly).
            //

            ProcessorFeatures &= ~(0x08 | 0x2000 | 0x8000);

            //
            // We don't know what this processor returns if we
            // probe for extended CPUID support.
            //

            ExtendedCPUIDSupport = FALSE;
        }
    }

    //
    // Intel specific stuff
    //

    if (CpuVendor == CPU_INTEL) {
        if (Prcb->CpuType >= 6) {
            WRMSR (0x8B, 0);
            CPUID (1, &Junk, &Junk, &Junk, &ProcessorFeatures);
            Prcb->UpdateSignature.QuadPart = RDMSR (0x8B);
        }

        else if (Prcb->CpuType == 5) {
            KiI386PentiumLockErrataPresent = TRUE;
        }

        if ( ((ProcessorSignature & 0x0FF0) == 0x0610 &&
              (ProcessorSignature & 0x000F) <= 0x9) ||

             ((ProcessorSignature & 0x0FF0) == 0x0630 &&
              (ProcessorSignature & 0x000F) <= 0x4)) {

            //
            // If the boot processor has PII spec A27 errata (also present in
            // early Pentium Pro chips), then use only one processor to avoid
            // unpredictable eflags corruption.
            //

            NtBits &= ~KF_WORKING_PTE;
        }

        //
        // Don't support prior attempts at implementing syscall/sysexit
        // instructions.
        //

        if ((Prcb->CpuType < 6) ||
            ((Prcb->CpuType == 6) && (Prcb->CpuStep < 0x0303))) {

            ProcessorFeatures &= ~KI_FAST_SYSCALL_SUPPORTED;
        }
    }

    //
    // Cyrix specific stuff
    //

    if (CpuVendor == CPU_CYRIX) {

        //
        // Workaround problem caused by INTR being
        // held high too long during an FP instruction and causing
        // random Trap07 with no exception bits.
        //

        extern BOOLEAN KiIgnoreUnexpectedTrap07;

        KiIgnoreUnexpectedTrap07 = TRUE;

        //
        // Workaround CMPXCHG bug to Cyrix processors where
        // Family = 6, Model = 0, Stepping <= 1.  Note that
        // Prcb->CpuStep contains both model and stepping.
        //
        // Disable Locking in one of processor specific registers
        // (accessible via i/o space index/data pair).
        //

        if ((Prcb->CpuType == 6) &&
            (Prcb->CpuStep <= 1)) {

            #define CRC_NDX (PUCHAR)0x22
            #define CRC_DAT (CRC_NDX + 1)
            #define CCR1    0xc1

            UCHAR ValueCCR1;

            //
            // Get current setting.
            //

            WRITE_PORT_UCHAR(CRC_NDX, CCR1);

            ValueCCR1 = READ_PORT_UCHAR(CRC_DAT);

            //
            // Set the NO_LOCK bit and write it back.
            //

            ValueCCR1 |= 0x10;

            WRITE_PORT_UCHAR(CRC_NDX, CCR1);
            WRITE_PORT_UCHAR(CRC_DAT, ValueCCR1);

            #undef CCR1
            #undef CRC_DAT
            #undef CRC_NDX
        }
    }

    //
    // Check the standard CPUID feature bits.
    //
    // The following bits are known to work on Intel, AMD and Cyrix.
    // We hope (and assume) the clone makers will follow suit.
    //

    if (ProcessorFeatures & 0x00000002) {
        NtBits |= KF_V86_VIS | KF_CR4;
    }

    if (ProcessorFeatures & 0x00000008) {
        NtBits |= KF_LARGE_PAGE | KF_CR4;
    }

    if (ProcessorFeatures & 0x00000010) {
        NtBits |= KF_RDTSC;
    }

    //
    // N.B. CMPXCHG8B MUST be done in a generic manner or clone processors
    // will not be able to boot if they set this feature bit.
    //
    // This was incorrect in NT4 and resulted processor vendors claiming
    // not to support cmpxchg8b even if they did.   Windows XP requires
    // cmpxchg8b, work around this problems for the cases we know about.
    //
    // Because cmpxchg8b is a requirement for Windows XP, winnt32 needs to
    // be modified if new processors are added to the following list.
    // Also, setupldr.   Both executables were modified so as to warn
    // the user rather than installing an unbootable system.
    //

    if ((ProcessorFeatures & 0x00000100) == 0) {

        ULONGLONG MsrValue;

        if ((CpuVendor == CPU_TRANSMETA) &&
            (Prcb->CpuType >= 5)         &&
            (Prcb->CpuStep >= 0x402)) {

            //
            // Transmeta processors have a cpuid feature bit 'mask' in
            // msr 80860004.   Unmask the cmpxchg8b bit.
            //

            MsrValue = RDMSR(0x80860004);
            MsrValue |= 0x100;
            WRMSR(0x80860004, MsrValue);

            ProcessorFeatures |= 0x100;

        } else if ((CpuVendor == CPU_CENTAUR) &&
                   (Prcb->CpuType >= 5)) {

            //
            // Centaur/IDT processors turn on the cmpxchg8b
            // feature bit by setting bit 1 in MSR 107.
            //

            ULONG CentaurFeatureControlMSR = 0x107;
            ULONGLONG FeatureMask = 0xFFFFFFFFFFFFFFFFUI64;

            if (Prcb->CpuType >= 6) {

                //
                // Centaur processors (Cyrix III) turn on the cmpxchg8b
                // feature bit by setting bit 1 in MSR 1107.
                //
                // Disable bit 0 which controls the Cyrix ALTINST feature.
                //
            
                CentaurFeatureControlMSR = 0x1107;
                FeatureMask = 0xFFFFFFFFFFFFFFFEUI64;
            }

            MsrValue = RDMSR(CentaurFeatureControlMSR);
            MsrValue |= 2;
            MsrValue &= FeatureMask;
            WRMSR(CentaurFeatureControlMSR, MsrValue);

            ProcessorFeatures |= 0x100;
        
        } else if (CpuVendor == CPU_RISE) {

            //
            // Embedded x86 processor from Rise.  This processor
            // doesn't have a mechanism to turn on this feature bit
            // but does have the functionality.  Act as if we saw the
            // feature bit.
            //

            ProcessorFeatures |= 0x100;
        }
    }

    if (ProcessorFeatures & 0x00000100) {
        NtBits |= KF_CMPXCHG8B;
    }

    if (ProcessorFeatures & KI_FAST_SYSCALL_SUPPORTED) {
        NtBits |= KF_FAST_SYSCALL;
        KiFastSystemCallIsIA32 = TRUE;
    }

    if (ProcessorFeatures & 0x00001000) {
        NtBits |= KF_MTRR;
    }

    if (ProcessorFeatures & 0x00002000) {
        NtBits |= KF_GLOBAL_PAGE | KF_CR4;
    }

    if (ProcessorFeatures & 0x00008000) {
        NtBits |= KF_CMOV;
    }

    if (ProcessorFeatures & 0x00010000) {
        NtBits |= KF_PAT;
    }

    if (ProcessorFeatures & 0x00200000) {
        NtBits |= KF_DTS;
    }

    if (ProcessorFeatures & 0x00800000) {
        NtBits |= KF_MMX;
    }

    if (ProcessorFeatures & 0x01000000) {
        NtBits |= KF_FXSR;
    }

    if (ProcessorFeatures & 0x02000000) {
        NtBits |= KF_XMMI;
    }

    if (ProcessorFeatures & 0x04000000) {
        NtBits |= KF_XMMI64;
    }

    //
    // Test for SMT and determine the number of logical processors the
    // underlying physical processor supports.  
    //

    if (ProcessorFeatures & 0x10000000) {
        Prcb->LogicalProcessorsPerPhysicalProcessor = (UCHAR)(Temp >> 16);
        if (Prcb->LogicalProcessorsPerPhysicalProcessor > 1) {
            KiSMTProcessorsPresent = TRUE;

        } else {
            Prcb->LogicalProcessorsPerPhysicalProcessor = 1;
        }

    } else {
        Prcb->LogicalProcessorsPerPhysicalProcessor = 1;
    }

    //
    // Check extended functions.   First, check for existence,
    // then check extended function 0x80000001 (Extended Processor
    // Features) if present.
    //
    // Note: Intel guarantees that no processor that doesn't support
    // extended CPUID functions will ever return a value with the
    // most significant bit set.   Microsoft asks all CPU vendors
    // to make the same guarantee.
    //

    if (ExtendedCPUIDSupport != FALSE) {

        CPUID(0x80000000, &Temp, &Junk, &Junk, &Junk);

        //
        // Sanity check the result, assuming there are no more
        // than 256 extended feature functions (should be valid
        // for a little while).
        //

        if ((Temp & 0xffffff00) == 0x80000000) {

            //
            // Check extended processor features.  These, by definition,
            // can vary on a processor by processor basis.
            //

            if (Temp >= 0x80000001) {

                CPUID(0x80000001, &Temp, &Junk, &Junk, &ExtendedProcessorFeatures);

                //
                // Check if no execute protection supported.
                //

                if (ExtendedProcessorFeatures & 0x00100000) {
                    NtBits |= KF_NOEXECUTE;
                }

                //
                // With these, we can only do what we're told.
                //

                switch (CpuVendor) {
                case CPU_AMD:

                    if (ExtendedProcessorFeatures & 0x80000000) {
                        NtBits |= KF_3DNOW;
                    }

                    //
                    // If the host processor supports no execute protection,
                    // then it is a K8 chip and it also supports 40-bits of
                    // physical address. For this case the MTRR register
                    // variables must be initialized to support 40-bits of
                    // physical memory.
                    //

                    if (ExtendedProcessorFeatures & 0x00100000) {
                        KiMtrrMaskBase = 0x000000fffffff000;
                        KiMtrrMaskMask = 0x000000fffffff000;
                        KiMtrrOverflowMask = (~0x10000000000);
                        KiMtrrResBitMask = 0xffffffffff;
                        KiMtrrMaxRangeShift = 40;
                    }

                    break;
                }
            }
        }
    }

    return NtBits;
}

VOID
KiGetCacheInformation (
    VOID
    )
{

#define CPUID_REG_COUNT 4

    ULONG CpuidData[CPUID_REG_COUNT];
    ULONG Line = 64;
    ULONG Size = 0;
    ULONG AdjustedSize = 0;
    UCHAR Assoc = 0;
    ULONG CpuVendor;
    PKPCR Pcr;

    //
    // Set default.
    //

    Pcr = KeGetPcr();
    Pcr->SecondLevelCacheSize = 0;

    //
    // Determine the processor manufacturer
    //

    CpuVendor = KiGetCpuVendor();
    if (CpuVendor == CPU_NONE) {
        return;
    }

    //
    // Obtain Cache size information for those processors on which
    // we know how.
    //

    switch (CpuVendor) {
    case CPU_INTEL:

        CPUID(0, CpuidData, CpuidData+1, CpuidData+2, CpuidData+3);

        //
        // Check this processor supports CPUID function 2 which is the
        // one that returns cache size info.
        //

        if (CpuidData[0] >= 2) {

            //
            // The above returns a series of bytes.    (In EAX, EBX, ECX
            // and EDX).   The least significant byte (of EAX) gives the
            // number of times CPUID(2 ...) should be issued to return
            // the complete set of data.   The bytes are self describing
            // data.
            //
            // In particular, the bytes describing the L2 cache size
            // will be in the following set (and meaning)
            //
            // 0x40       0  bytes
            // 0x41     128K bytes
            // 0x42     256K bytes
            // 0x43     512K bytes
            // 0x44    1024K bytes
            // 0x45    2048K bytes
            // 0x46    4096K bytes
            //
            // I am extrapolating the above as anything in the range
            // 0x41 thru 0x4f can be computed as
            //
            //   128KB << (descriptor - 0x41)
            //
            // The Intel folks say keep it to a reasonable upper bound,
            // eg 49.
            //
            // N.B. the range 0x80 .. 0x85 indicates the same cache
            // sizes but 8 way associative.
            //
            // Also, the most significant bit of each register indicates
            // whether not the register contains valid information.
            // 0 == Valid, 1 == InValid.
            //

            ULONG CpuidIterations = 0;      // satisfy no_opt compilation
            ULONG i;
            ULONG CpuidReg;

            BOOLEAN FirstPass = TRUE;

            do {
                CPUID(2, CpuidData, CpuidData+1, CpuidData+2, CpuidData+3);

                if (FirstPass) {

                    //
                    // Get the iteration count from the first byte
                    // of the returned data then replace that byte
                    // with 0 (a null descriptor).
                    //

                    CpuidIterations = CpuidData[0] & 0xff;
                    CpuidData[0] &= 0xffffff00;

                    FirstPass = FALSE;
                }

                for (i = 0; i < CPUID_REG_COUNT; i++) {

                    CpuidReg = CpuidData[i];

                    if (CpuidReg & 0x80000000) {

                        //
                        // Register doesn't contain valid data,
                        // skip it.
                        //

                        continue;
                    }

                    while (CpuidReg) {

                        //
                        // Get LS Byte from this DWORD and remove the
                        // byte.
                        //

                        UCHAR Descriptor = (UCHAR)(CpuidReg & 0xff);
                        CpuidReg >>= 8;

                        if (Descriptor == 0) {

                            //
                            // NULL descriptor
                            //

                            continue;
                        }

                        if (((Descriptor > 0x40) && (Descriptor <= 0x47)) ||
                            ((Descriptor > 0x78) && (Descriptor <= 0x7c)) ||
                            ((Descriptor > 0x80) && (Descriptor <= 0x85))) {

                            //
                            // L2 descriptor.
                            //
                            // To date, for most of the descriptors we know
                            // about those above 0x78 are 8 way and those
                            // below are 4 way.  The others will be special
                            // cased below.
                            //

                            Assoc = Descriptor >= 0x79 ? 8 : 4;

                            if (((Descriptor & 0xf8) == 0x78) &&
                                (Line < 128)) {
                                Line = 128;
                            }
                            Descriptor &= 0x07;

                            //
                            // There may be cache descriptors in this
                            // range that we don't understand
                            // accurately yet.
                            //

                            Size = 0x10000 << Descriptor;
                            if ((Size / Assoc) > AdjustedSize) {
                                AdjustedSize = Size / Assoc;
                                Pcr->SecondLevelCacheSize = Size;
                                Pcr->SecondLevelCacheAssociativity = Assoc;
                            }

                        } else if ((Descriptor > 0x21) && (Descriptor <= 0x29)) {
                            if (Line < 128) {
                                Line = 128;
                            }
                            Assoc = 8;
                            switch (Descriptor) {
                            case 0x22:
                                Size = 512 * 1024;
                                Assoc = 4;
                                break;
                            case 0x23:
                                Size = 1024 * 1024;
                                break;
                            case 0x25:
                                Size = 2048 * 1024;
                                break;
                            case 0x29:
                                Size = 4096 * 1024;
                                break;
                            default:
                                Size = 0;
                                break;
                            }
                            if ((Size / Assoc) > AdjustedSize) {
                                AdjustedSize = Size / Assoc;
                                Pcr->SecondLevelCacheSize = Size;
                                Pcr->SecondLevelCacheAssociativity = Assoc;
                            }
                        } else if (((Descriptor > 0x65) && (Descriptor < 0x69)) ||
                                   (Descriptor == 0x2C) ||
                                   (Descriptor == 0xF0)) {

                            //
                            // L1 Descriptor with line size of 64
                            // bytes or an explicit prefetch
                            // descriptor indicating 64 bytes.
                            //

                            KePrefetchNTAGranularity = 64;

                        } else if (Descriptor == 0xF1) {

                            //
                            // Explicit prefetch descriptor indicating
                            // 128 bytes.
                            //

                            KePrefetchNTAGranularity = 128;

                        } else if (
                             ((Descriptor >= 0x4A) && (Descriptor <= 0x4C)) ||
                             (Descriptor == 0x78) ||
                             (Descriptor == 0x7D) || (Descriptor == 0x7F) ||
                             (Descriptor == 0x86) || (Descriptor == 0x87)
                            ) {

                            //
                            // These are the 64 byte cache line entries for L2
                            // caches that do not fit the pattern described
                            // above.
                            //

                            if (Line < 64) {
                                Line = 64;
                            }

                            switch (Descriptor) {

                            case 0x4A:
                                Size = 4 * 1024 * 1024;
                                Assoc = 8;
                                break;

                            case 0x4B:
                                Size = 6 * 1024 * 1024;
                                Assoc = 12;
                                break;

                            case 0x4C:
                                Size = 8 * 1024 * 1024;
                                Assoc = 16;
                                break;

                            case 0x78:
                                Size = 1 * 1024 * 1024;
                                Assoc = 4;
                                break;

                            case 0x7D:
                                Size = 2 * 1024 * 1024;
                                Assoc = 8;
                                break;

                            case 0x7F:
                                Size = 512 * 1024;
                                Assoc = 2;
                                break;

                            case 0x86:
                                Size = 512 * 1024;
                                Assoc = 4;
                                break;

                            case 0x87:
                                Size = 1 * 1024 * 1024;
                                Assoc = 8;
                                break;

                            }

                            if ((Size / Assoc) > AdjustedSize) {
                                AdjustedSize = Size / Assoc;
                                Pcr->SecondLevelCacheSize = Size;
                                Pcr->SecondLevelCacheAssociativity = Assoc;
                            }
                        }

                        //
                        // else if (do other descriptors)
                        //

                    } // while more bytes in this register

                } // for each register

                //
                // Note: Always run thru all iterations indicated by
                // the first to ensure a subsequent call won't start
                // part way thru.
                //

            } while (--CpuidIterations);
        }

        break;

    case CPU_AMD:

        //
        // Get L1 Cache Data.
        //

        CPUID(0x80000000, CpuidData, CpuidData+1, CpuidData+2, CpuidData+3);
        if (CpuidData[0] < 0x80000005) {

            //
            // This processor doesn't support L1 cache details.
            //

            break;
        }

        CPUID(0x80000005, CpuidData, CpuidData+1, CpuidData+2, CpuidData+3);
        KePrefetchNTAGranularity = CpuidData[2] & 0xff;

        //
        // Get L2 data.
        //

        CPUID(0x80000000, CpuidData, CpuidData+1, CpuidData+2, CpuidData+3);
        if (CpuidData[0] < 0x80000006) {

            //
            // This processor doesn't support L2 cache details.
            //

            break;
        }

        CPUID(0x80000006, CpuidData, CpuidData+1, CpuidData+2, CpuidData+3);
        Line = CpuidData[2] & 0xff;
        switch ((CpuidData[2] >> 12) & 0xf) {
        case 0x2:   Assoc = 2;  break;
        case 0x4:   Assoc = 4;  break;
        case 0x6:   Assoc = 8;  break;
        case 0x8:   Assoc = 16; break;

        //
        // ff is really fully associative, just represent as 16 way.
        //
        case 0xf:  Assoc = 16; break;
        default:    Assoc = 1;  break;
        }

        Size = (CpuidData[2] >> 16) << 10;
        if ((Pcr->PrcbData.CpuType == 0x6) &&
            (Pcr->PrcbData.CpuStep == 0x300)) {

            //
            // Model 6,3,0 uses a different algorithm to report cache
            // size.
            //

            Size = 64 * 1024;
        }

        Pcr->SecondLevelCacheAssociativity = Assoc;
        Pcr->SecondLevelCacheSize = Size;
        break;
    }

    if (Line > KeLargestCacheLine) {
        KeLargestCacheLine = Line;
    }

#undef CPUID_REG_COUNT

}

#define MAX_ATTEMPTS 10

VOID
KiLockStepProcessor (
    PKIPI_CONTEXT SignalDone,
    IN PVOID Arg1,
    IN PVOID Arg2,
    IN PVOID Proceed
    )

{

    UNREFERENCED_PARAMETER(Arg1);
    UNREFERENCED_PARAMETER(Arg2);

    //
    // Tell initiating processor that this processor is now waiting
    // and wait until the initial processor signals this processor
    // to continue.
    //

    KiIpiSignalPacketDoneAndStall(SignalDone, Proceed);
}

VOID
KiLockStepOtherProcessors (
    PULONG Proceed
    )

{

    PKPRCB Prcb;
    KAFFINITY TargetProcessors;

    ASSERT(KeGetCurrentIrql() >= DISPATCH_LEVEL);

    Prcb = KeGetCurrentPrcb();
    TargetProcessors = KeActiveProcessors & ~Prcb->SetMember;
    if (TargetProcessors != 0) {
        KeAcquireSpinLockAtDpcLevel (&KiReverseStallIpiLock);
        KiIpiSendSynchronousPacket(Prcb,
                                   TargetProcessors,
                                   KiLockStepProcessor,
                                   NULL,
                                   NULL,
                                   Proceed);
        KiIpiStallOnPacketTargets(TargetProcessors);
        KeReleaseSpinLockFromDpcLevel (&KiReverseStallIpiLock);
    }
}

VOID
KiUnlockStepOtherProcessors(
    PULONG Proceed
    )

{
    (*Proceed) += 1;
}


BOOLEAN
KiInitMachineDependent (
    VOID
    )

{

    PKPRCB Prcb;
    KAFFINITY       ActiveProcessors, CurrentAffinity;
    ULONG           NumberProcessors;
    IDENTITY_MAP    IdentityMap;
    ULONG           Index;
    ULONG           Average;
    ULONG           Junk;
    struct {
        LARGE_INTEGER   PerfStart;
        LARGE_INTEGER   PerfEnd;
        LONGLONG        PerfDelta;
        LARGE_INTEGER   PerfFreq;
        LONGLONG        TSCStart;
        LONGLONG        TSCEnd;
        LONGLONG        TSCDelta;
        ULONG           MHz;
    } Samples[MAX_ATTEMPTS], *pSamp;

#ifndef NT_UP

    PUCHAR          PatchLocation;

#endif

    Prcb = KeGetCurrentPrcb();


    //
    // If PDE large page is supported, enable it.
    //
    // We enable large pages before global pages to make TLB invalidation
    // easier while turning on large pages.
    //

    KiLargePageSafetyCheck();
    if (KeFeatureBits & KF_LARGE_PAGE) {
        if (Ki386CreateIdentityMap(&IdentityMap,
                                   (PVOID) (ULONG_PTR) &Ki386EnableCurrentLargePage,
                                   (PVOID) (ULONG_PTR) &Ki386EnableCurrentLargePageEnd )) {

            KeIpiGenericCall (
                (PKIPI_BROADCAST_WORKER) Ki386EnableTargetLargePage,
                (ULONG)(&IdentityMap)
            );
        }

        //
        // Always call Ki386ClearIdentityMap() to free any memory allocated
        //

        Ki386ClearIdentityMap(&IdentityMap);
    }

    //
    // If PDE/PTE global page is supported, enable it
    //

    if (KeFeatureBits & KF_GLOBAL_PAGE) {
        NumberProcessors = KeNumberProcessors;
        KeIpiGenericCall (
            (PKIPI_BROADCAST_WORKER) Ki386EnableGlobalPage,
            (ULONG)(&NumberProcessors)
        );
    }

    //
    // If PAT or MTRR supported but the HAL indicates it shouldn't
    // be used (eg on a Shared Memory Cluster), drop the feature.
    //

    if (KeFeatureBits & (KF_PAT | KF_MTRR)) {

        NTSTATUS Status;
        BOOLEAN  UseFrameBufferCaching;
        ULONG    Size;

        Status = HalQuerySystemInformation(
                     HalFrameBufferCachingInformation,
                     sizeof(UseFrameBufferCaching),
                     &UseFrameBufferCaching,
                     &Size
                     );

        if (NT_SUCCESS(Status) &&
            (UseFrameBufferCaching == FALSE)) {

            //
            // Hal says don't use.
            //

            KeFeatureBits &= ~(KF_PAT | KF_MTRR);
        }
    }

    //
    // If PAT is supported then initialize it.
    //

    if (KeFeatureBits & KF_PAT) {
        KiInitializePAT();
    }

    //
    // Check to see if the floating point emulator should be used.
    //

    SharedUserData->ProcessorFeatures[PF_FLOATING_POINT_PRECISION_ERRATA] =
            FALSE;

    switch (KeI386ForceNpxEmulation) {
    case 0:

        //
        // Use the emulator based on the value in KeI386NpxPresent
        //

        break;

    case 1:

        //
        // Only use the emulator if any processor has the known
        // Pentium floating point division problem.
        //

        if (KeI386NpxPresent) {

            //
            // A coprocessor is present, check to see if the precision
            // errata exists.
            //

            double  Dividend, Divisor;
            BOOLEAN PrecisionErrata = FALSE;

            ActiveProcessors = KeActiveProcessors;
            for (CurrentAffinity = 1; ActiveProcessors; CurrentAffinity <<= 1) {

                if (ActiveProcessors & CurrentAffinity) {
                    ActiveProcessors &= ~CurrentAffinity;

                    //
                    // Run calculation on each processor.
                    //

                    KeSetSystemAffinityThread(CurrentAffinity);
                    _asm {

                        ;
                        ; This is going to destroy the state in the coprocesssor,
                        ; but we know that there's no state currently in it.
                        ;

                        cli
                        mov     eax, cr0
                        mov     ecx, eax    ; hold original cr0 value
                        and     eax, not (CR0_TS+CR0_MP+CR0_EM)
                        mov     cr0, eax

                        fninit              ; to known state
                    }

                    Dividend = 4195835.0;
                    Divisor  = 3145727.0;

                    _asm {
                        fld     Dividend
                        fdiv    Divisor     ; test known faulty divison
                        fmul    Divisor     ; Multiple quotient by divisor
                        fcomp   Dividend    ; Compare product and dividend
                        fstsw   ax          ; Move float conditions to ax
                        sahf                ; move to eflags

                        mov     cr0, ecx    ; restore cr0
                        sti

                        jc      short em10
                        jz      short em20
em10:                   mov     PrecisionErrata, TRUE
em20:
                    }
                    if (PrecisionErrata) {
                        KeI386NpxPresent = FALSE;
                        SharedUserData->ProcessorFeatures[PF_FLOATING_POINT_PRECISION_ERRATA] = TRUE;
                        break;
                    }
                }
            }

        }

        break;

    default:

        //
        // Unknown setting - use the emulator
        //

        KeI386NpxPresent = FALSE;
        break;
    }

    //
    // Setup processor features, and install emulator if needed
    //

    SharedUserData->ProcessorFeatures[PF_FLOATING_POINT_EMULATED] =
            !KeI386NpxPresent;

    if (!KeI386NpxPresent) {

        //
        // MMx, fast save/restore, streaming SIMD not available when
        // emulator is used.  (Nor FP errata).
        //

        KeFeatureBits &= ~(KF_MMX | KF_FXSR | KF_XMMI | KF_XMMI64);
        KeI386XMMIPresent = FALSE;
        KeI386FxsrPresent = FALSE;

        SharedUserData->ProcessorFeatures[PF_MMX_INSTRUCTIONS_AVAILABLE]      =
        SharedUserData->ProcessorFeatures[PF_XMMI_INSTRUCTIONS_AVAILABLE]     =
        SharedUserData->ProcessorFeatures[PF_3DNOW_INSTRUCTIONS_AVAILABLE]    =
        SharedUserData->ProcessorFeatures[PF_XMMI64_INSTRUCTIONS_AVAILABLE]   =
        SharedUserData->ProcessorFeatures[PF_FLOATING_POINT_PRECISION_ERRATA] =
            FALSE;
    }

    //
    // If CR4 exists, enable DE extensions for IO breakpoints
    //

    if (KeFeatureBits & KF_CR4) {
        NumberProcessors = KeNumberProcessors;

        KeIpiGenericCall (
            (PKIPI_BROADCAST_WORKER) Ki386EnableDE,
            (ULONG)(&NumberProcessors)
        );
    }

    //
    // If FXSR feature is supported, set OSFXSR (bit 9) in CR4
    //

    if (KeFeatureBits & KF_FXSR) {
        NumberProcessors = KeNumberProcessors;

        KeIpiGenericCall (
            (PKIPI_BROADCAST_WORKER) Ki386EnableFxsr,
            (ULONG)(&NumberProcessors)
        );


        //
        // If XMMI feature is supported,
        //    a. Hook int 19 handler
        //    b. Set OSXMMEXCPT (bit 10) in CR4
        //    c. Enable use of fast XMMI based zero page routines.
        //    d. Remove return instruction at start of prefetch routine.
        //

        if (KeFeatureBits & KF_XMMI) {
            KeIpiGenericCall (
                (PKIPI_BROADCAST_WORKER) Ki386EnableXMMIExceptions,
                (ULONG)(&NumberProcessors)
            );

#if !defined(NT_UP)


#define XMMI_ZEROING_ALLOW_OVERRIDE                     1
#define XMMI_ZEROING_DISALLOW_OVERRIDE                  2


            //
            // Having XMMI Zeroing enabled if the processor supports it is good.
            // By default if the feature is present we will use it.
            //
            // We allow three sets of overrides to this however.
            // 1. disable use of XMMI Zeroing if explicitly configured via disable regkey.
            //  Purportedly, some pentium 3 based systems boot faster in this configuration.
            //
            // 2. Some Intel pentium 4 systems do not operate properly with this feature
            //  enabled.  These machines hit a livelock.  Thus by default, if your system
            //  is a pentium 4, this feature gets disabled.
            //
            // 3. Not all pentium 4 based systems have this livelock issue.  To enable these
            //  systems that work properly to take advantage of this feature, we allow an
            //  explicit enable registry key to be set.
            //
            if (KiXMMIZeroingEnable != XMMI_ZEROING_DISALLOW_OVERRIDE) {
                //
                // Enable non-temporal zeroing on all machines except MP
                // Pentium 4 machines.  Pentium 4 machines can explicitly
                // request this functionality via registry key.  This was
                // done to address a livelock issue.
                //

                if ((strcmp((PCHAR)Prcb->VendorString, CmpIntelID) != 0) ||
                    (Prcb->CpuType != 15) || (KiXMMIZeroingEnable == XMMI_ZEROING_ALLOW_OVERRIDE) )

#endif

                {
                    KeZeroPages = KiXMMIZeroPages;
                    KeZeroPagesFromIdleThread = KiXMMIZeroPagesNoSave;
                }
#if !defined(NT_UP)
             }
#endif
                *(PUCHAR)(ULONG_PTR)&RtlPrefetchMemoryNonTemporal = 0x90;
        }


    } else {

#ifndef NT_UP

        //
        // Patch the fxsave instruction in SwapContext to use
        // "fnsave {dd, 31}, fwait {9b}"
        //

        ASSERT( ((ULONG)&ScPatchFxe-(ULONG)&ScPatchFxb) >= 3);

        PatchLocation = (PUCHAR)&ScPatchFxb;

        *PatchLocation++ = 0xdd;
        *PatchLocation++ = 0x31;
        *PatchLocation++ = 0x9b;
        while (PatchLocation < (PUCHAR)&ScPatchFxe) {
            //
            // Put nop's in the remaining bytes
            //
            *PatchLocation++ = 0x90;
        }

#endif

    }

    //
    // If the system (ie all processors) supports fast system
    // call/return, initialize the machine specific registers
    // required to support it.
    //

    KiRestoreFastSyscallReturnState();
    ActiveProcessors = KeActiveProcessors;
    for (CurrentAffinity=1; ActiveProcessors; CurrentAffinity <<= 1) {
        if (ActiveProcessors & CurrentAffinity) {

            //
            // Switch to that processor, and remove it from the
            // remaining set of processors
            //

            ActiveProcessors &= ~CurrentAffinity;
            KeSetSystemAffinityThread(CurrentAffinity);

            //
            // Determine the MHz for the processor
            //

            KeGetCurrentPrcb()->MHz = 0;

            if (KeFeatureBits & KF_RDTSC) {

                Index = 0;
                pSamp = Samples;

                for (; ;) {

                    //
                    // Collect a new sample
                    // Delay the thread a "long" amount and time it with
                    // a time source and RDTSC.
                    //

                    CPUID (0, &Junk, &Junk, &Junk, &Junk);
                    pSamp->PerfStart = KeQueryPerformanceCounter (NULL);
                    pSamp->TSCStart = RDTSC();
                    pSamp->PerfFreq.QuadPart = -50000;

                    KeDelayExecutionThread (KernelMode, FALSE, &pSamp->PerfFreq);

                    CPUID (0, &Junk, &Junk, &Junk, &Junk);
                    pSamp->PerfEnd = KeQueryPerformanceCounter (&pSamp->PerfFreq);
                    pSamp->TSCEnd = RDTSC();

                    //
                    // Calculate processors MHz
                    //

                    pSamp->PerfDelta = pSamp->PerfEnd.QuadPart - pSamp->PerfStart.QuadPart;
                    pSamp->TSCDelta = pSamp->TSCEnd - pSamp->TSCStart;

                    pSamp->MHz = (ULONG) ((pSamp->TSCDelta * pSamp->PerfFreq.QuadPart + 500000L) /
                                          (pSamp->PerfDelta * 1000000L));


                    //
                    // If last 2 samples matched within a MHz, done
                    //

                    if (Index) {
                        if (pSamp->MHz == pSamp[-1].MHz ||
                            pSamp->MHz == pSamp[-1].MHz + 1 ||
                            pSamp->MHz == pSamp[-1].MHz - 1) {
                                break;
                        }
                    }

                    //
                    // Advance to next sample
                    //

                    pSamp += 1;
                    Index += 1;

                    //
                    // If too many samples, then something is wrong
                    //

                    if (Index >= MAX_ATTEMPTS) {

#if DBG
                        //
                        // Temp breakpoint to see where this is failing
                        // and why
                        //

                        DbgBreakPoint();
#endif

                        Average = 0;
                        for (Index = 0; Index < MAX_ATTEMPTS; Index++) {
                            Average += Samples[Index].MHz;
                        }
                        pSamp[-1].MHz = Average / MAX_ATTEMPTS;
                        break;
                    }

                }

                KeGetCurrentPrcb()->MHz = (USHORT) pSamp[-1].MHz;
            }

            //
            // If MTRRs are supported and PAT not supported, initialize MTRRs
            // per processor
            //

            if (KeFeatureBits & KF_MTRR) {
                KiInitializeMTRR ( (BOOLEAN) (ActiveProcessors ? FALSE : TRUE));
            }

            //
            // If the processor is a AMD K6 with MTRR support then
            // perform processor specific initialization.
            //

            if (KeFeatureBits & KF_AMDK6MTRR) {
                KiAmdK6InitializeMTRR();
            }

            //
            // Apply Pentium workaround if needed
            //

            if (KiI386PentiumLockErrataPresent) {
                KiI386PentiumLockErrataFixup ();
            }

            //
            // If this processor supports fast floating save/restore,
            // determine the MXCSR mask value that should be used.
            //

            if (KeFeatureBits & KF_FXSR) {

                //
                // Get base of NPX save area.
                //
                //

                PFX_SAVE_AREA NpxFrame;
                ULONG MXCsrMask = 0xFFBF;

                NpxFrame = (PFX_SAVE_AREA)
                    (((ULONG)(KeGetCurrentThread()->InitialStack) -
                    sizeof(FX_SAVE_AREA)));

                NpxFrame->U.FxArea.MXCsrMask = 0;
                Kix86FxSave(NpxFrame);

                //
                // If the processor supplied a mask value, use
                // that, otherwise set the default value.
                //

                if (NpxFrame->U.FxArea.MXCsrMask != 0) {
                    MXCsrMask = NpxFrame->U.FxArea.MXCsrMask;
                }

                //
                // All processors must use the same (most restrictive)
                // value.
                //

                if (KiMXCsrMask == 0) {
                    KiMXCsrMask = MXCsrMask;
                } else if (KiMXCsrMask != MXCsrMask) {
                    KeBugCheckEx(MULTIPROCESSOR_CONFIGURATION_NOT_SUPPORTED,
                                 KF_FXSR,
                                 KiMXCsrMask,
                                 MXCsrMask,
                                 0);
                }

                KiMXCsrMask &= MXCsrMask;
            }
        }
    }

    KeRevertToUserAffinityThread();

    //
    // If ISR time limits are being enforced, modify KiDispatchInterrupt
    // and KiChainedDispatch2ndLvl to call into the appropriate equivalent
    // timing routines.
    //

    if (KiTimeLimitIsrMicroseconds != 0) {

        ULONG_PTR Target;
        ULONG_PTR Source;
        ULONG_PTR SourceEnd;
        PUCHAR Code;
        KIRQL OldIrql;
        ULONG Proceed = 0;

        OldIrql = KfRaiseIrql(SYNCH_LEVEL);

        Target = (ULONG_PTR)&KiTimedChainedDispatch2ndLvl;
        Source = (ULONG_PTR)&KiChainedDispatch2ndLvl;
        
        //
        // Compute offset from end of branch instruction to new instruction
        // stream.  N.B. The end of the branch instruction will be 7 bytes in.
        //

        Target = Target - (Source + 7);

        //
        // Freeze the other processors.
        //

        KiLockStepOtherProcessors(&Proceed);

        //
        // Patch KiChainedDispatch2ndLvl to branch into 
        // KiTimedChainedDispatch2ndLvl.
        //

        KfRaiseIrql(HIGH_LEVEL);

        Code = (PUCHAR)Source;
        *Code++ = 0x8b; // mov ecx, edi ; pass int obj as argument
        *Code++ = 0xcf;
        *Code++ = 0xe9; // jmp xxxxxxxx
        *(PULONG)Code = Target;

        //
        // Get addresses of code to patch in KiInterruptDispatch
        //

        KiGetInterruptDispatchPatchAddresses(&Source, &SourceEnd);

        //
        // Patch KiInterruptDispatch to call into KiTimedInterruptDispatch.
        // Resulting code looks like-
        //
        //      mov     ecx, edi        ; set interrupt object address
        //      call    @KiTimedInterruptDispatch@4
        //      jmp     xxx             ; skip unpatched excess code.
        //

        Target = (ULONG_PTR)&KiTimedInterruptDispatch;
        Target = Target - (Source + 7);

        Code = (PUCHAR)Source;
        *Code++ = 0x8b; // mov ecx, edi ; pass int obj as argument
        *Code++ = 0xcf;
        *Code++ = 0xe8; // call xxxxxxxx
        *(PULONG)Code = Target;
        Code += sizeof(ULONG);
        *Code++ = 0xeb; // jmp short yyy
        *Code++ = (UCHAR)(SourceEnd - (ULONG_PTR)Code - 1);

        //
        // Unfreeze other processors.
        //

        KiUnlockStepOtherProcessors(&Proceed);
        KfLowerIrql(OldIrql);
    }

    return TRUE;
}

VOID
KeOptimizeProcessorControlState (
    VOID
    )
{
    Ke386ConfigureCyrixProcessor();
}

VOID
KeSetup80387OrEmulate (
    IN PVOID *R3EmulatorTable
    )

/*++

Routine Description:

    This routine is called by PS initialization after loading NTDLL.

    If this is a 386 system without 387s (all processors must be
    symmetrical) then this function will set the trap 07 vector on all
    processors to point to the address passed in (which should be the
    entry point of the 80387 emulator in NTDLL, NPXNPHandler).

Arguments:

    HandlerAddress - Supplies the address of the trap07 handler.

Return Value:

    None.

--*/

{

    PKINTERRUPT_ROUTINE HandlerAddress;
    KAFFINITY           ActiveProcessors, CurrentAffinity;
    KIRQL               OldIrql;
    ULONG               disposition;
    HANDLE              SystemHandle, SourceHandle, DestHandle;
    NTSTATUS            Status;
    UNICODE_STRING      unicodeString;
    OBJECT_ATTRIBUTES   ObjectAttributes;

    if (!KeI386NpxPresent) {

        //
        // Use the user mode floating point emulator
        //

        HandlerAddress = (PKINTERRUPT_ROUTINE) ((PULONG) R3EmulatorTable)[0];
        Ki387RoundModeTable = (PVOID) ((PULONG) R3EmulatorTable)[1];

        ActiveProcessors = KeActiveProcessors;
        for (CurrentAffinity = 1; ActiveProcessors; CurrentAffinity <<= 1) {

            if (ActiveProcessors & CurrentAffinity) {
                ActiveProcessors &= ~CurrentAffinity;

                //
                // Run this code on each processor.
                //

                KeSetSystemAffinityThread(CurrentAffinity);

                //
                // Raise IRQL and lock dispatcher database.
                //

                KiLockDispatcherDatabase(&OldIrql);

                //
                // Make the trap 07 IDT entry point at the passed-in handler
                //

                KiSetHandlerAddressToIDT(I386_80387_NP_VECTOR, HandlerAddress);
                KeGetPcr()->IDT[I386_80387_NP_VECTOR].Selector = KGDT_R3_CODE;
                KeGetPcr()->IDT[I386_80387_NP_VECTOR].Access = TRAP332_GATE;


                //
                // Unlock dispatcher database and lower IRQL to its previous value.
                //

                KiUnlockDispatcherDatabase(OldIrql);
            }
        }

        //
        // Set affinity back to the original value.
        //

        KeRevertToUserAffinityThread();

        //
        // Move any entries from ..\System\FloatingPointProcessor to
        // ..\System\DisabledFloatingPointProcessor.
        //

        //
        // Open system tree
        //

        InitializeObjectAttributes(
            &ObjectAttributes,
            &CmRegistryMachineHardwareDescriptionSystemName,
            OBJ_CASE_INSENSITIVE,
            NULL,
            NULL
            );

        Status = ZwOpenKey( &SystemHandle,
                            KEY_ALL_ACCESS,
                            &ObjectAttributes
                            );

        if (NT_SUCCESS(Status)) {

            //
            // Open FloatingPointProcessor key
            //

            InitializeObjectAttributes(
                &ObjectAttributes,
                &CmTypeName[FloatingPointProcessor],
                OBJ_CASE_INSENSITIVE,
                SystemHandle,
                NULL
                );

            Status = ZwOpenKey ( &SourceHandle,
                                 KEY_ALL_ACCESS,
                                 &ObjectAttributes
                                 );

            if (NT_SUCCESS(Status)) {

                //
                // Create DisabledFloatingPointProcessor key
                //

                RtlInitUnicodeString (
                    &unicodeString,
                    CmDisabledFloatingPointProcessor
                    );

                InitializeObjectAttributes(
                    &ObjectAttributes,
                    &unicodeString,
                    OBJ_CASE_INSENSITIVE,
                    SystemHandle,
                    NULL
                    );

                Status = ZwCreateKey( &DestHandle,
                                      KEY_ALL_ACCESS,
                                      &ObjectAttributes,
                                      0,
                                      NULL,
                                      REG_OPTION_VOLATILE,
                                      &disposition
                                      );

                if (NT_SUCCESS(Status)) {

                    //
                    // Move it
                    //

                    KiMoveRegTree (SourceHandle, DestHandle);
                    ZwClose (DestHandle);
                }

                ZwClose (SourceHandle);
            }

            ZwClose (SystemHandle);
        }
    }
}

NTSTATUS
KiMoveRegTree (
    HANDLE  Source,
    HANDLE  Dest
    )

{

    NTSTATUS                    Status;
    PKEY_BASIC_INFORMATION      KeyInformation;
    PKEY_VALUE_FULL_INFORMATION KeyValue;
    OBJECT_ATTRIBUTES           ObjectAttributes;
    HANDLE                      SourceChild;
    HANDLE                      DestChild;
    ULONG                       ResultLength;
    UCHAR                       buffer[1024];           // hmm....
    UNICODE_STRING              ValueName;
    UNICODE_STRING              KeyName;


    KeyValue = (PKEY_VALUE_FULL_INFORMATION)buffer;

    //
    // Move values from source node to dest node
    //

    for (; ;) {
        //
        // Get first value
        //

        Status = ZwEnumerateValueKey(Source,
                                     0,
                                     KeyValueFullInformation,
                                     buffer,
                                     sizeof (buffer),
                                     &ResultLength);

        if (!NT_SUCCESS(Status)) {
            break;
        }

        //
        // Write value to dest node
        //

        ValueName.Buffer = KeyValue->Name;
        ValueName.Length = (USHORT) KeyValue->NameLength;
        ZwSetValueKey(Dest,
                      &ValueName,
                      KeyValue->TitleIndex,
                      KeyValue->Type,
                      buffer+KeyValue->DataOffset,
                      KeyValue->DataLength);

        //
        // Delete value and get first value again
        //

        Status = ZwDeleteValueKey(Source, &ValueName);
        if (!NT_SUCCESS(Status)) {
            break;
        }
    }

    //
    // Enumerate node's children and apply ourselves to each one
    //

    KeyInformation = (PKEY_BASIC_INFORMATION)buffer;
    for (; ;) {

        //
        // Open node's first key
        //

        Status = ZwEnumerateKey(Source,
                                0,
                                KeyBasicInformation,
                                KeyInformation,
                                sizeof (buffer),
                                &ResultLength);

        if (!NT_SUCCESS(Status)) {
            break;
        }

        KeyName.Buffer = KeyInformation->Name;
        KeyName.Length = (USHORT) KeyInformation->NameLength;
        InitializeObjectAttributes(
            &ObjectAttributes,
            &KeyName,
            OBJ_CASE_INSENSITIVE,
            Source,
            NULL
            );

        Status = ZwOpenKey(
                    &SourceChild,
                    KEY_ALL_ACCESS,
                    &ObjectAttributes
                    );

        if (!NT_SUCCESS(Status)) {
            break;
        }

        //
        // Create key in dest tree
        //

        InitializeObjectAttributes(
            &ObjectAttributes,
            &KeyName,
            OBJ_CASE_INSENSITIVE,
            Dest,
            NULL
            );

        Status = ZwCreateKey(
                    &DestChild,
                    KEY_ALL_ACCESS,
                    &ObjectAttributes,
                    0,
                    NULL,
                    REG_OPTION_VOLATILE,
                    NULL
                    );

        if (!NT_SUCCESS(Status)) {
            break;
        }

        //
        // Move subtree
        //

        Status = KiMoveRegTree(SourceChild, DestChild);

        ZwClose(DestChild);
        ZwClose(SourceChild);

        if (!NT_SUCCESS(Status)) {
            break;
        }

        //
        // Loop and get first key.  (old first key was deleted by the
        // call to KiMoveRegTree).
        //
    }

    //
    // Remove source node
    //

    return NtDeleteKey (Source);
}

VOID
KiI386PentiumLockErrataFixup (
    VOID
    )

/*++

Routine Description:

    This routine is called once on every processor when
    KiI386PentiumLockErrataPresent is TRUE.

    This routine replaces the local IDT with an IDT that has the first 7 IDT
    entries on their own page and returns the first page to the caller to
    be marked as read-only.  This causes the processor to trap-0e fault when
    the errata occurs.  Special code in the trap-0e handler detects the
    problem and performs the proper fixup.

Arguments:

    FixupPage   - Returns a virtual address of a page to be marked read-only

Return Value:

    None.

--*/

{
    KDESCRIPTOR IdtDescriptor;
    PUCHAR      NewBase, BasePage;
    BOOLEAN     Enable;
    BOOLEAN     Status;


#define IDT_SKIP   (7 * sizeof (KIDTENTRY))

    //
    // Allocate memory for a new copy of the processor's IDT
    //

    BasePage = MmAllocateIndependentPages (2*PAGE_SIZE, 0);

    //
    // The IDT base is such that the first 7 entries are on the
    // first (read-only) page, and the remaining entries are on the
    // second (read-write) page
    //

    NewBase = BasePage + PAGE_SIZE - IDT_SKIP;

    //
    // Disable interrupts on this processor while updating the IDT base
    //

    Enable = KeDisableInterrupts();

    //
    // Copy Old IDT to new IDT
    //

    _asm {
        sidt IdtDescriptor.Limit
    }

    RtlCopyMemory ((PVOID) NewBase,
                   (PVOID) IdtDescriptor.Base,
                   IdtDescriptor.Limit + 1
                  );

    IdtDescriptor.Base = (ULONG) NewBase;

    //
    // Set the new IDT
    //

    _asm {
        lidt IdtDescriptor.Limit
    }

    //
    // Update the PCR
    //

    KeGetPcr()->IDT = (PKIDTENTRY) NewBase;

    //
    // Restore interrupts
    //

    KeEnableInterrupts(Enable);

    //
    // Mark the first page which contains IDT entries 0-6 as read-only
    //

    Status = MmSetPageProtection (BasePage, PAGE_SIZE, PAGE_READONLY);
    ASSERT (Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ke\i386\kix86.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    kix86.h

Abstract:

    This module contains the private (internal) platform specific header file
    for the kernel.

--*/

#if !defined(_KIX86_)
#define _KIX86_

//
// Define get current ready summary macro.
//

#define KiGetCurrentReadySummary()                                           \
    (KAFFINITY)__readfsdword(FIELD_OFFSET(KPCR, PrcbData.ReadySummary))

//
// VOID
// KiIpiSendSynchronousPacket (
//   IN PKPRCB Prcb,
//   IN KAFFINITY TargetProcessors,
//   IN PKIPI_WORKER WorkerFunction,
//   IN PVOID Parameter1,
//   IN PVOID Parameter2,
//   IN PVOID Parameter3
//   )
//
// Routine Description:
//
//   Similar to KiIpiSendPacket except that the pointer to the
//   originating PRCB (SignalDone) is kept in the global variable
//   KiSynchPacket and is protected by the context swap lock.  The
//   actual IPI is sent via KiIpiSend with a request type of
//   IPI_SYNCH_REQUEST.  This mechanism is used to send IPI's that
//   (reverse) stall until released by the originator.   This avoids
//   a deadlock that can occur if two processors are trying to deliver
//   IPI packets at the same time and one of them is a reverse stall.
//
//   N.B. The low order bit of the packet address is set if there is
//        exactly one target recipient. Otherwise, the low order bit
//        of the packet address is clear.
//

#define KiIpiSendSynchronousPacket(Prcb,Target,Function,P1,P2,P3)       \
    {                                                                   \
        extern PKPRCB KiSynchPacket;                                    \
                                                                        \
        Prcb->CurrentPacket[0] = (PVOID)(P1);                           \
        Prcb->CurrentPacket[1] = (PVOID)(P2);                           \
        Prcb->CurrentPacket[2] = (PVOID)(P3);                           \
        Prcb->TargetSet = (Target);                                     \
        Prcb->WorkerRoutine = (Function);                               \
        if (((Target) & ((Target) - 1)) == 0) {                         \
           KiSynchPacket = (PKPRCB)((ULONG_PTR)(Prcb) | 1);             \
        } else {                                                        \
           KiSynchPacket = (Prcb);                                      \
           Prcb->PacketBarrier = 1;                                     \
        }                                                               \
        KiIpiSend((Target),IPI_SYNCH_REQUEST);                          \
    }

VOID
KiInitializePcr (
    IN ULONG Processor,
    IN PKPCR Pcr,
    IN PKIDTENTRY Idt,
    IN PKGDTENTRY Gdt,
    IN PKTSS Tss,
    IN PKTHREAD Thread,
    IN PVOID DpcStack
    );

VOID
KiFlushNPXState (
    PFLOATING_SAVE_AREA SaveArea
    );

//
// Kix86FxSave(NpxFame) - performs an FxSave to the address specified
//

__inline
VOID
Kix86FxSave(
    PFX_SAVE_AREA NpxFrame
    )
{
    _asm {
        mov eax, NpxFrame
        ;fxsave [eax]
        _emit  0fh
        _emit  0aeh
        _emit   0
    }
}

//
// Kix86FnSave(NpxFame) - performs an FxSave to the address specified
//

__inline
VOID
Kix86FnSave(
    PFX_SAVE_AREA NpxFrame
    )
{
    __asm {
        mov eax, NpxFrame
        fnsave [eax]
    }
}

//
// Load Katmai New Instruction Technology Control/Status
//

__inline
VOID
Kix86LdMXCsr(
    PULONG MXCsr
    )
{
    _asm {
        mov eax, MXCsr
        ;LDMXCSR [eax]
        _emit  0fh
        _emit  0aeh
        _emit  10h
    }
}

//
// Store Katmai New Instruction Technology Control/Status
//

__inline
VOID
Kix86StMXCsr(
    PULONG MXCsr
    )
{
    _asm {
        mov eax, MXCsr
        ;STMXCSR [eax]
        _emit  0fh
        _emit  0aeh
        _emit  18h
    }
}

VOID
Ke386ConfigureCyrixProcessor (
    VOID
    );

ULONG
KiCopyInformation (
    IN OUT PEXCEPTION_RECORD ExceptionRecord1,
    IN PEXCEPTION_RECORD ExceptionRecord2
    );

VOID
KiSetHardwareTrigger (
    VOID
    );

//
// Debug register support
//

extern const ULONG KiDebugRegisterTrapOffsets [];
extern const ULONG KiDebugRegisterContextOffsets [];

BOOLEAN
FASTCALL
KiRecordDr7 (
    IN OUT PULONG Dr7Ptr,
    IN OUT PUCHAR Mask OPTIONAL
    );

BOOLEAN
FASTCALL
KiProcessDebugRegister (
    IN OUT PKTRAP_FRAME TrapFrame,
    IN ULONG Register
    );

ULONG
FASTCALL
KiUpdateDr7 (
    IN ULONG Dr7
    );

#ifdef DBGMP

VOID
KiPollDebugger (
    VOID
    );

#endif

VOID
FASTCALL
KiIpiSignalPacketDoneAndStall (
    IN PKIPI_CONTEXT Signaldone,
    IN ULONG volatile *ReverseStall
    );

extern KIRQL KiProfileIrql;

//
// Context size (as written to user stacks)
//

#define CONTEXT_ALIGNED_SIZE ((sizeof(CONTEXT) + CONTEXT_ROUND) & ~CONTEXT_ROUND)
C_ASSERT ((CONTEXT_ALIGNED_SIZE & CONTEXT_ROUND) == 0);

//
// PAE definitions.
//

#define MAX_IDENTITYMAP_ALLOCATIONS 30

typedef struct _IDENTITY_MAP  {
    PHARDWARE_PTE   TopLevelDirectory;
    ULONG           IdentityCR3;
    ULONG           IdentityAddr;
    ULONG           PagesAllocated;
    PVOID           PageList[ MAX_IDENTITYMAP_ALLOCATIONS ];
} IDENTITY_MAP, *PIDENTITY_MAP;


VOID
Ki386ClearIdentityMap(
    PIDENTITY_MAP IdentityMap
    );

VOID
Ki386EnableTargetLargePage(
    PIDENTITY_MAP IdentityMap
    );

BOOLEAN
Ki386CreateIdentityMap(
    IN OUT PIDENTITY_MAP IdentityMap,
    IN     PVOID StartVa,
    IN     PVOID EndVa
    );

BOOLEAN
Ki386EnableCurrentLargePage (
    IN ULONG IdentityAddr,
    IN ULONG IdentityCr3
    );

extern PVOID Ki386EnableCurrentLargePageEnd;

#if defined(_X86PAE_)
#define PPI_BITS    2
#define PDI_BITS    9
#define PTI_BITS    9
#else
#define PPI_BITS    0
#define PDI_BITS    10
#define PTI_BITS    10
#endif

#define PPI_MASK    ((1 << PPI_BITS) - 1)
#define PDI_MASK    ((1 << PDI_BITS) - 1)
#define PTI_MASK    ((1 << PTI_BITS) - 1)

#define KiGetPpeIndex(va) ((((ULONG)(va)) >> PPI_SHIFT) & PPI_MASK)
#define KiGetPdeIndex(va) ((((ULONG)(va)) >> PDI_SHIFT) & PDI_MASK)
#define KiGetPteIndex(va) ((((ULONG)(va)) >> PTI_SHIFT) & PTI_MASK)

//
// Define MTRR register variables.
//

extern LONG64 KiMtrrMaskBase;
extern LONG64 KiMtrrMaskMask;
extern LONG64 KiMtrrOverflowMask;
extern LONG64 KiMtrrResBitMask;
extern UCHAR KiMtrrMaxRangeShift;

#endif // _KIX86_
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ke\i386\intsup.asm ===
TITLE  "Interrupt Object Support Routines"
;++
;
; Copyright (c) Microsoft Corporation. All rights reserved. 
;
; You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
; If you do not agree to the terms, do not use the code.
;
;
; Module Name:
;
;    intsup.asm
;
; Abstract:
;
;    This module implements the code necessary to support interrupt objects.
;    It contains the interrupt dispatch code and the code template that gets
;    copied into an interrupt object.
;
;--
.386p
        .xlist
KERNELONLY  equ     1
include ks386.inc
include i386\kimacro.inc
include mac386.inc
include callconv.inc
include irqli386.inc
        .list

        EXTRNP  _KeBugCheck,1
        EXTRNP  _KeBugCheckEx,5
        EXTRNP  _KiDeliverApc,3
        EXTRNP  _HalBeginSystemInterrupt,3,IMPORT
        EXTRNP  _HalEndSystemInterrupt,2,IMPORT
        EXTRNP  Kei386EoiHelper
        EXTRNP  PerfInfoLogInterrupt,4,,FASTCALL
if DBG
        extrn   _DbgPrint:near
        extrn   _MsgISRTimeout:BYTE
        extrn   _KiISRTimeout:DWORD
endif
        extrn   _DbgPrint:near
        extrn   _MsgISROverflow:BYTE
        extrn   _KeTickCount:DWORD
        extrn   _KiISROverflow:WORD
        extrn   _KdDebuggerEnabled:BYTE

MI_MOVEDI       EQU     0BFH            ; op code for mov  edi, constant
MI_DIRECTJMP    EQU     0E9H            ; op code for indirect jmp
                                        ; or index registers

if DBG
DETECT_INT_STORM    EQU 1
else
DETECT_INT_STORM    EQU 0
endif


if DETECT_INT_STORM

INT_TICK_MASK   EQU     03FH

;
; Macro to check for an interrupt storm on a particular interrupt object
;
CHECK_INT_STORM macro Prefix
        mov     eax, _KeTickCount               ; current time
        and     eax, NOT INT_TICK_MASK          ; mask to closest 640ms
        cmp     eax, dword ptr [edi].InTickCount  ; in same 640ms second range
        jg      Prefix&_overflowreset     ; tick count has advanced since last interrupt, reset counts
        jl      Prefix&_waittick          ; we have already overflowed interrupt count for this tick, do nothing
                                                ; until the clock advances to the next tick period

        dec     word ptr [edi].InDispatchCount
        jz      Prefix&_interruptoverflow           ; interrupt count has just overflowed
Prefix&_dbg2:

        endm

CHECK_INT_STORM_TAIL macro Prefix, BugCheckID
Prefix&_interruptoverflow:

        dec     word ptr [edi].InDispatchCount+2
        jz      short @f
        add     eax, INT_TICK_MASK+1
        mov     [edi].InTickCount, eax  ; bump tick count to next tick
        jmp     short Prefix&_overflowreset2
        
@@:
        cmp     _KdDebuggerEnabled, 0
        jnz     short @f
        stdCall _KeBugCheckEx, <HARDWARE_INTERRUPT_STORM, [edi].InServiceRoutine, [edi].InServiceContext, edi, BugCheckID>

        ;
        ; Debugger is enabled so do a BP instead of bugchecking
        ;
@@:
        push    [edi].InServiceRoutine
        push    offset FLAT:_MsgISROverflow
        call    _DbgPrint
        add     esp, 8
        int 3
        mov     eax, _KeTickCount               ; current time
        and     eax, NOT INT_TICK_MASK          ; mask to closest 20 second
        ;
        ; deliberately fall through to reset the count
        ;


Prefix&_overflowreset:
        mov     dword ptr [edi].InTickCount, eax  ; initialize time
        mov     word ptr [edi].InDispatchCount+2, 64     ; 
Prefix&_overflowreset2:
        mov     ax, _KiISROverflow
        mov     word ptr [edi].InDispatchCount, ax      ; reset count
        jmp     Prefix&_dbg2

;
; Additional work we do here in Prefix&_waittick is to make sure the tickcount
; didn't actually wrap and send us here.
;
Prefix&_waittick:
        add     eax, INT_TICK_MASK+1
        cmp     eax, dword ptr [edi].InTickCount
        je      Prefix&_dbg2                        ; exactly one tick apart, do nothing
        ;
        ; tick count must have wrapped - reset all counters
        ;
        mov     eax, _KeTickCount
        jmp     short Prefix&_overflowreset
        endm

else 

CHECK_INT_STORM macro Prefix
        endm

CHECK_INT_STORM_TAIL macro Prefix, BugCheckID
        endm

endif

        page ,132
        subttl  "Syn0chronize Execution"

_TEXT$00   SEGMENT PARA PUBLIC 'CODE'

;++
;
; BOOLEAN
; KeSynchronizeExecution (
;    IN PKINTERRUPT Interrupt,
;    IN PKSYNCHRONIZE_ROUTINE SynchronizeRoutine,
;    IN PVOID SynchronizeContext
;    )
;
; Routine Description:
;
;    This function synchronizes the execution of the specified routine with the
;    execution of the service routine associated with the specified interrupt
;    object.
;
; Arguments:
;
;    Interrupt - Supplies a pointer to a control object of type interrupt.
;
;    SynchronizeRoutine - Supplies a pointer to a function whose execution
;       is to be synchronized with the execution of the service routine
;       associated with the specified interrupt object.
;
;    SynchronizeContext - Supplies a pointer to an arbitrary data structure
;       which is to be passed to the function specified by the
;       SynchronizeRoutine parameter.
;
; Return Value:
;
;    The value returned by the SynchronizeRoutine function is returned as the
;    function value.
;
;--
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING
cPublicProc _KeSynchronizeExecution ,3

        push    ebx                     ; save nonvolatile register
        mov     ebx, 8[esp]             ; get interrupt object address
        mov     cl, BYTE PTR InSynchronizeIrql[ebx] ; get synchronization IRQL
        RaiseIrql cl                    ; raise IRQL to synchronization level
        push    eax                     ; save previous IRQL

ifndef NT_UP
        mov     ebx,InActualLock[ebx]   ; get actual lock address

kse10:  ACQUIRE_SPINLOCK ebx,<short kse20>  ; acquire spin lock
endif

        push    20[esp]                 ; push synchronization context routine
        call    20[esp]                 ; call synchronization routine

ifndef NT_UP
        RELEASE_SPINLOCK ebx            ; release spin lock
endif

        mov     ebx, eax                ; save synchronization routine value
        pop     ecx                     ; retrieve previous IRQL
        LowerIrql ecx                   ; lower IRQL to previous value
        mov     eax, ebx                ; set return value
        pop     ebx                     ; restore nonvolatile register

        stdRET  _KeSynchronizeExecution

ifndef NT_UP
kse20:  SPIN_ON_SPINLOCK ebx,<short kse10>  ; wait until lock is free
endif

stdENDP _KeSynchronizeExecution

        page ,132
        subttl  "Chained Dispatch"
;++
;
; Routine Description:
;
;    This routine is entered as the result of an interrupt being generated
;    via a vector that is connected to more than one interrupt object.
;
; Arguments:
;
;    edi - Supplies a pointer to the interrupt object.
;    esp - Supplies a pointer to the top of trap frame
;    ebp - Supplies a pointer to the top of trap frame
;
; Return Value:
;
;    None.
;
;--


align 16
cPublicProc _KiChainedDispatch      ,0
.FPO (2, 0, 0, 0, 0, 1)

;
; update statistic
;

        inc     dword ptr PCR[PcPrcbData+PbInterruptCount]

;
; set ebp to the top of trap frame.  We don't need to save ebp because
; it is saved in trap frame already.
;

        mov     ebp, esp                ; (ebp)->trap frame

;
; Save previous IRQL and set new priority level
;

        mov     eax, [edi].InVector     ; save vector
        push    eax
        sub     esp, 4                  ; make room for OldIrql
        mov     ecx, [edi].InIrql       ; Irql

;
; esp - pointer to OldIrql
; eax - vector
; ecx - Irql
;

        stdCall   _HalBeginSystemInterrupt, <ecx, eax, esp>
        or      eax, eax                ; check for spurious int.
        jz      kid_spuriousinterrupt

        stdCall _KiChainedDispatch2ndLvl

        INTERRUPT_EXIT                  ; will do an iret

stdENDP _KiChainedDispatch

        page ,132
        subttl  "Chained Dispatch 2nd Level"
;++
;
; Routine Description:
;
;    This routine is entered as the result of an interrupt being generated
;    via a vector that is either connected to more than one interrupt object,
;    or is being 2nd level dispatched.  Its function is to walk the list
;    of connected interrupt objects and call each interrupt service routine.
;    If the mode of the interrupt is latched, then a complete traversal of
;    the chain must be performed. If any of the routines require saving the
;    floating point machine state, then it is only saved once.
;
; Arguments:
;
;    edi - Supplies a pointer to the interrupt object.
;
; Return Value:
;
;   None.
;   Uses all registers
;
;--


public _KiInterruptDispatch2ndLvl@0
_KiInterruptDispatch2ndLvl@0:
        nop

cPublicProc _KiChainedDispatch2ndLvl,0
cPublicFpo 0, 4

        push    ebp
        sub     esp, 20                 ; Make room for scratch and local values

;
;   [esp]       OldIrql
;   [esp+4]     Scratch
;   [esp+8]     TimeStamp
;   [esp+16]    ISRTracingOn
;

        xor     ebp, ebp                ; init (ebp) = Interrupthandled = FALSE
        lea     ebx, [edi].InInterruptListEntry
                                        ; (ebx)->Interrupt Head List

        mov     ecx, PCR[PcSelfPcr]     ; get address of PCR
        cmp     [ecx]+PcPerfGlobalGroupMask, 0  ; Is event tracing on?
        mov     [esp+16], 0             ; ISRTracingOn = 0
        jne     kcd120

;
; Walk the list of connected interrupt objects and call the appropriate dispatch
; routine.
;

kcd40:

;
; Raise irql level to the SynchronizeIrql level if it is not equal to current
; irql.
;

        mov     cl, [edi+InIrql]        ; [cl] = Current Irql
        mov     esi,[edi+InActualLock]
        cmp     [edi+InSynchronizeIrql], cl ; Is SyncIrql > current IRQL?
        je      short kcd50             ; if e, no, go kcd50

        mov     cl, [edi+InSynchronizeIrql] ; (cl) = Irql to raise to
        RaiseIrql cl
        mov     [esp], eax              ; Save OldIrql


;
; Acquire the service routine spin lock and call the service routine.
;

kcd50:
        ACQUIRE_SPINLOCK esi,kcd110

;
; Check for an interrupt storm on this interrupt object
;
        CHECK_INT_STORM kcd
if DBG
        mov     eax, _KeTickCount       ; Grab ISR start time
        mov     [esp+4], eax            ; save to local variable
endif
        mov     eax, InServiceContext[edi] ; set parameter value
        push    eax
        push    edi                     ; pointer to interrupt object
        call    InServiceRoutine[edi]   ; call specified routine

if DBG
        mov     ecx, [esp+4]            ; (ecx) = time isr started
        add     ecx, _KiISRTimeout      ; adjust for timeout
        cmp     _KeTickCount, ecx       ; Did ISR timeout?
        jnc     kcd200
kcd51:
endif

;
; Release the service routine spin lock and check to determine if end of loop.
;

        RELEASE_SPINLOCK esi

;
; Lower IRQL to earlier level if we raised it to SynchronizedLevel.
;

        mov     cl, [edi+InIrql]
        cmp     [edi+InSynchronizeIrql], cl ; Is SyncIrql > current IRQL?
        je      short kcd55             ; if e, no, go kcd55

        mov     esi, eax                ; save ISR returned value

;
; Arg1 : Irql to Lower to
;

        mov     ecx, [esp]
        LowerIrql cl

        mov     eax, esi                ; [eax] = ISR returned value
kcd55:
        cmp     [esp+16], 0             ; check if ISR logging is enabled
        jne     kcd130
kcd57:

        or      al,al                   ; Is interrupt handled?
        je      short kcd60             ; if eq, interrupt not handled

        cmp     word ptr InMode[edi], InLevelSensitive
        je      short kcd70             ; if eq, level sensitive interrupt

        mov     ebp, eax                ; else edge shared int is handled. Remember it.
kcd60:  mov     edi, [edi].InInterruptListEntry
                                        ; (edi)->next obj's addr of listentry
        cmp     ebx, edi                ; Are we at end of interrupt list?
        je      short kcd65             ; if eq, reach end of list
        sub     edi, InInterruptListEntry; (edi)->addr of next interrupt object
        jmp     kcd40

kcd65:
;
; If this is edge shared interrupt, we need to loop till no one handle the
; interrupt.  In theory only shared edge triggered interrupts come here.
;

        sub     edi, InInterruptListEntry; (edi)->addr of next interrupt object
        cmp     word ptr InMode[edi], InLevelSensitive
        je      short kcd70             ; if level, exit.  No one handle the interrupt?

        test    ebp, 0fh                ; does anyone handle the interrupt?
        je      short kcd70             ; if e, no one, we can exit.

        xor     ebp, ebp                ; init local var to no one handle the int
        jmp     kcd40                   ; restart the loop.

;
; Either the interrupt is level sensitive and has been handled or the end of
; the interrupt object chain has been reached.
;

; restore frame pointer, and deallocate trap frame.

kcd70:
        add     esp, 20                  ; clear local variable space
        pop     ebp
        stdRet  _KiChainedDispatch2ndLvl


; Service routine Lock is currently owned, spin until free and then
; attempt to acquire lock again.

ifndef NT_UP
kcd110: SPIN_ON_SPINLOCK esi, kcd50,,DbgMp
endif

;
; If ISR event tracing is on, note that it is and take a timestamp
;
kcd120:
        mov     ecx, [ecx]+PcPerfGlobalGroupMask
        cmp     ecx, 0                  ; catch race here
        jz      kcd40
        test    dword ptr [ecx+PERF_INTERRUPT_OFFSET], PERF_INTERRUPT_FLAG
        jz      kcd40                   ; return if our flag is not set
        
        mov     [esp+16], 1             ; records that ISR tracing is enabled

        PERF_GET_TIMESTAMP              ; Places 64bit in edx:eax and trashes ecx

        mov     [esp+8], eax            ; Time saved on the stack
        mov     [esp+12], edx
        jmp     kcd40

;
; Log the ISR, initial time, and return value.  Also, get the timestamp for the
; next iteration.
;
kcd130:
        push    eax                     ; save the ISRs return value

        mov     edx, eax                ; pass ISRs return value
        mov     eax, [esp+12]           ; push the initial timestamp
        mov     ecx, [esp+16]
        push    ecx
        push    eax     

        mov     ecx, InServiceRoutine[edi]
        fstCall PerfInfoLogInterrupt
        
        PERF_GET_TIMESTAMP              ; Places 64bit in edx:eax and trashes ecx

        mov     [esp+12], eax           ; Time saved on the stack
        mov     [esp+16], edx

        pop     eax                     ; restore the ISRs return value
        jmp     kcd57 

;
; ISR took a long time to complete, abort to debugger
;

if DBG
kcd200: push    eax                     ; save return code
        push    InServiceRoutine[edi]
        push    offset FLAT:_MsgISRTimeout
        call    _DbgPrint
        add     esp,8
        pop     eax
        int     3
        jmp     kcd51                   ; continue
endif

    CHECK_INT_STORM_TAIL kcd, 2

stdENDP _KiChainedDispatch2ndLvl


        page ,132
        subttl  "Floating Dispatch"
;++
;
; Routine Description:
;
;    This routine is entered as the result of an interrupt being generated
;    via a vector that is connected to an interrupt object. Its function is
;    to save the machine state and floating state and then call the specified
;    interrupt service routine.
;
; Arguments:
;
;    edi - Supplies a pointer to the interrupt object.
;    esp - Supplies a pointer to the top of trap frame
;    ebp - Supplies a pointer to the top of trap frame
;
; Return Value:
;
;    None.
;
;--

align 16
cPublicProc _KiFloatingDispatch     ,0
.FPO (2, 0, 0, 0, 0, 1)

;
; update statistic
;
        inc     dword ptr PCR[PcPrcbData+PbInterruptCount]

; set ebp to the top of trap frame.  We don't need to save ebp because
; it is saved in trap frame already.
;

        mov     ebp, esp                ; (ebp)->trap frame

;
; Save previous IRQL and set new priority level to interrupt obj's SyncIrql
;
        mov     eax, [edi].InVector
        mov     ecx, [edi].InSynchronizeIrql ; Irql
        push    eax                     ; save vector
        sub     esp, 4                  ; make room for OldIrql

; arg3 - ptr to OldIrql
; arg2 - vector
; arg1 - Irql
        stdCall   _HalBeginSystemInterrupt, <ecx, eax, esp>

        or      eax, eax                ; check for spurious int.
        jz      kid_spuriousinterrupt

        sub     esp, 12                 ; make room for ISRTracingOn and InitialTime

        mov     ecx, PCR[PcSelfPcr]     ; get address of PCR
        cmp     [ecx]+PcPerfGlobalGroupMask, 0 ; Is event tracing on?
        mov     [ebp-12], 0             ; ISRTracingOn = 0
        jne     kfd110

;
; Acquire the service routine spin lock and call the service routine.
;

kfd30:  mov     esi,[edi+InActualLock]
        ACQUIRE_SPINLOCK esi,kfd100

;
; Check for an interrupt storm on this interrupt object
;
        CHECK_INT_STORM kfd
if DBG
        mov     ebx, _KeTickCount       ; Grab current tick time
endif
        mov     eax, InServiceContext[edi] ; set parameter value
        push    eax
        push    edi                     ; pointer to interrupt object
        call    InServiceRoutine[edi]   ; call specified routine
if DBG
        add     ebx, _KiISRTimeout      ; adjust for ISR timeout
        cmp     _KeTickCount, ebx       ; Did ISR timeout?
        jnc     kfd200
kfd31:
endif

;
; Release the service routine spin lock.
;

        RELEASE_SPINLOCK esi

        cmp     [ebp-12], 0             ; check if ISR logging is enabled
        jne     kfd120
kfd40:
        add     esp, 12

;
; Do interrupt exit processing
;
        INTERRUPT_EXIT                  ; will do an iret

;
; Service routine Lock is currently owned; spin until free and
; then attempt to acquire lock again.
;

ifndef NT_UP
kfd100: SPIN_ON_SPINLOCK esi,kfd30,,DbgMp
endif

;
; If ISR event tracing is on, collect a time stamp and record that we did.
;
kfd110:
        mov     ecx, [ecx]+PcPerfGlobalGroupMask
        cmp     ecx, 0                  ; catch race here
        jz      kfd30
        test    dword ptr [ecx+PERF_INTERRUPT_OFFSET], PERF_INTERRUPT_FLAG
        jz      kfd30                   ; return if our flag is not set
        
        PERF_GET_TIMESTAMP              ; Places 64bit in edx:eax and trashes ecx

        mov     [ebp-16], eax           ; Time saved on the stack
        mov     [ebp-20], edx
        mov     [ebp-12], 1             ; Records that timestamp is on stack
        jmp     kfd30

;
; Log the ISR, initial time, and return value
;
kfd120:

        mov     edx, eax                ; pass ISRs return value
        mov     eax, [ebp-16]           ; push InitialTime
        mov     ecx, [ebp-20]
        push    ecx
        push    eax     

        mov     ecx, InServiceRoutine[edi]       
        fstCall PerfInfoLogInterrupt
        jmp     kfd40 

;
; ISR took a long time to complete, abort to debugger
;

if DBG
kfd200: push    InServiceRoutine[edi]   ; timed out
        push    offset FLAT:_MsgISRTimeout
        call    _DbgPrint
        add     esp,8
        int     3
        jmp     kfd31                   ; continue
endif
        CHECK_INT_STORM_TAIL kfd, 1

stdENDP _KiFloatingDispatch

        page ,132
        subttl  "Interrupt Dispatch"
;++
;
; Routine Description:
;
;    This routine is entered as the result of an interrupt being generated
;    via a vector that is connected to an interrupt object. Its function is
;    to directly call the specified interrupt service routine.
;
; Arguments:
;
;    edi - Supplies a pointer to the interrupt object.
;    esp - Supplies a pointer to the top of trap frame
;    ebp - Supplies a pointer to the top of trap frame
;
; Return Value:
;
;    None.
;
;--

align 16
cPublicProc _KiInterruptDispatch    ,0
.FPO (2, 0, 0, 0, 0, 1)

;
; update statistic
;
        inc     dword ptr PCR[PcPrcbData+PbInterruptCount]

;
; set ebp to the top of trap frame.  We don't need to save ebp because
; it is saved in trap frame already.
;

        mov     ebp, esp                ; (ebp)->trap frame

;
; Save previous IRQL and set new priority level
;
        mov     eax, [edi].InVector     ; save vector
        mov     ecx, [edi].InSynchronizeIrql ; Irql to raise to
        push    eax
        sub     esp, 4                  ; make room for OldIrql

        stdCall   _HalBeginSystemInterrupt,<ecx, eax, esp>

        or      eax, eax                ; check for spurious int.
        jz      kid_spuriousinterrupt

        sub     esp, 12                 ; make room for ISRTracingOn and InitialTime

        mov     ecx, PCR[PcSelfPcr]     ; get address of PCR
        cmp     [ecx]+PcPerfGlobalGroupMask, 0
        mov     [ebp-12], 0             ; ISRTracingOn = 0
        jne     kid110                  ; check if ISR logging is enabled

;
; Acquire the service routine spin lock and call the service routine.
;

kid30:  mov     esi,[edi+InActualLock]
        ACQUIRE_SPINLOCK esi,kid100


;
; Check for an interrupt storm on this interrupt object
;
        CHECK_INT_STORM kid
if DBG
        mov     ebx, _KeTickCount
endif
        mov     eax, InServiceContext[edi] ; set parameter value
        push    eax
        push    edi                     ; pointer to interrupt object
        call    InServiceRoutine[edi]   ; call specified routine

if DBG
        add     ebx, _KiISRTimeout      ; adjust for ISR timeout
        cmp     _KeTickCount, ebx       ; Did ISR timeout?
        jnc     kid200
kid31:
endif

;
; Release the service routine spin lock, retrieve the return address,
; deallocate stack storage, and return.
;

        RELEASE_SPINLOCK esi

        cmp     [ebp-12], 0             ; check if ISR logging is enabled
        jne     kid120
kid40:
        add     esp, 12


;
; Do interrupt exit processing
;

kid32:  INTERRUPT_EXIT                  ; will do an iret

kid_spuriousinterrupt:
        add     esp, 8                  ; Irql wasn't raised, exit interrupt
        SPURIOUS_INTERRUPT_EXIT         ; without eoi or lower irql

;
; Lock is currently owned; spin until free and then attempt to acquire
; lock again.
;

ifndef NT_UP
kid100: SPIN_ON_SPINLOCK esi,kid30,,DbgMp
endif

;
; If ISR event tracing is on, collect a time stamp and record that we did.
;
kid110:
        mov     ecx, [ecx]+PcPerfGlobalGroupMask
        cmp     ecx, 0                  ; catch race here
        jz      kid30
        test    dword ptr [ecx+PERF_INTERRUPT_OFFSET], PERF_INTERRUPT_FLAG
        jz      kid30                   ; return if our flag is not set
        
        PERF_GET_TIMESTAMP              ; Places 64bit in edx:eax and trashes ecx

        mov     [ebp-16], eax            ; Time saved on the stack
        mov     [ebp-20], edx
        mov     [ebp-12], 1             ; Records that timestamp is on stack
        jmp     kid30

;
; Log the ISR, initial time, and return value
;
kid120:
        mov     edx, eax                ; pass the ISRs return value
        mov     eax, [ebp-16]           ; push InitialTime
        mov     ecx, [ebp-20]
        push    ecx
        push    eax     

        mov     ecx, InServiceRoutine[edi]       
        fstCall PerfInfoLogInterrupt
        jmp     kid40 

;
; ISR took a long time to complete, abort to debugger
;

if DBG
kid200: push    InServiceRoutine[edi]   ; timed out
        push    offset FLAT:_MsgISRTimeout
        call    _DbgPrint
        add     esp,8
        int     3
        jmp     kid31                   ; continue
endif

CHECK_INT_STORM_TAIL kid, 0

stdENDP _KiInterruptDispatch

;++
;
; Routine Description:
;
;    This routine returns the addresses of kid30 and kid32 (above) so
;    that they may be patched at system startup if ISR timing is enabled.
;    this is to avoid making them public.
;
; Arguments:
;
;    Arg0 - Supplies the address to receive the address of kid30.
;    Arg1 - Supplies the address to receive the address of kid32.
;
; Return Value:
;
;    None.
;
;--
cPublicProc _KiGetInterruptDispatchPatchAddresses, 2
        mov     ecx, [esp+4]
        mov     dword ptr [ecx], offset FLAT:kid30
        mov     ecx, [esp+8]
        mov     dword ptr [ecx], offset FLAT:kid32
        stdRet  _KiGetInterruptDispatchPatchAddresses

stdENDP _KiGetInterruptDispatchPatchAddresses

        page ,132
        subttl  "Interrupt Template"
;++
;
; Routine Description:
;
;    This routine is a template that is copied into each interrupt object. Its
;    function is to save machine state and pass the address of the respective
;    interrupt object and transfer control to the appropriate interrupt
;    dispatcher.
;
;    Control comes here through i386 interrupt gate and, upon entry, the
;    interrupt is disabled.
;
;    Note: If the length of this template changed, the corresponding constant
;          defined in Ki.h needs to be updated accordingly.
;
; Arguments:
;
;    None
;
; Return Value:
;
;    edi - addr of interrupt object
;    esp - top of trap frame
;    interrupts are disabled
;
;--

_KiShutUpAssembler      proc

        public  _KiInterruptTemplate
_KiInterruptTemplate    label   byte

; Save machine state on trap frame

        ENTER_INTERRUPT kit_a,  kit_t

;
; the following instruction gets the addr of associated interrupt object.
; the value ? will be replaced by REAL interrupt object address at
; interrupt object initialization time.
;       mov     edi, addr of interrupt object
; 
; Template modifications made to support BBT, include replacing bogus
; insructions (created by db and dd) with real instructions.   
; This stuff gets overwritten anyway.  BBT just needs to see real instructions.

        public  _KiInterruptTemplate2ndDispatch
_KiInterruptTemplate2ndDispatch equ     this dword
        mov      edi,0  

        public  _KiInterruptTemplateObject
_KiInterruptTemplateObject      equ     this dword


; the following instruction transfers control to the appropriate dispatcher
; code.  The value ? will be replaced by real InterruptObj.DispatchAddr
; at interrupt initialization time.  The dispatcher routine will be any one
; of _KiInterruptDispatch, _KiFloatingDispatch, or _KiChainDispatch.
;       jmp     [IntObj.DispatchAddr]

        jmp _KeSynchronizeExecution

        public  _KiInterruptTemplateDispatch
_KiInterruptTemplateDispatch    equ     this dword

        ENTER_DR_ASSIST kit_a,  kit_t

; end of _KiInterruptTemplate

if  ($ - _KiInterruptTemplate) GT DISPATCH_LENGTH
    .err
    %out    <InterruptTemplate greater than dispatch_length>
endif

_KiShutUpAssembler      endp

        page ,132
        subttl  "Unexpected Interrupt"
;++
;
; Routine Description:
;
;    This routine is entered as the result of an interrupt being generated
;    via a vector that is not connected to an interrupt object.
;
;    For any unconnected vector, its associated 8259 irq is masked out at
;    Initialization time.  So, this routine should NEVER be called.
;    If somehow, this routine gets control we simple raise a BugCheck and
;    stop the system.
;
; Arguments:
;
;    None
;    Interrupt is disabled
;
; Return Value:
;
;    None.
;
;--
        public _KiUnexpectedInterrupt
_KiUnexpectedInterrupt  proc
cPublicFpo 0,0

; stop the system
        stdCall   _KeBugCheck, <TRAP_CAUSE_UNKNOWN>
        nop

_KiUnexpectedInterrupt endp

_TEXT$00   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ke\i386\ldtsup2.asm ===
title  "Ldt Support 2 - Low Level"
;++
;
; Copyright (c) Microsoft Corporation. All rights reserved. 
;
; You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
; If you do not agree to the terms, do not use the code.
;
;
; Module Name:
;
;    ldtsup2.asm
;
; Abstract:
;
;    This module implements procedures to load a new ldt and to flush
;    segment descriptors.
;
;--

.386p
        .xlist
include ks386.inc
include i386\kimacro.inc
include mac386.inc
include callconv.inc
        .list

_TEXT$00   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING
;++
;
; VOID
; KiLoadLdtr(
;    VOID
;    )
;
; Routine Description:
;
;    This routine copies the Ldt descriptor image out of the currently
;    executing process object into the Ldt descriptor, and reloads the
;    the Ldt descriptor into the Ldtr.  The effect of this is to provide
;    a new Ldt.
;
;    If the Ldt descriptor image has a base or limit of 0, then NULL will
;    be loaded into the Ldtr, and no copy to the Gdt will be done.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    None.
;
;--

cPublicProc _KiLoadLdtr, 0

        push    esi
        push    edi

        mov     eax,PCR[PcPrcbData+PbCurrentThread]   ; (eax)->CurrentThread
        mov     eax,[eax]+(ThApcState+AsProcess)    ; (eax)->CurrentProcess

        lea     esi,[eax]+PrLdtDescriptor           ; (esi)->Ldt value
        xor     dx,dx                               ; assume null value
        cmp     word ptr [esi],0                    ; limit == 0?
        jz      kill10                              ; yes limit 0, go load null

;
;   We have a non-null Ldt Descriptor, copy it into the Gdt
;

        mov     edi,PCR[PcGdt]
        add     edi,KGDT_LDT                        ; (edi)->Ldt descriptor

        movsd
        movsd                                       ; descrip. now matches value

        mov     dx,KGDT_LDT

kill10: lldt    dx

        pop     edi
        pop     esi

        stdCall   _KiFlushDescriptors

        stdRET    _KiLoadLdtr

stdENDP _KiLoadLdtr



;++
;
; VOID
; KiFlushDescriptors(
;    VOID
;    )
;
; Routine Description:
;
;    Flush the in-processor descriptor registers for the segment registers.
;    We do this by reloading each segment register.
;
;    N.B.
;
;       This procedure is only intended to support Ldt operations.
;       It does not support operations on the Gdt.  In particular,
;       neither it nor Ke386SetDescriptorProcess are appropriate for
;       editing descriptors used by 16bit kernel code (i.e. ABIOS.)
;
;       Since we are in kernel mode, we know that CS and SS do NOT
;       contain Ldt selectors, any such selectors will be save/restored
;       by the interrupt that brought us here from user space.
;
;       Since we are in kernel mode, DS must contain a flat GDT descriptor,
;       since all entry sequences would have forced a reference to it.
;
;       Since we are in kernel mode, FS points to the PCR, since all
;       entry sequences force it to.
;
;       Therefore, only ES and GS need to be flushed.
;
;       Since no inline kernel code ever uses GS, we know it will be
;       restored from a frame of some caller, or nobody cares.  Therefore,
;       we load null into GS.  (Fastest possible load.)
;
;       ES is restored to KGDT_R3_DATA, because kernel exit will not restore
;       it for us.  If we do not put the correct value in ES, we may wind
;       up with zero in ES in user mode.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    None.
;
;--

cPublicProc _KiFlushDescriptors ,0

        xor     ax,ax
        mov     gs,ax
        push    ds
        pop     es
        stdRET    _KiFlushDescriptors

stdENDP _KiFlushDescriptors


_TEXT$00   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ke\i386\kimacro.inc ===
;++
;
; Copyright (c) Microsoft Corporation. All rights reserved. 
;
; You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
; If you do not agree to the terms, do not use the code.
;
;
;   Module Name:
;
;       kimacro.inc
;
;   Abstract:
;
;       This module contains the macros used by kernel assembler code.
;       It includes macros to manipulate interrupts, support system
;       entry and exit for syscalls, faults, and interrupts, and
;       manipulate floating point state.
;
;--

;++
;
;   These constants are used by the fpo directives in this file.
;   This directive causes the assembler to output a .debug$f segment
;   in the obj file.  The segment will contain 1 fpo record for each
;   directive present during assembly.
;
;   Although the assembler will accept all valid values, the value of 7
;   in the FPO_REGS field indicates to the debugger that a trap frame is
;   generated by the function.  The value of 7 can be used because the
;   C/C++ compiler puts a maximum value of 3 in the field.
;
FPO_LOCALS      equ     0         ; 32 bits, size of locals in dwords
FPO_PARAMS      equ     0         ; 32 bits, size of parameters in dwords
FPO_PROLOG      equ     0         ; 12 bits, 0-4095, # of bytes in prolog
FPO_REGS        equ     0         ; 3 bits, 0-7, # regs saved in prolog
FPO_USE_EBP     equ     0         ; 1 bit, 0-1, is ebp used?
FPO_TRAPFRAME   equ     1         ; 2 bits, 0=fpo, 1=trap frame, 2=tss
;
;--


;++
;
;   POLL_DEBUGGER
;
;   Macro Description:
;
;       Call the debugger so it can check for control-c.  If it finds
;       it, it will report our iret address as address of break-in.
;
;       N.B. This macro should be used when all the caller's registers
;            have been restored. (Otherwise, the kernel debugger register
;            dump will not have correct state.)  The only exception is
;            fs.  This is because Kd may need to access PCR or PRCB.
;
;   Arguments:
;
;       There MUST be an iret frame on the stack when this macro
;       is invoked.
;
;   Exit:
;
;       Debugger will iret for us, so we don't usually return from
;       this macro, but remember that it generates nothing for non-DEVL
;       kernels.
;--

POLL_DEBUGGER   macro
local   a, b, c_

if  DEVL
        EXTRNP   _DbgBreakPointWithStatus,1
        stdCall _KdPollBreakIn
        or      al,al
        jz      short c_
        stdCall _DbgBreakPointWithStatus,<DBG_STATUS_CONTROL_C>
c_:
endif   ; DEVL
endm

;++
;
;   ASSERT_FS
;
;   Try to catch funky condition wherein we get FS=r3 value while
;   running in kernel mode.
;
;--

ASSERT_FS   macro
local   a,b

if DBG
        EXTRNP   _KeBugCheck,1

        mov     bx,fs
        cmp     bx,KGDT_R0_PCR
        jnz     short a

        cmp     dword ptr fs:[0], 0
        jne     short b

a:
        stdCall   _KeBugCheck,<-1>
align 4
b:
endif
endm



;++
;
;
;   Copy data from various places into base of TrapFrame, net effect
;   is to allow dbg KB command to trace across trap frame, and to
;   allow user to find arguments to system calls.
;
;   USE ebx and edi.
;--

SET_DEBUG_DATA  macro

ife FPO

;
; This macro is used by ENTER_SYSCALL, ENTER_TRAP and ENTER_INTERRUPT
; and is used at the end of above macros.  It is safe to destroy ebx, edi.
;

        mov     ebx,[ebp]+TsEbp
        mov     edi,[ebp]+TsEip
        mov     [ebp]+TsDbgArgPointer,edx
        mov     [ebp]+TsDbgArgMark,0BADB0D00h
        mov     [ebp]+TsDbgEbp,ebx
        mov     [ebp]+TsDbgEip,edi
endif

endm


;++
;
;   ENTER_DR_ASSIST     EnterLabel, ExitLabel, NoAbiosAssist, NoV86Assist
;
;   Macro Description:
;
;       Jumped to by ENTER_ macros to deal with DR register work,
;       abios work and v86 work.  The main purpose of this macro is
;       that interrupt/trap/systemCall EnterMacros can jump here to
;       deal with some special cases such that most of the times the
;       main ENTER_ execution flow can proceed without being branched.
;
;       If (previousmode == usermode) {
;           save DR* in trapframe
;           load DR* from Prcb
;       }
;
;   Arguments:
;       EnterLabel - label to emit
;       ExitLabel - label to branch to when done
;
;   Entry-conditions:
;     Dr work:
;       DebugActive == TRUE
;       (esi)->Thread object
;       (esp)->base of trap frame
;       (ebp)->base of trap frame
;
;     Abios work:
;     v86 work:
;
;   Exit-conditions:
;     Dr work:
;       Interrupts match input state (this routine doesn't change IEF)
;       (esp)->base of trap frame
;       (ebp)->base of trap frame
;       Preserves entry eax, edx
;     Abios work:
;     v86 work:
;
;--

ENTER_DR_ASSIST macro   EnterLabel, ExitLabel, NoAbiosAssist, NoV86Assist, V86R
        local   a,b

        public  Dr_&EnterLabel
align 4
Dr_&EnterLabel:

;
; Test if we came from user-mode.  If not, do nothing.
;
        test    dword ptr [ebp]+TsEFlags,EFLAGS_V86_MASK
        jnz     short a

.errnz (MODE_MASK AND 0FFFFFF00h)
        test    byte ptr [ebp]+TsSegCs,MODE_MASK
        jz      Dr_&ExitLabel          ; called from kmode, go continue


;
; Save user-mode Dr* regs in TrapFrame
;
; We are safe to destroy ebx, ecx, edi because in ENTER_INTERRUPT and
; ENTER_TRAP these registers are saved already.  In ENTER_SYSCALL
; ebx, edi is saved and ecx is saved as needed.
;

a:      mov     ebx,dr0
        mov     ecx,dr1
        mov     edi,dr2
        mov     [ebp]+TsDr0,ebx
        mov     [ebp]+TsDr1,ecx
        mov     [ebp]+TsDr2,edi
        mov     ebx,dr3
        mov     ecx,dr6
        mov     edi,dr7
        mov     [ebp]+TsDr3,ebx
        mov     [ebp]+TsDr6,ecx
        xor     ebx,ebx
        mov     [ebp]+TsDr7,edi

;
; Make Dr7 safe before loading junk from save area
;
        mov     dr7,ebx

;
; Load KernelDr* into processor
;

        mov     edi,dword ptr fs:[PcPrcb]
        mov     ebx,[edi].PbProcessorState.PsSpecialRegisters.SrKernelDr0
        mov     ecx,[edi].PbProcessorState.PsSpecialRegisters.SrKernelDr1
        mov     dr0,ebx
        mov     dr1,ecx
        mov     ebx,[edi].PbProcessorState.PsSpecialRegisters.SrKernelDr2
        mov     ecx,[edi].PbProcessorState.PsSpecialRegisters.SrKernelDr3
        mov     dr2,ebx
        mov     dr3,ecx
        mov     ebx,[edi].PbProcessorState.PsSpecialRegisters.SrKernelDr6
        mov     ecx,[edi].PbProcessorState.PsSpecialRegisters.SrKernelDr7
        mov     dr6,ebx
        mov     dr7,ecx

ifnb <V86R>
        test    dword ptr [ebp]+TsEFlags,EFLAGS_V86_MASK
        jz      short b
        jmp     Dr_&V86R
endif
b:
        jmp     Dr_&ExitLabel


ifb <NoAbiosAssist>

        public  Abios_&EnterLabel
align 4
Abios_&EnterLabel:

;
;   INTERRUPT_STACK16_TO_STACK32
;
;       This macro remaps current 32bit stack to 16bit stack at interrupt
;       time.
;
;   Arguments:
;
;       (esp)->trap frame.
;       (eax)->Entry Esp.
;

        mov     eax, [esp].TsErrCode    ; (eax) = Entry Esp
        mov     ecx, KGDT_R0_DATA
        mov     edx, fs:[PcPrcb]        ; get current PRCB address
        mov     edx, [edx]+PbCurrentThread ; get current thread
        mov     edx, [edx]+ThStackLimit ; get thread stack base
        shl     eax, 16
        add     edx, esp
        mov     [esp].TsErrCode, eax
        mov     ss, cx
        mov     esp, edx                ; Interrupts are off
        mov     ebp, edx
        jmp     Abios_&ExitLabel

endif   ; NoAbiosAssist

ifb <NoV86Assist>

        public  V86_&EnterLabel
align 4
V86_&EnterLabel:

;
;   Move the V86 segment registers to the correct place in the frame
;
        mov     eax,dword ptr [ebp].TsV86Fs
        mov     ebx,dword ptr [ebp].TsV86Gs
        mov     ecx,dword ptr [ebp].TsV86Es
        mov     edx,dword ptr [ebp].TsV86Ds
        mov     [ebp].TsSegFs,ax
        mov     [ebp].TsSegGs,bx
        mov     [ebp].TsSegEs,cx
        mov     [ebp].TsSegDs,dx
        jmp     V86_&ExitLabel

endif   ; NoV86Assist

        endm

;++
;
;   ENTER_SYSCALL       AssistLabel, TagetLabel, NoFSLoad, SaveEcx
;
;   Macro Description:
;
;       Build the frame and set registers needed by a system call.
;
;       Save:
;           Errorpad,
;           Non-volatile regs,
;           FS,
;           ExceptionList,
;           PreviousMode
;
;       Don't Save:
;           Volatile regs
;           Seg regs
;           Floating point state
;
;       Set:
;           FS,
;           ExceptionList,
;           PreviousMode,
;           Direction
;
;   Arguments:
;       AssistLabel - label ENTER_ASSIST macro is at
;       TargetLabel - label to emit for ENTER_ASSIST to jump to
;       NoFSLoad    - Don't set FS(it is already set to KGDT_R0_PCR at entry).
;	SaveEcx     - Save ecx off in the trap frame.
;
;   Exit-conditions:
;       Interrupts match input state (this routine doesn't change IEF)
;       (esp)->base of trap frame
;       (ebp)->base of trap frame
;       Preserves entry eax, edx
;
;   Note:
;       The DS: reference to PreviousMode is *required* for correct
;       functioning of lazy selector loads.  If you remove this use
;       of DS:, put a DS: override on something.
;
;--

ENTER_SYSCALL macro     AssistLabel, TargetLabel, NoFSLoad, RejectVdmLabel, SaveEcx


.FPO ( FPO_LOCALS, FPO_PARAMS, FPO_PROLOG, FPO_REGS, FPO_USE_EBP, FPO_TRAPFRAME )

ifdef KERNELONLY

;
; Construct trap frame.
;
; N.B. The initial part of the trap frame is constructed by pushing values
;      on the stack. If the format of the trap frame is changed, then the
;      following code must alos be changed.
;

        push    0                       ; put pad dword for error on stack
        push    ebp                     ; save the non-volatile registers
        push    ebx                     ;
        push    esi                     ;
        push    edi                     ;
ifb <NoFSLoad>
        push    fs                      ; save and set FS to PCR.
        mov     ebx,KGDT_R0_PCR         ; set PCR segment number
        mov     fs,bx                   ;
else
        ; FS already contains KGDT_R0_PCR(entry via PentiumPro fast system call)
        push    KGDT_R3_TEB OR RPL_MASK
endif  ; NoFSLoad

        mov     esi,PCR[PcPrcbData+PbCurrentThread] ; get current thread address
;
; Save the old exception list in trap frame and initialize a new empty
; exception list.
;

        push    PCR[PcExceptionList]    ; save old exception list
        mov     PCR[PcExceptionList],EXCEPTION_CHAIN_END ; set new empty list

;
; Save the old previous mode in trap frame, allocate remainder of trap frame,
; and set the new previous mode.
;

        push    [esi]+ThPreviousMode    ; save old previous mode
        sub     esp,TsPreviousPreviousMode ; allocate remainder of trap frame
        mov     ebx,[esp+TsSegCS]       ; compute new previous mode
        and     ebx,MODE_MASK           ;
        mov     [esi]+ThPreviousMode,bl ; set new previous mode
;
; Save the old trap frame address and set the new trap frame address.
;

        mov     ebp,esp                 ; set trap frame address
        mov     ebx,[esi].ThTrapFrame   ; save current trap frame address
        mov     [ebp].TsEdx,ebx         ;
ifnb <SaveEcx>
        mov     [ebp].TsEcx,ecx         ; Save ecx if requested
endif
        and     dword ptr [ebp].TsDr7, 0
        test    byte ptr [esi].ThDebugActive, 0ffh ; See if we need to save debug registers
        mov     [esi].ThTrapFrame,ebp   ; set new trap frame address
        cld                             ; make sure direction is forward
        
        jnz     Dr_&AssistLabel         ; if nz, debugging is active on thread

Dr_&TargetLabel:                        ;

        SET_DEBUG_DATA                  ; Note this destroys edi
        sti                             ; enable interrupts

else
        %out    ENTER_SYSCAL outside of kernel
        .err
endif
        endm

;++
;
;   ENTER_INTERRUPT     AssistLabel, TargetLabel
;
;   Macro Description:
;
;       Build the frame and set registers needed by an interrupt.
;
;       Save:
;           Errorpad,
;           Non-volatile regs,
;           FS,
;           ExceptionList,
;           PreviousMode
;           Volatile regs
;           Seg regs from V86 mode
;           DS, ES, GS
;
;       Don't Save:
;           Floating point state
;
;       Set:
;           FS,
;           ExceptionList,
;           Direction,
;           DS, ES
;
;       Don't Set:
;           PreviousMode
;
;   Arguments:
;       AssistLabel - label ENTER_ASSIST macro is at
;       TargetLabel - label to emit for ENTER_ASSIST to jump to
;
;   Exit-conditions:
;       Interrupts match input state (this routine doesn't change IEF)
;       (esp)->base of trap frame
;       (ebp)->base of trap frame
;       Preserves entry eax, ecx, edx
;
;--

ENTER_INTERRUPT macro   AssistLabel, TargetLabel, PassParm
        local b

.FPO ( FPO_LOCALS+2, FPO_PARAMS, FPO_PROLOG, FPO_REGS, FPO_USE_EBP, FPO_TRAPFRAME )

;
;   Fill in parts of frame we care about
;

ifb <PassParm>
        push    esp                 ; Use Error code field to save 16bit esp
endif
        push    ebp                 ; Save the non-volatile registers
        push    ebx
        push    esi
        push    edi

        sub     esp, TsEdi
        mov     ebp,esp

        mov     [esp]+TsEax, eax    ; Save volatile registers
        mov     [esp]+TsEcx, ecx
        mov     [esp]+TsEdx, edx
if DBG
        mov     dword ptr [esp]+TsPreviousPreviousMode, -1 ; ThPreviousMode not pushed on interrupt
endif

        test    dword ptr [esp].TsEFlags,EFLAGS_V86_MASK

        jnz     V86_&AssistLabel

        cmp     word ptr [esp]+TsSegCs, KGDT_R0_CODE
        jz      short @f

        mov     [esp]+TsSegFs, fs  ; Save and set FS to PCR.
        mov     [esp]+TsSegDs, ds
        mov     [esp]+TsSegEs, es
        mov     [esp]+TsSegGs, gs

V86_&TargetLabel:
        mov     ebx,KGDT_R0_PCR
        mov     eax,KGDT_R3_DATA OR RPL_MASK
        mov     fs, bx
        mov     ds, ax
        mov     es, ax
@@:
        mov     ebx, fs:[PcExceptionList] ;Save, set ExceptionList
        mov     fs:[PcExceptionList],EXCEPTION_CHAIN_END
        mov     [esp]+TsExceptionList, ebx

ifnb <PassParm>
        lea     eax, [esp].TsErrCode
        lea     ecx, [esp].TsEip    ; Move eax to EIP field
        mov     ebx, ss:[eax]       ; (ebx) = parameter to pass
        mov     ss:[eax], ecx       ; save 16bit esp
endif

;
; Remap ABIOS 16 bit stack to 32 bit stack, if necessary.
;

        cmp     esp, 10000h
        jb      Abios_&AssistLabel

        mov     dword ptr [esp].TsErrCode, 0 ; Indicate no remapping.
Abios_&TargetLabel:

;
; end of Abios stack checking
;

ifdef PcPrcbData
        mov     ecx,PCR[PcPrcbData+PbCurrentThread] ; get current thread address
else
        mov     ecx,PCR[PcPrcb]
        mov     ecx,[ecx].PbCurrentThread ; get current thread address
endif

        cld

        and     dword ptr [ebp].TsDr7, 0
        test    byte ptr [ecx].ThDebugActive, 0ffh ; See if debug registers need saving
ifnb <PassParm>
        push    ebx                 ; push parameter as argument
endif
        jnz     Dr_&AssistLabel

Dr_&TargetLabel:

        SET_DEBUG_DATA

        endm

;++
;
;   ENTER_INTERRUPT_FORCE_STATE   AssistLabel, TargetLabel
;
;   Macro Description:
;
;       Build the frame and set registers needed by an interrupt.
;
;       This macro is the same as ENTER_INTERRUPT except that it forces the
;       needed state and does not save previous state.
;
;       This macro is currently only used by HalpApicRebootService which does not
;       return;
;
;       Save:
;           Errorpad,
;           Non-volatile regs,
;           ExceptionList,
;           PreviousMode
;           Volatile regs
;           Seg regs from V86 mode
;
;       Don't Save:
;           FS,
;           DS, ES, GS
;           Floating point state
;
;       Set:
;           FS,
;           ExceptionList,
;           Direction,
;           DS, ES
;
;       Don't Set:
;           PreviousMode
;
;   Arguments:
;       AssistLabel - label ENTER_ASSIST macro is at
;       TargetLabel - label to emit for ENTER_ASSIST to jump to
;
;   Exit-conditions:
;       Interrupts match input state (this routine doesn't change IEF)
;       (esp)->base of trap frame
;       (ebp)->base of trap frame
;       Preserves entry eax, ecx, edx
;
;--

ENTER_INTERRUPT_FORCE_STATE macro   AssistLabel, TargetLabel, PassParm
        local b

.FPO ( FPO_LOCALS+2, FPO_PARAMS, FPO_PROLOG, FPO_REGS, FPO_USE_EBP, FPO_TRAPFRAME )

;
;   Fill in parts of frame we care about
;

ifb <PassParm>
        push    esp                 ; Use Error code field to save 16bit esp
endif
        push    ebp                 ; Save the non-volatile registers
        push    ebx
        push    esi
        push    edi

        sub     esp, TsEdi
        mov     ebp,esp

        mov     [esp]+TsEax, eax    ; Save volatile registers
        mov     [esp]+TsEcx, ecx
        mov     [esp]+TsEdx, edx
if DBG
        mov     dword ptr [esp]+TsPreviousPreviousMode, -1 ; ThPreviousMode not pushed on interrupt
endif

        test    dword ptr [esp].TsEflags,EFLAGS_V86_MASK

        jnz     V86_&AssistLabel

V86_&TargetLabel:
        mov     ebx,KGDT_R0_PCR
        mov     eax,KGDT_R3_DATA OR RPL_MASK
        mov     fs, bx
        mov     ds, ax
        mov     es, ax
@@:
        mov     ebx, fs:[PcExceptionList] ;Save, set ExceptionList
        mov     fs:[PcExceptionList],EXCEPTION_CHAIN_END
        mov     [esp]+TsExceptionList, ebx

ifnb <PassParm>
        lea     eax, [esp].TsErrCode
        lea     ecx, [esp].TsEip    ; Move eax to EIP field
        mov     ebx, ss:[eax]       ; (ebx) = parameter to pass
        mov     ss:[eax], ecx       ; save 16bit esp
endif

;
; Remap ABIOS 16 bit stack to 32 bit stack, if necessary.
;

        cmp     esp, 10000h
        jb      Abios_&AssistLabel

        mov     dword ptr [esp].TsErrCode, 0 ; Indicate no remapping.
Abios_&TargetLabel:

;
; end of Abios stack checking
;

ifdef PcPrcbData
        mov     ecx,PCR[PcPrcbData+PbCurrentThread] ; get current thread address
else
        mov     ecx,PCR[PcPrcb]
        mov     ecx,[ecx].PbCurrentThread ; get current thread address
endif
        cld

        and     dword ptr [ebp].TsDr7, 0
        test    byte ptr [ecx].ThDebugActive, 0ffh ; See if debug registers need saving
ifnb <PassParm>
        push    ebx                 ; push parameter as argument
endif
        jnz     Dr_&AssistLabel

Dr_&TargetLabel:

        SET_DEBUG_DATA


        endm

;++
;
;   ENTER_TRAP      AssistLabel, TargetLabel
;
;   Macro Description:
;
;       Build the frame and set registers needed by a trap or exception.
;
;       Save:
;           Non-volatile regs,
;           FS,
;           ExceptionList,
;           PreviousMode,
;           Volatile regs
;           Seg Regs from V86 mode
;           DS, ES, GS
;
;       Don't Save:
;           Floating point state
;
;       Set:
;           FS,
;           Direction,
;           DS, ES
;
;       Don't Set:
;           PreviousMode,
;           ExceptionList
;
;   Arguments:
;       AssistLabel - label ENTER_ASSIST macro is at
;       TargetLabel - label to emit for ENTER_ASSIST to jump to
;
;   Exit-conditions:
;       Interrupts match input state (this routine doesn't change IEF)
;       (esp)->base of trap frame
;       (ebp)->base of trap frame
;       Preserves entry eax
;
;--

ENTER_TRAP macro    AssistLabel, TargetLabel
        local b

.FPO ( FPO_LOCALS, FPO_PARAMS, FPO_PROLOG, FPO_REGS, FPO_USE_EBP, FPO_TRAPFRAME )

;
;   Fill in parts of frame we care about
;

if DBG
ifndef  _Ki16BitStackException
    EXTRNP   _Ki16BitStackException
endif
endif ; DBG

        mov     word ptr [esp+2], 0 ; Clear upper word of ErrorCode

        push    ebp                 ; Save the non-volatile registers
        push    ebx
        push    esi
        push    edi

        push    fs                  ; Save and set FS to PCR.
        mov     ebx,KGDT_R0_PCR
        mov     fs,bx
        mov     ebx, fs:[PcExceptionList] ;Save ExceptionList
        push    ebx
if DBG
        push    -1                  ; Don't need to save ThPreviousMode from trap
else
        sub     esp, 4              ; pad dword
endif
        push    eax                 ; Save the volatile registers
        push    ecx
        push    edx

        push    ds                  ; Save segments
        push    es
        push    gs

;
;   Skip allocate reset of trap frame and Set up DS/ES, they may be trash
;

        mov     ax,KGDT_R3_DATA OR RPL_MASK
        sub     esp,TsSegGs
        mov     ds,ax
        mov     es,ax

if DBG
;
; The code here check if the exception occurred in ring 0
; ABIOS code. If yes, this is a fatal condition.  We will
; put out message and bugcheck.
;

        cmp     esp, 10000h             ; Is the trap in abios?
        jb      _Ki16BitStackException       ; if b, yes, switch stack and bugcheck.

endif ; DBG

        mov     ebp,esp

        test    dword ptr [esp].TsEflags,EFLAGS_V86_MASK

        jnz     V86_&AssistLabel

V86_&TargetLabel:

ifdef PcPrcbData
        mov     ecx,PCR[PcPrcbData+PbCurrentThread] ; get current thread address
else
        mov     ecx,PCR[PcPrcb]
        mov     ecx,[ecx].PbCurrentThread ; get current thread address
endif
        cld

        and     dword ptr [ebp].TsDr7, 0
        test    byte ptr [ecx].ThDebugActive, 0ffh ; See if debug registers need saving

        jnz     Dr_&AssistLabel

Dr_&TargetLabel:

        SET_DEBUG_DATA


        endm
;++
;
;   EXIT_ALL    NoRestoreSegs, NoRestoreVolatiles, NoPreviousMode
;
;   Macro Description:
;
;       Load a syscall frame back into the machine.
;
;       Restore:
;           Volatile regs, IF NoRestoreVolatiles blank
;           NoPreviousMode,
;           ExceptionList,
;           FS,
;           Non-volatile regs
;
;       If the frame is a kernel mode frame, AND esp has been edited,
;       then TsSegCs will have a special value.  Test for that value
;       and execute special code for that case.
;
;       N.B. This macro generates an IRET!  (i.e. It exits!)
;
;   Arguments:
;
;       NoRestoreSegs - non-blank if DS, ES, GS are NOT to be restored
;
;       NoRestoreVolatiles - non-blank if Volatile regs are NOT to be restored
;
;       NoPreviousMode - if nb pop ThPreviousMode
;
;   Entry-conditions:
;
;       (esp)->base of trap frame
;       (ebp)->Base of trap frame
;
;   Exit-conditions:
;
;       Does not exit, returns.
;       Preserves eax, ecx, edx, IFF NoRestoreVolatiles is set
;
;--

?adjesp = 0
?RestoreAll = 1

EXIT_ALL macro  NoRestoreSegs, NoRestoreVolatiles, NoPreviousMode
local   a, b, f, x
local   Dr_ExitHelp, Dr_ExitHelp_Target
local   Db_NotATrapFrame, Db_A, Db_NotValidEntry, NonFlatPm_Target
;
; Sanity check some values and setup globals for macro
;

?adjesp = TsSegGs
?RestoreAll = 1

ifnb <NoRestoreSegs>
    ?RestoreAll = 0
    ?adjesp = ?adjesp + 12
endif

ifnb <NoRestoreVolatiles>
    if ?RestoreAll eq 1
        %out "EXIT_ALL NoRestoreVolatiles requires NoRestoreSegs"
        .err
    endif
    ?adjesp = ?adjesp + 12
endif

ifb <NoPreviousMode>
ifndef KERNELONLY
        %out    EXIT_ALL can not restore previousmode outside kernel
        .err
endif
endif

; All callers are responsible for getting here with interrupts disabled.

if DBG
        pushfd
        pop     edx

        test    edx, EFLAGS_INTERRUPT_MASK
        jnz     Db_NotValidEntry

        cmp     esp, ebp                    ; make sure esp = ebp
        jne     Db_NotValidEntry

; Make sure BADB0D00 sig is present.  If not this isn't a trap frame!
Db_A:   sub     [esp]+TsDbgArgMark,0BADB0D00h
        jne     Db_NotATrapFrame

endif

        ASSERT_FS

        mov     edx, [esp]+TsExceptionList
if DBG
        or      edx, edx
        jnz     short @f
    int 3
@@:
endif
        mov     PCR[PcExceptionList], edx   ; Restore ExceptionList

ifb <NoPreviousMode>
        mov     ecx, [esp]+TsPreviousPreviousMode ; Restore PreviousMode
if DBG
        cmp     ecx, -1     ; temporary debugging code
        jne     @f          ; to make sure no one tries to pop ThPreviousMode
    int 3                   ; when it wasn't saved
@@:
endif
        mov     esi,PCR[PcPrcbData+PbCurrentThread]
        mov     [esi]+ThPreviousMode,cl
else
if DBG
        mov     ecx, [esp]+TsPreviousPreviousMode
        cmp     ecx, -1     ; temporary debugging code
        je     @f           ; to make sure no one pushed ThPreviousMode and
    int 3                   ; is now exiting without restoreing it
@@:
endif
endif

        test    dword ptr [esp].TsDr7, (NOT DR7_RESERVED_MASK)
        jnz     Dr_ExitHelp

Dr_ExitHelp_Target:

        test    dword ptr [esp].TsEflags,EFLAGS_V86_MASK
        jnz     V86ExitHelp

        test    word ptr [esp]+TsSegCs,FRAME_EDITED
        jz      b                           ; Edited frame pop out.


if ?RestoreAll eq 0
.errnz MODE_MASK-1
        cmp     word ptr [esp]+TsSegCs,KGDT_R3_CODE OR RPL_MASK ; set/clear ZF
        bt      word ptr [esp]+TsSegCs,0    ; test MODE_MASK      set/clear CF
        cmc                                 ;       (CF=1 and ZF=0)
        ja      f                           ; jmp if CF=0 and ZF=0
endif
ifb <NoRestoreVolatiles>
        mov     edx, [esp]+TsEdx            ; Restore volitales
        mov     ecx, [esp]+TsEcx
                                            ; must restore eax before any
        mov     eax, [esp].TsEax            ; selectors! (see trap0e handler)
endif

        cmp     word ptr [ebp]+TsSegCs, KGDT_R0_CODE
        jz      short @f

ifb <NoRestoreSegs>
        lea     esp, [ebp]+TsSegGs
        pop     gs                          ; Restore Segs
        pop     es
        pop     ds
endif
NonFlatPm_Target:
        lea     esp, [ebp]+TsSegFs
        pop     fs
@@:
        lea     esp, [ebp]+TsEdi            ; Skip PreMode, ExceptList and fs

        pop     edi                         ; restore non-volatiles
        pop     esi
        pop     ebx
        pop     ebp

;
; Esp MUST point to the Error Code on the stack.  Because we use it to
; store the entering esp.
;

        cmp     word ptr [esp+8], 80h ; check for abios code segment?
        ja      AbiosExitHelp

        add     esp, 4              ; remove error code from trap frame

ifnb <NoRestoreVolatiles>

        public  _KiSystemCallExitBranch
        public  _KiSystemCallExit
        public  _KiSystemCallExit2
        public  _KiSystemCallExit3

; NoRestoreVolatiles is only used for return from System Service.
; If returning to Kernel mode, the processor state does not need
; to be altered (CS, CPL stays the same etc), so simply unwind the
; kernel frame and branch to the saved EIP.

        test    dword ptr [esp+4], MODE_MASK

; If the following branch is taken, we are returning to usermode.
; If this processor supports the SYSEXIT instruction, the branch
; will be adjusted at boot time to use the appropriate code sequence.

_KiSystemCallExitBranch:
        jnz     short _KiSystemCallExit

        ; Exit to kernel mode from system call, faster than IRETD,
        ; unwind the frame and branch to return address.

        pop     edx                 ; get eip
        pop     ecx                 ; remove CS from stack
        popfd                       ; restore eflags
        jmp     edx


_KiSystemCallExit:

        iretd                       ; return

_KiSystemCallExit2:

        test    dword ptr [esp+8], EFLAGS_TF
        jne     short _KiSystemCallExit

        pop     edx                 ; pop EIP
        add     esp, 4              ; Remove CS
        and     dword ptr [esp], NOT EFLAGS_INTERRUPT_MASK ; Disable interrupts in the flags
        popfd
        pop     ecx                 ; pop ESP

        sti                         ; sysexit does not reload flags

        iSYSEXIT

_KiSystemCallExit3:

        ; AMD

        pop     ecx                 ; pop EIP
        add     esp, 8
        pop     esp
;        mov     esp, [esp+8]        ; remove CS & Eflags, get ESP

        iSYSRET

endif  ;; <NoRestoreVolatiles>

        iretd                       ; return

if DBG
Db_NotATrapFrame:
        add     [esp]+TsDbgArgMark,0BADB0D00h   ; put back the orig value
Db_NotValidEntry:
        int 3
        jmp     Db_A
endif

;
;   EXIT_HELPER
;
;       if (PreviousMode == UserMode) {
;           DR* regs = TF.Dr* regs
;       }
;
;   Entry-Conditions:
;
;       DebugActive == TRUE
;       (ebp)->TrapFrame
;
;--

align dword
Dr_ExitHelp:

        test    dword ptr [ebp]+TsEFlags,EFLAGS_V86_MASK
        jnz     short x

        test    dword ptr [ebp]+TsSegCs,MODE_MASK
        jz      Dr_ExitHelp_Target

x:      xor     ebx,ebx
        mov     esi,[ebp]+TsDr0
        mov     edi,[ebp]+TsDr1
        mov     dr7,ebx
        mov     dr0,esi
        mov     ebx,[ebp]+TsDr2
        mov     dr1,edi
        mov     dr2,ebx
        mov     esi,[ebp]+TsDr3
        mov     edi,[ebp]+TsDr6
        mov     ebx,[ebp]+TsDr7
        mov     dr3,esi
        mov     dr6,edi
        mov     dr7,ebx

        jmp     Dr_ExitHelp_Target

;
if ?RestoreAll eq 0
;
;   Restore segs and volatiles for non-flat R3 PM (VDM in PM)
;

f:      mov     eax,[esp].TsEax     ; restore eax before any selectors
                                        ; (see trap0e handler)
        add     esp,TsSegGs

        pop     gs
        pop     es
        pop     ds

        pop     edx
        pop     ecx
        jmp     NonFlatPm_Target

endif   ; not ?RestoreAll


;
;   TsSegCs contains the special value that means the frame was edited
;   in a way that affected esp, AND it's a kernel mode frame.
;   (Special value is null selector except for RPL.)
;
;   Put back the real CS.
;   push eflags, eip onto target stack
;   restore
;   switch to target stack
;   iret
;

b:      mov     ebx,[esp]+TsTempSegCs
        mov     [esp]+TsSegCs,ebx

;
;   There is no instruction that will load esp with an arbitrary value
;   (i.e. one out of a frame) and do a return, if no privledge transition
;   is occuring.  Therefore, if we are returning to kernel mode, and
;   esp has been edited, we must "emulate" a kind of iretd.
;
;   We do this by logically pushing the eip,cs,eflags onto the new
;   logical stack, loading that stack, and doing an iretd.  This
;   requires that the new logical stack is at least 1 dword higher
;   than the unedited esp would have been.  (i.e.  It is not legal
;   to edit esp to have a new value < the old value.)
;
;   KeContextToKframes enforces this rule.
;

;
;   Compute new logical stack address
;

        mov     ebx,[esp]+TsTempEsp
        sub     ebx,12
        mov     [esp]+TsErrCode,ebx

;
;   Copy eip,cs,eflags to new stack.  note we do this high to low
;

        mov     esi,[esp]+TsEflags
        mov     [ebx+8],esi
        mov     esi,[esp]+TsSegCs
        mov     [ebx+4],esi
        mov     esi,[esp]+TsEip
        mov     [ebx],esi

;
;   Do a standard restore sequence.
;
;   Observe that RestoreVolatiles is honored.  Editing a volatile
;   register has no effect when returning from a system call.
;
ifb     <NoRestoreVolatiles>
        mov     eax,[esp].TsEax
endif
;        add     esp,TsSegGs
;
;ifb     <NoRestoreSegs>
;        pop     gs
;        pop     es
;        pop     ds
;else
;        add     esp,12
;endif

ifb     <NoRestoreVolatiles>
        mov     edx, [esp]+TsEdx
        mov     ecx, [esp]+TsEcx
endif

;ifnb <NoPreviousMode>
;        add     esp, 4              ; Skip previous mode
;else
;        pop     ebx                 ; Restore PreviousMode
;        mov     esi,fs:[PcPrcbData+PbCurrentThread]
;        mov     ss:[esi]+ThPreviousMode,bl
;endif
;
;       pop     ebx
;
;       mov     fs:[PcExceptionList], ebx ;Restore ExceptionList
;       pop     fs

        add     esp, TsEdi
        pop     edi                 ; restore non-volatiles
        pop     esi
        pop     ebx
        pop     ebp

;
;   (esp)->TsErrCode, where we saved the new esp
;

        mov     esp,[esp]           ; Do move not push to avoid increment
        iretd

        endm


;++
;
;   INTERRUPT_EXIT
;
;   Macro Description:
;
;       This macro is executed on return from an interrupt vector service
;       service routine.  Its function is to restore privileged processor
;       state, and continue thread execution. If control is returning to
;       user mode and there is a user  APC pending, then APC level interupt
;       will be requested and control is transfered to the user APC delivery
;       routine, if no higher level interrupt pending.
;
;   Arguments:
;
;       (TOS)   = previous irql
;       (TOS+4) = irq vector to eoi
;       (TOS+8 ...) = machine_state frame
;       (ebp)-> machine state frame (trap frame)
;
;--

INTERRUPT_EXIT     macro    DebugCheck
local   a

ifnb <DebugCheck>
        POLL_DEBUGGER
endif
if DBG                                          ; save current eip for
a:      mov     esi, offset a                   ; debugging bad trap frames
endif

;
; N.B. End system interrupt MUST be called with a trap frame at 8[esp].
;

ifdef __imp_Kei386EoiHelper@0
        cli

        call    _HalEndSystemInterrupt@8
        jmp     dword ptr [__imp_Kei386EoiHelper@0]

else
        cli
        call    dword ptr [__imp__HalEndSystemInterrupt@8]
        jmp     Kei386EoiHelper@0
endif
endm


;++
;
;   SPURIOUS_INTERRUPT_EXIT
;
;   Macro Description:
;
;       To exit an interrupt without performing the EOI.
;
;   Arguments:
;
;       (TOS) = machine_state frame
;       (ebp)-> machine state frame (trap frame)
;
;--

SPURIOUS_INTERRUPT_EXIT  macro
local   a
if DBG                                          ; save current eip for
a:      mov     esi, offset a                   ; debugging bad trap frames
endif


ifdef __imp_Kei386EoiHelper@0
        jmp     dword ptr [__imp_Kei386EoiHelper@0]
else
        jmp     Kei386EoiHelper@0
endif
endm

;++
;
;   ENTER_TRAPV86
;
;   Macro Description:
;
;       Construct trap frame for v86 mode traps.
;
;--

ENTER_TRAPV86 macro DRENTER,V86ENTER
        sub     esp, TsErrCode
        mov     word ptr [esp].TsErrCode + 2, 0
        mov     [esp].TsEbx, ebx
        mov     [esp].TsEax, eax
        mov     [esp].TsEbp, ebp
        mov     [esp].TsEsi, esi
        mov     [esp].TsEdi, edi
        mov     ebx, KGDT_R0_PCR
        mov     eax, KGDT_R3_DATA OR RPL_MASK
        mov     [esp].TsEcx, ecx
        mov     [esp].TsEdx, edx
if DBG
        mov     [esp].TsPreviousPreviousMode, -1
        mov     [esp].TsDbgArgMark, 0BADB0D00h
endif
        mov     fs, bx
        mov     ds, ax
        mov     es, ax
        mov     ebp, esp
        mov     eax, PCR[PcExceptionList]
        mov     [esp]+TsExceptionList, eax
        mov     eax, dr7
        cld                             ; do we really need it?
        test    eax, (NOT DR7_RESERVED_MASK)
        mov     [esp].TsDr7, eax
        jnz     Dr_&DRENTER

Dr_&V86ENTER:
endm


;
; Taken from ntos\vdm\i386\vdmtb.inc
;

FIXED_NTVDMSTATE_LINEAR_PC_AT equ 0714H
FIXED_NTVDMSTATE_LINEAR_PC_98 equ 0614H
MACHINE_TYPE_MASK equ 0ff00H
VDM_VIRTUAL_INTERRUPTS  equ 0200H

;++
;
;   EXIT_TRAPV86
;
;   Macro Description:
;
;       if UserApc is pending deliver it
;       if User Context is v86 mode
;          Exit from kernel (does not return)
;       else
;          return (expected to execute EXIT_ALL)
;--

EXIT_TRAPV86 macro
        local w, x, y, z

z:      mov     ebx, PCR[PcPrcbData+PbCurrentThread]
        mov     byte ptr [ebx]+ThAlerted, 0
        cmp     byte ptr [ebx]+ThApcState.AsUserApcPending, 0
        jne     short w

        ;
        ; Kernel exit to V86 mode
        ;

        add     esp,TsEdx
        pop     edx
        pop     ecx
        pop     eax
        test    dword ptr [ebp].TsDr7, (NOT DR7_RESERVED_MASK)
        jnz     short x
y:
        add     esp,12              ; unused fields
        pop     edi
        pop     esi
        pop     ebx
        pop     ebp
        add     esp,4               ; clear error code
        iretd

x:      xor     ebx, ebx
        mov     esi,[ebp]+TsDr0
        mov     edi,[ebp]+TsDr1
        mov     dr7, ebx            ; Turn off debug exceptions while reloading
        mov     ebx,[ebp]+TsDr2
        mov     dr0,esi
        mov     dr1,edi
        mov     dr2,ebx
        mov     esi,[ebp]+TsDr3
        mov     edi,[ebp]+TsDr6
        mov     ebx,[ebp]+TsDr7
        mov     dr3,esi
        mov     dr6,edi
        mov     dr7,ebx
        jmp     short y

w:
        ;
        ; Dispatch user mode APC
        ; The APC routine runs with interrupts on and at APC level
        ;

        RaiseIrql APC_LEVEL
        push    eax                              ; Save OldIrql
        sti

        stdCall _KiDeliverApc, <1, 0, ebp>       ; ebp - Trap frame
                                                 ; 0 - Null exception frame
                                                 ; 1 - Previous mode

        pop     ecx                              ; (TOS) = OldIrql
        LowerIrql ecx

        cli

        ;
        ; UserApc may have changed to vdm Monitor context (user flat 32)
        ; If it has cannot use the v86 only kernel exit
        ;

        test    dword ptr [ebp]+TsEFlags,EFLAGS_V86_MASK
        jnz     z

        ; Exit to do EXIT_ALL
endm


;++
;
;   PERF_GET_TIMESTAMP
;
;   Macro Description:
;
;
;   Return a time stamp that for event tracing in EDX:EAX
;
;   NOTE: This may trash ECX
; 
;   In retail, get the clock value from WmiGetCpuClock.  Else if using
;   reserved memory for logging, get cycle counter.  
; 
;--
PERF_GET_TIMESTAMP macro
        extrn   _WmiGetCpuClock:DWORD

        call    [_WmiGetCpuClock]

endm
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ke\i386\largepag.c ===
//
// Copyright (c) Microsoft Corporation. All rights reserved. 
//
// You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
// If you do not agree to the terms, do not use the code.
//

#include "ki.h"

PVOID
Ki386AllocateContiguousMemory(
    IN OUT PIDENTITY_MAP IdentityMap,
    IN     ULONG Pages,
    IN     BOOLEAN Low4Meg
    );

BOOLEAN
Ki386IdentityMapMakeValid(
    IN OUT PIDENTITY_MAP IdentityMap,
    IN     PHARDWARE_PTE PageTableEntry,
    OUT    PVOID *Page OPTIONAL
    );

BOOLEAN
Ki386MapAddress(
    IN OUT PIDENTITY_MAP IdentityMap,
    IN     ULONG Va,
    IN     PHYSICAL_ADDRESS PhysicalAddress
    );

PVOID
Ki386ConvertPte(
    IN OUT PHARDWARE_PTE Pte
    );

PHYSICAL_ADDRESS
Ki386BuildIdentityBuffer(
    IN OUT PIDENTITY_MAP IdentityMap,
    IN     PVOID StartVa,
    IN     ULONG Length,
    OUT    PULONG PagesToMap
    );

#ifdef ALLOC_PRAGMA

#pragma alloc_text(INIT,Ki386AllocateContiguousMemory)
#pragma alloc_text(INIT,Ki386BuildIdentityBuffer)
#pragma alloc_text(INIT,Ki386ClearIdentityMap)
#pragma alloc_text(INIT,Ki386ConvertPte)
#pragma alloc_text(INIT,Ki386CreateIdentityMap)
#pragma alloc_text(INIT,Ki386EnableTargetLargePage)
#pragma alloc_text(INIT,Ki386IdentityMapMakeValid)
#pragma alloc_text(INIT,Ki386MapAddress)

#endif

#define PTES_PER_PAGE (PAGE_SIZE / sizeof(HARDWARE_PTE))

BOOLEAN
Ki386CreateIdentityMap(
    IN OUT PIDENTITY_MAP IdentityMap,
    IN     PVOID StartVa,
    IN     PVOID EndVa
    )
{
/*++

    This function creates an identity mapping for a region of memory.

    If the region of memory passed in includes memory that lies above
    4G, then a new buffer is allocated below 4G.

Arguments:

    IdentityMap - Pointer to the structure which will be filled with the newly
                  created top-level directory address.  It also provides
                  storage for the pointers used in allocating and freeing the
                  memory.

    StartVa - Pointer to the first byte of the region of memory that is to be
              memory mapped.

    EndVa - Pointer to the byte immediately after the last byte of the region
            that is to be memory mapped.

Return Value:

    TRUE if the function succeeds, FALSE otherwise.

    Note - Ki386ClearIdentityMap() should be called even on FALSE return to
    free any memory allocated.

--*/

    ULONG pageDirectoryIndex;
    ULONG pagesToMap;
    PCHAR currentVa;
    ULONG length;
    BOOLEAN result;
    PHARDWARE_PTE pageDirectory;
    PHARDWARE_PTE pageDirectoryEntry;
    PHYSICAL_ADDRESS identityAddress;

#if defined(_X86PAE_)

    ULONG pageDirectoryPointerTableIndex;
    PHARDWARE_PTE pageDirectoryPointerTable;
    PHARDWARE_PTE pageDirectoryPointerTableEntry;

#endif

    //
    // Initialize the IdentityMap structure to a known state.
    //

    RtlZeroMemory( IdentityMap, sizeof(IDENTITY_MAP) );
    length = (PCHAR)EndVa - (PCHAR)StartVa;

    //
    // Get the physical address of the input buffer (or suitable copy).
    //

    identityAddress = Ki386BuildIdentityBuffer( IdentityMap,
                                                StartVa,
                                                length,
                                                &pagesToMap );
    if( identityAddress.QuadPart == 0) {

        //
        // The input buffer was not contiguous or not below 4G, and a
        // suitable buffer could not be allocated.
        //

        return FALSE;
    }

    IdentityMap->IdentityAddr = identityAddress.LowPart;

    //
    // Set up the mappings.
    //

    currentVa = StartVa;
    do {

        //
        // Map in the virtual address
        //

        result = Ki386MapAddress( IdentityMap,
                                  (ULONG)currentVa,
                                  identityAddress );
        if (result == FALSE) {
            return FALSE;
        }

        //
        // Map in the identity (physical) address
        //

        result = Ki386MapAddress( IdentityMap,
                                  identityAddress.LowPart,
                                  identityAddress );
        if (result == FALSE) {
            return FALSE;
        }

        //
        // Advance both the Va and identityAddress pointers in anticipation
        // of mapping in another page.
        //

        currentVa += PAGE_SIZE;
        identityAddress.QuadPart += PAGE_SIZE;
        pagesToMap -= 1;

    } while (pagesToMap > 0);

    //
    // Now go through the page directory pointer table and page directories,
    // converting virtual page frames to physical ones.
    //

#if defined(_X86PAE_)

    //
    // This PAE-only outer loop walks the page directory pointer table entries
    // and processes each valid page directory referenced.
    //

    pageDirectoryPointerTable = IdentityMap->TopLevelDirectory;
    for (pageDirectoryPointerTableIndex = 0;
         pageDirectoryPointerTableIndex < (1 << PPI_BITS);
         pageDirectoryPointerTableIndex++) {

        pageDirectoryPointerTableEntry =
            &pageDirectoryPointerTable[ pageDirectoryPointerTableIndex ];

        if (pageDirectoryPointerTableEntry->Valid == 0) {
            continue;
        }

        pageDirectory =
            (PHARDWARE_PTE)Ki386ConvertPte( pageDirectoryPointerTableEntry );

#else
        pageDirectory = IdentityMap->TopLevelDirectory;
#endif

        for (pageDirectoryIndex = 0;
             pageDirectoryIndex < PTES_PER_PAGE;
             pageDirectoryIndex++) {

            pageDirectoryEntry = &pageDirectory[ pageDirectoryIndex ];
            if (pageDirectoryEntry->Valid == 0) {
                continue;
            }

            Ki386ConvertPte( pageDirectoryEntry );
        }

#if defined(_X86PAE_)
    }
#endif

    identityAddress = MmGetPhysicalAddress( IdentityMap->TopLevelDirectory );
    IdentityMap->IdentityCR3 = identityAddress.LowPart;

    return TRUE;
}

PVOID
Ki386AllocateContiguousMemory(
    IN OUT PIDENTITY_MAP IdentityMap,
    IN     ULONG Pages,
    IN     BOOLEAN Low4Meg
    )
/*++

    This function allocates page-aligned, physically contiguous memory.
    The allocation is recorded in the IdentityMap structure, so that it
    can be freed on cleanup.

Arguments:

    IdentityMap - Context pointer for this identity mapping.

    Pages - Number of pages to allocate

    Low4Meg - Indicates whether the allocation must be below 4M.

Return Value:

    Pointer to the new page on success, NULL otherwise.

--*/
{
    ULONG pageListIndex;
    PVOID page;
    ULONG allocationSize;
    PHYSICAL_ADDRESS highestAddress;

    if (Low4Meg != FALSE) {

        //
        // The caller has specified that a page must reside physically
        // below 4 MB.
        //

        highestAddress.LowPart = 0xFFFFFFFF;
        highestAddress.HighPart = 0;

    } else {

        //
        // Memory can reside anywhere
        //

        highestAddress.LowPart = 0xFFFFFFFF;
        highestAddress.HighPart = 0xFFFFFFFF;
    }

    allocationSize = Pages * PAGE_SIZE;
    page = MmAllocateContiguousMemory( allocationSize, highestAddress );
    if (page != NULL) {

        //
        // Record that this page was allocated so that it can be freed when
        // the IdentityMap structure is cleared.
        //

        pageListIndex = IdentityMap->PagesAllocated;
        IdentityMap->PageList[ pageListIndex ] = page;
        IdentityMap->PagesAllocated++;

        //
        // Initialize it.
        //

        RtlZeroMemory( page, allocationSize );
    }

    return page;
}

BOOLEAN
Ki386IdentityMapMakeValid(
    IN OUT PIDENTITY_MAP IdentityMap,
    IN     PHARDWARE_PTE PageTableEntry,
    OUT    PVOID *Page OPTIONAL
    )
/*++

    If the page table has the valid bit set, this function merely returns
    the address referenced by the page table entry.

    If the page table does not have the valid bit set, then another page
    is allocated and inserted into the page table entry and the entry is
    marked valid.

    NOTE: At this point, PTE frames are virtual.  After the entire mapping
          is built, we go through and convert all virtual frames to physical
          ones.

Arguments:

    IdentityMap - Context pointer for this identity mapping.

    PageTableEntry - Pointer to the page table entry.

    Page - Virtual address now referenced by the PTE, whether it was
           valid before or not.

Return Value:

    TRUE on success, FALSE otherwise.

--*/
{
    PVOID page;

    if (PageTableEntry->Valid != 0) {

        //
        // If it already is present, there is nothing to do except record
        // the virtual page number that is already there.
        //

        page = (PVOID)((ULONG)(PageTableEntry->PageFrameNumber << PAGE_SHIFT));

    } else {

        //
        // The page table entry is not valid.  Allocate a new page table.
        //

        page = Ki386AllocateContiguousMemory( IdentityMap, 1, FALSE );
        if (page == NULL) {
            return FALSE;
        }

        //
        // Insert it into the page table entry and mark it valid.
        //
        // NOTE: Virtual page numbers are inserted into the page table
        //       structure as it is being built.  When it is finished, we walk
        //       the tables and convert all of the virtual page numbers to
        //       physical page numbers.
        //

        PageTableEntry->PageFrameNumber = ((ULONG)page) >> PAGE_SHIFT;
        PageTableEntry->Valid = 1;
    }

    if (ARGUMENT_PRESENT( Page )) {
        *Page = page;
    }

    return TRUE;
}

BOOLEAN
Ki386MapAddress(
    IN OUT PIDENTITY_MAP IdentityMap,
    IN     ULONG Va,
    IN     PHYSICAL_ADDRESS PhysicalAddress
    )

/*++

    Creates a new virtual->physical mapping in the identity map.

Arguments:

    IdentityMap - Context pointer for this identity mapping.

    Va - Virtual address to map.

    PhysicalAddress - Physical address to map.

Return Value:

    TRUE on success, FALSE otherwise.

--*/
{
    PHARDWARE_PTE pageTable;
    PHARDWARE_PTE pageTableEntry;
    PHARDWARE_PTE pageDirectory;
    PHARDWARE_PTE pageDirectoryEntry;
    PVOID table;
    ULONG index;
    BOOLEAN result;

#if defined(_X86PAE_)
    PHARDWARE_PTE pageDirectoryPointerTable;
    PHARDWARE_PTE pageDirectoryPointerTableEntry;
#endif

    if (IdentityMap->TopLevelDirectory == NULL) {

        //
        // Allocate a top-level directory structure, either a page directory
        // or a page directory pointer table.
        //

        table = Ki386AllocateContiguousMemory( IdentityMap, 1, TRUE );
        if (table == FALSE) {
            return FALSE;
        }

        IdentityMap->TopLevelDirectory = table;
    }

#if defined(_X86PAE_)

    index = KiGetPpeIndex( Va );
    pageDirectoryPointerTable = IdentityMap->TopLevelDirectory;
    pageDirectoryPointerTableEntry = &pageDirectoryPointerTable[ index ];

    result = Ki386IdentityMapMakeValid( IdentityMap,
                                        pageDirectoryPointerTableEntry,
                                        &pageDirectory );
    if (result == FALSE) {
        return FALSE;
    }

#else

    pageDirectory = IdentityMap->TopLevelDirectory;

#endif

    //
    // Get a pointer to the appropriate page directory entry.  If it is
    // not valid, allocate a new page table and mark the page directory
    // entry valid and writeable.
    //

    index = KiGetPdeIndex( Va );
    pageDirectoryEntry = &pageDirectory[ index ];
    result = Ki386IdentityMapMakeValid( IdentityMap,
                                        pageDirectoryEntry,
                                        &pageTable );
    if (result == FALSE) {
        return FALSE;
    }
    pageDirectoryEntry->Write = 1;

    //
    // Get a pointer to the appropriate page table entry and fill it in.
    //

    index = KiGetPteIndex( Va );
    pageTableEntry = &pageTable[ index ];

#if defined(_X86PAE_)
    pageTableEntry->PageFrameNumber = PhysicalAddress.QuadPart >> PAGE_SHIFT;
#else
    pageTableEntry->PageFrameNumber = PhysicalAddress.LowPart >> PAGE_SHIFT;
#endif
    pageTableEntry->Valid = 1;

    return TRUE;
}

PVOID
Ki386ConvertPte(
    IN OUT PHARDWARE_PTE Pte
    )
/*++

    Converts the virtual frame number in a PTE to a physical frame number.

Arguments:

    Pte - Pointer to the page table entry to convert.

Return Value:

    None.

--*/
{
    PVOID va;
    PHYSICAL_ADDRESS physicalAddress;

    ASSERT (Pte->PageFrameNumber < 0x100000);

    va = (PVOID)(ULONG_PTR)(Pte->PageFrameNumber << PAGE_SHIFT);
    physicalAddress = MmGetPhysicalAddress( va );

#if defined(_X86PAE_)
    Pte->PageFrameNumber = physicalAddress.QuadPart >> PAGE_SHIFT;
#else
    Pte->PageFrameNumber = physicalAddress.LowPart >> PAGE_SHIFT;
#endif

    return va;
}

PHYSICAL_ADDRESS
Ki386BuildIdentityBuffer(
    IN OUT PIDENTITY_MAP IdentityMap,
    IN     PVOID StartVa,
    IN     ULONG Length,
    OUT    PULONG PagesToMap
    )
{

/*++

    This function checks to see if the physical memory backing a virtual
    buffer is physically contiguous and lies completely below 4G.

    If these requirements are met, then the physical address of StartVa is
    returned.

    If not, then a physically contiguous buffer is allocated, the contents
    of the region is copied in, and its address is returned.

Arguments:

    IdentityMap - Pointer to the identity map building structure.

    StartVa - Virtual address of the start of the region for which a
              physically contiguous copy is desired.

    Length - Length of the region for which a physically contiguous copy
             is desired.

--*/

    ULONG pagesToMap;
    ULONG pagesRemaining;
    PCHAR nextVirtualAddress;
    PHYSICAL_ADDRESS nextPhysicalAddress;
    PHYSICAL_ADDRESS physicalAddress;
    PHYSICAL_ADDRESS firstPhysicalAddress;
    ULONG pageOffset;
    PCHAR identityBuffer;

    //
    // Count the number of pages in the buffer, and record the physical
    // address of the start of the buffer.
    //

    pagesToMap = ADDRESS_AND_SIZE_TO_SPAN_PAGES( StartVa, Length );
    nextVirtualAddress = StartVa;
    firstPhysicalAddress = MmGetPhysicalAddress( StartVa );
    nextPhysicalAddress = firstPhysicalAddress;

    //
    // Examine each page in the region.
    //

    pagesRemaining = pagesToMap;
    while (TRUE) {

        physicalAddress = MmGetPhysicalAddress( nextVirtualAddress );
        if (physicalAddress.QuadPart != nextPhysicalAddress.QuadPart) {

            //
            // The buffer is not physically contiguous.
            //

            break;
        }

        if (physicalAddress.HighPart != 0) {

            //
            // The buffer does not lie entirely below 4G
            //

            break;
        }

        pagesRemaining -= 1;
        if (pagesRemaining == 0) {

            //
            // All of the pages in the buffer have been examined, and have
            // been found to meet the critera.  Return the physical address
            // of the start of the buffer.
            //

            *PagesToMap = pagesToMap;
            return firstPhysicalAddress;
        }

        nextVirtualAddress += PAGE_SIZE;
        nextPhysicalAddress.QuadPart += PAGE_SIZE;
    }

    //
    // The buffer does not meet the criteria and so its contents must be
    // copied to a buffer that does.
    //

    identityBuffer = Ki386AllocateContiguousMemory( IdentityMap,
                                                    pagesToMap,
                                                    TRUE );
    if (identityBuffer == 0) {

        //
        // A contiguous region of the appropriate size could not be located
        // below 4G physical.
        //

        physicalAddress.QuadPart = 0;

    } else {

        //
        // Got an appropriate physical buffer, now copy in the data
        //

        pageOffset = (ULONG)StartVa & (PAGE_SIZE-1);
        identityBuffer += pageOffset;

        RtlCopyMemory( identityBuffer, StartVa, Length );
        physicalAddress = MmGetPhysicalAddress( identityBuffer );

        *PagesToMap = pagesToMap;
    }

    return physicalAddress;
}



VOID
Ki386ClearIdentityMap(
    IN PIDENTITY_MAP IdentityMap
    )
{
/*++

    This function just frees the page directory and page tables created in
    Ki386CreateIdentityMap().

--*/

    ULONG index;
    PVOID page;

    //
    // IdentityMap->PageList is an array of addresses of pages allocated with
    // MmAllocateContiguousMemory().  Walk the array, freeing each page.
    //

    for (index = 0; index < IdentityMap->PagesAllocated; index++) {

        page = IdentityMap->PageList[ index ];
        MmFreeContiguousMemory( page );
    }
}

VOID
Ki386EnableTargetLargePage(
    IN PIDENTITY_MAP IdentityMap
    )
{
/*++

    This function just passes info on to the assembly routine
    Ki386EnableLargePage().

--*/

    Ki386EnableCurrentLargePage(IdentityMap->IdentityAddr,
                                IdentityMap->IdentityCR3);
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ke\i386\ldtsup.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    ldtsup.c

Abstract:

    This module implements interfaces that support manipulation of i386 Ldts.
    These entry points only exist on i386 machines.

--*/

#include "ki.h"

//
// Low level assembler support procedures
//

VOID
KiLoadLdtr(
    VOID
    );

VOID
KiFlushDescriptors(
    VOID
    );

//
// Local service procedures
//


VOID
Ki386LoadTargetLdtr (
    PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

VOID
Ki386FlushTargetDescriptors (
    PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

typedef struct _LDTINFO {
    PKPROCESS Process;
    KGDTENTRY LdtDescriptor;
    ULONG Offset;
    LDT_ENTRY LdtEntry;
    PLDT_ENTRY Ldt;
} LDTINFO, *PLDTINFO;

VOID
Ke386SetLdtProcess (
    IN PKPROCESS Process,
    IN PLDT_ENTRY Ldt,
    IN ULONG Limit
    )

/*++

Routine Description:

    The specified LDT (which may be null) will be made the active Ldt of
    the specified process, for all threads thereof, on whichever
    processors they are running.  The change will take effect before the
    call returns.

    An Ldt address of NULL or a Limit of 0 will cause the process to
    receive the NULL Ldt.

    This function only exists on i386 and i386 compatible processors.

    No checking is done on the validity of Ldt entries.


    N.B.

    While a single Ldt structure can be shared among processes, any
    edits to the Ldt of one of those processes will only be synchronized
    for that process.  Thus, processes other than the one the change is
    applied to may not see the change correctly.

Arguments:

    Process - Pointer to KPROCESS object describing the process for
        which the Ldt is to be set.

    Ldt - Pointer to an array of LDT_ENTRYs (that is, a pointer to an
        Ldt.)

    Limit - Ldt limit (must be 0 mod 8)

Return Value:

    None.

--*/

{
    LDTINFO LdtInfo;
    KGDTENTRY LdtDescriptor;

    //
    // Compute the contents of the Ldt descriptor
    //

    if ((Ldt == NULL) || (Limit == 0)) {

        //
        //  Set up an empty descriptor
        //

        LdtDescriptor.LimitLow = 0;
        LdtDescriptor.BaseLow = 0;
        LdtDescriptor.HighWord.Bytes.BaseMid = 0;
        LdtDescriptor.HighWord.Bytes.Flags1 = 0;
        LdtDescriptor.HighWord.Bytes.Flags2 = 0;
        LdtDescriptor.HighWord.Bytes.BaseHi = 0;

    } else {

        //
        // Ensure that the unfilled fields of the selector are zero
        // N.B.  If this is not done, random values appear in the high
        //       portion of the Ldt limit.
        //

        LdtDescriptor.HighWord.Bytes.Flags1 = 0;
        LdtDescriptor.HighWord.Bytes.Flags2 = 0;

        //
        //  Set the limit and base
        //

        LdtDescriptor.LimitLow = (USHORT) ((ULONG) Limit - 1);
        LdtDescriptor.BaseLow = (USHORT)  ((ULONG) Ldt & 0xffff);
        LdtDescriptor.HighWord.Bytes.BaseMid = (UCHAR) (((ULONG)Ldt & 0xff0000) >> 16);
        LdtDescriptor.HighWord.Bytes.BaseHi =  (UCHAR) (((ULONG)Ldt & 0xff000000) >> 24);

        //
        //  Type is LDT, DPL = 0
        //

        LdtDescriptor.HighWord.Bits.Type = TYPE_LDT;
        LdtDescriptor.HighWord.Bits.Dpl = DPL_SYSTEM;

        //
        // Make it present
        //

        LdtDescriptor.HighWord.Bits.Pres = 1;

    }

    LdtInfo.Process       = Process;
    LdtInfo.LdtDescriptor = LdtDescriptor;

    KeGenericCallDpc (Ki386LoadTargetLdtr,
                      &LdtInfo);

    return;
}

VOID
Ki386LoadTargetLdtr (
    PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )
/*++

Routine Description:

    Reload local Ldt register and clear signal bit in TargetProcessor mask

Arguments:

    Dpc - DPC used to initiate this call
    DeferredContext - Context
    SystemArgument1 - System context, Used to signal completion of this call
    SystemArgument2 - System context

Return Value:

    none.

--*/

{
    PLDTINFO LdtInfo;

    UNREFERENCED_PARAMETER (Dpc);

    LdtInfo = DeferredContext;

    //
    // Make sure all DPC's are running so a load of the process
    // LdtDescriptor field can't be torn
    //

    if (KeSignalCallDpcSynchronize (SystemArgument2)) {

        //
        // Set the Ldt fields in the process object.
        //

        LdtInfo->Process->LdtDescriptor = LdtInfo->LdtDescriptor;
    }

    //
    // Make sure the field has been updated before we continue
    //

    KeSignalCallDpcSynchronize (SystemArgument2);

    //
    // Reload the LDTR register from currently active process object
    //

    KiLoadLdtr();

    //
    // Signal that all processing has been done
    //

    KeSignalCallDpcDone (SystemArgument1);
    return;
}

VOID
Ke386SetDescriptorProcess (
    IN PKPROCESS Process,
    IN ULONG Offset,
    IN LDT_ENTRY LdtEntry
    )
/*++

Routine Description:

    The specified LdtEntry (which could be 0, not present, etc) will be
    edited into the specified Offset in the Ldt of the specified Process.
    This will be synchronized across all the processors executing the
    process.  The edit will take affect on all processors before the call
    returns.

    N.B.

    Editing an Ldt descriptor requires stalling all processors active
    for the process, to prevent accidental loading of descriptors in
    an inconsistent state.

Arguments:

    Process - Pointer to KPROCESS object describing the process for
        which the descriptor edit is to be performed.

    Offset - Byte offset into the Ldt of the descriptor to edit.
        Must be 0 mod 8.

    LdtEntry - Value to edit into the descriptor in hardware format.
        No checking is done on the validity of this item.

Return Value:

    none.

--*/

{

    PLDT_ENTRY Ldt;
    LDTINFO LdtInfo;

    //
    // Compute address of descriptor to edit. It is safe to fetch the process
    // LdtDescriptor here as we are always called with the PS LdtMutex held.
    //

    Ldt =
        (PLDT_ENTRY)
         ((Process->LdtDescriptor.HighWord.Bytes.BaseHi << 24) |
         ((Process->LdtDescriptor.HighWord.Bytes.BaseMid << 16) & 0xff0000) |
         (Process->LdtDescriptor.BaseLow & 0xffff));
    Offset = Offset / 8;


    LdtInfo.Process  = Process;
    LdtInfo.Offset   = Offset;
    LdtInfo.Ldt      = Ldt;
    LdtInfo.LdtEntry = LdtEntry;

    KeGenericCallDpc (Ki386FlushTargetDescriptors,
                      &LdtInfo);

    return;
}

VOID
Ki386FlushTargetDescriptors (
    PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )

/*++

Routine Description:

    This function flushes the segment descriptors on the current processor.

Arguments:

    Dpc - DPC used to initiate this call
    DeferredContext - Context
    SystemArgument1 - System context, Used to signal completion of this call
    SystemArgument2 - System context

Return Value:

    none.

--*/

{
    PLDTINFO LdtInfo;

    UNREFERENCED_PARAMETER (Dpc);

    LdtInfo = DeferredContext;

    //
    // Flush the segment descriptors on the current processor.
    // This call removes all possible references to the LDT from
    // the segment registers.
    //

    KiFlushDescriptors ();

    //
    // Make sure all DPC's are running so a load of the process
    // LdtDescriptor field can't be torn
    //

    if (KeSignalCallDpcSynchronize (SystemArgument2)) {

        //
        // Update the LDT entry
        //

        LdtInfo->Ldt[LdtInfo->Offset] = LdtInfo->LdtEntry;
    }

    //
    // Wait until everyone has got to this point before continuing
    //

    KeSignalCallDpcSynchronize (SystemArgument2);


    //
    // Signal that all processing has been done
    //

    KeSignalCallDpcDone (SystemArgument1);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ke\i386\misc.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    misc.c

Abstract:

    This module implements machine dependent miscellaneous kernel functions.

--*/

#include "ki.h"
#include "fastsys.inc"

extern BOOLEAN KeI386FxsrPresent;
extern BOOLEAN KeI386XMMIPresent;
extern UCHAR KiSystemCallExitBranch[];
extern UCHAR KiFastCallEntry[];
extern UCHAR KiDefaultSystemCall[];
extern UCHAR KiSystemCallExit[];
extern UCHAR KiSystemCallExit2[];
extern UCHAR KiSystemCallExit3[];
extern UCHAR KiFastSystemCallIa32[];
extern UCHAR KiFastSystemCallAmdK6[];
extern ULONG_PTR KiSystemCallExitAdjust;
extern ULONG KiFastSystemCallDisable;

ULONG_PTR KiSystemCallExitAdjust;
UCHAR KiSystemCallExitAdjusted;
BOOLEAN KiFastSystemCallIsIA32;
BOOLEAN KiFastCallCopyDoneOnce = FALSE;

VOID
KeRestoreMtrr (
    VOID
    );

VOID
KeRestorePAT(
    VOID
    );
//
//
// Internal format of the floating_save structure which is passed.
//

typedef struct _CONTROL_WORD {
    USHORT      ControlWord;
    ULONG       MXCsr;
} CONTROL_WORD, *PCONTROL_WORD;

typedef struct {
    UCHAR       Flags;
    KIRQL       Irql;
    KIRQL       PreviousNpxIrql;
    UCHAR       Spare[2];

    union {
        CONTROL_WORD    Fcw;
        PFX_SAVE_AREA   Context;
        ULONG_PTR       ContextAddressAsULONG;
    } u;
    ULONG       Cr0NpxState;

    PKTHREAD    Thread;         // debug

} FLOAT_SAVE, *PFLOAT_SAVE;


#define FLOAT_SAVE_COMPLETE_CONTEXT     0x01
#define FLOAT_SAVE_FREE_CONTEXT_HEAP    0x02
#define FLOAT_SAVE_VALID                0x04
#define FLOAT_SAVE_ALIGN_ADJUSTED       0x08
#define FLOAT_SAVE_RESERVED             0xF0

//
// Allocate Pool returns a pointer which is 8 byte aligned.  The
// floating point save area needs to be 16 byte aligned.  When 
// allocating the save area we add the difference and adjust if
// needed.
//

#define ALIGN_ADJUST                    8


NTSTATUS
KeSaveFloatingPointState (
    OUT PKFLOATING_SAVE     PublicFloatSave
    )
/*++

Routine Description:

    This routine saves the thread's current non-volatile NPX state,
    and sets a new initial floating point state for the caller.

Arguments:

    FloatSave - receives the current non-volatile npx state for the thread

Return Value:

--*/
{
    PKTHREAD Thread;
    PFX_SAVE_AREA NpxFrame;
    KIRQL                   Irql;
    USHORT                  ControlWord;
    ULONG                   MXCsr;
    PKPRCB                  Prcb;
    PFLOAT_SAVE             FloatSave;

    //
    // If the system is using floating point emulation, then
    // return an error
    //

    if (!KeI386NpxPresent) {
        return STATUS_ILLEGAL_FLOAT_CONTEXT;
    }

    //
    // Get the current irql and thread
    //

    FloatSave = (PFLOAT_SAVE) PublicFloatSave;

    Irql = KeGetCurrentIrql();
    Thread = KeGetCurrentThread();

    ASSERT (Thread->Header.NpxIrql <= Irql);

    FloatSave->Flags = 0;
    FloatSave->Irql = Irql;
    FloatSave->PreviousNpxIrql = Thread->Header.NpxIrql;
    FloatSave->Thread = Thread;

    //
    // If the irql has changed we need to save the complete floating
    // state context as the prior level has been interrupted.
    //

    if (Thread->Header.NpxIrql != Irql) {

        //
        // If this is apc level we don't have anyplace to hold this
        // context, allocate some heap.
        //

        if (Irql == APC_LEVEL) {
            FloatSave->u.Context = ExAllocatePoolWithTag(NonPagedPool,
                                                         sizeof (FX_SAVE_AREA) + ALIGN_ADJUST,
                                                         ' XPN');

            if (!FloatSave->u.Context) {
                return STATUS_INSUFFICIENT_RESOURCES;
            }

            FloatSave->Flags |= FLOAT_SAVE_FREE_CONTEXT_HEAP;

            //
            // ExAllocatePoolWithTag returns an 8 byte aligned pointer.
            // The FXSAVE instruction requires 16 byte alignment.  Adjust
            // the base address of the save area if needed.
            //

            if ((FloatSave->u.ContextAddressAsULONG & ALIGN_ADJUST) != 0) {
                FloatSave->u.ContextAddressAsULONG += ALIGN_ADJUST;
                FloatSave->Flags |= FLOAT_SAVE_ALIGN_ADJUSTED;
            }
            ASSERT((FloatSave->u.ContextAddressAsULONG & 0xF) == 0);

        } else {

            ASSERT (Irql == DISPATCH_LEVEL);
            FloatSave->u.Context = &KeGetCurrentPrcb()->NpxSaveArea;

        }

        FloatSave->Flags |= FLOAT_SAVE_COMPLETE_CONTEXT;
    }

    //
    // Stop context switching and allow access to the local fp unit
    //

    _asm {
        cli
        mov     eax, cr0
        mov     ecx, eax
        and     eax, not (CR0_MP|CR0_EM|CR0_TS)
        cmp     eax, ecx
        je      short sav10

        mov     cr0, eax
sav10:
    }

    Prcb = KeGetCurrentPrcb();

    //
    // Get ownership of npx register set for this context
    //

    if (Prcb->NpxThread != Thread) {

        //
        // If the other context is loaded in the npx registers, flush
        // it to that threads save area
        //
        if (Prcb->NpxThread) {

            NpxFrame = (PFX_SAVE_AREA)(((ULONG)(Prcb->NpxThread->InitialStack) -
                        sizeof(FX_SAVE_AREA)));

            if (KeI386FxsrPresent) {
                Kix86FxSave(NpxFrame);
            } else {
                Kix86FnSave(NpxFrame);
            }

            NpxFrame->NpxSavedCpu = 0;
            Prcb->NpxThread->NpxState = NPX_STATE_NOT_LOADED;

        }

        Prcb->NpxThread = Thread;
    }

    NpxFrame = (PFX_SAVE_AREA)(((ULONG)(Thread->InitialStack) -
                sizeof(FX_SAVE_AREA)));


    //
    // Save the previous state as required
    //

    if (FloatSave->Flags & FLOAT_SAVE_COMPLETE_CONTEXT) {

        //
        // Need to save the entire context
        //

        if (Thread->NpxState == NPX_STATE_LOADED) {
            if (KeI386FxsrPresent) {
                Kix86FxSave((FloatSave->u.Context));
            } else {
                Kix86FnSave((FloatSave->u.Context));
            }

            FloatSave->u.Context->NpxSavedCpu = 0;
            FloatSave->u.Context->Cr0NpxState = NpxFrame->Cr0NpxState;

        } else {
            RtlCopyMemory (FloatSave->u.Context, NpxFrame, sizeof(FX_SAVE_AREA));
            FloatSave->u.Context->NpxSavedCpu = 0;

        }

    } else {

        //
        // Save only the non-volatile state
        //

        if (Thread->NpxState == NPX_STATE_LOADED) {

            _asm {
                mov     eax, FloatSave
                fnstcw  [eax] FLOAT_SAVE.u.Fcw.ControlWord
            }

            if ((KeI386FxsrPresent) && (KeI386XMMIPresent)) {
                Kix86StMXCsr(&FloatSave->u.Fcw.MXCsr);
            }

        } else {
            //
            // Save the control word from the npx frame.
            //

            if (KeI386FxsrPresent) {
                FloatSave->u.Fcw.ControlWord = (USHORT) NpxFrame->U.FxArea.ControlWord;
                FloatSave->u.Fcw.MXCsr = NpxFrame->U.FxArea.MXCsr;

            } else {
                FloatSave->u.Fcw.ControlWord = (USHORT) NpxFrame->U.FnArea.ControlWord;
            }
        }


        //
        // Save Cr0NpxState, but clear CR0_TS as there's not non-volatile
        // pending fp exceptions
        //

        FloatSave->Cr0NpxState = NpxFrame->Cr0NpxState & ~CR0_TS;
    }

    //
    // The previous state is saved.  Set an initial default
    // FP state for the caller
    //

    NpxFrame->Cr0NpxState = 0;
    Thread->NpxState = NPX_STATE_LOADED;
    Thread->Header.NpxIrql  = Irql;
    ControlWord = 0x27f;    // 64bit mode
    MXCsr = 0x1f80;

    _asm {
        fninit
        fldcw       ControlWord
    }

    if ((KeI386FxsrPresent) && (KeI386XMMIPresent)) {
        Kix86LdMXCsr(&MXCsr);
    }

    _asm {
        sti
    }

    FloatSave->Flags |= FLOAT_SAVE_VALID;
    return STATUS_SUCCESS;
}


NTSTATUS
KeRestoreFloatingPointState (
    IN PKFLOATING_SAVE      PublicFloatSave
    )
/*++

Routine Description:

    This routine restores the thread's current non-volatile NPX state,
    to the passed in state.

Arguments:

    FloatSave - the non-volatile npx state for the thread to restore

Return Value:

--*/
{
    PKTHREAD Thread;
    PFX_SAVE_AREA NpxFrame;
    ULONG                   Cr0State;
    PFLOAT_SAVE             FloatSave;

    ASSERT (KeI386NpxPresent);

    FloatSave = (PFLOAT_SAVE) PublicFloatSave;
    Thread = FloatSave->Thread;

    NpxFrame = (PFX_SAVE_AREA)(((ULONG)(Thread->InitialStack) -
                sizeof(FX_SAVE_AREA)));


    //
    // Verify float save looks like it's from the right context
    //

    if ((FloatSave->Flags & (FLOAT_SAVE_VALID | FLOAT_SAVE_RESERVED)) != FLOAT_SAVE_VALID) {

        //
        // Invalid floating point save area.
        //

        KeBugCheckEx(INVALID_FLOATING_POINT_STATE,
                     0,
                     FloatSave->Flags,
                     0,
                     0);
    }

    if (FloatSave->Irql != KeGetCurrentIrql()) {

        //
        // Invalid IRQL.   IRQL now must be the same as when the
        // context was saved.  (Why?   Because we save it in different
        // places depending on the IRQL at that time).
        //

        KeBugCheckEx(INVALID_FLOATING_POINT_STATE,
                     1,
                     FloatSave->Irql,
                     KeGetCurrentIrql(),
                     0);
    }

    if (Thread != KeGetCurrentThread()) {

        //
        // Invalid Thread.   The thread this floating point context
        // belongs to is not the current thread (or the saved thread
        // field is trash).
        //

        KeBugCheckEx(INVALID_FLOATING_POINT_STATE,
                     2,
                     (ULONG_PTR)Thread,
                     (ULONG_PTR)KeGetCurrentThread(),
                     0);
    }


    //
    // Synchronize with context switches and the npx trap handlers
    //

    _asm {
        cli
    }

    //
    // Restore the required state
    //

    if (FloatSave->Flags & FLOAT_SAVE_COMPLETE_CONTEXT) {

        //
        // Restore the entire fp state to the threads save area
        //

        if (Thread->NpxState == NPX_STATE_LOADED) {

            //
            // This state in the fp unit is no longer needed, just disregard it
            //

            Thread->NpxState = NPX_STATE_NOT_LOADED;
            KeGetCurrentPrcb()->NpxThread = NULL;
        }

        //
        // Copy restored state to npx frame
        //

        RtlCopyMemory (NpxFrame, FloatSave->u.Context, sizeof(FX_SAVE_AREA));

    } else {

        //
        // Restore the non-volatile state
        //

        if (Thread->NpxState == NPX_STATE_LOADED) {

            //
            // Init fp state and restore control word
            //

            _asm {
                fninit
                mov     eax, FloatSave
                fldcw   [eax] FLOAT_SAVE.u.Fcw.ControlWord
            }


            if ((KeI386FxsrPresent) && (KeI386XMMIPresent)) {
                Kix86LdMXCsr(&FloatSave->u.Fcw.MXCsr);
            }


        } else {

            //
            // Fp state not loaded.  Restore control word in npx frame
            //

            if (KeI386FxsrPresent) {
                NpxFrame->U.FxArea.ControlWord = FloatSave->u.Fcw.ControlWord;
                NpxFrame->U.FxArea.StatusWord = 0;
                NpxFrame->U.FxArea.TagWord = 0;
                NpxFrame->NpxSavedCpu = 0;
                NpxFrame->U.FxArea.MXCsr = FloatSave->u.Fcw.MXCsr;

            } else {
                NpxFrame->U.FnArea.ControlWord = FloatSave->u.Fcw.ControlWord;
                NpxFrame->U.FnArea.StatusWord = 0;
                NpxFrame->U.FnArea.TagWord = 0xffff;
            }

        }

        NpxFrame->Cr0NpxState = FloatSave->Cr0NpxState;
    }

    //
    // Restore NpxIrql and Cr0
    //

    Thread->Header.NpxIrql = FloatSave->PreviousNpxIrql;
    Cr0State = Thread->NpxState | NpxFrame->Cr0NpxState;

    _asm {
        mov     eax, cr0
        mov     ecx, eax
        and     eax, not (CR0_MP|CR0_EM|CR0_TS)
        or      eax, Cr0State
        cmp     eax, ecx
        je      short res10
        mov     cr0, eax
res10:
        sti
    }

    //
    // Done
    //

    if ((FloatSave->Flags & FLOAT_SAVE_FREE_CONTEXT_HEAP) != 0) {

        //
        // If FXSAVE area was adjusted for alignment after allocation,
        // undo that adjustment before freeing.
        //

        if ((FloatSave->Flags & FLOAT_SAVE_ALIGN_ADJUSTED) != 0) {
            FloatSave->u.ContextAddressAsULONG -= ALIGN_ADJUST;
        }
        ExFreePool (FloatSave->u.Context);
    }

    FloatSave->Flags = 0;
    return STATUS_SUCCESS;
}

VOID
KiDisableFastSyscallReturn(
    VOID
    )

/*++

Routine Description:

    The fast syscall/return feature cannot be used until
    certain processor specific registers have been initialized.
    This routine is called when the system is switching to a
    state where not all processors are powered on.

    This routine adjusts the exit path for system calls to
    use the iretd instruction instead of the faster sysexit
    instruction, it accomplishes this by adjusting the offset
    of a branch.

Arguments:

    None.

Return Value:

    None.

--*/

{
    if (KiSystemCallExitAdjusted) {
        KiSystemCallExitBranch[1] = (UCHAR) (KiSystemCallExitBranch[1] - KiSystemCallExitAdjusted);
        KiSystemCallExitAdjusted = 0;
    }
}

VOID
KiEnableFastSyscallReturn(
    VOID
    )

/*++

Routine Description:

    The fast syscall/return feature cannot be used until
    certain processor specific registers have been initialized.
    This routine is called once the registers are known to
    have been set on all processors.

    This routine adjusts the exit path for system calls to
    use the appropriate sequence for the processor, it does
    this by adjusting the offset of a branch.

Arguments:

    None.

Return Value:

    None.

--*/

{
    //
    // Adjust the second byte of the two byte branch instruction.
    // It can never be otherwise, but, make sure we aren't going
    // to adjust it out of range.
    //

    //
    // The following is a workaround for the fact that in resume
    // from hibernate the kernel is read only.   Basically, we
    // won't try to do it again, we also don't undo it when
    // hibernating/suspending.
    //

    if ((KiSystemCallExitAdjusted == KiSystemCallExitAdjust) &&
        KiFastCallCopyDoneOnce) {

        //
        // It's already done, don't try to do it again.
        //

        return;
    }

    if ((KiSystemCallExitAdjust + KiSystemCallExitBranch[1]) < 0x80) {

        //
        // It's good, undo any previous adjustment.
        //

        KiDisableFastSyscallReturn();

        //
        // Adjust the branch.
        //

        KiSystemCallExitAdjusted = (UCHAR)KiSystemCallExitAdjust;
        KiSystemCallExitBranch[1] = (UCHAR) (KiSystemCallExitBranch[1] + KiSystemCallExitAdjusted);

        KiFastCallCopyDoneOnce = TRUE;
    }
}

VOID
KePrepareToLoseProcessorSpecificState(
    VOID
    )
{
    //
    //  The kernel has been marked read only, adjusting
    //  code right now won't work.   Fortunately, we
    //  don't actually need to do this as the SYSEXIT
    //  instruction doesn't depend on the SYSENTER MSRs.
    //
    // KiDisableFastSyscallReturn();
}

VOID
KiLoadFastSyscallMachineSpecificRegisters(
    IN PLONG Context
    )

/*++

Routine Description:

    Load MSRs used to support Fast Syscall/return.  This routine is
    run on all processors.

Arguments:

    None.

Return Value:

    None.

--*/

{
    PKPRCB Prcb;

    UNREFERENCED_PARAMETER (Context);

    if (KiFastSystemCallIsIA32) {

        Prcb = KeGetCurrentPrcb();

        //
        // Use Intel defined way of doing this.
        //

        WRMSR(MSR_SYSENTER_CS,  KGDT_R0_CODE);
        WRMSR(MSR_SYSENTER_EIP, (ULONGLONG)(ULONG)KiFastCallEntry);
        WRMSR(MSR_SYSENTER_ESP, (ULONGLONG)(ULONG)Prcb->DpcStack);

    }
}

VOID
KiRestoreFastSyscallReturnState(
    VOID
    )
{
    ULONG_PTR Void = 0;

    if (KeFeatureBits & KF_FAST_SYSCALL) {

        if (KiFastSystemCallDisable == 0) {

            //
            // Fast system call is enabled.
            //

            KiSystemCallExitAdjust = KiSystemCallExit2 - KiSystemCallExit;
        } else {

            //
            // Fast system call has been explicitly disabled or is
            // not implemented on all processors in the system.
            //

            KeFeatureBits &= ~KF_FAST_SYSCALL;
        }
    }
    if (KeFeatureBits & KF_FAST_SYSCALL) {

        //
        // On all processors, set the MSRs that support syscall/sysexit.
        //

        KeIpiGenericCall(
            (PKIPI_BROADCAST_WORKER)KiLoadFastSyscallMachineSpecificRegisters,
            Void
            );

    }

    //
    // Set the appropriate code for system call into the system
    // call area of the shared user data area.
    //

    KiEnableFastSyscallReturn();
}

VOID
KeRestoreProcessorSpecificFeatures(
    VOID
    )

/*++

Routine Description:

    Restore processor specific features.  This routine is called
    when processors have been restored to a powered on state to
    restore those things which are not part of the processor's
    "normal" context which may have been lost.  For example, this
    routine is called when a system is resumed from hibernate or
    suspend.

Arguments:

    None.

Return Value:

    None.

--*/
{
    KeRestoreMtrr();
    KeRestorePAT();
    KiRestoreFastSyscallReturnState();
}


#if !defined(NT_UP)

VOID
FASTCALL
KiAcquireQueuedSpinLockCheckForFreeze(
    IN PKSPIN_LOCK_QUEUE QueuedLock,
    IN PKTRAP_FRAME TrapFrame
    )

/*++

Routine Description:

    This routine is called to acquire a queued spin lock while at high
    priority.   While the lock is not available, a check is made to see
    if another processor has requested this processor freeze execution.
    
    Note: This routine must be called with current IRQL at or above
    dispatch lever, or interrupts disabled.

Arguments:

    QueuedLock  Supplies the address of the queued spinlock.
    TrapFrame   Supplies the address of the trap frame to pass to
                KiFreezeTargetExecution.

Return Value:

    None.

--*/

{
    PKSPIN_LOCK_QUEUE Previous;
    PKPRCB Prcb;
    volatile ULONG_PTR * LockPointer;

    LockPointer = (volatile ULONG_PTR *)&QueuedLock->Lock;

    Previous = InterlockedExchangePointer(QueuedLock->Lock, QueuedLock);

    if (Previous == NULL) {

        //
        // This processor now owns this lock.
        //

        *LockPointer |= LOCK_QUEUE_OWNER;

    } else {

        //
        // Lock is already held, update thew next pointer in the
        // previous queue entry to point to this new waiter and 
        // wait until the lock is granted.
        //
        // The following loop is careful not to write ANYTHING
        // while waiting unless a freeze execution has been
        // requested.   This includes any stack variables or
        // return addresses.
        //

        *LockPointer |= LOCK_QUEUE_WAIT;
        Previous->Next = QueuedLock;

        Prcb = KeGetCurrentPrcb();

        while (*LockPointer & LOCK_QUEUE_WAIT) {
            if (Prcb->RequestSummary & IPI_FREEZE) {
                ULONG OldSummary;
                ULONG NewSummary;
                ULONG Summary;

                OldSummary = Prcb->RequestSummary;
                NewSummary = OldSummary & ~IPI_FREEZE;
                Summary = InterlockedCompareExchange((PVOID)&Prcb->RequestSummary,
                                                     NewSummary,
                                                     OldSummary);

                //
                // If something else edited the RequestSummary, we'll
                // get it next time around (unless the IPI has been
                // handled).
                //

                if (Summary == OldSummary) {

                    //
                    // IPI_FREEZE cleared in RequestSummary.   Now
                    // freeze as requested.
                    //

                    KiFreezeTargetExecution(TrapFrame, NULL);
                }
            }

            //
            // Don't be a hog.
            //

            KeYieldProcessor();
        }
    }

    //
    // Lock has been acquired.
    //
}

#endif


/*++

QLOCK_STAT_GATHER

    If this flag is defined, the queued spinlock routines are
    replaced by wrappers used to gather performance characteristics
    of the code acquiring the locks.

--*/

#if defined(QLOCK_STAT_GATHER)

#define QLOCK_STAT_CLEAN
#define QLOCKS_NUMBER   16
#define QLOCKS_MAX_LOG  512

ULONG
FASTCALL
KiRDTSC(
    PULONGLONG Time
    );

//
// The following structure is used to accumulate data about each
// acquire/release pair for a lock.
//

typedef struct {
    ULONGLONG   Key;
    ULONGLONG   Time;
    ULONGLONG   WaitTime;
    ULONG       Count;
    ULONG       Waiters;
    ULONG       Depth;
    ULONG       IncreasedDepth;
    ULONG       Clean;
} QLOCKDATA, *PQLOCKDATA;

//
// House keeping data for each lock.
//

typedef struct {

    //
    // The following fields are used to keep data from acquire
    // to release.
    //

    ULONGLONG   AcquireTime;
    ULONGLONG   WaitToAcquire;
    ULONG_PTR   AcquirePoint;
    BOOLEAN     Clean;

    //
    // Remaining fields accumulate global stats for this lock.
    //

    ULONG       Count;
    ULONG       Pairs;
    ULONG       FailedTry;
    UCHAR       MaxDepth;
    UCHAR       PreviousDepth;
    ULONG       NoWait;
} QLOCKHOUSE, *PQLOCKHOUSE;

QLOCKDATA   KiQueuedSpinLockLog[QLOCKS_NUMBER][QLOCKS_MAX_LOG];
QLOCKHOUSE  KiQueuedSpinLockHouse[QLOCKS_NUMBER];

//
// Implement the lock queue mechanisms in C for when we are
// gathering performance data.
//

VOID
FASTCALL
KiAcquireQueuedLock(
    IN PKSPIN_LOCK_QUEUE QueuedLock
    )
{
    PKSPIN_LOCK_QUEUE Previous;
    volatile ULONG_PTR * LockPointer;

    LockPointer = (volatile ULONG_PTR *)&QueuedLock->Lock;

    Previous = InterlockedExchangePointer(QueuedLock->Lock, QueuedLock);

    if (Previous == NULL) {

        //
        // This processor now owns this lock.
        //

#if defined(QLOCK_STAT_CLEAN)

        ULONG LockNumber;

        LockNumber = QueuedLock - KeGetCurrentPrcb()->LockQueue;

        //
        // The following check allows the conversion from QueuedLock to
        // lock number to work (validly) even if in stack queued spin
        // locks are using this routine.
        //

        if (LockNumber < QLOCKS_NUMBER) {
            KiQueuedSpinLockHouse[LockNumber].Clean = 1;
        }
        
#endif

        *LockPointer |= LOCK_QUEUE_OWNER;

    } else {

        //
        // Lock is already held, update thew next pointer in the
        // previous queue entry to point to this new waiter and 
        // wait until the lock is granted.
        //

        *LockPointer |= LOCK_QUEUE_WAIT;
        Previous->Next = QueuedLock;

        while (*LockPointer & LOCK_QUEUE_WAIT) {
            KeYieldProcessor();
        }
    }

    //
    // Lock has been acquired.
    //
}

VOID
FASTCALL
KiReleaseQueuedLock(
    IN PKSPIN_LOCK_QUEUE QueuedLock
    )
{
    PKSPIN_LOCK_QUEUE Waiter;

    //
    // Get the address of the actual lock and strip out the bottom
    // two bits which are used for status.
    //

    ASSERT((((ULONG_PTR)QueuedLock->Lock) & 3) == LOCK_QUEUE_OWNER);
    QueuedLock->Lock = (PKSPIN_LOCK)((ULONG_PTR)QueuedLock->Lock & ~3);

    Waiter = (PKSPIN_LOCK_QUEUE)*QueuedLock->Lock;

    if (Waiter == QueuedLock) {

        //
        // Good chance noone is queued on this lock, to be sure
        // we need to do an interlocked operation on it.
        // Note: This is just an optimization, there is no point
        // in doing the interlocked compare exchange if someone
        // else has already joined the queue.
        //

        Waiter = InterlockedCompareExchangePointer(QueuedLock->Lock,
                                                   NULL,
                                                   QueuedLock);
    }
    if (Waiter != QueuedLock) {

        //
        // There is another waiter.  It is possible for the waiter
        // to have only just performed the exchange that put its 
        // context in the lock and to have not yet updated the
        // 'next' pointer in the previous context (which could be 
        // this context), so we wait for our next pointer to be
        // non-null before continuing.
        //

        volatile PKSPIN_LOCK_QUEUE * NextQueuedLock = &QueuedLock->Next;

        while ((Waiter = *NextQueuedLock) == NULL) {
            KeYieldProcessor();
        }

        //
        // Pass the lock on to the next in line.
        //

        *((PULONG_PTR)&Waiter->Lock) ^= (LOCK_QUEUE_WAIT | LOCK_QUEUE_OWNER);
        QueuedLock->Next = NULL;
    }
}

KIRQL
FASTCALL
KiQueueStatAcquireQueuedLock(
    IN KSPIN_LOCK_QUEUE_NUMBER Number
    )
{
    KIRQL PreviousIrql;

    PreviousIrql = KfRaiseIrql(DISPATCH_LEVEL);
    KiAcquireQueuedLock(&KeGetCurrentPrcb()->LockQueue[Number]);
    return PreviousIrql;
}

KIRQL
FASTCALL
KiQueueStatAcquireQueuedLockRTS(
    IN KSPIN_LOCK_QUEUE_NUMBER Number
    )
{
    KIRQL PreviousIrql;

    PreviousIrql = KfRaiseIrql(SYNCH_LEVEL);
    KiAcquireQueuedLock(&KeGetCurrentPrcb()->LockQueue[Number]);
    return PreviousIrql;
}

LOGICAL
FASTCALL
KiQueueStatTryAcquire(
    IN KSPIN_LOCK_QUEUE_NUMBER Number,
    IN PKIRQL OldIrql,
    IN KIRQL NewIrql
    )
{
    KIRQL PreviousIrql;
    LOGICAL Acquired = FALSE;
    PKSPIN_LOCK_QUEUE Previous;
    PKSPIN_LOCK_QUEUE QueuedLock;
    ULONG_PTR * LockPointer;
    ULONG_PTR Lock;

    _disable();

    QueuedLock = &KeGetCurrentPrcb()->LockQueue[Number];
    LockPointer = (ULONG_PTR *)&QueuedLock->Lock;
    Lock = *LockPointer;

    Previous = InterlockedCompareExchangePointer(Lock, QueuedLock, NULL);

    if (Previous == NULL) {

        //
        // This processor now owns this lock.  Set the owner bit in
        // the queued lock lock pointer, raise IRQL to the requested
        // level, set the old IRQL in the caller provided location
        // and return success.
        //

        Lock |= LOCK_QUEUE_OWNER;
        *LockPointer = Lock;
        Acquired = TRUE;
        PreviousIrql = KfRaiseIrql(NewIrql);
        *OldIrql = PreviousIrql;
    }
    
    _enable();

    return Acquired;
}

VOID
FASTCALL
KiQueueStatReleaseQueuedLock(
    IN KSPIN_LOCK_QUEUE_NUMBER Number,
    IN KIRQL OldIrql
    )
{
    KiReleaseQueuedLock(&KeGetCurrentPrcb()->LockQueue[Number]);
    KfLowerIrql(OldIrql);
}

UCHAR
FASTCALL
KiQueuedLockDepth(
    IN PKSPIN_LOCK_QUEUE QueuedLock
    )
{
    //
    // Run down the list of waiters and see how many there are.
    //

    ULONG Depth = 0;
    ULONG_PTR LastAcquire;
    ULONG Debug;


    //
    // Get address of last acquirer in queue (stip the status bits
    // out of the address).
    //

    LastAcquire = (ULONG_PTR)QueuedLock->Lock;
    LastAcquire &= ~3;
    LastAcquire = *(PULONG_PTR)LastAcquire;

    //
    // Run down the list advancing QueuedLock until the end is reached.
    //

    while (LastAcquire != (ULONG_PTR)QueuedLock) {
        Debug = 0;

        //
        // If the waiter is not at the end of the list and has not yet
        // updated the forward pointer, wait for that update to happen.
        //

        if (QueuedLock->Next == NULL) {
            volatile PKSPIN_LOCK_QUEUE * NextQueuedLock = &QueuedLock->Next;

            while (*NextQueuedLock == NULL) {
                KeYieldProcessor();
                if (++Debug > 10000000) {
                    DbgBreakPoint();
                    Debug = 0;
                }
            }
        }
        Depth++;
        QueuedLock = QueuedLock->Next;
    }

    return (UCHAR) Depth;
}

//
// The following routines complete the queued spinlock package.
//

VOID
FASTCALL
KeAcquireInStackQueuedSpinLockAtDpcLevel(
    IN PKSPIN_LOCK SpinLock,
    IN PKLOCK_QUEUE_HANDLE LockHandle
    )
{
    LockHandle->LockQueue.Next = NULL;
    LockHandle->LockQueue.Lock = SpinLock;
    KiAcquireQueuedLock(&LockHandle->LockQueue);
}

VOID
FASTCALL
KeReleaseInStackQueuedSpinLockFromDpcLevel (
    IN PKLOCK_QUEUE_HANDLE LockHandle
    )
{
    KiReleaseQueuedLock(&LockHandle->LockQueue);
}

//
// Although part of the queued spinlock package, the following 
// routines need to be implemented in assembly code to gather
// lock statistics.
//

// VOID
// FASTCALL
// KeAcquireQueuedSpinLockAtDpcLevel(
//     IN PKSPIN_LOCK_QUEUE QueuedLock
//     )
// {
//     KiAcquireQueuedLock(QueuedLock);
// }
// 
// VOID
// FASTCALL
// KeReleaseQueuedSpinLockFromDpcLevel (
//     IN PKSPIN_LOCK_QUEUE QueuedLock
//     )
// {
//     KiReleaseQueuedLock(QueuedLock);
// }


VOID
FASTCALL
KiQueueStatTrySucceeded(
    IN PKSPIN_LOCK_QUEUE QueuedLock,
    IN ULONG_PTR CallersAddress
    )
{
    PKPRCB      Prcb;
    ULONG       LockNumber;

    Prcb = KeGetCurrentPrcb();
    LockNumber = QueuedLock - Prcb->LockQueue;

    //
    // Record time now.
    //

    KiRDTSC(&KiQueuedSpinLockHouse[LockNumber].AcquireTime);
    KiQueuedSpinLockHouse[LockNumber].WaitToAcquire = 0;
    KiQueuedSpinLockHouse[LockNumber].AcquirePoint = CallersAddress;
}

VOID
FASTCALL
KiQueueStatTryFailed(
    IN PKSPIN_LOCK_QUEUE QueuedLock
    )
{
    PKPRCB      Prcb;
    ULONG       LockNumber;

    Prcb = KeGetCurrentPrcb();
    LockNumber = QueuedLock - Prcb->LockQueue;

    KiQueuedSpinLockHouse[LockNumber].FailedTry++;
}

VOID
FASTCALL
KiQueueStatTry(
    IN PULONG Everything
    )

/*++

Routine Description:

    Log success or failure of a TryToAcquire.   

    If success, logs the same data as KiQueueStatAcquire except
    the wait time is 0.

Arguments:

    Argument points to an array of ULONG data.

        +0   xxxxxxRR    RR is result (1 = success, 0 = fail)
        +4   aaaaaaaa    Argument to try to acquire (ie lock number)
        +8   cccccccc    Caller address


Return Value:

    None.

--*/

{

    UCHAR Success = *(PUCHAR)Everything;
    ULONG LockNumber = Everything[1];

    if (!Success) {
        KiQueuedSpinLockHouse[LockNumber].FailedTry++;
        return;
    }

    KiRDTSC(&KiQueuedSpinLockHouse[LockNumber].AcquireTime);
    KiQueuedSpinLockHouse[LockNumber].WaitToAcquire = 0;
    KiQueuedSpinLockHouse[LockNumber].AcquirePoint = Everything[2];
}

VOID
FASTCALL
KiQueueStatAcquire(
    IN PULONG Everything
    )

/*++

Routine Description:

    This routine is called when a lock has been acquired.  It's
    purpose it to record wait time, acquisition time and who
    acquired the lock.

Arguments:

    Argument points to an array of ULONG data.

        +0   aaaaaaaa    LockNumber
        +4   tltltltl    time low  = time wait to acquire began
        +8   thththth    time high =
        +c   cccccccc    Caller address


Return Value:

    None.

--*/

{
    ULONG LockNumber = Everything[0];
    PQLOCKHOUSE LockHome;

    //
    // Make this routine work with either a lock number of lock address.
    //

    if (LockNumber > QLOCKS_NUMBER) {

        LockNumber = ((PKSPIN_LOCK_QUEUE)Everything[0]) -
                     KeGetCurrentPrcb()->LockQueue;
    }

    LockHome = &KiQueuedSpinLockHouse[LockNumber];
    LockHome->WaitToAcquire = *(PULONGLONG)&Everything[1];
    LockHome->AcquirePoint = Everything[3];
    KiRDTSC(&LockHome->AcquireTime);
}

VOID
FASTCALL
KiQueueStatRelease(
    IN PULONG Everything
    )

/*++

Routine Description:

    This routine is called when a lock is released to log statistics
    about the lock.   This routine is called with the lock still held,
    the statistics update is protected by the lock itself.

Arguments:

    Argument points to an array of ULONG data.

        +0   aaaaaaaa    Lock number
        +4   cccccccc    Caller address

Return Value:

    None.

--*/

{

    PQLOCKDATA Entry;
    ULONGLONG Key;
    ULONGLONG Now;
    UCHAR Waiters;
    PQLOCKHOUSE LockHome;
    ULONG LockNumber = Everything[0];
    LONGLONG HoldTime;
    ULONG Clean;

    KiRDTSC(&Now);

    //
    // Make this routine work with either a lock number of lock address.
    //

    if (LockNumber > QLOCKS_NUMBER) {
        LockNumber = ((PKSPIN_LOCK_QUEUE)Everything[0]) -
                     KeGetCurrentPrcb()->LockQueue;
    }

    LockHome = &KiQueuedSpinLockHouse[LockNumber];

    //
    // Make up the key for this acquire/release pair.
    //

    ((PLARGE_INTEGER)&Key)->HighPart = LockHome->AcquirePoint;
    ((PLARGE_INTEGER)&Key)->LowPart  = Everything[1];

    //
    // Get the count of processors now waiting on this lock.
    //

    Waiters = KiQueuedLockDepth(&KeGetCurrentPrcb()->LockQueue[LockNumber]);
    if (Waiters > LockHome->MaxDepth) {
        LockHome->MaxDepth = Waiters;
    }

    //
    // Reset per acquire/release data.  This is data we don't want
    // lying around for the next pair if we happen to throw away this
    // particular data point.
    //

    Clean = LockHome->Clean;
    LockHome->Clean = 0;
    LockHome->AcquirePoint = 0;

    HoldTime = Now - LockHome->AcquireTime;
    if (HoldTime < 0) {

        //
        // This happens when KeSetSystemTime is called.  
        // Drop any negative results.
        //

        return;
    }

    //
    // Update global statistics.
    //

    LockHome->Count++;
    LockHome->NoWait += Clean;

    //
    // Search for a match in the log and add in the new data.
    //

    for (Entry = KiQueuedSpinLockLog[LockNumber]; TRUE; Entry++) {
        if (Entry->Key == 0) {

            //
            // We have reached the end of the list of valid
            // entries without finding a key match.   If there's
            // room, create a new entry.
            //

            if (LockHome->Pairs >= QLOCKS_MAX_LOG) {

                //
                // No room, just return.
                //

                return;
            }
            LockHome->Pairs++;
            Entry->Key = Key;
        }

        if (Entry->Key == Key) {

            //
            // Found a match (or created a new pair).  Update statistics
            // for this acquire/release pair.
            //

            Entry->Time += HoldTime;
            if (LockHome->WaitToAcquire) {
                Entry->WaitTime += (LockHome->AcquireTime - LockHome->WaitToAcquire);
            }
            Entry->Count++;
            Entry->Waiters += (Waiters != 0);
            Entry->Depth += Waiters;

            //
            // There should be one less waiter now than there was
            // before we acquired the lock.   If not, a new waiter
            // has joined the queue.  This is is condition we want
            // to know about as it indicates contention on this
            // lock.
            //
            
            if ((Waiters) && (Waiters >= LockHome->PreviousDepth)) {
                Entry->IncreasedDepth++;
            }
            LockHome->PreviousDepth = Waiters;
            Entry->Clean += Clean;
            break;
        }
    }
}

#endif

//
// Table of debug register offsets
//

const ULONG KiDebugRegisterTrapOffsets [] = 
    { 
        FIELD_OFFSET (KTRAP_FRAME, Dr0),
        FIELD_OFFSET (KTRAP_FRAME, Dr1),
        FIELD_OFFSET (KTRAP_FRAME, Dr2),
        FIELD_OFFSET (KTRAP_FRAME, Dr3),
        0, // Unused [Dr4]
        0, // Unused [Dr5]
        FIELD_OFFSET (KTRAP_FRAME, Dr6),
        FIELD_OFFSET (KTRAP_FRAME, Dr7) 
    };

const ULONG KiDebugRegisterContextOffsets [] =
    {
        FIELD_OFFSET (CONTEXT, Dr0),
        FIELD_OFFSET (CONTEXT, Dr1),
        FIELD_OFFSET (CONTEXT, Dr2),
        FIELD_OFFSET (CONTEXT, Dr3),
        0,  // Unused [Dr4]
        0,  // Unused [Dr5]
        FIELD_OFFSET (CONTEXT, Dr6),
        FIELD_OFFSET (CONTEXT, Dr7)
    };

BOOLEAN
FASTCALL
KiRecordDr7 (
    IN OUT PULONG Dr7Ptr,
    IN OUT PUCHAR Mask OPTIONAL
    )

/*++

Routine Description:

    This updates Dr7 (located in the trap frame) to reflect the status
    of both Dr7 and the active debug mask.

    N.B. This routine should be called after Dr7 has been written to 
        with the user value and the debug mask accurately reflects
        the state of the remaining debug registers.

    N.B. Note that the Dr7 override technique enables the Bx bits in
        Dr6, associated with the appropriate Drs. In the previous model,
        the Dr registers were not save/restored unless Drs were enabled,
        and thus a dependency on these bits in that case would have
        been questionable. Additionally, the processor may clear these
        Dr6 bits on certain debug exceptions, making them unreliable.

Arguments:

    Dr7Ptr - Pointer to the sanitized Dr7 register within the trap frame.

    Mask - Optional pointer to the currently active debug mask. If 
        absent, this routine will directly update the current thread's 
        debugging state as needed.

Return Value:

    Boolean indicating whether or not the transition from inactive to
    active debugging state occurred. This is needed in cases where
    the entire debugging state is not atomically updated (e.g. VDM).

--*/

{
    BOOLEAN SanitizeTrapFrame;
    UCHAR OldMask, NewMask;

    if (ARGUMENT_PRESENT (Mask)) {
        OldMask = *Mask;
    } else {
        OldMask = (UCHAR) (KeGetCurrentThread ()->Header.DebugActive);
    }

    NewMask = OldMask;

    //
    // Note that separate bits are used to identify the state of Dr7 
    // (i.e., whether it has valid contents or contents used only for 
    // bookkeeping).
    //

    ASSERT ((*Dr7Ptr & DR7_RESERVED_MASK) == 0);
    
    if (*Dr7Ptr == 0) {
        
        SanitizeTrapFrame = FALSE;
        NewMask &= ~(DR_MASK (7));
        
        if ((NewMask & DR_REG_MASK) != 0) {
            NewMask |= DR_MASK (DR7_OVERRIDE_V);
            *Dr7Ptr |= DR7_OVERRIDE_MASK;
        } else {

            //
            // The override bit only occurs in conjunction with bits from 
            // DR_REG_MASK.
            //

            ASSERT (NewMask == 0);
        }
    } else {

        //
        // Sanitize the trap frame only if no other debug register is
        // active. Also take care to ensure that the override bit is clear.
        //
        
        SanitizeTrapFrame = (NewMask == 0);
        NewMask &= ~(DR_MASK (DR7_OVERRIDE_V));
        NewMask |= DR_MASK (7);
    }

    if (ARGUMENT_PRESENT (Mask)) {
        *Mask = NewMask;
    } else if (OldMask != NewMask) {
        KeGetCurrentThread ()->Header.DebugActive = ((BOOLEAN) NewMask);
    }

    return SanitizeTrapFrame;
}

BOOLEAN
FASTCALL
KiProcessDebugRegister (
    IN OUT PKTRAP_FRAME TrapFrame,
    IN ULONG Register
    )

/*++

Routine Description:

    This routine processes the indicated debug register, and updates
    the trap frame and the thread's active debug mask accordingly. 
    A caller should invoke the routine only after the register has been 
    written with the sanitized value. 

    N.B. This routine need only be called when the debug registers are
        updated individually (e.g., via the VDM).

    N.B. Dr7 should already contain the user specified value.

Arguments:

    TrapFrame - The target trap frame housing both the register being
        processed and the value of Dr7.

    Register - The debug register to inspect.

Return Value:

    Boolean indicating whether or not the transition from inactive to
    active debugging state occurred. This is needed in cases where
    the entire debugging state is not atomically updated (e.g. VDM).

--*/

{
    BOOLEAN SanitizeTrapFrame;
    PULONG RegPtr;
    UCHAR OldMask, NewMask;

    ASSERT ((DR_REG_MASK & DR_MASK (Register)) != 0);

    RegPtr = (PULONG)((ULONG_PTR)TrapFrame + KiDebugRegisterTrapOffsets[Register]);

    OldMask = NewMask = (UCHAR) KeGetCurrentThread ()->Header.DebugActive;
    
    ASSERT ((NewMask & (DR_MASK (7) | DR_MASK (DR7_OVERRIDE_V))) != 
        (DR_MASK (7) | DR_MASK (DR7_OVERRIDE_V)));
    
    if (*RegPtr != 0) {

        SanitizeTrapFrame = (NewMask == 0);
        
        NewMask |= DR_MASK (Register);

        //
        // Set Dr7 override as required, ignoring any reserved bits.
        //
        
        if ((TrapFrame->Dr7 & ~DR7_RESERVED_MASK) == 0) {
            NewMask |= DR_MASK (DR7_OVERRIDE_V);
            TrapFrame->Dr7 |= DR7_OVERRIDE_MASK;
        }
        
    } else {
    
        SanitizeTrapFrame = FALSE;
        
        if (NewMask != 0) {
        
            NewMask &= ~(DR_MASK (Register));

            //
            // If only the override bit remains set, then Dr7 was set only
            // for bookkeeping purposes, and may be cleared.
            //
            
            if (NewMask == DR_MASK(DR7_OVERRIDE_V)) {
                ASSERT ((TrapFrame->Dr7 & ~DR7_RESERVED_MASK) == DR7_OVERRIDE_MASK);
                TrapFrame->Dr7 = 0;
                NewMask = 0;
            }
        }
    }

    if (OldMask != NewMask) {
        KeGetCurrentThread ()->Header.DebugActive = ((BOOLEAN) NewMask);
    }
    
    return SanitizeTrapFrame;
}

ULONG
FASTCALL
KiUpdateDr7 (
    IN ULONG Dr7
    )

/*++

Routine Description:

    If Dr7 has bits set purely to flag debugging active, then this routine
    detects and removes bits prior to returning the state to the user.

Arguments:

    Dr7 - The actual value of Dr7.

Return Value:

    Updated version of Dr7.

--*/

{
    UCHAR DebugMask;

    DebugMask = (UCHAR) KeGetCurrentThread ()->Header.DebugActive; 
    
    if ((DebugMask & DR_MASK (DR7_OVERRIDE_V)) != 0) {
        ASSERT ((DebugMask & DR_REG_MASK) != 0);
        ASSERT ((Dr7 & ~DR7_RESERVED_MASK) == DR7_OVERRIDE_MASK);
        return 0;
    }

    return Dr7;
}

#ifdef _X86_
#pragma optimize("y", off)      // RtlCaptureContext needs EBP to be correct
#endif

VOID
__cdecl
KeSaveStateForHibernate(
    __out PKPROCESSOR_STATE ProcessorState
    )
/*++

Routine Description:

    Saves all processor-specific state that must be preserved
    across an S4 state (hibernation).

    N.B. #pragma surrounding this function is required in order
         to create the frame pointer than RtlCaptureContext relies
         on.
    N.B. _CRTAPI1 (__cdecl) decoration is also required so that
         RtlCaptureContext can compute the correct ESP.

Arguments:

    ProcessorState - Supplies the KPROCESSOR_STATE where the
        current CPU's state is to be saved.

Return Value:

    None.

--*/

{
    RtlCaptureContext(&ProcessorState->ContextFrame);
    KiSaveProcessorControlState(ProcessorState);
}

#ifdef _X86_
#pragma optimize("", on)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ke\i386\mi.inc ===
;++
;
; Copyright (c) Microsoft Corporation. All rights reserved. 
;
; You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
; If you do not agree to the terms, do not use the code.
;
;
;   Module Name:
;
;       MI.INC
;
;   Abstract:
;
;       This module contains equates for x86 machine instructions
;
;   Revision History:
;       
;       This information used to reside in Trap.asm, but is now needed in
;       multiple source files.
;
;--


MAX_INSTRUCTION_LENGTH		EQU	15
MAX_INSTRUCTION_PREFIX_LENGTH	EQU	4
MI_LOCK_PREFIX			EQU	0F0H
MI_ADDR_PREFIX			EQU	067H
MI_TWO_BYTE			EQU	0FH
MI_HLT				EQU	0F4H
MI_LTR_LLDT			EQU	0
MI_LGDT_LIDT_LMSW		EQU	01H
MI_MODRM_MASK			EQU	38H
MI_LLDT_MASK			EQU	10h
MI_LTR_MASK			EQU	18H
MI_LGDT_MASK			EQU	10H
MI_LIDT_MASK			EQU	18H
MI_LMSW_MASK			EQU	30H
MI_SPECIAL_MOV_MASK		EQU	20H
MI_REP_INS_OUTS 		EQU	0F3H
MI_MIN_INS_OUTS 		EQU	06CH
MI_MAX_INS_OUTS 		EQU	06FH

MI_CLTS                         EQU     006H
MI_INVD                         EQU     008H
MI_WBINVD                       EQU     009H

MI_MOV_FROM_CR                  EQU     020H
MI_MOV_FROM_DR                  EQU     021H
MI_MOV_TO_CR                    EQU     022H
MI_MOV_TO_DR                    EQU     023H
MI_MOV_FROM_TR                  EQU     024H
MI_MOV_TO_TR                    EQU     026H

MI_WRMSR                        EQU     030H
MI_RDTSC                        EQU     031H
MI_RDMSR                        EQU     032H
MI_RDPMC                        EQU     033H
MI_SYSEXIT                      EQU     035H
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ke\i386\mpipia.asm ===
title  "mpipia"
;++
;
; Copyright (c) Microsoft Corporation. All rights reserved. 
;
; You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
; If you do not agree to the terms, do not use the code.
;
;
; Module Name:
;
;    mpipia.asm
;
; Abstract:
;
;    This module implements the x86 specific functions required to
;    support multiprocessor systems.
;
;--

.586p
        .xlist
include ks386.inc
include mac386.inc
include callconv.inc
        .list

        EXTRNP  HalRequestSoftwareInterrupt,1,IMPORT,FASTCALL
        EXTRNP  HalRequestSoftwareInterrupt,1,IMPORT,FASTCALL
        EXTRNP  _HalRequestIpi,1,IMPORT
        EXTRNP  _KiFreezeTargetExecution, 2
ifdef DBGMP
        EXTRNP  _KiPollDebugger
endif
        extrn   _KiProcessorBlock:DWORD

DELAYCOUNT  equ    2000h

_DATA   SEGMENT DWORD PUBLIC 'DATA'

public  _KiSynchPacket
_KiSynchPacket dd  0

_DATA   ENDS



_TEXT  SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

;++
;
; BOOLEAN
; KiIpiServiceRoutine (
;     IN PKTRAP_FRAME TrapFrame,
;     IN PKEXCEPTION_FRAME ExceptionFrame
;     )
;
; Routine Description:
;
;     This routine is called at IPI level to process any outstanding
;     interporcessor requests for the current processor.
;
; Arguments:
;
;     TrapFrame - Supplies a pointer to a trap frame.
;
;     ExceptionFrame - Not used.
;
; Return Value:
;
;     A value of TRUE is returned, if one of more requests were service.
;     Otherwise, FALSE is returned.
;
;--

cPublicProc _KiIpiServiceRoutine, 2

ifndef NT_UP

cPublicFpo 2, 3
        push    ebx                     ; save nonvolatile registers
        push    esi                     ;
        push    edi                     ;

        xor     ebx, ebx                ; set exchange value
        xor     edi, edi
        mov     esi, PCR[PcPrcb]        ; get current processor block address

        xchg    dword ptr [esi].PbRequestSummary, ebx
        xchg    dword ptr [esi].PbSignalDone, edi
;
; Check for freeze request or synchronous request.
;

        test    bl, IPI_FREEZE + IPI_SYNCH_REQUEST ; test for freeze or packet
        jnz     short isr50             ; if nz, freeze or synch request

;
; For RequestSummary's other then IPI_FREEZE set return to TRUE
;

        mov     bh, 1                   ; set return value

;
; Check for Packet ready.
;
; If a packet is ready, then get the address of the requested function
; and call the function passing the address of the packet address as a
; parameter.
;

isr10:  mov     edx, edi                ; copy request pack address
        and     edx, NOT 1              ; Clear point to point bit
        jz      short isr20             ; if z set, no packet ready
        push    [edx].PbCurrentPacket + 8 ; push parameters on stack
        push    [edx].PbCurrentPacket + 4 ;
        push    [edx].PbCurrentPacket + 0 ;
        push    edi                     ; push source processor block address
        mov     eax, [edx].PbWorkerRoutine ; get worker routine address
        mov     edx, [esp + 16 + 4*4]   ; get current trap frame address
        mov     [esi].PbIpiFrame, edx   ; save current trap frame address
        call    eax                     ; call worker routine
        mov     bh, 1                   ; set return value

;
; Check for APC interrupt request.
;

isr20:  test    bl, IPI_APC             ; check if APC interrupt requested
        jz      short isr30             ; if z, APC interrupt not requested

        mov     ecx, APC_LEVEL          ; request APC interrupt
        fstCall HalRequestSoftwareInterrupt ;

;
; Check for DPC interrupt request.
;

isr30:  test    bl, IPI_DPC             ; check if DPC interrupt requested
        jz      short isr40             ; if z, DPC interrupt not requested

        mov     ecx, DISPATCH_LEVEL     ; request DPC interrupt
        fstCall HalRequestSoftwareInterrupt ;

isr40:  mov     al, bh                  ; return status
        pop     edi                     ; restore nonvolatile registers
        pop     esi                     ;
        pop     ebx                     ;

        stdRET  _KiIpiServiceRoutine

;
; Freeze or synchronous request
;

isr50:  test    bl, IPI_FREEZE          ; test if freeze request
        jz      short isr60             ; if z, no freeze request

;
; Freeze request is requested
;

        mov     ecx, [esp] + 20         ; get exception frame address
        mov     edx, [esp] + 16         ; get trap frame address
        stdCall _KiFreezeTargetExecution, <edx, ecx> ; freeze execution
        test    bl, not IPI_FREEZE      ; Any other IPI RequestSummary?
        setnz   bh                      ; Set return code accordingly
        test    bl, IPI_SYNCH_REQUEST   ; test if synch request
        jz      isr10                   ; if z, no sync request

;
; Synchronous packet request.   Pointer to requesting PRCB in KiSynchPacket.
;

isr60:  mov     eax, _KiSynchPacket     ; get PRCB of requesting processor
        mov     edx, eax                ; clear low bit in packet address
        btr     edx, 0                  ;
        push    [edx].PbCurrentPacket+8 ; push parameters on stack
        push    [edx].PbCurrentPacket+4 ;
        push    [edx].PbCurrentPacket+0 ;
        push    eax                     ; push source processor block address
        mov     eax, [edx].PbWorkerRoutine ; get worker routine address
        mov     edx, [esp + 16 + 4*4]   ; get current trap frame address
        mov     [esi].PbIpiFrame, edx   ; save current trap frame address
        call    eax                     ; call worker routine
        mov     bh, 1                   ; set return value
        jmp     isr10                   ; join common code

else

        xor     eax, eax                ; return FALSE

        stdRET  _KiIpiServiceRoutine

endif

stdENDP _KiIpiServiceRoutine


;++
;
; VOID
; FASTCALL
; KiIpiSend (
;    IN KAFFINITY TargetProcessors,
;    IN KIPI_REQUEST Request
;    )
;
; Routine Description:
;
;    This function requests the specified operation on the targt set of
;    processors.
;
; Arguments:
;
;    TargetProcessors (ecx) - Supplies the set of processors on which the
;        specified operation is to be executed.
;
;    IpiRequest (edx) - Supplies the request operation code.
;
; Return Value:
;
;     None.
;
;--

cPublicFastCall KiIpiSend, 2

ifndef NT_UP

cPublicFpo 0, 2
        push    esi                     ; save registers
        push    edi                     ;
        mov     esi, ecx                ; save target processor set

        shr     ecx, 1                  ; shift out first bit
        lea     edi, _KiProcessorBlock  ; get processor block array address
        jnc     short is20              ; if nc, not in target set

is10:   mov     eax, [edi]              ; get processor block address
   lock or      [eax].PbRequestSummary, edx ; set request summary bit

is20:   shr     ecx, 1                  ; shift out next bit
        lea     edi, [edi+4]            ; advance to next processor
        jc      short is10              ; if target, go set summary bit
        jnz     short is20              ; if more, check next

        stdCall _HalRequestIpi, <esi>   ; request IPI interrupts on targets

        pop     edi                     ; restore registers
        pop     esi                     ;
endif
        fstRet  KiIpiSend

fstENDP KiIpiSend

;++
;
; VOID
; KiIpiSendPacket (
;     IN KAFFINITY TargetProcessors,
;     IN PKIPI_WORKER WorkerFunction,
;     IN PVOID Parameter1,
;     IN PVOID Parameter2,
;     IN PVOID Parameter3
;     )
;
; Routine Description:
;
;    This routine executes the specified worker function on the specified
;    set of processors.
;
; Arguments:
;
;   TargetProcessors [esp + 4] - Supplies the set of processors on which the
;       specfied operation is to be executed.
;
;   WorkerFunction [esp + 8] - Supplies the address of the worker function.
;
;   Parameter1 - Parameter3 [esp + 12] - Supplies worker function specific
;       parameters.
;
; Return Value:
;
;     None.
;
;--*/

cPublicProc _KiIpiSendPacket, 5

ifndef NT_UP

cPublicFpo 5, 2
        push    esi                     ; save registers
        push    edi                     ;

;
; Store function address and parameters in the packet area of the PRCB on
; the current processor.
;

        mov     edx, PCR[PcPrcb]        ; get current processor block address
        mov     ecx, [esp] + 12         ; get target processor set
        mov     eax, [esp] + 16         ; get worker function address
        mov     edi, [esp] + 20         ; get worker function parameter 1
        mov     esi, [esp] + 24         ; get worker function parameter 2

        mov     [edx].PbTargetSet, ecx  ; set target processor set
        mov     [edx].PbWorkerRoutine, eax ; set worker function address

        mov     eax, [esp] + 28         ; get worker function parameter 3
        mov     [edx].PbCurrentPacket, edi ; set work function parameters
        mov     [edx].PbCurrentPacket + 4, esi ;
        mov     [edx].PbCurrentPacket + 8, eax ;

;
; Determine whether one and only one bit is set in the target set.
;

        mov     edi, ecx                ; copy recipient target set
        lea     esi, dword ptr [ecx-1]  ; compute target set - 1
        and     edi, esi                ; and target set with target set - 1
        neg     edi                     ; negate result (CF = 0 if zero)
        sbb     edi, edi                ; compute result as one if the
        inc     edi                     ; target set has one bit set
        jnz     short isp5              ; if nz, target set has one bit
        mov     [edx].PbPacketBarrier, ecx ; set packet barrier
isp5:   add     edx, edi                ; set low order bit if appropriate

;
; Loop through the target processors and send the packet to the specified
; recipients.
;

        shr     ecx, 1                  ; shift out first bit
        lea     edi, _KiProcessorBlock  ; get processor block array address
        jnc     short isp30             ; if nc, not in target set
isp10:  mov     esi, [edi]              ; get processor block address
isp20:  mov     eax, [esi].PbSignalDone ; check if packet being processed
        or      eax, eax                ;
        jne     isp40                   ; if ne, packet being processed

   lock cmpxchg [esi].PbSignalDone, edx ; compare and exchange

        jnz     short isp20             ; if nz, exchange failed

isp30:  shr     ecx, 1                  ; shift out next bit
        lea     edi, [edi+4]            ; advance to next processor
        jc      short isp10             ; if c, in target set
        jnz     short isp30             ; if nz, more target processors

        mov     ecx, [esp] + 12         ; set target processor set
        stdCall _HalRequestIpi, <ecx>   ; send IPI to targets

        pop     edi                     ; restore register
        pop     esi                     ;
endif

        stdRet  _KiIpiSendPacket

ifndef NT_UP
isp40:
        YIELD
        jmp     short isp20             ; retry packet test
endif

stdENDP _KiIpiSendPacket

;++
;
; VOID
; FASTCALL
; KiIpiSignalPacketDone (
;     IN PKIPI_CONTEXT Signaldone
;     )
;
; Routine Description:
;
;     This routine signals that a processor has completed a packet by
;     clearing the calling processor's set member of the requesting
;     processor's packet.
;
; Arguments:
;
;     SignalDone (ecx) - Supplies a pointer to the processor block of the
;         sending processor.
;
;         N.B. The low order bit of signal done is set if the target set
;              has one and only one bit set.
;
; Return Value:
;
;     None.
;
;--

cPublicFastCall KiIpiSignalPacketDone, 1

ifndef NT_UP

        btr     ecx, 0                          ; test and clear bit 0
        jc      short spd20                     ; if c set, only one bit set
        mov     edx, PCR[PcPrcb]                ; get current processor block address
        mov     eax, [edx].PbSetMember          ; get processor bit
if DBG
        test    [ecx].PbTargetSet, eax
        jne     @f
        int     3
@@:
endif

   lock xor     [ecx].PbTargetSet, eax          ; clear processor set member
        jnz     short spd10                     ; if nz, more targets to go
        xor     eax, eax                        ; clear packet barrier
if DBG
        cmp     [ecx].PbPacketBarrier, eax
        jne     @f
        int     3
@@:
endif
        mov     [ecx].PbPacketBarrier, eax      ;

spd10:  fstRET  KiIpiSignalPacketDone

;
; One and only one bit is set in the target set. Since this is the only
; processor that can clear any bits in the target set, the target set can
; be cleared with a simple write.
;

spd20:  xor     eax, eax                        ; clear target set
if DBG
        cmp     [ecx].PbTargetSet, eax
        jne     @f
        int     3
@@:
endif
        mov     [ecx].PbTargetSet, eax          ;

endif

        fstRET  KiIpiSignalPacketDone

fstENDP KiIpiSignalPacketDone


;++
;
; VOID
; FASTCALL
; KiIpiSignalPacketDoneAndStall (
;     IN PKIPI_CONTEXT Signaldone
;     IN PULONG ReverseStall
;     )
;
; Routine Description:
;
;     This routine signals that a processor has completed a packet by
;     clearing the calling processor's set member of the requesting
;     processor's packet, and then stalls on the reverse stall value
;
; Arguments:
;
;     SignalDone (ecx) - Supplies a pointer to the processor block of the
;         sending processor.
;
;         N.B. The low order bit of signal done is set if the target set
;              has one and only one bit set.
;
;     ReverseStall (edx) - Supplies a pointer to the reverse stall barrier
;
; Return Value:
;
;     None.
;
;--

cPublicFastCall KiIpiSignalPacketDoneAndStall, 2
cPublicFpo 0, 2

ifndef NT_UP

        push    ebx                             ; save register
        mov     ebx, dword ptr [edx]            ; get current value of barrier
        btr     ecx, 0                          ; test and clear bit 0
        jc      short sps10                     ; if c set, only one bit set
        mov     eax, PCR[PcPrcb]                ; get processor block address
        mov     eax, [eax].PbSetMember          ; get processor bit

if DBG
        test    [ecx].PbTargetSet, eax          ; Make sure the bit is set in the mask
        jne     @f
        int     3
@@:
endif

   lock xor     [ecx].PbTargetSet, eax          ; clear processor set member
        jnz     short sps20                     ; if nz, more targets to go
        xor     eax, eax                        ; clear packet barrier
if DBG
        cmp     [ecx].PbPacketBarrier, eax      ; Make sure the barrier is still set
        jne     @f
        int     3
@@:
endif
        mov     [ecx].PbPacketBarrier, eax      ;
        jmp     short sps20                     ;

;
; One and only one bit is set in the target set. Since this is the only
; processor that can clear any bits in the target set, the target set can
; be cleared with a simple write.
;

sps10:  xor     eax, eax                        ; clear target set

if DBG
        cmp    [ecx].PbTargetSet, eax          ; Make sure the bit is set in the mask
        jne     @f
        int     3
@@:
endif
        mov     [ecx].PbTargetSet, eax          ;

;
; Wait for barrier value to change.
;

sps20:  mov     eax, DELAYCOUNT
sps30:  cmp     ebx, dword ptr [edx]            ; barrier set?
        jne     short sps90                     ; yes, all done

        YIELD
        dec     eax                             ; P54C pre C2 workaround
        jnz     short sps30                     ; if eax = 0, generate bus cycle

ifdef DBGMP
        stdCall _KiPollDebugger                 ; Check for debugger ^C
endif

;
; There could be a freeze execution outstanding.  Check and clear
; freeze flag.
;

.errnz IPI_FREEZE - 4
        mov     eax, PCR[PcPrcb]                ; get processor block address
   lock btr     [eax].PbRequestSummary, 2       ; Generate bus cycle
        jnc     short sps20                     ; Freeze pending?

cPublicFpo 0,4
        push    ecx                             ; save target processor block
        push    edx                             ; save barrier address
        stdCall _KiFreezeTargetExecution, <[eax].PbIpiFrame, 0> ;
        pop     edx                             ; restore barrier address
        pop     ecx                             ; restore target processor block
        jmp     short sps20                     ;

sps90:  pop     ebx                             ; restore register

endif
        fstRET  KiIpiSignalPacketDoneAndStall

fstENDP KiIpiSignalPacketDoneAndStall

_TEXT   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ke\i386\mtrr.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    mtrr.h

Abstract:

    This module contains the i386 specific mtrr register 
    hardware definitions.

--*/

//
// MTRR MSR architecture definitions
//

#define MTRR_MSR_CAPABILITIES       0x0fe
#define MTRR_MSR_DEFAULT            0x2ff
#define MTRR_MSR_VARIABLE_BASE      0x200
#define MTRR_MSR_VARIABLE_MASK     (MTRR_MSR_VARIABLE_BASE+1)

#define MTRR_PAGE_SIZE              4096
#define MTRR_PAGE_MASK              (~(MTRR_PAGE_SIZE-1))

//
// Memory range types
//

#define MTRR_TYPE_UC            0
#define MTRR_TYPE_USWC          1
#define MTRR_TYPE_WT            4
#define MTRR_TYPE_WP            5
#define MTRR_TYPE_WB            6
#define MTRR_TYPE_MAX           7

//
// MTRR specific registers - capability register, default
// register, and variable mask and base register
//

#include "pshpack1.h"

typedef struct _MTRR_CAPABILITIES {
    union {
        struct {
            ULONG   VarCnt:8;
            ULONG   FixSupported:1;
            ULONG   Reserved_0:1;
            ULONG   UswcSupported:1;
            ULONG   Reserved_1:21;
            ULONG   Reserved_2;
        } hw;
        ULONGLONG   QuadPart;
    } u;
} MTRR_CAPABILITIES, *PMTRR_CAPABILITIES;

typedef struct _MTRR_DEFAULT {
    union {
        struct {
            ULONG   Type:8;
            ULONG   Reserved_0:2;
            ULONG   FixedEnabled:1;
            ULONG   MtrrEnabled:1;
            ULONG   Reserved_1:20;
            ULONG   Reserved_2;
        } hw;
        ULONGLONG   QuadPart;
    } u;
} MTRR_DEFAULT, *PMTRR_DEFAULT;

typedef struct _MTRR_VARIABLE_BASE {
    union {
        struct {
            ULONG       Type:8;
            ULONG       Reserved_0:4;
            ULONG       PhysBase_1:20;
            ULONG       PhysBase_2:4;
            ULONG       PhysBase_3:4;
            ULONG       Reserved_1:24;
        } hw;
        ULONGLONG   QuadPart;
    } u;
} MTRR_VARIABLE_BASE, *PMTRR_VARIABLE_BASE;

typedef struct _MTRR_VARIABLE_MASK {
    union {
        struct {
            ULONG      Reserved_0:11;
            ULONG      Valid:1;
            ULONG      PhysMask_1:20;
            ULONG      PhysMask_2:4;
            ULONG      PhysMask_3:4;
            ULONG      Reserved_1:24;
        } hw;
        ULONGLONG   QuadPart;
    } u;
} MTRR_VARIABLE_MASK, *PMTRR_VARIABLE_MASK;

#include "poppack.h"

typedef struct _PROCESSOR_LOCKSTEP {
    ULONG               Processor;
    volatile ULONG      TargetCount;
    volatile ULONG      *TargetPhase;
} PROCESSOR_LOCKSTEP, *PPROCESSOR_LOCKSTEP;

VOID
KiLockStepExecution(
    IN PPROCESSOR_LOCKSTEP Context
    );
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ke\i386\mtrr.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    mtrr.c

Abstract:

    This module implements interfaces that support manipulation of
    memory type range registers.

    These entry points only exist on x86 machines.

--*/

#include "ki.h"
#include "mtrr.h"

#define STATIC

#define IDBG    0

#if DBG
#define DBGMSG(a)   DbgPrint(a)
#else
#define DBGMSG(a)
#endif

//
// Define MTTR variable values for 36-bits of physical address support.
//
// N.B. During system initialization these variables may be changed for
//      40-bits of physical address support.
//

LONG64 KiMtrrMaskBase = 0x0000000ffffff000;
LONG64 KiMtrrMaskMask = 0x0000000ffffff000;
LONG64 KiMtrrOverflowMask = (~0x1000000000);
LONG64 KiMtrrResBitMask = 0xfffffffff;
UCHAR KiMtrrMaxRangeShift = 36;

//
// Internal declarations
//

//
// Range in generic terms
//

typedef struct _ONE_RANGE {
    ULONGLONG           Base;
    ULONGLONG           Limit;
    UCHAR               Type;
} ONE_RANGE, *PONE_RANGE;

#define GROW_RANGE_TABLE    4

//
// Range in specific mtrr terms
//

typedef struct _MTRR_RANGE {
    MTRR_VARIABLE_BASE  Base;
    MTRR_VARIABLE_MASK  Mask;
} MTRR_RANGE, *PMTRR_RANGE;

//
// System static information concerning cached range types
//

typedef struct _RANGE_INFO {

    //
    // Global MTRR info
    //

    MTRR_DEFAULT        Default;            // h/w mtrr default
    MTRR_CAPABILITIES   Capabilities;       // h/w mtrr Capabilities
    UCHAR               DefaultCachedType;  // default type for MmCached

    //
    // Variable MTRR information
    //

    BOOLEAN             RangesValid;        // Ranges initialized and valid.
    BOOLEAN             MtrrWorkaround;     // Work Around needed/not.
    UCHAR               NoRange;            // No ranges currently in Ranges
    UCHAR               MaxRange;           // Max size of Ranges
    PONE_RANGE          Ranges;             // Current ranges as set into h/w

} RANGE_INFO, *PRANGE_INFO;


//
// Structure used while processing range database
//

typedef struct _NEW_RANGE {
    //
    // Current Status
    //

    NTSTATUS            Status;

    //
    // Generic info on new range
    //

    ULONGLONG           Base;
    ULONGLONG           Limit;
    UCHAR               Type;

    //
    // MTRR image to be set into h/w
    //

    PMTRR_RANGE         MTRR;

    //
    // RangeDatabase before edits were started
    //

    UCHAR               NoRange;
    PONE_RANGE          Ranges;

    //
    // IPI context to coordinate concurrent processor update
    //

    ULONG               NoMTRR;

    PROCESSOR_LOCKSTEP  Synchronize;
    ULONG               Processor;
} NEW_RANGE, *PNEW_RANGE;

//
// Prototypes
//

VOID
KiInitializeMTRR (
    IN BOOLEAN LastProcessor
    );

BOOLEAN
KiRemoveRange (
    IN PNEW_RANGE   NewRange,
    IN ULONGLONG    Base,
    IN ULONGLONG    Limit,
    IN PBOOLEAN     RemoveThisType
    );

VOID
KiAddRange (
    IN PNEW_RANGE   NewRange,
    IN ULONGLONG    Base,
    IN ULONGLONG    Limit,
    IN UCHAR        Type
    );

VOID
KiStartEffectiveRangeChange (
    IN PNEW_RANGE   NewRange
    );

VOID
KiCompleteEffectiveRangeChange (
    IN PNEW_RANGE   NewRange
    );

STATIC ULONG
KiRangeWeight (
    IN PONE_RANGE   Range
    );

STATIC ULONG
KiFindFirstSetLeftBit (
    IN ULONGLONG    Set
    );

STATIC ULONG
KiFindFirstSetRightBit (
    IN ULONGLONG    Set
    );

VOID
KiLoadMTRRTarget (
    IN PKIPI_CONTEXT SignalDone,
    IN PVOID Context,
    IN PVOID Parameter2,
    IN PVOID Parameter3
    );

NTSTATUS
KiLoadMTRR (
    IN PNEW_RANGE Context
    );

ULONGLONG
KiMaskToLength (
    IN ULONGLONG    Mask
    );

ULONGLONG
KiLengthToMask (
    IN ULONGLONG    Length
    );

#if IDBG
VOID
KiDumpMTRR (
    PUCHAR      DebugString,
    PMTRR_RANGE MTRR
    );
#endif

//
// --- AMD - Prototypes for AMD K6 MTRR Support functions. ---
//

NTSTATUS
KiAmdK6MtrrSetMemoryType (
    IN ULONG BaseAddress,
    IN ULONG NumberOfBytes,
    IN MEMORY_CACHING_TYPE CacheType
    );

VOID
KiAmdK6MtrrWRMSR (
    VOID
    );

// --- AMD - End ---

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,KiInitializeMTRR)
#pragma alloc_text(PAGELK,KiRemoveRange)
#pragma alloc_text(PAGELK,KiAddRange)
#pragma alloc_text(PAGELK,KiStartEffectiveRangeChange)
#pragma alloc_text(PAGELK,KiCompleteEffectiveRangeChange)
#pragma alloc_text(PAGELK,KiRangeWeight)
#pragma alloc_text(PAGELK,KiFindFirstSetLeftBit)
#pragma alloc_text(PAGELK,KiFindFirstSetRightBit)
#pragma alloc_text(PAGELK,KiLoadMTRR)
#pragma alloc_text(PAGELK,KiLoadMTRRTarget)
#pragma alloc_text(PAGELK,KiLockStepExecution)
#pragma alloc_text(PAGELK,KiLengthToMask)
#pragma alloc_text(PAGELK,KiMaskToLength)

#if IDBG
#pragma alloc_text(PAGELK,KiDumpMTRR)
#endif

#endif

//
// KiRangeLock - Used to synchronize accesses to KiRangeInfo
//

KSPIN_LOCK          KiRangeLock;

//
// KiRangeInfo - Range type mapping information.  Details specific h/w support
//               and contains the current range database of how physical
//               addresses have been set

RANGE_INFO          KiRangeInfo;

VOID
KiInitializeMTRR (
    IN BOOLEAN LastProcessor
    )
/*++

Routine Description:

    Called to incrementally initialize the physical range
    database feature.   First processor's MTRR set is read into the
    physical range database.

Arguments:

    LastProcessor - If set this is the last processor to execute this routine
    such that when this processor finishes, the initialization is complete.

Return Value:

    None - if there was a problem the function
    KeSetPhysicalCacheTypeRange type is disabled.

--*/
{
    BOOLEAN             Status;
    ULONG               Index;
    MTRR_DEFAULT        Default;
    MTRR_CAPABILITIES   Capabilities;
    NEW_RANGE           NewRange;
    MTRR_VARIABLE_BASE  MtrrBase;
    MTRR_VARIABLE_MASK  MtrrMask;
    ULONGLONG           Base, Mask, Length;
    PKPRCB              Prcb;

    Status = TRUE;
    RtlZeroMemory (&NewRange, sizeof (NewRange));
    NewRange.Status = STATUS_UNSUCCESSFUL;

    //
    // If this is the first processor, initialize some fields
    //

    if (KeGetPcr()->Number == 0) {
        KeInitializeSpinLock (&KiRangeLock);

        KiRangeInfo.Capabilities.u.QuadPart = RDMSR(MTRR_MSR_CAPABILITIES);
        KiRangeInfo.Default.u.QuadPart = RDMSR(MTRR_MSR_DEFAULT);
        KiRangeInfo.DefaultCachedType = MTRR_TYPE_MAX;

        //
        // If h/w mtrr support is not enabled, disable OS support
        //

        if (!KiRangeInfo.Default.u.hw.MtrrEnabled ||
            KiRangeInfo.Capabilities.u.hw.VarCnt == 0 ||
            KiRangeInfo.Default.u.hw.Type != MTRR_TYPE_UC) {

            DBGMSG("MTRR feature disabled.\n");
            Status = FALSE;

        } else {

            //
            // If USWC type is supported by hardware, but the MTRR
            // feature is not set in KeFeatureBits, it is because
            // the HAL indicated USWC should not be used on this
            // machine.  (Possibly due to shared memory clusters).
            //

            if (KiRangeInfo.Capabilities.u.hw.UswcSupported &&
                ((KeFeatureBits & KF_MTRR) == 0)) {

                DBGMSG("KiInitializeMTRR: MTRR use globally disabled on this machine.\n");
                KiRangeInfo.Capabilities.u.hw.UswcSupported = 0;
            }

            //
            // Allocate initial range type database
            //

            KiRangeInfo.NoRange = 0;
            KiRangeInfo.MaxRange = (UCHAR) KiRangeInfo.Capabilities.u.hw.VarCnt + GROW_RANGE_TABLE;

            //
            // Don't allocate a new range on reinitialization from
            // hibernate.
            //

            if (KiRangeInfo.Ranges == NULL) {
                KiRangeInfo.Ranges = ExAllocatePoolWithTag (NonPagedPool,
                                        sizeof(ONE_RANGE) * KiRangeInfo.MaxRange,
                                        '  eK');
            }
            if (KiRangeInfo.Ranges != NULL) {
                RtlZeroMemory (KiRangeInfo.Ranges,
                               sizeof(ONE_RANGE) * KiRangeInfo.MaxRange);
            }
        }
    }

    //
    // Workaround for cpu signatures 611, 612, 616 and 617
    // - if the request for setting a variable MTRR specifies
    // an address which is not 4M aligned or length is not
    // a multiple of 4M then possible problem for INVLPG inst.
    // Detect if workaround is required
    //

    Prcb = KeGetCurrentPrcb();
    if (Prcb->CpuType == 6  &&
        (Prcb->CpuStep == 0x0101 || Prcb->CpuStep == 0x0102 ||
         Prcb->CpuStep == 0x0106 || Prcb->CpuStep == 0x0107 )) {

        if (strcmp((PCHAR)Prcb->VendorString, "GenuineIntel") == 0) {

            //
            // Only do this if it's an Intel part, other
            // manufacturers may have the same stepping
            // numbers but no bug.
            //

            KiRangeInfo.MtrrWorkaround = TRUE;
        }
    }

    //
    // If MTRR support disabled on first processor or if
    // buffer not allocated then fall through
    //

    if (!KiRangeInfo.Ranges){
        Status = FALSE;
        Capabilities.u.QuadPart = 0;        // satisfy no_opt compilation
    } else {

        //
        // Verify MTRR support is symmetric
        //

        Capabilities.u.QuadPart = RDMSR(MTRR_MSR_CAPABILITIES);

        if ((Capabilities.u.hw.UswcSupported) &&
            ((KeFeatureBits & KF_MTRR) == 0)) {
            DBGMSG ("KiInitializeMTRR: setting UswcSupported FALSE\n");
            Capabilities.u.hw.UswcSupported = 0;
        }

        Default.u.QuadPart = RDMSR(MTRR_MSR_DEFAULT);

        if (Default.u.QuadPart != KiRangeInfo.Default.u.QuadPart ||
            Capabilities.u.QuadPart != KiRangeInfo.Capabilities.u.QuadPart) {
            DBGMSG ("KiInitializeMTRR: asymmetric mtrr support\n");
            Status = FALSE;
        }
    }

    NewRange.Status = STATUS_SUCCESS;

    //
    // MTRR registers should be identically set on each processor.
    // Ranges should be added to the range database only for one
    // processor.
    //

    if (Status && (KeGetPcr()->Number == 0)) {
#if IDBG
        KiDumpMTRR ("Processor MTRR:", NULL);
#endif

        //
        // Read current MTRR settings for various cached range types
        // and add them to the range database
        //

        for (Index=0; Index < Capabilities.u.hw.VarCnt; Index++) {

            MtrrBase.u.QuadPart = RDMSR(MTRR_MSR_VARIABLE_BASE+Index*2);
            MtrrMask.u.QuadPart = RDMSR(MTRR_MSR_VARIABLE_MASK+Index*2);

            Mask = MtrrMask.u.QuadPart & KiMtrrMaskMask;
            Base = MtrrBase.u.QuadPart & KiMtrrMaskBase;

            //
            // Note - the variable MTRR Mask does NOT contain the length
            // spanned by the variable MTRR. Thus just checking the Valid
            // Bit should be sufficient for identifying a valid MTRR.
            //

            if (MtrrMask.u.hw.Valid) {

                Length = KiMaskToLength(Mask);

                //
                // Check for non-contiguous MTRR mask.
                //

                if ((Mask + Length) & KiMtrrOverflowMask) {
                    DBGMSG ("KiInitializeMTRR: Found non-contiguous MTRR mask!\n");
                    Status = FALSE;
                }

                //
                // Add this MTRR to the range database
                //

                Base &= Mask;
                KiAddRange (
                    &NewRange,
                    Base,
                    Base + Length - 1,
                    (UCHAR) MtrrBase.u.hw.Type
                    );

                //
                // Check for default cache type
                //

                if (MtrrBase.u.hw.Type == MTRR_TYPE_WB) {
                    KiRangeInfo.DefaultCachedType = MTRR_TYPE_WB;
                }

                if (KiRangeInfo.DefaultCachedType == MTRR_TYPE_MAX  &&
                    MtrrBase.u.hw.Type == MTRR_TYPE_WT) {
                    KiRangeInfo.DefaultCachedType = MTRR_TYPE_WT;
                }
            }
        }

        //
        // If a default type for "cached" was not found, assume write-back
        //

        if (KiRangeInfo.DefaultCachedType == MTRR_TYPE_MAX) {
            DBGMSG ("KiInitializeMTRR: assume write-back\n");
            KiRangeInfo.DefaultCachedType = MTRR_TYPE_WB;
        }
    }

    //
    // Done
    //

    if (!NT_SUCCESS(NewRange.Status)) {
        Status = FALSE;
    }

    if (!Status) {
        DBGMSG ("KiInitializeMTRR: OS support for MTRRs disabled\n");
        if (KiRangeInfo.Ranges != NULL) {
            ExFreePool (KiRangeInfo.Ranges);
            KiRangeInfo.Ranges = NULL;
        }
    } else {

        // if last processor indicate initialization complete
        if (LastProcessor) {
            KiRangeInfo.RangesValid = TRUE;
        }
    }
}

VOID
KeRestoreMtrr (
    VOID
    )
/*++

Routine Description:

    This function reloads the MTRR registers to be the current
    known values.   This is used on a system wakeup to ensure the
    registers are sane.

    N.B. The caller must have the PAGELK code locked

Arguments:

    none

Return Value:

    none

--*/
{
    NEW_RANGE           NewRange;
    KIRQL               OldIrql;

    if (KiRangeInfo.RangesValid) {
        RtlZeroMemory (&NewRange, sizeof (NewRange));
        KeAcquireSpinLock (&KiRangeLock, &OldIrql);
        KiStartEffectiveRangeChange (&NewRange);
        ASSERT (NT_SUCCESS(NewRange.Status));
        KiCompleteEffectiveRangeChange (&NewRange);
        KeReleaseSpinLock (&KiRangeLock, OldIrql);
        return;
    }

    //
    // If the processor is a AMD K6 with MTRR support then perform
    // processor specific implementation.
    //

    if (KeFeatureBits & KF_AMDK6MTRR) {
        KeAcquireSpinLock (&KiRangeLock, &OldIrql);
        KiLoadMTRR(NULL);
        KeReleaseSpinLock (&KiRangeLock, OldIrql);
    }
}


NTSTATUS
KeSetPhysicalCacheTypeRange (
    IN PHYSICAL_ADDRESS PhysicalAddress,
    IN ULONG NumberOfBytes,
    IN MEMORY_CACHING_TYPE CacheType
    )
/*++

Routine Description:

    This function sets a physical range to a particular cache type.
    If the system does not support setting cache policies based on
    physical ranges, no action is taken.

Arguments:

    PhysicalAddress - The starting address of the range being set

    NumberOfBytes   - The length, in bytes, of the range being set

    CacheType       - The caching type for which the physical range is
                      to be set to.

                     NonCached:
                        Setting ranges to be NonCached is done for
                        book keeping reasons.  A return of SUCCESS when
                        setting a range NonCached does not mean it has
                        been physically set to as NonCached.  The caller
                        must use a cache-disabled virtual pointer for
                        any NonCached range.

                     Cached:
                        A successful return indicates that the physical
                        range has been set to cached.   This mode requires
                        the caller to be at irql < dispatch_level.

                     FrameBuffer:
                        A successful return indicates that the physical
                        range has been set to be framebuffer cached.
                        This mode requires the caller to be at irql <
                        dispatch_level.

                     USWCCached:
                        This type is to be satisfied only via PAT and
                        fails for the MTRR interface.

Return Value:

    STATUS_SUCCESS - if success, the cache attributes of the physical range
                     have been set.

    STATUS_NOT_SUPPORTED - either feature not supported or not yet initialized,
                           or MmWriteCombined type not supported and is
                           requested, or input range does not match restrictions
                           imposed by workarounds for current processor stepping
                           or is below 1M (in the fixed MTRR range), or not yet
                           initialized.

    STATUS_UNSUCCESSFUL - Unable to satisfy request due to
                        - Unable to map software image into limited # of
                          hardware MTRRs.
                        - irql was not < DISPATCH_LEVEL.
                        - Failure due to other internal error (out of memory).

  STATUS_INVALID_PARAMETER - Incorrect input memory type.

--*/
{
    KIRQL               OldIrql;
    NEW_RANGE           NewRange;
    BOOLEAN             RemoveThisType[MTRR_TYPE_MAX];
    BOOLEAN             EffectRangeChange, AddToRangeDatabase;

    //
    // If caller has requested the MmUSWCCached memory type then fail
    // - MmUSWCCached is supported via PAT and not otherwise
    //

    if (CacheType == MmUSWCCached) {
        return STATUS_NOT_SUPPORTED;
    }

    //
    // Addresses above 4GB, below 1MB or not page aligned and
    // page length are not supported.
    //

    if ((PhysicalAddress.HighPart != 0)               ||
        (PhysicalAddress.LowPart < (1 * 1024 * 1024)) ||
        (PhysicalAddress.LowPart & 0xfff)             ||
        (NumberOfBytes & 0xfff)                          ) {
        return STATUS_NOT_SUPPORTED;
    }

    ASSERT (NumberOfBytes != 0);

    //
    // If the processor is a AMD K6 with MTRR support then perform
    // processor specific implementation.
    //

    if (KeFeatureBits & KF_AMDK6MTRR) {

        if ((CacheType != MmWriteCombined) && (CacheType != MmNonCached)) {
            return STATUS_NOT_SUPPORTED;
        }

        return KiAmdK6MtrrSetMemoryType(PhysicalAddress.LowPart,
                                        NumberOfBytes,
                                        CacheType);
    }

    //
    // If processor doesn't have the memory type range feature
    // return not supported.
    //

    if (!KiRangeInfo.RangesValid) {
        return STATUS_NOT_SUPPORTED;
    }

    //
    // Workaround for cpu signatures 611, 612, 616 and 617
    // - if the request for setting a variable MTRR specifies
    // an address which is not 4M aligned or length is not
    // a multiple of 4M then return status not supported
    //

    if ((KiRangeInfo.MtrrWorkaround) &&
        ((PhysicalAddress.LowPart & 0x3fffff) ||
         (NumberOfBytes & 0x3fffff))) {

            return STATUS_NOT_SUPPORTED;
    }

    RtlZeroMemory (&NewRange, sizeof (NewRange));
    NewRange.Base  = PhysicalAddress.QuadPart;
    NewRange.Limit = NewRange.Base + NumberOfBytes - 1;

    //
    // Determine what the new mtrr range type is.   If setting NonCached then
    // the database need not be updated to reflect the virtual change.  This
    // is because non-cached virtual pointers are mapped as cache disabled.
    //

    EffectRangeChange = TRUE;
    AddToRangeDatabase = TRUE;
    switch (CacheType) {
        case MmNonCached:
            NewRange.Type = MTRR_TYPE_UC;

            //
            // NonCached ranges do not need to be reflected into the h/w state
            // as all non-cached ranges are mapped with cache-disabled pointers.
            // This also means that cache-disabled ranges do not need to
            // be put into mtrrs, or held in the range, regardless of the default
            // range type.
            //

            EffectRangeChange = FALSE;
            AddToRangeDatabase = FALSE;
            break;

        case MmCached:
            NewRange.Type = KiRangeInfo.DefaultCachedType;
            break;

        case MmWriteCombined:
            NewRange.Type = MTRR_TYPE_USWC;

            //
            // If USWC type isn't supported, then request can not be honored
            //

            if (!KiRangeInfo.Capabilities.u.hw.UswcSupported) {
                DBGMSG ("KeSetPhysicalCacheTypeRange: USWC not supported\n");
                return STATUS_NOT_SUPPORTED;
            }
            break;

        default:
            DBGMSG ("KeSetPhysicalCacheTypeRange: no such cache type\n");
            return STATUS_INVALID_PARAMETER;
            break;
    }

    NewRange.Status = STATUS_SUCCESS;

    //
    // The default type is UC thus the range is still mapped using
    // a Cache Disabled VirtualPointer and hence it need not be added.
    //

    //
    // If h/w needs updated, lock down the code required to effect the change
    //

    if (EffectRangeChange) {
        if (KeGetCurrentIrql() >= DISPATCH_LEVEL) {

            //
            // Code can not be locked down.   Supplying a new range type requires
            // that the caller calls at irql < dispatch_level.
            //

            DBGMSG ("KeSetPhysicalCacheTypeRange failed due to calling IRQL == DISPATCH_LEVEL\n");
            return STATUS_UNSUCCESSFUL;
        }

        MmLockPageableSectionByHandle(ExPageLockHandle);
    }

    //
    // Serialize the range type database
    //

    KeAcquireSpinLock (&KiRangeLock, &OldIrql);

    //
    // If h/w is going to need updated, then start an effective range change
    //

    if (EffectRangeChange) {
        KiStartEffectiveRangeChange (&NewRange);
    }

    if (NT_SUCCESS (NewRange.Status)) {

        //
        // If the new range is NonCached, then don't remove standard memory
        // caching types
        //

        memset (RemoveThisType, TRUE, MTRR_TYPE_MAX);
        if (NewRange.Type != MTRR_TYPE_UC) {
            //
            // If the requested type is uncached then the physical
            // memory region is mapped using a cache disabled virtual pointer.
            // The effective memory type for that region will be the lowest
            // common denominator of the MTRR type and the cache type in the
            // PTE.  Therefore for a request of type UC, the effective type
            // will be UC irrespective of the MTRR settings in that range.
            // Hence it is not necessary to remove the existing MTRR settings
            // (if any) for that range.
            //

            //
            // Clip/remove any ranges in the target area
            //

            KiRemoveRange (&NewRange, NewRange.Base, NewRange.Limit, RemoveThisType);
        }

        //
        // If needed, add new range type
        //

        if (AddToRangeDatabase) {
            ASSERT (EffectRangeChange == TRUE);
            KiAddRange (&NewRange, NewRange.Base, NewRange.Limit, NewRange.Type);
        }

        //
        // If this is an effect range change, then complete it
        //

        if (EffectRangeChange) {
            KiCompleteEffectiveRangeChange (&NewRange);
        }
    }

    KeReleaseSpinLock (&KiRangeLock, OldIrql);
    if (EffectRangeChange) {
        MmUnlockPageableImageSection(ExPageLockHandle);
    }

    return NewRange.Status;
}

BOOLEAN
KiRemoveRange (
    IN PNEW_RANGE   NewRange,
    IN ULONGLONG    Base,
    IN ULONGLONG    Limit,
    IN PBOOLEAN     RemoveThisType
    )
/*++

Routine Description:

    This function removes any range overlapping with the passed range, of
    type supplied in RemoveThisType from the global range database.

Arguments:

    NewRange        - Context information

    Base            - Base & Limit signify the first & last address of a range
    Limit           - which is to be removed from the range database

    RemoveThisType  - A TRUE flag for each type which can not overlap the
                      target range


Return Value:

    TRUE  - if the range database was altered such that it may no longer
            be sorted.

--*/
{
    ULONG       i;
    PONE_RANGE  Range;
    BOOLEAN     DatabaseNeedsSorted;


    DatabaseNeedsSorted = FALSE;

    //
    // Check each range
    //

    for (i=0, Range=KiRangeInfo.Ranges; i < KiRangeInfo.NoRange; i++, Range++) {

        //
        // If this range type doesn't need to be altered, skip it
        //

        if (!RemoveThisType[Range->Type]) {
            continue;
        }

        //
        // Check range to see if it overlaps with range being removed
        //

        if (Range->Base < Base) {

            if (Range->Limit >= Base  &&  Range->Limit <= Limit) {

                //
                // Truncate range to not overlap with area being removed
                //

                Range->Limit = Base - 1;
            }

            if (Range->Limit > Limit) {

                //
                // Target area is contained totally within this area.
                // Split into two ranges
                //

                //
                // Add range at end
                //

                DatabaseNeedsSorted = TRUE;
                KiAddRange (
                    NewRange,
                    Limit+1,
                    Range->Limit,
                    Range->Type
                    );

                //
                // Turn current range into range at beginning
                //

                Range->Limit = Base - 1;
            }

        } else {

            // Range->Base >= Base

            if (Range->Base <= Limit) {
                if (Range->Limit <= Limit) {
                    //
                    // This range is totally within the target area.  Remove it.
                    //

                    DatabaseNeedsSorted = TRUE;
                    KiRangeInfo.NoRange -= 1;
                    Range->Base  = KiRangeInfo.Ranges[KiRangeInfo.NoRange].Base;
                    Range->Limit = KiRangeInfo.Ranges[KiRangeInfo.NoRange].Limit;
                    Range->Type = KiRangeInfo.Ranges[KiRangeInfo.NoRange].Type;

                    //
                    // recheck at current location
                    //

                    i -= 1;
                    Range -= 1;

                } else {

                    //
                    // Bump beginning past area being removed
                    //

                    Range->Base = Limit + 1;
                }
            }
        }
    }

    if (!NT_SUCCESS (NewRange->Status)) {
        DBGMSG ("KiRemoveRange: failure\n");
    }

    return DatabaseNeedsSorted;
}


VOID
KiAddRange (
    IN PNEW_RANGE   NewRange,
    IN ULONGLONG    Base,
    IN ULONGLONG    Limit,
    IN UCHAR        Type
    )
/*++

Routine Description:

    This function adds the passed range to the global range database.

Arguments:

    NewRange        - Context information

    Base            - Base & Limit signify the first & last address of a range
    Limit           - which is to be added to the range database

    Type            - Type of caching required for this range

Return Value:

    None - Context is updated with an error if the table has overflowed

--*/
{
    PONE_RANGE      Range, OldRange;
    ULONG           size;

    if (KiRangeInfo.NoRange >= KiRangeInfo.MaxRange) {

        //
        // Table is out of space, get a bigger one
        //

        OldRange = KiRangeInfo.Ranges;
        size = sizeof(ONE_RANGE) * (KiRangeInfo.MaxRange + GROW_RANGE_TABLE);
        Range  = ExAllocatePoolWithTag (NonPagedPool, size, '  eK');

        if (!Range) {
            NewRange->Status = STATUS_UNSUCCESSFUL;
            return ;
        }

        //
        // Grow table
        //

        RtlZeroMemory (Range, size);
        RtlCopyMemory (Range, OldRange, sizeof(ONE_RANGE) * KiRangeInfo.MaxRange);
        KiRangeInfo.Ranges = Range;
        KiRangeInfo.MaxRange += GROW_RANGE_TABLE;
        ExFreePool (OldRange);
    }

    //
    // Add new entry to table
    //

    KiRangeInfo.Ranges[KiRangeInfo.NoRange].Base = Base;
    KiRangeInfo.Ranges[KiRangeInfo.NoRange].Limit = Limit;
    KiRangeInfo.Ranges[KiRangeInfo.NoRange].Type = Type;
    KiRangeInfo.NoRange += 1;
}


VOID
KiStartEffectiveRangeChange (
    IN PNEW_RANGE   NewRange
    )
/*++

Routine Description:

    This functions sets up the context information required to
    track & later effect a range change in hardware

Arguments:

    NewRange        - Context information

Return Value:

    None

--*/
{
    ULONG   size;

    //
    // Allocate working space for MTRR image
    //

    size = sizeof(MTRR_RANGE) * ((ULONG) KiRangeInfo.Capabilities.u.hw.VarCnt + 1);
    NewRange->MTRR = ExAllocatePoolWithTag (NonPagedPool, size, '  eK');
    if (!NewRange->MTRR) {
        NewRange->Status = STATUS_UNSUCCESSFUL;
        return ;
    }

    RtlZeroMemory (NewRange->MTRR, size);

    //
    // Save current range information in case of an error
    //

    size = sizeof(ONE_RANGE) * KiRangeInfo.NoRange;
    NewRange->NoRange = KiRangeInfo.NoRange;
    NewRange->Ranges = ExAllocatePoolWithTag (NonPagedPool, size, '  eK');
    if (!NewRange->Ranges) {
        NewRange->Status = STATUS_UNSUCCESSFUL;
        return ;
    }

    RtlCopyMemory (NewRange->Ranges, KiRangeInfo.Ranges, size);
}


VOID
KiCompleteEffectiveRangeChange (
    IN PNEW_RANGE   NewRange
    )
/*++

Routine Description:

    This functions commits the range database to hardware, or backs
    out the current changes to it.

Arguments:

    NewRange        - Context information

Return Value:

    None

--*/
{
    BOOLEAN         Restart;
    ULONG           Index, Index2, RemIndex2, NoMTRR;
    ULONGLONG       BestLength, WhichMtrr;
    ULONGLONG       CurrLength;
    ULONGLONG       l, Base, Length, MLength;
    PONE_RANGE      Range;
    ONE_RANGE       OneRange;
    PMTRR_RANGE     MTRR;
    BOOLEAN         RoundDown;
    BOOLEAN         RemoveThisType[MTRR_TYPE_MAX];
    PKPRCB          Prcb;
    KIRQL           OldIrql;
#if !defined(NT_UP)
    KIRQL           OldIrql2;
    KAFFINITY       TargetProcessors;
#endif


    ASSERT (KeGetCurrentIrql() == DISPATCH_LEVEL);
    Prcb = KeGetCurrentPrcb();

    //
    // Round all ranges, according to type, to match what h/w can support
    //

    for (Index=0; Index < KiRangeInfo.NoRange; Index++) {
        Range = &KiRangeInfo.Ranges[Index];

        //
        // Determine rounding for this range type
        //

        RoundDown = TRUE;
        if (Range->Type == MTRR_TYPE_UC) {
            RoundDown = FALSE;
        }

        //
        // Apply rounding
        //

        if (RoundDown) {
            Range->Base  = (Range->Base  + MTRR_PAGE_SIZE - 1) & MTRR_PAGE_MASK;
            Range->Limit = ((Range->Limit+1) & MTRR_PAGE_MASK)-1;
        } else {
            Range->Base  = (Range->Base  & MTRR_PAGE_MASK);
            Range->Limit = ((Range->Limit + MTRR_PAGE_SIZE) & MTRR_PAGE_MASK)-1;
        }
    }

    do {
        Restart = FALSE;

        //
        // Sort the ranges by base address
        //

        for (Index=0; Index < KiRangeInfo.NoRange; Index++) {
            Range = &KiRangeInfo.Ranges[Index];

            for (Index2=Index+1; Index2 < KiRangeInfo.NoRange; Index2++) {

                if (KiRangeInfo.Ranges[Index2].Base < Range->Base) {

                    //
                    // Swap KiRangeInfo.Ranges[Index] with KiRangeInfo.Ranges[Index2]
                    //

                    OneRange = *Range;
                    *Range = KiRangeInfo.Ranges[Index2];
                    KiRangeInfo.Ranges[Index2] = OneRange;
                }
            }
        }

        //
        // At this point the range database is sorted on
        // base address. Scan range database combining adjacent and
        // overlapping ranges of the same type
        //

        for (Index=0; Index < (ULONG) KiRangeInfo.NoRange-1; Index++) {
            Range = &KiRangeInfo.Ranges[Index];

            //
            // Scan the range database. If ranges are adjacent/overlap and are of
            // the same type, combine them.
            //

            for (Index2 = Index+1; Index2 < (ULONG) KiRangeInfo.NoRange; Index2++) {

                l = Range[0].Limit + 1;
                if (l < Range[0].Limit) {
                    l = Range[0].Limit;
                }

                if (l >= KiRangeInfo.Ranges[Index2].Base  &&
                    Range[0].Type == KiRangeInfo.Ranges[Index2].Type) {

                    //
                    // Increase Range[0] limit to cover Range[Index2]
                    //

                    if (KiRangeInfo.Ranges[Index2].Limit > Range[0].Limit) {
                        Range[0].Limit = KiRangeInfo.Ranges[Index2].Limit;
                    }

                    //
                    // Remove KiRangeInfo.Ranges[Index2]
                    //

                    if (Index2 < (ULONG) KiRangeInfo.NoRange - 1 ) {

                        //
                        // Copy everything from Index2 till end
                        // of range list. # Entries to copy is
                        // (KiRangeInfo.NoRange -1) - (Index2+1) + 1
                        //

                        RtlCopyMemory(
                            &(KiRangeInfo.Ranges[Index2]),
                            &(KiRangeInfo.Ranges[Index2+1]),
                            sizeof(ONE_RANGE) * (KiRangeInfo.NoRange-Index2-1)
                            );
                    }

                    KiRangeInfo.NoRange -= 1;

                    //
                    // Recheck current location
                    //

                    Index2 -= 1;
                }
            }
        }

        //
        // At this point the range database is sorted on base
        // address and adjacent/overlapping ranges of the same
        // type are combined. Check for overlapping ranges -
        // If legal then allow else truncate the less "weighty" range
        //

        for (Index = 0; Index < (ULONG) KiRangeInfo.NoRange-1  &&  !Restart; Index++) {

            Range = &KiRangeInfo.Ranges[Index];

            l = Range[0].Limit + 1;
            if (l < Range[0].Limit) {
                l = Range[0].Limit;
            }

            //
            // If ranges overlap and are not of same type, and if the
            // overlap is not legal then carve them to the best cache type
            // available.
            //

            for (Index2 = Index+1; Index2 < (ULONG) KiRangeInfo.NoRange && !Restart; Index2++) {

                if (l > KiRangeInfo.Ranges[Index2].Base) {

                    if (Range[0].Type == MTRR_TYPE_UC ||
                        KiRangeInfo.Ranges[Index2].Type == MTRR_TYPE_UC) {

                        //
                        // Overlap of a UC type with a range of any other type is
                        // legal
                        //

                    } else if ((Range[0].Type == MTRR_TYPE_WT &&
                                KiRangeInfo.Ranges[Index2].Type == MTRR_TYPE_WB) ||
                               (Range[0].Type == MTRR_TYPE_WB &&
                                KiRangeInfo.Ranges[Index2].Type == MTRR_TYPE_WT) ) {
                        //
                        // Overlap of WT and WB range is legal. The overlap range will
                        // be WT.
                        //

                    } else {

                        //
                        // This is an illegal overlap and we need to carve the ranges
                        // to remove the overlap.
                        //
                        // Pick range which has the cache type which should be used for
                        // the overlapped area
                        //

                        if (KiRangeWeight(&Range[0]) > KiRangeWeight(&(KiRangeInfo.Ranges[Index2]))){
                            RemIndex2 = Index2;
                        } else {
                            RemIndex2 = Index;
                        }

                        //
                        // Remove ranges of type which do not belong in the overlapped area
                        //

                        RtlZeroMemory (RemoveThisType, MTRR_TYPE_MAX);
                        RemoveThisType[KiRangeInfo.Ranges[RemIndex2].Type] = TRUE;

                        //
                        // Remove just the overlapped portion of the range.
                        //

                        Restart = KiRemoveRange (
                           NewRange,
                           KiRangeInfo.Ranges[Index2].Base,
                           (Range[0].Limit < KiRangeInfo.Ranges[Index2].Limit ?
                                    Range[0].Limit : KiRangeInfo.Ranges[Index2].Limit),
                           RemoveThisType
                           );
                    }
                }
            }
        }

    } while (Restart);

    //
    // The range database is now rounded to fit in the h/w and sorted.
    // Attempt to build MTRR settings which exactly describe the ranges
    //

    MTRR = NewRange->MTRR;
    NoMTRR = 0;
    for (Index=0;NT_SUCCESS(NewRange->Status)&& Index<KiRangeInfo.NoRange;Index++) {
        Range = &KiRangeInfo.Ranges[Index];

        //
        // Build MTRRs to fit this range
        //

        Base   = Range->Base;
        Length = Range->Limit - Base + 1;

        while (Length) {

            //
            // Compute MTRR length for current range base & length
            //

            if (Base == 0) {
                MLength = Length;
            } else {
                MLength = (ULONGLONG) 1 << KiFindFirstSetRightBit(Base);
            }
            if (MLength > Length) {
                MLength = Length;
            }

            l = (ULONGLONG) 1 << KiFindFirstSetLeftBit (MLength);
            if (MLength > l) {
                MLength = l;
            }

            //
            // Store it in the next MTRR
            //

            MTRR[NoMTRR].Base.u.QuadPart = Base;
            MTRR[NoMTRR].Base.u.hw.Type  = Range->Type;
            MTRR[NoMTRR].Mask.u.QuadPart = KiLengthToMask(MLength);
            MTRR[NoMTRR].Mask.u.hw.Valid = 1;
            NoMTRR += 1;

            //
            // Adjust off amount of data covered by that last MTRR
            //

            Base += MLength;
            Length -= MLength;

            //
            // If there are too many MTRRs, and currently setting a
            // Non-USWC range try to remove a USWC MTRR.
            // (ie, convert some MmWriteCombined to MmNonCached).
            //

            if (NoMTRR > (ULONG) KiRangeInfo.Capabilities.u.hw.VarCnt) {

                if (Range->Type != MTRR_TYPE_USWC) {

                    //
                    // Find smallest USWC type and drop it
                    //
                    // This is okay only if the default type is UC.
                    // Default type should always be UC unless BIOS changes
                    // it. Still ASSERT!
                    //

                    ASSERT(KiRangeInfo.Default.u.hw.Type == MTRR_TYPE_UC);

                    WhichMtrr = 0;      // satisfy no_opt compilation
                    BestLength = (ULONGLONG) 1 << (KiMtrrMaxRangeShift + 1);

                    for (Index2=0; Index2 < KiRangeInfo.Capabilities.u.hw.VarCnt; Index2++) {

                        if (MTRR[Index2].Base.u.hw.Type == MTRR_TYPE_USWC) {

                            CurrLength = KiMaskToLength(MTRR[Index2].Mask.u.QuadPart &
                                                 KiMtrrMaskMask);

                            if (CurrLength < BestLength) {
                                WhichMtrr = Index2;
                                BestLength = CurrLength;
                            }
                        }
                    }

                    if (BestLength == ((ULONGLONG) 1 << (KiMtrrMaxRangeShift + 1))) {
                        //
                        // Range was not found which could be dropped.  Abort process
                        //

                        NewRange->Status = STATUS_UNSUCCESSFUL;
                        Length = 0;

                    } else {
                        //
                        // Remove WhichMtrr
                        //

                        NoMTRR -= 1;
                        MTRR[WhichMtrr] = MTRR[NoMTRR];
                    }

                } else {

                    NewRange->Status = STATUS_UNSUCCESSFUL;
                    Length =0;
                }
            }
        }
    }

    //
    // Done building new MTRRs
    //

    if (NT_SUCCESS(NewRange->Status)) {

        //
        // Update the MTRRs on all processors
        //

#if IDBG
        KiDumpMTRR ("Loading the following MTRR:", NewRange->MTRR);
#endif

        NewRange->Synchronize.TargetCount = 0;
        NewRange->Synchronize.TargetPhase = &Prcb->ReverseStall;
        NewRange->Synchronize.Processor = Prcb->Number;

        //
        // Previously enabled MTRRs with index > NoMTRR
        // which could conflict with existing setting should be disabled
        // This is taken care of by setting NewRange->NoMTRR to total
        // number of variable MTRRs.
        //

        NewRange->NoMTRR = (ULONG) KiRangeInfo.Capabilities.u.hw.VarCnt;

        //
        // Synchronize with other IPI functions which may stall
        //

        KeAcquireSpinLock (&KiReverseStallIpiLock, &OldIrql);

#if !defined(NT_UP)
        //
        // Collect all the (other) processors
        //

        TargetProcessors = KeActiveProcessors & ~Prcb->SetMember;
        if (TargetProcessors != 0) {

            KiIpiSendSynchronousPacket (
                Prcb,
                TargetProcessors,
                KiLoadMTRRTarget,
                (PVOID) NewRange,
                NULL,
                NULL
                );

            //
            // Wait for all processors to be collected
            //

            KiIpiStallOnPacketTargets(TargetProcessors);

            //
            // All processors are now waiting.  Raise to high level to
            // ensure this processor doesn't enter the debugger due to
            // some interrupt service routine.
            //

            KeRaiseIrql (HIGH_LEVEL, &OldIrql2);

            //
            // There's no reason for any debug events now, so signal
            // the other processors that they can all disable interrupts
            // and begin the MTRR update
            //

            Prcb->ReverseStall += 1;
        }
#endif

        //
        // Update MTRRs
        //

        KiLoadMTRR (NewRange);

        //
        // Release lock
        //

        KeReleaseSpinLock (&KiReverseStallIpiLock, OldIrql);


#if IDBG
        KiDumpMTRR ("Processor MTRR:", NewRange->MTRR);
#endif

    } else {

        //
        // There was an error, put original range database back
        //

        DBGMSG ("KiCompleteEffectiveRangeChange: mtrr update did not occur\n");

        if (NewRange->Ranges) {
            KiRangeInfo.NoRange = NewRange->NoRange;

            RtlCopyMemory (
                KiRangeInfo.Ranges,
                NewRange->Ranges,
                sizeof (ONE_RANGE) * KiRangeInfo.NoRange
                );
        }
    }

    //
    // Cleanup
    //

    ExFreePool (NewRange->Ranges);
    ExFreePool (NewRange->MTRR);
}


STATIC ULONG
KiRangeWeight (
    IN PONE_RANGE   Range
    )
/*++

Routine Description:

    This functions returns a weighting of the passed in range's cache
    type.   When two or more regions collide within the same h/w region
    the types are weighted and that cache type of the higher weight
    is used for the collision area.

Arguments:

    Range   - Range to obtain weighting for

Return Value:

    The weight of the particular cache type

--*/
{
    ULONG   Weight;

    switch (Range->Type) {
        case MTRR_TYPE_UC:      Weight = 5;     break;
        case MTRR_TYPE_USWC:    Weight = 4;     break;
        case MTRR_TYPE_WP:      Weight = 3;     break;
        case MTRR_TYPE_WT:      Weight = 2;     break;
        case MTRR_TYPE_WB:      Weight = 1;     break;
        default:                Weight = 0;     break;
    }

    return Weight;
}


STATIC ULONGLONG
KiMaskToLength (
    IN ULONGLONG    Mask
    )
/*++

Routine Description:

    This function returns the length specified by a particular
    mtrr variable register mask.

--*/
{
    if (Mask == 0) {
        // Zero Mask signifies a length of 2**36 or 2**40
        return(((ULONGLONG) 1 << KiMtrrMaxRangeShift));
    } else {
        return(((ULONGLONG) 1 << KiFindFirstSetRightBit(Mask)));
    }
}

STATIC ULONGLONG
KiLengthToMask (
    IN ULONGLONG    Length
    )
/*++

Routine Description:

    This function constructs the mask corresponding to the input length
    to be set in a variable MTRR register. The length is assumed to be
    a multiple of 4K.

--*/
{
    ULONGLONG FullMask = 0xffffff;

    if (Length == ((ULONGLONG) 1 << KiMtrrMaxRangeShift)) {
        return(0);
    } else {
        return(((FullMask << KiFindFirstSetRightBit(Length)) & KiMtrrResBitMask));
    }
}

STATIC ULONG
KiFindFirstSetRightBit (
    IN ULONGLONG    Set
    )
/*++

Routine Description:

    This function returns a bit position of the least significant
    bit set in the passed ULONGLONG parameter. Passed parameter
    must be non-zero.

--*/
{
    ULONG   bitno;

    ASSERT(Set != 0);
    for (bitno=0; !(Set & 0xFF); bitno += 8, Set >>= 8) ;
    return KiFindFirstSetRight[Set & 0xFF] + bitno;
}

STATIC ULONG
KiFindFirstSetLeftBit (
    IN ULONGLONG    Set
    )
/*++

Routine Description:

    This function returns a bit position of the most significant
    bit set in the passed ULONGLONG parameter. Passed parameter
    must be non-zero.

--*/
{
    ULONG   bitno;

    ASSERT(Set != 0);
    for (bitno=56;!(Set & 0xFF00000000000000); bitno -= 8, Set <<= 8) ;
    return KiFindFirstSetLeft[Set >> 56] + bitno;
}

#if IDBG
VOID
KiDumpMTRR (
    PUCHAR          DebugString,
    PMTRR_RANGE     MTRR
    )
/*++

Routine Description:

    This function dumps the MTRR information to the debugger

--*/
{
    static PUCHAR Type[] = {
    //  0       1       2       3       4       5       6
        "UC  ", "USWC", "????", "????", "WT  ", "WP  ", "WB  " };
    MTRR_VARIABLE_BASE  Base;
    MTRR_VARIABLE_MASK  Mask;
    ULONG       Index;
    ULONG       i;
    PUCHAR      p;

    DbgPrint ("%s\n", DebugString);
    for (Index=0; Index < (ULONG) KiRangeInfo.Capabilities.u.hw.VarCnt; Index++) {
        if (MTRR) {
            Base = MTRR[Index].Base;
            Mask = MTRR[Index].Mask;
        } else {
            Base.u.QuadPart = RDMSR(MTRR_MSR_VARIABLE_BASE+2*Index);
            Mask.u.QuadPart = RDMSR(MTRR_MSR_VARIABLE_MASK+2*Index);
        }

        DbgPrint ("  %d. ", Index);
        if (Mask.u.hw.Valid) {
            p = "????";
            if (Base.u.hw.Type < 7) {
                p = Type[Base.u.hw.Type];
            }

            DbgPrint ("%s  %08x:%08x  %08x:%08x",
                p,
                (ULONG) (Base.u.QuadPart >> 32),
                ((ULONG) (Base.u.QuadPart & KiMtrrMaskBase)),
                (ULONG) (Mask.u.QuadPart >> 32),
                ((ULONG) (Mask.u.QuadPart & KiMtrrMaskMask))
                );

        }
        DbgPrint ("\n");
    }
}
#endif


VOID
KiLoadMTRRTarget (
    IN PKIPI_CONTEXT SignalDone,
    IN PVOID NewRange,
    IN PVOID Parameter2,
    IN PVOID Parameter3
    )
{
    PNEW_RANGE Context;

    UNREFERENCED_PARAMETER (Parameter2);
    UNREFERENCED_PARAMETER (Parameter3);

    Context = (PNEW_RANGE) NewRange;

    //
    // Wait for all processors to be ready
    //

    KiIpiSignalPacketDoneAndStall(SignalDone,
                                  Context->Synchronize.TargetPhase);

    //
    // Update MTRRs
    //

    KiLoadMTRR (Context);
}



#define MOV_EAX_CR4   _emit { 0Fh, 20h, E0h }
#define MOV_CR4_EAX   _emit { 0Fh, 22h, E0h }

NTSTATUS
KiLoadMTRR (
    IN PNEW_RANGE Context
    )
/*++

Routine Description:

    This function loads the memory type range registers into all processors

Arguments:

    Context     - Context which include the MTRRs to load

Return Value:

    All processors are set into the new state

--*/
{
    MTRR_DEFAULT        Default;
    BOOLEAN             Enable;
    ULONG               HldCr0, HldCr4;
    ULONG               Index;

    //
    // Disable interrupts
    //

    Enable = KeDisableInterrupts();

    //
    // Synchronize all processors
    //

    if (!(KeFeatureBits & KF_AMDK6MTRR)) {
        KiLockStepExecution (&Context->Synchronize);
    }

    _asm {
        ;
        ; Get current CR0
        ;

        mov     eax, cr0
        mov     HldCr0, eax

        ;
        ; Disable caching & line fill
        ;

        and     eax, not CR0_NW
        or      eax, CR0_CD
        mov     cr0, eax

        ;
        ; Flush caches
        ;

        ;
        ; wbinvd
        ;

        _emit 0Fh
        _emit 09h

        ;
        ; Get current cr4
        ;

        _emit  0Fh
        _emit  20h
        _emit  0E0h             ; mov eax, cr4
        mov     HldCr4, eax

        ;
        ; Disable global page
        ;

        and     eax, not CR4_PGE
        _emit  0Fh
        _emit  22h
        _emit  0E0h             ; mov cr4, eax

        ;
        ; Flush TLB
        ;

        mov     eax, cr3
        mov     cr3, eax
    }

    if (KeFeatureBits & KF_AMDK6MTRR) {

        //
        // Write the MTRRs
        //

        KiAmdK6MtrrWRMSR();

    } else {

        //
        // Disable MTRRs
        //

        Default.u.QuadPart = RDMSR(MTRR_MSR_DEFAULT);
        Default.u.hw.MtrrEnabled = 0;
        WRMSR (MTRR_MSR_DEFAULT, Default.u.QuadPart);

        //
        // Load new MTRRs
        //

        for (Index=0; Index < Context->NoMTRR; Index++) {
            WRMSR (MTRR_MSR_VARIABLE_BASE+2*Index, Context->MTRR[Index].Base.u.QuadPart);
            WRMSR (MTRR_MSR_VARIABLE_MASK+2*Index, Context->MTRR[Index].Mask.u.QuadPart);
        }
    }
    _asm {

        ;
        ; Flush caches (this should be a "nop", but it was in the Intel reference algorithm)
        ; This is required because of aggressive prefetch of both instr + data
        ;

        ;
        ; wbinvd
        ;

        _emit 0Fh
        _emit 09h

        ;
        ; Flush TLBs (same comment as above)
        ; Same explanation as above
        ;

        mov     eax, cr3
        mov     cr3, eax
    }

    if (!(KeFeatureBits & KF_AMDK6MTRR)) {

        //
        // Enable MTRRs
        //

        Default.u.hw.MtrrEnabled = 1;
        WRMSR (MTRR_MSR_DEFAULT, Default.u.QuadPart);
    }

    _asm {
        ;
        ; Restore CR4 (global page enable)
        ;

        mov     eax, HldCr4
        _emit  0Fh
        _emit  22h
        _emit  0E0h             ; mov cr4, eax

        ;
        ; Restore CR0 (cache enable)
        ;

        mov     eax, HldCr0
        mov     cr0, eax
    }

    //
    // Wait for all processors to reach the same place,
    // restore interrupts and return.
    //

    if (!(KeFeatureBits & KF_AMDK6MTRR)) {
        KiLockStepExecution (&Context->Synchronize);
    }

    KeEnableInterrupts (Enable);
    return STATUS_SUCCESS;
}


VOID
KiLockStepExecution (
    IN PPROCESSOR_LOCKSTEP  Context
    )
{

#if !defined(NT_UP)

    LONG                CurrentPhase;
    volatile PLONG      TargetPhase;
    PKPRCB              Prcb;

    TargetPhase = (volatile PLONG) Context->TargetPhase;
    Prcb = KeGetCurrentPrcb();

    if (Prcb->Number == (CCHAR) Context->Processor) {

        //
        // Wait for all processors to signal
        //

        while (Context->TargetCount != (ULONG) KeNumberProcessors - 1) {
            KeYieldProcessor ();
        }

        //
        // Reset count for next time
        //

        Context->TargetCount = 0;

        //
        // Let waiting processor go to next synchronization point
        //

        InterlockedIncrement (TargetPhase);


    } else {

        //
        // Get current phase
        //

        CurrentPhase = *TargetPhase;

        //
        // Signal that we have completed the current phase
        //

        InterlockedIncrement ((PLONG)&Context->TargetCount);

        //
        // Wait for new phase to begin
        //

        while (*TargetPhase == CurrentPhase) {
            KeYieldProcessor ();
        }
    }

#else
    UNREFERENCED_PARAMETER (Context);
#endif

}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ke\i386\mtrramd.c ===
//
// Copyright (c) Microsoft Corporation. All rights reserved. 
//
// You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
// If you do not agree to the terms, do not use the code.
//

#include "ki.h"

#define STATIC

#define IDBG    0

#if DBG
#define DBGMSG(a)   DbgPrint(a)
#else
#define DBGMSG(a)
#endif

//
// Externals.
//

NTSTATUS
KiLoadMTRR (
    PVOID Context
    );

// --- AMD Structure definitions ---

// K6 MTRR hardware register layout.

// Single MTRR control register.

typedef struct _AMDK6_MTRR {
    ULONG       type:2;
    ULONG       mask:15;
    ULONG       base:15;
} AMDK6_MTRR, *PAMDK6_MTRR;

// MSR image, contains two control regs.

typedef struct _AMDK6_MTRR_MSR_IMAGE {
    union {
        struct {
            AMDK6_MTRR    mtrr0;
            AMDK6_MTRR    mtrr1;
        } hw;
        ULONGLONG   QuadPart;
    } u;
} AMDK6_MTRR_MSR_IMAGE, *PAMDK6_MTRR_MSR_IMAGE;

// MTRR reg type field values.

#define AMDK6_MTRR_TYPE_DISABLED    0
#define AMDK6_MTRR_TYPE_UC          1
#define AMDK6_MTRR_TYPE_WC          2
#define AMDK6_MTRR_TYPE_MASK        3

// AMD K6 MTRR MSR Index number

#define AMDK6_MTRR_MSR                0xC0000085

//
// Region table entry - used to track all write combined regions.
//
// Set BaseAddress to AMDK6_REGION_UNUSED for unused entries.
//

typedef struct _AMDK6_MTRR_REGION {
    ULONG                BaseAddress;
    ULONG                Size;
    MEMORY_CACHING_TYPE  RegionType;
    ULONG                RegionFlags;
} AMDK6_MTRR_REGION, *PAMDK6_MTRR_REGION;

#define MAX_K6_REGIONS          2		// Limit the write combined regions to 2 since that's how many MTRRs we have available.

//
// Value to set base address to for unused indication.
//

#define AMDK6_REGION_UNUSED     0xFFFFFFFF

//
// Flag to indicate that this region was set up by the BIOS.    
//

#define AMDK6_REGION_FLAGS_BIOS 0x00000001

//
// Usage count for hardware MTRR registers.
//

#define AMDK6_MAX_MTRR        2

//
// AMD Function Prototypes.
//

VOID
KiAmdK6InitializeMTRR (
    VOID
    );

NTSTATUS
KiAmdK6RestoreMTRR (
    );

NTSTATUS
KiAmdK6MtrrSetMemoryType (
    ULONG BaseAddress,
    ULONG Size,
    MEMORY_CACHING_TYPE Type
    );

BOOLEAN
KiAmdK6AddRegion (
    ULONG BaseAddress,
    ULONG Size,
    MEMORY_CACHING_TYPE Type,
    ULONG Flags
    );

NTSTATUS
KiAmdK6MtrrCommitChanges (
    VOID
    );

NTSTATUS
KiAmdK6HandleWcRegionRequest (
    ULONG BaseAddress,
    ULONG Size
    );

VOID
KiAmdK6MTRRAddRegionFromHW (
    AMDK6_MTRR RegImage
    );

PAMDK6_MTRR_REGION
KiAmdK6FindFreeRegion (
MEMORY_CACHING_TYPE Type
    );

#pragma alloc_text(INIT,KiAmdK6InitializeMTRR)
#pragma alloc_text(PAGELK,KiAmdK6RestoreMTRR)
#pragma alloc_text(PAGELK,KiAmdK6MtrrSetMemoryType)
#pragma alloc_text(PAGELK,KiAmdK6AddRegion)
#pragma alloc_text(PAGELK,KiAmdK6MtrrCommitChanges)
#pragma alloc_text(PAGELK,KiAmdK6HandleWcRegionRequest)
#pragma alloc_text(PAGELK,KiAmdK6MTRRAddRegionFromHW)
#pragma alloc_text(PAGELK,KiAmdK6FindFreeRegion)

// --- AMD Global Variables ---

extern KSPIN_LOCK KiRangeLock;

// AmdK6Regions - Table to track wc regions.

AMDK6_MTRR_REGION AmdK6Regions[MAX_K6_REGIONS];
ULONG AmdK6RegionCount;

// Usage counter for hardware MTRRs.

ULONG AmdMtrrHwUsageCount;

// Global variable image of MTRR MSR.

AMDK6_MTRR_MSR_IMAGE    KiAmdK6Mtrr;

// --- AMD Start of code ---

VOID
KiAmdK6InitializeMTRR (
    VOID
    )
{
    ULONG    i;
    KIRQL    OldIrql;

    DBGMSG("KiAmdK6InitializeMTRR: Initializing K6 MTRR support\n");

    KiAmdK6Mtrr.u.hw.mtrr0.type = AMDK6_MTRR_TYPE_DISABLED;
    KiAmdK6Mtrr.u.hw.mtrr1.type = AMDK6_MTRR_TYPE_DISABLED;
    AmdK6RegionCount = MAX_K6_REGIONS;
    AmdMtrrHwUsageCount = 0;

    //
    // Set all regions to free.
    //

    for (i = 0; i < AmdK6RegionCount; i++) {
        AmdK6Regions[i].BaseAddress = AMDK6_REGION_UNUSED;
        AmdK6Regions[i].RegionFlags = 0;
    }

    //
    // Initialize the spin lock.
    //
    // N.B. Normally this is done by KiInitializeMTRR but that
    // routine is not called in the AMD K6 case.
    //

    KeInitializeSpinLock (&KiRangeLock);

    //
    // Read the MTRR registers to see if the BIOS has set them up.
    // If so, add entries to the region table and adjust the usage
    // count.  Serialize the region table.
    //

    KeAcquireSpinLock (&KiRangeLock, &OldIrql);
                
    KiAmdK6Mtrr.u.QuadPart = RDMSR (AMDK6_MTRR_MSR);

    //
    // Check MTRR0 first.
    //

    KiAmdK6MTRRAddRegionFromHW(KiAmdK6Mtrr.u.hw.mtrr0);

    //
    // Now check MTRR1.
    //

    KiAmdK6MTRRAddRegionFromHW(KiAmdK6Mtrr.u.hw.mtrr1);

    //
    // Release the locks.
    //

    KeReleaseSpinLock (&KiRangeLock, OldIrql);
}

VOID
KiAmdK6MTRRAddRegionFromHW (
    AMDK6_MTRR RegImage
    )
{
    ULONG BaseAddress, Size, TempMask;

    //
    // Check to see if this MTRR is enabled.
    //
        
    if (RegImage.type != AMDK6_MTRR_TYPE_DISABLED) {

        //
        // If this is a write combined region then add an entry to
        // the region table.
        //

        if ((RegImage.type & AMDK6_MTRR_TYPE_UC) == 0) {

            //
            // Create a new resion table entry.
            //

            BaseAddress = RegImage.base << 17;

            //
            // Calculate the size base on the mask value.
            //

            TempMask = RegImage.mask;
            
            //
            // There should never be 4GB WC region!
            //

            ASSERT (TempMask != 0);

            //
            // Start with 128 size and search upward.
            //

            Size = 0x00020000;

            while ((TempMask & 0x00000001) == 0) {
                TempMask >>= 1;
                Size <<= 1;
            }

            //
            // Add the region to the table.
            //
            
            KiAmdK6AddRegion(BaseAddress,
                             Size,
                             MmWriteCombined,
                             AMDK6_REGION_FLAGS_BIOS);

            AmdMtrrHwUsageCount++;
        }
    }
}


NTSTATUS
KiAmdK6MtrrSetMemoryType (
    ULONG BaseAddress,
    ULONG Size,
    MEMORY_CACHING_TYPE Type
    )
{
    NTSTATUS    Status = STATUS_SUCCESS;
    KIRQL       OldIrql;

    switch(Type) {
    case MmWriteCombined:

        //
        // H/W needs updating, lock down the code required to effect
        // the change.
        //

        if (KeGetCurrentIrql() >= DISPATCH_LEVEL) {

            //
            // Code can not be locked down.   Supplying a new range type
            // requires that the caller calls at irql < dispatch_level.
            //

            DBGMSG ("KeAmdK6SetPhysicalCacheTypeRange failed due to calling IRQL == DISPATCH_LEVEL\n");
            return STATUS_UNSUCCESSFUL;
        }

        //
        // Lock the code.
        //

        MmLockPageableSectionByHandle(ExPageLockHandle);
        
        //
        // Serialize the region table.
        //

        KeAcquireSpinLock (&KiRangeLock, &OldIrql);

        Status = KiAmdK6HandleWcRegionRequest(BaseAddress, Size);
        
        //
        // Release the locks.
        //

        KeReleaseSpinLock (&KiRangeLock, OldIrql);
        MmUnlockPageableImageSection(ExPageLockHandle);
        
        break;  // End of WriteCombined case.

    case MmNonCached:

        //
        // Add an entry to the region table.
        //

	// Don't need to add these to the region table.  Non-cached regions are 
	// accessed using a non-caching virtual pointer set up in the page tables.

        break;

    case MmCached:

        //
        // Redundant.  These should be filtered out in
        // KeAmdK6SetPhysicalCacheTypeRange();
        //

        Status = STATUS_NOT_SUPPORTED;
        break;

    default:
        DBGMSG ("KeAmdK6SetPhysicalCacheTypeRange: no such cache type\n");
        Status = STATUS_INVALID_PARAMETER;
        break;
    }
    return Status;
}

NTSTATUS
KiAmdK6HandleWcRegionRequest (
    ULONG BaseAddress,
    ULONG Size
    )
{
    ULONG               i;
    ULONG               AdjustedSize, AdjustedEndAddress, AlignmentMask;
    ULONG               CombinedBase, CombinedSize, CombinedAdjustedSize;
    PAMDK6_MTRR_REGION  pRegion;
    BOOLEAN             bCanCombine, bValidRange;

    //
    // Try and find a region that overlaps or is adjacent to the new one and
    // check to see if the combined region would be a legal mapping.
    //

    for (i = 0; i < AmdK6RegionCount; i++) {
        pRegion = &AmdK6Regions[i];
        if ((pRegion->BaseAddress != AMDK6_REGION_UNUSED) &&
            (pRegion->RegionType == MmWriteCombined)) {

            //
            // Does the new start address overlap or adjoin an
            // existing WC region?
            //

            if (((pRegion->BaseAddress >= BaseAddress) &&
                 (pRegion->BaseAddress <= (BaseAddress + Size))) ||
                 ((BaseAddress <= (pRegion->BaseAddress + pRegion->Size)) &&
                  (BaseAddress >= pRegion->BaseAddress))) {

                //
                // Combine the two regions into one.
                //

                AdjustedEndAddress = BaseAddress + Size;

                if (pRegion->BaseAddress < BaseAddress) {
                    CombinedBase = pRegion->BaseAddress;
                } else {
                    CombinedBase = BaseAddress;
                }

                if ((pRegion->BaseAddress + pRegion->Size) >
                    AdjustedEndAddress) {
                    CombinedSize = (pRegion->BaseAddress + pRegion->Size) -
                           CombinedBase;
                } else {
                    CombinedSize = AdjustedEndAddress - CombinedBase;
                }

                //
                // See if the new region would be a legal mapping.
                //
                //
                // Find the smallest legal size that is equal to the requested range.  Scan
                // all ranges from 128k - 2G. (Start at 2G and work down).
                //
        
                CombinedAdjustedSize = 0x80000000;
                AlignmentMask = 0x7fffffff;
                bCanCombine = FALSE;
                
                while (CombinedAdjustedSize > 0x00010000) {

                    //
                    // Check the size to see if it matches the requested limit.
                    //

                    if (CombinedAdjustedSize == CombinedSize) {

                        //
                        // This one works.
                        // Check to see if the base address conforms to the MTRR restrictions.
                        //

                        if ((CombinedBase & AlignmentMask) == 0) {
                            bCanCombine = TRUE;
                        }

                        break;

                    } else {

                        //
                        // Bump it down to the next range size and try again.
                        //

                        CombinedAdjustedSize >>= 1;
                        AlignmentMask >>= 1;
                    }
                }

                if (bCanCombine) {
                    //
                    // If the resized range is OK, record the change in the region
                    // table and commit the changes to hardware.
                    //
                    
                    pRegion->BaseAddress = CombinedBase;
                    pRegion->Size = CombinedAdjustedSize;
                
                    //
                    // Reset the BIOS flag since we now "own" this region (if we didn't already).
                    //
                
                    pRegion->RegionFlags &= ~AMDK6_REGION_FLAGS_BIOS;

                    return KiAmdK6MtrrCommitChanges();
                }
            }
        }
    }

	// A valid combination could not be found, so try to create a new range for this request.
    //
    // Find the smallest legal size that is less than or equal to the requested range.  Scan
    // all ranges from 128k - 2G. (Start at 2G and work down).
    //
        
    AdjustedSize = 0x80000000;
    AlignmentMask = 0x7fffffff;
    bValidRange = FALSE;

    while (AdjustedSize > 0x00010000) {

        //
        // Check the size to see if it matches the requested limit.
        //

        if (AdjustedSize == Size) {

            //
            // This one works.
            //
            // Check to see if the base address conforms to the MTRR restrictions.
            //

            if ((BaseAddress & AlignmentMask) == 0) {
                bValidRange = TRUE;
            }
            
            //
            // Stop looking.
            //
            
            break;

        } else {

            //
            // Bump it down to the next range size and try again.
            //

            AdjustedSize >>= 1;
            AlignmentMask >>= 1;
        }
    }

    //
    // Couldn't find a legal region that fit.
    //
    
    if (!bValidRange) {
        return STATUS_NOT_SUPPORTED;
    }
    
    
    //
    // If we got this far then this is a new WC region.
    // Create a new region entry for this request.
    //

    if (!KiAmdK6AddRegion(BaseAddress, AdjustedSize, MmWriteCombined, 0)) {
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Commit the changes to hardware.
    //
        
    return KiAmdK6MtrrCommitChanges();
}

BOOLEAN
KiAmdK6AddRegion (
    ULONG BaseAddress,
    ULONG Size,
    MEMORY_CACHING_TYPE Type,
    ULONG Flags
    )
{
    PAMDK6_MTRR_REGION pRegion;

    if ((pRegion = KiAmdK6FindFreeRegion(Type)) == NULL) {
        return FALSE;
    }
    pRegion->BaseAddress = BaseAddress;
    pRegion->Size = Size;
    pRegion->RegionType = Type;
    pRegion->RegionFlags = Flags;
    
    return TRUE;
}

PAMDK6_MTRR_REGION
KiAmdK6FindFreeRegion (
    MEMORY_CACHING_TYPE Type
    )
{
    ULONG    i;

    //
    // If this is a MmWriteCombined request, limit the number of
    // regions to match the actual hardware support.
    //

    if (Type == MmWriteCombined) {
        if (AmdMtrrHwUsageCount >= AMDK6_MAX_MTRR) {

            //
            // Search the table to see if there are any BIOS entries
            // we can replace.
            //

            for (i = 0; i < AmdK6RegionCount; i++) {
                if (AmdK6Regions[i].RegionFlags & AMDK6_REGION_FLAGS_BIOS) {
                    return &AmdK6Regions[i];
                }
            }

            //
            // No free HW MTRRs and no reusable entries.
            //

            return FALSE;
        }
    }

    //
    // Find the next free region in the table.
    //

    for (i = 0; i < AmdK6RegionCount; i++) {
        if (AmdK6Regions[i].BaseAddress == AMDK6_REGION_UNUSED) {

            if (Type == MmWriteCombined) {
                AmdMtrrHwUsageCount++;
            }
            return &AmdK6Regions[i];
        }
    }


    DBGMSG("AmdK6FindFreeRegion: Region Table is Full!\n");

    return NULL;
}

NTSTATUS
KiAmdK6MtrrCommitChanges (
    VOID
    )

/*++

Routine Description:

    Commits the values in the table to hardware.

    This procedure builds the MTRR images into the KiAmdK6Mtrr variable and
    calls KiLoadMTRR to actually load the register.

Arguments:

   None.

Return Value:

   None.

--*/

{
    ULONG    i, dwWcRangeCount = 0;
    ULONG    RangeTemp, RangeMask;

    //
    // Reset the MTRR image for both MTRRs disabled.
    //

    KiAmdK6Mtrr.u.hw.mtrr0.type = AMDK6_MTRR_TYPE_DISABLED;
    KiAmdK6Mtrr.u.hw.mtrr1.type = AMDK6_MTRR_TYPE_DISABLED;

    //
    // Find the Write Combining Regions, if any and set up the MTRR register.
    //

    for (i = 0; i < AmdK6RegionCount; i++) {

        //
        // Is this a valid region, and is it a write combined type?
        //

        if ((AmdK6Regions[i].BaseAddress != AMDK6_REGION_UNUSED) &&
            (AmdK6Regions[i].RegionType == MmWriteCombined)) {
            
            //
            // Calculate the correct mask for this range size.  The
            // BaseAddress and size were validated and adjusted in
            // AmdK6MtrrSetMemoryType().
            //
            // Start with 128K and scan for all legal range values and
            // build the appropriate range mask at the same time.
            //

            RangeTemp = 0x00020000;
            RangeMask = 0xfffe0000;            

            while (RangeTemp != 0) {
                if (RangeTemp == AmdK6Regions[i].Size) {
                    break;
                }
                RangeTemp <<= 1;
                RangeMask <<= 1;
            }
            if (RangeTemp == 0) {

                //
                // Not a valid range size.  This can never happen!!
                //

                DBGMSG ("AmdK6MtrrCommitChanges: Bad WC range in region table!\n");

                return STATUS_NOT_SUPPORTED;
            }

            //
            // Add the region to the next available register.
            //

            if (dwWcRangeCount == 0)  {

                KiAmdK6Mtrr.u.hw.mtrr0.base = AmdK6Regions[i].BaseAddress >> 17;
                KiAmdK6Mtrr.u.hw.mtrr0.mask = RangeMask >> 17;
                KiAmdK6Mtrr.u.hw.mtrr0.type = AMDK6_MTRR_TYPE_WC;
                dwWcRangeCount++;

            }  else if (dwWcRangeCount == 1) {

                KiAmdK6Mtrr.u.hw.mtrr1.base = AmdK6Regions[i].BaseAddress >> 17;
                KiAmdK6Mtrr.u.hw.mtrr1.mask = RangeMask >> 17;
                KiAmdK6Mtrr.u.hw.mtrr1.type = AMDK6_MTRR_TYPE_WC;
                dwWcRangeCount++;

            } else {

                //
                // Should never happen!  This should have been caught in
                // the calling routine.
                //

                DBGMSG ("AmdK6MtrrCommitChanges: Not enough MTRR registers to satisfy region table!\n");

                return STATUS_NOT_SUPPORTED;
            }
        }
    }

    //
    // Commit the changes to hardware.
    //

    KiLoadMTRR(NULL);

    return STATUS_SUCCESS;
}

VOID
KiAmdK6MtrrWRMSR (
    VOID
    )

/*++

Routine Description:

    Write the AMD K6 MTRRs.

    Note: Access to KiAmdK6Mtrr has been synchronized around this
    call.

Arguments:

    None.

Return Value:

    None.

--*/

{
    //
    // Write the MTRRs
    //

    WRMSR (AMDK6_MTRR_MSR, KiAmdK6Mtrr.u.QuadPart);
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ke\i386\pat.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    pat.c

Abstract:

    This module implements interfaces that set the Page Attribute
    Table. These entry points only exist on i386 machines.

--*/

#include "ki.h"
#include "pat.h"

//
// Use lockstep mechanism from mtrr code.
//

#include "mtrr.h"

#if DBG
#define DBGMSG(a)   DbgPrint(a)
#else
#define DBGMSG(a)
#endif

//
// Structure used for PAT initialization
//

typedef struct _NEW_PAT {

    PAT                 Attributes;

    //
    // IPI context to coordinate concurrent PAT update
    //

    PROCESSOR_LOCKSTEP  Synchronize;
} NEW_PAT, *PNEW_PAT;

// Prototypes

VOID
KeRestorePAT (
    VOID
    );

VOID
KiInitializePAT (
    VOID
    );

VOID
KiLoadPAT (
    IN PNEW_PAT Context
    );

VOID
KiLoadPATTarget (
    IN PKIPI_CONTEXT    SignalDone,
    IN PVOID            Context,
    IN PVOID            Parameter2,
    IN PVOID            Parameter3
    );

#if DBG
VOID
KiDumpPAT (
    PUCHAR      DebugString,
    PAT         Attributes
    );
#endif

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGELK,KiInitializePAT)
#pragma alloc_text(PAGELK,KiLoadPAT)
#pragma alloc_text(PAGELK,KiLoadPATTarget)
#endif

VOID
KeRestorePAT (
    VOID
    )
/*++
Routine Description:

    Reinitialize the Page Attribute Table (PAT) on all processors.

    N.B. The caller must have the PAGELK code locked

  Arguments:

    None.

Return Value:

    None.
--*/
{
    if (KeFeatureBits & KF_PAT) {
        KiInitializePAT();
    }
}

VOID
KiInitializePAT (
    VOID
    )
/*++

Routine Description:

    Initialize the Page Attribute Table (PAT) on all processors. PAT
    is setup to provide WB, WC, STRONG_UC and WEAK_UC as the memory
    types such that mm macros for enabling/disabling/querying caching
    (MI_DISABLE_CACHING, MI_ENABLE_CACHING and MI_IS_CACHING_ENABLED)
    are unaffected.

    PAT_Entry   PAT Index   PCD PWT     Memory Type
    0            0           0   0       WB
    1            0           0   1       WC *
    2            0           1   0       WEAK_UC
    3            0           1   1       STRONG_UC
    4            1           0   0       WB
    5            1           0   1       WC *
    6            1           1   0       WEAK_UC
    7            1           1   1       STRONG_UC

    N.B. The caller must have the PAGELK code locked and ensure that the
    PAT feature is supported.

  Arguments:

    None.

Return Value:

    None.

--*/
{
    PAT         PatAttributes;
    KIRQL       OldIrql;
    PKPRCB      Prcb;
    NEW_PAT     NewPAT;
#if !defined(NT_UP)
    KIRQL       NewIrql;
    KAFFINITY   TargetProcessors;
#endif

    ASSERT ((KeFeatureBits & KF_PAT) != 0);

    //
    // Initialize the PAT
    //

    PatAttributes.hw.Pat[0] = PAT_TYPE_WB;
    PatAttributes.hw.Pat[1] = PAT_TYPE_USWC;
    PatAttributes.hw.Pat[2] = PAT_TYPE_WEAK_UC;
    PatAttributes.hw.Pat[3] = PAT_TYPE_STRONG_UC;
    PatAttributes.hw.Pat[4] = PAT_TYPE_WB;
    PatAttributes.hw.Pat[5] = PAT_TYPE_USWC;
    PatAttributes.hw.Pat[6] = PAT_TYPE_WEAK_UC;
    PatAttributes.hw.Pat[7] = PAT_TYPE_STRONG_UC;

    //
    // Synchronize with other IPI functions which may stall
    //
    KeAcquireSpinLock (&KiReverseStallIpiLock, &OldIrql);

    Prcb = KeGetCurrentPrcb();

    NewPAT.Attributes = PatAttributes;
    NewPAT.Synchronize.TargetCount = 0;
    NewPAT.Synchronize.TargetPhase = &Prcb->ReverseStall;
    NewPAT.Synchronize.Processor = Prcb->Number;


#if !defined(NT_UP)

    //
    // Collect all the (other) processors
    //

    TargetProcessors = KeActiveProcessors & ~Prcb->SetMember;
    if (TargetProcessors != 0) {

        KiIpiSendSynchronousPacket (
            Prcb,
            TargetProcessors,
            KiLoadPATTarget,
            (PVOID) (&NewPAT),
            NULL,
            NULL
            );

        //
        // Wait for all processors to be collected
        //

        KiIpiStallOnPacketTargets(TargetProcessors);

        //
        // All processors are now waiting.  Raise to high level to
        // ensure this processor doesn't enter the debugger due to
        // some interrupt service routine.
        //

        KeRaiseIrql (HIGH_LEVEL, &NewIrql);

        //
        // There's no reason for any debug events now, so signal
        // the other processors that they can all begin the PAT update
        //

        Prcb->ReverseStall += 1;
    }

#endif

    //
    // Update PAT
    //

    KiLoadPAT(&NewPAT);

    //
    // Release lock and lower to initial irql
    //

    KeReleaseSpinLock (&KiReverseStallIpiLock, OldIrql);
    MmEnablePAT();
    return;
}

VOID
KiLoadPATTarget (
    IN PKIPI_CONTEXT SignalDone,
    IN PVOID NewPAT,
    IN PVOID Parameter2,
    IN PVOID Parameter3
    )
/*++

Routine Description:

    Synchronize with target processors prior to PAT modification.

Arguments:

    Context     - Context which includes the PAT to load

Return Value:

    None

--*/
{
    PNEW_PAT Context;

    UNREFERENCED_PARAMETER (Parameter2);
    UNREFERENCED_PARAMETER (Parameter3);

    Context = (PNEW_PAT) NewPAT;

    //
    // Wait for all processors to be ready
    //

    KiIpiSignalPacketDoneAndStall(SignalDone,
                                  Context->Synchronize.TargetPhase);

    //
    // Update PAT
    //

    KiLoadPAT (Context);
}

VOID
KiLoadPAT (
    IN PNEW_PAT Context
    )
/*++

Routine Description:

    This function loads the PAT to all processors.

Arguments:

    Context - Context which includes new PAT to load

Return Value:

    PAT on all processors programmed to new values

--*/
{
    BOOLEAN             Enable;
    ULONG               HldCr0, HldCr4;

    //
    // Disable interrupts
    //

    Enable = KeDisableInterrupts();

    //
    // Synchronize all processors
    //

    KiLockStepExecution (&Context->Synchronize);

    _asm {
        ;
        ; Get current CR0
        ;

        mov     eax, cr0
        mov     HldCr0, eax

        ;
        ; Disable caching & line fill
        ;

        and     eax, not CR0_NW
        or      eax, CR0_CD
        mov     cr0, eax

        ;
        ; Flush caches
        ;

        ;
        ; wbinvd
        ;

        _emit 0Fh
        _emit 09h

        ;
        ; Get current cr4
        ;

        _emit  0Fh
        _emit  20h
        _emit  0E0h             ; mov eax, cr4
        mov     HldCr4, eax

        ;
        ; Disable global page
        ;

        and     eax, not CR4_PGE
        _emit  0Fh
        _emit  22h
        _emit  0E0h             ; mov cr4, eax

        ;
        ; Flush TLB
        ;

        mov     eax, cr3
        mov     cr3, eax
    }

    //
    // Load new PAT
    //

    WRMSR (PAT_MSR, Context->Attributes.QuadPart);

    _asm {

        ;
        ; Flush caches.
        ;

        ;
        ; wbinvd
        ;

        _emit 0Fh
        _emit 09h

        ;
        ; Flush TLBs
        ;

        mov     eax, cr3
        mov     cr3, eax
    }

    _asm {
        ;
        ; Restore CR4 (global page enable)
        ;

        mov     eax, HldCr4
        _emit  0Fh
        _emit  22h
        _emit  0E0h             ; mov cr4, eax

        ;
        ; Restore CR0 (cache enable)
        ;

        mov     eax, HldCr0
        mov     cr0, eax
    }

    //
    // Wait for all processors to reach the same place,
    // restore interrupts and return.
    //

    KiLockStepExecution (&Context->Synchronize);
    KeEnableInterrupts (Enable);
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ke\i386\newsysbg.asm ===
title  "System Startup"
;++
;
; Copyright (c) Microsoft Corporation. All rights reserved. 
;
; You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
; If you do not agree to the terms, do not use the code.
;
;
; Module Name:
;
;    systembg.asm
;
; Abstract:
;
;    This module implements the code necessary to initially startup the
;    NT system.
;
;--
.386p
        .xlist
include ks386.inc
include i386\kimacro.inc
include mac386.inc
include callconv.inc
include irqli386.inc
        .list

        option  segment:flat

        extrn   _KiBootFeatureBits:DWORD
        EXTRNP  _KdInitSystem,2
        EXTRNP  _KdPollBreakIn,0
        EXTRNP  _KiInitializeKernel,6
        EXTRNP  GetMachineBootPointers
        EXTRNP  KiIdleLoop,0,,FASTCALL
        EXTRNP  _KiInitializePcr,7
        EXTRNP  _KiSwapIDT
        EXTRNP  _KiInitializeTSS,1
        EXTRNP  _KiInitializeTSS2,2
        extrn   _KiTrap08:PROC
        extrn   _KiTrap02:PROC
        EXTRNP  _KiInitializeAbios,1
        EXTRNP  _KiInitializeMachineType
        EXTRNP  _HalInitializeProcessor,2,IMPORT
        extrn   _KiFreezeExecutionLock:DWORD
        extrn   _IDT:BYTE
        extrn   _IDTLEN:BYTE            ; NOTE - really an ABS, linker problems
        extrn   _KeNumberProcessors:BYTE
        extrn   _KeActiveProcessors:DWORD
        extrn   _KeLoaderBlock:DWORD
        extrn   _KiInitialProcess:BYTE
        extrn   _KiInitialThread:BYTE

ifndef NT_UP
        extrn   _KiBarrierWait:DWORD
        EXTRNP  _KiProcessorStart
endif


;
; Constants for various variables
;

_DATA   SEGMENT PARA PUBLIC 'DATA'

;
; Statically allocated structures for Bootstrap processor
; double fault stack for P0
; idle thread stack for P0
;

        align   16
        public  _KiDoubleFaultStack
        db      DOUBLE_FAULT_STACK_SIZE dup (?)
_KiDoubleFaultStack label byte

        public  P0BootStack
        db      KERNEL_STACK_SIZE dup (?)
P0BootStack  label byte


;
; Double fault task stack
;

MINIMUM_TSS_SIZE  EQU     TssIoMaps

        align   16

        public  _KiDoubleFaultTSS
_KiDoubleFaultTSS label byte
        db      MINIMUM_TSS_SIZE dup(0)

        public  _KiNMITSS
_KiNMITSS label byte
        db      MINIMUM_TSS_SIZE dup(0)

;
; Abios specific definitions
;

        public  _KiCommonDataArea, _KiAbiosPresent
_KiCommonDataArea       dd      0
_KiAbiosPresent         dd      0

_DATA   ends

        page ,132
        subttl  "System Startup"
INIT    SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

;++
;
; For processor 0, Routine Description:
;
;    This routine is called when the NT system begins execution.
;    Its function is to initialize system hardware state, call the
;    kernel initialization routine, and then fall into code that
;    represents the idle thread for all processors.
;
;    Entry state created by the boot loader:
;       A short-form IDT (0-1f) exists and is active.
;       A complete GDT is set up and loaded.
;       A complete TSS is set up and loaded.
;       Page map is set up with minimal start pages loaded
;           The lower 4Mb of virtual memory are directly mapped into
;           physical memory.
;
;           The system code (ntoskrnl.exe) is mapped into virtual memory
;           as described by its memory descriptor.
;       DS=ES=SS = flat
;       ESP->a usable boot stack
;       Interrupts OFF
;
; For processor > 0, Routine Description:
;
;   This routine is called when each additional processor begins execution.
;   The entry state for the processor is:
;       IDT, GDT, TSS, stack, selectors, PCR = all valid
;       Page directory is set to the current running directory
;       LoaderBlock - parameters for this processor
;
; Arguments:
;
;    PLOADER_PARAMETER_BLOCK LoaderBlock
;
; Return Value:
;
;    None.
;
;--
;
; Arguments for KiSystemStartupPx
;


KissLoaderBlock         equ     [ebp+8]

;
; Local variables
;

KissGdt                 equ     [ebp-4]
KissPcr                 equ     [ebp-8]
KissTss                 equ     [ebp-12]
KissIdt                 equ     [ebp-16]
KissIrql                equ     [ebp-20]
KissPbNumber            equ     [ebp-24]
KissIdleStack           equ     [ebp-28]
KissIdleThread          equ     [ebp-32]

cPublicProc _KiSystemStartup        ,1

        push    ebp
        mov     ebp, esp
        sub     esp, 32                     ; Reserve space for local variables

        mov     ebx, dword ptr KissLoaderBlock
        mov     _KeLoaderBlock, ebx         ; Get loader block param

        movzx   ecx, _KeNumberProcessors    ; get number of processors
        mov     KissPbNumber, ecx
        or      ecx, ecx                    ; Is the the boot processor?
        jnz     @f                          ; no

        ; P0 uses static memory for these
        mov     dword ptr [ebx].LpbThread,      offset _KiInitialThread
        mov     dword ptr [ebx].LpbKernelStack, offset P0BootStack

        push    KGDT_R0_PCR                 ; P0 needs FS set
        pop     fs

        ; Save processornumber in Prcb
        mov     byte ptr PCR[PcPrcbData+PbNumber], cl
@@:
        mov     eax, dword ptr [ebx].LpbThread
        mov     dword ptr KissIdleThread, eax

        lea     ecx, [eax].ThApcState.AsApcListHead ; initialize kernel APC list head
        mov     [eax].ThApcState.AsApcListHead, ecx ;
        mov     [eax].ThApcState.AsApcListHead+4, ecx ;

        mov     eax, dword ptr [ebx].LpbKernelStack
        mov     dword ptr KissIdleStack, eax

        stdCall   _KiInitializeMachineType
        cmp     byte ptr KissPbNumber, 0    ; if not p0, then
        jne     kiss_notp0                  ; skip a bunch

;
;+++++++++++++++++++++++
;
; Initialize the PCR
;

        stdCall   GetMachineBootPointers
;
; Upon return:
;   (edi) -> gdt
;   (esi) -> pcr
;   (edx) -> tss
;   (eax) -> idt
; Now, save them in our local variables
;


        mov     KissGdt, edi
        mov     KissPcr, esi
        mov     KissTss, edx
        mov     KissIdt, eax

;
;       edit TSS to be 32bits.  loader gives us a tss, but it's 16bits!
;
        lea     ecx,[edi]+KGDT_TSS      ; (ecx) -> TSS descriptor
        mov     byte ptr [ecx+5],089h   ; 32bit, dpl=0, present, TSS32, not busy

; KiInitializeTSS2(
;       Linear address of TSS
;       Linear address of TSS descriptor
;       );
        stdCall   _KiInitializeTSS2, <KissTss, ecx>

        stdCall   _KiInitializeTSS, <KissTss>

        mov     cx,KGDT_TSS
        ltr     cx


;
;   set up 32bit double fault task gate to catch double faults.
;

        mov     eax,KissIdt
        lea     ecx,[eax]+40h           ; Descriptor 8
        mov     byte ptr [ecx+5],085h   ; dpl=0, present, taskgate

        mov     word ptr [ecx+2],KGDT_DF_TSS

        lea     ecx,[edi]+KGDT_DF_TSS
        mov     byte ptr [ecx+5],089h   ; 32bit, dpl=0, present, TSS32, not busy

        mov     edx,offset FLAT:_KiDoubleFaultTSS
        mov     eax,edx
        mov     [ecx+KgdtBaseLow],ax
        shr     eax,16
        mov     [ecx+KgdtBaseHi],ah
        mov     [ecx+KgdtBaseMid],al
        mov     eax, MINIMUM_TSS_SIZE
        mov     [ecx+KgdtLimitLow],ax

; KiInitializeTSS(
;       address of double fault TSS
;       );
        push      edx
        stdCall   _KiInitializeTSS, <edx>
        pop       edx

        mov     eax,cr3
        mov     [edx+TssCr3],eax

        mov     eax, offset FLAT:_KiDoubleFaultStack
        mov     dword ptr [edx+TssEsp],eax
        mov     dword ptr [edx+TssEsp0],eax

        mov     dword ptr [edx+020h],offset FLAT:_KiTrap08
        mov     dword ptr [edx+024h],0              ; eflags
        mov     word ptr [edx+04ch],KGDT_R0_CODE    ; set value for CS
        mov     word ptr [edx+058h],KGDT_R0_PCR     ; set value for FS
        mov     [edx+050h],ss
        mov     word ptr [edx+048h],KGDT_R3_DATA OR RPL_MASK ; Es
        mov     word ptr [edx+054h],KGDT_R3_DATA OR RPL_MASK ; Ds

;
;   set up 32bit NMI task gate to catch NMI faults.
;

        mov     eax,KissIdt
        lea     ecx,[eax]+10h           ; Descriptor 2
        mov     byte ptr [ecx+5],085h   ; dpl=0, present, taskgate

        mov     word ptr [ecx+2],KGDT_NMI_TSS

        lea     ecx,[edi]+KGDT_NMI_TSS
        mov     byte ptr [ecx+5],089h   ; 32bit, dpl=0, present, TSS32, not busy

        mov     edx,offset FLAT:_KiNMITSS
        mov     eax,edx
        mov     [ecx+KgdtBaseLow],ax
        shr     eax,16
        mov     [ecx+KgdtBaseHi],ah
        mov     [ecx+KgdtBaseMid],al
        mov     eax, MINIMUM_TSS_SIZE
        mov     [ecx+KgdtLimitLow],ax

        push    edx
        stdCall _KiInitializeTSS,<edx>  ; KiInitializeTSS(
                                        ;       address TSS
                                        ;       );
        pop     edx

;
; We are using the DoubleFault stack as the DoubleFault stack and the
; NMI Task Gate stack and briefly, it is the DPC stack for the first
; processor.
;

        mov     eax,cr3
        mov     [edx+TssCr3],eax

        mov     eax, offset FLAT:_KiDoubleFaultTSS
        mov     eax, dword ptr [eax+038h]           ; get DF stack
        mov     dword ptr [edx+TssEsp0],eax         ; use it for NMI stack
        mov     dword ptr [edx+038h],eax

        mov     dword ptr [edx+020h],offset FLAT:_KiTrap02
        mov     dword ptr [edx+024h],0              ; eflags
        mov     word ptr [edx+04ch],KGDT_R0_CODE    ; set value for CS
        mov     word ptr [edx+058h],KGDT_R0_PCR     ; set value for FS
        mov     [edx+050h],ss
        mov     word ptr [edx+048h],KGDT_R3_DATA OR RPL_MASK ; Es
        mov     word ptr [edx+054h],KGDT_R3_DATA OR RPL_MASK ; Ds

        stdCall   _KiInitializePcr, <KissPbNumber,KissPcr,KissIdt,KissGdt,KissTss,KissIdleThread,offset FLAT:_KiDoubleFaultStack>

;
; set current process pointer in current thread object
;
        mov     edx, KissIdleThread
        mov     ecx, offset FLAT:_KiInitialProcess ; (ecx)-> idle process obj
        mov     [edx]+ThApcState+AsProcess, ecx ; set addr of thread's process


;
; set up PCR: Teb, Prcb pointers.  The PCR:InitialStack, and various fields
; of Prcb will be set up in _KiInitializeKernel
;

        mov     dword ptr PCR[PcTeb], 0   ; PCR->Teb = 0

;
; Initialize KernelDr7 and KernelDr6 to 0.  This must be done before
; the debugger is called.
;

        mov     dword ptr PCR[PcPrcbData+PbProcessorState+PsSpecialRegisters+SrKernelDr6],0
        mov     dword ptr PCR[PcPrcbData+PbProcessorState+PsSpecialRegisters+SrKernelDr7],0

;
; Since the entries of Kernel IDT have their Selector and Extended Offset
; fields set up in the wrong order, we need to swap them back to the order
; which i386 recognizes.
; This is only done by the bootup processor.
;

        stdCall   _KiSwapIDT                  ; otherwise, do the work

;
;   Switch to R3 flat selectors that we want loaded so lazy segment
;   loading will work.
;
        mov     eax,KGDT_R3_DATA OR RPL_MASK    ; Set RPL = ring 3
        mov     ds,ax
        mov     es,ax

;
; Now copy our trap handlers to replace kernel debugger's handlers.
;

        mov     eax, KissIdt            ; (eax)-> Idt
        push    dword ptr [eax+40h]     ; save double fault's descriptor
        push    dword ptr [eax+44h]
        push    dword ptr [eax+10h]     ; save nmi fault's descriptor
        push    dword ptr [eax+14h]

        mov     edi,KissIdt
        mov     esi,offset FLAT:_IDT
        mov     ecx,offset FLAT:_IDTLEN ; _IDTLEN is really an abs, we use
        shr     ecx,2

        rep     movsd
        pop     dword ptr [eax+14h]     ; restore nmi fault's descriptor
        pop     dword ptr [eax+10h]
        pop     dword ptr [eax+44h]     ; restore double fault's descriptor
        pop     dword ptr [eax+40h]

ifdef QLOCK_STAT_GATHER

        EXTRNP  KiCaptureQueuedSpinlockRoutines,0,,FASTCALL

        fstCall KiCaptureQueuedSpinlockRoutines

endif

kiss_notp0:

ifndef NT_UP

;
; Let the boot processor know this processor is starting.
;

        stdCall _KiProcessorStart

endif

;
; A new processor can't come online while execution is frozen
; Take freezelock while adding a processor to the system
; NOTE: don't use SPINLOCK macro - it has debugger stuff in it
;

@@:     test    _KiFreezeExecutionLock, 1
        jnz     short @b

        lock bts _KiFreezeExecutionLock, 0
        jc      short @b

;
; Add processor to active summary, and update BroadcastMasks
;
        mov     ecx, dword ptr KissPbNumber ; mark this processor as active
        mov     byte ptr PCR[PcNumber], cl
        mov     eax, 1
        shl     eax, cl                     ; our affinity bit
        mov     PCR[PcSetMember], eax
        mov     PCR[PcSetMemberCopy], eax
        mov     PCR[PcPrcbData.PbSetMember], eax

;
; Initialize the interprocessor interrupt vector and increment ready
; processor count to enable kernel debugger.
;
        stdCall   _HalInitializeProcessor, <dword ptr KissPbNumber, KissLoaderBlock>

ifdef _APIC_TPR_

;
; Record the IRQL tables passed to us by the hal
;

        mov     eax, KissLoaderBlock
        mov     eax, [eax]+LpbExtension
        mov     ecx, [eax]+LpeHalpIRQLToTPR
        mov     _HalpIRQLToTPR, ecx
        mov     ecx, [eax]+LpeHalpVectorToIRQL
        mov     _HalpVectorToIRQL, ecx

endif


        mov     eax, PCR[PcSetMember]
        or      _KeActiveProcessors, eax    ; New affinity of active processors

;
; Initialize ABIOS data structure if present.
; Note, the KiInitializeAbios MUST be called after the KeLoaderBlock is
; initialized.
;
        stdCall   _KiInitializeAbios, <dword ptr KissPbNumber>

        inc     _KeNumberProcessors         ; One more processor now active

        xor     eax, eax                    ; release the executionlock
        mov     _KiFreezeExecutionLock, eax

        cmp     byte ptr KissPbNumber, 0
        jnz     @f

; don't stop in debugger
        stdCall   _KdInitSystem, <0,_KeLoaderBlock>

if  DEVL
;
; Give the debugger an opportunity to gain control.
;

        POLL_DEBUGGER
endif   ; DEVL
@@:
        nop                             ; leave a spot for int-3 patch
;
; Set initial IRQL = HIGH_LEVEL for init
;

        RaiseIrql HIGH_LEVEL
        mov     KissIrql, al
        or      _KiBootFeatureBits, KF_CMPXCHG8B ; We're committed to using

;
; Initialize ebp, esp, and argument registers for initializing the kernel.
;

        mov     ebx, KissIdleThread
        mov     edx, KissIdleStack
        mov     eax, KissPbNumber
        and     edx, NOT 3h             ; align stack to 4 byte boundary

        xor     ebp, ebp                ; (ebp) = 0.   No more stack frame
        mov     esp, edx

;
; Reserve space for idle thread stack NPX_SAVE_AREA and initialization
;

        sub     esp, NPX_FRAME_LENGTH+KTRAP_FRAME_LENGTH+KTRAP_FRAME_ALIGN
        push    CR0_EM+CR0_TS+CR0_MP    ; make space for Cr0NpxState

; arg6 - LoaderBlock
; arg5 - processor number
; arg4 - addr of prcb
; arg3 - idle thread's stack
; arg2 - addr of current thread obj
; arg1 - addr of current process obj

; initialize system data structures
; and HAL.

        stdCall    _KiInitializeKernel,<offset _KiInitialProcess,ebx,edx,dword ptr PCR[PcPrcb],eax,_KeLoaderBlock>

;
; Set idle thread priority.
;

        mov     ebx,PCR[PcPrcbData+PbCurrentThread] ; get idle thread address
        mov     byte ptr [ebx]+ThPriority, 0 ; set idle thread priority

;
; Control is returned to the idle thread with IRQL at HIGH_LEVEL. Lower IRQL
; to DISPATCH_LEVEL and set wait IRQL of idle thread.
;

        sti
        LowerIrql DISPATCH_LEVEL
        mov     byte ptr [ebx]+ThWaitIrql, DISPATCH_LEVEL

;
; The following code represents the idle thread for a processor. The idle
; thread executes at IRQL DISPATCH_LEVEL and continually polls for work to
; do. Control may be given to this loop either as a result of a return from
; the system initialization routine or as the result of starting up another
; processor in a multiprocessor configuration.
;

        mov     ebx, PCR[PcSelfPcr]     ; get address of PCR

;
; In a multiprocessor system the boot processor proceeds directly into
; the idle loop. As other processors start executing, however, they do
; not directly enter the idle loop - they spin until all processors have
; been started and the boot master allows them to proceed.
;

ifndef NT_UP

@@:     cmp     _KiBarrierWait, 0       ; check if barrier set
        YIELD
        jnz     short @b                ; if nz, barrier set

endif

        push    0                       ; terminate KD traceback 0 RA.
        jmp     @KiIdleLoop@0           ; enter idle loop

stdENDP _KiSystemStartup

        page ,132
        subttl  "Set up 80387, or allow for emulation"
;++
;
; Routine Description:
;
;    This routine is called during kernel initialization once for each
;    processor.  It sets EM+TS+MP whether we are emulating or not.
;
;    If the 387 hardware exists, EM+TS+MP will all be cleared on the
;    first trap 07.  Thereafter, EM will never be seen for this thread.
;    MP+TS will only be set when an error is detected (via IRQ 13), and
;    it will be cleared by the trap 07 that will occur on the next FP
;    instruction.
;
;    If we're emulating, EM+TS+MP are all always set to ensure that all
;    FP instructions trap to the emulator (the trap 07 handler is edited
;    to point to the emulator, rather than KiTrap07).
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    None.
;
;--

cPublicProc _KiSetCR0Bits ,0

        mov     eax, cr0
;
; There are two useful bits in CR0 that we want to turn on if the processor
; is a 486 or above.  (They don't exist on the 386)
;
;       CR0_AM - Alignment mask (so we can turn on alignment faults)
;
;       CR0_WP - Write protect (so we get page faults if we write to a
;                write-protected page from kernel mode)
;
        cmp     byte ptr PCR[PcPrcbData.PbCpuType], 3h
        jbe     @f
;
; The processor is not a 386, (486 or greater) so we assume it is ok to
; turn on these bits.
;

        or      eax, CR0_WP

@@:
        mov     cr0, eax
        stdRET  _KiSetCR0Bits

stdENDP _KiSetCR0Bits


ifdef DBGMP
cPublicProc _KiPollDebugger,0
cPublicFpo 0,3
        push    eax
        push    ecx
        push    edx
        POLL_DEBUGGER
        pop     edx
        pop     ecx
        pop     eax
        stdRET    _KiPollDebugger
stdENDP _KiPollDebugger

endif

INIT    ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ke\i386\spindbg.asm ===
TITLE   "Spin Locks"
;++
;
; Copyright (c) Microsoft Corporation. All rights reserved. 
;
; You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
; If you do not agree to the terms, do not use the code.
;
;
;  Module Name:
;
;     spindbg.asm
;
;  Abstract:
;
;--

        PAGE

.386p

include ks386.inc
include callconv.inc                    ; calling convention macros
include mac386.inc
include irqli386.inc


if DBG
        EXTRNP  _KeBugCheckEx,5
ifdef DBGMP
        EXTRNP  _KiPollDebugger,0
endif
        extrn   _KeTickCount:DWORD
        extrn   _KiSpinlockTimeout:DWORD
endif


_TEXT$00   SEGMENT  DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

;++
;
;  VOID
;  Kii386SpinOnSpinLock (
;     IN PKSPIN_LOCK SpinLock
;     IN ULONG       Flag
;     )
;
;  Routine Description:
;
;     This function is called on a debug build to spin on a spinlock.
;     It is invoked by the DEBUG version of SPIN_ON_SPINLOCK macro.
;
;  Warning:
;
;     Not called with C calling conventions
;     Does not destroy any register
;
;--

cPublicProc Kii386SpinOnSpinLock,2

if DBG
cPublicFpo 2,2
        push    eax
        push    ebx

        mov     eax, [esp+12]           ; (eax) = LockAddress

        mov     ebx, PCR[PcPrcbData.PbCurrentThread]
        or      ebx, 1                  ; or on busy bit
        cmp     ebx, [eax]              ; current thread the owner?
        je      short ssl_sameid        ; Yes, go abort

ssl_10:
        mov     ebx, _KeTickCount       ; Current time
        add     ebx, _KiSpinlockTimeout ; wait n ticks

ifdef DBGMP
        test    byte ptr [esp+16], 2    ; poll debugger while waiting?
        jnz     short ssl_30
endif

;
; Spin while watching KeTickCount
;

ssl_20: YIELD
        cmp     _KeTickCount, ebx       ; check current time
        jnc     short ssl_timeout       ; NC, too many ticks have gone by

        test    dword ptr [eax], 1
        jnz     short ssl_20

ssl_exit:
        pop     ebx                     ; Spinlock is not busy, return
        pop     eax
        stdRET  Kii386SpinOnSpinLock

ifdef DBGMP
;
; Spin while watching KeTickCount & poll debugger
;

ssl_30: YIELD
        cmp     _KeTickCount, ebx       ; check current time
        jnc     short ssl_timeout       ; overflowed

        stdCall _KiPollDebugger

        test    dword ptr [eax], 1
        jnz     short ssl_30

        pop     ebx                     ; Spinlock is not busy, return
        pop     eax
        stdRET  Kii386SpinOnSpinLock
endif

;
; Out of line exception conditions
;

ssl_sameid:
        test    byte ptr [esp+16], 1    ; ID check enabled?
        jz      short ssl_10            ; no, continue
        push    eax
        CurrentIrql                     ; Get current IRQL
        cmp     al, SYNCH_LEVEL         ; Above synch_level we may seen the same
        pop     eax                     ;  thread on two different processors
        jg      ssl_10

        ; recursed on lock, abort

        stdCall _KeBugCheckEx,<SPIN_LOCK_ALREADY_OWNED,eax,0,0,0>

ssl_timeout:
        test    byte ptr [esp+16], 4    ; Timeout check enabled?
        jz      short ssl_10            ; no, continue

        CurrentIrql                     ; Check to see what level we're spinning at
        cmp     al, DISPATCH_LEVEL
        mov     eax, [esp+12]           ; restore eax
        jc      short ssl_10            ; if < dispatch_level, don't timeout

        test    dword ptr [eax], 1      ; Check to see if spinlock was freed
        jz      short ssl_exit

        public SpinLockSpinningForTooLong
SpinLockSpinningForTooLong:

        int 3                           ; Stop here
        jmp     short ssl_10            ; re-wait

else    ; DBG
        stdRET  Kii386SpinOnSpinLock
endif
stdENDP Kii386SpinOnSpinLock,2

_TEXT$00   ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ke\i386\pat.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    pat.h

Abstract:

    This module contains the i386 specific Page Attribute
    Table (PAT) register hardware definitions.

--*/

//
// PAT MSR architecture definitions
//

//
// PAT model specific register
//

#define PAT_MSR       0x277

//
// PAT memory attributes
//

#define PAT_TYPE_STRONG_UC  0       // corresponds to PPro PCD=1,PWT=1
#define PAT_TYPE_USWC       1
#define PAT_TYPE_WT         4
#define PAT_TYPE_WP         5
#define PAT_TYPE_WB         6
#define PAT_TYPE_WEAK_UC    7       // corresponds to PPro PCD=1,PWT=0
#define PAT_TYPE_MAX        8       

#include "pshpack1.h"

typedef union _PAT {
    struct {
        UCHAR Pat[8];
    } hw;
    ULONGLONG   QuadPart;
} PAT, *PPAT;

#include "poppack.h"
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ke\i386\spinlock.asm ===
TITLE   "Spin Locks"
;++
;
; Copyright (c) Microsoft Corporation. All rights reserved. 
;
; You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
; If you do not agree to the terms, do not use the code.
;
;
;  Module Name:
;
;     spinlock.asm
;
;  Abstract:
;
;     This module implements the routines for acquiring and releasing
;     spin locks.
;
;--

        PAGE

.586p

include ks386.inc
include callconv.inc                    ; calling convention macros
include i386\kimacro.inc
include mac386.inc
include irqli386.inc

        EXTRNP  _KeBugCheckEx,5


_TEXT$00   SEGMENT  PARA PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

        PAGE
        SUBTTL "Ke Acquire Spin Lock At DPC Level"

;++
;
;  VOID
;  KefAcquireSpinLockAtDpcLevel (
;     IN PKSPIN_LOCK SpinLock
;     )
;
;  Routine Description:
;
;     This function acquires a kernel spin lock.
;
;     N.B. This function assumes that the current IRQL is set properly.
;        It neither raises nor lowers IRQL.
;
;  Arguments:
;
;     (ecx) SpinLock - Supplies a pointer to an kernel spin lock.
;
;  Return Value:
;
;     None.
;
;--

align 16
cPublicFastCall KefAcquireSpinLockAtDpcLevel, 1
cPublicFpo 0, 0
if DBG
        push    ecx
        CurrentIrql
        pop     ecx

        cmp     al, DISPATCH_LEVEL
        jl      short asld50
endif

ifdef NT_UP
        fstRET    KefAcquireSpinLockAtDpcLevel
else
;
;   Attempt to assert the lock
;

asld10: ACQUIRE_SPINLOCK    ecx,<short asld20>
        fstRET    KefAcquireSpinLockAtDpcLevel

;
;   Lock is owned, spin till it looks free, then go get it again.
;

align 4
asld20: SPIN_ON_SPINLOCK    ecx,<short asld10>

endif

if DBG
asld50: stdCall   _KeBugCheckEx,<IRQL_NOT_GREATER_OR_EQUAL,ecx,eax,0,0>
        int       3                 ; help debugger backtrace.
endif

fstENDP KefAcquireSpinLockAtDpcLevel


;++
;
;  VOID
;  KeAcquireSpinLockAtDpcLevel (
;     IN PKSPIN_LOCK SpinLock
;     )
;
;  Routine Description:
;
;   Thunk for standard call callers
;
;--

cPublicProc _KeAcquireSpinLockAtDpcLevel, 1
cPublicFpo 1,0

ifndef NT_UP
        mov     ecx,[esp+4]         ; SpinLock

aslc10: ACQUIRE_SPINLOCK    ecx,<short aslc20>
        stdRET    _KeAcquireSpinLockAtDpcLevel

aslc20: SPIN_ON_SPINLOCK    ecx,<short aslc10>
endif
        stdRET    _KeAcquireSpinLockAtDpcLevel
stdENDP _KeAcquireSpinLockAtDpcLevel


        PAGE
        SUBTTL "Ke Release Spin Lock From Dpc Level"
;++
;
;  VOID
;  KefReleaseSpinLockFromDpcLevel (
;     IN PKSPIN_LOCK SpinLock
;     )
;
;  Routine Description:
;
;     This function releases a kernel spin lock.
;
;     N.B. This function assumes that the current IRQL is set properly.
;        It neither raises nor lowers IRQL.
;
;  Arguments:
;
;     (ecx) SpinLock - Supplies a pointer to an executive spin lock.
;
;  Return Value:
;
;     None.
;
;--
align 16
cPublicFastCall KefReleaseSpinLockFromDpcLevel  ,1
cPublicFpo 0,0
ifndef NT_UP
        RELEASE_SPINLOCK    ecx
endif
        fstRET    KefReleaseSpinLockFromDpcLevel

fstENDP KefReleaseSpinLockFromDpcLevel

;++
;
;  VOID
;  KeReleaseSpinLockFromDpcLevel (
;     IN PKSPIN_LOCK SpinLock
;     )
;
;  Routine Description:
;
;   Thunk for standard call callers
;
;--

cPublicProc _KeReleaseSpinLockFromDpcLevel, 1
cPublicFpo 1,0
ifndef NT_UP
        mov     ecx, [esp+4]            ; (ecx) = SpinLock
        RELEASE_SPINLOCK    ecx
endif
        stdRET    _KeReleaseSpinLockFromDpcLevel
stdENDP _KeReleaseSpinLockFromDpcLevel



        PAGE
        SUBTTL "Ki Acquire Kernel Spin Lock"

;++
;
;  VOID
;  FASTCALL
;  KiAcquireSpinLock (
;     IN PKSPIN_LOCK SpinLock
;     )
;
;  Routine Description:
;
;     This function acquires a kernel spin lock.
;
;     N.B. This function assumes that the current IRQL is set properly.
;        It neither raises nor lowers IRQL.
;
;  Arguments:
;
;     (ecx) SpinLock - Supplies a pointer to an kernel spin lock.
;
;  Return Value:
;
;     None.
;
;--

align 16
cPublicFastCall KiAcquireSpinLock  ,1
cPublicFpo 0,0
ifndef NT_UP

;
;   Attempt to assert the lock
;

asl10:  ACQUIRE_SPINLOCK    ecx,<short asl20>
        fstRET    KiAcquireSpinLock

;
;   Lock is owned, spin till it looks free, then go get it again.
;

align 4
asl20:  SPIN_ON_SPINLOCK    ecx,<short asl10>

else
        fstRET    KiAcquireSpinLock
endif

fstENDP KiAcquireSpinLock

        PAGE
        SUBTTL "Ki Release Kernel Spin Lock"
;++
;
;  VOID
;  FASTCALL
;  KiReleaseSpinLock (
;     IN PKSPIN_LOCK SpinLock
;     )
;
;  Routine Description:
;
;     This function releases a kernel spin lock.
;
;     N.B. This function assumes that the current IRQL is set properly.
;        It neither raises nor lowers IRQL.
;
;  Arguments:
;
;     (ecx) SpinLock - Supplies a pointer to an executive spin lock.
;
;  Return Value:
;
;     None.
;
;--
align 16
cPublicFastCall KiReleaseSpinLock  ,1
cPublicFpo 0,0
ifndef NT_UP

        RELEASE_SPINLOCK    ecx

endif
        fstRET    KiReleaseSpinLock

fstENDP KiReleaseSpinLock

        PAGE
        SUBTTL "Try to acquire Kernel Spin Lock"

;++
;
;  BOOLEAN
;  KeTryToAcquireSpinLock (
;     IN PKSPIN_LOCK SpinLock,
;     OUT PKIRQL     OldIrql
;     )
;
;  Routine Description:
;
;     This function attempts acquires a kernel spin lock.  If the
;     spinlock is busy, it is not acquire and FALSE is returned.
;
;  Arguments:
;
;     SpinLock (TOS+4) - Supplies a pointer to an kernel spin lock.
;     OldIrql  (TOS+8) = Location to store old irql
;
;  Return Value:
;     TRUE  - Spinlock was acquired & irql was raise
;     FALSE - SpinLock was not acquired - irql is unchanged.
;
;--

align dword
cPublicProc _KeTryToAcquireSpinLock  ,2
cPublicFpo 2,0

ifdef NT_UP
; UP Version of KeTryToAcquireSpinLock

        RaiseIrql DISPATCH_LEVEL

        mov     ecx, [esp+8]        ; (ecx) -> ptr to OldIrql
        mov     [ecx], al           ; save OldIrql

        mov     eax, 1              ; Return TRUE
        stdRET    _KeTryToAcquireSpinLock

else
; MP Version of KeTryToAcquireSpinLock

        mov     edx,[esp+4]         ; (edx) -> spinlock

;
; First check the spinlock without asserting a lock
;

        TEST_SPINLOCK       edx,<short ttsl10>

;
; Spinlock looks free raise irql & try to acquire it
;

;
; raise to dispatch_level
;

        RaiseIrql DISPATCH_LEVEL

        mov     edx, [esp+4]        ; (edx) -> spinlock
        mov     ecx, [esp+8]        ; (ecx) = Return OldIrql

        ACQUIRE_SPINLOCK    edx,<short ttsl20>

        mov     [ecx], al           ; save OldIrql
        mov     eax, 1              ; spinlock was acquired, return TRUE

        stdRET    _KeTryToAcquireSpinLock

ttsl10: xor     eax, eax            ; return FALSE
        YIELD
        stdRET    _KeTryToAcquireSpinLock

ttsl20:
        YIELD
        mov     ecx, eax            ; (ecx) = OldIrql
        LowerIrql ecx
        xor     eax, eax            ; return FALSE
        stdRET    _KeTryToAcquireSpinLock
endif

stdENDP _KeTryToAcquireSpinLock

        PAGE
        SUBTTL "Ki Try to acquire Kernel Spin Lock"
;++
;
;  BOOLEAN
;  FASTCALL
;  KeTryToAcquireSpinLockAtDpcLevel (
;     IN PKSPIN_LOCK SpinLock
;     )
;
;  Routine Description:
;
;     This function attempts acquires a kernel spin lock.  If the
;     spinlock is busy, it is not acquire and FALSE is returned.
;
;  Arguments:
;
;     SpinLock (ecx) - Supplies a pointer to an kernel spin lock.
;
;  Return Value:
;
;     TRUE  - Spinlock was acquired
;     FALSE - SpinLock was not acquired
;
;--

align dword
cPublicFastCall KeTryToAcquireSpinLockAtDpcLevel  ,1
cPublicFpo 0, 0

;
; First check the spinlock without asserting a lock
;

ifndef NT_UP

        TEST_SPINLOCK       ecx, <short atsl20>

;
; Spinlock looks free try to acquire it.
;

        ACQUIRE_SPINLOCK    ecx, <short atsl20>

endif

        mov     eax, 1              ; spinlock was acquired, return TRUE

        fstRET  KeTryToAcquireSpinLockAtDpcLevel

ifndef NT_UP

atsl20: YIELD                       ;
        xor     eax, eax            ; return FALSE

        fstRET  KeTryToAcquireSpinLockAtDpclevel

endif

fstENDP KeTryToAcquireSpinLockAtDpcLevel

;++
;
;  BOOLEAN
;  KeTestSpinLock (
;     IN PKSPIN_LOCK SpinLock
;     )
;
;  Routine Description:
;
;     This function tests a kernel spin lock.  If the spinlock is
;     busy, FALSE is returned.  If not, TRUE is returned.  The spinlock
;     is never acquired.  This is provided to allow code to spin at low
;     IRQL, only raising the IRQL when there is a reasonable hope of
;     acquiring the lock.
;
;  Arguments:
;
;     SpinLock (ecx) - Supplies a pointer to a kernel spin lock.
;
;  Return Value:
;     TRUE  - Spinlock appears available
;     FALSE - SpinLock is busy
;
;--

cPublicFastCall KeTestSpinLock  ,1
        TEST_SPINLOCK       ecx,<short tso10>
        mov       eax, 1
        fstRET    KeTestSpinLock

tso10:  YIELD
        xor       eax, eax
        fstRET    KeTestSpinLock

fstENDP KeTestSpinLock

        page    ,132
        subttl  "Acquire In Stack Queued SpinLock At Dpc Level"

ifdef QLOCK_STAT_GATHER

        EXTRNP  KiQueueStatTrySucceeded,2,,FASTCALL
        EXTRNP  KiQueueStatTryFailed,1,,FASTCALL
        EXTRNP  KiQueueStatTry,1,,FASTCALL
        EXTRNP  KiQueueStatAcquireQueuedLock,1,,FASTCALL
        EXTRNP  KiQueueStatAcquireQueuedLockRTS,1,,FASTCALL
        EXTRNP  KiQueueStatTryAcquire,3,,FASTCALL
        EXTRNP  KiQueueStatReleaseQueuedLock,2,,FASTCALL
        EXTRNP  KiQueueStatAcquire,1,,FASTCALL
        EXTRNP  KiQueueStatRelease,1,,FASTCALL
        EXTRNP  KiAcquireQueuedLock,1,,FASTCALL
        EXTRNP  KiReleaseQueuedLock,1,,FASTCALL

;
; The following routines are used to wrap the actual calls to the 
; real routines which have been usurped here by patching the import
; table.
;

cPublicFastCall __cap_KeAcquireQueuedSpinLock,1
        sub     esp, 8          ; make room to save time
        push    ecx             ; save args
        rdtsc                   ; get time
        mov     [esp].4, eax    ; save low part
        mov     [esp].8, edx    ; save high part
        mov     ecx, [esp]      ; restore arg
        fstCall KiQueueStatAcquireQueuedLock
acqst:  mov     ecx, esp        ; set arg pointer for data accum
        push    eax             ; save result
        fstCall KiQueueStatAcquire
        pop     eax             ; restore result
        add     esp, 12         ; restore stack pointer
        fstRET  __cap_KeAcquireQueuedSpinLock
        fstENDP __cap_KeAcquireQueuedSpinLock

cPublicFastCall __cap_KeAcquireQueuedSpinLockRaiseToSynch,1
        sub     esp, 8          ; make room to save time
        push    ecx             ; save args
        rdtsc                   ; get time
        mov     [esp].4, eax    ; save low part
        mov     [esp].8, edx    ; save high part
        mov     ecx, [esp]      ; restore arg
        fstCall KiQueueStatAcquireQueuedLockRTS
        jmp     short acqst     ; use common code to finish
        fstENDP __cap_KeAcquireQueuedSpinLockRaiseToSynch

cPublicFastCall __cap_KeTryToAcquireQueuedSpinLockRaiseToSynch,2
        push    ecx             ; save arg
        push    SYNCH_LEVEL
tryst:  fstCall KiQueueStatTryAcquire
        push    eax             ; save result
        mov     ecx, esp
        fstCall KiQueueStatTry
        pop     eax             ; restore result
        add     esp, 4          ; drop saved arg
        or      eax, eax        ; some assembly callers expect appropriate flags
        fstRET  __cap_KeTryToAcquireQueuedSpinLockRaiseToSynch
        fstENDP __cap_KeTryToAcquireQueuedSpinLockRaiseToSynch

cPublicFastCall __cap_KeTryToAcquireQueuedSpinLock,2
        push    ecx             ; save arg
        push    DISPATCH_LEVEL
        jmp     short tryst     ; use common code to finish
        fstENDP __cap_KeTryToAcquireQueuedSpinLock

cPublicFastCall __cap_KeReleaseQueuedSpinLock,2
        push    ecx             ; save args
        mov     ecx, esp        ; set arg for stat release routine
        push    edx             ; save other arg
        fstCall KiQueueStatRelease
        pop     edx
        pop     ecx
        fstCall KiQueueStatReleaseQueuedLock
        fstRET  __cap_KeReleaseQueuedSpinLock
        fstENDP __cap_KeReleaseQueuedSpinLock

;
; KeAcquireQueuedSpinLockAtDpcLevel
; KeReleaseQueuedSpinLockFromDpcLevel
;
; These two routines are defined here in assembly code so
; as to capture the caller's address.
;

cPublicFastCall KeAcquireQueuedSpinLockAtDpcLevel,1
        sub     esp, 8          ; make room to save time
        push    ecx             ; save args
        rdtsc                   ; get time
        mov     [esp].4, eax    ; save low part
        mov     [esp].8, edx    ; save high part
        mov     ecx, [esp]      ; restore arg
        fstCall KiAcquireQueuedLock
        mov     ecx, esp
        fstCall KiQueueStatAcquire
        add     esp, 12         ; restore SP
        fstRET  KeAcquireQueuedSpinLockAtDpcLevel
        fstENDP KeAcquireQueuedSpinLockAtDpcLevel

cPublicFastCall KeReleaseQueuedSpinLockFromDpcLevel,1
        push    ecx             ; save args
        mov     ecx, esp        ; set arg for stat release routine
        fstCall KiQueueStatRelease
        pop     ecx
        fstCall KiReleaseQueuedLock
        fstRET  KeReleaseQueuedSpinLockFromDpcLevel
        fstENDP KeReleaseQueuedSpinLockFromDpcLevel

;
; KiCaptureQueuedSpinlockRoutines
;
; Replace the import table entries for the x86 HAL queued spinlock
; routines with our statistic capturing variety.
;

        EXTRNP  KeAcquireQueuedSpinLock,1,IMPORT,FASTCALL
        EXTRNP  KeAcquireQueuedSpinLockRaiseToSynch,1,IMPORT,FASTCALL
        EXTRNP  KeTryToAcquireQueuedSpinLockRaiseToSynch,2,IMPORT,FASTCALL
        EXTRNP  KeTryToAcquireQueuedSpinLock,2,IMPORT,FASTCALL
        EXTRNP  KeReleaseQueuedSpinLock,2,IMPORT,FASTCALL

cPublicFastCall KiCaptureQueuedSpinlockRoutines,0

        mov     eax, @__cap_KeAcquireQueuedSpinLock@4
        mov     [__imp_@KeAcquireQueuedSpinLock@4], eax

        mov     eax, @__cap_KeAcquireQueuedSpinLockRaiseToSynch@4
        mov     [__imp_@KeAcquireQueuedSpinLockRaiseToSynch@4], eax

        mov     eax, @__cap_KeTryToAcquireQueuedSpinLockRaiseToSynch@8
        mov     [__imp_@KeTryToAcquireQueuedSpinLockRaiseToSynch@8], eax

        mov     eax, @__cap_KeTryToAcquireQueuedSpinLock@8
        mov     [__imp_@KeTryToAcquireQueuedSpinLock@8], eax

        mov     eax, @__cap_KeReleaseQueuedSpinLock@8
        mov     [__imp_@KeReleaseQueuedSpinLock@8], eax

        fstRet  KiCaptureQueuedSpinlockRoutines
        fstENDP KiCaptureQueuedSpinlockRoutines

else

;++
;
; VOID
; FASTCALL
; KeAcquireInStackQueuedSpinLockAtDpcLevel (
;     IN PKSPIN_LOCK SpinLock,
;     IN PKLOCK_QUEUE_HANDLE LockHandle
;     )
;
; Routine Description:
;
;    This function acquires the specified in stack queued spin lock at the
;    current IRQL.
;
; Arguments:
;
;    SpinLock (ecx) - Supplies the address of a spin lock.
;
;    LockHandle (edx) - Supplies the address of an in stack lock handle.
;
; Return Value:
;
;    None.
;--

align 16
cPublicFastCall KeAcquireInStackQueuedSpinLockAtDpcLevel,2
cPublicFpo 0,0

ifndef NT_UP

        xor     eax, eax                 ; set next link to NULL
        mov     [edx].LqhNext, eax       ;
        mov     [edx].LqhLock, ecx       ; set spin lock address
        lea     ecx, dword ptr [edx+LqhNext] ; compute address of lock queue
        jmp     short @KeAcquireQueuedSpinLockAtDpcLevel@4 ; finish in common code

else

        fstRET  KeAcquireInStackQueuedSpinLockAtDpcLevel

endif

fstENDP KeAcquireInStackQueuedSpinLockAtDpcLevel

        page    ,132
        subttl  "Acquire Queued SpinLock"

;++
;
; VOID
; KeAcquireQueuedSpinLockAtDpcLevel (
;     IN PKSPIN_LOCK_QUEUE QueuedLock
;     )
;
; Routine Description:
;
;    This function acquires the specified queued spinlock.
;    No change to IRQL is made, IRQL is not returned.  It is
;    expected IRQL is sufficient to avoid context switch.
;
;    Unlike the equivalent Ke versions of these routines,
;    the argument to this routine is the address of the
;    lock queue entry (for the lock to be acquired) in the
;    PRCB rather than the LockQueueNumber.  This saves us
;    a couple of instructions as the address can be calculated
;    at compile time.
;
;    NOTE: This code may be modified for use during textmode
;    setup if this is an MP kernel running with a UP HAL.
;
; Arguments:
;
;    LockQueueEntry (ecx) - Supplies the address of the queued
;                           spinlock entry in this processor's
;                           PRCB.
;
; Return Value:
;
;    None.
;
;    N.B. ecx is preserved, assembly code callers can take advantage
;    of this by avoiding setting up ecx for the call to release if
;    the caller can preserve the lock that long.
;
;--

        ; compile time assert sizeof(KSPIN_LOCK_QUEUE) == 8

.errnz  (LOCK_QUEUE_HEADER_SIZE - 8)

align 16
cPublicFastCall KeAcquireQueuedSpinLockAtDpcLevel,1
cPublicFpo 0,0

ifndef NT_UP

        ; Get address of the actual lock.

        mov     edx, [ecx].LqLock
        mov     eax, ecx                        ; save Lock Queue entry address

        ; Exchange the value of the lock with the address of this
        ; Lock Queue entry.

        xchg    [edx], eax

        cmp     eax, 0                          ; check if lock is held
        jnz     short @f                        ; jiff held

        ; note: the actual lock address will be word aligned, we use
        ; the bottom two bits as indicators, bit 0 is LOCK_QUEUE_WAIT,
        ; bit 1 is LOCK_QUEUE_OWNER.

        or      edx, LOCK_QUEUE_OWNER           ; mark self as lock owner
        mov     [ecx].LqLock, edx

        ; lock has been acquired, return.

aqsl20:

endif

        fstRET  KeAcquireQueuedSpinLockAtDpcLevel

ifndef NT_UP

@@:

if DBG

        ; make sure it isn't already held by THIS processor.

        test    edx, LOCK_QUEUE_OWNER
        jz      short @f

        ; KeBugCheckEx(SPIN_LOCK_ALREADY_OWNED,
        ;             actual lock address,
        ;             my context,
        ;             previous acquirer,
        ;             2);

        stdCall _KeBugCheckEx,<SPIN_LOCK_ALREADY_OWNED,edx,ecx,eax,2>
@@:

endif
        ; The lock is already held by another processor.  Set the wait
        ; bit in this processor's Lock Queue entry, then set the next
        ; field in the Lock Queue entry of the last processor to attempt
        ; to acquire the lock (this is the address returned by the xchg
        ; above) to point to THIS processor's lock queue entry.

        or      edx, LOCK_QUEUE_WAIT            ; set lock bit
        mov     [ecx].LqLock, edx

        mov     [eax].LqNext, ecx               ; set previous acquirer's
                                                ; next field.
        ; Wait.
@@:
        test    [ecx].LqLock, LOCK_QUEUE_WAIT   ; check if still waiting
        jz      short aqsl20                    ; jif lock acquired
        YIELD                                   ; fire avoidance.
        jmp     short @b                        ; else, continue waiting

endif

fstENDP KeAcquireQueuedSpinLockAtDpcLevel

        page    ,132
        subttl  "Release In Stack Queued SpinLock From Dpc Level"
;++
;
; VOID
; FASTCALL
; KeReleaseInStackQueuedSpinLockFromDpcLevel (
;     IN PKLOCK_QUEUE_HANDLE LockHandle
;     )
;
; Routine Description:
;
;    This function releases a queued spinlock and preserves the current
;    IRQL.
;
; Arguments:
;
;    LockHandle (ecx) - Supplies the address of a lock handle.
;
; Return Value:
;
;    None.
;
;--

cPublicFastCall KeReleaseInStackQueuedSpinLockFromDpcLevel,1
cPublicFpo 0,0

ifndef NT_UP

        lea     ecx, dword ptr[ecx+LqhNext] ; compute address of lock queue
        jmp     short @KeReleaseQueuedSpinLockFromDpcLevel@4 ; finish in common code

else

        fstRET  KeReleaseInStackQueuedSpinLockFromDpcLevel

endif

fstENDP KeReleaseInStackQueuedSpinLockFromDpcLevel

        page    ,132
        subttl  "Release Queued SpinLock"

;++
;
; VOID
; KeReleaseQueuedSpinLockFromDpcLevel (
;     IN PKSPIN_LOCK_QUEUE QueuedLock
;     )
;
; Routine Description:
;
;    This function releases a queued spinlock.
;    No change to IRQL is made, IRQL is not returned.  It is
;    expected IRQL is sufficient to avoid context switch.
;
;    NOTE: This code may be modified for use during textmode
;    setup if this is an MP kernel running with a UP HAL.
;
; Arguments:
;
;    LockQueueEntry (ecx) - Supplies the address of the queued
;                           spinlock entry in this processor's
;                           PRCB.
;
; Return Value:
;
;    None.
;
;--

cPublicFastCall KeReleaseQueuedSpinLockFromDpcLevel,1
cPublicFpo 0,0

.errnz  (LOCK_QUEUE_OWNER - 2)           ; error if not bit 1 for btr

ifndef NT_UP

        mov     eax, ecx                        ; need in eax for cmpxchg
        mov     edx, [ecx].LqNext
        mov     ecx, [ecx].LqLock

        ; Quick check: If Lock Queue entry's Next field is not NULL,
        ; there is another waiter.  Don't bother with ANY atomic ops
        ; in this case.
        ;
        ; N.B. Careful ordering, the test will clear the CF bit and set
        ; the ZF bit appropriately if the Next Field (in EDX) is zero.
        ; The BTR will set the CF bit to the previous value of the owner
        ; bit.

        test    edx, edx

        ; Clear the "I am owner" field in the Lock entry.

        btr     ecx, 1                          ; clear owner bit

if DBG
        jnc     short rqsl90                    ; bugcheck if was not set
                                                ; tests CF
endif

        mov     [eax].LqLock, ecx               ; clear lock bit in queue entry
        jnz     short rqsl40                    ; jif another processor waits
                                                ; tests ZF

        xor     edx, edx                        ; new lock owner will be NULL
        push    eax                             ; save &PRCB->LockQueue[Number]

        ; Use compare exchange to attempt to clear the actual lock.
        ; If there are still no processors waiting for the lock when
        ; the compare exchange happens, the old contents of the lock
        ; should be the address of this lock entry (eax).

        lock cmpxchg [ecx], edx                 ; store 0 if no waiters
        pop     eax                             ; restore lock queue address
        jnz     short rqsl60                    ; jif store failed

        ; The lock has been released.  Return to caller.

endif

        fstRET  KeReleaseQueuedSpinLockFromDpcLevel

ifndef NT_UP

        ; Another processor is waiting on this lock.   Hand the lock
        ; to that processor by getting the address of its LockQueue
        ; entry, turning ON its owner bit and OFF its wait bit.

rqsl40: xor     [edx].LqLock, (LOCK_QUEUE_OWNER+LOCK_QUEUE_WAIT)

        ; Done, the other processor now owns the lock, clear the next
        ; field in my LockQueue entry (to preserve the order for entering
        ; the queue again) and return.

        mov     [eax].LqNext, 0
        fstRET  KeReleaseQueuedSpinLockFromDpcLevel

        ; We get here if another processor is attempting to acquire
        ; the lock but had not yet updated the next field in this
        ; processor's Queued Lock Next field.   Wait for the next
        ; field to be updated.

rqsl60: mov     edx, [eax].LqNext
        test    edx, edx                        ; check if still 0
        jnz     short rqsl40                    ; jif Next field now set.
        YIELD                                   ; wait a bit
        jmp     short rqsl60                    ; continue waiting

if DBG

rqsl90:
        stdCall _KeBugCheckEx,<SPIN_LOCK_NOT_OWNED,ecx,eax,0,0>
        int     3                               ; help debugger back trace.

endif

endif

fstENDP KeReleaseQueuedSpinLockFromDpcLevel

endif

        page    ,132
        subttl  "Try to Acquire Queued SpinLock"

;++
;
; LOGICAL
; KeTryToAcquireQueuedSpinLockAtRaisedIrql (
;     IN PKSPIN_LOCK_QUEUE QueuedLock
;     )
;
; Routine Description:
;
;    This function attempts to acquire the specified queued spinlock.
;    No change to IRQL is made, IRQL is not returned.  It is
;    expected IRQL is sufficient to avoid context switch.
;
;    NOTE: This code may be modified for use during textmode
;    setup if this is an MP kernel running with a UP HAL.
;
; Arguments:
;
;    LockQueueEntry (ecx) - Supplies the address of the queued
;                           spinlock entry in this processor's
;                           PRCB.
;
; Return Value:
;
;    TRUE if the lock was acquired, FALSE otherwise.
;    N.B. ZF is set if FALSE returned, clear otherwise.
;
;--


align 16
cPublicFastCall KeTryToAcquireQueuedSpinLockAtRaisedIrql,1
cPublicFpo 0,0

ifndef NT_UP

        ; Get address of Lock Queue entry

        mov     edx, [ecx].LqLock

        ; Store the Lock Queue entry address in the lock ONLY if the
        ; current lock value is 0.

        xor     eax, eax                        ; old value must be 0
        lock cmpxchg [edx], ecx
        jnz     short taqsl60

        ; Lock has been acquired.

        ; note: the actual lock address will be word aligned, we use
        ; the bottom two bits as indicators, bit 0 is LOCK_QUEUE_WAIT,
        ; bit 1 is LOCK_QUEUE_OWNER.

        or      edx, LOCK_QUEUE_OWNER           ; mark self as lock owner
        mov     [ecx].LqLock, edx

ifdef QLOCK_STAT_GATHER

        mov     edx, [esp]
        fstCall KiQueueStatTrySucceeded

endif

        or      eax, 1                          ; return TRUE

        fstRET  KeTryToAcquireQueuedSpinLockAtRaisedIrql

taqsl60:

        ; The lock is already held by another processor.  Indicate
        ; failure to the caller.

ifdef QLOCK_STAT_GATHER

        fstCall KiQueueStatTryFailed

endif

        xor     eax, eax                        ; return FALSE
        fstRET  KeTryToAcquireQueuedSpinLockAtRaisedIrql

        ; In the event that this is an MP kernel running with a UP
        ; HAL, the following UP version is copied over the MP version
        ; during kernel initialization.

        public  _KeTryToAcquireQueuedSpinLockAtRaisedIrqlUP
_KeTryToAcquireQueuedSpinLockAtRaisedIrqlUP:

endif

        ; UP version, always succeed.

        xor     eax, eax
        or      eax, 1
        fstRet  KeTryToAcquireQueuedSpinLockAtRaisedIrql

fstENDP KeTryToAcquireQueuedSpinLockAtRaisedIrql


_TEXT$00   ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ke\i386\sysstubs.asm ===
;++
;
; Copyright (c) Microsoft Corporation. All rights reserved. 
;
; You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
; If you do not agree to the terms, do not use the code.
;
; Module Name:
;
;    sysstubs.asm
;
; Abstract:
;
;    This module implements the system service dispatch stub procedures.
;
; Revision History:
;       Use Fast System call mechanism.
;
;--

include ks386.inc
include callconv.inc

.386

STUBS_BEGIN1 macro t
    TITLE t
endm
STUBS_BEGIN2 macro t
endm
STUBS_BEGIN3 macro t
_TEXT	SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING
endm
STUBS_BEGIN4 macro t
endm
STUBS_BEGIN5 macro t
    align 4
endm
STUBS_BEGIN6 macro t
endm
STUBS_BEGIN7 macro t
endm
STUBS_BEGIN8 macro t
endm

STUBS_END    macro t
_TEXT ENDS
      end
endm

SYSSTUBS_ENTRY1 macro ServiceNumber, Name, NumArgs
cPublicProc _Zw&Name,NumArgs
.FPO ( 0, NumArgs, 0, 0, 0, 0 )
        extrn   _KiSystemService:PROC
        mov     eax, ServiceNumber      ; (eax) = service number
        lea     edx, [esp]+4            ; (edx) -> arguments
        pushfd                          ; EFLAGS to trap frame
        push    KGDT_R0_CODE            ; CS to trap frame
        call    _KiSystemService        ; EIP to trap frame and enter handler
        stdRET  _Zw&Name
stdENDP _Zw&Name
endm

SYSSTUBS_ENTRY2 macro ServiceNumber, Name, NumArgs
endm
SYSSTUBS_ENTRY3 macro ServiceNumber, Name, NumArgs
endm
SYSSTUBS_ENTRY4 macro ServiceNumber, Name, NumArgs
endm
SYSSTUBS_ENTRY5 macro ServiceNumber, Name, NumArgs
endm
SYSSTUBS_ENTRY6 macro ServiceNumber, Name, NumArgs
endm
SYSSTUBS_ENTRY7 macro ServiceNumber, Name, NumArgs
endm
SYSSTUBS_ENTRY8 macro ServiceNumber, Name, NumArgs
endm


USRSTUBS_ENTRY1 macro ServiceNumber, Name, NumArgs
cPublicProc     _Zw&Name, NumArgs
PUBLICP _Nt&Name, NumArgs
LABELP  _Nt&Name, NumArgs
.FPO ( 0, NumArgs, 0, 0, 0, 0 )
        mov     eax, ServiceNumber      ; (eax) = service number
        mov     edx, MM_SHARED_USER_DATA_VA+UsSystemCall
        call    [edx]
        stdRET  _Zw&Name
stdENDP _Zw&Name
endm

USRSTUBS_ENTRY2 macro ServiceNumber, Name, NumArgs
endm
USRSTUBS_ENTRY3 macro ServiceNumber, Name, NumArgs
endm
USRSTUBS_ENTRY4 macro ServiceNumber, Name, NumArgs
endm
USRSTUBS_ENTRY5 macro ServiceNumber, Name, NumArgs
endm
USRSTUBS_ENTRY6 macro ServiceNumber, Name, NumArgs
endm
USRSTUBS_ENTRY7 macro ServiceNumber, Name, NumArgs
endm
USRSTUBS_ENTRY8 macro ServiceNumber, Name, NumArgs
endm

        STUBS_BEGIN1 <"System Service Stub Procedures">
        STUBS_BEGIN2 <"System Service Stub Procedures">
        STUBS_BEGIN3 <"System Service Stub Procedures">
        STUBS_BEGIN4 <"System Service Stub Procedures">
        STUBS_BEGIN5 <"System Service Stub Procedures">
        STUBS_BEGIN6 <"System Service Stub Procedures">
        STUBS_BEGIN7 <"System Service Stub Procedures">
        STUBS_BEGIN8 <"System Service Stub Procedures">
SYSSTUBS_ENTRY1  0, AcceptConnectPort, 6 
SYSSTUBS_ENTRY2  0, AcceptConnectPort, 6 
SYSSTUBS_ENTRY3  0, AcceptConnectPort, 6 
SYSSTUBS_ENTRY4  0, AcceptConnectPort, 6 
SYSSTUBS_ENTRY5  0, AcceptConnectPort, 6 
SYSSTUBS_ENTRY6  0, AcceptConnectPort, 6 
SYSSTUBS_ENTRY7  0, AcceptConnectPort, 6 
SYSSTUBS_ENTRY8  0, AcceptConnectPort, 6 
SYSSTUBS_ENTRY1  1, AccessCheck, 8 
SYSSTUBS_ENTRY2  1, AccessCheck, 8 
SYSSTUBS_ENTRY3  1, AccessCheck, 8 
SYSSTUBS_ENTRY4  1, AccessCheck, 8 
SYSSTUBS_ENTRY5  1, AccessCheck, 8 
SYSSTUBS_ENTRY6  1, AccessCheck, 8 
SYSSTUBS_ENTRY7  1, AccessCheck, 8 
SYSSTUBS_ENTRY8  1, AccessCheck, 8 
SYSSTUBS_ENTRY1  2, AccessCheckAndAuditAlarm, 11 
SYSSTUBS_ENTRY2  2, AccessCheckAndAuditAlarm, 11 
SYSSTUBS_ENTRY3  2, AccessCheckAndAuditAlarm, 11 
SYSSTUBS_ENTRY4  2, AccessCheckAndAuditAlarm, 11 
SYSSTUBS_ENTRY5  2, AccessCheckAndAuditAlarm, 11 
SYSSTUBS_ENTRY6  2, AccessCheckAndAuditAlarm, 11 
SYSSTUBS_ENTRY7  2, AccessCheckAndAuditAlarm, 11 
SYSSTUBS_ENTRY8  2, AccessCheckAndAuditAlarm, 11 
SYSSTUBS_ENTRY1  3, AccessCheckByType, 11 
SYSSTUBS_ENTRY2  3, AccessCheckByType, 11 
SYSSTUBS_ENTRY3  3, AccessCheckByType, 11 
SYSSTUBS_ENTRY4  3, AccessCheckByType, 11 
SYSSTUBS_ENTRY5  3, AccessCheckByType, 11 
SYSSTUBS_ENTRY6  3, AccessCheckByType, 11 
SYSSTUBS_ENTRY7  3, AccessCheckByType, 11 
SYSSTUBS_ENTRY8  3, AccessCheckByType, 11 
SYSSTUBS_ENTRY1  4, AccessCheckByTypeAndAuditAlarm, 16 
SYSSTUBS_ENTRY2  4, AccessCheckByTypeAndAuditAlarm, 16 
SYSSTUBS_ENTRY3  4, AccessCheckByTypeAndAuditAlarm, 16 
SYSSTUBS_ENTRY4  4, AccessCheckByTypeAndAuditAlarm, 16 
SYSSTUBS_ENTRY5  4, AccessCheckByTypeAndAuditAlarm, 16 
SYSSTUBS_ENTRY6  4, AccessCheckByTypeAndAuditAlarm, 16 
SYSSTUBS_ENTRY7  4, AccessCheckByTypeAndAuditAlarm, 16 
SYSSTUBS_ENTRY8  4, AccessCheckByTypeAndAuditAlarm, 16 
SYSSTUBS_ENTRY1  5, AccessCheckByTypeResultList, 11 
SYSSTUBS_ENTRY2  5, AccessCheckByTypeResultList, 11 
SYSSTUBS_ENTRY3  5, AccessCheckByTypeResultList, 11 
SYSSTUBS_ENTRY4  5, AccessCheckByTypeResultList, 11 
SYSSTUBS_ENTRY5  5, AccessCheckByTypeResultList, 11 
SYSSTUBS_ENTRY6  5, AccessCheckByTypeResultList, 11 
SYSSTUBS_ENTRY7  5, AccessCheckByTypeResultList, 11 
SYSSTUBS_ENTRY8  5, AccessCheckByTypeResultList, 11 
SYSSTUBS_ENTRY1  6, AccessCheckByTypeResultListAndAuditAlarm, 16 
SYSSTUBS_ENTRY2  6, AccessCheckByTypeResultListAndAuditAlarm, 16 
SYSSTUBS_ENTRY3  6, AccessCheckByTypeResultListAndAuditAlarm, 16 
SYSSTUBS_ENTRY4  6, AccessCheckByTypeResultListAndAuditAlarm, 16 
SYSSTUBS_ENTRY5  6, AccessCheckByTypeResultListAndAuditAlarm, 16 
SYSSTUBS_ENTRY6  6, AccessCheckByTypeResultListAndAuditAlarm, 16 
SYSSTUBS_ENTRY7  6, AccessCheckByTypeResultListAndAuditAlarm, 16 
SYSSTUBS_ENTRY8  6, AccessCheckByTypeResultListAndAuditAlarm, 16 
SYSSTUBS_ENTRY1  7, AccessCheckByTypeResultListAndAuditAlarmByHandle, 17 
SYSSTUBS_ENTRY2  7, AccessCheckByTypeResultListAndAuditAlarmByHandle, 17 
SYSSTUBS_ENTRY3  7, AccessCheckByTypeResultListAndAuditAlarmByHandle, 17 
SYSSTUBS_ENTRY4  7, AccessCheckByTypeResultListAndAuditAlarmByHandle, 17 
SYSSTUBS_ENTRY5  7, AccessCheckByTypeResultListAndAuditAlarmByHandle, 17 
SYSSTUBS_ENTRY6  7, AccessCheckByTypeResultListAndAuditAlarmByHandle, 17 
SYSSTUBS_ENTRY7  7, AccessCheckByTypeResultListAndAuditAlarmByHandle, 17 
SYSSTUBS_ENTRY8  7, AccessCheckByTypeResultListAndAuditAlarmByHandle, 17 
SYSSTUBS_ENTRY1  8, AddAtom, 3 
SYSSTUBS_ENTRY2  8, AddAtom, 3 
SYSSTUBS_ENTRY3  8, AddAtom, 3 
SYSSTUBS_ENTRY4  8, AddAtom, 3 
SYSSTUBS_ENTRY5  8, AddAtom, 3 
SYSSTUBS_ENTRY6  8, AddAtom, 3 
SYSSTUBS_ENTRY7  8, AddAtom, 3 
SYSSTUBS_ENTRY8  8, AddAtom, 3 
SYSSTUBS_ENTRY1  9, AddBootEntry, 2 
SYSSTUBS_ENTRY2  9, AddBootEntry, 2 
SYSSTUBS_ENTRY3  9, AddBootEntry, 2 
SYSSTUBS_ENTRY4  9, AddBootEntry, 2 
SYSSTUBS_ENTRY5  9, AddBootEntry, 2 
SYSSTUBS_ENTRY6  9, AddBootEntry, 2 
SYSSTUBS_ENTRY7  9, AddBootEntry, 2 
SYSSTUBS_ENTRY8  9, AddBootEntry, 2 
SYSSTUBS_ENTRY1  10, AddDriverEntry, 2 
SYSSTUBS_ENTRY2  10, AddDriverEntry, 2 
SYSSTUBS_ENTRY3  10, AddDriverEntry, 2 
SYSSTUBS_ENTRY4  10, AddDriverEntry, 2 
SYSSTUBS_ENTRY5  10, AddDriverEntry, 2 
SYSSTUBS_ENTRY6  10, AddDriverEntry, 2 
SYSSTUBS_ENTRY7  10, AddDriverEntry, 2 
SYSSTUBS_ENTRY8  10, AddDriverEntry, 2 
SYSSTUBS_ENTRY1  11, AdjustGroupsToken, 6 
SYSSTUBS_ENTRY2  11, AdjustGroupsToken, 6 
SYSSTUBS_ENTRY3  11, AdjustGroupsToken, 6 
SYSSTUBS_ENTRY4  11, AdjustGroupsToken, 6 
SYSSTUBS_ENTRY5  11, AdjustGroupsToken, 6 
SYSSTUBS_ENTRY6  11, AdjustGroupsToken, 6 
SYSSTUBS_ENTRY7  11, AdjustGroupsToken, 6 
SYSSTUBS_ENTRY8  11, AdjustGroupsToken, 6 
SYSSTUBS_ENTRY1  12, AdjustPrivilegesToken, 6 
SYSSTUBS_ENTRY2  12, AdjustPrivilegesToken, 6 
SYSSTUBS_ENTRY3  12, AdjustPrivilegesToken, 6 
SYSSTUBS_ENTRY4  12, AdjustPrivilegesToken, 6 
SYSSTUBS_ENTRY5  12, AdjustPrivilegesToken, 6 
SYSSTUBS_ENTRY6  12, AdjustPrivilegesToken, 6 
SYSSTUBS_ENTRY7  12, AdjustPrivilegesToken, 6 
SYSSTUBS_ENTRY8  12, AdjustPrivilegesToken, 6 
SYSSTUBS_ENTRY1  13, AlertResumeThread, 2 
SYSSTUBS_ENTRY2  13, AlertResumeThread, 2 
SYSSTUBS_ENTRY3  13, AlertResumeThread, 2 
SYSSTUBS_ENTRY4  13, AlertResumeThread, 2 
SYSSTUBS_ENTRY5  13, AlertResumeThread, 2 
SYSSTUBS_ENTRY6  13, AlertResumeThread, 2 
SYSSTUBS_ENTRY7  13, AlertResumeThread, 2 
SYSSTUBS_ENTRY8  13, AlertResumeThread, 2 
SYSSTUBS_ENTRY1  14, AlertThread, 1 
SYSSTUBS_ENTRY2  14, AlertThread, 1 
SYSSTUBS_ENTRY3  14, AlertThread, 1 
SYSSTUBS_ENTRY4  14, AlertThread, 1 
SYSSTUBS_ENTRY5  14, AlertThread, 1 
SYSSTUBS_ENTRY6  14, AlertThread, 1 
SYSSTUBS_ENTRY7  14, AlertThread, 1 
SYSSTUBS_ENTRY8  14, AlertThread, 1 
SYSSTUBS_ENTRY1  15, AllocateLocallyUniqueId, 1 
SYSSTUBS_ENTRY2  15, AllocateLocallyUniqueId, 1 
SYSSTUBS_ENTRY3  15, AllocateLocallyUniqueId, 1 
SYSSTUBS_ENTRY4  15, AllocateLocallyUniqueId, 1 
SYSSTUBS_ENTRY5  15, AllocateLocallyUniqueId, 1 
SYSSTUBS_ENTRY6  15, AllocateLocallyUniqueId, 1 
SYSSTUBS_ENTRY7  15, AllocateLocallyUniqueId, 1 
SYSSTUBS_ENTRY8  15, AllocateLocallyUniqueId, 1 
SYSSTUBS_ENTRY1  16, AllocateUserPhysicalPages, 3 
SYSSTUBS_ENTRY2  16, AllocateUserPhysicalPages, 3 
SYSSTUBS_ENTRY3  16, AllocateUserPhysicalPages, 3 
SYSSTUBS_ENTRY4  16, AllocateUserPhysicalPages, 3 
SYSSTUBS_ENTRY5  16, AllocateUserPhysicalPages, 3 
SYSSTUBS_ENTRY6  16, AllocateUserPhysicalPages, 3 
SYSSTUBS_ENTRY7  16, AllocateUserPhysicalPages, 3 
SYSSTUBS_ENTRY8  16, AllocateUserPhysicalPages, 3 
SYSSTUBS_ENTRY1  17, AllocateUuids, 4 
SYSSTUBS_ENTRY2  17, AllocateUuids, 4 
SYSSTUBS_ENTRY3  17, AllocateUuids, 4 
SYSSTUBS_ENTRY4  17, AllocateUuids, 4 
SYSSTUBS_ENTRY5  17, AllocateUuids, 4 
SYSSTUBS_ENTRY6  17, AllocateUuids, 4 
SYSSTUBS_ENTRY7  17, AllocateUuids, 4 
SYSSTUBS_ENTRY8  17, AllocateUuids, 4 
SYSSTUBS_ENTRY1  18, AllocateVirtualMemory, 6 
SYSSTUBS_ENTRY2  18, AllocateVirtualMemory, 6 
SYSSTUBS_ENTRY3  18, AllocateVirtualMemory, 6 
SYSSTUBS_ENTRY4  18, AllocateVirtualMemory, 6 
SYSSTUBS_ENTRY5  18, AllocateVirtualMemory, 6 
SYSSTUBS_ENTRY6  18, AllocateVirtualMemory, 6 
SYSSTUBS_ENTRY7  18, AllocateVirtualMemory, 6 
SYSSTUBS_ENTRY8  18, AllocateVirtualMemory, 6 
SYSSTUBS_ENTRY1  19, ApphelpCacheControl, 2 
SYSSTUBS_ENTRY2  19, ApphelpCacheControl, 2 
SYSSTUBS_ENTRY3  19, ApphelpCacheControl, 2 
SYSSTUBS_ENTRY4  19, ApphelpCacheControl, 2 
SYSSTUBS_ENTRY5  19, ApphelpCacheControl, 2 
SYSSTUBS_ENTRY6  19, ApphelpCacheControl, 2 
SYSSTUBS_ENTRY7  19, ApphelpCacheControl, 2 
SYSSTUBS_ENTRY8  19, ApphelpCacheControl, 2 
SYSSTUBS_ENTRY1  20, AreMappedFilesTheSame, 2 
SYSSTUBS_ENTRY2  20, AreMappedFilesTheSame, 2 
SYSSTUBS_ENTRY3  20, AreMappedFilesTheSame, 2 
SYSSTUBS_ENTRY4  20, AreMappedFilesTheSame, 2 
SYSSTUBS_ENTRY5  20, AreMappedFilesTheSame, 2 
SYSSTUBS_ENTRY6  20, AreMappedFilesTheSame, 2 
SYSSTUBS_ENTRY7  20, AreMappedFilesTheSame, 2 
SYSSTUBS_ENTRY8  20, AreMappedFilesTheSame, 2 
SYSSTUBS_ENTRY1  21, AssignProcessToJobObject, 2 
SYSSTUBS_ENTRY2  21, AssignProcessToJobObject, 2 
SYSSTUBS_ENTRY3  21, AssignProcessToJobObject, 2 
SYSSTUBS_ENTRY4  21, AssignProcessToJobObject, 2 
SYSSTUBS_ENTRY5  21, AssignProcessToJobObject, 2 
SYSSTUBS_ENTRY6  21, AssignProcessToJobObject, 2 
SYSSTUBS_ENTRY7  21, AssignProcessToJobObject, 2 
SYSSTUBS_ENTRY8  21, AssignProcessToJobObject, 2 
SYSSTUBS_ENTRY1  22, CallbackReturn, 3 
SYSSTUBS_ENTRY2  22, CallbackReturn, 3 
SYSSTUBS_ENTRY3  22, CallbackReturn, 3 
SYSSTUBS_ENTRY4  22, CallbackReturn, 3 
SYSSTUBS_ENTRY5  22, CallbackReturn, 3 
SYSSTUBS_ENTRY6  22, CallbackReturn, 3 
SYSSTUBS_ENTRY7  22, CallbackReturn, 3 
SYSSTUBS_ENTRY8  22, CallbackReturn, 3 
SYSSTUBS_ENTRY1  23, CancelDeviceWakeupRequest, 1 
SYSSTUBS_ENTRY2  23, CancelDeviceWakeupRequest, 1 
SYSSTUBS_ENTRY3  23, CancelDeviceWakeupRequest, 1 
SYSSTUBS_ENTRY4  23, CancelDeviceWakeupRequest, 1 
SYSSTUBS_ENTRY5  23, CancelDeviceWakeupRequest, 1 
SYSSTUBS_ENTRY6  23, CancelDeviceWakeupRequest, 1 
SYSSTUBS_ENTRY7  23, CancelDeviceWakeupRequest, 1 
SYSSTUBS_ENTRY8  23, CancelDeviceWakeupRequest, 1 
SYSSTUBS_ENTRY1  24, CancelIoFile, 2 
SYSSTUBS_ENTRY2  24, CancelIoFile, 2 
SYSSTUBS_ENTRY3  24, CancelIoFile, 2 
SYSSTUBS_ENTRY4  24, CancelIoFile, 2 
SYSSTUBS_ENTRY5  24, CancelIoFile, 2 
SYSSTUBS_ENTRY6  24, CancelIoFile, 2 
SYSSTUBS_ENTRY7  24, CancelIoFile, 2 
SYSSTUBS_ENTRY8  24, CancelIoFile, 2 
SYSSTUBS_ENTRY1  25, CancelTimer, 2 
SYSSTUBS_ENTRY2  25, CancelTimer, 2 
SYSSTUBS_ENTRY3  25, CancelTimer, 2 
SYSSTUBS_ENTRY4  25, CancelTimer, 2 
SYSSTUBS_ENTRY5  25, CancelTimer, 2 
SYSSTUBS_ENTRY6  25, CancelTimer, 2 
SYSSTUBS_ENTRY7  25, CancelTimer, 2 
SYSSTUBS_ENTRY8  25, CancelTimer, 2 
SYSSTUBS_ENTRY1  26, ClearEvent, 1 
SYSSTUBS_ENTRY2  26, ClearEvent, 1 
SYSSTUBS_ENTRY3  26, ClearEvent, 1 
SYSSTUBS_ENTRY4  26, ClearEvent, 1 
SYSSTUBS_ENTRY5  26, ClearEvent, 1 
SYSSTUBS_ENTRY6  26, ClearEvent, 1 
SYSSTUBS_ENTRY7  26, ClearEvent, 1 
SYSSTUBS_ENTRY8  26, ClearEvent, 1 
SYSSTUBS_ENTRY1  27, Close, 1 
SYSSTUBS_ENTRY2  27, Close, 1 
SYSSTUBS_ENTRY3  27, Close, 1 
SYSSTUBS_ENTRY4  27, Close, 1 
SYSSTUBS_ENTRY5  27, Close, 1 
SYSSTUBS_ENTRY6  27, Close, 1 
SYSSTUBS_ENTRY7  27, Close, 1 
SYSSTUBS_ENTRY8  27, Close, 1 
SYSSTUBS_ENTRY1  28, CloseObjectAuditAlarm, 3 
SYSSTUBS_ENTRY2  28, CloseObjectAuditAlarm, 3 
SYSSTUBS_ENTRY3  28, CloseObjectAuditAlarm, 3 
SYSSTUBS_ENTRY4  28, CloseObjectAuditAlarm, 3 
SYSSTUBS_ENTRY5  28, CloseObjectAuditAlarm, 3 
SYSSTUBS_ENTRY6  28, CloseObjectAuditAlarm, 3 
SYSSTUBS_ENTRY7  28, CloseObjectAuditAlarm, 3 
SYSSTUBS_ENTRY8  28, CloseObjectAuditAlarm, 3 
SYSSTUBS_ENTRY1  29, CompactKeys, 2 
SYSSTUBS_ENTRY2  29, CompactKeys, 2 
SYSSTUBS_ENTRY3  29, CompactKeys, 2 
SYSSTUBS_ENTRY4  29, CompactKeys, 2 
SYSSTUBS_ENTRY5  29, CompactKeys, 2 
SYSSTUBS_ENTRY6  29, CompactKeys, 2 
SYSSTUBS_ENTRY7  29, CompactKeys, 2 
SYSSTUBS_ENTRY8  29, CompactKeys, 2 
SYSSTUBS_ENTRY1  30, CompareTokens, 3 
SYSSTUBS_ENTRY2  30, CompareTokens, 3 
SYSSTUBS_ENTRY3  30, CompareTokens, 3 
SYSSTUBS_ENTRY4  30, CompareTokens, 3 
SYSSTUBS_ENTRY5  30, CompareTokens, 3 
SYSSTUBS_ENTRY6  30, CompareTokens, 3 
SYSSTUBS_ENTRY7  30, CompareTokens, 3 
SYSSTUBS_ENTRY8  30, CompareTokens, 3 
SYSSTUBS_ENTRY1  31, CompleteConnectPort, 1 
SYSSTUBS_ENTRY2  31, CompleteConnectPort, 1 
SYSSTUBS_ENTRY3  31, CompleteConnectPort, 1 
SYSSTUBS_ENTRY4  31, CompleteConnectPort, 1 
SYSSTUBS_ENTRY5  31, CompleteConnectPort, 1 
SYSSTUBS_ENTRY6  31, CompleteConnectPort, 1 
SYSSTUBS_ENTRY7  31, CompleteConnectPort, 1 
SYSSTUBS_ENTRY8  31, CompleteConnectPort, 1 
SYSSTUBS_ENTRY1  32, CompressKey, 1 
SYSSTUBS_ENTRY2  32, CompressKey, 1 
SYSSTUBS_ENTRY3  32, CompressKey, 1 
SYSSTUBS_ENTRY4  32, CompressKey, 1 
SYSSTUBS_ENTRY5  32, CompressKey, 1 
SYSSTUBS_ENTRY6  32, CompressKey, 1 
SYSSTUBS_ENTRY7  32, CompressKey, 1 
SYSSTUBS_ENTRY8  32, CompressKey, 1 
SYSSTUBS_ENTRY1  33, ConnectPort, 8 
SYSSTUBS_ENTRY2  33, ConnectPort, 8 
SYSSTUBS_ENTRY3  33, ConnectPort, 8 
SYSSTUBS_ENTRY4  33, ConnectPort, 8 
SYSSTUBS_ENTRY5  33, ConnectPort, 8 
SYSSTUBS_ENTRY6  33, ConnectPort, 8 
SYSSTUBS_ENTRY7  33, ConnectPort, 8 
SYSSTUBS_ENTRY8  33, ConnectPort, 8 
SYSSTUBS_ENTRY1  34, Continue, 2 
SYSSTUBS_ENTRY2  34, Continue, 2 
SYSSTUBS_ENTRY3  34, Continue, 2 
SYSSTUBS_ENTRY4  34, Continue, 2 
SYSSTUBS_ENTRY5  34, Continue, 2 
SYSSTUBS_ENTRY6  34, Continue, 2 
SYSSTUBS_ENTRY7  34, Continue, 2 
SYSSTUBS_ENTRY8  34, Continue, 2 
SYSSTUBS_ENTRY1  35, CreateDebugObject, 4 
SYSSTUBS_ENTRY2  35, CreateDebugObject, 4 
SYSSTUBS_ENTRY3  35, CreateDebugObject, 4 
SYSSTUBS_ENTRY4  35, CreateDebugObject, 4 
SYSSTUBS_ENTRY5  35, CreateDebugObject, 4 
SYSSTUBS_ENTRY6  35, CreateDebugObject, 4 
SYSSTUBS_ENTRY7  35, CreateDebugObject, 4 
SYSSTUBS_ENTRY8  35, CreateDebugObject, 4 
SYSSTUBS_ENTRY1  36, CreateDirectoryObject, 3 
SYSSTUBS_ENTRY2  36, CreateDirectoryObject, 3 
SYSSTUBS_ENTRY3  36, CreateDirectoryObject, 3 
SYSSTUBS_ENTRY4  36, CreateDirectoryObject, 3 
SYSSTUBS_ENTRY5  36, CreateDirectoryObject, 3 
SYSSTUBS_ENTRY6  36, CreateDirectoryObject, 3 
SYSSTUBS_ENTRY7  36, CreateDirectoryObject, 3 
SYSSTUBS_ENTRY8  36, CreateDirectoryObject, 3 
SYSSTUBS_ENTRY1  37, CreateEvent, 5 
SYSSTUBS_ENTRY2  37, CreateEvent, 5 
SYSSTUBS_ENTRY3  37, CreateEvent, 5 
SYSSTUBS_ENTRY4  37, CreateEvent, 5 
SYSSTUBS_ENTRY5  37, CreateEvent, 5 
SYSSTUBS_ENTRY6  37, CreateEvent, 5 
SYSSTUBS_ENTRY7  37, CreateEvent, 5 
SYSSTUBS_ENTRY8  37, CreateEvent, 5 
SYSSTUBS_ENTRY1  38, CreateEventPair, 3 
SYSSTUBS_ENTRY2  38, CreateEventPair, 3 
SYSSTUBS_ENTRY3  38, CreateEventPair, 3 
SYSSTUBS_ENTRY4  38, CreateEventPair, 3 
SYSSTUBS_ENTRY5  38, CreateEventPair, 3 
SYSSTUBS_ENTRY6  38, CreateEventPair, 3 
SYSSTUBS_ENTRY7  38, CreateEventPair, 3 
SYSSTUBS_ENTRY8  38, CreateEventPair, 3 
SYSSTUBS_ENTRY1  39, CreateFile, 11 
SYSSTUBS_ENTRY2  39, CreateFile, 11 
SYSSTUBS_ENTRY3  39, CreateFile, 11 
SYSSTUBS_ENTRY4  39, CreateFile, 11 
SYSSTUBS_ENTRY5  39, CreateFile, 11 
SYSSTUBS_ENTRY6  39, CreateFile, 11 
SYSSTUBS_ENTRY7  39, CreateFile, 11 
SYSSTUBS_ENTRY8  39, CreateFile, 11 
SYSSTUBS_ENTRY1  40, CreateIoCompletion, 4 
SYSSTUBS_ENTRY2  40, CreateIoCompletion, 4 
SYSSTUBS_ENTRY3  40, CreateIoCompletion, 4 
SYSSTUBS_ENTRY4  40, CreateIoCompletion, 4 
SYSSTUBS_ENTRY5  40, CreateIoCompletion, 4 
SYSSTUBS_ENTRY6  40, CreateIoCompletion, 4 
SYSSTUBS_ENTRY7  40, CreateIoCompletion, 4 
SYSSTUBS_ENTRY8  40, CreateIoCompletion, 4 
SYSSTUBS_ENTRY1  41, CreateJobObject, 3 
SYSSTUBS_ENTRY2  41, CreateJobObject, 3 
SYSSTUBS_ENTRY3  41, CreateJobObject, 3 
SYSSTUBS_ENTRY4  41, CreateJobObject, 3 
SYSSTUBS_ENTRY5  41, CreateJobObject, 3 
SYSSTUBS_ENTRY6  41, CreateJobObject, 3 
SYSSTUBS_ENTRY7  41, CreateJobObject, 3 
SYSSTUBS_ENTRY8  41, CreateJobObject, 3 
SYSSTUBS_ENTRY1  42, CreateJobSet, 3 
SYSSTUBS_ENTRY2  42, CreateJobSet, 3 
SYSSTUBS_ENTRY3  42, CreateJobSet, 3 
SYSSTUBS_ENTRY4  42, CreateJobSet, 3 
SYSSTUBS_ENTRY5  42, CreateJobSet, 3 
SYSSTUBS_ENTRY6  42, CreateJobSet, 3 
SYSSTUBS_ENTRY7  42, CreateJobSet, 3 
SYSSTUBS_ENTRY8  42, CreateJobSet, 3 
SYSSTUBS_ENTRY1  43, CreateKey, 7 
SYSSTUBS_ENTRY2  43, CreateKey, 7 
SYSSTUBS_ENTRY3  43, CreateKey, 7 
SYSSTUBS_ENTRY4  43, CreateKey, 7 
SYSSTUBS_ENTRY5  43, CreateKey, 7 
SYSSTUBS_ENTRY6  43, CreateKey, 7 
SYSSTUBS_ENTRY7  43, CreateKey, 7 
SYSSTUBS_ENTRY8  43, CreateKey, 7 
SYSSTUBS_ENTRY1  44, CreateMailslotFile, 8 
SYSSTUBS_ENTRY2  44, CreateMailslotFile, 8 
SYSSTUBS_ENTRY3  44, CreateMailslotFile, 8 
SYSSTUBS_ENTRY4  44, CreateMailslotFile, 8 
SYSSTUBS_ENTRY5  44, CreateMailslotFile, 8 
SYSSTUBS_ENTRY6  44, CreateMailslotFile, 8 
SYSSTUBS_ENTRY7  44, CreateMailslotFile, 8 
SYSSTUBS_ENTRY8  44, CreateMailslotFile, 8 
SYSSTUBS_ENTRY1  45, CreateMutant, 4 
SYSSTUBS_ENTRY2  45, CreateMutant, 4 
SYSSTUBS_ENTRY3  45, CreateMutant, 4 
SYSSTUBS_ENTRY4  45, CreateMutant, 4 
SYSSTUBS_ENTRY5  45, CreateMutant, 4 
SYSSTUBS_ENTRY6  45, CreateMutant, 4 
SYSSTUBS_ENTRY7  45, CreateMutant, 4 
SYSSTUBS_ENTRY8  45, CreateMutant, 4 
SYSSTUBS_ENTRY1  46, CreateNamedPipeFile, 14 
SYSSTUBS_ENTRY2  46, CreateNamedPipeFile, 14 
SYSSTUBS_ENTRY3  46, CreateNamedPipeFile, 14 
SYSSTUBS_ENTRY4  46, CreateNamedPipeFile, 14 
SYSSTUBS_ENTRY5  46, CreateNamedPipeFile, 14 
SYSSTUBS_ENTRY6  46, CreateNamedPipeFile, 14 
SYSSTUBS_ENTRY7  46, CreateNamedPipeFile, 14 
SYSSTUBS_ENTRY8  46, CreateNamedPipeFile, 14 
SYSSTUBS_ENTRY1  47, CreatePagingFile, 4 
SYSSTUBS_ENTRY2  47, CreatePagingFile, 4 
SYSSTUBS_ENTRY3  47, CreatePagingFile, 4 
SYSSTUBS_ENTRY4  47, CreatePagingFile, 4 
SYSSTUBS_ENTRY5  47, CreatePagingFile, 4 
SYSSTUBS_ENTRY6  47, CreatePagingFile, 4 
SYSSTUBS_ENTRY7  47, CreatePagingFile, 4 
SYSSTUBS_ENTRY8  47, CreatePagingFile, 4 
SYSSTUBS_ENTRY1  48, CreatePort, 5 
SYSSTUBS_ENTRY2  48, CreatePort, 5 
SYSSTUBS_ENTRY3  48, CreatePort, 5 
SYSSTUBS_ENTRY4  48, CreatePort, 5 
SYSSTUBS_ENTRY5  48, CreatePort, 5 
SYSSTUBS_ENTRY6  48, CreatePort, 5 
SYSSTUBS_ENTRY7  48, CreatePort, 5 
SYSSTUBS_ENTRY8  48, CreatePort, 5 
SYSSTUBS_ENTRY1  49, CreateProcess, 8 
SYSSTUBS_ENTRY2  49, CreateProcess, 8 
SYSSTUBS_ENTRY3  49, CreateProcess, 8 
SYSSTUBS_ENTRY4  49, CreateProcess, 8 
SYSSTUBS_ENTRY5  49, CreateProcess, 8 
SYSSTUBS_ENTRY6  49, CreateProcess, 8 
SYSSTUBS_ENTRY7  49, CreateProcess, 8 
SYSSTUBS_ENTRY8  49, CreateProcess, 8 
SYSSTUBS_ENTRY1  50, CreateProcessEx, 9 
SYSSTUBS_ENTRY2  50, CreateProcessEx, 9 
SYSSTUBS_ENTRY3  50, CreateProcessEx, 9 
SYSSTUBS_ENTRY4  50, CreateProcessEx, 9 
SYSSTUBS_ENTRY5  50, CreateProcessEx, 9 
SYSSTUBS_ENTRY6  50, CreateProcessEx, 9 
SYSSTUBS_ENTRY7  50, CreateProcessEx, 9 
SYSSTUBS_ENTRY8  50, CreateProcessEx, 9 
SYSSTUBS_ENTRY1  51, CreateProfile, 9 
SYSSTUBS_ENTRY2  51, CreateProfile, 9 
SYSSTUBS_ENTRY3  51, CreateProfile, 9 
SYSSTUBS_ENTRY4  51, CreateProfile, 9 
SYSSTUBS_ENTRY5  51, CreateProfile, 9 
SYSSTUBS_ENTRY6  51, CreateProfile, 9 
SYSSTUBS_ENTRY7  51, CreateProfile, 9 
SYSSTUBS_ENTRY8  51, CreateProfile, 9 
SYSSTUBS_ENTRY1  52, CreateSection, 7 
SYSSTUBS_ENTRY2  52, CreateSection, 7 
SYSSTUBS_ENTRY3  52, CreateSection, 7 
SYSSTUBS_ENTRY4  52, CreateSection, 7 
SYSSTUBS_ENTRY5  52, CreateSection, 7 
SYSSTUBS_ENTRY6  52, CreateSection, 7 
SYSSTUBS_ENTRY7  52, CreateSection, 7 
SYSSTUBS_ENTRY8  52, CreateSection, 7 
SYSSTUBS_ENTRY1  53, CreateSemaphore, 5 
SYSSTUBS_ENTRY2  53, CreateSemaphore, 5 
SYSSTUBS_ENTRY3  53, CreateSemaphore, 5 
SYSSTUBS_ENTRY4  53, CreateSemaphore, 5 
SYSSTUBS_ENTRY5  53, CreateSemaphore, 5 
SYSSTUBS_ENTRY6  53, CreateSemaphore, 5 
SYSSTUBS_ENTRY7  53, CreateSemaphore, 5 
SYSSTUBS_ENTRY8  53, CreateSemaphore, 5 
SYSSTUBS_ENTRY1  54, CreateSymbolicLinkObject, 4 
SYSSTUBS_ENTRY2  54, CreateSymbolicLinkObject, 4 
SYSSTUBS_ENTRY3  54, CreateSymbolicLinkObject, 4 
SYSSTUBS_ENTRY4  54, CreateSymbolicLinkObject, 4 
SYSSTUBS_ENTRY5  54, CreateSymbolicLinkObject, 4 
SYSSTUBS_ENTRY6  54, CreateSymbolicLinkObject, 4 
SYSSTUBS_ENTRY7  54, CreateSymbolicLinkObject, 4 
SYSSTUBS_ENTRY8  54, CreateSymbolicLinkObject, 4 
SYSSTUBS_ENTRY1  55, CreateThread, 8 
SYSSTUBS_ENTRY2  55, CreateThread, 8 
SYSSTUBS_ENTRY3  55, CreateThread, 8 
SYSSTUBS_ENTRY4  55, CreateThread, 8 
SYSSTUBS_ENTRY5  55, CreateThread, 8 
SYSSTUBS_ENTRY6  55, CreateThread, 8 
SYSSTUBS_ENTRY7  55, CreateThread, 8 
SYSSTUBS_ENTRY8  55, CreateThread, 8 
SYSSTUBS_ENTRY1  56, CreateTimer, 4 
SYSSTUBS_ENTRY2  56, CreateTimer, 4 
SYSSTUBS_ENTRY3  56, CreateTimer, 4 
SYSSTUBS_ENTRY4  56, CreateTimer, 4 
SYSSTUBS_ENTRY5  56, CreateTimer, 4 
SYSSTUBS_ENTRY6  56, CreateTimer, 4 
SYSSTUBS_ENTRY7  56, CreateTimer, 4 
SYSSTUBS_ENTRY8  56, CreateTimer, 4 
SYSSTUBS_ENTRY1  57, CreateToken, 13 
SYSSTUBS_ENTRY2  57, CreateToken, 13 
SYSSTUBS_ENTRY3  57, CreateToken, 13 
SYSSTUBS_ENTRY4  57, CreateToken, 13 
SYSSTUBS_ENTRY5  57, CreateToken, 13 
SYSSTUBS_ENTRY6  57, CreateToken, 13 
SYSSTUBS_ENTRY7  57, CreateToken, 13 
SYSSTUBS_ENTRY8  57, CreateToken, 13 
SYSSTUBS_ENTRY1  58, CreateWaitablePort, 5 
SYSSTUBS_ENTRY2  58, CreateWaitablePort, 5 
SYSSTUBS_ENTRY3  58, CreateWaitablePort, 5 
SYSSTUBS_ENTRY4  58, CreateWaitablePort, 5 
SYSSTUBS_ENTRY5  58, CreateWaitablePort, 5 
SYSSTUBS_ENTRY6  58, CreateWaitablePort, 5 
SYSSTUBS_ENTRY7  58, CreateWaitablePort, 5 
SYSSTUBS_ENTRY8  58, CreateWaitablePort, 5 
SYSSTUBS_ENTRY1  59, DebugActiveProcess, 2 
SYSSTUBS_ENTRY2  59, DebugActiveProcess, 2 
SYSSTUBS_ENTRY3  59, DebugActiveProcess, 2 
SYSSTUBS_ENTRY4  59, DebugActiveProcess, 2 
SYSSTUBS_ENTRY5  59, DebugActiveProcess, 2 
SYSSTUBS_ENTRY6  59, DebugActiveProcess, 2 
SYSSTUBS_ENTRY7  59, DebugActiveProcess, 2 
SYSSTUBS_ENTRY8  59, DebugActiveProcess, 2 
SYSSTUBS_ENTRY1  60, DebugContinue, 3 
SYSSTUBS_ENTRY2  60, DebugContinue, 3 
SYSSTUBS_ENTRY3  60, DebugContinue, 3 
SYSSTUBS_ENTRY4  60, DebugContinue, 3 
SYSSTUBS_ENTRY5  60, DebugContinue, 3 
SYSSTUBS_ENTRY6  60, DebugContinue, 3 
SYSSTUBS_ENTRY7  60, DebugContinue, 3 
SYSSTUBS_ENTRY8  60, DebugContinue, 3 
SYSSTUBS_ENTRY1  61, DelayExecution, 2 
SYSSTUBS_ENTRY2  61, DelayExecution, 2 
SYSSTUBS_ENTRY3  61, DelayExecution, 2 
SYSSTUBS_ENTRY4  61, DelayExecution, 2 
SYSSTUBS_ENTRY5  61, DelayExecution, 2 
SYSSTUBS_ENTRY6  61, DelayExecution, 2 
SYSSTUBS_ENTRY7  61, DelayExecution, 2 
SYSSTUBS_ENTRY8  61, DelayExecution, 2 
SYSSTUBS_ENTRY1  62, DeleteAtom, 1 
SYSSTUBS_ENTRY2  62, DeleteAtom, 1 
SYSSTUBS_ENTRY3  62, DeleteAtom, 1 
SYSSTUBS_ENTRY4  62, DeleteAtom, 1 
SYSSTUBS_ENTRY5  62, DeleteAtom, 1 
SYSSTUBS_ENTRY6  62, DeleteAtom, 1 
SYSSTUBS_ENTRY7  62, DeleteAtom, 1 
SYSSTUBS_ENTRY8  62, DeleteAtom, 1 
SYSSTUBS_ENTRY1  63, DeleteBootEntry, 1 
SYSSTUBS_ENTRY2  63, DeleteBootEntry, 1 
SYSSTUBS_ENTRY3  63, DeleteBootEntry, 1 
SYSSTUBS_ENTRY4  63, DeleteBootEntry, 1 
SYSSTUBS_ENTRY5  63, DeleteBootEntry, 1 
SYSSTUBS_ENTRY6  63, DeleteBootEntry, 1 
SYSSTUBS_ENTRY7  63, DeleteBootEntry, 1 
SYSSTUBS_ENTRY8  63, DeleteBootEntry, 1 
SYSSTUBS_ENTRY1  64, DeleteDriverEntry, 1 
SYSSTUBS_ENTRY2  64, DeleteDriverEntry, 1 
SYSSTUBS_ENTRY3  64, DeleteDriverEntry, 1 
SYSSTUBS_ENTRY4  64, DeleteDriverEntry, 1 
SYSSTUBS_ENTRY5  64, DeleteDriverEntry, 1 
SYSSTUBS_ENTRY6  64, DeleteDriverEntry, 1 
SYSSTUBS_ENTRY7  64, DeleteDriverEntry, 1 
SYSSTUBS_ENTRY8  64, DeleteDriverEntry, 1 
SYSSTUBS_ENTRY1  65, DeleteFile, 1 
SYSSTUBS_ENTRY2  65, DeleteFile, 1 
SYSSTUBS_ENTRY3  65, DeleteFile, 1 
SYSSTUBS_ENTRY4  65, DeleteFile, 1 
SYSSTUBS_ENTRY5  65, DeleteFile, 1 
SYSSTUBS_ENTRY6  65, DeleteFile, 1 
SYSSTUBS_ENTRY7  65, DeleteFile, 1 
SYSSTUBS_ENTRY8  65, DeleteFile, 1 
SYSSTUBS_ENTRY1  66, DeleteKey, 1 
SYSSTUBS_ENTRY2  66, DeleteKey, 1 
SYSSTUBS_ENTRY3  66, DeleteKey, 1 
SYSSTUBS_ENTRY4  66, DeleteKey, 1 
SYSSTUBS_ENTRY5  66, DeleteKey, 1 
SYSSTUBS_ENTRY6  66, DeleteKey, 1 
SYSSTUBS_ENTRY7  66, DeleteKey, 1 
SYSSTUBS_ENTRY8  66, DeleteKey, 1 
SYSSTUBS_ENTRY1  67, DeleteObjectAuditAlarm, 3 
SYSSTUBS_ENTRY2  67, DeleteObjectAuditAlarm, 3 
SYSSTUBS_ENTRY3  67, DeleteObjectAuditAlarm, 3 
SYSSTUBS_ENTRY4  67, DeleteObjectAuditAlarm, 3 
SYSSTUBS_ENTRY5  67, DeleteObjectAuditAlarm, 3 
SYSSTUBS_ENTRY6  67, DeleteObjectAuditAlarm, 3 
SYSSTUBS_ENTRY7  67, DeleteObjectAuditAlarm, 3 
SYSSTUBS_ENTRY8  67, DeleteObjectAuditAlarm, 3 
SYSSTUBS_ENTRY1  68, DeleteValueKey, 2 
SYSSTUBS_ENTRY2  68, DeleteValueKey, 2 
SYSSTUBS_ENTRY3  68, DeleteValueKey, 2 
SYSSTUBS_ENTRY4  68, DeleteValueKey, 2 
SYSSTUBS_ENTRY5  68, DeleteValueKey, 2 
SYSSTUBS_ENTRY6  68, DeleteValueKey, 2 
SYSSTUBS_ENTRY7  68, DeleteValueKey, 2 
SYSSTUBS_ENTRY8  68, DeleteValueKey, 2 
SYSSTUBS_ENTRY1  69, DeviceIoControlFile, 10 
SYSSTUBS_ENTRY2  69, DeviceIoControlFile, 10 
SYSSTUBS_ENTRY3  69, DeviceIoControlFile, 10 
SYSSTUBS_ENTRY4  69, DeviceIoControlFile, 10 
SYSSTUBS_ENTRY5  69, DeviceIoControlFile, 10 
SYSSTUBS_ENTRY6  69, DeviceIoControlFile, 10 
SYSSTUBS_ENTRY7  69, DeviceIoControlFile, 10 
SYSSTUBS_ENTRY8  69, DeviceIoControlFile, 10 
SYSSTUBS_ENTRY1  70, DisplayString, 1 
SYSSTUBS_ENTRY2  70, DisplayString, 1 
SYSSTUBS_ENTRY3  70, DisplayString, 1 
SYSSTUBS_ENTRY4  70, DisplayString, 1 
SYSSTUBS_ENTRY5  70, DisplayString, 1 
SYSSTUBS_ENTRY6  70, DisplayString, 1 
SYSSTUBS_ENTRY7  70, DisplayString, 1 
SYSSTUBS_ENTRY8  70, DisplayString, 1 
SYSSTUBS_ENTRY1  71, DuplicateObject, 7 
SYSSTUBS_ENTRY2  71, DuplicateObject, 7 
SYSSTUBS_ENTRY3  71, DuplicateObject, 7 
SYSSTUBS_ENTRY4  71, DuplicateObject, 7 
SYSSTUBS_ENTRY5  71, DuplicateObject, 7 
SYSSTUBS_ENTRY6  71, DuplicateObject, 7 
SYSSTUBS_ENTRY7  71, DuplicateObject, 7 
SYSSTUBS_ENTRY8  71, DuplicateObject, 7 
SYSSTUBS_ENTRY1  72, DuplicateToken, 6 
SYSSTUBS_ENTRY2  72, DuplicateToken, 6 
SYSSTUBS_ENTRY3  72, DuplicateToken, 6 
SYSSTUBS_ENTRY4  72, DuplicateToken, 6 
SYSSTUBS_ENTRY5  72, DuplicateToken, 6 
SYSSTUBS_ENTRY6  72, DuplicateToken, 6 
SYSSTUBS_ENTRY7  72, DuplicateToken, 6 
SYSSTUBS_ENTRY8  72, DuplicateToken, 6 
SYSSTUBS_ENTRY1  73, EnumerateBootEntries, 2 
SYSSTUBS_ENTRY2  73, EnumerateBootEntries, 2 
SYSSTUBS_ENTRY3  73, EnumerateBootEntries, 2 
SYSSTUBS_ENTRY4  73, EnumerateBootEntries, 2 
SYSSTUBS_ENTRY5  73, EnumerateBootEntries, 2 
SYSSTUBS_ENTRY6  73, EnumerateBootEntries, 2 
SYSSTUBS_ENTRY7  73, EnumerateBootEntries, 2 
SYSSTUBS_ENTRY8  73, EnumerateBootEntries, 2 
SYSSTUBS_ENTRY1  74, EnumerateDriverEntries, 2 
SYSSTUBS_ENTRY2  74, EnumerateDriverEntries, 2 
SYSSTUBS_ENTRY3  74, EnumerateDriverEntries, 2 
SYSSTUBS_ENTRY4  74, EnumerateDriverEntries, 2 
SYSSTUBS_ENTRY5  74, EnumerateDriverEntries, 2 
SYSSTUBS_ENTRY6  74, EnumerateDriverEntries, 2 
SYSSTUBS_ENTRY7  74, EnumerateDriverEntries, 2 
SYSSTUBS_ENTRY8  74, EnumerateDriverEntries, 2 
SYSSTUBS_ENTRY1  75, EnumerateKey, 6 
SYSSTUBS_ENTRY2  75, EnumerateKey, 6 
SYSSTUBS_ENTRY3  75, EnumerateKey, 6 
SYSSTUBS_ENTRY4  75, EnumerateKey, 6 
SYSSTUBS_ENTRY5  75, EnumerateKey, 6 
SYSSTUBS_ENTRY6  75, EnumerateKey, 6 
SYSSTUBS_ENTRY7  75, EnumerateKey, 6 
SYSSTUBS_ENTRY8  75, EnumerateKey, 6 
SYSSTUBS_ENTRY1  76, EnumerateSystemEnvironmentValuesEx, 3 
SYSSTUBS_ENTRY2  76, EnumerateSystemEnvironmentValuesEx, 3 
SYSSTUBS_ENTRY3  76, EnumerateSystemEnvironmentValuesEx, 3 
SYSSTUBS_ENTRY4  76, EnumerateSystemEnvironmentValuesEx, 3 
SYSSTUBS_ENTRY5  76, EnumerateSystemEnvironmentValuesEx, 3 
SYSSTUBS_ENTRY6  76, EnumerateSystemEnvironmentValuesEx, 3 
SYSSTUBS_ENTRY7  76, EnumerateSystemEnvironmentValuesEx, 3 
SYSSTUBS_ENTRY8  76, EnumerateSystemEnvironmentValuesEx, 3 
SYSSTUBS_ENTRY1  77, EnumerateValueKey, 6 
SYSSTUBS_ENTRY2  77, EnumerateValueKey, 6 
SYSSTUBS_ENTRY3  77, EnumerateValueKey, 6 
SYSSTUBS_ENTRY4  77, EnumerateValueKey, 6 
SYSSTUBS_ENTRY5  77, EnumerateValueKey, 6 
SYSSTUBS_ENTRY6  77, EnumerateValueKey, 6 
SYSSTUBS_ENTRY7  77, EnumerateValueKey, 6 
SYSSTUBS_ENTRY8  77, EnumerateValueKey, 6 
SYSSTUBS_ENTRY1  78, ExtendSection, 2 
SYSSTUBS_ENTRY2  78, ExtendSection, 2 
SYSSTUBS_ENTRY3  78, ExtendSection, 2 
SYSSTUBS_ENTRY4  78, ExtendSection, 2 
SYSSTUBS_ENTRY5  78, ExtendSection, 2 
SYSSTUBS_ENTRY6  78, ExtendSection, 2 
SYSSTUBS_ENTRY7  78, ExtendSection, 2 
SYSSTUBS_ENTRY8  78, ExtendSection, 2 
SYSSTUBS_ENTRY1  79, FilterToken, 6 
SYSSTUBS_ENTRY2  79, FilterToken, 6 
SYSSTUBS_ENTRY3  79, FilterToken, 6 
SYSSTUBS_ENTRY4  79, FilterToken, 6 
SYSSTUBS_ENTRY5  79, FilterToken, 6 
SYSSTUBS_ENTRY6  79, FilterToken, 6 
SYSSTUBS_ENTRY7  79, FilterToken, 6 
SYSSTUBS_ENTRY8  79, FilterToken, 6 
SYSSTUBS_ENTRY1  80, FindAtom, 3 
SYSSTUBS_ENTRY2  80, FindAtom, 3 
SYSSTUBS_ENTRY3  80, FindAtom, 3 
SYSSTUBS_ENTRY4  80, FindAtom, 3 
SYSSTUBS_ENTRY5  80, FindAtom, 3 
SYSSTUBS_ENTRY6  80, FindAtom, 3 
SYSSTUBS_ENTRY7  80, FindAtom, 3 
SYSSTUBS_ENTRY8  80, FindAtom, 3 
SYSSTUBS_ENTRY1  81, FlushBuffersFile, 2 
SYSSTUBS_ENTRY2  81, FlushBuffersFile, 2 
SYSSTUBS_ENTRY3  81, FlushBuffersFile, 2 
SYSSTUBS_ENTRY4  81, FlushBuffersFile, 2 
SYSSTUBS_ENTRY5  81, FlushBuffersFile, 2 
SYSSTUBS_ENTRY6  81, FlushBuffersFile, 2 
SYSSTUBS_ENTRY7  81, FlushBuffersFile, 2 
SYSSTUBS_ENTRY8  81, FlushBuffersFile, 2 
SYSSTUBS_ENTRY1  82, FlushInstructionCache, 3 
SYSSTUBS_ENTRY2  82, FlushInstructionCache, 3 
SYSSTUBS_ENTRY3  82, FlushInstructionCache, 3 
SYSSTUBS_ENTRY4  82, FlushInstructionCache, 3 
SYSSTUBS_ENTRY5  82, FlushInstructionCache, 3 
SYSSTUBS_ENTRY6  82, FlushInstructionCache, 3 
SYSSTUBS_ENTRY7  82, FlushInstructionCache, 3 
SYSSTUBS_ENTRY8  82, FlushInstructionCache, 3 
SYSSTUBS_ENTRY1  83, FlushKey, 1 
SYSSTUBS_ENTRY2  83, FlushKey, 1 
SYSSTUBS_ENTRY3  83, FlushKey, 1 
SYSSTUBS_ENTRY4  83, FlushKey, 1 
SYSSTUBS_ENTRY5  83, FlushKey, 1 
SYSSTUBS_ENTRY6  83, FlushKey, 1 
SYSSTUBS_ENTRY7  83, FlushKey, 1 
SYSSTUBS_ENTRY8  83, FlushKey, 1 
SYSSTUBS_ENTRY1  84, FlushVirtualMemory, 4 
SYSSTUBS_ENTRY2  84, FlushVirtualMemory, 4 
SYSSTUBS_ENTRY3  84, FlushVirtualMemory, 4 
SYSSTUBS_ENTRY4  84, FlushVirtualMemory, 4 
SYSSTUBS_ENTRY5  84, FlushVirtualMemory, 4 
SYSSTUBS_ENTRY6  84, FlushVirtualMemory, 4 
SYSSTUBS_ENTRY7  84, FlushVirtualMemory, 4 
SYSSTUBS_ENTRY8  84, FlushVirtualMemory, 4 
SYSSTUBS_ENTRY1  85, FlushWriteBuffer, 0 
SYSSTUBS_ENTRY2  85, FlushWriteBuffer, 0 
SYSSTUBS_ENTRY3  85, FlushWriteBuffer, 0 
SYSSTUBS_ENTRY4  85, FlushWriteBuffer, 0 
SYSSTUBS_ENTRY5  85, FlushWriteBuffer, 0 
SYSSTUBS_ENTRY6  85, FlushWriteBuffer, 0 
SYSSTUBS_ENTRY7  85, FlushWriteBuffer, 0 
SYSSTUBS_ENTRY8  85, FlushWriteBuffer, 0 
SYSSTUBS_ENTRY1  86, FreeUserPhysicalPages, 3 
SYSSTUBS_ENTRY2  86, FreeUserPhysicalPages, 3 
SYSSTUBS_ENTRY3  86, FreeUserPhysicalPages, 3 
SYSSTUBS_ENTRY4  86, FreeUserPhysicalPages, 3 
SYSSTUBS_ENTRY5  86, FreeUserPhysicalPages, 3 
SYSSTUBS_ENTRY6  86, FreeUserPhysicalPages, 3 
SYSSTUBS_ENTRY7  86, FreeUserPhysicalPages, 3 
SYSSTUBS_ENTRY8  86, FreeUserPhysicalPages, 3 
SYSSTUBS_ENTRY1  87, FreeVirtualMemory, 4 
SYSSTUBS_ENTRY2  87, FreeVirtualMemory, 4 
SYSSTUBS_ENTRY3  87, FreeVirtualMemory, 4 
SYSSTUBS_ENTRY4  87, FreeVirtualMemory, 4 
SYSSTUBS_ENTRY5  87, FreeVirtualMemory, 4 
SYSSTUBS_ENTRY6  87, FreeVirtualMemory, 4 
SYSSTUBS_ENTRY7  87, FreeVirtualMemory, 4 
SYSSTUBS_ENTRY8  87, FreeVirtualMemory, 4 
SYSSTUBS_ENTRY1  88, FsControlFile, 10 
SYSSTUBS_ENTRY2  88, FsControlFile, 10 
SYSSTUBS_ENTRY3  88, FsControlFile, 10 
SYSSTUBS_ENTRY4  88, FsControlFile, 10 
SYSSTUBS_ENTRY5  88, FsControlFile, 10 
SYSSTUBS_ENTRY6  88, FsControlFile, 10 
SYSSTUBS_ENTRY7  88, FsControlFile, 10 
SYSSTUBS_ENTRY8  88, FsControlFile, 10 
SYSSTUBS_ENTRY1  89, GetContextThread, 2 
SYSSTUBS_ENTRY2  89, GetContextThread, 2 
SYSSTUBS_ENTRY3  89, GetContextThread, 2 
SYSSTUBS_ENTRY4  89, GetContextThread, 2 
SYSSTUBS_ENTRY5  89, GetContextThread, 2 
SYSSTUBS_ENTRY6  89, GetContextThread, 2 
SYSSTUBS_ENTRY7  89, GetContextThread, 2 
SYSSTUBS_ENTRY8  89, GetContextThread, 2 
SYSSTUBS_ENTRY1  90, GetDevicePowerState, 2 
SYSSTUBS_ENTRY2  90, GetDevicePowerState, 2 
SYSSTUBS_ENTRY3  90, GetDevicePowerState, 2 
SYSSTUBS_ENTRY4  90, GetDevicePowerState, 2 
SYSSTUBS_ENTRY5  90, GetDevicePowerState, 2 
SYSSTUBS_ENTRY6  90, GetDevicePowerState, 2 
SYSSTUBS_ENTRY7  90, GetDevicePowerState, 2 
SYSSTUBS_ENTRY8  90, GetDevicePowerState, 2 
SYSSTUBS_ENTRY1  91, GetPlugPlayEvent, 4 
SYSSTUBS_ENTRY2  91, GetPlugPlayEvent, 4 
SYSSTUBS_ENTRY3  91, GetPlugPlayEvent, 4 
SYSSTUBS_ENTRY4  91, GetPlugPlayEvent, 4 
SYSSTUBS_ENTRY5  91, GetPlugPlayEvent, 4 
SYSSTUBS_ENTRY6  91, GetPlugPlayEvent, 4 
SYSSTUBS_ENTRY7  91, GetPlugPlayEvent, 4 
SYSSTUBS_ENTRY8  91, GetPlugPlayEvent, 4 
SYSSTUBS_ENTRY1  92, GetWriteWatch, 7 
SYSSTUBS_ENTRY2  92, GetWriteWatch, 7 
SYSSTUBS_ENTRY3  92, GetWriteWatch, 7 
SYSSTUBS_ENTRY4  92, GetWriteWatch, 7 
SYSSTUBS_ENTRY5  92, GetWriteWatch, 7 
SYSSTUBS_ENTRY6  92, GetWriteWatch, 7 
SYSSTUBS_ENTRY7  92, GetWriteWatch, 7 
SYSSTUBS_ENTRY8  92, GetWriteWatch, 7 
SYSSTUBS_ENTRY1  93, ImpersonateAnonymousToken, 1 
SYSSTUBS_ENTRY2  93, ImpersonateAnonymousToken, 1 
SYSSTUBS_ENTRY3  93, ImpersonateAnonymousToken, 1 
SYSSTUBS_ENTRY4  93, ImpersonateAnonymousToken, 1 
SYSSTUBS_ENTRY5  93, ImpersonateAnonymousToken, 1 
SYSSTUBS_ENTRY6  93, ImpersonateAnonymousToken, 1 
SYSSTUBS_ENTRY7  93, ImpersonateAnonymousToken, 1 
SYSSTUBS_ENTRY8  93, ImpersonateAnonymousToken, 1 
SYSSTUBS_ENTRY1  94, ImpersonateClientOfPort, 2 
SYSSTUBS_ENTRY2  94, ImpersonateClientOfPort, 2 
SYSSTUBS_ENTRY3  94, ImpersonateClientOfPort, 2 
SYSSTUBS_ENTRY4  94, ImpersonateClientOfPort, 2 
SYSSTUBS_ENTRY5  94, ImpersonateClientOfPort, 2 
SYSSTUBS_ENTRY6  94, ImpersonateClientOfPort, 2 
SYSSTUBS_ENTRY7  94, ImpersonateClientOfPort, 2 
SYSSTUBS_ENTRY8  94, ImpersonateClientOfPort, 2 
SYSSTUBS_ENTRY1  95, ImpersonateThread, 3 
SYSSTUBS_ENTRY2  95, ImpersonateThread, 3 
SYSSTUBS_ENTRY3  95, ImpersonateThread, 3 
SYSSTUBS_ENTRY4  95, ImpersonateThread, 3 
SYSSTUBS_ENTRY5  95, ImpersonateThread, 3 
SYSSTUBS_ENTRY6  95, ImpersonateThread, 3 
SYSSTUBS_ENTRY7  95, ImpersonateThread, 3 
SYSSTUBS_ENTRY8  95, ImpersonateThread, 3 
SYSSTUBS_ENTRY1  96, InitializeRegistry, 1 
SYSSTUBS_ENTRY2  96, InitializeRegistry, 1 
SYSSTUBS_ENTRY3  96, InitializeRegistry, 1 
SYSSTUBS_ENTRY4  96, InitializeRegistry, 1 
SYSSTUBS_ENTRY5  96, InitializeRegistry, 1 
SYSSTUBS_ENTRY6  96, InitializeRegistry, 1 
SYSSTUBS_ENTRY7  96, InitializeRegistry, 1 
SYSSTUBS_ENTRY8  96, InitializeRegistry, 1 
SYSSTUBS_ENTRY1  97, InitiatePowerAction, 4 
SYSSTUBS_ENTRY2  97, InitiatePowerAction, 4 
SYSSTUBS_ENTRY3  97, InitiatePowerAction, 4 
SYSSTUBS_ENTRY4  97, InitiatePowerAction, 4 
SYSSTUBS_ENTRY5  97, InitiatePowerAction, 4 
SYSSTUBS_ENTRY6  97, InitiatePowerAction, 4 
SYSSTUBS_ENTRY7  97, InitiatePowerAction, 4 
SYSSTUBS_ENTRY8  97, InitiatePowerAction, 4 
SYSSTUBS_ENTRY1  98, IsProcessInJob, 2 
SYSSTUBS_ENTRY2  98, IsProcessInJob, 2 
SYSSTUBS_ENTRY3  98, IsProcessInJob, 2 
SYSSTUBS_ENTRY4  98, IsProcessInJob, 2 
SYSSTUBS_ENTRY5  98, IsProcessInJob, 2 
SYSSTUBS_ENTRY6  98, IsProcessInJob, 2 
SYSSTUBS_ENTRY7  98, IsProcessInJob, 2 
SYSSTUBS_ENTRY8  98, IsProcessInJob, 2 
SYSSTUBS_ENTRY1  99, IsSystemResumeAutomatic, 0 
SYSSTUBS_ENTRY2  99, IsSystemResumeAutomatic, 0 
SYSSTUBS_ENTRY3  99, IsSystemResumeAutomatic, 0 
SYSSTUBS_ENTRY4  99, IsSystemResumeAutomatic, 0 
SYSSTUBS_ENTRY5  99, IsSystemResumeAutomatic, 0 
SYSSTUBS_ENTRY6  99, IsSystemResumeAutomatic, 0 
SYSSTUBS_ENTRY7  99, IsSystemResumeAutomatic, 0 
SYSSTUBS_ENTRY8  99, IsSystemResumeAutomatic, 0 
SYSSTUBS_ENTRY1  100, ListenPort, 2 
SYSSTUBS_ENTRY2  100, ListenPort, 2 
SYSSTUBS_ENTRY3  100, ListenPort, 2 
SYSSTUBS_ENTRY4  100, ListenPort, 2 
SYSSTUBS_ENTRY5  100, ListenPort, 2 
SYSSTUBS_ENTRY6  100, ListenPort, 2 
SYSSTUBS_ENTRY7  100, ListenPort, 2 
SYSSTUBS_ENTRY8  100, ListenPort, 2 
SYSSTUBS_ENTRY1  101, LoadDriver, 1 
SYSSTUBS_ENTRY2  101, LoadDriver, 1 
SYSSTUBS_ENTRY3  101, LoadDriver, 1 
SYSSTUBS_ENTRY4  101, LoadDriver, 1 
SYSSTUBS_ENTRY5  101, LoadDriver, 1 
SYSSTUBS_ENTRY6  101, LoadDriver, 1 
SYSSTUBS_ENTRY7  101, LoadDriver, 1 
SYSSTUBS_ENTRY8  101, LoadDriver, 1 
SYSSTUBS_ENTRY1  102, LoadKey, 2 
SYSSTUBS_ENTRY2  102, LoadKey, 2 
SYSSTUBS_ENTRY3  102, LoadKey, 2 
SYSSTUBS_ENTRY4  102, LoadKey, 2 
SYSSTUBS_ENTRY5  102, LoadKey, 2 
SYSSTUBS_ENTRY6  102, LoadKey, 2 
SYSSTUBS_ENTRY7  102, LoadKey, 2 
SYSSTUBS_ENTRY8  102, LoadKey, 2 
SYSSTUBS_ENTRY1  103, LoadKey2, 3 
SYSSTUBS_ENTRY2  103, LoadKey2, 3 
SYSSTUBS_ENTRY3  103, LoadKey2, 3 
SYSSTUBS_ENTRY4  103, LoadKey2, 3 
SYSSTUBS_ENTRY5  103, LoadKey2, 3 
SYSSTUBS_ENTRY6  103, LoadKey2, 3 
SYSSTUBS_ENTRY7  103, LoadKey2, 3 
SYSSTUBS_ENTRY8  103, LoadKey2, 3 
SYSSTUBS_ENTRY1  104, LoadKeyEx, 4 
SYSSTUBS_ENTRY2  104, LoadKeyEx, 4 
SYSSTUBS_ENTRY3  104, LoadKeyEx, 4 
SYSSTUBS_ENTRY4  104, LoadKeyEx, 4 
SYSSTUBS_ENTRY5  104, LoadKeyEx, 4 
SYSSTUBS_ENTRY6  104, LoadKeyEx, 4 
SYSSTUBS_ENTRY7  104, LoadKeyEx, 4 
SYSSTUBS_ENTRY8  104, LoadKeyEx, 4 
SYSSTUBS_ENTRY1  105, LockFile, 10 
SYSSTUBS_ENTRY2  105, LockFile, 10 
SYSSTUBS_ENTRY3  105, LockFile, 10 
SYSSTUBS_ENTRY4  105, LockFile, 10 
SYSSTUBS_ENTRY5  105, LockFile, 10 
SYSSTUBS_ENTRY6  105, LockFile, 10 
SYSSTUBS_ENTRY7  105, LockFile, 10 
SYSSTUBS_ENTRY8  105, LockFile, 10 
SYSSTUBS_ENTRY1  106, LockProductActivationKeys, 2 
SYSSTUBS_ENTRY2  106, LockProductActivationKeys, 2 
SYSSTUBS_ENTRY3  106, LockProductActivationKeys, 2 
SYSSTUBS_ENTRY4  106, LockProductActivationKeys, 2 
SYSSTUBS_ENTRY5  106, LockProductActivationKeys, 2 
SYSSTUBS_ENTRY6  106, LockProductActivationKeys, 2 
SYSSTUBS_ENTRY7  106, LockProductActivationKeys, 2 
SYSSTUBS_ENTRY8  106, LockProductActivationKeys, 2 
SYSSTUBS_ENTRY1  107, LockRegistryKey, 1 
SYSSTUBS_ENTRY2  107, LockRegistryKey, 1 
SYSSTUBS_ENTRY3  107, LockRegistryKey, 1 
SYSSTUBS_ENTRY4  107, LockRegistryKey, 1 
SYSSTUBS_ENTRY5  107, LockRegistryKey, 1 
SYSSTUBS_ENTRY6  107, LockRegistryKey, 1 
SYSSTUBS_ENTRY7  107, LockRegistryKey, 1 
SYSSTUBS_ENTRY8  107, LockRegistryKey, 1 
SYSSTUBS_ENTRY1  108, LockVirtualMemory, 4 
SYSSTUBS_ENTRY2  108, LockVirtualMemory, 4 
SYSSTUBS_ENTRY3  108, LockVirtualMemory, 4 
SYSSTUBS_ENTRY4  108, LockVirtualMemory, 4 
SYSSTUBS_ENTRY5  108, LockVirtualMemory, 4 
SYSSTUBS_ENTRY6  108, LockVirtualMemory, 4 
SYSSTUBS_ENTRY7  108, LockVirtualMemory, 4 
SYSSTUBS_ENTRY8  108, LockVirtualMemory, 4 
SYSSTUBS_ENTRY1  109, MakePermanentObject, 1 
SYSSTUBS_ENTRY2  109, MakePermanentObject, 1 
SYSSTUBS_ENTRY3  109, MakePermanentObject, 1 
SYSSTUBS_ENTRY4  109, MakePermanentObject, 1 
SYSSTUBS_ENTRY5  109, MakePermanentObject, 1 
SYSSTUBS_ENTRY6  109, MakePermanentObject, 1 
SYSSTUBS_ENTRY7  109, MakePermanentObject, 1 
SYSSTUBS_ENTRY8  109, MakePermanentObject, 1 
SYSSTUBS_ENTRY1  110, MakeTemporaryObject, 1 
SYSSTUBS_ENTRY2  110, MakeTemporaryObject, 1 
SYSSTUBS_ENTRY3  110, MakeTemporaryObject, 1 
SYSSTUBS_ENTRY4  110, MakeTemporaryObject, 1 
SYSSTUBS_ENTRY5  110, MakeTemporaryObject, 1 
SYSSTUBS_ENTRY6  110, MakeTemporaryObject, 1 
SYSSTUBS_ENTRY7  110, MakeTemporaryObject, 1 
SYSSTUBS_ENTRY8  110, MakeTemporaryObject, 1 
SYSSTUBS_ENTRY1  111, MapUserPhysicalPages, 3 
SYSSTUBS_ENTRY2  111, MapUserPhysicalPages, 3 
SYSSTUBS_ENTRY3  111, MapUserPhysicalPages, 3 
SYSSTUBS_ENTRY4  111, MapUserPhysicalPages, 3 
SYSSTUBS_ENTRY5  111, MapUserPhysicalPages, 3 
SYSSTUBS_ENTRY6  111, MapUserPhysicalPages, 3 
SYSSTUBS_ENTRY7  111, MapUserPhysicalPages, 3 
SYSSTUBS_ENTRY8  111, MapUserPhysicalPages, 3 
SYSSTUBS_ENTRY1  112, MapUserPhysicalPagesScatter, 3 
SYSSTUBS_ENTRY2  112, MapUserPhysicalPagesScatter, 3 
SYSSTUBS_ENTRY3  112, MapUserPhysicalPagesScatter, 3 
SYSSTUBS_ENTRY4  112, MapUserPhysicalPagesScatter, 3 
SYSSTUBS_ENTRY5  112, MapUserPhysicalPagesScatter, 3 
SYSSTUBS_ENTRY6  112, MapUserPhysicalPagesScatter, 3 
SYSSTUBS_ENTRY7  112, MapUserPhysicalPagesScatter, 3 
SYSSTUBS_ENTRY8  112, MapUserPhysicalPagesScatter, 3 
SYSSTUBS_ENTRY1  113, MapViewOfSection, 10 
SYSSTUBS_ENTRY2  113, MapViewOfSection, 10 
SYSSTUBS_ENTRY3  113, MapViewOfSection, 10 
SYSSTUBS_ENTRY4  113, MapViewOfSection, 10 
SYSSTUBS_ENTRY5  113, MapViewOfSection, 10 
SYSSTUBS_ENTRY6  113, MapViewOfSection, 10 
SYSSTUBS_ENTRY7  113, MapViewOfSection, 10 
SYSSTUBS_ENTRY8  113, MapViewOfSection, 10 
SYSSTUBS_ENTRY1  114, ModifyBootEntry, 1 
SYSSTUBS_ENTRY2  114, ModifyBootEntry, 1 
SYSSTUBS_ENTRY3  114, ModifyBootEntry, 1 
SYSSTUBS_ENTRY4  114, ModifyBootEntry, 1 
SYSSTUBS_ENTRY5  114, ModifyBootEntry, 1 
SYSSTUBS_ENTRY6  114, ModifyBootEntry, 1 
SYSSTUBS_ENTRY7  114, ModifyBootEntry, 1 
SYSSTUBS_ENTRY8  114, ModifyBootEntry, 1 
SYSSTUBS_ENTRY1  115, ModifyDriverEntry, 1 
SYSSTUBS_ENTRY2  115, ModifyDriverEntry, 1 
SYSSTUBS_ENTRY3  115, ModifyDriverEntry, 1 
SYSSTUBS_ENTRY4  115, ModifyDriverEntry, 1 
SYSSTUBS_ENTRY5  115, ModifyDriverEntry, 1 
SYSSTUBS_ENTRY6  115, ModifyDriverEntry, 1 
SYSSTUBS_ENTRY7  115, ModifyDriverEntry, 1 
SYSSTUBS_ENTRY8  115, ModifyDriverEntry, 1 
SYSSTUBS_ENTRY1  116, NotifyChangeDirectoryFile, 9 
SYSSTUBS_ENTRY2  116, NotifyChangeDirectoryFile, 9 
SYSSTUBS_ENTRY3  116, NotifyChangeDirectoryFile, 9 
SYSSTUBS_ENTRY4  116, NotifyChangeDirectoryFile, 9 
SYSSTUBS_ENTRY5  116, NotifyChangeDirectoryFile, 9 
SYSSTUBS_ENTRY6  116, NotifyChangeDirectoryFile, 9 
SYSSTUBS_ENTRY7  116, NotifyChangeDirectoryFile, 9 
SYSSTUBS_ENTRY8  116, NotifyChangeDirectoryFile, 9 
SYSSTUBS_ENTRY1  117, NotifyChangeKey, 10 
SYSSTUBS_ENTRY2  117, NotifyChangeKey, 10 
SYSSTUBS_ENTRY3  117, NotifyChangeKey, 10 
SYSSTUBS_ENTRY4  117, NotifyChangeKey, 10 
SYSSTUBS_ENTRY5  117, NotifyChangeKey, 10 
SYSSTUBS_ENTRY6  117, NotifyChangeKey, 10 
SYSSTUBS_ENTRY7  117, NotifyChangeKey, 10 
SYSSTUBS_ENTRY8  117, NotifyChangeKey, 10 
SYSSTUBS_ENTRY1  118, NotifyChangeMultipleKeys, 12 
SYSSTUBS_ENTRY2  118, NotifyChangeMultipleKeys, 12 
SYSSTUBS_ENTRY3  118, NotifyChangeMultipleKeys, 12 
SYSSTUBS_ENTRY4  118, NotifyChangeMultipleKeys, 12 
SYSSTUBS_ENTRY5  118, NotifyChangeMultipleKeys, 12 
SYSSTUBS_ENTRY6  118, NotifyChangeMultipleKeys, 12 
SYSSTUBS_ENTRY7  118, NotifyChangeMultipleKeys, 12 
SYSSTUBS_ENTRY8  118, NotifyChangeMultipleKeys, 12 
SYSSTUBS_ENTRY1  119, OpenDirectoryObject, 3 
SYSSTUBS_ENTRY2  119, OpenDirectoryObject, 3 
SYSSTUBS_ENTRY3  119, OpenDirectoryObject, 3 
SYSSTUBS_ENTRY4  119, OpenDirectoryObject, 3 
SYSSTUBS_ENTRY5  119, OpenDirectoryObject, 3 
SYSSTUBS_ENTRY6  119, OpenDirectoryObject, 3 
SYSSTUBS_ENTRY7  119, OpenDirectoryObject, 3 
SYSSTUBS_ENTRY8  119, OpenDirectoryObject, 3 
SYSSTUBS_ENTRY1  120, OpenEvent, 3 
SYSSTUBS_ENTRY2  120, OpenEvent, 3 
SYSSTUBS_ENTRY3  120, OpenEvent, 3 
SYSSTUBS_ENTRY4  120, OpenEvent, 3 
SYSSTUBS_ENTRY5  120, OpenEvent, 3 
SYSSTUBS_ENTRY6  120, OpenEvent, 3 
SYSSTUBS_ENTRY7  120, OpenEvent, 3 
SYSSTUBS_ENTRY8  120, OpenEvent, 3 
SYSSTUBS_ENTRY1  121, OpenEventPair, 3 
SYSSTUBS_ENTRY2  121, OpenEventPair, 3 
SYSSTUBS_ENTRY3  121, OpenEventPair, 3 
SYSSTUBS_ENTRY4  121, OpenEventPair, 3 
SYSSTUBS_ENTRY5  121, OpenEventPair, 3 
SYSSTUBS_ENTRY6  121, OpenEventPair, 3 
SYSSTUBS_ENTRY7  121, OpenEventPair, 3 
SYSSTUBS_ENTRY8  121, OpenEventPair, 3 
SYSSTUBS_ENTRY1  122, OpenFile, 6 
SYSSTUBS_ENTRY2  122, OpenFile, 6 
SYSSTUBS_ENTRY3  122, OpenFile, 6 
SYSSTUBS_ENTRY4  122, OpenFile, 6 
SYSSTUBS_ENTRY5  122, OpenFile, 6 
SYSSTUBS_ENTRY6  122, OpenFile, 6 
SYSSTUBS_ENTRY7  122, OpenFile, 6 
SYSSTUBS_ENTRY8  122, OpenFile, 6 
SYSSTUBS_ENTRY1  123, OpenIoCompletion, 3 
SYSSTUBS_ENTRY2  123, OpenIoCompletion, 3 
SYSSTUBS_ENTRY3  123, OpenIoCompletion, 3 
SYSSTUBS_ENTRY4  123, OpenIoCompletion, 3 
SYSSTUBS_ENTRY5  123, OpenIoCompletion, 3 
SYSSTUBS_ENTRY6  123, OpenIoCompletion, 3 
SYSSTUBS_ENTRY7  123, OpenIoCompletion, 3 
SYSSTUBS_ENTRY8  123, OpenIoCompletion, 3 
SYSSTUBS_ENTRY1  124, OpenJobObject, 3 
SYSSTUBS_ENTRY2  124, OpenJobObject, 3 
SYSSTUBS_ENTRY3  124, OpenJobObject, 3 
SYSSTUBS_ENTRY4  124, OpenJobObject, 3 
SYSSTUBS_ENTRY5  124, OpenJobObject, 3 
SYSSTUBS_ENTRY6  124, OpenJobObject, 3 
SYSSTUBS_ENTRY7  124, OpenJobObject, 3 
SYSSTUBS_ENTRY8  124, OpenJobObject, 3 
SYSSTUBS_ENTRY1  125, OpenKey, 3 
SYSSTUBS_ENTRY2  125, OpenKey, 3 
SYSSTUBS_ENTRY3  125, OpenKey, 3 
SYSSTUBS_ENTRY4  125, OpenKey, 3 
SYSSTUBS_ENTRY5  125, OpenKey, 3 
SYSSTUBS_ENTRY6  125, OpenKey, 3 
SYSSTUBS_ENTRY7  125, OpenKey, 3 
SYSSTUBS_ENTRY8  125, OpenKey, 3 
SYSSTUBS_ENTRY1  126, OpenMutant, 3 
SYSSTUBS_ENTRY2  126, OpenMutant, 3 
SYSSTUBS_ENTRY3  126, OpenMutant, 3 
SYSSTUBS_ENTRY4  126, OpenMutant, 3 
SYSSTUBS_ENTRY5  126, OpenMutant, 3 
SYSSTUBS_ENTRY6  126, OpenMutant, 3 
SYSSTUBS_ENTRY7  126, OpenMutant, 3 
SYSSTUBS_ENTRY8  126, OpenMutant, 3 
SYSSTUBS_ENTRY1  127, OpenObjectAuditAlarm, 12 
SYSSTUBS_ENTRY2  127, OpenObjectAuditAlarm, 12 
SYSSTUBS_ENTRY3  127, OpenObjectAuditAlarm, 12 
SYSSTUBS_ENTRY4  127, OpenObjectAuditAlarm, 12 
SYSSTUBS_ENTRY5  127, OpenObjectAuditAlarm, 12 
SYSSTUBS_ENTRY6  127, OpenObjectAuditAlarm, 12 
SYSSTUBS_ENTRY7  127, OpenObjectAuditAlarm, 12 
SYSSTUBS_ENTRY8  127, OpenObjectAuditAlarm, 12 
SYSSTUBS_ENTRY1  128, OpenProcess, 4 
SYSSTUBS_ENTRY2  128, OpenProcess, 4 
SYSSTUBS_ENTRY3  128, OpenProcess, 4 
SYSSTUBS_ENTRY4  128, OpenProcess, 4 
SYSSTUBS_ENTRY5  128, OpenProcess, 4 
SYSSTUBS_ENTRY6  128, OpenProcess, 4 
SYSSTUBS_ENTRY7  128, OpenProcess, 4 
SYSSTUBS_ENTRY8  128, OpenProcess, 4 
SYSSTUBS_ENTRY1  129, OpenProcessToken, 3 
SYSSTUBS_ENTRY2  129, OpenProcessToken, 3 
SYSSTUBS_ENTRY3  129, OpenProcessToken, 3 
SYSSTUBS_ENTRY4  129, OpenProcessToken, 3 
SYSSTUBS_ENTRY5  129, OpenProcessToken, 3 
SYSSTUBS_ENTRY6  129, OpenProcessToken, 3 
SYSSTUBS_ENTRY7  129, OpenProcessToken, 3 
SYSSTUBS_ENTRY8  129, OpenProcessToken, 3 
SYSSTUBS_ENTRY1  130, OpenProcessTokenEx, 4 
SYSSTUBS_ENTRY2  130, OpenProcessTokenEx, 4 
SYSSTUBS_ENTRY3  130, OpenProcessTokenEx, 4 
SYSSTUBS_ENTRY4  130, OpenProcessTokenEx, 4 
SYSSTUBS_ENTRY5  130, OpenProcessTokenEx, 4 
SYSSTUBS_ENTRY6  130, OpenProcessTokenEx, 4 
SYSSTUBS_ENTRY7  130, OpenProcessTokenEx, 4 
SYSSTUBS_ENTRY8  130, OpenProcessTokenEx, 4 
SYSSTUBS_ENTRY1  131, OpenSection, 3 
SYSSTUBS_ENTRY2  131, OpenSection, 3 
SYSSTUBS_ENTRY3  131, OpenSection, 3 
SYSSTUBS_ENTRY4  131, OpenSection, 3 
SYSSTUBS_ENTRY5  131, OpenSection, 3 
SYSSTUBS_ENTRY6  131, OpenSection, 3 
SYSSTUBS_ENTRY7  131, OpenSection, 3 
SYSSTUBS_ENTRY8  131, OpenSection, 3 
SYSSTUBS_ENTRY1  132, OpenSemaphore, 3 
SYSSTUBS_ENTRY2  132, OpenSemaphore, 3 
SYSSTUBS_ENTRY3  132, OpenSemaphore, 3 
SYSSTUBS_ENTRY4  132, OpenSemaphore, 3 
SYSSTUBS_ENTRY5  132, OpenSemaphore, 3 
SYSSTUBS_ENTRY6  132, OpenSemaphore, 3 
SYSSTUBS_ENTRY7  132, OpenSemaphore, 3 
SYSSTUBS_ENTRY8  132, OpenSemaphore, 3 
SYSSTUBS_ENTRY1  133, OpenSymbolicLinkObject, 3 
SYSSTUBS_ENTRY2  133, OpenSymbolicLinkObject, 3 
SYSSTUBS_ENTRY3  133, OpenSymbolicLinkObject, 3 
SYSSTUBS_ENTRY4  133, OpenSymbolicLinkObject, 3 
SYSSTUBS_ENTRY5  133, OpenSymbolicLinkObject, 3 
SYSSTUBS_ENTRY6  133, OpenSymbolicLinkObject, 3 
SYSSTUBS_ENTRY7  133, OpenSymbolicLinkObject, 3 
SYSSTUBS_ENTRY8  133, OpenSymbolicLinkObject, 3 
SYSSTUBS_ENTRY1  134, OpenThread, 4 
SYSSTUBS_ENTRY2  134, OpenThread, 4 
SYSSTUBS_ENTRY3  134, OpenThread, 4 
SYSSTUBS_ENTRY4  134, OpenThread, 4 
SYSSTUBS_ENTRY5  134, OpenThread, 4 
SYSSTUBS_ENTRY6  134, OpenThread, 4 
SYSSTUBS_ENTRY7  134, OpenThread, 4 
SYSSTUBS_ENTRY8  134, OpenThread, 4 
SYSSTUBS_ENTRY1  135, OpenThreadToken, 4 
SYSSTUBS_ENTRY2  135, OpenThreadToken, 4 
SYSSTUBS_ENTRY3  135, OpenThreadToken, 4 
SYSSTUBS_ENTRY4  135, OpenThreadToken, 4 
SYSSTUBS_ENTRY5  135, OpenThreadToken, 4 
SYSSTUBS_ENTRY6  135, OpenThreadToken, 4 
SYSSTUBS_ENTRY7  135, OpenThreadToken, 4 
SYSSTUBS_ENTRY8  135, OpenThreadToken, 4 
SYSSTUBS_ENTRY1  136, OpenThreadTokenEx, 5 
SYSSTUBS_ENTRY2  136, OpenThreadTokenEx, 5 
SYSSTUBS_ENTRY3  136, OpenThreadTokenEx, 5 
SYSSTUBS_ENTRY4  136, OpenThreadTokenEx, 5 
SYSSTUBS_ENTRY5  136, OpenThreadTokenEx, 5 
SYSSTUBS_ENTRY6  136, OpenThreadTokenEx, 5 
SYSSTUBS_ENTRY7  136, OpenThreadTokenEx, 5 
SYSSTUBS_ENTRY8  136, OpenThreadTokenEx, 5 
SYSSTUBS_ENTRY1  137, OpenTimer, 3 
SYSSTUBS_ENTRY2  137, OpenTimer, 3 
SYSSTUBS_ENTRY3  137, OpenTimer, 3 
SYSSTUBS_ENTRY4  137, OpenTimer, 3 
SYSSTUBS_ENTRY5  137, OpenTimer, 3 
SYSSTUBS_ENTRY6  137, OpenTimer, 3 
SYSSTUBS_ENTRY7  137, OpenTimer, 3 
SYSSTUBS_ENTRY8  137, OpenTimer, 3 
SYSSTUBS_ENTRY1  138, PlugPlayControl, 3 
SYSSTUBS_ENTRY2  138, PlugPlayControl, 3 
SYSSTUBS_ENTRY3  138, PlugPlayControl, 3 
SYSSTUBS_ENTRY4  138, PlugPlayControl, 3 
SYSSTUBS_ENTRY5  138, PlugPlayControl, 3 
SYSSTUBS_ENTRY6  138, PlugPlayControl, 3 
SYSSTUBS_ENTRY7  138, PlugPlayControl, 3 
SYSSTUBS_ENTRY8  138, PlugPlayControl, 3 
SYSSTUBS_ENTRY1  139, PowerInformation, 5 
SYSSTUBS_ENTRY2  139, PowerInformation, 5 
SYSSTUBS_ENTRY3  139, PowerInformation, 5 
SYSSTUBS_ENTRY4  139, PowerInformation, 5 
SYSSTUBS_ENTRY5  139, PowerInformation, 5 
SYSSTUBS_ENTRY6  139, PowerInformation, 5 
SYSSTUBS_ENTRY7  139, PowerInformation, 5 
SYSSTUBS_ENTRY8  139, PowerInformation, 5 
SYSSTUBS_ENTRY1  140, PrivilegeCheck, 3 
SYSSTUBS_ENTRY2  140, PrivilegeCheck, 3 
SYSSTUBS_ENTRY3  140, PrivilegeCheck, 3 
SYSSTUBS_ENTRY4  140, PrivilegeCheck, 3 
SYSSTUBS_ENTRY5  140, PrivilegeCheck, 3 
SYSSTUBS_ENTRY6  140, PrivilegeCheck, 3 
SYSSTUBS_ENTRY7  140, PrivilegeCheck, 3 
SYSSTUBS_ENTRY8  140, PrivilegeCheck, 3 
SYSSTUBS_ENTRY1  141, PrivilegeObjectAuditAlarm, 6 
SYSSTUBS_ENTRY2  141, PrivilegeObjectAuditAlarm, 6 
SYSSTUBS_ENTRY3  141, PrivilegeObjectAuditAlarm, 6 
SYSSTUBS_ENTRY4  141, PrivilegeObjectAuditAlarm, 6 
SYSSTUBS_ENTRY5  141, PrivilegeObjectAuditAlarm, 6 
SYSSTUBS_ENTRY6  141, PrivilegeObjectAuditAlarm, 6 
SYSSTUBS_ENTRY7  141, PrivilegeObjectAuditAlarm, 6 
SYSSTUBS_ENTRY8  141, PrivilegeObjectAuditAlarm, 6 
SYSSTUBS_ENTRY1  142, PrivilegedServiceAuditAlarm, 5 
SYSSTUBS_ENTRY2  142, PrivilegedServiceAuditAlarm, 5 
SYSSTUBS_ENTRY3  142, PrivilegedServiceAuditAlarm, 5 
SYSSTUBS_ENTRY4  142, PrivilegedServiceAuditAlarm, 5 
SYSSTUBS_ENTRY5  142, PrivilegedServiceAuditAlarm, 5 
SYSSTUBS_ENTRY6  142, PrivilegedServiceAuditAlarm, 5 
SYSSTUBS_ENTRY7  142, PrivilegedServiceAuditAlarm, 5 
SYSSTUBS_ENTRY8  142, PrivilegedServiceAuditAlarm, 5 
SYSSTUBS_ENTRY1  143, ProtectVirtualMemory, 5 
SYSSTUBS_ENTRY2  143, ProtectVirtualMemory, 5 
SYSSTUBS_ENTRY3  143, ProtectVirtualMemory, 5 
SYSSTUBS_ENTRY4  143, ProtectVirtualMemory, 5 
SYSSTUBS_ENTRY5  143, ProtectVirtualMemory, 5 
SYSSTUBS_ENTRY6  143, ProtectVirtualMemory, 5 
SYSSTUBS_ENTRY7  143, ProtectVirtualMemory, 5 
SYSSTUBS_ENTRY8  143, ProtectVirtualMemory, 5 
SYSSTUBS_ENTRY1  144, PulseEvent, 2 
SYSSTUBS_ENTRY2  144, PulseEvent, 2 
SYSSTUBS_ENTRY3  144, PulseEvent, 2 
SYSSTUBS_ENTRY4  144, PulseEvent, 2 
SYSSTUBS_ENTRY5  144, PulseEvent, 2 
SYSSTUBS_ENTRY6  144, PulseEvent, 2 
SYSSTUBS_ENTRY7  144, PulseEvent, 2 
SYSSTUBS_ENTRY8  144, PulseEvent, 2 
SYSSTUBS_ENTRY1  145, QueryAttributesFile, 2 
SYSSTUBS_ENTRY2  145, QueryAttributesFile, 2 
SYSSTUBS_ENTRY3  145, QueryAttributesFile, 2 
SYSSTUBS_ENTRY4  145, QueryAttributesFile, 2 
SYSSTUBS_ENTRY5  145, QueryAttributesFile, 2 
SYSSTUBS_ENTRY6  145, QueryAttributesFile, 2 
SYSSTUBS_ENTRY7  145, QueryAttributesFile, 2 
SYSSTUBS_ENTRY8  145, QueryAttributesFile, 2 
SYSSTUBS_ENTRY1  146, QueryBootEntryOrder, 2 
SYSSTUBS_ENTRY2  146, QueryBootEntryOrder, 2 
SYSSTUBS_ENTRY3  146, QueryBootEntryOrder, 2 
SYSSTUBS_ENTRY4  146, QueryBootEntryOrder, 2 
SYSSTUBS_ENTRY5  146, QueryBootEntryOrder, 2 
SYSSTUBS_ENTRY6  146, QueryBootEntryOrder, 2 
SYSSTUBS_ENTRY7  146, QueryBootEntryOrder, 2 
SYSSTUBS_ENTRY8  146, QueryBootEntryOrder, 2 
SYSSTUBS_ENTRY1  147, QueryBootOptions, 2 
SYSSTUBS_ENTRY2  147, QueryBootOptions, 2 
SYSSTUBS_ENTRY3  147, QueryBootOptions, 2 
SYSSTUBS_ENTRY4  147, QueryBootOptions, 2 
SYSSTUBS_ENTRY5  147, QueryBootOptions, 2 
SYSSTUBS_ENTRY6  147, QueryBootOptions, 2 
SYSSTUBS_ENTRY7  147, QueryBootOptions, 2 
SYSSTUBS_ENTRY8  147, QueryBootOptions, 2 
SYSSTUBS_ENTRY1  148, QueryDebugFilterState, 2 
SYSSTUBS_ENTRY2  148, QueryDebugFilterState, 2 
SYSSTUBS_ENTRY3  148, QueryDebugFilterState, 2 
SYSSTUBS_ENTRY4  148, QueryDebugFilterState, 2 
SYSSTUBS_ENTRY5  148, QueryDebugFilterState, 2 
SYSSTUBS_ENTRY6  148, QueryDebugFilterState, 2 
SYSSTUBS_ENTRY7  148, QueryDebugFilterState, 2 
SYSSTUBS_ENTRY8  148, QueryDebugFilterState, 2 
SYSSTUBS_ENTRY1  149, QueryDefaultLocale, 2 
SYSSTUBS_ENTRY2  149, QueryDefaultLocale, 2 
SYSSTUBS_ENTRY3  149, QueryDefaultLocale, 2 
SYSSTUBS_ENTRY4  149, QueryDefaultLocale, 2 
SYSSTUBS_ENTRY5  149, QueryDefaultLocale, 2 
SYSSTUBS_ENTRY6  149, QueryDefaultLocale, 2 
SYSSTUBS_ENTRY7  149, QueryDefaultLocale, 2 
SYSSTUBS_ENTRY8  149, QueryDefaultLocale, 2 
SYSSTUBS_ENTRY1  150, QueryDefaultUILanguage, 1 
SYSSTUBS_ENTRY2  150, QueryDefaultUILanguage, 1 
SYSSTUBS_ENTRY3  150, QueryDefaultUILanguage, 1 
SYSSTUBS_ENTRY4  150, QueryDefaultUILanguage, 1 
SYSSTUBS_ENTRY5  150, QueryDefaultUILanguage, 1 
SYSSTUBS_ENTRY6  150, QueryDefaultUILanguage, 1 
SYSSTUBS_ENTRY7  150, QueryDefaultUILanguage, 1 
SYSSTUBS_ENTRY8  150, QueryDefaultUILanguage, 1 
SYSSTUBS_ENTRY1  151, QueryDirectoryFile, 11 
SYSSTUBS_ENTRY2  151, QueryDirectoryFile, 11 
SYSSTUBS_ENTRY3  151, QueryDirectoryFile, 11 
SYSSTUBS_ENTRY4  151, QueryDirectoryFile, 11 
SYSSTUBS_ENTRY5  151, QueryDirectoryFile, 11 
SYSSTUBS_ENTRY6  151, QueryDirectoryFile, 11 
SYSSTUBS_ENTRY7  151, QueryDirectoryFile, 11 
SYSSTUBS_ENTRY8  151, QueryDirectoryFile, 11 
SYSSTUBS_ENTRY1  152, QueryDirectoryObject, 7 
SYSSTUBS_ENTRY2  152, QueryDirectoryObject, 7 
SYSSTUBS_ENTRY3  152, QueryDirectoryObject, 7 
SYSSTUBS_ENTRY4  152, QueryDirectoryObject, 7 
SYSSTUBS_ENTRY5  152, QueryDirectoryObject, 7 
SYSSTUBS_ENTRY6  152, QueryDirectoryObject, 7 
SYSSTUBS_ENTRY7  152, QueryDirectoryObject, 7 
SYSSTUBS_ENTRY8  152, QueryDirectoryObject, 7 
SYSSTUBS_ENTRY1  153, QueryDriverEntryOrder, 2 
SYSSTUBS_ENTRY2  153, QueryDriverEntryOrder, 2 
SYSSTUBS_ENTRY3  153, QueryDriverEntryOrder, 2 
SYSSTUBS_ENTRY4  153, QueryDriverEntryOrder, 2 
SYSSTUBS_ENTRY5  153, QueryDriverEntryOrder, 2 
SYSSTUBS_ENTRY6  153, QueryDriverEntryOrder, 2 
SYSSTUBS_ENTRY7  153, QueryDriverEntryOrder, 2 
SYSSTUBS_ENTRY8  153, QueryDriverEntryOrder, 2 
SYSSTUBS_ENTRY1  154, QueryEaFile, 9 
SYSSTUBS_ENTRY2  154, QueryEaFile, 9 
SYSSTUBS_ENTRY3  154, QueryEaFile, 9 
SYSSTUBS_ENTRY4  154, QueryEaFile, 9 
SYSSTUBS_ENTRY5  154, QueryEaFile, 9 
SYSSTUBS_ENTRY6  154, QueryEaFile, 9 
SYSSTUBS_ENTRY7  154, QueryEaFile, 9 
SYSSTUBS_ENTRY8  154, QueryEaFile, 9 
SYSSTUBS_ENTRY1  155, QueryEvent, 5 
SYSSTUBS_ENTRY2  155, QueryEvent, 5 
SYSSTUBS_ENTRY3  155, QueryEvent, 5 
SYSSTUBS_ENTRY4  155, QueryEvent, 5 
SYSSTUBS_ENTRY5  155, QueryEvent, 5 
SYSSTUBS_ENTRY6  155, QueryEvent, 5 
SYSSTUBS_ENTRY7  155, QueryEvent, 5 
SYSSTUBS_ENTRY8  155, QueryEvent, 5 
SYSSTUBS_ENTRY1  156, QueryFullAttributesFile, 2 
SYSSTUBS_ENTRY2  156, QueryFullAttributesFile, 2 
SYSSTUBS_ENTRY3  156, QueryFullAttributesFile, 2 
SYSSTUBS_ENTRY4  156, QueryFullAttributesFile, 2 
SYSSTUBS_ENTRY5  156, QueryFullAttributesFile, 2 
SYSSTUBS_ENTRY6  156, QueryFullAttributesFile, 2 
SYSSTUBS_ENTRY7  156, QueryFullAttributesFile, 2 
SYSSTUBS_ENTRY8  156, QueryFullAttributesFile, 2 
SYSSTUBS_ENTRY1  157, QueryInformationAtom, 5 
SYSSTUBS_ENTRY2  157, QueryInformationAtom, 5 
SYSSTUBS_ENTRY3  157, QueryInformationAtom, 5 
SYSSTUBS_ENTRY4  157, QueryInformationAtom, 5 
SYSSTUBS_ENTRY5  157, QueryInformationAtom, 5 
SYSSTUBS_ENTRY6  157, QueryInformationAtom, 5 
SYSSTUBS_ENTRY7  157, QueryInformationAtom, 5 
SYSSTUBS_ENTRY8  157, QueryInformationAtom, 5 
SYSSTUBS_ENTRY1  158, QueryInformationFile, 5 
SYSSTUBS_ENTRY2  158, QueryInformationFile, 5 
SYSSTUBS_ENTRY3  158, QueryInformationFile, 5 
SYSSTUBS_ENTRY4  158, QueryInformationFile, 5 
SYSSTUBS_ENTRY5  158, QueryInformationFile, 5 
SYSSTUBS_ENTRY6  158, QueryInformationFile, 5 
SYSSTUBS_ENTRY7  158, QueryInformationFile, 5 
SYSSTUBS_ENTRY8  158, QueryInformationFile, 5 
SYSSTUBS_ENTRY1  159, QueryInformationJobObject, 5 
SYSSTUBS_ENTRY2  159, QueryInformationJobObject, 5 
SYSSTUBS_ENTRY3  159, QueryInformationJobObject, 5 
SYSSTUBS_ENTRY4  159, QueryInformationJobObject, 5 
SYSSTUBS_ENTRY5  159, QueryInformationJobObject, 5 
SYSSTUBS_ENTRY6  159, QueryInformationJobObject, 5 
SYSSTUBS_ENTRY7  159, QueryInformationJobObject, 5 
SYSSTUBS_ENTRY8  159, QueryInformationJobObject, 5 
SYSSTUBS_ENTRY1  160, QueryInformationPort, 5 
SYSSTUBS_ENTRY2  160, QueryInformationPort, 5 
SYSSTUBS_ENTRY3  160, QueryInformationPort, 5 
SYSSTUBS_ENTRY4  160, QueryInformationPort, 5 
SYSSTUBS_ENTRY5  160, QueryInformationPort, 5 
SYSSTUBS_ENTRY6  160, QueryInformationPort, 5 
SYSSTUBS_ENTRY7  160, QueryInformationPort, 5 
SYSSTUBS_ENTRY8  160, QueryInformationPort, 5 
SYSSTUBS_ENTRY1  161, QueryInformationProcess, 5 
SYSSTUBS_ENTRY2  161, QueryInformationProcess, 5 
SYSSTUBS_ENTRY3  161, QueryInformationProcess, 5 
SYSSTUBS_ENTRY4  161, QueryInformationProcess, 5 
SYSSTUBS_ENTRY5  161, QueryInformationProcess, 5 
SYSSTUBS_ENTRY6  161, QueryInformationProcess, 5 
SYSSTUBS_ENTRY7  161, QueryInformationProcess, 5 
SYSSTUBS_ENTRY8  161, QueryInformationProcess, 5 
SYSSTUBS_ENTRY1  162, QueryInformationThread, 5 
SYSSTUBS_ENTRY2  162, QueryInformationThread, 5 
SYSSTUBS_ENTRY3  162, QueryInformationThread, 5 
SYSSTUBS_ENTRY4  162, QueryInformationThread, 5 
SYSSTUBS_ENTRY5  162, QueryInformationThread, 5 
SYSSTUBS_ENTRY6  162, QueryInformationThread, 5 
SYSSTUBS_ENTRY7  162, QueryInformationThread, 5 
SYSSTUBS_ENTRY8  162, QueryInformationThread, 5 
SYSSTUBS_ENTRY1  163, QueryInformationToken, 5 
SYSSTUBS_ENTRY2  163, QueryInformationToken, 5 
SYSSTUBS_ENTRY3  163, QueryInformationToken, 5 
SYSSTUBS_ENTRY4  163, QueryInformationToken, 5 
SYSSTUBS_ENTRY5  163, QueryInformationToken, 5 
SYSSTUBS_ENTRY6  163, QueryInformationToken, 5 
SYSSTUBS_ENTRY7  163, QueryInformationToken, 5 
SYSSTUBS_ENTRY8  163, QueryInformationToken, 5 
SYSSTUBS_ENTRY1  164, QueryInstallUILanguage, 1 
SYSSTUBS_ENTRY2  164, QueryInstallUILanguage, 1 
SYSSTUBS_ENTRY3  164, QueryInstallUILanguage, 1 
SYSSTUBS_ENTRY4  164, QueryInstallUILanguage, 1 
SYSSTUBS_ENTRY5  164, QueryInstallUILanguage, 1 
SYSSTUBS_ENTRY6  164, QueryInstallUILanguage, 1 
SYSSTUBS_ENTRY7  164, QueryInstallUILanguage, 1 
SYSSTUBS_ENTRY8  164, QueryInstallUILanguage, 1 
SYSSTUBS_ENTRY1  165, QueryIntervalProfile, 2 
SYSSTUBS_ENTRY2  165, QueryIntervalProfile, 2 
SYSSTUBS_ENTRY3  165, QueryIntervalProfile, 2 
SYSSTUBS_ENTRY4  165, QueryIntervalProfile, 2 
SYSSTUBS_ENTRY5  165, QueryIntervalProfile, 2 
SYSSTUBS_ENTRY6  165, QueryIntervalProfile, 2 
SYSSTUBS_ENTRY7  165, QueryIntervalProfile, 2 
SYSSTUBS_ENTRY8  165, QueryIntervalProfile, 2 
SYSSTUBS_ENTRY1  166, QueryIoCompletion, 5 
SYSSTUBS_ENTRY2  166, QueryIoCompletion, 5 
SYSSTUBS_ENTRY3  166, QueryIoCompletion, 5 
SYSSTUBS_ENTRY4  166, QueryIoCompletion, 5 
SYSSTUBS_ENTRY5  166, QueryIoCompletion, 5 
SYSSTUBS_ENTRY6  166, QueryIoCompletion, 5 
SYSSTUBS_ENTRY7  166, QueryIoCompletion, 5 
SYSSTUBS_ENTRY8  166, QueryIoCompletion, 5 
SYSSTUBS_ENTRY1  167, QueryKey, 5 
SYSSTUBS_ENTRY2  167, QueryKey, 5 
SYSSTUBS_ENTRY3  167, QueryKey, 5 
SYSSTUBS_ENTRY4  167, QueryKey, 5 
SYSSTUBS_ENTRY5  167, QueryKey, 5 
SYSSTUBS_ENTRY6  167, QueryKey, 5 
SYSSTUBS_ENTRY7  167, QueryKey, 5 
SYSSTUBS_ENTRY8  167, QueryKey, 5 
SYSSTUBS_ENTRY1  168, QueryMultipleValueKey, 6 
SYSSTUBS_ENTRY2  168, QueryMultipleValueKey, 6 
SYSSTUBS_ENTRY3  168, QueryMultipleValueKey, 6 
SYSSTUBS_ENTRY4  168, QueryMultipleValueKey, 6 
SYSSTUBS_ENTRY5  168, QueryMultipleValueKey, 6 
SYSSTUBS_ENTRY6  168, QueryMultipleValueKey, 6 
SYSSTUBS_ENTRY7  168, QueryMultipleValueKey, 6 
SYSSTUBS_ENTRY8  168, QueryMultipleValueKey, 6 
SYSSTUBS_ENTRY1  169, QueryMutant, 5 
SYSSTUBS_ENTRY2  169, QueryMutant, 5 
SYSSTUBS_ENTRY3  169, QueryMutant, 5 
SYSSTUBS_ENTRY4  169, QueryMutant, 5 
SYSSTUBS_ENTRY5  169, QueryMutant, 5 
SYSSTUBS_ENTRY6  169, QueryMutant, 5 
SYSSTUBS_ENTRY7  169, QueryMutant, 5 
SYSSTUBS_ENTRY8  169, QueryMutant, 5 
SYSSTUBS_ENTRY1  170, QueryObject, 5 
SYSSTUBS_ENTRY2  170, QueryObject, 5 
SYSSTUBS_ENTRY3  170, QueryObject, 5 
SYSSTUBS_ENTRY4  170, QueryObject, 5 
SYSSTUBS_ENTRY5  170, QueryObject, 5 
SYSSTUBS_ENTRY6  170, QueryObject, 5 
SYSSTUBS_ENTRY7  170, QueryObject, 5 
SYSSTUBS_ENTRY8  170, QueryObject, 5 
SYSSTUBS_ENTRY1  171, QueryOpenSubKeys, 2 
SYSSTUBS_ENTRY2  171, QueryOpenSubKeys, 2 
SYSSTUBS_ENTRY3  171, QueryOpenSubKeys, 2 
SYSSTUBS_ENTRY4  171, QueryOpenSubKeys, 2 
SYSSTUBS_ENTRY5  171, QueryOpenSubKeys, 2 
SYSSTUBS_ENTRY6  171, QueryOpenSubKeys, 2 
SYSSTUBS_ENTRY7  171, QueryOpenSubKeys, 2 
SYSSTUBS_ENTRY8  171, QueryOpenSubKeys, 2 
SYSSTUBS_ENTRY1  172, QueryOpenSubKeysEx, 4 
SYSSTUBS_ENTRY2  172, QueryOpenSubKeysEx, 4 
SYSSTUBS_ENTRY3  172, QueryOpenSubKeysEx, 4 
SYSSTUBS_ENTRY4  172, QueryOpenSubKeysEx, 4 
SYSSTUBS_ENTRY5  172, QueryOpenSubKeysEx, 4 
SYSSTUBS_ENTRY6  172, QueryOpenSubKeysEx, 4 
SYSSTUBS_ENTRY7  172, QueryOpenSubKeysEx, 4 
SYSSTUBS_ENTRY8  172, QueryOpenSubKeysEx, 4 
SYSSTUBS_ENTRY1  173, QueryPerformanceCounter, 2 
SYSSTUBS_ENTRY2  173, QueryPerformanceCounter, 2 
SYSSTUBS_ENTRY3  173, QueryPerformanceCounter, 2 
SYSSTUBS_ENTRY4  173, QueryPerformanceCounter, 2 
SYSSTUBS_ENTRY5  173, QueryPerformanceCounter, 2 
SYSSTUBS_ENTRY6  173, QueryPerformanceCounter, 2 
SYSSTUBS_ENTRY7  173, QueryPerformanceCounter, 2 
SYSSTUBS_ENTRY8  173, QueryPerformanceCounter, 2 
SYSSTUBS_ENTRY1  174, QueryQuotaInformationFile, 9 
SYSSTUBS_ENTRY2  174, QueryQuotaInformationFile, 9 
SYSSTUBS_ENTRY3  174, QueryQuotaInformationFile, 9 
SYSSTUBS_ENTRY4  174, QueryQuotaInformationFile, 9 
SYSSTUBS_ENTRY5  174, QueryQuotaInformationFile, 9 
SYSSTUBS_ENTRY6  174, QueryQuotaInformationFile, 9 
SYSSTUBS_ENTRY7  174, QueryQuotaInformationFile, 9 
SYSSTUBS_ENTRY8  174, QueryQuotaInformationFile, 9 
SYSSTUBS_ENTRY1  175, QuerySection, 5 
SYSSTUBS_ENTRY2  175, QuerySection, 5 
SYSSTUBS_ENTRY3  175, QuerySection, 5 
SYSSTUBS_ENTRY4  175, QuerySection, 5 
SYSSTUBS_ENTRY5  175, QuerySection, 5 
SYSSTUBS_ENTRY6  175, QuerySection, 5 
SYSSTUBS_ENTRY7  175, QuerySection, 5 
SYSSTUBS_ENTRY8  175, QuerySection, 5 
SYSSTUBS_ENTRY1  176, QuerySecurityObject, 5 
SYSSTUBS_ENTRY2  176, QuerySecurityObject, 5 
SYSSTUBS_ENTRY3  176, QuerySecurityObject, 5 
SYSSTUBS_ENTRY4  176, QuerySecurityObject, 5 
SYSSTUBS_ENTRY5  176, QuerySecurityObject, 5 
SYSSTUBS_ENTRY6  176, QuerySecurityObject, 5 
SYSSTUBS_ENTRY7  176, QuerySecurityObject, 5 
SYSSTUBS_ENTRY8  176, QuerySecurityObject, 5 
SYSSTUBS_ENTRY1  177, QuerySemaphore, 5 
SYSSTUBS_ENTRY2  177, QuerySemaphore, 5 
SYSSTUBS_ENTRY3  177, QuerySemaphore, 5 
SYSSTUBS_ENTRY4  177, QuerySemaphore, 5 
SYSSTUBS_ENTRY5  177, QuerySemaphore, 5 
SYSSTUBS_ENTRY6  177, QuerySemaphore, 5 
SYSSTUBS_ENTRY7  177, QuerySemaphore, 5 
SYSSTUBS_ENTRY8  177, QuerySemaphore, 5 
SYSSTUBS_ENTRY1  178, QuerySymbolicLinkObject, 3 
SYSSTUBS_ENTRY2  178, QuerySymbolicLinkObject, 3 
SYSSTUBS_ENTRY3  178, QuerySymbolicLinkObject, 3 
SYSSTUBS_ENTRY4  178, QuerySymbolicLinkObject, 3 
SYSSTUBS_ENTRY5  178, QuerySymbolicLinkObject, 3 
SYSSTUBS_ENTRY6  178, QuerySymbolicLinkObject, 3 
SYSSTUBS_ENTRY7  178, QuerySymbolicLinkObject, 3 
SYSSTUBS_ENTRY8  178, QuerySymbolicLinkObject, 3 
SYSSTUBS_ENTRY1  179, QuerySystemEnvironmentValue, 4 
SYSSTUBS_ENTRY2  179, QuerySystemEnvironmentValue, 4 
SYSSTUBS_ENTRY3  179, QuerySystemEnvironmentValue, 4 
SYSSTUBS_ENTRY4  179, QuerySystemEnvironmentValue, 4 
SYSSTUBS_ENTRY5  179, QuerySystemEnvironmentValue, 4 
SYSSTUBS_ENTRY6  179, QuerySystemEnvironmentValue, 4 
SYSSTUBS_ENTRY7  179, QuerySystemEnvironmentValue, 4 
SYSSTUBS_ENTRY8  179, QuerySystemEnvironmentValue, 4 
SYSSTUBS_ENTRY1  180, QuerySystemEnvironmentValueEx, 5 
SYSSTUBS_ENTRY2  180, QuerySystemEnvironmentValueEx, 5 
SYSSTUBS_ENTRY3  180, QuerySystemEnvironmentValueEx, 5 
SYSSTUBS_ENTRY4  180, QuerySystemEnvironmentValueEx, 5 
SYSSTUBS_ENTRY5  180, QuerySystemEnvironmentValueEx, 5 
SYSSTUBS_ENTRY6  180, QuerySystemEnvironmentValueEx, 5 
SYSSTUBS_ENTRY7  180, QuerySystemEnvironmentValueEx, 5 
SYSSTUBS_ENTRY8  180, QuerySystemEnvironmentValueEx, 5 
SYSSTUBS_ENTRY1  181, QuerySystemInformation, 4 
SYSSTUBS_ENTRY2  181, QuerySystemInformation, 4 
SYSSTUBS_ENTRY3  181, QuerySystemInformation, 4 
SYSSTUBS_ENTRY4  181, QuerySystemInformation, 4 
SYSSTUBS_ENTRY5  181, QuerySystemInformation, 4 
SYSSTUBS_ENTRY6  181, QuerySystemInformation, 4 
SYSSTUBS_ENTRY7  181, QuerySystemInformation, 4 
SYSSTUBS_ENTRY8  181, QuerySystemInformation, 4 
SYSSTUBS_ENTRY1  182, QuerySystemTime, 1 
SYSSTUBS_ENTRY2  182, QuerySystemTime, 1 
SYSSTUBS_ENTRY3  182, QuerySystemTime, 1 
SYSSTUBS_ENTRY4  182, QuerySystemTime, 1 
SYSSTUBS_ENTRY5  182, QuerySystemTime, 1 
SYSSTUBS_ENTRY6  182, QuerySystemTime, 1 
SYSSTUBS_ENTRY7  182, QuerySystemTime, 1 
SYSSTUBS_ENTRY8  182, QuerySystemTime, 1 
SYSSTUBS_ENTRY1  183, QueryTimer, 5 
SYSSTUBS_ENTRY2  183, QueryTimer, 5 
SYSSTUBS_ENTRY3  183, QueryTimer, 5 
SYSSTUBS_ENTRY4  183, QueryTimer, 5 
SYSSTUBS_ENTRY5  183, QueryTimer, 5 
SYSSTUBS_ENTRY6  183, QueryTimer, 5 
SYSSTUBS_ENTRY7  183, QueryTimer, 5 
SYSSTUBS_ENTRY8  183, QueryTimer, 5 
SYSSTUBS_ENTRY1  184, QueryTimerResolution, 3 
SYSSTUBS_ENTRY2  184, QueryTimerResolution, 3 
SYSSTUBS_ENTRY3  184, QueryTimerResolution, 3 
SYSSTUBS_ENTRY4  184, QueryTimerResolution, 3 
SYSSTUBS_ENTRY5  184, QueryTimerResolution, 3 
SYSSTUBS_ENTRY6  184, QueryTimerResolution, 3 
SYSSTUBS_ENTRY7  184, QueryTimerResolution, 3 
SYSSTUBS_ENTRY8  184, QueryTimerResolution, 3 
SYSSTUBS_ENTRY1  185, QueryValueKey, 6 
SYSSTUBS_ENTRY2  185, QueryValueKey, 6 
SYSSTUBS_ENTRY3  185, QueryValueKey, 6 
SYSSTUBS_ENTRY4  185, QueryValueKey, 6 
SYSSTUBS_ENTRY5  185, QueryValueKey, 6 
SYSSTUBS_ENTRY6  185, QueryValueKey, 6 
SYSSTUBS_ENTRY7  185, QueryValueKey, 6 
SYSSTUBS_ENTRY8  185, QueryValueKey, 6 
SYSSTUBS_ENTRY1  186, QueryVirtualMemory, 6 
SYSSTUBS_ENTRY2  186, QueryVirtualMemory, 6 
SYSSTUBS_ENTRY3  186, QueryVirtualMemory, 6 
SYSSTUBS_ENTRY4  186, QueryVirtualMemory, 6 
SYSSTUBS_ENTRY5  186, QueryVirtualMemory, 6 
SYSSTUBS_ENTRY6  186, QueryVirtualMemory, 6 
SYSSTUBS_ENTRY7  186, QueryVirtualMemory, 6 
SYSSTUBS_ENTRY8  186, QueryVirtualMemory, 6 
SYSSTUBS_ENTRY1  187, QueryVolumeInformationFile, 5 
SYSSTUBS_ENTRY2  187, QueryVolumeInformationFile, 5 
SYSSTUBS_ENTRY3  187, QueryVolumeInformationFile, 5 
SYSSTUBS_ENTRY4  187, QueryVolumeInformationFile, 5 
SYSSTUBS_ENTRY5  187, QueryVolumeInformationFile, 5 
SYSSTUBS_ENTRY6  187, QueryVolumeInformationFile, 5 
SYSSTUBS_ENTRY7  187, QueryVolumeInformationFile, 5 
SYSSTUBS_ENTRY8  187, QueryVolumeInformationFile, 5 
SYSSTUBS_ENTRY1  188, QueueApcThread, 5 
SYSSTUBS_ENTRY2  188, QueueApcThread, 5 
SYSSTUBS_ENTRY3  188, QueueApcThread, 5 
SYSSTUBS_ENTRY4  188, QueueApcThread, 5 
SYSSTUBS_ENTRY5  188, QueueApcThread, 5 
SYSSTUBS_ENTRY6  188, QueueApcThread, 5 
SYSSTUBS_ENTRY7  188, QueueApcThread, 5 
SYSSTUBS_ENTRY8  188, QueueApcThread, 5 
SYSSTUBS_ENTRY1  189, RaiseException, 3 
SYSSTUBS_ENTRY2  189, RaiseException, 3 
SYSSTUBS_ENTRY3  189, RaiseException, 3 
SYSSTUBS_ENTRY4  189, RaiseException, 3 
SYSSTUBS_ENTRY5  189, RaiseException, 3 
SYSSTUBS_ENTRY6  189, RaiseException, 3 
SYSSTUBS_ENTRY7  189, RaiseException, 3 
SYSSTUBS_ENTRY8  189, RaiseException, 3 
SYSSTUBS_ENTRY1  190, RaiseHardError, 6 
SYSSTUBS_ENTRY2  190, RaiseHardError, 6 
SYSSTUBS_ENTRY3  190, RaiseHardError, 6 
SYSSTUBS_ENTRY4  190, RaiseHardError, 6 
SYSSTUBS_ENTRY5  190, RaiseHardError, 6 
SYSSTUBS_ENTRY6  190, RaiseHardError, 6 
SYSSTUBS_ENTRY7  190, RaiseHardError, 6 
SYSSTUBS_ENTRY8  190, RaiseHardError, 6 
SYSSTUBS_ENTRY1  191, ReadFile, 9 
SYSSTUBS_ENTRY2  191, ReadFile, 9 
SYSSTUBS_ENTRY3  191, ReadFile, 9 
SYSSTUBS_ENTRY4  191, ReadFile, 9 
SYSSTUBS_ENTRY5  191, ReadFile, 9 
SYSSTUBS_ENTRY6  191, ReadFile, 9 
SYSSTUBS_ENTRY7  191, ReadFile, 9 
SYSSTUBS_ENTRY8  191, ReadFile, 9 
SYSSTUBS_ENTRY1  192, ReadFileScatter, 9 
SYSSTUBS_ENTRY2  192, ReadFileScatter, 9 
SYSSTUBS_ENTRY3  192, ReadFileScatter, 9 
SYSSTUBS_ENTRY4  192, ReadFileScatter, 9 
SYSSTUBS_ENTRY5  192, ReadFileScatter, 9 
SYSSTUBS_ENTRY6  192, ReadFileScatter, 9 
SYSSTUBS_ENTRY7  192, ReadFileScatter, 9 
SYSSTUBS_ENTRY8  192, ReadFileScatter, 9 
SYSSTUBS_ENTRY1  193, ReadRequestData, 6 
SYSSTUBS_ENTRY2  193, ReadRequestData, 6 
SYSSTUBS_ENTRY3  193, ReadRequestData, 6 
SYSSTUBS_ENTRY4  193, ReadRequestData, 6 
SYSSTUBS_ENTRY5  193, ReadRequestData, 6 
SYSSTUBS_ENTRY6  193, ReadRequestData, 6 
SYSSTUBS_ENTRY7  193, ReadRequestData, 6 
SYSSTUBS_ENTRY8  193, ReadRequestData, 6 
SYSSTUBS_ENTRY1  194, ReadVirtualMemory, 5 
SYSSTUBS_ENTRY2  194, ReadVirtualMemory, 5 
SYSSTUBS_ENTRY3  194, ReadVirtualMemory, 5 
SYSSTUBS_ENTRY4  194, ReadVirtualMemory, 5 
SYSSTUBS_ENTRY5  194, ReadVirtualMemory, 5 
SYSSTUBS_ENTRY6  194, ReadVirtualMemory, 5 
SYSSTUBS_ENTRY7  194, ReadVirtualMemory, 5 
SYSSTUBS_ENTRY8  194, ReadVirtualMemory, 5 
SYSSTUBS_ENTRY1  195, RegisterThreadTerminatePort, 1 
SYSSTUBS_ENTRY2  195, RegisterThreadTerminatePort, 1 
SYSSTUBS_ENTRY3  195, RegisterThreadTerminatePort, 1 
SYSSTUBS_ENTRY4  195, RegisterThreadTerminatePort, 1 
SYSSTUBS_ENTRY5  195, RegisterThreadTerminatePort, 1 
SYSSTUBS_ENTRY6  195, RegisterThreadTerminatePort, 1 
SYSSTUBS_ENTRY7  195, RegisterThreadTerminatePort, 1 
SYSSTUBS_ENTRY8  195, RegisterThreadTerminatePort, 1 
SYSSTUBS_ENTRY1  196, ReleaseMutant, 2 
SYSSTUBS_ENTRY2  196, ReleaseMutant, 2 
SYSSTUBS_ENTRY3  196, ReleaseMutant, 2 
SYSSTUBS_ENTRY4  196, ReleaseMutant, 2 
SYSSTUBS_ENTRY5  196, ReleaseMutant, 2 
SYSSTUBS_ENTRY6  196, ReleaseMutant, 2 
SYSSTUBS_ENTRY7  196, ReleaseMutant, 2 
SYSSTUBS_ENTRY8  196, ReleaseMutant, 2 
SYSSTUBS_ENTRY1  197, ReleaseSemaphore, 3 
SYSSTUBS_ENTRY2  197, ReleaseSemaphore, 3 
SYSSTUBS_ENTRY3  197, ReleaseSemaphore, 3 
SYSSTUBS_ENTRY4  197, ReleaseSemaphore, 3 
SYSSTUBS_ENTRY5  197, ReleaseSemaphore, 3 
SYSSTUBS_ENTRY6  197, ReleaseSemaphore, 3 
SYSSTUBS_ENTRY7  197, ReleaseSemaphore, 3 
SYSSTUBS_ENTRY8  197, ReleaseSemaphore, 3 
SYSSTUBS_ENTRY1  198, RemoveIoCompletion, 5 
SYSSTUBS_ENTRY2  198, RemoveIoCompletion, 5 
SYSSTUBS_ENTRY3  198, RemoveIoCompletion, 5 
SYSSTUBS_ENTRY4  198, RemoveIoCompletion, 5 
SYSSTUBS_ENTRY5  198, RemoveIoCompletion, 5 
SYSSTUBS_ENTRY6  198, RemoveIoCompletion, 5 
SYSSTUBS_ENTRY7  198, RemoveIoCompletion, 5 
SYSSTUBS_ENTRY8  198, RemoveIoCompletion, 5 
SYSSTUBS_ENTRY1  199, RemoveProcessDebug, 2 
SYSSTUBS_ENTRY2  199, RemoveProcessDebug, 2 
SYSSTUBS_ENTRY3  199, RemoveProcessDebug, 2 
SYSSTUBS_ENTRY4  199, RemoveProcessDebug, 2 
SYSSTUBS_ENTRY5  199, RemoveProcessDebug, 2 
SYSSTUBS_ENTRY6  199, RemoveProcessDebug, 2 
SYSSTUBS_ENTRY7  199, RemoveProcessDebug, 2 
SYSSTUBS_ENTRY8  199, RemoveProcessDebug, 2 
SYSSTUBS_ENTRY1  200, RenameKey, 2 
SYSSTUBS_ENTRY2  200, RenameKey, 2 
SYSSTUBS_ENTRY3  200, RenameKey, 2 
SYSSTUBS_ENTRY4  200, RenameKey, 2 
SYSSTUBS_ENTRY5  200, RenameKey, 2 
SYSSTUBS_ENTRY6  200, RenameKey, 2 
SYSSTUBS_ENTRY7  200, RenameKey, 2 
SYSSTUBS_ENTRY8  200, RenameKey, 2 
SYSSTUBS_ENTRY1  201, ReplaceKey, 3 
SYSSTUBS_ENTRY2  201, ReplaceKey, 3 
SYSSTUBS_ENTRY3  201, ReplaceKey, 3 
SYSSTUBS_ENTRY4  201, ReplaceKey, 3 
SYSSTUBS_ENTRY5  201, ReplaceKey, 3 
SYSSTUBS_ENTRY6  201, ReplaceKey, 3 
SYSSTUBS_ENTRY7  201, ReplaceKey, 3 
SYSSTUBS_ENTRY8  201, ReplaceKey, 3 
SYSSTUBS_ENTRY1  202, ReplyPort, 2 
SYSSTUBS_ENTRY2  202, ReplyPort, 2 
SYSSTUBS_ENTRY3  202, ReplyPort, 2 
SYSSTUBS_ENTRY4  202, ReplyPort, 2 
SYSSTUBS_ENTRY5  202, ReplyPort, 2 
SYSSTUBS_ENTRY6  202, ReplyPort, 2 
SYSSTUBS_ENTRY7  202, ReplyPort, 2 
SYSSTUBS_ENTRY8  202, ReplyPort, 2 
SYSSTUBS_ENTRY1  203, ReplyWaitReceivePort, 4 
SYSSTUBS_ENTRY2  203, ReplyWaitReceivePort, 4 
SYSSTUBS_ENTRY3  203, ReplyWaitReceivePort, 4 
SYSSTUBS_ENTRY4  203, ReplyWaitReceivePort, 4 
SYSSTUBS_ENTRY5  203, ReplyWaitReceivePort, 4 
SYSSTUBS_ENTRY6  203, ReplyWaitReceivePort, 4 
SYSSTUBS_ENTRY7  203, ReplyWaitReceivePort, 4 
SYSSTUBS_ENTRY8  203, ReplyWaitReceivePort, 4 
SYSSTUBS_ENTRY1  204, ReplyWaitReceivePortEx, 5 
SYSSTUBS_ENTRY2  204, ReplyWaitReceivePortEx, 5 
SYSSTUBS_ENTRY3  204, ReplyWaitReceivePortEx, 5 
SYSSTUBS_ENTRY4  204, ReplyWaitReceivePortEx, 5 
SYSSTUBS_ENTRY5  204, ReplyWaitReceivePortEx, 5 
SYSSTUBS_ENTRY6  204, ReplyWaitReceivePortEx, 5 
SYSSTUBS_ENTRY7  204, ReplyWaitReceivePortEx, 5 
SYSSTUBS_ENTRY8  204, ReplyWaitReceivePortEx, 5 
SYSSTUBS_ENTRY1  205, ReplyWaitReplyPort, 2 
SYSSTUBS_ENTRY2  205, ReplyWaitReplyPort, 2 
SYSSTUBS_ENTRY3  205, ReplyWaitReplyPort, 2 
SYSSTUBS_ENTRY4  205, ReplyWaitReplyPort, 2 
SYSSTUBS_ENTRY5  205, ReplyWaitReplyPort, 2 
SYSSTUBS_ENTRY6  205, ReplyWaitReplyPort, 2 
SYSSTUBS_ENTRY7  205, ReplyWaitReplyPort, 2 
SYSSTUBS_ENTRY8  205, ReplyWaitReplyPort, 2 
SYSSTUBS_ENTRY1  206, RequestDeviceWakeup, 1 
SYSSTUBS_ENTRY2  206, RequestDeviceWakeup, 1 
SYSSTUBS_ENTRY3  206, RequestDeviceWakeup, 1 
SYSSTUBS_ENTRY4  206, RequestDeviceWakeup, 1 
SYSSTUBS_ENTRY5  206, RequestDeviceWakeup, 1 
SYSSTUBS_ENTRY6  206, RequestDeviceWakeup, 1 
SYSSTUBS_ENTRY7  206, RequestDeviceWakeup, 1 
SYSSTUBS_ENTRY8  206, RequestDeviceWakeup, 1 
SYSSTUBS_ENTRY1  207, RequestPort, 2 
SYSSTUBS_ENTRY2  207, RequestPort, 2 
SYSSTUBS_ENTRY3  207, RequestPort, 2 
SYSSTUBS_ENTRY4  207, RequestPort, 2 
SYSSTUBS_ENTRY5  207, RequestPort, 2 
SYSSTUBS_ENTRY6  207, RequestPort, 2 
SYSSTUBS_ENTRY7  207, RequestPort, 2 
SYSSTUBS_ENTRY8  207, RequestPort, 2 
SYSSTUBS_ENTRY1  208, RequestWaitReplyPort, 3 
SYSSTUBS_ENTRY2  208, RequestWaitReplyPort, 3 
SYSSTUBS_ENTRY3  208, RequestWaitReplyPort, 3 
SYSSTUBS_ENTRY4  208, RequestWaitReplyPort, 3 
SYSSTUBS_ENTRY5  208, RequestWaitReplyPort, 3 
SYSSTUBS_ENTRY6  208, RequestWaitReplyPort, 3 
SYSSTUBS_ENTRY7  208, RequestWaitReplyPort, 3 
SYSSTUBS_ENTRY8  208, RequestWaitReplyPort, 3 
SYSSTUBS_ENTRY1  209, RequestWakeupLatency, 1 
SYSSTUBS_ENTRY2  209, RequestWakeupLatency, 1 
SYSSTUBS_ENTRY3  209, RequestWakeupLatency, 1 
SYSSTUBS_ENTRY4  209, RequestWakeupLatency, 1 
SYSSTUBS_ENTRY5  209, RequestWakeupLatency, 1 
SYSSTUBS_ENTRY6  209, RequestWakeupLatency, 1 
SYSSTUBS_ENTRY7  209, RequestWakeupLatency, 1 
SYSSTUBS_ENTRY8  209, RequestWakeupLatency, 1 
SYSSTUBS_ENTRY1  210, ResetEvent, 2 
SYSSTUBS_ENTRY2  210, ResetEvent, 2 
SYSSTUBS_ENTRY3  210, ResetEvent, 2 
SYSSTUBS_ENTRY4  210, ResetEvent, 2 
SYSSTUBS_ENTRY5  210, ResetEvent, 2 
SYSSTUBS_ENTRY6  210, ResetEvent, 2 
SYSSTUBS_ENTRY7  210, ResetEvent, 2 
SYSSTUBS_ENTRY8  210, ResetEvent, 2 
SYSSTUBS_ENTRY1  211, ResetWriteWatch, 3 
SYSSTUBS_ENTRY2  211, ResetWriteWatch, 3 
SYSSTUBS_ENTRY3  211, ResetWriteWatch, 3 
SYSSTUBS_ENTRY4  211, ResetWriteWatch, 3 
SYSSTUBS_ENTRY5  211, ResetWriteWatch, 3 
SYSSTUBS_ENTRY6  211, ResetWriteWatch, 3 
SYSSTUBS_ENTRY7  211, ResetWriteWatch, 3 
SYSSTUBS_ENTRY8  211, ResetWriteWatch, 3 
SYSSTUBS_ENTRY1  212, RestoreKey, 3 
SYSSTUBS_ENTRY2  212, RestoreKey, 3 
SYSSTUBS_ENTRY3  212, RestoreKey, 3 
SYSSTUBS_ENTRY4  212, RestoreKey, 3 
SYSSTUBS_ENTRY5  212, RestoreKey, 3 
SYSSTUBS_ENTRY6  212, RestoreKey, 3 
SYSSTUBS_ENTRY7  212, RestoreKey, 3 
SYSSTUBS_ENTRY8  212, RestoreKey, 3 
SYSSTUBS_ENTRY1  213, ResumeProcess, 1 
SYSSTUBS_ENTRY2  213, ResumeProcess, 1 
SYSSTUBS_ENTRY3  213, ResumeProcess, 1 
SYSSTUBS_ENTRY4  213, ResumeProcess, 1 
SYSSTUBS_ENTRY5  213, ResumeProcess, 1 
SYSSTUBS_ENTRY6  213, ResumeProcess, 1 
SYSSTUBS_ENTRY7  213, ResumeProcess, 1 
SYSSTUBS_ENTRY8  213, ResumeProcess, 1 
SYSSTUBS_ENTRY1  214, ResumeThread, 2 
SYSSTUBS_ENTRY2  214, ResumeThread, 2 
SYSSTUBS_ENTRY3  214, ResumeThread, 2 
SYSSTUBS_ENTRY4  214, ResumeThread, 2 
SYSSTUBS_ENTRY5  214, ResumeThread, 2 
SYSSTUBS_ENTRY6  214, ResumeThread, 2 
SYSSTUBS_ENTRY7  214, ResumeThread, 2 
SYSSTUBS_ENTRY8  214, ResumeThread, 2 
SYSSTUBS_ENTRY1  215, SaveKey, 2 
SYSSTUBS_ENTRY2  215, SaveKey, 2 
SYSSTUBS_ENTRY3  215, SaveKey, 2 
SYSSTUBS_ENTRY4  215, SaveKey, 2 
SYSSTUBS_ENTRY5  215, SaveKey, 2 
SYSSTUBS_ENTRY6  215, SaveKey, 2 
SYSSTUBS_ENTRY7  215, SaveKey, 2 
SYSSTUBS_ENTRY8  215, SaveKey, 2 
SYSSTUBS_ENTRY1  216, SaveKeyEx, 3 
SYSSTUBS_ENTRY2  216, SaveKeyEx, 3 
SYSSTUBS_ENTRY3  216, SaveKeyEx, 3 
SYSSTUBS_ENTRY4  216, SaveKeyEx, 3 
SYSSTUBS_ENTRY5  216, SaveKeyEx, 3 
SYSSTUBS_ENTRY6  216, SaveKeyEx, 3 
SYSSTUBS_ENTRY7  216, SaveKeyEx, 3 
SYSSTUBS_ENTRY8  216, SaveKeyEx, 3 
SYSSTUBS_ENTRY1  217, SaveMergedKeys, 3 
SYSSTUBS_ENTRY2  217, SaveMergedKeys, 3 
SYSSTUBS_ENTRY3  217, SaveMergedKeys, 3 
SYSSTUBS_ENTRY4  217, SaveMergedKeys, 3 
SYSSTUBS_ENTRY5  217, SaveMergedKeys, 3 
SYSSTUBS_ENTRY6  217, SaveMergedKeys, 3 
SYSSTUBS_ENTRY7  217, SaveMergedKeys, 3 
SYSSTUBS_ENTRY8  217, SaveMergedKeys, 3 
SYSSTUBS_ENTRY1  218, SecureConnectPort, 9 
SYSSTUBS_ENTRY2  218, SecureConnectPort, 9 
SYSSTUBS_ENTRY3  218, SecureConnectPort, 9 
SYSSTUBS_ENTRY4  218, SecureConnectPort, 9 
SYSSTUBS_ENTRY5  218, SecureConnectPort, 9 
SYSSTUBS_ENTRY6  218, SecureConnectPort, 9 
SYSSTUBS_ENTRY7  218, SecureConnectPort, 9 
SYSSTUBS_ENTRY8  218, SecureConnectPort, 9 
SYSSTUBS_ENTRY1  219, SetBootEntryOrder, 2 
SYSSTUBS_ENTRY2  219, SetBootEntryOrder, 2 
SYSSTUBS_ENTRY3  219, SetBootEntryOrder, 2 
SYSSTUBS_ENTRY4  219, SetBootEntryOrder, 2 
SYSSTUBS_ENTRY5  219, SetBootEntryOrder, 2 
SYSSTUBS_ENTRY6  219, SetBootEntryOrder, 2 
SYSSTUBS_ENTRY7  219, SetBootEntryOrder, 2 
SYSSTUBS_ENTRY8  219, SetBootEntryOrder, 2 
SYSSTUBS_ENTRY1  220, SetBootOptions, 2 
SYSSTUBS_ENTRY2  220, SetBootOptions, 2 
SYSSTUBS_ENTRY3  220, SetBootOptions, 2 
SYSSTUBS_ENTRY4  220, SetBootOptions, 2 
SYSSTUBS_ENTRY5  220, SetBootOptions, 2 
SYSSTUBS_ENTRY6  220, SetBootOptions, 2 
SYSSTUBS_ENTRY7  220, SetBootOptions, 2 
SYSSTUBS_ENTRY8  220, SetBootOptions, 2 
SYSSTUBS_ENTRY1  221, SetContextThread, 2 
SYSSTUBS_ENTRY2  221, SetContextThread, 2 
SYSSTUBS_ENTRY3  221, SetContextThread, 2 
SYSSTUBS_ENTRY4  221, SetContextThread, 2 
SYSSTUBS_ENTRY5  221, SetContextThread, 2 
SYSSTUBS_ENTRY6  221, SetContextThread, 2 
SYSSTUBS_ENTRY7  221, SetContextThread, 2 
SYSSTUBS_ENTRY8  221, SetContextThread, 2 
SYSSTUBS_ENTRY1  222, SetDebugFilterState, 3 
SYSSTUBS_ENTRY2  222, SetDebugFilterState, 3 
SYSSTUBS_ENTRY3  222, SetDebugFilterState, 3 
SYSSTUBS_ENTRY4  222, SetDebugFilterState, 3 
SYSSTUBS_ENTRY5  222, SetDebugFilterState, 3 
SYSSTUBS_ENTRY6  222, SetDebugFilterState, 3 
SYSSTUBS_ENTRY7  222, SetDebugFilterState, 3 
SYSSTUBS_ENTRY8  222, SetDebugFilterState, 3 
SYSSTUBS_ENTRY1  223, SetDefaultHardErrorPort, 1 
SYSSTUBS_ENTRY2  223, SetDefaultHardErrorPort, 1 
SYSSTUBS_ENTRY3  223, SetDefaultHardErrorPort, 1 
SYSSTUBS_ENTRY4  223, SetDefaultHardErrorPort, 1 
SYSSTUBS_ENTRY5  223, SetDefaultHardErrorPort, 1 
SYSSTUBS_ENTRY6  223, SetDefaultHardErrorPort, 1 
SYSSTUBS_ENTRY7  223, SetDefaultHardErrorPort, 1 
SYSSTUBS_ENTRY8  223, SetDefaultHardErrorPort, 1 
SYSSTUBS_ENTRY1  224, SetDefaultLocale, 2 
SYSSTUBS_ENTRY2  224, SetDefaultLocale, 2 
SYSSTUBS_ENTRY3  224, SetDefaultLocale, 2 
SYSSTUBS_ENTRY4  224, SetDefaultLocale, 2 
SYSSTUBS_ENTRY5  224, SetDefaultLocale, 2 
SYSSTUBS_ENTRY6  224, SetDefaultLocale, 2 
SYSSTUBS_ENTRY7  224, SetDefaultLocale, 2 
SYSSTUBS_ENTRY8  224, SetDefaultLocale, 2 
SYSSTUBS_ENTRY1  225, SetDefaultUILanguage, 1 
SYSSTUBS_ENTRY2  225, SetDefaultUILanguage, 1 
SYSSTUBS_ENTRY3  225, SetDefaultUILanguage, 1 
SYSSTUBS_ENTRY4  225, SetDefaultUILanguage, 1 
SYSSTUBS_ENTRY5  225, SetDefaultUILanguage, 1 
SYSSTUBS_ENTRY6  225, SetDefaultUILanguage, 1 
SYSSTUBS_ENTRY7  225, SetDefaultUILanguage, 1 
SYSSTUBS_ENTRY8  225, SetDefaultUILanguage, 1 
SYSSTUBS_ENTRY1  226, SetDriverEntryOrder, 2 
SYSSTUBS_ENTRY2  226, SetDriverEntryOrder, 2 
SYSSTUBS_ENTRY3  226, SetDriverEntryOrder, 2 
SYSSTUBS_ENTRY4  226, SetDriverEntryOrder, 2 
SYSSTUBS_ENTRY5  226, SetDriverEntryOrder, 2 
SYSSTUBS_ENTRY6  226, SetDriverEntryOrder, 2 
SYSSTUBS_ENTRY7  226, SetDriverEntryOrder, 2 
SYSSTUBS_ENTRY8  226, SetDriverEntryOrder, 2 
SYSSTUBS_ENTRY1  227, SetEaFile, 4 
SYSSTUBS_ENTRY2  227, SetEaFile, 4 
SYSSTUBS_ENTRY3  227, SetEaFile, 4 
SYSSTUBS_ENTRY4  227, SetEaFile, 4 
SYSSTUBS_ENTRY5  227, SetEaFile, 4 
SYSSTUBS_ENTRY6  227, SetEaFile, 4 
SYSSTUBS_ENTRY7  227, SetEaFile, 4 
SYSSTUBS_ENTRY8  227, SetEaFile, 4 
SYSSTUBS_ENTRY1  228, SetEvent, 2 
SYSSTUBS_ENTRY2  228, SetEvent, 2 
SYSSTUBS_ENTRY3  228, SetEvent, 2 
SYSSTUBS_ENTRY4  228, SetEvent, 2 
SYSSTUBS_ENTRY5  228, SetEvent, 2 
SYSSTUBS_ENTRY6  228, SetEvent, 2 
SYSSTUBS_ENTRY7  228, SetEvent, 2 
SYSSTUBS_ENTRY8  228, SetEvent, 2 
SYSSTUBS_ENTRY1  229, SetEventBoostPriority, 1 
SYSSTUBS_ENTRY2  229, SetEventBoostPriority, 1 
SYSSTUBS_ENTRY3  229, SetEventBoostPriority, 1 
SYSSTUBS_ENTRY4  229, SetEventBoostPriority, 1 
SYSSTUBS_ENTRY5  229, SetEventBoostPriority, 1 
SYSSTUBS_ENTRY6  229, SetEventBoostPriority, 1 
SYSSTUBS_ENTRY7  229, SetEventBoostPriority, 1 
SYSSTUBS_ENTRY8  229, SetEventBoostPriority, 1 
SYSSTUBS_ENTRY1  230, SetHighEventPair, 1 
SYSSTUBS_ENTRY2  230, SetHighEventPair, 1 
SYSSTUBS_ENTRY3  230, SetHighEventPair, 1 
SYSSTUBS_ENTRY4  230, SetHighEventPair, 1 
SYSSTUBS_ENTRY5  230, SetHighEventPair, 1 
SYSSTUBS_ENTRY6  230, SetHighEventPair, 1 
SYSSTUBS_ENTRY7  230, SetHighEventPair, 1 
SYSSTUBS_ENTRY8  230, SetHighEventPair, 1 
SYSSTUBS_ENTRY1  231, SetHighWaitLowEventPair, 1 
SYSSTUBS_ENTRY2  231, SetHighWaitLowEventPair, 1 
SYSSTUBS_ENTRY3  231, SetHighWaitLowEventPair, 1 
SYSSTUBS_ENTRY4  231, SetHighWaitLowEventPair, 1 
SYSSTUBS_ENTRY5  231, SetHighWaitLowEventPair, 1 
SYSSTUBS_ENTRY6  231, SetHighWaitLowEventPair, 1 
SYSSTUBS_ENTRY7  231, SetHighWaitLowEventPair, 1 
SYSSTUBS_ENTRY8  231, SetHighWaitLowEventPair, 1 
SYSSTUBS_ENTRY1  232, SetInformationDebugObject, 5 
SYSSTUBS_ENTRY2  232, SetInformationDebugObject, 5 
SYSSTUBS_ENTRY3  232, SetInformationDebugObject, 5 
SYSSTUBS_ENTRY4  232, SetInformationDebugObject, 5 
SYSSTUBS_ENTRY5  232, SetInformationDebugObject, 5 
SYSSTUBS_ENTRY6  232, SetInformationDebugObject, 5 
SYSSTUBS_ENTRY7  232, SetInformationDebugObject, 5 
SYSSTUBS_ENTRY8  232, SetInformationDebugObject, 5 
SYSSTUBS_ENTRY1  233, SetInformationFile, 5 
SYSSTUBS_ENTRY2  233, SetInformationFile, 5 
SYSSTUBS_ENTRY3  233, SetInformationFile, 5 
SYSSTUBS_ENTRY4  233, SetInformationFile, 5 
SYSSTUBS_ENTRY5  233, SetInformationFile, 5 
SYSSTUBS_ENTRY6  233, SetInformationFile, 5 
SYSSTUBS_ENTRY7  233, SetInformationFile, 5 
SYSSTUBS_ENTRY8  233, SetInformationFile, 5 
SYSSTUBS_ENTRY1  234, SetInformationJobObject, 4 
SYSSTUBS_ENTRY2  234, SetInformationJobObject, 4 
SYSSTUBS_ENTRY3  234, SetInformationJobObject, 4 
SYSSTUBS_ENTRY4  234, SetInformationJobObject, 4 
SYSSTUBS_ENTRY5  234, SetInformationJobObject, 4 
SYSSTUBS_ENTRY6  234, SetInformationJobObject, 4 
SYSSTUBS_ENTRY7  234, SetInformationJobObject, 4 
SYSSTUBS_ENTRY8  234, SetInformationJobObject, 4 
SYSSTUBS_ENTRY1  235, SetInformationKey, 4 
SYSSTUBS_ENTRY2  235, SetInformationKey, 4 
SYSSTUBS_ENTRY3  235, SetInformationKey, 4 
SYSSTUBS_ENTRY4  235, SetInformationKey, 4 
SYSSTUBS_ENTRY5  235, SetInformationKey, 4 
SYSSTUBS_ENTRY6  235, SetInformationKey, 4 
SYSSTUBS_ENTRY7  235, SetInformationKey, 4 
SYSSTUBS_ENTRY8  235, SetInformationKey, 4 
SYSSTUBS_ENTRY1  236, SetInformationObject, 4 
SYSSTUBS_ENTRY2  236, SetInformationObject, 4 
SYSSTUBS_ENTRY3  236, SetInformationObject, 4 
SYSSTUBS_ENTRY4  236, SetInformationObject, 4 
SYSSTUBS_ENTRY5  236, SetInformationObject, 4 
SYSSTUBS_ENTRY6  236, SetInformationObject, 4 
SYSSTUBS_ENTRY7  236, SetInformationObject, 4 
SYSSTUBS_ENTRY8  236, SetInformationObject, 4 
SYSSTUBS_ENTRY1  237, SetInformationProcess, 4 
SYSSTUBS_ENTRY2  237, SetInformationProcess, 4 
SYSSTUBS_ENTRY3  237, SetInformationProcess, 4 
SYSSTUBS_ENTRY4  237, SetInformationProcess, 4 
SYSSTUBS_ENTRY5  237, SetInformationProcess, 4 
SYSSTUBS_ENTRY6  237, SetInformationProcess, 4 
SYSSTUBS_ENTRY7  237, SetInformationProcess, 4 
SYSSTUBS_ENTRY8  237, SetInformationProcess, 4 
SYSSTUBS_ENTRY1  238, SetInformationThread, 4 
SYSSTUBS_ENTRY2  238, SetInformationThread, 4 
SYSSTUBS_ENTRY3  238, SetInformationThread, 4 
SYSSTUBS_ENTRY4  238, SetInformationThread, 4 
SYSSTUBS_ENTRY5  238, SetInformationThread, 4 
SYSSTUBS_ENTRY6  238, SetInformationThread, 4 
SYSSTUBS_ENTRY7  238, SetInformationThread, 4 
SYSSTUBS_ENTRY8  238, SetInformationThread, 4 
SYSSTUBS_ENTRY1  239, SetInformationToken, 4 
SYSSTUBS_ENTRY2  239, SetInformationToken, 4 
SYSSTUBS_ENTRY3  239, SetInformationToken, 4 
SYSSTUBS_ENTRY4  239, SetInformationToken, 4 
SYSSTUBS_ENTRY5  239, SetInformationToken, 4 
SYSSTUBS_ENTRY6  239, SetInformationToken, 4 
SYSSTUBS_ENTRY7  239, SetInformationToken, 4 
SYSSTUBS_ENTRY8  239, SetInformationToken, 4 
SYSSTUBS_ENTRY1  240, SetIntervalProfile, 2 
SYSSTUBS_ENTRY2  240, SetIntervalProfile, 2 
SYSSTUBS_ENTRY3  240, SetIntervalProfile, 2 
SYSSTUBS_ENTRY4  240, SetIntervalProfile, 2 
SYSSTUBS_ENTRY5  240, SetIntervalProfile, 2 
SYSSTUBS_ENTRY6  240, SetIntervalProfile, 2 
SYSSTUBS_ENTRY7  240, SetIntervalProfile, 2 
SYSSTUBS_ENTRY8  240, SetIntervalProfile, 2 
SYSSTUBS_ENTRY1  241, SetIoCompletion, 5 
SYSSTUBS_ENTRY2  241, SetIoCompletion, 5 
SYSSTUBS_ENTRY3  241, SetIoCompletion, 5 
SYSSTUBS_ENTRY4  241, SetIoCompletion, 5 
SYSSTUBS_ENTRY5  241, SetIoCompletion, 5 
SYSSTUBS_ENTRY6  241, SetIoCompletion, 5 
SYSSTUBS_ENTRY7  241, SetIoCompletion, 5 
SYSSTUBS_ENTRY8  241, SetIoCompletion, 5 
SYSSTUBS_ENTRY1  242, SetLdtEntries, 6 
SYSSTUBS_ENTRY2  242, SetLdtEntries, 6 
SYSSTUBS_ENTRY3  242, SetLdtEntries, 6 
SYSSTUBS_ENTRY4  242, SetLdtEntries, 6 
SYSSTUBS_ENTRY5  242, SetLdtEntries, 6 
SYSSTUBS_ENTRY6  242, SetLdtEntries, 6 
SYSSTUBS_ENTRY7  242, SetLdtEntries, 6 
SYSSTUBS_ENTRY8  242, SetLdtEntries, 6 
SYSSTUBS_ENTRY1  243, SetLowEventPair, 1 
SYSSTUBS_ENTRY2  243, SetLowEventPair, 1 
SYSSTUBS_ENTRY3  243, SetLowEventPair, 1 
SYSSTUBS_ENTRY4  243, SetLowEventPair, 1 
SYSSTUBS_ENTRY5  243, SetLowEventPair, 1 
SYSSTUBS_ENTRY6  243, SetLowEventPair, 1 
SYSSTUBS_ENTRY7  243, SetLowEventPair, 1 
SYSSTUBS_ENTRY8  243, SetLowEventPair, 1 
SYSSTUBS_ENTRY1  244, SetLowWaitHighEventPair, 1 
SYSSTUBS_ENTRY2  244, SetLowWaitHighEventPair, 1 
SYSSTUBS_ENTRY3  244, SetLowWaitHighEventPair, 1 
SYSSTUBS_ENTRY4  244, SetLowWaitHighEventPair, 1 
SYSSTUBS_ENTRY5  244, SetLowWaitHighEventPair, 1 
SYSSTUBS_ENTRY6  244, SetLowWaitHighEventPair, 1 
SYSSTUBS_ENTRY7  244, SetLowWaitHighEventPair, 1 
SYSSTUBS_ENTRY8  244, SetLowWaitHighEventPair, 1 
SYSSTUBS_ENTRY1  245, SetQuotaInformationFile, 4 
SYSSTUBS_ENTRY2  245, SetQuotaInformationFile, 4 
SYSSTUBS_ENTRY3  245, SetQuotaInformationFile, 4 
SYSSTUBS_ENTRY4  245, SetQuotaInformationFile, 4 
SYSSTUBS_ENTRY5  245, SetQuotaInformationFile, 4 
SYSSTUBS_ENTRY6  245, SetQuotaInformationFile, 4 
SYSSTUBS_ENTRY7  245, SetQuotaInformationFile, 4 
SYSSTUBS_ENTRY8  245, SetQuotaInformationFile, 4 
SYSSTUBS_ENTRY1  246, SetSecurityObject, 3 
SYSSTUBS_ENTRY2  246, SetSecurityObject, 3 
SYSSTUBS_ENTRY3  246, SetSecurityObject, 3 
SYSSTUBS_ENTRY4  246, SetSecurityObject, 3 
SYSSTUBS_ENTRY5  246, SetSecurityObject, 3 
SYSSTUBS_ENTRY6  246, SetSecurityObject, 3 
SYSSTUBS_ENTRY7  246, SetSecurityObject, 3 
SYSSTUBS_ENTRY8  246, SetSecurityObject, 3 
SYSSTUBS_ENTRY1  247, SetSystemEnvironmentValue, 2 
SYSSTUBS_ENTRY2  247, SetSystemEnvironmentValue, 2 
SYSSTUBS_ENTRY3  247, SetSystemEnvironmentValue, 2 
SYSSTUBS_ENTRY4  247, SetSystemEnvironmentValue, 2 
SYSSTUBS_ENTRY5  247, SetSystemEnvironmentValue, 2 
SYSSTUBS_ENTRY6  247, SetSystemEnvironmentValue, 2 
SYSSTUBS_ENTRY7  247, SetSystemEnvironmentValue, 2 
SYSSTUBS_ENTRY8  247, SetSystemEnvironmentValue, 2 
SYSSTUBS_ENTRY1  248, SetSystemEnvironmentValueEx, 5 
SYSSTUBS_ENTRY2  248, SetSystemEnvironmentValueEx, 5 
SYSSTUBS_ENTRY3  248, SetSystemEnvironmentValueEx, 5 
SYSSTUBS_ENTRY4  248, SetSystemEnvironmentValueEx, 5 
SYSSTUBS_ENTRY5  248, SetSystemEnvironmentValueEx, 5 
SYSSTUBS_ENTRY6  248, SetSystemEnvironmentValueEx, 5 
SYSSTUBS_ENTRY7  248, SetSystemEnvironmentValueEx, 5 
SYSSTUBS_ENTRY8  248, SetSystemEnvironmentValueEx, 5 
SYSSTUBS_ENTRY1  249, SetSystemInformation, 3 
SYSSTUBS_ENTRY2  249, SetSystemInformation, 3 
SYSSTUBS_ENTRY3  249, SetSystemInformation, 3 
SYSSTUBS_ENTRY4  249, SetSystemInformation, 3 
SYSSTUBS_ENTRY5  249, SetSystemInformation, 3 
SYSSTUBS_ENTRY6  249, SetSystemInformation, 3 
SYSSTUBS_ENTRY7  249, SetSystemInformation, 3 
SYSSTUBS_ENTRY8  249, SetSystemInformation, 3 
SYSSTUBS_ENTRY1  250, SetSystemPowerState, 3 
SYSSTUBS_ENTRY2  250, SetSystemPowerState, 3 
SYSSTUBS_ENTRY3  250, SetSystemPowerState, 3 
SYSSTUBS_ENTRY4  250, SetSystemPowerState, 3 
SYSSTUBS_ENTRY5  250, SetSystemPowerState, 3 
SYSSTUBS_ENTRY6  250, SetSystemPowerState, 3 
SYSSTUBS_ENTRY7  250, SetSystemPowerState, 3 
SYSSTUBS_ENTRY8  250, SetSystemPowerState, 3 
SYSSTUBS_ENTRY1  251, SetSystemTime, 2 
SYSSTUBS_ENTRY2  251, SetSystemTime, 2 
SYSSTUBS_ENTRY3  251, SetSystemTime, 2 
SYSSTUBS_ENTRY4  251, SetSystemTime, 2 
SYSSTUBS_ENTRY5  251, SetSystemTime, 2 
SYSSTUBS_ENTRY6  251, SetSystemTime, 2 
SYSSTUBS_ENTRY7  251, SetSystemTime, 2 
SYSSTUBS_ENTRY8  251, SetSystemTime, 2 
SYSSTUBS_ENTRY1  252, SetThreadExecutionState, 2 
SYSSTUBS_ENTRY2  252, SetThreadExecutionState, 2 
SYSSTUBS_ENTRY3  252, SetThreadExecutionState, 2 
SYSSTUBS_ENTRY4  252, SetThreadExecutionState, 2 
SYSSTUBS_ENTRY5  252, SetThreadExecutionState, 2 
SYSSTUBS_ENTRY6  252, SetThreadExecutionState, 2 
SYSSTUBS_ENTRY7  252, SetThreadExecutionState, 2 
SYSSTUBS_ENTRY8  252, SetThreadExecutionState, 2 
SYSSTUBS_ENTRY1  253, SetTimer, 7 
SYSSTUBS_ENTRY2  253, SetTimer, 7 
SYSSTUBS_ENTRY3  253, SetTimer, 7 
SYSSTUBS_ENTRY4  253, SetTimer, 7 
SYSSTUBS_ENTRY5  253, SetTimer, 7 
SYSSTUBS_ENTRY6  253, SetTimer, 7 
SYSSTUBS_ENTRY7  253, SetTimer, 7 
SYSSTUBS_ENTRY8  253, SetTimer, 7 
SYSSTUBS_ENTRY1  254, SetTimerResolution, 3 
SYSSTUBS_ENTRY2  254, SetTimerResolution, 3 
SYSSTUBS_ENTRY3  254, SetTimerResolution, 3 
SYSSTUBS_ENTRY4  254, SetTimerResolution, 3 
SYSSTUBS_ENTRY5  254, SetTimerResolution, 3 
SYSSTUBS_ENTRY6  254, SetTimerResolution, 3 
SYSSTUBS_ENTRY7  254, SetTimerResolution, 3 
SYSSTUBS_ENTRY8  254, SetTimerResolution, 3 
SYSSTUBS_ENTRY1  255, SetUuidSeed, 1 
SYSSTUBS_ENTRY2  255, SetUuidSeed, 1 
SYSSTUBS_ENTRY3  255, SetUuidSeed, 1 
SYSSTUBS_ENTRY4  255, SetUuidSeed, 1 
SYSSTUBS_ENTRY5  255, SetUuidSeed, 1 
SYSSTUBS_ENTRY6  255, SetUuidSeed, 1 
SYSSTUBS_ENTRY7  255, SetUuidSeed, 1 
SYSSTUBS_ENTRY8  255, SetUuidSeed, 1 
SYSSTUBS_ENTRY1  256, SetValueKey, 6 
SYSSTUBS_ENTRY2  256, SetValueKey, 6 
SYSSTUBS_ENTRY3  256, SetValueKey, 6 
SYSSTUBS_ENTRY4  256, SetValueKey, 6 
SYSSTUBS_ENTRY5  256, SetValueKey, 6 
SYSSTUBS_ENTRY6  256, SetValueKey, 6 
SYSSTUBS_ENTRY7  256, SetValueKey, 6 
SYSSTUBS_ENTRY8  256, SetValueKey, 6 
SYSSTUBS_ENTRY1  257, SetVolumeInformationFile, 5 
SYSSTUBS_ENTRY2  257, SetVolumeInformationFile, 5 
SYSSTUBS_ENTRY3  257, SetVolumeInformationFile, 5 
SYSSTUBS_ENTRY4  257, SetVolumeInformationFile, 5 
SYSSTUBS_ENTRY5  257, SetVolumeInformationFile, 5 
SYSSTUBS_ENTRY6  257, SetVolumeInformationFile, 5 
SYSSTUBS_ENTRY7  257, SetVolumeInformationFile, 5 
SYSSTUBS_ENTRY8  257, SetVolumeInformationFile, 5 
SYSSTUBS_ENTRY1  258, ShutdownSystem, 1 
SYSSTUBS_ENTRY2  258, ShutdownSystem, 1 
SYSSTUBS_ENTRY3  258, ShutdownSystem, 1 
SYSSTUBS_ENTRY4  258, ShutdownSystem, 1 
SYSSTUBS_ENTRY5  258, ShutdownSystem, 1 
SYSSTUBS_ENTRY6  258, ShutdownSystem, 1 
SYSSTUBS_ENTRY7  258, ShutdownSystem, 1 
SYSSTUBS_ENTRY8  258, ShutdownSystem, 1 
SYSSTUBS_ENTRY1  259, SignalAndWaitForSingleObject, 4 
SYSSTUBS_ENTRY2  259, SignalAndWaitForSingleObject, 4 
SYSSTUBS_ENTRY3  259, SignalAndWaitForSingleObject, 4 
SYSSTUBS_ENTRY4  259, SignalAndWaitForSingleObject, 4 
SYSSTUBS_ENTRY5  259, SignalAndWaitForSingleObject, 4 
SYSSTUBS_ENTRY6  259, SignalAndWaitForSingleObject, 4 
SYSSTUBS_ENTRY7  259, SignalAndWaitForSingleObject, 4 
SYSSTUBS_ENTRY8  259, SignalAndWaitForSingleObject, 4 
SYSSTUBS_ENTRY1  260, StartProfile, 1 
SYSSTUBS_ENTRY2  260, StartProfile, 1 
SYSSTUBS_ENTRY3  260, StartProfile, 1 
SYSSTUBS_ENTRY4  260, StartProfile, 1 
SYSSTUBS_ENTRY5  260, StartProfile, 1 
SYSSTUBS_ENTRY6  260, StartProfile, 1 
SYSSTUBS_ENTRY7  260, StartProfile, 1 
SYSSTUBS_ENTRY8  260, StartProfile, 1 
SYSSTUBS_ENTRY1  261, StopProfile, 1 
SYSSTUBS_ENTRY2  261, StopProfile, 1 
SYSSTUBS_ENTRY3  261, StopProfile, 1 
SYSSTUBS_ENTRY4  261, StopProfile, 1 
SYSSTUBS_ENTRY5  261, StopProfile, 1 
SYSSTUBS_ENTRY6  261, StopProfile, 1 
SYSSTUBS_ENTRY7  261, StopProfile, 1 
SYSSTUBS_ENTRY8  261, StopProfile, 1 
SYSSTUBS_ENTRY1  262, SuspendProcess, 1 
SYSSTUBS_ENTRY2  262, SuspendProcess, 1 
SYSSTUBS_ENTRY3  262, SuspendProcess, 1 
SYSSTUBS_ENTRY4  262, SuspendProcess, 1 
SYSSTUBS_ENTRY5  262, SuspendProcess, 1 
SYSSTUBS_ENTRY6  262, SuspendProcess, 1 
SYSSTUBS_ENTRY7  262, SuspendProcess, 1 
SYSSTUBS_ENTRY8  262, SuspendProcess, 1 
SYSSTUBS_ENTRY1  263, SuspendThread, 2 
SYSSTUBS_ENTRY2  263, SuspendThread, 2 
SYSSTUBS_ENTRY3  263, SuspendThread, 2 
SYSSTUBS_ENTRY4  263, SuspendThread, 2 
SYSSTUBS_ENTRY5  263, SuspendThread, 2 
SYSSTUBS_ENTRY6  263, SuspendThread, 2 
SYSSTUBS_ENTRY7  263, SuspendThread, 2 
SYSSTUBS_ENTRY8  263, SuspendThread, 2 
SYSSTUBS_ENTRY1  264, SystemDebugControl, 6 
SYSSTUBS_ENTRY2  264, SystemDebugControl, 6 
SYSSTUBS_ENTRY3  264, SystemDebugControl, 6 
SYSSTUBS_ENTRY4  264, SystemDebugControl, 6 
SYSSTUBS_ENTRY5  264, SystemDebugControl, 6 
SYSSTUBS_ENTRY6  264, SystemDebugControl, 6 
SYSSTUBS_ENTRY7  264, SystemDebugControl, 6 
SYSSTUBS_ENTRY8  264, SystemDebugControl, 6 
SYSSTUBS_ENTRY1  265, TerminateJobObject, 2 
SYSSTUBS_ENTRY2  265, TerminateJobObject, 2 
SYSSTUBS_ENTRY3  265, TerminateJobObject, 2 
SYSSTUBS_ENTRY4  265, TerminateJobObject, 2 
SYSSTUBS_ENTRY5  265, TerminateJobObject, 2 
SYSSTUBS_ENTRY6  265, TerminateJobObject, 2 
SYSSTUBS_ENTRY7  265, TerminateJobObject, 2 
SYSSTUBS_ENTRY8  265, TerminateJobObject, 2 
SYSSTUBS_ENTRY1  266, TerminateProcess, 2 
SYSSTUBS_ENTRY2  266, TerminateProcess, 2 
SYSSTUBS_ENTRY3  266, TerminateProcess, 2 
SYSSTUBS_ENTRY4  266, TerminateProcess, 2 
SYSSTUBS_ENTRY5  266, TerminateProcess, 2 
SYSSTUBS_ENTRY6  266, TerminateProcess, 2 
SYSSTUBS_ENTRY7  266, TerminateProcess, 2 
SYSSTUBS_ENTRY8  266, TerminateProcess, 2 
SYSSTUBS_ENTRY1  267, TerminateThread, 2 
SYSSTUBS_ENTRY2  267, TerminateThread, 2 
SYSSTUBS_ENTRY3  267, TerminateThread, 2 
SYSSTUBS_ENTRY4  267, TerminateThread, 2 
SYSSTUBS_ENTRY5  267, TerminateThread, 2 
SYSSTUBS_ENTRY6  267, TerminateThread, 2 
SYSSTUBS_ENTRY7  267, TerminateThread, 2 
SYSSTUBS_ENTRY8  267, TerminateThread, 2 
SYSSTUBS_ENTRY1  268, TestAlert, 0 
SYSSTUBS_ENTRY2  268, TestAlert, 0 
SYSSTUBS_ENTRY3  268, TestAlert, 0 
SYSSTUBS_ENTRY4  268, TestAlert, 0 
SYSSTUBS_ENTRY5  268, TestAlert, 0 
SYSSTUBS_ENTRY6  268, TestAlert, 0 
SYSSTUBS_ENTRY7  268, TestAlert, 0 
SYSSTUBS_ENTRY8  268, TestAlert, 0 
SYSSTUBS_ENTRY1  269, TraceEvent, 4 
SYSSTUBS_ENTRY2  269, TraceEvent, 4 
SYSSTUBS_ENTRY3  269, TraceEvent, 4 
SYSSTUBS_ENTRY4  269, TraceEvent, 4 
SYSSTUBS_ENTRY5  269, TraceEvent, 4 
SYSSTUBS_ENTRY6  269, TraceEvent, 4 
SYSSTUBS_ENTRY7  269, TraceEvent, 4 
SYSSTUBS_ENTRY8  269, TraceEvent, 4 
SYSSTUBS_ENTRY1  270, TranslateFilePath, 4 
SYSSTUBS_ENTRY2  270, TranslateFilePath, 4 
SYSSTUBS_ENTRY3  270, TranslateFilePath, 4 
SYSSTUBS_ENTRY4  270, TranslateFilePath, 4 
SYSSTUBS_ENTRY5  270, TranslateFilePath, 4 
SYSSTUBS_ENTRY6  270, TranslateFilePath, 4 
SYSSTUBS_ENTRY7  270, TranslateFilePath, 4 
SYSSTUBS_ENTRY8  270, TranslateFilePath, 4 
SYSSTUBS_ENTRY1  271, UnloadDriver, 1 
SYSSTUBS_ENTRY2  271, UnloadDriver, 1 
SYSSTUBS_ENTRY3  271, UnloadDriver, 1 
SYSSTUBS_ENTRY4  271, UnloadDriver, 1 
SYSSTUBS_ENTRY5  271, UnloadDriver, 1 
SYSSTUBS_ENTRY6  271, UnloadDriver, 1 
SYSSTUBS_ENTRY7  271, UnloadDriver, 1 
SYSSTUBS_ENTRY8  271, UnloadDriver, 1 
SYSSTUBS_ENTRY1  272, UnloadKey, 1 
SYSSTUBS_ENTRY2  272, UnloadKey, 1 
SYSSTUBS_ENTRY3  272, UnloadKey, 1 
SYSSTUBS_ENTRY4  272, UnloadKey, 1 
SYSSTUBS_ENTRY5  272, UnloadKey, 1 
SYSSTUBS_ENTRY6  272, UnloadKey, 1 
SYSSTUBS_ENTRY7  272, UnloadKey, 1 
SYSSTUBS_ENTRY8  272, UnloadKey, 1 
SYSSTUBS_ENTRY1  273, UnloadKey2, 2 
SYSSTUBS_ENTRY2  273, UnloadKey2, 2 
SYSSTUBS_ENTRY3  273, UnloadKey2, 2 
SYSSTUBS_ENTRY4  273, UnloadKey2, 2 
SYSSTUBS_ENTRY5  273, UnloadKey2, 2 
SYSSTUBS_ENTRY6  273, UnloadKey2, 2 
SYSSTUBS_ENTRY7  273, UnloadKey2, 2 
SYSSTUBS_ENTRY8  273, UnloadKey2, 2 
SYSSTUBS_ENTRY1  274, UnloadKeyEx, 2 
SYSSTUBS_ENTRY2  274, UnloadKeyEx, 2 
SYSSTUBS_ENTRY3  274, UnloadKeyEx, 2 
SYSSTUBS_ENTRY4  274, UnloadKeyEx, 2 
SYSSTUBS_ENTRY5  274, UnloadKeyEx, 2 
SYSSTUBS_ENTRY6  274, UnloadKeyEx, 2 
SYSSTUBS_ENTRY7  274, UnloadKeyEx, 2 
SYSSTUBS_ENTRY8  274, UnloadKeyEx, 2 
SYSSTUBS_ENTRY1  275, UnlockFile, 5 
SYSSTUBS_ENTRY2  275, UnlockFile, 5 
SYSSTUBS_ENTRY3  275, UnlockFile, 5 
SYSSTUBS_ENTRY4  275, UnlockFile, 5 
SYSSTUBS_ENTRY5  275, UnlockFile, 5 
SYSSTUBS_ENTRY6  275, UnlockFile, 5 
SYSSTUBS_ENTRY7  275, UnlockFile, 5 
SYSSTUBS_ENTRY8  275, UnlockFile, 5 
SYSSTUBS_ENTRY1  276, UnlockVirtualMemory, 4 
SYSSTUBS_ENTRY2  276, UnlockVirtualMemory, 4 
SYSSTUBS_ENTRY3  276, UnlockVirtualMemory, 4 
SYSSTUBS_ENTRY4  276, UnlockVirtualMemory, 4 
SYSSTUBS_ENTRY5  276, UnlockVirtualMemory, 4 
SYSSTUBS_ENTRY6  276, UnlockVirtualMemory, 4 
SYSSTUBS_ENTRY7  276, UnlockVirtualMemory, 4 
SYSSTUBS_ENTRY8  276, UnlockVirtualMemory, 4 
SYSSTUBS_ENTRY1  277, UnmapViewOfSection, 2 
SYSSTUBS_ENTRY2  277, UnmapViewOfSection, 2 
SYSSTUBS_ENTRY3  277, UnmapViewOfSection, 2 
SYSSTUBS_ENTRY4  277, UnmapViewOfSection, 2 
SYSSTUBS_ENTRY5  277, UnmapViewOfSection, 2 
SYSSTUBS_ENTRY6  277, UnmapViewOfSection, 2 
SYSSTUBS_ENTRY7  277, UnmapViewOfSection, 2 
SYSSTUBS_ENTRY8  277, UnmapViewOfSection, 2 
SYSSTUBS_ENTRY1  278, VdmControl, 2 
SYSSTUBS_ENTRY2  278, VdmControl, 2 
SYSSTUBS_ENTRY3  278, VdmControl, 2 
SYSSTUBS_ENTRY4  278, VdmControl, 2 
SYSSTUBS_ENTRY5  278, VdmControl, 2 
SYSSTUBS_ENTRY6  278, VdmControl, 2 
SYSSTUBS_ENTRY7  278, VdmControl, 2 
SYSSTUBS_ENTRY8  278, VdmControl, 2 
SYSSTUBS_ENTRY1  279, WaitForDebugEvent, 4 
SYSSTUBS_ENTRY2  279, WaitForDebugEvent, 4 
SYSSTUBS_ENTRY3  279, WaitForDebugEvent, 4 
SYSSTUBS_ENTRY4  279, WaitForDebugEvent, 4 
SYSSTUBS_ENTRY5  279, WaitForDebugEvent, 4 
SYSSTUBS_ENTRY6  279, WaitForDebugEvent, 4 
SYSSTUBS_ENTRY7  279, WaitForDebugEvent, 4 
SYSSTUBS_ENTRY8  279, WaitForDebugEvent, 4 
SYSSTUBS_ENTRY1  280, WaitForMultipleObjects, 5 
SYSSTUBS_ENTRY2  280, WaitForMultipleObjects, 5 
SYSSTUBS_ENTRY3  280, WaitForMultipleObjects, 5 
SYSSTUBS_ENTRY4  280, WaitForMultipleObjects, 5 
SYSSTUBS_ENTRY5  280, WaitForMultipleObjects, 5 
SYSSTUBS_ENTRY6  280, WaitForMultipleObjects, 5 
SYSSTUBS_ENTRY7  280, WaitForMultipleObjects, 5 
SYSSTUBS_ENTRY8  280, WaitForMultipleObjects, 5 
SYSSTUBS_ENTRY1  281, WaitForSingleObject, 3 
SYSSTUBS_ENTRY2  281, WaitForSingleObject, 3 
SYSSTUBS_ENTRY3  281, WaitForSingleObject, 3 
SYSSTUBS_ENTRY4  281, WaitForSingleObject, 3 
SYSSTUBS_ENTRY5  281, WaitForSingleObject, 3 
SYSSTUBS_ENTRY6  281, WaitForSingleObject, 3 
SYSSTUBS_ENTRY7  281, WaitForSingleObject, 3 
SYSSTUBS_ENTRY8  281, WaitForSingleObject, 3 
SYSSTUBS_ENTRY1  282, WaitHighEventPair, 1 
SYSSTUBS_ENTRY2  282, WaitHighEventPair, 1 
SYSSTUBS_ENTRY3  282, WaitHighEventPair, 1 
SYSSTUBS_ENTRY4  282, WaitHighEventPair, 1 
SYSSTUBS_ENTRY5  282, WaitHighEventPair, 1 
SYSSTUBS_ENTRY6  282, WaitHighEventPair, 1 
SYSSTUBS_ENTRY7  282, WaitHighEventPair, 1 
SYSSTUBS_ENTRY8  282, WaitHighEventPair, 1 
SYSSTUBS_ENTRY1  283, WaitLowEventPair, 1 
SYSSTUBS_ENTRY2  283, WaitLowEventPair, 1 
SYSSTUBS_ENTRY3  283, WaitLowEventPair, 1 
SYSSTUBS_ENTRY4  283, WaitLowEventPair, 1 
SYSSTUBS_ENTRY5  283, WaitLowEventPair, 1 
SYSSTUBS_ENTRY6  283, WaitLowEventPair, 1 
SYSSTUBS_ENTRY7  283, WaitLowEventPair, 1 
SYSSTUBS_ENTRY8  283, WaitLowEventPair, 1 
SYSSTUBS_ENTRY1  284, WriteFile, 9 
SYSSTUBS_ENTRY2  284, WriteFile, 9 
SYSSTUBS_ENTRY3  284, WriteFile, 9 
SYSSTUBS_ENTRY4  284, WriteFile, 9 
SYSSTUBS_ENTRY5  284, WriteFile, 9 
SYSSTUBS_ENTRY6  284, WriteFile, 9 
SYSSTUBS_ENTRY7  284, WriteFile, 9 
SYSSTUBS_ENTRY8  284, WriteFile, 9 
SYSSTUBS_ENTRY1  285, WriteFileGather, 9 
SYSSTUBS_ENTRY2  285, WriteFileGather, 9 
SYSSTUBS_ENTRY3  285, WriteFileGather, 9 
SYSSTUBS_ENTRY4  285, WriteFileGather, 9 
SYSSTUBS_ENTRY5  285, WriteFileGather, 9 
SYSSTUBS_ENTRY6  285, WriteFileGather, 9 
SYSSTUBS_ENTRY7  285, WriteFileGather, 9 
SYSSTUBS_ENTRY8  285, WriteFileGather, 9 
SYSSTUBS_ENTRY1  286, WriteRequestData, 6 
SYSSTUBS_ENTRY2  286, WriteRequestData, 6 
SYSSTUBS_ENTRY3  286, WriteRequestData, 6 
SYSSTUBS_ENTRY4  286, WriteRequestData, 6 
SYSSTUBS_ENTRY5  286, WriteRequestData, 6 
SYSSTUBS_ENTRY6  286, WriteRequestData, 6 
SYSSTUBS_ENTRY7  286, WriteRequestData, 6 
SYSSTUBS_ENTRY8  286, WriteRequestData, 6 
SYSSTUBS_ENTRY1  287, WriteVirtualMemory, 5 
SYSSTUBS_ENTRY2  287, WriteVirtualMemory, 5 
SYSSTUBS_ENTRY3  287, WriteVirtualMemory, 5 
SYSSTUBS_ENTRY4  287, WriteVirtualMemory, 5 
SYSSTUBS_ENTRY5  287, WriteVirtualMemory, 5 
SYSSTUBS_ENTRY6  287, WriteVirtualMemory, 5 
SYSSTUBS_ENTRY7  287, WriteVirtualMemory, 5 
SYSSTUBS_ENTRY8  287, WriteVirtualMemory, 5 
SYSSTUBS_ENTRY1  288, YieldExecution, 0 
SYSSTUBS_ENTRY2  288, YieldExecution, 0 
SYSSTUBS_ENTRY3  288, YieldExecution, 0 
SYSSTUBS_ENTRY4  288, YieldExecution, 0 
SYSSTUBS_ENTRY5  288, YieldExecution, 0 
SYSSTUBS_ENTRY6  288, YieldExecution, 0 
SYSSTUBS_ENTRY7  288, YieldExecution, 0 
SYSSTUBS_ENTRY8  288, YieldExecution, 0 
SYSSTUBS_ENTRY1  289, CreateKeyedEvent, 4 
SYSSTUBS_ENTRY2  289, CreateKeyedEvent, 4 
SYSSTUBS_ENTRY3  289, CreateKeyedEvent, 4 
SYSSTUBS_ENTRY4  289, CreateKeyedEvent, 4 
SYSSTUBS_ENTRY5  289, CreateKeyedEvent, 4 
SYSSTUBS_ENTRY6  289, CreateKeyedEvent, 4 
SYSSTUBS_ENTRY7  289, CreateKeyedEvent, 4 
SYSSTUBS_ENTRY8  289, CreateKeyedEvent, 4 
SYSSTUBS_ENTRY1  290, OpenKeyedEvent, 3 
SYSSTUBS_ENTRY2  290, OpenKeyedEvent, 3 
SYSSTUBS_ENTRY3  290, OpenKeyedEvent, 3 
SYSSTUBS_ENTRY4  290, OpenKeyedEvent, 3 
SYSSTUBS_ENTRY5  290, OpenKeyedEvent, 3 
SYSSTUBS_ENTRY6  290, OpenKeyedEvent, 3 
SYSSTUBS_ENTRY7  290, OpenKeyedEvent, 3 
SYSSTUBS_ENTRY8  290, OpenKeyedEvent, 3 
SYSSTUBS_ENTRY1  291, ReleaseKeyedEvent, 4 
SYSSTUBS_ENTRY2  291, ReleaseKeyedEvent, 4 
SYSSTUBS_ENTRY3  291, ReleaseKeyedEvent, 4 
SYSSTUBS_ENTRY4  291, ReleaseKeyedEvent, 4 
SYSSTUBS_ENTRY5  291, ReleaseKeyedEvent, 4 
SYSSTUBS_ENTRY6  291, ReleaseKeyedEvent, 4 
SYSSTUBS_ENTRY7  291, ReleaseKeyedEvent, 4 
SYSSTUBS_ENTRY8  291, ReleaseKeyedEvent, 4 
SYSSTUBS_ENTRY1  292, WaitForKeyedEvent, 4 
SYSSTUBS_ENTRY2  292, WaitForKeyedEvent, 4 
SYSSTUBS_ENTRY3  292, WaitForKeyedEvent, 4 
SYSSTUBS_ENTRY4  292, WaitForKeyedEvent, 4 
SYSSTUBS_ENTRY5  292, WaitForKeyedEvent, 4 
SYSSTUBS_ENTRY6  292, WaitForKeyedEvent, 4 
SYSSTUBS_ENTRY7  292, WaitForKeyedEvent, 4 
SYSSTUBS_ENTRY8  292, WaitForKeyedEvent, 4 
SYSSTUBS_ENTRY1  293, QueryPortInformationProcess, 0 
SYSSTUBS_ENTRY2  293, QueryPortInformationProcess, 0 
SYSSTUBS_ENTRY3  293, QueryPortInformationProcess, 0 
SYSSTUBS_ENTRY4  293, QueryPortInformationProcess, 0 
SYSSTUBS_ENTRY5  293, QueryPortInformationProcess, 0 
SYSSTUBS_ENTRY6  293, QueryPortInformationProcess, 0 
SYSSTUBS_ENTRY7  293, QueryPortInformationProcess, 0 
SYSSTUBS_ENTRY8  293, QueryPortInformationProcess, 0 
SYSSTUBS_ENTRY1  294, GetCurrentProcessorNumber, 0 
SYSSTUBS_ENTRY2  294, GetCurrentProcessorNumber, 0 
SYSSTUBS_ENTRY3  294, GetCurrentProcessorNumber, 0 
SYSSTUBS_ENTRY4  294, GetCurrentProcessorNumber, 0 
SYSSTUBS_ENTRY5  294, GetCurrentProcessorNumber, 0 
SYSSTUBS_ENTRY6  294, GetCurrentProcessorNumber, 0 
SYSSTUBS_ENTRY7  294, GetCurrentProcessorNumber, 0 
SYSSTUBS_ENTRY8  294, GetCurrentProcessorNumber, 0 
SYSSTUBS_ENTRY1  295, WaitForMultipleObjects32, 5 
SYSSTUBS_ENTRY2  295, WaitForMultipleObjects32, 5 
SYSSTUBS_ENTRY3  295, WaitForMultipleObjects32, 5 
SYSSTUBS_ENTRY4  295, WaitForMultipleObjects32, 5 
SYSSTUBS_ENTRY5  295, WaitForMultipleObjects32, 5 
SYSSTUBS_ENTRY6  295, WaitForMultipleObjects32, 5 
SYSSTUBS_ENTRY7  295, WaitForMultipleObjects32, 5 
SYSSTUBS_ENTRY8  295, WaitForMultipleObjects32, 5 

STUBS_END
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ke\i386\procstat.asm ===
title  "Processor State Save Restore"
;++
;
; Copyright (c) Microsoft Corporation. All rights reserved. 
;
; You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
; If you do not agree to the terms, do not use the code.
;
;
; Module Name:
;
;    procstat.asm
;
; Abstract:
;
;    This module implements procedures for saving and restoring
;    processor control state, and processor run&control state.
;    These procedures support debugging of UP and MP systems.
;
;--

.386p
        .xlist
include ks386.inc
include i386\kimacro.inc
include callconv.inc
        .list

        EXTRNP  _KeContextToKframes,5
        EXTRNP  _KeContextFromKframes,3
        extrn   _KeFeatureBits:DWORD

        page ,132
_TEXT   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

        subttl  "Save Processor State"
;++
;
; KiSaveProcessorState(
;       PKTRAP_FRAME TrapFrame,
;       PKEXCEPTION_FRAME   ExceptionFrame
;       );
;
; Routine Description:
;
;    This routine saves the processor state for debugger.  When the current
;    processor receives the request of IPI_FREEZE, it saves all the registers
;    in a save area in the PRCB so the debugger can get access to them.
;
; Arguments:
;
;    TrapFrame (esp+4) - Pointer to machine trap frame
;
;    ExceptionFrame (esp+8) - Pointer to exception frame
;           (IGNORED on the x86!)
;
; Return Value:
;
;    None.
;
;--

cPublicProc _KiSaveProcessorState   ,2

        mov     eax, [esp+4]                    ; (eax) -> TrapFrame

        mov     edx, PCR[PcPrcb]                ; (edx)->PrcbData
        add     edx, PbProcessorState           ; (edx)->ProcessorState
        push    edx
;
; Copy the whole TrapFrame to our ProcessorState
;

        lea     ecx, [edx].PsContextFrame
        mov     dword ptr [ecx].CsContextFlags, CONTEXT_FULL OR CONTEXT_DEBUG_REGISTERS

; ecx - ContextFrame
; 0 - ExceptionFrame == NULL
; eax - TrapFrame
        stdCall   _KeContextFromKframes, <eax, 0, ecx>

;
; Save special registers for debugger
;

        ; TOS = PKPROCESSOR_STATE
        call    _KiSaveProcessorControlState@4

        stdRET  _KiSaveProcessorState

stdENDP _KiSaveProcessorState


        page    ,132
        subttl  "Save Processor Control State"
;++
;
; KiSaveProcessorControlState(
;       PKPROCESSOR_STATE   ProcessorState
;       );
;
; Routine Description:
;
;    This routine saves the control subset of the processor state.
;    (Saves the same information as KiSaveProcessorState EXCEPT that
;     data in TrapFrame/ExceptionFrame=Context record is NOT saved.)
;    Called by the debug subsystem, and KiSaveProcessorState()
;
;   N.B.  This procedure will save Dr7, and then 0 it.  This prevents
;         recursive hardware trace breakpoints and allows debuggers
;         to work.
;
; Arguments:
;
; Return Value:
;
;    None.
;
;--

cPublicProc _KiSaveProcessorControlState   ,1

        mov     edx, [esp+4]                    ; ProcessorState

;
; Save special registers for debugger
;
        xor     ecx,ecx

        mov     eax, cr0
        mov     [edx].PsSpecialRegisters.SrCr0, eax
        mov     eax, cr2
        mov     [edx].PsSpecialRegisters.SrCr2, eax
        mov     eax, cr3
        mov     [edx].PsSpecialRegisters.SrCr3, eax

        mov     [edx].PsSpecialRegisters.SrCr4, ecx

        test    _KeFeatureBits, KF_CR4
        jz      short @f

.586p
        mov     eax, cr4
        mov     [edx].PsSpecialRegisters.SrCr4, eax
.486p

@@:
        mov     eax,dr0
        mov     [edx].PsSpecialRegisters.SrKernelDr0,eax
        mov     eax,dr1
        mov     [edx].PsSpecialRegisters.SrKernelDr1,eax
        mov     eax,dr2
        mov     [edx].PsSpecialRegisters.SrKernelDr2,eax
        mov     eax,dr3
        mov     [edx].PsSpecialRegisters.SrKernelDr3,eax
        mov     eax,dr6
        mov     [edx].PsSpecialRegisters.SrKernelDr6,eax

        mov     eax,dr7
        mov     dr7,ecx
        mov     [edx].PsSpecialRegisters.SrKernelDr7,eax

        sgdt    fword ptr [edx].PsSpecialRegisters.SrGdtr
        sidt    fword ptr [edx].PsSpecialRegisters.SrIdtr

        str     word ptr [edx].PsSpecialRegisters.SrTr
        sldt    word ptr [edx].PsSpecialRegisters.SrLdtr

        stdRET    _KiSaveProcessorControlState

stdENDP _KiSaveProcessorControlState

        page ,132
        subttl  "Restore Processor State"
;++
;
; KiRestoreProcessorState(
;       PKTRAP_FRAME TrapFrame,
;       PKEXCEPTION_FRAME ExceptionFrame
;       );
;
; Routine Description:
;
;    This routine Restores the processor state for debugger.  When the
;    control returns from debugger (UnFreezeExecution), this function
;    restores the entire processor state.
;
; Arguments:
;
;    TrapFrame (esp+4) - Pointer to machine trap frame
;
;    ExceptionFrame (esp+8) - Pointer to exception frame
;           (IGNORED on the x86!)
;
; Return Value:
;
;    None.
;
;--

cPublicProc _KiRestoreProcessorState   ,2

        mov     eax, [esp+4]                    ; (eax) -> TrapFrame

        mov     edx, PCR[PcPrcb]                ; (edx)->PrcbData
        add     edx, PbProcessorState           ; (edx)->ProcessorState
        push    edx

;
; Copy the whole ContextFrame to TrapFrame
;

        lea     ecx, [edx].PsContextFrame
        mov     edx, [edx].PsContextFrame.CsSegCs
        and     edx, MODE_MASK

; edx - Previous mode
; ecx - ContextFrame
; 0 - ExceptionFrame == NULL
; eax - TrapFrame
        stdCall   _KeContextToKframes, <eax,0,ecx,[ecx].CsContextFlags,edx>

;
; Save special registers for debugger
;

        ; TOS = KPROCESSOR_STATE
        call    _KiRestoreProcessorControlState@4

        stdRET  _KiRestoreProcessorState

stdENDP _KiRestoreProcessorState


        page    ,132
        subttl  "Restore Processor Control State"
;++
;
; KiRestoreProcessorControlState(
;       );
;
; Routine Description:
;
;    This routine restores the control subset of the processor state.
;    (Restores the same information as KiRestoreProcessorState EXCEPT that
;     data in TrapFrame/ExceptionFrame=Context record is NOT restored.)
;    Called by the debug subsystem, and KiRestoreProcessorState()
;
; Arguments:
;
; Return Value:
;
;    None.
;
;--

cPublicProc _KiRestoreProcessorControlState,1

        mov     edx, [esp+4]                    ; (edx)->ProcessorState

;
; Restore special registers for debugger
;

        mov     eax, [edx].PsSpecialRegisters.SrCr0
        mov     cr0, eax
        mov     eax, [edx].PsSpecialRegisters.SrCr2
        mov     cr2, eax
        mov     eax, [edx].PsSpecialRegisters.SrCr3
        mov     cr3, eax

        test    _KeFeatureBits, KF_CR4
        jz      short @f

.586p
        mov     eax, [edx].PsSpecialRegisters.SrCr4
        mov     cr4, eax
.486p
@@:
        mov     eax, [edx].PsSpecialRegisters.SrKernelDr0
        mov     dr0, eax
        mov     eax, [edx].PsSpecialRegisters.SrKernelDr1
        mov     dr1, eax
        mov     eax, [edx].PsSpecialRegisters.SrKernelDr2
        mov     dr2, eax
        mov     eax, [edx].PsSpecialRegisters.SrKernelDr3
        mov     dr3, eax
        mov     eax, [edx].PsSpecialRegisters.SrKernelDr6
        mov     dr6, eax
        mov     eax, [edx].PsSpecialRegisters.SrKernelDr7
        mov     dr7, eax

        lgdt    fword ptr [edx].PsSpecialRegisters.SrGdtr
        lidt    fword ptr [edx].PsSpecialRegisters.SrIdtr

;
; Force the TSS descriptor into a non-busy state, so we don't fault
; when we load the TR.
;

        mov     eax, [edx].PsSpecialRegisters.SrGdtr+2  ; (eax)->GDT base
        xor     ecx, ecx
        mov     cx,  word ptr [edx].PsSpecialRegisters.SrTr
        add     eax, 5
        add     eax, ecx                                ; (eax)->TSS Desc. Byte
        and     byte ptr [eax],NOT 2
        ltr     word ptr [edx].PsSpecialRegisters.SrTr

        lldt    word ptr [edx].PsSpecialRegisters.SrLdtr

        stdRET    _KiRestoreProcessorControlState

stdENDP _KiRestoreProcessorControlState

_TEXT   ENDS
        END
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ke\i386\threadbg.asm ===
title  "Thread Startup"
;++
;
; Copyright (c) Microsoft Corporation. All rights reserved. 
;
; You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
; If you do not agree to the terms, do not use the code.
;
;
; Module Name:
;
;    threadbg.asm
;
; Abstract:
;
;    This module implements the code necessary to startup a thread in kernel
;    mode.
;
; Environment:
;
;    IRQL APC_LEVEL.
;
;--

.386p
        .xlist
include ks386.inc
include i386\kimacro.inc
include callconv.inc
include irqli386.inc
        .list

        EXTRNP   _KeBugCheck,1
        extrn   _KiServiceExit2:PROC

        page ,132
        subttl  "Thread Startup"

_TEXT$00   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

;++
;
; Routine Description:
;
;    This routine is called at thread startup. Its function is to call the
;    initial thread procedure. If control returns from the initial thread
;    procedure and a user mode context was established when the thread
;    was initialized, then the user mode context is restored and control
;    is transferred to user mode. Otherwise a bugcheck will occur.
;
;
; Arguments:
;
;   (TOS)    = SystemRoutine - address of initial system routine.
;   (TOS+4)  = StartRoutine - Initial thread routine.
;   (TOS+8)  = StartContext - Context parm for initial thread routine.
;   (TOS+12) = UserContextFlag - 0 if no user context, !0 if there is one
;   (TOS+16) = Base of KTrapFrame if and only if there's a user context.
;
; Return Value:
;
;    None.
;
;--

cPublicProc _KiThreadStartup    ,1

        xor     ebx,ebx             ; clear registers
        xor     esi,esi             ;
        xor     edi,edi             ;
        xor     ebp,ebp             ;
        LowerIrql APC_LEVEL         ; KeLowerIrql(APC_LEVEL)

        pop     eax                 ; (eax)->SystemRoutine
        call    eax                 ; SystemRoutine(StartRoutine, StartContext)

        pop     ecx                 ; (ecx) = UserContextFlag
        or      ecx, ecx
        jz      short kits10              ; No user context, go bugcheck

        mov     ebp,esp             ; (bp) -> TrapFrame holding UserContext

        jmp     _KiServiceExit2

kits10: stdCall _KeBugCheck, <NO_USER_MODE_CONTEXT>

stdENDP _KiThreadStartup

_TEXT$00   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ke\i386\systable.asm ===
;++
;
; Copyright (c) Microsoft Corporation. All rights reserved. 
;
; You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
; If you do not agree to the terms, do not use the code.
;
;
; Module Name:
;
;    systable.asm
;
; Abstract:
;
;    This module implements the system service dispatch table.
;
;--

;
; To add a system service simply add the name of the service to the below
; table. If the system service has arguments, then immediately
; follow the name of the serice with a comma and following that the number
; of bytes of in memory arguments, e.g. CreateObject,40.
;

;ifdef i386

.386p
include callconv.inc

TABLE_ERROR macro t
.err    ; Maximum number of in-memory system service arguments exceeded.
        endm

TABLE_BEGIN1 macro t
    TITLE t
endm
TABLE_BEGIN2 macro t
_TEXT	SEGMENT DWORD PUBLIC 'DATA'
	ASSUME	DS:FLAT
endm
TABLE_BEGIN3 macro t
    align 4
endm
TABLE_BEGIN4 macro t
    public _KiServiceTable
_KiServiceTable label dword
endm
TABLE_BEGIN5 macro t
endm
TABLE_BEGIN6 macro t
endm
TABLE_BEGIN7 macro t
endm
TABLE_BEGIN8 macro t
endm

TABLE_ENTRY macro l,bias,numargs
        Local   Bytes

        Bytes = numargs*4

        EXTRNP  _Nt&l,&numargs
        ComposeInst <dd offset FLAT:>,_Nt,l,<@>,%(Bytes)
endm

TABLE_END macro n
    public _KiServiceLimit
_KiServiceLimit dd n+1
endm

ARGTBL_BEGIN macro
    public _KiArgumentTable
_KiArgumentTable label dword
endm

ARGTBL_ENTRY macro e0,e1,e2,e3,e4,e5,e6,e7
        db   e0,e1,e2,e3,e4,e5,e6,e7
endm

ARGTBL_END macro
_TEXT   ENDS
        end
endm

;endif

        TABLE_BEGIN1 <"System Service Dispatch Table">
        TABLE_BEGIN2 <"System Service Dispatch Table">
        TABLE_BEGIN3 <"System Service Dispatch Table">
        TABLE_BEGIN4 <"System Service Dispatch Table">
        TABLE_BEGIN5 <"System Service Dispatch Table">
        TABLE_BEGIN6 <"System Service Dispatch Table">
        TABLE_BEGIN7 <"System Service Dispatch Table">
        TABLE_BEGIN8 <"System Service Dispatch Table">
TABLE_ENTRY  AcceptConnectPort, 1, 6 
TABLE_ENTRY  AccessCheck, 1, 8 
TABLE_ENTRY  AccessCheckAndAuditAlarm, 1, 11 
TABLE_ENTRY  AccessCheckByType, 1, 11 
TABLE_ENTRY  AccessCheckByTypeAndAuditAlarm, 1, 16 
TABLE_ENTRY  AccessCheckByTypeResultList, 1, 11 
TABLE_ENTRY  AccessCheckByTypeResultListAndAuditAlarm, 1, 16 
TABLE_ENTRY  AccessCheckByTypeResultListAndAuditAlarmByHandle, 1, 17 
TABLE_ENTRY  AddAtom, 1, 3 
TABLE_ENTRY  AddBootEntry, 1, 2 
TABLE_ENTRY  AddDriverEntry, 1, 2 
TABLE_ENTRY  AdjustGroupsToken, 1, 6 
TABLE_ENTRY  AdjustPrivilegesToken, 1, 6 
TABLE_ENTRY  AlertResumeThread, 1, 2 
TABLE_ENTRY  AlertThread, 1, 1 
TABLE_ENTRY  AllocateLocallyUniqueId, 1, 1 
TABLE_ENTRY  AllocateUserPhysicalPages, 1, 3 
TABLE_ENTRY  AllocateUuids, 1, 4 
TABLE_ENTRY  AllocateVirtualMemory, 1, 6 
TABLE_ENTRY  ApphelpCacheControl, 1, 2 
TABLE_ENTRY  AreMappedFilesTheSame, 1, 2 
TABLE_ENTRY  AssignProcessToJobObject, 1, 2 
TABLE_ENTRY  CallbackReturn, 1, 3 
TABLE_ENTRY  CancelDeviceWakeupRequest, 1, 1 
TABLE_ENTRY  CancelIoFile, 1, 2 
TABLE_ENTRY  CancelTimer, 1, 2 
TABLE_ENTRY  ClearEvent, 1, 1 
TABLE_ENTRY  Close, 1, 1 
TABLE_ENTRY  CloseObjectAuditAlarm, 1, 3 
TABLE_ENTRY  CompactKeys, 1, 2 
TABLE_ENTRY  CompareTokens, 1, 3 
TABLE_ENTRY  CompleteConnectPort, 1, 1 
TABLE_ENTRY  CompressKey, 1, 1 
TABLE_ENTRY  ConnectPort, 1, 8 
TABLE_ENTRY  Continue, 1, 2 
TABLE_ENTRY  CreateDebugObject, 1, 4 
TABLE_ENTRY  CreateDirectoryObject, 1, 3 
TABLE_ENTRY  CreateEvent, 1, 5 
TABLE_ENTRY  CreateEventPair, 1, 3 
TABLE_ENTRY  CreateFile, 1, 11 
TABLE_ENTRY  CreateIoCompletion, 1, 4 
TABLE_ENTRY  CreateJobObject, 1, 3 
TABLE_ENTRY  CreateJobSet, 1, 3 
TABLE_ENTRY  CreateKey, 1, 7 
TABLE_ENTRY  CreateMailslotFile, 1, 8 
TABLE_ENTRY  CreateMutant, 1, 4 
TABLE_ENTRY  CreateNamedPipeFile, 1, 14 
TABLE_ENTRY  CreatePagingFile, 1, 4 
TABLE_ENTRY  CreatePort, 1, 5 
TABLE_ENTRY  CreateProcess, 1, 8 
TABLE_ENTRY  CreateProcessEx, 1, 9 
TABLE_ENTRY  CreateProfile, 1, 9 
TABLE_ENTRY  CreateSection, 1, 7 
TABLE_ENTRY  CreateSemaphore, 1, 5 
TABLE_ENTRY  CreateSymbolicLinkObject, 1, 4 
TABLE_ENTRY  CreateThread, 1, 8 
TABLE_ENTRY  CreateTimer, 1, 4 
TABLE_ENTRY  CreateToken, 1, 13 
TABLE_ENTRY  CreateWaitablePort, 1, 5 
TABLE_ENTRY  DebugActiveProcess, 1, 2 
TABLE_ENTRY  DebugContinue, 1, 3 
TABLE_ENTRY  DelayExecution, 1, 2 
TABLE_ENTRY  DeleteAtom, 1, 1 
TABLE_ENTRY  DeleteBootEntry, 1, 1 
TABLE_ENTRY  DeleteDriverEntry, 1, 1 
TABLE_ENTRY  DeleteFile, 1, 1 
TABLE_ENTRY  DeleteKey, 1, 1 
TABLE_ENTRY  DeleteObjectAuditAlarm, 1, 3 
TABLE_ENTRY  DeleteValueKey, 1, 2 
TABLE_ENTRY  DeviceIoControlFile, 1, 10 
TABLE_ENTRY  DisplayString, 1, 1 
TABLE_ENTRY  DuplicateObject, 1, 7 
TABLE_ENTRY  DuplicateToken, 1, 6 
TABLE_ENTRY  EnumerateBootEntries, 1, 2 
TABLE_ENTRY  EnumerateDriverEntries, 1, 2 
TABLE_ENTRY  EnumerateKey, 1, 6 
TABLE_ENTRY  EnumerateSystemEnvironmentValuesEx, 1, 3 
TABLE_ENTRY  EnumerateValueKey, 1, 6 
TABLE_ENTRY  ExtendSection, 1, 2 
TABLE_ENTRY  FilterToken, 1, 6 
TABLE_ENTRY  FindAtom, 1, 3 
TABLE_ENTRY  FlushBuffersFile, 1, 2 
TABLE_ENTRY  FlushInstructionCache, 1, 3 
TABLE_ENTRY  FlushKey, 1, 1 
TABLE_ENTRY  FlushVirtualMemory, 1, 4 
TABLE_ENTRY  FlushWriteBuffer, 0, 0 
TABLE_ENTRY  FreeUserPhysicalPages, 1, 3 
TABLE_ENTRY  FreeVirtualMemory, 1, 4 
TABLE_ENTRY  FsControlFile, 1, 10 
TABLE_ENTRY  GetContextThread, 1, 2 
TABLE_ENTRY  GetDevicePowerState, 1, 2 
TABLE_ENTRY  GetPlugPlayEvent, 1, 4 
TABLE_ENTRY  GetWriteWatch, 1, 7 
TABLE_ENTRY  ImpersonateAnonymousToken, 1, 1 
TABLE_ENTRY  ImpersonateClientOfPort, 1, 2 
TABLE_ENTRY  ImpersonateThread, 1, 3 
TABLE_ENTRY  InitializeRegistry, 1, 1 
TABLE_ENTRY  InitiatePowerAction, 1, 4 
TABLE_ENTRY  IsProcessInJob, 1, 2 
TABLE_ENTRY  IsSystemResumeAutomatic, 0, 0 
TABLE_ENTRY  ListenPort, 1, 2 
TABLE_ENTRY  LoadDriver, 1, 1 
TABLE_ENTRY  LoadKey, 1, 2 
TABLE_ENTRY  LoadKey2, 1, 3 
TABLE_ENTRY  LoadKeyEx, 1, 4 
TABLE_ENTRY  LockFile, 1, 10 
TABLE_ENTRY  LockProductActivationKeys, 1, 2 
TABLE_ENTRY  LockRegistryKey, 1, 1 
TABLE_ENTRY  LockVirtualMemory, 1, 4 
TABLE_ENTRY  MakePermanentObject, 1, 1 
TABLE_ENTRY  MakeTemporaryObject, 1, 1 
TABLE_ENTRY  MapUserPhysicalPages, 1, 3 
TABLE_ENTRY  MapUserPhysicalPagesScatter, 1, 3 
TABLE_ENTRY  MapViewOfSection, 1, 10 
TABLE_ENTRY  ModifyBootEntry, 1, 1 
TABLE_ENTRY  ModifyDriverEntry, 1, 1 
TABLE_ENTRY  NotifyChangeDirectoryFile, 1, 9 
TABLE_ENTRY  NotifyChangeKey, 1, 10 
TABLE_ENTRY  NotifyChangeMultipleKeys, 1, 12 
TABLE_ENTRY  OpenDirectoryObject, 1, 3 
TABLE_ENTRY  OpenEvent, 1, 3 
TABLE_ENTRY  OpenEventPair, 1, 3 
TABLE_ENTRY  OpenFile, 1, 6 
TABLE_ENTRY  OpenIoCompletion, 1, 3 
TABLE_ENTRY  OpenJobObject, 1, 3 
TABLE_ENTRY  OpenKey, 1, 3 
TABLE_ENTRY  OpenMutant, 1, 3 
TABLE_ENTRY  OpenObjectAuditAlarm, 1, 12 
TABLE_ENTRY  OpenProcess, 1, 4 
TABLE_ENTRY  OpenProcessToken, 1, 3 
TABLE_ENTRY  OpenProcessTokenEx, 1, 4 
TABLE_ENTRY  OpenSection, 1, 3 
TABLE_ENTRY  OpenSemaphore, 1, 3 
TABLE_ENTRY  OpenSymbolicLinkObject, 1, 3 
TABLE_ENTRY  OpenThread, 1, 4 
TABLE_ENTRY  OpenThreadToken, 1, 4 
TABLE_ENTRY  OpenThreadTokenEx, 1, 5 
TABLE_ENTRY  OpenTimer, 1, 3 
TABLE_ENTRY  PlugPlayControl, 1, 3 
TABLE_ENTRY  PowerInformation, 1, 5 
TABLE_ENTRY  PrivilegeCheck, 1, 3 
TABLE_ENTRY  PrivilegeObjectAuditAlarm, 1, 6 
TABLE_ENTRY  PrivilegedServiceAuditAlarm, 1, 5 
TABLE_ENTRY  ProtectVirtualMemory, 1, 5 
TABLE_ENTRY  PulseEvent, 1, 2 
TABLE_ENTRY  QueryAttributesFile, 1, 2 
TABLE_ENTRY  QueryBootEntryOrder, 1, 2 
TABLE_ENTRY  QueryBootOptions, 1, 2 
TABLE_ENTRY  QueryDebugFilterState, 1, 2 
TABLE_ENTRY  QueryDefaultLocale, 1, 2 
TABLE_ENTRY  QueryDefaultUILanguage, 1, 1 
TABLE_ENTRY  QueryDirectoryFile, 1, 11 
TABLE_ENTRY  QueryDirectoryObject, 1, 7 
TABLE_ENTRY  QueryDriverEntryOrder, 1, 2 
TABLE_ENTRY  QueryEaFile, 1, 9 
TABLE_ENTRY  QueryEvent, 1, 5 
TABLE_ENTRY  QueryFullAttributesFile, 1, 2 
TABLE_ENTRY  QueryInformationAtom, 1, 5 
TABLE_ENTRY  QueryInformationFile, 1, 5 
TABLE_ENTRY  QueryInformationJobObject, 1, 5 
TABLE_ENTRY  QueryInformationPort, 1, 5 
TABLE_ENTRY  QueryInformationProcess, 1, 5 
TABLE_ENTRY  QueryInformationThread, 1, 5 
TABLE_ENTRY  QueryInformationToken, 1, 5 
TABLE_ENTRY  QueryInstallUILanguage, 1, 1 
TABLE_ENTRY  QueryIntervalProfile, 1, 2 
TABLE_ENTRY  QueryIoCompletion, 1, 5 
TABLE_ENTRY  QueryKey, 1, 5 
TABLE_ENTRY  QueryMultipleValueKey, 1, 6 
TABLE_ENTRY  QueryMutant, 1, 5 
TABLE_ENTRY  QueryObject, 1, 5 
TABLE_ENTRY  QueryOpenSubKeys, 1, 2 
TABLE_ENTRY  QueryOpenSubKeysEx, 1, 4 
TABLE_ENTRY  QueryPerformanceCounter, 1, 2 
TABLE_ENTRY  QueryQuotaInformationFile, 1, 9 
TABLE_ENTRY  QuerySection, 1, 5 
TABLE_ENTRY  QuerySecurityObject, 1, 5 
TABLE_ENTRY  QuerySemaphore, 1, 5 
TABLE_ENTRY  QuerySymbolicLinkObject, 1, 3 
TABLE_ENTRY  QuerySystemEnvironmentValue, 1, 4 
TABLE_ENTRY  QuerySystemEnvironmentValueEx, 1, 5 
TABLE_ENTRY  QuerySystemInformation, 1, 4 
TABLE_ENTRY  QuerySystemTime, 1, 1 
TABLE_ENTRY  QueryTimer, 1, 5 
TABLE_ENTRY  QueryTimerResolution, 1, 3 
TABLE_ENTRY  QueryValueKey, 1, 6 
TABLE_ENTRY  QueryVirtualMemory, 1, 6 
TABLE_ENTRY  QueryVolumeInformationFile, 1, 5 
TABLE_ENTRY  QueueApcThread, 1, 5 
TABLE_ENTRY  RaiseException, 1, 3 
TABLE_ENTRY  RaiseHardError, 1, 6 
TABLE_ENTRY  ReadFile, 1, 9 
TABLE_ENTRY  ReadFileScatter, 1, 9 
TABLE_ENTRY  ReadRequestData, 1, 6 
TABLE_ENTRY  ReadVirtualMemory, 1, 5 
TABLE_ENTRY  RegisterThreadTerminatePort, 1, 1 
TABLE_ENTRY  ReleaseMutant, 1, 2 
TABLE_ENTRY  ReleaseSemaphore, 1, 3 
TABLE_ENTRY  RemoveIoCompletion, 1, 5 
TABLE_ENTRY  RemoveProcessDebug, 1, 2 
TABLE_ENTRY  RenameKey, 1, 2 
TABLE_ENTRY  ReplaceKey, 1, 3 
TABLE_ENTRY  ReplyPort, 1, 2 
TABLE_ENTRY  ReplyWaitReceivePort, 1, 4 
TABLE_ENTRY  ReplyWaitReceivePortEx, 1, 5 
TABLE_ENTRY  ReplyWaitReplyPort, 1, 2 
TABLE_ENTRY  RequestDeviceWakeup, 1, 1 
TABLE_ENTRY  RequestPort, 1, 2 
TABLE_ENTRY  RequestWaitReplyPort, 1, 3 
TABLE_ENTRY  RequestWakeupLatency, 1, 1 
TABLE_ENTRY  ResetEvent, 1, 2 
TABLE_ENTRY  ResetWriteWatch, 1, 3 
TABLE_ENTRY  RestoreKey, 1, 3 
TABLE_ENTRY  ResumeProcess, 1, 1 
TABLE_ENTRY  ResumeThread, 1, 2 
TABLE_ENTRY  SaveKey, 1, 2 
TABLE_ENTRY  SaveKeyEx, 1, 3 
TABLE_ENTRY  SaveMergedKeys, 1, 3 
TABLE_ENTRY  SecureConnectPort, 1, 9 
TABLE_ENTRY  SetBootEntryOrder, 1, 2 
TABLE_ENTRY  SetBootOptions, 1, 2 
TABLE_ENTRY  SetContextThread, 1, 2 
TABLE_ENTRY  SetDebugFilterState, 1, 3 
TABLE_ENTRY  SetDefaultHardErrorPort, 1, 1 
TABLE_ENTRY  SetDefaultLocale, 1, 2 
TABLE_ENTRY  SetDefaultUILanguage, 1, 1 
TABLE_ENTRY  SetDriverEntryOrder, 1, 2 
TABLE_ENTRY  SetEaFile, 1, 4 
TABLE_ENTRY  SetEvent, 1, 2 
TABLE_ENTRY  SetEventBoostPriority, 1, 1 
TABLE_ENTRY  SetHighEventPair, 1, 1 
TABLE_ENTRY  SetHighWaitLowEventPair, 1, 1 
TABLE_ENTRY  SetInformationDebugObject, 1, 5 
TABLE_ENTRY  SetInformationFile, 1, 5 
TABLE_ENTRY  SetInformationJobObject, 1, 4 
TABLE_ENTRY  SetInformationKey, 1, 4 
TABLE_ENTRY  SetInformationObject, 1, 4 
TABLE_ENTRY  SetInformationProcess, 1, 4 
TABLE_ENTRY  SetInformationThread, 1, 4 
TABLE_ENTRY  SetInformationToken, 1, 4 
TABLE_ENTRY  SetIntervalProfile, 1, 2 
TABLE_ENTRY  SetIoCompletion, 1, 5 
TABLE_ENTRY  SetLdtEntries, 1, 6 
TABLE_ENTRY  SetLowEventPair, 1, 1 
TABLE_ENTRY  SetLowWaitHighEventPair, 1, 1 
TABLE_ENTRY  SetQuotaInformationFile, 1, 4 
TABLE_ENTRY  SetSecurityObject, 1, 3 
TABLE_ENTRY  SetSystemEnvironmentValue, 1, 2 
TABLE_ENTRY  SetSystemEnvironmentValueEx, 1, 5 
TABLE_ENTRY  SetSystemInformation, 1, 3 
TABLE_ENTRY  SetSystemPowerState, 1, 3 
TABLE_ENTRY  SetSystemTime, 1, 2 
TABLE_ENTRY  SetThreadExecutionState, 1, 2 
TABLE_ENTRY  SetTimer, 1, 7 
TABLE_ENTRY  SetTimerResolution, 1, 3 
TABLE_ENTRY  SetUuidSeed, 1, 1 
TABLE_ENTRY  SetValueKey, 1, 6 
TABLE_ENTRY  SetVolumeInformationFile, 1, 5 
TABLE_ENTRY  ShutdownSystem, 1, 1 
TABLE_ENTRY  SignalAndWaitForSingleObject, 1, 4 
TABLE_ENTRY  StartProfile, 1, 1 
TABLE_ENTRY  StopProfile, 1, 1 
TABLE_ENTRY  SuspendProcess, 1, 1 
TABLE_ENTRY  SuspendThread, 1, 2 
TABLE_ENTRY  SystemDebugControl, 1, 6 
TABLE_ENTRY  TerminateJobObject, 1, 2 
TABLE_ENTRY  TerminateProcess, 1, 2 
TABLE_ENTRY  TerminateThread, 1, 2 
TABLE_ENTRY  TestAlert, 0, 0 
TABLE_ENTRY  TraceEvent, 1, 4 
TABLE_ENTRY  TranslateFilePath, 1, 4 
TABLE_ENTRY  UnloadDriver, 1, 1 
TABLE_ENTRY  UnloadKey, 1, 1 
TABLE_ENTRY  UnloadKey2, 1, 2 
TABLE_ENTRY  UnloadKeyEx, 1, 2 
TABLE_ENTRY  UnlockFile, 1, 5 
TABLE_ENTRY  UnlockVirtualMemory, 1, 4 
TABLE_ENTRY  UnmapViewOfSection, 1, 2 
TABLE_ENTRY  VdmControl, 1, 2 
TABLE_ENTRY  WaitForDebugEvent, 1, 4 
TABLE_ENTRY  WaitForMultipleObjects, 1, 5 
TABLE_ENTRY  WaitForSingleObject, 1, 3 
TABLE_ENTRY  WaitHighEventPair, 1, 1 
TABLE_ENTRY  WaitLowEventPair, 1, 1 
TABLE_ENTRY  WriteFile, 1, 9 
TABLE_ENTRY  WriteFileGather, 1, 9 
TABLE_ENTRY  WriteRequestData, 1, 6 
TABLE_ENTRY  WriteVirtualMemory, 1, 5 
TABLE_ENTRY  YieldExecution, 0, 0 
TABLE_ENTRY  CreateKeyedEvent, 1, 4 
TABLE_ENTRY  OpenKeyedEvent, 1, 3 
TABLE_ENTRY  ReleaseKeyedEvent, 1, 4 
TABLE_ENTRY  WaitForKeyedEvent, 1, 4 
TABLE_ENTRY  QueryPortInformationProcess, 0, 0 
TABLE_ENTRY  GetCurrentProcessorNumber, 0, 0 
TABLE_ENTRY  WaitForMultipleObjects32, 1, 5 

TABLE_END 295 

ARGTBL_BEGIN
ARGTBL_ENTRY 24,32,44,44,64,44,64,68 
ARGTBL_ENTRY 12,8,8,24,24,8,4,4 
ARGTBL_ENTRY 12,16,24,8,8,8,12,4 
ARGTBL_ENTRY 8,8,4,4,12,8,12,4 
ARGTBL_ENTRY 4,32,8,16,12,20,12,44 
ARGTBL_ENTRY 16,12,12,28,32,16,56,16 
ARGTBL_ENTRY 20,32,36,36,28,20,16,32 
ARGTBL_ENTRY 16,52,20,8,12,8,4,4 
ARGTBL_ENTRY 4,4,4,12,8,40,4,28 
ARGTBL_ENTRY 24,8,8,24,12,24,8,24 
ARGTBL_ENTRY 12,8,12,4,16,0,12,16 
ARGTBL_ENTRY 40,8,8,16,28,4,8,12 
ARGTBL_ENTRY 4,16,8,0,8,4,8,12 
ARGTBL_ENTRY 16,40,8,4,16,4,4,12 
ARGTBL_ENTRY 12,40,4,4,36,40,48,12 
ARGTBL_ENTRY 12,12,24,12,12,12,12,48 
ARGTBL_ENTRY 16,12,16,12,12,12,16,16 
ARGTBL_ENTRY 20,12,12,20,12,24,20,20 
ARGTBL_ENTRY 8,8,8,8,8,8,4,44 
ARGTBL_ENTRY 28,8,36,20,8,20,20,20 
ARGTBL_ENTRY 20,20,20,20,4,8,20,20 
ARGTBL_ENTRY 24,20,20,8,16,8,36,20 
ARGTBL_ENTRY 20,20,12,16,20,16,4,20 
ARGTBL_ENTRY 12,24,24,20,20,12,24,36 
ARGTBL_ENTRY 36,24,20,4,8,12,20,8 
ARGTBL_ENTRY 8,12,8,16,20,8,4,8 
ARGTBL_ENTRY 12,4,8,12,12,4,8,8 
ARGTBL_ENTRY 12,12,36,8,8,8,12,4 
ARGTBL_ENTRY 8,4,8,16,8,4,4,4 
ARGTBL_ENTRY 20,20,16,16,16,16,16,16 
ARGTBL_ENTRY 8,20,24,4,4,16,12,8 
ARGTBL_ENTRY 20,12,12,8,8,28,12,4 
ARGTBL_ENTRY 24,20,4,16,4,4,4,8 
ARGTBL_ENTRY 24,8,8,8,0,16,16,4 
ARGTBL_ENTRY 4,8,8,20,16,8,8,16 
ARGTBL_ENTRY 20,12,4,4,36,36,24,20 
ARGTBL_ENTRY 0,16,12,16,16,0,0,20 

ARGTBL_END
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ke\i386\trapc.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    trapc.c

Abstract:

    This module contains some trap handling code written in C.
    Only by the kernel.

--*/

#include    "ki.h"

NTSTATUS
Ki386CheckDivideByZeroTrap (
    IN  PKTRAP_FRAME    UserFrame
    );

VOID
KipWorkAroundCompiler (
    USHORT * StatusWord,
    USHORT * ControlWord
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, Ki386CheckDivideByZeroTrap)
#endif

#define REG(field)          ((ULONG)(&((KTRAP_FRAME *)0)->field))
#define GETREG(frame,reg)   ((PULONG) (((ULONG) frame)+reg))[0]

typedef struct {
    UCHAR   RmDisplaceOnly;     // RM of displacment only, no base reg
    UCHAR   RmSib;              // RM of SIB
    UCHAR   RmDisplace;         // bit mask of RMs which have a displacement
    UCHAR   Disp;               // sizeof displacement (in bytes)
} KMOD, *PKMOD;

static UCHAR RM32[] = {
    /* 000 */   REG(Eax),
    /* 001 */   REG(Ecx),
    /* 010 */   REG(Edx),
    /* 011 */   REG(Ebx),
    /* 100 */   REG(HardwareEsp),
    /* 101 */   REG(Ebp),       // SIB
    /* 110 */   REG(Esi),
    /* 111 */   REG(Edi)
};

static UCHAR RM8[] = {
    /* 000 */   REG(Eax),       // al
    /* 001 */   REG(Ecx),       // cl
    /* 010 */   REG(Edx),       // dl
    /* 011 */   REG(Ebx),       // bl
    /* 100 */   REG(Eax) + 1,   // ah
    /* 101 */   REG(Ecx) + 1,   // ch
    /* 110 */   REG(Edx) + 1,   // dh
    /* 111 */   REG(Ebx) + 1    // bh
};

static KMOD MOD32[] = {
    /* 00 */     5,     4,   0x20,   4,
    /* 01 */  0xff,     4,   0xff,   1,
    /* 10 */  0xff,     4,   0xff,   4,
    /* 11 */  0xff,  0xff,   0x00,   0
} ;

static struct {
    UCHAR   Opcode1, Opcode2;   // instruction opcode
    UCHAR   ModRm, type;        // if 2nd part of opcode is encoded in ModRm
} NoWaitNpxInstructions[] = {
    /* FNINIT   */  0xDB, 0xE3, 0,  1,
    /* FNCLEX   */  0xDB, 0xE2, 0,  1,
    /* FNSTENV  */  0xD9, 0x06, 1,  1,
    /* FNSAVE   */  0xDD, 0x06, 1,  1,
    /* FNSTCW   */  0xD9, 0x07, 1,  2,
    /* FNSTSW   */  0xDD, 0x07, 1,  3,
    /* FNSTSW AX*/  0xDF, 0xE0, 0,  4,
                    0x00, 0x00, 0,  1
};

NTSTATUS
Ki386CheckDivideByZeroTrap (
    IN  PKTRAP_FRAME    UserFrame
    )

/*++

Routine Description:

    This function gains control when the x86 processor generates a
    divide by zero trap.  The x86 design generates such a trap on
    divide by zero and on division overflows.  In order to determine
    which exception code to dispatch, the divisor of the "div" or "idiv"
    instruction needs to be inspected.

Arguments:

    UserFrame - Trap frame of the divide by zero trap

Return Value:

    exception code dispatch

--*/

{

    ULONG       operandsize, operandmask, i, accum;
    PUCHAR      istream, pRM;
    UCHAR       ibyte, rm;
    PKMOD       Mod;
    BOOLEAN     fPrefix;
    NTSTATUS    status;
    KIRQL       OldIrql;

    status = STATUS_INTEGER_DIVIDE_BY_ZERO;

    //
    // Raise IRQL to synchronize access to the trap frame
    //
    OldIrql = KeGetCurrentIrql();
    if (OldIrql < APC_LEVEL) {
        KeRaiseIrql(APC_LEVEL, &OldIrql);
    }

    if (UserFrame->SegCs == KGDT_R0_CODE && (UserFrame->EFlags & EFLAGS_V86_MASK) == 0) {

        //
        // Divide by zero exception from Kernel Mode?
        // Likely bad hardware interrupt and the device or vector table
        // is corrupt.  Bugcheck NOW so we can figure out what went wrong.
        // If we try and proceed, then we'll likely fault in reading the
        // top of user space, and then double fault (page fault in the
        // div zero handler.) -- This is a debugging consideration.
        // You can't put breakpoints on the trap labels so this is hard
        // to debug.
        //

        KeBugCheck (UNEXPECTED_KERNEL_MODE_TRAP);
    }

    //
    // read instruction prefixes
    //

    fPrefix = TRUE;
    pRM = RM32;
    operandsize = 4;
    operandmask = 0xffffffff;
    ibyte = 0;
    istream = (PUCHAR) UserFrame->Eip;

    try {

        while (fPrefix) {
            ibyte = ProbeAndReadUchar(istream);
            istream++;
            switch (ibyte) {
                case 0x2e:  // cs override
                case 0x36:  // ss override
                case 0x3e:  // ds override
                case 0x26:  // es override
                case 0x64:  // fs override
                case 0x65:  // gs override
                case 0xF3:  // rep
                case 0xF2:  // rep
                case 0xF0:  // lock
                    break;

                case 0x66:
                    // 16 bit operand override
                    operandsize = 2;
                    operandmask = 0xffff;
                    break;

                case 0x67:
                    // 16 bit address size override
                    // this is some non-flat code
                    goto try_exit;

                default:
                    fPrefix = FALSE;
                    break;
            }
        }

        //
        // Check instruction opcode
        //

        if (ibyte != 0xf7  &&  ibyte != 0xf6) {
            // this is not a DIV or IDIV opcode
            goto try_exit;
        }

        if (ibyte == 0xf6) {
            // this is a byte div or idiv
            operandsize = 1;
            operandmask = 0xff;
        }

        //
        // Get Mod R/M
        //

        ibyte = ProbeAndReadUchar (istream);
        istream++;
        Mod = MOD32 + (ibyte >> 6);
        rm  = ibyte & 7;

        //
        // put register values into accum
        //

        if (operandsize == 1  &&  (ibyte & 0xc0) == 0xc0) {
            pRM = RM8;
        }

        accum = 0;
        if (rm != Mod->RmDisplaceOnly) {
            if (rm == Mod->RmSib) {
                // get SIB
                ibyte = ProbeAndReadUchar(istream);
                istream++;
                i = (ibyte >> 3) & 7;
                if (i != 4) {
                    accum = GETREG(UserFrame, RM32[i]);
                    accum = accum << (ibyte >> 6);    // apply scaler
                }
                i = ibyte & 7;
                accum = accum + GETREG(UserFrame, RM32[i]);
            } else {
                // get register's value
                accum = GETREG(UserFrame, pRM[rm]);
            }
        }

        //
        // apply displacement to accum
        //

        if (Mod->RmDisplace & (1 << rm)) {
            if (Mod->Disp == 4) {
                i = ProbeAndReadUlong ((PULONG) istream);
            } else {
                ibyte = ProbeAndReadChar ((PCHAR)istream);
                i = (signed long) ((signed char) ibyte);    // sign extend
            }
            accum += i;
        }

        //
        // if this is an effective address, go get the data value
        //

        if (Mod->Disp && accum) {
            switch (operandsize) {
                case 1:  accum = ProbeAndReadUchar((PUCHAR) accum);    break;
                case 2:  accum = ProbeAndReadUshort((PUSHORT) accum);  break;
                case 4:  accum = ProbeAndReadUlong((PULONG) accum);    break;
            }
        }

        //
        // accum now contains the instruction operand, see if the
        // operand was really a zero
        //

        if (accum & operandmask) {
            // operand was non-zero, must be an overflow
            status = STATUS_INTEGER_OVERFLOW;
        }

try_exit: ;
    } except (EXCEPTION_EXECUTE_HANDLER) {
        NOTHING;
    }

    if (OldIrql < APC_LEVEL) {
        KeLowerIrql (OldIrql);
    }

    return status;
}

UCHAR
KiNextIStreamByte (
    IN  PKTRAP_FRAME UserFrame,
    IN  PUCHAR  *istream
    )

/*++

Routine Description:

    Reads the next byte from the istream pointed to by the UserFrame, and
    advances the EIP.


    Note: this function works for 32 bit code only

--*/

{

    UCHAR   ibyte;

    if (UserFrame->SegCs == KGDT_R0_CODE && (UserFrame->EFlags & EFLAGS_V86_MASK) == 0) {
        ibyte = **istream;
    } else {
        ibyte = ProbeAndReadUchar (*istream);
    }

    *istream += 1;
    return ibyte;
}

BOOLEAN
Ki386CheckDelayedNpxTrap (
    IN  PKTRAP_FRAME UserFrame,
    IN  PFX_SAVE_AREA NpxFrame
    )

/*++

Routine Description:

    This function gains control from the Trap07 handler.  It examines
    the user mode instruction to see if it's a NoWait NPX instruction.
    Such instructions do not generate floating point exceptions - this
    check needs to be done due to the way 80386/80387 systems are
    implemented.  Such machines will generate a floating point exception
    interrupt when the kernel performs an FRSTOR to reload the thread's
    NPX context.  If the thread's next instruction is a NoWait style
    instruction, then we clear the exception or emulate the instruction.

    AND... due to a different 80386/80387 "feature" the kernel needs
    to use FWAIT at times which can causes 80487's to generate delayed
    exceptions that can lead to the same problem described above.

    Note: If the CR0_NE = 0 NPX mode is deprecated, this routine may be unnecessary,
    as the no-wait style instructions should not generate a pending FP exception.

Arguments:

    UserFrame - Trap frame of the exception
    NpxFrame - Thread's NpxFrame  (WARNING: may not have NpxState)

    Interrupts are disabled.

Return Value:

    FALSE - Dispatch NPX exception to user mode
    TRUE - Exception handled, continue

    Note that this function toggles interrupts on/off, possibly affecting the
    caller's NPX state. Interrupts remain disabled on exit.
    
--*/

{

    EXCEPTION_RECORD ExceptionRecord;
    UCHAR       ibyte1, ibyte2 = 0, inmodrm, status;
    USHORT      StatusWord, ControlWord, UsersWord;
    PUCHAR      istream;
    BOOLEAN     fPrefix;
    UCHAR       rm;
    PKMOD       Mod;
    ULONG       accum, i, NpxState;
    KIRQL       OldIrql;

    status = 0;

    //
    // read instruction prefixes
    //

    fPrefix = TRUE;
    istream = (PUCHAR) UserFrame->Eip;

    OldIrql = KeGetCurrentIrql();
    if (OldIrql < APC_LEVEL) {
        KeRaiseIrql(APC_LEVEL, &OldIrql);
    }

    // Enable interrupts since the code will touch the instruction stream. Note that the trap frame 
    // integrity is protected by the elevated IRQL.
    _asm {
        sti
    }
    
    try {

        do {
            ibyte1 = KiNextIStreamByte (UserFrame, &istream);
            switch (ibyte1) {
                case 0x2e:  // cs override
                case 0x36:  // ss override
                case 0x3e:  // ds override
                case 0x26:  // es override
                case 0x64:  // fs override
                case 0x65:  // gs override
                    break;

                default:
                    fPrefix = FALSE;
                    break;
            }
        } while (fPrefix);

        //
        // Check for coprocessor NoWait NPX instruction
        //

        ibyte2 = KiNextIStreamByte (UserFrame, &istream);
        inmodrm = (ibyte2 >> 3) & 0x7;

        for (i=0; NoWaitNpxInstructions[i].Opcode1; i++) {

            if (NoWaitNpxInstructions[i].Opcode1 == ibyte1) {

                //
                // first opcode byte matched - check second part of opcode
                //

                if (NoWaitNpxInstructions[i].ModRm) {

                    //
                    // modrm only applies for opcode in range 0-0xbf
                    //

                    if (((ibyte2 & 0xc0) != 0xc0) &&
                        (NoWaitNpxInstructions[i].Opcode2 == inmodrm)) {

                        //
                        // This is a no-wait NPX instruction
                        //

                        status = NoWaitNpxInstructions[i].type;
                        break;
                    }

                } else {
                    if (NoWaitNpxInstructions[i].Opcode2 == ibyte2) {

                        //
                        // This is a no-wait NPX instruction
                        //

                        status = NoWaitNpxInstructions[i].type;
                        break;
                    }
                }
            }
        }

    } except (EXCEPTION_EXECUTE_HANDLER) {
        NOTHING;
    }

    // Disable interrupts as we are done touching the instruction stream, and may return
    // to the caller.
    _asm {
        cli
    }
    
    if (status == 0) {
        //
        // Dispatch coprocessor exception to user mode
        //
        if (OldIrql < APC_LEVEL) {
            KeLowerIrql (OldIrql);
        }
        return FALSE;
    }

    if (status == 1) {
        //
        // Ignore pending exception, user mode instruction does not trap
        // on pending execptions and it will clear/mask the pending exceptions
        //

        // The thread's NPX state may no longer be resident. Avoid executing with
        // another thread's NPX state.
        NpxState = KeGetCurrentThread()->NpxState;
        
        _asm {
            mov     eax, cr0
            and     eax, NOT (CR0_MP+CR0_EM+CR0_TS)
            or       eax, NpxState
            mov     cr0, eax
        }

        NpxFrame->Cr0NpxState &= ~CR0_TS;
        if (OldIrql < APC_LEVEL) {
            KeLowerIrql (OldIrql);
        }
        return TRUE;
    }

    //
    // This is either FNSTSW or FNSTCW.  Both of these instructions get
    // a value from the coprocessor without effecting the pending exception
    // state.  To do this we emulate the instructions.
    //

    //
    // Read the coprocessors Status & Control word state, then re-enable
    // interrupts. 
    //

    //
    // NOTE: The new compiler is generating a FWAIT at the
    // entry to the try/except block if it sees inline
    // fp instructions, even if they are only control word accesses.
    // put this stuff in another function to fool it.
    //

    // Since we toggled the interrupt state, our NPX state might not be resident.
    
    if (KeGetCurrentThread()->NpxState == NPX_STATE_NOT_LOADED) {
        if (KeI386FxsrPresent) {
            ControlWord = NpxFrame->U.FxArea.ControlWord;
            StatusWord = NpxFrame->U.FxArea.StatusWord;
        } else {
            ControlWord = (USHORT) NpxFrame->U.FnArea.ControlWord;
            StatusWord = (USHORT) NpxFrame->U.FnArea.StatusWord;
        }
    } else {
        KipWorkAroundCompiler (&StatusWord, &ControlWord);
    }
    
    if (status == 4) {
        //
        // Emulate FNSTSW AX
        //
        
        UserFrame->Eip = (ULONG)istream;
        UserFrame->Eax = (UserFrame->Eax & 0xFFFF0000) | StatusWord;
        if (OldIrql < APC_LEVEL) {
            KeLowerIrql (OldIrql);
        }
        return TRUE;
    }

    // Since the following code examines the instruction stream, re-enable interrupts.
    _asm {
        sti
    }

    if (status == 2) {
        UsersWord = ControlWord;
    } else {
        UsersWord = StatusWord;
    }

    try {

        //
        // decode Mod/RM byte
        //

        Mod = MOD32 + (ibyte2 >> 6);
        rm  = ibyte2 & 7;

        //
        // Decode the instruction's word pointer into accum
        //

        accum = 0;
        if (rm != Mod->RmDisplaceOnly) {
            if (rm == Mod->RmSib) {
                // get SIB
                ibyte1 = KiNextIStreamByte (UserFrame, &istream);
                i = (ibyte1 >> 3) & 7;
                if (i != 4) {
                    accum = GETREG(UserFrame, RM32[i]);
                    accum = accum << (ibyte1 >> 6);    // apply scaler
                }
                i = ibyte1 & 7;
                accum = accum + GETREG(UserFrame, RM32[i]);
            } else {
                // get register's value
                accum = GETREG(UserFrame, RM32[rm]);
            }
        }

        //
        // apply displacement to accum
        //

        if (Mod->RmDisplace & (1 << rm)) {
            if (Mod->Disp == 4) {
                i = (KiNextIStreamByte (UserFrame, &istream) << 0) |
                    (KiNextIStreamByte (UserFrame, &istream) << 8) |
                    (KiNextIStreamByte (UserFrame, &istream) << 16) |
                    (KiNextIStreamByte (UserFrame, &istream) << 24);
            } else {
                ibyte1 = KiNextIStreamByte (UserFrame, &istream);
                i = (signed long) ((signed char) ibyte1);    // sign extend
            }
            accum += i;
        }

        //
        // Set the word pointer
        //

        if (UserFrame->SegCs == KGDT_R0_CODE && (UserFrame->EFlags & EFLAGS_V86_MASK) == 0) {
            *((PUSHORT) accum) = UsersWord;
        } else {
            ProbeAndWriteUshort ((PUSHORT) accum, UsersWord);
        }
        UserFrame->Eip = (ULONG)istream;

    } except (KiCopyInformation(&ExceptionRecord,
                (GetExceptionInformation())->ExceptionRecord)) {

        //
        // Faulted addressing user's memory.
        // Set the address of the exception to the current program address
        // and raise the exception by calling the exception dispatcher.
        //
        ExceptionRecord.ExceptionAddress = (PVOID)(UserFrame->Eip);
        if (OldIrql < APC_LEVEL) {
            KeLowerIrql (OldIrql);
        }
        // Note: Interrupts are still enabled along this path.
        KiDispatchException(
            &ExceptionRecord,
            NULL,                // ExceptionFrame
            UserFrame,
            UserMode,
            TRUE
        );
    }

    // Lower IRQL and disable interrutps (caller expects them disabled upon return).
    if (OldIrql < APC_LEVEL) {
        KeLowerIrql (OldIrql);
    }
    _asm {
        cli
    }
    
    return TRUE;
}

//
// Code description is above. We do this here to stop the compiler
// from putting fwait in the try/except block
//
// Read the coprocessor's Status & Control word state.
//
// Interrupts must be disabled.
//
//

VOID
KipWorkAroundCompiler (
    IN PUSHORT StatusWord,
    IN PUSHORT ControlWord
    )

{

    USHORT sw;
    USHORT cw;
    
    sw = *StatusWord;
    cw = *ControlWord;

    _asm {
        mov     eax, cr0
        mov     ecx, eax
        and     eax, NOT (CR0_MP+CR0_EM+CR0_TS)
        mov     cr0, eax

        fnstsw  sw
        fnstcw  cw

        mov     cr0, ecx
    }

    *StatusWord = sw;
    *ControlWord = cw;
}

VOID
FASTCALL
KiCheckForSListAddress (
    IN PKTRAP_FRAME TrapFrame
    )

/*++

Routine Description:

    This function is called from the APC and DPC interrupt code to check if
    the specified EIP lies within the SLIST pop code. If the specified EIP
    lies within the SLIST code, then RIP is reset to the SLIST resume address.

Arguments:

    TrapFrame - Supplies the address of a trap frame.

Return Value:

    None.

--*/

{

    USHORT SegCs;
    ULONG Eip;

    //
    // Check for kernel mode and user mode execution.
    //

    SegCs = (USHORT)TrapFrame->SegCs;
    Eip = TrapFrame->Eip;
    if (SegCs == KGDT_R0_CODE) {
        if ((Eip >= (ULONG)&ExpInterlockedPopEntrySListResume) &&
            (Eip <= (ULONG)&ExpInterlockedPopEntrySListEnd)) {

            TrapFrame->Eip = (ULONG)&ExpInterlockedPopEntrySListResume;
        }

    } else if (SegCs == (KGDT_R3_CODE | RPL_MASK)) {
        if ((Eip >= (ULONG)KeUserPopEntrySListResume) &&
            (Eip <= (ULONG)KeUserPopEntrySListEnd)) {

            TrapFrame->Eip = (ULONG)KeUserPopEntrySListResume;
        }
    }

    return;
}

BOOLEAN
FASTCALL
KeInvalidAccessAllowed (
    __in_opt PVOID TrapInformation
    )

/*++

Routine Description:

    Mm will pass a pointer to a trap frame prior to issuing a bugcheck on
    a pagefault.  This routine lets Mm know if it is ok to bugcheck.  The
    specific case we must protect are the interlocked pop sequences which can
    blindly access memory that may have been freed and/or reused prior to the
    access.  We don't want to bugcheck the system in these cases, so we check
    the instruction pointer here.

    For a usermode fault, Mm uses this routine for similar reasons, to determine
    whether a guard page fault should be ignored.

Arguments:

    TrapInformation - Supplies a trap frame pointer.  NULL means return False.

Return Value:

    True if the invalid access should be ignored, False otherwise.

--*/

{

    ULONG slistFaultIP;
    PKTRAP_FRAME trapFrame;

    if (ARGUMENT_PRESENT(TrapInformation) == FALSE) {
        return FALSE;
    }

    trapFrame = TrapInformation;
    switch (trapFrame->SegCs) {

        case KGDT_R0_CODE:

            //
            // Fault occured in kernel mode
            //

            slistFaultIP = (ULONG)&ExpInterlockedPopEntrySListFault;
            break;

        case KGDT_R3_CODE | RPL_MASK:

            //
            // Fault occured in native usermode
            //

            slistFaultIP = (ULONG)KeUserPopEntrySListFault;
            break;

        default:
            return FALSE;
    }

    if (trapFrame->Eip == slistFaultIP) {
        return TRUE;

    } else {
        return FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ke\i386\trap.asm ===
title  "Trap Processing"
;++
;
; Copyright (c) Microsoft Corporation. All rights reserved. 
;
; You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
; If you do not agree to the terms, do not use the code.
;
;
; Module Name:
;
;    trap.asm
;
; Abstract:
;
;    This module implements the code necessary to field and process i386
;    trap conditions.
;
;--
.586p
        .xlist
KERNELONLY  equ     1
include ks386.inc
include callconv.inc                    ; calling convention macros
include i386\kimacro.inc
include mac386.inc
include i386\mi.inc
include ..\..\vdm\i386\vdm.inc
include vdmtib.inc
include fastsys.inc
include irqli386.inc
        .list

FAST_BOP        equ      1


        page ,132
        extrn   _KeI386FxsrPresent:BYTE
        extrn   ExpInterlockedPopEntrySListFault:DWORD
        extrn   ExpInterlockedPopEntrySListResume:DWORD
        extrn   _KeGdiFlushUserBatch:DWORD
        extrn   _KeTickCount:DWORD
        extrn   _ExpTickCountMultiplier:DWORD
        extrn   _KiDoubleFaultTSS:dword
        extrn   _KeErrorMask:dword
        extrn   _KiNMITSS:dword
        extrn   _KeServiceDescriptorTable:dword
if DBG
        extrn   _MmInjectUserInpageErrors:dword
        EXTRNP  _MmTrimProcessMemory,1
endif
        extrn   _KiHardwareTrigger:dword
        extrn   _KiBugCheckData:dword
        extrn   _KdpOweBreakpoint:byte
        extrn   Ki386BiosCallReturnAddress:near
        extrn   _PoHiberInProgress:byte
        extrn   _KiI386PentiumLockErrataPresent:BYTE
        extrn   _KdDebuggerNotPresent:byte
        extrn   _KdDebuggerEnabled:byte
        EXTRNP  _KeEnterKernelDebugger,0
        EXTRNP  _KiDeliverApc,3
        EXTRNP  _PsConvertToGuiThread,0
        EXTRNP  _ZwUnmapViewOfSection,2

        EXTRNP  _KiHandleNmi,0
        EXTRNP  _KiSaveProcessorState,2
        EXTRNP  _HalHandleNMI,1,IMPORT
        EXTRNP  _HalBeginSystemInterrupt,3,IMPORT
        EXTRNP  _HalEndSystemInterrupt,2,IMPORT
        EXTRNP  _KiDispatchException,5
        EXTRNP  _PsWatchWorkingSet,3
        extrn   _PsWatchEnabled:byte
        EXTRNP  _MmAccessFault,4
        extrn   _MmUserProbeAddress:DWORD
        EXTRNP  _KeBugCheck2,6
        EXTRNP  _KeTestAlertThread,1
        EXTRNP  _KiContinue,3
        EXTRNP  _KiRaiseException,5
        EXTRNP  _VdmDispatchOpcodeV86_try,1
        EXTRNP  _VdmDispatchOpcode_try,1
        EXTRNP  _VdmDispatchPageFault,3
        EXTRNP  _Ki386VdmReflectException,1
        EXTRNP  _Ki386VdmSegmentNotPresent,0
        extrn   _DbgPrint:proc
        EXTRNP  _KdSetOwedBreakpoints
        extrn   _KiFreezeFlag:dword
        EXTRNP  _Ki386CheckDivideByZeroTrap,1
        EXTRNP  _Ki386CheckDelayedNpxTrap,2
        EXTRNP  _VdmDispatchIRQ13, 1

        EXTRNP  _VdmDispatchBop,1
        EXTRNP  _VdmFetchBop1,1
        EXTRNP  _VdmFetchBop4,1
        EXTRNP  _VdmTibPass1,3
        extrn   _KeI386VirtualIntExtensions:dword
        EXTRNP  _NTFastDOSIO,2
        EXTRNP  _NtSetLdtEntries,6
	EXTRNP  _NtCallbackReturn,3
        extrn   OpcodeIndex:byte
        extrn   _KeFeatureBits:DWORD
        extrn   _KeServiceDescriptorTableShadow:dword
        extrn   _KiIgnoreUnexpectedTrap07:byte
        extrn   _KeUserPopEntrySListFault:dword
        extrn   _KeUserPopEntrySListResume:dword

ifndef NT_UP

        EXTRNP  KiAcquireQueuedSpinLockCheckForFreeze,2,,FASTCALL
        EXTRNP  KeReleaseQueuedSpinLockFromDpcLevel,1,,FASTCALL

endif

;
; Equates for exceptions which cause system fatal error
;

EXCEPTION_DIVIDED_BY_ZERO       EQU     0
EXCEPTION_DEBUG                 EQU     1
EXCEPTION_NMI                   EQU     2
EXCEPTION_INT3                  EQU     3
EXCEPTION_BOUND_CHECK           EQU     5
EXCEPTION_INVALID_OPCODE        EQU     6
EXCEPTION_NPX_NOT_AVAILABLE     EQU     7
EXCEPTION_DOUBLE_FAULT          EQU     8
EXCEPTION_NPX_OVERRUN           EQU     9
EXCEPTION_INVALID_TSS           EQU     0AH
EXCEPTION_SEGMENT_NOT_PRESENT   EQU     0BH
EXCEPTION_STACK_FAULT           EQU     0CH
EXCEPTION_GP_FAULT              EQU     0DH
EXCEPTION_RESERVED_TRAP         EQU     0FH
EXCEPTION_NPX_ERROR             EQU     010H
EXCEPTION_ALIGNMENT_CHECK       EQU     011H

;
; Exception flags
;

EXCEPT_UNKNOWN_ACCESS           EQU     0H
EXCEPT_LIMIT_ACCESS             EQU     10H

;
; Equates for some opcodes and instruction prefixes
;

IOPL_MASK                       EQU     3000H
IOPL_SHIFT_COUNT                EQU     12

;
; Debug register 6 (dr6) BS (single step) bit mask
;

DR6_BS_MASK                     EQU     4000H

;
; EFLAGS overflow bit
;

EFLAGS_OF_BIT                   EQU     4000H

;
; The mask of selector's table indicator (ldt or gdt)
;

TABLE_INDICATOR_MASK            EQU     4

;
; Opcode for Pop SegReg and iret instructions
;

POP_DS                          EQU     1FH
POP_ES                          EQU     07h
POP_FS                          EQU     0A10FH
POP_GS                          EQU     0A90FH
IRET_OP                         EQU     0CFH
CLI_OP                          EQU     0FAH
STI_OP                          EQU     0FBH
PUSHF_OP                        EQU     9CH
POPF_OP                         EQU     9DH
INTNN_OP                        EQU     0CDH
FRSTOR_ECX                      EQU     021DD9Bh
FWAIT_OP                        EQU     09bh

;
;   Force assume into place
;

_TEXT$00   SEGMENT PARA PUBLIC 'CODE'
        ASSUME  DS:NOTHING, ES:NOTHING, SS:NOTHING, FS:NOTHING, GS:NOTHING
_TEXT$00   ENDS

_DATA   SEGMENT DWORD PUBLIC 'DATA'

;
; Definitions for gate descriptors
;

GATE_TYPE_386INT        EQU     0E00H
GATE_TYPE_386TRAP       EQU     0F00H
GATE_TYPE_TASK          EQU     0500H
D_GATE                  EQU     0
D_PRESENT               EQU     8000H
D_DPL_3                 EQU     6000H
D_DPL_0                 EQU     0

;
; Definitions for present x86 trap and interrupt gate attributes
;

D_TRAP032               EQU     D_PRESENT+D_DPL_0+D_GATE+GATE_TYPE_386TRAP
D_TRAP332               EQU     D_PRESENT+D_DPL_3+D_GATE+GATE_TYPE_386TRAP
D_INT032                EQU     D_PRESENT+D_DPL_0+D_GATE+GATE_TYPE_386INT
D_INT332                EQU     D_PRESENT+D_DPL_3+D_GATE+GATE_TYPE_386INT
D_TASK                  EQU     D_PRESENT+D_DPL_0+D_GATE+GATE_TYPE_TASK

;
;       This is the protected mode interrupt descriptor table.
;

if DBG
;
; NOTE - embedded enlish messages won't fly for NLS! (OK for debug code only)
;

BadInterruptMessage db 0ah,7,7,'!!! Unexpected Interrupt %02lx !!!',0ah,00

Ki16BitStackTrapMessage  db 0ah,'Exception inside of 16bit stack',0ah,00

public KiBiosReenteredAssert
KiBiosReenteredAssert   db 0ah,'Bios has been re-entered. Not safe. ',0ah,00
endif

;
; NMI only one processor at a time.  This is handled in the kernel
; using a queued spinlock to avoid thrashing the lock in case a
; crash dump is underway.
;

KiLockNMI   dd  0

;
; Define a value that we'll use to track the processor that owns the NMI lock.
; This information is needed in order to handle nested NMIs properly.  A
; distinguished value is used in cases where the NMI lock is unowned.
;

ifndef NT_UP

KI_NMI_UNOWNED equ 0FFFFFFFFh

KiNMIOwner dd KI_NMI_UNOWNED

endif

;
; Define a counter that will be used to limit NMI recursion.
;

KiNMIRecursionCount dd 0

;++
;
;   DEFINE_SINGLE_EMPTY_VECTOR - helper for DEFINE_EMPTY_VECTORS
;
;--

DEFINE_SINGLE_EMPTY_VECTOR macro    number
IDTEntry    _KiUnexpectedInterrupt&number, D_INT032
_TEXT$00   SEGMENT
        public  _KiUnexpectedInterrupt&number
_KiUnexpectedInterrupt&number proc
        push    dword ptr (&number + PRIMARY_VECTOR_BASE)
        ;;  jmp     _KiUnexpectedInterruptTail        ; replaced with following jmp which will then jump
        jmp _KiAfterUnexpectedRange                   ; to the _KiUnexpectedInterruptTail location
                                                      ; in a manner suitable for BBT, which needs to treat
                                                      ; this whole set of KiUnexpectedInterrupt&number
                                                      ; vectors as DATA, meaning a relative jmp will not
                                                      ; be adjusted properly in the BBT Instrumented or
                                                      ; Optimized code.
                                                      ;

_KiUnexpectedInterrupt&number endp
_TEXT$00   ENDS

        endm

FPOFRAME macro a, b
.FPO ( a, b, 0, 0, 0, FPO_TRAPFRAME )
endm

FXSAVE_ESI  macro
    db  0FH, 0AEH, 06
endm

FXSAVE_ECX  macro
    db  0FH, 0AEH, 01
endm

FXRSTOR_ECX macro
    db  0FH, 0AEH, 09
endm

;++
;
;   DEFINE_EMPTY_VECTORS emits an IDTEntry macro (and thus and IDT entry)
;   into the data segment.  It then emits an unexpected interrupt target
;   with push of a constant into the code segment.  Labels in the code
;   segment are defined to bracket the unexpected interrupt targets so
;   that KeConnectInterrupt can correctly test for them.
;
;   Empty vectors will be defined from 30 to ff, which is the hardware
;   vector set.
;
;--

NUMBER_OF_IDT_VECTOR    EQU     0ffH

DEFINE_EMPTY_VECTORS macro

;
;   Set up
;

        empty_vector = 00H

_TEXT$00   SEGMENT
        public  _KiStartUnexpectedRange@0
_KiStartUnexpectedRange@0   equ     $
_TEXT$00   ENDS

        rept (NUMBER_OF_IDT_VECTOR - (($ - _IDT)/8)) + 1

        DEFINE_SINGLE_EMPTY_VECTOR  %empty_vector
        empty_vector = empty_vector + 1

        endm    ;; rept

_TEXT$00   SEGMENT
        public  _KiEndUnexpectedRange@0
_KiEndUnexpectedRange@0     equ     $


        ;; added by to handle BBT unexpected interrupt problem
        ;;
_KiAfterUnexpectedRange     equ     $               ;;  BBT
        jmp     [KiUnexpectedInterruptTail]         ;;  BBT

KiUnexpectedInterruptTail dd offset _KiUnexpectedInterruptTail   ;;  BBT

        public _KiBBTUnexpectedRange
_KiBBTUnexpectedRange     equ     $               ;;  BBT

_TEXT$00   ENDS

        endm    ;; DEFINE_EMPTY_VECTORS macro

IDTEntry macro  name,access
        dd      offset FLAT:name
        dw      access
        dw      KGDT_R0_CODE
        endm

INIT    SEGMENT DWORD PUBLIC 'CODE'

;
; The IDT table is put into the INIT code segment so the memory
; can be reclaimed afer bootup
;

ALIGN 4
                public  _IDT, _IDTLEN, _IDTEnd
_IDT            label byte

IDTEntry        _KiTrap00, D_INT032             ; 0: Divide Error
IDTEntry        _KiTrap01, D_INT032             ; 1: DEBUG TRAP
IDTEntry        _KiTrap02, D_INT032             ; 2: NMI/NPX Error
IDTEntry        _KiTrap03, D_INT332             ; 3: Breakpoint
IDTEntry        _KiTrap04, D_INT332             ; 4: INTO
IDTEntry        _KiTrap05, D_INT032             ; 5: BOUND/Print Screen
IDTEntry        _KiTrap06, D_INT032             ; 6: Invalid Opcode
IDTEntry        _KiTrap07, D_INT032             ; 7: NPX Not Available
IDTEntry        _KiTrap08, D_INT032             ; 8: Double Exception
IDTEntry        _KiTrap09, D_INT032             ; 9: NPX Segment Overrun
IDTEntry        _KiTrap0A, D_INT032             ; A: Invalid TSS
IDTEntry        _KiTrap0B, D_INT032             ; B: Segment Not Present
IDTEntry        _KiTrap0C, D_INT032             ; C: Stack Fault
IDTEntry        _KiTrap0D, D_INT032             ; D: General Protection
IDTEntry        _KiTrap0E, D_INT032             ; E: Page Fault
IDTEntry        _KiTrap0F, D_INT032             ; F: Intel Reserved

IDTEntry        _KiTrap10, D_INT032             ;10: 486 coprocessor error
IDTEntry        _KiTrap11, D_INT032             ;11: 486 alignment
IDTEntry        _KiTrap0F, D_INT032             ;12: Intel Reserved
IDTEntry        _KiTrap0F, D_INT032             ;13: XMMI unmasked numeric exception
IDTEntry        _KiTrap0F, D_INT032             ;14: Intel Reserved
IDTEntry        _KiTrap0F, D_INT032             ;15: Intel Reserved
IDTEntry        _KiTrap0F, D_INT032             ;16: Intel Reserved
IDTEntry        _KiTrap0F, D_INT032             ;17: Intel Reserved

IDTEntry        _KiTrap0F, D_INT032             ;18: Intel Reserved
IDTEntry        _KiTrap0F, D_INT032             ;19: Intel Reserved
IDTEntry        _KiTrap0F, D_INT032             ;1A: Intel Reserved
IDTEntry        _KiTrap0F, D_INT032             ;1B: Intel Reserved
IDTEntry        _KiTrap0F, D_INT032             ;1C: Intel Reserved
IDTEntry        _KiTrap0F, D_INT032             ;1D: Intel Reserved
IDTEntry        _KiTrap0F, D_INT032             ;1E: Intel Reserved
IDTEntry        _KiTrap0F, D_INT032             ;1F: Reserved for APIC

;
; Note IDTEntry 0x21 is reserved for WOW apps.
;

        rept 2AH - (($ - _IDT)/8)
IDTEntry        0, 0                            ;invalid IDT entry
        endm
IDTEntry        _KiGetTickCount,  D_INT332          ;2A: KiGetTickCount service
IDTEntry        _KiCallbackReturn,  D_INT332        ;2B: KiCallbackReturn
IDTEntry        _KiRaiseAssertion,  D_INT332        ;2C: KiRaiseAssertion service
IDTEntry        _KiDebugService,  D_INT332          ;2D: debugger calls
IDTEntry        _KiSystemService, D_INT332          ;2E: system service calls
IDTEntry        _KiTrap0F, D_INT032                 ;2F: Reserved for APIC

;
;   Generate per-vector unexpected interrupt entries for 30 - ff
;
        DEFINE_EMPTY_VECTORS

_IDTLEN         equ     $ - _IDT
_IDTEnd         equ     $

INIT    ends

                public  _KiUnexpectedEntrySize
_KiUnexpectedEntrySize          dd  _KiUnexpectedInterrupt1 - _KiUnexpectedInterrupt0

;
; defines all the possible instruction prefix
;

PrefixTable     label   byte
        db      0f2h                    ; rep prefix
        db      0f3h                    ; rep ins/outs prefix
        db      67h                     ; addr prefix
        db      0f0h                    ; lock prefix
        db      66h                     ; operand prefix
        db      2eh                     ; segment override prefix:cs
        db      3eh                     ; ds
        db      26h                     ; es
        db      64h                     ; fs
        db      65h                     ; gs
        db      36h                     ; ss

PREFIX_REPEAT_COUNT     EQU     11      ; Prefix table length

;
; defines all the possible IO privileged IO instructions
;

IOInstructionTable      label byte
;       db      0fah                    ; cli
;       db      0fdh                    ; sti
        db      0e4h, 0e5h, 0ech, 0edh  ; IN
        db      6ch, 6dh                ; INS
        db      0e6h, 0e7h, 0eeh, 0efh  ; OUT
        db      6eh, 6fh                ; OUTS

IO_INSTRUCTION_TABLE_LENGTH     EQU     12

;
; definition for  floating status word error mask
;

FSW_INVALID_OPERATION   EQU     1
FSW_DENORMAL            EQU     2
FSW_ZERO_DIVIDE         EQU     4
FSW_OVERFLOW            EQU     8
FSW_UNDERFLOW           EQU     16
FSW_PRECISION           EQU     32
FSW_STACK_FAULT         EQU     64
FSW_CONDITION_CODE_0    EQU     100H
FSW_CONDITION_CODE_1    EQU     200H
FSW_CONDITION_CODE_2    EQU     400H
FSW_CONDITION_CODE_3    EQU     4000H

_DATA   ENDS

_TEXT$00   SEGMENT
        ASSUME  DS:NOTHING, ES:NOTHING, SS:FLAT, FS:NOTHING, GS:NOTHING

        page , 132
        subttl "Macro to Handle v86 trap d"
;++
;
; Macro Description:
;
;    This macro is a fast way to handle v86 bop instructions.
;    Note, all the memory write operations in this macro are done in such a
;    way that if a page fault occurs the memory will still be in a consistent
;    state.
;
;    That is, we must process the trapped instruction in the following order:
;
;    1. Read and Write user memory
;    2. Update VDM state flags
;    3. Update trap frame
;
; Arguments:
;
;    interrupts disabled
;
; Return Value:
;
;--

FAST_V86_TRAP_6  MACRO

local   DoFastIo, a, b

BOP_FOR_FASTWRITE       EQU     4350C4C4H
BOP_FOR_FASTREAD        EQU     4250C4C4H
TRAP6_IP                EQU     32              ; 8 * 4
TRAP6_CS                EQU     36              ; 8 * 4 + 4
TRAP6_FLAGS             EQU     40              ; 8 * 4 + 8
TRAP6_SP                EQU     44              ; 8 * 4 + 12
TRAP6_SS                EQU     48              ; 8 * 4 + 16
TRAP6_ES                EQU     52
TRAP6_DS                EQU     56
TRAP6_FS                EQU     60
TRAP6_GS                EQU     64
TRAP6_EAX               EQU     28
TRAP6_EDX               EQU     20

        pushad          ;eax, ecx, edx, ebx, old esp, ebp, esi, edi
        mov     eax, KGDT_R3_DATA OR RPL_MASK
        mov     ds, ax
        mov     es, ax

        mov     eax, KGDT_R0_PCR
        mov     fs, ax

        mov     ax, word ptr [esp+TRAP6_CS] ; [eax] = v86 user cs
        shl     eax, 4
        and     dword ptr [esp+TRAP6_IP], 0FFFFH
        add     eax, [esp+TRAP6_IP]; [eax] = addr of BOP

        ;
        ; Set the magic PCR bit indicating we are executing VDM management code
        ; so faults on potentially invalid or plain bad user addresses do
        ; not bugcheck the system.  Note both interrupts are disabled and
        ; (for performance reasons) we do not have any exception handlers
        ; set up.
        ;

        mov     dword ptr PCR[PcVdmAlert], offset FLAT:V86Trap6Recovery

        ;
        ; Fetch the actual opcode from user space.
        ;

        mov     edx, [eax]      ; [edx] = xxxxc4c4  bop + maj bop # + mi #

        cmp     edx, BOP_FOR_FASTREAD
        je      DoFastIo

        cmp     edx, BOP_FOR_FASTWRITE
        je      DoFastIo

        cmp     dx, 0c4c4h      ; Is it a bop?
        jne     V86Trap6PassThrough ; It's an error condition

        mov     eax,PCR[PcTeb]
        shr     edx, 16
        mov     eax,[eax].TeVdm

        cmp     eax, _MmUserProbeAddress     ; check if user address
        jae     V86Trap6PassThrough          ; if ae, then not user address

        and     edx, 0ffh
        mov     dword ptr [eax].VtEIEvent, VdmBop
        mov     dword ptr [eax].VtEIBopNumber, edx
        mov     dword ptr [eax].VtEIInstSize, 3
        lea     eax, [eax].VtVdmContext

        ;
        ;       Save V86 state to Vdm structure
        ;

        mov     edx, [esp+TRAP6_EDX]  ; get edx

        cmp     eax, _MmUserProbeAddress     ; check if user address
        jae     V86Trap6PassThrough          ; if ae, then not user address

        mov     [eax].CsEcx, ecx
        mov     [eax].CsEbx, ebx      ; Save non-volatile registers
        mov     [eax].CsEsi, esi
        mov     [eax].CsEdi, edi
        mov     ecx, [esp+TRAP6_EAX]  ; Get eax
        mov     [eax].CsEbp, ebp
        mov     [eax].CsEdx, edx
        mov     [eax].CsEax, ecx

        mov     ebx, [esp]+TRAP6_IP   ; (ebx) = user ip
        mov     ecx, [esp]+TRAP6_CS   ; (ecx) = user cs
        mov     esi, [esp]+TRAP6_SP   ; (esi) = user esp
        mov     edi, [esp]+TRAP6_SS   ; (edi) = user ss
        mov     edx, [esp]+TRAP6_FLAGS; (edx) = user eflags
        mov     [eax].CsEip, ebx
        and     esi, 0ffffh
        mov     [eax].CsSegCs, ecx
        mov     [eax].CsEsp, esi
        mov     [eax].CsSegSs, edi
        test    _KeI386VirtualIntExtensions, V86_VIRTUAL_INT_EXTENSIONS
        jz      short @f

        test    edx, EFLAGS_VIF
        jnz     short a

        and     edx, NOT EFLAGS_INTERRUPT_MASK
        jmp     short a

@@:     test    ds:FIXED_NTVDMSTATE_LINEAR, VDM_VIRTUAL_INTERRUPTS ; check interrupt
        jnz     short a

        and     edx, NOT EFLAGS_INTERRUPT_MASK
a:
        mov     [eax].CsEFlags, edx
        mov     ebx, [esp]+TRAP6_DS   ; (ebx) = user ds
        mov     ecx, [esp]+TRAP6_ES   ; (ecx) = user es
        mov     edx, [esp]+TRAP6_FS   ; (edx) = user fs
        mov     esi, [esp]+TRAP6_GS   ; (esi) = user gs
        mov     [eax].CsSegDs, ebx
        mov     [eax].CsSegEs, ecx
        mov     [eax].CsSegFs, edx
        mov     [eax].CsSegGs, esi

        ;
        ; Load Monitor context
        ;

        add     eax, VtMonitorContext - VtVdmContext ; (eax)->monitor context

        mov     ebx, [eax].CsEbx        ; We don't need to load volatile registers.
        mov     esi, [eax].CsEsi        ; because monitor uses SystemCall to return
        mov     edi, [eax].CsEdi        ; back to v86.  C compiler knows that
        mov     ebp, [eax].CsEbp        ; SystemCall does not preserve volatile
                                        ; registers.
                                        ; es, ds are set up already.

        ;
        ; Note these push instructions won't fail.  Do NOT combine the
        ; 'move ebx, [eax].CsEbx' with 'push ebx' to 'push [eax].CsEbx'
        ;

        push    ebx                     ; note, these push instructions won't fail
        push    esi
        push    edi
        push    ebp
        mov     dword ptr PCR[PcVdmAlert], offset FLAT:V86Trap6Recovery2

        mov     ebx, [eax].CsSegSs
        mov     esi, [eax].CsEsp
        mov     edi, [eax].CsEFlags
        mov     edx, [eax].CsSegCs
        mov     ecx, [eax].CsEip

        ;
        ; after this point, we don't need to worry about instruction fault
        ; Clear magic flag as no more potentially bogus references will be made.
        ;

        mov     dword ptr PCR[PcVdmAlert], 0


        and     edi, EFLAGS_USER_SANITIZE
        or      edi, EFLAGS_INTERRUPT_MASK
        mov     [esp + TRAP6_SS + 16], ebx  ; Build Iret frame (can not single step!)
        mov     [esp + TRAP6_SP + 16], esi
        mov     [esp + TRAP6_FLAGS + 16], edi
        test    edi, EFLAGS_V86_MASK
        jne     short @f
        or      edx, RPL_MASK
        cmp     edx, 8
        jge     short @f
        mov     edx, KGDT_R3_CODE OR RPL_MASK
@@:     mov     [esp + TRAP6_CS + 16], edx
        mov     [esp + TRAP6_IP + 16], ecx

        pop     ebp
        pop     edi
        pop     esi
        pop     ebx

        add     esp, 32

        ;
        ; Adjust Tss esp0 value and set return value to SUCCESS
        ;

        mov     ecx, PCR[PcPrcbData+PbCurrentThread]
        mov     ecx, [ecx].thInitialStack
        mov     edx, PCR[PcTss]

.errnz (EFLAGS_V86_MASK AND 0FF00FFFFh)

        test    byte ptr [esp+8+2],EFLAGS_V86_MASK/010000h  ; is this a V86 frame?
        jnz     short @f
        sub     ecx, TsV86Gs - TsHardwareSegSs
@@:
        sub     ecx, NPX_FRAME_LENGTH
        xor     eax, eax         ; ret status = SUCCESS
        mov     [edx].TssEsp0, ecx

        mov     edx, KGDT_R3_TEB OR RPL_MASK
        mov     fs, dx
        iretd

DoFastIo:

        ;
        ; Clear magic flag as no bogus references are going to be made.
        ;

        mov     dword ptr PCR[PcVdmAlert], 0

        xor     eax, eax
        mov     edx, [esp]+TRAP6_EDX    ; Restore edx
        add     esp, 7 * 4              ; leave eax in the TsErrCode
        xchg    [esp], eax              ; Restore eax, store a zero errcode
        sub     esp, TsErrcode          ; build a trap frame
        mov     [esp].TsEbx, ebx
        mov     [esp].TsEax, eax
        mov     [esp].TsEbp, ebp
        mov     [esp].TsEsi, esi
        mov     [esp].TsEdi, edi
        mov     [esp].TsEcx, ecx
        mov     [esp].TsEdx, edx
if DBG
        mov     [esp].TsPreviousPreviousMode, -1
        mov     [esp]+TsDbgArgMark, 0BADB0D00h
endif
        mov     edi, PCR[PcExceptionList]
        mov     [esp]+TsExceptionList, edi

ifdef NT_UP
        mov     ebx, KGDT_R0_PCR
        mov     fs, bx
endif
        mov     ebx, PCR[PcPrcbData+PbCurrentThread] ; fetch current thread
        and     dword ptr [esp].TsDr7, 0        
        test    byte ptr [ebx].ThDebugActive, 0ffh            ; See if debug registers are active
        mov     ebp, esp
        cld
        je      short @f

        mov     ebx,dr0
        mov     esi,dr1
        mov     edi,dr2
        mov     [ebp]+TsDr0,ebx
        mov     [ebp]+TsDr1,esi
        mov     [ebp]+TsDr2,edi
        mov     ebx,dr3
        mov     esi,dr6
        mov     edi,dr7
        mov     [ebp]+TsDr3,ebx
        xor     ebx, ebx
        mov     [ebp]+TsDr6,esi
        mov     [ebp]+TsDr7,edi
        mov     dr7, ebx          ; Clear out control before reloading
        ;
        ; Load KernelDr* into processor
        ;
        mov     edi,dword ptr PCR[PcPrcb]
        mov     ebx,[edi].PbProcessorState.PsSpecialRegisters.SrKernelDr0
        mov     esi,[edi].PbProcessorState.PsSpecialRegisters.SrKernelDr1
        mov     dr0,ebx
        mov     dr1,esi
        mov     ebx,[edi].PbProcessorState.PsSpecialRegisters.SrKernelDr2
        mov     esi,[edi].PbProcessorState.PsSpecialRegisters.SrKernelDr3
        mov     dr2,ebx
        mov     dr3,esi
        mov     ebx,[edi].PbProcessorState.PsSpecialRegisters.SrKernelDr6
        mov     esi,[edi].PbProcessorState.PsSpecialRegisters.SrKernelDr7
        mov     dr6,ebx
        mov     dr7,esi
@@:
        xor     edx, edx
        mov     dx, word ptr [ebp].TsSegCs
        shl     edx, 4
        xor     ebx, ebx
        add     edx, [ebp].TsEip

        ;
        ; Set the magic PCR bit indicating we are executing VDM management code
        ; so faults on potentially invalid or plain bad user addresses do
        ; not bugcheck the system.  Note both interrupts are disabled and
        ; (for performance reasons) we do not have any exception handlers
        ; set up.
        ;

        mov     dword ptr PCR[PcVdmAlert], offset FLAT:V86Trap6Recovery1

        ;
        ; Fetch the actual opcode from user space.
        ;

        mov     bl, [edx+3]             ; [bl] = minor BOP code

        ;
        ; Clear magic flag as no bogus references are going to be made.
        ;

        mov     dword ptr PCR[PcVdmAlert], 0

        ;
        ; Raise Irql to APC level before enabling interrupts.
        ;

        RaiseIrql APC_LEVEL
        push    eax                     ; Save OldIrql
        sti

        push    ebx
        push    ebp                     ; (ebp)->TrapFrame
        call    _NTFastDOSIO@8
        jmp     Kt061i

V86Trap6PassThrough:

        ;
        ; Clear magic flag as no bogus references are going to be made.
        ;

        mov     dword ptr PCR[PcVdmAlert], 0

V86Trap6Recovery:
        popad
        jmp     Kt6SlowBop              ; Fall through

V86Trap6Recovery1:
        jmp     Kt6SlowBop1             ; Fall through

V86Trap6Recovery2:
        add     esp, 16
        popad
        jmp     Kt6SlowBop              ; Fall through
endm
        page , 132
        subttl "Macro to dispatch user APC"

;++
;
; Macro Description:
;
;    This macro is called before returning to user mode.  It dispatches
;    any pending user mode APCs.
;
; Arguments:
;
;    TFrame - TrapFrame
;    interrupts disabled
;
; Return Value:
;
;--

DISPATCH_USER_APC   macro   TFrame, ReturnCurrentEax
local   a, b, c
c:
.errnz (EFLAGS_V86_MASK AND 0FF00FFFFh)

        test    byte ptr [TFrame]+TsEflags+2, EFLAGS_V86_MASK/010000h ; is previous mode v86?
        jnz     short b                             ; if nz, yes, go check for APC
        test    byte ptr [TFrame]+TsSegCs,MODE_MASK ; is previous mode user mode?
        jz      a                                   ; No, previousmode=Kernel, jump out
b:      mov     ebx, PCR[PcPrcbData+PbCurrentThread]; get addr of current thread
        mov     byte ptr [ebx]+ThAlerted, 0         ; clear kernel mode alerted
        cmp     byte ptr [ebx]+ThApcState.AsUserApcPending, 0
        je      a                                   ; if eq, no user APC pending

        mov     ebx, TFrame
ifnb <ReturnCurrentEax>
        mov     [ebx].TsEax, eax        ; Store return code in trap frame
        mov     dword ptr [ebx]+TsSegFs, KGDT_R3_TEB OR RPL_MASK
        mov     dword ptr [ebx]+TsSegDs, KGDT_R3_DATA OR RPL_MASK
        mov     dword ptr [ebx]+TsSegEs, KGDT_R3_DATA OR RPL_MASK
        mov     dword ptr [ebx]+TsSegGs, 0
endif

;
; Save previous IRQL and set new priority level
;
        RaiseIrql APC_LEVEL
        push    eax                     ; Save OldIrql

        sti                             ; Allow higher priority ints

;
; call the APC delivery routine.
;
; ebx - Trap frame
; 0 - Null exception frame
; 1 - Previous mode
;
; call APC deliver routine
;

        stdCall _KiDeliverApc, <1, 0, ebx>

        pop     ecx                     ; (ecx) = OldIrql
        LowerIrql ecx

ifnb <ReturnCurrentEax>
        mov     eax, [ebx].TsEax        ; Restore eax, just in case
endif

        cli
        jmp     b

    ALIGN 4
a:
endm


if DBG
        page ,132
        subttl "Processing Exception occurred in a 16 bit stack"
;++
;
; Routine Description:
;
;    This routine is called after an exception being detected during
;    a 16 bit stack.  The system will switch 16 stack to 32 bit
;    stack and bugcheck.
;
; Arguments:
;
;    None.
;
; Return value:
;
;    system stopped.
;
;--

align dword
        public  _Ki16BitStackException
_Ki16BitStackException proc

.FPO (2, 0, 0, 0, 0, FPO_TRAPFRAME)

        push    ss
        push    esp
        mov     eax, PCR[PcPrcbData+PbCurrentThread] ; get current thread address
        add     esp, [eax]+ThStackLimit ; compute 32-bit stack address
        mov     eax, KGDT_R0_DATA
        mov     ss, ax

        lea     ebp, [esp+8]
        cld
        SET_DEBUG_DATA

if DBG
        push    offset FLAT:Ki16BitStackTrapMessage
        call    _dbgPrint
        add     esp, 4
endif
	stdCall _KeBugCheck2, <0F000FFFFh,0,0,0,0,ebp> ; Never return
        ret

_Ki16BitStackException endp

endif


        page    ,132
        subttl "System Service Call"
;++
;
; Routine Description:
;
;    This routine gains control when trap occurs via vector 2EH.
;    INT 2EH is reserved for system service calls.
;
;    The system service is executed by locating its routine address in
;    system service dispatch table and calling the specified function.
;    On return necessary state is restored.
;
; Arguments:
;
;    eax - System service number.
;    edx - Pointer to arguments
;
; Return Value:
;
;    eax - System service status code.
;
;--

;
; The specified system service number is not within range. Attempt to
; convert the thread to a GUI thread if the specified system service is
; not a base service and the thread has not already been converted to a
; GUI thread.
;

Kss_ErrorHandler:
        cmp     ecx, SERVICE_TABLE_TEST ; test if GUI service
        jne     short Kss_LimitError    ; if ne, not GUI service
        push    edx                     ; save argument registers
        push    ebx                     ;
        stdcall _PsConvertToGuiThread   ; attempt to convert to GUI thread
        or      eax, eax                ; check if service was successful
        pop     eax                     ; restore argument registers
        pop     edx                     ;
        mov     ebp, esp                ; reset trap frame address
        mov     [esi]+ThTrapFrame, ebp  ; save address of trap frame
        jz      _KiSystemServiceRepeat  ; if eq, successful conversion

;
; The conversion to a GUI thread failed. The correct return value is encoded
; in a byte table indexed by the service number that is at the end of the
; service address table. The encoding is as follows:
;
;     0 - return 0.
;    -1 - return -1.
;     1 - return status code.
;

        lea     edx, _KeServiceDescriptorTableShadow + SERVICE_TABLE_TEST ;
        mov     ecx, [edx]+SdLimit      ; get service number limit
        mov     edx, [edx]+SdBase       ; get service table base
        lea     edx, [edx][ecx*4]       ; get ending service table address
        and     eax, SERVICE_NUMBER_MASK ; isolate service number
        add     edx, eax                ; compute return value address
        movsx   eax, byte ptr [edx]     ; get status byte
        or      eax, eax                ; check for 0 or -1
        jle     Kss70                   ; if le, return value set

Kss_LimitError:                         ;
        mov     eax, STATUS_INVALID_SYSTEM_SERVICE ; set return status
        jmp     kss70                   ;


        ENTER_DR_ASSIST kss_a, kss_t,NoAbiosAssist,NoV86Assist
        ENTER_DR_ASSIST FastCallDrSave, FastCallDrReturn,NoAbiosAssist,NoV86Assist



;
; General System service entrypoint
;

        PUBLIC  _KiSystemService
_KiSystemService        proc

        ENTER_SYSCALL   kss_a, kss_t    ; set up trap frame and save state
        jmp     _KiSystemServiceRepeat


_KiSystemService endp



;
; Fast System Call entry point
;
;   At entry:
;   EAX = service number
;   EDX = Pointer to caller's arguments
;   ECX = unused
;   ESP = DPC stack for this processor
;
; Create a stack frame like a call to inner privilege then continue
; in KiSystemService.
;

;
; Normal entry is at KiFastCallEntry, not KiFastCallEntry2.   Entry
; is via KiFastCallEntry2 if a trace trap occured and EIP
; was KiFastCallEntry.  This happens if a single step exception occurs
; on the instruction following SYSENTER instruction because this
; instruction does not sanitize this flag.
;
; This is NOT a performance path.

        PUBLIC _KiFastCallEntry2
_KiFastCallEntry2:

;
; Sanitize the segment registers
;
        mov     ecx, KGDT_R0_PCR
        mov     fs, ecx
        mov     ecx, KGDT_R3_DATA OR RPL_MASK
        mov     ds, ecx
        mov     es, ecx
;
; When we trap into the kernel via fast system call we start on the DPC stack. We need
; shift to the threads stack before enabling interrupts.
;
        mov     ecx, PCR[PcTss]        ;
        mov     esp, [ecx]+TssEsp0

        push    KGDT_R3_DATA OR RPL_MASK   ; Push user SS
        push    edx                         ; Push ESP
        pushfd
.errnz (EFLAGS_TF AND 0FFFF00FFh)
        or      byte ptr [esp+1], EFLAGS_TF/0100h  ; Set TF flag ready for return or
                                            ;   get/set thread context
        jmp     short Kfsc10

;
; If the sysenter instruction was executed in 16 bit mode, generate
; an error rather than trying to process the system call.   There is
; no way to return to the correct code in user mode.
;

Kfsc90:
        mov     ecx, PCR[PcTss]        ;
        mov     esp, [ecx]+TssEsp0
        push    0                           ; save VX86 Es, Ds, Fs, Gs
        push    0
        push    0
        push    0

        push    KGDT_R3_DATA OR RPL_MASK    ; SS
        push    0                           ; can't know user esp
        push    EFLAGS_INTERRUPT_MASK+EFLAGS_V86_MASK+2h; eflags with VX86 set
        push    KGDT_R3_CODE OR RPL_MASK    ; CS
        push    0                           ; don't know original EIP
        jmp     _KiTrap06                   ; turn exception into illegal op.

Kfsc91: jmp     Kfsc90

        align 16

        PUBLIC _KiFastCallEntry
_KiFastCallEntry        proc

;
; Sanitize the segment registers
;
        mov     ecx, KGDT_R3_DATA OR RPL_MASK
        push    KGDT_R0_PCR
        pop     fs
        mov     ds, ecx
        mov     es, ecx

;
; When we trap into the kernel via fast system call we start on the DPC stack. We need
; shift to the threads stack before enabling interrupts.
;
        mov     ecx, PCR[PcTss]        ;
        mov     esp, [ecx]+TssEsp0

        push    KGDT_R3_DATA OR RPL_MASK   ; Push user SS
        push    edx                         ; Push ESP
        pushfd
Kfsc10:
        push    2                           ; Sanitize eflags, clear direction, NT etc
        add     edx, 8                      ; (edx) -> arguments
        popfd                               ;
.errnz(EFLAGS_INTERRUPT_MASK AND 0FFFF00FFh)
        or      byte ptr [esp+1], EFLAGS_INTERRUPT_MASK/0100h ; Enable interrupts in eflags

        push    KGDT_R3_CODE OR RPL_MASK    ; Push user CS
        push    dword ptr ds:[USER_SHARED_DATA+UsSystemCallReturn] ; push return address
        push    0                           ; put pad dword for error on stack
        push    ebp                         ; save the non-volatile registers
        push    ebx                         ;
        push    esi                         ;
        push    edi                         ;
        mov     ebx, PCR[PcSelfPcr]         ; Get PRCB address
        push    KGDT_R3_TEB OR RPL_MASK     ; Push user mode FS
        mov     esi, [ebx].PcPrcbData+PbCurrentThread   ; get current thread address
;
; Save the old exception list in trap frame and initialize a new empty
; exception list.
;

        push    [ebx].PcExceptionList       ; save old exception list
        mov     [ebx].PcExceptionList, EXCEPTION_CHAIN_END ; set new empty list
        mov     ebp, [esi].ThInitialStack

;
; Save the old previous mode in trap frame, allocate remainder of trap frame,
; and set the new previous mode.
;
        push    MODE_MASK                  ; Save previous mode as user
        sub     esp,TsPreviousPreviousMode ; allocate remainder of trap frame
        sub     ebp, NPX_FRAME_LENGTH + KTRAP_FRAME_LENGTH
        mov     byte ptr [esi].ThPreviousMode,MODE_MASK ; set new previous mode of user
;
; Now the full trap frame is build.
; Calculate initial stack pointer from thread initial stack to contain NPX and trap.
; If this isn't the same as esp then we are a VX86 thread and we are rejected
;

        cmp     ebp, esp
        jne     short Kfsc91

;
; Set the new trap frame address.
;
        and     dword ptr [ebp].TsDr7, 0
        test    byte ptr [esi].ThDebugActive, 0ffh ; See if we need to save debug registers
        mov     [esi].ThTrapFrame, ebp   ; set new trap frame address

        jnz     Dr_FastCallDrSave       ; if nz, debugging is active on thread

Dr_FastCallDrReturn:                       ;

        SET_DEBUG_DATA                  ; Note this destroys edi
        sti                             ; enable interrupts

?FpoValue = 0

;
; (eax) = Service number
; (edx) = Callers stack pointer
; (esi) = Current thread address
;
; All other registers have been saved and are free.
;
; Check if the service number within valid range
;

_KiSystemServiceRepeat:
        mov     edi, eax                ; copy system service number
        shr     edi, SERVICE_TABLE_SHIFT ; isolate service table number
        and     edi, SERVICE_TABLE_MASK ;
        mov     ecx, edi                ; save service table number
        add     edi, [esi]+ThServiceTable ; compute service descriptor address
        mov     ebx, eax                ; save system service number
        and     eax, SERVICE_NUMBER_MASK ; isolate service table offset

;
; If the specified system service number is not within range, then attempt
; to convert the thread to a GUI thread and retry the service dispatch.
;

        cmp     eax, [edi]+SdLimit      ; check if valid service
        jae     Kss_ErrorHandler        ; if ae, try to convert to GUI thread

;
; If the service is a GUI service and the GDI user batch queue is not empty,
; then call the appropriate service to flush the user batch.
;

        cmp     ecx, SERVICE_TABLE_TEST ; test if GUI service
        jne     short Kss40             ; if ne, not GUI service
        mov     ecx, PCR[PcTeb]         ; get current thread TEB address
        xor     ebx, ebx                ; get number of batched GDI calls

KiSystemServiceAccessTeb:
        or      ebx, [ecx]+TbGdiBatchCount ; may cause an inpage exception

        jz      short Kss40             ; if z, no batched calls
        push    edx                     ; save address of user arguments
        push    eax                     ; save service number
        call    [_KeGdiFlushUserBatch]  ; flush GDI user batch
        pop     eax                     ; restore service number
        pop     edx                     ; restore address of user arguments

;
; The arguments are passed on the stack. Therefore they always need to get
; copied since additional space has been allocated on the stack for the
; machine state frame.  Note that we don't check for the zero argument case -
; copy is always done regardless of the number of arguments because the
; zero argument case is very rare.
;

Kss40:  inc     dword ptr PCR[PcPrcbData+PbSystemCalls] ; system calls

if DBG

        mov     ecx, [edi]+SdCount      ; get count table address
        jecxz   short @f                ; if zero, table not specified
        inc     dword ptr [ecx+eax*4]   ; increment service count
@@:                                     ;

endif

FPOFRAME ?FpoValue, 0

        mov     esi, edx                ; (esi)->User arguments
        mov     ebx, [edi]+SdNumber     ; get argument table address
        xor     ecx, ecx
        mov     cl, byte ptr [ebx+eax]  ; (ecx) = argument size
        mov     edi, [edi]+SdBase       ; get service table address
        mov     ebx, [edi+eax*4]        ; (ebx)-> service routine
        sub     esp, ecx                ; allocate space for arguments
        shr     ecx, 2                  ; (ecx) = number of argument DWORDs
        mov     edi, esp                ; (edi)->location to receive 1st arg
        cmp     esi, _MmUserProbeAddress ; check if user address
        jae     kss80                   ; if ae, then not user address

KiSystemServiceCopyArguments:
        rep     movsd                   ; copy the arguments to top of stack.
                                        ; Since we usually copy more than 3
                                        ; arguments.  rep movsd is faster than
                                        ; mov instructions.

;
; Check if low resource usage should be simulated.
;

if DBG

        test    _MmInjectUserInpageErrors, 2
        jz      short @f
        stdCall _MmTrimProcessMemory, <0>
        jmp     short kssdoit
@@:

        mov     eax,PCR[PcPrcbData+PbCurrentThread]
        mov     eax,[eax]+ThApcState+AsProcess
        test    dword ptr [eax]+PrFlags,0100000h ; is this a inpage-err process?
        je      short @f
        stdCall _MmTrimProcessMemory, <0>
@@:

endif

;
; Make actual call to system service
;

kssdoit:
        call    ebx                     ; call system service

kss60:

;
; Check for return to user mode at elevated IRQL.
;

if DBG

        test    byte ptr [ebp]+TsSegCs,MODE_MASK ; test if previous mode user
        jz      short kss50b            ; if z, previous mode not user
        mov     esi,eax                 ; save return status
        CurrentIrql                     ; get current IRQL
        or      al,al                   ; check if IRQL is passive level
        jnz     kss100                  ; if nz, IRQL not passive level
        mov     eax,esi                 ; restore return status

;
; Check if kernel APCs are disabled or a process is attached.
;
        
        mov     ecx,PCR[PcPrcbData+PbCurrentThread] ; get current thread address
        mov     dl,[ecx]+ThApcStateIndex ; get APC state index
        or      dl,dl                   ; check if process attached
        jne     kss120                  ; if ne, process is attached
        mov     edx,[ecx]+ThCombinedApcDisable ; get kernel APC disable
        or      edx,edx                 ; check if kernel APCs disabled
        jne     kss120                  ; if ne, kernel APCs disabled.
kss50b:                                 ;

endif

kss61:

;
; Upon return, (eax)= status code. This code may also be entered from a failed
; KiCallbackReturn call.
;

        mov     esp, ebp                ; deallocate stack space for arguments

;
; Restore old trap frame address from the current trap frame.
;

kss70:  mov     ecx, PCR[PcPrcbData+PbCurrentThread] ; get current thread address
        mov     edx, [ebp].TsEdx        ; restore previous trap frame address
        mov     [ecx].ThTrapFrame, edx  ;

;
;   System service's private version of KiExceptionExit
;   (Also used by KiDebugService)
;
;   Check for pending APC interrupts, if found, dispatch to them
;   (saving eax in frame first).
;
        public  _KiServiceExit
_KiServiceExit:

        cli                                         ; disable interrupts
        DISPATCH_USER_APC   ebp, ReturnCurrentEax

;
; Exit from SystemService
;

        EXIT_ALL    NoRestoreSegs, NoRestoreVolatile

;
; The address of the argument list is not a user address. If the previous mode
; is user, then return an access violation as the status of the system service.
; Otherwise, copy the argument list and execute the system service.
;

kss80:  test    byte ptr [ebp].TsSegCs, MODE_MASK ; test previous mode
        jz      KiSystemServiceCopyArguments ; if z, previous mode kernel
        mov     eax, STATUS_ACCESS_VIOLATION ; set service status
        jmp     kss60                   ;

;++
;
;   _KiServiceExit2 - same as _KiServiceExit BUT the full trap_frame
;       context is restored
;
;--
        public  _KiServiceExit2
_KiServiceExit2:

        cli                             ; disable interrupts
        DISPATCH_USER_APC   ebp

;
; Exit from SystemService
;

        EXIT_ALL                            ; RestoreAll

if DBG

kss100: push    PCR[PcIrql]                 ; put bogus value on stack for dbg

?FpoValue = ?FpoValue + 1

FPOFRAME ?FpoValue, 0
        mov     byte ptr PCR[PcIrql],0      ; avoid recursive trap
        cli                                 ; 

;
; IRQL_GT_ZERO_AT_SYSTEM_SERVICE - attempted return to usermode at elevated
; IRQL.
;
; KeBugCheck2(IRQL_GT_ZERO_AT_SYSTEM_SERVICE,
;             System Call Handler (address of system routine),
;             Irql,
;             0,
;             0,
;	      TrapFrame);
;

        stdCall _KeBugCheck2,<IRQL_GT_ZERO_AT_SYSTEM_SERVICE,ebx,eax,0,0,ebp>

;
; APC_INDEX_MISMATCH - attempted return to user mode with kernel APCs disabled
; or a process attached.
;
; KeBugCheck2(APC_INDEX_MISMATCH,
;             System Call Handler (address of system routine),
;             Thread->ApcStateIndex,
;             Thread->CombinedApcDisable,
;             0,
;	      TrapFrame);
;

kss120: movzx   eax,byte ptr [ecx]+ThApcStateIndex ; get APC state index
        mov     edx,[ecx]+ThCombinedApcDisable ; get kernel APC disable
	stdCall _KeBugCheck2,<APC_INDEX_MISMATCH,ebx,eax,edx,0,ebp>

endif
        ret

_KiFastCallEntry  endp

;
; BBT cannot instrument code between this label and BBT_Exclude_Trap_Code_End
;
        public  _BBT_Exclude_Trap_Code_Begin
_BBT_Exclude_Trap_Code_Begin  equ     $
        int 3

;
; Fast path NtGetTickCount
;

align 16
        ENTER_DR_ASSIST kitx_a, kitx_t,NoAbiosAssist
        PUBLIC  _KiGetTickCount
_KiGetTickCount proc

        cmp     [esp+4], KGDT_R3_CODE OR RPL_MASK
        jnz     short @f

Kgtc00:
        mov     eax,dword ptr cs:[_KeTickCount]
        mul     dword ptr cs:[_ExpTickCountMultiplier]
        shrd    eax,edx,24                  ; compute resultant tick count

        iretd
@@:
        ;
        ; if v86 mode, we dont handle it
        ;
.errnz (EFLAGS_V86_MASK AND 0FF00FFFFh)

        test    byte ptr [esp+8+2], EFLAGS_V86_MASK/010000h
        jnz     ktgc20

        ;
        ; if kernel mode, must be get tick count
        ;
.errnz (MODE_MASK AND 0FFFFFF00h)
        test    byte ptr [esp+4], MODE_MASK
        jz      short Kgtc00

        ;
        ; else check if the caller is USER16
        ;   if eax = ebp = 0xf0f0f0f0  it is get-tick-count
        ;   if eax = ebp = 0xf0f0f0f1  it is set-ldt-entry
        ;

        cmp     eax, ebp                ; if eax != ebp, not USER16
        jne     ktgc20

        and     eax, 0fffffff0h
        cmp     eax, 0f0f0f0f0h
        jne     ktgc20

        cmp     ebp, 0f0f0f0f0h         ; Is it user16 gettickcount?
        je      short Kgtc00            ; if z, yes


        cmp     ebp, 0f0f0f0f1h         ; If this is setldt entry
        jne     ktgc20                  ; if nz, we don't know what
                                        ; it is.

        ;
        ; The idea here is that user16 can call 32 bit api to
        ; update LDT entry without going through the penalty
        ; of DPMI.
        ;

        push    0                       ; push dummy error code
        ENTER_TRAP      kitx_a, kitx_t
        sti

        xor     eax, eax
        mov     ebx, [ebp+TsEbx]
        mov     ecx, [ebp+TsEcx]
        mov     edx, [ebp+TsEdx]
        stdCall _NtSetLdtEntries <ebx, ecx, edx, eax, eax, eax>
        mov     [ebp+TsEax], eax
        and     dword ptr [ebp+TsEflags], 0FFFFFFFEH ; clear carry flag
        cmp     eax, 0                  ; success?
        je      short ktgc10

        or      dword ptr [ebp+TsEflags], 1 ; set carry flag
ktgc10:
        jmp     _KiExceptionExit

ktgc20:
        ;
        ; We need to *trap* this int 2a.  For exception, the eip should
        ; point to the int 2a instruction not the instruction after it.
        ;

        sub     word ptr [esp], 2
        push    0
        jmp     _KiTrap0D

_KiGetTickCount endp

        page ,132
        subttl  "Return from User Mode Callback"
;++
;
; NTSTATUS
; NtCallbackReturn (
;    IN PVOID OutputBuffer OPTIONAL,
;    IN ULONG OutputLength,
;    IN NTSTATUS Status
;    )
;
; Routine Description:
;
;    This function returns from a user mode callout to the kernel mode
;    caller of the user mode callback function.
;
;    N.B. This service uses a nonstandard calling sequence. The trap
;	is converted to a standard system call so that the exit sequence
;	can take advantage of any processor support for fast user mode
;	return.
;
; Arguments:
;
;    OutputBuffer (ecx) - Supplies an optional pointer to an output buffer.
;
;    OutputLength (edx) - Supplies the length of the output buffer.
;
;    Status (eax) - Supplies the status value returned to the caller of
;        the callback function.
;
; Return Value:
;
;    If the callback return cannot be executed, then an error status is
;    returned. Otherwise, the specified callback status is returned to
;    the caller of the callback function.
;
;    N.B. This function returns to the function that called out to user
;         mode if a callout is currently active.
;
;--

        ENTER_DR_ASSIST kcb_a, kcb_t, NoAbiosAssist, NoV86Assist

align 16
        PUBLIC  _KiCallbackReturn
_KiCallbackReturn proc

        ENTER_SYSCALL   kcb_a, kcb_t, , , SaveEcx

        mov     ecx, [ebp].TsEcx		; Recover ecx from the trap frame
        stdCall _NtCallbackReturn, <ecx,edx,eax> 
        
        ; If it returns, then exit with a failure code as any system call would.
        jmp kss61

_KiCallbackReturn endp

        page ,132
        subttl "Raise Assertion"
;++
;
; Routine Description:
;
;    This routine is entered as the result of the execution of an int 2c
;    instruction. Its function is to raise an assertion.
;
; Arguments:
;
;     None.
;
;--

        ASSUME  DS:NOTHING, SS:NOTHING, ES:NOTHING

        ENTER_DR_ASSIST kira_a, kira_t, NoAbiosAssist

        align dword
        public  _KiRaiseAssertion
_KiRaiseAssertion proc
        push    0                           ; push dummy error code

        ENTER_TRAP kira_a, kira_t           ;

        sub     dword ptr [ebp]+TsEip, 2    ; convert trap to a fault
        mov     ebx, [ebp]+TsEip            ; set exception address
        mov     eax, STATUS_ASSERTION_FAILURE ; set exception code
        jmp     CommonDispatchException0Args ; finish in common code

_KiRaiseAssertion endp

        page ,132
        subttl  "Common Trap Exit"
;++
;
;   KiUnexpectedInterruptTail
;
;   Routine Description:
;       This function is jumped to by an IDT entry who has no interrupt
;       handler.
;
;   Arguments:
;
;       (esp)   - Dword, vector
;       (esp+4) - Processor generated IRet frame
;
;--

        ENTER_DR_ASSIST kui_a, kui_t

        public  _KiUnexpectedInterruptTail
_KiUnexpectedInterruptTail  proc
        ENTER_INTERRUPT kui_a, kui_t, PassDwordParm

        inc     dword ptr PCR[PcPrcbData+PbInterruptCount]

        mov     ebx, [esp]      ; get vector & leave it on the stack
        sub     esp, 4          ; make space for OldIrql

; esp - ptr to OldIrql
; ebx - Vector
; HIGH_LEVEL - Irql
        stdCall   _HalBeginSystemInterrupt, <HIGH_LEVEL,ebx,esp>
        or      eax, eax
        jnz     short kui10

;
; spurious interrupt
;
        add     esp, 8
        jmp     kee99

kui10:
if DBG
        push    dword ptr [esp+4]       ; Vector #
        push    offset FLAT:BadInterruptMessage
        call    _DbgPrint               ; display unexpected interrupt message
        add     esp, 8
endif
;
; end this interrupt
;
        INTERRUPT_EXIT

_KiUnexpectedInterruptTail  endp



;++
;
; N.B. KiExceptionExit and Kei386EoiHelper are identical and have
;      been combined.
;
;   KiExceptionExit
;
;   Routine Description:
;
;       This code is transferred to at the end of the processing for
;       an exception.  Its function is to restore machine state, and
;       continue thread execution.  If control is returning to user mode
;       and there is a user APC pending, then control is transferred to
;       the user APC delivery routine.
;
;       N.B. It is assumed that this code executes at IRQL zero or APC_LEVEL.
;          Therefore page faults and access violations can be taken.
;
;       NOTE: This code is jumped to, not called.
;
;   Arguments:
;
;       (ebp) -> base of trap frame.
;
;   Return Value:
;
;       None.
;
;--
;++
;
;   Kei386EoiHelper
;
;   Routine Description:
;
;       This code is transferred to at the end of an interrupt.  (via the
;       exit_interrupt macro).  It checks for user APC dispatching and
;       performs the exit_all for the interrupt.
;
;       NOTE: This code is jumped to, not called.
;
;   Arguments:
;
;       (esp) -> base of trap frame.
;       interrupts are disabled
;
;   Return Value:
;
;       None.
;
;--

align 4
        public  _KiExceptionExit
cPublicProc Kei386EoiHelper, 0
_KiExceptionExit:
.FPO (0, 0, 0, 0, 0, FPO_TRAPFRAME)

        cli                             ; disable interrupts
        DISPATCH_USER_APC   ebp

;
; Exit from Exception
;

kee99:

        EXIT_ALL       ,,NoPreviousMode

stdENDP Kei386EoiHelper


;
;   V86ExitHelp
;
;       Restore volatiles for V86 mode, and move seg regs
;
;   Arguments:
;
;      esp = ebp = &TrapFrame
;
;   Return Value:
;
;      None, returns to previous mode using IRETD.
;

align dword
V86ExitHelp:

        add     esp,TsEdx
        pop     edx
        pop     ecx
        pop     eax

        lea     esp, [ebp]+TsEdi        ; Skip PreMode, ExceptList and fs

        pop     edi                     ; restore non-volatiles
        pop     esi
        pop     ebx
        pop     ebp

;
; Esp MUST point to the Error Code on the stack.  Because we use it to
; store the entering esp.
;

        cmp     word ptr [esp+8], 80h   ; check for abios code segment?
        ja      AbiosExitHelp

v86eh90:

        add     esp, 4                  ; remove error code from trap frame
        iretd                           ; return

Abios_ExitHelp_Target2:

;
; End of ABIOS stack check
;
;
;   AbiosExit:
;
;       This routine remaps current 32bit stack to 16bit stack at return
;       from interrupt time and returns from interrupt.
;
;   Arguments:
;
;       (esp) -> TrapFrame
;
;   Return Value:
;
;      None, returns to previous mode using IRETD.
;      Note: May use above exit to remove error code from stack.
;


align dword
AbiosExitHelp:
        cmp     word ptr [esp+2], 0     ; (esp+2) = Low word of error code
        jz      short v86eh90
        cmp     word ptr [esp], 0       ; (esp) = High word of error code
        jnz     short v86eh90

        shr     dword ptr [esp], 16
        mov     word ptr [esp + 2], KGDT_STACK16
        lss     sp, dword ptr [esp]
        movzx   esp, sp
        iretd                           ; return

        page , 132
        subttl "trap processing"

;++
;
; Routine Description:
;
;    _KiTrapxx - protected mode trap entry points
;
;    These entry points are for internally generated exceptions,
;    such as a general protection fault.  They do not handle
;    external hardware interrupts, or user software interrupts.
;
; Arguments:
;
;    On entry the stack looks like:
;
;       [ss]
;       [esp]
;       eflags
;       cs
;       eip
;    ss:sp-> [error]
;
;    The cpu saves the previous SS:ESP, eflags, and CS:EIP on
;    the new stack if there was a privilege transition. If no
;    privilege level transition occurred, then there is no
;    saved SS:ESP.
;
;    Some exceptions save an error code, others do not.
;
; Return Value:
;
;       None.
;
;--


        page , 132
        subttl "Macro to dispatch exception"

;++
;
; Macro Description:
;
;    This macro allocates exception record on stack, sets up exception
;    record using specified parameters and finally sets up arguments
;    and calls _KiDispatchException.
;
; Arguments:
;
;    ExcepCode - Exception code to put into exception record
;    ExceptFlags - Exception flags to put into exception record
;    ExceptRecord - Associated exception record
;    ExceptAddress - Addr of instruction which the hardware exception occurs
;    NumParms - Number of additional parameters
;    ParameterList - the additional parameter list
;
; Return Value:
;
;    None.
;
;--

DISPATCH_EXCEPTION macro ExceptCode, ExceptFlags, ExceptRecord, ExceptAddress,\
                         NumParms, ParameterList
        local de10, de20

.FPO ( ExceptionRecordSize/4+NumParms, 0, 0, 0, 0, FPO_TRAPFRAME )

; Set up exception record for raising exception

?i      =       0
        sub     esp, ExceptionRecordSize + NumParms * 4
                                        ; allocate exception record
        mov     dword ptr [esp]+ErExceptionCode, ExceptCode
                                        ; set up exception code
        mov     dword ptr [esp]+ErExceptionFlags, ExceptFlags
                                        ; set exception flags
        mov     dword ptr [esp]+ErExceptionRecord, ExceptRecord
                                        ; set associated exception record
        mov     dword ptr [esp]+ErExceptionAddress, ExceptAddress
        mov     dword ptr [esp]+ErNumberParameters, NumParms
                                        ; set number of parameters
        IRP     z, <ParameterList>
        mov     dword ptr [esp]+(ErExceptionInformation+?i*4), z
?i      =       ?i + 1
        ENDM

; set up arguments and call _KiDispatchException

        mov     ecx, esp                ; (ecx)->exception record
        mov     eax,[ebp]+TsSegCs

.errnz (EFLAGS_V86_MASK AND 0FF00FFFFh)

        test    byte ptr [ebp]+TsEFlags+2,EFLAGS_V86_MASK/010000h
        jz      de10

        mov     eax,0FFFFh
de10:   and     eax,MODE_MASK

; 1 - first chance TRUE
; eax - PreviousMode
; ebp - trap frame addr
; 0 - Null exception frame
; ecx - exception record addr

; dispatchexception as appropriate
        stdCall   _KiDispatchException, <ecx, 0, ebp, eax, 1>

        mov     esp, ebp                ; (esp) -> trap frame

        ENDM

        page , 132
        subttl "dispatch exception"

;++
;
; CommonDispatchException
;
; Routine Description:
;
;    This routine allocates exception record on stack, sets up exception
;    record using specified parameters and finally sets up arguments
;    and calls _KiDispatchException.
;
;    NOTE:
;
;    The purpose of this routine is to save code space.  Use this routine
;    only if:
;    1. ExceptionRecord is NULL
;    2. ExceptionFlags is 0
;    3. Number of parameters is less or equal than 3.
;
;    Otherwise, you should use DISPATCH_EXCEPTION macro to set up your special
;    exception record.
;
; Arguments:
;
;    (eax) = ExcepCode - Exception code to put into exception record
;    (ebx) = ExceptAddress - Addr of instruction which the hardware exception occurs
;    (ecx) = NumParms - Number of additional parameters
;    (edx) = Parameter1
;    (esi) = Parameter2
;    (edi) = Parameter3
;
; Return Value:
;
;    None.
;
;--
CommonDispatchException0Args:
        xor     ecx, ecx                ; zero arguments
        call    CommonDispatchException

CommonDispatchException1Arg0d:
        xor     edx, edx                ; zero edx
CommonDispatchException1Arg:
        mov     ecx, 1                  ; one argument
        call    CommonDispatchException ; there is no return

CommonDispatchException2Args0d:
        xor     edx, edx                ; zero edx
CommonDispatchException2Args:
        mov     ecx, 2                  ; two arguments
        call    CommonDispatchException ; there is no return

      public CommonDispatchException
align dword
CommonDispatchException proc
cPublicFpo 0, ExceptionRecordLength/4
;
;       Set up exception record for raising exception
;

        sub     esp, ExceptionRecordLength
                                        ; allocate exception record
        mov     dword ptr [esp]+ErExceptionCode, eax
                                        ; set up exception code
        xor     eax, eax
        mov     dword ptr [esp]+ErExceptionFlags, eax
                                        ; set exception flags
        mov     dword ptr [esp]+ErExceptionRecord, eax
                                        ; set associated exception record
        mov     dword ptr [esp]+ErExceptionAddress, ebx
        mov     dword ptr [esp]+ErNumberParameters, ecx
                                        ; set number of parameters
        cmp     ecx, 0
        je      short de00

        lea     ebx, [esp + ErExceptionInformation]
        mov     [ebx], edx
        mov     [ebx+4], esi
        mov     [ebx+8], edi
de00:
;
; set up arguments and call _KiDispatchException
;

        mov     ecx, esp                ; (ecx)->exception record

.errnz (EFLAGS_V86_MASK AND 0FF00FFFFh)
        test    byte ptr [ebp]+TsEFlags+2,EFLAGS_V86_MASK/010000h
        jz      short de10

        mov     eax,0FFFFh
        jmp     short de20

de10:   mov     eax,[ebp]+TsSegCs
de20:   and     eax,MODE_MASK

; 1 - first chance TRUE
; eax - PreviousMode
; ebp - trap frame addr
; 0 - Null exception frame
; ecx - exception record addr

        stdCall _KiDispatchException,<ecx, 0, ebp, eax, 1>

        mov     esp, ebp                ; (esp) -> trap frame
        jmp     _KiExceptionExit

CommonDispatchException endp

        page , 132
        subttl "Macro to verify base trap frame"

;++
;
; Macro Description:
;
;   This macro verifies the base trap frame is intact.
;
;   It is possible while returning to UserMode that we take an exception.
;   Any exception which may block, such as not-present, needs to verify
;   that the base trap frame is not partially dismantled.
;
; Arguments:
;   The macro MUST be used directly after ENTER_TRAP macro
;   as it assumes all sorts of stuff about ESP!
;
; Return Value:
;
;   If the base frame was incomplete it is totally restored and the
;   return EIP of the current frame is (virtually) backed up to the
;   beginning of the exit_all - the effect is that the base frame
;   will be completely exited again.  (ie, the exit_all of the base
;   frame is atomic, if it's interrupted we restore it and do it over).
;
;    None.
;
;--

MODIFY_BASE_TRAP_FRAME macro
       local    vbfdone

        mov     edi, PCR[PcPrcbData+PbCurrentThread] ; Get current thread
        lea     eax, [esp]+KTRAP_FRAME_LENGTH + NPX_FRAME_LENGTH ; adjust for base frame
        sub     eax, [edi].ThInitialStack ; Bias out this stack
        je      short vbfdone           ; if eq, then this is the base frame

        cmp     eax, -TsEflags          ; second frame is only this big
        jc      short vbfdone           ; is stack deeper then 2 frames?
                                        ; yes, then done
    ;
    ; Stack usage is not exactly one frame, and it's not large enough
    ; to be two complete frames; therefore, we may have a partial base
    ; frame. (unless it's a kernel thread)
    ;
    ; See if this is a kernel thread as kernel threads don't have a base
    ; frame (and therefore don't need correcting).
    ;

        mov     eax, PCR[PcTeb]
        or      eax, eax                ; Any Teb?
        jle     short vbfdone           ; Br if zero or kernel thread address

        call    KiRestoreBaseFrame

    align 4
vbfdone:
        ENDM

;++ KiRestoreBaseFrame
;
; Routine Description:
;
;   Only to be used from MODIFY_BASE_TRAP_FRAME macro.
;   Makes lots of assumptions about esp & trap frames
;
; Arguments:
;
;   Stack:
;       +-------------------------+
;       |                         |
;       |                         |
;       | Npx save area           |
;       |                         |
;       |                         |
;       +-------------------------+
;       | (possible mvdm regs)    |
;       +-------------------------+  <- PCR[PcInitialStack]
;       |                         |
;       | Partial base trap frame |
;       |                         |
;       |             ------------+
;       +------------/            |  <- Esp @ time of current frame. Location
;       |                         |     where base trap frame is incomplete
;       | Completed 'current'     |
;       |  trap frame             |
;       |                         |
;       |                         |
;       |                         |
;       |                         |
;       +-------------------------+  <- EBP
;       | return address (dword)  |
;       +-------------------------+  <- current ESP
;       |                         |
;       |                         |
;
; Return:
;
;   Stack:
;       +-------------------------+
;       |                         |
;       |                         |
;       | Npx save area           |
;       |                         |
;       |                         |
;       +-------------------------+
;       | (possible mvdm regs)    |
;       +-------------------------+  <- PCR[PcInitialStack]
;       |                         |
;       | Base trap frame         |
;       |                         |
;       |                         |
;       |                         |
;       |                         |
;       |                         |
;       +-------------------------+  <- return esp & ebp
;       |                         |
;       | Current trap frame      |
;       |                         |  EIP set to beginning of
;       |                         |  exit_all code
;       |                         |
;       |                         |
;       |                         |
;       +-------------------------+  <- EBP, ESP
;       |                         |
;       |                         |
;
;--

KiRestoreBaseFrame proc
        pop     ebx                     ; Get return address
IF DBG
        mov     eax, [esp].TsEip        ; EIP of trap

    ;
    ; This code is to handle a very specific problem of a not-present
    ; fault during an exit_all.  If it's not this problem then stop.
    ;
        cmp     word ptr [eax], POP_GS
        je      short @f
        cmp     byte ptr [eax], POP_ES
        je      short @f
        cmp     byte ptr [eax], POP_DS
        je      short @f
        cmp     word ptr [eax], POP_FS
        je      short @f
        cmp     byte ptr [eax], IRET_OP
        je      short @f
        int 3
@@:
ENDIF
    ;
    ; Move current trap frame out of the way to make space for
    ; a full base trap frame
    ;
        mov     eax, PCR[PcPrcbData+PbCurrentThread] ; Get current thread
        mov     edi, [eax].ThInitialStack
        sub     edi, NPX_FRAME_LENGTH + KTRAP_FRAME_LENGTH + TsEFlags + 4 ; (edi) = bottom of target
        mov     esi, esp                ; (esi) = bottom of source
        mov     esp, edi                ; make space before copying the data
        mov     ebp, edi                ; update location of our trap frame
        push    ebx                     ; put return address back on stack

        mov     ecx, (TsEFlags+4)/4     ; # of dword to move
        rep     movsd                   ; Move current trap frame

    ;
    ; Part of the base frame was destroyed when the current frame was
    ; originally pushed.  Now that the current frame has been moved out of
    ; the way restore the base frame.  We know that any missing data from
    ; the base frame was reloaded into it's corresponding registers which
    ; were then pushed into the current frame.  So we can restore the missing
    ; data from the current frame.
    ;
        mov     ecx, esi                ; Location of esp at time of fault
        mov     edi, [eax].ThInitialStack
        sub     edi, NPX_FRAME_LENGTH + KTRAP_FRAME_LENGTH ; (edi) = base trap frame
        mov     ebx, edi

        sub     ecx, edi                ; (ecx) = # of bytes which were
                                        ; removed from base frame before
                                        ; trap occured
IF DBG
        test    ecx, 3
        jz      short @f                ; assume dword alignments only
        int 3
@@:
ENDIF
        mov     esi, ebp                ; (esi) = current frame
        shr     ecx, 2                  ; copy in dwords
        rep     movsd
    ;
    ; The base frame is restored.  Instead of backing EIP up to the
    ; start of the interrupted EXIT_ALL, we simply move the EIP to a
    ; well known EXIT_ALL.  However, this causes a couple of problems
    ; since this exit_all restores every register whereas the original
    ; one may not.  So:
    ;
    ;   - When exiting from a system call, eax is normally returned by
    ;     simply not restoring it.  We 'know' that the current trap frame's
    ;     EAXs is always the correct one to return.  (We know this because
    ;     exit_all always restores eax (if it's going to) before any other
    ;     instruction which may cause a fault).
    ;
    ;   - Not all enter's push the PreviousPreviousMode.  Since this is
    ;     the base trap frame we know that this must be UserMode.
    ;
        mov     eax, [ebp].TsEax                    ; make sure correct
        mov     [ebx].TsEax, eax                    ; eax is in base frame
        mov     byte ptr [ebx].TsPreviousPreviousMode, 1    ; UserMode

        mov     [ebp].TsEbp, ebx
        mov     [ebp].TsEip, offset _KiServiceExit2 ; ExitAll which

                                                    ; restores everything
    ;
    ; Since we backed up Eip we need to reset some of the kernel selector
    ; values in case they were already restored by the attempted base frame pop
    ;
        mov     dword ptr [ebp].TsSegDs, KGDT_R3_DATA OR RPL_MASK
        mov     dword ptr [ebp].TsSegEs, KGDT_R3_DATA OR RPL_MASK
        mov     dword ptr [ebp].TsSegFs, KGDT_R0_PCR

    ;
    ; The backed up EIP is before interrupts were disabled.  Re-enable
    ; interrupts for the current trap frame
    ;
        or      [ebp].TsEFlags, EFLAGS_INTERRUPT_MASK

        ret

KiRestoreBaseFrame endp

        page ,132
        subttl "Divide error processing"
;++
;
; Routine Description:
;
;    Handle divide error fault.
;
;    The divide error fault occurs if a DIV or IDIV instructions is
;    executed with a divisor of 0, or if the quotient is too big to
;    fit in the result operand.
;
;    An INTEGER DIVIDED BY ZERO exception will be raised for the fault.
;    If the fault occurs in kernel mode, the system will be terminated.
;
; Arguments:
;
;    At entry, the saved CS:EIP point to the faulting instruction.
;    No error code is provided with the divide error.
;
; Return value:
;
;    None
;
;--
        ASSUME  DS:NOTHING, SS:NOTHING, ES:NOTHING
        ENTER_DR_ASSIST kit0_a, kit0_t,NoAbiosAssist
align dword
        public  _KiTrap00
_KiTrap00       proc

        push    0                       ; push dummy error code
        ENTER_TRAP      kit0_a, kit0_t

.errnz (EFLAGS_V86_MASK AND 0FF00FFFFh)
        test    byte ptr [ebp]+TsEFlags+2,EFLAGS_V86_MASK/010000h
        jnz     Kt0040                  ; trap occured in V86 mode

        test    byte ptr [ebp]+TsSegCs, MODE_MASK  ; Is previous mode = USER
        jz      short Kt0000

        cmp     word ptr [ebp]+TsSegCs,KGDT_R3_CODE OR RPL_MASK
        jne     Kt0020
;
; Set up exception record for raising Integer_Divided_by_zero exception
; and call _KiDispatchException
;

Kt0000:

if DBG
        test    [ebp]+TsEFlags, EFLAGS_INTERRUPT_MASK   ; faulted with
        jnz     short @f                                ; interrupts disabled?

        xor     eax, eax
        mov     esi, [ebp]+TsEip        ; [esi] = faulting instruction
	stdCall _KeBugCheck2,<IRQL_NOT_LESS_OR_EQUAL,eax,-1,eax,esi,ebp>
@@:
endif

        sti


;
; Flat mode
;
; The intel processor raises a divide by zero exception on DIV instructions
; which overflow. To be compatible with other processors we want to
; return overflows as such and not as divide by zero's.  The operand
; on the div instruction is tested to see if it's zero or not.
;
        stdCall _Ki386CheckDivideByZeroTrap,<ebp>
        mov     ebx, [ebp]+TsEip        ; (ebx)-> faulting instruction
        jmp     CommonDispatchException0Args ; Won't return

Kt0010:
;
; 16:16 mode
;
        sti
        mov     ebx, [ebp]+TsEip        ; (ebx)-> faulting instruction
        mov     eax, STATUS_INTEGER_DIVIDE_BY_ZERO
        jmp     CommonDispatchException0Args ; never return

Kt0020:
; Check to see if this process is a vdm
        mov     ebx,PCR[PcPrcbData+PbCurrentThread]
        mov     ebx,[ebx]+ThApcState+AsProcess
        cmp     dword ptr [ebx]+PrVdmObjects,0 ; is this a vdm process?
        je      Kt0010

Kt0040:
        stdCall _Ki386VdmReflectException_A, <0>

        or      al,al
        jz      short Kt0010             ; couldn't reflect, gen exception
        jmp     _KiExceptionExit

_KiTrap00       endp


        page ,132
        subttl "Debug Exception"
;++
;
; Routine Description:
;
;    Handle debug exception.
;
;    The processor triggers this exception for any of the following
;    conditions:
;
;    1. Instruction breakpoint fault.
;    2. Data address breakpoint trap.
;    3. General detect fault.
;    4. Single-step trap.
;    5. Task-switch breakpoint trap.
;
;
; Arguments:
;
;    At entry, the values of saved CS and EIP depend on whether the
;    exception is a fault or a trap.
;    No error code is provided with the divide error.
;
; Return value:
;
;    None
;
;--
        ASSUME  DS:NOTHING, SS:NOTHING, ES:NOTHING
align dword
;
; We branch here to handle a trap01 fromt he fast system call entry
; we need to propagate the trap bit to the return eflags etc and
; continue.
;


Kt0100: mov     [ebp].TsEip, _KiFastCallEntry2
        and     dword ptr [ebp].TsEflags, NOT EFLAGS_TF
        jmp     _KiExceptionExit        ; join common code

        ENTER_DR_ASSIST kit1_a, kit1_t, NoAbiosAssist
align dword
        public  _KiTrap01
_KiTrap01       proc

; Set up machine state frame for displaying

        push    0                       ; push dummy error code
        ENTER_TRAP      kit1_a, kit1_t

;
; Inspect old EIP in case this is a single stepped
; sysenter instruction.
;

        mov     ecx, [ebp]+TsEip
        cmp     ecx, _KiFastCallEntry
        je      Kt0100

;
; See if were doing the fast bop optimization of touching user memory
; with ints disabled. If we are then ignore data breakpoints.
;
;
if FAST_BOP

        cmp     dword ptr PCR[PcVdmAlert], 0

        jne     Kt01VdmAlert

endif


;
; If caller is user mode, we want interrupts back on.
;   . all relevant state has already been saved
;   . user mode code always runs with ints on
;
; If caller is kernel mode, we want them off!
;   . some state still in registers, must prevent races
;   . kernel mode code can run with ints off
;
;

.errnz (EFLAGS_V86_MASK AND 0FF00FFFFh)
        test    byte ptr [ebp]+TsEFlags+2,EFLAGS_V86_MASK/010000h
        jnz     kit01_30                ; fault occured in V86 mode => Usermode

.errnz (MODE_MASK AND 0FFFFFF00h)
        test    byte ptr [ebp]+TsSegCs,MODE_MASK
        jz      kit01_10

        cmp     word ptr [ebp]+TsSegCs,KGDT_R3_CODE OR RPL_MASK
        jne     kit01_30
kit01_05:
        sti
kit01_10:

;
; Set up exception record for raising single step exception
; and call _KiDispatchException
;

kit01_20:
        and     dword ptr [ebp]+TsEflags, not EFLAGS_TF
        mov     ebx, [ebp]+TsEip                ; (ebx)-> faulting instruction
        mov     eax, STATUS_SINGLE_STEP
        jmp     CommonDispatchException0Args    ; Never return

kit01_30:

; Check to see if this process is a vdm

        mov     ebx,PCR[PcPrcbData+PbCurrentThread]
        mov     ebx,[ebx]+ThApcState+AsProcess
        cmp     dword ptr [ebx]+PrVdmObjects,0 ; is this a vdm process?
        je      kit01_05

        stdCall _Ki386VdmReflectException_A, <01h>
        test    ax,0FFFFh
        jz      Kit01_20
        jmp     _KiExceptionExit

if FAST_BOP

Kt01VdmAlert:

        ;
        ; If a DEBUG trap occured while we are in VDM alert mode (processing
        ; v86 trap without building trap frame), we will restore all the
        ; registers and return to its recovery routine.
        ;

        mov     eax, PCR[PcVdmAlert]
        mov     dword ptr PCR[PcVdmAlert], 0

        mov     [ebp].TsEip, eax
        mov     esp,ebp                 ; (esp) -> trap frame
        jmp     _KiExceptionExit        ; join common code

endif   ; FAST_BOP

_KiTrap01       endp

        page ,132
        subttl "Nonmaskable Interrupt"
;++
;
; Routine Description:
;
;    Handle Nonmaskable interrupt.
;
;    An NMI is typically used to signal serious system conditions
;    such as bus time-out, memory parity error, and so on.
;
;    Upon detection of the NMI, the system will be terminated, ie a
;    bugcheck will be raised, no matter what previous mode is.
;
; Arguments:
;
;    No error code is provided with the error.
;
; Return value:
;
;    None
;
;--
        ASSUME  DS:NOTHING, SS:NOTHING, ES:NOTHING
;        ENTER_DR_ASSIST kit2_a, kit2_t, NoAbiosAssist
align dword
        public  _KiTrap02
_KiTrap02       proc
.FPO (1, 0, 0, 0, 0, 2)
        cli

; 
; Set CR3, the I/O map base address, and LDT segment selector
; in the old TSS since they are not set on context
; switches. These values will be needed to return to the
; interrupted task.

        mov     eax, PCR[PcTss]                      ; get old TSS address
        mov     ecx, PCR[PcPrcbData+PbCurrentThread] ; get thread address
        mov     edi, [ecx].ThApcState.AsProcess      ; get process address
        mov     ecx, [edi]+PrDirectoryTableBase      ; get directory base
        mov     [eax]+TssCR3, ecx                    ; set previous cr3

        mov     cx, [edi]+PrIopmOffset               ; get IOPM offset
        mov     [eax]+TssIoMapBase, cx               ; set IOPM offset

        mov     ecx, [edi]+PrLdtDescriptor           ; get LDT descriptor
        test    ecx, ecx                             ; does task use LDT?
        jz      @f
        mov     cx, KGDT_LDT

@@:     mov     [eax]+TssLDT, cx                     ; set LDT into old TSS

;
; Update the TSS pointer in the PCR to point to the NMI TSS
; (which is what we're running on, or else we wouldn't be here)
;
        push    dword ptr PCR[PcTss]

        mov     eax, PCR[PcGdt]
        mov     ch, [eax+KGDT_NMI_TSS+KgdtBaseHi]
        mov     cl, [eax+KGDT_NMI_TSS+KgdtBaseMid]
        shl     ecx, 16
        mov     cx, [eax+KGDT_NMI_TSS+KgdtBaseLow]
        mov     PCR[PcTss], ecx

;
; Clear Nested Task bit in EFLAGS
;
        pushfd
        and     [esp], not 04000h
        popfd

;
; Clear the busy bit in the TSS selector
;
        mov     ecx, PCR[PcGdt]
        lea     eax, [ecx] + KGDT_NMI_TSS
        mov     byte ptr [eax+5], 089h  ; 32bit, dpl=0, present, TSS32, not busy

;
; Allow only one processor at a time to enter the NMI path.  While
; waiting, spin on a LOCAL data structure (to avoid cache thrashing
; during a crashdump which can cause the dump to hang), and poll for
; Freeze IPI requests so that the correct state for this processor
; appears in the crashdump.
;
;
; (1) make a trap frame,
; (2) acquire lock
; (3) while not lock owner
; (4)     if (IPI_FREEZE)
; (5)        KeFreezeExecutionTarget(&TrapFrame, NULL)
; (6) let the HAL have it
; (7) release lock to next in line
;
; Build trap frame from the data in the previous TSS.
;

        mov     eax, [esp]              ; get saved TSS address
        push    0                       ; build trap frame, starting with
        push    0                       ; faked V86Gs thru V86Es
        push    0
        push    0
        push    [eax].TssSs             ; copy fields from TSS to
        push    [eax].TssEsp            ; trap frame.
        push    [eax].TssEflags
        push    [eax].TssCs
        push    [eax].TssEip
        push    0
        push    [eax].TssEbp
        push    [eax].TssEbx
        push    [eax].TssEsi
        push    [eax].TssEdi
        push    [eax].TssFs
        push    PCR[PcExceptionList]
        push    -1                      ; previous mode
        push    [eax].TssEax
        push    [eax].TssEcx
        push    [eax].TssEdx
        push    [eax].TssDs
        push    [eax].TssEs
        push    [eax].TssGs
        push    0                       ; fake out the debug registers
        push    0
        push    0
        push    0
        push    0
        push    0
        push    0                       ; temp ESP
        push    0                       ; temp CS
        push    0
        push    0
        push    [eax].TssEip
        push    [eax].TssEbp
        mov     ebp, esp                ; ebp -> TrapFrame
        stdCall _KiSaveProcessorState, <ebp, 0> ; save processor state

.FPO ( 0, 0, 0, 0, 0, FPO_TRAPFRAME )

        stdCall _KiHandleNmi            ; Rundown the list of NMI handlers
        or      al, al                  ; did someone handle it?
        jne     short Kt02100           ; jif handled

;
; In the UP case, jump to the recursive NMI processing code if this is a
; nested NMI.
;
; In the MP case, attempt to acquire the NMI lock, checking for freeze
; execution in case another processor is trying to dump memory.  We need
; a special check here to jump to the recursive NMI processing code if
; we're already the owner of the NMI lock.
;

ifdef NT_UP

        cmp     ds:KiNMIRecursionCount, 0
        jne     short Kt0260

else

;
; Check if we recursed out of the HAL and back into the NMI handler.
;

        xor     ebx, ebx
        mov     bl, PCR[PcNumber]       ; extend processor number to 32 bits
        cmp     ds:KiNMIOwner, ebx      ; check against the NMI lock owner
        je      short Kt0260            ; go handle nested NMI if needed

;
; We aren't dealing with a recursive NMI out of the HAL, so try to acquire the
; NMI lock.
;

        lea     eax, KiLockNMI          ; build in stack queued spin lock.
        push    eax
        push    0
        mov     ecx, esp
        mov     edx, ebp
        fstCall KiAcquireQueuedSpinLockCheckForFreeze

endif

        jmp     short Kt0280

;
; The processor will hold off nested NMIs until an iret instruction is
; executed or until we enter and leave SMM mode.  There is exposure in this
; second case because the processor doesn't save the "NMI disabled" indication
; along with the rest of the processor state in the SMRAM save state map.  As
; a result, it unconditionally enables NMIs when leaving SMM mode.
;
; This means that we're exposed to nested NMIs in the following cases.
;
; 1) When the HAL issues an iret to enter the int 10 BIOS code needed to print
;    an error message to the screen.
;
; 2) When the NMI handler is preempted by a BIOS SMI.
;
; 3) When we take some kind of exception from the context of the NMI handler
;    (e.g. due to a debugger breakpoint) and automatically run an iret when
;    exiting the exception handler.
;
; Case (3) isn't of concern since the NMI handler shouldn't be raising
; exceptions except when being debugged.
;
; For (2), NMIs can become "unmasked" while in SMM mode if the SMM code
; actually issues an iret instruction, meaning they may actually occur
; before the SMI handler exits.  We assume that these NMIs will be handled by
; the SMM code.  After the SMI handler exits, NMIs will be "unmasked" and
; we'll continue in the NMI handler, running on the NMI TSS.  If a nested NMI
; comes in at this point, it will be dispatched using the following sequence.
;
;    a) The NMI sends us through a task gate, causing a task switch from the
;       NMI TSS back onto itself.
;
;    b) The processor saves the current execution context in the old TSS.
;       This is the NMI TSS in our case.
;
;    c) The processor sets up the exception handler context by loading the
;       contents of the new TSS.  Since this is also the NMI TSS, we'll just
;       reload our interrupted context and keep executing as if nothing had
;       happened.
;
; The only side effect of this "invisible" NMI is that the backlink field of
; the NMI TSS will be stomped, meaning the link to the TSS containing our
; interrupted context is broken.
;
; In case (1), the NMI isn't invisible since the HAL will "borrow" the
; KGDT_TSS before issuing the iret.  It does this when it finds that the NMI
; TSS doesn't contain space for an IOPM.  Due to "borrowing" the TSS, the
; nested NMI will put us back at the top of this NMI handler.  We've again
; lost touch with the original interrupted context since the NMI TSS backlink
; now points to a TSS containing the state of the interrupted HAL code.
;
; To increase the chances of displaying a blue screen in the presence of
; hardware that erroneously generates multiple NMIs, we reenter the HAL NMI
; handler in response to the first few NMIs fitting into case (1).  Once the
; number of nested NMIs exceeds an arbitrarily chosen threshold value, we
; decide that we're seeing an "NMI storm" of sorts and go into a tight loop.
; We can't bugcheck the system directly since this will invoke the same HAL
; int 10 code that allowed us to keep looping through this routine in the
; first place.
;
; The only other case where this handler needs to explicitly account for
; nested NMIs is to avoid exiting the handler when our original interrupted
; context has been lost as will happen in cases (2) and (3).
;

KI_NMI_RECURSION_LIMIT equ 8

Kt0260:

        cmp     ds:KiNMIRecursionCount, KI_NMI_RECURSION_LIMIT
        jb      short Kt0280

;
; When we first hit the recursion limit, take a shot at entering the debugger.
; Go into a tight loop if this somehow causes additional recursion.
;

        jne     short Kt0270

        cmp     _KdDebuggerNotPresent, 0
        jne     short Kt0270

        cmp     _KdDebuggerEnabled, 0
        je      short Kt0270

        stdCall _KeEnterKernelDebugger

Kt0270:
        jmp     short Kt0270

;
; This processor now owns the NMI lock.   See if the HAL will handle the NMI.
; If the HAL does not handle it, it will NOT return, so if we get back here,
; it's handled.
;
; Before handing off to the HAL, set the NMI owner field and increment the NMI
; recursion count so we'll be able to properly handle cases where we recurse
; out of the HAL back into the NMI handler.
;

Kt0280:

ifndef NT_UP
        mov     ds:KiNMIOwner, ebx
endif
        inc     ds:KiNMIRecursionCount
        stdCall _HalHandleNMI,<0>

;
; We're back, therefore the Hal has dealt with the NMI.  Clear the NMI owner
; flag, decrement the NMI recursion count, and release the NMI lock.
;
; As described above, we can't safely resume execution if we're running in the
; context of a nested NMI.  Bugcheck the machine if the NMI recursion counter
; indicates that this is the case.
;

        dec     ds:KiNMIRecursionCount
        jnz     Kt02200

ifndef NT_UP

        mov     ds:KiNMIOwner, KI_NMI_UNOWNED

        mov     ecx, esp                ; release queued spinlock.
        fstCall KeReleaseQueuedSpinLockFromDpcLevel
        add     esp, 8                  ; free queued spinlock context

endif

Kt02100:

;
; As described in the comments above, we can experience "invisible" nested
; NMIs whose only effect will be pointing the backlink field of the NMI TSS
; to itself.  Our interrupted context is gone in these cases so we can't leave
; this exception handler if we find a self referencing backlink.  The backlink
; field is found in the first 2 bytes of the TSS structure.
;
; N.B. This still leaves a window where an invisible NMI can cause us to iret
;      back onto the NMI TSS.  The busy bit of the NMI TSS will be cleared on
;      the first iret, which will lead to a general protection fault when we
;      try to iret back into the NMI TSS (iret expects the targeted task to be
;      marked "busy").
;

        mov     eax, PCR[PcTss]
        cmp     word ptr [eax], KGDT_NMI_TSS    ; check for a self reference
        je      Kt02200

        add     esp, KTRAP_FRAME_LENGTH ; free trap frame
        pop     dword ptr PCR[PcTss]    ; restore PcTss

        mov     ecx, PCR[PcGdt]
        lea     eax, [ecx] + KGDT_TSS
        mov     byte ptr [eax+5], 08bh  ; 32bit, dpl=0, present, TSS32, *busy*

        pushfd                          ; Set Nested Task bit in EFLAGS
        or      [esp], 04000h           ; so iretd will do a task switch
        popfd

        iretd                           ; Return from NMI
        jmp     _KiTrap02               ; in case we NMI again

;
; We'll branch here if we need to bugcheck the machine directly.
;

Kt02200:

        mov     eax, EXCEPTION_NMI
        jmp     _KiSystemFatalException

_KiTrap02       endp

        page ,132
        subttl "DebugService Breakpoint"
;++
;
; Routine Description:
;
;    Handle INT 2d DebugService
;
;    The trap is caused by an INT 2d.  This is used instead of a
;    BREAKPOINT exception so that parameters can be passed for the
;    requested debug service.  A BREAKPOINT instruction is assumed
;    to be right after the INT 2d - this allows this code to share code
;    with the breakpoint handler.
;
; Arguments:
;     eax - ServiceClass - which call is to be performed
;     ecx - Arg1 - generic first argument
;     edx - Arg2 - generic second argument
;     ebx - Arg3 - generic third argument
;
;--

        ASSUME  DS:NOTHING, SS:NOTHING, ES:NOTHING

        ENTER_DR_ASSIST kids_a, kids_t, NoAbiosAssist
align dword
        public  _KiDebugService
_KiDebugService  proc
        push    0                           ; push dummy error code
        ENTER_TRAP      kids_a, kids_t
;       sti                                 ; *NEVER sti here*

        inc     dword ptr [ebp]+TsEip
        mov     eax, [ebp]+TsEax            ; ServiceClass
        mov     ecx, [ebp]+TsEcx            ; Arg1      (already loaded)
        mov     edx, [ebp]+TsEdx            ; Arg2      (already loaded)
        jmp     KiTrap03DebugService

_KiDebugService  endp

        page ,132
        subttl "Single Byte INT3 Breakpoin"
;++
;
; Routine Description:
;
;    Handle INT 3 breakpoint.
;
;    The trap is caused by a single byte INT 3 instruction.  A
;    BREAKPOINT exception with additional parameter indicating
;    READ access is raised for this trap if previous mode is user.
;
; Arguments:
;
;    At entry, the saved CS:EIP point to the instruction immediately
;    following the INT 3 instruction.
;    No error code is provided with the error.
;
; Return value:
;
;    None
;
;--
        ASSUME  DS:NOTHING, SS:NOTHING, ES:NOTHING

        ENTER_DR_ASSIST kit3_a, kit3_t, NoAbiosAssist
align dword
        public  _KiTrap03
_KiTrap03       proc
        push    0                       ; push dummy error code
        ENTER_TRAP      kit3_a, kit3_t

        cmp     ds:_PoHiberInProgress, 0
        jnz     short kit03_01

   lock inc     ds:_KiHardwareTrigger   ; trip hardware analyzer

kit03_01:
        mov     eax, BREAKPOINT_BREAK

KiTrap03DebugService:
;
; If caller is user mode, we want interrupts back on.
;   . all relevant state has already been saved
;   . user mode code always runs with ints on
;
; If caller is kernel mode, we want them off!
;   . some state still in registers, must prevent races
;   . kernel mode code can run with ints off
;
;
; Arguments:
;     eax - ServiceClass - which call is to be performed
;     ecx - Arg1 - generic first argument
;     edx - Arg2 - generic second argument
;

.errnz (EFLAGS_V86_MASK AND 0FF00FFFFh)
        test    byte ptr [ebp]+TsEFlags+2,EFLAGS_V86_MASK/010000h
        jnz     kit03_30                ; fault occured in V86 mode => Usermode

.errnz (MODE_MASK AND 0FFFFFF00h)
        test    byte ptr [ebp]+TsSegCs,MODE_MASK
        jz      kit03_10

        cmp     word ptr [ebp]+TsSegCs,KGDT_R3_CODE OR RPL_MASK
        jne     kit03_30

kit03_05:
        sti
kit03_10:


;
; Set up exception record and arguments for raising breakpoint exception
;

        mov     esi, ecx                ; ExceptionInfo 2
        mov     edi, edx                ; ExceptionInfo 3
        mov     edx, eax                ; ExceptionInfo 1

        mov     ebx, [ebp]+TsEip
        dec     ebx                     ; (ebx)-> int3 instruction
        mov     ecx, 3
        mov     eax, STATUS_BREAKPOINT
        call    CommonDispatchException ; Never return

kit03_30:
; Check to see if this process is a vdm

        mov     ebx,PCR[PcPrcbData+PbCurrentThread]
        mov     ebx,[ebx]+ThApcState+AsProcess
        cmp     dword ptr [ebx]+PrVdmObjects,0 ; is this a vdm process?
        je      kit03_05

        stdCall _Ki386VdmReflectException_A, <03h>
        test    ax,0FFFFh
        jz      Kit03_10

        jmp     _KiExceptionExit

_KiTrap03       endp

        page ,132
        subttl "Integer Overflow"
;++
;
; Routine Description:
;
;    Handle INTO overflow.
;
;    The trap occurs when the processor encounters an INTO instruction
;    and the OF flag is set.
;
;    An INTEGER_OVERFLOW exception will be raised for this fault.
;
;    N.B. i386 will not generate fault if only OF flag is set.
;
; Arguments:
;
;    At entry, the saved CS:EIP point to the instruction immediately
;    following the INTO instruction.
;    No error code is provided with the error.
;
; Return value:
;
;    None
;
;--
        ASSUME  DS:NOTHING, SS:NOTHING, ES:NOTHING

        ENTER_DR_ASSIST kit4_a, kit4_t, NoAbiosAssist
align dword
        public  _KiTrap04
_KiTrap04       proc

        push    0                       ; push dummy error code
        ENTER_TRAP      kit4_a, kit4_t

.errnz (EFLAGS_V86_MASK AND 0FF00FFFFh)
        test    byte ptr [ebp]+TsEFlags+2,EFLAGS_V86_MASK/010000h
        jnz     short Kt0430            ; in a vdm, reflect to vdm

.errnz (MODE_MASK AND 0FFFFFF00h)
        test    byte ptr [ebp]+TsSegCs,MODE_MASK
        jz      short Kt0410            ; in kernel mode, gen exception

        cmp     word ptr [ebp]+TsSegCs,KGDT_R3_CODE OR RPL_MASK
        jne     short Kt0420            ; maybe in a vdm

; Set up exception record and arguments for raising exception

Kt0410: sti
        mov     ebx, [ebp]+TsEip        ; (ebx)-> instr. after INTO
        dec     ebx                     ; (ebx)-> INTO
        mov     eax, STATUS_INTEGER_OVERFLOW
        jmp     CommonDispatchException0Args ; Never return

Kt0430:
        stdCall _Ki386VdmReflectException_A, <04h>
        test    al,0fh
        jz      Kt0410                  ; couldn't reflect, gen exception
        jmp     _KiExceptionExit

Kt0420:
; Check to see if this process is a vdm

        mov     ebx,PCR[PcPrcbData+PbCurrentThread]
        mov     ebx,[ebx]+ThApcState+AsProcess
        cmp     dword ptr [ebx]+PrVdmObjects,0 ; is this a vdm process?
        je      Kt0410
        jmp     Kt0430

_KiTrap04       endp

        page ,132
        subttl "Bound Check fault"
;++
;
; Routine Description:
;
;    Handle bound check fault.
;
;    The bound check fault occurs if a BOUND instruction finds that
;    the tested value is outside the specified range.
;
;    For bound check fault, an ARRAY BOUND EXCEEDED exception will be
;    raised.
;    For kernel mode exception, it causes system to be terminated.
;
; Arguments:
;
;    At entry, the saved CS:EIP point to the faulting BOUND
;    instruction.
;    No error code is provided with the error.
;
; Return value:
;
;    None
;
;--
        ASSUME  DS:NOTHING, SS:NOTHING, ES:NOTHING
        ENTER_DR_ASSIST kit5_a, kit5_t, NoAbiosAssist
align dword
        public  _KiTrap05
_KiTrap05       proc

        push    0                       ; push dummy error code
        ENTER_TRAP      kit5_a, kit5_t

.errnz (EFLAGS_V86_MASK AND 0FF00FFFFh)
        test    byte ptr [ebp]+TsEFlags+2,EFLAGS_V86_MASK/010000h
        jnz     short Kt0530            ; fault in V86 mode

.errnz (MODE_MASK AND 0FFFFFF00h)
        test    byte ptr [ebp]+TsSegCs, MODE_MASK  ; Is previous mode = USER
        jnz     short Kt0500            ; if nz, previous mode = user
        mov     eax, EXCEPTION_BOUND_CHECK ; (eax) = exception type
        jmp     _KiSystemFatalException ; go terminate the system


kt0500: cmp     word ptr [ebp]+TsSegCs,KGDT_R3_CODE OR RPL_MASK
        jne     short Kt0520            ; maybe in a vdm
;
; set exception record and arguments and call _KiDispatchException
;
Kt0510: sti
        mov     ebx, [ebp]+TsEip        ; (ebx)->BOUND instruction
        mov     eax, STATUS_ARRAY_BOUNDS_EXCEEDED
        jmp     CommonDispatchException0Args ; Won't return

Kt0520:
; Check to see if this process is a vdm

        mov     ebx,PCR[PcPrcbData+PbCurrentThread]
        mov     ebx,[ebx]+ThApcState+AsProcess
        cmp     dword ptr [ebx]+PrVdmObjects,0 ; is this a vdm process?
        je      Kt0510

Kt0530:

        stdCall _Ki386VdmReflectException_A, <05h>
        test    al,0fh
        jz      Kt0510            ; couldn't reflect, gen exception
        jmp     _KiExceptionExit

_KiTrap05       endp

        page ,132
        subttl "Invalid OP code"
;++
;
; Routine Description:
;
;    Handle invalid op code fault.
;
;    The invalid opcode fault occurs if CS:EIP point to a bit pattern which
;    is not recognized as an instruction by the x86.  This may happen if:
;
;    1. the opcode is not a valid 80386 instruction
;    2. a register operand is specified for an instruction which requires
;       a memory operand
;    3. the LOCK prefix is used on an instruction that cannot be locked
;
;    If fault occurs in USER mode:
;       an Illegal_Instruction exception will be raised
;    if fault occurs in KERNEL mode:
;       system will be terminated.
;
; Arguments:
;
;    At entry, the saved CS:EIP point to the first byte of the invalid
;    instruction.
;    No error code is provided with the error.
;
; Return value:
;
;    None
;
;--
        ASSUME  DS:FLAT, SS:NOTHING, ES:NOTHING

        ENTER_DR_ASSIST kit6_a, kit6_t, NoAbiosAssist,, kit6_v
align dword
        public  _KiTrap06
_KiTrap06       proc

        ;
        ; KiTrap06 is performance critical for VDMs and rarely executed in
        ; native mode.  So this routine is tuned for the VDM case.
        ;
.errnz (EFLAGS_V86_MASK AND 0FF00FFFFh)

        test    byte ptr [esp]+8h+2,EFLAGS_V86_MASK/010000h
        jz      Kt060i

if FAST_BOP
        FAST_V86_TRAP_6
endif

Kt6SlowBop:
        push    0                       ; push dummy error code
        ENTER_TRAPV86 kit6_a, kit6_v
Kt6SlowBop1:
Kt06VMpf:

        ;
        ; If the current process is NOT a VDM just hand it an
        ; illegal instruction exception.
        ;

        mov     ecx,PCR[PcPrcbData+PbCurrentThread]
        mov     ecx,[ecx]+ThApcState+AsProcess
        cmp     dword ptr [ecx]+PrVdmObjects,0  ; if not a vdm process,
        je      Kt0635                          ; then deliver exception

        ;
        ; Raise Irql to APC level before enabling interrupts to prevent
        ; a setcontext from editing the trapframe.
        ;

        RaiseIrql APC_LEVEL
        push    eax                     ; Save OldIrql
if DBG
        cmp     eax, PASSIVE_LEVEL
        je      @f
        int     3
@@:
endif
        sti

        ;
        ; Call VdmDispatchBop to try and handle the opcode immediately.
        ; If it returns FALSE (meaning too complicated for us to quickly parse)
        ; then reflect the opcode off to the ntvdm monitor to handle it.
        ;

        stdCall _VdmDispatchBop, <ebp>

        ;
        ; If the operation was processed directly above then return back now.
        ;

        test    al,0fh
        jnz     short Kt061i

        ;
        ; The operation could not be processed directly above so reflect it
        ; back to the ntvdm monitor now.
        ;


        stdCall   _Ki386VdmReflectException,<6>

        test    al,0fh
        jnz     Kt061i
        pop     ecx                     ; (TOS) = OldIrql
        LowerIrql ecx
        jmp     Kt0635
Kt061i:
        pop     ecx                     ; (TOS) = OldIrql
        LowerIrql ecx
        cli
.errnz (EFLAGS_V86_MASK AND 0FF00FFFFh)
        test    byte ptr [ebp]+TsEFlags+2,EFLAGS_V86_MASK/010000h
        jz      Kt062i

        ;
        ; EXIT_TRAPv86 does not exit if a user mode apc has switched
        ; the context from V86 mode to flat mode (VDM monitor context)
        ;

        EXIT_TRAPV86

Kt062i:
        jmp     _KiExceptionExit

Kt060i:

        ;
        ; Non-v86 (user or kernel) executing code arrives here for
        ; invalid opcode traps.
        ;

        push    0                       ; Push dummy error code
        ENTER_TRAP      kit6_a, kit6_t
Kt06pf:

        test    byte ptr [ebp]+TsSegCs, MODE_MASK  ; Is previous mode = USER
        jz      short Kt0635            ; if z, kernel mode - go dispatch exception

        ;
        ; UserMode. Did the fault happen in a vdm running in protected mode?
        ;

        cmp     word ptr [ebp]+TsSegCs, KGDT_R3_CODE OR RPL_MASK
        jz      short kt0605            ; normal 32-bit mode so give exception

        ;
        ; The code segment is not a normal flat 32-bit entity, so see if
        ; this process is a vdm.  If so, then try to handle it.  If not,
        ; give this process an exception.
        ;

        mov     ebx,PCR[PcPrcbData+PbCurrentThread]
        mov     ebx,[ebx]+ThApcState+AsProcess
        cmp     dword ptr [ebx]+PrVdmObjects,0 ; is this a vdm process?
        jne     Kt0650

kt0605:

        ;
        ; Invalid Opcode exception could be either INVALID_LOCK_SEQUENCE or
        ; ILLEGAL_INSTRUCTION.
        ;

        mov     esi, [ebp]+TsEip

        sti

	; This should be a completely valid user address, but for consistency
	; it will be probed here.
	cmp	esi, _MmUserProbeAddress ; Probe captured EIP
        jb      short kt0606
        mov     esi, _MmUserProbeAddress ; Use bad user EIP to force exception
kt0606:
        mov     ecx, MAX_INSTRUCTION_PREFIX_LENGTH

        ;
        ; Set up an exception handler in case we fault
        ; while reading the user mode instruction.
        ;

        push    ebp                     ; pass trapframe to handler
        push    offset FLAT:Kt6_ExceptionHandler
                                        ; set up exception registration record
        push    PCR[PcExceptionList]
        mov     PCR[PcExceptionList], esp

        ; esi -> address of faulting instruction

@@:
        mov     al, byte ptr [esi]      ; (al) = instruction byte
        cmp     al, MI_LOCK_PREFIX      ; Is it a lock prefix?
        je      short Kt0640            ; Yes, raise Invalid_lock exception
        add     esi, 1
        loop    short @b                ; keep on looping

        pop     PCR[PcExceptionList]
        add     esp, 8                  ; clear stack

Kt0630:
        ;
        ; Set up exception record for raising Illegal instruction exception
        ;

Kt0635:
        sti
        mov     ebx, [ebp]+TsEip        ; (ebx)-> invalid instruction
        mov     eax, STATUS_ILLEGAL_INSTRUCTION
        jmp     CommonDispatchException0Args ; Won't return

;
; Set up exception record for raising Invalid lock sequence exception
;

Kt0640:
        pop     PCR[PcExceptionList]
        add     esp, 8                  ; clear stack

        mov     ebx, [ebp]+TsEip        ; (ebx)-> invalid instruction
        mov     eax, STATUS_INVALID_LOCK_SEQUENCE
        jmp     CommonDispatchException0Args ; Won't return

Kt0650:

        ; Raise Irql to APC level before enabling interrupts
        RaiseIrql APC_LEVEL
        push    eax                                 ; SaveOldIrql
        sti

        stdCall _VdmDispatchBop, <ebp>

        test    al,0fh
        jnz     short Kt0660

        stdCall   _Ki386VdmReflectException,<6>
        test    al,0fh
        jnz      Kt0660
        pop     ecx                         ; (TOS) = OldIrql
        LowerIrql ecx
        jmp      short Kt0635

Kt0660:
        pop     ecx                         ; (TOS) = OldIrql
        LowerIrql ecx
        jmp     _KiExceptionExit

_KiTrap06       endp

;
;   Error and exception blocks for KiTrap06
;

Kt6_ExceptionHandler proc

        ;
        ; WARNING: Here we directly unlink the exception handler from the
        ; exception registration chain.  NO unwind is performed.
        ;

        mov     esp, [esp+8]            ; (esp)-> ExceptionList
        pop     PCR[PcExceptionList]
        add     esp, 4                  ; pop out except handler
        pop     ebp                     ; (ebp)-> trap frame

        test    dword ptr [ebp].TsSegCs, MODE_MASK ; if premode=kernel
        jnz     Kt0630                  ; nz, prevmode=user, go return

        ;
        ; Raise bugcheck if prevmode=kernel
        ;

        stdCall   _KeBugCheck2, <KMODE_EXCEPTION_NOT_HANDLED,0,0,0,0,ebp>
Kt6_ExceptionHandler endp

        page ,132
        subttl "Coprocessor Not Avalaible"
;++
;
; Routine Description:
;
;   Handle Coprocessor not available exception.
;
;   If we are REALLY emulating the FPU, the trap 07 vector is edited
;   to point directly at the emulator's entry point.  So this code is
;   only hit when FPU hardware DOES exist.
;
;   The current thread's coprocessor state is loaded into the
;   coprocessor.  If the coprocessor has a different thread's state
;   in it (UP only) it is first saved away.  The thread is then continued.
;   Note: the thread's state may contain the TS bit - In this case the
;   code loops back to the top of the Trap07 handler.  (which is where
;   we would end up if we let the thread return to user code anyway).
;
;   If the thread's NPX context is in the coprocessor and we hit a Trap07
;   there is an NPX error which needs to be processed.  If the trap was
;   from usermode the error is dispatched.  If the trap was from kernelmode
;   the error is remembered, but we clear CR0 so the kernel code can
;   continue.  We can do this because the kernel mode code will restore
;   CR0 (and set TS) to signal a delayed error for this thread.
;
; Arguments:
;
;    At entry, the saved CS:EIP point to the first byte of the faulting
;    instruction.
;    No error code is provided with the error.
;
; Return value:
;
;    None
;
;--
        ASSUME  DS:NOTHING, SS:NOTHING, ES:NOTHING

        ENTER_DR_ASSIST kit7_a, kit7_t, NoAbiosAssist
align dword
        public  _KiTrap07
_KiTrap07       proc

        push    0                       ; push dummy error code
        ENTER_TRAP      kit7_a, kit7_t

Kt0700:
        mov     eax, PCR[PcPrcbData+PbCurrentThread]
        mov     ecx, [eax].ThInitialStack ; (ecx) -> top of kernel stack
        sub     ecx, NPX_FRAME_LENGTH
.errnz (CR0_EM AND 0FFFFFF00h)
        test    byte ptr [ecx].FpCr0NpxState,CR0_EM
        jnz     Kt07140

Kt0701: cmp     byte ptr [eax].ThNpxState, NPX_STATE_LOADED
        mov     ebx, cr0
        je      Kt0710

;
; Trap occured and this thread's NPX state is not loaded.  Load it now
; and resume the application.  If someone else's state is in the coprocessor
; (uniprocessor implementation only) then save it first.
;

        and     ebx, NOT (CR0_MP+CR0_TS+CR0_EM)
        mov     cr0, ebx                ; allow frstor (& fnsave) to work

ifdef NT_UP
Kt0702:
        mov     edx, PCR[PcPrcbData+PbNpxThread] ; Owner of NPX state
        or      edx, edx                ; NULL?
        jz      Kt0704                  ; Yes - skip save

;
; Due to an hardware errata we need to know that the coprocessor
; doesn't generate an error condition once interrupts are disabled and
; trying to perform an fnsave which could wait for the error condition
; to be handled.
;
; The fix for this errata is that we "know" that the coprocessor is
; being used by a different thread then the one which may have caused
; the error condition.  The round trip time to swap to a new thread
; is longer then ANY floating point instruction.  We therefore know
; that any possible coprocessor error has already occured and been
; handled.
;
        mov     esi,[edx].ThInitialStack
        sub     esi, NPX_FRAME_LENGTH   ; Space for NPX_FRAME

        test    byte ptr _KeI386FxsrPresent, 1  ; Is FXSR feature present
        jz      short Kt0703a
        FXSAVE_ESI
        jmp     short Kt0703b
Kt0703a:
        fnsave  [esi]                   ; Save thread's coprocessor state
Kt0703b:
        mov     byte ptr [edx].ThNpxState, NPX_STATE_NOT_LOADED
Kt0704:
endif

;
; Load current thread's coprocessor state into the coprocessor
;
; (eax) - CurrentThread
; (ecx) - CurrentThread's NPX save area
; (ebx) - CR0
; (ebp) - trap frame
; Interrupts disabled
;

;
; frstor might generate a NPX exception if there's an error image being
; loaded.  The handler will simply set the TS bit for this context an iret.
;

        test    byte ptr _KeI386FxsrPresent, 1  ; Is FXSR feature present
        jz      short Kt0704b

ifndef NT_UP
endif
        FXRSTOR_ECX                     ; reload NPX context
        jmp     short Kt0704c
Kt0704b:
        frstor  [ecx]                   ; reload NPX context

Kt0704c:
        mov     byte ptr [eax].ThNpxState, NPX_STATE_LOADED
        mov     PCR[PcPrcbData+PbNpxThread], eax  ; owner of coprocessors state

        sti                             ; Allow interrupts & context switches
        nop                             ; sti needs one cycle

        cmp     dword ptr [ecx].FpCr0NpxState, 0
        jz      _KiExceptionExit        ; nothing to set, skip CR0 reload

;
; Note: we have to get the CR0 value again to ensure that we have the
;       correct state for TS.  We may have context switched since
;       the last move from CR0, and our npx state may have been moved off
;       of the npx.
;
        cli
if DBG
        test    dword ptr [ecx].FpCr0NpxState, NOT (CR0_MP+CR0_EM+CR0_TS)
        jnz short Kt07dbg1
endif
        mov     ebx,CR0
        or      ebx, [ecx].FpCr0NpxState
        mov     cr0, ebx                ; restore thread's CR0 NPX state
        sti
.errnz (CR0_TS AND 0FFFFFF00h)
        test    bl, CR0_TS              ; Setting TS?  (delayed error)
        jz      _KiExceptionExit        ; No - continue

        clts
        cli                             ; Make sure interrupts disabled
        jmp     Kt0700                  ; Dispatch delayed exception
if DBG
Kt07dbg1:    int 3
Kt07dbg2:    int 3
Kt07dbg3:    int 3
        sti
        jmp short $-2
endif

Kt0705:
;
; A Trap07 or Trap10 has occured from a ring 0 ESCAPE instruction.  This
; may occur when trying to load the coprocessors state.  These
; code paths rely on Cr0NpxState to signal a delayed error (not CR0) - we
; set CR0_TS in Cr0NpxState to get a delayed error, and make sure CR0 CR0_TS
; is not set so the R0 ESC instruction(s) can complete.
;
; (ecx) - CurrentThread's NPX save area
; (ebp) - trap frame
; Interrupts disabled
;

if DBG
        mov     eax, cr0                    ; Did we fault because some bit in CR0
        test    eax, (CR0_TS+CR0_MP+CR0_EM)
        jnz     short Kt07dbg3
endif

        or      dword ptr [ecx].FpCr0NpxState, CR0_TS   ; signal a delayed error

        cmp     dword ptr [ebp]+TsEip, Kt0704b  ; Is this fault on reload a thread's context?
        jne     short Kt0716                ; No, dispatch exception

        add     dword ptr [ebp]+TsEip, 3    ; Skip frstor ecx instruction
        jmp     _KiExceptionExit
; A floating point exception was just swallowed (instruction was of no-wait type).
Kt0709:
	sti				; Re-enable interrupts
        jmp     _KiExceptionExit        ; Already handled
        

Kt0710:
.errnz (CR0_TS AND 0FFFFFF00h)
        test    bl, CR0_TS             ; check for task switch
        jnz     Kt07150

;
; WARNING:  May enter here from the trap 10 handler.
; Expecting interrupts disabled.
;

Kt0715:
.errnz (EFLAGS_V86_MASK AND 0FF00FFFFh)
        test    byte ptr [ebp]+TsEFlags+2,EFLAGS_V86_MASK/010000h
        jnz     Kt07110                 ; v86 mode

.errnz (MODE_MASK AND 0FFFFFF00h)
        test    byte ptr [ebp]+TsSegCs, MODE_MASK ; Is previousMode=USER?
        jz      Kt0705                  ; if z, previousmode=SYSTEM

        cmp     word ptr [ebp]+TsSegCs,KGDT_R3_CODE OR RPL_MASK
        jne     Kt07110

;
; We are about to dispatch a floating point exception to user mode.
; We need to check to see if the user's NPX instruction is supposed to
; cause an exception or not. Interrupts should be disabled.
;
; (ecx) - CurrentThread's NPX save area
;

Kt0716: stdCall _Ki386CheckDelayedNpxTrap,<ebp,ecx>
        or      al, al
	jnz	short Kt0709

Kt0719:
        mov     eax, PCR[PcPrcbData+PbCurrentThread]
; Since Ki386CheckDelayedNpxTrap toggled the interrupt state, the NPX state
; may no longer be resident.
	cmp     byte ptr [eax].ThNpxState, NPX_STATE_NOT_LOADED
        mov     ecx, [eax].ThInitialStack ; (ecx) -> top of kernel stack
        lea     ecx, [ecx-NPX_FRAME_LENGTH]
        je	Kt0726a

Kt0720:
;
; Some type of coprocessor exception has occured for the current thread.
;
; (eax) - CurrentThread
; (ecx) - CurrentThread's NPX save area
; (ebp) - TrapFrame
; Interrupts disabled
;
        mov     ebx, cr0
        and     ebx, NOT (CR0_MP+CR0_EM+CR0_TS)
        mov     cr0, ebx                ; Clear MP+TS+EM to do fnsave & fwait

;
; Save the faulting state so we can inspect the cause of the floating
; point fault
;

        test    byte ptr _KeI386FxsrPresent, 1  ; Is FXSR feature present
        jz      short Kt0725a
        FXSAVE_ECX
        jmp     short Kt0725b
Kt0725a:
        fnsave  [ecx]                   ; Save thread's coprocessor state
        fwait                           ; in case fnsave hasn't finished yet
Kt0725b:

if DBG
        test    dword ptr [ecx].FpCr0NpxState, NOT (CR0_MP+CR0_EM+CR0_TS)
        jnz     Kt07dbg2
endif
        or      ebx, NPX_STATE_NOT_LOADED
        or      ebx,[ecx]+FpCr0NpxState ; restore this thread's CR0 NPX state
        mov     cr0, ebx                ; set TS so next ESC access causes trap

;
; The state is no longer in the coprocessor.  Clear ThNpxState and
; re-enable interrupts to allow context switching.
;
        mov     byte ptr [eax].ThNpxState, NPX_STATE_NOT_LOADED
        mov     dword ptr PCR[PcPrcbData+PbNpxThread], 0  ; No state in coprocessor
;
; Clear TS bit in Cr0NpxFlags in case it was set to trigger this trap.
;
Kt0726a:
        and     dword ptr [ecx].FpCr0NpxState, NOT CR0_TS
Kt0726b:
        sti

;
; According to the floating error priority, we test what is the cause of
; the NPX error and raise an appropriate exception.
;

        test    byte ptr _KeI386FxsrPresent, 1  ; Is FXSR feature present
        jz      short Kt0727a

        mov     ebx, [ecx] + FxErrorOffset
        movzx   eax, word ptr [ecx] + FxControlWord
        movzx   edx, word ptr [ecx] + FxStatusWord
        mov     esi, [ecx] + FxDataOffset ; (esi) = operand addr
        jmp     short Kt0727b

Kt0727a:
        mov     ebx, [ecx] + FpErrorOffset
        movzx   eax, word ptr [ecx] + FpControlWord
        movzx   edx, word ptr [ecx] + FpStatusWord
        mov     esi, [ecx] + FpDataOffset ; (esi) = operand addr

Kt0727b:

        and     eax, FSW_INVALID_OPERATION + FSW_DENORMAL + FSW_ZERO_DIVIDE + FSW_OVERFLOW + FSW_UNDERFLOW + FSW_PRECISION
        not     eax                        ; ax = mask of enabled exceptions
        and     eax, edx
.errnz (FSW_INVALID_OPERATION AND 0FFFFFF00h)
        test    al, FSW_INVALID_OPERATION  ; Is it an invalid op exception?
        jz      short Kt0740               ; if z, no, go Kt0740
.errnz (FSW_STACK_FAULT AND 0FFFFFF00h)
        test    al, FSW_STACK_FAULT        ; Is it caused by stack fault?
        jnz     short Kt0730               ; if nz, yes, go Kt0730

; Raise Floating reserved operand exception
;

        mov     eax, STATUS_FLOAT_INVALID_OPERATION
        jmp     CommonDispatchException1Arg0d ; Won't return

Kt0730:
;
; Raise Access Violation exception for stack overflow/underflow
;

        mov     eax, STATUS_FLOAT_STACK_CHECK
        jmp     CommonDispatchException2Args0d ; Won't return

Kt0740:

; Check for floating zero divide exception

.errnz (FSW_ZERO_DIVIDE AND 0FFFFFF00h)
        test    al, FSW_ZERO_DIVIDE     ; Is it a zero divide error?
        jz      short Kt0750            ; if z, no, go Kt0750

; Raise Floating divided by zero exception

        mov     eax, STATUS_FLOAT_DIVIDE_BY_ZERO
        jmp     CommonDispatchException1Arg0d ; Won't return

Kt0750:

; Check for denormal error

.errnz (FSW_DENORMAL AND 0FFFFFF00h)
        test    al, FSW_DENORMAL        ; Is it a denormal error?
        jz      short Kt0760            ; if z, no, go Kt0760

; Raise floating reserved operand exception

        mov     eax, STATUS_FLOAT_INVALID_OPERATION
        jmp     CommonDispatchException1Arg0d ; Won't return

Kt0760:

; Check for floating overflow error

.errnz (FSW_OVERFLOW AND 0FFFFFF00h)
        test    al, FSW_OVERFLOW        ; Is it an overflow error?
        jz      short Kt0770            ; if z, no, go Kt0770

; Raise floating overflow exception

        mov     eax, STATUS_FLOAT_OVERFLOW
        jmp     CommonDispatchException1Arg0d ; Won't return

Kt0770:

; Check for floating underflow error
.errnz (FSW_UNDERFLOW AND 0FFFFFF00h)
        test    al, FSW_UNDERFLOW      ; Is it a underflow error?
        jz      short Kt0780            ; if z, no, go Kt0780

; Raise floating underflow exception

        mov     eax, STATUS_FLOAT_UNDERFLOW
        jmp     CommonDispatchException1Arg0d ; Won't return

Kt0780:

; Check for precision (IEEE inexact) error

.errnz (FSW_PRECISION AND 0FFFFFF00h)
        test    al, FSW_PRECISION       ; Is it a precision error
        jz      short Kt07100           ; if z, no, go Kt07100

        mov     eax, STATUS_FLOAT_INEXACT_RESULT
        jmp     CommonDispatchException1Arg0d ; Won't return

Kt07100:

; If status word does not indicate error, then something is wrong...
;
; There is a known bug on Cyrix processors, up to and including
; the MII that causes Trap07 for no real reason (INTR is asserted
; during an FP instruction and is held high too long, we end up
; in the Trap07 handler with not exception set).   Bugchecking seems
; a little heavy handed, if this is a Cyrix processor, just ignore
; the error.

        cmp     _KiIgnoreUnexpectedTrap07, 0
        jnz     _KiExceptionExit

; stop the system
        sti
        stdCall   _KeBugCheck2, <TRAP_CAUSE_UNKNOWN,1,eax,0,0,ebp>

Kt07110:
; Check to see if this process is a vdm

        mov     eax,PCR[PcPrcbData+PbCurrentThread]
        mov     ebx,[eax]+ThApcState+AsProcess
        cmp     dword ptr [ebx]+PrVdmObjects,0 ; is this a vdm process?
        je      Kt0720                  ; no, dispatch exception

Kt07130:
        clts                                ; Turn off TS
        and     dword ptr [ecx]+FpCr0NpxState,NOT CR0_TS


; Reflect the exception to the vdm, the VdmHandler enables interrupts

        ; Raise Irql to APC level before enabling interrupts
        RaiseIrql APC_LEVEL
        push    eax                         ; Save OldIrql
        sti

        stdCall   _VdmDispatchIRQ13, <ebp>  ; ebp - Trapframe
        test    al,0fh
        jnz     Kt07135
        pop     ecx                         ; (TOS) = OldIrql
        LowerIrql ecx

; Could not reflect, generate exception.
;
; FP context may or may not still be loaded.   If loaded, it needs to
; be saved now, if not loaded, skip save.

        mov     eax, PCR[PcPrcbData+PbCurrentThread]
        mov     ecx, [eax].ThInitialStack   ; ecx -> top of kernel stack
        sub     ecx, NPX_FRAME_LENGTH       ; ecx -> NPX save area
        cli
        cmp     byte ptr [eax].ThNpxState, NPX_STATE_LOADED
        je      Kt0720                      ; jif NPX state needs to be saved
        jmp     Kt0726b                     ; NPX state already saved

Kt07135:
        pop     ecx                         ; (TOS) = OldIrql
        LowerIrql ecx
        jmp     _KiExceptionExit

Kt07140:

;
; ensure that this is not an NPX instruction in the kernel. (If
; an app, such as C7, sets the EM bit after executing NPX instructions,
; the fsave in SwapContext will catch an NPX exception
;
        cmp     [ebp].TsSegCS, word ptr KGDT_R0_CODE
        je      Kt0701

;
; Check to see if it really is a VDM
;
        mov     ebx,PCR[PcPrcbData+PbCurrentThread]
        mov     ebx,[ebx]+ThApcState+AsProcess
        cmp     dword ptr [ebx]+PrVdmObjects,0 ; is this a vdm process?
        je      Kt07100

; A vdm is emulating NPX instructions on a machine with an NPX.

        stdCall _Ki386VdmReflectException_A, <07h>
        test    al,0fh
        jnz     _KiExceptionExit

        mov     ebx, [ebp]+TsEip        ; (ebx)->faulting instruction
        mov     eax, STATUS_ACCESS_VIOLATION
        mov     esi, -1
        jmp     CommonDispatchException2Args0d ; Won't return

;
; If the processor took an NMI (or other task switch) CR0_TS will have
; been set.   If this occured while the FP state was loaded it would
; appear that it is no longer valid.   This is not actually true, the
; state is perfectly valid.
;
; Sanity: make sure CR0_MP is clear, if the OS had set CR0_TS, then
; CR0_MP should also be set.
;

Kt07150:
.errnz (CR0_MP AND 0FFFFFF00h)
        test    bl, CR0_MP
        jnz short Kt07151

        clts                                ; clear CR0_TS and continue
        jmp     _KiExceptionExit

Kt07151:
        stdCall   _KeBugCheck2, <TRAP_CAUSE_UNKNOWN,2,ebx,0,0,ebp>
        jmp short Kt07151

_KiTrap07       endp


        page ,132
        subttl "Double Fault"
;++
;
; Routine Description:
;
;    Handle double exception fault.
;
;    Normally, when the processor detects an exception while trying to
;    invoke the handler for a prior exception, the two exception can be
;    handled serially.  If, however, the processor cannot handle them
;    serially, it signals the double-fault exception instead.
;
;    If double exception is detected, no matter previous mode is USER
;    or kernel, a bugcheck will be raised and the system will be terminated.
;
;
; Arguments:
;
;    error code, which is always zero, is pushed on stack.
;
; Return value:
;
;    None
;
;--
        ASSUME  DS:NOTHING, SS:NOTHING, ES:NOTHING



        public  _KiTrap08
_KiTrap08       proc
.FPO (0, 0, 0, 0, 0, 2)

        cli


; 
; Set CR3, the I/O map base address, and LDT segment selector
; in the old TSS since they are not set on context
; switches. These values will be needed to return to the
; interrupted task.

        mov     eax, PCR[PcTss]                      ; get old TSS address
        mov     ecx, PCR[PcPrcbData+PbCurrentThread] ; get thread address
        mov     edi, [ecx].ThApcState.AsProcess      ; get process address
        mov     ecx, [edi]+PrDirectoryTableBase      ; get directory base
        mov     [eax]+TssCR3, ecx                    ; set previous cr3

        mov     cx, [edi]+PrIopmOffset               ; get IOPM offset
        mov     [eax]+TssIoMapBase, cx               ; set IOPM offset

        mov     ecx, [edi]+PrLdtDescriptor           ; get LDT descriptor
        test    ecx, ecx                             ; does task use LDT?
        jz      @f
        mov     cx, KGDT_LDT

@@:     mov     [eax]+TssLDT, cx                     ; set LDT into old TSS

;
; Clear the busy bit in the TSS selector
;

        mov     ecx, PCR[PcGdt]
        lea     eax, [ecx] + KGDT_DF_TSS
        mov     byte ptr [eax+5], 089h  ; 32bit, dpl=0, present, TSS32, not busy

;
; Clear Nested Task bit in EFLAGS
;
        pushfd
        and     [esp], not 04000h
        popfd

;
; Get address of the double-fault TSS which we are now running on.
;
        mov     eax, PCR[PcGdt]
        mov     ch, [eax+KGDT_DF_TSS+KgdtBaseHi]
        mov     cl, [eax+KGDT_DF_TSS+KgdtBaseMid]
        shl     ecx, 16
        mov     cx, [eax+KGDT_DF_TSS+KgdtBaseLow]
;
; Update the TSS pointer in the PCR to point to the double-fault TSS
; (which is what we're running on, or else we wouldn't be here)
;
        mov     eax, PCR[PcTss]
        mov     PCR[PcTss], ecx

;
; The original machine context is in original task's TSS
;
@@:     stdCall _KeBugCheck2,<UNEXPECTED_KERNEL_MODE_TRAP,8,eax,0,0,0>
        jmp     short @b        ; do not remove - for debugger

_KiTrap08       endp

        page ,132
        subttl "Coprocessor Segment Overrun"
;++
;
; Routine Description:
;
;    Handle Coprocessor Segment Overrun exception.
;
;    This exception only occurs on the 80286 (it's a trap 0d on the 80386),
;    so choke if we get here.
;
; Arguments:
;
;    At entry, the saved CS:EIP point to the aborted instruction.
;    No error code is provided with the error.
;
; Return value:
;
;    None
;
;--
        ASSUME  DS:NOTHING, SS:NOTHING, ES:NOTHING

        ENTER_DR_ASSIST kit9_a, kit9_t, NoAbiosAssist
align dword
        public  _KiTrap09
_KiTrap09       proc


        push    0                       ; push dummy error code
        ENTER_TRAP  kit9_a, kit9_t


        sti

        mov     eax, EXCEPTION_NPX_OVERRUN ; (eax) = exception type
        jmp     _KiSystemFatalException ; go terminate the system

_KiTrap09       endp

        page ,132
        subttl "Invalid TSS exception"
;++
;
; Routine Description:
;
;    Handle Invalid TSS fault.
;
;    This exception occurs if a segment exception other than the
;    not-present exception is detected when loading a selector
;    from the TSS.
;
;    If the exception is caused as a result of the kernel, device
;    drivers, or user incorrectly setting the NT bit in the flags
;    while the back-link selector in the TSS is invalid and the
;    IRET instruction being executed, in this case, this routine
;    will clear the NT bit in the trap frame and restart the iret
;    instruction.  For other causes of the fault, the user process
;    will be terminated if previous mode is user and the system
;    will stop if the exception occurs in kernel mode.  No exception
;    is raised.
;
; Arguments:
;
;    At entry, the saved CS:EIP point to the faulting instruction or
;    the first instruction of the task if the fault occurs as part of
;    a task switch.
;    Error code containing the segment causing the exception is provided.
;
;    NT386 does not use TSS for context switching.  So, the invalid tss
;    fault should NEVER occur.  If it does, something is wrong with
;    the kernel.  We simply shutdown the system.
;
; Return value:
;
;    None
;
;--
        ASSUME  DS:NOTHING, SS:NOTHING, ES:NOTHING

        ENTER_DR_ASSIST kita_a, kita_t, NoAbiosAssist
align dword
        public  _KiTrap0A
_KiTrap0A       proc


        ENTER_TRAP  kita_a, kita_t


        ; We can not enable interrupt here.  If we came here because DOS/WOW
        ; iret with NT bit set, it is possible that vdm will swap the trap frame
        ; with their monitor context.  If this happen before we check the NT bit
        ; we will bugcheck.

;       sti

;
;   If the trap occur in USER mode and is caused by iret instruction with
;   OF bit set, we simply clear the OF bit and restart the iret.
;   Any other causes of Invalid TSS cause system to be shutdown.
;
.errnz (EFLAGS_V86_MASK AND 0FF00FFFFh)
        test    byte ptr [ebp]+TsEFlags+2, EFLAGS_V86_MASK/010000h
        jnz     short Kt0a10

.errnz (MODE_MASK AND 0FFFFFF00h)
        test    byte ptr [ebp]+TsSegCs, MODE_MASK  ; Is previous mode = USER
        jz      short Kt0a20

Kt0a10:

.errnz (EFLAGS_OF_BIT AND 0FFFF00FFh)
        test    byte ptr [ebp]+TsEFlags+1, EFLAGS_OF_BIT/0100h
        sti
        jz      short Kt0a20

        and     dword ptr [ebp]+TsEFlags, NOT EFLAGS_OF_BIT
        jmp     _KiExceptionExit                ; restart the instruction

Kt0a20:
        mov     eax, EXCEPTION_INVALID_TSS ; (eax) = trap type
        jmp     _KiSystemFatalException ; go terminate the system

_KiTrap0A       endp

        page ,132
        subttl "Segment Not Present"
;++
;
; Routine Description:
;
;    Handle Segment Not Present fault.
;
;    This exception occurs when the processor finds the P bit 0
;    when accessing an otherwise valid descriptor that is not to
;    be loaded in SS register.
;
;    The only place the fault can occur (in kernel mode) is Trap/Exception
;    exit code.  Otherwise, this exception causes system to be terminated.
;    NT386 uses flat mode, the segment not present fault in Kernel mode
;    indicates system malfunction.
;
; Arguments:
;
;    At entry, the saved CS:EIP point to the faulting instruction or
;    the first instruction of the task if the fault occurs as part of
;    a task switch.
;    Error code containing the segment causing the exception is provided.
;
; Return value:
;
;    None
;
;--
        ASSUME  DS:NOTHING, SS:NOTHING, ES:NOTHING

        ENTER_DR_ASSIST kitb_a, kitb_t, NoAbiosAssist

align dword
        public  _KiTrap0B
_KiTrap0B       proc

; Set up machine state frame for displaying

        ENTER_TRAP      kitb_a, kitb_t

;
;   Did the trap occur in a VDM?
;

        test    byte ptr [ebp]+TsSegCs, MODE_MASK  ; Is previous mode = USER
        jz      Kt0b30

        cmp     word ptr [ebp]+TsSegCs,KGDT_R3_CODE OR RPL_MASK
        je      Kt0b20

Kt0b10:

; Check to see if this process is a vdm

        mov     ebx,PCR[PcPrcbData+PbCurrentThread]
        mov     ebx,[ebx]+ThApcState+AsProcess
        cmp     dword ptr [ebx]+PrVdmObjects,0 ; is this a vdm process?
        je      short Kt0b20

        ; Raise Irql to APC level before enabling interrupts
        RaiseIrql APC_LEVEL
        push    eax                             ; Save OldIrql
        sti
        stdCall   _Ki386VdmSegmentNotPresent
        test    eax, 0ffffh
        jz      short Kt0b15

        pop     ecx                                ; (TOS) = OldIrql
        LowerIrql ecx
        jmp     _KiExceptionExit

Kt0b15:
        pop     ecx                                ; (TOS) = OldIrql
        LowerIrql ecx

Kt0b20: sti
        mov     ebx, [ebp]+TsEip        ; (ebx)->faulting instruction
        mov     esi, [ebp]+TsErrCode
        and     esi, 0FFFFh
        or      esi, RPL_MASK
        mov     eax, STATUS_ACCESS_VIOLATION
        jmp     CommonDispatchException2Args0d ; Won't return

Kt0b30:
;
; Check if the exception is caused by pop SegmentRegister.
; We need to deal with the case that user puts a NP selector in fs, ds, cs
; or es through kernel debugger. (kernel will trap while popping segment
; registers in trap exit code.)
; Note: We assume if the faulted instruction is pop segreg.  It MUST be
; in trap exit code.  So there MUST be a valid trap frame for the trap exit.
;

        mov     eax, [ebp]+TsEip        ; (eax)->faulted Instruction
        mov     eax, [eax]              ; (eax)= opcode of faulted instruction
        mov     edx, [ebp]+TsEbp        ; (edx)->previous trap exit trapframe

        add     edx, TsSegDs            ; [edx] = prev trapframe + TsSegDs
        cmp     al, POP_DS              ; Is it pop ds instruction?
        jz      Kt0b90                  ; if z, yes, go Kt0b90

        add     edx, TsSegEs - TsSegDs  ; [edx] = prev trapframe + TsSegEs
        cmp     al, POP_ES              ; Is it pop es instruction?
        jz      Kt0b90                  ; if z, yes, go Kt0b90

        add     edx, TsSegFs - TsSegEs  ; [edx] = prev trapframe + TsSegFs
        cmp     ax, POP_FS              ; Is it pop fs (2-byte) instruction?
        jz      Kt0b90                  ; If z, yes, go Kt0b90

        add     edx, TsSegGs - TsSegFs  ; [edx] = prev trapframe + TsSegGs
        cmp     ax, POP_GS              ; Is it pop gs (2-byte) instruction?
        jz      Kt0b90                  ; If z, yes, go Kt0b90

;
; The exception is not caused by pop instruction.  We still need to check
; if it is caused by iret (to user mode.)  Because user may have a NP
; cs and we will trap at iret in trap exit code.
;

        cmp     al, IRET_OP             ; Is it an iret instruction?
        jne     Kt0b199                 ; if ne, not iret, go bugcheck

        lea     edx, [ebp]+TsHardwareEsp ; (edx)->trapped iret frame
.errnz (RPL_MASK AND 0FFFFFF00h)
        test    byte ptr [edx]+4, RPL_MASK ; Check CS of iret addr
                                        ; Does the iret have ring transition?
        jz      Kt0b199                 ; if z, it's a real fault
;
; Before enabling interrupts we need to save off any debug registers again
; and build a good trap frame.
;
        call    SaveDebugReg

;
; we trapped at iret while returning back to user mode. We will dispatch
; the exception back to user program.
;

        mov     ecx, (TsErrCode+4) / 4
        lea     edx, [ebp]+TsErrCode
Kt0b40:
        mov     eax, [edx]
        mov     [edx+12], eax
        sub     edx, 4
        loop    Kt0b40

        sti

        add     esp, 12                 ; adjust esp and ebp
        add     ebp, 12
        jmp     Kt0b10

;        mov     ebx, [ebp]+TsEip        ; (ebx)->faulting instruction
;        xor     edx, edx
;        mov     esi, [ebp]+TsErrCode
;        or      esi, RPL_MASK
;        and     esi, 0FFFFh
;        mov     ecx, 2
;        mov     eax, STATUS_ACCESS_VIOLATION
;        call    CommonDispatchException ; WOn't return

;
; The faulted instruction is pop seg
;

Kt0b90:
if DBG
        lea     eax, [ebp].TsHardwareEsp
        cmp     eax, edx
        je      @f
        int     3
@@:
endif
        mov     dword ptr [edx], 0      ; set the segment reg to 0 such that
                                        ; we will trap in user mode.
        jmp     Kt0d01                  ; continue in common code

Kt0b199:
        sti
        mov     eax, EXCEPTION_SEGMENT_NOT_PRESENT ; (eax) = exception type
        jmp     _KiSystemFatalException ; terminate the system

_KiTrap0B       endp

SaveDebugReg:
        push    ebx
        mov     ebx, dr7
;
; Check if any bits are set (ignoring the reserved bits).
;
        test    ebx, (NOT DR7_RESERVED_MASK)
        mov     [ebp]+TsDr7,ebx
        je      @f
        push    edi
        push    esi
        mov     ebx,dr0
        mov     esi,dr1
        mov     edi,dr2
        mov     [ebp]+TsDr0,ebx
        mov     [ebp]+TsDr1,esi
        mov     [ebp]+TsDr2,edi
        mov     ebx,dr3
        mov     esi,dr6
        mov     [ebp]+TsDr3,ebx
        xor     ebx, ebx
        mov     [ebp]+TsDr6,esi
        mov     dr7, ebx
        ;
        ; Load KernelDr* into processor
        ;
        mov     edi,dword ptr PCR[PcPrcb]
        mov     ebx,[edi].PbProcessorState.PsSpecialRegisters.SrKernelDr0
        mov     esi,[edi].PbProcessorState.PsSpecialRegisters.SrKernelDr1
        mov     dr0,ebx
        mov     dr1,esi
        mov     ebx,[edi].PbProcessorState.PsSpecialRegisters.SrKernelDr2
        mov     esi,[edi].PbProcessorState.PsSpecialRegisters.SrKernelDr3
        mov     dr2,ebx
        mov     dr3,esi
        mov     ebx,[edi].PbProcessorState.PsSpecialRegisters.SrKernelDr6
        mov     esi,[edi].PbProcessorState.PsSpecialRegisters.SrKernelDr7
        mov     dr6,ebx
        mov     dr7,esi
        pop    esi
        pop    edi
@@:     pop    ebx
        ret


        page ,132
        subttl "Stack segment fault"
;++
;
; Routine Description:
;
;    Handle Stack Segment fault.
;
;    This exception occurs when the processor detects certain problem
;    with the segment addressed by the SS segment register:
;
;    1. A limit violation in the segment addressed by the SS (error
;       code = 0)
;    2. A limit violation in the inner stack during an interlevel
;       call or interrupt (error code = selector for the inner stack)
;    3. If the descriptor to be loaded into SS has its present bit 0
;       (error code = selector for the not-present segment)
;
;    The exception should never occur in kernel mode except when we
;    perform the iret back to user mode.
;
; Arguments:
;
;    At entry, the saved CS:EIP point to the faulting instruction or
;    the first instruction of the task if the fault occurs as part of
;    a task switch.
;    Error code (whose value depends on detected condition) is provided.
;
; Return value:
;
;    None
;
;--
        ASSUME  DS:NOTHING, SS:NOTHING, ES:NOTHING

        ENTER_DR_ASSIST kitc_a, kitc_t, NoAbiosAssist
align dword
        public  _KiTrap0C
_KiTrap0C       proc



        ENTER_TRAP kitc_a, kitc_t

.errnz (EFLAGS_V86_MASK AND 0FF00FFFFh)

        test    byte ptr [ebp]+TsEFlags+2,EFLAGS_V86_MASK/010000h
        jnz     Kt0c20

.errnz (MODE_MASK AND 0FFFFFF00h)
        test    byte ptr [ebp]+TsSegCs, MODE_MASK  ; Is previous mode = USER
        jz      Kt0c10

        cmp     word ptr [ebp]+TsSegCs, KGDT_R3_CODE OR RPL_MASK
        jne     Kt0c20                  ; maybe in a vdm

Kt0c00: sti
        mov     ebx, [ebp]+TsEip        ; (ebx)->faulting instruction
        mov     edx, EXCEPT_LIMIT_ACCESS; assume it is limit violation
        mov     esi, [ebp]+TsHardwareEsp; (ecx) = User Stack pointer
        cmp     word ptr [ebp]+TsErrCode, 0 ; Is errorcode = 0?
        jz      short kt0c05            ; if z, yes, go dispatch exception

        mov     esi, [ebp]+TsErrCode    ; Otherwise, set SS segment value
                                        ;   to be the address causing the fault
        mov     edx, EXCEPT_UNKNOWN_ACCESS
        or      esi, RPL_MASK
        and     esi, 0FFFFh
kt0c05: mov     eax, STATUS_ACCESS_VIOLATION
        jmp     CommonDispatchException2Args ; Won't return

kt0c10:

;
; Check if the exception is caused by kernel mode iret to user code.
; We need to deal with the case that user puts a bogus value in ss
; through SetContext call. (kernel will trap while iret to user code
; in trap exit code.)
; Note: We assume if the faulted instruction is iret.  It MUST be in
; trap/exception exit code.  So there MUST be a valid trap frame for
; the trap exit.
;

        mov     eax, [ebp]+TsEip        ; (eax)->faulted Instruction

        ;
        ; Note the eip is captured above before enabling interrupts to
        ; prevent a setcontext from editing a bogus eip into our trapframe.
        ;


        movzx   eax, byte ptr[eax]

        ; (eax)= opcode of faulted instruction

;
; Check if the exception is caused by iret (to user mode.)
; Because user may have a NOT PRESENT ss and we will trap at iret
; in trap exit code. (If user put a bogus/not valid SS in trap frame, we
; will catch it in trap 0D handler.
;

        cmp     al, IRET_OP             ; Is it an iret instruction?
        jne     Kt0c15            ; if ne, not iret, go bugcheck

;
; Before enabling interrupts we need to save off any debug registers again
;
        call    SaveDebugReg

        lea     edx, [ebp]+TsHardwareEsp ; (edx)->trapped iret frame
        test    dword ptr [edx]+4, RPL_MASK ; Check CS of iret addr
                                        ; Does the iret have ring transition?
        jz      Kt0c15            ; if z, no SS involved, it's a real fault

;
; we trapped at iret while returning back to user mode. We will dispatch
; the exception back to user program.
;

        mov     ecx, (TsErrCode+4) / 4
        lea     edx, [ebp]+TsErrCode
@@:
        mov     eax, [edx]
        mov     [edx+12], eax
        sub     edx, 4
        loop    @b

        sti

        add     esp, 12                 ; adjust esp and ebp
        add     ebp, 12

        ;
        ; Now, we have user mode trap frame set up
        ;

        mov     ebx, [ebp]+TsEip        ; (ebx)->faulting instruction
        mov     edx, EXCEPT_LIMIT_ACCESS; assume it is limit violation
        mov     esi, [ebp]+TsHardwareEsp; (ecx) = User Stack pointer
        cmp     word ptr [ebp]+TsErrCode, 0 ; Is errorcode = 0?
        jz      short @f                ; if z, yes, go dispatch exception

        mov     esi, [ebp]+TsErrCode    ; Otherwise, set SS segment value
                                        ;   to be the address causing the fault
        and     esi, 0FFFFh
        mov     edx, EXCEPT_UNKNOWN_ACCESS
        or      esi, RPL_MASK
@@:
        mov     eax, STATUS_ACCESS_VIOLATION
        jmp     CommonDispatchException2Args ; Won't return

Kt0c15:
        sti
        mov     eax, EXCEPTION_STACK_FAULT      ; (eax) = trap type
        jmp     _KiSystemFatalException

Kt0c20:
; Check to see if this process is a vdm

        mov     ebx,PCR[PcPrcbData+PbCurrentThread]
        mov     ebx,[ebx]+ThApcState+AsProcess
        cmp     dword ptr [ebx]+PrVdmObjects,0 ; is this a vdm process?
        je      Kt0c00

Kt0c30:
.errnz (EFLAGS_V86_MASK AND 0FF00FFFFh)

        test    byte ptr [ebp]+TsEFlags+2,EFLAGS_V86_MASK/010000h
        jnz     short @f

        ;
        ; Raise Irql to APC level before enabling interrupt
        ;

        RaiseIrql APC_LEVEL
        sti
        mov     edi, eax                           ; [edi] = OldIrql

        call    VdmFixEspEbp

        push    eax
        mov     ecx, edi
        LowerIrql ecx
        cli
        pop     eax
        test    al, 0fh
        jz      short @f
        jmp     _KiExceptionExit

@@:
        stdCall _Ki386VdmReflectException_A,<0ch>
        test    al,0fh
        jz      Kt0c00
        jmp     _KiExceptionExit

_KiTrap0C       endp


        page ,132
        subttl "TrapC handler for NTVDM"
;++
;
; Routine Description:
;
;       Some protected dos games (ex, Duke3D) while running in a BIG code
;       segment with SMALL Stack segment will hit trap c with higher 16bit
;       of esp containing kernel esp higher 16 bit.  The question it should
;       not trapped because cpu should only look at sp.  So, here we try
;       to deal with this problem.
;
; Arguments:
;
;    EBP - Trap frame
;
; Return value:
;
;    None
;
;--
        ASSUME  DS:NOTHING, SS:NOTHING, ES:NOTHING

        public  VdmFixEspEbp
VdmFixEspEbp  proc

        ;
        ; First check if user SS is small.  If it is big, do nothing
        ;

        mov     eax, [ebp].TsHardwareSegSs
        lar     eax, eax                        ; [eax]= ss access right
        jnz     Vth_err

        test    eax, 400000h                    ; is SS a big segment?
        jnz     Vth_err                         ; nz, yes, do nothing

        xor     edx, edx                        ; [edx] = 0 no need to update tframe
        mov     eax, esp
        and     eax, 0ffff0000h                 ; [eax]=kernel esp higher 16bit
        mov     ecx, [ebp].TsHardwareEsp
        and     ecx, 0ffff0000h                 ; [ecx]=user esp higher 16bit
        cmp     ecx, eax                        ; are they the same
        jnz     short @f                        ; if nz, no, go check ebp

        and     dword ptr [ebp].TsHardwareEsp, 0ffffH ; zero higher 16 bit of user esp
        mov     edx, 1                          ; [edx]=1 indicates we need to update trap frame
@@:
        mov     ecx, [ebp].TsEbp
        and     ecx, 0ffff0000h                 ; [ecx]=user ebp higher 16bit
        cmp     ecx, eax                        ; are they the same as kernel's
        jnz     short @f                        ; if nz, no, go check if we need to update tframe

        and     dword ptr [ebp].TsEbp, 0ffffH   ; zero higher 16bit of user ebp
        mov     edx, 1                          ; update kernel trap frame
@@:     cmp     edx, 1                          ; do we need to update trap frame?
        jnz     short Vth_err                   ; if nz, no, do nothing

Vth_ok:

;
; copy user's cs:eip and ss:esp to vdmtib, note this needs to be done
; with proper probing and exception handling.
;

        mov     ebx, PCR[PcTeb]

        mov     eax, [ebp].TsSegCs
        mov     ecx, [ebp].TsEip
        mov     edx, [ebp].TsEbx

        stdCall _VdmTibPass1, <eax,ecx,edx>

        ; eax now points at the VDM tib (or NULL if anything went wrong)

        ;
        ; Move the vdmtib to the trap frame such that we return back to ntvdm
        ; [ebx]->vdmtib
        ;

        mov     [ebp].TsEbx, eax

;
; dispatch control to ntvdm trapc handler which will load ss:esp
; and jump to the trapped cs:eip
;

        mov     eax,PCR[PcPrcbData+PbCurrentThread]
        mov     eax,[eax]+ThApcState+AsProcess
        mov     eax,[eax]+PrVdmTrapcHandler

        mov     dword ptr [ebp].TsSegCs, KGDT_R3_CODE OR RPL_MASK
        mov     dword ptr [ebp].TsEip, eax

        mov     eax, 1
        ret

Vth_err:
        xor     eax, eax
        ret
VdmFixEspEbp endp


        page ,132
        subttl "General Protection Fault"
;++
;
; Routine Description:
;
;    Handle General protection fault.
;
;    First, check to see if the fault occured in kernel mode with
;    incorrect selector values.  If so, this is a lazy segment load.
;    Correct the selector values and restart the instruction.  Otherwise,
;    parse out various kinds of faults and report as exceptions.
;
;    All protection violations that do not cause another exception
;    cause a general exception.  If the exception indicates a violation
;    of the protection model by an application program executing a
;    privileged instruction or I/O reference, a PRIVILEGED INSTRUCTION
;    exception will be raised.  All other causes of general protection
;    fault cause a ACCESS VIOLATION exception to be raised.
;
;    If previous mode = Kernel;
;        the system will be terminated  (assuming not lazy segment load)
;    Else previous mode = USER
;        the process will be terminated if the exception was not caused
;        by privileged instruction.
;
; Arguments:
;
;    At entry, the saved CS:EIP point to the faulting instruction or
;    the first instruction of the task if the fault occurs as part of
;    a task switch.
;    Error code (whose value depends on detected condition) is provided.
;
; Return value:
;
;    None
;
;--
        ASSUME  DS:FLAT, SS:NOTHING, ES:FLAT

;
;   Error and exception blocks for KiTrap0d
;

Ktd_ExceptionHandler proc

;
; WARNING: Here we directly unlink the exception handler from the
; exception registration chain.  NO unwind is performed.
;

        mov     esp, [esp+8]            ; (esp)-> ExceptionList
        pop     PCR[PcExceptionList]
        add     esp, 4                  ; pop out except handler
        pop     ebp                     ; (ebp)-> trap frame

        test    dword ptr [ebp].TsSegCs, MODE_MASK ; if premode=kernel
        jnz     Kt0d103                 ; nz, prevmode=user, go return

; raise bugcheck if prevmode=kernel
        stdCall   _KeBugCheck2, <KMODE_EXCEPTION_NOT_HANDLED,0,0,0,0,ebp>
Ktd_ExceptionHandler endp


        ENTER_DR_ASSIST kitd_a, kitd_t, NoAbiosAssist,, kitd_v
align dword

        public  _KiTrap0D
_KiTrap0D       proc


        ;
        ; Did the trap occur in a VDM in V86 mode? Trap0d is not critical from
        ; performance point of view to native NT, but it's super critical to
        ; VDMs. So here we are doing every thing to make v86 mode most
        ; efficient.

.errnz (EFLAGS_V86_MASK AND 0FF00FFFFh)
        test    byte ptr [esp]+0ch+2,EFLAGS_V86_MASK/010000h
        jz      Ktdi

KtdV86Slow:
        ENTER_TRAPV86 kitd_a, kitd_v

KtdV86Slow2:
        mov     ecx,PCR[PcPrcbData+PbCurrentThread]
        mov     ecx,[ecx]+ThApcState+AsProcess
        cmp     dword ptr [ecx]+PrVdmObjects,0 ; is this a vdm process?
        jnz     short @f                        ; if nz, yes

        sti                                     ; else, enable ints
        jmp     Kt0d105                         ; and dispatch exception

@@:
        ; Raise Irql to APC level, before enabling interrupts
        RaiseIrql APC_LEVEL
        push    eax                             ; Save OldIrql
        sti

        stdCall   _VdmDispatchOpcodeV86_try,<ebp>
KtdV86Exit:
        test    al,0FFh
        jnz     short Ktdi2

        stdCall   _Ki386VdmReflectException,<0dh>
        test    al,0fh
        jnz     short Ktdi2
        pop     ecx                                ; (TOS) = OldIrql
        LowerIrql ecx
        jmp     Kt0d105
Ktdi2:
        pop     ecx                                ; (TOS) = OldIrql
        LowerIrql ecx
        cli
.errnz (EFLAGS_V86_MASK AND 0FF00FFFFh)
        test    byte ptr [ebp]+TsEFlags+2,EFLAGS_V86_MASK/010000h
        jz      Ktdi3

        EXIT_TRAPV86
        ;
        ; EXIT_TRAPv86 does not exit if a user mode apc has switched
        ; the context from V86 mode to flat mode (VDM monitor context)
        ;

Ktdi3:
        jmp     _KiExceptionExit

Ktdi:
        ENTER_TRAP kitd_a, kitd_t

;
; DO NOT TURN INTERRUPTS ON!  If we're doing a lazy segment load,
; could be in an ISR or other code that needs ints off!
;

;
; Is this just a lazy segment load?  First make sure the exception occurred
; in kernel mode.
;

        test    dword ptr [ebp]+TsSegCs,MODE_MASK
        jnz     Kt0d02                  ; not kernel mode, go process normally

;
; Before handling kernel mode trap0d, we need to do some checks to make
; sure the kernel mode code is the one to blame.
;

if FAST_BOP
        cmp     dword ptr PCR[PcVdmAlert], 0
        jne     Kt0eVdmAlert
endif

;
; Check if the exception is caused by the handler trying to examine offending
; instruction.  If yes, we raise exception to user mode program.  This occurs
; when user cs is bogus.  Note if cs is valid and eip is bogus, the exception
; will be caught by page fault and out Ktd_ExceptionHandler will be invoked.
; Both cases, the exception is dispatched back to user mode.
;

        mov     eax, [ebp]+TsEip
        cmp     eax, offset FLAT:Kt0d03
        jbe     short Kt0d000
        cmp     eax, offset FLAT:Kt0d60
        jae     short Kt0d000

        sti
        mov     ebp, [ebp]+TsEbp        ; remove the current trap frame
        mov     esp, ebp                ; set ebp, esp to previous trap frame
        jmp     Kt0d105                 ; and dispatch exception to user mode.

;
; Check if the exception is caused by pop SegmentRegister.
; We need to deal with the case that user puts a bogus value in fs, ds,
; or es through kernel debugger. (kernel will trap while popping segment
; registers in trap exit code.)
; Note: We assume if the faulted instruction is pop segreg.  It MUST be
; in trap exit code.  So there MUST be a valid trap frame for the trap exit.
;

Kt0d000:
        mov     eax, [ebp]+TsEip        ; (eax)->faulted Instruction
        mov     eax, [eax]              ; (eax)= opcode of faulted instruction
        mov     edx, [ebp]+TsEbp        ; (edx)->previous trap exit trapframe

        add     edx, TsSegDs            ; [edx] = prev trapframe + TsSegDs
        cmp     al, POP_DS              ; Is it pop ds instruction?
        jz      Kt0d005                 ; if z, yes, go Kt0d005

        add     edx, TsSegEs - TsSegDs  ; [edx] = prev trapframe + TsSegEs
        cmp     al, POP_ES              ; Is it pop es instruction?
        jz      Kt0d005                 ; if z, yes, go Kt0d005

        add     edx, TsSegFs - TsSegEs  ; [edx] = prev trapframe + TsSegFs
        cmp     ax, POP_FS              ; Is it pop fs (2-byte) instruction?
        jz      Kt0d005                 ; If z, yes, go Kt0d005

        add     edx, TsSegGs - TsSegFs  ; [edx] = prev trapframe + TsSegGs
        cmp     ax, POP_GS              ; Is it pop gs (2-byte) instruction?
        jz      Kt0d005                 ; If z, yes, go Kt0d005

;
; The exception is not caused by pop instruction.  We still need to check
; if it is caused by iret (to user mode.)  Because user may have a bogus
; ss and we will trap at iret in trap exit code.
;

        cmp     al, IRET_OP             ; Is it an iret instruction?
        jne     Kt0d002                 ; if ne, not iret, go check lazy load

        lea     edx, [ebp]+TsHardwareEsp ; (edx)->trapped iret frame
        mov     ax, [ebp]+TsErrCode     ; (ax) = Error Code
        and     ax, NOT RPL_MASK        ; No need to do this ...
        mov     cx, word ptr [edx]+4    ; [cx] = cs selector
        and     cx, NOT RPL_MASK
        cmp     cx, ax                  ; is it faulted in CS?
        jne     short Kt0d0008          ; No

;
; Check if this is the code which we use to return to Ki386CallBios
; (see biosa.asm):
;    cs should be KGDT_R0_CODE OR RPL_MASK
;    eip should be Ki386BiosCallReturnAddress
;    esi should be the esp of function Ki386SetUpAndExitToV86Code
; (edx) -> trapped iret frame
;

        mov     eax, OFFSET FLAT:Ki386BiosCallReturnAddress
        cmp     eax, [edx]              ; [edx]= trapped eip
                                        ; Is eip what we're expecting?
        jne     short Kt0d0005          ; No, continue

        mov     eax, [edx]+4            ; (eax) = trapped cs
        cmp     ax, KGDT_R0_CODE OR RPL_MASK ; Is Cs what we're exptecting?
        jne     short Kt0d0005          ; No

        jmp     Ki386BiosCallReturnAddress ; with interrupts off

Kt0d0005:
;
; Since the CS is bogus, we cannot tell if we are going back to user mode...
;

        mov     ebx,PCR[PcPrcbData+PbCurrentThread] ; if previous mode is
        test    byte ptr [ebx]+ThPreviousMode, 0ffh ;   kernel, we bugcheck
        jz      Kt0d02

        or      word ptr [edx]+4, RPL_MASK
Kt0d0008:
        test    dword ptr [edx]+4, RPL_MASK ; Check CS of iret addr
                                        ; Does the iret have ring transition?
        jz      Kt0d02                  ; if z, no SS involved, it's a real fault
;
; Before enabling interrupts we need to save off any debug registers again
;
        call    SaveDebugReg

;
; we trapped at iret while returning back to user mode. We will dispatch
; the exception back to user program.
;

        mov     ecx, (TsErrCode+4)/4
        lea     edx, [ebp]+TsErrCode
Kt0d001:
        mov     eax, [edx]
        mov     [edx+12], eax
        sub     edx, 4
        loop    Kt0d001

        sti

        add     esp, 12                 ; adjust esp and ebp
        add     ebp, 12
        mov     ebx, [ebp]+TsEip        ; (ebx)->faulting instruction
        mov     esi, [ebp]+TsErrCode
        and     esi, 0FFFFh
        mov     eax, STATUS_ACCESS_VIOLATION
        jmp     CommonDispatchException2Args0d ; Won't return

;
; Kernel mode, first opcode byte is 0f, check for rdmsr or wrmsr instruction
;

Kt0d001a:
        shr     eax, 8
        cmp     al, 30h
        je      short Kt0d001b
        cmp     al, 32h
        jne     short Kt0d002a


Kt0d001b:

.errnz(EFLAGS_INTERRUPT_MASK AND 0FFFF00FFh)
        test    [ebp+1]+TsEFlags, EFLAGS_INTERRUPT_MASK/0100h   ; faulted with
        jz      short @f                                ; interrupts disabled?
        sti                                             ; interrupts were enabled so reenable
@@:     mov     ebx, [ebp]+TsEip        ; (ebx)->faulting instruction
        mov     eax, STATUS_ACCESS_VIOLATION
        jmp     CommonDispatchException0Args ; Won't return

;
; The Exception is not caused by pop instruction.  Check to see
; if the instruction is a rdmsr or wrmsr
;
Kt0d002:
        cmp     al, 0fh
        je      short Kt0d001a

;
; We now check if DS and ES contain correct value.  If not, this is lazy
; segment load, we simply set them to valid selector.
;

Kt0d002a:
        cmp     word ptr [ebp]+TsSegDs, KGDT_R3_DATA OR RPL_MASK
        je      short Kt0d003

        mov     dword ptr [ebp]+TsSegDs, KGDT_R3_DATA OR RPL_MASK
        jmp     short Kt0d01

Kt0d003:
        cmp     word ptr [ebp]+TsSegEs, KGDT_R3_DATA OR RPL_MASK
        je      Kt0d02                  ; Real fault, go process it

        mov     dword ptr [ebp]+TsSegEs, KGDT_R3_DATA OR RPL_MASK
        jmp     short Kt0d01

;
; The faulted instruction is pop seg
;

Kt0d005:
if DBG
        lea     eax, [ebp].TsHardwareEsp
        cmp     edx, eax
        je      @f
        int     3
@@:
endif
        xor     eax, eax
        mov     dword ptr [edx], eax    ; set the segment reg to 0 such that
                                        ; we will trap in user mode.
Kt0d01:

        EXIT_ALL NoRestoreSegs,,NoPreviousMode  ; RETURN

;
;   Caller is not kernel mode, or DS and ES are OK.  Therefore this
;   is a real fault rather than a lazy segment load.  Process as such.
;   Since this is not a lazy segment load is now safe to turn interrupts on.
;
Kt0d02: mov     eax, EXCEPTION_GP_FAULT ; (eax) = trap type
        test    byte ptr [ebp]+TsSegCs, MODE_MASK ; Is prevmode=User?
        jz      _KiSystemFatalException ; If z, prevmode=kernel, stop...


;       preload pointer to process
        mov     ebx,PCR[PcPrcbData+PbCurrentThread]
        mov     ebx,[ebx]+ThApcState+AsProcess

;       flat or protect mode ?
        cmp     word ptr [ebp]+TsSegCs, KGDT_R3_CODE OR RPL_MASK
        jz      kt0d0201

;
; if vdm running in protected mode, handle instruction
;
        cmp     dword ptr [ebx]+PrVdmObjects,0 ; is this a vdm process?
        jne     Kt0d110

        sti
        cmp     word ptr [ebp]+TsErrCode, 0 ; if errcode<>0, raise access
                                        ; violation exception
        jnz     Kt0d105                 ; if nz, raise access violation
        jmp     short Kt0d03


;
; if vdm running in flat mode, handle pop es,fs,gs by setting to Zero
;
kt0d0202:
        add     dword ptr [ebp].TsEip, 1
kt0d02021:
        mov     dword ptr [edx], 0
        add     dword ptr [ebp].TsEip, 1
        add     dword ptr [ebp].TsHardwareEsp, 4
        jmp     _KiExceptionExit

kt0d0201:
        cmp     dword ptr [ebx]+PrVdmObjects,0 ; is this a vdm process?
        je      short Kt0d03

        sti
        mov     eax, [ebp]+TsEip        ; (eax)->faulted Instruction
        stdCall _VdmFetchBop4, <eax>    ; (eax)= opcode of faulted instruction
        mov     edx, ebp                ; (edx)-> trap frame

        add     edx, TsSegEs            ; [edx] = prev trapframe + TsSegEs
        cmp     al, POP_ES              ; Is it pop es instruction?
        jz      short Kt0d02021

@@:
        add     edx, TsSegFs - TsSegEs  ; [edx] = prev trapframe + TsSegFs
        cmp     ax, POP_FS              ; Is it pop fs (2-byte) instruction?
        jz      short kt0d0202

        add     edx, TsSegGs - TsSegFs  ; [edx] = prev trapframe + TsSegGs
        cmp     ax, POP_GS              ; Is it pop gs (2-byte) instruction?
        jz      short kt0d0202

;
; we need to determine if the trap0d was caused by privileged instruction.
; First, we need to skip all the instruction prefix bytes
;

Kt0d03: sti
;
; First we need to set up an exception handler to handle the case that
; we fault while reading user mode instruction.
;

        push    ebp                     ; pass trapframe to handler
        push    offset FLAT:Ktd_ExceptionHandler
                                        ; set up exception registration record
        push    PCR[PcExceptionList]
        mov     PCR[PcExceptionList], esp

        mov     esi, [ebp]+TsEip        ; (esi) -> flat address of faulting instruction
        cmp	esi, _MmUserProbeAddress ; Probe captured EIP
        jb      short @f
        mov     esi, _MmUserProbeAddress ; Use address of the GAP to force exception
@@:     mov     ecx, MAX_INSTRUCTION_LENGTH

@@:
        push    ecx                     ; save ecx for loop count
        lods    byte ptr [esi]          ; (al)= instruction byte
        mov     ecx, PREFIX_REPEAT_COUNT
        mov     edi, offset FLAT:PrefixTable ; (EDI)->prefix table
        repnz   scasb                   ; search for matching (al)
        pop     ecx                     ; restore loop count
        jnz     short Kt0d10            ; (al) not a prefix byte, go kt0d10
        loop    short @b                ; go check for prefix byte again
        pop     PCR[PcExceptionList]
        add     esp, 8                  ; clear stack
        jmp     Kt0635                  ; exceed max instruction length,
                                        ; raise ILLEGALINSTRUCTION exception

;
; (al) = first opcode which is NOT prefix byte
; (ds:esi)= points to the first opcode which is not prefix byte + 1
; We need to check if it is one of the privileged instructions
;

Kt0d10: cmp     al, MI_HLT              ; Is it a HLT instruction?
        je      Kt0d80                  ; if e, yes, go kt0d80

        cmp     al, MI_TWO_BYTE         ; Is it a two-byte instruction?
        jne     short Kt0d50            ; if ne, no, go check for IO inst.

        lods    byte ptr [esi]          ; (al)= next instruction byte
        cmp     al, MI_LTR_LLDT         ; Is it a LTR or LLDT ?
        jne     short Kt0d20            ; if ne, no, go kt0d20

        lods    byte ptr [esi]          ; (al)= ModRM byte of instruction
        and     al, MI_MODRM_MASK       ; (al)= bit 3-5 of ModRM byte
        cmp     al, MI_LLDT_MASK        ; Is it a LLDT instruction?
        je      Kt0d80                  ; if e, yes, go Kt0d80

        cmp     al, MI_LTR_MASK         ; Is it a LTR instruction?
        je      Kt0d80                  ; if e, yes, go Kt0d80

        jmp     Kt0d100                 ; if ne, go raise access violation

Kt0d20: cmp     al, MI_LGDT_LIDT_LMSW   ; Is it one of these instructions?
        jne     short Kt0d30            ; if ne, no, go check special mov inst.

        lods    byte ptr [esi]          ; (al)= ModRM byte of instruction
        and     al, MI_MODRM_MASK       ; (al)= bit 3-5 of ModRM byte
        cmp     al, MI_LGDT_MASK        ; Is it a LGDT instruction?
        je      Kt0d80                  ; if e, yes, go Kt0d80

        cmp     al, MI_LIDT_MASK        ; Is it a LIDT instruction?
        je      Kt0d80                  ; if e, yes, go Kt0d80

        cmp     al, MI_LMSW_MASK        ; Is it a LMSW instruction?
        je      Kt0d80                  ; if e, yes, go Kt0d80

        jmp     Kt0d100                 ; else, raise access violation except

Kt0d30:

;
; Check some individual privileged instructions
;
        cmp     al, MI_INVD
        je      kt0d80
        cmp     al, MI_WBINVD
        je      kt0d80
        cmp     al, MI_SYSEXIT
        je      short kt0d80
        cmp     al, MI_MOV_TO_TR        ;                 mov tx, rx
        je      short kt0d80
        cmp     al, MI_CLTS
        je      short kt0d80

;
; Test ordering of these compares
;
if MI_MOV_FROM_CR GT MI_WRMSR
.err
endif
;
; Test for the mov instructions as a block with a single unused gap
;
.errnz (MI_MOV_FROM_CR + 1 - MI_MOV_FROM_DR)
.errnz (MI_MOV_FROM_DR + 1 - MI_MOV_TO_CR)
.errnz (MI_MOV_TO_CR + 1 - MI_MOV_TO_DR)
.errnz (MI_MOV_TO_DR + 1 - MI_MOV_FROM_TR)

        cmp     al, MI_MOV_FROM_CR      ; See if we are a mov rx, cx
        jb      Kt0d100                 ;                 mov cx, rx
        cmp     al, MI_MOV_FROM_TR      ;                 mov rx, dx
        jbe     short kt0d80            ;                 mov dx, rx
                                        ;                 mov rx, tx
;
; Test the counter instructions as a block
;
.errnz (MI_WRMSR + 1 - MI_RDTSC)
.errnz (MI_RDTSC + 1 - MI_RDMSR)
.errnz (MI_RDMSR + 1 - MI_RDPMC)

        cmp     al, MI_WRMSR
        jb      Kt0d100
        cmp     al, MI_RDPMC
        jbe     short kt0d80
        jmp     Kt0d100                 ; else, no, raise access violation

;
; Now, we need to check if the trap 0d was caused by IO privileged instruct.
; (al) = first opcode which is NOT prefix byte
; Also note, if we come here, the instruction has 1 byte opcode (still need to
; check REP case.)
;

Kt0d50: mov     ebx, [ebp]+TsEflags     ; (ebx) = client's eflags
        and     ebx, IOPL_MASK          ;
        shr     ebx, IOPL_SHIFT_COUNT   ; (ebx) = client's IOPL
        mov     ecx, [ebp]+TsSegCs
        and     ecx, RPL_MASK           ; RPL_MASK NOT MODE_MASK!!!
                                        ; (ecx) = CPL, 1/2 of computation of
                                        ; whether IOPL applies.

        cmp     ebx,ecx                 ; compare IOPL with CPL of caller
        jge     short Kt0d100           ; if ge, not IO privileged,
                                        ;        go raise access violation

Kt0d60: cmp     al, CLI_OP              ; Is it a CLI instruction
        je      short Kt0d80            ; if e, yes. Report it.

        cmp     al, STI_OP              ; Is it a STI?
        je      short Kt0d80            ; if e, yes, report it.

        mov     ecx, IO_INSTRUCTION_TABLE_LENGTH
        mov     edi, offset FLAT:IOInstructionTable
        repnz   scasb                   ; Is it a IO instruction?
        jnz     short Kt0d100           ; if nz, not io instrct.

;
; We know the instr is an IO instr without IOPL.  But, this doesn't mean
; this is a privileged instruction exception.  We need to make sure the
; IO port access is not granted in the bit map
;


        mov     edi, PCR[PcSelfPcr]       ; (edi)->Pcr
        mov     esi, [edi]+PcGdt        ; (esi)->Gdt addr
        add     esi, KGDT_TSS
        movzx   ebx, word ptr [esi]     ; (ebx) = Tss limit

        mov     edx, [ebp].TsEdx        ; [edx] = port addr
        mov     ecx, edx
        and     ecx, 07                 ; [ecx] = Bit position
        shr     edx, 3                  ; [edx] = offset to the IoMap

        mov     edi, [edi]+PcTss        ; (edi)->TSS
        movzx   eax, word ptr [edi + TssIoMapBase] ; [eax] = Iomap offset
        add     edx, eax
        cmp     edx, ebx                ; is the offset addr beyond tss limit?
        ja      short Kt0d80            ; yes, no I/O priv.

        add     edi, edx                ; (edi)-> byte corresponds to the port addr
        mov     edx, 1
        shl     edx, cl
        test    dword ptr [edi], edx    ; Is the bit of the port disabled?
        jz      short Kt0d100           ; if z, no, then it is access violation

Kt0d80:
        pop     PCR[PcExceptionList]
        add     esp, 8                  ; clear stack
        mov     ebx, [ebp]+TsEip        ; (ebx)->faulting instruction
        mov     eax, STATUS_PRIVILEGED_INSTRUCTION
        jmp     CommonDispatchException0Args ; Won't return

;
;       NOTE    All the GP fault (except the ones we can
;               easily detect now) will cause access violation exception
;               AND, all the access violation will be raised with additional
;               parameters set to "read" and "virtual address which caused
;               the violation = unknown (-1)"
;

Kt0d100:
        pop     PCR[PcExceptionList]
        add     esp, 8                  ; clear stack
Kt0d103:
Kt0d105:
        mov     ebx, [ebp]+TsEip        ; (ebx)->faulting instruction
        mov     esi, -1
        mov     eax, STATUS_ACCESS_VIOLATION
        jmp     CommonDispatchException2Args0d ; Won't return

Kt0d110:
        ; Raise Irql to APC level, before enabling interrupts
        RaiseIrql APC_LEVEL
        sti
	push    eax                             ; Save OldIrql

        stdCall   _VdmDispatchOpcode_try <ebp>
        or	al,al
        jnz     short Kt0d120

        stdCall   _Ki386VdmReflectException,<0dh>
        test    al,0fh
        jnz     short Kt0d120
        pop     ecx                             ; (TOS) = OldIrql
        LowerIrql ecx
        jmp     short Kt0d105

Kt0d120:
        pop     ecx                                ; (TOS) = OldIrql
        LowerIrql ecx
        jmp     _KiExceptionExit

_KiTrap0D       endp


;
; The following code it to fix a bug in the Pentium Processor dealing with
; Invalid Opcodes.
;


PentiumTest:                            ; Is this access to the write protect
                                        ; IDT page?
        test    [ebp]+TsErrCode, 04h    ; Do not allow user mode access to trap 6
        jne     NoPentiumFix            ; vector. Let page fault code deal with it
        mov     eax, PCR[PcIDT]         ; Get address of trap 6 IDT entry
        add     eax, (6 * 8)
        cmp     eax, edi                ; Is that the faulting address?
        jne     NoPentiumFix            ; No.  Back to page fault code

                                        ; Yes. We have accessed the write
                                        ; protect page of the IDT
        mov     [ebp]+TsErrCode, 0      ; Overwrite error code
.errnz (EFLAGS_V86_MASK AND 0FF00FFFFh)
        test    byte ptr [ebp]+TsEFlags+2, EFLAGS_V86_MASK/010000h ; Was it a VM?
        jne     Kt06VMpf                ; Yes.  Go to VM part of trap 6
        jmp     Kt06pf                  ; Not from a VM


        page ,132
        subttl "Page fault processing"
;++
;
; Routine Description:
;
;    Handle page fault.
;
;    The page fault occurs if paging is enabled and any one of the
;    conditions is true:
;
;    1. page not present
;    2. the faulting procedure does not have sufficient privilege to
;       access the indicated page.
;
;    For case 1, the referenced page will be loaded to memory and
;    execution continues.
;    For case 2, registered exception handler will be invoked with
;    appropriate error code (in most cases STATUS_ACCESS_VIOLATION)
;
;    N.B. It is assumed that no page fault is allowed during task
;    switches.
;
;    N.B. INTERRUPTS MUST REMAIN OFF UNTIL AFTER CR2 IS CAPTURED.
;
; Arguments:
;
;    Error code left on stack.
;    CR2 contains faulting address.
;    Interrupts are turned off at entry by use of an interrupt gate.
;
; Return value:
;
;    None
;
;--

        ASSUME  DS:NOTHING, SS:NOTHING, ES:NOTHING
        ENTER_DR_ASSIST kite_a, kite_t, NoAbiosAssist
align dword
        public  _KiTrap0E
_KiTrap0E       proc

        ENTER_TRAP      kite_a, kite_t


if FAST_BOP
        cmp     dword ptr PCR[PcVdmAlert], 0
        jne     Kt0eVdmAlert
endif

        MODIFY_BASE_TRAP_FRAME

        mov     edi,cr2
;
; Now that everything is in a sane state check for rest of the Pentium
; Processor bug work around for illegal operands
;

        cmp     _KiI386PentiumLockErrataPresent, 0
        jne     PentiumTest              ; Check for special problems

NoPentiumFix:                            ; No.  Skip it
        sti


        test    [ebp]+TsEFlags, EFLAGS_INTERRUPT_MASK   ; faulted with
        jz      Kt0e12b                 ; interrupts disabled?

Kt0e01:

;
; call _MmAccessFault to page in the not present page.  If the cause
; of the fault is 2, _MmAccessFault will return appropriate error code
;

        push    ebp                     ; set trap frame address
        mov     eax, [ebp]+TsSegCs      ; set previous mode
        and     eax, MODE_MASK          ;
        push    eax                     ;
        push    edi                     ; set virtual address of page fault
        mov     eax, [ebp]+TsErrCode    ; set load/store indicator
        shr     eax, 1                  ;
        and     eax, _KeErrorMask       ;
        push    eax                     ;

        call    _MmAccessFault@16

        test    eax, eax                ; check if page fault resolved
        jl      short Kt0e05            ; if l, page fault not resolved
        cmp     _PsWatchEnabled, 0      ; check if working set watch enabled
        je      short @f                ; if e, working set watch not enabled
        mov     ebx, [ebp]+TsEip        ; set exception address
        stdCall _PsWatchWorkingSet, <eax, ebx, edi> ; record working set information
@@:     cmp     _KdpOweBreakpoint, 0    ; check for owed  breakpoints
        je      _KiExceptionExit        ; if e, no owed breakpoints
        stdCall _KdSetOwedBreakpoints   ; notify the debugger
        jmp     _KiExceptionExit        ; join common code

;
; Memory management could not resolve the page fault.
;
; Check to determine if the fault occured in the interlocked pop entry slist
; code. There is a case where a fault may occur in this code when the right
; set of circumstances occurs. The fault can be ignored by simply skipping
; the faulting instruction.
;

Kt0e05: mov     ecx, offset FLAT:ExpInterlockedPopEntrySListFault ; get pop code address
        cmp     [ebp].TsEip, ecx        ; check if fault at pop code address
        je      Kt0e10a                 ; if eq, skip faulting instruction

;
; Check to determine if the page fault occured in the user mode interlocked
; pop entry SLIST code.
;

        mov     ecx, _KeUserPopEntrySListFault
        cmp     [ebp].TsEip, ecx        ; check if fault at USER pop code address
        je      Kt0e10b

;
;   Did the fault occur in KiSystemService while copying arguments from
;   user stack to kernel stack?
;

Kt0e05a:mov     ecx, offset FLAT:KiSystemServiceCopyArguments
        cmp     [ebp].TsEip, ecx
        je      short Kt0e06

        mov     ecx, offset FLAT:KiSystemServiceAccessTeb
        cmp     [ebp].TsEip, ecx
        jne     short Kt0e07

        mov     ecx, [ebp].TsEbp        ; (eax)->TrapFrame of SysService
        test    [ecx].TsSegCs, MODE_MASK
        jz      short Kt0e07            ; caller of SysService is k mode, we
                                        ; will let it bugcheck.
        mov     [ebp].TsEip, offset FLAT:kss61
        mov     eax, STATUS_ACCESS_VIOLATION
        mov     [ebp].TsEax, eax
        jmp     _KiExceptionExit

Kt0e06:
        mov     ecx, [ebp].TsEbp        ; (eax)->TrapFrame of SysService
        test    [ecx].TsSegCs, MODE_MASK
        jz      short Kt0e07            ; caller of SysService is k mode, we
                                        ; will let it bugcheck.
        mov     [ebp].TsEip, offset FLAT:kss60
        mov     eax, STATUS_ACCESS_VIOLATION
        mov     [ebp].TsEax, eax
        jmp     _KiExceptionExit
Kt0e07:

        mov     ecx, [ebp]+TsErrCode    ; (ecx) = error code
        shr     ecx, 1                  ; isolate read/write bit
        and     ecx, _KeErrorMask       ;
;
;   Did the fault occur in a VDM?
;

.errnz (EFLAGS_V86_MASK AND 0FF00FFFFh)
        test    byte ptr [ebp]+TsEFlags+2,EFLAGS_V86_MASK/010000h
        jnz     Kt0e7

;
;   Did the fault occur in a VDM while running in protected mode?
;

        mov     esi,PCR[PcPrcbData+PbCurrentThread]
        mov     esi,[esi]+ThApcState+AsProcess
        cmp     dword ptr [esi]+PrVdmObjects,0 ; is this a vdm process?
        je      short Kt0e9             ; z -> not vdm

.errnz (MODE_MASK AND 0FFFFFF00h)
        test    byte ptr [ebp]+TsSegCs, MODE_MASK
        jz      short Kt0e9             ; kernel mode, just dispatch exception.

        cmp     word ptr [ebp]+TsSegCs, KGDT_R3_CODE OR RPL_MASK
        jz      short kt0e9             ; z -> not vdm

Kt0e7:  mov     esi, eax
        stdCall _VdmDispatchPageFault, <ebp,ecx,edi>
        test    al,0fh                  ; returns TRUE, if success
        jnz     Kt0e11                  ; Exit,No need to call the debugger
        mov     eax, esi

Kt0e9:
; Set up exception record and arguments and call _KiDispatchException
        mov     esi, [ebp]+TsEip        ; (esi)-> faulting instruction

        cmp     eax, STATUS_ACCESS_VIOLATION ; dispatch access violation or
        je      short Kt0e9a                 ; or in_page_error?

        cmp     eax, STATUS_GUARD_PAGE_VIOLATION
        je      short Kt0e9b

        cmp     eax, STATUS_STACK_OVERFLOW
        je      short Kt0e9b


;
; test to see if reserved status code bit is set. If so, then bugchecka
;

        cmp     eax, STATUS_IN_PAGE_ERROR or 10000000h
        je      Kt0e12                  ; bugchecka

;
; (ecx) = ExceptionInfo 1
; (edi) = ExceptionInfo 2
; (eax) = ExceptionInfo 3
; (esi) -> Exception Addr
;

        mov     edx, ecx
        mov     ebx, esi
        mov     esi, edi
        mov     ecx, 3
        mov     edi, eax
        mov     eax, STATUS_IN_PAGE_ERROR
        call    CommonDispatchException ; Won't return

Kt0e9a: mov     eax, KI_EXCEPTION_ACCESS_VIOLATION
Kt0e9b:
        mov     ebx, esi
        mov     edx, ecx
        mov     esi, edi
        jmp     CommonDispatchException2Args ; Won't return

.FPO ( 0, 0, 0, 0, 0, FPO_TRAPFRAME )

;
; The fault occured in the kernel interlocked pop slist function.  The operation should
; be retried.

Kt0e10a:mov     ecx, offset FLAT:ExpInterlockedPopEntrySListResume ; get resume address
        jmp     Kt0e10e

;
; An unresolved page fault occured in the user mode interlocked pop slist
; code at the resumable fault address.
;
; Within the KTHREAD structure are these fields:
;
; ThSListFaultAddress - The VA of the last slist pop fault
; ThSListFaultCount - The number of consecutive faults at that address
;
; If the current VA != ThSListFaultAddress, then update both fields and retry
;   the operation.
;
; Otherwise, if ThSListFaultCount < KI_SLIST_FAULT_COUNT_MAXIMUM, increment
;   ThSListFaultCount and retry the operation.
;
; Otherwise, reset ThSListFaultCount and DO NOT retry the operation.
;

Kt0e10b:test    byte ptr [ebp]+TsSegCs, MODE_MASK
        jz      Kt0e05a                             ; not in usermode
        mov     ecx, PCR[PcPrcbData+PbCurrentThread]; get pointer to KTHREAD
        cmp     edi, [ecx].ThSListFaultAddress      ; get faulting VA - same as
        jne     Kt0e10d                             ; last time? no - update fault state
        cmp     DWORD PTR [ecx].ThSListFaultCount, KI_SLIST_FAULT_COUNT_MAXIMUM
        inc     DWORD PTR [ecx].ThSListFaultCount   ; presuppose under threshold. carry unchanged.
        jc      Kt0e10c                             ; same VA as last, but less than threshold
        mov     DWORD PTR [ecx].ThSListFaultCount, 0; over threshold - reset count
        jmp     Kt0e05a                             ; and do not retry

Kt0e10d:mov     [ecx].ThSListFaultAddress, edi      ; update new faulting VA
        mov     DWORD PTR [ecx].ThSListFaultCount, 0; and reset count
Kt0e10c:mov     ecx, _KeUserPopEntrySListResume     ; get resume address
Kt0e10e:mov     [ebp].TsEip, ecx                    ; set resume address and fall through

Kt0e10:

        mov     esp,ebp                 ; (esp) -> trap frame
        test    _KdpOweBreakpoint, 1    ; do we have any owed breakpoints?
        jz      _KiExceptionExit        ; No, all done

        stdCall _KdSetOwedBreakpoints   ; notify the debugger

Kt0e11: mov     esp,ebp                 ; (esp) -> trap frame
        jmp     _KiExceptionExit        ; join common code


Kt0e12:
        CurrentIrql                     ; (eax) = OldIrql
Kt0e12a:
        lock inc     ds:_KiHardwareTrigger   ; trip hardware analyzer

;
; bugcheck a, addr, irql, load/store, pc
;
        mov     ecx, [ebp]+TsErrCode    ; (ecx)= error code
        shr     ecx, 1                  ; isolate read/write bit
        and     ecx, _KeErrorMask       ;
        mov     esi, [ebp]+TsEip        ; [esi] = faulting instruction

        stdCall _KeBugCheck2,<IRQL_NOT_LESS_OR_EQUAL,edi,eax,ecx,esi,ebp>

Kt0e12b:cmp     _KiFreezeFlag,0         ; during boot we can take
        jnz     Kt0e01                  ; 'transition faults' on the
                                        ; debugger before it's been locked

        cmp     _KiBugCheckData, 0      ; If crashed, handle trap in
        jnz     Kt0e01                  ; normal manner


        mov     eax, 0ffh               ; OldIrql = -1
        jmp     short Kt0e12a

if FAST_BOP

Kt0eVdmAlert:

        ;
        ; If a page fault occured while we are in VDM alert mode (processing
        ; v86 trap without building trap frame), we will restore all the
        ; registers and return to its recovery routine which is stored in
        ; the TsSegGs of original trap frame.
        ;

        mov     eax, PCR[PcVdmAlert]
        mov     dword ptr PCR[PcVdmAlert], 0

        mov     [ebp].TsEip, eax
        mov     esp,ebp                 ; (esp) -> trap frame
        jmp     _KiExceptionExit        ; join common code

endif   ; FAST_BOP


_KiTrap0E       endp

        page ,132
        subttl "Trap0F -- Intel Reserved"
;++
;
; Routine Description:
;
;    The trap 0F should never occur.  If, however, the exception occurs in
;    USER mode, the current process will be terminated.  If the exception
;    occurs in KERNEL mode, a bugcheck will be raised.  NO registered
;    handler, if any, will be invoked to handle the exception.
;
; Arguments:
;
;    None
; Return value:
;
;    None
;
;--
        ASSUME  DS:NOTHING, SS:NOTHING, ES:NOTHING

        ENTER_DR_ASSIST kitf_a, kitf_t, NoAbiosAssist
align dword
        public  _KiTrap0F
_KiTrap0F       proc


        push    0                       ; push dummy error code
        ENTER_TRAP      kitf_a, kitf_t

        sti

        mov     eax, EXCEPTION_RESERVED_TRAP ; (eax) = trap type
        jmp     _KiSystemFatalException ; go terminate the system

_KiTrap0F       endp


        page ,132
        subttl "Coprocessor Error"

;++
;
; Routine Description:
;
;    Handle Coprocessor Error.
;
;    This exception is used on 486 or above only.  For i386, it uses
;    IRQ 13 instead.
;
; Arguments:
;
;    At entry, the saved CS:EIP point to the aborted instruction.
;    No error code is provided with the error.
;
; Return value:
;
;    None
;
;--
        ASSUME  DS:NOTHING, SS:NOTHING, ES:NOTHING

        ENTER_DR_ASSIST kit10_a, kit10_t, NoAbiosAssist

align dword
        public  _KiTrap10
_KiTrap10       proc


        push    0                       ; push dummy error code
        ENTER_TRAP      kit10_a, kit10_t


        mov     eax, PCR[PcPrcbData+PbCurrentThread]    ; Correct context for
        cmp     eax, PCR[PcPrcbData+PbNpxThread]        ; fault?
        mov     ecx, [eax].ThInitialStack
        lea     ecx, [ecx]-NPX_FRAME_LENGTH
        je      Kt0715                  ; Yes - go try to dispatch it

;
; We are in the wrong NPX context and can not dispatch the exception right now.
; Set up the target thread for a delay exception.
;
; Note: we don't think this is a possible case, but just to be safe...
;

        sti                                             ; Re-enable context switches
        or      dword ptr [ecx].FpCr0NpxState, CR0_TS   ; Set for delayed error
        jmp     _KiExceptionExit

_KiTrap10       endp

        page ,132
        subttl "Alignment fault"
;++
;
; Routine Description:
;
;    Handle alignment faults.
;
;    This exception occurs when an unaligned data access is made by a thread
;    with alignment checking turned on.
;
;    The x86 will not do any alignment checking.  Only threads which have
;    the appropriate bit set in EFLAGS will generate alignment faults.
;
;    The exception will never occur in kernel mode.  (hardware limitation)
;
; Arguments:
;
;    At entry, the saved CS:EIP point to the faulting instruction.
;    Error code is provided.
;
; Return value:
;
;    None
;
;--
        ASSUME  DS:NOTHING, SS:NOTHING, ES:NOTHING

        ENTER_DR_ASSIST kit11_a, kit11_t, NoAbiosAssist
align dword
        public  _KiTrap11
_KiTrap11       proc


        ENTER_TRAP kit11_a, kit11_t

        sti

.errnz (EFLAGS_V86_MASK AND 0FF00FFFFh)
        test    byte ptr [ebp]+TsEFlags+2,EFLAGS_V86_MASK/010000h
        jnz     Kt11_01                 ; v86 mode => usermode

.errnz (MODE_MASK AND 0FFFFFF00h)
        test    byte ptr [ebp]+TsSegCs, MODE_MASK  ; Is previous mode = USER
        jz      Kt11_10

;
; Check to make sure that the AutoAlignment state of this thread is FALSE.
; If not, this fault occurred because the thread messed with its own EFLAGS.
; In order to "fixup" this fault, we just clear the ALIGN_CHECK bit in the
; EFLAGS and restart the instruction.  Exceptions will only be generated if
; AutoAlignment is FALSE.
;
Kt11_01:
        mov     ebx,PCR[PcPrcbData+PbCurrentThread] ; (ebx)-> Current Thread
        bt      dword [ebx].ThThreadFlags, KTHREAD_AUTO_ALIGNMENT_BIT
        jnc     kt11_00
;
; This fault was generated even though the thread had AutoAlignment set to
; TRUE.  So we fix it up by setting the correct state in his EFLAGS and
; restarting the instruction.
;
        and     dword ptr [ebp]+TsEflags, NOT EFLAGS_ALIGN_CHECK
        jmp     _KiExceptionExit

kt11_00:
        mov     ebx, [ebp]+TsEip        ; (ebx)->faulting instruction
        mov     edx, EXCEPT_LIMIT_ACCESS; assume it is limit violation
        mov     esi, [ebp]+TsHardwareEsp; (esi) = User Stack pointer
        cmp     word ptr [ebp]+TsErrCode, 0 ; Is errorcode = 0?
        jz      short kt11_05            ; if z, yes, go dispatch exception

        mov     edx, EXCEPT_UNKNOWN_ACCESS
kt11_05:
        mov     eax, STATUS_DATATYPE_MISALIGNMENT
        jmp     CommonDispatchException2Args ; Won't return

kt11_10:
;
; We should never be here, since the 486 will not generate alignment faults
; in kernel mode.
;
        mov     eax, EXCEPTION_ALIGNMENT_CHECK      ; (eax) = trap type
        jmp     _KiSystemFatalException

_KiTrap11       endp

;++
;
; Routine Description:
;
;    Handle XMMI Exception.
;;
; Arguments:
;
;    At entry, the saved CS:EIP point to the aborted instruction.
;    No error code is provided with the error.
;
; Return value:
;
;    None
;
;--
        ASSUME  DS:NOTHING, SS:NOTHING, ES:NOTHING

        ENTER_DR_ASSIST kit13_a, kit13_t, NoAbiosAssist

align dword
        public  _KiTrap13
_KiTrap13       proc


        push    0                       ; push dummy error code
        ENTER_TRAP      kit13_a, kit13_t

        mov     eax, PCR[PcPrcbData+PbNpxThread]  ; Correct context for fault?
        cmp     eax, PCR[PcPrcbData+PbCurrentThread]
        je      Kt13_10                 ; Yes - go try to dispatch it

;
;       Katmai New Instruction exceptions are precise and occur immediately.
;       if we are in the wrong NPX context, bugcheck the system.
;
        ; stop the system
        stdCall _KeBugCheck2,<TRAP_CAUSE_UNKNOWN,13,eax,0,0,ebp>

Kt13_10:
        mov     ecx, [eax].ThInitialStack ; (ecx) -> top of kernel stack
        sub     ecx, NPX_FRAME_LENGTH

;
;       TrapFrame is built by ENTER_TRAP.
;       XMMI are accessible from all IA execution modes:
;       Protected Mode, Real address mode, Virtual 8086 mode
;
Kt13_15:
.errnz (EFLAGS_V86_MASK AND 0FF00FFFFh)
        test    byte ptr [ebp]+TsEFlags+2,EFLAGS_V86_MASK/010000h
        jnz     Kt13_130                ; v86 mode

;
;       eflags.vm=0 (not v86 mode)
;
.errnz (MODE_MASK AND 0FFFFFF00h)
        test    byte ptr [ebp]+TsSegCs, MODE_MASK ; Is previousMode=USER?
        jz      Kt13_05                 ; if z, previousmode=SYSTEM

;
;       eflags.vm=0 (not v86 mode)
;       previousMode=USER
;
        cmp     word ptr [ebp]+TsSegCs,KGDT_R3_CODE OR RPL_MASK
        jne     Kt13_110                ; May still be a vdm...

;
;       eflags.vm=0 (not v86 mode)
;       previousMode=USER
;       Cs=00011011
;
; We are about to dispatch a XMMI floating point exception to user mode.
;
; (ebp) - Trap frame
; (ecx) - CurrentThread's NPX save area (PCR[PcInitialStack])
; (eax) - CurrentThread

; Dispatch
Kt13_20:
;
; Some type of coprocessor exception has occured for the current thread.
;
; Interrupts disabled
;
        mov     ebx, cr0
        and     ebx, NOT (CR0_MP+CR0_EM+CR0_TS)
        mov     cr0, ebx                ; Clear MP+TS+EM to do fxsave

;
; Save the faulting state so we can inspect the cause of the floating
; point fault
;
        FXSAVE_ECX

if DBG
        test    dword ptr [ecx].FpCr0NpxState, NOT (CR0_MP+CR0_EM+CR0_TS)
        jnz     Kt13_dbg2
endif

        or      ebx, NPX_STATE_NOT_LOADED ; CR0_TS | CR0_MP
        or      ebx,[ecx]+FpCr0NpxState ; restore this thread's CR0 NPX state
        mov     cr0, ebx                ; set TS so next ESC access causes trap

;
; Clear TS bit in Cr0NpxFlags in case it was set to trigger this trap.
;
        and     dword ptr [ecx].FpCr0NpxState, NOT CR0_TS

;
; The state is no longer in the coprocessor.  Clear ThNpxState and
; re-enable interrupts to allow context switching.
;
        mov     byte ptr [eax].ThNpxState, NPX_STATE_NOT_LOADED
        mov     dword ptr PCR[PcPrcbData+PbNpxThread], 0  ; No state in coprocessor
        sti

; (eax) = ExcepCode - Exception code to put into exception record
; (ebx) = ExceptAddress - Addr of instruction which the hardware exception occurs
; (ecx) = NumParms - Number of additional parameters
; (edx) = Parameter1
; (esi) = Parameter2
; (edi) = Parameter3
        mov     ebx, [ebp].TsEip          ; Eip is from trap frame, not from FxErrorOffset
        movzx   eax, word ptr [ecx] + FxMXCsr
        mov     edx, eax
        shr     edx, 7                    ; get the mask
        not     edx
        mov     esi, 0                    ; (esi) = operand addr, addr is computed from
                                          ; trap frame, not from FxDataOffset
;
;       Exception will be handled in user's handler if there is one declared.
;
        and     eax, FSW_INVALID_OPERATION + FSW_DENORMAL + FSW_ZERO_DIVIDE + FSW_OVERFLOW + FSW_UNDERFLOW + FSW_PRECISION
        and     eax, edx
.errnz (FSW_INVALID_OPERATION AND 0FFFFFF00h)
        test    al, FSW_INVALID_OPERATION  ; Is it an invalid op exception?
        jz      short Kt13_40              ; if z, no, go Kt13_40
;
; Invalid Operation Exception - Invalid arithmetic operand
; Raise exception
;
        mov     eax, STATUS_FLOAT_MULTIPLE_TRAPS
        jmp     CommonDispatchException1Arg0d ; Won't return

Kt13_40:
; Check for floating zero divide exception
;
.errnz (FSW_ZERO_DIVIDE AND 0FFFFFF00h)
        test    al, FSW_ZERO_DIVIDE     ; Is it a zero divide error?
        jz      short Kt13_50           ; if z, no, go Kt13_50
;
; Division-By-Zero Exception
; Raise exception
;
        mov     eax, STATUS_FLOAT_MULTIPLE_TRAPS
        jmp     CommonDispatchException1Arg0d ; Won't return

Kt13_50:
; Check for denormal error
;
.errnz (FSW_DENORMAL AND 0FFFFFF00h)
        test    al, FSW_DENORMAL        ; Is it a denormal error?
        jz      short Kt13_60           ; if z, no, go Kt13_60
;
; Denormal Operand Exception
; Raise exception
;
        mov     eax, STATUS_FLOAT_MULTIPLE_TRAPS
        jmp     CommonDispatchException1Arg0d ; Won't return

Kt13_60:
; Check for floating overflow error
;
.errnz (FSW_OVERFLOW AND 0FFFFFF00h)
        test    al, FSW_OVERFLOW        ; Is it an overflow error?
        jz      short Kt13_70           ; if z, no, go Kt13_70
;
; Numeric Overflow Exception
; Raise exception
;
        mov     eax, STATUS_FLOAT_MULTIPLE_FAULTS
        jmp     CommonDispatchException1Arg0d ; Won't return

Kt13_70:
; Check for floating underflow error
;
.errnz (FSW_UNDERFLOW AND 0FFFFFF00h)
        test    al, FSW_UNDERFLOW       ; Is it a underflow error?
        jz      short Kt13_80           ; if z, no, go Kt13_80
;
; Numeric Underflow Exception
; Raise exception
;
        mov     eax, STATUS_FLOAT_MULTIPLE_FAULTS
        jmp     CommonDispatchException1Arg0d ; Won't return

Kt13_80:
; Check for precision (IEEE inexact) error
;
.errnz (FSW_PRECISION AND 0FFFFFF00h)
        test    al, FSW_PRECISION       ; Is it a precision error
        jz      short Kt13_100          ; if z, no, go Kt13_100
;
; Inexact-Result (Precision) Exception
; Raise exception
;
        mov     eax, STATUS_FLOAT_MULTIPLE_FAULTS
        jmp     CommonDispatchException1Arg0d ; Won't return

; Huh?
Kt13_100:
; If status word does not indicate error, then something is wrong...
; (Note: that we have done a sti, before the status is examined)
        sti
; stop the system
        stdCall _KeBugCheck2,<TRAP_CAUSE_UNKNOWN,13,eax,0,1,ebp>

;
;       eflags.vm=0 (not v86 mode)
;       previousMode=USER
;       Cs=!00011011
;       (We should have (eax) -> CurrentThread)
;
Kt13_110:
; Check to see if this process is a vdm
        mov     ebx,PCR[PcPrcbData+PbCurrentThread] ; (ebx) -> CurrentThread
        mov     ebx,[ebx]+ThApcState+AsProcess      ; (ebx) -> CurrentProcess
        cmp     dword ptr [ebx]+PrVdmObjects,0 ; is this a vdm process?
        je      Kt13_20                             ; no, dispatch exception
                                                    ; yes, drop down to v86 mode
;
;       eflags.vm=1 (v86 mode)
;
Kt13_130:
; Turn off TS
        mov     ebx,CR0
        and     ebx,NOT CR0_TS
        mov     CR0,ebx
        and     dword ptr [ecx]+FpCr0NpxState,NOT CR0_TS

;
; Reflect the exception to the vdm, the VdmHandler enables interrupts
;

        ; Raise Irql to APC level before enabling interrupts
        RaiseIrql APC_LEVEL
        push    eax                     ; Save OldIrql
        sti

        stdCall   _VdmDispatchIRQ13, <ebp> ; ebp - Trapframe
        test    al,0fh
        jnz     Kt13_135
        pop     ecx                     ; (TOS) = OldIrql
        LowerIrql ecx
        jmp     Kt13_20                 ; could not reflect, gen exception

Kt13_135:
        pop     ecx                     ; (TOS) = OldIrql
        LowerIrql ecx
        jmp     _KiExceptionExit

;
;       eflags.vm=0 (not v86 mode)
;       previousMode=SYSTEM
;
Kt13_05:
        ; stop the system
        stdCall _KeBugCheck2,<TRAP_CAUSE_UNKNOWN,13,0,0,2,ebp>

if DBG
Kt13_dbg1:    int 3
Kt13_dbg2:    int 3
Kt13_dbg3:    int 3
        sti
        jmp short $-2
endif

_KiTrap13       endp


        page ,132
        subttl "Coprocessor Error Handler"
;++
;
; Routine Description:
;
;    When the FPU detects an error, it raises its error line.  This
;    was supposed to be routed directly to the x86 to cause a trap 16
;    (which would actually occur when the x86 encountered the next FP
;    instruction).
;
;    However, the ISA design routes the error line to IRQ13 on the
;    slave 8259.  So an interrupt will be generated whenever the FPU
;    discovers an error.  Unfortunately, we could be executing system
;    code at the time, in which case we can't dispatch the exception.
;
;    So we force emulation of the intended behavior.  This interrupt
;    handler merely sets TS and Cr0NpxState TS and dismisses the interrupt.
;    Then, on the next user FP instruction, a trap 07 will be generated, and
;    the exception can be dispatched then.
;
;    Note that we don't have to clear the FP exeception here,
;    since that will be done in the trap 07 handler.  The x86 will
;    generate the trap 07 before the FPU gets a chance to raise another
;    error interrupt.  We'll want to save the FPU state in the trap 07
;    handler WITH the error information.
;
;    Note the caller must clear the FPU error latch.  (this is done in
;    the hal).
;
; Arguments:
;
;    None
;
; Return value:
;
;    None
;
;--
        ASSUME  DS:FLAT, SS:NOTHING, ES:NOTHING

align dword
cPublicProc _KiCoprocessorError     ,0

;
; Set TS in Cr0NpxState - the next time this thread runs an ESC
; instruction the error will be dispatched.  We also need to set TS
; in CR0 in case the owner of the NPX is currently running.
;
; Bit must be set in FpCr0NpxState before CR0.
;
        mov     eax, PCR[PcPrcbData+PbNpxThread]
        mov     eax, [eax].ThInitialStack
        sub     eax, NPX_FRAME_LENGTH   ; Space for NPX_FRAME
        or      dword ptr [eax].FpCr0NpxState, CR0_TS

        mov     eax, cr0
        or      eax, CR0_TS
        mov     cr0, eax
        stdRET    _KiCoprocessorError

stdENDP _KiCoprocessorError

;
; BBT cannot instrument code between BBT_Exclude_Trap_Code_Begin and this label
;
        public  _BBT_Exclude_Trap_Code_End
_BBT_Exclude_Trap_Code_End  equ     $
        int 3

;++
;
; VOID
; KiFlushNPXState (
;     PFLOATING_SAVE_AREA SaveArea
;     )
;
; Routine Description:
;
;   When a thread's NPX context is requested (most likely by a debugger)
;   this function is called to flush the thread's NPX context out of the
;   compressor if required.
;
; Arguments:
;
;    Pointer to a location where this function must do fnsave for the
;    current thread.
;
;    NOTE that this pointer can be NON-NULL only if KeI386FxsrPresent is
;         set (FXSR feature is present)
;
; Return value:
;
;    None
;
;--
        ASSUME  DS:FLAT, SS:NOTHING, ES:NOTHING
align dword

SaveArea    equ     [esp + 20]

cPublicProc _KiFlushNPXState    ,1
cPublicFpo 1, 4

        push    esi
        push    edi
        push    ebx
        pushfd
        cli                             ; don't context switch

        mov     edi, PCR[PcSelfPcr]
        mov     esi, [edi].PcPrcbData+PbCurrentThread

        cmp     byte ptr [esi].ThNpxState, NPX_STATE_LOADED
        je      short fnpx20

fnpx00:
        ; NPX state is not loaded. If SaveArea is non-null, we need to return
        ; the saved FP state in fnsave format.

        cmp     dword ptr SaveArea, 0
        je      fnpx70

if DBG
        ;
        ; SaveArea can be NON-NULL ONLY when FXSR feature is present
        ;

        test    byte ptr _KeI386FxsrPresent, 1
        jnz     @f
        int     3
@@:
endif
        ;
        ; Need to convert the (not loaded) NPX state of the current thread
        ; to FNSAVE format into the SaveArea
        ;
        mov     ebx, cr0
.errnz ((CR0_MP+CR0_TS+CR0_EM) AND 0FFFFFF00h)
        test    bl, CR0_MP+CR0_TS+CR0_EM
        jz      short fnpx07
        and     ebx, NOT (CR0_MP+CR0_TS+CR0_EM)
        mov     cr0, ebx                ; allow frstor (& fnsave) to work
fnpx07:
        ;
        ; If NPX state is for some other thread, save it away
        ;

        mov     eax, [edi].PcPrcbData+PbNpxThread   ; Owner of NPX state
        or      eax, eax
        jz      short fnpx10            ; no - skip save

        cmp     byte ptr [eax].ThNpxState, NPX_STATE_LOADED
        jne     short fnpx10            ; not loaded, skip save

ifndef NT_UP
if DBG
        ; This can only happen UP where the context is not unloaded on a swap
        int 3
endif
endif

        ;
        ; Save current owners NPX state
        ;

        mov     ecx, [eax].ThInitialStack
        sub     ecx, NPX_FRAME_LENGTH   ; Space for NPX_FRAME
        FXSAVE_ECX
        mov     byte ptr [eax].ThNpxState, NPX_STATE_NOT_LOADED

fnpx10:
        ;
        ; Load current thread's NPX state
        ;
        mov     ecx, [esi].ThInitialStack ; (ecx) -> top of kernel stack
        sub     ecx, NPX_FRAME_LENGTH
        FXRSTOR_ECX                       ; reload NPX context
        mov     edx, [ecx]+FpCr0NpxState
        mov     ecx, SaveArea
        jmp     short fnpx40

fnpx20:
        ;
        ; Current thread has NPX state in the coprocessor, flush it
        ;
        mov     ebx, cr0
.errnz ((CR0_MP+CR0_TS+CR0_EM) AND 0FFFFFF00h)
        test    bl, CR0_MP+CR0_TS+CR0_EM
        jz      short fnpx30
        and     ebx, NOT (CR0_MP+CR0_TS+CR0_EM)
        mov     cr0, ebx                   ; allow frstor (& fnsave) to work
fnpx30:
        mov     ecx, [esi].ThInitialStack  ; (ecx) -> top of kernel stack
        test    byte ptr _KeI386FxsrPresent, 1
        lea     ecx, dword ptr [ecx-NPX_FRAME_LENGTH]
        ; This thread's NPX state can be flagged as not loaded
        mov     byte ptr [esi].ThNpxState, NPX_STATE_NOT_LOADED
        mov     edx, [ecx]+FpCr0NpxState
        jz      short fnpx40
        FXSAVE_ECX

        ; Do fnsave to SaveArea if it is non-null
        mov     ecx,  SaveArea
        jecxz   short fnpx50

fnpx40:
        fnsave  [ecx]                   ; Flush NPX state to save area
        fwait                           ; Make sure data is in save area
fnpx50:
        xor     eax, eax
        or      ebx, NPX_STATE_NOT_LOADED               ; Or in new thread's CR0
        mov     [edi].PcPrcbData+PbNpxThread, eax       ; Clear NPX owner
        or      ebx, edx                ; Merge new thread setable state
        mov     cr0, ebx

fnpx70:
        popfd                           ; enable interrupts
        pop     ebx
        pop     edi
        pop     esi
        stdRET    _KiFlushNPXState

stdENDP _KiFlushNPXState

        page ,132
        subttl "Processing System Fatal Exceptions"
;++
;
; Routine Description:
;
;    This routine processes the system fatal exceptions.
;    The machine state and trap type will be displayed and
;    System will be stopped.
;
; Arguments:
;
;    (eax) = Trap type
;    (ebp) -> machine state frame
;
; Return value:
;
;    system stopped.
;
;--
        assume  ds:nothing, es:nothing, ss:nothing, fs:nothing, gs:nothing

align dword
        public  _KiSystemFatalException
_KiSystemFatalException proc
.FPO (0, 0, 0, 0, 0, FPO_TRAPFRAME)

        stdCall _KeBugCheck2,<UNEXPECTED_KERNEL_MODE_TRAP,eax,0,0,0,ebp>
        ret

_KiSystemFatalException endp

        page
        subttl  "Continue Execution System Service"
;++
;
; NTSTATUS
; NtContinue (
;    IN PCONTEXT ContextRecord,
;    IN BOOLEAN TestAlert
;    )
;
; Routine Description:
;
;    This routine is called as a system service to continue execution after
;    an exception has occurred. Its function is to transfer information from
;    the specified context record into the trap frame that was built when the
;    system service was executed, and then exit the system as if an exception
;    had occurred.
;
;   WARNING - Do not call this routine directly, always call it as
;             ZwContinue!!!  This is required because it needs the
;             trapframe built by KiSystemService.
;
; Arguments:
;
;    KTrapFrame (ebp+0: after setup) -> base of KTrapFrame
;
;    ContextRecord (ebp+8: after setup) = Supplies a pointer to a context rec.
;
;    TestAlert (esp+12: after setup) = Supplies a boolean value that specifies
;       whether alert should be tested for the previous processor mode.
;
; Return Value:
;
;    Normally there is no return from this routine. However, if the specified
;    context record is misaligned or is not accessible, then the appropriate
;    status code is returned.
;
;--

NcTrapFrame             equ     [ebp + 0]
NcContextRecord         equ     [ebp + 8]
NcTestAlert             equ     [ebp + 12]

align dword
cPublicProc _NtContinue     ,2

        push    ebp

;
; Restore old trap frame address since this service exits directly rather
; than returning.
;

        mov     ebx, PCR[PcPrcbData+PbCurrentThread] ; get current thread address
        mov     edx, [ebp].TsEdx        ; restore old trap frame address
        mov     [ebx].ThTrapFrame, edx  ;

;
; Call KiContinue to load ContextRecord into TrapFrame.  On x86 TrapFrame
; is an atomic entity, so we don't need to allocate any other space here.
;
; KiContinue(NcContextRecord, 0, NcTrapFrame)
;

        mov     ebp,esp
        mov     eax, NcTrapFrame
        mov     ecx, NcContextRecord
        stdCall  _KiContinue, <ecx, 0, eax>
        or      eax,eax                 ; return value 0?
        jnz     short Nc20              ; KiContinue failed, go report error

;
; Check to determine if alert should be tested for the previous processor mode.
;

        cmp     byte ptr NcTestAlert,0  ; Check test alert flag
        je      short Nc10              ; if z, don't test alert, go Nc10
        mov     al,byte ptr [ebx]+ThPreviousMode ; No need to xor eax, eax.
        stdCall _KeTestAlertThread, <eax> ; test alert for current thread
Nc10:   pop     ebp                     ; (ebp) -> TrapFrame
        mov     esp,ebp                 ; (esp) = (ebp) -> trapframe
        jmp     _KiServiceExit2         ; common exit

Nc20:   pop     ebp                     ; (ebp) -> TrapFrame
        mov     esp,ebp                 ; (esp) = (ebp) -> trapframe
        jmp     _KiServiceExit          ; common exit

stdENDP _NtContinue

        page
        subttl  "Raise Exception System Service"
;++
;
; NTSTATUS
; NtRaiseException (
;    IN PEXCEPTION_RECORD ExceptionRecord,
;    IN PCONTEXT ContextRecord,
;    IN BOOLEAN FirstChance
;    )
;
; Routine Description:
;
;    This routine is called as a system service to raise an exception. Its
;    function is to transfer information from the specified context record
;    into the trap frame that was built when the system service was executed.
;    The exception may be raised as a first or second chance exception.
;
;   WARNING - Do not call this routine directly, always call it as
;             ZwRaiseException!!!  This is required because it needs the
;             trapframe built by KiSystemService.
;
;   NOTE - KiSystemService will terminate the ExceptionList, which is
;          not what we want for this case, so we will fish it out of
;          the trap frame and restore it.
;
; Arguments:
;
;    TrapFrame (ebp+0: before setup) -> System trap frame for this call
;
;    ExceptionRecord (ebp+8: after setup) -> An exception record.
;
;    ContextRecord (ebp+12: after setup) -> Points to a context record.
;
;    FirstChance (ebp+16: after setup) -> Supplies a boolean value that
;       specifies whether the exception is to be raised as a first (TRUE)
;       or second chance (FALSE) exception.
;
; Return Value:
;
;    None.
;--
align dword
cPublicProc _NtRaiseException ,3
NtRaiseException:

        push    ebp

;
; Restore old trap frame address since this service exits directly rather
; than returning.
;

        mov     ebx, PCR[PcPrcbData+PbCurrentThread] ; get current thread address
        mov     edx, [ebp].TsEdx        ; restore old trap frame address
        mov     [ebx].ThTrapFrame, edx  ;

;
;   Put back the ExceptionList so the exception can be properly
;   dispatched.
;

        mov     ebp,esp                 ; [ebp+0] -> TrapFrame
        mov     ebx, [ebp+0]            ; (ebx)->TrapFrame
        mov     edx, [ebp+16]           ; (edx) = First chance indicator
        mov     eax, [ebx]+TsExceptionList ; Old exception list
        mov     ecx, [ebp+12]           ; (ecx)->ContextRecord
        mov     PCR[PcExceptionList],eax
        mov     eax, [ebp+8]            ; (eax)->ExceptionRecord

;
;   KiRaiseException(ExceptionRecord, ContextRecord, ExceptionFrame,
;           TrapFrame, FirstChance)
;

        stdCall   _KiRaiseException,<eax, ecx, 0, ebx, edx>

        pop     ebp
        mov     esp,ebp                 ; (esp) = (ebp) -> trap frame

;
;   If the exception was handled, then the trap frame has been edited to
;   reflect new state, and we'll simply exit the system service to get
;   the effect of a continue.
;
;   If the exception was not handled, exit via KiServiceExit so the
;   return status is propagated back to the caller.
;
        or      eax, eax                ; test exception handled
        jnz     _KiServiceExit          ; if exception not handled
        jmp     _KiServiceExit2

stdENDP _NtRaiseException



        page
        subttl "Reflect Exception to a Vdm"
;++
;
;   Routine Description:
;       Local stub which reflects an exception to a VDM using
;       Ki386VdmReflectException,
;
;   Arguments:
;
;       ebp -> Trap frame
;       ss:esp + 4 = trap number
;
;   Returns
;       ret value from Ki386VdmReflectException
;       interrupts are disabled uppon return
;
cPublicProc _Ki386VdmReflectException_A, 1

        sub     esp, 4*2

        RaiseIrql APC_LEVEL

        sti
        mov     [esp+4], eax                ; Save OldIrql
        mov     eax, [esp+12]               ; Pick up trap number
        mov     [esp+0], eax

        call    _Ki386VdmReflectException@4 ; pops one dword

        mov     ecx, [esp+0]                ; (ecx) = OldIrql
        mov     [esp+0], eax                ; Save return code

        LowerIrql ecx

        pop     eax                         ; pops second dword
        ret     4

stdENDP _Ki386VdmReflectException_A


_TEXT$00   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ke\i386\timindex.asm ===
TITLE   "Compute Timer Table Index"
;++
;
; Copyright (c) Microsoft Corporation. All rights reserved. 
;
; You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
; If you do not agree to the terms, do not use the code.
;
;
; Module Name:
;
;    timindex.asm
;
; Abstract:
;
;    This module implements the code necessary to compute the timer table
;    index for a timer.
;
;--

.386p
        .xlist
include ks386.inc
include callconv.inc            ; calling convention macros
        .list

        extrn  _KiTimeIncrementReciprocal:dword
        extrn  _KiTimeIncrementShiftCount:BYTE

_TEXT$00   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

        subttl  "Compute 64-bit Timer Table Index"
;++
;
; ULONG
; KiComputeTimerTableIndex (
;    IN ULONG64 DueTime
;    )
;
; Routine Description:
;
;    This function computes the timer table index for the specified due time.
;
;    The formula for the index calculation is:
;
;    Index = (Due Time / Maximum time) & (Table Size - 1)
;
;    The time increment division is performed using reciprocal multiplication.
;
; Arguments:
;
;    DueTime  - Supplies the absolute due time.
;
; Return Value:
;
;    The time table index is returned as the function value.
;
;--

DueTimeLow equ 8[esp]
DueTimeHigh equ 12[esp]

cPublicProc _KiComputeTimerTableIndex, 2

        push    ebx                     ; save nonvolatile register

;
; Compute low 32-bits of dividend times high 32-bits of divisor.
;

        mov     eax, DueTimeLow         ; get low 32-bits of dividend
        mul     [_KiTimeIncrementReciprocal + 4] ; multiply by high 32-bits of divisor
        mov     ebx, eax                ; save full 64-bit product
        mov     ecx, edx                ;

;
; Compute high 32-bits of dividend times low 32-bits of divisor.
;

        mov     eax, DueTimeHigh        ; get high 32-bits of dividend
        mul     [_KiTimeIncrementReciprocal] ; multiply by low 32-bits of divisor
        add     ebx, eax                ; compute middle 64-bits of product
        adc     ecx, edx                ;

;
; Compute low 32-bits of dividend times low 32-bits of divisor.
;

        mov     eax, DueTimeLow         ; get low 32-bits of dividend
        mul     [_KiTimeIncrementReciprocal] ; multiply by low 32-bits of divisor

;
; Compute high 32-bits of dividend time high 32-bits of divisor
;

        mov     eax, DueTimeHigh        ; get high 32-bits of dividend
        push    edx                     ; save high 32-bits of product
        mul     [_KiTimeIncrementReciprocal + 4] ; multiply by high 32-bits of divisor
        pop     edx                     ; retrieve high 32-bits of prodcut
        add     edx, ebx                ; compute full middle 64-bits of product
        adc     eax, ecx                ;

;
; Right shift the result by the specified shift count and mask off extra
; bits.
;

        mov     cl, [_KiTimeIncrementShiftCount] ; get shift count value
        shr     eax, cl                 ; extract appropriate product bits
        and     eax, (TIMER_TABLE_SIZE - 1); reduce to size of table
        pop     ebx                     ; restore nonvolatile register

        stdRET  _KicomputeTimerTableIndex

stdENDP _KiComputeTimerTableIndex

_TEXT$00   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ke\i386\zero.asm ===
title  "Zero memory pages using fastest means available"
;++
;
; Copyright (c) Microsoft Corporation. All rights reserved. 
;
; You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
; If you do not agree to the terms, do not use the code.
;
;
; Module Name:
;
;    zero.asm
;
; Abstract:
;
;    Zero memory pages using the fastest means available.
;
;--

.386p
        .xlist
include ks386.inc
include callconv.inc
include mac386.inc
include irqli386.inc

        .list

        EXTRNP  HalRequestSoftwareInterrupt,1,IMPORT,FASTCALL

;
; Register Definitions (for instruction macros).
;

rEAX            equ     0
rECX            equ     1
rEDX            equ     2
rEBX            equ     3
rESP            equ     4
rEBP            equ     5
rESI            equ     6
rEDI            equ     7

;
; Define SIMD instructions used in this module.
;

xorps           macro   XMMReg1, XMMReg2
                db      0FH, 057H, 0C0H + (XMMReg1 * 8) + XMMReg2
                endm

movntps         macro   GeneralReg, Offset, XMMReg
                db      0FH, 02BH, 040H + (XmmReg * 8) + GeneralReg, Offset
                endm

sfence          macro
                db      0FH, 0AEH, 0F8H
                endm

movaps_load     macro   XMMReg, GeneralReg
                db      0FH, 028H, (XMMReg * 8) + 4, (4 * 8) + GeneralReg
                endm

movaps_store    macro   GeneralReg, XMMReg
                db      0FH, 029H, (XMMReg * 8) + 4, (4 * 8) + GeneralReg
                endm


;
; NPX Save and Restore
;

fxsave          macro   Register
                db      0FH, 0AEH, Register
                endm

fxrstor         macro   Register
                db      0FH, 0AEH, 8+Register
                endm


_TEXT   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

;++
;
; VOID
; KeZeroPages (
;     IN PVOID PageBase,
;     IN SIZE_T NumberOfBytes
;    )
;
; Routine Description:
;
;     KeZeroPages is really just a function pointer that points at
;     either KiZeroPages or KiXMMIZeroPages depending on whether or
;     not XMMI instructions are available.
;
; Arguments:
;
;     (ecx) PageBase    Base address of pages to be zeroed.
;
;     (edx) NumberOfBytes    Number of bytes to be zeroed.  Always a PAGE_SIZE multiple.
;
;
; Return Value:
;
;--


        page    ,132
        subttl  "KiXMMIZeroPagesNoSave - Use XMMI to zero memory (XMMI owned)"

;++
;
; VOID
; KiXMMIZeroPagesNoSave (
;     IN PVOID PageBase,
;     IN SIZE_T NumberOfBytes
;     )
;
; Routine Description:
;
;     Use XMMI to zero a page of memory 16 bytes at a time while
;     at the same time minimizing cache pollution.
;
;     Note: The XMMI register set belongs to this thread.  It is neither
;     saved nor restored by this procedure.
;
; Arguments:
;
;     (ecx) PageBase    Virtual address of the base of the page to be zeroed.
;
;     (edx) NumberOfBytes    Number of bytes to be zeroed.  Always a PAGE_SIZE multiple.
;
; Return Value:
;
;     None.
;
;--

INNER_LOOP_BYTES    equ 64
INNER_LOOP_SHIFT    equ 6

cPublicFastCall KiXMMIZeroPagesNoSave,2
cPublicFpo 0, 1

        xorps   0, 0                            ; zero xmm0 (128 bits)
        shr     edx, INNER_LOOP_SHIFT           ; Number of Iterations

inner:

        movntps rECX, 0,  0                     ; store bytes  0 - 15
        movntps rECX, 16, 0                     ;             16 - 31
        movntps rECX, 32, 0                     ;             32 - 47
        movntps rECX, 48, 0                     ;             48 - 63

        add     ecx, 64                         ; increment base
        dec     edx                             ; decrement loop count
        jnz     short inner

        ; Force all stores to complete before any other
        ; stores from this processor.

        sfence

ifndef SFENCE_IS_NOT_BUSTED

        ; ERRATA the next uncached write to this processor's APIC 
        ; may fail unless the store pipes have drained.  sfence by
        ; itself is not enough.   Force drainage now by doing an
        ; interlocked exchange.

        xchg    [esp-4], edx

endif

        fstRET  KiXMMIZeroPagesNoSave

fstENDP KiXMMIZeroPagesNoSave


        page    ,132
        subttl  "KiXMMIZeroPages - Use XMMI to zero memory"

;++
;
; VOID
; KiXMMIZeroPages (
;     IN PVOID PageBase,
;     IN SIZE_T NumberOfBytes
;     )
;
; Routine Description:
;
;     Use XMMI to zero a page of memory 16 bytes at a time.  This
;     routine is a wrapper around KiXMMIZeroPagesNoSave.  In this
;     case we don't have the luxury of not saving/restoring context.
;
; Arguments:
;
;     (ecx) PageBase    Virtual address of the base of the page to be zeroed.
;
;     (edx) NumberOfBytes    Number of bytes to be zeroed.  Always a PAGE_SIZE multiple.
;
; Return Value:
;
;     None.
;
;--

cPublicFastCall KiXMMIZeroPages,2
cPublicFpo 0, 2

        push    ebp
        push    ebx
        mov     ebx, PCR[PcPrcbData+PbCurrentThread]
        mov     eax, [ebx].ThInitialStack
        sub     eax, NPX_FRAME_LENGTH
        mov     ebp, esp                        ; save stack pointer
        sub     esp, 16                         ; reserve space for xmm0
        and     esp, 0FFFFFFF0H                 ; 16 byte aligned
        cli                                     ; don't context switch
        test    [eax].FpCr0NpxState, CR0_EM     ; if FP explicitly disabled
        jnz     short kxzp90                    ; do it the old way
        dec     word ptr [ebx].ThSpecialApcDisable ; Disable APCs now we know we are zeroing with SSE
        cmp     byte ptr [ebx].ThNpxState, NPX_STATE_LOADED
        je      short kxzp80                    ; jiff, NPX stated loaded

        ; NPX state is not loaded on this thread, it will be by
        ; the time we reenable context switching.

        mov     byte ptr [ebx].ThNpxState, NPX_STATE_LOADED

        ; enable use of FP instructions

        mov     ebx, cr0
        and     ebx, NOT (CR0_MP+CR0_TS+CR0_EM)
        mov     cr0, ebx                        ; enable NPX

ifdef NT_UP

        ; if this is a UP machine, the state might be loaded for
        ; another thread in which case it needs to be saved.

        mov     ebx, PCR[PcPrcbData+PbNpxThread]; Owner of NPX state
        or      ebx, ebx                        ; NULL?
        jz      short @f                        ; yes, skip save.

        mov     byte ptr [ebx].ThNpxState, NPX_STATE_NOT_LOADED
        mov     ebx, [ebx].ThInitialStack       ; get address of save
        sub     ebx, NPX_FRAME_LENGTH           ; area.
        fxsave  rEBX                            ; save NPX
@@:

endif

        ; Now load the NPX context for this thread.  This is because
        ; if we switch away from this thread it will get saved again
        ; in this save area and destroying it would be bad.

        fxrstor rEAX

        mov     eax, PCR[PcPrcbData+PbCurrentThread]
        mov     PCR[PcPrcbData+PbNpxThread], eax

kxzp80:
        sti                                     ; reenable context switching
        movaps_store rESP, 0                    ; save xmm0
        fstCall KiXMMIZeroPagesNoSave           ; zero the page
        movaps_load  0, rESP                    ; restore xmm

        mov     eax, PCR[PcPrcbData+PbCurrentThread]
        inc     word ptr [eax].ThSpecialApcDisable
        jne     @f
        lea     eax, [eax].ThApcState.AsApcListHead
        cmp     eax, [eax]
        je      @f
        mov     cl, APC_LEVEL           ; request software interrupt level
        fstCall HalRequestSoftwareInterrupt ;
@@:
        ; restore stack pointer, non-volatiles and return

        mov     esp, ebp
        pop     ebx
        pop     ebp
        fstRET  KiXMMIZeroPages


        ; FP is explicitly disabled for this thread (probably a VDM
        ; thread).  Restore stack pointer, non-volatiles and jump into
        ; KiZeroPage to do the work the old fashioned way.

kxzp90:
        sti
        mov     esp, ebp
        pop     ebx
        pop     ebp
        jmp     short @KiZeroPages@8

fstENDP KiXMMIZeroPages


        page    ,132
        subttl  "KiZeroPages - Available to all X86 processors"

;++
;
; KiZeroPages(
;     PVOID PageBase,
;     IN SIZE_T NumberOfBytes
;     )
;
; Routine Description:
;
;     Generic Zero Page routine, used on processors that don't have
;     a more efficient way to zero large blocks of memory.
;     (Same as RtlZeroMemory).
;
; Arguments:
;
;     (ecx) PageBase    Base address of page to be zeroed.
;
;     (edx) NumberOfBytes    Number of bytes to be zeroed.  Always a PAGE_SIZE multiple.
;
; Return Value:
;
;     None.
;
;--

cPublicFastCall KiZeroPages,2
cPublicFpo 0, 0

        push    edi                             ; save EDI (non-volatile)
        xor     eax, eax                        ; 32 bit zero
        mov     edi, ecx                        ; setup for repsto
        mov     ecx, edx                        ; number of bytes
        shr     ecx, 2                          ; iteration count

        ; store eax, ecx times starting at edi

        rep stosd

        pop     edi                             ; restore edi and return
        fstRET  KiZeroPages

fstENDP KiZeroPages


_TEXT   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\ke\i386\thredini.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    thredini.c

Abstract:

    This module implements the machine dependent function to set the initial
    context and data alignment handling mode for a process or thread object.

--*/

#include "ki.h"

//
// Our notion of alignment is different, so force use of ours
//

#undef ALIGN_UP
#undef ALIGN_DOWN
#define ALIGN_DOWN(address, amt) ((ULONG)(address) & ~(( amt ) - 1))
#define ALIGN_UP(address, amt) (ALIGN_DOWN( (address + (amt) - 1), (amt)))

VOID
KiInitializeContextThread (
    IN PKTHREAD Thread,
    IN PKSYSTEM_ROUTINE SystemRoutine,
    IN PKSTART_ROUTINE StartRoutine OPTIONAL,
    IN PVOID StartContext OPTIONAL,
    IN PCONTEXT ContextFrame OPTIONAL
    )

/*++

Routine Description:

    This function initializes the machine dependent context of a thread object.

    N.B. This function does not check the accessibility of the context record.
         It is assumed the the caller of this routine is either prepared to
         handle access violations or has probed and copied the context record
         as appropriate.

Arguments:

    Thread - Supplies a pointer to a dispatcher object of type thread.

    SystemRoutine - Supplies a pointer to the system function that is to be
        called when the thread is first scheduled for execution.

    StartRoutine - Supplies an optional pointer to a function that is to be
        called after the system has finished initializing the thread. This
        parameter is specified if the thread is a system thread and will
        execute totally in kernel mode.

    StartContext - Supplies an optional pointer to an arbitrary data structure
        which will be passed to the StartRoutine as a parameter. This
        parameter is specified if the thread is a system thread and will
        execute totally in kernel mode.

    ContextFrame - Supplies an optional pointer a context frame which contains
        the initial user mode state of the thread. This parameter is specified
        if the thread is a user thread and will execute in user mode. If this
        parameter is not specified, then the Teb parameter is ignored.

Return Value:

    None.

--*/

{

    PFX_SAVE_AREA NpxFrame;
    PKSWITCHFRAME SwitchFrame;
    PKTRAP_FRAME TrFrame;
    PULONG PSystemRoutine;
    PULONG PStartRoutine;
    PULONG PStartContext;
    PULONG PUserContextFlag;
    ULONG  ContextFlags;
    CONTEXT Context2;
    PCONTEXT ContextFrame2 = NULL;
    PFXSAVE_FORMAT PFxSaveArea;

    //
    // If a context frame is specified, then initialize a trap frame and
    // and an exception frame with the specified user mode context.
    //

    if (ARGUMENT_PRESENT(ContextFrame)) {

        RtlCopyMemory(&Context2, ContextFrame, sizeof(CONTEXT));
        ContextFrame2 = &Context2;
        ContextFlags = CONTEXT_CONTROL;

        //
        // The 80387 save area is at the very base of the kernel stack.
        //

        NpxFrame = (PFX_SAVE_AREA)(((ULONG)(Thread->InitialStack) -
                    sizeof(FX_SAVE_AREA)));

        TrFrame = (PKTRAP_FRAME)(((ULONG)NpxFrame - KTRAP_FRAME_LENGTH));

        //
        // Zero out the trap frame and save area
        //

        RtlZeroMemory(TrFrame, KTRAP_FRAME_LENGTH + sizeof(FX_SAVE_AREA));

        //
        // Load up an initial NPX state.
        //

        if (KeI386FxsrPresent == TRUE) {
            PFxSaveArea = (PFXSAVE_FORMAT)ContextFrame2->ExtendedRegisters;
    
            PFxSaveArea->ControlWord   = 0x27f;  // like fpinit but 64bit mode
            PFxSaveArea->StatusWord    = 0;
            PFxSaveArea->TagWord       = 0;
            PFxSaveArea->ErrorOffset   = 0;
            PFxSaveArea->ErrorSelector = 0;
            PFxSaveArea->DataOffset    = 0;
            PFxSaveArea->DataSelector  = 0;
            PFxSaveArea->MXCsr         = 0x1f80; // mask all the exceptions
        } else {
            ContextFrame2->FloatSave.ControlWord   = 0x27f;  // like fpinit but 64bit mode
            ContextFrame2->FloatSave.StatusWord    = 0;
            ContextFrame2->FloatSave.TagWord       = 0xffff;
            ContextFrame2->FloatSave.ErrorOffset   = 0;
            ContextFrame2->FloatSave.ErrorSelector = 0;
            ContextFrame2->FloatSave.DataOffset    = 0;
            ContextFrame2->FloatSave.DataSelector  = 0;
        }


        if (KeI386NpxPresent) {
            ContextFrame2->FloatSave.Cr0NpxState = 0;
            NpxFrame->Cr0NpxState = 0;
            NpxFrame->NpxSavedCpu = 0;
            if (KeI386FxsrPresent == TRUE) {
                ContextFlags |= CONTEXT_EXTENDED_REGISTERS;
            } else {
                ContextFlags |= CONTEXT_FLOATING_POINT;
            }

            //
            // Threads NPX state is not in the coprocessor.
            //

            Thread->NpxState = NPX_STATE_NOT_LOADED;
            Thread->Header.NpxIrql = PASSIVE_LEVEL;

        } else {
            NpxFrame->Cr0NpxState = CR0_EM;

            //
            // Threads NPX state is not in the coprocessor.
            // In the emulator case, do not set the CR0_EM bit as their
            // emulators may not want exceptions on FWAIT instructions.
            //

            Thread->NpxState = NPX_STATE_NOT_LOADED & ~CR0_MP;
        }

        //
        // Force debug registers off.  They won't work anyway from an
        // initial frame, debuggers must set a hard breakpoint in the target
        //

        ContextFrame2->ContextFlags &= ~CONTEXT_DEBUG_REGISTERS;

        //
        //  Space for arguments to KiThreadStartup.  Order is important,
        //  Since args are passed on stack through KiThreadStartup to
        //  PStartRoutine with PStartContext as an argument.
        //

        PUserContextFlag = (PULONG)TrFrame - 1;
        PStartContext = PUserContextFlag - 1;
        PStartRoutine = PStartContext - 1;
        PSystemRoutine = PStartRoutine - 1;

        SwitchFrame = (PKSWITCHFRAME)((PUCHAR)PSystemRoutine -
                                    sizeof(KSWITCHFRAME));

        //
        // Copy information from the specified context frame to the trap and
        // exception frames.
        //

        KeContextToKframes(TrFrame, NULL, ContextFrame2,
                           ContextFrame2->ContextFlags | ContextFlags,
                           UserMode);

        TrFrame->HardwareSegSs |= RPL_MASK;
        TrFrame->SegDs |= RPL_MASK;
        TrFrame->SegEs |= RPL_MASK;
        TrFrame->Dr7 = 0;

#if DBG

        TrFrame->DbgArgMark = 0xBADB0D00;

#endif

        //
        // Tell KiThreadStartup that a user context is present.
        //

        *PUserContextFlag = 1;


        //
        // Initialize the kernel mode ExceptionList pointer
        //

        TrFrame->ExceptionList = EXCEPTION_CHAIN_END;

        //
        // Initialize the saved previous processor mode.
        //

        TrFrame->PreviousPreviousMode = UserMode;

        //
        // Set the previous mode in thread object to user.
        //

        Thread->PreviousMode = UserMode;


    } else {

        //
        // Dummy floating save area.  Kernel threads don't have or use
        // the floating point - the dummy save area is make the stacks
        // consistent.
        //

        NpxFrame = (PFX_SAVE_AREA)(((ULONG)(Thread->InitialStack) -
                    sizeof(FX_SAVE_AREA)));

        //
        // Load up an initial NPX state.
        //
        RtlZeroMemory((PVOID)NpxFrame, sizeof(FX_SAVE_AREA));

        if (KeI386FxsrPresent == TRUE) {
            NpxFrame->U.FxArea.ControlWord = 0x27f;//like fpinit but 64bit mode
            NpxFrame->U.FxArea.MXCsr       = 0x1f80;// mask all the exceptions

        } else {
            NpxFrame->U.FnArea.ControlWord  = 0x27f;//like fpinit but 64bit mode
            NpxFrame->U.FnArea.TagWord      = 0xffff;
        }

        //
        // Threads NPX state is not in the coprocessor.
        //

        Thread->NpxState = NPX_STATE_NOT_LOADED;

        //
        //  Space for arguments to KiThreadStartup.
        //  Order of fields in the switchframe is important,
        //  Since args are passed on stack through KiThreadStartup to
        //  PStartRoutine with PStartContext as an argument.
        //

        PUserContextFlag = (PULONG)((ULONG)NpxFrame) - 1;

        PStartContext = PUserContextFlag - 1;
        PStartRoutine = PStartContext - 1;
        PSystemRoutine = PStartRoutine - 1;

        SwitchFrame = (PKSWITCHFRAME)((PUCHAR)PSystemRoutine -
                                        sizeof(KSWITCHFRAME));

        //
        // Tell KiThreadStartup that a user context is NOT present.
        //

        *PUserContextFlag = 0;


        //
        // Set the previous mode in thread object to kernel.
        //

        Thread->PreviousMode = KernelMode;
    }

    //
    //  Set up thread start parameters.
    //  (UserContextFlag set above)
    //

    *PStartContext = (ULONG)StartContext;
    *PStartRoutine = (ULONG)StartRoutine;
    *PSystemRoutine = (ULONG)SystemRoutine;

    //
    //  Set up switch frame.  Assume the thread doesn't use the 80387;
    //  if it ever does (and there is one), these flags will get reset.
    //  Each thread starts with these same flags set, regardless of
    //  whether the hardware exists or not.
    //

    SwitchFrame->RetAddr = (ULONG)KiThreadStartup;
    SwitchFrame->ApcBypassDisable = TRUE;
    SwitchFrame->ExceptionList = (ULONG)(EXCEPTION_CHAIN_END);

#if DBG

    //
    //  On checked builds add a check field so context swap can break
    //  early on bad context swaps (corrupted stacks for example).
    //  We place this below the stack pointer so the kernel debugger
    //  doesn't need knowledge of this.
    //

    ((PULONG)SwitchFrame)[-1] = (ULONG)(ULONG_PTR)Thread;

#endif

    //
    // Set the initial kernel stack pointer.
    //

    Thread->KernelStack = (PVOID)SwitchFrame;
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\lpc\lpccompl.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    lpccompl.c

Abstract:

    Local Inter-Process Communication (LPC) connection system services.

--*/

#include "lpcp.h"

//
//  Local procedure prototypes
//

VOID
LpcpPrepareToWakeClient (
    IN PETHREAD ClientThread
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,NtAcceptConnectPort)
#pragma alloc_text(PAGE,NtCompleteConnectPort)
#pragma alloc_text(PAGE,LpcpPrepareToWakeClient)
#endif


NTSTATUS
NtAcceptConnectPort (
    __out PHANDLE PortHandle,
    __in_opt PVOID PortContext,
    __in PPORT_MESSAGE ConnectionRequest,
    __in BOOLEAN AcceptConnection,
    __inout_opt PPORT_VIEW ServerView,
    __out_opt PREMOTE_PORT_VIEW ClientView
    )

/*++

Routine Description:

    A server process can accept or reject a client connection request
    using the NtAcceptConnectPort service.

    The ConnectionRequest parameter must specify a connection request
    returned by a previous call to the NtListenPort service.  This
    service will either complete the connection if the AcceptConnection
    parameter is TRUE, or reject the connection request if the
    AcceptConnection parameter is FALSE.

    In either case, the contents of the data portion of the connection
    request is the data to return to the caller of NtConnectPort.

    If the connection request is accepted, then two communication port
    objects will be created and connected together.  One will be
    inserted in the client process' handle table and returned to the
    client via the PortHandle parameter it specified on the
    NtConnectPort service.  The other will be inserted in the server
    process' handle table and returned via the PortHandle parameter
    specified on the NtCompleteConnectPort service.  In addition the
    two communication ports (client and server) will be linked together.

    If the connection request is accepted, and the ServerView parameter
    was specified, then the section handle is examined.  If it is valid,
    then the portion of the section described by the SectionOffset and
    ViewSize fields will be mapped into both the client and server
    process address spaces.  The address in server's address space will
    be returned in the ViewBase field.  The address in the client's
    address space will be returned in the ViewRemoteBase field.  The
    actual offset and size used to map the section will be returned in
    the SectionOffset and ViewSize fields.

    Communication port objects are temporary objects that have no names
    and cannot be inherited.  When either the client or server process
    calls the !f NtClose service for a communication port, the port will
    be deleted since there can never be more than one outstanding handle
    for each communication port.  The port object type specific delete
    procedure will then be invoked.  This delete procedure will examine
    the communication port, and if it is connected to another
    communication port, it will queue an LPC_PORT_CLOSED datagram to
    that port's message queue.  This will allow both the client and
    server processes to notice when a port becomes disconnected, either
    because of an explicit call to NtClose or an implicit call due to
    process termination.  In addition, the delete procedure will scan
    the message queue of the port being closed and for each message
    still in the queue, it will return an ERROR_PORT_CLOSED status to
    any thread that is waiting for a reply to the message.

Arguments:

    PortHandle - A pointer to a variable that will receive the server
        communication port object handle value.

    PortContext - An uninterpreted pointer that is stored in the
        server communication port.  This pointer is returned whenever
        a message is received for this port.

    ConnectionRequest - A pointer to a structure that describes the
        connection request being accepted or rejected:

        The ConnectionRequest structure

        ULONG Length - Specifies the size of this data structure in
            bytes.

        CLIENT_ID ClientId - Specifies a structure that contains the
            client identifier (CLIENT_ID) of the thread that sent the
            request.

        The ClientId Structure

            ULONG UniqueProcessId - A unique value for each process
                in the system.

            ULONG UniqueThreadId - A unique value for each thread in the
                system.

        ULONG MessageId - A unique value that identifies the connection
            request being completed.

        ULONG PortAttributes - This field has no meaning for this service.

        ULONG ClientViewSize - This field has no meaning for this service.

    AcceptConnection - Specifies a boolean value which indicates where
        the connection request is being accepted or rejected.  A value
        of TRUE means that the connection request is accepted and a
        server communication port handle will be created and connected
        to the client's communication port handle.  A value of FALSE
        means that the connection request is not accepted.

    ServerView - A pointer to a structure that specifies the section that
        the server process will use to send messages back to the client
        process connected to this port.

        The ServerView Structure

        ULONG Length - Specifies the size of this data structure in
            bytes.

        HANDLE SectionHandle - Specifies an open handle to a section
            object.

        ULONG SectionOffset - Specifies a field that will receive the
            actual offset, in bytes, from the start of the section.  The
            initial value of this parameter specifies the byte offset
            within the section that the client's view is based.  The
            value is rounded down to the next host page size boundary.

        ULONG ViewSize - Specifies the size of the view, in bytes.

        PVOID ViewBase - Specifies a field that will receive the base
            address of the port memory in the server's address space.

        PVOID ViewRemoteBase - Specifies a field that will receive
            the base address of the server port's memory in the client's
            address space.  Used to generate pointers that are
            meaningful to the client.

    ClientView - An optional pointer to a structure that will receive
        information about the client process' view in the server's
        address space.  The server process can use this information
        to validate pointers it receives from the client process.

        The ClientView Structure

        ULONG Length - Specifies the size of this data structure in
            bytes.

        PVOID ViewBase - Specifies a field that will receive the base
            address of the client port's memory in the server's address
            space.

        ULONG ViewSize - Specifies a field that will receive the
            size, in bytes, of the client's view in the server's address
            space.  If this field is zero, then client has no view in
            the server's address space.

Return Value:

    NTSTATUS - An appropriate status value.

--*/

{
    PLPCP_PORT_OBJECT ConnectionPort;
    PLPCP_PORT_OBJECT ServerPort;
    PLPCP_PORT_OBJECT ClientPort;
    PVOID ClientSectionToMap;
    HANDLE Handle;
    KPROCESSOR_MODE PreviousMode;
    NTSTATUS Status;
    ULONG ConnectionInfoLength;
    PLPCP_MESSAGE Msg;
    PLPCP_CONNECTION_MESSAGE ConnectMsg;
    PORT_MESSAGE CapturedReplyMessage;
    PVOID SectionToMap;
    LARGE_INTEGER SectionOffset;
    SIZE_T ViewSize;
    PEPROCESS ClientProcess;
    PETHREAD ClientThread;
    PORT_VIEW CapturedServerView;

    PAGED_CODE();

    //
    //  Get previous processor mode and probe output arguments if necessary.
    //

    PreviousMode = KeGetPreviousMode();

    if (PreviousMode != KernelMode) {

        try {

            ProbeForWriteHandle( PortHandle );

            ProbeForReadSmallStructure( ConnectionRequest,
                                        sizeof( *ConnectionRequest ),
                                        sizeof( ULONG ));

            CapturedReplyMessage = *ConnectionRequest;

            if (ARGUMENT_PRESENT( ServerView )) {

                CapturedServerView = ProbeAndReadStructure( ServerView, PORT_VIEW );

                if (CapturedServerView.Length != sizeof( *ServerView )) {

                    return STATUS_INVALID_PARAMETER;
                }

                ProbeForWriteSmallStructure( ServerView,
                                             sizeof( *ServerView ),
                                             sizeof( ULONG ));
            }

            if (ARGUMENT_PRESENT( ClientView )) {

                if (ProbeAndReadUlong( &ClientView->Length ) != sizeof( *ClientView )) {

                    return STATUS_INVALID_PARAMETER;
                }

                ProbeForWriteSmallStructure( ClientView,
                                             sizeof( *ClientView ),
                                             sizeof( ULONG ));
            }

        } except( EXCEPTION_EXECUTE_HANDLER ) {

            return GetExceptionCode();
        }

    } else {

        //
        //  Otherwise the previous mode is kernel mode
        //

        CapturedReplyMessage = *ConnectionRequest;

        if (ARGUMENT_PRESENT( ServerView )) {

            if (ServerView->Length != sizeof( *ServerView )) {

                return STATUS_INVALID_PARAMETER;
            }

            CapturedServerView = *ServerView;
        }

        if (ARGUMENT_PRESENT( ClientView )) {

            if (ClientView->Length != sizeof( *ClientView )) {

                return STATUS_INVALID_PARAMETER;
            }
        }
    }

    //
    //  Translate the ClientId from the connection request into a
    //  thread pointer.  This is a referenced pointer to keep the thread
    //  from evaporating out from under us.
    //

    Status = PsLookupProcessThreadByCid( &CapturedReplyMessage.ClientId,
                                         &ClientProcess,
                                         &ClientThread );

    if (!NT_SUCCESS( Status )) {

        return Status;
    }

    //
    //  Acquire the mutex that guards the LpcReplyMessage field of
    //  the thread and get the pointer to the message that the thread
    //  is waiting for a reply to.
    //

    LpcpAcquireLpcpLock();

    //
    //  See if the thread is waiting for a reply to the connection request
    //  specified on this call.  If not then a bogus connection request
    //  has been specified, so release the mutex, dereference the thread
    //  and return failure.
    //
    //  The check is that the client is waiting for a reply to a connection
    //  request and that the message id is both valid and lines up correctly
    //

    if (( LpcpGetThreadMessage( ClientThread ) == NULL ) ||
        (CapturedReplyMessage.MessageId == 0) ||
        (ClientThread->LpcReplyMessageId != CapturedReplyMessage.MessageId) ||
        ((LpcpGetThreadMessage(ClientThread)->Request.u2.s2.Type & ~LPC_KERNELMODE_MESSAGE) != LPC_CONNECTION_REQUEST)) {

        Msg = NULL;

    } else {

        //
        //  Remember the LPCP message from the thread
        //

        Msg = LpcpGetThreadMessage(ClientThread);

        //
        //  Get connection message immediately following the LPCP message
        //

        ConnectMsg = (PLPCP_CONNECTION_MESSAGE)(Msg + 1);

        //
        //  Remember the client port from the connection message
        //

        ClientPort = ConnectMsg->ClientPort;
        
        //
        //  Get a pointer to the connection port from the client port.
        //

        ConnectionPort = ClientPort->ConnectionPort;
        
        //
        //  Check if the server process accept the connection
        //
        
        if ( ConnectionPort->ServerProcess != PsGetCurrentProcess() ) {
            
            //
            //  Release the LPC mutex
            //
            
            LpcpReleaseLpcpLock();
            
            ObDereferenceObject( ClientProcess );
            ObDereferenceObject( ClientThread );

            return (STATUS_REPLY_MESSAGE_MISMATCH);
        }
        
        //
        //  Remove the LPC message from the thread
        //
                
        ClientThread->LpcReplyMessage = NULL;
        
        //
        //  Remove the client port from the connection message
        //

        ConnectMsg->ClientPort = NULL;

        //
        //  Clean up the rest of the client thread.  This cleanup use to be
        //  done unconditionally right before releasing the mutex however
        //  this causes trouble if our caller supplied a bad reply message
        //  and we clobber an arbitrary threads state
        //

        ClientThread->LpcReplyMessageId = 0;
    }

    //
    //  Release the mutex that guards the field.
    //

    LpcpReleaseLpcpLock();

    //
    //  Now if we did not get an LPCP message from a client thread then this
    //  isn't a good call and we'll dereference what we thought was the
    //  client thread/process and tell our caller their mistake
    //

    if ( !Msg ) {

        LpcpPrint(( "%s Attempted AcceptConnectPort to Thread %lx (%s)\n",
                    PsGetCurrentProcess()->ImageFileName,
                    ClientThread,
                    THREAD_TO_PROCESS( ClientThread )->ImageFileName ));
        LpcpPrint(( "failed.  MessageId == %u\n", CapturedReplyMessage.MessageId ));
        LpcpPrint(( "         Thread MessageId == %u\n", ClientThread->LpcReplyMessageId ));
        LpcpPrint(( "         Thread Msg == %x\n", ClientThread->LpcReplyMessage ));

        ObDereferenceObject( ClientProcess );
        ObDereferenceObject( ClientThread );

        return (STATUS_REPLY_MESSAGE_MISMATCH);
    }

    //
    //  At this point we have a good matching client for this accept connect
    //  call.
    //
    
    LpcpTrace(("Replying to Connect Msg %lx to Port %lx\n",
               Msg, ClientPort->ConnectionPort ));

    //
    //  Regardless of whether we are accepting or rejecting the connection,
    //  return the connection information to the waiting thread.
    //

    ConnectionInfoLength = CapturedReplyMessage.u1.s1.DataLength;

    if (ConnectionInfoLength > ConnectionPort->MaxConnectionInfoLength) {

        ConnectionInfoLength = ConnectionPort->MaxConnectionInfoLength;
    }

    Msg->Request.u1.s1.DataLength = (CSHORT)(sizeof( *ConnectMsg ) +
                                             ConnectionInfoLength);

    Msg->Request.u1.s1.TotalLength = (CSHORT)(sizeof( *Msg ) +
                                              Msg->Request.u1.s1.DataLength);

    Msg->Request.u2.s2.Type = LPC_REPLY;
    Msg->Request.u2.s2.DataInfoOffset = 0;
    Msg->Request.ClientId = CapturedReplyMessage.ClientId;
    Msg->Request.MessageId = CapturedReplyMessage.MessageId;
    Msg->Request.ClientViewSize = 0;

    try {

        RtlCopyMemory( ConnectMsg + 1,
                       (PCHAR)(ConnectionRequest + 1),
                       ConnectionInfoLength );

    } except( EXCEPTION_EXECUTE_HANDLER ) {

        Status = GetExceptionCode();
    }

    //
    //  Now it is time to process a positive accept request
    //

    ClientSectionToMap = NULL;

    if (AcceptConnection) {

        //
        //  Allocate and initialize a server communication port object.
        //  Communication ports have no names, can not be inherited and
        //  are process private handles.
        //

        Status = ObCreateObject( PreviousMode,
                                 LpcPortObjectType,
                                 NULL,
                                 PreviousMode,
                                 NULL,
                                 FIELD_OFFSET( LPCP_PORT_OBJECT, WaitEvent ),
                                 0,
                                 0,
                                 (PVOID *)&ServerPort );

        if (!NT_SUCCESS( Status )) {

            goto bailout;
        }

        RtlZeroMemory( ServerPort, FIELD_OFFSET( LPCP_PORT_OBJECT, WaitEvent ));

        ServerPort->PortContext = PortContext;
        ServerPort->Flags = SERVER_COMMUNICATION_PORT;

        InitializeListHead( &ServerPort->LpcReplyChainHead );
        InitializeListHead( &ServerPort->LpcDataInfoChainHead );

        //
        //  Connect the newly created server communication port to the
        //  connection port with a referenced pointer.  Prevents the
        //  connection port from going away until all of the communication
        //  ports have been closed.
        //

        ObReferenceObject( ConnectionPort );

        ServerPort->ConnectionPort = ConnectionPort;
        ServerPort->MaxMessageLength = ConnectionPort->MaxMessageLength;

        //
        //  Connect the client and server communication ports together
        //  with unreferenced pointers.  They are unreferenced so that
        //  the PortObjectType delete procedure will get called when a
        //  communication port is closed.  If this were not the case then
        //  we would need a special NtClosePort system service in order
        //  to tear down a pair of connected communication ports.
        //

        ServerPort->ConnectedPort = ClientPort;
        ClientPort->ConnectedPort = ServerPort;

        ServerPort->Creator = PsGetCurrentThread()->Cid;
        ClientPort->Creator = Msg->Request.ClientId;
        
        //
        //  If the client has allocated a port memory section that is mapped
        //  into the client's address space, then map a view of the same
        //  section for the server process to see.
        //

        LpcpAcquireLpcpLock();

        ClientSectionToMap = ConnectMsg->SectionToMap;
        ConnectMsg->SectionToMap = NULL;

        LpcpReleaseLpcpLock();

        if (ClientSectionToMap) {

            LARGE_INTEGER LargeSectionOffset;

            LargeSectionOffset.LowPart = ConnectMsg->ClientView.SectionOffset;
            LargeSectionOffset.HighPart = 0;

            Status = MmMapViewOfSection( ClientSectionToMap,
                                         PsGetCurrentProcess(),
                                         &ServerPort->ClientSectionBase,
                                         0,
                                         0,
                                         &LargeSectionOffset,
                                         &ConnectMsg->ClientView.ViewSize,
                                         ViewUnmap,
                                         0,
                                         PAGE_READWRITE );

            ConnectMsg->ClientView.SectionOffset = LargeSectionOffset.LowPart;

            if (NT_SUCCESS( Status )) {

                ConnectMsg->ClientView.ViewRemoteBase = ServerPort->ClientSectionBase;

                //
                //  The client section was mapped. We'll add an extra reference to 
                //  server process. This reference will be removed on port cleanup.
                //

                ServerPort->MappingProcess = PsGetCurrentProcess();

                ObReferenceObject( ServerPort->MappingProcess );

            } else {

                //
                //  At this point we're really going to drop all the way
                //  out to the label bailout: because everything else is
                //  protected with a test against Status.  But first we have
                //  to release the server port that we've just created
                //

                ObDereferenceObject( ServerPort );
            }
        }

        //
        //  If the server process has allocated a port memory section for
        //  send data to the client on call back requests, map two views
        //  of that section, the first for the server process and the
        //  second view for the client process.  Return the location of the
        //  server's view to the caller of this function.  Return the
        //  client's view to the client process via the reply to the
        //  connection request.
        //

        if (NT_SUCCESS( Status ) && ARGUMENT_PRESENT( ServerView )) {

            LARGE_INTEGER LargeSectionOffset;

            LargeSectionOffset.LowPart = CapturedServerView.SectionOffset;
            LargeSectionOffset.HighPart = 0;

            //
            //  Map in the section into the servers address space
            //

            //
            //  Does this call need to verify that the section handle
            //  is still valid.
            //

            Status = ObReferenceObjectByHandle( CapturedServerView.SectionHandle,
                                                SECTION_MAP_READ |
                                                SECTION_MAP_WRITE,
                                                MmSectionObjectType,
                                                PreviousMode,
                                                (PVOID *)&SectionToMap,
                                                NULL );

            if (NT_SUCCESS( Status )) {

                Status = MmMapViewOfSection( SectionToMap,
                                             PsGetCurrentProcess(),
                                             &ServerPort->ServerSectionBase,
                                             0,
                                             0,
                                             &LargeSectionOffset,
                                             &CapturedServerView.ViewSize,
                                             ViewUnmap,
                                             0,
                                             PAGE_READWRITE );

                if (NT_SUCCESS( Status )) {

                    //
                    //  The section was mapped into the server process. We'll add a
                    //  reference to the server process only if we didn't before.
                    //

                    if ( ServerPort->MappingProcess == NULL ) {

                        ServerPort->MappingProcess = PsGetCurrentProcess();
                        ObReferenceObject( ServerPort->MappingProcess );
                    }

                    CapturedServerView.SectionOffset = LargeSectionOffset.LowPart;

                    CapturedServerView.ViewBase = ServerPort->ServerSectionBase;


                    SectionOffset.LowPart = CapturedServerView.SectionOffset;
                    SectionOffset.HighPart = 0;

                    ViewSize = CapturedServerView.ViewSize;

                    Status = MmMapViewOfSection( SectionToMap,
                                                 ClientProcess,
                                                 &ClientPort->ServerSectionBase,
                                                 0,
                                                 0,
                                                 &SectionOffset,
                                                 &ViewSize,
                                                 ViewUnmap,
                                                 0,
                                                 PAGE_READWRITE );

                    if (NT_SUCCESS( Status )) {

                        //
                        //  The section was mapped into the client process. We'll add a
                        //  reference to the client process only we didn't before.
                        //  (we don't have also a client section)
                        //

                        if ( ClientPort->MappingProcess == NULL ) {

                            ClientPort->MappingProcess = ClientProcess;
                            ObReferenceObject( ClientProcess );
                        }

                        //
                        //  Let the server know where the client's view of the
                        //  section got mapped
                        //

                        CapturedServerView.ViewRemoteBase = ClientPort->ServerSectionBase;

                        //
                        //  Let the client know where the server's view of the
                        //  section got mapped
                        //

                        ConnectMsg->ServerView.ViewBase = ClientPort->ServerSectionBase;
                        ConnectMsg->ServerView.ViewSize = ViewSize;

                    } else {

                        ObDereferenceObject( ServerPort );
                    }

                } else {

                    ObDereferenceObject( ServerPort );
                }

                ObDereferenceObject( SectionToMap );

            } else {

                ObDereferenceObject( ServerPort );
            }
        }

        //
        //  Insert the server communication port object in specified object
        //  table.  Set port handle value if successful.  If not
        //  successful, then the port will have been dereferenced, which
        //  will cause it to be freed, after our delete procedure is
        //  called.  The delete procedure will undo the work done to
        //  initialize the port.
        //

        if (NT_SUCCESS( Status )) {

            //
            //  Add an extra reference to the object otherwise right when we
            //  create the handle a rogue caller might close and destroy the
            //  port.
            //

            ObReferenceObject( ServerPort );

            //
            //  Now add the handle
            //

            Status = ObInsertObject( ServerPort,
                                     NULL,
                                     PORT_ALL_ACCESS,
                                     0,
                                     (PVOID *)NULL,
                                     &Handle );

            if (NT_SUCCESS( Status )) {

                try {

                    if (ARGUMENT_PRESENT( ServerView )) {

                        *ServerView = CapturedServerView;
                    }

                    if (ARGUMENT_PRESENT( ClientView )) {

                        ClientView->ViewBase = ConnectMsg->ClientView.ViewRemoteBase;
                        ClientView->ViewSize = ConnectMsg->ClientView.ViewSize;
                    }

                    *PortHandle = Handle;

                    if (!ARGUMENT_PRESENT( PortContext )) {

                        ServerPort->PortContext = Handle;
                    }

                    ServerPort->ClientThread = ClientThread;

                    LpcpAcquireLpcpLock();
                    ClientThread->LpcReplyMessage = Msg;
                    LpcpReleaseLpcpLock();

                    ClientThread = NULL;

                } except( EXCEPTION_EXECUTE_HANDLER ) {

                    NtClose( Handle );
                    Status = GetExceptionCode();
                }
            }

            //
            //  Now we can remove the extra object reference
            //

            ObDereferenceObject( ServerPort );
        }

    } else {

        //
        //  Otherwise the server has not accepted the connection request
        //

        LpcpPrint(( "Refusing connection from %x.%x\n",
                    Msg->Request.ClientId.UniqueProcess,
                    Msg->Request.ClientId.UniqueThread ));
    }

bailout:

    if ( ClientSectionToMap ) {

        ObDereferenceObject( ClientSectionToMap );
    }

    //
    //  If the client is not null then this is an error condition and we need
    //  to cleanup and wake the client thread.  In success cases the client
    //  thread is woken up with a call to Complete Connect Request
    //

    if (ClientThread != NULL) {

        LpcpAcquireLpcpLock();

        ClientThread->LpcReplyMessage = Msg;

        if (AcceptConnection) {

            LpcpPrint(( "LPC: Failing AcceptConnection with Status == %x\n", Status ));
        }

        LpcpPrepareToWakeClient( ClientThread );

        LpcpReleaseLpcpLock();

        //
        //  Wake up the thread that is waiting for an answer to its connection
        //  request inside of NtConnectPort.
        //

        KeReleaseSemaphore( &ClientThread->LpcReplySemaphore,
                            0,
                            1L,
                            FALSE );

        //
        //  Dereference client thread and return the system service status.
        //

        ObDereferenceObject( ClientThread );
    }

    if (ClientPort) {

        ObDereferenceObject( ClientPort );
    }

    ObDereferenceObject( ClientProcess );

    //
    //  And return to our caller
    //

    return Status;
}


NTSTATUS
NtCompleteConnectPort (
    __in HANDLE PortHandle
    )

/*++

Routine Description:

    This routine is called by the server after it calls NtAcceptConnectPort to
    wake up the client thread.  Between calling NtAcceptConnectPort and
    NtCompleteConnectPort the server can do whatever work is necessary before
    waking up the client

Arguments:

    PortHandle - Supplies a handle to the server communication port

Return Value:

    NTSTATUS - An appropriate status value.

--*/

{
    PLPCP_PORT_OBJECT PortObject;
    KPROCESSOR_MODE PreviousMode;
    NTSTATUS Status;
    PETHREAD ClientThread;

    PAGED_CODE();

    //
    //  Get previous processor mode
    //

    PreviousMode = KeGetPreviousMode();

    //
    //  Reference the port object by handle
    //

    Status = LpcpReferencePortObject( PortHandle,
                                      0,
                                      PreviousMode,
                                      &PortObject );

    if (!NT_SUCCESS( Status )) {

        return Status;
    }

    //
    //  Error if a port type is invalid.
    //

    if ((PortObject->Flags & PORT_TYPE) != SERVER_COMMUNICATION_PORT) {

        ObDereferenceObject( PortObject );

        return STATUS_INVALID_PORT_HANDLE;
    }

    //
    //  Under the LPC lock we need to check for a client thread and if there
    //  is one we'll remember and remove the client thread, and then prepare
    //  to wake the client
    //

    LpcpAcquireLpcpLock();

    if (PortObject->ClientThread == NULL) {

        LpcpReleaseLpcpLock();

        ObDereferenceObject( PortObject );

        return STATUS_INVALID_PARAMETER;
    }

    ClientThread = PortObject->ClientThread;

    //
    //  Double check that the thread is still waiting for a reply message
    //

    if (LpcpGetThreadMessage(ClientThread) == NULL) {

        LpcpReleaseLpcpLock();

        ObDereferenceObject( PortObject );
        //
        // At this point the client has already been woken. We will get a client died message
        //
        return STATUS_SUCCESS;
    }

    //
    //  The check needs to ensure that the client thread is really on the
    //  reply chain for the server's connection port.  This is a quick and
    //  dirty fix for NT 5.0.  We zoom down the connection port lpc reply
    //  chain looking for an entry that contains the client threads.  If
    //  we find a match it's okay if we don't it's bad.
    //

    if (PortObject->ConnectionPort) {
        
        PLIST_ENTRY Entry;

        for (Entry = PortObject->ConnectionPort->LpcReplyChainHead.Flink;
             Entry != (PLIST_ENTRY)(&PortObject->ConnectionPort->LpcReplyChainHead.Flink);
             Entry = Entry->Flink) {

            if (Entry == ((PLIST_ENTRY)(&ClientThread->LpcReplyChain.Flink))) {

                break;
            }
        }

        if (Entry != ((PLIST_ENTRY)(&ClientThread->LpcReplyChain.Flink))) {

            LpcpReleaseLpcpLock();

            ObDereferenceObject( PortObject );

            //
            // At this point the client has already been woken. We will get a client died message
            //
            return STATUS_SUCCESS;
        }
    }

    //
    //  Now do the wakeup
    //

    PortObject->ClientThread = NULL;

    LpcpPrepareToWakeClient( ClientThread );

    LpcpReleaseLpcpLock();

    //
    //  Wake up the thread that is waiting for an answer to its connection
    //  request inside of NtConnectPort.
    //

    KeReleaseSemaphore( &ClientThread->LpcReplySemaphore,
                        0,
                        1L,
                        FALSE );

    //
    //  Dereference client thread
    //

    ObDereferenceObject( ClientThread );
    ObDereferenceObject( PortObject );

    //
    //  And return to our caller
    //

    return Status;
}


//
//  Local support routine
//

VOID
LpcpPrepareToWakeClient (
    IN PETHREAD ClientThread
    )

/*++

Routine Description:

    This routine is used to prepare the client thread to receive a reply to
    its connection request

Arguments:

    ClientThread - Specifies the thread we are preparing to wake up

Return Value:

    None.

--*/

{
    PAGED_CODE();

    //
    //  Remove the thread from the rundown list the connection port as we are
    //  sending a reply.  The operation only needs to take place if the
    //  thread isn't exiting and it's in the lpc reply chain for a connection
    //  port
    //

    if ((!ClientThread->LpcExitThreadCalled) &&
        (!IsListEmpty( &ClientThread->LpcReplyChain ))) {

        RemoveEntryList( &ClientThread->LpcReplyChain );
        InitializeListHead( &ClientThread->LpcReplyChain );
    }

    //
    //  And return to our caller
    //

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\lpc\lpcclose.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    lpcclose.c

Abstract:

    Local Inter-Process Communication close procedures that are called when
    a connection port or a communications port is closed.

--*/

#include "lpcp.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,LpcpClosePort)
#pragma alloc_text(PAGE,LpcpDeletePort)
#pragma alloc_text(PAGE,LpcExitThread)
#endif


VOID
LpcpClosePort (
    IN PEPROCESS Process OPTIONAL,
    IN PVOID Object,
    IN ACCESS_MASK GrantedAccess,
    IN ULONG_PTR ProcessHandleCount,
    IN ULONG_PTR SystemHandleCount
    )

/*++

Routine Description:

    This routine is the callback used for closing a port object.

Arguments:

    Process - Supplies an optional pointer to the process whose port is being
        closed

    Object - Supplies a pointer to the port object being closed

    GrantedAccess - Supplies the access granted to the handle closing port
        object

    ProcessHandleCount - Supplies the number of process handles remaining to
        the object

    SystemHandleCount - Supplies the number of system handles remaining to
        the object

Return Value:

    None.

--*/

{
    //
    //  Translate the object to what it really is, an LPCP port object
    //

    PLPCP_PORT_OBJECT Port = Object;

    UNREFERENCED_PARAMETER (Process);
    UNREFERENCED_PARAMETER (GrantedAccess);
    UNREFERENCED_PARAMETER (ProcessHandleCount);

    //
    //  We only have work to do if the object is a server communication port
    //

    if ( (Port->Flags & PORT_TYPE) == SERVER_CONNECTION_PORT ) {

        //
        //  If this is a server communication port without any system handles
        //  then we can completely destroy the communication queue for the
        //  port
        //

        if ( SystemHandleCount == 0 ) {

            LpcpDestroyPortQueue( Port, TRUE );

        //
        //  If there is only one system handle left then we'll reset the
        //  communication queue for the port
        //

        } else if ( SystemHandleCount == 1 ) {

            LpcpDestroyPortQueue( Port, FALSE );
        }

        //
        //  Otherwise we do nothing
        //
    }

    return;
}


VOID
LpcpDeletePort (
    IN PVOID Object
    )

/*++

Routine Description:

    This routine is the callback used for deleting a port object.

Arguments:

    Object - Supplies a pointer to the port object being deleted

Return Value:

    None.

--*/

{
    PETHREAD CurrentThread;
    PLPCP_PORT_OBJECT Port = Object;
    PLPCP_PORT_OBJECT ConnectionPort;
    LPC_CLIENT_DIED_MSG ClientPortClosedDatagram;
    PLPCP_MESSAGE Msg;
    PLIST_ENTRY Head, Next;
    HANDLE CurrentProcessId;
    NTSTATUS Status;
    LARGE_INTEGER RetryInterval = {(ULONG)(-10 * 1000 * 100), -1}; // 100 milliseconds

    PAGED_CODE();

    CurrentThread = PsGetCurrentThread ();

    //
    //  If the port is a server communication port then make sure that if
    //  there is a dangling client thread that we get rid of it.  This
    //  handles the case of someone calling NtAcceptConnectPort and not
    //  calling NtCompleteConnectPort
    //

    if ((Port->Flags & PORT_TYPE) == SERVER_COMMUNICATION_PORT) {

        PETHREAD ClientThread;

        LpcpAcquireLpcpLockByThread(CurrentThread);

        if ((ClientThread = Port->ClientThread) != NULL) {

            Port->ClientThread = NULL;

            LpcpReleaseLpcpLock();

            ObDereferenceObject( ClientThread );

        } else {

            LpcpReleaseLpcpLock();
        }
    }

    //
    //  Send an LPC_PORT_CLOSED datagram to whoever is connected
    //  to this port so they know they are no longer connected.
    //

    if ((Port->Flags & PORT_TYPE) == CLIENT_COMMUNICATION_PORT) {

        ClientPortClosedDatagram.PortMsg.u1.s1.TotalLength = sizeof( ClientPortClosedDatagram );
        ClientPortClosedDatagram.PortMsg.u1.s1.DataLength = sizeof( ClientPortClosedDatagram.CreateTime );

        ClientPortClosedDatagram.PortMsg.u2.s2.Type = LPC_PORT_CLOSED;
        ClientPortClosedDatagram.PortMsg.u2.s2.DataInfoOffset = 0;

        ClientPortClosedDatagram.CreateTime = PsGetCurrentProcess()->CreateTime;

        Status = LpcRequestPort( Port, (PPORT_MESSAGE)&ClientPortClosedDatagram );

        while (Status == STATUS_NO_MEMORY) {

            KeDelayExecutionThread(KernelMode, FALSE, &RetryInterval);

            Status = LpcRequestPort( Port, (PPORT_MESSAGE)&ClientPortClosedDatagram );
        }
    }

    //
    //  If connected, disconnect the port, and then scan the message queue
    //  for this port and dereference any messages in the queue.
    //

    LpcpDestroyPortQueue( Port, TRUE );

    //
    //  If we had mapped sections into the server or client communication ports,
    //  we need to unmap them in the context of that process.
    //

    if ( (Port->ClientSectionBase != NULL) ||
         (Port->ServerSectionBase != NULL) ) {

        //
        //  If the client has a port memory view, then unmap it
        //

        if (Port->ClientSectionBase != NULL) {

            MmUnmapViewOfSection( Port->MappingProcess,
                                  Port->ClientSectionBase );

        }

        //
        //  If the server has a port memory view, then unmap it
        //

        if (Port->ServerSectionBase != NULL) {

            MmUnmapViewOfSection( Port->MappingProcess,
                                  Port->ServerSectionBase  );

        }

        //
        //  Removing the reference added while mapping the section
        //

        ObDereferenceObject( Port->MappingProcess );

        Port->MappingProcess = NULL;
    }

    //
    //  Dereference the pointer to the connection port if it is not
    //  this port.
    //

    LpcpAcquireLpcpLockByThread(CurrentThread);

    ConnectionPort = Port->ConnectionPort;

    if (ConnectionPort) {

        CurrentProcessId = CurrentThread->Cid.UniqueProcess;

        Head = &ConnectionPort->LpcDataInfoChainHead;
        Next = Head->Flink;

        while (Next != Head) {

            Msg = CONTAINING_RECORD( Next, LPCP_MESSAGE, Entry );
            Next = Next->Flink;
            
            if (Port == ConnectionPort) {

                //
                //  If the Connection port is going away free all queued messages
                //

                RemoveEntryList( &Msg->Entry );
                InitializeListHead( &Msg->Entry );

                LpcpFreeToPortZone( Msg, LPCP_MUTEX_OWNED );

                //
                //  In LpcpFreeToPortZone the LPC lock is released and reacquired.
                //  Another thread might free the LPC message captured above
                //  in Next. We need to restart the search at the list head.
                //

                Next = Head->Flink;

            } else if ((Msg->Request.ClientId.UniqueProcess == CurrentProcessId)
                    &&
                ((Msg->SenderPort == Port) 
                        || 
                 (Msg->SenderPort == Port->ConnectedPort) 
                        || 
                 (Msg->SenderPort == ConnectionPort))) {

                //
                //  Test whether the message come from the same port and process
                //

                LpcpTrace(( "%s Freeing DataInfo Message %lx (%u.%u)  Port: %lx\n",
                            PsGetCurrentProcess()->ImageFileName,
                            Msg,
                            Msg->Request.MessageId,
                            Msg->Request.CallbackId,
                            ConnectionPort ));

                RemoveEntryList( &Msg->Entry );
                InitializeListHead( &Msg->Entry );

                LpcpFreeToPortZone( Msg, LPCP_MUTEX_OWNED );

                //
                //  In LpcpFreeToPortZone the LPC lock is released and reacquired.
                //  Another thread might free the LPC message captured above
                //  in Next. We need to restart the search at the list head.
                //

                Next = Head->Flink;
            }
        }

        LpcpReleaseLpcpLock();

        if (ConnectionPort != Port) {

            ObDereferenceObject( ConnectionPort );
        }

    } else {

        LpcpReleaseLpcpLock();
    }

    if (((Port->Flags & PORT_TYPE) == SERVER_CONNECTION_PORT) &&
        (ConnectionPort->ServerProcess != NULL)) {

        ObDereferenceObject( ConnectionPort->ServerProcess );

        ConnectionPort->ServerProcess = NULL;
    }

    //
    //  Free any static client security context
    //

    LpcpFreePortClientSecurity( Port );

    //
    //  And return to our caller
    //

    return;
}


VOID
LpcExitThread (
    PETHREAD Thread
    )

/*++

Routine Description:

    This routine is called whenever a thread is exiting and need to cleanup the
    lpc port for the thread.

Arguments:

    Thread - Supplies the thread being terminated

Return Value:

    None.

--*/

{
    PLPCP_MESSAGE Msg;

    //
    //  Acquire the mutex that protects the LpcReplyMessage field of
    //  the thread.  Zero the field so nobody else tries to process it
    //  when we release the lock.
    //

    ASSERT (Thread == PsGetCurrentThread());

    LpcpAcquireLpcpLockByThread(Thread);

    if (!IsListEmpty( &Thread->LpcReplyChain )) {

        RemoveEntryList( &Thread->LpcReplyChain );
    }

    //
    //  Indicate that this thread is exiting
    //

    Thread->LpcExitThreadCalled = TRUE;
    Thread->LpcReplyMessageId = 0;

    //
    //  If we need to reply to a message then if the thread that we need to reply
    //  to is still around we want to dereference the thread and free the message
    //

    Msg = LpcpGetThreadMessage(Thread);

    if (Msg != NULL) {

        Thread->LpcReplyMessage = NULL;

        if (Msg->RepliedToThread != NULL) {

            ObDereferenceObject( Msg->RepliedToThread );

            Msg->RepliedToThread = NULL;
        }

        LpcpTrace(( "Cleanup Msg %lx (%d) for Thread %lx allocated\n", Msg, IsListEmpty( &Msg->Entry ), Thread ));

        LpcpFreeToPortZone( Msg, LPCP_MUTEX_OWNED | LPCP_MUTEX_RELEASE_ON_RETURN );
    }
    else {

        //
        //  Free the global lpc mutex.
        //

        LpcpReleaseLpcpLock();
    }

    //
    //  And return to our caller
    //

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\lpc\lpcconn.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    lpcconn.c

Abstract:

    Local Inter-Process Communication (LPC) connection system services.

--*/

#include "lpcp.h"

//
//  Local procedure prototypes
//

PVOID
LpcpFreeConMsg(
    IN PLPCP_MESSAGE *Msg,
    PLPCP_CONNECTION_MESSAGE *ConnectMsg,
    IN PETHREAD CurrentThread
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,NtConnectPort)
#pragma alloc_text(PAGE,NtSecureConnectPort)
#pragma alloc_text(PAGE,LpcpFreeConMsg)
#endif


NTSYSAPI
NTSTATUS
NTAPI
NtConnectPort (
    __out PHANDLE PortHandle,
    __in PUNICODE_STRING PortName,
    __in PSECURITY_QUALITY_OF_SERVICE SecurityQos,
    __inout_opt PPORT_VIEW ClientView,
    __inout_opt PREMOTE_PORT_VIEW ServerView,
    __out_opt PULONG MaxMessageLength,
    __inout_opt PVOID ConnectionInformation,
    __inout_opt PULONG ConnectionInformationLength
    )

/*++

Routine Description:

    See NtSecureConnectPort

Arguments:

    See NtSecureConnectPort

Return Value:

    NTSTATUS - An appropriate status value

--*/

{
    return NtSecureConnectPort( PortHandle,
                                PortName,
                                SecurityQos,
                                ClientView,
                                NULL,
                                ServerView,
                                MaxMessageLength,
                                ConnectionInformation,
                                ConnectionInformationLength );
}


NTSTATUS
NtSecureConnectPort (
    __out PHANDLE PortHandle,
    __in PUNICODE_STRING PortName,
    __in PSECURITY_QUALITY_OF_SERVICE SecurityQos,
    __inout_opt PPORT_VIEW ClientView,
    __in_opt PSID RequiredServerSid,
    __inout_opt PREMOTE_PORT_VIEW ServerView,
    __out_opt PULONG MaxMessageLength,
    __inout_opt PVOID ConnectionInformation,
    __inout_opt PULONG ConnectionInformationLength
    )

/*++

Routine Description:

    A client process can connect to a server process by name using the
    NtConnectPort service.

    The PortName parameter specifies the name of the server port to
    connect to.  It must correspond to an object name specified on a
    call to NtCreatePort.  The service sends a connection request to the
    server thread that is listening for them with the NtListenPort
    service.  The client thread then blocks until a server thread
    receives the connection request and responds with a call to the
    NtCompleteConnectPort service.  The server thread receives the ID of
    the client thread, along with any information passed via the
    ConnectionInformation parameter.  The server thread then decides to
    either accept or reject the connection request.

    The server communicates the acceptance or rejection with the
    NtCompleteConnectPort service.  The server can pass back data to the
    client about the acceptance or rejection via the
    ConnectionInformation data block.

    If the server accepts the connection request, then the client
    receives a communication port object in the location pointed to by
    the PortHandle parameter.  This object handle has no name associated
    with it and is private to the client process (i.e.  it cannot be
    inherited by a child process).  The client uses the handle to send
    and receive messages to/from the server process using the
    NtRequestWaitReplyPort service.

    If the ClientView parameter was specified, then the section handle
    is examined.  If it is a valid section handle, then the portion of
    the section described by the SectionOffset and ViewSize fields will
    be mapped into both the client and server process' address spaces.
    The address in client address space will be returned in the ViewBase
    field.  The address in the server address space will be returned in
    the ViewRemoteBase field.  The actual offset and size used to map
    the section will be returned in the SectionOffset and ViewSize
    fields.

    If the server rejects the connection request, then no communication
    port object handle is returned, and the return status indicates an
    error occurred.  The server may optionally return information in the
    ConnectionInformation data block giving the reason the connection
    requests was rejected.

    If the PortName does not exist, or the client process does not have
    sufficient access rights then the returned status will indicate that
    the port was not found.

Arguments:

    PortHandle - A pointer to a variable that will receive the client
        communication port object handle value.

    PortName - A pointer to a port name string.  The form of the name
        is [\name...\name]\port_name.

    SecurityQos - A pointer to security quality of service information
        to be applied to the server on the client's behalf.

    ClientView - An optional pointer to a structure that specifies the
        section that all client threads will use to send messages to the
        server.

    ClientView Structure

        ULONG Length - Specifies the size of this data structure in
            bytes.

        HANDLE SectionHandle - Specifies an open handle to a section
            object.

        ULONG SectionOffset - Specifies a field that will receive the
            actual offset, in bytes, from the start of the section.  The
            initial value of this parameter specifies the byte offset
            within the section that the client's view is based.  The
            value is rounded down to the next host page size boundary.

        ULONG ViewSize - Specifies a field that will receive the
            actual size, in bytes, of the view.  If the value of this
            parameter is zero, then the client's view of the section
            will be mapped starting at the specified section offset and
            continuing to the end of the section.  Otherwise, the
            initial value of this parameter specifies the size, in
            bytes, of the client's view and is rounded up to the next
            host page size boundary.

        PVOID ViewBase - Specifies a field that will receive the base
            address of the section in the client's address space.

        PVOID ViewRemoteBase - Specifies a field that will receive
            the base address of the client's section in the server's
            address space.  Used to generate pointers that are
            meaningful to the server.

    RequiredServerSid - Optionally specifies the SID that we expect the
        server side of the port to possess.  If not specified then we'll
        connect to any server SID.

    ServerView - An optional pointer to a structure that will receive
        information about the server process' view in the client's
        address space.  The client process can use this information
        to validate pointers it receives from the server process.

        ServerView Structure

        ULONG Length - Specifies the size of this data structure in
            bytes.

        PVOID ViewBase - Specifies a field that will receive the base
            address of the server's section in the client's address
            space.

        ULONG ViewSize - Specifies a field that will receive the
            size, in bytes, of the server's view in the client's address
            space.  If this field is zero, then server has no view in
            the client's address space.

    MaxMessageLength - An optional pointer to a variable that will
        receive maximum length of messages that can be sent to the
        server.  The value of this parameter will not exceed
        MAX_PORTMSG_LENGTH bytes.

    ConnectionInformation - An optional pointer to uninterpreted data.
        This data is intended for clients to pass package, version and
        protocol identification information to the server to allow the
        server to determine if it can satisfy the client before
        accepting the connection.  Upon return to the client, the
        ConnectionInformation data block contains any information passed
        back from the server by its call to the NtCompleteConnectPort
        service.  The output data overwrites the input data.

    ConnectionInformationLength - Pointer to the length of the
        ConnectionInformation data block.  The output value is the
        length of the data stored in the ConnectionInformation data
        block by the server's call to the NtCompleteConnectPort
        service.  This parameter is OPTIONAL only if the
        ConnectionInformation parameter is null, otherwise it is
        required.

Return Value:

    NTSTATUS - An appropriate status value.

--*/

{
    PLPCP_PORT_OBJECT ConnectionPort;
    PLPCP_PORT_OBJECT ClientPort;
    HANDLE Handle;
    KPROCESSOR_MODE PreviousMode;
    NTSTATUS Status;
    ULONG ConnectionInfoLength;
    PVOID SectionToMap;
    PLPCP_MESSAGE Msg;
    PLPCP_CONNECTION_MESSAGE ConnectMsg;
    PEPROCESS CurrentProcess;
    PETHREAD CurrentThread = PsGetCurrentThread();
    LARGE_INTEGER SectionOffset;
    PORT_VIEW CapturedClientView;
    SECURITY_QUALITY_OF_SERVICE CapturedQos;
    PSID CapturedRequiredServerSid;

    PAGED_CODE();

    //
    //  Get previous processor mode and probe input and output arguments if
    //  necessary.
    //

    PreviousMode = KeGetPreviousMode();
    ConnectionInfoLength = 0;

    if (PreviousMode != KernelMode) {

        try {

            ProbeForWriteHandle( PortHandle );

            if (ARGUMENT_PRESENT( ClientView )) {

                CapturedClientView = ProbeAndReadStructure( ClientView, PORT_VIEW );

                if (CapturedClientView.Length != sizeof( *ClientView )) {

                    return( STATUS_INVALID_PARAMETER );
                }

                ProbeForWriteSmallStructure( ClientView,
                                             sizeof( *ClientView ),
                                             sizeof( ULONG ));
            }

            if (ARGUMENT_PRESENT( ServerView )) {

                if (ProbeAndReadUlong( &ServerView->Length ) != sizeof( *ServerView )) {

                    return( STATUS_INVALID_PARAMETER );
                }

                ProbeForWriteSmallStructure( ServerView,
                                             sizeof( *ServerView ),
                                             sizeof( ULONG ));
            }

            if (ARGUMENT_PRESENT( MaxMessageLength )) {

                ProbeForWriteUlong( MaxMessageLength );
            }

            if (ARGUMENT_PRESENT( ConnectionInformationLength )) {

                ConnectionInfoLength = ProbeAndReadUlong( ConnectionInformationLength );
                ProbeForWriteUlong( ConnectionInformationLength );
            }

            if (ARGUMENT_PRESENT( ConnectionInformation )) {

                ProbeForWrite( ConnectionInformation,
                               ConnectionInfoLength,
                               sizeof( UCHAR ));
            }

            CapturedQos = ProbeAndReadStructure( SecurityQos, SECURITY_QUALITY_OF_SERVICE );

            CapturedRequiredServerSid = RequiredServerSid;

            if (ARGUMENT_PRESENT( RequiredServerSid )) {

                Status = SeCaptureSid( RequiredServerSid,
                                       PreviousMode,
                                       NULL,
                                       0,
                                       PagedPool,
                                       TRUE,
                                       &CapturedRequiredServerSid );

                if (!NT_SUCCESS(Status)) {

                    return Status;
                }
            }

        } except( EXCEPTION_EXECUTE_HANDLER ) {

            return( GetExceptionCode() );
        }

    //
    //  Otherwise this is a kernel mode operation
    //

    } else {

        if (ARGUMENT_PRESENT( ClientView )) {

            if (ClientView->Length != sizeof( *ClientView )) {

                return( STATUS_INVALID_PARAMETER );
            }

            CapturedClientView = *ClientView;
        }

        if (ARGUMENT_PRESENT( ServerView )) {

            if (ServerView->Length != sizeof( *ServerView )) {

                return( STATUS_INVALID_PARAMETER );
            }
        }

        if (ARGUMENT_PRESENT( ConnectionInformationLength )) {

            ConnectionInfoLength = *ConnectionInformationLength;
        }

        CapturedQos = *SecurityQos;
        CapturedRequiredServerSid = RequiredServerSid;
    }

    //
    //  Reference the connection port object by name.  Return status if
    //  unsuccessful.
    //

    Status = ObReferenceObjectByName( PortName,
                                      0,
                                      NULL,
                                      PORT_CONNECT,
                                      LpcPortObjectType,
                                      PreviousMode,
                                      NULL,
                                      (PVOID *)&ConnectionPort );

    //
    //  If the port type object didn't work then try for a waitable port type
    //  object
    //

    if ( Status == STATUS_OBJECT_TYPE_MISMATCH ) {

        Status = ObReferenceObjectByName( PortName,
                                          0,
                                          NULL,
                                          PORT_CONNECT,
                                          LpcWaitablePortObjectType,
                                          PreviousMode,
                                          NULL,
                                          (PVOID *)&ConnectionPort );
    }

    //
    //  We can't locate the name so release the sid if we captured one and
    //  return error status back to our caller
    //

    if (!NT_SUCCESS( Status )) {

        if (CapturedRequiredServerSid != RequiredServerSid) {

            SeReleaseSid( CapturedRequiredServerSid, PreviousMode, TRUE);
        }

        return Status;
    }

    LpcpTrace(("Connecting to port %wZ\n", PortName ));

    //
    //  Error if user didn't give us a server communication port
    //

    if ((ConnectionPort->Flags & PORT_TYPE) != SERVER_CONNECTION_PORT) {

        ObDereferenceObject( ConnectionPort );

        if (CapturedRequiredServerSid != RequiredServerSid) {

            SeReleaseSid( CapturedRequiredServerSid, PreviousMode, TRUE);
        }

        return STATUS_INVALID_PORT_HANDLE;
    }

    //
    //  If this is NtSecureConnectPort, validated the required SID against
    //  the SID of the server process.  Fail if not equal.
    //

    if (ARGUMENT_PRESENT( RequiredServerSid )) {

        PTOKEN_USER TokenInfo;

        if (ConnectionPort->ServerProcess != NULL) {

            PACCESS_TOKEN Token ;

            Token = PsReferencePrimaryToken( ConnectionPort->ServerProcess );

    
            Status = SeQueryInformationToken( Token,
                                              TokenUser,
                                              &TokenInfo );
            
            PsDereferencePrimaryTokenEx( ConnectionPort->ServerProcess, Token );

            if (NT_SUCCESS( Status )) {

                if (!RtlEqualSid( CapturedRequiredServerSid, TokenInfo->User.Sid )) {

                    Status = STATUS_SERVER_SID_MISMATCH;
                }

                ExFreePool( TokenInfo );
            }

        } else {

            Status = STATUS_SERVER_SID_MISMATCH;
        }

        //
        //  We are all done with the required server sid if specified so
        //  now release one if we had to capture it
        //

        if (CapturedRequiredServerSid != RequiredServerSid) {

            SeReleaseSid( CapturedRequiredServerSid, PreviousMode, TRUE);
        }

        //
        //  If the se information token query didn't work then return the
        //  error to our caller
        //

        if (!NT_SUCCESS( Status )) {

            ObDereferenceObject( ConnectionPort );

            return Status;
        }
    }

    //
    //  Allocate and initialize a client communication port object.  Give
    //  the port a request message queue for lost reply datagrams.  If
    //  unable to initialize the port, then deference the port object which
    //  will cause it to be deleted and return the system service status.
    //

    Status = ObCreateObject( PreviousMode,
                             LpcPortObjectType,
                             NULL,
                             PreviousMode,
                             NULL,
                             FIELD_OFFSET( LPCP_PORT_OBJECT, WaitEvent ),
                             0,
                             0,
                             (PVOID *)&ClientPort );

    if (!NT_SUCCESS( Status )) {

        ObDereferenceObject( ConnectionPort );

        return Status;
    }

    //
    //  Note, that from here on, none of the error paths dereference the
    //  connection port pointer, just the newly created client port pointer.
    //  The port delete routine will get called when the client port is
    //  deleted and it will dereference the connection port pointer stored
    //  in the client port object.
    //

    //
    //  Initialize the client port object to zeros and then fill in the
    //  fields.
    //

    RtlZeroMemory( ClientPort, FIELD_OFFSET( LPCP_PORT_OBJECT, WaitEvent ));

    ClientPort->Flags = CLIENT_COMMUNICATION_PORT;
    ClientPort->ConnectionPort = ConnectionPort;
    ClientPort->MaxMessageLength = ConnectionPort->MaxMessageLength;
    ClientPort->SecurityQos = CapturedQos;

    InitializeListHead( &ClientPort->LpcReplyChainHead );
    InitializeListHead( &ClientPort->LpcDataInfoChainHead );

    //
    //  Set the security tracking mode, and initialize the client security
    //  context if it is static tracking.
    //

    if (CapturedQos.ContextTrackingMode == SECURITY_DYNAMIC_TRACKING) {

        ClientPort->Flags |= PORT_DYNAMIC_SECURITY;

    } else {

        Status = SeCreateClientSecurity( CurrentThread,
                                         &CapturedQos,
                                         FALSE,
                                         &ClientPort->StaticSecurity );

        if (!NT_SUCCESS( Status )) {

            ObDereferenceObject( ClientPort );

            return Status;
        }
    }

    //
    //  Client communication ports get a request message queue for lost
    //  replies.
    //

    Status = LpcpInitializePortQueue( ClientPort );

    if (!NT_SUCCESS( Status )) {

        ObDereferenceObject( ClientPort );

        return Status;
    }

    //
    //  If client has allocated a port memory section, then map a view of
    //  that section into the client's address space.  Also reference the
    //  section object so we can pass a pointer to the section object in
    //  connection request message.  If the server accepts the connection,
    //  then it will map a corresponding view of the section in the server's
    //  address space, using the referenced pointer passed in the connection
    //  request message.
    //

    if (ARGUMENT_PRESENT( ClientView )) {

        Status = ObReferenceObjectByHandle( CapturedClientView.SectionHandle,
                                            SECTION_MAP_READ |
                                            SECTION_MAP_WRITE,
                                            MmSectionObjectType,
                                            PreviousMode,
                                            (PVOID *)&SectionToMap,
                                            NULL );

        if (!NT_SUCCESS( Status )) {

            ObDereferenceObject( ClientPort );

            return Status;
        }

        SectionOffset.LowPart = CapturedClientView.SectionOffset,
        SectionOffset.HighPart = 0;

        CurrentProcess = PsGetCurrentProcess();

        //
        //  Now map a view of the section using the reference we just captured
        //  and not the section handle itself, because the handle may have changed
        //

        Status = MmMapViewOfSection( SectionToMap,
                                     CurrentProcess,
                                     &ClientPort->ClientSectionBase,
                                     0,
                                     0,
                                     &SectionOffset,
                                     &CapturedClientView.ViewSize,
                                     ViewUnmap,
                                     0,
                                     PAGE_READWRITE );

        CapturedClientView.SectionOffset = SectionOffset.LowPart;

        if (!NT_SUCCESS( Status )) {

            ObDereferenceObject( SectionToMap );
            ObDereferenceObject( ClientPort );

            return Status;
        }

        CapturedClientView.ViewBase = ClientPort->ClientSectionBase;

        //
        //  We'll add an extra-reference to the current process, when we have 
        //  a section mapped in that process. 
        //

        ClientPort->MappingProcess = CurrentProcess;

        ObReferenceObject( ClientPort->MappingProcess );

    } else {

        SectionToMap = NULL;
    }

    //
    //  Adjust the size of the connection info length that the client supplied
    //  to be the no longer than one the connection port will accept
    //

    if (ConnectionInfoLength > ConnectionPort->MaxConnectionInfoLength) {

        ConnectionInfoLength = ConnectionPort->MaxConnectionInfoLength;
    }

    //
    //  At this point the client port is all setup and now we have to
    //  allocate a request connection message for the server and send it off
    //
    //  Allocate a connection request message.  It holds the LPCP message,
    //  the LPCP connection message, and the user supplied connection
    //  information
    //

    Msg = LpcpAllocateFromPortZone( sizeof( *Msg ) +
                                    sizeof( *ConnectMsg ) +
                                    ConnectionInfoLength );

    //
    //  If we didn't get memory for the message then tell our caller we failed
    //

    if (Msg == NULL) {

        if (SectionToMap != NULL) {

            ObDereferenceObject( SectionToMap );
        }

        ObDereferenceObject( ClientPort );

        return STATUS_NO_MEMORY;
    }

    //
    //  Msg points to the LPCP message, followed by ConnectMsg which points to
    //  the LPCP connection message, followed by client specified information.
    //  We'll now fill it all in.
    //

    ConnectMsg = (PLPCP_CONNECTION_MESSAGE)(Msg + 1);

    //
    //  This thread originated the message
    //

    Msg->Request.ClientId = CurrentThread->Cid;

    //
    //  If we have a client view then copy over the client view information
    //  otherwise we'll zero out all of the view information
    //

    if (ARGUMENT_PRESENT( ClientView )) {

        Msg->Request.ClientViewSize = CapturedClientView.ViewSize;

        RtlCopyMemory( &ConnectMsg->ClientView,
                       &CapturedClientView,
                       sizeof( CapturedClientView ));

        RtlZeroMemory( &ConnectMsg->ServerView, sizeof( ConnectMsg->ServerView ));

    } else {

        Msg->Request.ClientViewSize = 0;
        RtlZeroMemory( ConnectMsg, sizeof( *ConnectMsg ));
    }

    ConnectMsg->ClientPort = NULL;              // Set below
    ConnectMsg->SectionToMap = SectionToMap;

    //
    //  The data length is everything after the port message within the lpcp
    //  message.  In other words the connection message and the user supplied
    //  information
    //

    Msg->Request.u1.s1.DataLength = (CSHORT)(sizeof( *ConnectMsg ) +
                                             ConnectionInfoLength);

    //
    //  The total length add on the LPCP message
    //

    Msg->Request.u1.s1.TotalLength = (CSHORT)(sizeof( *Msg ) +
                                              Msg->Request.u1.s1.DataLength);

    //
    //  This will be a connection request message
    //

    Msg->Request.u2.s2.Type = LPC_CONNECTION_REQUEST;

    //
    //  If the caller supplied some connection information then copy
    //  that into place right now
    //

    if (ARGUMENT_PRESENT( ConnectionInformation )) {

        try {

            RtlCopyMemory( ConnectMsg + 1,
                           ConnectionInformation,
                           ConnectionInfoLength );

        } except( EXCEPTION_EXECUTE_HANDLER ) {

            //
            //  If we fail then cleanup after ourselves and return the
            //  error to our caller
            //

            LpcpFreeToPortZone( Msg, 0 );

            if (SectionToMap != NULL) {

                ObDereferenceObject( SectionToMap );
            }

            ObDereferenceObject( ClientPort );

            return GetExceptionCode();
        }
    }

    //
    //  The message is mostly ready to go now put it on the servers queue.
    //
    //  Acquire the mutex that guards the LpcReplyMessage field of the
    //  thread.  Also acquire the semaphore that guards the connection
    //  request message queue.  Stamp the connection request message with
    //  a serial number, insert the message at the tail of the connection
    //  request message queue and remember the address of the message in
    //  the LpcReplyMessage field for the current thread.
    //

    Status = STATUS_SUCCESS;

    LpcpAcquireLpcpLockByThread(CurrentThread);

    //
    //  See if the port name has been deleted from under us.  If so, then
    //  don't queue the message and don't wait for a reply
    //

    if (ConnectionPort->Flags & PORT_NAME_DELETED) {

        Status = STATUS_OBJECT_NAME_NOT_FOUND;

    } else {

        LpcpTrace(( "Send Connect Msg %lx to Port %wZ (%lx)\n", Msg, PortName, ConnectionPort ));

        //
        //  Stamp the request message with a serial number, insert the message
        //  at the tail of the request message queue
        //

        Msg->RepliedToThread = NULL;
        Msg->Request.MessageId = LpcpGenerateMessageId();

        CurrentThread->LpcReplyMessageId = Msg->Request.MessageId;

        InsertTailList( &ConnectionPort->MsgQueue.ReceiveHead, &Msg->Entry );

        InsertTailList( &ConnectionPort->LpcReplyChainHead, &CurrentThread->LpcReplyChain );

        CurrentThread->LpcReplyMessage = Msg;

        //
        //  Reference the port we are passing in the connect msg so if we die
        //  it will still be valid for the server in NtAcceptConnectPort.  The
        //  reference will be released when the message is freed.
        //

        ObReferenceObject( ClientPort );

        ConnectMsg->ClientPort = ClientPort;

        KeEnterCriticalRegionThread (&CurrentThread->Tcb);
    }
    
    //
    //  Add an extra-reference to the connection port to prevent going away
    //  if the server closes the handle. The reference we already have is not enough
    //  because closing the connection port will delete the connection message from
    //  the queue, which will delete the client port, which will dereference the 
    //  connection port. Therefore right after releasing the lock the connection
    //  port might be invalid in the absence of this extra reference.
    //

    ObReferenceObject( ConnectionPort );
    
    LpcpReleaseLpcpLock();

    //
    //  At this point the client's communication port is all set up and the
    //  connection request message is in the server's queue.  So now we have
    //  to single the server and wait for a reply
    //

    if (NT_SUCCESS( Status )) {

        //
        //  If this is a waitable port then set the event that they might be
        //  waiting on
        //

        if ( ConnectionPort->Flags & PORT_WAITABLE ) {

            KeSetEvent( &ConnectionPort->WaitEvent, 1, FALSE );
        }

        //
        //  Increment the connection request message queue semaphore by one for
        //  the newly inserted connection request message.  Release the spin
        //  locks, while remaining at the dispatcher IRQL.  Then wait for the
        //  reply to this connection request by waiting on the LpcReplySemaphore
        //  for the current thread.
        //

        KeReleaseSemaphore( ConnectionPort->MsgQueue.Semaphore,
                            1,
                            1,
                            FALSE );
        KeLeaveCriticalRegionThread (&CurrentThread->Tcb);

        Status = KeWaitForSingleObject( &CurrentThread->LpcReplySemaphore,
                                        Executive,
                                        PreviousMode,
                                        FALSE,
                                        NULL );

    }

    if (Status == STATUS_USER_APC) {

        //
        //  if the semaphore is signaled, then clear it
        //

        if (KeReadStateSemaphore( &CurrentThread->LpcReplySemaphore )) {

            KeWaitForSingleObject( &CurrentThread->LpcReplySemaphore,
                                   WrExecutive,
                                   KernelMode,
                                   FALSE,
                                   NULL );

            Status = STATUS_SUCCESS;
        }
    }

    //
    //  A connection request is accepted if the ConnectedPort of the client's
    //  communication port has been filled in.
    //

    if (Status == STATUS_SUCCESS) {

        SectionToMap = LpcpFreeConMsg( &Msg, &ConnectMsg, CurrentThread );

        //
        //  Check that we got a reply message
        //

        if (Msg != NULL) {

            //
            //  Copy any connection information back to the caller, but first
            //  calculate the new connection data length for the reply and
            //  don't let it grow beyond what we probed originally
            //

            if ((Msg->Request.u1.s1.DataLength - sizeof( *ConnectMsg )) < ConnectionInfoLength) {

                ConnectionInfoLength = Msg->Request.u1.s1.DataLength - sizeof( *ConnectMsg );
            }

            if (ARGUMENT_PRESENT( ConnectionInformation )) {

                try {

                    if (ARGUMENT_PRESENT( ConnectionInformationLength )) {

                        *ConnectionInformationLength = ConnectionInfoLength;
                    }

                    RtlCopyMemory( ConnectionInformation,
                                   ConnectMsg + 1,
                                   ConnectionInfoLength );

                } except( EXCEPTION_EXECUTE_HANDLER ) {

                    Status = GetExceptionCode();
                }
            }

            //
            //  Insert client communication port object in specified object
            //  table.  Set port handle value if successful.  If not
            //  successful, then the port will have been dereferenced, which
            //  will cause it to be freed, after our delete procedure is
            //  called.  The delete procedure will undo the work done to
            //  initialize the port.
            //

            if (ClientPort->ConnectedPort != NULL) {

                ULONG CapturedMaxMessageLength;

                //
                //  Before we do the object insert we need to get the max
                //  message length because right after the call the object
                //  could be dereferenced and gone away
                //

                CapturedMaxMessageLength = ConnectionPort->MaxMessageLength;

                //
                //  Now create a handle for the new client port object.
                //

                Status = ObInsertObject( ClientPort,
                                         NULL,
                                         PORT_ALL_ACCESS,
                                         0,
                                         (PVOID *)NULL,
                                         &Handle );

                if (NT_SUCCESS( Status )) {

                    //
                    //  This is the only successful path through this routine.
                    //  Set the output variables, later we'll free the msg
                    //  back to the port zone and return to our caller
                    //

                    try {

                        *PortHandle = Handle;

                        if (ARGUMENT_PRESENT( MaxMessageLength )) {

                            *MaxMessageLength = CapturedMaxMessageLength;
                        }

                        if (ARGUMENT_PRESENT( ClientView )) {

                            RtlCopyMemory( ClientView,
                                           &ConnectMsg->ClientView,
                                           sizeof( *ClientView ));
                        }

                        if (ARGUMENT_PRESENT( ServerView )) {

                            RtlCopyMemory( ServerView,
                                           &ConnectMsg->ServerView,
                                           sizeof( *ServerView ));
                        }

                    } except( EXCEPTION_EXECUTE_HANDLER ) {

                        Status = GetExceptionCode();
                        NtClose( Handle );
                    }
                }

            } else {

                //
                //  Otherwise we did not get a connect port from the server so
                //  the connection was refused
                //

                LpcpTrace(( "Connection request refused.\n" ));

                if ( SectionToMap != NULL ) {

                    ObDereferenceObject( SectionToMap );
                }

                //
                //  Synchronize with the deletion path for the port object
                //  If the server accepted the connection and immediately 
                //  closed the server handle, the ConnectionPort field will be NULL.
                //  If the server closed the connection port as well, the captured
                //  value for the connection port will be invalid.
                //

                LpcpAcquireLpcpLockByThread(CurrentThread);

                if ((ClientPort->ConnectionPort == NULL)
                        ||
                    (ConnectionPort->Flags & PORT_NAME_DELETED)) {

                    Status = STATUS_OBJECT_NAME_NOT_FOUND;

                } else {

                    Status = STATUS_PORT_CONNECTION_REFUSED;
                }
                
                LpcpReleaseLpcpLock();

                ObDereferenceObject( ClientPort );
            }

            //
            //  Free the reply message back to the port zone
            //

            LpcpFreeToPortZone( Msg, 0 );

        } else {

            //
            //  We did not get a reply message so the connection must have
            //  been refused
            //

            if (SectionToMap != NULL) {

                ObDereferenceObject( SectionToMap );
            }

            ObDereferenceObject( ClientPort );

            Status = STATUS_PORT_CONNECTION_REFUSED;
        }

    } else {

        //
        //  Our wait was not successful
        //

        //
        //  Remove the connection request message from the received
        //  queue and free the message back to the connection
        //  port's zone.
        //

        SectionToMap = LpcpFreeConMsg( &Msg, &ConnectMsg, CurrentThread );
        
        //
        //  The wait was not successful, but in the meantime the server could
        //  replied, so it signaled the lpc semaphore. We have to clear the
        //  semaphore state right now.
        //

        if (KeReadStateSemaphore( &CurrentThread->LpcReplySemaphore )) {

            KeWaitForSingleObject( &CurrentThread->LpcReplySemaphore,
                                   WrExecutive,
                                   KernelMode,
                                   FALSE,
                                   NULL );
        }

        if (Msg != NULL) {

            LpcpFreeToPortZone( Msg, 0 );
        }

        //
        //  If a client section was specified, then dereference the section
        //  object.
        //

        if ( SectionToMap != NULL ) {

            ObDereferenceObject( SectionToMap );
        }

        //
        //  If the connection was rejected or the wait failed, then
        //  dereference the client port object, which will cause it to
        //  be deleted.
        //

        ObDereferenceObject( ClientPort );
    }
    
    //
    //  Remove the extra reference we added to the connection port
    //

    ObDereferenceObject( ConnectionPort );

    //
    //  And return to our caller
    //

    return Status;
}


//
//  Local support routine
//

PVOID
LpcpFreeConMsg (
    IN PLPCP_MESSAGE *Msg,
    PLPCP_CONNECTION_MESSAGE *ConnectMsg,
    IN PETHREAD CurrentThread
    )

/*++

Routine Description:

    This routine returns a connection reply message for the specified thread

Arguments:

    Msg - Receives a pointer to the LPCP message if there is a reply

    ConnectMsg - Receives a pointer to the LPCP connection message if there
        is a reply

    CurrentThread - Specifies the thread we're to be examining

Return Value:

    PVOID - Returns a pointer to the section to map in the connection message

--*/

{
    PVOID SectionToMap;
    PLPCP_MESSAGE LpcMessage;

    //
    //  Acquire the LPC mutex, remove the connection request message
    //  from the received queue and free the message back to the connection
    //  port's zone.
    //

    LpcpAcquireLpcpLock();

    //
    //  Remove the thread from the reply rundown list in case we did not wakeup due to
    //  a reply
    //

    if (!IsListEmpty( &CurrentThread->LpcReplyChain )) {

        RemoveEntryList( &CurrentThread->LpcReplyChain );

        InitializeListHead( &CurrentThread->LpcReplyChain );
    }

    //
    //  Check if the thread has an LPC reply message waiting to be handled
    //
    
    LpcMessage = LpcpGetThreadMessage(CurrentThread);

    if (LpcMessage != NULL) {

        //
        //  Take the message off the threads list
        //

        *Msg = LpcMessage;

        if (!IsListEmpty( &LpcMessage->Entry )) {

            RemoveEntryList( &LpcMessage->Entry );
            InitializeListHead( &LpcMessage->Entry );
        }
        
        CurrentThread->LpcReplyMessage = NULL;

        CurrentThread->LpcReplyMessageId = 0;

        //
        //  Set the connection message pointer, and copy over the section
        //  to map location before zeroing it out
        //

        *ConnectMsg = (PLPCP_CONNECTION_MESSAGE)(LpcMessage + 1);

        SectionToMap = (*ConnectMsg)->SectionToMap;
        (*ConnectMsg)->SectionToMap = NULL;

    } else {

        //
        //  Otherwise there is no LPC message to be handle so we'll return
        //  null's to our caller
        //

        *Msg = NULL;
        SectionToMap = NULL;
    }

    //
    //  Release the global lock and return to our caller
    //

    LpcpReleaseLpcpLock();

    return SectionToMap;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\lpc\lpccreat.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    lpccreat.c

Abstract:

    Local Inter-Process Communication (LPC) connection system services.

--*/

#include "lpcp.h"

//
//  Local procedure prototype
//

NTSTATUS
LpcpCreatePort (
    OUT PHANDLE PortHandle,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN ULONG MaxConnectionInfoLength,
    IN ULONG MaxMessageLength,
    IN ULONG MaxPoolUsage,
    IN BOOLEAN Waitable
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,NtCreatePort)
#pragma alloc_text(PAGE,NtCreateWaitablePort)
#pragma alloc_text(PAGE,LpcpCreatePort)
#endif


NTSTATUS
NtCreatePort (
    __out PHANDLE PortHandle,
    __in POBJECT_ATTRIBUTES ObjectAttributes,
    __in ULONG MaxConnectionInfoLength,
    __in ULONG MaxMessageLength,
    __in_opt ULONG MaxPoolUsage
    )

/*++

Routine Description:

    See LpcpCreatePort.

Arguments:

    See LpcpCreatePort.

Return Value:

    NTSTATUS - An appropriate status value

--*/

{
    NTSTATUS Status;

    PAGED_CODE();

    Status = LpcpCreatePort( PortHandle,
                             ObjectAttributes,
                             MaxConnectionInfoLength,
                             MaxMessageLength,
                             MaxPoolUsage,
                             FALSE );

    return Status ;

}


NTSTATUS
NtCreateWaitablePort (
    __out PHANDLE PortHandle,
    __in POBJECT_ATTRIBUTES ObjectAttributes,
    __in ULONG MaxConnectionInfoLength,
    __in ULONG MaxMessageLength,
    __in_opt ULONG MaxPoolUsage
    )

/*++

Routine Description:

    Same as NtCreatePort.

    The only difference between this call and NtCreatePort is that the
    working KEVENT that can be used to wait for LPC messages to arrive
    asynchronously.

Arguments:

    See LpcpCreatePort.

Return Value:

    NTSTATUS - An appropriate status value

--*/

{
    NTSTATUS Status ;

    PAGED_CODE();

    Status = LpcpCreatePort( PortHandle,
                             ObjectAttributes,
                             MaxConnectionInfoLength,
                             MaxMessageLength,
                             MaxPoolUsage,
                             TRUE );

    return Status ;
}


//
//  Local support routine
//

NTSTATUS
LpcpCreatePort (
    OUT PHANDLE PortHandle,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN ULONG MaxConnectionInfoLength,
    IN ULONG MaxMessageLength,
    IN ULONG MaxPoolUsage,
    IN BOOLEAN Waitable
    )

/*++

Routine Description:

    A server process can create a named connection port with the NtCreatePort
    service.

    A connection port is created with the name and SECURITY_DESCRIPTOR
    specified in the ObjectAttributes structure.  A handle to the connection
    port object is returned in the location pointed to by the PortHandle
    parameter.  The returned handle can then be used to listen for connection
    requests to that port name, using the NtListenPort service.

    The standard object architecture defined desired access parameter is not
    necessary since this service can only create a new port, not access an
    existing port.

    Connection ports cannot be used to send and receive messages.  They are
    only valid as a parameter to the NtListenPort service.

Arguments:

    PortHandle - A pointer to a variable that will receive the connection port
        object handle value.

    ObjectAttributes - A pointer to a structure that specifies the name of the
        object, an access control list (SECURITY_DESCRIPTOR) to be applied to
        the object, and a set of object attribute flags.

        PUNICODE_STRING ObjectName - An optional pointer to a null terminated
            port name string.  The form of the name is
            [\name...\name]\port_name.  If no name is specified then an
            unconnected communication port is created rather than a connection
            port.  This is useful for sending and receiving messages between
            threads of a single process.

        ULONG Attributes - A set of flags that control the port object
            attributes.

            None of the standard values are relevant for this call.
            Connection ports cannot be inherited, are always placed in the
            system handle table and are exclusive to the creating process.
            This field must be zero.  Future implementations might support
            specifying the OBJ_PERMANENT attribute.

    MaxMessageLength - Specifies the maximum length of messages sent or
        received on communication ports created from this connection
        port.  The value of this parameter cannot exceed
        MAX_PORTMSG_LENGTH bytes.

    MaxPoolUsage - Specifies the maximum amount of NonPaged pool used for
        message storage.

    Waitable - Specifies if the event used by the port can be use to wait
        for LPC messages to arrive asynchronously.

Return Value:

    NTSTATUS - An appropriate status value

--*/

{
    PLPCP_PORT_OBJECT ConnectionPort;
    HANDLE Handle;
    KPROCESSOR_MODE PreviousMode;
    NTSTATUS Status;
    PUNICODE_STRING NamePtr;
    UNICODE_STRING CapturedObjectName;

    PAGED_CODE();

    UNREFERENCED_PARAMETER (MaxPoolUsage);

    //
    //  Get previous processor mode and probe output arguments if necessary.
    //

    PreviousMode = KeGetPreviousMode();
    RtlInitUnicodeString( &CapturedObjectName, NULL );

    if (PreviousMode != KernelMode) {

        try {

            ProbeForWriteHandle( PortHandle );

            ProbeForReadSmallStructure( ObjectAttributes,
                                        sizeof( OBJECT_ATTRIBUTES ),
                                        sizeof( ULONG ));

            NamePtr = ObjectAttributes->ObjectName;

            if (NamePtr != NULL) {

                CapturedObjectName = ProbeAndReadStructure( NamePtr,
                                                            UNICODE_STRING );
            }

        } except( EXCEPTION_EXECUTE_HANDLER ) {

            return( GetExceptionCode() );
        }

    } else {

        if (ObjectAttributes->ObjectName != NULL) {

            CapturedObjectName = *(ObjectAttributes->ObjectName);
        }
    }

    //
    //  Make the null buffer indicate an unspecified port name
    //

    if (CapturedObjectName.Length == 0) {

        CapturedObjectName.Buffer = NULL;
    }

    //
    //  Allocate and initialize a port object.  If an object name was
    //  specified, then this is a connection port.  Otherwise this is an
    //  unconnected communication port that a process can use to communicate
    //  between threads.
    //

    Status = ObCreateObject( PreviousMode,
                             (Waitable ? LpcWaitablePortObjectType
                                       : LpcPortObjectType),
                             ObjectAttributes,
                             PreviousMode,
                             NULL,
                             (Waitable ? sizeof( LPCP_PORT_OBJECT )
                                       : FIELD_OFFSET( LPCP_PORT_OBJECT, WaitEvent )),
                             0,
                             0,
                             (PVOID *)&ConnectionPort );

    if (!NT_SUCCESS( Status )) {

        return( Status );
    }

    //
    //  Zero out the connection port object and then initialize its fields
    //

    RtlZeroMemory( ConnectionPort, (Waitable ? sizeof( LPCP_PORT_OBJECT )
                                             : FIELD_OFFSET( LPCP_PORT_OBJECT, WaitEvent )));

    ConnectionPort->ConnectionPort = ConnectionPort;
    ConnectionPort->Creator = PsGetCurrentThread()->Cid;

    InitializeListHead( &ConnectionPort->LpcReplyChainHead );

    InitializeListHead( &ConnectionPort->LpcDataInfoChainHead );

    //
    //  Named ports get a connection message queue.
    //

    if (CapturedObjectName.Buffer == NULL) {

        ConnectionPort->Flags = UNCONNECTED_COMMUNICATION_PORT;
        ConnectionPort->ConnectedPort = ConnectionPort;
        ConnectionPort->ServerProcess = NULL;

    } else {

        ConnectionPort->Flags = SERVER_CONNECTION_PORT;

        ObReferenceObject( PsGetCurrentProcess() );
        ConnectionPort->ServerProcess = PsGetCurrentProcess();
    }
    
    if ( Waitable ) {

        ConnectionPort->Flags |= PORT_WAITABLE;
    }
    
    //
    //  All ports get a request message queue.
    //

    Status = LpcpInitializePortQueue( ConnectionPort );

    if (!NT_SUCCESS(Status)) {

        ObDereferenceObject( ConnectionPort );

        return(Status);
    }

    //
    //  For a waitable port, create the KEVENT that will
    //  be used to signal clients
    //

    if (ConnectionPort->Flags & PORT_WAITABLE) {

        KeInitializeEvent( &ConnectionPort->WaitEvent,
                           NotificationEvent,
                           FALSE );
    }

    //
    //  Set the maximum message length and connection info length based on the
    //  zone block size less the structs overhead.
    //

    ConnectionPort->MaxMessageLength = (USHORT) (LpcpGetMaxMessageLength() -
                                                 FIELD_OFFSET( LPCP_MESSAGE, Request ));

    ConnectionPort->MaxConnectionInfoLength = (USHORT) (ConnectionPort->MaxMessageLength -
                                                        sizeof( PORT_MESSAGE ) -
                                                        sizeof( LPCP_CONNECTION_MESSAGE ));

#if DBG
    LpcpTrace(( "Created port %ws (%x) - MaxMsgLen == %x  MaxConnectInfoLen == %x\n",
                CapturedObjectName.Buffer == NULL ? L"** UnNamed **" : ObjectAttributes->ObjectName->Buffer,
                ConnectionPort,
                ConnectionPort->MaxMessageLength,
                ConnectionPort->MaxConnectionInfoLength ));
#endif

    //
    //  Sanity check that the max message length being asked for is not
    //  greater than the max message length possible in the system
    //

    if (ConnectionPort->MaxMessageLength < MaxMessageLength) {

#if DBG
        LpcpPrint(( "MaxMessageLength granted is %x but requested %x\n",
                    ConnectionPort->MaxMessageLength,
                    MaxMessageLength ));
#endif

        ObDereferenceObject( ConnectionPort );

        return STATUS_INVALID_PARAMETER_4;
    }
    
    //
    //  Save the MaxMessageLength to the connection port
    //

    ConnectionPort->MaxMessageLength = (USHORT) MaxMessageLength;

    //
    //  Sanity check that the max connection info length being asked for is
    //  not greater than the maximum possible in the system
    //

    if (ConnectionPort->MaxConnectionInfoLength < MaxConnectionInfoLength) {

#if DBG
        LpcpPrint(( "MaxConnectionInfoLength granted is %x but requested %x\n",
                    ConnectionPort->MaxConnectionInfoLength,
                    MaxConnectionInfoLength ));
#endif

        ObDereferenceObject( ConnectionPort );

        return STATUS_INVALID_PARAMETER_3;
    }

    //
    //  Save the max connection length to the port
    //

    ConnectionPort->MaxConnectionInfoLength = (USHORT)MaxConnectionInfoLength;

    //
    //  Insert connection port object in specified object table.  Set port
    //  handle value if successful.  If not successful, then the port will
    //  have been dereferenced, which will cause it to be freed, after our
    //  delete procedure is called.  The delete procedure will undo the work
    //  done to initialize the port.  Finally, return the system server status.
    //

    Status = ObInsertObject( ConnectionPort,
                             NULL,
                             PORT_ALL_ACCESS,
                             0,
                             (PVOID *)NULL,
                             &Handle );

    if (NT_SUCCESS( Status )) {

        //
        //  Set the output variable protected against access faults
        //

        try {

            *PortHandle = Handle;

        } except( EXCEPTION_EXECUTE_HANDLER ) {

            NtClose( Handle );

            Status = GetExceptionCode();
        }
    }

    //
    //  And return to our caller
    //

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\lpc\lpcinit.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    lpcinit.c

Abstract:

    Initialization module for the LPC subcomponent of NTOS

--*/

#include "lpcp.h"

//
//  The following two object types are defined system wide to handle lpc ports
//

POBJECT_TYPE LpcPortObjectType;
POBJECT_TYPE LpcWaitablePortObjectType;

//
//  This is the default access mask mapping for lpc port objects
//

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("INITCONST")
#pragma data_seg("PAGEDATA")
#endif // ALLOC_DATA_PRAGMA
const GENERIC_MAPPING LpcpPortMapping = {
    READ_CONTROL | PORT_CONNECT,
    DELETE | PORT_CONNECT,
    0,
    PORT_ALL_ACCESS
};
ULONG LpcpNextMessageId = 1;
ULONG LpcpNextCallbackId = 1;
#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg()
#pragma data_seg()
#endif // ALLOC_DATA_PRAGMA

//
//  This lock is used to protect practically everything in lpc
//

LPC_MUTEX LpcpLock;

//
//  The following array of strings is used to debugger purposes and the
//  values correspond to the Port message types defined in ntlpcapi.h
//

#if ENABLE_LPC_TRACING

char *LpcpMessageTypeName[] = {
    "UNUSED_MSG_TYPE",
    "LPC_REQUEST",
    "LPC_REPLY",
    "LPC_DATAGRAM",
    "LPC_LOST_REPLY",
    "LPC_PORT_CLOSED",
    "LPC_CLIENT_DIED",
    "LPC_EXCEPTION",
    "LPC_DEBUG_EVENT",
    "LPC_ERROR_EVENT",
    "LPC_CONNECTION_REQUEST"
};

#endif // ENABLE_LPC_TRACING

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,LpcInitSystem)

#if ENABLE_LPC_TRACING
#pragma alloc_text(PAGE,LpcpGetCreatorName)
#endif // ENABLE_LPC_TRACING

#endif // ALLOC_PRAGMA


BOOLEAN
LpcInitSystem (
    VOID
)

/*++

Routine Description:

    This function performs the system initialization for the LPC package.
    LPC stands for Local Inter-Process Communication.

Arguments:

    None.

Return Value:

    TRUE if successful and FALSE if an error occurred.

    The following errors can occur:

    - insufficient memory

--*/

{
    OBJECT_TYPE_INITIALIZER ObjectTypeInitializer;
    UNICODE_STRING PortTypeName;
    ULONG ZoneElementSize;

    //
    //  Initialize our global lpc lock
    //

    LpcpInitializeLpcpLock();

    //
    //  Create the object type for the port object
    //

    RtlInitUnicodeString( &PortTypeName, L"Port" );

    RtlZeroMemory( &ObjectTypeInitializer, sizeof( ObjectTypeInitializer ));

    ObjectTypeInitializer.Length = sizeof( ObjectTypeInitializer );
    ObjectTypeInitializer.GenericMapping = LpcpPortMapping;
    ObjectTypeInitializer.MaintainTypeList = FALSE;
    ObjectTypeInitializer.PoolType = PagedPool;
    ObjectTypeInitializer.DefaultPagedPoolCharge = FIELD_OFFSET( LPCP_PORT_OBJECT, WaitEvent );
    ObjectTypeInitializer.DefaultNonPagedPoolCharge = sizeof( LPCP_NONPAGED_PORT_QUEUE );
    ObjectTypeInitializer.InvalidAttributes = OBJ_VALID_ATTRIBUTES ^ PORT_VALID_OBJECT_ATTRIBUTES;
    ObjectTypeInitializer.ValidAccessMask = PORT_ALL_ACCESS;
    ObjectTypeInitializer.CloseProcedure = LpcpClosePort;
    ObjectTypeInitializer.DeleteProcedure = LpcpDeletePort;
    ObjectTypeInitializer.UseDefaultObject = TRUE ;

    ObCreateObjectType( &PortTypeName,
                        &ObjectTypeInitializer,
                        (PSECURITY_DESCRIPTOR)NULL,
                        &LpcPortObjectType );

    //
    //  Create the object type for the waitable port object
    //

    RtlInitUnicodeString( &PortTypeName, L"WaitablePort" );
    ObjectTypeInitializer.PoolType = NonPagedPool;
    ObjectTypeInitializer.DefaultNonPagedPoolCharge += sizeof( LPCP_PORT_OBJECT );
    ObjectTypeInitializer.DefaultPagedPoolCharge = 0;
    ObjectTypeInitializer.UseDefaultObject = FALSE;

    ObCreateObjectType( &PortTypeName,
                        &ObjectTypeInitializer,
                        (PSECURITY_DESCRIPTOR)NULL,
                        &LpcWaitablePortObjectType );

    //
    //  Initialize the lpc port zone.  Each element can contain a max
    //  message, plus an LPCP message structure, plus an LPCP connection
    //  message
    //

    ZoneElementSize = PORT_MAXIMUM_MESSAGE_LENGTH +
                      sizeof( LPCP_MESSAGE ) +
                      sizeof( LPCP_CONNECTION_MESSAGE );

    //
    //  Round up the size to the next 16 byte alignment
    //

    ZoneElementSize = (ZoneElementSize + LPCP_ZONE_ALIGNMENT - 1) &
                      LPCP_ZONE_ALIGNMENT_MASK;

    //
    //  Initialize the zone
    //

    LpcpInitializePortZone( ZoneElementSize );

    LpcpInitilizeLogging();

    return( TRUE );
}

#if ENABLE_LPC_TRACING

char *
LpcpGetCreatorName (
    PLPCP_PORT_OBJECT PortObject
    )

/*++

Routine Description:

    This routine returns the name of the process that created the specified
    port object

Arguments:

    PortObject - Supplies the port object being queried

Return Value:

    char * - The image name of the process that created the port process

--*/

{
    NTSTATUS Status;
    PEPROCESS Process;

    //
    //  First find the process that created the port object
    //

    Status = PsLookupProcessByProcessId( PortObject->Creator.UniqueProcess, &Process );

    //
    //  If we were able to get the process then return the name of the process
    //  to our caller
    //

    if (NT_SUCCESS( Status )) {

        return (char *)Process->ImageFileName;

    } else {

        //
        //  Otherwise tell our caller we don't know the name
        //

        return "Unknown";
    }
}
#endif // ENABLE_LPC_TRACING
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\lpc\lpclistn.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    lpclistn.c

Abstract:

    Local Inter-Process Communication (LPC) connection system services.

--*/

#include "lpcp.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,NtListenPort)
#endif


NTSTATUS
NtListenPort (
    __in HANDLE PortHandle,
    __out PPORT_MESSAGE ConnectionRequest
    )

/*++

Routine Description:

    A server thread can listen for connection requests from client threads
    using the NtReplyWaitReceivePort service and looking for an
    LPC_CONNECTION_REQUEST message type.

    This call will loop, calling the NtReplyWaitReceivePort service, and
    return when it sees a message of type LPC_CONNECTION_REQUEST

Arguments:

    PortHandle - Specifies the connection port to listen for connection
        requests to.

    ConnectionRequest - Pointer to a structure that describes the
        connection request the client is making:

Return Value:

    NTSTATUS - An appropriate status value

--*/

{
    NTSTATUS Status;

    PAGED_CODE();

    //
    //  Keep on looping until we get a connection request on the lpc port
    //

    while (TRUE) {

        Status = NtReplyWaitReceivePort( PortHandle,
                                         NULL,
                                         NULL,
                                         ConnectionRequest );

        //
        //  We'll return from this procedure if ever we get back non success
        //  or the message is a connection request.  We still need to protect
        //  the testing of ConnectionRequest because it is a user supplied
        //  buffer.
        //

        try {

            if ((Status != STATUS_SUCCESS) ||
                ((ConnectionRequest->u2.s2.Type & ~LPC_KERNELMODE_MESSAGE) == LPC_CONNECTION_REQUEST)) {

                break;
            }

        } except( EXCEPTION_EXECUTE_HANDLER ) {

            Status = GetExceptionCode();

            break;
        }
    }

    //
    //  And return to our caller
    //

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\lpc\lpcp.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    lpcp.h

Abstract:

    Private include file for the LPC subcomponent of the NTOS project

--*/

#pragma warning(disable:4214)   // bit field types other than int
#pragma warning(disable:4201)   // nameless struct/union
#pragma warning(disable:4324)   // alignment sensitive to declspec
#pragma warning(disable:4127)   // condition expression is constant
#pragma warning(disable:4115)   // named type definition in parentheses
#pragma warning(disable:4310)   // cast truncates constant value

#include "ntos.h"
#include <zwapi.h>

//
//  Global Mutex to guard the following fields:
//
//      ETHREAD.LpcReplyMsg
//      LPCP_PORT_QUEUE.ReceiveHead
//
//  Mutex is never held longer than is necessary to modify or read the field.
//  Contains an additional field to track the owner of the mutex.
//

typedef struct _LPC_MUTEX {

    KGUARDED_MUTEX  Lock;

    //
    //  field that holds the thread that owns the lock
    //

    PETHREAD    Owner;

} LPC_MUTEX, *PLPC_MUTEX;


extern LPC_MUTEX LpcpLock;

extern ULONG LpcpMaxMessageSize;

#define LpcpGetMaxMessageLength() (LpcpMaxMessageSize)

extern ULONG LpcpNextMessageId;

extern ULONG LpcpNextCallbackId;

#define LpcpGenerateMessageId() \
    LpcpNextMessageId++;    if (LpcpNextMessageId == 0) LpcpNextMessageId = 1;

#define LpcpGenerateCallbackId() \
    LpcpNextCallbackId++;    if (LpcpNextCallbackId == 0) LpcpNextCallbackId = 1;

extern ULONG LpcpTotalNumberOfMessages;

//
//  Global macrodefinitions to acquire and release the LPC_MUTEX
//  in order to track the owner and allow recursive calls
//

#define LpcpInitializeLpcpLock()                             \
{                                                            \
    KeInitializeGuardedMutex( &LpcpLock.Lock );              \
    LpcpLock.Owner = NULL;                                   \
}

#define LpcpAcquireLpcpLock()                                       \
{                                                                   \
    ASSERT ( LpcpLock.Owner != PsGetCurrentThread() );              \
                                                                    \
    KeAcquireGuardedMutex( &LpcpLock.Lock );                        \
    LpcpLock.Owner = PsGetCurrentThread();                          \
}

#define LpcpAcquireLpcpLockByThread(Thread)                         \
{                                                                   \
    ASSERT ( LpcpLock.Owner != PsGetCurrentThread() );              \
                                                                    \
    KeAcquireGuardedMutex( &LpcpLock.Lock );                        \
    LpcpLock.Owner = Thread;                                        \
}

#define LpcpReleaseLpcpLock()                                       \
{                                                                   \
    ASSERT( LpcpLock.Owner == PsGetCurrentThread() );               \
                                                                    \
    LpcpLock.Owner = NULL;                                          \
    KeReleaseGuardedMutex( &LpcpLock.Lock );                        \
}


//
//  Internal Entry Points defined in lpcclose.c
//

VOID
LpcpClosePort (
    IN PEPROCESS Process OPTIONAL,
    IN PVOID Object,
    IN ACCESS_MASK GrantedAccess,
    IN ULONG_PTR ProcessHandleCount,
    IN ULONG_PTR SystemHandleCount
    );

VOID
LpcpDeletePort (
    IN PVOID Object
    );


//
//  Entry points defined in lpcqueue.c
//

NTSTATUS
LpcpInitializePortQueue (
    IN PLPCP_PORT_OBJECT Port
    );

VOID
LpcpDestroyPortQueue (
    IN PLPCP_PORT_OBJECT Port,
    IN BOOLEAN CleanupAndDestroy
    );

VOID
LpcpInitializePortZone (
    IN ULONG MaxEntrySize
    );

NTSTATUS
LpcpExtendPortZone (
    VOID
    );

VOID
LpcpSaveDataInfoMessage (
    IN PLPCP_PORT_OBJECT Port,
    IN PLPCP_MESSAGE Msg,
    IN ULONG MutexFlags
    );

VOID
LpcpFreeDataInfoMessage (
    IN PLPCP_PORT_OBJECT Port,
    IN ULONG MessageId,
    IN ULONG CallbackId,
    IN LPC_CLIENT_ID ClientId
    );

PLPCP_MESSAGE
LpcpFindDataInfoMessage (
    IN PLPCP_PORT_OBJECT Port,
    IN ULONG MessageId,
    IN ULONG CallbackId,
    IN LPC_CLIENT_ID ClientId
    );


//
//  Entry points defined in lpcquery.c
//


#if defined(_AMD64_)

VOID
FORCEINLINE
LpcpMoveMessage (
    OUT PPORT_MESSAGE DstMsg,
    IN PPORT_MESSAGE SrcMsg,
    IN PVOID SrcMsgData,
    IN ULONG MsgType OPTIONAL,
    IN PCLIENT_ID ClientId OPTIONAL
    )
{
    *DstMsg = *SrcMsg;

    if (ARGUMENT_PRESENT(MsgType)) {
        DstMsg->u2.s2.Type = (CSHORT)MsgType;
    }

    if (ARGUMENT_PRESENT(ClientId)) {
        DstMsg->ClientId = *ClientId;
    }

    __movsd( (PULONG)(DstMsg+1),
             (PULONG)SrcMsgData,
             ((USHORT)SrcMsg->u1.s1.DataLength + sizeof(ULONG) - 1) / sizeof(ULONG) );
}

#else

//
//  Entry points defined in lpcmove.s and lpcmove.asm
//

VOID
LpcpMoveMessage (
    OUT PPORT_MESSAGE DstMsg,
    IN PPORT_MESSAGE SrcMsg,
    IN PVOID SrcMsgData,
    IN ULONG MsgType OPTIONAL,
    IN PCLIENT_ID ClientId OPTIONAL
    );

#endif


//
//  Internal Entry Points defined in lpcpriv.c
//

VOID
LpcpFreePortClientSecurity (
    IN PLPCP_PORT_OBJECT Port
    );


//
//  Macro Procedures used by RequestWaitReply, Reply, ReplyWaitReceive,
//  and ReplyWaitReply services
//

#define LpcpGetDynamicClientSecurity(Thread,Port,DynamicSecurity) \
    SeCreateClientSecurity((Thread),&(Port)->SecurityQos,FALSE,(DynamicSecurity))

#define LpcpFreeDynamicClientSecurity(DynamicSecurity) \
    SeDeleteClientSecurity( DynamicSecurity )

#define LpcpReferencePortObject(PortHandle,PortAccess,PreviousMode,PortObject) \
    ObReferenceObjectByHandle((PortHandle),(PortAccess),LpcPortObjectType,(PreviousMode),(PVOID *)(PortObject),NULL)


#define LPCP_PORT_BIT           1
#define LPCP_NO_IMPERSONATION   2

#define LPCP_THREAD_ATTRIBUTES (LPCP_PORT_BIT | LPCP_NO_IMPERSONATION)

#define LpcpGetThreadMessage(T)                                                  \
    (                                                                            \
        (((ULONG_PTR)(T)->LpcReplyMessage) & LPCP_PORT_BIT) ? NULL :             \
            (PLPCP_MESSAGE)((ULONG_PTR)(T)->LpcReplyMessage & ~LPCP_THREAD_ATTRIBUTES)      \
    )

#define LpcpGetThreadPort(T)                                                     \
    (                                                                            \
        (((ULONG_PTR)(T)->LpcReplyMessage) & LPCP_PORT_BIT) ?                    \
            (PLPCP_PORT_OBJECT)(((ULONG_PTR)(T)->LpcWaitingOnPort) & ~LPCP_THREAD_ATTRIBUTES):     \
            NULL                                                                 \
    )

#define LpcpGetThreadAttributes(T) \
    (((ULONG_PTR)(T)->LpcWaitingOnPort) & LPCP_THREAD_ATTRIBUTES)
    
#define LpcpSetThreadAttributes(T,A) \
    (T)->LpcWaitingOnPort = (PVOID)(((ULONG_PTR)(T)->LpcWaitingOnPort) | (A));

#define LpcpSetPortToThread(T,P) \
    (T)->LpcWaitingOnPort = (PVOID)(((ULONG_PTR)P) | LPCP_PORT_BIT);

#define LPCP_VALIDATE_REASON_IMPERSONATION  1
#define LPCP_VALIDATE_REASON_REPLY          2
#define LPCP_VALIDATE_REASON_WRONG_DATA     3

BOOLEAN
FASTCALL
LpcpValidateClientPort(
    IN PETHREAD Thread,
    IN PLPCP_PORT_OBJECT ReplyPort,
    IN ULONG Reason
    );


//
//  Entry Points defined in lpcinit.c
//

#if DBG
#define ENABLE_LPC_TRACING 1
#else
#define ENABLE_LPC_TRACING 0
#endif

#if ENABLE_LPC_TRACING
BOOLEAN LpcpStopOnReplyMismatch;
BOOLEAN LpcpTraceMessages;

char *LpcpMessageTypeName[];

char *
LpcpGetCreatorName (
    PLPCP_PORT_OBJECT PortObject
    );

#define LpcpPrint( _x_ ) {                              \
    DbgPrint( "LPC[ %02x.%02x ]: ",                     \
              PsGetCurrentThread()->Cid.UniqueProcess,  \
              PsGetCurrentThread()->Cid.UniqueThread ); \
    DbgPrint _x_ ;                                      \
}

#define LpcpTrace( _x_ ) if (LpcpTraceMessages) { LpcpPrint( _x_ ); }

#else

#define LpcpPrint( _x_ )
#define LpcpTrace( _x_ )

#endif // ENABLE_LPC_TRACING

extern PAGED_LOOKASIDE_LIST LpcpMessagesLookaside;

__forceinline
PLPCP_MESSAGE
LpcpAllocateFromPortZone (
    ULONG Size
    )
{
    PLPCP_MESSAGE Msg;

    PAGED_CODE();

    UNREFERENCED_PARAMETER (Size);

    Msg = ExAllocateFromPagedLookasideList( &LpcpMessagesLookaside );

    if (Msg != NULL) {

        LpcpTrace(( "Allocate Msg %lx\n", Msg ));

        InitializeListHead( &Msg->Entry );

        Msg->RepliedToThread = NULL;

        //
        //  Clear the message type field. In some failure paths this message get freed
        //  w/o having it initialized.
        //

        Msg->Request.u2.s2.Type = 0;

        return Msg;
    }

    return NULL;
}


#define LPCP_MUTEX_OWNED                0x1
#define LPCP_MUTEX_RELEASE_ON_RETURN    0x2

VOID
FASTCALL
LpcpFreeToPortZone (
    IN PLPCP_MESSAGE Msg,
    IN ULONG MutexFlags
    );

#define LpcpInitilizeLogging()
#define LpcpLogEntry(_Status_,_ClientId_,_PortMessage_)
#define LpcpTraceError(_Status_,_ClientId_,_PortMessage_)
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\lpc\lpcqueue.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    lpcqueue.c

Abstract:

    Local Inter-Process Communication (LPC) queue support routines.

--*/

#include "lpcp.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,LpcpInitializePortZone)
#pragma alloc_text(PAGE,LpcpInitializePortQueue)
#pragma alloc_text(PAGE,LpcpDestroyPortQueue)
#pragma alloc_text(PAGE,LpcpExtendPortZone)
#pragma alloc_text(PAGE,LpcpFreeToPortZone)
#pragma alloc_text(PAGE,LpcpSaveDataInfoMessage)
#pragma alloc_text(PAGE,LpcpFreeDataInfoMessage)
#pragma alloc_text(PAGE,LpcpFindDataInfoMessage)
#pragma alloc_text(PAGE,LpcDisconnectPort)
#endif

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg("PAGEDATA")
#endif // ALLOC_DATA_PRAGMA

ULONG LpcpTotalNumberOfMessages = 0;
ULONG LpcpMaxMessageSize = 0;
PAGED_LOOKASIDE_LIST LpcpMessagesLookaside;


#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg()
#endif // ALLOC_DATA_PRAGMA


NTSTATUS
LpcpInitializePortQueue (
    IN PLPCP_PORT_OBJECT Port
    )

/*++

Routine Description:

    This routine is used to initialize the message queue for a port object.

Arguments:

    Port - Supplies the port object being initialized

Return Value:

    NTSTATUS - An appropriate status value

--*/

{
    PLPCP_NONPAGED_PORT_QUEUE NonPagedPortQueue;

    PAGED_CODE();

    //
    //  Allocate space for the port queue
    //

    NonPagedPortQueue = ExAllocatePoolWithTag( NonPagedPool,
                                               sizeof(LPCP_NONPAGED_PORT_QUEUE),
                                               'troP' );

    if (NonPagedPortQueue == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    //  Initialize the fields in the non paged port queue
    //

    KeInitializeSemaphore( &NonPagedPortQueue->Semaphore, 0, 0x7FFFFFFF );

    NonPagedPortQueue->BackPointer = Port;

    //
    //  Have the port msg queue point to the non nonpaged port queue
    //

    Port->MsgQueue.Semaphore = &NonPagedPortQueue->Semaphore;

    //
    //  Initialize the port msg queue to be empty
    //

    InitializeListHead( &Port->MsgQueue.ReceiveHead );

    //
    //  And return to our caller
    //

    return STATUS_SUCCESS;
}


VOID
LpcpDestroyPortQueue (
    IN PLPCP_PORT_OBJECT Port,
    IN BOOLEAN CleanupAndDestroy
    )

/*++

Routine Description:

    This routine is used to teardown the message queue of a port object.
    After running this message will either be empty (like it was just
    initialized) or completely gone (needs to be initialized)

Arguments:

    Port - Supplies the port containing the message queue being modified

    CleanupAndDestroy - Specifies if the message queue should be set back
        to the freshly initialized state (value of FALSE) or completely
        torn down (value of TRUE)

Return Value:

    None.

--*/

{
    PLIST_ENTRY Next, Head;
    PETHREAD ThreadWaitingForReply;
    PLPCP_MESSAGE Msg;
    PLPCP_PORT_OBJECT ConnectionPort = NULL;

    PAGED_CODE();

    //
    //  If this port is connected to another port, then disconnect it.
    //  Protect this with a lock in case the other side is going away
    //  at the same time.
    //

    LpcpAcquireLpcpLock();

    if ( ((Port->Flags & PORT_TYPE) != UNCONNECTED_COMMUNICATION_PORT)
            &&
         (Port->ConnectedPort != NULL) ) {

        Port->ConnectedPort->ConnectedPort = NULL;
        
        //
        //  Disconnect the connection port
        //

        if (Port->ConnectedPort->ConnectionPort) {

            ConnectionPort = Port->ConnectedPort->ConnectionPort;

            Port->ConnectedPort->ConnectionPort = NULL;
        }
    }

    //
    //  If connection port, then mark name as deleted
    //

    if ((Port->Flags & PORT_TYPE) == SERVER_CONNECTION_PORT) {

        Port->Flags |= PORT_NAME_DELETED;
    }

    //
    //  Walk list of threads waiting for a reply to a message sent to this
    //  port.  Signal each thread's LpcReplySemaphore to wake them up.  They
    //  will notice that there was no reply and return
    //  STATUS_PORT_DISCONNECTED
    //

    Head = &Port->LpcReplyChainHead;
    Next = Head->Flink;

    while ((Next != NULL) && (Next != Head)) {

        ThreadWaitingForReply = CONTAINING_RECORD( Next, ETHREAD, LpcReplyChain );

        //
        //  If the thread is exiting, in the location of LpcReplyChain is stored the ExitTime
        //  We'll stop to search through the list.

        if ( ThreadWaitingForReply->LpcExitThreadCalled ) {
            
            break;
        }

        Next = Next->Flink;

        RemoveEntryList( &ThreadWaitingForReply->LpcReplyChain );

        InitializeListHead( &ThreadWaitingForReply->LpcReplyChain );

        if (!KeReadStateSemaphore( &ThreadWaitingForReply->LpcReplySemaphore )) {

            //
            //  Thread is waiting on a message.  Signal the semaphore and free
            //  the message
            //

            Msg = LpcpGetThreadMessage(ThreadWaitingForReply);

            if ( Msg ) {

                //
                //  If the message is a connection request and has a section object
                //  attached, then dereference that section object
                //

                if ((Msg->Request.u2.s2.Type & ~LPC_KERNELMODE_MESSAGE) == LPC_CONNECTION_REQUEST) {

                    PLPCP_CONNECTION_MESSAGE ConnectMsg;
                
                    ConnectMsg = (PLPCP_CONNECTION_MESSAGE)(Msg + 1);

                    if ( ConnectMsg->SectionToMap != NULL ) {

                        ObDereferenceObject( ConnectMsg->SectionToMap );
                    }
                }

                ThreadWaitingForReply->LpcReplyMessage = NULL;

                LpcpFreeToPortZone( Msg, LPCP_MUTEX_OWNED );
                Next = Port->LpcReplyChainHead.Flink; // Lock has been dropped
            }

            ThreadWaitingForReply->LpcReplyMessageId = 0;

            KeReleaseSemaphore( &ThreadWaitingForReply->LpcReplySemaphore,
                                0,
                                1L,
                                FALSE );
        }
    }

    InitializeListHead( &Port->LpcReplyChainHead );

    //
    //  Walk list of messages queued to this port.  Remove each message from
    //  the list and free it.
    //

    while (Port->MsgQueue.ReceiveHead.Flink && !IsListEmpty (&Port->MsgQueue.ReceiveHead)) {

        Msg  = CONTAINING_RECORD( Port->MsgQueue.ReceiveHead.Flink, LPCP_MESSAGE, Entry );

        RemoveEntryList (&Msg->Entry);

        InitializeListHead( &Msg->Entry );

        LpcpFreeToPortZone( Msg, LPCP_MUTEX_OWNED );
        
    }

    LpcpReleaseLpcpLock();

    if ( ConnectionPort ) {

        ObDereferenceObject( ConnectionPort );
    }

    //
    //  Check if the caller wants it all to go away
    //

    if ( CleanupAndDestroy ) {

        //
        //  Free semaphore associated with the queue.
        //

        if (Port->MsgQueue.Semaphore != NULL) {

            ExFreePool( CONTAINING_RECORD( Port->MsgQueue.Semaphore,
                                           LPCP_NONPAGED_PORT_QUEUE,
                                           Semaphore ));
        }
    }

    //
    //  And return to our caller
    //

    return;
}


NTSTATUS
LpcDisconnectPort (
    IN PVOID Port
    )

/*++

Routine Description:

    This routine is used to disconnect an LPC port so no more messages can be sent and anybody waiting for a message
    is woken up with an error.

Arguments:

    Port - Supplies the port to be disconnected

Return Value:

    NTSTATUS - Status of operation

--*/
{
    LpcpDestroyPortQueue (Port, FALSE);
    return STATUS_SUCCESS;
}


VOID
LpcpInitializePortZone (
    IN ULONG MaxEntrySize
    )
{
    LpcpMaxMessageSize = MaxEntrySize;

    ExInitializePagedLookasideList( &LpcpMessagesLookaside,
                                    NULL,
                                    NULL,
                                    0,
                                    MaxEntrySize,
                                    'McpL',
                                    32 
                                    );
}


VOID
FASTCALL
LpcpFreeToPortZone (
    IN PLPCP_MESSAGE Msg,
    IN ULONG MutexFlags
    )
{
    PLPCP_CONNECTION_MESSAGE ConnectMsg;
    PETHREAD RepliedToThread = NULL;
    PLPCP_PORT_OBJECT ClientPort = NULL;

    PAGED_CODE();

    //
    //  Acquire the global lock if necessary
    //

    if ((MutexFlags & LPCP_MUTEX_OWNED) == 0) {

        LpcpAcquireLpcpLock();
    }

    //
    //  A entry field connects the message to the message queue of the
    //  owning port object.  If not already removed then remove this
    //  message
    //

    if (!IsListEmpty( &Msg->Entry )) {
        RemoveEntryList( &Msg->Entry );
        InitializeListHead( &Msg->Entry );
    }

    //
    //  If the replied to thread is not null then we have a reference
    //  to the thread that we should now remove
    //

    if (Msg->RepliedToThread != NULL) {
        RepliedToThread = Msg->RepliedToThread;
        Msg->RepliedToThread = NULL;
    }

    //
    //  If the msg was for a connection request then we know that
    //  right after the lpcp message is a connection message whose
    //  client port field might need to be dereferenced
    //

    if ((Msg->Request.u2.s2.Type & ~LPC_KERNELMODE_MESSAGE) == LPC_CONNECTION_REQUEST) {

        ConnectMsg = (PLPCP_CONNECTION_MESSAGE)(Msg + 1);

        if (ConnectMsg->ClientPort) {

            //
            //  Capture a pointer to the client port then null it
            //  out so that no one else can use it, then release
            //  lpcp lock before we dereference the client port
            //

            ClientPort = ConnectMsg->ClientPort;

            ConnectMsg->ClientPort = NULL;
        }
    }

    LpcpReleaseLpcpLock();

    if ( ClientPort ) {
        
        ObDereferenceObject( ClientPort );
    }

    if ( RepliedToThread ) {

        ObDereferenceObject( RepliedToThread );
    }

    ExFreeToPagedLookasideList(&LpcpMessagesLookaside, Msg);

    if ((MutexFlags & LPCP_MUTEX_OWNED) &&
        ((MutexFlags & LPCP_MUTEX_RELEASE_ON_RETURN) == 0)) {

        LpcpAcquireLpcpLock();
    }

}



VOID
LpcpSaveDataInfoMessage (
    IN PLPCP_PORT_OBJECT Port,
    IN PLPCP_MESSAGE Msg,
    IN ULONG MutexFlags
    )

/*++

Routine Description:

    This routine is used in place of freeing a message and instead saves the
    message off a separate queue from the port.

Arguments:

    Port - Specifies the port object under which to save this message

    Msg - Supplies the message being saved

    MutexFlags - Supplies whether the mutex is owned.

Return Value:

    None.

--*/

{
    PAGED_CODE();

    //
    //  Take out the global lock if our caller didn't already.
    //

    if ((MutexFlags & LPCP_MUTEX_OWNED) == 0) {
        LpcpAcquireLpcpLock();
    }

    //
    //  Make sure we get to the connection port object of this port
    //

    if ((Port->Flags & PORT_TYPE) > UNCONNECTED_COMMUNICATION_PORT) {

        Port = Port->ConnectionPort;

        if (Port == NULL) {

            if ((MutexFlags & LPCP_MUTEX_OWNED) == 0) {
                LpcpReleaseLpcpLock();
            }

            return;
        }
    }

    LpcpTrace(( "%s Saving DataInfo Message %lx (%u.%u)  Port: %lx\n",
                PsGetCurrentProcess()->ImageFileName,
                Msg,
                Msg->Request.MessageId,
                Msg->Request.CallbackId,
                Port ));

    //
    //  Enqueue this message onto the data info chain for the port
    //

    InsertTailList( &Port->LpcDataInfoChainHead, &Msg->Entry );

    //
    //  Free the global lock
    //

    if ((MutexFlags & LPCP_MUTEX_OWNED) == 0) {
        LpcpReleaseLpcpLock();
    }

    //
    //  And return to our caller
    //

    return;
}


VOID
LpcpFreeDataInfoMessage (
    IN PLPCP_PORT_OBJECT Port,
    IN ULONG MessageId,
    IN ULONG CallbackId,
    IN LPC_CLIENT_ID ClientId
    )

/*++

Routine Description:

    This routine is used to free up a saved message in a port

Arguments:

    Port - Supplies the port being manipulated

    MessageId - Supplies the id of the message being freed

    CallbackId - Supplies the callback id of the message being freed

Return Value:

    None.

--*/

{
    PLPCP_MESSAGE Msg;
    PLIST_ENTRY Head, Next;

    PAGED_CODE();

    //
    //  Make sure we get to the connection port object of this port
    //

    if ((Port->Flags & PORT_TYPE) > UNCONNECTED_COMMUNICATION_PORT) {

        Port = Port->ConnectionPort;

        if (Port == NULL) {

            return;
        }
    }

    //
    //  Zoom down the data info chain for the connection port object
    //

    Head = &Port->LpcDataInfoChainHead;
    Next = Head->Flink;

    while (Next != Head) {

        Msg = CONTAINING_RECORD( Next, LPCP_MESSAGE, Entry );

        //
        //  If this message matches the callers specification then remove
        //  this message, free it back to the port zone, and return back
        //  to our caller
        //

        if ((Msg->Request.MessageId == MessageId) &&
            (Msg->Request.ClientId.UniqueProcess == ClientId.UniqueProcess) &&
            (Msg->Request.ClientId.UniqueThread == ClientId.UniqueThread)) {

            LpcpTrace(( "%s Removing DataInfo Message %lx (%u.%u) Port: %lx\n",
                        PsGetCurrentProcess()->ImageFileName,
                        Msg,
                        Msg->Request.MessageId,
                        Msg->Request.CallbackId,
                        Port ));

            RemoveEntryList( &Msg->Entry );

            InitializeListHead( &Msg->Entry );

            LpcpFreeToPortZone( Msg, LPCP_MUTEX_OWNED );

            return;

        } else {
            
            //
            //  Keep on going down the data info chain
            //

            Next = Next->Flink;
        }
    }

    //
    //  We didn't find a match so just return to our caller
    //

    LpcpTrace(( "%s Unable to find DataInfo Message (%u.%u)  Port: %lx\n",
                PsGetCurrentProcess()->ImageFileName,
                MessageId,
                CallbackId,
                Port ));

    return;
}


PLPCP_MESSAGE
LpcpFindDataInfoMessage (
    IN PLPCP_PORT_OBJECT Port,
    IN ULONG MessageId,
    IN ULONG CallbackId,
    IN LPC_CLIENT_ID ClientId
    )

/*++

Routine Description:

    This routine is used to locate a specific message stored off the
    data info chain of a port

Arguments:

    Port - Supplies the port being examined

    MessageId - Supplies the ID of the message being searched for

    CallbackId - Supplies the callback ID being searched for

Return Value:

    PLPCP_MESSAGE - returns a pointer to the message satisfying the
        search criteria or NULL of none was found

--*/

{
    PLPCP_MESSAGE Msg;
    PLIST_ENTRY Head, Next;

    PAGED_CODE();

    //
    //  Make sure we get to the connection port object of this port
    //

    if ((Port->Flags & PORT_TYPE) > UNCONNECTED_COMMUNICATION_PORT) {

        Port = Port->ConnectionPort;

        if (Port == NULL) {

            return NULL;
        }
    }

    //
    //  Zoom down the data info chain for the connection port object looking
    //  for a match
    //

    Head = &Port->LpcDataInfoChainHead;
    Next = Head->Flink;

    while (Next != Head) {

        Msg = CONTAINING_RECORD( Next, LPCP_MESSAGE, Entry );

        if ((Msg->Request.MessageId == MessageId) &&
            (Msg->Request.ClientId.UniqueProcess == ClientId.UniqueProcess) &&
            (Msg->Request.ClientId.UniqueThread == ClientId.UniqueThread)) {

            LpcpTrace(( "%s Found DataInfo Message %lx (%u.%u)  Port: %lx\n",
                        PsGetCurrentProcess()->ImageFileName,
                        Msg,
                        Msg->Request.MessageId,
                        Msg->Request.CallbackId,
                        Port ));

            return Msg;

        } else {

            Next = Next->Flink;
        }
    }

    //
    //  We did not find a match so return null to our caller
    //

    LpcpTrace(( "%s Unable to find DataInfo Message (%u.%u)  Port: %lx\n",
                PsGetCurrentProcess()->ImageFileName,
                MessageId,
                CallbackId,
                Port ));

    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\lpc\lpcpriv.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    lpcpriv.c

Abstract:

    Local Inter-Process Communication privileged procedures that implement
    client impersonation.

--*/

#include "lpcp.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,LpcpFreePortClientSecurity)
#pragma alloc_text(PAGE,NtImpersonateClientOfPort)
#endif


NTSTATUS
NtImpersonateClientOfPort (
    __in HANDLE PortHandle,
    __in PPORT_MESSAGE Message
    )

/*++

Routine Description:

    This procedure is used by the server thread to temporarily acquire the
    identifier set of a client thread.

    This service establishes an impersonation token for the calling thread.
    The impersonation token corresponds to the context provided by the port
    client.  The client must currently be waiting for a reply to the
    specified message.

    This service returns an error status code if the client thread is not
    waiting for a reply to the message.  The security quality of service
    parameters specified by the client upon connection dictate what use the
    server will have of the client's security context.

    For complicated or extended impersonation needs, the server may open a
    copy of the client's token (using NtOpenThreadToken()).  This must be
    done while impersonating the client.

Arguments:

    PortHandle - Specifies the handle of the communication port that the
        message was received from.

    Message - Specifies an address of a message that was received from the
        client that is to be impersonated.  The ClientId field of the message
        identifies the client thread that is to be impersonated.  The client
        thread must be waiting for a reply to the message in order to
        impersonate the client.

Return Value:

    NTSTATUS - Status code that indicates whether or not the operation was
    successful.

--*/

{
    PLPCP_PORT_OBJECT PortObject;
    PLPCP_PORT_OBJECT ConnectedPort;
    KPROCESSOR_MODE PreviousMode;
    NTSTATUS Status;
    PETHREAD ClientThread;
    CLIENT_ID CapturedClientId;
    ULONG CapturedMessageId;
    SECURITY_CLIENT_CONTEXT DynamicSecurity;

    PAGED_CODE();

    //
    //  Get previous processor mode and probe output arguments if necessary.
    //

    PreviousMode = KeGetPreviousMode();

    if (PreviousMode != KernelMode) {

        try {

            ProbeForReadSmallStructure( Message, sizeof( PORT_MESSAGE ), sizeof( ULONG ));

            CapturedClientId = Message->ClientId;
            CapturedMessageId = Message->MessageId;

        } except( EXCEPTION_EXECUTE_HANDLER ) {

            return( GetExceptionCode() );
        }

    } else {

        CapturedClientId = Message->ClientId;
        CapturedMessageId = Message->MessageId;
    }

    //
    //  Reference the communication port object by handle.  Return status if
    //  unsuccessful.
    //

    Status = LpcpReferencePortObject( PortHandle, 0,
                                      PreviousMode, &PortObject );
    if (!NT_SUCCESS( Status )) {

        return( Status );
    }

    //
    //  It is an error to try this on any port other than a server
    //  communication port
    //

    if ((PortObject->Flags & PORT_TYPE) != SERVER_COMMUNICATION_PORT) {

        ObDereferenceObject( PortObject );

        return( STATUS_INVALID_PORT_HANDLE );
    }

    //
    //  Translate the ClientId from the connection request into a
    //  thread pointer.  This is a referenced pointer to keep the thread
    //  from evaporating out from under us.
    //

    Status = PsLookupProcessThreadByCid( &CapturedClientId,
                                         NULL,
                                         &ClientThread );

    if (!NT_SUCCESS( Status )) {

        ObDereferenceObject( PortObject );

        return( Status );
    }

    //
    //  Acquire the mutex that guards the LpcReplyMessage field of
    //  the thread and get the pointer to the message that the thread
    //  is waiting for a reply to.
    //

    LpcpAcquireLpcpLock();

    //
    //  The connected port can be in a state with 0 references in a deletion process.
    //  We need to test this case while referencing it.
    //

    ConnectedPort = PortObject->ConnectedPort;
    
    if ( ( ConnectedPort == NULL ) || 
         ( !ObReferenceObjectSafe( ConnectedPort ) ) ) {

        //
        //  The port is being deleted. Quit this function with 
        //  appropriate return status. 
        //  We don't need to dereference the connected port because 
        //  it is anyway about to be deleted
        //

        LpcpReleaseLpcpLock();

        ObDereferenceObject( PortObject );
        ObDereferenceObject( ClientThread );

        return( STATUS_PORT_DISCONNECTED );
    }

    //
    //  See if the thread is waiting for a reply to the message
    //  specified on this call, if the user gave us a bad
    //  message id.  If not then a bogus message
    //  has been specified, so return failure.
    //

    //
    //  The W2k fix searched the client thread in the rundown queue, to make sure
    //  we are not impersonating a port from a different connection. Ones we added the port
    //  to the thread structure to fix other security issues for reply os accessing data
    //  we can use that easy test for the impersonation too, w/o searching the rundown queue
    //

    if ((ClientThread->LpcReplyMessageId != CapturedMessageId) 
            ||
        (CapturedMessageId == 0) 
            ||
        (!LpcpValidateClientPort( ClientThread, 
                                  PortObject, 
                                  LPCP_VALIDATE_REASON_IMPERSONATION)) ) {

        LpcpReleaseLpcpLock();

        ObDereferenceObject( PortObject );
        ObDereferenceObject( ClientThread );
        ObDereferenceObject( ConnectedPort );

        return (STATUS_REPLY_MESSAGE_MISMATCH);
    }

    //
    //  Test whether the client allows impersonation for this message or not.
    //

    if (LpcpGetThreadAttributes(ClientThread) & LPCP_NO_IMPERSONATION) {
        
        LpcpReleaseLpcpLock();

        ObDereferenceObject( PortObject );
        ObDereferenceObject( ClientThread );
        ObDereferenceObject( ConnectedPort );

        return (STATUS_ACCESS_DENIED);
    }

    LpcpReleaseLpcpLock();

    //
    //  If the client requested dynamic security tracking, then the client
    //  security needs to be referenced.  Otherwise, (static case)
    //  it is already in the client's port.
    //

    if (ConnectedPort->Flags & PORT_DYNAMIC_SECURITY) {

        //
        //  Impersonate the client with information from the queued message
        //

        Status = LpcpGetDynamicClientSecurity( ClientThread,
                                               ConnectedPort,
                                               &DynamicSecurity );

        if (!NT_SUCCESS( Status )) {

            ObDereferenceObject( PortObject );
            ObDereferenceObject( ClientThread );
            ObDereferenceObject( ConnectedPort );

            return( Status );
        }

        Status = SeImpersonateClientEx( &DynamicSecurity, NULL );

        LpcpFreeDynamicClientSecurity( &DynamicSecurity );

    } else {

        //
        //  Impersonate the client with information from the client's port
        //

        Status = SeImpersonateClientEx( &ConnectedPort->StaticSecurity, NULL );

    }

    ObDereferenceObject( PortObject );
    ObDereferenceObject( ClientThread );
    ObDereferenceObject( ConnectedPort );

    //
    //  And return to our caller
    //

    return Status;
}


VOID
LpcpFreePortClientSecurity (
    IN PLPCP_PORT_OBJECT Port
    )

/*++

Routine Description:

    This routine cleans up the captured security context for a client port.
    The cleanup is typically done when we are deleting a port

Arguments:

    Port - Supplies the client port being deleted

Return Value:

    None.

--*/

{
    //
    //  We only do this action if supplied with a client communication port
    //

    if ((Port->Flags & PORT_TYPE) == CLIENT_COMMUNICATION_PORT) {

        //
        //  We only do this action if the port has static security tracking,
        //  and we have a captured client token.  The action is to simply
        //  delete the client token.
        //

        if (!(Port->Flags & PORT_DYNAMIC_SECURITY)) {

            if ( Port->StaticSecurity.ClientToken ) {

                SeDeleteClientSecurity( &(Port)->StaticSecurity );
            }
        }
    }

    //
    //  And return to our caller
    //

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\lpc\lpcquery.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    lpcquery.c

Abstract:

    Local Inter-Process Communication (LPC) query services

--*/

#include "lpcp.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,NtQueryInformationPort)
#endif


NTSTATUS
NTAPI
NtQueryInformationPort (
    __in HANDLE PortHandle,
    __in PORT_INFORMATION_CLASS PortInformationClass,
    __out_bcount(Length) PVOID PortInformation,
    __in ULONG Length,
    __out_opt PULONG ReturnLength
    )

/*++

Routine Description:

    This routine should be used to query an lpc port, but is pretty much a
    noop.  Currently it can only indicate if the input handle is for a port
    object.

Arguments:

    PortHandle - Supplies the handle for the port being queried

    PortInformationClass - Specifies the type information class being asked
        for.  Currently ignored.

    PortInformation - Supplies a pointer to the buffer to receive the
        information.  Currently just probed and then ignored.

    Length - Specifies, in bytes, the size of the port information buffer.

    ReturnLength  - Optionally receives the size, in bytes, of the information
        being returned.  Currently just probed and then ignored.

Return Value:

    NTSTATUS - An appropriate status value.

--*/

{
    KPROCESSOR_MODE PreviousMode;
    NTSTATUS Status;
    PLPCP_PORT_OBJECT PortObject;

    PAGED_CODE();

    UNREFERENCED_PARAMETER ( PortInformationClass );

    //
    //  Get previous processor mode and probe output argument if necessary.
    //

    PreviousMode = KeGetPreviousMode();

    if (PreviousMode != KernelMode) {

        try {

            ProbeForWrite( PortInformation,
                           Length,
                           sizeof( ULONG ));

            if (ARGUMENT_PRESENT( ReturnLength )) {

                ProbeForWriteUlong( ReturnLength );
            }

        } except( EXCEPTION_EXECUTE_HANDLER ) {

            return( GetExceptionCode() );
        }
    }

    //
    //  If the user gave us a handle then reference the object.  And return
    //  success if we got a good reference and an error otherwise.
    //

    if (ARGUMENT_PRESENT( PortHandle )) {

        Status = ObReferenceObjectByHandle( PortHandle,
                                            GENERIC_READ,
                                            LpcPortObjectType,
                                            PreviousMode,
                                            &PortObject,
                                            NULL );

        if (!NT_SUCCESS( Status )) {

            //
            //  It might be a waitable port object. 
            //  Let's try again as this object type
            //

            Status = ObReferenceObjectByHandle( PortHandle,
                                                GENERIC_READ,
                                                LpcWaitablePortObjectType,
                                                PreviousMode,
                                                &PortObject,
                                                NULL );

            //
            //  If this one fails too we'll return that status
            //

            if (!NT_SUCCESS( Status )) {

                return( Status );
            }
        }

        ObDereferenceObject( PortObject );

        return STATUS_SUCCESS;

    } else {

        return STATUS_INVALID_INFO_CLASS;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\lpc\lpcsend.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    lpcsend.c

Abstract:

    Local Inter-Process Communication (LPC) request system services.

--*/

#include "lpcp.h"

NTSTATUS
LpcpRequestWaitReplyPort (
    IN PVOID PortAddress,
    IN PPORT_MESSAGE RequestMessage,
    OUT PPORT_MESSAGE ReplyMessage,
    IN KPROCESSOR_MODE AccessMode
    );


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,NtRequestPort)
#pragma alloc_text(PAGE,NtRequestWaitReplyPort)
#pragma alloc_text(PAGE,LpcRequestPort)
#pragma alloc_text(PAGE,LpcRequestWaitReplyPort)
#pragma alloc_text(PAGE,LpcpRequestWaitReplyPort)
#pragma alloc_text(PAGE,LpcRequestWaitReplyPortEx)
#endif


NTSTATUS
NtRequestPort (
    __in HANDLE PortHandle,
    __in PPORT_MESSAGE RequestMessage
    )

/*++

Routine Description:

    A client and server process send datagram messages using this procedure.

    The message pointed to by the RequestMessage parameter is placed in the
    message queue of the port connected to the communication port specified
    by the PortHandle parameter.  This service returns an error if PortHandle
    is invalid or if the MessageId field of the PortMessage structure is
    non-zero.

Arguments:

    PortHandle - Specifies the handle of the communication port to send
        the request message to.

    RequestMessage - Specifies a pointer to the request message.  The Type
        field of the message is set to LPC_DATAGRAM by the service.

Return Value:

    NTSTATUS - A status code that indicates whether or not the operation was
        successful.

--*/

{
    PETHREAD CurrentThread;
    PLPCP_PORT_OBJECT PortObject;
    PLPCP_PORT_OBJECT QueuePort;
    PORT_MESSAGE CapturedRequestMessage;
    ULONG MsgType;
    KPROCESSOR_MODE PreviousMode;
    NTSTATUS Status;
    PLPCP_MESSAGE Msg;
    PLPCP_PORT_OBJECT ConnectionPort = NULL;

    PAGED_CODE();

    //
    //  Get previous processor mode and validate parameters
    //

    PreviousMode = KeGetPreviousMode();

    if (PreviousMode != KernelMode) {

        try {

            ProbeForReadSmallStructure( RequestMessage,
                                        sizeof( *RequestMessage ),
                                        PROBE_ALIGNMENT (PORT_MESSAGE));

            CapturedRequestMessage = *RequestMessage;
            CapturedRequestMessage.u2.s2.Type &= ~LPC_KERNELMODE_MESSAGE;

        } except( EXCEPTION_EXECUTE_HANDLER ) {

            return GetExceptionCode();
        }

        if (CapturedRequestMessage.u2.s2.Type != 0) {

            return STATUS_INVALID_PARAMETER;
        }

    } else {

        //
        //  This is a kernel mode caller
        //

        CapturedRequestMessage = *RequestMessage;

        if ((CapturedRequestMessage.u2.s2.Type & ~LPC_KERNELMODE_MESSAGE) != 0) {

            return STATUS_INVALID_PARAMETER;
        }
    }

    //
    //  Make sure that the caller has given us some data to send
    //

    if (CapturedRequestMessage.u2.s2.DataInfoOffset != 0) {

        return STATUS_INVALID_PARAMETER;
    }

    //
    //  Make sure DataLength is valid with respect to header size and total length
    //

    if ((((CLONG)CapturedRequestMessage.u1.s1.DataLength) + sizeof( PORT_MESSAGE )) >
        ((CLONG)CapturedRequestMessage.u1.s1.TotalLength)) {

        return STATUS_INVALID_PARAMETER;
    }

    //
    //  Reference the communication port object by handle.  Return status if
    //  unsuccessful.
    //

    Status = LpcpReferencePortObject( PortHandle,
                                      0,
                                      PreviousMode,
                                      &PortObject );

    if (!NT_SUCCESS( Status )) {

        return Status;
    }

    //
    //  Validate the message length
    //

    if (((ULONG)CapturedRequestMessage.u1.s1.TotalLength > PortObject->MaxMessageLength) ||
        ((ULONG)CapturedRequestMessage.u1.s1.TotalLength <= (ULONG)CapturedRequestMessage.u1.s1.DataLength)) {

        ObDereferenceObject( PortObject );

        return STATUS_PORT_MESSAGE_TOO_LONG;
    }

    //
    //  Determine which port to queue the message to and get client
    //  port context if client sending to server.  Also validate
    //  length of message being sent.
    //

    //
    //  Allocate and initialize the LPC message to send off
    //

    Msg = (PLPCP_MESSAGE)LpcpAllocateFromPortZone( CapturedRequestMessage.u1.s1.TotalLength );

    if (Msg == NULL) {

        ObDereferenceObject( PortObject );

        return STATUS_NO_MEMORY;
    }

    Msg->RepliedToThread = NULL;
    Msg->PortContext = NULL;
    MsgType = CapturedRequestMessage.u2.s2.Type | LPC_DATAGRAM;

    CurrentThread = PsGetCurrentThread();

    if (PreviousMode != KernelMode) {

        try {

            LpcpMoveMessage( &Msg->Request,
                            &CapturedRequestMessage,
                            (RequestMessage + 1),
                            MsgType,
                            &CurrentThread->Cid );

        } except( EXCEPTION_EXECUTE_HANDLER ) {

            Status = GetExceptionCode();

            LpcpFreeToPortZone( Msg, 0 );

            ObDereferenceObject( PortObject );

            return Status;
        }

    }
    else {

        LpcpMoveMessage( &Msg->Request,
                         &CapturedRequestMessage,
                         (RequestMessage + 1),
                         MsgType,
                         &CurrentThread->Cid );
    }

    //
    //  Acquire the global Lpc mutex that guards the LpcReplyMessage
    //  field of the thread and the request message queue.  Stamp the
    //  request message with a serial number, insert the message at
    //  the tail of the request message queue and remember the address
    //  of the message in the LpcReplyMessage field for the current thread.
    //

    LpcpAcquireLpcpLockByThread(CurrentThread);

    //
    //  Based on what type of port the caller gave us we'll need to get
    //  the port to actually queue the message off to.
    //

    if ((PortObject->Flags & PORT_TYPE) != SERVER_CONNECTION_PORT) {

        //
        //  The caller didn't give us a connection port so find the
        //  connection port for this port.  If it is null then we'll
        //  fall through without sending a message
        //

        QueuePort = PortObject->ConnectedPort;

        //
        //  Check if the queue port is in process of going away
        //

        if ( QueuePort != NULL) {

            //
            //  If the port is a client communication port then give the
            //  message the proper port context
            //

            if ((PortObject->Flags & PORT_TYPE) == CLIENT_COMMUNICATION_PORT) {

                Msg->PortContext = QueuePort->PortContext;
                ConnectionPort = QueuePort = PortObject->ConnectionPort;

                if (ConnectionPort == NULL) {

                    LpcpFreeToPortZone( Msg, LPCP_MUTEX_OWNED | LPCP_MUTEX_RELEASE_ON_RETURN );
                    
                    ObDereferenceObject( PortObject );

                    return STATUS_PORT_DISCONNECTED;
                }

            //
            //  In the case we don't have a CLIENT_COMMUNICATION_PORT nor 
            //  SERVER_COMMUNICATION_PORT we'll use the connection port
            //  to queue messages. 
            //    

            } else if ((PortObject->Flags & PORT_TYPE) != SERVER_COMMUNICATION_PORT) {

                ConnectionPort = QueuePort = PortObject->ConnectionPort;
                
                if (ConnectionPort == NULL) {

                    LpcpFreeToPortZone( Msg, LPCP_MUTEX_OWNED | LPCP_MUTEX_RELEASE_ON_RETURN );
                    
                    ObDereferenceObject( PortObject );
                    
                    return STATUS_PORT_DISCONNECTED;
                }
            }

            if (ConnectionPort) {

                ObReferenceObject( ConnectionPort );
            }
        }

    } else {

        //
        //  The caller supplied a server connection port so that is the port
        //  we queue off to
        //

        QueuePort = PortObject;
    }

    //
    //  At this point we have an LPC message ready to send and if queue port is
    //  not null then we have a port to actually send the message off to
    //

    if (QueuePort != NULL) {

        //
        //  Reference the QueuePort to prevent this port evaporating under us
        //  Test if the QueuePort isn't in the process of going away 
        //  (i.e. we need to have at least 2 references for this object when 
        //  ObReferenceObject returns). Note the LPC lock is still held.
        //

        if ( ObReferenceObjectSafe( QueuePort ) ) {

            //
            //  Finish filling in the message and then insert it in the queue
            //

            Msg->Request.MessageId = LpcpGenerateMessageId();
            Msg->Request.CallbackId = 0;
            Msg->SenderPort = PortObject;

            CurrentThread->LpcReplyMessageId = 0;

            InsertTailList( &QueuePort->MsgQueue.ReceiveHead, &Msg->Entry );

            LpcpTrace(( "%s Send DataGram (%s) Msg %lx [%08x %08x %08x %08x] to Port %lx (%s)\n",
                        PsGetCurrentProcess()->ImageFileName,
                        LpcpMessageTypeName[ Msg->Request.u2.s2.Type & ~LPC_KERNELMODE_MESSAGE ],
                        Msg,
                        *((PULONG)(Msg+1)+0),
                        *((PULONG)(Msg+1)+1),
                        *((PULONG)(Msg+1)+2),
                        *((PULONG)(Msg+1)+3),
                        QueuePort,
                        LpcpGetCreatorName( QueuePort )));

            //
            //  Release the mutex, increment the request message queue
            //  semaphore by one for the newly inserted request message
            //  then exit the critical region.
            //
            //  Disable APCs to prevent this thread from being suspended
            //  before being able to release the semaphore.
            //

            KeEnterCriticalRegionThread(&CurrentThread->Tcb);

            LpcpReleaseLpcpLock();

            KeReleaseSemaphore( QueuePort->MsgQueue.Semaphore,
                                LPC_RELEASE_WAIT_INCREMENT,
                                1L,
                                FALSE );

            //
            //  If this is a waitable port then we'll need to set the event for
            //  anyone that was waiting on the port
            //

            if ( QueuePort->Flags & PORT_WAITABLE ) {

                KeSetEvent( &QueuePort->WaitEvent,
                            LPC_RELEASE_WAIT_INCREMENT,
                            FALSE );
            }

            //
            //  Exit the critical region and release the port object
            //

            KeLeaveCriticalRegionThread(&CurrentThread->Tcb);

            if (ConnectionPort) {

                ObDereferenceObject( ConnectionPort );
            }
            
            ObDereferenceObject( QueuePort );
            ObDereferenceObject( PortObject );

            //
            //  And return to our caller.  This is the only successful way out
            //  of this routine
            //

            return Status;
        }
    }

    //
    //  At this point we have a message but not a valid port to queue it off
    //  to so we'll free up the port object and release the unused message.
    //

    LpcpFreeToPortZone( Msg, LPCP_MUTEX_OWNED | LPCP_MUTEX_RELEASE_ON_RETURN );

    ObDereferenceObject( PortObject );
    
    if (ConnectionPort) {

        ObDereferenceObject( ConnectionPort );
    }

    //
    //  And return the error status to our caller
    //

    return STATUS_PORT_DISCONNECTED;
}


NTSTATUS
NtRequestWaitReplyPort (
    __in HANDLE PortHandle,
    __in PPORT_MESSAGE RequestMessage,
    __out PPORT_MESSAGE ReplyMessage
    )

/*++

Routine Description:

    A client and server process can send a request and wait for a reply using
    the NtRequestWaitReplyPort service.

    If the Type field of the RequestMessage structure is euqal to LPC_REQUEST,
    then this is identified as a callback request.  The ClientId and MessageId
    fields are used to identify the thread that is waiting for a reply.  This
    thread is unblocked and the current thread that called this service then
    blocks waiting for a reply.

    The Type field of the message is set to LPC_REQUEST by the service.
    Otherwise the Type field of the message must be zero and it will be set to
    LPC_REQUEST by the service.  The message pointed to by the RequestMessage
    parameter is placed in the message queue of the port connected to the
    communication port specified by the PortHandle parameter.  This service
    returns an error if PortHandle is invalid.  The calling thread then blocks
    waiting for a reply.

    The reply message is stored in the location pointed to by the ReplyMessage
    parameter.  The ClientId, MessageId and message type fields will be filled
    in by the service.

Arguments:

    PortHandle - Specifies the handle of the communication port to send the
        request message to.

    RequestMessage - Specifies a pointer to a request message to send.

    ReplyMessage - Specifies the address of a variable that will receive the
        reply message.  This parameter may point to the same buffer as the
        RequestMessage parameter.

Return Value:

    NTSTATUS - A status code that indicates whether or not the operation was
        successful.

--*/

{
    PLPCP_PORT_OBJECT PortObject;
    PLPCP_PORT_OBJECT QueuePort;
    PLPCP_PORT_OBJECT RundownPort;
    PORT_MESSAGE CapturedRequestMessage;
    ULONG MsgType;
    PKSEMAPHORE ReleaseSemaphore;
    KPROCESSOR_MODE PreviousMode;
    NTSTATUS Status;
    PLPCP_MESSAGE Msg;
    PETHREAD CurrentThread;
    PETHREAD WakeupThread;
    BOOLEAN CallbackRequest;
    PORT_DATA_INFORMATION CapturedDataInfo;
    PLPCP_PORT_OBJECT ConnectionPort = NULL;
    LOGICAL NoImpersonate;

    PAGED_CODE();

    //
    //  We cannot wait for a reply if the current thread is exiting
    //

    CurrentThread = PsGetCurrentThread();

    if (CurrentThread->LpcExitThreadCalled) {

        return STATUS_THREAD_IS_TERMINATING;
    }

    //
    //  Get previous processor mode and probe output arguments if necessary.
    //

    PreviousMode = KeGetPreviousMode();

    if (PreviousMode != KernelMode) {

        try {

            ProbeForReadSmallStructure( RequestMessage,
                                        sizeof( *RequestMessage ),
                                        PROBE_ALIGNMENT (PORT_MESSAGE));

            CapturedRequestMessage = *RequestMessage;
            CapturedRequestMessage.u2.s2.Type &= ~LPC_KERNELMODE_MESSAGE;

            ProbeForWriteSmallStructure( ReplyMessage,
                                         sizeof( *ReplyMessage ),
                                         PROBE_ALIGNMENT (PORT_MESSAGE));

            //
            //  Make sure that if this message has a data info offset that
            //  the port data information actually fits in the message.
            //
            //  We first check that the DataInfoOffset doesn't put us beyond
            //  the end of the message.
            //
            //  Then we capture the data info record and compute a pointer to
            //  the first unused data entry based on the supplied count.  If
            //  the start of the message plus its total length doesn't come
            //  up to the first unused data entry then the last valid data
            //  entry doesn't fit in the message buffer.  Also if the data
            //  entry pointer that we compute is less than the data info
            //  pointer then we must have wrapped.
            //

            if (CapturedRequestMessage.u2.s2.DataInfoOffset != 0) {

                PPORT_DATA_INFORMATION DataInfo;
                PPORT_DATA_ENTRY DataEntry;

                if (((ULONG)CapturedRequestMessage.u2.s2.DataInfoOffset) > (CapturedRequestMessage.u1.s1.TotalLength - sizeof(PORT_DATA_INFORMATION))) {

                    return STATUS_INVALID_PARAMETER;
                }

                if ((ULONG)CapturedRequestMessage.u2.s2.DataInfoOffset < sizeof(PORT_MESSAGE)) {

                    return STATUS_INVALID_PARAMETER;
                }

                DataInfo = (PPORT_DATA_INFORMATION)(((PUCHAR)RequestMessage) + CapturedRequestMessage.u2.s2.DataInfoOffset);

                ProbeForReadSmallStructure( DataInfo,
                                            sizeof( *DataInfo ),
                                            PROBE_ALIGNMENT (PORT_DATA_INFORMATION));

                CapturedDataInfo = *DataInfo;

                if (CapturedDataInfo.CountDataEntries > ((CapturedRequestMessage.u1.s1.TotalLength - CapturedRequestMessage.u2.s2.DataInfoOffset) / sizeof(PORT_DATA_ENTRY))) {

                    return STATUS_INVALID_PARAMETER;
                }

                DataEntry = &(DataInfo->DataEntries[CapturedDataInfo.CountDataEntries]);

                if ( ((PUCHAR)DataEntry < (PUCHAR)DataInfo)
                        ||
                     ((((PUCHAR)RequestMessage) + CapturedRequestMessage.u1.s1.TotalLength) < (PUCHAR)DataEntry)) {

                    return STATUS_INVALID_PARAMETER;
                }
            }

        } except( EXCEPTION_EXECUTE_HANDLER ) {

            return GetExceptionCode();
        }

    } else {

        CapturedRequestMessage = *RequestMessage;

        if (CapturedRequestMessage.u2.s2.DataInfoOffset != 0) {

            PPORT_DATA_INFORMATION DataInfo;

            if (((ULONG)CapturedRequestMessage.u2.s2.DataInfoOffset) > (CapturedRequestMessage.u1.s1.TotalLength - sizeof(PORT_DATA_INFORMATION))) {

                return STATUS_INVALID_PARAMETER;
            }

            if ((ULONG)CapturedRequestMessage.u2.s2.DataInfoOffset < sizeof(PORT_MESSAGE)) {

                return STATUS_INVALID_PARAMETER;
            }
            
            DataInfo = (PPORT_DATA_INFORMATION)(((PUCHAR)RequestMessage) + CapturedRequestMessage.u2.s2.DataInfoOffset);

            CapturedDataInfo = *DataInfo;
        }
    }

    //
    //  Capture the NoImpersonateFlag and clear the bit if necessary
    //

    if (CapturedRequestMessage.u2.s2.Type & LPC_NO_IMPERSONATE) {

        NoImpersonate = TRUE;
        CapturedRequestMessage.u2.s2.Type &= ~LPC_NO_IMPERSONATE;

    } else {

        NoImpersonate = FALSE;
    }
    
    //
    //  If the message type is an lpc request then say we need a callback.
    //  Otherwise if it not an lpc request and it is not a kernel mode message
    //  then it is an illegal parameter.  A third case is if the type is
    //  a kernel mode message in which case we make it look like an lpc request
    //  but without the callback.
    //

    if ((CapturedRequestMessage.u2.s2.Type & ~LPC_KERNELMODE_MESSAGE) == LPC_REQUEST) {

        CallbackRequest = TRUE;

    } else if ((CapturedRequestMessage.u2.s2.Type & ~LPC_KERNELMODE_MESSAGE) != 0) {

        return STATUS_INVALID_PARAMETER;

    } else {

        CapturedRequestMessage.u2.s2.Type |= LPC_REQUEST;
        CallbackRequest = FALSE;
    }

    //
    //  Make sure DataLength is valid with respect to header size and total length
    //

    if ((((CLONG)CapturedRequestMessage.u1.s1.DataLength) + sizeof( PORT_MESSAGE )) >
        ((CLONG)CapturedRequestMessage.u1.s1.TotalLength)) {

        return STATUS_INVALID_PARAMETER;
    }

    //
    //  Reference the communication port object by handle.  Return status if
    //  unsuccessful.
    //

    Status = LpcpReferencePortObject( PortHandle,
                                      0,
                                      PreviousMode,
                                      &PortObject );

    if (!NT_SUCCESS( Status )) {

        return Status;
    }

    //
    //  Validate the message length
    //

    if (((ULONG)CapturedRequestMessage.u1.s1.TotalLength > PortObject->MaxMessageLength) ||
        ((ULONG)CapturedRequestMessage.u1.s1.TotalLength <= (ULONG)CapturedRequestMessage.u1.s1.DataLength)) {

        ObDereferenceObject( PortObject );

        return STATUS_PORT_MESSAGE_TOO_LONG;
    }

    //
    //  Determine which port to queue the message to and get client
    //  port context if client sending to server.  Also validate
    //  length of message being sent.
    //

    //
    //  Allocate and initialize the LPC message to send off
    //


    Msg = (PLPCP_MESSAGE)LpcpAllocateFromPortZone( CapturedRequestMessage.u1.s1.TotalLength );

    if (Msg == NULL) {

        ObDereferenceObject( PortObject );

        return STATUS_NO_MEMORY;
    }

    MsgType = CapturedRequestMessage.u2.s2.Type;

    //
    //  Check if we need to do a callback
    //

    if (CallbackRequest) {

        //
        //  Check for a valid request message id
        //

        if (CapturedRequestMessage.MessageId == 0) {

            LpcpFreeToPortZone( Msg, 0 );

            ObDereferenceObject( PortObject );

            return STATUS_INVALID_PARAMETER;
        }

        //
        //  Translate the ClientId from the request into a
        //  thread pointer.  This is a referenced pointer to keep the thread
        //  from evaporating out from under us.
        //

        Status = PsLookupProcessThreadByCid( &CapturedRequestMessage.ClientId,
                                             NULL,
                                             &WakeupThread );

        if (!NT_SUCCESS( Status )) {

            LpcpFreeToPortZone( Msg, 0 );

            ObDereferenceObject( PortObject );

            return Status;
        }

        //
        //  Acquire the mutex that guards the LpcReplyMessage field of
        //  the thread and get the pointer to the message that the thread
        //  is waiting for a reply to.
        //

        LpcpAcquireLpcpLockByThread(CurrentThread);

        //
        //  See if the thread is waiting for a reply to the message
        //  specified on this call.  If not then a bogus message has been
        //  specified, so release the mutex, dereference the thread
        //  and return failure.
        //

        if ((WakeupThread->LpcReplyMessageId != CapturedRequestMessage.MessageId)

                ||

            ((LpcpGetThreadMessage(WakeupThread) != NULL) &&
             (LpcpGetThreadMessage(WakeupThread)->Request.u2.s2.Type & ~LPC_KERNELMODE_MESSAGE) != LPC_REQUEST)
                
                ||

            (!LpcpValidateClientPort(WakeupThread, PortObject, LPCP_VALIDATE_REASON_REPLY)) ) {

            LpcpPrint(( "%s Attempted CallBack Request to Thread %lx (%s)\n",
                        PsGetCurrentProcess()->ImageFileName,
                        WakeupThread,
                        THREAD_TO_PROCESS( WakeupThread )->ImageFileName ));

            LpcpPrint(( "failed.  MessageId == %u  Client Id: %x.%x\n",
                        CapturedRequestMessage.MessageId,
                        CapturedRequestMessage.ClientId.UniqueProcess,
                        CapturedRequestMessage.ClientId.UniqueThread ));

            LpcpPrint(( "         Thread MessageId == %u  Client Id: %x.%x\n",
                        WakeupThread->LpcReplyMessageId,
                        WakeupThread->Cid.UniqueProcess,
                        WakeupThread->Cid.UniqueThread ));

#if DBG
            if (LpcpStopOnReplyMismatch) {

                DbgBreakPoint();
            }
#endif

            LpcpFreeToPortZone( Msg, LPCP_MUTEX_OWNED | LPCP_MUTEX_RELEASE_ON_RETURN );

            ObDereferenceObject( WakeupThread );
            ObDereferenceObject( PortObject );

            return STATUS_REPLY_MESSAGE_MISMATCH;
        }

        //
        //  Copy over the text of the message
        //

        try {

            LpcpMoveMessage( &Msg->Request,
                             &CapturedRequestMessage,
                             (RequestMessage + 1),
                             MsgType,
                             &CurrentThread->Cid );

            if (CapturedRequestMessage.u2.s2.DataInfoOffset != 0) {

                PPORT_DATA_INFORMATION DataInfo;

                DataInfo = (PPORT_DATA_INFORMATION)(((PUCHAR)&Msg->Request) + CapturedRequestMessage.u2.s2.DataInfoOffset);

                if ( DataInfo->CountDataEntries != CapturedDataInfo.CountDataEntries ) {
                    
                    Status = STATUS_INVALID_PARAMETER;
                }
            }
        } except( EXCEPTION_EXECUTE_HANDLER ) {

            Status = GetExceptionCode();
        }

        if (!NT_SUCCESS( Status )) {

            LpcpFreeToPortZone( Msg, LPCP_MUTEX_OWNED | LPCP_MUTEX_RELEASE_ON_RETURN );

            ObDereferenceObject( WakeupThread );
            ObDereferenceObject( PortObject );

            return Status;
        }

        //
        //  Under the protect of the global lock we'll get everything
        //  ready for the callback
        //

        QueuePort = NULL;
        Msg->PortContext = NULL;

        if ((PortObject->Flags & PORT_TYPE) == SERVER_CONNECTION_PORT) {

            RundownPort = PortObject;

        } else {

            RundownPort = PortObject->ConnectedPort;

            if (RundownPort == NULL) {

                LpcpFreeToPortZone( Msg, LPCP_MUTEX_OWNED | LPCP_MUTEX_RELEASE_ON_RETURN );

                ObDereferenceObject( WakeupThread );
                ObDereferenceObject( PortObject );

                return STATUS_PORT_DISCONNECTED;
            }

            if ((PortObject->Flags & PORT_TYPE) == CLIENT_COMMUNICATION_PORT) {

                Msg->PortContext = RundownPort->PortContext;
            }
        }

        Msg->Request.CallbackId = LpcpGenerateCallbackId();

        LpcpTrace(( "%s CallBack Request (%s) Msg %lx (%u.%u) [%08x %08x %08x %08x] to Thread %lx (%s)\n",
                    PsGetCurrentProcess()->ImageFileName,
                    LpcpMessageTypeName[ Msg->Request.u2.s2.Type & ~LPC_KERNELMODE_MESSAGE ],
                    Msg,
                    Msg->Request.MessageId,
                    Msg->Request.CallbackId,
                    *((PULONG)(Msg+1)+0),
                    *((PULONG)(Msg+1)+1),
                    *((PULONG)(Msg+1)+2),
                    *((PULONG)(Msg+1)+3),
                    WakeupThread,
                    THREAD_TO_PROCESS( WakeupThread )->ImageFileName ));

        //
        //  Add an extra reference so LpcExitThread does not evaporate
        //  the pointer before we get to the wait below
        //

        ObReferenceObject( WakeupThread );

        Msg->RepliedToThread = WakeupThread;

        WakeupThread->LpcReplyMessageId = 0;
        WakeupThread->LpcReplyMessage = (PVOID)Msg;

        //
        //  Remove the thread from the reply rundown list as we are sending a callback
        //

        if (!IsListEmpty( &WakeupThread->LpcReplyChain )) {

            RemoveEntryList( &WakeupThread->LpcReplyChain );

            InitializeListHead( &WakeupThread->LpcReplyChain );
        }

        CurrentThread->LpcReplyMessageId = Msg->Request.MessageId;
        CurrentThread->LpcReplyMessage = NULL;

        InsertTailList( &RundownPort->LpcReplyChainHead, &CurrentThread->LpcReplyChain );

        LpcpSetPortToThread( CurrentThread, PortObject );
        
        if (NoImpersonate) {

            LpcpSetThreadAttributes(CurrentThread, LPCP_NO_IMPERSONATION);
        }

        KeEnterCriticalRegionThread (&CurrentThread->Tcb);
        LpcpReleaseLpcpLock();

        //
        //  Wake up the thread that is waiting for an answer to its request
        //  inside of NtRequestWaitReplyPort or NtReplyWaitReplyPort
        //

        ReleaseSemaphore = &WakeupThread->LpcReplySemaphore;

    } else {

        //
        //  A callback is not required, so continue setting up the
        //  lpc message
        //

        try {

            LpcpMoveMessage( &Msg->Request,
                             &CapturedRequestMessage,
                             (RequestMessage + 1),
                             MsgType,
                             &CurrentThread->Cid );

            if (CapturedRequestMessage.u2.s2.DataInfoOffset != 0) {

                PPORT_DATA_INFORMATION DataInfo;

                DataInfo = (PPORT_DATA_INFORMATION)(((PUCHAR)&Msg->Request) + CapturedRequestMessage.u2.s2.DataInfoOffset);

                if ( DataInfo->CountDataEntries != CapturedDataInfo.CountDataEntries ) {

                    LpcpFreeToPortZone( Msg, 0 );

                    ObDereferenceObject( PortObject );

                    return STATUS_INVALID_PARAMETER;
                }
            }
        } except( EXCEPTION_EXECUTE_HANDLER ) {

            LpcpFreeToPortZone( Msg, 0 );

            ObDereferenceObject( PortObject );

            return GetExceptionCode();
        }

        //
        //  Acquire the global Lpc mutex that guards the LpcReplyMessage
        //  field of the thread and the request message queue.  Stamp the
        //  request message with a serial number, insert the message at
        //  the tail of the request message queue and remember the address
        //  of the message in the LpcReplyMessage field for the current thread.
        //

        LpcpAcquireLpcpLockByThread(CurrentThread);

        Msg->PortContext = NULL;

        if ((PortObject->Flags & PORT_TYPE) != SERVER_CONNECTION_PORT) {

            QueuePort = PortObject->ConnectedPort;

            if (QueuePort == NULL) {

                LpcpFreeToPortZone( Msg, LPCP_MUTEX_OWNED | LPCP_MUTEX_RELEASE_ON_RETURN );

                ObDereferenceObject( PortObject );

                return STATUS_PORT_DISCONNECTED;
            }

            RundownPort = QueuePort;

            if ((PortObject->Flags & PORT_TYPE) == CLIENT_COMMUNICATION_PORT) {

                Msg->PortContext = QueuePort->PortContext;
                ConnectionPort = QueuePort = PortObject->ConnectionPort;
                
                if (ConnectionPort == NULL) {

                    LpcpFreeToPortZone( Msg, LPCP_MUTEX_OWNED | LPCP_MUTEX_RELEASE_ON_RETURN );

                    ObDereferenceObject( PortObject );

                    return STATUS_PORT_DISCONNECTED;
                }

            } else if ((PortObject->Flags & PORT_TYPE) != SERVER_COMMUNICATION_PORT) {

                ConnectionPort = QueuePort = PortObject->ConnectionPort;
                
                if (ConnectionPort == NULL) {

                    LpcpFreeToPortZone( Msg, LPCP_MUTEX_OWNED | LPCP_MUTEX_RELEASE_ON_RETURN );

                    ObDereferenceObject( PortObject );

                    return STATUS_PORT_DISCONNECTED;
                }
            }

            if (ConnectionPort) {

                ObReferenceObject( ConnectionPort );
            }

        } else {

            QueuePort = PortObject;
            RundownPort = PortObject;
        }

        //
        //  Stamp the request message with a serial number, insert the message
        //  at the tail of the request message queue
        //

        Msg->RepliedToThread = NULL;
        Msg->Request.MessageId = LpcpGenerateMessageId();
        Msg->Request.CallbackId = 0;
        Msg->SenderPort = PortObject;

        CurrentThread->LpcReplyMessageId = Msg->Request.MessageId;
        CurrentThread->LpcReplyMessage = NULL;
        
        InsertTailList( &QueuePort->MsgQueue.ReceiveHead, &Msg->Entry );
        InsertTailList( &RundownPort->LpcReplyChainHead, &CurrentThread->LpcReplyChain );
        
        LpcpSetPortToThread(CurrentThread, PortObject);

        if (NoImpersonate) {

            LpcpSetThreadAttributes(CurrentThread, LPCP_NO_IMPERSONATION);
        }

        LpcpTrace(( "%s Send Request (%s) Msg %lx (%u) [%08x %08x %08x %08x] to Port %lx (%s)\n",
                    PsGetCurrentProcess()->ImageFileName,
                    LpcpMessageTypeName[ Msg->Request.u2.s2.Type & ~LPC_KERNELMODE_MESSAGE ],
                    Msg,
                    Msg->Request.MessageId,
                    *((PULONG)(Msg+1)+0),
                    *((PULONG)(Msg+1)+1),
                    *((PULONG)(Msg+1)+2),
                    *((PULONG)(Msg+1)+3),
                    QueuePort,
                    LpcpGetCreatorName( QueuePort )));

        KeEnterCriticalRegionThread (&CurrentThread->Tcb);
        LpcpReleaseLpcpLock();

        //
        //  Increment the request message queue semaphore by one for
        //  the newly inserted request message.
        //

        ReleaseSemaphore = QueuePort->MsgQueue.Semaphore;

        //
        //  If port is waitable then set the event that someone could
        //  be waiting on
        //

        if ( QueuePort->Flags & PORT_WAITABLE ) {

            KeSetEvent( &QueuePort->WaitEvent,
                        LPC_RELEASE_WAIT_INCREMENT,
                        FALSE );
        }
    }

    //
    //  At this point we've enqueued our request and if necessary
    //  set ourselves up for the callback or reply.
    //
    //  So now wake up the other end
    //

    Status = KeReleaseSemaphore( ReleaseSemaphore,
                                 1,
                                 1,
                                 FALSE );

    KeLeaveCriticalRegionThread (&CurrentThread->Tcb);
    if (CallbackRequest) {

        ObDereferenceObject( WakeupThread );
    }

    //
    //  And wait for a reply
    //

    Status = KeWaitForSingleObject( &CurrentThread->LpcReplySemaphore,
                                    WrLpcReply,
                                    PreviousMode,
                                    FALSE,
                                    NULL );

    if (Status == STATUS_USER_APC) {

        //
        //  if the semaphore is signaled, then clear it
        //

        if (KeReadStateSemaphore( &CurrentThread->LpcReplySemaphore )) {

            KeWaitForSingleObject( &CurrentThread->LpcReplySemaphore,
                                   WrExecutive,
                                   KernelMode,
                                   FALSE,
                                   NULL );

            Status = STATUS_SUCCESS;
        }
    }

    //
    //  Acquire the LPC mutex.  Remove the reply message from the current thread
    //

    LpcpAcquireLpcpLockByThread(CurrentThread);

    Msg = LpcpGetThreadMessage(CurrentThread);

    CurrentThread->LpcReplyMessage = NULL;
    CurrentThread->LpcReplyMessageId = 0;

    //
    //  Remove the thread from the reply rundown list in case we did not wakeup due to
    //  a reply
    //

    if (!IsListEmpty( &CurrentThread->LpcReplyChain )) {

        RemoveEntryList( &CurrentThread->LpcReplyChain );

        InitializeListHead( &CurrentThread->LpcReplyChain );
    }

#if DBG
    if (Status == STATUS_SUCCESS && Msg != NULL) {

        LpcpTrace(( "%s Got Reply Msg %lx (%u) [%08x %08x %08x %08x] for Thread %lx (%s)\n",
                    PsGetCurrentProcess()->ImageFileName,
                    Msg,
                    Msg->Request.MessageId,
                    *((PULONG)(Msg+1)+0),
                    *((PULONG)(Msg+1)+1),
                    *((PULONG)(Msg+1)+2),
                    *((PULONG)(Msg+1)+3),
                    CurrentThread,
                    THREAD_TO_PROCESS( CurrentThread )->ImageFileName ));

        if (!IsListEmpty( &Msg->Entry )) {

            LpcpTrace(( "Reply Msg %lx has non-empty list entry\n", Msg ));
        }
    }
#endif

    LpcpReleaseLpcpLock();

    //
    //  If the wait succeeded, copy the reply to the reply buffer.
    //

    if (Status == STATUS_SUCCESS) {

        if (Msg != NULL) {

            try {

                LpcpMoveMessage( ReplyMessage,
                                 &Msg->Request,
                                 (&Msg->Request) + 1,
                                 0,
                                 NULL );

            } except( EXCEPTION_EXECUTE_HANDLER ) {

                Status = GetExceptionCode();
            }

            //
            //  Acquire the LPC mutex and decrement the reference count for the
            //  message.  If the reference count goes to zero the message will be
            //  deleted.
            //

            if (((Msg->Request.u2.s2.Type & ~LPC_KERNELMODE_MESSAGE) == LPC_REQUEST) &&
                (Msg->Request.u2.s2.DataInfoOffset != 0)) {

                LpcpSaveDataInfoMessage( PortObject, Msg, 0 );

            } else {

                LpcpFreeToPortZone( Msg, 0 );
            }

        } else {

            Status = STATUS_LPC_REPLY_LOST;
        }

    } else {

        //
        //  Wait failed, free the message if any.
        //

        LpcpTrace(( "%s NtRequestWaitReply wait failed - Status == %lx\n",
                    PsGetCurrentProcess()->ImageFileName,
                    Status ));

        if (Msg != NULL) {

            LpcpFreeToPortZone( Msg, 0);
        }
    }

    ObDereferenceObject( PortObject );
    
    if (ConnectionPort) {

        ObDereferenceObject( ConnectionPort );
    }

    //
    //  And return to our caller
    //

    return Status;
}


NTSTATUS
LpcRequestPort (
    __in PVOID PortAddress,
    __in PPORT_MESSAGE RequestMessage
    )

/*++

Routine Description:

    This procedure is similar to NtRequestPort but without the Handle based
    interface.

Arguments:

    PortAddress - Supplies a pointer to the communication port to send
        the request message to.

    RequestMessage - Specifies a pointer to the request message.  The Type
        field of the message is set to LPC_DATAGRAM by the service.

Return Value:

    NTSTATUS - A status code that indicates whether or not the operation was
        successful.

--*/

{
    PETHREAD CurrentThread;
    PLPCP_PORT_OBJECT PortObject = (PLPCP_PORT_OBJECT)PortAddress;
    PLPCP_PORT_OBJECT QueuePort;
    ULONG MsgType;
    PLPCP_MESSAGE Msg;
    KPROCESSOR_MODE PreviousMode;
    PLPCP_PORT_OBJECT ConnectionPort = NULL;

    PAGED_CODE();

    //
    //  Get previous processor mode and validate parameters
    //

    PreviousMode = KeGetPreviousMode();

    if (RequestMessage->u2.s2.Type != 0) {

        MsgType = RequestMessage->u2.s2.Type & ~LPC_KERNELMODE_MESSAGE;

        if ((MsgType < LPC_DATAGRAM) ||
            (MsgType > LPC_CLIENT_DIED)) {

            return STATUS_INVALID_PARAMETER;
        }

        //
        //  If previous mode is kernel, allow the LPC_KERNELMODE_MESSAGE
        //  bit to be passed in message type field.
        //

        if ((PreviousMode == KernelMode) &&
            (RequestMessage->u2.s2.Type & LPC_KERNELMODE_MESSAGE)) {

            MsgType |= LPC_KERNELMODE_MESSAGE;
        }

    } else {

        MsgType = LPC_DATAGRAM;
    }

    if (RequestMessage->u2.s2.DataInfoOffset != 0) {

        return STATUS_INVALID_PARAMETER;
    }

    //
    //  Validate the message length
    //

    if (((ULONG)RequestMessage->u1.s1.TotalLength > PortObject->MaxMessageLength) ||
        ((ULONG)RequestMessage->u1.s1.TotalLength <= (ULONG)RequestMessage->u1.s1.DataLength)) {

        return STATUS_PORT_MESSAGE_TOO_LONG;
    }

    //
    //  Allocate a message block
    //


    Msg = (PLPCP_MESSAGE)LpcpAllocateFromPortZone( RequestMessage->u1.s1.TotalLength );

    if (Msg == NULL) {

        return STATUS_NO_MEMORY;
    }

    //
    //  Fill in the message block.
    //

    Msg->RepliedToThread = NULL;
    Msg->PortContext = NULL;

    CurrentThread = PsGetCurrentThread();

    LpcpMoveMessage( &Msg->Request,
                     RequestMessage,
                     (RequestMessage + 1),
                     MsgType,
                     &CurrentThread->Cid );

    //
    //  Acquire the global Lpc mutex that guards the LpcReplyMessage
    //  field of the thread and the request message queue.  Stamp the
    //  request message with a serial number, insert the message at
    //  the tail of the request message queue
    //

    LpcpAcquireLpcpLockByThread(CurrentThread);

    if ((PortObject->Flags & PORT_TYPE) != SERVER_CONNECTION_PORT) {

        QueuePort = PortObject->ConnectedPort;

        if (QueuePort != NULL) {

            if ((PortObject->Flags & PORT_TYPE) == CLIENT_COMMUNICATION_PORT) {

                Msg->PortContext = QueuePort->PortContext;
                ConnectionPort = QueuePort = PortObject->ConnectionPort;

                if (ConnectionPort == NULL) {

                    LpcpFreeToPortZone( Msg, LPCP_MUTEX_OWNED | LPCP_MUTEX_RELEASE_ON_RETURN );

                    return STATUS_PORT_DISCONNECTED;
                }

            //
            //  In the case we don't have a CLIENT_COMMUNICATION_PORT nor 
            //  SERVER_COMMUNICATION_PORT we'll use the connection port
            //  to queue messages. 
            //    

            } else if ((PortObject->Flags & PORT_TYPE) != SERVER_COMMUNICATION_PORT) {

                ConnectionPort = QueuePort = PortObject->ConnectionPort;
                
                if (ConnectionPort == NULL) {

                    LpcpFreeToPortZone( Msg, LPCP_MUTEX_OWNED | LPCP_MUTEX_RELEASE_ON_RETURN );

                    return STATUS_PORT_DISCONNECTED;
                }
            }

            if (ConnectionPort) {

                ObReferenceObject( ConnectionPort );
            }
        }

    } else {

        QueuePort = PortObject;
    }

    //
    //  At this point we have an LPC message ready to send and if queue port is
    //  not null then we have a port to actually send the message off to
    //

    if (QueuePort != NULL) {

        Msg->Request.MessageId = LpcpGenerateMessageId();
        Msg->Request.CallbackId = 0;
        Msg->SenderPort = PortObject;

        CurrentThread->LpcReplyMessageId = 0;

        InsertTailList( &QueuePort->MsgQueue.ReceiveHead, &Msg->Entry );

        LpcpTrace(( "%s Send DataGram (%s) Msg %lx [%08x %08x %08x %08x] to Port %lx (%s)\n",
                    PsGetCurrentProcess()->ImageFileName,
                    LpcpMessageTypeName[ Msg->Request.u2.s2.Type & ~LPC_KERNELMODE_MESSAGE ],
                    Msg,
                    *((PULONG)(Msg+1)+0),
                    *((PULONG)(Msg+1)+1),
                    *((PULONG)(Msg+1)+2),
                    *((PULONG)(Msg+1)+3),
                    QueuePort,
                    LpcpGetCreatorName( QueuePort )));

        //
        //  Release the mutex, increment the request message queue
        //  semaphore by one for the newly inserted request message,
        //  then exit the critical region.
        //
        //  Disable APCs to prevent this thread from being suspended
        //  before being able to release the semaphore.
        //

        KeEnterCriticalRegionThread(&CurrentThread->Tcb);

        LpcpReleaseLpcpLock();

        KeReleaseSemaphore( QueuePort->MsgQueue.Semaphore,
                            LPC_RELEASE_WAIT_INCREMENT,
                            1L,
                            FALSE );


        if ( QueuePort->Flags & PORT_WAITABLE ) {

            KeSetEvent( &QueuePort->WaitEvent,
                        LPC_RELEASE_WAIT_INCREMENT,
                        FALSE );
        }

        KeLeaveCriticalRegionThread(&CurrentThread->Tcb);

        if (ConnectionPort) {

            ObDereferenceObject( ConnectionPort );
        }

        return STATUS_SUCCESS;

    }

    //
    //  At this point we have a message but not a valid port to queue it off
    //  to so we'll release the unused message and release our mutex.
    //

    LpcpFreeToPortZone( Msg, LPCP_MUTEX_OWNED | LPCP_MUTEX_RELEASE_ON_RETURN );

    if (ConnectionPort) {

        ObDereferenceObject( ConnectionPort );
    }

    //
    //  And return the error status to our caller
    //

    return STATUS_PORT_DISCONNECTED;
}


NTSTATUS
LpcpRequestWaitReplyPort (
    IN PVOID PortAddress,
    IN PPORT_MESSAGE RequestMessage,
    OUT PPORT_MESSAGE ReplyMessage,
    IN KPROCESSOR_MODE AccessMode
    )

/*++

Routine Description:

    This procedure is similar to NtRequestWaitReplyPort but without the
    handle based interface

Arguments:

    PortAddress - Supplies the communication port object to send the
        request message to.

    RequestMessage - Specifies a pointer to a request message to send.

    ReplyMessage - Specifies the address of a variable that will receive the
        reply message.  This parameter may point to the same buffer as the
        RequestMessage parameter.

Return Value:

    NTSTATUS - A status code that indicates whether or not the operation was
        successful.

--*/

{
    PLPCP_PORT_OBJECT PortObject = (PLPCP_PORT_OBJECT)PortAddress;
    PLPCP_PORT_OBJECT QueuePort;
    PLPCP_PORT_OBJECT RundownPort;
    PKSEMAPHORE ReleaseSemaphore;
    NTSTATUS Status;
    ULONG MsgType;
    PLPCP_MESSAGE Msg;
    PETHREAD CurrentThread;
    PETHREAD WakeupThread;
    BOOLEAN CallbackRequest;
    KPROCESSOR_MODE PreviousMode;
    PLPCP_PORT_OBJECT ConnectionPort = NULL;

    PAGED_CODE();

    CurrentThread = PsGetCurrentThread();

    if (CurrentThread->LpcExitThreadCalled) {

        return STATUS_THREAD_IS_TERMINATING;
    }

    //
    //  Get previous processor mode and validate parameters
    //

    PreviousMode = KeGetPreviousMode();
    MsgType = RequestMessage->u2.s2.Type & ~LPC_KERNELMODE_MESSAGE;
    CallbackRequest = FALSE;

    switch (MsgType) {

    case 0:

        MsgType = LPC_REQUEST;
        break;

    case LPC_REQUEST:

        CallbackRequest = TRUE;
        break;

    case LPC_CLIENT_DIED:
    case LPC_PORT_CLOSED:
    case LPC_EXCEPTION:
    case LPC_DEBUG_EVENT:
    case LPC_ERROR_EVENT:

        break;

    default :

        return STATUS_INVALID_PARAMETER;
    }

    //
    //  Allow the LPC_KERNELMODE_MESSAGE
    //  bit to be passed in message type field. Don't check the previous mode !!!
    //

    if ( RequestMessage->u2.s2.Type & LPC_KERNELMODE_MESSAGE) {

        MsgType |= LPC_KERNELMODE_MESSAGE;
    }

    RequestMessage->u2.s2.Type = (CSHORT)MsgType;

    //
    //  Validate the message length
    //

    if (((ULONG)RequestMessage->u1.s1.TotalLength > PortObject->MaxMessageLength) ||
        ((ULONG)RequestMessage->u1.s1.TotalLength <= (ULONG)RequestMessage->u1.s1.DataLength)) {

        return STATUS_PORT_MESSAGE_TOO_LONG;
    }

    //
    //  Determine which port to queue the message to and get client
    //  port context if client sending to server.  Also validate
    //  length of message being sent.
    //


    Msg = (PLPCP_MESSAGE)LpcpAllocateFromPortZone( RequestMessage->u1.s1.TotalLength );


    if (Msg == NULL) {

        return STATUS_NO_MEMORY;
    }

    if (CallbackRequest) {

        //
        //  Check for a valid request message id
        //

        if (RequestMessage->MessageId == 0) {

            LpcpFreeToPortZone( Msg, 0 );

            return STATUS_INVALID_PARAMETER;
        }

        //
        //  Translate the ClientId from the request into a
        //  thread pointer.  This is a referenced pointer to keep the thread
        //  from evaporating out from under us.
        //

        Status = PsLookupProcessThreadByCid( &RequestMessage->ClientId,
                                             NULL,
                                             &WakeupThread );

        if (!NT_SUCCESS( Status )) {

            LpcpFreeToPortZone( Msg, 0 );

            return Status;
        }

        //
        //  Acquire the mutex that guards the LpcReplyMessage field of
        //  the thread and get the pointer to the message that the thread
        //  is waiting for a reply to.
        //

        LpcpAcquireLpcpLockByThread(CurrentThread);

        //
        //  See if the thread is waiting for a reply to the message
        //  specified on this call.  If not then a bogus message
        //  has been specified, so release the mutex, dereference the thread
        //  and return failure.
        //

        if ((WakeupThread->LpcReplyMessageId != RequestMessage->MessageId)

                ||

            ((LpcpGetThreadMessage(WakeupThread) != NULL) &&
             (LpcpGetThreadMessage(WakeupThread)->Request.u2.s2.Type & ~LPC_KERNELMODE_MESSAGE) != LPC_REQUEST)

                ||

            (!LpcpValidateClientPort(WakeupThread, PortObject, LPCP_VALIDATE_REASON_REPLY)) ) {

            LpcpFreeToPortZone( Msg, LPCP_MUTEX_OWNED | LPCP_MUTEX_RELEASE_ON_RETURN );

            ObDereferenceObject( WakeupThread );

            return STATUS_REPLY_MESSAGE_MISMATCH;
        }

        QueuePort = NULL;
        Msg->PortContext = NULL;

        if ((PortObject->Flags & PORT_TYPE) == SERVER_CONNECTION_PORT) {

            RundownPort = PortObject;

        } else {

            RundownPort = PortObject->ConnectedPort;

            if (RundownPort == NULL) {

                LpcpFreeToPortZone( Msg, LPCP_MUTEX_OWNED | LPCP_MUTEX_RELEASE_ON_RETURN );

                ObDereferenceObject( WakeupThread );

                return STATUS_PORT_DISCONNECTED;
            }

            if ((PortObject->Flags & PORT_TYPE) == CLIENT_COMMUNICATION_PORT) {

                Msg->PortContext = RundownPort->PortContext;
            }
        }
        
        //
        //  Allocate and initialize a request message
        //

        LpcpMoveMessage( &Msg->Request,
                         RequestMessage,
                         (RequestMessage + 1),
                         0,
                         &CurrentThread->Cid );

        Msg->Request.CallbackId = LpcpGenerateCallbackId();

        LpcpTrace(( "%s CallBack Request (%s) Msg %lx (%u.%u) [%08x %08x %08x %08x] to Thread %lx (%s)\n",
                    PsGetCurrentProcess()->ImageFileName,
                    LpcpMessageTypeName[ Msg->Request.u2.s2.Type & ~LPC_KERNELMODE_MESSAGE ],
                    Msg,
                    Msg->Request.MessageId,
                    Msg->Request.CallbackId,
                    *((PULONG)(Msg+1)+0),
                    *((PULONG)(Msg+1)+1),
                    *((PULONG)(Msg+1)+2),
                    *((PULONG)(Msg+1)+3),
                    WakeupThread,
                    THREAD_TO_PROCESS( WakeupThread )->ImageFileName ));

        //
        //  Add an extra reference so LpcExitThread does not evaporate
        //  the pointer before we get to the wait below
        //

        ObReferenceObject( WakeupThread );

        Msg->RepliedToThread = WakeupThread;

        WakeupThread->LpcReplyMessageId = 0;
        WakeupThread->LpcReplyMessage = (PVOID)Msg;

        //
        //  Remove the thread from the reply rundown list as we are sending a callback
        //

        if (!IsListEmpty( &WakeupThread->LpcReplyChain )) {

            RemoveEntryList( &WakeupThread->LpcReplyChain );

            InitializeListHead( &WakeupThread->LpcReplyChain );
        }

        CurrentThread->LpcReplyMessageId = Msg->Request.MessageId;
        CurrentThread->LpcReplyMessage = NULL;
        
        InsertTailList( &RundownPort->LpcReplyChainHead, &CurrentThread->LpcReplyChain );
        
        LpcpSetPortToThread(CurrentThread, PortObject);

        KeEnterCriticalRegionThread (&CurrentThread->Tcb);
        LpcpReleaseLpcpLock();

        //
        //  Wake up the thread that is waiting for an answer to its request
        //  inside of NtRequestWaitReplyPort or NtReplyWaitReplyPort
        //

        ReleaseSemaphore = &WakeupThread->LpcReplySemaphore;

    } else {

        //
        //  There is no callback requested
        //

        LpcpMoveMessage( &Msg->Request,
                         RequestMessage,
                         (RequestMessage + 1),
                         0,
                         &CurrentThread->Cid );

        //
        //  Acquire the global Lpc mutex that guards the LpcReplyMessage
        //  field of the thread and the request message queue.  Stamp the
        //  request message with a serial number, insert the message at
        //  the tail of the request message queue and remember the address
        //  of the message in the LpcReplyMessage field for the current thread.
        //

        LpcpAcquireLpcpLockByThread(CurrentThread);

        if ((CurrentThread->LpcReplyMessage != NULL)
                ||
            (CurrentThread->LpcReplyMessageId != 0)
                ||
            (CurrentThread->KeyedEventInUse)) {
            
            LpcpFreeToPortZone( Msg, LPCP_MUTEX_OWNED | LPCP_MUTEX_RELEASE_ON_RETURN );

            return STATUS_UNSUCCESSFUL;
        }

        Msg->PortContext = NULL;

        if ((PortObject->Flags & PORT_TYPE) != SERVER_CONNECTION_PORT) {

            QueuePort = PortObject->ConnectedPort;

            if (QueuePort == NULL) {

                LpcpFreeToPortZone( Msg, LPCP_MUTEX_OWNED | LPCP_MUTEX_RELEASE_ON_RETURN );

                return STATUS_PORT_DISCONNECTED;
            }

            RundownPort = QueuePort;

            if ((PortObject->Flags & PORT_TYPE) == CLIENT_COMMUNICATION_PORT) {

                Msg->PortContext = QueuePort->PortContext;
                ConnectionPort = QueuePort = PortObject->ConnectionPort;

                if (ConnectionPort == NULL) {

                    LpcpFreeToPortZone( Msg, LPCP_MUTEX_OWNED | LPCP_MUTEX_RELEASE_ON_RETURN );

                    return STATUS_PORT_DISCONNECTED;
                }

            } else if ((PortObject->Flags & PORT_TYPE) != SERVER_COMMUNICATION_PORT) {

                ConnectionPort = QueuePort = PortObject->ConnectionPort;
                
                if (ConnectionPort == NULL) {

                    LpcpFreeToPortZone( Msg, LPCP_MUTEX_OWNED | LPCP_MUTEX_RELEASE_ON_RETURN );

                    return STATUS_PORT_DISCONNECTED;
                }
            }

            if (ConnectionPort) {

                ObReferenceObject( ConnectionPort );
            }

        } else {

            if ((PortObject->Flags & PORT_NAME_DELETED) != 0) {
                LpcpFreeToPortZone( Msg, LPCP_MUTEX_OWNED | LPCP_MUTEX_RELEASE_ON_RETURN );

                return STATUS_PORT_DISCONNECTED;
            }

            QueuePort = PortObject;
            RundownPort = PortObject;
        }

        Msg->RepliedToThread = NULL;
        Msg->Request.MessageId = LpcpGenerateMessageId();
        Msg->Request.CallbackId = 0;
        Msg->SenderPort = PortObject;

        CurrentThread->LpcReplyMessageId = Msg->Request.MessageId;
        CurrentThread->LpcReplyMessage = NULL;

        InsertTailList( &QueuePort->MsgQueue.ReceiveHead, &Msg->Entry );
        InsertTailList( &RundownPort->LpcReplyChainHead, &CurrentThread->LpcReplyChain );
        
        LpcpSetPortToThread(CurrentThread, PortObject);

        LpcpTrace(( "%s Send Request (%s) Msg %lx (%u) [%08x %08x %08x %08x] to Port %lx (%s)\n",
                    PsGetCurrentProcess()->ImageFileName,
                    LpcpMessageTypeName[ Msg->Request.u2.s2.Type & ~LPC_KERNELMODE_MESSAGE ],
                    Msg,
                    Msg->Request.MessageId,
                    *((PULONG)(Msg+1)+0),
                    *((PULONG)(Msg+1)+1),
                    *((PULONG)(Msg+1)+2),
                    *((PULONG)(Msg+1)+3),
                    QueuePort,
                    LpcpGetCreatorName( QueuePort )));

        KeEnterCriticalRegionThread (&CurrentThread->Tcb);
        LpcpReleaseLpcpLock();

        //
        //  Increment the request message queue semaphore by one for
        //  the newly inserted request message.  Release the spin
        //  lock, while remaining at the dispatcher IRQL.  Then wait for the
        //  reply to this request by waiting on the LpcReplySemaphore
        //  for the current thread.
        //

        ReleaseSemaphore = QueuePort->MsgQueue.Semaphore;

        if ( QueuePort->Flags & PORT_WAITABLE ) {

            KeSetEvent( &QueuePort->WaitEvent,
                        LPC_RELEASE_WAIT_INCREMENT,
                        FALSE );
        }
    }

    //
    //  At this point we've enqueued our request and if necessary
    //  set ourselves up for the callback or reply.
    //
    //  So now wake up the other end
    //

    Status = KeReleaseSemaphore( ReleaseSemaphore,
                                 1,
                                 1,
                                 FALSE );
    KeLeaveCriticalRegionThread (&CurrentThread->Tcb);

    if (CallbackRequest) {

        ObDereferenceObject( WakeupThread );
    }

    //
    //  And wait for a reply
    //

    Status = KeWaitForSingleObject( &CurrentThread->LpcReplySemaphore,
                                    WrLpcReply,
                                    AccessMode,
                                    FALSE,
                                    NULL );

    if (Status == STATUS_USER_APC) {

        //
        //  if the semaphore is signaled, then clear it
        //

        if (KeReadStateSemaphore( &CurrentThread->LpcReplySemaphore )) {

            KeWaitForSingleObject( &CurrentThread->LpcReplySemaphore,
                                   WrExecutive,
                                   KernelMode,
                                   FALSE,
                                   NULL );

            Status = STATUS_SUCCESS;
        }
    }

    //
    //  Acquire the LPC mutex.  Remove the reply message from the current thread
    //

    LpcpAcquireLpcpLockByThread(CurrentThread);

    Msg = LpcpGetThreadMessage(CurrentThread);

    CurrentThread->LpcReplyMessage = NULL;
    CurrentThread->LpcReplyMessageId = 0;

    //
    //  Remove the thread from the reply rundown list in case we did not wakeup due to
    //  a reply
    //

    if (!IsListEmpty( &CurrentThread->LpcReplyChain )) {

        RemoveEntryList( &CurrentThread->LpcReplyChain );

        InitializeListHead( &CurrentThread->LpcReplyChain );
    }

#if DBG
    if (Msg != NULL) {

        LpcpTrace(( "%s Got Reply Msg %lx (%u) [%08x %08x %08x %08x] for Thread %lx (%s)\n",
                    PsGetCurrentProcess()->ImageFileName,
                    Msg,
                    Msg->Request.MessageId,
                    *((PULONG)(Msg+1)+0),
                    *((PULONG)(Msg+1)+1),
                    *((PULONG)(Msg+1)+2),
                    *((PULONG)(Msg+1)+3),
                    CurrentThread,
                    THREAD_TO_PROCESS( CurrentThread )->ImageFileName ));
    }
#endif

    LpcpReleaseLpcpLock();

    //
    //  If the wait succeeded, copy the reply to the reply buffer.
    //

    if (Status == STATUS_SUCCESS) {

        if (Msg != NULL) {

            LpcpMoveMessage( ReplyMessage,
                             &Msg->Request,
                             (&Msg->Request) + 1,
                             0,
                             NULL );

            //
            //  Acquire the LPC mutex and decrement the reference count for the
            //  message.  If the reference count goes to zero the message will be
            //  deleted.
            //

            LpcpAcquireLpcpLockByThread(CurrentThread);

            if (Msg->RepliedToThread != NULL) {

                ObDereferenceObject( Msg->RepliedToThread );

                Msg->RepliedToThread = NULL;
            }

            LpcpFreeToPortZone( Msg, LPCP_MUTEX_OWNED | LPCP_MUTEX_RELEASE_ON_RETURN );

        } else {

            Status = STATUS_LPC_REPLY_LOST;
        }

    } else {

        //
        //  Wait failed, free the message if any.
        //

        if (Msg != NULL) {

            LpcpFreeToPortZone( Msg, 0 );
        }
    }

    if (ConnectionPort) {

        ObDereferenceObject( ConnectionPort );
    }
    
    //
    //  And return to our caller
    //

    return Status;
}


NTSTATUS
LpcRequestWaitReplyPort (
    __in PVOID PortAddress,
    __in PPORT_MESSAGE RequestMessage,
    __out PPORT_MESSAGE ReplyMessage
    )
{
    return LpcpRequestWaitReplyPort( PortAddress,
                                     RequestMessage,
                                     ReplyMessage,
                                     KernelMode
                                   );
}


NTSTATUS
LpcRequestWaitReplyPortEx (
    IN PVOID PortAddress,
    IN PPORT_MESSAGE RequestMessage,
    OUT PPORT_MESSAGE ReplyMessage
    )
{
    return LpcpRequestWaitReplyPort( PortAddress,
                                     RequestMessage,
                                     ReplyMessage,
                                     KeGetPreviousMode()
                                   );
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\lpc\lpcreply.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    lpcreply.c

Abstract:

    Local Inter-Process Communication (LPC) reply system services.

--*/

#include "lpcp.h"

NTSTATUS
LpcpCopyRequestData (
    IN BOOLEAN WriteToMessageData,
    IN HANDLE PortHandle,
    IN PPORT_MESSAGE Message,
    IN ULONG DataEntryIndex,
    IN PVOID Buffer,
    IN SIZE_T BufferSize,
    OUT PSIZE_T NumberOfBytesCopied OPTIONAL
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,NtReplyPort)
#pragma alloc_text(PAGE,NtReplyWaitReplyPort)
#pragma alloc_text(PAGE,NtReadRequestData)
#pragma alloc_text(PAGE,NtWriteRequestData)
#pragma alloc_text(PAGE,LpcpCopyRequestData)
#pragma alloc_text(PAGE,LpcpValidateClientPort)

ULONG LpcMaxEventLogs = 10;

#define LPCP_PORT_NAME_MAX      256

typedef struct _LPC_WORK_CONTEXT {
    WORK_QUEUE_ITEM WorkItem;
    PVOID Buffer;
} LPC_WORK_CONTEXT, *PLPC_WORK_CONTEXT;

#endif

//
//  The current number of events registered
//

ULONG LpcpEventCounts = 0;


NTSTATUS
NtReplyPort (
    __in HANDLE PortHandle,
    __in PPORT_MESSAGE ReplyMessage
    )

/*++

Routine Description:

    A client and server process can send a reply to a previous request
    message with the NtReplyPort service:

    The Type field of the message is set to LPC_REPLY by the service.  If the
    MapInfoOffset field of the reply message is non-zero, then the
    PORT_MAP_INFORMATION structure it points to will be processed and the
    relevant pages in the caller's address space will be unmapped.

    The ClientId and MessageId fields of the ReplyMessage structure are used
    to identify the thread waiting for this reply.  If the target thread is
    in fact waiting for this reply message, then the reply message is copied
    into the thread's message buffer and the thread's wait is satisfied.

    If the thread is not waiting for a reply or is waiting for a reply to
    some other MessageId, then the message is placed in the message queue of
    the port that is connected to the communication port specified by the
    PortHandle parameter and the Type field of the message is set to
    LPC_LOST_REPLY.

Arguments:

    PortHandle - Specifies the handle of the communication port that the
        original message was received from.

    ReplyMessage - Specifies a pointer to the reply message to be sent.
        The ClientId and MessageId fields determine which thread will
        get the reply.

Return Value:

    Status code that indicates whether or not the operation was
    successful.

--*/

{
    KPROCESSOR_MODE PreviousMode;
    PLPCP_PORT_OBJECT PortObject;
    PORT_MESSAGE CapturedReplyMessage;
    NTSTATUS Status;
    PLPCP_MESSAGE Msg;
    PETHREAD CurrentThread;
    PETHREAD WakeupThread;

    PAGED_CODE();

    CurrentThread = PsGetCurrentThread();

    //
    //  Get previous processor mode and probe output arguments if necessary.
    //

    PreviousMode = KeGetPreviousMode();

    if (PreviousMode != KernelMode) {

        try {

            ProbeForReadSmallStructure( ReplyMessage,
                                        sizeof( *ReplyMessage ),
                                        sizeof( ULONG ));

            CapturedReplyMessage = *ReplyMessage;

        } except( EXCEPTION_EXECUTE_HANDLER ) {

            return GetExceptionCode();
        }

    } else {

        CapturedReplyMessage = *ReplyMessage;
    }

    //
    //  Make sure DataLength is valid with respect to header size and total
    //  length
    //

    if ((((CLONG)CapturedReplyMessage.u1.s1.DataLength) + sizeof( PORT_MESSAGE )) >
        ((CLONG)CapturedReplyMessage.u1.s1.TotalLength)) {

        return STATUS_INVALID_PARAMETER;
    }

    //
    //  Make sure the user didn't give us a bogus reply message id
    //

    if (CapturedReplyMessage.MessageId == 0) {

        return STATUS_INVALID_PARAMETER;
    }

    //
    //  Reference the port object by handle
    //

    Status = LpcpReferencePortObject( PortHandle,
                                      0,
                                      PreviousMode,
                                      &PortObject );

    if (!NT_SUCCESS( Status )) {

        Status = ObReferenceObjectByHandle( PortHandle,
                                            0,
                                            LpcWaitablePortObjectType,
                                            PreviousMode,
                                            &PortObject,
                                            NULL );

        if ( !NT_SUCCESS( Status ) ) {

            return Status;
        }
    }

    //
    //  Validate the message length
    //

    if (((ULONG)CapturedReplyMessage.u1.s1.TotalLength > PortObject->MaxMessageLength) ||
        ((ULONG)CapturedReplyMessage.u1.s1.TotalLength <= (ULONG)CapturedReplyMessage.u1.s1.DataLength)) {

        ObDereferenceObject( PortObject );

        return STATUS_PORT_MESSAGE_TOO_LONG;
    }

    //
    //  Translate the ClientId from the connection request into a thread
    //  pointer.  This is a referenced pointer to keep the thread from
    //  evaporating out from under us.
    //

    Status = PsLookupProcessThreadByCid( &CapturedReplyMessage.ClientId,
                                         NULL,
                                         &WakeupThread );

    if (!NT_SUCCESS( Status )) {

        ObDereferenceObject( PortObject );

        return Status;
    }

    //
    //  Acquire the mutex that guards the LpcReplyMessage field of the thread
    //  and get the pointer to the message that the thread is waiting for a
    //  reply to.
    //


    Msg = (PLPCP_MESSAGE)LpcpAllocateFromPortZone( CapturedReplyMessage.u1.s1.TotalLength );

    if (Msg == NULL) {

        LpcpTraceError(STATUS_NO_MEMORY, CurrentThread->Cid, &CapturedReplyMessage);

        ObDereferenceObject( WakeupThread );
        ObDereferenceObject( PortObject );

        return STATUS_NO_MEMORY;
    }
    LpcpAcquireLpcpLockByThread(CurrentThread);

    //
    //  See if the thread is waiting for a reply to the message specified on
    //  this call.  If not then a bogus message has been specified, so
    //  release the mutex, dereference the thread and return failure.
    //
    //  We also fail this request if the caller isn't replying to a request
    //  message.  For example, if the caller is replying to a connection
    //  request
    //
    
    if ((WakeupThread->LpcReplyMessageId != CapturedReplyMessage.MessageId)

            ||

        ((LpcpGetThreadMessage(WakeupThread) != NULL) &&
         (LpcpGetThreadMessage(WakeupThread)->Request.u2.s2.Type & ~LPC_KERNELMODE_MESSAGE) != LPC_REQUEST)
            
            ||

        (!LpcpValidateClientPort(WakeupThread, PortObject, LPCP_VALIDATE_REASON_REPLY)) ) {

        LpcpPrint(( "%s Attempted reply to Thread %lx (%s)\n",
                    PsGetCurrentProcess()->ImageFileName,
                    WakeupThread,
                    THREAD_TO_PROCESS( WakeupThread )->ImageFileName ));

        LpcpPrint(( "failed.  MessageId == %u  Client Id: %x.%x\n",
                    CapturedReplyMessage.MessageId,
                    CapturedReplyMessage.ClientId.UniqueProcess,
                    CapturedReplyMessage.ClientId.UniqueThread ));

        LpcpPrint(( "         Thread MessageId == %u  Client Id: %x.%x\n",
                    WakeupThread->LpcReplyMessageId,
                    WakeupThread->Cid.UniqueProcess,
                    WakeupThread->Cid.UniqueThread ));

#if DBG
        if (LpcpStopOnReplyMismatch) {

            DbgBreakPoint();
        }
#endif

        LpcpFreeToPortZone( Msg, LPCP_MUTEX_OWNED | LPCP_MUTEX_RELEASE_ON_RETURN );

        ObDereferenceObject( WakeupThread );
        ObDereferenceObject( PortObject );

        return STATUS_REPLY_MESSAGE_MISMATCH;
    }

    //
    //  Copy the reply message to the request message buffer.  Do this before
    //  we actually fiddle with the wakeup threads fields.  Otherwise we
    //  could mess up its state
    //

    try {

        LpcpMoveMessage( &Msg->Request,
                         &CapturedReplyMessage,
                         (ReplyMessage + 1),
                         LPC_REPLY,
                         NULL );

    } except( EXCEPTION_EXECUTE_HANDLER ) {

        LpcpFreeToPortZone( Msg, LPCP_MUTEX_OWNED | LPCP_MUTEX_RELEASE_ON_RETURN );

        ObDereferenceObject( WakeupThread );
        ObDereferenceObject( PortObject );

        return GetExceptionCode();
    }

    //
    //  At this point we know the thread is waiting for our reply
    //

    LpcpTrace(( "%s Sending Reply Msg %lx (%u, %x) [%08x %08x %08x %08x] to Thread %lx (%s)\n",
                PsGetCurrentProcess()->ImageFileName,
                Msg,
                CapturedReplyMessage.MessageId,
                CapturedReplyMessage.u2.s2.DataInfoOffset,
                *((PULONG)(Msg+1)+0),
                *((PULONG)(Msg+1)+1),
                *((PULONG)(Msg+1)+2),
                *((PULONG)(Msg+1)+3),
                WakeupThread,
                THREAD_TO_PROCESS( WakeupThread )->ImageFileName ));

    //
    //  Add an extra reference so LpcExitThread does not evaporate the
    //  pointer before we get to the wait below
    //

    ObReferenceObject( WakeupThread );

    //
    //  Release the mutex that guards the LpcReplyMessage field after marking
    //  message as being replied to.
    //

    Msg->RepliedToThread = WakeupThread;

    WakeupThread->LpcReplyMessageId = 0;
    WakeupThread->LpcReplyMessage = (PVOID)Msg;

    //
    //  Remove the thread from the reply rundown list as we are sending the
    //  reply.
    //

    if (!WakeupThread->LpcExitThreadCalled && !IsListEmpty( &WakeupThread->LpcReplyChain )) {

        RemoveEntryList( &WakeupThread->LpcReplyChain );

        InitializeListHead( &WakeupThread->LpcReplyChain );
    }

    if ((CurrentThread->LpcReceivedMsgIdValid) &&
        (CurrentThread->LpcReceivedMessageId == CapturedReplyMessage.MessageId)) {

        CurrentThread->LpcReceivedMessageId = 0;
        CurrentThread->LpcReceivedMsgIdValid = FALSE;
    }

    //
    //  Locate and free the message from the port.  This call use to
    //  test for (CapturedReplyMessage.u2.s2.DataInfoOffset != 0) as a
    //  prerequisite for doing the call.
    //

    LpcpFreeDataInfoMessage( PortObject,
                             CapturedReplyMessage.MessageId,
                             CapturedReplyMessage.CallbackId,
                             CapturedReplyMessage.ClientId );

    LpcpReleaseLpcpLock();

    //
    //  Wake up the thread that is waiting for an answer to its request
    //  inside of NtRequestWaitReplyPort or NtReplyWaitReplyPort.  That
    //  will dereference itself when it wakes up.
    //

    KeReleaseSemaphore( &WakeupThread->LpcReplySemaphore,
                        0,
                        1L,
                        FALSE );

    ObDereferenceObject( WakeupThread );

    //
    //  Dereference port object and return the system service status.
    //

    ObDereferenceObject( PortObject );

    return Status;
}


NTSTATUS
NtReplyWaitReplyPort (
    __in HANDLE PortHandle,
    __inout PPORT_MESSAGE ReplyMessage
    )

/*++

Routine Description:

    A client and server process can send a reply to a previous message and
    block waiting for a reply using the NtReplyWaitReplyPort service:

    This service works the same as NtReplyPort, except that after delivering
    the reply message, it blocks waiting for a reply to a previous message.
    When the reply is received, it will be placed in the location specified
    by the ReplyMessage parameter.

Arguments:

    PortHandle - Specifies the handle of the communication port that the
        original message was received from.

    ReplyMessage - Specifies a pointer to the reply message to be sent.
        The ClientId and MessageId fields determine which thread will
        get the reply.  This buffer also receives any reply that comes
        back from the wait.

Return Value:

    Status code that indicates whether or not the operation was
    successful.

--*/

{
    KPROCESSOR_MODE PreviousMode;
    NTSTATUS Status;
    PLPCP_PORT_OBJECT PortObject;
    PORT_MESSAGE CapturedReplyMessage;
    PLPCP_MESSAGE Msg;
    PETHREAD CurrentThread;
    PETHREAD WakeupThread;
    PLPCP_PORT_OBJECT RundownPort;

    PAGED_CODE();

    CurrentThread = PsGetCurrentThread();

    //
    //  Get previous processor mode and probe output arguments if necessary.
    //

    PreviousMode = KeGetPreviousMode();

    if (PreviousMode != KernelMode) {

        try {

            ProbeForWriteSmallStructure( ReplyMessage,
                                         sizeof( *ReplyMessage ),
                                         sizeof( ULONG ));

            CapturedReplyMessage = *ReplyMessage;

        } except( EXCEPTION_EXECUTE_HANDLER ) {

            return GetExceptionCode();
        }

    } else {

        CapturedReplyMessage = *ReplyMessage;
    }

    //
    //  Make sure DataLength is valid with respect to header size and total length
    //

    if ((((CLONG)CapturedReplyMessage.u1.s1.DataLength) + sizeof( PORT_MESSAGE )) >
        ((CLONG)CapturedReplyMessage.u1.s1.TotalLength)) {

        return STATUS_INVALID_PARAMETER;
    }

    //
    //  Make sure the user didn't give us a bogus reply message id
    //

    if (CapturedReplyMessage.MessageId == 0) {

        return STATUS_INVALID_PARAMETER;
    }

    //
    //  Reference the communication port object by handle.  Return status if
    //  unsuccessful.
    //

    Status = LpcpReferencePortObject( PortHandle,
                                      0,
                                      PreviousMode,
                                      &PortObject );

    if (!NT_SUCCESS( Status )) {

        return Status;
    }

    //
    //  Validate the message length
    //

    if (((ULONG)CapturedReplyMessage.u1.s1.TotalLength > PortObject->MaxMessageLength) ||
        ((ULONG)CapturedReplyMessage.u1.s1.TotalLength <= (ULONG)CapturedReplyMessage.u1.s1.DataLength)) {

        ObDereferenceObject( PortObject );

        return STATUS_PORT_MESSAGE_TOO_LONG;
    }

    //
    //  Translate the ClientId from the connection request into a
    //  thread pointer.  This is a referenced pointer to keep the thread
    //  from evaporating out from under us.
    //

    Status = PsLookupProcessThreadByCid( &CapturedReplyMessage.ClientId,
                                         NULL,
                                         &WakeupThread );

    if (!NT_SUCCESS( Status )) {

        ObDereferenceObject( PortObject );

        return Status;
    }

    //
    //  Acquire the mutex that guards the LpcReplyMessage field of
    //  the thread and get the pointer to the message that the thread
    //  is waiting for a reply to.
    //


    Msg = (PLPCP_MESSAGE)LpcpAllocateFromPortZone( CapturedReplyMessage.u1.s1.TotalLength );

    if (Msg == NULL) {

        LpcpTraceError(STATUS_NO_MEMORY, CurrentThread->Cid, &CapturedReplyMessage);

        ObDereferenceObject( WakeupThread );
        ObDereferenceObject( PortObject );

        return STATUS_NO_MEMORY;
    }
    LpcpAcquireLpcpLockByThread(CurrentThread);

    //
    //  See if the thread is waiting for a reply to the message
    //  specified on this call.  If not then a bogus message
    //  has been specified, so release the mutex, dereference the thread
    //  and return failure.
    //
    //  We also fail this request if the caller isn't replying to a request
    //  message.  For example, if the caller is replying to a connection
    //  request
    //

    if ((WakeupThread->LpcReplyMessageId != CapturedReplyMessage.MessageId)

            ||

        ((LpcpGetThreadMessage(WakeupThread) != NULL) &&
         (LpcpGetThreadMessage(WakeupThread)->Request.u2.s2.Type & ~LPC_KERNELMODE_MESSAGE) != LPC_REQUEST)

            ||

        (!LpcpValidateClientPort(WakeupThread, PortObject, LPCP_VALIDATE_REASON_REPLY)) ) {

        LpcpPrint(( "%s Attempted reply wait reply to Thread %lx (%s)\n",
                    PsGetCurrentProcess()->ImageFileName,
                    WakeupThread,
                    THREAD_TO_PROCESS( WakeupThread )->ImageFileName ));

        LpcpPrint(( "failed.  MessageId == %u  Client Id: %x.%x\n",
                    CapturedReplyMessage.MessageId,
                    CapturedReplyMessage.ClientId.UniqueProcess,
                    CapturedReplyMessage.ClientId.UniqueThread ));

        LpcpPrint(( "         Thread MessageId == %u  Client Id: %x.%x\n",
                    WakeupThread->LpcReplyMessageId,
                    WakeupThread->Cid.UniqueProcess,
                    WakeupThread->Cid.UniqueThread ));

#if DBG
        if (LpcpStopOnReplyMismatch) {

            DbgBreakPoint();
        }
#endif

        LpcpFreeToPortZone( Msg, LPCP_MUTEX_OWNED | LPCP_MUTEX_RELEASE_ON_RETURN );

        ObDereferenceObject( WakeupThread );
        ObDereferenceObject( PortObject );

        return STATUS_REPLY_MESSAGE_MISMATCH;
    }

    //
    //  Copy the reply message to the request message buffer.  Do this before
    //  we actually fiddle with the wakeup threads fields.  Otherwise we
    //  could mess up its state
    //

    try {

        LpcpMoveMessage( &Msg->Request,
                         &CapturedReplyMessage,
                         (ReplyMessage + 1),
                         LPC_REPLY,
                         NULL );

    } except( EXCEPTION_EXECUTE_HANDLER ) {

        LpcpFreeToPortZone( Msg, LPCP_MUTEX_OWNED | LPCP_MUTEX_RELEASE_ON_RETURN );

        ObDereferenceObject( WakeupThread );
        ObDereferenceObject( PortObject );

        return (Status = GetExceptionCode());
    }

    //
    //  At this point we know the thread is waiting for our reply
    //

    LpcpTrace(( "%s Sending Reply Wait Reply Msg %lx (%u, %x) [%08x %08x %08x %08x] to Thread %lx (%s)\n",
                PsGetCurrentProcess()->ImageFileName,
                Msg,
                CapturedReplyMessage.MessageId,
                CapturedReplyMessage.u2.s2.DataInfoOffset,
                *((PULONG)(Msg+1)+0),
                *((PULONG)(Msg+1)+1),
                *((PULONG)(Msg+1)+2),
                *((PULONG)(Msg+1)+3),
                WakeupThread,
                THREAD_TO_PROCESS( WakeupThread )->ImageFileName ));

    //
    //  Add an extra reference so LpcExitThread does not evaporate
    //  the pointer before we get to the wait below
    //

    ObReferenceObject( WakeupThread );

    //
    //  Release the mutex that guards the LpcReplyMessage field
    //  after marking message as being replied to.
    //

    Msg->RepliedToThread = WakeupThread;

    WakeupThread->LpcReplyMessageId = 0;
    WakeupThread->LpcReplyMessage = (PVOID)Msg;

    //
    //  Remove the thread from the reply rundown list as we are sending the reply.
    //

    if (!WakeupThread->LpcExitThreadCalled && !IsListEmpty( &WakeupThread->LpcReplyChain )) {

        RemoveEntryList( &WakeupThread->LpcReplyChain );

        InitializeListHead( &WakeupThread->LpcReplyChain );
    }

    //
    //  Set ourselves up to get the following reply
    //

    CurrentThread->LpcReplyMessageId = CapturedReplyMessage.MessageId;
    CurrentThread->LpcReplyMessage = NULL;
    
    if ((CurrentThread->LpcReceivedMsgIdValid) &&
        (CurrentThread->LpcReceivedMessageId == CapturedReplyMessage.MessageId)) {

        CurrentThread->LpcReceivedMessageId = 0;
        CurrentThread->LpcReceivedMsgIdValid = FALSE;
    }

    //
    //  Insert the current thread into the rundown queue
    //

    if ((PortObject->Flags & PORT_TYPE) != SERVER_CONNECTION_PORT) {

        RundownPort = PortObject->ConnectedPort;
    
    } else {
        
        RundownPort = PortObject;
    }
    
    InsertTailList( &RundownPort->LpcReplyChainHead, &CurrentThread->LpcReplyChain );
    
    //
    //  Save the port context in the current thread, because
    //  it waits a reply from the same message
    //
    
    LpcpSetPortToThread(CurrentThread, PortObject);

    //
    //  Locate and free the message from the port.  This call use to
    //  test for (CapturedReplyMessage.u2.s2.DataInfoOffset != 0) as a
    //  prerequisite for doing the call.
    //

    LpcpFreeDataInfoMessage( PortObject,
                             CapturedReplyMessage.MessageId,
                             CapturedReplyMessage.CallbackId,
                             CapturedReplyMessage.ClientId );

    LpcpReleaseLpcpLock();

    //
    //  Wake up the thread that is waiting for an answer to its request
    //  inside of NtRequestWaitReplyPort or NtReplyWaitReplyPort.  That
    //  will dereference itself when it wakes up.
    //

    KeReleaseSemaphore( &WakeupThread->LpcReplySemaphore,
                        1,
                        1,
                        FALSE );

    ObDereferenceObject( WakeupThread );

    //
    //  And wait for a reply
    //

    Status = KeWaitForSingleObject( &CurrentThread->LpcReplySemaphore,
                                    Executive,
                                    PreviousMode,
                                    FALSE,
                                    NULL );

    if (Status == STATUS_USER_APC) {

        //
        //  if the semaphore is signaled, then clear it
        //

        if (KeReadStateSemaphore( &CurrentThread->LpcReplySemaphore )) {

            KeWaitForSingleObject( &CurrentThread->LpcReplySemaphore,
                                   WrExecutive,
                                   KernelMode,
                                   FALSE,
                                   NULL );

            Status = STATUS_SUCCESS;
        }
    }

    //
    //  Remove the thread from the reply rundown list in case we did not wakeup due to
    //  a reply
    //
    
    LpcpAcquireLpcpLockByThread(CurrentThread);

    if (!IsListEmpty( &CurrentThread->LpcReplyChain )) {

        RemoveEntryList( &CurrentThread->LpcReplyChain );

        InitializeListHead( &CurrentThread->LpcReplyChain );
    }
    
    //
    //  If the wait succeeded, copy the reply to the reply buffer.
    //

    if (Status == STATUS_SUCCESS) {

        //
        //  Acquire the mutex that guards the request message queue.  Remove
        //  the request message from the list of messages being processed and
        //  free the message back to the queue's zone.  If the zone's free
        //  list was zero before freeing this message then pulse the free
        //  event after free the message so that threads waiting to allocate
        //  a request message buffer will wake up.  Finally, release the mutex
        //  and return the system service status.
        //

        Msg = LpcpGetThreadMessage(CurrentThread);
        CurrentThread->LpcReplyMessage = NULL;

#if DBG
        if (Msg != NULL) {

            LpcpTrace(( "%s Got Reply Msg %lx (%u) [%08x %08x %08x %08x] for Thread %lx (%s)\n",
                        PsGetCurrentProcess()->ImageFileName,
                        Msg,
                        Msg->Request.MessageId,
                        *((PULONG)(Msg+1)+0),
                        *((PULONG)(Msg+1)+1),
                        *((PULONG)(Msg+1)+2),
                        *((PULONG)(Msg+1)+3),
                        CurrentThread,
                        THREAD_TO_PROCESS( CurrentThread )->ImageFileName ));

            if (!IsListEmpty( &Msg->Entry )) {

                LpcpTrace(( "Reply Msg %lx has non-empty list entry\n", Msg ));
            }
        }
#endif

        LpcpReleaseLpcpLock();

        if (Msg != NULL) {

            try {

                LpcpMoveMessage( ReplyMessage,
                                 &Msg->Request,
                                 (&Msg->Request) + 1,
                                 0,
                                 NULL );

            } except( EXCEPTION_EXECUTE_HANDLER ) {

                Status = GetExceptionCode();
            }

            //
            //  Acquire the LPC mutex and decrement the reference count for the
            //  message.  If the reference count goes to zero the message will be
            //  deleted.
            //

            LpcpAcquireLpcpLockByThread(CurrentThread);

            if (Msg->RepliedToThread != NULL) {

                ObDereferenceObject( Msg->RepliedToThread );

                Msg->RepliedToThread = NULL;
            }

            LpcpFreeToPortZone( Msg, LPCP_MUTEX_OWNED | LPCP_MUTEX_RELEASE_ON_RETURN );

        } else {

            Status = STATUS_LPC_REPLY_LOST;
        }
    }
    else {
        LpcpReleaseLpcpLock();
    }

    ObDereferenceObject( PortObject );

    return Status;
}


NTSTATUS
NtReadRequestData (
    __in HANDLE PortHandle,
    __in PPORT_MESSAGE Message,
    __in ULONG DataEntryIndex,
    __out_bcount(BufferSize) PVOID Buffer,
    __in SIZE_T BufferSize,
    __out_opt PSIZE_T NumberOfBytesRead
    )

/*++

Routine Description:

    This routine is used to copy data from a port message into the user
    supplied buffer.

Arguments:

    PortHandle - Supplies the port from which the message is being read

    Message - Supplies the message that we are trying to read

    DataEntryIndex - Supplies the index of the port data entry in the
        preceding message that we are reading

    Buffer - Supplies the location into which the data is to be read

    BufferSize - Supplies the size, in bytes, of the preceding buffer

    NumberOfBytesRead - Optionally returns the number of bytes read into
        the buffer

Return Value:

    NTSTATUS - An appropriate status value

--*/

{
    NTSTATUS status;

    PAGED_CODE();


    status = LpcpCopyRequestData( FALSE,
                                PortHandle,
                                Message,
                                DataEntryIndex,
                                Buffer,
                                BufferSize,
                                NumberOfBytesRead );
    
    return status;
}


NTSTATUS
NtWriteRequestData (
    __in HANDLE PortHandle,
    __in PPORT_MESSAGE Message,
    __in ULONG DataEntryIndex,
    __in_bcount(BufferSize) PVOID Buffer,
    __in SIZE_T BufferSize,
    __out_opt PSIZE_T NumberOfBytesWritten
    )

/*++

Routine Description:

    This routine is used to copy data from the user supplied buffer into the
    port message

Arguments:

    PortHandle - Supplies the port into which the message is being written

    Message - Supplies the message that we are trying to write

    DataEntryIndex - Supplies the index of the port data entry in the
        preceding message that we are writing

    Buffer - Supplies the location into which the data is to be written

    BufferSize - Supplies the size, in bytes, of the preceding buffer

    NumberOfBytesWritten - Optionally returns the number of bytes written from
        the buffer

Return Value:

    NTSTATUS - An appropriate status value

--*/

{
    NTSTATUS status;

    PAGED_CODE();

    status = LpcpCopyRequestData( TRUE,
                                PortHandle,
                                Message,
                                DataEntryIndex,
                                Buffer,
                                BufferSize,
                                NumberOfBytesWritten );

    return status;
}


//
//  Local support routine
//

NTSTATUS
LpcpCopyRequestData (
    IN BOOLEAN WriteToMessageData,
    IN HANDLE PortHandle,
    IN PPORT_MESSAGE Message,
    IN ULONG DataEntryIndex,
    IN PVOID Buffer,
    IN SIZE_T BufferSize,
    OUT PSIZE_T NumberOfBytesCopied OPTIONAL
    )

/*++

Routine Description:

    This routine will copy data to or from the user supplied buffer and the
    port message data information buffer

Arguments:

    WriteToMessageData - TRUE if the data is to be copied from the user buffer
        to the message and FALSE otherwise

    PortHandle - Supplies the port into which the message is being manipulated

    Message - Supplies the message that we are trying to manipulate

    DataEntryIndex - Supplies the index of the port data entry in the
        preceding message that we are transferring

    Buffer - Supplies the location into which the data is to be transferred

    BufferSize - Supplies the size, in bytes, of the preceding buffer

    NumberOfBytesRead - Optionally returns the number of bytes transferred from
        the buffer

Return Value:

    NTSTATUS - An appropriate status value

--*/

{
    KPROCESSOR_MODE PreviousMode;
    PLPCP_PORT_OBJECT PortObject;
    PLPCP_MESSAGE Msg;
    NTSTATUS Status;
    PETHREAD ClientThread;
    PPORT_DATA_INFORMATION DataInfo;
    PPORT_DATA_ENTRY DataEntry;
    PORT_MESSAGE CapturedMessage;
    PORT_DATA_ENTRY CapturedDataEntry;
    SIZE_T BytesCopied;

    PAGED_CODE();

    //
    //  Get previous processor mode and probe output arguments if necessary.
    //

    PreviousMode = KeGetPreviousMode();

    if (PreviousMode != KernelMode) {

        try {

            //
            //  We are either reading or writing the user buffer
            //

            if (WriteToMessageData) {

                ProbeForRead( Buffer,
                              BufferSize,
                              1 );

            } else {

                ProbeForWrite( Buffer,
                               BufferSize,
                               1 );
            }

            ProbeForReadSmallStructure( Message,
                                        sizeof( *Message ),
                                        sizeof( ULONG ));

            CapturedMessage = *Message;

            if (ARGUMENT_PRESENT( NumberOfBytesCopied )) {

                ProbeForWriteUlong_ptr( NumberOfBytesCopied );
            } 

        } except( EXCEPTION_EXECUTE_HANDLER ) {

            return GetExceptionCode();
        }

    } else {

        CapturedMessage = *Message;
    }

    //
    //  The message better have at least one data entry
    //

    if (CapturedMessage.u2.s2.DataInfoOffset == 0) {

        return STATUS_INVALID_PARAMETER;
    }

    //
    //  Reference the port object by handle
    //

    Status = LpcpReferencePortObject( PortHandle,
                                      0,
                                      PreviousMode,
                                      &PortObject );

    if (!NT_SUCCESS( Status )) {

        return Status;
    }

    //
    //  Translate the ClientId from the connection request into a
    //  thread pointer.  This is a referenced pointer to keep the thread
    //  from evaporating out from under us.
    //

    Status = PsLookupProcessThreadByCid( &CapturedMessage.ClientId,
                                         NULL,
                                         &ClientThread );

    if (!NT_SUCCESS( Status )) {

        ObDereferenceObject( PortObject );

        return Status;
    }

    //
    //  Acquire the mutex that guards the LpcReplyMessage field of
    //  the thread and get the pointer to the message that the thread
    //  is waiting for a reply to.
    //

    LpcpAcquireLpcpLock();

    //
    //  See if the thread is waiting for a reply to the message
    //  specified on this call.  If not then a bogus message
    //  has been specified, so release the mutex, dereference the thread
    //  and return failure.
    //
    
    if ( (ClientThread->LpcReplyMessageId != CapturedMessage.MessageId) ||
         !LpcpValidateClientPort(ClientThread, PortObject, LPCP_VALIDATE_REASON_WRONG_DATA) ) {

        Status = STATUS_REPLY_MESSAGE_MISMATCH;

    } else {

        Status = STATUS_INVALID_PARAMETER;

        Msg = LpcpFindDataInfoMessage( PortObject,
                                       CapturedMessage.MessageId,
                                       CapturedMessage.CallbackId,
                                       CapturedMessage.ClientId );

        if (Msg != NULL) {

            DataInfo = (PPORT_DATA_INFORMATION)((PUCHAR)&Msg->Request +
                                                Msg->Request.u2.s2.DataInfoOffset);

            //
            //  Make sure the caller isn't asking for an index beyond what's
            //  in the message
            //

            if (DataInfo->CountDataEntries > DataEntryIndex) {

                DataEntry = &DataInfo->DataEntries[ DataEntryIndex ];
                CapturedDataEntry = *DataEntry;

                if (CapturedDataEntry.Size >= BufferSize) {

                    Status = STATUS_SUCCESS;
                }
            }
        }
    }

    //
    //  Release the mutex that guards the LpcReplyMessage field
    //

    LpcpReleaseLpcpLock();

    if (!NT_SUCCESS( Status )) {

        ObDereferenceObject( ClientThread );
        ObDereferenceObject( PortObject );

        return Status;
    }

    //
    //  Copy the message data
    //

    if (WriteToMessageData) {

        Status = MmCopyVirtualMemory( PsGetCurrentProcess(),
                                      Buffer,
                                      THREAD_TO_PROCESS( ClientThread ),
                                      CapturedDataEntry.Base,
                                      BufferSize,
                                      PreviousMode,
                                      &BytesCopied );

    } else {

        Status = MmCopyVirtualMemory( THREAD_TO_PROCESS( ClientThread ),
                                      CapturedDataEntry.Base,
                                      PsGetCurrentProcess(),
                                      Buffer,
                                      BufferSize,
                                      PreviousMode,
                                      &BytesCopied );
    }

    if (ARGUMENT_PRESENT( NumberOfBytesCopied )) {

        try {

            *NumberOfBytesCopied = BytesCopied;

        } except( EXCEPTION_EXECUTE_HANDLER ) {

            NOTHING;
        }
    }

    //
    //  Dereference client thread and return the system service status.
    //

    ObDereferenceObject( ClientThread );
    ObDereferenceObject( PortObject );

    return Status;
}


BOOLEAN
FASTCALL
LpcpValidateClientPort(
    IN PETHREAD Thread, 
    IN PLPCP_PORT_OBJECT ReplyPort,
    IN ULONG Reason
    )

/*++

Routine Description:

    This routine validates whether the reply for a request come from
    an appropriate port
    
Arguments:

    Thread - The thread waiting for a reply
    
    ReplyPort - The port object that is replying 

Return Value:

    BOOLEAN - TRUE if the reply come from a valid port

Environment:

    This is called holding the global LPC mutex.

--*/

{
    PLPCP_PORT_OBJECT PortThread;

    PortThread = LpcpGetThreadPort(Thread);

    //
    //  The thread must have a port set
    //

    if (PortThread == NULL) {

        return FALSE;
    }
    
    //
    //  We only allow a port connected with the requestor.
    //  Also csrss is giving the server connection port to clients
    //  and we can have a client sending a request from a server connection port
    //  and csrss can reply with a server communication port
    //

    if ( ( ReplyPort == PortThread->ConnectionPort ) 
            ||                      
         ( ReplyPort == PortThread->ConnectedPort ) 
            ||
         ( ReplyPort == PortThread ) 
            ||
         ( 
            ((ReplyPort->Flags & PORT_TYPE) == SERVER_COMMUNICATION_PORT) 
                &&
            (ReplyPort->ConnectionPort == PortThread)
         )
       ) {
        
        return TRUE;
    }
    
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\lpc\lpcrecv.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

    lpcrecv.c

Abstract:

    Local Inter-Process Communication (LPC) receive system services.

--*/

#include "lpcp.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,NtReplyWaitReceivePort)
#pragma alloc_text(PAGE,NtReplyWaitReceivePortEx)
#endif


NTSTATUS
NtReplyWaitReceivePort (
    __in HANDLE PortHandle,
    __out_opt PVOID *PortContext ,
    __in_opt PPORT_MESSAGE ReplyMessage,
    __out PPORT_MESSAGE ReceiveMessage
    )

/*++

Routine Description:

    This procedure is used by the server process to wait for a message from a
    client process

    A client and server process can receive messages using the
    NtReplyWaitReceivePort service:

    If the ReplyMessage parameter is specified, then the reply will be sent
    using NtReplyPort.

    If the PortHandle parameter specifies a connection port, then the receive
    will return whenever a message is sent to a server communication port that
    does not have its own receive queue and the message is therefore queued to
    the receive queue of the connection port.

    If the PortHandle parameter specifies a server communication port that
    does not have a receive queue, then behaves as if the associated
    connection port handle was specified.  Otherwise the receive will return
    whenever message is placed in the receive queue associated with the
    server communication port.

    The received message will be returned in the variable specified by the
    ReceiveMessage parameter.  If the MapInfoOffset field of the reply message
    is non-zero, then the PORT_MAP_INFORMATION structure it points to will be
    processed and the relevant pages will be mapped into the caller's address
    space.  The service returns an error if there is not enough room in the
    caller's address space to accommodate the mappings.

Arguments:

    PortHandle - Specifies the handle of the connection or communication port
        to do the receive from.

    PortContext - Specifies an optional pointer to a variable that is to
        receive the context value associated with the communication port that
        the message is being received from.  This context variable was
        specified on the call to the NtAcceptConnectPort service.

    ReplyMessage - This optional parameter specifies the address of a reply
        message to be sent.  The ClientId and MessageId fields determine which
        thread will get the reply.  See description of NtReplyPort for how the
        reply is sent.  The reply is sent before blocking for the receive.

    ReceiveMessage - Specifies the address of a variable to receive the
        message.

Return Value:

    Status code that indicates whether or not the operation was successful.

--*/

{
    PAGED_CODE();

    return NtReplyWaitReceivePortEx (PortHandle,
                                     PortContext,
                                     ReplyMessage,
                                     ReceiveMessage,
                                     NULL);
}


NTSTATUS
NtReplyWaitReceivePortEx(
    __in HANDLE PortHandle,
    __out_opt PVOID *PortContext,
    __in_opt PPORT_MESSAGE ReplyMessage,
    __out PPORT_MESSAGE ReceiveMessage,
    __in_opt PLARGE_INTEGER Timeout
    )

/*++

Routine Description:

    See NtReplyWaitReceivePort.

Arguments:

    See NtReplyWaitReceivePort.

    Timeout - Supplies an optional timeout value to use when waiting for a
        receive.

Return Value:

    See NtReplyWaitReceivePort.

--*/

{
    PLPCP_PORT_OBJECT PortObject;
    PLPCP_PORT_OBJECT ReceivePort;
    PORT_MESSAGE CapturedReplyMessage;
    KPROCESSOR_MODE PreviousMode;
    KPROCESSOR_MODE WaitMode;
    NTSTATUS Status;
    PLPCP_MESSAGE Msg;
    PETHREAD CurrentThread;
    PETHREAD WakeupThread;
    LARGE_INTEGER TimeoutValue ;
    PLPCP_PORT_OBJECT ConnectionPort = NULL;

    PAGED_CODE();

    CurrentThread = PsGetCurrentThread();

    TimeoutValue.QuadPart = 0 ;

    //
    //  Get previous processor mode
    //

    PreviousMode = KeGetPreviousMode();
    WaitMode = PreviousMode;

    if (PreviousMode != KernelMode) {

        try {

            if (ARGUMENT_PRESENT( PortContext )) {

                ProbeForWriteUlong( (PULONG)PortContext );
            }

            if (ARGUMENT_PRESENT( ReplyMessage)) {

                ProbeForReadSmallStructure( ReplyMessage,
                                            sizeof( *ReplyMessage ),
                                            sizeof( ULONG ));

                CapturedReplyMessage = *ReplyMessage;
            }

            if (ARGUMENT_PRESENT( Timeout )) {

                TimeoutValue = ProbeAndReadLargeInteger( Timeout );

                Timeout = &TimeoutValue ;
            }

            ProbeForWriteSmallStructure( ReceiveMessage,
                                         sizeof( *ReceiveMessage ),
                                         sizeof( ULONG ));

        } except( EXCEPTION_EXECUTE_HANDLER ) {

            return GetExceptionCode();
        }

    } else {

        //
        //  Kernel mode threads call with wait mode of user so that their
        //  kernel // stacks are swappable. Main consumer of this is
        //  SepRmCommandThread
        //

        if ( IS_SYSTEM_THREAD(CurrentThread) ) {

            WaitMode = UserMode;
        }

        if (ARGUMENT_PRESENT( ReplyMessage)) {

            CapturedReplyMessage = *ReplyMessage;
        }
    }

    if (ARGUMENT_PRESENT( ReplyMessage)) {

        //
        //  Make sure DataLength is valid with respect to header size and total
        //  length
        //

        if ((((CLONG)CapturedReplyMessage.u1.s1.DataLength) + sizeof( PORT_MESSAGE )) >
            ((CLONG)CapturedReplyMessage.u1.s1.TotalLength)) {

            return STATUS_INVALID_PARAMETER;
        }

        //
        //  Make sure the user didn't give us a bogus reply message id
        //

        if (CapturedReplyMessage.MessageId == 0) {

            return STATUS_INVALID_PARAMETER;
        }
    }

    //
    //  Reference the port object by handle and if that doesn't work try
    //  a waitable port object type
    //

    Status = LpcpReferencePortObject( PortHandle,
                                      0,
                                      PreviousMode,
                                      &PortObject );

    if (!NT_SUCCESS( Status )) {

        Status = ObReferenceObjectByHandle( PortHandle,
                                            0,
                                            LpcWaitablePortObjectType,
                                            PreviousMode,
                                            &PortObject,
                                            NULL );

        if ( !NT_SUCCESS( Status ) ) {

            return Status;
        }
    }

    //
    //  Validate the message length
    //

    if (ARGUMENT_PRESENT( ReplyMessage )) {

        if (((ULONG)CapturedReplyMessage.u1.s1.TotalLength > PortObject->MaxMessageLength) ||
            ((ULONG)CapturedReplyMessage.u1.s1.TotalLength <= (ULONG)CapturedReplyMessage.u1.s1.DataLength)) {

            ObDereferenceObject( PortObject );

            return STATUS_PORT_MESSAGE_TOO_LONG;
        }
    }

    //
    //  The receive port we use is either the connection port for the port
    //  object we were given if we were given a client communication port then
    //  we expect to receive the reply on the communication port itself.
    //

    if ((PortObject->Flags & PORT_TYPE) != CLIENT_COMMUNICATION_PORT) {

        if (PortObject->ConnectionPort == PortObject) {
            ConnectionPort = ReceivePort = PortObject;
            ObReferenceObject (ConnectionPort);
        } else {

            LpcpAcquireLpcpLockByThread(CurrentThread);
        
            ConnectionPort = ReceivePort = PortObject->ConnectionPort;
        
            if (ConnectionPort == NULL) {
            
                LpcpReleaseLpcpLock();
                ObDereferenceObject( PortObject );

                return STATUS_PORT_DISCONNECTED;
            }

            ObReferenceObject( ConnectionPort );
            LpcpReleaseLpcpLock();
        }
        
    } else {

        ReceivePort = PortObject;
    }

    //
    //  If ReplyMessage argument present, then send reply
    //

    if (ARGUMENT_PRESENT( ReplyMessage )) {

        //
        //  Translate the ClientId from the connection request into a
        //  thread pointer.  This is a referenced pointer to keep the thread
        //  from evaporating out from under us.
        //

        Status = PsLookupProcessThreadByCid( &CapturedReplyMessage.ClientId,
                                             NULL,
                                             &WakeupThread );

        if (!NT_SUCCESS( Status )) {

            ObDereferenceObject( PortObject );

            if (ConnectionPort) {

                ObDereferenceObject(ConnectionPort);
            }

            return Status;
        }

        //
        //  Acquire the global Lpc mutex that guards the LpcReplyMessage
        //  field of the thread and get the pointer to the message that
        //  the thread is waiting for a reply to.
        //


        Msg = (PLPCP_MESSAGE)LpcpAllocateFromPortZone( CapturedReplyMessage.u1.s1.TotalLength );

        if (Msg == NULL) {
            
            LpcpTraceError(STATUS_NO_MEMORY, CurrentThread->Cid, &CapturedReplyMessage);

            if (ConnectionPort) {

                ObDereferenceObject(ConnectionPort);
            }

            ObDereferenceObject( WakeupThread );
            ObDereferenceObject( PortObject );

            return STATUS_NO_MEMORY;
        }
        LpcpAcquireLpcpLockByThread(CurrentThread);

        //
        //  See if the thread is waiting for a reply to the message
        //  specified on this call.  If not then a bogus message
        //  has been specified, so release the mutex, dereference the thread
        //  and return failure.
        //
        //  We also fail this request if the caller isn't replying to a request
        //  message.  For example, if the caller is replying to a connection
        //  request
        //

        if ((WakeupThread->LpcReplyMessageId != CapturedReplyMessage.MessageId)

                ||

            ((LpcpGetThreadMessage(WakeupThread) != NULL) &&
             (LpcpGetThreadMessage(WakeupThread)->Request.u2.s2.Type & ~LPC_KERNELMODE_MESSAGE) != LPC_REQUEST)
                
                ||
            
            (!LpcpValidateClientPort(WakeupThread, PortObject, LPCP_VALIDATE_REASON_REPLY))) {

            LpcpPrint(( "%s Attempted ReplyWaitReceive to Thread %lx (%s)\n",
                        PsGetCurrentProcess()->ImageFileName,
                        WakeupThread,
                        THREAD_TO_PROCESS( WakeupThread )->ImageFileName ));

            LpcpPrint(( "failed.  MessageId == %u  Client Id: %x.%x\n",
                        CapturedReplyMessage.MessageId,
                        CapturedReplyMessage.ClientId.UniqueProcess,
                        CapturedReplyMessage.ClientId.UniqueThread ));

            LpcpPrint(( "         Thread MessageId == %u  Client Id: %x.%x\n",
                        WakeupThread->LpcReplyMessageId,
                        WakeupThread->Cid.UniqueProcess,
                        WakeupThread->Cid.UniqueThread ));

#if DBG
            if (LpcpStopOnReplyMismatch) {

                DbgBreakPoint();
            }
#endif

            LpcpFreeToPortZone( Msg, LPCP_MUTEX_OWNED | LPCP_MUTEX_RELEASE_ON_RETURN );

            if (ConnectionPort) {

                ObDereferenceObject(ConnectionPort);
            }

            ObDereferenceObject( WakeupThread );
            ObDereferenceObject( PortObject );

            return STATUS_REPLY_MESSAGE_MISMATCH;
        }

        //
        //  Copy the reply message to the request message buffer.  Do this before
        //  we actually fiddle with the wakeup threads fields.  Otherwise we
        //  could mess up its state
        //

        try {

            LpcpMoveMessage( &Msg->Request,
                             &CapturedReplyMessage,
                             (ReplyMessage + 1),
                             LPC_REPLY,
                             NULL );

        } except( EXCEPTION_EXECUTE_HANDLER ) {

            LpcpFreeToPortZone( Msg, LPCP_MUTEX_OWNED | LPCP_MUTEX_RELEASE_ON_RETURN );

            if (ConnectionPort) {

                ObDereferenceObject(ConnectionPort);
            }

            ObDereferenceObject( WakeupThread );
            ObDereferenceObject( PortObject );

            return (Status = GetExceptionCode());
        }

        LpcpTrace(( "%s Sending Reply Msg %lx (%u.%u, %x) [%08x %08x %08x %08x] to Thread %lx (%s)\n",
                    PsGetCurrentProcess()->ImageFileName,
                    Msg,
                    CapturedReplyMessage.MessageId,
                    CapturedReplyMessage.CallbackId,
                    CapturedReplyMessage.u2.s2.DataInfoOffset,
                    *((PULONG)(Msg+1)+0),
                    *((PULONG)(Msg+1)+1),
                    *((PULONG)(Msg+1)+2),
                    *((PULONG)(Msg+1)+3),
                    WakeupThread,
                    THREAD_TO_PROCESS( WakeupThread )->ImageFileName ));

        //
        //  Add an extra reference so LpcExitThread does not evaporate
        //  the pointer before we get to the wait below
        //

        ObReferenceObject( WakeupThread );

        //
        //  Release the mutex that guards the LpcReplyMessage field
        //  after marking message as being replied to.
        //

        Msg->RepliedToThread = WakeupThread;

        WakeupThread->LpcReplyMessageId = 0;
        WakeupThread->LpcReplyMessage = (PVOID)Msg;

        //
        //  Remove the thread from the reply rundown list as we are sending the reply.
        //

        if ((!WakeupThread->LpcExitThreadCalled) && (!IsListEmpty( &WakeupThread->LpcReplyChain ))) {

            RemoveEntryList( &WakeupThread->LpcReplyChain );

            InitializeListHead( &WakeupThread->LpcReplyChain );
        }

        if ((CurrentThread->LpcReceivedMsgIdValid) &&
            (CurrentThread->LpcReceivedMessageId == CapturedReplyMessage.MessageId)) {

            CurrentThread->LpcReceivedMessageId = 0;

            CurrentThread->LpcReceivedMsgIdValid = FALSE;
        }

        //
        //  Locate and free the message from the port. This call may
        //  free an existing message and release the LPC lock. It was moved down 
        //  to keep checking for the message ID and set the reply message 
        //  atomically
        //

        LpcpFreeDataInfoMessage( PortObject,
                                 CapturedReplyMessage.MessageId,
                                 CapturedReplyMessage.CallbackId,
                                 CapturedReplyMessage.ClientId );

        LpcpReleaseLpcpLock();

        //
        //  Wake up the thread that is waiting for an answer to its request
        //  inside of NtRequestWaitReplyPort or NtReplyWaitReplyPort
        //

        KeReleaseSemaphore( &WakeupThread->LpcReplySemaphore,
                            1,
                            1,
                            FALSE );

        ObDereferenceObject( WakeupThread );

    }

    LpcpTrace(( "%s Waiting for message to Port %x (%s)\n",
                PsGetCurrentProcess()->ImageFileName,
                ReceivePort,
                LpcpGetCreatorName( ReceivePort )));

    //
    //  The timeout on this wait and the next wait appear to be the
    //  only substantial difference between NtReplyWaitReceivePort
    //  and NtReplyWaitReceivePortEx

    Status = KeWaitForSingleObject( ReceivePort->MsgQueue.Semaphore,
                                    WrLpcReceive,
                                    WaitMode,
                                    FALSE,
                                    Timeout );

    //
    //  Fall into receive code.  Client thread reference will be
    //  returned by the client when it wakes up.
    //
    
    //
    //  At this point we've awoke from our wait for a receive
    //

    if (Status == STATUS_SUCCESS) {

        LpcpAcquireLpcpLockByThread(CurrentThread);

        //
        //  See if we awoke without a message in our receive port
        //

        if (IsListEmpty( &ReceivePort->MsgQueue.ReceiveHead )) {

            if ( ReceivePort->Flags & PORT_WAITABLE ) {

                KeResetEvent( &ReceivePort->WaitEvent );
            }

            LpcpReleaseLpcpLock();

            if (ConnectionPort) {

                ObDereferenceObject(ConnectionPort);
            }

            ObDereferenceObject( PortObject );

            return STATUS_UNSUCCESSFUL;
        }

        //
        //  We have a message in our receive port.  So let's pull it out
        //

        Msg = (PLPCP_MESSAGE)RemoveHeadList( &ReceivePort->MsgQueue.ReceiveHead );

        if ( IsListEmpty( &ReceivePort->MsgQueue.ReceiveHead ) ) {

            if ( ReceivePort->Flags & PORT_WAITABLE ) {

                KeResetEvent( &ReceivePort->WaitEvent );
            }
        }

        InitializeListHead( &Msg->Entry );

        LpcpTrace(( "%s Receive Msg %lx (%u) from Port %lx (%s)\n",
                    PsGetCurrentProcess()->ImageFileName,
                    Msg,
                    Msg->Request.MessageId,
                    ReceivePort,
                    LpcpGetCreatorName( ReceivePort )));

        //
        //  Now make the thread state to be the message we're currently
        //  working on
        //

        CurrentThread->LpcReceivedMessageId = Msg->Request.MessageId;
        CurrentThread->LpcReceivedMsgIdValid = TRUE;

        try {

            //
            //  Check if the message is a connection request
            //

            if ((Msg->Request.u2.s2.Type & ~LPC_KERNELMODE_MESSAGE) == LPC_CONNECTION_REQUEST) {

                PLPCP_CONNECTION_MESSAGE ConnectMsg;
                ULONG ConnectionInfoLength;
                PLPCP_MESSAGE TempMsg;

                ConnectMsg = (PLPCP_CONNECTION_MESSAGE)(Msg + 1);

                ConnectionInfoLength = Msg->Request.u1.s1.DataLength - sizeof( *ConnectMsg );

                //
                //  Don't free message until NtAcceptConnectPort called, and if it's never called
                //  then we'll keep the message until the client exits.
                //

                TempMsg = Msg;
                Msg = NULL;

                *ReceiveMessage = TempMsg->Request;

                ReceiveMessage->u1.s1.TotalLength = (CSHORT)(sizeof( *ReceiveMessage ) + ConnectionInfoLength);
                ReceiveMessage->u1.s1.DataLength = (CSHORT)ConnectionInfoLength;

                RtlCopyMemory( ReceiveMessage+1,
                               ConnectMsg + 1,
                               ConnectionInfoLength );

                if (ARGUMENT_PRESENT( PortContext )) {

                    *PortContext = NULL;
                }

            //
            //  Check if the message is not a reply
            //

            } else if ((Msg->Request.u2.s2.Type & ~LPC_KERNELMODE_MESSAGE) != LPC_REPLY) {

                LpcpMoveMessage( ReceiveMessage,
                                 &Msg->Request,
                                 (&Msg->Request) + 1,
                                 0,
                                 NULL );

                if (ARGUMENT_PRESENT( PortContext )) {

                    *PortContext = Msg->PortContext;
                }

                //
                //  If message contains DataInfo for access via NtRead/WriteRequestData
                //  then put the message on a list in the communication port and don't
                //  free it.  It will be freed when the server replies to the message.
                //

                if (Msg->Request.u2.s2.DataInfoOffset != 0) {

                    LpcpSaveDataInfoMessage( PortObject, Msg, LPCP_MUTEX_OWNED );
                    Msg = NULL;
                }

            //
            //  Otherwise this is a reply message we just received
            //

            } else {

                LpcpPrint(( "LPC: Bogus reply message (%08x) in receive queue of connection port %08x\n",
                            Msg, ReceivePort ));

                KdBreakPoint();
            }

        } except( EXCEPTION_EXECUTE_HANDLER ) {

            Status = GetExceptionCode();    
        }

        //
        //  Acquire the LPC mutex and decrement the reference count for the
        //  message.  If the reference count goes to zero the message will be
        //  deleted.
        //

        if (Msg != NULL) {

            LpcpFreeToPortZone( Msg, LPCP_MUTEX_OWNED | LPCP_MUTEX_RELEASE_ON_RETURN );
        }
        else {
        
            LpcpReleaseLpcpLock();
        }
    }

    if (ConnectionPort) {

        ObDereferenceObject(ConnectionPort);
    }

    ObDereferenceObject( PortObject );

    //
    //  And return to our caller
    //

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\lpc\i386\lpcmove.asm ===
title  "LPC Move Message Support"
;++
;
; Copyright (c) Microsoft Corporation. All rights reserved. 
;
; You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
; If you do not agree to the terms, do not use the code.
;
;
; Module Name:
;
;    lpcmove.asm
;
; Abstract:
;
;    This module implements functions to support the efficient movement of
;    LPC Message blocks
;
;--

.386p

include callconv.inc            ; calling convention macros

        page ,132
        subttl  "Update System Time"

_PAGE SEGMENT DWORD PUBLIC 'CODE'
	ASSUME	DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

;++
;
; VOID
; LpcpMoveMessage (
;    OUT PPORT_MESSAGE DstMsg
;    IN PPORT_MESSAGE SrcMsg
;    IN ULONG MsgType OPTIONAL,
;    IN PCLIENT_ID ClientId OPTIONAL
;    )
;
; Routine Description:
;
;    This function moves an LPC message block.
;
; Arguments:
;
;    DstMsg (TOS) - Supplies pointer to where to move the message block to.
;
;    SrcMsg (TOS+4) - Supplies a pointer to the message to move.
;
;    MsgType (TOS+8) - If non-zero, then store in Type field of DstMsg
;
;    ClientId (TOS+12) - If non-NULL, then points to a ClientId to copy to dst
;
; Return Value:
;
;    None
;
;--

DstMsg      equ [esp + 12]
SrcMsg      equ [esp + 16]
SrcMsgData  equ [esp + 20]
MsgType     equ [esp + 24]
ClientId    equ [esp + 28]

cPublicProc _LpcpMoveMessage    ,5

        push    esi                     ; Save non-volatile registers
        push    edi

        mov     edi,DstMsg              ; (edi)->Destination
        cld
        mov     esi,SrcMsg              ; (esi)->Source

        lodsd                           ; (eax)=length
        stosd
        lea     ecx,3[eax]
        and     ecx,0FFFCH              ; (ecx)=length rounded up to 4
        shr     ecx,2                   ; (ecx)=length in dwords

        lodsd                           ; (eax)=DataInfoOffset U Type
        mov     edx,MsgType             ; (edx)=MsgType
        or      edx,edx
        jz      lmm10                   ; No MsgType, go do straight copy
        mov     ax,dx                   ; (eax low 16)=MsgType
lmm10:  stosd

        mov     edx,ClientId            ; (edx)=ClientId
        or      edx,edx
        jz      lmm20                   ; No Clientid to set, go do copy
        mov     eax,[edx]               ; Get new ClientId
        stosd                           ; and store in DstMsg->ClientId
        mov     eax,[edx+4]
        stosd
        add     esi,8                   ; and skip over SrcMsg->ClientId
        jmp     short lmm30

lmm20:  movsd                           ; Copy ClientId
        movsd

;
;   At this point, all of the control structures are copied, all we
;   need to copy is the data.
;

lmm30:
        movsd                           ; Copy MessageId
        movsd                           ; Copy ClientViewSize

        mov     esi,SrcMsgData          ; Copy data directly from user buffer
        rep     movsd                   ; Copy the data portion of message

        pop     edi
        pop     esi                     ; Restore non-volatile registers

        stdRET    _LpcpMoveMessage

stdENDP _LpcpMoveMessage

_PAGE ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\Windows Kernel Source Code like\WindowsResearchKernel-WRK\WRK-v1.2\base\ntos\mm\allocpag.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved. 

You may only use this code if you agree to the terms of the Windows Research Kernel Source Code License agreement (see License.txt).
If you do not agree to the terms, do not use the code.


Module Name:

   allocpag.c

Abstract:

    This module contains the routines which allocate and deallocate
    one or more pages from paged or nonpaged pool.

--*/

#include "mi.h"

#if DBG
extern ULONG MiShowStuckPages;
#endif

PVOID
MiFindContiguousMemoryInPool (
    IN PFN_NUMBER LowestPfn,
    IN PFN_NUMBER HighestPfn,
    IN PFN_NUMBER BoundaryPfn,
    IN PFN_NUMBER SizeInPages,
    IN PVOID CallingAddress
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, MiInitializeNonPagedPool)
#pragma alloc_text(INIT, MiAddExpansionNonPagedPool)
#pragma alloc_text(INIT, MiInitializePoolEvents)
#pragma alloc_text(INIT, MiSyncCachedRanges)

#pragma alloc_text(PAGE, MmAvailablePoolInPages)
#pragma alloc_text(PAGE, MiFindContiguousMemory)
#pragma alloc_text(PAGELK, MiFindContiguousMemoryInPool)
#pragma alloc_text(PAGELK, MiFindLargePageMemory)

#pragma alloc_text(PAGE, MiCheckSessionPoolAllocations)
#pragma alloc_text(PAGE, MiSessionPoolVector)
#pragma alloc_text(PAGE, MiSessionPoolMutex)
#pragma alloc_text(PAGE, MiInitializeSessionPool)
#pragma alloc_text(PAGE, MiFreeSessionPoolBitMaps)

#pragma alloc_text(POOLMI, MiAllocatePoolPages)
#pragma alloc_text(POOLMI, MiFreePoolPages)
#endif

ULONG MmPagedPoolCommit;        // used by the debugger

SLIST_HEADER MiNonPagedPoolSListHead;
ULONG MiNonPagedPoolSListMaximum = 4;

SLIST_HEADER MiPagedPoolSListHead;
ULONG MiPagedPoolSListMaximum = 8;

PFN_NUMBER MmAllocatedNonPagedPool;
PFN_NUMBER MiStartOfInitialPoolFrame;
PFN_NUMBER MiEndOfInitialPoolFrame;

PVOID MmNonPagedPoolEnd0;
PVOID MmNonPagedPoolExpansionStart;

LIST_ENTRY MmNonPagedPoolFreeListHead[MI_MAX_FREE_LIST_HEADS];

PMMPFN MiCachedNonPagedPool;
PFN_NUMBER MiCachedNonPagedPoolCount;

extern POOL_DESCRIPTOR NonPagedPoolDescriptor;

extern PFN_NUMBER MmFreedExpansionPoolMaximum;

extern KGUARDED_MUTEX MmPagedPoolMutex;

#define MM_SMALL_ALLOCATIONS 4

#if DBG

ULONG MiClearCache;

//
// Set this to a nonzero (ie: 10000) value to cause every pool allocation to
// be checked and an ASSERT fires if the allocation is larger than this value.
//

ULONG MmCheckRequestInPages = 0;

//
// Set this to a nonzero (ie: 0x23456789) value to cause this pattern to be
// written into freed nonpaged pool pages.
//

ULONG MiFillFreedPool = 0;
#endif

PFN_NUMBER MiExpansionPoolPagesInUse;
PFN_NUMBER MiExpansionPoolPagesInitialCharge;

ULONG MmUnusedSegmentForceFreeDefault = 30;

extern ULONG MmUnusedSegmentForceFree;

//
// For debugging purposes.
//

typedef enum _MM_POOL_TYPES {
    MmNonPagedPool,
    MmPagedPool,
    MmSessionPagedPool,
    MmMaximumPoolType
} MM_POOL_TYPES;

typedef enum _MM_POOL_PRIORITIES {
    MmHighPriority,
    MmNormalPriority,
    MmLowPriority,
    MmMaximumPoolPriority
} MM_POOL_PRIORITIES;

typedef enum _MM_POOL_FAILURE_REASONS {
    MmNonPagedNoPtes,
    MmPriorityTooLow,
    MmNonPagedNoPagesAvailable,
    MmPagedNoPtes,
    MmSessionPagedNoPtes,
    MmPagedNoPagesAvailable,
    MmSessionPagedNoPagesAvailable,
    MmPagedNoCommit,
    MmSessionPagedNoCommit,
    MmNonPagedNoResidentAvailable,
    MmNonPagedNoCommit,
    MmMaximumFailureReason
} MM_POOL_FAILURE_REASONS;

ULONG MmPoolFailures[MmMaximumPoolType][MmMaximumPoolPriority];
ULONG MmPoolFailureReasons[MmMaximumFailureReason];

typedef enum _MM_PREEMPTIVE_TRIMS {
    MmPreemptForNonPaged,
    MmPreemptForPaged,
    MmPreemptForNonPagedPriority,
    MmPreemptForPagedPriority,
    MmMaximumPreempt
} MM_PREEMPTIVE_TRIMS;

ULONG MmPreemptiveTrims[MmMaximumPreempt];


VOID
MiProtectFreeNonPagedPool (
    IN PVOID VirtualAddress,
    IN ULONG SizeInPages
    )

/*++

Routine Description:

    This function protects freed nonpaged pool.

Arguments:

    VirtualAddress - Supplies the freed pool address to protect.

    SizeInPages - Supplies the size of the request in pages.

Return Value:

    None.

Environment:

    Kernel mode.

--*/

{
    ULONG i;
    MMPTE PteContents;
    PMMPTE PointerPte;
    PMMPTE LastPte;
    PVOID FlushVa[MM_MAXIMUM_FLUSH_COUNT];

    if (MI_IS_PHYSICAL_ADDRESS (VirtualAddress)) {
        return;
    }

    //
    // Prevent anyone from touching the free non paged pool.
    //

    PointerPte = MiGetPteAddress (VirtualAddress);
    LastPte = PointerPte + SizeInPages;

    do {

        PteContents = *PointerPte;

        PteContents.u.Hard.Valid = 0;
        PteContents.u.Soft.Prototype = 1;

        MI_WRITE_INVALID_PTE (PointerPte, PteContents);

        PointerPte += 1;

    } while (PointerPte < LastPte);

    if (SizeInPages == 1) {
        MI_FLUSH_SINGLE_TB (VirtualAddress, TRUE);
    }
    else if (SizeInPages < MM_MAXIMUM_FLUSH_COUNT) {

        for (i = 0; i < SizeInPages; i += 1) {
            FlushVa[i] = VirtualAddress;
            VirtualAddress = (PVOID)((PCHAR)VirtualAddress + PAGE_SIZE);
        }

        MI_FLUSH_MULTIPLE_TB (SizeInPages, &FlushVa[0], TRUE);
    }
    else {
        MI_FLUSH_ENTIRE_TB (0xB);
    }

    return;
}


LOGICAL
MiUnProtectFreeNonPagedPool (
    IN PVOID VirtualAddress,
    IN ULONG SizeInPages
    )

/*++

Routine Description:

    This function unprotects freed nonpaged pool.

Arguments:

    VirtualAddress - Supplies the freed pool address to unprotect.

    SizeInPages - Supplies the size of the request in pages - zero indicates
                  to keep going until there are no more protected PTEs (ie: the
                  caller doesn't know how many protected PTEs there are).

Return Value:

    TRUE if pages were unprotected, FALSE if not.

Environment:

    Kernel mode.

--*/

{
    PMMPTE PointerPte;
    MMPTE PteContents;
    ULONG PagesDone;

    PagesDone = 0;

    //
    // Unprotect the previously freed pool so it can be manipulated
    //

    if (MI_IS_PHYSICAL_ADDRESS(VirtualAddress) == 0) {

        PointerPte = MiGetPteAddress((PVOID)VirtualAddress);

        PteContents = *PointerPte;

        while (PteContents.u.Hard.Valid == 0 && PteContents.u.Soft.Prototype == 1) {

            PteContents.u.Hard.Valid = 1;
            PteContents.u.Soft.Prototype = 0;
    
            MI_WRITE_VALID_PTE (PointerPte, PteContents);

            PagesDone += 1;

            if (PagesDone == SizeInPages) {
                break;
            }

            PointerPte += 1;
            PteContents = *PointerPte;
        }
    }

    if (PagesDone == 0) {
        return FALSE;
    }

    return TRUE;
}


VOID
MiProtectedPoolInsertList (
    IN PLIST_ENTRY ListHead,
    IN PLIST_ENTRY Entry,
    IN LOGICAL InsertHead
    )

/*++

Routine Description:

    This function inserts the entry into the protected list.

Arguments:

    ListHead - Supplies the list head to add onto.

    Entry - Supplies the list entry to insert.

    InsertHead - If TRUE, insert at the head otherwise at the tail.

Return Value:

    None.

Environment:

    Kernel mode.

--*/
{
    PVOID FreeFlink;
    PVOID FreeBlink;
    PVOID VirtualAddress;

    //
    // Either the flink or the blink may be pointing
    // at protected nonpaged pool.  Unprotect now.
    //

    FreeFlink = (PVOID)0;
    FreeBlink = (PVOID)0;

    if (IsListEmpty(ListHead) == 0) {

        VirtualAddress = (PVOID)ListHead->Flink;
        if (MiUnProtectFreeNonPagedPool (VirtualAddress, 1) == TRUE) {
            FreeFlink = VirtualAddress;
        }
    }

    if (((PVOID)Entry == ListHead->Blink) == 0) {
        VirtualAddress = (PVOID)ListHead->Blink;
        if (MiUnProtectFreeNonPagedPool (VirtualAddress, 1) == TRUE) {
            FreeBlink = VirtualAddress;
        }
    }

    if (InsertHead == TRUE) {
        InsertHeadList (ListHead, Entry);
    }
    else {
        InsertTailList (ListHead, Entry);
    }

    if (FreeFlink) {
        //
        // Reprotect the flink.
        //

        MiProtectFreeNonPagedPool (FreeFlink, 1);
    }

    if (FreeBlink) {
        //
        // Reprotect the blink.
        //

        MiProtectFreeNonPagedPool (FreeBlink, 1);
    }
}


VOID
MiProtectedPoolRemoveEntryList (
    IN PLIST_ENTRY Entry
    )

/*++

Routine Description:

    This function unlinks the list pointer from protected freed nonpaged pool.

Arguments:

    Entry - Supplies the list entry to remove.

Return Value:

    None.

Environment:

    Kernel mode.

--*/
{
    PVOID FreeFlink;
    PVOID FreeBlink;
    PVOID VirtualAddress;

    //
    // Either the flink or the blink may be pointing
    // at protected nonpaged pool.  Unprotect now.
    //

    FreeFlink = (PVOID)0;
    FreeBlink = (PVOID)0;

    if (IsListEmpty(Entry) == 0) {

        VirtualAddress = (PVOID)Entry->Flink;
        if (MiUnProtectFreeNonPagedPool (VirtualAddress, 1) == TRUE) {
            FreeFlink = VirtualAddress;
        }
    }

    if (((PVOID)Entry == Entry->Blink) == 0) {
        VirtualAddress = (PVOID)Entry->Blink;
        if (MiUnProtectFreeNonPagedPool (VirtualAddress, 1) == TRUE) {
            FreeBlink = VirtualAddress;
        }
    }

    RemoveEntryList (Entry);

    if (FreeFlink) {
        //
        // Reprotect the flink.
        //

        MiProtectFreeNonPagedPool (FreeFlink, 1);
    }

    if (FreeBlink) {
        //
        // Reprotect the blink.
        //

        MiProtectFreeNonPagedPool (FreeBlink, 1);
    }
}


VOID
MiTrimSegmentCache (
    VOID
    )

/*++

Routine Description:

    This function initiates trimming of the segment cache.

Arguments:

    None.

Return Value:

    None.

Environment:

    Kernel Mode Only.

--*/

{
    KIRQL OldIrql;
    LOGICAL SignalDereferenceThread;
    LOGICAL SignalSystemCache;

    SignalDereferenceThread = FALSE;
    SignalSystemCache = FALSE;

    LOCK_PFN2 (OldIrql);

    if (MmUnusedSegmentForceFree == 0) {

        if (!IsListEmpty(&MmUnusedSegmentList)) {

            SignalDereferenceThread = TRUE;
            MmUnusedSegmentForceFree = MmUnusedSegmentForceFreeDefault;
        }
        else {
            if (!IsListEmpty(&MmUnusedSubsectionList)) {
                SignalDereferenceThread = TRUE;
                MmUnusedSegmentForceFree = MmUnusedSegmentForceFreeDefault;
            }

            if (MiUnusedSubsectionPagedPool < 4 * PAGE_SIZE) {

                //
                // No unused segments and tossable subsection usage is low as
                // well.  Start unmapping system cache views in an attempt
                // to get back the paged pool containing its prototype PTEs.
                //
    
                SignalSystemCache = TRUE;
            }
        }
    }

    UNLOCK_PFN2 (OldIrql);

    if (SignalSystemCache == TRUE) {
        if (CcHasInactiveViews() == TRUE) {
            if (SignalDereferenceThread == FALSE) {
                LOCK_PFN2 (OldIrql);
                if (MmUnusedSegmentForceFree == 0) {
                    SignalDereferenceThread = TRUE;
                    MmUnusedSegmentForceFree = MmUnusedSegmentForceFreeDefault;
                }
                UNLOCK_PFN2 (OldIrql);
            }
        }
    }

    if (SignalDereferenceThread == TRUE) {
        KeSetEvent (&MmUnusedSegmentCleanup, 0, FALSE);
    }
}


POOL_TYPE
MmDeterminePoolType (
    IN PVOID VirtualAddress
    )

/*++

Routine Description:

    This function determines which pool a virtual address resides within.

Arguments:

    VirtualAddress - Supplies the virtual address to determine which pool
                     it resides within.

Return Value:

    Returns the POOL_TYPE (PagedPool, NonPagedPool, PagedPoolSession or
            NonPagedPoolSession).

Environment:

    Kernel Mode Only.

--*/

{
    if ((VirtualAddress >= MmPagedPoolStart) &&
        (VirtualAddress <= MmPagedPoolEnd)) {
        return PagedPool;
    }

    if (MI_IS_SESSION_POOL_ADDRESS (VirtualAddress) == TRUE) {
        return PagedPoolSession;
    }

    return NonPagedPool;
}


PVOID
MiSessionPoolVector (
    VOID
    )

/*++

Routine Description:

    This function returns the session pool descriptor for the current session.

Arguments:

    None.

Return Value:

    Pool descriptor.

--*/

{
    PAGED_CODE ();

    return (PVOID)&MmSessionSpace->PagedPool;
}


SIZE_T
MmAvailablePoolInPages (
    IN POOL_TYPE PoolType
    )

/*++

Routine Description:

    This function returns the number of pages available for the given pool.
    Note that it does not account for any executive pool fragmentation.

Arguments:

    PoolType - Supplies the type of pool to retrieve information about.

Return Value:

    The number of full pool pages remaining.

Environment:

    PASSIVE_LEVEL, no mutexes or locks held.

--*/

{
    SIZE_T FreePoolInPages;
    SIZE_T FreeCommitInPages;

#if !DBG
    UNREFERENCED_PARAMETER (PoolType);
#endif

    ASSERT (KeGetCurrentIrql() == PASSIVE_LEVEL);

    ASSERT (PoolType == PagedPool);

    FreePoolInPages = MmSizeOfPagedPoolInPages - MmPagedPoolInfo.AllocatedPagedPool;

    FreeCommitInPages = MmTotalCommitLimitMaximum - MmTotalCommittedPages;

    if (FreePoolInPages > FreeCommitInPages) {
        FreePoolInPages = FreeCommitInPages;
    }

    return FreePoolInPages;
}


LOGICAL
MmResourcesAvailable (
    IN POOL_TYPE PoolType,
    IN SIZE_T NumberOfBytes,
    IN EX_POOL_PRIORITY Priority
    )

/*++

Routine Description:

    This function examines various resources to determine if this
    pool allocation should be allowed to proceed.

Arguments:

    PoolType - Supplies the type of pool to retrieve information about.

    NumberOfBytes - Supplies the number of bytes to allocate.

    Priority - Supplies an indication as to how important it is that this
               request succeed under low available resource conditions.                       
Return Value:

    TRUE if the pool allocation should be allowed to proceed, FALSE if not.

--*/

{
    KIRQL OldIrql;
    PFN_NUMBER NumberOfPages;
    SIZE_T FreePoolInBytes;
    LOGICAL Status;
    MM_POOL_PRIORITIES Index;

    ASSERT (Priority != HighPoolPriority);
    ASSERT ((PoolType & MUST_SUCCEED_POOL_TYPE_MASK) == 0);

    NumberOfPages = BYTES_TO_PAGES (NumberOfBytes);

    if ((PoolType & BASE_POOL_TYPE_MASK) == NonPagedPool) {
        FreePoolInBytes = ((MmMaximumNonPagedPoolInPages - MmAllocatedNonPagedPool) << PAGE_SHIFT);
    }
    else if (PoolType & SESSION_POOL_MASK) {
        FreePoolInBytes = MmSessionPoolSize - (MmSessionSpace->PagedPoolInfo.AllocatedPagedPool << PAGE_SHIFT);
    }
    else {
        FreePoolInBytes = ((MmSizeOfPagedPoolInPages - MmPagedPoolInfo.AllocatedPagedPool) << PAGE_SHIFT);
    }

    Status = FALSE;

    //
    // Check available VA space.
    //

    if (Priority == NormalPoolPriority) {
        if ((SIZE_T)NumberOfBytes + 512*1024 > FreePoolInBytes) {
            if ((PsGetCurrentThread()->MemoryMaker == 0) || (KeIsExecutingDpc ())) {
                goto nopool;
            }
        }
    }
    else {
        if ((SIZE_T)NumberOfBytes + 2*1024*1024 > FreePoolInBytes) {
            if ((PsGetCurrentThread()->MemoryMaker == 0) || (KeIsExecutingDpc ())) {
                goto nopool;
            }
        }
    }

    //
    // Paged allocations (session and normal) can also fail for lack of commit.
    //

    if ((PoolType & BASE_POOL_TYPE_MASK) == PagedPool) {
        if (MmTotalCommittedPages + NumberOfPages > MmTotalCommitLimitMaximum) {
            if (PsGetCurrentThread()->MemoryMaker == 0) {
                MiIssuePageExtendRequestNoWait (NumberOfPages);
                goto nopool;
            }
        }
    }

    //
    // If a substantial amount of free pool is still available, return TRUE now.
    //

    if (((SIZE_T)NumberOfBytes + 10*1024*1024 < FreePoolInBytes) ||
        (MmNumberOfPhysicalPages < 256 * 1024)) {
        return TRUE;
    }

    //
    // This pool allocation is permitted, but because we're starting to run low,
    // trigger a round of dereferencing in parallel before returning success.
    // Note this is only done on machines with at least 1GB of RAM as smaller
    // configuration machines will already trigger this due to physical page
    // consumption.
    //

    Status = TRUE;

nopool:

    //
    // Running low on pool - if this request is not for session pool,
    // force unused segment trimming when appropriate.
    //

    if ((PoolType & SESSION_POOL_MASK) == 0) {

        if ((PoolType & BASE_POOL_TYPE_MASK) == NonPagedPool) {

            MmPreemptiveTrims[MmPreemptForNonPagedPriority] += 1;

            OldIrql = KeAcquireQueuedSpinLock (LockQueueMmNonPagedPoolLock);

            //
            // Only pulse the event if it is not already set.  This saves
            // on dispatcher lock contention, but more importantly since
            // KePulse always clears the event it saves us having to check
            // whether to set it (and potentially do the setting) afterwards.
            //

            if (MiLowNonPagedPoolEvent->Header.SignalState == 0) {
                KePulseEvent (MiLowNonPagedPoolEvent, 0, FALSE);
            }

            KeReleaseQueuedSpinLock (LockQueueMmNonPagedPoolLock,
                                     OldIrql);
        }
        else {

            MmPreemptiveTrims[MmPreemptForPagedPriority] += 1;

            KeAcquireGuardedMutex (&MmPagedPoolMutex);

            //
            // Only pulse the event if it is not already set.  This saves
            // on dispatcher lock contention, but more importantly since
            // KePulse always clears the event it saves us having to check
            // whether to set it (and potentially do the setting) afterwards.
            //

            if (MiLowPagedPoolEvent->Header.SignalState == 0) {
                KePulseEvent (MiLowPagedPoolEvent, 0, FALSE);
            }

            KeReleaseGuardedMutex (&MmPagedPoolMutex);
        }

        if (MI_UNUSED_SEGMENTS_SURPLUS()) {
            KeSetEvent (&MmUnusedSegmentCleanup, 0, FALSE);
        }
        else {
            MiTrimSegmentCache ();
        }
    }

    if (Status == FALSE) {

        //
        // Log this failure for debugging purposes.
        //

        if (Priority == NormalPoolPriority) {
            Index = MmNormalPriority;
        }
        else {
            Index = MmLowPriority;
        }

        if ((PoolType & BASE_POOL_TYPE_MASK) == NonPagedPool) {
            MmPoolFailures[MmNonPagedPool][Index] += 1;
        }
        else if (PoolType & SESSION_POOL_MASK) {
            MmPoolFailures[MmSessionPagedPool][Index] += 1;
            MmSessionSpace->SessionPoolAllocationFailures[0] += 1;
        }
        else {
            MmPoolFailures[MmPagedPool][Index] += 1;
        }

        MmPoolFailureReasons[MmPriorityTooLow] += 1;
    }

    return Status;
}


VOID
MiFreeNonPagedPool (
    IN PVOID StartingAddress,
    IN PFN_NUMBER NumberOfPages
    )

/*++

Routine Description:

    This function releases virtually mapped nonpaged expansion pool.

Arguments:

    StartingAddress - Supplies the starting address.

    NumberOfPages - Supplies the number of pages to free.

Return Value:

    None.

Environment:

    These functions are used by the internal Mm page allocation/free routines
    only and should not be called directly.

    The nonpaged pool spinlock must be held at DISPATCH_LEVEL when calling
    this function.

--*/

{
    PFN_NUMBER i;
    PMMPFN Pfn1;
    PMMPTE PointerPte;
    PFN_NUMBER ResAvailToReturn;
    PFN_NUMBER PageFrameIndex;

    PointerPte = MiGetPteAddress (StartingAddress);

    //
    // Return commitment.
    //

    MiReturnCommitment (NumberOfPages);

    MM_TRACK_COMMIT (MM_DBG_COMMIT_RETURN_NONPAGED_POOL_EXPANSION,
                     NumberOfPages);

    ResAvailToReturn = 0;

    LOCK_PFN_AT_DPC ();

    if (MiExpansionPoolPagesInUse > MiExpansionPoolPagesInitialCharge) {
        ResAvailToReturn = MiExpansionPoolPagesInUse - MiExpansionPoolPagesInitialCharge;
    }
    MiExpansionPoolPagesInUse -= NumberOfPages;

    for (i = 0; i < NumberOfPages; i += 1) {

        PageFrameIndex = MI_GET_PAGE_FRAME_FROM_PTE (PointerPte);

        //
        // Set the pointer to the PTE as empty so the page
        // is deleted when the reference count goes to zero.
        //

        Pfn1 = MI_PFN_ELEMENT (PageFrameIndex);
        ASSERT (Pfn1->u2.ShareCount == 1);
        Pfn1->u2.ShareCount = 0;
        MI_SET_PFN_DELETED (Pfn1);
#if DBG
        Pfn1->u3.e1.PageLocation = StandbyPageList;
#endif
        MiDecrementReferenceCount (Pfn1, PageFrameIndex);

        MI_WRITE_ZERO_PTE (PointerPte);

        PointerPte += 1;
    }

    //
    // No TB flush is done here - the system PTE management code will
    // lazily flush as needed.
    //

    UNLOCK_PFN_FROM_DPC ();

    //
    // Generally there is no need to update resident available
    // pages at this time as it has all been done during initialization.
    // However, only some of the expansion pool was charged at init, so
    // calculate how much (if any) resident available page charge to return.
    //

    if (ResAvailToReturn > NumberOfPages) {
        ResAvailToReturn = NumberOfPages;
    }

    if (ResAvailToReturn != 0) {
        MI_INCREMENT_RESIDENT_AVAILABLE (ResAvailToReturn, MM_RESAVAIL_FREE_EXPANSION_NONPAGED_POOL);
    }

    PointerPte -= NumberOfPages;

    MiReleaseSystemPtes (PointerPte,
                         (ULONG)NumberOfPages,
                         NonPagedPoolExpansion);
}

LOGICAL
MiFreeAllExpansionNonPagedPool (
    VOID
    )

/*++

Routine Description:

    This function releases all virtually mapped nonpaged expansion pool.

Arguments:

    None.

Return Value:

    TRUE if pages were freed, FALSE if not.

Environment:

    Kernel mode.

--*/

{
    ULONG Index;
    KIRQL OldIrql;
    PLIST_ENTRY Entry;
    LOGICAL FreedPool;
    PMMFREE_POOL_ENTRY FreePageInfo;

    FreedPool = FALSE;

    OldIrql = KeAcquireQueuedSpinLock (LockQueueMmNonPagedPoolLock);

    for (Index = 0; Index < MI_MAX_FREE_LIST_HEADS; Index += 1) {

        Entry = MmNonPagedPoolFreeListHead[Index].Flink;

        while (Entry != &MmNonPagedPoolFreeListHead[Index]) {

            if (MmProtectFreedNonPagedPool == TRUE) {
                MiUnProtectFreeNonPagedPool ((PVOID)Entry, 0);
            }

            //
            // The list is not empty, see if this one is virtually
            // mapped.
            //

            FreePageInfo = CONTAINING_RECORD(Entry,
                                             MMFREE_POOL_ENTRY,
                                             List);

            if ((!MI_IS_PHYSICAL_ADDRESS(FreePageInfo)) &&
                ((PVOID)FreePageInfo >= MmNonPagedPoolExpansionStart)) {

                if (MmProtectFreedNonPagedPool == FALSE) {
                    RemoveEntryList (&FreePageInfo->List);
                }
                else {
                    MiProtectedPoolRemoveEntryList (&FreePageInfo->List);
                }

                MmNumberOfFreeNonPagedPool -= FreePageInfo->Size;
                ASSERT ((LONG)MmNumberOfFreeNonPagedPool >= 0);

                FreedPool = TRUE;

                MiFreeNonPagedPool ((PVOID)FreePageInfo,
                                    FreePageInfo->Size);

                Index = (ULONG)-1;
                break;
            }

            Entry = FreePageInfo->List.Flink;

            if (MmProtectFreedNonPagedPool == TRUE) {
                MiProtectFreeNonPagedPool ((PVOID)FreePageInfo,
                                           (ULONG)FreePageInfo->Size);
            }
        }
    }

    KeReleaseQueuedSpinLock (LockQueueMmNonPagedPoolLock, OldIrql);

    return FreedPool;
}

VOID
MiMarkPoolLargeSession (
    IN PVOID VirtualAddress
    )

/*++

Routine Description:

    This function marks a NONPAGED pool allocation as being of
    type large session.

Arguments:

    VirtualAddress - Supplies the virtual address of the pool allocation.

Return Value:

    None.

Environment:

    This function is used by the general pool allocation routines
    and should not be called directly.

    Kernel mode, IRQL <= DISPATCH_LEVEL.

--*/

{
    KIRQL OldIrql;
    PMMPFN Pfn1;
    PMMPTE PointerPte;
    PFN_NUMBER PageFrameIndex;

    ASSERT (PAGE_ALIGN (VirtualAddress) == VirtualAddress);

    if (MI_IS_PHYSICAL_ADDRESS (VirtualAddress)) {

        //
        // On certain architectures, virtual addresses
        // may be physical and hence have no corresponding PTE.
        //

        PageFrameIndex = MI_CONVERT_PHYSICAL_TO_PFN (VirtualAddress);
    }
    else {
        PointerPte = MiGetPteAddress (VirtualAddress);
        ASSERT (PointerPte->u.Hard.Valid == 1);
        PageFrameIndex = MI_GET_PAGE_FRAME_FROM_PTE (PointerPte);
    }

    Pfn1 = MI_PFN_ELEMENT (PageFrameIndex);

    LOCK_PFN2 (OldIrql);

    ASSERT (Pfn1->u3.e1.StartOfAllocation == 1);
    ASSERT (Pfn1->u3.e1.LargeSessionAllocation == 0);

    Pfn1->u3.e1.LargeSessionAllocation = 1;

    UNLOCK_PFN2 (OldIrql);

    return;
}


LOGICAL
MiIsPoolLargeSession (
    IN PVOID VirtualAddress
    )

/*++

Routine Description:

    This function determines whether the argument nonpaged allocation was
    marked as a large session allocation.

Arguments:

    VirtualAddress - Supplies the virtual address of the pool allocation.

Return Value:

    None.

Environment:

    This function is used by the general pool allocation routines
    and should not be called directly.

    Kernel mode, IRQL <= DISPATCH_LEVEL.

--*/

{
    PMMPFN Pfn1;
    PMMPTE PointerPte;
    PFN_NUMBER PageFrameIndex;

    ASSERT (PAGE_ALIGN (VirtualAddress) == VirtualAddress);

    if (MI_IS_PHYSICAL_ADDRESS (VirtualAddress)) {

        //
        // On certain architectures, virtual addresses
        // may be physical and hence have no corresponding PTE.
        //

        PageFrameIndex = MI_CONVERT_PHYSICAL_TO_PFN (VirtualAddress);
    }
    else {
        PointerPte = MiGetPteAddress (VirtualAddress);
        ASSERT (PointerPte->u.Hard.Valid == 1);
        PageFrameIndex = MI_GET_PAGE_FRAME_FROM_PTE (PointerPte);
    }

    Pfn1 = MI_PFN_ELEMENT (PageFrameIndex);

    ASSERT (Pfn1->u3.e1.StartOfAllocation == 1);

    if (Pfn1->u3.e1.LargeSessionAllocation == 0) {
        return FALSE;
    }

    return TRUE;
}


PVOID
MiAllocatePoolPages (
    IN POOL_TYPE PoolType,
    IN SIZE_T SizeInBytes
    )

/*++

Routine Description:

    This function allocates a set of pages from the specified pool
    and returns the starting virtual address to the caller.

Arguments:

    PoolType - Supplies the type of pool from which to obtain pages.

    SizeInBytes - Supplies the size of the request in bytes.  The actual
                  size returned is rounded up to a page boundary.

Return Value:

    Returns a pointer to the allocated pool, or NULL if no more pool is
    available.

Environment:

    These functions are used by the general pool allocation routines
    and should not be called directly.

    Kernel mode, IRQL at DISPATCH_LEVEL.

--*/

{
    PFN_NUMBER SizeInPages;
    ULONG TimeStamp;
    ULONG LastTimeStamp;
    ULONG StartPosition;
    ULONG EndPosition;
    PMMPTE StartingPte;
    PMMPTE PointerPte;
    PMMPFN Pfn1;
    PMMPFN PfnList;
    MMPTE TempPte;
    PFN_NUMBER PageFrameIndex;
    PVOID BaseVa;
    KIRQL OldIrql;
    PFN_NUMBER i;
    PFN_NUMBER j;
    PLIST_ENTRY Entry;
    PLIST_ENTRY ListHead;
    PLIST_ENTRY LastListHead;
    PMMFREE_POOL_ENTRY FreePageInfo;
    PMM_SESSION_SPACE SessionSpace;
    PMM_PAGED_POOL_INFO PagedPoolInfo;
    PVOID VirtualAddress;
    PVOID VirtualAddressSave;
    ULONG_PTR Index;
    ULONG PageTableCount;
    PFN_NUMBER FreePoolInPages;
    LOGICAL FlushedTb;
    ULONG FlushCount;
    PVOID VaFlushList[MM_MAXIMUM_FLUSH_COUNT];
    LOGICAL PreviousPteNeededFlush;

    SizeInPages = BYTES_TO_PAGES (SizeInBytes);

#if DBG
    if (MmCheckRequestInPages != 0) {
        ASSERT (SizeInPages < MmCheckRequestInPages);
    }
#endif

    if ((PoolType & BASE_POOL_TYPE_MASK) == NonPagedPool) {

        if ((SizeInPages == 1) &&
            (ExQueryDepthSList (&MiNonPagedPoolSListHead) != 0)) {

            BaseVa = InterlockedPopEntrySList (&MiNonPagedPoolSListHead);

            if (BaseVa != NULL) {

                if (PoolType & POOL_VERIFIER_MASK) {
                    if (MI_IS_PHYSICAL_ADDRESS(BaseVa)) {
                        PageFrameIndex = MI_CONVERT_PHYSICAL_TO_PFN (BaseVa);
                    }
                    else {
                        PointerPte = MiGetPteAddress(BaseVa);
                        ASSERT (PointerPte->u.Hard.Valid == 1);
                        PageFrameIndex = MI_GET_PAGE_FRAME_FROM_PTE (PointerPte);
                    }
                    Pfn1 = MI_PFN_ELEMENT (PageFrameIndex);
                    Pfn1->u4.VerifierAllocation = 1;
                }

                return BaseVa;
            }
        }

        Index = SizeInPages - 1;

        if (Index >= MI_MAX_FREE_LIST_HEADS) {
            Index = MI_MAX_FREE_LIST_HEADS - 1;
        }

        //
        // NonPaged pool is linked together through the pages themselves.
        //

        ListHead = &MmNonPagedPoolFreeListHead[Index];
        LastListHead = &MmNonPagedPoolFreeListHead[MI_MAX_FREE_LIST_HEADS];

        OldIrql = KeAcquireQueuedSpinLock (LockQueueMmNonPagedPoolLock);

        do {

            Entry = ListHead->Flink;

            while (Entry != ListHead) {

                if (MmProtectFreedNonPagedPool == TRUE) {
                    MiUnProtectFreeNonPagedPool ((PVOID)Entry, 0);
                }
    
                //
                // The list is not empty, see if this one has enough space.
                //
    
                FreePageInfo = CONTAINING_RECORD(Entry,
                                                 MMFREE_POOL_ENTRY,
                                                 List);
    
                ASSERT (FreePageInfo->Signature == MM_FREE_POOL_SIGNATURE);
                if (FreePageInfo->Size >= SizeInPages) {
    
                    //
                    // This entry has sufficient space, remove
                    // the pages from the end of the allocation.
                    //
    
                    FreePageInfo->Size -= SizeInPages;
    
                    BaseVa = (PVOID)((PCHAR)FreePageInfo +
                                            (FreePageInfo->Size  << PAGE_SHIFT));
    
                    if (MmProtectFreedNonPagedPool == FALSE) {
                        RemoveEntryList (&FreePageInfo->List);
                    }
                    else {
                        MiProtectedPoolRemoveEntryList (&FreePageInfo->List);
                    }

                    if (FreePageInfo->Size != 0) {
    
                        //
                        // Insert any remainder into the correct list.
                        //
    
                        Index = (ULONG)(FreePageInfo->Size - 1);
                        if (Index >= MI_MAX_FREE_LIST_HEADS) {
                            Index = MI_MAX_FREE_LIST_HEADS - 1;
                        }

                        if (MmProtectFreedNonPagedPool == FALSE) {
                            InsertTailList (&MmNonPagedPoolFreeListHead[Index],
                                            &FreePageInfo->List);
                        }
                        else {
                            MiProtectedPoolInsertList (&MmNonPagedPoolFreeListHead[Index],
                                                       &FreePageInfo->List,
                                                       FALSE);

                            MiProtectFreeNonPagedPool ((PVOID)FreePageInfo,
                                                       (ULONG)FreePageInfo->Size);
                        }
                    }
    
                    //
                    // Adjust the number of free pages remaining in the pool.
                    //
    
                    MmNumberOfFreeNonPagedPool -= SizeInPages;
                    ASSERT ((LONG)MmNumberOfFreeNonPagedPool >= 0);
    
                    //
                    // Mark start and end of allocation in the PFN database.
                    //
    
                    if (MI_IS_PHYSICAL_ADDRESS(BaseVa)) {
    
                        //
                        // On certain architectures, virtual addresses
                        // may be physical and hence have no corresponding PTE.
                        //
    
                        PointerPte = NULL;
                        PageFrameIndex = MI_CONVERT_PHYSICAL_TO_PFN (BaseVa);
                    }
                    else {
                        PointerPte = MiGetPteAddress(BaseVa);
                        ASSERT (PointerPte->u.Hard.Valid == 1);
                        PageFrameIndex = MI_GET_PAGE_FRAME_FROM_PTE (PointerPte);
                    }
                    Pfn1 = MI_PFN_ELEMENT (PageFrameIndex);
    
                    ASSERT (Pfn1->u3.e1.StartOfAllocation == 0);
                    ASSERT (Pfn1->u4.VerifierAllocation == 0);
    
                    Pfn1->u3.e1.StartOfAllocation = 1;
    
                    if (PoolType & POOL_VERIFIER_MASK) {
                        Pfn1->u4.VerifierAllocation = 1;
                    }

                    //
                    // Calculate the ending PTE's address.
                    //
    
                    if (SizeInPages != 1) {
                        if (PointerPte == NULL) {
                            Pfn1 += SizeInPages - 1;
                        }
                        else {
                            PointerPte += SizeInPages - 1;
                            ASSERT (PointerPte->u.Hard.Valid == 1);
                            Pfn1 = MI_PFN_ELEMENT (PointerPte->u.Hard.PageFrameNumber);
                        }
                    }
    
                    ASSERT (Pfn1->u3.e1.EndOfAllocation == 0);
    
                    Pfn1->u3.e1.EndOfAllocation = 1;
    
                    MmAllocatedNonPagedPool += SizeInPages;

                    FreePoolInPages = MmMaximumNonPagedPoolInPages - MmAllocatedNonPagedPool;

                    if (FreePoolInPages < MiHighNonPagedPoolThreshold) {

                        //
                        // Read the state directly instead of calling
                        // KeReadStateEvent since we are holding the nonpaged
                        // pool lock and want to keep instructions at a
                        // minimum.
                        //

                        if (MiHighNonPagedPoolEvent->Header.SignalState != 0) {
                            KeClearEvent (MiHighNonPagedPoolEvent);
                        }
                        if (FreePoolInPages <= MiLowNonPagedPoolThreshold) {
                            if (MiLowNonPagedPoolEvent->Header.SignalState == 0) {
                                KeSetEvent (MiLowNonPagedPoolEvent, 0, FALSE);
                            }
                        }
                    }

                    KeReleaseQueuedSpinLock (LockQueueMmNonPagedPoolLock,
                                             OldIrql);

                    return BaseVa;
                }
    
                Entry = FreePageInfo->List.Flink;
    
                if (MmProtectFreedNonPagedPool == TRUE) {
                    MiProtectFreeNonPagedPool ((PVOID)FreePageInfo,
                                               (ULONG)FreePageInfo->Size);
                }
            }

            ListHead += 1;

        } while (ListHead < LastListHead);

        KeReleaseQueuedSpinLock (LockQueueMmNonPagedPoolLock, OldIrql);

        //
        // No more entries on the list, expand nonpaged pool if
        // possible to satisfy this request.
        //
        // If pool is starting to run low then free some page cache up now.
        // While this can never guarantee pool allocations will succeed,
        // it does give allocators a better chance.
        //

        FreePoolInPages = MmMaximumNonPagedPoolInPages - MmAllocatedNonPagedPool;
        if (FreePoolInPages < (3 * 1024 * 1024) / PAGE_SIZE) {
            MmPreemptiveTrims[MmPreemptForNonPaged] += 1;
            MiTrimSegmentCache ();
        }

#if defined (_WIN64)
        if (SizeInPages >= _4gb) {
            return NULL;
        }
#endif

        //
        // Try to find system PTEs to expand the pool into.
        //

        StartingPte = MiReserveSystemPtes ((ULONG)SizeInPages,
                                           NonPagedPoolExpansion);

        if (StartingPte == NULL) {

            //
            // There are no free physical PTEs to expand nonpaged pool.
            //
            // Check to see if there are too many unused segments lying
            // around.  If so, set an event so they get deleted.
            //

            if (MI_UNUSED_SEGMENTS_SURPLUS()) {
                KeSetEvent (&MmUnusedSegmentCleanup, 0, FALSE);
            }

            //
            // If there are any cached expansion PTEs, free them now in
            // an attempt to get enough contiguous VA for our caller.
            //

            if ((SizeInPages > 1) && (MmNumberOfFreeNonPagedPool != 0)) {

                if (MiFreeAllExpansionNonPagedPool () == TRUE) {

                    StartingPte = MiReserveSystemPtes ((ULONG)SizeInPages,
                                                       NonPagedPoolExpansion);
                }
            }

            if (StartingPte == NULL) {

                MmPoolFailures[MmNonPagedPool][MmHighPriority] += 1;
                MmPoolFailureReasons[MmNonPagedNoPtes] += 1;

                //
                // Running low on pool - force unused segment trimming.
                //
            
                MiTrimSegmentCache ();

                return NULL;
            }
        }

        //
        // See if the allocation can be satisfied from expansion slush ...
        //

        PfnList = NULL;

        if (MiCachedNonPagedPoolCount >= SizeInPages) {

            i = SizeInPages;

            LOCK_PFN2 (OldIrql);

            if (MiCachedNonPagedPoolCount >= i) {
                Pfn1 = MiCachedNonPagedPool;
                PfnList = Pfn1;
                do {
                    ASSERT (Pfn1->u3.e1.PageLocation == ActiveAndValid);
                    ASSERT (Pfn1->u2.ShareCount == 1);
                    ASSERT (Pfn1->u3.e2.ReferenceCount == 1);
                    ASSERT (Pfn1->OriginalPte.u.Long == MM_DEMAND_ZERO_WRITE_PTE);
                    ASSERT (Pfn1->u4.MustBeCached == 1);

                    ASSERT (Pfn1->u3.e1.PageLocation == ActiveAndValid);

                    ASSERT (Pfn1->u3.e1.LargeSessionAllocation == 0);
                    ASSERT (Pfn1->u4.VerifierAllocation == 0);

                    ASSERT (Pfn1->u3.e1.CacheAttribute == MiCached);
                    Pfn1 = (PMMPFN) Pfn1->u1.Event;
                    i -= 1;
                } while (i != 0);

                MiCachedNonPagedPool = Pfn1;
                MiCachedNonPagedPoolCount -= SizeInPages;
#if DBG
                if (MiCachedNonPagedPoolCount == 0) {
                    ASSERT (MiCachedNonPagedPool == NULL);
                }
#endif
            }

            UNLOCK_PFN2 (OldIrql);
        }

        //
        // Charge commitment as nonpaged pool uses physical memory.
        //

        if ((PfnList == NULL) &&
            (MiChargeCommitmentCantExpand (SizeInPages, FALSE) == FALSE)) {

            if ((PsGetCurrentThread()->MemoryMaker == 1) &&
                (!KeIsExecutingDpc ())) {

                MiChargeCommitmentCantExpand (SizeInPages, TRUE);
            }
            else {
                MiReleaseSystemPtes (StartingPte,
                                     (ULONG)SizeInPages,
                                     NonPagedPoolExpansion);

                MmPoolFailures[MmNonPagedPool][MmHighPriority] += 1;
                MmPoolFailureReasons[MmNonPagedNoCommit] += 1;
                MiTrimSegmentCache ();
                return NULL;
            }
        }

        PointerPte = StartingPte;
        TempPte = ValidKernelPte;
        i = SizeInPages;

        MI_ADD_EXECUTE_TO_VALID_PTE_IF_PAE (TempPte);

        if (PfnList != NULL) {
            Pfn1 = PfnList;
            ASSERT (PfnList->u3.e1.StartOfAllocation == 0);
            ASSERT (PfnList->u4.VerifierAllocation == 0);
            PfnList->u3.e1.StartOfAllocation = 1;
            if (PoolType & POOL_VERIFIER_MASK) {
                PfnList->u4.VerifierAllocation = 1;
            }
    
            //
            // The lock must be acquired prior to filling any PTEs to
            // prevent a free happening in parallel from mistakenly trying
            // to coalesce with this allocation !
            //

            OldIrql = KeAcquireQueuedSpinLock (LockQueueMmNonPagedPoolLock);

            do {

                ASSERT (Pfn1->u3.e2.ReferenceCount == 1);
                ASSERT (Pfn1->u2.ShareCount == 1);
                ASSERT (Pfn1->OriginalPte.u.Long == MM_DEMAND_ZERO_WRITE_PTE);
                ASSERT (Pfn1->u4.MustBeCached == 1);
                ASSERT ((Pfn1->u3.e1.StartOfAllocation == 0) ||
                        (Pfn1 == PfnList));
                ASSERT (Pfn1->u3.e1.EndOfAllocation == 0);

                ASSERT (Pfn1->u3.e1.PageLocation == ActiveAndValid);
                ASSERT (Pfn1->u3.e1.CacheAttribute == MiCached);

                ASSERT (Pfn1->u3.e1.LargeSessionAllocation == 0);
                ASSERT ((Pfn1->u4.VerifierAllocation == 0) ||
                        ((Pfn1 == PfnList) && (PoolType & POOL_VERIFIER_MASK)));

                Pfn1->PteAddress = PointerPte;
                Pfn1->u4.PteFrame = MI_GET_PAGE_FRAME_FROM_PTE (MiGetPteAddress(PointerPte));
    
                TempPte.u.Hard.PageFrameNumber = Pfn1 - MmPfnDatabase;
                MI_WRITE_VALID_PTE (PointerPte, TempPte);

                SizeInPages -= 1;
                if (SizeInPages == 0) {
                    Pfn1->u3.e1.EndOfAllocation = 1;
                    MmAllocatedNonPagedPool += i;
                    goto AllocationSucceeded;
                }

                Pfn1 = (PMMPFN) Pfn1->u1.Event;
                PointerPte += 1;

            } while (TRUE);
        }
        else {
            OldIrql = KeAcquireQueuedSpinLock (LockQueueMmNonPagedPoolLock);
        }

        MmAllocatedNonPagedPool += SizeInPages;

        LOCK_PFN_AT_DPC ();

        //
        // Make sure we have 1 more than the number of pages
        // requested available.
        //

        if (MmAvailablePages <= SizeInPages) {

            UNLOCK_PFN_FROM_DPC ();

            //
            // There are no free physical pages to expand nonpaged pool.
            //

            MmAllocatedNonPagedPool -= SizeInPages;

            KeReleaseQueuedSpinLock (LockQueueMmNonPagedPoolLock, OldIrql);

            MmPoolFailureReasons[MmNonPagedNoPagesAvailable] += 1;

            MmPoolFailures[MmNonPagedPool][MmHighPriority] += 1;

            MiReturnCommitment (SizeInPages);

            MiReleaseSystemPtes (StartingPte,
                                 (ULONG)SizeInPages,
                                 NonPagedPoolExpansion);

            MiTrimSegmentCache ();

            return NULL;
        }

        //
        // Charge resident available pages now for any excess.
        //

        MiExpansionPoolPagesInUse += SizeInPages;
        if (MiExpansionPoolPagesInUse > MiExpansionPoolPagesInitialCharge) {
            j = MiExpansionPoolPagesInUse - MiExpansionPoolPagesInitialCharge;
            if (j > SizeInPages) {
                j = SizeInPages;
            }
            if (MI_NONPAGEABLE_MEMORY_AVAILABLE() >= (SPFN_NUMBER)j) {
                MI_DECREMENT_RESIDENT_AVAILABLE (j, MM_RESAVAIL_ALLOCATE_EXPANSION_NONPAGED_POOL);
            }
            else {
                MiExpansionPoolPagesInUse -= SizeInPages;
                UNLOCK_PFN_FROM_DPC ();

                MmAllocatedNonPagedPool -= SizeInPages;

                KeReleaseQueuedSpinLock (LockQueueMmNonPagedPoolLock, OldIrql);

                MmPoolFailureReasons[MmNonPagedNoResidentAvailable] += 1;

                MmPoolFailures[MmNonPagedPool][MmHighPriority] += 1;

                MiReturnCommitment (SizeInPages);

                MiReleaseSystemPtes (StartingPte,
                                    (ULONG)SizeInPages,
                                    NonPagedPoolExpansion);

                MiTrimSegmentCache ();

                return NULL;
            }
        }
    
        MM_TRACK_COMMIT (MM_DBG_COMMIT_NONPAGED_POOL_EXPANSION, SizeInPages);

        //
        // Expand the pool.
        //

        FlushedTb = FALSE;

        do {
            PageFrameIndex = MiRemoveAnyPage (
                                MI_GET_PAGE_COLOR_FROM_PTE (PointerPte));

            Pfn1 = MI_PFN_ELEMENT (PageFrameIndex);

            Pfn1->u3.e2.ReferenceCount = 1;
            Pfn1->u2.ShareCount = 1;
            Pfn1->PteAddress = PointerPte;
            Pfn1->OriginalPte.u.Long = MM_DEMAND_ZERO_WRITE_PTE;
            Pfn1->u4.PteFrame = MI_GET_PAGE_FRAME_FROM_PTE (MiGetPteAddress(PointerPte));

            Pfn1->u3.e1.PageLocation = ActiveAndValid;

            //
            // The entire TB must be flushed if we are changing cache
            // attributes.
            //
            // KeFlushSingleTb cannot be used because we don't know
            // what virtual address(es) this physical frame was last mapped at.
            //
            // Note we can skip the flush if we've already done it once in
            // this loop already because the PFN lock is held throughout.
            //

            if ((Pfn1->u3.e1.CacheAttribute != MiCached) && (FlushedTb == FALSE)) {
                MI_FLUSH_TB_FOR_INDIVIDUAL_ATTRIBUTE_CHANGE (PageFrameIndex,
                                                             MiCached);
                FlushedTb = TRUE;
            }

            Pfn1->u3.e1.CacheAttribute = MiCached;
            Pfn1->u3.e1.LargeSessionAllocation = 0;
            Pfn1->u4.VerifierAllocation = 0;

            TempPte.u.Hard.PageFrameNumber = PageFrameIndex;
            MI_WRITE_VALID_PTE (PointerPte, TempPte);
            PointerPte += 1;
            SizeInPages -= 1;
        } while (SizeInPages > 0);

        Pfn1->u3.e1.EndOfAllocation = 1;

        Pfn1 = MI_PFN_ELEMENT (StartingPte->u.Hard.PageFrameNumber);
        Pfn1->u3.e1.StartOfAllocation = 1;

        ASSERT (Pfn1->u4.VerifierAllocation == 0);

        if (PoolType & POOL_VERIFIER_MASK) {
            Pfn1->u4.VerifierAllocation = 1;
        }

        UNLOCK_PFN_FROM_DPC ();

AllocationSucceeded:

        FreePoolInPages = MmMaximumNonPagedPoolInPages - MmAllocatedNonPagedPool;

        if (FreePoolInPages < MiHighNonPagedPoolThreshold) {

            //
            // Read the state directly instead of calling
            // KeReadStateEvent since we are holding the nonpaged
            // pool lock and want to keep instructions at a
            // minimum.
            //

            if (MiHighNonPagedPoolEvent->Header.SignalState != 0) {
                KeClearEvent (MiHighNonPagedPoolEvent);
            }
            if (FreePoolInPages <= MiLowNonPagedPoolThreshold) {
                if (MiLowNonPagedPoolEvent->Header.SignalState == 0) {
                    KeSetEvent (MiLowNonPagedPoolEvent, 0, FALSE);
                }
            }
        }

        KeReleaseQueuedSpinLock (LockQueueMmNonPagedPoolLock, OldIrql);

        BaseVa = MiGetVirtualAddressMappedByPte (StartingPte);

        return BaseVa;
    }

    //
    // Paged Pool.
    //

    if ((PoolType & SESSION_POOL_MASK) == 0) {

        //
        // If pool is starting to run low then free some page cache up now.
        // While this can never guarantee pool allocations will succeed,
        // it does give allocators a better chance.
        //

        FreePoolInPages = MmSizeOfPagedPoolInPages - MmPagedPoolInfo.AllocatedPagedPool;

        if (FreePoolInPages < (5 * 1024 * 1024) / PAGE_SIZE) {
            MmPreemptiveTrims[MmPreemptForPaged] += 1;
            MiTrimSegmentCache ();
        }
#if DBG
        if (MiClearCache != 0) {
            LARGE_INTEGER CurrentTime;

            KeQueryTickCount(&CurrentTime);

            if ((CurrentTime.LowPart & MiClearCache) == 0) {

                MmPreemptiveTrims[MmPreemptForPaged] += 1;
                MiTrimSegmentCache ();
            }
        }
#endif

        if ((SizeInPages == 1) &&
            (ExQueryDepthSList (&MiPagedPoolSListHead) != 0)) {

            BaseVa = InterlockedPopEntrySList (&MiPagedPoolSListHead);

            if (BaseVa != NULL) {
                return BaseVa;
            }
        }

        SessionSpace = NULL;
        PagedPoolInfo = &MmPagedPoolInfo;

        KeAcquireGuardedMutex (&MmPagedPoolMutex);
    }
    else {
        SessionSpace = SESSION_GLOBAL (MmSessionSpace);
        PagedPoolInfo = &SessionSpace->PagedPoolInfo;

        KeAcquireGuardedMutex (&SessionSpace->PagedPoolMutex);
    }

    StartPosition = RtlFindClearBitsAndSet (
                               PagedPoolInfo->PagedPoolAllocationMap,
                               (ULONG)SizeInPages,
                               PagedPoolInfo->PagedPoolHint);

    if (StartPosition == NO_BITS_FOUND) {

        //
        // No room in pool - attempt to expand the paged pool.  If there is
        // a surplus of unused segments (or subsections) get rid of some now.
        //

        if (MI_UNUSED_SEGMENTS_SURPLUS()) {
            KeSetEvent (&MmUnusedSegmentCleanup, 0, FALSE);
        }

        StartPosition = (((ULONG)SizeInPages - 1) / PTE_PER_PAGE) + 1;

        //
        // Make sure there is enough space to create at least some
        // page table pages.  Note if we can create even one it's worth
        // doing as there may be free space in the already existing pool
        // (at the end) - and this can be concatenated with the expanded
        // portion below into one big allocation.
        //

        if (PagedPoolInfo->NextPdeForPagedPoolExpansion >
            MiGetPteAddress (PagedPoolInfo->LastPteForPagedPool)) {

NoVaSpaceLeft:

            //
            // Can't expand pool any more.  If this request is not for session
            // pool, force unused segment trimming when appropriate.
            //

            if (SessionSpace == NULL) {

                KeReleaseGuardedMutex (&MmPagedPoolMutex);

                MmPoolFailures[MmPagedPool][MmHighPriority] += 1;
                MmPoolFailureReasons[MmPagedNoPtes] += 1;

                //
                // Running low on pool - force unused segment trimming.
                //
            
                MiTrimSegmentCache ();

                return NULL;
            }

            KeReleaseGuardedMutex (&SessionSpace->PagedPoolMutex);

            MmPoolFailures[MmSessionPagedPool][MmHighPriority] += 1;
            MmPoolFailureReasons[MmSessionPagedNoPtes] += 1;

            SessionSpace->SessionPoolAllocationFailures[1] += 1;

            return NULL;
        }

        if (((StartPosition - 1) + PagedPoolInfo->NextPdeForPagedPoolExpansion) >
            MiGetPteAddress (PagedPoolInfo->LastPteForPagedPool)) {

            PageTableCount = (ULONG)(MiGetPteAddress (PagedPoolInfo->LastPteForPagedPool) - PagedPoolInfo->NextPdeForPagedPoolExpansion + 1);
            ASSERT (PageTableCount < StartPosition);
            StartPosition = PageTableCount;
        }
        else {
            PageTableCount = StartPosition;
        }

        if (SessionSpace) {
            TempPte = ValidKernelPdeLocal;
        }
        else {
            TempPte = ValidKernelPde;
        }

        //
        // Charge commitment for the pagetable pages for paged pool expansion.
        //

        if (MiChargeCommitmentCantExpand (PageTableCount, FALSE) == FALSE) {

            if ((PsGetCurrentThread()->MemoryMaker == 1) &&
                (!KeIsExecutingDpc ())) {

                MiChargeCommitmentCantExpand (PageTableCount, TRUE);
            }
            else {
                if (SessionSpace) {
                    KeReleaseGuardedMutex (&SessionSpace->PagedPoolMutex);
                }
                else {
                    KeReleaseGuardedMutex (&MmPagedPoolMutex);
                }
                MmPoolFailures[MmPagedPool][MmHighPriority] += 1;
                MmPoolFailureReasons[MmPagedNoCommit] += 1;
                MiTrimSegmentCache ();

                return NULL;
            }
        }

        EndPosition = (ULONG)((PagedPoolInfo->NextPdeForPagedPoolExpansion -
                          MiGetPteAddress(PagedPoolInfo->FirstPteForPagedPool)) *
                          PTE_PER_PAGE);

        //
        // Expand the pool.
        //

        PointerPte = PagedPoolInfo->NextPdeForPagedPoolExpansion;
        VirtualAddress = MiGetVirtualAddressMappedByPte (PointerPte);
        VirtualAddressSave = VirtualAddress;

        LOCK_PFN (OldIrql);

        //
        // Make sure we have 1 more than the number of pages
        // requested available.
        //

        if (MmAvailablePages <= PageTableCount) {

            //
            // There are no free physical pages to expand paged pool.
            //

            UNLOCK_PFN (OldIrql);

            if (SessionSpace == NULL) {
                KeReleaseGuardedMutex (&MmPagedPoolMutex);
                MmPoolFailures[MmPagedPool][MmHighPriority] += 1;
                MmPoolFailureReasons[MmPagedNoPagesAvailable] += 1;
            }
            else {
                KeReleaseGuardedMutex (&SessionSpace->PagedPoolMutex);
                MmPoolFailures[MmSessionPagedPool][MmHighPriority] += 1;
                MmPoolFailureReasons[MmSessionPagedNoPagesAvailable] += 1;
                SessionSpace->SessionPoolAllocationFailures[2] += 1;
            }

            MiReturnCommitment (PageTableCount);

            return NULL;
        }

        MM_TRACK_COMMIT (MM_DBG_COMMIT_PAGED_POOL_PAGETABLE, PageTableCount);

        //
        // Update the count of available resident pages.
        //

        MI_DECREMENT_RESIDENT_AVAILABLE (PageTableCount, MM_RESAVAIL_ALLOCATE_PAGETABLES_FOR_PAGED_POOL);

        //
        // Allocate the page table pages for the pool expansion.
        //

        do {
            ASSERT (PointerPte->u.Hard.Valid == 0);

            PageFrameIndex = MiRemoveAnyPage (
                                MI_GET_PAGE_COLOR_FROM_PTE (PointerPte));

            TempPte.u.Hard.PageFrameNumber = PageFrameIndex;

            //
            // Map valid PDE into system (or session) address space.
            //

#if (_MI_PAGING_LEVELS >= 3)

            MiInitializePfnAndMakePteValid (PageFrameIndex, PointerPte, TempPte);

#else

            if (SessionSpace) {

                Index = (ULONG)(PointerPte - MiGetPdeAddress (MmSessionBase));
                ASSERT (SessionSpace->PageTables[Index].u.Long == 0);
                SessionSpace->PageTables[Index] = TempPte;

                MiInitializePfnForOtherProcess (PageFrameIndex,
                                                PointerPte,
                                                SessionSpace->SessionPageDirectoryIndex);

                MM_BUMP_SESS_COUNTER(MM_DBG_SESSION_PAGEDPOOL_PAGETABLE_ALLOC1, 1);
            }
            else {
                MmSystemPagePtes [((ULONG_PTR)PointerPte &
                    (PD_PER_SYSTEM * (sizeof(MMPTE) * PDE_PER_PAGE) - 1)) / sizeof(MMPTE)] = TempPte;
                MiInitializePfnForOtherProcess (PageFrameIndex,
                                                PointerPte,
                                                MmSystemPageDirectory[(PointerPte - MiGetPdeAddress(0)) / PDE_PER_PAGE]);
            }

            MI_WRITE_VALID_PTE (PointerPte, TempPte);
#endif

            PointerPte += 1;
            VirtualAddress = (PVOID)((PCHAR)VirtualAddress + PAGE_SIZE);
            StartPosition -= 1;

        } while (StartPosition > 0);

        UNLOCK_PFN (OldIrql);

        //
        // Clear the bitmap locations for the expansion area to indicate it
        // is available for consumption.
        //

        RtlClearBits (PagedPoolInfo->PagedPoolAllocationMap,
                      EndPosition,
                      (ULONG) PageTableCount * PTE_PER_PAGE);

        //
        // Denote where to start the next pool expansion.
        //

        PagedPoolInfo->NextPdeForPagedPoolExpansion += PageTableCount;

        //
        // Mark the PTEs for the expanded pool no-access.
        //

        MiZeroMemoryPte (VirtualAddressSave,
                         PageTableCount * (PAGE_SIZE / sizeof (MMPTE)));

        if (SessionSpace) {

            InterlockedExchangeAddSizeT (&SessionSpace->CommittedPages,
                                         PageTableCount);

            MM_BUMP_SESS_COUNTER (MM_DBG_SESSION_NP_PAGETABLE_ALLOC, PageTableCount);
            InterlockedExchangeAddSizeT (&SessionSpace->NonPageablePages,
                                         PageTableCount);
        }

        //
        // Start searching from the beginning of the bitmap as we may be
        // able to coalesce an earlier entry and only use part of the expansion
        // we just did.  This is not only important to reduce fragmentation but
        // in fact, required for the case where we could not expand enough
        // to cover the entire allocation and thus, must coalesce backwards
        // in order to satisfy the request.
        //

        StartPosition = RtlFindClearBitsAndSet (
                                   PagedPoolInfo->PagedPoolAllocationMap,
                                   (ULONG)SizeInPages,
                                   0);

        if (StartPosition == NO_BITS_FOUND) {
            goto NoVaSpaceLeft;
        }
    }

    //
    // This is paged pool, the start and end can't be saved
    // in the PFN database as the page isn't always resident
    // in memory.  The ideal place to save the start and end
    // would be in the prototype PTE, but there are no free
    // bits.  To solve this problem, a bitmap which parallels
    // the allocation bitmap exists which contains set bits
    // in the positions where an allocation ends.  This
    // allows pages to be deallocated with only their starting
    // address.
    //
    // For sanity's sake, the starting address can be verified
    // from the 2 bitmaps as well.  If the page before the starting
    // address is not allocated (bit is zero in allocation bitmap)
    // then this page is obviously a start of an allocation block.
    // If the page before is allocated and the other bit map does
    // not indicate the previous page is the end of an allocation,
    // then the starting address is wrong and a bugcheck should
    // be issued.
    //

    if (SizeInPages == 1) {
        PagedPoolInfo->PagedPoolHint = StartPosition + (ULONG)SizeInPages;
    }

    //
    // If paged pool has been configured as non-pageable, commitment has
    // already been charged so just set the length and return the address.
    //

    if ((MmDisablePagingExecutive & MM_PAGED_POOL_LOCKED_DOWN) &&
        (SessionSpace == NULL)) {

        BaseVa = (PVOID)((PCHAR) MmPagedPoolStart + ((ULONG_PTR)StartPosition << PAGE_SHIFT));

#if DBG
        PointerPte = MiGetPteAddress (BaseVa);
        for (i = 0; i < SizeInPages; i += 1) {
            ASSERT (PointerPte->u.Hard.Valid == 1);
            PointerPte += 1;
        }
#endif
    
        EndPosition = StartPosition + (ULONG)SizeInPages - 1;
        RtlSetBit (PagedPoolInfo->EndOfPagedPoolBitmap, EndPosition);
    
        if (PoolType & POOL_VERIFIER_MASK) {
            RtlSetBit (VerifierLargePagedPoolMap, StartPosition);
        }
    
        InterlockedExchangeAddSizeT (&PagedPoolInfo->AllocatedPagedPool,
                                     SizeInPages);
    
        FreePoolInPages = MmSizeOfPagedPoolInPages - MmPagedPoolInfo.AllocatedPagedPool;

        if (FreePoolInPages < MiHighPagedPoolThreshold) {

            //
            // Read the state directly instead of calling
            // KeReadStateEvent since we are holding the paged
            // pool mutex and want to keep instructions at a
            // minimum.
            //

            if (MiHighPagedPoolEvent->Header.SignalState != 0) {
                KeClearEvent (MiHighPagedPoolEvent);
            }
            if (FreePoolInPages <= MiLowPagedPoolThreshold) {
                if (MiLowPagedPoolEvent->Header.SignalState == 0) {
                    KeSetEvent (MiLowPagedPoolEvent, 0, FALSE);
                }
            }
        }

        KeReleaseGuardedMutex (&MmPagedPoolMutex);

        return BaseVa;
    }

    if (MiChargeCommitmentCantExpand (SizeInPages, FALSE) == FALSE) {

        if ((PsGetCurrentThread()->MemoryMaker == 1) &&
            (!KeIsExecutingDpc ())) {

            MiChargeCommitmentCantExpand (SizeInPages, TRUE);
        }
        else {
            RtlClearBits (PagedPoolInfo->PagedPoolAllocationMap,
                          StartPosition,
                          (ULONG)SizeInPages);
    
            //
            // Could not commit the page(s), return NULL indicating
            // no pool was allocated.  Note that the lack of commit may be due
            // to unused segments and the MmSharedCommit, prototype PTEs, etc
            // associated with them.  So force a reduction now.
            //
    
            if (SessionSpace == NULL) {
                KeReleaseGuardedMutex (&MmPagedPoolMutex);

                MmPoolFailures[MmPagedPool][MmHighPriority] += 1;
                MmPoolFailureReasons[MmPagedNoCommit] += 1;
            }
            else {
                KeReleaseGuardedMutex (&SessionSpace->PagedPoolMutex);

                MmPoolFailures[MmSessionPagedPool][MmHighPriority] += 1;
                MmPoolFailureReasons[MmSessionPagedNoCommit] += 1;
                SessionSpace->SessionPoolAllocationFailures[3] += 1;
            }

            MiIssuePageExtendRequestNoWait (SizeInPages);

            MiTrimSegmentCache ();

            return NULL;
        }
    }

    MM_TRACK_COMMIT (MM_DBG_COMMIT_PAGED_POOL_PAGES, SizeInPages);

    EndPosition = StartPosition + (ULONG)SizeInPages - 1;
    RtlSetBit (PagedPoolInfo->EndOfPagedPoolBitmap, EndPosition);

    if (SessionSpace) {
        KeReleaseGuardedMutex (&SessionSpace->PagedPoolMutex);
        InterlockedExchangeAddSizeT (&SessionSpace->CommittedPages,
                                     SizeInPages);
        MM_BUMP_SESS_COUNTER(MM_DBG_SESSION_COMMIT_PAGEDPOOL_PAGES, (ULONG)SizeInPages);
        BaseVa = (PVOID)((PCHAR)SessionSpace->PagedPoolStart +
                                ((ULONG_PTR)StartPosition << PAGE_SHIFT));

        InterlockedExchangeAddSizeT (&PagedPoolInfo->AllocatedPagedPool,
                                     SizeInPages);
    }
    else {
        if (PoolType & POOL_VERIFIER_MASK) {
            RtlSetBit (VerifierLargePagedPoolMap, StartPosition);
        }

        InterlockedExchangeAddSizeT (&PagedPoolInfo->AllocatedPagedPool,
                                     SizeInPages);

        FreePoolInPages = MmSizeOfPagedPoolInPages - PagedPoolInfo->AllocatedPagedPool;

        if (FreePoolInPages < MiHighPagedPoolThreshold) {

            //
            // Read the state directly instead of calling
            // KeReadStateEvent since we are holding the paged
            // pool mutex and want to keep instructions at a
            // minimum.
            //

            if (MiHighPagedPoolEvent->Header.SignalState != 0) {
                KeClearEvent (MiHighPagedPoolEvent);
            }
            if (FreePoolInPages <= MiLowPagedPoolThreshold) {
                if (MiLowPagedPoolEvent->Header.SignalState == 0) {
                    KeSetEvent (MiLowPagedPoolEvent, 0, FALSE);
                }
            }
        }

        KeReleaseGuardedMutex (&MmPagedPoolMutex);
        InterlockedExchangeAdd ((PLONG) &MmPagedPoolCommit, (LONG)SizeInPages);
        BaseVa = (PVOID)((PCHAR) MmPagedPoolStart +
                                ((ULONG_PTR)StartPosition << PAGE_SHIFT));
    }

    InterlockedExchangeAddSizeT (&PagedPoolInfo->PagedPoolCommit,
                                 SizeInPages);

    //
    // Carefully check the TB flush time stamps to decide if a flush is needed.
    //

    FlushCount = 0;
    LastTimeStamp = 0;
    PreviousPteNeededFlush = FALSE;
    PointerPte = MiGetPteAddress (BaseVa);

    for (i = 0; i < SizeInPages; i += 1, PointerPte += 1) {
        ASSERT (PointerPte->u.Hard.Valid == 0);

        TimeStamp = (ULONG) PointerPte->u.Soft.PageFileHigh;

        if (TimeStamp == 0) {

            //
            // This entry has already been flushed.
            //

            PreviousPteNeededFlush = FALSE;
            LastTimeStamp = TimeStamp;
            continue;
        }

        if (TimeStamp == LastTimeStamp) {

            if (PreviousPteNeededFlush == TRUE) {

                //
                // If this entry is the same as the prior one then it must be
                // treated the same with respect to flushes.
                //

                VaFlushList[FlushCount] = MiGetVirtualAddressMappedByPte (PointerPte);
                FlushCount += 1;
                if (FlushCount == MM_MAXIMUM_FLUSH_COUNT) {
                    FlushCount = 0;
                    MI_FLUSH_ENTIRE_TB (0x1E);
                    break;
                }
            }

            continue;
        }

        if (MiCompareTbFlushTimeStamp (TimeStamp, MI_PTE_LOOKUP_NEEDED)) {

            VaFlushList[FlushCount] = MiGetVirtualAddressMappedByPte (PointerPte);
            FlushCount += 1;
            if (FlushCount == MM_MAXIMUM_FLUSH_COUNT) {
                FlushCount = 0;
                MI_FLUSH_ENTIRE_TB (0x1E);
                break;
            }
            PreviousPteNeededFlush = TRUE;
        }
        else {
            PreviousPteNeededFlush = FALSE;
        }

        LastTimeStamp = TimeStamp;
    }

    //
    // Flush the TB entries for any relevant pages.
    //

    if (FlushCount == 0) {
        NOTHING;
    }
    else if (FlushCount == 1) {
        MI_FLUSH_SINGLE_TB (VaFlushList[0], TRUE);
    }
    else {
        ASSERT (FlushCount < MM_MAXIMUM_FLUSH_COUNT);
        MI_FLUSH_MULTIPLE_TB (FlushCount, &VaFlushList[0], TRUE);
    }

    TempPte.u.Long = MM_KERNEL_DEMAND_ZERO_PTE;

    MI_ADD_EXECUTE_TO_INVALID_PTE_IF_PAE (TempPte);

    PointerPte = MiGetPteAddress (BaseVa);

    StartingPte = PointerPte + SizeInPages;

    //
    // Fill the PTEs inline instead of using MiFillMemoryPte because on
    // most platforms MiFillMemoryPte degrades to a function call and 
    // typically only a small number of PTEs are filled here.
    //

    do {
        MI_WRITE_INVALID_PTE (PointerPte, TempPte);
        PointerPte += 1;
    } while (PointerPte < StartingPte);

    return BaseVa;
}

ULONG
MiFreePoolPages (
    IN PVOID StartingAddress
    )

/*++

Routine Description:

    This function returns a set of pages back to the pool from
    which they were obtained.  Once the pages have been deallocated
    the region provided by the allocation becomes available for
    allocation to other callers, i.e. any data in the region is now
    trashed and cannot be referenced.

Arguments:

    StartingAddress - Supplies the starting address which was returned
                      in a previous call to MiAllocatePoolPages.

Return Value:

    Returns the number of pages deallocated.

Environment:

    These functions are used by the general pool allocation routines
    and should not be called directly.

--*/

{
    PMMPFN PfnList;
    KIRQL OldIrql;
    KIRQL PfnIrql;
    ULONG StartPosition;
    ULONG Index;
    PFN_NUMBER i;
    PFN_NUMBER NumberOfPages;
    PFN_NUMBER PageFrameIndex;
    PMMPTE PointerPte;
    PMMPTE StartPte;
    PMMPFN Pfn1;
    PMMPFN StartPfn;
    PMMFREE_POOL_ENTRY Entry;
    PMMFREE_POOL_ENTRY NextEntry;
    PMMFREE_POOL_ENTRY LastEntry;
    PMM_PAGED_POOL_INFO PagedPoolInfo;
    PMM_SESSION_SPACE SessionSpace;
    PFN_NUMBER PagesFreed;
    MMPFNENTRY OriginalPfnFlags;
    ULONG_PTR VerifierAllocation;
    PULONG BitMap;
    PKGUARDED_MUTEX PoolMutex;
    PFN_NUMBER FreePoolInPages;
#if DBG
    PMMPTE DebugPte;
    PMMPFN DebugPfn;
    PMMPFN LastDebugPfn;
#endif

    //
    // Determine pool type based on the virtual address of the block
    // to deallocate.
    //
    // This assumes paged pool is virtually contiguous.
    //

    if ((StartingAddress >= MmPagedPoolStart) &&
        (StartingAddress <= MmPagedPoolEnd)) {
        SessionSpace = NULL;
        PagedPoolInfo = &MmPagedPoolInfo;
        StartPosition = (ULONG)(((PCHAR)StartingAddress -
                          (PCHAR)MmPagedPoolStart) >> PAGE_SHIFT);
        PoolMutex = &MmPagedPoolMutex;
    }
    else if (MI_IS_SESSION_POOL_ADDRESS (StartingAddress) == TRUE) {
        SessionSpace = SESSION_GLOBAL (MmSessionSpace);
        ASSERT (SessionSpace);
        PagedPoolInfo = &SessionSpace->PagedPoolInfo;
        StartPosition = (ULONG)(((PCHAR)StartingAddress -
                          (PCHAR)SessionSpace->PagedPoolStart) >> PAGE_SHIFT);
        PoolMutex = &SessionSpace->PagedPoolMutex;
    }
    else {

        if (StartingAddress < MM_SYSTEM_RANGE_START) {
            KeBugCheckEx (BAD_POOL_CALLER,
                          0x40,
                          (ULONG_PTR)StartingAddress,
                          (ULONG_PTR)MM_SYSTEM_RANGE_START,
                          0);
        }

        StartPosition = (ULONG)(((PCHAR)StartingAddress -
                          (PCHAR) MmNonPagedPoolStart) >> PAGE_SHIFT);

        //
        // Check to ensure this page is really the start of an allocation.
        //

        if (MI_IS_PHYSICAL_ADDRESS (StartingAddress)) {

            //
            // On certain architectures, virtual addresses
            // may be physical and hence have no corresponding PTE.
            //

            PointerPte = NULL;
            Pfn1 = MI_PFN_ELEMENT (MI_CONVERT_PHYSICAL_TO_PFN (StartingAddress));
            ASSERT (StartPosition < (ULONG) BYTES_TO_PAGES (MmSizeOfNonPagedPoolInBytes));

            if ((StartingAddress < MmNonPagedPoolStart) ||
                (StartingAddress >= MmNonPagedPoolEnd0)) {
                KeBugCheckEx (BAD_POOL_CALLER,
                              0x42,
                              (ULONG_PTR)StartingAddress,
                              0,
                              0);
            }
        }
        else {
            PointerPte = MiGetPteAddress (StartingAddress);

            if (((StartingAddress >= MmNonPagedPoolExpansionStart) &&
                (StartingAddress < MmNonPagedPoolEnd)) ||
                ((StartingAddress >= MmNonPagedPoolStart) &&
                (StartingAddress < MmNonPagedPoolEnd0))) {
                    NOTHING;
            }
            else {
                KeBugCheckEx (BAD_POOL_CALLER,
                              0x43,
                              (ULONG_PTR)StartingAddress,
                              0,
                              0);
            }
            Pfn1 = MI_PFN_ELEMENT (PointerPte->u.Hard.PageFrameNumber);
        }

        if (Pfn1->u3.e1.StartOfAllocation == 0) {
            KeBugCheckEx (BAD_POOL_CALLER,
                          0x41,
                          (ULONG_PTR) StartingAddress,
                          (ULONG_PTR) MI_PFN_ELEMENT_TO_INDEX (Pfn1),
                          MmHighestPhysicalPage);
        }

        ASSERT (Pfn1->u4.PteFrame != MI_MAGIC_AWE_PTEFRAME);

        //
        // Hang single page allocations off our slist header.
        //

        if ((Pfn1->u3.e1.EndOfAllocation == 1) &&
            (Pfn1->u4.VerifierAllocation == 0) &&
            (Pfn1->u3.e1.LargeSessionAllocation == 0) &&
            (ExQueryDepthSList (&MiNonPagedPoolSListHead) < MiNonPagedPoolSListMaximum)) {
            InterlockedPushEntrySList (&MiNonPagedPoolSListHead,
                                       (PSLIST_ENTRY) StartingAddress);
            return 1;
        }

        //
        // The nonpaged pool being freed may be the target of a delayed unlock.
        // Since these pages may be immediately released, force any pending
        // delayed actions to occur now.
        //

#if !defined(MI_MULTINODE)
        if (MmPfnDeferredList != NULL) {
            MiDeferredUnlockPages (0);
        }
#else
        //
        // Each and every node's deferred list would have to be checked so
        // we might as well go the long way and just call.
        //

        MiDeferredUnlockPages (0);
#endif

        StartPfn = Pfn1;

        OriginalPfnFlags = Pfn1->u3.e1;
        VerifierAllocation = Pfn1->u4.VerifierAllocation;

        //
        // ASSERT to ensure the pool being freed is not still in use
        // for an I/O.
        //

        if ((Pfn1->u3.e2.ReferenceCount == 0) ||
            ((Pfn1->u3.e2.ReferenceCount > 1) &&
             (Pfn1->u3.e1.WriteInProgress == 0))) {

            MiBadRefCount (Pfn1);
        }

        //
        // Find end of allocation and release the pages.
        //

        if (PointerPte == NULL) {
            SATISFY_OVERZEALOUS_COMPILER (StartPte = NULL);
            while (Pfn1->u3.e1.EndOfAllocation == 0) {
                Pfn1 += 1;

                //
                // ASSERT to ensure the pool being freed is not still in use
                // for an I/O.
                //

                ASSERT (Pfn1->u3.e2.ReferenceCount != 0);
                ASSERT ((Pfn1->u3.e2.ReferenceCount == 1) ||
                        (Pfn1->u3.e1.WriteInProgress == 1));
            }
            NumberOfPages = Pfn1 - StartPfn + 1;
        }
        else {
            StartPte = PointerPte;
            while (Pfn1->u3.e1.EndOfAllocation == 0) {
                PointerPte += 1;
                Pfn1 = MI_PFN_ELEMENT (PointerPte->u.Hard.PageFrameNumber);

                //
                // ASSERT to ensure the pool being freed is not still in use
                // for an I/O.
                //

                ASSERT (Pfn1->u3.e2.ReferenceCount != 0);
                ASSERT ((Pfn1->u3.e2.ReferenceCount == 1) ||
                        (Pfn1->u3.e1.WriteInProgress == 1));
            }
            NumberOfPages = PointerPte - StartPte + 1;
        }

        if (VerifierAllocation != 0) {
            VerifierFreeTrackedPool (StartingAddress,
                                     NumberOfPages << PAGE_SHIFT,
                                     NonPagedPool,
                                     FALSE);
        }

#if DBG
        if (MiFillFreedPool != 0) {
            RtlFillMemoryUlong (StartingAddress,
                                PAGE_SIZE * NumberOfPages,
                                MiFillFreedPool);
        }
#endif

        OldIrql = KeAcquireQueuedSpinLock (LockQueueMmNonPagedPoolLock);

        StartPfn->u3.e1.StartOfAllocation = 0;
        StartPfn->u3.e1.LargeSessionAllocation = 0;
        StartPfn->u4.VerifierAllocation = 0;

        MmAllocatedNonPagedPool -= NumberOfPages;

        FreePoolInPages = MmMaximumNonPagedPoolInPages - MmAllocatedNonPagedPool;

        if (FreePoolInPages > MiLowNonPagedPoolThreshold) {

            //
            // Read the state directly instead of calling
            // KeReadStateEvent since we are holding the nonpaged
            // pool lock and want to keep instructions at a
            // minimum.
            //

            if (MiLowNonPagedPoolEvent->Header.SignalState != 0) {
                KeClearEvent (MiLowNonPagedPoolEvent);
            }
            if (FreePoolInPages >= MiHighNonPagedPoolThreshold) {
                if (MiHighNonPagedPoolEvent->Header.SignalState == 0) {
                    KeSetEvent (MiHighNonPagedPoolEvent, 0, FALSE);
                }
            }
        }

        Pfn1->u3.e1.EndOfAllocation = 0;

        if (StartingAddress >= MmNonPagedPoolExpansionStart) {

            //
            // This page was from the expanded pool, should
            // it be freed?
            //
            // NOTE: all pages in the expanded pool area have PTEs
            // so no physical address checks need to be performed.
            //

            if (Pfn1->u4.MustBeCached == 1) {

                //
                // This is a slush page that is concurrently mapped
                // (cached) within the kernel or HAL's large page mapping.
                // To prevent a possible TB attribute conflict, these pages
                // are never put on the general purpose page free lists.
                // Instead they are cached here for nonpaged pool usage only.
                //

                PfnList = NULL;
                PointerPte = StartPte;

                //
                // Hold the nonpaged pool lock until all the PTEs are cleared
                // so another thread trying to coalesce will see consistent
                // values.
                //

                for (i = 0; i < NumberOfPages; i += 1, PointerPte += 1) {

                    ASSERT (PointerPte->u.Hard.Valid == 1);
                    PageFrameIndex = MI_GET_PAGE_FRAME_FROM_PTE (PointerPte);
                    Pfn1 = MI_PFN_ELEMENT (PageFrameIndex);

                    ASSERT (Pfn1->u3.e1.PageLocation == ActiveAndValid);
                    ASSERT (Pfn1->u3.e1.CacheAttribute == MiCached);

                    ASSERT (Pfn1->u3.e2.ReferenceCount == 1);
                    ASSERT (Pfn1->u2.ShareCount == 1);
                    ASSERT (Pfn1->OriginalPte.u.Long == MM_DEMAND_ZERO_WRITE_PTE);
                    ASSERT (Pfn1->u4.MustBeCached == 1);
                    ASSERT (Pfn1->u3.e1.StartOfAllocation == 0);
                    ASSERT (Pfn1->u3.e1.EndOfAllocation == 0);
                    ASSERT (Pfn1->u3.e1.LargeSessionAllocation == 0);
                    ASSERT (Pfn1->u4.VerifierAllocation == 0);

                    Pfn1->u1.Event = (PKEVENT) PfnList;
                    PfnList = Pfn1;
                }

                LOCK_PFN2 (PfnIrql);
                StartPfn->u1.Event = (PKEVENT) MiCachedNonPagedPool;
                MiCachedNonPagedPool = PfnList;
                MiCachedNonPagedPoolCount += NumberOfPages;
                UNLOCK_PFN2 (PfnIrql);

                MiReleaseSystemPtes (StartPte,
                                     (ULONG)NumberOfPages,
                                     NonPagedPoolExpansion);

                KeReleaseQueuedSpinLock (LockQueueMmNonPagedPoolLock, OldIrql);

                //
                // No TB flush is done here - the system PTE management code
                // will lazily flush as needed.
                //

                return (ULONG)NumberOfPages;
            }

            if ((NumberOfPages > 3) ||
                (MmNumberOfFreeNonPagedPool > MmFreedExpansionPoolMaximum) ||
                ((MmResidentAvailablePages < 200) &&
                 (MiExpansionPoolPagesInUse > MiExpansionPoolPagesInitialCharge))) {

                //
                // Free these pages back to the free page list.
                //

                MiFreeNonPagedPool (StartingAddress, NumberOfPages);

                KeReleaseQueuedSpinLock (LockQueueMmNonPagedPoolLock, OldIrql);

                return (ULONG)NumberOfPages;
            }
        }

        //
        // Add the pages to the list of free pages.
        //

        MmNumberOfFreeNonPagedPool += NumberOfPages;

        //
        // Check to see if the next allocation is free.
        // We cannot walk off the end of nonpaged expansion
        // pages as the highest expansion allocation is always
        // virtual and guard-paged.
        //

        i = NumberOfPages;

        ASSERT (MiEndOfInitialPoolFrame != 0);

        if (MI_PFN_ELEMENT_TO_INDEX (Pfn1) == MiEndOfInitialPoolFrame) {
            PointerPte += 1;
            Pfn1 = NULL;
        }
        else if (PointerPte == NULL) {
            Pfn1 += 1;
            ASSERT ((PCHAR)StartingAddress + NumberOfPages < (PCHAR)MmNonPagedPoolStart + MmSizeOfNonPagedPoolInBytes);
        }
        else {
            PointerPte += 1;
            ASSERT ((PCHAR)StartingAddress + NumberOfPages <= (PCHAR)MmNonPagedPoolEnd);

            //
            // Unprotect the previously freed pool so it can be merged.
            //

            if (MmProtectFreedNonPagedPool == TRUE) {
                MiUnProtectFreeNonPagedPool (
                    (PVOID)MiGetVirtualAddressMappedByPte(PointerPte),
                    0);
            }

            if (PointerPte->u.Hard.Valid == 1) {
                Pfn1 = MI_PFN_ELEMENT (PointerPte->u.Hard.PageFrameNumber);
            }
            else {
                Pfn1 = NULL;
            }
        }

        if ((Pfn1 != NULL) && (Pfn1->u3.e1.StartOfAllocation == 0)) {

            //
            // This range of pages is free.  Remove this entry
            // from the list and add these pages to the current
            // range being freed.
            //

            Entry = (PMMFREE_POOL_ENTRY)((PCHAR)StartingAddress
                                        + (NumberOfPages << PAGE_SHIFT));
            ASSERT (Entry->Signature == MM_FREE_POOL_SIGNATURE);
            ASSERT (Entry->Owner == Entry);

#if DBG
            if (PointerPte == NULL) {

                ASSERT (MI_IS_PHYSICAL_ADDRESS(StartingAddress));

                //
                // On certain architectures, virtual addresses
                // may be physical and hence have no corresponding PTE.
                //

                DebugPfn = MI_PFN_ELEMENT (MI_CONVERT_PHYSICAL_TO_PFN (Entry));
                DebugPfn += Entry->Size;
                if (MI_PFN_ELEMENT_TO_INDEX (DebugPfn - 1) != MiEndOfInitialPoolFrame) {
                    ASSERT (DebugPfn->u3.e1.StartOfAllocation == 1);
                }
            }
            else {
                DebugPte = PointerPte + Entry->Size;
                if ((DebugPte-1)->u.Hard.Valid == 1) {
                    DebugPfn = MI_PFN_ELEMENT ((DebugPte-1)->u.Hard.PageFrameNumber);
                    if (MI_PFN_ELEMENT_TO_INDEX (DebugPfn) != MiEndOfInitialPoolFrame) {
                        if (DebugPte->u.Hard.Valid == 1) {
                            DebugPfn = MI_PFN_ELEMENT (DebugPte->u.Hard.PageFrameNumber);
                            ASSERT (DebugPfn->u3.e1.StartOfAllocation == 1);
                        }
                    }

                }
            }
#endif

            i += Entry->Size;
            if (MmProtectFreedNonPagedPool == FALSE) {
                RemoveEntryList (&Entry->List);
            }
            else {
                MiProtectedPoolRemoveEntryList (&Entry->List);
            }
        }

        //
        // Check to see if the previous page is the end of an allocation.
        // If it is not the end of an allocation, it must be free and
        // therefore this allocation can be tagged onto the end of
        // that allocation.
        //
        // We cannot walk off the beginning of expansion pool because it is
        // guard-paged.  If the initial pool is superpaged instead, we are also
        // safe as the must succeed pages always have EndOfAllocation set.
        //

        Entry = (PMMFREE_POOL_ENTRY)StartingAddress;

        ASSERT (MiStartOfInitialPoolFrame != 0);

        if (MI_PFN_ELEMENT_TO_INDEX (StartPfn) == MiStartOfInitialPoolFrame) {
            Pfn1 = NULL;
        }
        else if (PointerPte == NULL) {
            ASSERT (MI_IS_PHYSICAL_ADDRESS(StartingAddress));
            ASSERT (StartingAddress != MmNonPagedPoolStart);

            Pfn1 = MI_PFN_ELEMENT (MI_CONVERT_PHYSICAL_TO_PFN (
                                    (PVOID)((PCHAR)Entry - PAGE_SIZE)));

        }
        else {
            PointerPte -= NumberOfPages + 1;

            //
            // Unprotect the previously freed pool so it can be merged.
            //

            if (MmProtectFreedNonPagedPool == TRUE) {
                MiUnProtectFreeNonPagedPool (
                    (PVOID)MiGetVirtualAddressMappedByPte(PointerPte),
                    0);
            }

            if (PointerPte->u.Hard.Valid == 1) {
                Pfn1 = MI_PFN_ELEMENT (PointerPte->u.Hard.PageFrameNumber);
            }
            else {
                Pfn1 = NULL;
            }
        }
        if (Pfn1 != NULL) {
            if (Pfn1->u3.e1.EndOfAllocation == 0) {

                //
                // This range of pages is free, add these pages to
                // this entry.  The owner field points to the address
                // of the list entry which is linked into the free pool
                // pages list.
                //

                Entry = (PMMFREE_POOL_ENTRY)((PCHAR)StartingAddress - PAGE_SIZE);
                ASSERT (Entry->Signature == MM_FREE_POOL_SIGNATURE);
                Entry = Entry->Owner;

                //
                // Unprotect the previously freed pool so we can merge it
                //

                if (MmProtectFreedNonPagedPool == TRUE) {
                    MiUnProtectFreeNonPagedPool ((PVOID)Entry, 0);
                }

                //
                // If this entry became larger than MM_SMALL_ALLOCATIONS
                // pages, move it to the tail of the list.  This keeps the
                // small allocations at the front of the list.
                //

                if (Entry->Size < MI_MAX_FREE_LIST_HEADS - 1) {

                    if (MmProtectFreedNonPagedPool == FALSE) {
                        RemoveEntryList (&Entry->List);
                    }
                    else {
                        MiProtectedPoolRemoveEntryList (&Entry->List);
                    }

                    //
                    // Add these pages to the previous entry.
                    //
    
                    Entry->Size += i;

                    Index = (ULONG)(Entry->Size - 1);
            
                    if (Index >= MI_MAX_FREE_LIST_HEADS) {
                        Index = MI_MAX_FREE_LIST_HEADS - 1;
                    }

                    if (MmProtectFreedNonPagedPool == FALSE) {
                        InsertTailList (&MmNonPagedPoolFreeListHead[Index],
                                        &Entry->List);
                    }
                    else {
                        MiProtectedPoolInsertList (&MmNonPagedPoolFreeListHead[Index],
                                          &Entry->List,
                                          Entry->Size < MM_SMALL_ALLOCATIONS ?
                                              TRUE : FALSE);
                    }
                }
                else {

                    //
                    // Add these pages to the previous entry.
                    //
    
                    Entry->Size += i;
                }
            }
        }

        if (Entry == (PMMFREE_POOL_ENTRY)StartingAddress) {

            //
            // This entry was not combined with the previous, insert it
            // into the list.
            //

            Entry->Size = i;

            Index = (ULONG)(Entry->Size - 1);
    
            if (Index >= MI_MAX_FREE_LIST_HEADS) {
                Index = MI_MAX_FREE_LIST_HEADS - 1;
            }

            if (MmProtectFreedNonPagedPool == FALSE) {
                InsertTailList (&MmNonPagedPoolFreeListHead[Index],
                                &Entry->List);
            }
            else {
                MiProtectedPoolInsertList (&MmNonPagedPoolFreeListHead[Index],
                                      &Entry->List,
                                      Entry->Size < MM_SMALL_ALLOCATIONS ?
                                          TRUE : FALSE);
            }
        }

        //
        // Set the owner field in all these pages.
        //

        ASSERT (i != 0);
        NextEntry = (PMMFREE_POOL_ENTRY)StartingAddress;
        LastEntry = (PMMFREE_POOL_ENTRY)((PCHAR)NextEntry + (i << PAGE_SHIFT));

        do {
            NextEntry->Owner = Entry;
#if DBG
            NextEntry->Signature = MM_FREE_POOL_SIGNATURE;
#endif

            NextEntry = (PMMFREE_POOL_ENTRY)((PCHAR)NextEntry + PAGE_SIZE);
        } while (NextEntry != LastEntry);

#if DBG
        NextEntry = Entry;

        if (PointerPte == NULL) {
            ASSERT (MI_IS_PHYSICAL_ADDRESS(StartingAddress));
            DebugPfn = MI_PFN_ELEMENT (MI_CONVERT_PHYSICAL_TO_PFN (NextEntry));
            LastDebugPfn = DebugPfn + Entry->Size;

            for ( ; DebugPfn < LastDebugPfn; DebugPfn += 1) {
                ASSERT ((DebugPfn->u3.e1.StartOfAllocation == 0) &&
                        (DebugPfn->u3.e1.EndOfAllocation == 0));
                ASSERT (NextEntry->Owner == Entry);
                NextEntry = (PMMFREE_POOL_ENTRY)((PCHAR)NextEntry + PAGE_SIZE);
            }
        }
        else {

            for (i = 0; i < Entry->Size; i += 1) {

                DebugPte = MiGetPteAddress (NextEntry);
                DebugPfn = MI_PFN_ELEMENT (DebugPte->u.Hard.PageFrameNumber);
                ASSERT ((DebugPfn->u3.e1.StartOfAllocation == 0) &&
                        (DebugPfn->u3.e1.EndOfAllocation == 0));
                ASSERT (NextEntry->Owner == Entry);
                NextEntry = (PMMFREE_POOL_ENTRY)((PCHAR)NextEntry + PAGE_SIZE);
            }
        }
#endif

        //
        // Prevent anyone from accessing non paged pool after freeing it.
        //

        if (MmProtectFreedNonPagedPool == TRUE) {
            MiProtectFreeNonPagedPool ((PVOID)Entry, (ULONG)Entry->Size);
        }

        KeReleaseQueuedSpinLock (LockQueueMmNonPagedPoolLock, OldIrql);

        return (ULONG)NumberOfPages;
    }

    //
    // Paged pool.  Need to verify start of allocation using
    // end of allocation bitmap.
    //

    if (!RtlCheckBit (PagedPoolInfo->PagedPoolAllocationMap, StartPosition)) {
        KeBugCheckEx (BAD_POOL_CALLER,
                      0x50,
                      (ULONG_PTR)StartingAddress,
                      (ULONG_PTR)StartPosition,
                      MmSizeOfPagedPoolInBytes);
    }

#if DBG
    if (StartPosition > 0) {

        KeAcquireGuardedMutex (PoolMutex);

        if (RtlCheckBit (PagedPoolInfo->PagedPoolAllocationMap, StartPosition - 1)) {
            if (!RtlCheckBit (PagedPoolInfo->EndOfPagedPoolBitmap, StartPosition - 1)) {

                //
                // In the middle of an allocation... bugcheck.
                //

                KeBugCheckEx (MEMORY_MANAGEMENT,
                              0x41286,
                              (ULONG_PTR)PagedPoolInfo->PagedPoolAllocationMap,
                              (ULONG_PTR)PagedPoolInfo->EndOfPagedPoolBitmap,
                              StartPosition);
            }
        }

        KeReleaseGuardedMutex (PoolMutex);
    }
#endif

    //
    // Find the last allocated page and check to see if any
    // of the pages being deallocated are in the paging file.
    //

    BitMap = PagedPoolInfo->EndOfPagedPoolBitmap->Buffer;

    i = StartPosition;

    while (!MI_CHECK_BIT (BitMap, i)) {
        i += 1;
    }

    NumberOfPages = i - StartPosition + 1;

    if (SessionSpace == NULL) {

        if (VerifierLargePagedPoolMap != NULL) {

            BitMap = VerifierLargePagedPoolMap->Buffer;

            if (MI_CHECK_BIT (BitMap, StartPosition)) {

                KeAcquireGuardedMutex (&MmPagedPoolMutex);

                ASSERT (MI_CHECK_BIT (BitMap, StartPosition));

                MI_CLEAR_BIT (BitMap, StartPosition);

                KeReleaseGuardedMutex (&MmPagedPoolMutex);

                VerifierFreeTrackedPool (StartingAddress,
                                         NumberOfPages << PAGE_SHIFT,
                                         PagedPool,
                                         FALSE);
            }
        }

        if ((NumberOfPages == 1) &&
            (ExQueryDepthSList (&MiPagedPoolSListHead) < MiPagedPoolSListMaximum)) {
            InterlockedPushEntrySList (&MiPagedPoolSListHead,
                                       (PSLIST_ENTRY) StartingAddress);
            return 1;
        }

        //
        // If paged pool has been configured as non-pageable, only
        // virtual address space is released.
        //
        
        if (MmDisablePagingExecutive & MM_PAGED_POOL_LOCKED_DOWN) {

            KeAcquireGuardedMutex (&MmPagedPoolMutex);

            //
            // Clear the end of allocation bit in the bit map.
            //
    
            RtlClearBit (PagedPoolInfo->EndOfPagedPoolBitmap, (ULONG)i);
    
            //
            // Clear the allocation bits in the bit map.
            //
        
            RtlClearBits (PagedPoolInfo->PagedPoolAllocationMap,
                          StartPosition,
                          (ULONG)NumberOfPages);
        
            if (StartPosition < PagedPoolInfo->PagedPoolHint) {
                PagedPoolInfo->PagedPoolHint = StartPosition;
            }
        
            InterlockedExchangeAddSizeT (&PagedPoolInfo->AllocatedPagedPool,
                                         0 - NumberOfPages);

            FreePoolInPages = MmSizeOfPagedPoolInPages - MmPagedPoolInfo.AllocatedPagedPool;

            if (FreePoolInPages > MiLowPagedPoolThreshold) {

                //
                // Read the state directly instead of calling
                // KeReadStateEvent since we are holding the paged
                // pool mutex and want to keep instructions at a
                // minimum.
                //

                if (MiLowPagedPoolEvent->Header.SignalState != 0) {
                    KeClearEvent (MiLowPagedPoolEvent);
                }
                if (FreePoolInPages >= MiHighPagedPoolThreshold) {
                    if (MiHighPagedPoolEvent->Header.SignalState == 0) {
                        KeSetEvent (MiHighPagedPoolEvent, 0, FALSE);
                    }
                }
            }
    
            KeReleaseGuardedMutex (&MmPagedPoolMutex);

            return (ULONG)NumberOfPages;
        }
    }

    PointerPte = PagedPoolInfo->FirstPteForPagedPool + StartPosition;

    PagesFreed = MiDeleteSystemPageableVm (PointerPte,
                                          NumberOfPages,
                                          0,
                                          NULL);

    ASSERT (PagesFreed == NumberOfPages);

    //
    // Clear the end of allocation bit in the bit map.
    //

    BitMap = PagedPoolInfo->EndOfPagedPoolBitmap->Buffer;

    KeAcquireGuardedMutex (PoolMutex);

    MI_CLEAR_BIT (BitMap, i);

    //
    // Clear the allocation bits in the bit map.
    //

    RtlClearBits (PagedPoolInfo->PagedPoolAllocationMap,
                  StartPosition,
                  (ULONG)NumberOfPages);

    if (StartPosition < PagedPoolInfo->PagedPoolHint) {
        PagedPoolInfo->PagedPoolHint = StartPosition;
    }

    if (SessionSpace) {

        KeReleaseGuardedMutex (PoolMutex);

        InterlockedExchangeAddSizeT (&PagedPoolInfo->AllocatedPagedPool,
                                     0 - NumberOfPages);
    
        InterlockedExchangeAddSizeT (&SessionSpace->CommittedPages,
                                     0 - NumberOfPages);
   
        MM_BUMP_SESS_COUNTER (MM_DBG_SESSION_COMMIT_POOL_FREED,
                              (ULONG)NumberOfPages);
    }
    else {
        InterlockedExchangeAddSizeT (&PagedPoolInfo->AllocatedPagedPool,
                                     0 - NumberOfPages);
    
        FreePoolInPages = MmSizeOfPagedPoolInPages - MmPagedPoolInfo.AllocatedPagedPool;

        if (FreePoolInPages > MiLowPagedPoolThreshold) {

            //
            // Read the state directly instead of calling
            // KeReadStateEvent since we are holding the paged
            // pool mutex and want to keep instructions at a
            // minimum.
            //

            if (MiLowPagedPoolEvent->Header.SignalState != 0) {
                KeClearEvent (MiLowPagedPoolEvent);
            }
            if (FreePoolInPages >= MiHighPagedPoolThreshold) {
                if (MiHighPagedPoolEvent->Header.SignalState == 0) {
                    KeSetEvent (MiHighPagedPoolEvent, 0, FALSE);
                }
            }
        }

        KeReleaseGuardedMutex (PoolMutex);

        InterlockedExchangeAdd ((PLONG) &MmPagedPoolCommit,
                                (LONG)(0 - NumberOfPages));
    }

    MiReturnCommitment (NumberOfPages);

    InterlockedExchangeAddSizeT (&PagedPoolInfo->PagedPoolCommit,
                                 0 - NumberOfPages);

    MM_TRACK_COMMIT (MM_DBG_COMMIT_RETURN_PAGED_POOL_PAGES, NumberOfPages);

    return (ULONG)NumberOfPages;
}

VOID
MiInitializePoolEvents (
    VOID
    )

/*++

Routine Description:

    This function initializes the pool event states.

Arguments:

    None.

Return Value:

    None.

Environment:

    Kernel mode, during initialization.

--*/

{
    KIRQL OldIrql;
    PFN_NUMBER FreePoolInPages;

    //
    // Initialize the paged events.
    //

    KeAcquireGuardedMutex (&MmPagedPoolMutex);

    FreePoolInPages = MmSizeOfPagedPoolInPages - MmPagedPoolInfo.AllocatedPagedPool;

    if (FreePoolInPages >= MiHighPagedPoolThreshold) {
        KeSetEvent (MiHighPagedPoolEvent, 0, FALSE);
    }
    else {
        KeClearEvent (MiHighPagedPoolEvent);
    }

    if (FreePoolInPages <= MiLowPagedPoolThreshold) {
        KeSetEvent (MiLowPagedPoolEvent, 0, FALSE);
    }
    else {
        KeClearEvent (MiLowPagedPoolEvent);
    }

    KeReleaseGuardedMutex (&MmPagedPoolMutex);

    //
    // Initialize the nonpaged events.
    //

    OldIrql = KeAcquireQueuedSpinLock (LockQueueMmNonPagedPoolLock);

    FreePoolInPages = MmMaximumNonPagedPoolInPages - MmAllocatedNonPagedPool;

    if (FreePoolInPages >= MiHighNonPagedPoolThreshold) {
        KeSetEvent (MiHighNonPagedPoolEvent, 0, FALSE);
    }
    else {
        KeClearEvent (MiHighNonPagedPoolEvent);
    }

    if (FreePoolInPages <= MiLowNonPagedPoolThreshold) {
        KeSetEvent (MiLowNonPagedPoolEvent, 0, FALSE);
    }
    else {
        KeClearEvent (MiLowNonPagedPoolEvent);
    }

    KeReleaseQueuedSpinLock (LockQueueMmNonPagedPoolLock, OldIrql);

    return;
}

VOID
MiInitializeNonPagedPool (
    VOID
    )

/*++

Routine Description:

    This function initializes the NonPaged pool.

    NonPaged Pool is linked together through the pages.

Arguments:

    None.

Return Value:

    None.

Environment:

    Kernel mode, during initialization.

--*/

{
    PFN_NUMBER PagesInPool;
    PFN_NUMBER Size;
    ULONG Index;
    PMMFREE_POOL_ENTRY FreeEntry;
    PMMFREE_POOL_ENTRY FirstEntry;
    PMMPTE PointerPte;
    PVOID EndOfInitialPool;
    PFN_NUMBER PageFrameIndex;

    PAGED_CODE();

    //
    // Initialize the slist heads for free pages (both paged & nonpaged).
    //

    InitializeSListHead (&MiPagedPoolSListHead);
    InitializeSListHead (&MiNonPagedPoolSListHead);

    if (MmNumberOfPhysicalPages >= (2*1024*((1024*1024)/PAGE_SIZE))) {
        MiNonPagedPoolSListMaximum <<= 3;
        MiPagedPoolSListMaximum <<= 3;
    }
    else if (MmNumberOfPhysicalPages >= (1*1024*((1024*1024)/PAGE_SIZE))) {
        MiNonPagedPoolSListMaximum <<= 1;
        MiPagedPoolSListMaximum <<= 1;
    }

    //
    // If the verifier or special pool is enabled, then disable lookasides so
    // driver bugs can be found more quickly.
    //

    if ((MmVerifyDriverBufferLength != (ULONG)-1) ||
        (MmProtectFreedNonPagedPool == TRUE) ||
        ((MmSpecialPoolTag != 0) && (MmSpecialPoolTag != (ULONG)-1))) {

        MiNonPagedPoolSListMaximum = 0;
        MiPagedPoolSListMaximum = 0;
    }

    //
    // Initialize the list heads for free pages.
    //

    for (Index = 0; Index < MI_MAX_FREE_LIST_HEADS; Index += 1) {
        InitializeListHead (&MmNonPagedPoolFreeListHead[Index]);
    }

    //
    // Set up the non paged pool pages.
    //

    FreeEntry = (PMMFREE_POOL_ENTRY) MmNonPagedPoolStart;
    FirstEntry = FreeEntry;

    PagesInPool = BYTES_TO_PAGES (MmSizeOfNonPagedPoolInBytes);

    MmNumberOfFreeNonPagedPool = PagesInPool;

    Index = (ULONG)(MmNumberOfFreeNonPagedPool - 1);
    if (Index >= MI_MAX_FREE_LIST_HEADS) {
        Index = MI_MAX_FREE_LIST_HEADS - 1;
    }

    InsertHeadList (&MmNonPagedPoolFreeListHead[Index], &FreeEntry->List);

    FreeEntry->Size = PagesInPool;
#if DBG
    FreeEntry->Signature = MM_FREE_POOL_SIGNATURE;
#endif
    FreeEntry->Owner = FirstEntry;

    while (PagesInPool > 1) {
        FreeEntry = (PMMFREE_POOL_ENTRY)((PCHAR)FreeEntry + PAGE_SIZE);
#if DBG
        FreeEntry->Signature = MM_FREE_POOL_SIGNATURE;
#endif
        FreeEntry->Owner = FirstEntry;
        PagesInPool -= 1;
    }

    //
    // Initialize the first nonpaged pool PFN.
    //

    if (MI_IS_PHYSICAL_ADDRESS(MmNonPagedPoolStart)) {
        PageFrameIndex = MI_CONVERT_PHYSICAL_TO_PFN (MmNonPagedPoolStart);
    }
    else {
        PointerPte = MiGetPteAddress(MmNonPagedPoolStart);
        ASSERT (PointerPte->u.Hard.Valid == 1);
        PageFrameIndex = MI_GET_PAGE_FRAME_FROM_PTE (PointerPte);
    }
    MiStartOfInitialPoolFrame = PageFrameIndex;

    //
    // Set the last nonpaged pool PFN so coalescing on free doesn't go
    // past the end of the initial pool.
    //


    MmNonPagedPoolEnd0 = (PVOID)((ULONG_PTR)MmNonPagedPoolStart + MmSizeOfNonPagedPoolInBytes);
    EndOfInitialPool = (PVOID)((ULONG_PTR)MmNonPagedPoolStart + MmSizeOfNonPagedPoolInBytes - 1);

    if (MI_IS_PHYSICAL_ADDRESS(EndOfInitialPool)) {
        PageFrameIndex = MI_CONVERT_PHYSICAL_TO_PFN (EndOfInitialPool);
    }
    else {
        PointerPte = MiGetPteAddress(EndOfInitialPool);
        ASSERT (PointerPte->u.Hard.Valid == 1);
        PageFrameIndex = MI_GET_PAGE_FRAME_FROM_PTE (PointerPte);
    }
    MiEndOfInitialPoolFrame = PageFrameIndex;

    //
    // Set up the system PTEs for nonpaged pool expansion.
    //

    PointerPte = MiGetPteAddress (MmNonPagedPoolExpansionStart);
    ASSERT (PointerPte->u.Hard.Valid == 0);

#if defined (_WIN64)
    Size = BYTES_TO_PAGES ((ULONG_PTR)MmNonPagedPoolEnd - (ULONG_PTR)MmNonPagedPoolExpansionStart);
#else
    Size = BYTES_TO_PAGES (MmMaximumNonPagedPoolInBytes -
                            MmSizeOfNonPagedPoolInBytes);
#endif

    //
    // Insert a guard PTE at the top and bottom of expanded nonpaged pool.
    //

    if (Size != 0) {
        Size -= 2;
        PointerPte += 1;
    }

    ASSERT (MiExpansionPoolPagesInUse == 0);

    //
    // Initialize the nonpaged pool expansion resident available initial charge.
    // Note that MmResidentAvailablePages & MmAvailablePages are not initialized
    // yet, but this amount is subtracted when MmResidentAvailablePages is
    // initialized later.
    //
    // Limit the charge to 1/6 of the amount of physical memory at bootup or
    // 256mb, whichever is less.  Not the virtual size is not reduced because
    // if memory is plentiful, we want to allow the system to grow to its
    // maximal value.
    //
    // Note also the 256mb is not picked randomly - we have seen sparsely
    // populated NT64 machines that need more than 128mb in order to boot
    // because the PFN bitmap (not database) was 142mb.
    //

    MiExpansionPoolPagesInitialCharge = Size;

    if (MiExpansionPoolPagesInitialCharge > MmNumberOfPhysicalPages / 6) {
        MiExpansionPoolPagesInitialCharge = MmNumberOfPhysicalPages / 6;
    }

    if (MiExpansionPoolPagesInitialCharge > (256 * 1024 * 1024) / PAGE_SIZE) {
        MiExpansionPoolPagesInitialCharge = (256 * 1024 * 1024) / PAGE_SIZE;
    }

    MiInitializeSystemPtes (PointerPte, Size, NonPagedPoolExpansion);

    //
    // A guard PTE is built at the top by our caller.  This allows us to
    // freely increment virtual addresses in MiFreePoolPages and just check
    // for a blank PTE.
    //
}

VOID
MiAddExpansionNonPagedPool (
    IN PFN_NUMBER PageFrameIndex,
    IN PFN_NUMBER NumberOfPages,
    IN LOGICAL PfnHeld
    )
{
    KIRQL OldIrql;
    PFN_NUMBER i;
    PFN_NUMBER PageTablePage;
    PMMPFN Pfn1;
    PMMPFN PfnList;
    PMMPTE PointerPte;
    ULONG Color;

    Pfn1 = MI_PFN_ELEMENT (PageFrameIndex);
    PointerPte = MiGetPteAddress (MmNonPagedPoolExpansionStart);
    PageTablePage = MI_GET_PAGE_FRAME_FROM_PTE (MiGetPteAddress(PointerPte));

    SATISFY_OVERZEALOUS_COMPILER (OldIrql = MM_NOIRQL);

    if (PfnHeld == FALSE) {
        LOCK_PFN (OldIrql);
    }

    PfnList = MiCachedNonPagedPool;

    for (i = 0; i < NumberOfPages; i += 1) {

        //
        // Initialize the frames properly.
        //

        Color = Pfn1->u3.e1.PageColor;
        Pfn1->u3.e2.ShortFlags = 0;
        Pfn1->u3.e1.PageColor = (UCHAR) Color;

        Pfn1->u3.e2.ReferenceCount = 1;
        Pfn1->u2.ShareCount = 1;
        Pfn1->PteAddress = PointerPte;
        Pfn1->OriginalPte.u.Long = MM_DEMAND_ZERO_WRITE_PTE;
        Pfn1->u4.EntireFrame = 0;
        Pfn1->u4.MustBeCached = 1;
        Pfn1->u4.PteFrame = PageTablePage;

        Pfn1->u3.e1.PageLocation = ActiveAndValid;
        Pfn1->u3.e1.CacheAttribute = MiCached;

        ASSERT (Pfn1->u3.e1.LargeSessionAllocation == 0);
        ASSERT (Pfn1->u4.VerifierAllocation == 0);

        Pfn1->u1.Event = (PKEVENT) PfnList;
        PfnList = Pfn1;
        Pfn1 += 1;
    }

    MiCachedNonPagedPool = PfnList;
    MiCachedNonPagedPoolCount += NumberOfPages;

    if (PfnHeld == FALSE) {
        UNLOCK_PFN2 (OldIrql);
    }

    return;
}

VOID
MiCheckSessionPoolAllocations (
    VOID
    )

/*++

Routine Description:

    Ensure that the current session has no pool allocations since it is about
    to exit.  All session allocations must be freed prior to session exit.

Arguments:

    None.

Return Value:

    None.

Environment:

    Kernel mode.

--*/

{
    SIZE_T i;
    ULONG PagedAllocations;
    ULONG NonPagedAllocations;
    SIZE_T PagedBytes;
    SIZE_T NonPagedBytes;
    PMMPTE StartPde;
    PMMPTE EndPde;
    PMMPTE PointerPte;
    MMPTE TempPte;
    PVOID VirtualAddress;
    PPOOL_TRACKER_TABLE TrackTable;
    PPOOL_TRACKER_TABLE TrackTableBase;
    SIZE_T NumberOfEntries;

    PAGED_CODE();

    TrackTableBase = MiSessionPoolTrackTable ();
    NumberOfEntries = MiSessionPoolTrackTableSize ();

    //
    // Note the session pool descriptor TotalPages field is not reliable
    // for leak checking because of the fact that nonpaged session allocations
    // are converted to global session allocations - thus when a small nonpaged
    // session allocation results in splitting a full page, the global
    // nonpaged pool descriptor (not the session pool descriptor) is (and must
    // be because of the remaining fragment) charged.
    //

    //
    // Make sure all the pool tracking entries are zeroed out.
    //

    PagedAllocations = 0;
    NonPagedAllocations = 0;
    PagedBytes = 0;
    NonPagedBytes = 0;

    TrackTable = TrackTableBase;

    for (i = 0; i < NumberOfEntries; i += 1) {

        PagedBytes += TrackTable->PagedBytes;
        NonPagedBytes += TrackTable->NonPagedBytes;

        PagedAllocations += (TrackTable->PagedAllocs - TrackTable->PagedFrees);
        NonPagedAllocations += (TrackTable->NonPagedAllocs - TrackTable->NonPagedFrees);

        TrackTable += 1;
    }

    if (PagedBytes != 0) {

        //
        // All page tables for this session's paged pool must be freed by now.
        // Being here means they aren't - this is fatal.  Force in any valid
        // pages so that a debugger can show who the guilty party is.
        //

        StartPde = MiGetPdeAddress (MmSessionSpace->PagedPoolStart);
        EndPde = MiGetPdeAddress (MmSessionSpace->PagedPoolEnd);

        while (StartPde <= EndPde) {

            if (StartPde->u.Long != 0) {

                //
                // Hunt through the page table page for valid pages and force
                // them in.  Note this also forces in the page table page if
                // it is not already.
                //

                PointerPte = MiGetVirtualAddressMappedByPte (StartPde);

                for (i = 0; i < PTE_PER_PAGE; i += 1) {
                    TempPte = *PointerPte;

                    if ((TempPte.u.Hard.Valid == 0) &&
                        (TempPte.u.Soft.Protection != 0) &&
                        (TempPte.u.Soft.Protection != MM_NOACCESS)) {

                        VirtualAddress = MiGetVirtualAddressMappedByPte (PointerPte);
                        *(volatile UCHAR *)VirtualAddress = *(volatile UCHAR *)VirtualAddress;

                    }
                    PointerPte += 1;
                }

            }

            StartPde += 1;
        }
    }

    if ((NonPagedBytes != 0) || (PagedBytes != 0)) {

        KeBugCheckEx (SESSION_HAS_VALID_POOL_ON_EXIT,
                      (ULONG_PTR)MmSessionSpace->SessionId,
                      PagedBytes,
                      NonPagedBytes,
#if defined (_WIN64)
                      (((ULONG_PTR) NonPagedAllocations) << 32) | (PagedAllocations)
#else
                      (NonPagedAllocations << 16) | (PagedAllocations)
#endif
                    );
    }

#if DBG

    TrackTable = TrackTableBase;

    for (i = 0; i < NumberOfEntries; i += 1) {

        ASSERT (TrackTable->NonPagedBytes == 0);
        ASSERT (TrackTable->PagedBytes == 0);
        ASSERT (TrackTable->NonPagedAllocs == TrackTable->NonPagedFrees);
        ASSERT (TrackTable->PagedAllocs == TrackTable->PagedFrees);

        if (TrackTable->Key == 0) {
            ASSERT (TrackTable->NonPagedAllocs == 0);
            ASSERT (TrackTable->PagedAllocs == 0);
        }

        TrackTable += 1;
    }

    ASSERT (MmSessionSpace->PagedPool.TotalPages == 0);
    ASSERT (MmSessionSpace->PagedPool.TotalBigPages == 0);
    ASSERT (MmSessionSpace->PagedPool.RunningAllocs ==
            MmSessionSpace->PagedPool.RunningDeAllocs);
#endif
}

NTSTATUS
MiInitializeAndChargePfn (
    OUT PPFN_NUMBER PageFrameIndex,
    IN PMMPTE PointerPde,
    IN PFN_NUMBER ContainingPageFrame,
    IN LOGICAL SessionAllocation
    )

/*++

Routine Description:

    Nonpaged wrapper to allocate, initialize and charge for a new page.

Arguments:

    PageFrameIndex - Returns the page frame number which was initialized.

    PointerPde - Supplies the pointer to the PDE to initialize.

    ContainingPageFrame - Supplies the page frame number of the page
                          directory page which contains this PDE.

    SessionAllocation - Supplies TRUE if this allocation is in session space,
                        FALSE otherwise.

Return Value:

    Status of the page initialization.

--*/

{
    MMPTE TempPte;
    KIRQL OldIrql;

    if (SessionAllocation == TRUE) {
        TempPte = ValidKernelPdeLocal;
    }
    else {
        TempPte = ValidKernelPde;
    }

    LOCK_PFN2 (OldIrql);

    if ((MmAvailablePages < MM_MEDIUM_LIMIT) ||
        (MI_NONPAGEABLE_MEMORY_AVAILABLE() <= 1)) {

        UNLOCK_PFN2 (OldIrql);
        return STATUS_NO_MEMORY;
    }

    //
    // Ensure no other thread handled this while this one waited.  If one has,
    // then return STATUS_RETRY so the caller knows to try again.
    //

    if (PointerPde->u.Hard.Valid == 1) {
        UNLOCK_PFN2 (OldIrql);
        return STATUS_RETRY;
    }

    MI_DECREMENT_RESIDENT_AVAILABLE (1, MM_RESAVAIL_ALLOCATE_SINGLE_PFN);

    //
    // Allocate and map in the page at the requested address.
    //

    *PageFrameIndex = MiRemoveZeroPage (MI_GET_PAGE_COLOR_FROM_PTE (PointerPde));
    TempPte.u.Hard.PageFrameNumber = *PageFrameIndex;
    MI_WRITE_VALID_PTE (PointerPde, TempPte);

    MiInitializePfnForOtherProcess (*PageFrameIndex,
                                    PointerPde,
                                    ContainingPageFrame);

    //
    // This page will be locked into working set and assigned an index when
    // the working set is set up on return.
    //

    ASSERT (MI_PFN_ELEMENT(*PageFrameIndex)->u1.WsIndex == 0);

    UNLOCK_PFN2 (OldIrql);

    return STATUS_SUCCESS;
}


VOID
MiSessionPageTableRelease (
    IN PFN_NUMBER PageFrameIndex
    )

/*++

Routine Description:

    Nonpaged wrapper to release a session pool page table page.

Arguments:

    PageFrameIndex - Returns the page frame number which was initialized.

Return Value:

    None.

--*/

{
    KIRQL OldIrql;
    PMMPFN Pfn1;
    PMMPFN Pfn2;

    Pfn1 = MI_PFN_ELEMENT (PageFrameIndex);

    Pfn2 = MI_PFN_ELEMENT (Pfn1->u4.PteFrame);

    MI_SET_PFN_DELETED (Pfn1);

    LOCK_PFN (OldIrql);

    ASSERT (MmSessionSpace->SessionPageDirectoryIndex == Pfn1->u4.PteFrame);
    ASSERT (Pfn1->u2.ShareCount == 1);

    MiDecrementShareCount (Pfn2, Pfn1->u4.PteFrame);

    MiDecrementShareCount (Pfn1, PageFrameIndex);

    UNLOCK_PFN (OldIrql);

    MI_INCREMENT_RESIDENT_AVAILABLE (1, MM_RESAVAIL_FREE_SESSION_PAGE_TABLE);
}


NTSTATUS
MiInitializeSessionPool (
    VOID
    )

/*++

Routine Description:

    Initialize the current session's pool structure.

Arguments:

    None.

Return Value:

    Status of the pool initialization.

Environment:

    Kernel mode.

--*/

{
    PMMPTE PointerPde, PointerPte;
    PFN_NUMBER PageFrameIndex;
    PPOOL_DESCRIPTOR PoolDescriptor;
    PMM_SESSION_SPACE SessionGlobal;
    PMM_PAGED_POOL_INFO PagedPoolInfo;
    NTSTATUS Status;
#if (_MI_PAGING_LEVELS < 3)
    ULONG Index;
#endif
#if DBG
    PMMPTE StartPde;
    PMMPTE EndPde;
#endif

    PAGED_CODE ();

    SessionGlobal = SESSION_GLOBAL(MmSessionSpace);

    KeInitializeGuardedMutex (&SessionGlobal->PagedPoolMutex);

    PoolDescriptor = &MmSessionSpace->PagedPool;

    ExInitializePoolDescriptor (PoolDescriptor,
                                PagedPoolSession,
                                0,
                                0,
                                &SessionGlobal->PagedPoolMutex);

    MmSessionSpace->PagedPoolStart = (PVOID)MiSessionPoolStart;
    MmSessionSpace->PagedPoolEnd = (PVOID)(MiSessionPoolEnd -1);

    PagedPoolInfo = &MmSessionSpace->PagedPoolInfo;
    PagedPoolInfo->PagedPoolCommit = 0;
    PagedPoolInfo->PagedPoolHint = 0;
    PagedPoolInfo->AllocatedPagedPool = 0;

    //
    // Build the page table page for paged pool.
    //

    PointerPde = MiGetPdeAddress (MmSessionSpace->PagedPoolStart);
    MmSessionSpace->PagedPoolBasePde = PointerPde;

    PointerPte = MiGetPteAddress (MmSessionSpace->PagedPoolStart);

    PagedPoolInfo->FirstPteForPagedPool = PointerPte;
    PagedPoolInfo->LastPteForPagedPool = MiGetPteAddress (MmSessionSpace->PagedPoolEnd);

#if DBG
    //
    // Session pool better be unused.
    //

    StartPde = MiGetPdeAddress (MmSessionSpace->PagedPoolStart);
    EndPde = MiGetPdeAddress (MmSessionSpace->PagedPoolEnd);

    while (StartPde <= EndPde) {
        ASSERT (StartPde->u.Long == 0);
        StartPde += 1;
    }
#endif

    //
    // Mark all PDEs as empty.
    //

    MiZeroMemoryPte (PointerPde,
                     (1 + MiGetPdeAddress (MmSessionSpace->PagedPoolEnd) - PointerPde));

    if (MiChargeCommitment (1, NULL) == FALSE) {
        MM_BUMP_SESSION_FAILURES (MM_SESSION_FAILURE_NO_COMMIT);
        return STATUS_NO_MEMORY;
    }

    Status = MiInitializeAndChargePfn (&PageFrameIndex,
                                       PointerPde,
                                       MmSessionSpace->SessionPageDirectoryIndex,
                                       TRUE);

    if (!NT_SUCCESS(Status)) {
        MiReturnCommitment (1);
        MM_BUMP_SESSION_FAILURES (MM_SESSION_FAILURE_NO_RESIDENT);
        return Status;
    }

    MM_TRACK_COMMIT (MM_DBG_COMMIT_SESSION_POOL_PAGE_TABLES, 1);

    MM_BUMP_SESS_COUNTER(MM_DBG_SESSION_PAGEDPOOL_PAGETABLE_ALLOC, 1);

#if (_MI_PAGING_LEVELS < 3)

    Index = MiGetPdeSessionIndex (MmSessionSpace->PagedPoolStart);

    ASSERT (MmSessionSpace->PageTables[Index].u.Long == 0);
    MmSessionSpace->PageTables[Index] = *PointerPde;

#endif

    MM_BUMP_SESS_COUNTER (MM_DBG_SESSION_NP_POOL_CREATE, 1);

    InterlockedIncrementSizeT (&MmSessionSpace->NonPageablePages);

    InterlockedIncrementSizeT (&MmSessionSpace->CommittedPages);

    PagedPoolInfo->NextPdeForPagedPoolExpansion = PointerPde + 1;

    //
    // Initialize the bitmaps.
    //

    MiCreateBitMap (&PagedPoolInfo->PagedPoolAllocationMap,
                    MmSessionPoolSize >> PAGE_SHIFT,
                    NonPagedPool);

    if (PagedPoolInfo->PagedPoolAllocationMap == NULL) {
        MM_BUMP_SESSION_FAILURES (MM_SESSION_FAILURE_NO_NONPAGED_POOL);
        goto Failure;
    }

    //
    // We start with all pages in the virtual address space as "busy", and
    // clear bits to make pages available as we dynamically expand the pool.
    //

    RtlSetAllBits( PagedPoolInfo->PagedPoolAllocationMap );

    //
    // Indicate first page worth of PTEs are available.
    //

    RtlClearBits (PagedPoolInfo->PagedPoolAllocationMap, 0, PTE_PER_PAGE);

    //
    // Create the end of allocation range bitmap.
    //

    MiCreateBitMap (&PagedPoolInfo->EndOfPagedPoolBitmap,
                    MmSessionPoolSize >> PAGE_SHIFT,
                    NonPagedPool);

    if (PagedPoolInfo->EndOfPagedPoolBitmap == NULL) {
        MM_BUMP_SESSION_FAILURES (MM_SESSION_FAILURE_NO_NONPAGED_POOL);
        goto Failure;
    }

    RtlClearAllBits (PagedPoolInfo->EndOfPagedPoolBitmap);

    return STATUS_SUCCESS;

Failure:

    MiFreeSessionPoolBitMaps ();

    MiSessionPageTableRelease (PageFrameIndex);

    MI_WRITE_ZERO_PTE (PointerPde);

    MI_FLUSH_SINGLE_TB (MiGetVirtualAddressMappedByPte (PointerPde), TRUE);

    MM_BUMP_SESS_COUNTER (MM_DBG_SESSION_NP_POOL_CREATE_FAILED, 1);

    InterlockedDecrementSizeT (&MmSessionSpace->NonPageablePages);

    InterlockedDecrementSizeT (&MmSessionSpace->CommittedPages);

    MM_BUMP_SESS_COUNTER(MM_DBG_SESSION_PAGEDPOOL_PAGETABLE_FREE_FAIL1, 1);

    MiReturnCommitment (1);

    MM_TRACK_COMMIT_REDUCTION (MM_DBG_COMMIT_SESSION_POOL_PAGE_TABLES, 1);

    return STATUS_NO_MEMORY;
}


VOID
MiFreeSessionPoolBitMaps (
    VOID
    )

/*++

Routine Description:

    Free the current session's pool bitmap structures.

Arguments:

    None.

Return Value:

    None.

Environment:

    Kernel mode.

--*/

{
    PAGED_CODE();

    if (MmSessionSpace->PagedPoolInfo.PagedPoolAllocationMap ) {
        ExFreePool (MmSessionSpace->PagedPoolInfo.PagedPoolAllocationMap);
        MmSessionSpace->PagedPoolInfo.PagedPoolAllocationMap = NULL;
    }

    if (MmSessionSpace->PagedPoolInfo.EndOfPagedPoolBitmap ) {
        ExFreePool (MmSessionSpace->PagedPoolInfo.EndOfPagedPoolBitmap);
        MmSessionSpace->PagedPoolInfo.EndOfPagedPoolBitmap = NULL;
    }

    return;
}

#if DBG

#define MI_LOG_CONTIGUOUS  100

typedef struct _MI_CONTIGUOUS_ALLOCATORS {
    PVOID BaseAddress;
    SIZE_T NumberOfBytes;
    PVOID CallingAddress;
} MI_CONTIGUOUS_ALLOCATORS, *PMI_CONTIGUOUS_ALLOCATORS;

ULONG MiContiguousIndex;
MI_CONTIGUOUS_ALLOCATORS MiContiguousAllocators[MI_LOG_CONTIGUOUS];

VOID
MiInsertContiguousTag (
    IN PVOID BaseAddress,
    IN SIZE_T NumberOfBytes,
    IN PVOID CallingAddress
    )
{
    KIRQL OldIrql;

#if !DBG
    if ((NtGlobalFlag & FLG_POOL_ENABLE_TAGGING) == 0) {
        return;
    }
#endif

    OldIrql = KeAcquireQueuedSpinLock (LockQueueMmNonPagedPoolLock);

    if (MiContiguousIndex >= MI_LOG_CONTIGUOUS) {
        MiContiguousIndex = 0;
    }

    MiContiguousAllocators[MiContiguousIndex].BaseAddress = BaseAddress;
    MiContiguousAllocators[MiContiguousIndex].NumberOfBytes = NumberOfBytes;
    MiContiguousAllocators[MiContiguousIndex].CallingAddress = CallingAddress;

    MiContiguousIndex += 1;

    KeReleaseQueuedSpinLock (LockQueueMmNonPagedPoolLock, OldIrql);
}
#else
#define MiInsertContiguousTag(a, b, c) (c) = (c)
#endif


PVOID
MiFindContiguousMemoryInPool (
    IN PFN_NUMBER LowestPfn,
    IN PFN_NUMBER HighestPfn,
    IN PFN_NUMBER BoundaryPfn,
    IN PFN_NUMBER SizeInPages,
    IN PVOID CallingAddress
    )

/*++

Routine Description:

    This function searches nonpaged pool for contiguous pages to satisfy the
    request.  Note the pool address returned maps these pages as MmCached.

Arguments:

    LowestPfn - Supplies the lowest acceptable physical page number.

    HighestPfn - Supplies the highest acceptable physical page number.

    BoundaryPfn - Supplies the page frame number multiple the allocation must
                  not cross.  0 indicates it can cross any boundary.

    SizeInPages - Supplies the number of pages to allocate.

    CallingAddress - Supplies the calling address of the allocator.

Return Value:

    NULL - a contiguous range could not be found to satisfy the request.

    NON-NULL - Returns a pointer (virtual address in the nonpaged portion
               of the system) to the allocated physically contiguous
               memory.

Environment:

    Kernel mode, IRQL of APC_LEVEL or below.

--*/
{
    PMMPTE PointerPte;
    PMMPFN Pfn1;
    PVOID BaseAddress;
    PVOID BaseAddress2;
    KIRQL OldIrql;
    PMMFREE_POOL_ENTRY FreePageInfo;
    PLIST_ENTRY Entry;
    ULONG Index;
    PFN_NUMBER BoundaryMask;
    ULONG AllocationPosition;
    PVOID Va;
    PFN_NUMBER SpanInPages;
    PFN_NUMBER SpanInPages2;
    PFN_NUMBER FreePoolInPages;

    PAGED_CODE ();

    //
    // Initializing SpanInPages* is not needed for correctness
    // but without it the compiler cannot compile this code
    // W4 to check for use of uninitialized variables.
    //

    SpanInPages = 0;
    SpanInPages2 = 0;

    BaseAddress = NULL;

    BoundaryMask = ~(BoundaryPfn - 1);

    //
    // A suitable pool page was not allocated via the pool allocator.
    // Grab the pool lock and manually search for a page which meets
    // the requirements.
    //

    MmLockPageableSectionByHandle (ExPageLockHandle);

    //
    // Trace through the page allocator's pool headers for a page which
    // meets the requirements.
    //
    // NonPaged pool is linked together through the pages themselves.
    //

    Index = (ULONG)(SizeInPages - 1);

    if (Index >= MI_MAX_FREE_LIST_HEADS) {
        Index = MI_MAX_FREE_LIST_HEADS - 1;
    }

    OldIrql = KeAcquireQueuedSpinLock (LockQueueMmNonPagedPoolLock);

    while (Index < MI_MAX_FREE_LIST_HEADS) {

        Entry = MmNonPagedPoolFreeListHead[Index].Flink;
    
        while (Entry != &MmNonPagedPoolFreeListHead[Index]) {
    
            if (MmProtectFreedNonPagedPool == TRUE) {
                MiUnProtectFreeNonPagedPool ((PVOID)Entry, 0);
            }
    
            //
            // The list is not empty, see if this one meets the physical
            // requirements.
            //
    
            FreePageInfo = CONTAINING_RECORD(Entry,
                                             MMFREE_POOL_ENTRY,
                                             List);
    
            ASSERT (FreePageInfo->Signature == MM_FREE_POOL_SIGNATURE);
            if (FreePageInfo->Size >= SizeInPages) {
    
                //
                // This entry has sufficient space, check to see if the
                // pages meet the physical requirements.
                //
    
                Va = MiCheckForContiguousMemory (PAGE_ALIGN(Entry),
                                                 FreePageInfo->Size,
                                                 SizeInPages,
                                                 LowestPfn,
                                                 HighestPfn,
                                                 BoundaryPfn,
                                                 MiCached);
     
                if (Va != NULL) {

                    //
                    // These pages meet the requirements.  The returned
                    // address may butt up on the end, the front or be
                    // somewhere in the middle.  Split the Entry based
                    // on which case it is.
                    //

                    Entry = PAGE_ALIGN(Entry);
                    if (MmProtectFreedNonPagedPool == FALSE) {
                        RemoveEntryList (&FreePageInfo->List);
                    }
                    else {
                        MiProtectedPoolRemoveEntryList (&FreePageInfo->List);
                    }
    
                    //
                    // Adjust the number of free pages remaining in the pool.
                    // The TotalBigPages calculation appears incorrect for the
                    // case where we're splitting a block, but it's done this
                    // way because ExFreePool corrects it when we free the
                    // fragment block below.  Likewise for
                    // MmAllocatedNonPagedPool and MmNumberOfFreeNonPagedPool
                    // which is corrected by MiFreePoolPages for the fragment.
                    //
    
                    InterlockedExchangeAdd ((PLONG)&NonPagedPoolDescriptor.TotalBigPages,
                                            (LONG)FreePageInfo->Size);

                    InterlockedExchangeAddSizeT (&NonPagedPoolDescriptor.TotalBytes,
                                             FreePageInfo->Size << PAGE_SHIFT);

                    MmAllocatedNonPagedPool += FreePageInfo->Size;

                    FreePoolInPages = MmMaximumNonPagedPoolInPages - MmAllocatedNonPagedPool;

                    if (FreePoolInPages < MiHighNonPagedPoolThreshold) {

                        //
                        // Read the state directly instead of calling
                        // KeReadStateEvent since we are holding the nonpaged
                        // pool lock and want to keep instructions at a
                        // minimum.
                        //

                        if (MiHighNonPagedPoolEvent->Header.SignalState != 0) {
                            KeClearEvent (MiHighNonPagedPoolEvent);
                        }
                        if (FreePoolInPages <= MiLowNonPagedPoolThreshold) {
                            if (MiLowNonPagedPoolEvent->Header.SignalState == 0) {
                                KeSetEvent (MiLowNonPagedPoolEvent, 0, FALSE);
                            }
                        }
                    }

                    MmNumberOfFreeNonPagedPool -= FreePageInfo->Size;
    
                    ASSERT ((LONG)MmNumberOfFreeNonPagedPool >= 0);
    
                    if (Va == Entry) {

                        //
                        // Butted against the front.
                        //

                        AllocationPosition = 0;
                    }
                    else if (((PCHAR)Va + (SizeInPages << PAGE_SHIFT)) == ((PCHAR)Entry + (FreePageInfo->Size << PAGE_SHIFT))) {

                        //
                        // Butted against the end.
                        //

                        AllocationPosition = 2;
                    }
                    else {

                        //
                        // Somewhere in the middle.
                        //

                        AllocationPosition = 1;
                    }

                    //
                    // Pages are being removed from the front of
                    // the list entry and the whole list entry
                    // will be removed and then the remainder inserted.
                    //
    
                    //
                    // Mark start and end for the block at the top of the
                    // list.
                    //
    
                    if (MI_IS_PHYSICAL_ADDRESS(Va)) {
    
                        //
                        // On certain architectures, virtual addresses
                        // may be physical and hence have no corresponding PTE.
                        //
    
                        PointerPte = NULL;
                        Pfn1 = MI_PFN_ELEMENT (MI_CONVERT_PHYSICAL_TO_PFN (Va));
                    }
                    else {
                        PointerPte = MiGetPteAddress(Va);
                        ASSERT (PointerPte->u.Hard.Valid == 1);
                        Pfn1 = MI_PFN_ELEMENT (PointerPte->u.Hard.PageFrameNumber);
                    }
    
                    ASSERT (Pfn1->u4.VerifierAllocation == 0);
                    ASSERT (Pfn1->u3.e1.LargeSessionAllocation == 0);
                    ASSERT (Pfn1->u3.e1.StartOfAllocation == 0);
                    Pfn1->u3.e1.StartOfAllocation = 1;
    
                    //
                    // Calculate the ending PFN address, note that since
                    // these pages are contiguous, just add to the PFN.
                    //
    
                    Pfn1 += SizeInPages - 1;
                    ASSERT (Pfn1->u4.VerifierAllocation == 0);
                    ASSERT (Pfn1->u3.e1.LargeSessionAllocation == 0);
                    ASSERT (Pfn1->u3.e1.EndOfAllocation == 0);
                    Pfn1->u3.e1.EndOfAllocation = 1;
    
                    if (SizeInPages == FreePageInfo->Size) {
    
                        //
                        // Unlock the pool and return.
                        //

                        KeReleaseQueuedSpinLock (LockQueueMmNonPagedPoolLock,
                                                 OldIrql);

                        BaseAddress = (PVOID)Va;
                        goto Done;
                    }
    
                    BaseAddress = NULL;

                    if (AllocationPosition != 2) {

                        //
                        // The end piece needs to be freed as the removal
                        // came from the front or the middle.
                        //

                        BaseAddress = (PVOID)((PCHAR)Va + (SizeInPages << PAGE_SHIFT));
                        SpanInPages = FreePageInfo->Size - SizeInPages -
                            (((ULONG_PTR)Va - (ULONG_PTR)Entry) >> PAGE_SHIFT);
    
                        //
                        // Mark start and end of the allocation in the PFN database.
                        //
        
                        if (PointerPte == NULL) {
        
                            //
                            // On certain architectures, virtual addresses
                            // may be physical and hence have no corresponding PTE.
                            //
        
                            Pfn1 = MI_PFN_ELEMENT (MI_CONVERT_PHYSICAL_TO_PFN (BaseAddress));
                        }
                        else {
                            PointerPte = MiGetPteAddress(BaseAddress);
                            ASSERT (PointerPte->u.Hard.Valid == 1);
                            Pfn1 = MI_PFN_ELEMENT (PointerPte->u.Hard.PageFrameNumber);
                        }
        
                        ASSERT (Pfn1->u4.VerifierAllocation == 0);
                        ASSERT (Pfn1->u3.e1.LargeSessionAllocation == 0);
                        ASSERT (Pfn1->u3.e1.StartOfAllocation == 0);
                        Pfn1->u3.e1.StartOfAllocation = 1;
        
                        //
                        // Calculate the ending PTE's address, can't depend on
                        // these pages being physically contiguous.
                        //
        
                        if (PointerPte == NULL) {
                            Pfn1 += (SpanInPages - 1);
                        }
                        else {
                            PointerPte += (SpanInPages - 1);
                            ASSERT (PointerPte->u.Hard.Valid == 1);
                            Pfn1 = MI_PFN_ELEMENT (PointerPte->u.Hard.PageFrameNumber);
                        }
                        ASSERT (Pfn1->u3.e1.EndOfAllocation == 0);
                        Pfn1->u3.e1.EndOfAllocation = 1;
        
                        ASSERT (((ULONG_PTR)BaseAddress & (PAGE_SIZE -1)) == 0);
        
                        SpanInPages2 = SpanInPages;
                    }
        
                    BaseAddress2 = BaseAddress;
                    BaseAddress = NULL;

                    if (AllocationPosition != 0) {

                        //
                        // The front piece needs to be freed as the removal
                        // came from the middle or the end.
                        //

                        BaseAddress = (PVOID)Entry;

                        SpanInPages = ((ULONG_PTR)Va - (ULONG_PTR)Entry) >> PAGE_SHIFT;
    
                        //
                        // Mark start and end of the allocation in the PFN database.
                        //
        
                        if (PointerPte == NULL) {
        
                            //
                            // On certain architectures, virtual addresses
                            // may be physical and hence have no corresponding PTE.
                            //
        
                            Pfn1 = MI_PFN_ELEMENT (MI_CONVERT_PHYSICAL_TO_PFN (BaseAddress));
                        }
                        else {
                            PointerPte = MiGetPteAddress(BaseAddress);
                            ASSERT (PointerPte->u.Hard.Valid == 1);
                            Pfn1 = MI_PFN_ELEMENT (PointerPte->u.Hard.PageFrameNumber);
                        }
        
                        ASSERT (Pfn1->u4.VerifierAllocation == 0);
                        ASSERT (Pfn1->u3.e1.LargeSessionAllocation == 0);
                        ASSERT (Pfn1->u3.e1.StartOfAllocation == 0);
                        Pfn1->u3.e1.StartOfAllocation = 1;
        
                        //
                        // Calculate the ending PTE's address, can't depend on
                        // these pages being physically contiguous.
                        //
        
                        if (PointerPte == NULL) {
                            Pfn1 += (SpanInPages - 1);
                        }
                        else {
                            PointerPte += (SpanInPages - 1);
                            ASSERT (PointerPte->u.Hard.Valid == 1);
                            Pfn1 = MI_PFN_ELEMENT (PointerPte->u.Hard.PageFrameNumber);
                        }
                        ASSERT (Pfn1->u3.e1.EndOfAllocation == 0);
                        Pfn1->u3.e1.EndOfAllocation = 1;
        
                        ASSERT (((ULONG_PTR)BaseAddress & (PAGE_SIZE -1)) == 0);
                    }
        
                    //
                    // Unlock the pool.
                    //
    
                    KeReleaseQueuedSpinLock (LockQueueMmNonPagedPoolLock,
                                             OldIrql);
    
                    //
                    // Free the split entry at BaseAddress back into the pool.
                    // Note that we have overcharged the pool - the entire free
                    // chunk has been billed.  Here we return the piece we
                    // didn't use and correct the momentary overbilling.
                    //
                    // The start and end allocation bits of this split entry
                    // which we just set up enable ExFreePool and his callees
                    // to correctly adjust the billing.
                    //
    
                    if (BaseAddress) {
                        ExInsertPoolTag ('tnoC',
                                         BaseAddress,
                                         SpanInPages << PAGE_SHIFT,
                                         NonPagedPool);
                        ExFreePool (BaseAddress);
                    }
                    if (BaseAddress2) {
                        ExInsertPoolTag ('tnoC',
                                         BaseAddress2,
                                         SpanInPages2 << PAGE_SHIFT,
                                         NonPagedPool);
                        ExFreePool (BaseAddress2);
                    }
                    BaseAddress = Va;
                    goto Done;
                }
            }
            Entry = FreePageInfo->List.Flink;
            if (MmProtectFreedNonPagedPool == TRUE) {
                MiProtectFreeNonPagedPool ((PVOID)FreePageInfo,
                                           (ULONG)FreePageInfo->Size);
            }
        }
        Index += 1;
    }

    //
    // No entry was found in free nonpaged pool that meets the requirements.
    //

    KeReleaseQueuedSpinLock (LockQueueMmNonPagedPoolLock, OldIrql);

Done:

    MmUnlockPageableImageSection (ExPageLockHandle);

    if (BaseAddress) {

        MiInsertContiguousTag (BaseAddress,
                               SizeInPages << PAGE_SHIFT,
                               CallingAddress);

        ExInsertPoolTag ('tnoC',
                         BaseAddress,
                         SizeInPages << PAGE_SHIFT,
                         NonPagedPool);
    }

    return BaseAddress;
}

PFN_NUMBER
MiFindContiguousPages (
    IN PFN_NUMBER LowestPfn,
    IN PFN_NUMBER HighestPfn,
    IN PFN_NUMBER BoundaryPfn,
    IN PFN_NUMBER SizeInPages,
    IN MEMORY_CACHING_TYPE CacheType
    )

/*++

Routine Description:

    This function searches nonpaged pool and the free, zeroed,
    and standby lists for contiguous pages that satisfy the
    request.

    Note no virtual address space is used (thus nonpaged pool is not scanned).
    A physical frame number (the caller can map it if he wants to) is returned.

Arguments:

    LowestPfn - Supplies the lowest acceptable physical page number.

    HighestPfn - Supplies the highest acceptable physical page number.

    BoundaryPfn - Supplies the page frame number multiple the allocation must
                  not cross.  0 indicates it can cross any boundary.

    SizeInPages - Supplies the number of pages to allocate.

    CacheType - Supplies the type of cache mapping that will be used for the
                memory.

Return Value:

    0 - a contiguous range could not be found to satisfy the request.

    Nonzero - Returns the base physical frame number to the allocated
              physically contiguous memory.

Environment:

    Kernel mode, IRQL of APC_LEVEL or below.

    Note that in addition to being called at normal runtime, this routine
    is also called during Phase 0 initialization before the loaded module
    list has been initialized - therefore this routine cannot be made PAGELK
    as we wouldn't know how to find it to ensure it was resident.

--*/

{
    PMMPTE DummyPte;
    PKTHREAD Thread;
    PMMPFN Pfn1;
    PMMPFN EndPfn;
    KIRQL OldIrql;
    ULONG start;
    PFN_NUMBER count;
    PFN_NUMBER Page;
    PFN_NUMBER LastPage;
    PFN_NUMBER found;
    PFN_NUMBER BoundaryMask;
    PFN_NUMBER PageFrameIndex;
    MI_PFN_CACHE_ATTRIBUTE CacheAttribute;
    ULONG RetryCount;
    LOGICAL FlushedTb;

    PAGED_CODE ();

    ASSERT (SizeInPages != 0);

    CacheAttribute = MI_TRANSLATE_CACHETYPE (CacheType, 0);

    BoundaryMask = ~(BoundaryPfn - 1);

    Pfn1 = NULL;
    DummyPte = MiGetPteAddress (MmNonPagedPoolExpansionStart);

    //
    // Manually search for a page range which meets the requirements.
    //

    Thread = KeGetCurrentThread ();

    KeEnterGuardedRegionThread (Thread);

    MI_LOCK_DYNAMIC_MEMORY_SHARED ();

    //
    // Charge commitment.
    //
    // Then search the PFN database for pages that meet the requirements.
    //

    if (MiChargeCommitmentCantExpand (SizeInPages, FALSE) == FALSE) {
        MI_UNLOCK_DYNAMIC_MEMORY_SHARED ();
        KeLeaveGuardedRegionThread (Thread);
        return 0;
    }

    //
    // Charge resident available pages.
    //

    LOCK_PFN (OldIrql);

    MiDeferredUnlockPages (MI_DEFER_PFN_HELD);

    if ((SPFN_NUMBER)SizeInPages > MI_NONPAGEABLE_MEMORY_AVAILABLE()) {
        UNLOCK_PFN (OldIrql);
        goto Failed;
    }

    //
    // Systems utilizing memory compression may have more
    // pages on the zero, free and standby lists than we
    // want to give out.  Explicitly check MmAvailablePages
    // instead (and recheck whenever the PFN lock is released
    // and reacquired).
    //

    if ((SPFN_NUMBER)SizeInPages > (SPFN_NUMBER)(MmAvailablePages - MM_HIGH_LIMIT)) {
        UNLOCK_PFN (OldIrql);
        goto Failed;
    }

    MI_DECREMENT_RESIDENT_AVAILABLE (SizeInPages, MM_RESAVAIL_ALLOCATE_CONTIGUOUS);

    UNLOCK_PFN (OldIrql);

    RetryCount = 4;

Retry:

    start = 0;
    found = 0;

    do {

        count = MmPhysicalMemoryBlock->Run[start].PageCount;
        Page = MmPhysicalMemoryBlock->Run[start].BasePage;

        //
        // Close the gaps, then examine the range for a fit.
        //

        LastPage = Page + count; 

        if (LastPage - 1 > HighestPfn) {
            LastPage = HighestPfn + 1;
        }
    
        if (Page < LowestPfn) {
            Page = LowestPfn;
        }

        if ((count != 0) && (Page + SizeInPages <= LastPage)) {
    
            //
            // A fit may be possible in this run, check whether the pages
            // are on the right list.
            //

            found = 0;
            Pfn1 = MI_PFN_ELEMENT (Page);

            for ( ; Page < LastPage; Page += 1, Pfn1 += 1) {

                if ((Pfn1->u3.e1.PageLocation <= StandbyPageList) &&
                    (Pfn1->u1.Flink != 0) &&
                    (Pfn1->u2.Blink != 0) &&
                    (Pfn1->u3.e2.ReferenceCount == 0) &&
                    ((CacheAttribute == MiCached) || (Pfn1->u4.MustBeCached == 0))) {

                    //
                    // Before starting a new run, ensure that it
                    // can satisfy the boundary requirements (if any).
                    //
                    
                    if ((found == 0) && (BoundaryPfn != 0)) {
                        if (((Page ^ (Page + SizeInPages - 1)) & BoundaryMask) != 0) {
                            //
                            // This run's physical address does not meet the
                            // requirements.
                            //

                            continue;
                        }
                    }

                    found += 1;

                    if (found == SizeInPages) {

                        //
                        // Lock the PFN database and see if the pages are
                        // still available for us.  Note the invariant
                        // condition (boundary conformance) does not need
                        // to be checked again as it was already checked
                        // above.
                        //

                        Pfn1 -= (found - 1);
                        Page -= (found - 1);

                        LOCK_PFN (OldIrql);

                        do {

                            if ((Pfn1->u3.e1.PageLocation <= StandbyPageList) &&
                                (Pfn1->u1.Flink != 0) &&
                                (Pfn1->u2.Blink != 0) &&
                                (Pfn1->u3.e2.ReferenceCount == 0) &&
                                ((CacheAttribute == MiCached) || (Pfn1->u4.MustBeCached == 0))) {

                                NOTHING;            // Good page
                            }
                            else {
                                break;
                            }

                            found -= 1;

                            if (found == 0) {

                                //
                                // All the pages matched the criteria, keep the
                                // PFN lock, remove them and map them for our
                                // caller.
                                //

                                goto Success;
                            }

                            Pfn1 += 1;
                            Page += 1;

                        } while (TRUE);

                        UNLOCK_PFN (OldIrql);

                        //
                        // Restart the search at the first possible page.
                        //

                        found = 0;
                    }
                }
                else {
                    found = 0;
                }
            }
        }
        start += 1;

    } while (start != MmPhysicalMemoryBlock->NumberOfRuns);

    //
    // The desired physical pages could not be allocated - try harder.
    //

    if (InitializationPhase == 0) {
        MI_INCREMENT_RESIDENT_AVAILABLE (SizeInPages, MM_RESAVAIL_FREE_CONTIGUOUS);

        goto Failed;
    }

    InterlockedIncrement (&MiDelayPageFaults);

    //
    // Attempt to move pages to the standby list.  This is done with
    // gradually increasing aggressiveness so as not to prematurely
    // drain modified writes unless it's truly needed.
    //

    switch (RetryCount) {

        case 4:
            MmEmptyAllWorkingSets ();
            break;

        case 3:
            MiFlushAllPages ();
            KeDelayExecutionThread (KernelMode,
                                    FALSE,
                                    (PLARGE_INTEGER)&MmHalfSecond);
            break;

        case 2:
            MmEmptyAllWorkingSets ();
            MiFlushAllPages ();
            KeDelayExecutionThread (KernelMode,
                                    FALSE,
                                    (PLARGE_INTEGER)&MmOneSecond);
            break;

        case 1:

            //
            // Purge the transition list as transition pages keep
            // page tables from being taken and we are desperate.
            //

            MiPurgeTransitionList ();

            //
            // Empty all the working sets now that the
            // transition list has been purged.  This will put page tables
            // on the modified list.
            //

            MmEmptyAllWorkingSets ();

            //
            // Write out modified pages (including newly trimmed page table
            // pages).
            //

            MiFlushAllPages ();

            //
            // Give the writes a chance to complete so the modified pages
            // can be marked clean and put on the transition list.
            //

            KeDelayExecutionThread (KernelMode,
                                    FALSE,
                                    (PLARGE_INTEGER)&MmOneSecond);

            //
            // Purge the transition list one last time to get the now-clean
            // page table pages out.
            //

            MiPurgeTransitionList ();

            //
            // Finally get any straggling active pages onto the transition
            // lists.
            //

            MmEmptyAllWorkingSets ();
            MiFlushAllPages ();

            break;

        default:
            break;
    }

    InterlockedDecrement (&MiDelayPageFaults);

    if (RetryCount != 0) {
        RetryCount -= 1;
        goto Retry;
    }

Failed:

    MI_UNLOCK_DYNAMIC_MEMORY_SHARED ();
    KeLeaveGuardedRegionThread (Thread);

    MiReturnCommitment (SizeInPages);

    return 0;

Success:

    ASSERT (start != MmPhysicalMemoryBlock->NumberOfRuns);

    //
    // A match has been found, remove these pages
    // and return.  The PFN lock is held.
    //

    //
    // Systems utilizing memory compression may have more
    // pages on the zero, free and standby lists than we
    // want to give out.  Explicitly check MmAvailablePages
    // instead (and recheck whenever the PFN lock is
    // released and reacquired).
    //

    if ((SPFN_NUMBER)SizeInPages > (SPFN_NUMBER)(MmAvailablePages - MM_HIGH_LIMIT)) {
        UNLOCK_PFN (OldIrql);
        MI_INCREMENT_RESIDENT_AVAILABLE (SizeInPages, MM_RESAVAIL_FREE_CONTIGUOUS);
        MiReturnCommitment (SizeInPages);
        goto Failed;
    }

    EndPfn = Pfn1 - SizeInPages + 1;

    FlushedTb = FALSE;

    do {

        if (Pfn1->u3.e1.PageLocation == StandbyPageList) {
            MiUnlinkPageFromList (Pfn1);
            ASSERT (Pfn1->u3.e2.ReferenceCount == 0);
            MiRestoreTransitionPte (Pfn1);
        }
        else {
            MiUnlinkFreeOrZeroedPage (Pfn1);
        }

        Pfn1->u3.e2.ReferenceCount = 1;
        Pfn1->u2.ShareCount = 1;
        Pfn1->OriginalPte.u.Long = MM_DEMAND_ZERO_WRITE_PTE;
        Pfn1->u3.e1.PageLocation = ActiveAndValid;

        //
        // The entire TB must be flushed if we are changing cache
        // attributes.
        //
        // KeFlushSingleTb cannot be used because we don't know
        // what virtual address(es) this physical frame was last mapped at.
        //
        // Note we can skip the flush if we've already done it once in
        // this loop already because the PFN lock is held throughout.
        //

        if ((Pfn1->u3.e1.CacheAttribute != CacheAttribute) && (FlushedTb == FALSE)) {
            PageFrameIndex = Pfn1 - MmPfnDatabase;
            MI_FLUSH_TB_FOR_INDIVIDUAL_ATTRIBUTE_CHANGE (PageFrameIndex,
                                                         CacheAttribute);
            FlushedTb = TRUE;
        }

        Pfn1->u3.e1.CacheAttribute = CacheAttribute;
        Pfn1->u3.e1.StartOfAllocation = 0;
        Pfn1->u3.e1.EndOfAllocation = 0;
        Pfn1->u3.e1.LargeSessionAllocation = 0;
        Pfn1->u3.e1.PrototypePte = 0;
        Pfn1->u4.VerifierAllocation = 0;

        //
        // Initialize PteAddress so an MiIdentifyPfn scan
        // won't crash.  The real value is put in after the loop.
        //

        Pfn1->PteAddress = DummyPte;

        if (Pfn1 == EndPfn) {
            break;
        }

        Pfn1 -= 1;

    } while (TRUE);

    Pfn1->u3.e1.StartOfAllocation = 1;
    (Pfn1 + SizeInPages - 1)->u3.e1.EndOfAllocation = 1;

    UNLOCK_PFN (OldIrql);

    EndPfn = Pfn1 + SizeInPages;
    ASSERT (EndPfn == MI_PFN_ELEMENT (Page + 1));

    Page = Page - SizeInPages + 1;
    ASSERT (Pfn1 == MI_PFN_ELEMENT (Page));
    ASSERT (Page != 0);

    MM_TRACK_COMMIT (MM_DBG_COMMIT_CONTIGUOUS_PAGES, SizeInPages);

    MI_UNLOCK_DYNAMIC_MEMORY_SHARED ();
    KeLeaveGuardedRegionThread (Thread);

    return Page;
}


VOID
MiFreeContiguousPages (
    IN PFN_NUMBER PageFrameIndex,
    IN PFN_NUMBER SizeInPages
    )

/*++

Routine Description:

    This function frees the specified physical page range, returning both
    commitment and resident available.

Arguments:

    PageFrameIndex - Supplies the starting physical page number.

    SizeInPages - Supplies the number of pages to free.

Return Value:

    None.

Environment:

    Kernel mode, IRQL of APC_LEVEL or below.

    This is callable from MiReloadBootLoadedDrivers->MiUseDriverLargePages
    during Phase 0.  ExPageLockHandle and other variables won't exist at
    this point, so don't get too fancy here.

--*/

{
    KIRQL OldIrql;
    PMMPFN Pfn1;
    PMMPFN EndPfn;

    ASSERT (KeGetCurrentIrql () <= APC_LEVEL);

    Pfn1 = MI_PFN_ELEMENT (PageFrameIndex);
    EndPfn = Pfn1 + SizeInPages;

    LOCK_PFN2 (OldIrql);

    Pfn1->u3.e1.StartOfAllocation = 0;
    (EndPfn - 1)->u3.e1.EndOfAllocation = 0;

    do {
        MI_SET_PFN_DELETED (Pfn1);
        MiDecrementShareCount (Pfn1, PageFrameIndex);
        PageFrameIndex += 1;
        Pfn1 += 1;
    } while (Pfn1 < EndPfn);

    UNLOCK_PFN2 (OldIrql);

    MI_INCREMENT_RESIDENT_AVAILABLE (SizeInPages, MM_RESAVAIL_FREE_CONTIGUOUS);

    MiReturnCommitment (SizeInPages);

    return;
}


PVOID
MiFindContiguousMemory (
    IN PFN_NUMBER LowestPfn,
    IN PFN_NUMBER HighestPfn,
    IN PFN_NUMBER BoundaryPfn,
    IN PFN_NUMBER SizeInPages,
    IN MEMORY_CACHING_TYPE CacheType,
    IN PVOID CallingAddress
    )

/*++

Routine Description:

    This function searches nonpaged pool and the free, zeroed,
    and standby lists for contiguous pages that satisfy the
    request.

Arguments:

    LowestPfn - Supplies the lowest acceptable physical page number.

    HighestPfn - Supplies the highest acceptable physical page number.

    BoundaryPfn - Supplies the page frame number multiple the allocation must
                  not cross.  0 indicates it can cross any boundary.

    SizeInPages - Supplies the number of pages to allocate.

    CacheType - Supplies the type of cache mapping that will be used for the
                memory.

    CallingAddress - Supplies the calling address of the allocator.

Return Value:

    NULL - a contiguous range could not be found to satisfy the request.

    NON-NULL - Returns a pointer (virtual address in the nonpaged portion
               of the system) to the allocated physically contiguous
               memory.

Environment:

    Kernel mode, IRQL of APC_LEVEL or below.

--*/
{
    PMMPTE PointerPte;
    PMMPFN Pfn1;
    PMMPFN EndPfn;
    PVOID BaseAddress;
    PFN_NUMBER Page;
    PHYSICAL_ADDRESS PhysicalAddress;
    MI_PFN_CACHE_ATTRIBUTE CacheAttribute;

    PAGED_CODE ();

    ASSERT (SizeInPages != 0);

    CacheAttribute = MI_TRANSLATE_CACHETYPE (CacheType, 0);

    if (CacheAttribute == MiCached) {

        BaseAddress = MiFindContiguousMemoryInPool (LowestPfn,
                                                    HighestPfn,
                                                    BoundaryPfn,
                                                    SizeInPages,
                                                    CallingAddress);
        //
        // An existing range of nonpaged pool satisfies the requirements
        // so return it now.
        //

        if (BaseAddress != NULL) {
            return BaseAddress;
        }
    }

    //
    // Suitable pool was not allocated via the pool allocator.
    // Manually search for a page range which meets the requirements.
    //

    Page = MiFindContiguousPages (LowestPfn,
                                  HighestPfn,
                                  BoundaryPfn,
                                  SizeInPages,
                                  CacheType);

    if (Page == 0) {
        return NULL;
    }

    PhysicalAddress.QuadPart = Page;
    PhysicalAddress.QuadPart = PhysicalAddress.QuadPart << PAGE_SHIFT;

    BaseAddress = MmMapIoSpace (PhysicalAddress,
                                SizeInPages << PAGE_SHIFT,
                                CacheType);

    if (BaseAddress == NULL) {
        MiFreeContiguousPages (Page, SizeInPages);
        return NULL;
    }

    Pfn1 = MI_PFN_ELEMENT (Page);
    EndPfn = Pfn1 + SizeInPages;

    PointerPte = MiGetPteAddress (BaseAddress);
    do {
        Pfn1->PteAddress = PointerPte;
        Pfn1->u4.PteFrame = MI_GET_PAGE_FRAME_FROM_PTE (MiGetPteAddress(PointerPte));
        Pfn1 += 1;
        PointerPte += 1;
    } while (Pfn1 < EndPfn);

    MM_TRACK_COMMIT (MM_DBG_COMMIT_CONTIGUOUS_PAGES, SizeInPages);

    MiInsertContiguousTag (BaseAddress,
                           SizeInPages << PAGE_SHIFT,
                           CallingAddress);

    return BaseAddress;
}


PFN_NUMBER
MiFindLargePageMemory (
    IN PCOLORED_PAGE_INFO ColoredPageInfoBase,
    IN PFN_NUMBER SizeInPages,
    IN MM_PROTECTION_MASK ProtectionMask,
    OUT PPFN_NUMBER OutZeroCount
    )

/*++

Routine Description:

    This function searches the free, zeroed, standby and modified lists
    for contiguous pages to satisfy the request.

    Note the caller must zero the pages on return if these are made visible
    to the user.

Arguments:

    ColoredPageInfoBase - Supplies the colored page info structure to hang
                          allocated pages off of.  This allows the caller to
                          zero only pages that need zeroing, and to easily
                          do those in parallel.

    SizeInPages - Supplies the number of pages to allocate.

    ProtectionMask - Supplies the protection mask the caller is going to use.

    OutZeroCount - Receives the number of pages that need to be zeroed.

Return Value:

    0 - a contiguous range could not be found to satisfy the request.

    NON-0 - Returns the starting page frame number of the allocated physically
            contiguous memory.

Environment:

    Kernel mode, APCs disabled, AddressCreation mutex held.

    The caller must bring in PAGELK.

    The caller has already charged commitment for the range (typically by
    virtue of the VAD insert) so no commit is charged here.

--*/
{
    ULONG Color;
    PKTHREAD Thread;
    ULONG CurrentNodeColor;
    PFN_NUMBER ZeroCount;
    LOGICAL NeedToZero;
    PMMPFN Pfn1;
    PMMPFN EndPfn;
    PMMPFN BoundaryPfn;
    KIRQL OldIrql;
    ULONG start;
    PFN_NUMBER count;
    PFN_NUMBER Page;
    PFN_NUMBER NewPage;
    PFN_NUMBER LastPage;
    PFN_NUMBER found;
    PFN_NUMBER BoundaryMask;
    PCOLORED_PAGE_INFO ColoredPageInfo;
    MI_PFN_CACHE_ATTRIBUTE CacheAttribute;
    MEMORY_CACHING_TYPE CacheType;
    LOGICAL FlushTbNeeded;

    FlushTbNeeded = FALSE;

    PAGED_CODE ();

#ifdef _X86_
    ASSERT (KeFeatureBits & KF_LARGE_PAGE);
#endif

    ASSERT (SizeInPages != 0);

    BoundaryMask = (PFN_NUMBER) ((MM_MINIMUM_VA_FOR_LARGE_PAGE >> PAGE_SHIFT) - 1);

    start = 0;
    found = 0;
    Pfn1 = NULL;
    ZeroCount = 0;

    CacheType = MmCached;
    if (MI_IS_NOCACHE (ProtectionMask)) {
        CacheType = MmNonCached;
    }
    else if (MI_IS_WRITECOMBINE (ProtectionMask)) {
        CacheType = MmWriteCombined;
    }

    CacheAttribute = MI_TRANSLATE_CACHETYPE (CacheType, 0);

    //
    // Charge resident available pages.
    //

    LOCK_PFN (OldIrql);

    MiDeferredUnlockPages (MI_DEFER_PFN_HELD);

    if ((SPFN_NUMBER)SizeInPages > MI_NONPAGEABLE_MEMORY_AVAILABLE()) {
        UNLOCK_PFN (OldIrql);
        return 0;
    }

    //
    // Systems utilizing memory compression may have more
    // pages on the zero, free and standby lists than we
    // want to give out.  Explicitly check MmAvailablePages
    // instead (and recheck whenever the PFN lock is released
    // and reacquired).
    //

    if ((SPFN_NUMBER)SizeInPages > (SPFN_NUMBER)(MmAvailablePages - MM_HIGH_LIMIT)) {
        UNLOCK_PFN (OldIrql);
        return 0;
    }

    MI_DECREMENT_RESIDENT_AVAILABLE (SizeInPages, MM_RESAVAIL_ALLOCATE_LARGE_PAGES);

    UNLOCK_PFN (OldIrql);

    Page = 0;

    //
    // Search the PFN database for pages that meet the requirements.
    // For NUMA configurations, try the current local node first.
    //

#define ANY_COLOR_OK 0xFFFFFFFF      // Indicate any color is ok.

    CurrentNodeColor = ANY_COLOR_OK;

#if defined(MI_MULTINODE)
    if (KeNumberNodes > 1) {
        CurrentNodeColor = KeGetCurrentPrcb()->NodeColor;
    }
#endif

    Thread = KeGetCurrentThread ();

    KeEnterGuardedRegionThread (Thread);

    MI_LOCK_DYNAMIC_MEMORY_SHARED ();

rescan:

    for ( ; start != MmPhysicalMemoryBlock->NumberOfRuns; start += 1) {

        count = MmPhysicalMemoryBlock->Run[start].PageCount;
        Page = MmPhysicalMemoryBlock->Run[start].BasePage;

        //
        // Close the gaps, then examine the range for a fit.
        //

        LastPage = Page + count; 

        if ((Page & BoundaryMask) || (Page == 0)) {
            NewPage = MI_ROUND_TO_SIZE (Page, (MM_MINIMUM_VA_FOR_LARGE_PAGE >> PAGE_SHIFT));

            if (NewPage < Page) {
                continue;
            }

            Page = NewPage;

            if (Page == 0) {
                Page = (MM_MINIMUM_VA_FOR_LARGE_PAGE >> PAGE_SHIFT);
            }

            if (Page >= LastPage) {
                continue;
            }
        }

        if (LastPage & BoundaryMask) {
            LastPage &= ~BoundaryMask;

            if (Page >= LastPage) {
                continue;
            }
        }

        if (Page + SizeInPages > LastPage) {
            continue;
        }

        count = LastPage - Page + 1;

        ASSERT (count != 0);
    
        //
        // A fit may be possible in this run, check whether the pages
        // are on the right list.
        //

        found = 0;
        Pfn1 = MI_PFN_ELEMENT (Page);

        while (Page < LastPage) {

            if ((Pfn1->u3.e1.PageLocation <= StandbyPageList) &&
                (Pfn1->u1.Flink != 0) &&
                (Pfn1->u2.Blink != 0) &&
                (Pfn1->u3.e2.ReferenceCount == 0) &&
                ((CurrentNodeColor == ANY_COLOR_OK) ||
                 (Pfn1->u3.e1.PageColor == CurrentNodeColor))) {

                found += 1;

                if (found == SizeInPages) {

                    //
                    // Lock the PFN database and see if the pages are
                    // still available for us.
                    //

                    Pfn1 -= (found - 1);
                    Page -= (found - 1);

                    LOCK_PFN (OldIrql);

                    do {

                        if ((Pfn1->u3.e1.PageLocation <= StandbyPageList) &&
                            (Pfn1->u1.Flink != 0) &&
                            (Pfn1->u2.Blink != 0) &&
                            (Pfn1->u3.e2.ReferenceCount == 0)) {

                            NOTHING;            // Good page
                        }
                        else {
                            break;
                        }

                        found -= 1;

                        if (found == 0) {

                            //
                            // All the pages matched the criteria, keep the
                            // PFN lock, remove them and map them for our
                            // caller.
                            //

                            goto Done;
                        }

                        Pfn1 += 1;
                        Page += 1;

                    } while (TRUE);

#if DBG
                    if (MiShowStuckPages != 0) {
                        DbgPrintEx (DPFLTR_MM_ID, DPFLTR_INFO_LEVEL, 
                            "MiFindLargePages : could not claim stolen PFN %p\n",
                            Page);
                        if (MiShowStuckPages & 0x8) {
                            DbgBreakPoint ();
                        }
                    }
#endif
                    UNLOCK_PFN (OldIrql);

                    //
                    // Restart the search at the first possible page.
                    //

                    found = 0;
                }
            }
            else {
#if DBG
                if (MiShowStuckPages != 0) {
                    DbgPrintEx (DPFLTR_MM_ID, DPFLTR_INFO_LEVEL, 
                        "MiFindLargePages : could not claim PFN %p %x %x\n",
                        Page, Pfn1->u3.e1, Pfn1->u4.EntireFrame);
                    if (MiShowStuckPages & 0x8) {
                        DbgBreakPoint ();
                    }
                }
#endif
                found = 0;
            }

            Page += 1;
            Pfn1 += 1;

            if (found == 0) {

                //
                // The last page interrogated wasn't available so skip
                // ahead to the next acceptable boundary.
                //

                NewPage = MI_ROUND_TO_SIZE (Page,
                                (MM_MINIMUM_VA_FOR_LARGE_PAGE >> PAGE_SHIFT));

                if ((NewPage == 0) || (NewPage < Page) || (NewPage >= LastPage)) {

                    //
                    // Skip the rest of this entry.
                    //

                    Page = LastPage;
                    continue;
                }

                Page = NewPage;
                Pfn1 = MI_PFN_ELEMENT (Page);
            }
        }
    }

    //
    // The desired physical pages could not be allocated.  If we were trying
    // for local memory (ie: NUMA machine), then expand our search to include
    // any node and try one last time.
    //

    if (CurrentNodeColor != ANY_COLOR_OK) {
        CurrentNodeColor = ANY_COLOR_OK;
        start = 0;
        found = 0;
        goto rescan;
    }

    MI_UNLOCK_DYNAMIC_MEMORY_SHARED ();
    KeLeaveGuardedRegionThread (Thread);
    MI_INCREMENT_RESIDENT_AVAILABLE (SizeInPages, MM_RESAVAIL_FREE_LARGE_PAGES);
    return 0;

Done:

    //
    // A match has been found, remove these pages,
    // map them and return.  The PFN lock is held.
    //

    ASSERT (start != MmPhysicalMemoryBlock->NumberOfRuns);
    ASSERT (Page - SizeInPages + 1 != 0);

    //
    // Systems utilizing memory compression may have more
    // pages on the zero, free and standby lists than we
    // want to give out.  Explicitly check MmAvailablePages
    // instead (and recheck whenever the PFN lock is
    // released and reacquired).
    //

    if ((SPFN_NUMBER)SizeInPages > (SPFN_NUMBER)(MmAvailablePages - MM_HIGH_LIMIT)) {
        UNLOCK_PFN (OldIrql);
        MI_INCREMENT_RESIDENT_AVAILABLE (SizeInPages, MM_RESAVAIL_FREE_LARGE_PAGES);

        MI_UNLOCK_DYNAMIC_MEMORY_SHARED ();
        KeLeaveGuardedRegionThread (Thread);

        return 0;
    }

    EndPfn = Pfn1 - SizeInPages + 1;

    BoundaryPfn = Pfn1 - (MM_VA_MAPPED_BY_PDE >> PAGE_SHIFT);

    do {

        NeedToZero = TRUE;

        if (Pfn1->u3.e1.PageLocation == StandbyPageList) {
            MiUnlinkPageFromList (Pfn1);
            ASSERT (Pfn1->u3.e2.ReferenceCount == 0);
            MiRestoreTransitionPte (Pfn1);
        }
        else {
            if (Pfn1->u3.e1.PageLocation == ZeroedPageList) {
                NeedToZero = FALSE;
            }
            MiUnlinkFreeOrZeroedPage (Pfn1);
        }

        Pfn1->u3.e2.ReferenceCount = 1;
        Pfn1->u2.ShareCount = 1;
        MI_SET_PFN_DELETED(Pfn1);
        Pfn1->u4.PteFrame = MI_MAGIC_AWE_PTEFRAME;
        Pfn1->u3.e1.PageLocation = ActiveAndValid;

        if (Pfn1->u3.e1.CacheAttribute != CacheAttribute) {
            FlushTbNeeded = TRUE;
            Pfn1->u3.e1.CacheAttribute = CacheAttribute;
        }

        Pfn1->u3.e1.StartOfAllocation = 0;
        Pfn1->u3.e1.EndOfAllocation = 0;
        Pfn1->u4.VerifierAllocation = 0;
        Pfn1->u3.e1.LargeSessionAllocation = 0;

        ASSERT (Pfn1->u4.AweAllocation == 0);
        Pfn1->u4.AweAllocation = 1;

        Pfn1->u3.e1.PrototypePte = 0;

        //
        // Add free and standby pages to the list of pages to be zeroed
        // by our caller.
        //

        if (NeedToZero == TRUE) {
            Color = MI_GET_COLOR_FROM_LIST_ENTRY (Page, Pfn1);

            ColoredPageInfo = &ColoredPageInfoBase[Color];

            Pfn1->OriginalPte.u.Long = (ULONG_PTR) ColoredPageInfo->PfnAllocation;
            ColoredPageInfo->PfnAllocation = Pfn1;
            ColoredPageInfo->PagesQueued += 1;
            ZeroCount += 1;
        }
        else {
            Pfn1->OriginalPte.u.Long = MM_DEMAND_ZERO_WRITE_PTE;
        }

        if (Pfn1 == EndPfn) {
            break;
        }

        Pfn1 -= 1;

        if (Pfn1 == BoundaryPfn) {
            BoundaryPfn = Pfn1 - (MM_VA_MAPPED_BY_PDE >> PAGE_SHIFT);
        }

    } while (TRUE);

    Pfn1->u3.e1.StartOfAllocation = 1;
    (Pfn1 + SizeInPages - 1)->u3.e1.EndOfAllocation = 1;

    UNLOCK_PFN (OldIrql);

    MI_UNLOCK_DYNAMIC_MEMORY_SHARED ();
    KeLeaveGuardedRegionThread (Thread);

    if (FlushTbNeeded) {
        MI_FLUSH_ENTIRE_TB_FOR_ATTRIBUTE_CHANGE (CacheAttribute);
    }

    Page = Page - SizeInPages + 1;
    ASSERT (Page != 0);
    ASSERT (Pfn1 == MI_PFN_ELEMENT (Page));

    MM_TRACK_COMMIT (MM_DBG_COMMIT_CHARGE_LARGE_PAGES, SizeInPages);

    *OutZeroCount = ZeroCount;
    return Page;
}


VOID
MiFreeLargePageMemory (
    IN PFN_NUMBER PageFrameIndex,
    IN PFN_NUMBER SizeInPages
    )

/*++

Routine Description:

    This function returns a contiguous large page allocation to the free
    memory lists.

Arguments:

    VirtualAddress - Supplies the starting page frame index to free.

    SizeInPages - Supplies the number of pages to free.

Return Value:

    None.

Environment:

    Kernel mode, IRQL of APC_LEVEL or below.

--*/
{
    PMMPFN Pfn1;
    KIRQL OldIrql;
    PKTHREAD CurrentThread;
    PFN_NUMBER LastPageFrameIndex;
    LONG EntryCount;
    LONG 