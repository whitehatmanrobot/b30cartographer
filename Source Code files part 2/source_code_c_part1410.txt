    if (ulNewStatus && _pInstallFilter)
    {
        _pInstallFilter->ReportProgress(ulNewStatus, szStatusText);
    }

    PerfDbgLog1(tagClassInstallFilter, this, "-CClassInstallFilter::ReportProgress (hr:%lx)\n", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CClassInstallFilterSink::ReportData
//
//  Synopsis:
//
//  Arguments:  
//
//  Returns:
//
//  History:    06-27-97   EricV (Eric VandenBerg)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CClassInstallFilterSink::ReportData(DWORD grfBSCF, ULONG ulProgress, ULONG ulProgressMax)
{
    PerfDbgLog(tagClassInstallFilter, this, "+CClassInstallFilterSink::ReportData\n");
    HRESULT hr = NOERROR;

    if (_bDone)
    {
        hr = E_FAIL;
    }

    PerfDbgLog1(tagClassInstallFilter, this, "-CClassInstallFilter::ReportData (hr:%lx)\n", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CClassInstallFilterSink::ReportResult
//
//  Synopsis:
//
//  Arguments:  
//
//  Returns:
//
//  History:    06-27-97   EricV (Eric VandenBerg)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CClassInstallFilterSink::ReportResult(HRESULT hrResult, DWORD dwError, LPCWSTR wzResult)
{
    PerfDbgLog(tagClassInstallFilter, this, "+CClassInstallFilterSink::ReportResult\n");
    HRESULT hr = NOERROR;

    if (_bDone)
    {
        hr = E_FAIL;
    }
    else 
    {
        _bDone = TRUE;
     
        hr = _pInstallFilter->InstallerReportResult(hrResult, dwError, wzResult);
    }
    
    PerfDbgLog1(tagClassInstallFilter, this, "-CClassInstallFilter::ReportResult (hr:%lx)\n", hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CClassInstallFilterSink::QueryService
//
//  Synopsis:
//
//  Arguments:  [rsid] --
//              [riid] --
//              [ppvObj] --
//
//  Returns:
//
//  History:    06-27-97   EricV (Eric VandenBerg)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CClassInstallFilterSink::QueryService(REFGUID rsid, REFIID riid, void ** ppvObj)
{
    PerfDbgLog(tagClassInstallFilter, this, "-CClassInstallFilterSink::QueryService\n");
    HRESULT hr = NOERROR;

    if (!_pInstallFilter)
    {
        hr = E_NOINTERFACE;
    }
    else
    {
        hr = _pInstallFilter->QueryService(rsid,riid,ppvObj);
    }

    PerfDbgLog1(tagClassInstallFilter, this, "-CClassInstallFilterSink::QueryService (hr:%xd)\n", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CClassInstallFilter::CClassInstallFilter
//
//  Synopsis:
//
//  Arguments:  
//
//  Returns:
//
//  History:    06-27-97   EricV (Eric VandenBerg)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
CClassInstallFilter::CClassInstallFilter() 
{
    PerfDbgLog(tagClassInstallFilter, this, "-CClassInstallFilter::CClassInstallFilter\n");

    DllAddRef();

    _pwzCDLURL = 0;
    _pwzClsId = 0;
    _pwzMime = 0;
    _pInstallSink = 0;
    
    _bAddRef = FALSE;

    _grfBSCF = 0;
    _ulProgress = 0;
    _ulProgressMax = 0;

    _hrResult = 0;
    _dwError = 0;
    _wzResult = NULL;
    _fReportResult = FALSE;
    _pwzDocBase[0] = L'\0';
    _pSecMgr = NULL;

    _CRefs = 1;

    SetInstallState(installingNone);

    PerfDbgLog(tagClassInstallFilter, this, "-CClassInstallFilter::CClassInstallFilter (end)\n");
}

//+---------------------------------------------------------------------------
//
//  Method:     CClassInstallFilter::~CClassInstallFilter
//
//  Synopsis:
//
//  Arguments:  
//
//  Returns:
//
//  History:    06-27-97   EricV (Eric VandenBerg)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
CClassInstallFilter::~CClassInstallFilter()
{
    PerfDbgLog(tagClassInstallFilter, this, "-CClassInstallFilter::~CClassInstallFilter\n");

    DllRelease();

    TransAssert((GetInstallState() == installingNone) 
             || (GetInstallState() == installingDone));
 
    if (_wzResult)
    {
        delete [] _wzResult;
    }

    if (_pwzCDLURL)
    {
        delete [] _pwzCDLURL;
    }
    
    if (_pwzClsId)
    {
        delete [] _pwzClsId;
    }
    
    if (_pwzMime)
    {
        delete [] _pwzMime;
    }

    if (_pInstallSink)
    {
        _pInstallSink->Release();
    }

    if (_pCDLnetProtocol)
    {
        _pCDLnetProtocol->Release();
        _pCDLnetProtocol = NULL;
    }

    if (_pSecMgr) {
        _pSecMgr->Release();
    }
 
    PerfDbgLog(tagClassInstallFilter, this, "-CClassInstallFilter::~CClassInstallFilter (end)\n");
}

//+---------------------------------------------------------------------------
//
//  Method:     CClassInstallFilter::QueryInterface
//
//  Synopsis:
//
//  Arguments:  
//
//  Returns:
//
//  History:    06-27-97   EricV (Eric VandenBerg)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CClassInstallFilter::QueryInterface(REFIID riid, void **ppvObj)
{
    PerfDbgLog(tagClassInstallFilter, this, "+CClassInstallFilter::QueryInterface\n");
    VDATEPTROUT(ppvObj, void *);
    VDATETHIS(this);
    HRESULT hr = NOERROR;

    *ppvObj = NULL;

    {
        if (   (riid == IID_IUnknown)
            || (riid == IID_IOInetProtocol))
        {
            *ppvObj = (IOInetProtocol *) this;
            AddRef();
        }
        else if (riid == IID_IOInetProtocolSink)
        {
            *ppvObj = (IOInetProtocolSink *) this;
            AddRef();
        }
        else if (riid == IID_IServiceProvider)
        {
            *ppvObj = (IServiceProvider *) this;
            AddRef();
        }
        else
        {
            hr = E_NOINTERFACE;
        }
    }


    PerfDbgLog1(tagClassInstallFilter, this, "-CClassInstallFilter::QueryInterface (hr:%lx)\n", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   CClassInstallFilter::AddRef
//
//  Synopsis:
//
//  Arguments:  
//
//  Returns:
//
//  History:    06-27-97   EricV (Eric VandenBerg)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CClassInstallFilter::AddRef(void)
{
    PerfDbgLog(tagClassInstallFilter, this, "+CClassInstallFilter::AddRef\n");

    LONG lRet;
  
    {
        lRet = ++_CRefs;
    }
    
    PerfDbgLog1(tagClassInstallFilter, this, "-CClassInstallFilter::AddRef (cRefs:%ld)\n", lRet);
    return lRet;
}

//+---------------------------------------------------------------------------
//
//  Function:   CClassInstallFilter::Release
//
//  Synopsis:
//
//  Arguments:  
//
//  Returns:
//
//  History:    06-27-97   EricV (Eric VandenBerg)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CClassInstallFilter::Release(void)
{
    PerfDbgLog(tagClassInstallFilter, this, "+CClassInstallFilter::Release\n");

    LONG lRet;
    {
        lRet = --_CRefs;
        if (_CRefs == 0)
        {
            delete this;
        }
    }

    PerfDbgLog1(tagClassInstallFilter, this, "-CClassInstallFilter::Release (cRefs:%ld)\n", lRet);
    return lRet;
}

//+---------------------------------------------------------------------------
//
//  Method:     CInstallBindInfo::CInstallBindInfo
//
//  Synopsis:
//
//  Arguments:  
//
//  Returns:
//
//  History:    06-27-97   EricV (Eric VandenBerg)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
CInstallBindInfo::CInstallBindInfo() 
{
    PerfDbgLog(tagClassInstallFilter, this, "-CInstallBindInfo::CClassInstallFilter\n");

    _CRefs = 1;

    PerfDbgLog(tagClassInstallFilter, this, "-CInstallBindInfo::ClassInstallFilter (end)\n");
}

//+---------------------------------------------------------------------------
//
//  Method:     CInstallBindInfo::~CInstallBindInfo
//
//  Synopsis:
//
//  Arguments:  
//
//  Returns:
//
//  History:    06-27-97   EricV (Eric VandenBerg)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
CInstallBindInfo::~CInstallBindInfo()
{
    PerfDbgLog(tagClassInstallFilter, this, "-CInstallBindInfo::~CInstallBindInfo\n");
    PerfDbgLog(tagClassInstallFilter, this, "-CInstallBindInfo::~CInstallBindInfo (end)\n");
}

//+---------------------------------------------------------------------------
//
//  Method:     CInstallBindInfo::QueryInterface
//
//  Synopsis:
//
//  Arguments:  
//
//  Returns:
//
//  History:    06-27-97   EricV (Eric VandenBerg)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CInstallBindInfo::QueryInterface(REFIID riid, void **ppvObj)
{
    PerfDbgLog(tagClassInstallFilter, this, "+CInstallBindInfo::QueryInterface\n");
    VDATEPTROUT(ppvObj, void *);
    VDATETHIS(this);
    HRESULT hr = NOERROR;

    *ppvObj = NULL;

    {
        if (   (riid == IID_IUnknown)
            || (riid == IID_IOInetBindInfo))
        {
            *ppvObj = (IOInetBindInfo *) this;
            AddRef();
        }
        else
        {
            hr = E_NOINTERFACE;
        }
    }


    PerfDbgLog1(tagClassInstallFilter, this, "-CInstallBindInfo::QueryInterface (hr:%lx)\n", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   CInstallBindInfo::AddRef
//
//  Synopsis:
//
//  Arguments:  
//
//  Returns:
//
//  History:    06-27-97   EricV (Eric VandenBerg)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CInstallBindInfo::AddRef(void)
{
    PerfDbgLog(tagClassInstallFilter, this, "+CInstallBindInfo::AddRef\n");

    LONG lRet;
  
    {
        lRet = ++_CRefs;
    }
    
    PerfDbgLog1(tagClassInstallFilter, this, "-CInstallBindInfo::AddRef (cRefs:%ld)\n", lRet);
    return lRet;
}

//+---------------------------------------------------------------------------
//
//  Function:   CInstallBindInfo::Release
//
//  Synopsis:
//
//  Arguments:  
//
//  Returns:
//
//  History:    06-27-97   EricV (Eric VandenBerg)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CInstallBindInfo::Release(void)
{
    PerfDbgLog(tagClassInstallFilter, this, "+CInstallBindInfo::Release\n");

    LONG lRet;
    {
        lRet = --_CRefs;
        if (_CRefs == 0)
        {
            delete this;
        }
    }

    PerfDbgLog1(tagClassInstallFilter, this, "-CInstallBindInfo::Release (cRefs:%ld)\n", lRet);
    return lRet;
}

//+---------------------------------------------------------------------------
//
//  Method:     CInstallBindInfo::GetBindInfo
//
//  Synopsis:
//
//  Arguments:  [grfBINDF] --
//              [pbindinfo] --
//
//  Returns:
//
//  History:    06-27-97   EricV (Eric VandenBerg)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CInstallBindInfo::GetBindInfo(
                                    DWORD *grfBINDF, BINDINFO * pbindinfo)
{
    PerfDbgLog(tagClassInstallFilter, this, "+CInstallBindInfo::GetBindInfo\n");
    HRESULT hr = NOERROR;

    TransAssert(pbindinfo);
    if (!grfBINDF || !pbindinfo || !pbindinfo->cbSize) 
    {
        hr = E_INVALIDARG;
    }
    else
    {
        DWORD cbSize = pbindinfo->cbSize;
        memset(pbindinfo, 0, cbSize);
        pbindinfo->cbSize = cbSize;
    }

    PerfDbgLog1(tagClassInstallFilter, this, "+CInstallBindInfo::GetBindInfo (hr:%lx)\n",hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CInstallBindInfo::GetBindString
//
//  Synopsis:
//
//  Arguments:  [ulStringType] --
//              [ppwzStr] --
//              [cEl] --
//              [pcElFetched] --
//
//  Returns:
//
//  History:    06-27-97   EricV (Eric VandenBerg)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CInstallBindInfo::GetBindString(
                    ULONG ulStringType, LPOLESTR *ppwzStr, ULONG cEl, ULONG *pcElFetched)
{
    PerfDbgLog(tagClassInstallFilter, this, "+CInstallBindInfo::GetBindString\n");
    HRESULT hr = NOERROR;

    TransAssert(ppwzStr);
    TransAssert(pcElFetched);

    if (ppwzStr && pcElFetched)
    {
        *ppwzStr = NULL;
        *pcElFetched = 0;
    }

    hr = S_FALSE;

    PerfDbgLog1(tagClassInstallFilter, this, "+CInstallBindInfo::GetBindString (hr:%lx)\n",hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CClassInstallFilter::Start
//
//  Synopsis:
//
//  Arguments:  [pwzUrl] --
//              [pTrans] --
//              [pOIBindInfo] --
//              [grfSTI] --
//              [dwReserved] --
//
//  Returns:
//
//  History:    06-27-97   EricV (Eric VandenBerg)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CClassInstallFilter::Start(LPCWSTR pwzUrl, 
                          IOInetProtocolSink *pOInetProtSnk, 
                          IOInetBindInfo *pOIBindInfo,
                          DWORD grfSTI, 
                          DWORD_PTR dwReserved)
{
    PerfDbgLog(tagClassInstallFilter, this, "+CClassInstallFilter::Start\n");
    HRESULT hr = NOERROR;
    IOInetSession *pOInetSession = NULL;
    PROTOCOLFILTERDATA *pFilterData = (PROTOCOLFILTERDATA *)dwReserved;
    static LPCWSTR pwzCDLFormatCDL = L"cdl:";
    static LPCWSTR pwzCDLFormatCodebase = L"codebase=";
    static LPCWSTR pwzCDLFormatClsId = L"clsid=";
    static LPCWSTR pwzCDLFormatMime = L"mimetype=";
    static LPCWSTR pwzCDLFormatVerMS = L";verMS=";
    static LPCWSTR pwzCDLFormatVerLS = L";verLS=";
    static LPCWSTR pwzCDLFormatSeparator = L";";
    IOInetBindInfo *pBindInfo = NULL;
    LPWSTR pwzTmp = NULL;
    LPWSTR pwzVerInfo = NULL, pwzVerMS = NULL, pwzVerLS = NULL;
    DWORD dwSize;
    WCHAR chType = L'\0';

    TransAssert((pOIBindInfo && pOInetProtSnk && pwzUrl));
    TransAssert(!_pCDLnetProtocol);
    
    //BUGBUG:
    // we engage in some trickery to get the URL & class ID.  The URL string
    // passed to us is actually "Class Install Handler", but after the NULL
    // terminator we expect the docbase the show up. After this, the real URL
    // info to occur.  This is because the pwzURL
    // is used by LoadHandler to find us in the registry and then calls us with it.

    // Get the docbase
    while (*pwzUrl)
    {
        pwzUrl++;
    }
    pwzUrl++;
    
    lstrcpyW(_pwzDocBase, pwzUrl);

    // Now get the cdl:// codebase

    while (*pwzUrl)
    {
        pwzUrl++;
    }
    pwzUrl++;

    if (pOInetProtSnk && pwzUrl && *pwzUrl) 
    {
        TransAssert(pwzUrl);
   
        //
        // expect url:   codebase?<type>[clsid|mimetype]?<verMS>,<verLS>
        // example:      http://msw/officehandler.cab?CABCD1234-...?1,2
        //

        delete [] _pwzUrl;
        pwzTmp = _pwzUrl = OLESTRDuplicate((LPCWSTR)pwzUrl);

        while (*pwzTmp && *pwzTmp != L'?')
        {
            pwzTmp++;
        }

        if (*pwzTmp)
        {
            *pwzTmp = L'\0';
            pwzTmp++;

            delete [] _pwzClsId;
            
            // extract version info.
            pwzVerInfo = pwzTmp;
            while (*pwzVerInfo && *pwzVerInfo != L'?')
            {
                pwzVerInfo++;
            }

            if (*pwzVerInfo == L'?')
            {
                pwzVerMS = pwzVerInfo + 1;
                pwzVerLS = pwzVerMS;

                while (*pwzVerLS && *pwzVerLS != L',')
                {
                    pwzVerLS++;
                }
                if (*pwzVerLS == L',')
                {
                    *pwzVerLS = L'\0';
                    pwzVerLS++;        
                }

                *pwzVerInfo = '\0';
            }
            else
            {
                pwzVerInfo = NULL;
            }

            if (*pwzTmp == L'{')
            {
                // handle CLSID string
                _pwzClsId = OLESTRDuplicate((LPCWSTR)pwzTmp);
                _pwzMime = NULL;
            }
            else
            {
                _pwzMime = OLESTRDuplicate((LPCWSTR)pwzTmp);
                _pwzClsId = NULL;
            }

            // compose cdl:// string
            dwSize = lstrlenW(pwzCDLFormatCDL) 
                    + (_pwzUrl ? lstrlenW(pwzCDLFormatCodebase) 
                                + lstrlenW(_pwzUrl)
                                + lstrlenW(pwzCDLFormatSeparator) : 0)
                    + (_pwzClsId ? lstrlenW(pwzCDLFormatClsId)
                                + lstrlenW(_pwzClsId) : 0)
                    + (_pwzMime ? lstrlenW(pwzCDLFormatMime) 
                                + lstrlenW(_pwzMime) : 0)
                    + (pwzVerMS ? lstrlenW(pwzCDLFormatVerMS)
                                + lstrlenW(pwzVerMS) : 0)
                    + (pwzVerLS ? lstrlenW(pwzCDLFormatVerLS)
                                + lstrlenW(pwzVerLS) : 0)
                    + 3;

            delete [] _pwzCDLURL;
            _pwzCDLURL = new WCHAR[dwSize];

            if (_pwzCDLURL)
            {
                StrCpyW(_pwzCDLURL, pwzCDLFormatCDL);
                
                // codebase is optional, but one of clsid or mimetype must exist.
                if (_pwzUrl)
                {
                    StrCatW(_pwzCDLURL, pwzCDLFormatCodebase);
                    StrCatW(_pwzCDLURL, _pwzUrl);
                    StrCatW(_pwzCDLURL, pwzCDLFormatSeparator);
                }
                
                if (_pwzClsId)
                {
                    StrCatW(_pwzCDLURL, pwzCDLFormatClsId);
                    StrCatW(_pwzCDLURL, _pwzClsId);
                }
                else if (_pwzMime)
                {
                    StrCatW(_pwzCDLURL, pwzCDLFormatMime);
                    StrCatW(_pwzCDLURL, _pwzMime);
                }
                else
                {
                    hr = E_UNEXPECTED;
                }

                if (pwzVerMS)
                {
                    StrCatW(_pwzCDLURL, pwzCDLFormatVerMS);
                    StrCatW(_pwzCDLURL, pwzVerMS);
                }
                if (pwzVerLS)
                {
                    StrCatW(_pwzCDLURL, pwzCDLFormatVerLS);
                    StrCatW(_pwzCDLURL, pwzVerLS);
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }

        }
        else
        {
            hr = E_INVALIDARG;
        }

        if (SUCCEEDED(hr) && _pwzCDLURL && pFilterData && pFilterData->pProtocol)
        {
            _pProt = pFilterData->pProtocol;
            _pProt->AddRef();

            _pProtSnk = pOInetProtSnk;
            _pProtSnk->AddRef();

            // Pass our IInternetProtocolSink out
            pFilterData->pProtocolSink = (IOInetProtocolSink *)this;

            hr = CoInternetGetSession(0, &pOInetSession, 0);

            if (SUCCEEDED(hr))
            {
                hr = pOInetSession->CreateBinding(NULL, _pwzCDLURL, NULL, NULL, 
                                         (IOInetProtocol **)&_pCDLnetProtocol, 
                                         OIBDG_APARTMENTTHREADED);
                pOInetSession->Release();

                if (SUCCEEDED(hr) && _pCDLnetProtocol)
                {
                    _pInstallSink = new CClassInstallFilterSink(this);
                    
                    if (_pInstallSink)
                    {

                        //hr = _CBindInfo.QueryInterface(IID_IOInetBindInfo, (void **)&pBindInfo);

                        pBindInfo = new CInstallBindInfo();

                        if (!pBindInfo) {
                            hr = E_OUTOFMEMORY;
                        }
        
                        if (SUCCEEDED(hr) && pBindInfo) 
                        {
                            hr = _pCDLnetProtocol->Start(_pwzCDLURL, 
                                    (IOInetProtocolSink *)_pInstallSink, 
                                    (IOInetBindInfo *)pBindInfo,
                                    PI_FORCE_ASYNC | PI_APARTMENTTHREADED, 0);
                            
                            // We add reference ourself so that if we are terminated before
                            // the cdl:// download we don't get deleted.

                            pBindInfo->Release();
                            pBindInfo = NULL;

                            if (hr == E_PENDING) {

                                AddRef();
                                _bAddRef = TRUE;

                                SetInstallState(installingHandler);
                            }
                        }

                    }
                    else 
                    {
                        hr = E_OUTOFMEMORY;
                    }
                }
            }
        }
        else
        {
            hr = E_INVALIDARG;
        }

    }
    else
    {
        hr = E_FAIL;
    }

    // BUGBUG: when do we release if E_PENDING?
    if (hr != E_PENDING)
    {
        SetInstallState(installingDone);

        if (_pCDLnetProtocol)
        {
            _pCDLnetProtocol->Release();
            _pCDLnetProtocol = NULL;
        }

    }

    PerfDbgLog1(tagClassInstallFilter, this, "+CClassInstallFilter::Start (hr:%lx)\n",hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CClassInstallFilter::Continue
//
//  Synopsis:
//
//  Arguments:  [pStateInfoIn] --
//
//  Returns:
//
//  History:    06-27-97   EricV (Eric VandenBerg)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CClassInstallFilter::Continue(PROTOCOLDATA *pStateInfoIn)
{
    PerfDbgLog(tagClassInstallFilter, this, "+CClassInstallFilter::Continue\n");

    HRESULT hr = NOERROR;

    if (_pProt)
    {
         hr = _pProt->Continue(pStateInfoIn);
    }

    PerfDbgLog1(tagClassInstallFilter, this, "-CClassInstallFilter::Continue (hr:%lx)\n",hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CClassInstallFilter::Abort
//
//  Synopsis:
//
//  Arguments:  [hrReason] --
//              [dwOptions] --
//
//  Returns:
//
//  History:    06-27-97   EricV (Eric VandenBerg)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CClassInstallFilter::Abort(HRESULT hrReason, DWORD dwOptions)
{
    PerfDbgLog(tagClassInstallFilter, this, "+CClassInstallFilter::Abort\n");
    HRESULT hr = NOERROR;

    if (_pCDLnetProtocol)
    { 
        hr = _pCDLnetProtocol->Abort(hrReason, dwOptions);
    }

    if (_pProt)
    {
        hr = _pProt->Abort(hrReason, dwOptions);        
    }

    // Release sink
    if (_pProtSnk)
    {
        _pProtSnk->Release();
        _pProtSnk = NULL;
    }

    PerfDbgLog1(tagClassInstallFilter, this, "-CClassInstallFilter::Abort (hr:%lx)\n", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CClassInstallFilter::Terminate
//
//  Synopsis:
//
//  Arguments:  [dwOptions] --
//
//  Returns:
//
//  History:    06-27-97   EricV (Eric VandenBerg)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CClassInstallFilter::Terminate(DWORD dwOptions)
{
    PerfDbgLog(tagClassInstallFilter, this, "+CClassInstallFilter::Terminate\n");
    HRESULT hr = NOERROR;

    TransAssert((_pProt));

    if (_pCDLnetProtocol)
    {
        hr = _pCDLnetProtocol->Terminate(dwOptions);
    }

    if (_pProt)
    {
        hr = _pProt->Terminate(dwOptions);
    }

    // Release sink 
    if (_pProtSnk)
    {
        _pProtSnk->Release();
        _pProtSnk = NULL;
    }

    PerfDbgLog1(tagClassInstallFilter, this, "-CClassInstallFilter::Terminate (hr:%lx)\n", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CClassInstallFilter::Suspend
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    06-27-97   EricV (Eric VandenBerg)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CClassInstallFilter::Suspend()
{
    PerfDbgLog(tagClassInstallFilter, this, "+CClassInstallFilter::Suspend\n");
    HRESULT hr = NOERROR;
    
    if (_pProt) 
    {
         hr = _pProt->Suspend();
    }

    PerfDbgLog1(tagClassInstallFilter, this, "-CClassInstallFilter::Suspend (hr:%lx)\n", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CClassInstallFilter::Resume
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    06-27-97   EricV (Eric VandenBerg)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CClassInstallFilter::Resume()
{
    PerfDbgLog(tagClassInstallFilter, this, "+CClassInstallFilter::Resume\n");
    HRESULT hr = NOERROR;

    if (_pProt)
    {
        hr = _pProt->Resume();
    }

    PerfDbgLog1(tagClassInstallFilter, this, "-CClassInstallFilter::Resume (hr:%lx)\n", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CClassInstallFilter::Read
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    06-27-97   EricV (Eric VandenBerg)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CClassInstallFilter::Read(void *pv,ULONG cb,ULONG *pcbRead)
{
    PerfDbgLog(tagClassInstallFilter, this, "+CClassInstallFilter::Read\n");
    HRESULT hr = NOERROR;

    if (_pProt)
    {
        hr = _pProt->Read(pv,cb,pcbRead);
    }
 
    PerfDbgLog1(tagClassInstallFilter, this, "-CClassInstallFilter::Read (hr:%lx)\n", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CClassInstallFilter::Seek
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    06-27-97   EricV (Eric VandenBerg)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

STDMETHODIMP CClassInstallFilter::Seek(LARGE_INTEGER dlibMove,DWORD dwOrigin,
                      ULARGE_INTEGER *plibNewPosition)
{
    PerfDbgLog(tagClassInstallFilter, this, "+CClassInstallFilter::Seek\n");
    HRESULT hr = NOERROR;

    if (_pProt)
    {
        hr = _pProt->Seek(dlibMove, dwOrigin, plibNewPosition);
    } 

    PerfDbgLog1(tagClassInstallFilter, this, "-CClassInstallFilter::Seek (hr:%lx)\n", hr);
    return hr;

}

//+---------------------------------------------------------------------------
//
//  Method:     CClassInstallFilter::LockRequest
//
//  Synopsis:
//
//  Arguments:  [dwOptions] --
//
//  Returns:
//
//  History:    06-27-97   EricV (Eric VandenBerg)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CClassInstallFilter::LockRequest(DWORD dwOptions)
{
    PerfDbgLog(tagClassInstallFilter, this, "+CClassInstallFilter::LockRequest\n");

    HRESULT hr = NOERROR;

    if (_pProt)
    {    
        hr = _pProt->LockRequest(dwOptions);
    }

    PerfDbgLog1(tagClassInstallFilter, this, "-CClassInstallFilter::LockRequest (hr:%lx)\n",hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CClassInstallFilter::UnlockRequest
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    06-27-97   EricV (Eric VandenBerg)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CClassInstallFilter::UnlockRequest()
{
    PerfDbgLog(tagClassInstallFilter, this, "+CClassInstallFilter::UnlockRequest\n");
    HRESULT hr = NOERROR;

    if (_pProt)
    {
         hr = _pProt->UnlockRequest();
    }

    PerfDbgLog1(tagClassInstallFilter, this, "-CClassInstallFilter::UnlockRequest (hr:%lx)\n", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CClassInstallFilter::Switch
//
//  Synopsis:
//
//  Arguments:  [pStateInfo] --
//
//  Returns:
//
//  History:    06-27-97   EricV (Eric VandenBerg)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CClassInstallFilter::Switch(PROTOCOLDATA *pStateInfo)
{
    PerfDbgLog(tagClassInstallFilter, this, "+CClassInstallFilter::Switch\n");
    HRESULT hr = NOERROR;

    if (_pProtSnk)
    {
        hr = _pProtSnk->Switch(pStateInfo);
    }
 
    PerfDbgLog1(tagClassInstallFilter, this, "-CClassInstallFilter::Switch (hr:%lx)\n", hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CClassInstallFilter::ReportProgress
//
//  Synopsis:
//
//  Arguments:  [NotMsg] --
//              [szStatusText] --
//
//  Returns:
//
//  History:    06-27-97   EricV (Eric VandenBerg)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CClassInstallFilter::ReportProgress(ULONG NotMsg, LPCWSTR pwzStatusText)
{
    PerfDbgLog(tagClassInstallFilter, this, "+CClassInstallFilter::ReportProgress\n");
    HRESULT hr = NOERROR;

    if (_pProtSnk)
    {
        hr = _pProtSnk->ReportProgress(NotMsg, pwzStatusText);
    }

    PerfDbgLog1(tagClassInstallFilter, this, "-CClassInstallFilter::ReportProgress (hr:%lx)\n", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CClassInstallFilter::ReportData
//
//  Synopsis:
//
//  Arguments:  [grfBSCF] --
//              [ULONG] --
//              [ulProgressMax] --
//
//  Returns:
//
//  History:    06-27-97   EricV (Eric VandenBerg)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CClassInstallFilter::ReportData(DWORD grfBSCF, ULONG ulProgress, ULONG ulProgressMax)
{
    PerfDbgLog3(tagClassInstallFilter, this, "+CClassInstallFilter::ReportData(grfBSCF:%lx, ulProgress:%ld, ulProgressMax:%ld)\n",
                                       grfBSCF, ulProgress, ulProgressMax);
    HRESULT hr = NOERROR;

    _grfBSCF = grfBSCF;
    _ulProgress = ulProgress;
    _ulProgressMax = ulProgressMax;

    if (_pProtSnk)
    {
        hr = _pProtSnk->ReportData( grfBSCF, ulProgress, ulProgressMax);
    }

    PerfDbgLog1(tagClassInstallFilter, this, "-CClassInstallFilter::ReportData (hr:%lx)\n", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CClassInstallFilter::ReportResult
//
//  Synopsis:
//
//  Arguments:  [DWORD] --
//              [dwError] --
//              [wzResult] --
//
//  Returns:
//
//  History:    06-27-97   EricV (Eric VandenBerg)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CClassInstallFilter::ReportResult(HRESULT hrResult, DWORD dwError, LPCWSTR wzResult)
{
    PerfDbgLog(tagClassInstallFilter, this, "+CClassInstallFilter::ReportResult\n");
    HRESULT hr = NOERROR;

    // record any failure, unless overwriting previous failure
    if (FAILED(hrResult) && SUCCEEDED(_hrResult) ) {

        _hrResult = hrResult;
        _dwError = dwError;
        _wzResult = NULL;

        if (_wzResult)
        {
            _wzResult = new WCHAR[lstrlenW(wzResult)+1];
            StrCpyW(_wzResult, wzResult);
        }
    }


    if (GetInstallState() != installingDone)
    {

        // data (docfile) completed download

        _fReportResult = TRUE;
    } 
    else if (_fReportResult)
    {
        // all complete
        if (_pProtSnk)
        {
            // always report recorded results
            hr = _pProtSnk->ReportResult(_hrResult, _dwError, _wzResult);

        }

    } else {

        // data (docfile) completed download
        _fReportResult = TRUE;
    }

    PerfDbgLog1(tagClassInstallFilter, this, "-CClassInstallFilter::ReportResult (hr:%lx)\n", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CClassInstallFilter::CClassInstallFilter
//
//  Synopsis:
//
//  Arguments:  [DWORD] --
//              [dwError] --
//              [wzResult] --
//
//  Returns:
//
//  History:    06-27-97   EricV (Eric VandenBerg)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CClassInstallFilter::InstallerReportResult(HRESULT hrResult, DWORD dwError, LPCWSTR wzResult)
{
    HRESULT hr = NOERROR;

    SetInstallState(installingDone);

    if (_pProtSnk)
    {
        // tell sink to stop waiting on handler to install
        _pProtSnk->ReportProgress(BINDSTATUS_ENDDOWNLOADCOMPONENTS,NULL);

        // repeat last report data to kick start binding operation
        _pProtSnk->ReportData(_grfBSCF, _ulProgress, _ulProgressMax);
    }


    ReportResult(hrResult, dwError, wzResult);

    if (_bAddRef)
    {
        _bAddRef = FALSE;
        Release();
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CClassInstallFilter::QueryService
//
//  Synopsis:
//
//  Arguments:  [rsid] --
//              [riid] --
//              [ppvObj] --
//
//  Returns:
//
//  History:    06-27-97   EricV (Eric VandenBerg)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CClassInstallFilter::QueryService(REFGUID rsid, REFIID riid, void ** ppvObj)
{
    HRESULT     hr = NOERROR;
    IServiceProvider        *pIServiceProvider = NULL;

    EProtAssert(ppvObj);
    if (!ppvObj)
        return E_INVALIDARG;

    *ppvObj = 0;

    if (IsEqualGUID(rsid, IID_IInternetHostSecurityManager) &&
        IsEqualGUID(riid, IID_IInternetHostSecurityManager)) {

        if (_pSecMgr == NULL) {
            hr = CoInternetCreateSecurityManager(NULL, &_pSecMgr, NULL);
        }
        
        if (_pSecMgr) {
            *ppvObj = (IInternetHostSecurityManager *)this;
            AddRef();
        }
        else {
            hr = E_NOINTERFACE;
        }
    }
    else {
        hr = _pProtSnk->QueryInterface(IID_IServiceProvider,
                                                 (LPVOID *)&pIServiceProvider);
    
        if (SUCCEEDED(hr))
        {
            hr = pIServiceProvider->QueryService(rsid, riid, (LPVOID *)ppvObj);
            pIServiceProvider->Release();
        }
    }

    return hr;
}

// IInternetHostSecurityManager
STDMETHODIMP CClassInstallFilter::GetSecurityId(BYTE *pbSecurityId, DWORD *pcbSecurityId,
                                                DWORD_PTR dwReserved)
{
    HRESULT                    hr = E_FAIL;

    if (_pSecMgr) {
        hr = _pSecMgr->GetSecurityId(_pwzDocBase, pbSecurityId,
                                     pcbSecurityId, dwReserved);
    }

    return hr;
}

STDMETHODIMP CClassInstallFilter::ProcessUrlAction(DWORD dwAction, BYTE *pPolicy, DWORD cbPolicy,
                                                   BYTE *pContext, DWORD cbContext, DWORD dwFlags,
                                                   DWORD dwReserved)
{
    HRESULT                    hr = E_FAIL;

    if (_pSecMgr) {
        hr = _pSecMgr->ProcessUrlAction(_pwzDocBase, dwAction, pPolicy,
                                        cbPolicy, pContext, cbContext,
                                        dwFlags, dwReserved);
    }

    return hr;
}

STDMETHODIMP CClassInstallFilter::QueryCustomPolicy(REFGUID guidKey, BYTE **ppPolicy,
                                                    DWORD *pcbPolicy, BYTE *pContext,
                                                    DWORD cbContext, DWORD dwReserved)
{
    HRESULT                    hr = E_FAIL;

    if (_pSecMgr) {
        hr = _pSecMgr->QueryCustomPolicy(_pwzDocBase, guidKey, ppPolicy,
                                         pcbPolicy, pContext, cbContext,
                                         dwReserved);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\eapp\cdlprot.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       cdlprot.cxx
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    02-06-1997   t-alans (Alan Shi)   Created
//
//----------------------------------------------------------------------------

#include <eapp.h>
#include <tchar.h>
#ifdef unix
#include "../download/cdl.h"
#else
#include "..\download\cdl.h"
#endif /* !unix */


// From shlwapip.h
LWSTDAPI_(HRESULT) CLSIDFromStringWrap(LPOLESTR lpsz, LPCLSID pclsid);


#define VALUE_EQUAL_CHAR            '='
#define VALUE_SEPARATOR_CHAR        ';'


//+---------------------------------------------------------------------------
//
//  Method:     CCdlProtocol::CCdlProtocol
//
//  Synopsis:
//
//  Arguments:
//
//
//
//  Returns:
//
//  History:    02-06-1997   t-alans (Alan Shi)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

CCdlProtocol::CCdlProtocol(REFCLSID rclsid, IUnknown *pUnkOuter,
                           IUnknown **ppUnkInner)
: CBaseProtocol(rclsid, pUnkOuter, ppUnkInner)
{
    EProtDebugOut((DEB_PLUGPROT, "%p _IN CCdlProtocol::CCdlProtocol \n", this));

    DllAddRef();

    _clsidReport = CLSID_NULL;
    _pCodeDLBSC = NULL;
    _fDataPending = TRUE;
    _fNotStarted = TRUE;
    _iid = IID_IUnknown;
    _pbc = NULL;
    _fGetClassObject = FALSE;
    EProtDebugOut((DEB_PLUGPROT, "%p OUT CCdlProtocol::CCdlProtocol \n", this));
}

//+---------------------------------------------------------------------------
//
//  Method:     CCdlProtocol::~CCdlProtocol
//
//  Synopsis:
//
//  Arguments:
//
//
//
//  Returns:
//
//  History:    02-06-1997   t-alans (Alan Shi)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

CCdlProtocol::~CCdlProtocol()
{
    if (_pbc)
    {
        _pbc->Release();
    }

    DllRelease();
    EProtDebugOut((DEB_PLUGPROT, "%p _IN/OUT CCdlProtocol::~CCdlProtocol \n", this));
}

//+---------------------------------------------------------------------------
//
//  Method:     CCdlProtocol::Start
//
//  Synopsis:
//
//  Arguments:
//
//
//
//  Returns:
//
//  History:    02-06-1997   t-alans (Alan Shi)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

#ifdef _WIN64
LWSTDAPI_(BOOL)     StrToInt64ExW(LPCWSTR pszString, DWORD dwFlags, LONGLONG * pllRet);
#endif

STDMETHODIMP CCdlProtocol::Start(LPCWSTR pwzUrl,
                                 IOInetProtocolSink *pIOInetProtocolSink,
                                 IOInetBindInfo *pIOInetBindInfo,
                                 DWORD grfSTI,
                                 DWORD_PTR dwReserved)
{
    DWORD                     cElFetched = 0;
    LPOLESTR                  pwzIID = NULL;
    BINDINFO                  bindinfo;
    DWORD                     grfBINDF = 0;

    EProtDebugOut((DEB_PLUGPROT, "%p _IN CCdlProtocol::Start\n", this));
    HRESULT hr = NOERROR;
    WCHAR    wzURL[MAX_URL_SIZE];

    EProtAssert((!_pProtSink && pIOInetBindInfo && pIOInetProtocolSink));
    EProtAssert((_pwzUrl == NULL));

    bindinfo.cbSize = sizeof(BINDINFO);
    pIOInetBindInfo->GetBindInfo(&grfBINDF, &bindinfo);

    if (grfBINDF & BINDF_GETCLASSOBJECT)
    {
        LPWSTR                  pwzBC = NULL;
        DWORD                   cElFetched = 0;

        hr = pIOInetBindInfo->GetBindString(BINDSTRING_PTR_BIND_CONTEXT,
                                            &pwzBC, 0,
                                            &cElFetched);
        if (SUCCEEDED(hr))
        {
#ifdef _WIN64
            StrToInt64ExW(pwzBC, 0, (LONGLONG *)&_pbc);
#else
            _pbc = (IBindCtx *)StrToIntW(pwzBC);
#endif

            EProtAssert(_pbc);

            delete [] pwzBC;
            pwzBC = NULL;
        }
        else
        {
            hr = E_UNEXPECTED;
            goto Exit;
        }

        _fGetClassObject = TRUE;
    }

    grfSTI |= PI_FORCE_ASYNC;
    hr = CBaseProtocol::Start(pwzUrl, pIOInetProtocolSink, pIOInetBindInfo, grfSTI, dwReserved);

    if (SUCCEEDED(hr))
    {
        hr = pIOInetBindInfo->GetBindString(BINDSTRING_IID, &pwzIID, 0,
                                            &cElFetched);
    }

    if (hr == S_OK)
    {
        hr = CLSIDFromString(pwzIID, &_iid);
        delete [] pwzIID;
    }

    if (SUCCEEDED(hr))
    {
        hr =  ParseURL();
    }

Exit:

    EProtDebugOut((DEB_PLUGPROT, "%p OUT CCdlProtocol::Start (hr:%lx)\n",this, hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CCdlProtocol::Continue
//
//  Synopsis:
//
//  Arguments:
//
//
//
//  Returns:
//
//  History:    02-06-1997   t-alans (Alan Shi)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

STDMETHODIMP CCdlProtocol::Continue(PROTOCOLDATA *pStateInfoIn)
{
    EProtDebugOut((DEB_PLUGPROT, "%p _IN CCdlProtocol::Continue\n", this));
    HRESULT hr = E_FAIL;

    if (_fNotStarted && pStateInfoIn->dwState == CDL_STATE_BIND)
    {
        _fNotStarted = FALSE;
        hr =  ParseURL();
    }

    EProtDebugOut((DEB_PLUGPROT, "%p OUT CCdlProtocol::Continue (hr:%lx)\n",this, hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CCdlProtocol::Read
//
//  Synopsis:
//
//  Arguments:
//
//
//
//  Returns:
//
//  History:    02-06-1997   t-alans (Alan Shi)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

STDMETHODIMP CCdlProtocol::Read(void *pv,ULONG cb,ULONG *pcbRead)
{
    EProtDebugOut((DEB_PLUGPROT, "%p _IN CCdlProtocol::Read\n", this));
    HRESULT           hr;

    hr = (_fDataPending) ? (E_PENDING) : (S_FALSE);
    *pcbRead = (_fDataPending) ? (0x0) : (0x100);

    EProtDebugOut((DEB_PLUGPROT, "%p OUT CCdlProtocol::Read\n", this));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CCdlProtocol::Abort
//
//  Synopsis:
//
//  Arguments:
//
//
//
//  Returns:
//
//  History:    02-06-1997   t-alans (Alan Shi)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

STDMETHODIMP CCdlProtocol::Abort(HRESULT hrReason, DWORD dwOptions)
{
    EProtDebugOut((DEB_PLUGPROT, "%p _IN CCdlProtocol::Abort\n", this));
    HRESULT           hr = E_UNEXPECTED;

    EProtAssert( _pCodeDLBSC != NULL );
    if (_pCodeDLBSC != NULL)
    {
        hr = _pCodeDLBSC->Abort();
    }

#if 0
    if (_pProtSink)
    {
        hr = CBaseProtocol::Abort(hrReason, dwOptions);
    }
#endif

    EProtDebugOut((DEB_PLUGPROT, "%p OUT CCdlProtocol::Abort\n", this));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CCdlProtocol::Seek
//
//  Synopsis:
//
//  Arguments:
//
//
//
//  Returns:
//
//  History:    02-06-1997   t-alans (Alan Shi)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

STDMETHODIMP CCdlProtocol::Seek(LARGE_INTEGER dlibMove, DWORD dwOrigin,
                                ULARGE_INTEGER *plibNewPosition)
{
    EProtDebugOut((DEB_PLUGPROT, "%p _IN CCdlProtocol::Seek\n", this));
    EProtDebugOut((DEB_PLUGPROT, "%p OUT CCdlProtocol::Seek\n", this));
    return E_NOTIMPL;
}

//+---------------------------------------------------------------------------
//
//  Method:     CCdlProtocol::LockRequest
//
//  Synopsis:
//
//  Arguments:
//
//
//
//  Returns:
//
//  History:    02-06-1997   t-alans (Alan Shi)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

STDMETHODIMP CCdlProtocol::LockRequest(DWORD dwOptions)
{
    EProtDebugOut((DEB_PLUGPROT, "%p _IN CCdlProtocol::LockRequest\n", this));
    EProtDebugOut((DEB_PLUGPROT, "%p OUT CCdlProtocol::LockRequest\n", this));
    return E_NOTIMPL;
}

//+---------------------------------------------------------------------------
//
//  Method:     CCdlProtocol::UnlockRequest
//
//  Synopsis:
//
//  Arguments:
//
//
//
//  Returns:
//
//  History:    02-06-1997   t-alans (Alan Shi)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

STDMETHODIMP CCdlProtocol::UnlockRequest()
{
    EProtDebugOut((DEB_PLUGPROT, "%p _IN CCdlProtocol::UnlockRequest\n", this));
    EProtDebugOut((DEB_PLUGPROT, "%p OUT CCdlProtocol::UnlockRequest\n", this));
    return E_NOTIMPL;
}

//+---------------------------------------------------------------------------
//
//  Method:     CCdlProtocol::ParseURL
//
//  Synopsis:
//
//  Arguments:
//
//
//
//  Returns:
//
//  History:    02-06-1997   t-alans (Alan Shi)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

STDMETHODIMP CCdlProtocol::ParseURL()
{
    EProtDebugOut((DEB_PLUGPROT, "%p _IN CCdlProtocol::ParseURL\n", this));
    HRESULT            hr = MK_E_SYNTAX;
    WCHAR              wzlURL[MAX_URL_SIZE];
    LPWSTR             pwz = NULL;
    LPWSTR             pwzValue = NULL;
    LPWSTR             pwzTag = NULL;
    LPWSTR             pwzPound = NULL;
    BOOL               fGotRequiredField = FALSE;
    CodeDownloadData   cdldata;
    CHAR               szValue[MAX_PATH];

    cdldata.szDistUnit = NULL;
    cdldata.szClassString = NULL;
    cdldata.szURL = NULL;
    cdldata.szMimeType = NULL;
    cdldata.szExtension = NULL;
    cdldata.szDll = NULL;
    cdldata.dwFileVersionMS = 0;
    cdldata.dwFileVersionLS = 0;
    cdldata.dwFlags = 0;


// URL is of the form:
// (1)  cdl://[unused]?[clsid=xxx|codebase=xxx|mimetype=xxx|extension=xxx];
//                     [clsid=xxx|codebase=xxx|mimetype=xxx|extension=xxx];
//                     [clsid=xxx|codebase=xxx|mimetype=xxx|extension=xxx];...
//
//     OR
//
// (2)  cdl:[clsid=xxx|codebase=xxx|mimetype=xxx|extension=xxx];
//          [clsid=xxx|codebase=xxx|mimetype=xxx|extension=xxx];...
//
//
// NOTE: [distunit=xxx] added to support AsyncInstallDistributionUnit
//       [flags=xxx] added flags (as an integer so that we can dictate
//                   silent mode, async. etc.

    wcscpy(wzlURL, _wzFullURL);

    // ensure correct format: "cdl://[stuff]?"

    pwz = wcschr(wzlURL, ':');
    pwz++;
    if (!(wcsnicmp(pwz, L"//", 2) && wcsnicmp(pwz, L"\\\\", 2)))
    {
        // URL is of form (1)
        pwz = wcschr(pwz, '?');
        if( pwz == NULL ) {
            // error, no '?' found
            hr = MK_E_SYNTAX;
            goto Exit;
        }
        pwz++; // pwz now points to the start of the param list (start boundry)
    }

    pwzValue = pwz + wcslen( pwz ); // points to NULL


    // If there is a pound, NULL terminate there instead

    pwzPound = pwzValue - 1;

    while (pwzPound >= pwz)
    {
        if (*pwzPound == VALUE_POUND_CHAR)
        {
            *pwzPound = NULL;
            pwzValue = pwzPound;
            break;
        }
        pwzPound--;
    }

    for ( ;; )
    {
        while (pwzValue >= pwz && *pwzValue != VALUE_EQUAL_CHAR &&
               *pwzValue != VALUE_SEPARATOR_CHAR)
        {
            pwzValue--;
        }
        if (pwzValue < pwz || *pwzValue == VALUE_SEPARATOR_CHAR)
        {
            // error, expected '='
            hr = MK_E_SYNTAX;
            goto Exit;
        }

        // pwzValue now points to '='
        *pwzValue = NULL;
        pwzTag = pwzValue;
        pwzValue++;

        while (pwzTag >= pwz && *pwzTag != VALUE_EQUAL_CHAR &&
                                *pwzTag != VALUE_SEPARATOR_CHAR)
        {
            pwzTag--;
        }
        if (*pwzTag == VALUE_EQUAL_CHAR)
        {
            // error, expected either a separator, or the beginning
            hr = MK_E_SYNTAX;
            goto Exit;
        }
        pwzTag++;

        if (!wcsicmp(L"codebase", pwzTag))
        {
            cdldata.szURL = pwzValue;
        }
        else if (!wcsicmp(L"clsid", pwzTag))
        {
            cdldata.szClassString = pwzValue;
            fGotRequiredField = TRUE;
        }
        else if (!wcsicmp(L"mimetype", pwzTag))
        {
            cdldata.szMimeType = pwzValue;
            fGotRequiredField = TRUE;
        }
        else if (!wcsicmp(L"extension", pwzTag))
        {
            cdldata.szExtension = pwzValue;
            fGotRequiredField = TRUE;
        }
        else if (!wcsicmp(L"verMS", pwzTag))
        {
            //cdldata.dwFileVersionMS = _wtol(pwzValue);
            W2A(pwzValue, szValue, MAX_PATH);
            cdldata.dwFileVersionMS = atol(szValue);

        }
        else if (!wcsicmp(L"verLS", pwzTag))
        {
            //cdldata.dwFileVersionLS = _wtol(pwzValue);
            W2A(pwzValue, szValue, MAX_PATH);
            cdldata.dwFileVersionLS = atol(szValue);
        }
        else if (!wcsicmp(L"distunit", pwzTag))
        {
            cdldata.szDistUnit = pwzValue;
            fGotRequiredField = TRUE;
        }
        else if (!wcsicmp(L"flags", pwzTag))
        {
            cdldata.dwFlags = StrToIntW(pwzValue);
        }
        else if (!wcsicmp(L"version", pwzTag))
        {
            W2A(pwzValue, szValue, MAX_PATH);
            GetVersionFromString(szValue, &(cdldata.dwFileVersionMS), &(cdldata.dwFileVersionLS));
        }
        else if (!wcsicmp(L"dllname",pwzTag))
        {
            cdldata.szDll = pwzValue;
        }

        if (pwzTag <= pwz)
        {
            break; // we are done
        }
        else
        {
            pwzValue = pwzTag;
            pwzValue--;
            *pwzValue = NULL;
            pwzTag = NULL;
        }
    }

    // backwards compatability with clsid can be dist unit
    if(cdldata.szClassString && ! cdldata.szDistUnit)
    {
        cdldata.szDistUnit = cdldata.szClassString;
    }
    if(cdldata.szDistUnit && ! cdldata.szClassString)
    {
        cdldata.szClassString = cdldata.szDistUnit;
    }

    if (fGotRequiredField)
    {
        // The client must provide a host security manager for
        // CDL:// protocol bindings. Otherwise, a file:// URL codebase
        // will be executed without WVT UI.

        IInternetHostSecurityManager *phsm = NULL;
        IServiceProvider *psp = NULL;

        hr = _pProtSink->QueryInterface(IID_IServiceProvider,
                                        (void **)&psp);
        if (FAILED(hr)) {
            hr = TRUST_E_FAIL;
            goto Exit;
        }

        hr = psp->QueryService(IID_IInternetHostSecurityManager,
                               IID_IInternetHostSecurityManager, (void **)&phsm);

        if (FAILED(hr)) {
            hr = TRUST_E_FAIL;
            goto Exit;
        }

        psp->Release();
        phsm->Release();

        if (IsEqualGUID(_clsidReport , CLSID_NULL))
            CLSIDFromString((LPOLESTR)cdldata.szClassString, &_clsidReport);
        hr = StartDownload(cdldata);
    }
    else
    {
        hr = MK_E_SYNTAX;
    }

Exit:

    // if we error for any reason here, then CodeDL BSC was never initiated and we will
    // never get an BSC::OSB to shut up sink.

    if (hr != E_PENDING)
    {
        _fDataPending = FALSE;

        if (_pProtSink)
        {
            if (!IsEqualGUID(_clsidReport, CLSID_NULL))
            {
                LPOLESTR pwzStrClsId;
                StringFromCLSID(_clsidReport, &pwzStrClsId);
                _pProtSink->ReportProgress(BINDSTATUS_CLSIDCANINSTANTIATE, pwzStrClsId);

                delete [] pwzStrClsId;
            }

            _pProtSink->ReportResult(hr, 0, 0);
        }
    }

    EProtDebugOut((DEB_PLUGPROT, "%p OUT CCdlProtocol::ParseURL\n", this));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CCdlProtocol::StartDownload
//
//  Synopsis:
//
//  Arguments:
//
//
//
//  Returns:
//
//  History:    02-06-1997   t-alans (Alan Shi)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CCdlProtocol::StartDownload(CodeDownloadData &cdldata)
{
    EProtDebugOut((DEB_PLUGPROT, "%p _IN CCdlProtocol::StartDownload\n", this));
    HRESULT               hr  = S_OK;
    IBindCtx             *pbc = NULL;
    IUnknown             *pUnk = NULL;

// Kick off the download

    _pCodeDLBSC = new CCodeDLBSC(_pProtSink, _pOIBindInfo, this, _fGetClassObject);
    if (_pCodeDLBSC == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }
    hr = CreateBindCtx(0, &pbc);
    if (SUCCEEDED(hr))
    {
        hr = RegisterBindStatusCallback(pbc, _pCodeDLBSC, NULL, 0);
        if (_pCodeDLBSC != NULL)
        {
            _pCodeDLBSC->Release();
        }
        if (FAILED(hr))
        {
            goto Exit;
        }
    }

    cdldata.dwFlags = (_fGetClassObject) ? (CD_FLAGS_NEED_CLASSFACTORY) : (0);

    hr = AsyncInstallDistributionUnitEx(&cdldata, pbc, _iid, &pUnk, NULL);

    if (hr == MK_S_ASYNCHRONOUS)
    {
        hr = E_PENDING;
    }
    else
    {
        if (_fGetClassObject)
        {
            if (pUnk && SUCCEEDED(hr))
            {
                hr = RegisterIUnknown(pUnk);
                pUnk->Release();

                if (SUCCEEDED(hr))
                {
                    hr = _pProtSink->ReportProgress(BINDSTATUS_IUNKNOWNAVAILABLE, NULL);
                }
            }
            _pProtSink->ReportResult(hr, 0, 0);
        }
    }

Exit:
    if (pbc != NULL)
    {
        // NOTE: This instruction can cause deletion of this object,
        // referencing "this" afterwords may be a bad idea.
        pbc->Release();
    }

    EProtDebugOut((DEB_PLUGPROT, "%p OUT CCdlProtocol::StartDownload\n", this));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CCdlProtocol::SetDataPending
//
//  Synopsis:
//
//  Arguments:
//
//
//
//  Returns:
//
//  History:    02-06-1997   t-alans (Alan Shi)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void CCdlProtocol::SetDataPending(BOOL fPending)
{
    _fDataPending = fPending;
}

//+---------------------------------------------------------------------------
//
//  Method:     CCdlProtocol::RegisterIUnknown
//
//  Synopsis:
//
//  Arguments:
//
//
//
//  Returns:
//
//  History:    11-12-1998   AlanShi (Alan Shi)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

HRESULT CCdlProtocol::RegisterIUnknown(IUnknown *pUnk)
{
    EProtAssert(_pbc);

    return _pbc->RegisterObjectParam(SZ_IUNKNOWN_PTR, pUnk);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\eapp\guids.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       GUIDS.C
//
//  Contents:   Defines GUIDS used in this DLL.
//
//  Classes:
//
//  Functions:
//
//  History:    11-02-95   JoeS (Joe Souza)     Created
//
//----------------------------------------------------------------------------
//#include <urlint.h>


#ifdef __cplusplus
extern "C" {
#endif


#ifndef GUID_DEFINED
#define GUID_DEFINED

typedef struct _GUID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} GUID;
#endif // GUID_DEFINED

const GUID CLSID_UMkSrvDll =
{
    0x79ead9d0, 0xbaf9, 0x11ce, {0x8c, 0x82, 0x00, 0xaa, 0x00, 0x4b, 0xa9, 0x0b }
};

const GUID IID_IDebugRegister       = { 0xc733e4f0, 0x576e, 0x11d0, {0xb2, 0x8c, 0x00, 0xc0, 0x4f, 0xd7, 0xcd, 0x22} };
const GUID IID_IDebugOut            = { 0xc733e4f1, 0x576e, 0x11d0, {0xb2, 0x8c, 0x00, 0xc0, 0x4f, 0xd7, 0xcd, 0x22} };

// Notification sink texs class ids
const GUID CLSID_NotificaitonTest1  = {0xc733e501, 0x576e, 0x11d0, {0xb2, 0x8c, 0x00, 0xc0, 0x4f, 0xd7, 0xcd, 0x22}};
const GUID CLSID_NotificaitonTest2  = {0xc733e502, 0x576e, 0x11d0, {0xb2, 0x8c, 0x00, 0xc0, 0x4f, 0xd7, 0xcd, 0x22}};
const GUID CLSID_NotificaitonTest3  = {0xc733e503, 0x576e, 0x11d0, {0xb2, 0x8c, 0x00, 0xc0, 0x4f, 0xd7, 0xcd, 0x22}};
const GUID CLSID_NotificaitonTest4  = {0xc733e504, 0x576e, 0x11d0, {0xb2, 0x8c, 0x00, 0xc0, 0x4f, 0xd7, 0xcd, 0x22}};


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\eapp\notfsink.cxx ===
#include <eapp.h>

extern "C" const GUID IID_IDebugRegister;
extern "C" const GUID IID_IDebugOut;

#if DBG==1
HRESULT DumpIID(REFIID riid)
{

    HRESULT hr;
    LPOLESTR pszStr = NULL;
    hr = StringFromCLSID(riid, &pszStr);
    EProtDebugOut((DEB_NOTFSINK, "API >>> DumpIID (riid:%ws) \n", pszStr));

    if (pszStr)
    {
        delete pszStr;
    }
    return hr;
}
#else
#define DumpIID(x)
#endif


HRESULT CreateNotificationTest(DWORD dwId, REFCLSID rclsid, IUnknown *pUnkOuter, REFIID riid, IUnknown **ppUnk)
{
    EProtDebugOut((DEB_NOTFSINK, "API _IN CreateKnownProtocolInstance\n"));
    HRESULT hr = NOERROR;

    EProtAssert(( (dwId == 0) && ppUnk));

    do
    {
        if (!ppUnk)
        {
            // Note: aggregation only works if asked for IUnknown
            EProtAssert((FALSE && "Dude, need out parameter"));
            hr = E_INVALIDARG;
            break;
        }

        if (pUnkOuter)
        {
            hr = CLASS_E_NOAGGREGATION;
            break;
        }

        CNotfSink *pNotfSink = new CNotfSink(L"Notificaion Sink");

        if (pNotfSink)
        {
            hr = pNotfSink->QueryInterface(riid, (void **)ppUnk);
            // remove extra refcount
            pNotfSink->Release();
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }

        break;
    } while (TRUE);



    EProtDebugOut((DEB_NOTFSINK, "API OUT CreateKnownProtocolInstance(hr:%lx)\n", hr));
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CNotfSink::QueryInterface
//
//  Synopsis:
//
//  Arguments:  [riid] --
//              [ppvObj] --
//
//  Returns:
//
//  History:    11-22-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CNotfSink::QueryInterface(REFIID riid, void **ppvObj)
{
    VDATEPTROUT(ppvObj, void *);
    VDATETHIS(this);
    HRESULT hr = NOERROR;

    EProtDebugOut((DEB_NOTFSINK,  "%p _IN CNotfSink::QueryInterface\n", this));
    EProtAssert(( IsApartmentThread() ));

    *ppvObj = NULL;
    if ((riid == IID_IUnknown) || (riid == IID_INotificationSink) )
    {
        *ppvObj = this;
        AddRef();
    }
    else if ((riid == IID_IDebugRegister) )
    {
        *ppvObj = (IDebugRegister *) this;
        AddRef();
    }
    else
    {
        hr = E_NOINTERFACE;
    }

    EProtDebugOut((DEB_NOTFSINK,  "%p OUT CNotfSink::QueryInterface (hr:%lx\n", this,hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   CNotfSink::AddRef
//
//  Synopsis:
//
//  Arguments:  [ULONG] --
//
//  Returns:
//
//  History:    11-22-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CNotfSink::AddRef(void)
{
    EProtDebugOut((DEB_NOTFSINK,  "%p _IN CNotfSink::AddRef\n", this));
    EProtAssert(( IsApartmentThread() ));

    LONG lRet = ++_CRefs;

    EProtDebugOut((DEB_NOTFSINK,  "%p OUT CNotfSink::AddRef (cRefs:%ld)\n", this,lRet));
    return lRet;
}

//+---------------------------------------------------------------------------
//
//  Function:   CNotfSink::Release
//
//  Synopsis:
//
//  Arguments:  [ULONG] --
//
//  Returns:
//
//  History:    11-22-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CNotfSink::Release(void)
{
    EProtDebugOut((DEB_NOTFSINK,  "%p _IN CNotfSink::Release\n", this));
    EProtAssert(( IsApartmentThread() ));

    LONG lRet = --_CRefs;

    if (_CRefs == 0)
    {
        delete this;
    }

    EProtDebugOut((DEB_NOTFSINK,  "%p OUT CNotfSink::Release (cRefs:%ld)\n",this,lRet));
    return lRet;
}


//+---------------------------------------------------------------------------
//
//  Method:     CNotfSink::OnNotification
//
//  Synopsis:
//
//  Arguments:  [itemtype] --
//              [pWChkItem] --
//              [dwReserved] --
//
//  Returns:
//
//  History:    12-02-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CNotfSink::OnNotification(
                // the notification object itself
                LPNOTIFICATION          pNotification,
                // the cookie of the object the notification is targeted too
                //PNOTIFICATIONCOOKIE     pRunningNotfCookie,
                // flags how it was delivered and how it should
                // be processed
                //NOTIFICATIONFLAGS       grfNotification,
                // the report sink if - can be NULL
                LPNOTIFICATIONREPORT    pNotfctnReport,
                DWORD                   dwReserved
                )
{
    EProtDebugOut((DEB_NOTFSINK, "%p _IN CNotfSink::OnNotification\n", this));
    EProtAssert(( IsApartmentThread() ));
    EProtAssert((pNotification));
    HRESULT hr = NOERROR;
    LPOLESTR pszStr = NULL;
    NOTIFICATIONTYPE notfType;
    NOTIFICATIONCOOKIE notfCookie;

    PNOTIFICATIONCOOKIE     pRunningNotfCookie = 0;
    // flags how it was delivered and how it should
    // be processed
    NOTIFICATIONFLAGS       grfNotification = (NOTIFICATIONFLAGS)0;

    //hr = pNotification->GetNotificationType(&notfType);
    hr = pNotification->GetNotificationInfo(&notfType, &notfCookie, 0, 0, 0);

    if (hr == NOERROR)
    {
        hr = StringFromCLSID(notfType, &pszStr);
    }

    EProtDebugOut((DEB_NOTFSINK, "%p CNotfSink:%ws received pNotification:%p\n         with id:%ws\n", this, _pwzName, pNotification,pszStr));
    //EProtDebugOut((DEB_NOTFSINK, "%p CNotfSink:%ws received pNotification:%p \n", this, _pwzName, pNotification));
    MessageBeep(1000);

    if (pszStr)
    {
        delete pszStr;
    }

    /*
    if (pNotification->pCustomData != 0)
    {
        IDebugOut *pDbgOut = 0;
        char szOutBuffer[256];

        pDbgOut = (IDebugOut *) pNotification->pCustomData;

        sprintf(szOutBuffer, "%p CNotfSink:%ws received pNotification:%p with id:%ws\n", this, _pwzName, pNotification,  pNotification->pNotificationid);

        pDbgOut->SendEntry(GetCurrentThreadId(), 0, szOutBuffer, 0);
    }
    */

    // don't return an error!
    hr = NOERROR;

    EProtDebugOut((DEB_NOTFSINK,  "%p OUT CNotfSink::OnNotification (hr:%lx)\n",this, hr));
    return hr;
}

STDMETHODIMP CNotfSink::GetFacilities (LPCWSTR *ppwzNames, DWORD *pcNames, DWORD dwReserved)
{
    EProtDebugOut((DEB_NOTFSINK, "%p _IN CNotfSink::GetFacilities\n", this));
    EProtAssert(( IsApartmentThread() ));
    EProtAssert(( ppwzNames && pcNames ));

    HRESULT hr = NOERROR;

    ppwzNames = v_gDbgFacilitieNames;
    LONG x = sizeof(*v_gDbgFacilitieNames);
    LONG y = sizeof(LPCWSTR);

    *pcNames = (sizeof(*v_gDbgFacilitieNames)/sizeof(LPCWSTR));

    EProtDebugOut((DEB_NOTFSINK,  "%p OUT CNotfSink::GetFacilities (hr:%lx)\n",this, hr));
    return hr;
}

STDMETHODIMP CNotfSink::Register ( LPCWSTR pwzName, IDebugOut *pDbgOut, DWORD dwFlags, DWORD dwReserved)
{
    EProtDebugOut((DEB_NOTFSINK, "%p _IN CNotfSink::Register\n", this));
    EProtAssert(( IsApartmentThread() ));
    HRESULT hr = NOERROR;

    hr = RegisterDebugOut(pwzName, dwFlags, pDbgOut, dwReserved);

    EProtDebugOut((DEB_NOTFSINK,  "%p OUT CNotfSink::Register (hr:%lx)\n",this, hr));
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\eapp\multicst.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       resprot.cxx
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    11-07-1996   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------
#include <eapp.h>
#include <tchar.h>

#define MAX_ID 10000

#define WITH_TAGS

//+---------------------------------------------------------------------------
//
//  Method:     CMulticastProtocol::Start
//
//  Synopsis:
//
//  Arguments:  [pwzUrl] --
//              [pTrans] --
//              [pOIBindInfo] --
//              [grfSTI] --
//              [dwReserved] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CMulticastProtocol::Start(LPCWSTR pwzUrl, IOInetProtocolSink *pTrans, IOInetBindInfo *pOIBindInfo,
                          DWORD grfSTI, DWORD dwReserved)
{
    EProtDebugOut((DEB_PLUGPROT, "%p _IN CMulticastProtocol::Start\n", this));
    HRESULT hr = NOERROR;
    WCHAR    wzURL[MAX_URL_SIZE];

    EProtAssert((!_pProtSink && pOIBindInfo && pTrans));
    EProtAssert((_pwzUrl == NULL));

    hr = CBaseProtocol::Start(pwzUrl,pTrans, pOIBindInfo, grfSTI, dwReserved);

    if ( (grfSTI & PI_PARSE_URL) )
    {
        hr =  ParseAndBind(FALSE);
    }
    else if (hr == NOERROR)
    {
        // asked to go async as soon as possible
        // use the switch mechanism which will \
        // call back later on ::Continue
        if (grfSTI & PI_FORCE_ASYNC)
        {
            hr = E_PENDING;
            PROTOCOLDATA protdata;
            protdata.grfFlags = PI_FORCE_ASYNC;
            protdata.dwState = RES_STATE_BIND;
            protdata.pData = 0;
            protdata.cbData = 0;

            _pProtSink->Switch(&protdata);
        }
        else
        {
            hr =  ParseAndBind(TRUE);
        }
    }

    EProtDebugOut((DEB_PLUGPROT, "%p OUT CMulticastProtocol::Start (hr:%lx)\n",this, hr));
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CMulticastProtocol::Continue
//
//  Synopsis:
//
//  Arguments:  [pStateInfoIn] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CMulticastProtocol::Continue(PROTOCOLDATA *pStateInfoIn)
{
    EProtDebugOut((DEB_PLUGPROT, "%p _IN CMulticastProtocol::Continue\n", this));
    HRESULT hr = E_FAIL;

    EProtAssert((!pStateInfoIn->pData && pStateInfoIn->cbData && (pStateInfoIn->dwState == RES_STATE_BIND)));

    if (pStateInfoIn->dwState == RES_STATE_BIND)
    {
        hr =  ParseAndBind();
    }

    EProtDebugOut((DEB_PLUGPROT, "%p OUT CMulticastProtocol::Continue (hr:%lx)\n",this, hr));
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CMulticastProtocol::Read
//
//  Synopsis:
//
//  Arguments:  [ULONG] --
//              [ULONG] --
//              [pcbRead] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CMulticastProtocol::Read(void *pv,ULONG cb,ULONG *pcbRead)
{
    EProtDebugOut((DEB_PLUGPROT, "%p _IN CMulticastProtocol::Read (cb:%ld)\n", this,cb));
    HRESULT hr = NOERROR;

    if (_cbBuffer > _cbPos)
    {
        ULONG cbCopy = (cb < (_cbBuffer - _cbPos)) ? cb :  _cbBuffer - _cbPos;

        memcpy((LPVOID)pv, ((LPBYTE)_pBuffer) + _cbPos, cbCopy);

        _cbPos += cbCopy;

        *pcbRead = cbCopy;

        hr =  (_cbPos < _cbBuffer) ? S_OK : S_FALSE;
    }
    else
    {
        hr = S_FALSE;
    }

    EProtDebugOut((DEB_PLUGPROT, "%p OUT CMulticastProtocol::Read (pcbRead:%ld, hr:%lx)\n",this,*pcbRead, hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CMulticastProtocol::Seek
//
//  Synopsis:
//
//  Arguments:  [DWORD] --
//              [ULARGE_INTEGER] --
//              [plibNewPosition] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:      WORK: not done
//
//----------------------------------------------------------------------------
STDMETHODIMP CMulticastProtocol::Seek(LARGE_INTEGER dlibMove,DWORD dwOrigin,ULARGE_INTEGER *plibNewPosition)
{
    EProtDebugOut((DEB_PLUGPROT, "%p _IN CMulticastProtocol::Seek\n", this));
    HRESULT hr = NOERROR;

    if (dwOrigin == STREAM_SEEK_SET)
    {
        if (dlibMove.LowPart >= 0)
        {
            _cbPos = dlibMove.LowPart;

            if (plibNewPosition)
            {
                plibNewPosition->HighPart = 0;
                plibNewPosition->LowPart = _cbPos;
            }
        }
        else
        {
            hr = STG_E_INVALIDPOINTER;
        }
    }
    else
    {
        hr = E_NOTIMPL;
    }

    EProtDebugOut((DEB_PLUGPROT, "%p OUT CMulticastProtocol::Seek (hr:%lx)\n",this, hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CMulticastProtocol::LockRequest
//
//  Synopsis:
//
//  Arguments:  [dwOptions] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CMulticastProtocol::LockRequest(DWORD dwOptions)
{
    EProtDebugOut((DEB_PLUGPROT, "%p _IN CMulticastProtocol::LockRequest\n", this));

    HRESULT hr = NOERROR;

    if (OpenTempFile())
    {
        DWORD dwWrite;
        if (!WriteFile(_hFile, _pBuffer, _cbBuffer, &dwWrite,NULL))
        {
            hr = E_FAIL;
        }
        CloseTempFile();
    }

    EProtDebugOut((DEB_PLUGPROT, "%p OUT CMulticastProtocol::LockRequest (hr:%lx)\n",this, hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CMulticastProtocol::UnlockRequest
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CMulticastProtocol::UnlockRequest()
{
    EProtDebugOut((DEB_PLUGPROT, "%p _IN CMulticastProtocol::UnlockRequest\n", this));
    HRESULT hr = NOERROR;

    //CloseTempFile();

    EProtDebugOut((DEB_PLUGPROT, "%p OUT CMulticastProtocol::UnlockRequest (hr:%lx)\n",this, hr));
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CMulticastProtocol::CMulticastProtocol
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    1-27-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
CMulticastProtocol::CMulticastProtocol(REFCLSID rclsid, IUnknown *pUnkOuter, IUnknown **ppUnkInner) : CBaseProtocol(rclsid, pUnkOuter, ppUnkInner)
{
    EProtDebugOut((DEB_PLUGPROT, "%p _IN CMulticastProtocol::CMulticastProtocol \n", this));

    _hInst = NULL;
    _cbBuffer = 0;
    _pBuffer = 0;
    _hgbl = 0;
    _cbPos = 0;

    EProtDebugOut((DEB_PLUGPROT, "%p OUT CMulticastProtocol::CMulticastProtocol \n", this));
}

//+---------------------------------------------------------------------------
//
//  Method:     CMulticastProtocol::~CMulticastProtocol
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    11-09-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
CMulticastProtocol::~CMulticastProtocol()
{

    if (_hgbl)
    {
        UnlockResource(_hgbl);
    }
    if (_hInst)
    {
        FreeLibrary(_hInst);
    }

    EProtDebugOut((DEB_PLUGPROT, "%p _IN/OUT CMulticastProtocol::~CMulticastProtocol \n", this));
}

//+---------------------------------------------------------------------------
//
//  Method:     CMulticastProtocol::GetResource
//
//  Synopsis:
//
//  Arguments:  [pwzFileName] --
//              [pwzResName] --
//              [pwzResType] --
//
//  Returns:
//
//  History:    11-09-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CMulticastProtocol::GetResource(LPCWSTR pwzFileName, LPCWSTR pwzResName, LPCWSTR pwzResType, LPCWSTR pwzMime)
{
    EProtDebugOut((DEB_PLUGPROT, "CMulticastProtocol::GetResource\n)"));
    HRESULT     hr = NOERROR;
    DWORD       dwError = 0;
    HRSRC       hrsrc;

    LPSTR pszFileName =  DupW2A(pwzFileName );
    LPSTR pszResName  =  DupW2A(pwzResName  );
    LPSTR pszResType  =  DupW2A(pwzResType  );


    if (!pszFileName || !pszResName || !pszResType)
    {
        hr = E_OUTOFMEMORY;
    }
    else do
    {
        _pProtSink->ReportProgress(BINDSTATUS_SENDINGREQUEST, pwzResName);

        _hInst = LoadLibraryEx(pszFileName, NULL, DONT_RESOLVE_DLL_REFERENCES);
        if (!_hInst)
        {
            hr = INET_E_RESOURCE_NOT_FOUND;
            dwError = GetLastError();
            break;
        }

        if (!wcscmp(pwzResName, L"?"))
        {
            for (int i = 0 ; i < MAX_ID; i++)
            {
                hrsrc = FindResource(_hInst, (LPSTR)MAKEINTRESOURCE(i), pszResType);

                if (hrsrc)
                {
                    EProtDebugOut((DEB_PLUGPROT, "CMulticastProtocol::GetResource (szResName:#%ld, wzRestype:%s\n)",i,pszResType));
                    i = MAX_ID;
                }
            }
        }
        else
        {
            hrsrc = FindResource(_hInst, pszResName, pszResType);
        }

        if (!hrsrc)
        {
            hr = INET_E_OBJECT_NOT_FOUND;
            dwError = GetLastError();
            break;
        }

        _hgbl = LoadResource(_hInst, hrsrc);
        if (!_hgbl)
        {
            hr = INET_E_DATA_NOT_AVAILABLE;
            dwError = GetLastError();
            break;
        }

        _pBuffer = LockResource(_hgbl);
        if (!_pBuffer)
        {
            hr = INET_E_DATA_NOT_AVAILABLE;
            dwError = GetLastError();
            break;
        }

        _cbBuffer = SizeofResource(_hInst, hrsrc);


        if (_grfBindF & INTERNET_FLAG_NEED_FILE)
        {
            LockRequest(0);
        }

#ifdef UNUSED
        if (OpenTempFile())
        {
            DWORD dwWrite;
            if (!WriteFile(_hFile, _pBuffer, _cbBuffer, &dwWrite,NULL))
            {
                dwError = GetLastError();
                break;
            }
            CloseTempFile();
        }
#endif //UNUSED

        hr = NOERROR;
        break;

    }  while (1);

    if (dwError || (hr != NOERROR))
    {
        _pProtSink->ReportResult(hr, dwError, 0);
    }
    else
    {
        if (pwzMime)
        {
            _pProtSink->ReportProgress(BINDSTATUS_MIMETYPEAVAILABLE, pwzMime);
        }

        _bscf |= BSCF_LASTDATANOTIFICATION | BSCF_DATAFULLYAVAILABLE;
        _pProtSink->ReportData(_bscf, _cbBuffer, _cbBuffer);
    }

    if (pszFileName)
    {
        delete pszFileName;
    }

    if (pszResName)
    {
        delete pszResName;
    }

    if (pszResType)
    {
        delete pszResType;
    }


    EProtDebugOut((DEB_PLUGPROT, "%p OUT CMulticastProtocol::GetResource (hr:%lx)\n",this, hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CMulticastProtocol::ParseAndBind
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    11-09-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CMulticastProtocol::ParseAndBind(BOOL fBind)
{
    EProtDebugOut((DEB_PLUGPROT, "%p _IN CMulticastProtocol::ParseAndBind\n", this));

    HRESULT hr = MK_E_SYNTAX;

    WCHAR wzlURL[MAX_URL_SIZE];

    wcscpy(wzlURL, _wzFullURL);


    do
    {
        // check if protocol part
        LPWSTR pwz = wcschr(wzlURL, ':');

        pwz++;

        if (wcsnicmp(pwz, L"//", 2) && wcsnicmp(pwz, L"\\\\", 2))
        {
            break;
        }

        // find the file name and path
        LPWSTR pwzFileName = pwz + 2;

        EProtAssert((pwzFileName));

        // the file is
        LPWSTR pwz1 = wcsrchr(wzlURL, '/');

        if (!pwz1)
        {
            break;
        }

        *pwz1 = '\0';
        pwz1++;

        if (!*pwz1)
        {
            break;
        }
#ifdef WITH_TAGS
        LPWSTR pwzResDelimiter = wcschr(pwz1, '?');

        if (!pwzResDelimiter)
        {
            break;
        }

        LPWSTR pwzResTag = wcsstr(pwz1, L"name:");

        if (!pwzResTag)
        {
            break;
        }

        LPWSTR pwzTypeTag = wcsstr(pwz1, L"type:");

        if (!pwzTypeTag)
        {
            break;
        }

        LPWSTR pwzMimeTag = wcsstr(pwz1, L"mime:");

        // get the resource name
        LPWSTR pwzResName = wcschr(pwzResTag, ':');
        pwzResName++;

        //find the end of the resource name
        LPWSTR pwzResType = wcschr(pwzTypeTag, ':');
        pwzResType++;

        LPWSTR pwzMime = 0;
        if (pwzMimeTag)
        {
            pwzMime = wcschr(pwzMimeTag, ':');
            pwzMime++;
            *pwzMimeTag = 0;
        }

        *pwzResTag = 0;
        *pwzTypeTag = 0;


#else
        // find the delimiter for the private part
        LPWSTR pwzResName = wcschr(pwz1, '?');

        if (!pwzResName)
        {
            break;
        }

        // get the resource name
        pwzResName++;

        //find the end of the resource name
        LPWSTR pwzResType = wcschr(pwzResName, ' ');

        if (!pwzResType)
        {
            break;
        }

        *pwzResType = '\0';
        pwzResType++;
        EProtDebugOut((DEB_PLUGPROT, "CMulticastProtocol::GetResource (wzResName:%ws,pwzResType:%ws\n)",pwzResName,pwzResType));


        /*
        {
            pwzResType =  (LPWSTR)MAKEINTRESOURCE(RT_ICON);
            EProtDebugOut((DEB_PLUGPROT, "CMulticastProtocol::GetResource (wzResName:%ws,pwzResType:RT_ICON\n)",pwzResName));
        }
        */
#endif //WITH_TAGS


        EProtAssert(((WCHAR *)pwzFileName && (WCHAR *)pwzResName));
        if (fBind && pwzFileName && pwzResName && pwzResType)
        {
            hr = GetResource(pwzFileName, pwzResName, pwzResType, pwzMime);
        }

        break;

    }  while (1);


    if (hr == MK_E_SYNTAX)
    {
        _pProtSink->ReportResult(hr, 0, 0);
    }

    EProtDebugOut((DEB_PLUGPROT, "%p OUT CMulticastProtocol::ParseAndBind (hr:%lx)\n", this,hr));
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\eapp\knownhnd.cxx ===
#include <eapp.h>

typedef struct tagHandlerInfo
{
    LPWSTR          pwzHandler;
    DWORD           dwId;
    CLSID           *pClsID;
} HandlerInfo;


HandlerInfo rgKnownHandlers[] =
{
     { L"gzip" ,                    1,  (CLSID *) &CLSID_DeCompMimeFilter }
    ,{ L"deflate",                  2,  (CLSID *) &CLSID_DeCompMimeFilter }
    ,{ L"Class Install Handler",    3,  (CLSID *) &CLSID_ClassInstallFilter }
    ,{ L"cdl",                      4,  (CLSID *) &CLSID_CdlProtocol }
};


//+---------------------------------------------------------------------------
//
//  Function:   IsKnownHandler
//
//  Synopsis:   looks up if the Known Handler 
//
//  Arguments:  [wzHandler] --
//
//  Returns:    
//
//  History:    07-17-97   DanpoZ (Danpo Zhang)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD IsKnownHandler(LPCWSTR wzHandler)
{
    DWORD dwRet = 0;
    int i = 0;
    int cSize = sizeof(rgKnownHandlers)/sizeof(HandlerInfo);

    for (i = 0; i < cSize; ++i)
    {
        if (!_wcsicmp(wzHandler, rgKnownHandlers[i].pwzHandler) )
        {
            dwRet = rgKnownHandlers[i].dwId;
            i = cSize;
        }
    }
    return dwRet;
}

//+---------------------------------------------------------------------------
//
//  Function:   GetKnownHandlerClsID
//
//  Synopsis:
//
//  Arguments:  [dwId] --
//
//  Returns:
//
//  History:    07-17-1997   DanpoZ (Danpo Zhang)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
CLSID *GetKnownHandlerClsID(DWORD dwId)
{
    CLSID *pclsid = 0;
    int cSize = sizeof(rgKnownHandlers)/sizeof(HandlerInfo);

    for (int i = 0; i < cSize; ++i)
    {
        if (dwId == rgKnownHandlers[i].dwId )
        {
            pclsid = rgKnownHandlers[i].pClsID;
            i = cSize;
        }
    }

    return pclsid;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\eapp\mimehndl.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       mimehndl.cxx
//
//  Contents:   Class that performs the download of a particular request.
//
//  Classes:
//
//  Functions:
//
//  History:    12-04-95   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------
#include <eapp.h>


PerfDbgTag(tagCTransaction,    "Urlmon", "Log CTransaction",        DEB_TRANS)
    DbgTag(tagCTransactionErr, "Urlmon", "Log CTransaction Errors", DEB_TRANS|DEB_ERROR)
   
typedef struct _tagPROTOCOLFILTERDATA
{
    DWORD               cbSize;
    IOInetProtocolSink *pProtocolSink;  // out parameter
    IOInetProtocol     *pProtocol;      // in parameter
    IUnknown           *pUnk;
    DWORD               dwFilterFlags;  
} PROTOCOLFILTERDATA;


CMimeHandlerTest1::CMimeHandlerTest1(REFCLSID rclsid, IUnknown *pUnkOuter, IUnknown **ppUnkInner) : CBaseProtocol(rclsid, pUnkOuter, ppUnkInner)
{
    _pUnk = 0;
    _pProt = 0;
    _pProtSnk = 0;
    _dwMode = 0;
    _dwOInetBdgFlags = 0;
    _pBuffer = 0;           // DNLD_BUFFER_SIZE  size buffer
    _cbBufferSize = 0;
    _cbTotalBytesRead = 0;
    _cbBufferFilled = 0;    //how much of the buffer is in use
    _cbDataSniffMin = 0;
    _cbBytesReported = 0;
    _fDocFile = 0;
    _fMimeVerified = 0;
    _pwzFileName = 0;
    _pwzMimeSuggested = 0;
    _fDelete = 0;

}


//+---------------------------------------------------------------------------
//
//  Method:     CMimeHandlerTest1::QueryInterface
//
//  Synopsis:
//
//  Arguments:  [riid] --
//              [ppvObj] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CMimeHandlerTest1::QueryInterface(REFIID riid, void **ppvObj)
{
    VDATEPTROUT(ppvObj, void *);
    VDATETHIS(this);
    HRESULT hr = NOERROR;

    PerfDbgLog(tagCTransaction, this, "+CMimeHandlerTest1::QueryInterface");

    *ppvObj = NULL;

    {
        if (   (riid == IID_IUnknown)
            || (riid == IID_IOInetProtocol))
        {
            *ppvObj = (IOInetProtocol *) this;
            AddRef();
        }
        else if (riid == IID_IOInetProtocolSink)
        {
            *ppvObj = (IOInetProtocolSink *) this;
            AddRef();
        }
        else
        {
            hr = E_NOINTERFACE;
        }
    }


    PerfDbgLog1(tagCTransaction, this, "-CMimeHandlerTest1::QueryInterface (hr:%lx)", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   CMimeHandlerTest1::AddRef
//
//  Synopsis:
//
//  Arguments:  [ULONG] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CMimeHandlerTest1::AddRef(void)
{
    PerfDbgLog(tagCTransaction, this, "+CMimeHandlerTest1::AddRef");

    LONG lRet;
  
    {
        lRet = ++_CRefs;
    }
    
    PerfDbgLog1(tagCTransaction, this, "-CMimeHandlerTest1::AddRef (cRefs:%ld)", lRet);
    return lRet;
}

//+---------------------------------------------------------------------------
//
//  Function:   CMimeHandlerTest1::Release
//
//  Synopsis:
//
//  Arguments:  [ULONG] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CMimeHandlerTest1::Release(void)
{
    PerfDbgLog(tagCTransaction, this, "+CMimeHandlerTest1::Release");

    LONG lRet;
    {
        lRet = --_CRefs;
        if (_CRefs == 0 && _fDelete)
        {
            delete this;
        }
    }

    PerfDbgLog1(tagCTransaction, this, "-CMimeHandlerTest1::Release (cRefs:%ld)", lRet);
    return lRet;
}

//+---------------------------------------------------------------------------
//
//  Method:     CMimeHandlerTest1::Start
//
//  Synopsis:
//
//  Arguments:  [pwzUrl] --
//              [pTrans] --
//              [pOIBindInfo] --
//              [grfSTI] --
//              [dwReserved] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CMimeHandlerTest1::Start(LPCWSTR pwzUrl, IOInetProtocolSink *pOInetProtSnk, IOInetBindInfo *pOIBindInfo,
                          DWORD grfSTI, DWORD dwReserved)
{
    PerfDbgLog(tagCTransaction, this, "+CMimeHandlerTest1::Start\n");
    HRESULT hr = NOERROR;
    PROTOCOLFILTERDATA *pFilterData = 0;

    TransAssert((pOIBindInfo && pOInetProtSnk));
    if (dwReserved)
    {
        pFilterData = (PROTOCOLFILTERDATA *)dwReserved;
    }
    if (pFilterData && pOInetProtSnk)
    {
        TransAssert((pOIBindInfo && pOInetProtSnk));
        _pProt = pFilterData->pProtocol;
        if (_pProt)
        {
            _pProt->AddRef();
        }
        else
        {
            hr = E_FAIL;
        }
        _pProtSnk = pOInetProtSnk;
        _pProtSnk->AddRef();
    }
    else
    {
        hr = E_FAIL;
    }

    PerfDbgLog1(tagCTransaction, this, "+CMimeHandlerTest1::Start (hr:%lx)\n", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CMimeHandlerTest1::Continue
//
//  Synopsis:
//
//  Arguments:  [pStateInfoIn] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CMimeHandlerTest1::Continue(PROTOCOLDATA *pStateInfoIn)
{
    PerfDbgLog(tagCTransaction, this, "+CMimeHandlerTest1::Continue\n");

    HRESULT hr = _pProt->Continue(pStateInfoIn);

    PerfDbgLog1(tagCTransaction, this, "-CMimeHandlerTest1::Continue (hr:%lx)\n",hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CMimeHandlerTest1::Abort
//
//  Synopsis:
//
//  Arguments:  [hrReason] --
//              [dwOptions] --
//
//  Returns:
//
//  History:    11-09-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CMimeHandlerTest1::Abort(HRESULT hrReason, DWORD dwOptions)
{
    PerfDbgLog(tagCTransaction, this, "+CMimeHandlerTest1::Abort\n");
    HRESULT hr = NOERROR;

    hr = _pProt->Abort(hrReason, dwOptions);

    PerfDbgLog1(tagCTransaction, this, "-CMimeHandlerTest1::Abort (hr:%lx)\n", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CMimeHandlerTest1::Terminate
//
//  Synopsis:
//
//  Arguments:  [dwOptions] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CMimeHandlerTest1::Terminate(DWORD dwOptions)
{
    PerfDbgLog(tagCTransaction, this, "+CMimeHandlerTest1::Terminate\n");
    HRESULT hr = NOERROR;

    TransAssert((_pProt));
    //IOInetProtocol *pProt = _pProt;
    
    hr = _pProt->Terminate(dwOptions);
    //pProt->Release();
    //_pProt = 0;

    _pProtSnk->Release();
    _pProtSnk = 0;
    
    PerfDbgLog1(tagCTransaction, this, "-CMimeHandlerTest1::Terminate (hr:%lx)\n", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CMimeHandlerTest1::Suspend
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CMimeHandlerTest1::Suspend()
{
    PerfDbgLog(tagCTransaction, this, "+CMimeHandlerTest1::Suspend\n");

    HRESULT hr = _pProt->Suspend();

    PerfDbgLog1(tagCTransaction, this, "-CMimeHandlerTest1::Suspend (hr:%lx)\n", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CMimeHandlerTest1::Resume
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CMimeHandlerTest1::Resume()
{
    PerfDbgLog(tagCTransaction, this, "+CMimeHandlerTest1::Resume\n");

    HRESULT hr = _pProt->Resume();

    PerfDbgLog1(tagCTransaction, this, "-CMimeHandlerTest1::Resume (hr:%lx)\n", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CMimeHandlerTest1::Read
//
//  Synopsis:
//
//  Arguments:  [ULONG] --
//              [ULONG] --
//              [pcbRead] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CMimeHandlerTest1::Read(void *pBuffer, ULONG cbBuffer,ULONG *pcbRead)
{
    PerfDbgLog(tagCTransaction, this, "+CMimeHandlerTest1::Read\n");
    HRESULT     hr = E_FAIL;

    BOOL fRead = TRUE;
    DWORD dwCopy = 0;
    DWORD dwCopyNew = 0;

    if (   (_dwOInetBdgFlags & (PI_MIMEVERIFICATION | PI_DOCFILECLSIDLOOKUP))
        && (_cbBufferFilled))
    {
        fRead = FALSE;

        // copy data form the local buffer to the provide buffer
        if (cbBuffer < _cbBufferFilled)
        {
            dwCopy = cbBuffer;
            memcpy(pBuffer, _pBuffer, cbBuffer);
            // move the memory to the front
            memcpy(_pBuffer, _pBuffer + cbBuffer, _cbBufferFilled - cbBuffer);
            _cbBufferFilled -= cbBuffer;
            hr = S_OK;
        }
        else if (cbBuffer == _cbBufferFilled)
        {
            dwCopy = _cbBufferFilled;
            memcpy(pBuffer, _pBuffer, _cbBufferFilled);
            _cbBufferFilled = 0;
            hr = S_OK;
        }
        else
        {
            //
            // user buffer is greater than what is available in
            //
            dwCopy = _cbBufferFilled;
            memcpy(pBuffer, _pBuffer, _cbBufferFilled);
            _cbBufferFilled = 0;
            fRead = TRUE;
            hr = E_PENDING;
        }
    }

    if (fRead)
    {
        if (_pProt)
        {
            hr = _pProt->Read( ((LPBYTE)pBuffer) + dwCopy, cbBuffer - dwCopy, &dwCopyNew);
            _cbTotalBytesRead += dwCopyNew;
        }
        else
        {
            hr = S_FALSE;
        }
    }

    if (pcbRead)
    {
        *pcbRead = dwCopy + dwCopyNew;
    }
 

    PerfDbgLog1(tagCTransaction, this, "-CMimeHandlerTest1::Read (hr:%lx)\n",hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CMimeHandlerTest1::Seek
//
//  Synopsis:
//
//  Arguments:  [DWORD] --
//              [ULARGE_INTEGER] --
//              [plibNewPosition] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CMimeHandlerTest1::Seek(LARGE_INTEGER dlibMove,DWORD dwOrigin,ULARGE_INTEGER *plibNewPosition)
{
    PerfDbgLog(tagCTransaction, this, "+CMimeHandlerTest1::Seek\n");

    HRESULT hr = _pProt->Seek(dlibMove, dwOrigin, plibNewPosition);

    PerfDbgLog1(tagCTransaction, this, "-CMimeHandlerTest1::Seek (hr:%lx)\n", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CMimeHandlerTest1::LockRequest
//
//  Synopsis:
//
//  Arguments:  [dwOptions] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CMimeHandlerTest1::LockRequest(DWORD dwOptions)
{
    PerfDbgLog(tagCTransaction, this, "+CMimeHandlerTest1::LockRequest\n");

    HRESULT hr = hr = _pProt->LockRequest(dwOptions);

    PerfDbgLog1(tagCTransaction, this, "-CMimeHandlerTest1::LockRequest (hr:%lx)\n",hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CMimeHandlerTest1::UnlockRequest
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CMimeHandlerTest1::UnlockRequest()
{
    PerfDbgLog(tagCTransaction, this, "+CMimeHandlerTest1::UnlockRequest\n");
    HRESULT hr = NOERROR;

    hr = _pProt->UnlockRequest();

    PerfDbgLog1(tagCTransaction, this, "-CMimeHandlerTest1::UnlockRequest (hr:%lx)\n", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CTransaction::OnDataReceived
//
//  Synopsis:
//
//  Arguments:  [grfBSC] --
//              [cbBytesAvailable] --
//              [dwTotalSize] --
//              [pcbNewAvailable] --
//
//  Returns:
//
//  History:    4-15-1997   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
#if 0
STDMETHODIMP CMimeHandlerTest1::OnDataReceived(DWORD *pgrfBSC, DWORD *pcbBytesAvailable, DWORD *pdwTotalSize) //, DWORD *pcbNewAvailable)
{
    PerfDbgLog3(tagCTransaction, this, "+CMimeHandlerTest1::OnDataReceived (grfBSC:%lx,  cbBytesAvailable:%ld, _cbTotalBytesRead:%ld)",
                                    *pgrfBSC, *pcbBytesAvailable, _cbTotalBytesRead);
    HRESULT hr = NOERROR;
    DWORD grfBSC = *pgrfBSC;
    DWORD cbBytesAvailable = *pcbBytesAvailable; 
    DWORD dwTotalSize = *pdwTotalSize;
    DWORD *pcbNewAvailable = &cbBytesAvailable;
    
    *pcbNewAvailable = cbBytesAvailable;

    if (_dwOInetBdgFlags & (PI_MIMEVERIFICATION | PI_DOCFILECLSIDLOOKUP))
    {
        DWORD dwNewData = 0;
        TransAssert((_pProt && _cbDataSniffMin));

        // _cbTotalBytesRead = # of bytes read so far
        if (_cbTotalBytesRead < _cbDataSniffMin)
        {
            // no bytes read so far
            TransAssert((_cbTotalBytesRead < _cbDataSniffMin));
            // read data into buffer and report progess
            do
            {
                hr = _pProt->Read(_pBuffer + _cbBufferFilled, _cbBufferSize - _cbBufferFilled, &dwNewData);
                _cbTotalBytesRead += dwNewData;
                _cbBufferFilled += dwNewData;
            } while ((hr == S_OK) && (_cbTotalBytesRead < _cbDataSniffMin));

            // now check if this is docfile
            // if so download at least 2k
            if (!_fDocFile && _cbBufferFilled && (IsDocFile(_pBuffer, _cbBufferFilled) == S_OK))
            {
                _fDocFile = TRUE;
                _cbDataSniffMin =  (dwTotalSize && dwTotalSize < DATASNIFSIZEDOCFILE_MIN) ? dwTotalSize : DATASNIFSIZEDOCFILE_MIN;
            }

            if ((hr == E_PENDING) && (_cbTotalBytesRead < _cbDataSniffMin))
            {
                // do not report anything - wait until we get more data
                // a request is pending at this time
                // need more data to sniff properly
                hr  = S_NEEDMOREDATA;
            }
            else if (hr == NOERROR || hr == E_PENDING)
            {
                TransAssert((_cbTotalBytesRead != 0));

                // report the data we have in the buffer or
                // the available #
                DWORD cbBytesReport =  (cbBytesAvailable > _cbTotalBytesRead) ? cbBytesAvailable : _cbTotalBytesRead + 1;

                if (dwTotalSize && ((cbBytesReport > dwTotalSize)))
                {
                    cbBytesReport =  dwTotalSize;
                }
                *pcbNewAvailable = cbBytesReport;
            }
            else if (hr == S_FALSE)
            {
                // end of stream
                *pgrfBSC |=  (BSCF_LASTDATANOTIFICATION & BSCF_DATAFULLYAVAILABLE);
                *pcbBytesAvailable = *pdwTotalSize =  _cbTotalBytesRead;
            }
            
            if (   (!_fMimeVerified)
                && (   (*pcbNewAvailable >= _cbDataSniffMin)
                    || (hr == S_FALSE)) )
            {
                // enough data or end of stream
                _fMimeVerified = TRUE;
                LPCWSTR  pwzStr = FindMimeFromDataIntern(_pwzFileName,_pBuffer, _cbBufferFilled, _pwzMimeSuggested, 0);
                _pProtSnk->ReportProgress(BINDSTATUS_MIMETYPEAVAILABLE, pwzStr);
                
                if (_pwzMimeSuggested != pwzStr)
                {
                    if (_pwzMimeSuggested)
                    {
                        delete [] _pwzMimeSuggested;
                    }
                    if (pwzStr)
                    {
                        _pwzMimeSuggested = OLESTRDuplicate((LPWSTR)pwzStr);
                    }
                }

                if (   _fDocFile
                    && (_dwOInetBdgFlags & PI_DOCFILECLSIDLOOKUP))
                {
                    // find the class id and send it on
                    CLSID clsid;

                    HRESULT hr1 = GetClassDocFileBuffer(_pBuffer, _cbBufferFilled, &clsid);
                    if (hr1 == NOERROR)
                    {
                        LPOLESTR pwzStrClsId;
                        StringFromCLSID(clsid, &pwzStrClsId);
                        _pProtSnk->ReportProgress(BINDSTATUS_CLASSIDAVAILABLE, pwzStrClsId);

                        delete [] pwzStrClsId;
                    }
                }
            }
            hr = NOERROR;
        }
        //TransAssert((cbBytesAvailable <= *pcbNewAvailable));
        if (cbBytesAvailable > *pcbNewAvailable)
        {
            *pcbNewAvailable = cbBytesAvailable;
        }
        if (dwTotalSize && (dwTotalSize < *pcbNewAvailable))
        {
            *pcbNewAvailable = dwTotalSize;
        }
    }
    
    {
        CLock lck(_mxs);
        _cbBytesReported = *pcbNewAvailable;
        *pdwTotalSize = dwTotalSize;
    }


    PerfDbgLog2(tagCTransaction, this, "-CMimeHandlerTest1::OnDataReceived (hr:%lx, _cbBufferFilled:%lx)", hr, _cbBufferFilled);
    return hr;
}
#endif // 0
//+---------------------------------------------------------------------------
//
//  Method:     CMimeHandlerTest1::Switch
//
//  Synopsis:
//
//  Arguments:  [pStateInfo] --
//
//  Returns:
//
//  History:    11-07-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CMimeHandlerTest1::Switch(PROTOCOLDATA *pStateInfo)
{
    PerfDbgLog(tagCTransaction, this, "+CMimeHandlerTest1::Switch");
    HRESULT hr = NOERROR;

    hr = _pProtSnk->Switch(pStateInfo);
   
    PerfDbgLog1(tagCTransaction, this, "-CMimeHandlerTest1::Switch (hr:%lx)", hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CMimeHandlerTest1::ReportProgress
//
//  Synopsis:
//
//  Arguments:  [NotMsg] --
//              [szStatusText] --
//
//  Returns:
//
//  History:    11-07-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CMimeHandlerTest1::ReportProgress(ULONG NotMsg, LPCWSTR pwzStatusText)
{
    PerfDbgLog(tagCTransaction, this, "+CMimeHandlerTest1::ReportProgress");
    HRESULT hr = NOERROR;

    switch (NotMsg)
    {
    case BINDSTATUS_MIMETYPEAVAILABLE:
        if (_dwOInetBdgFlags & (PI_MIMEVERIFICATION | PI_DOCFILECLSIDLOOKUP))
        {
            // report the mime later after sniffing data
            _pwzMimeSuggested = OLESTRDuplicate(pwzStatusText);
        }
        else
        {
            hr = _pProtSnk->ReportProgress(NotMsg, pwzStatusText);
        }

    break;

    case BINDSTATUS_CACHEFILENAMEAVAILABLE :
        _pwzFileName = OLESTRDuplicate(pwzStatusText);

    default:
    {
        hr = _pProtSnk->ReportProgress(NotMsg, pwzStatusText);
        
    }

    } // end switch
    
    PerfDbgLog1(tagCTransaction, this, "-CMimeHandlerTest1::ReportProgress (hr:%lx)", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CMimeHandlerTest1::ReportData
//
//  Synopsis:
//
//  Arguments:  [grfBSCF] --
//              [ULONG] --
//              [ulProgressMax] --
//
//  Returns:
//
//  History:    11-07-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CMimeHandlerTest1::ReportData(DWORD grfBSCF, ULONG ulProgress,ULONG ulProgressMax)
{
    PerfDbgLog3(tagCTransaction, this, "+CMimeHandlerTest1::ReportData(grfBSCF:%lx, ulProgress:%ld, ulProgressMax:%ld)",
                                       grfBSCF, ulProgress, ulProgressMax);
    HRESULT hr = NOERROR;
    /*
    if (   (_dwOInetBdgFlags & (PI_MIMEVERIFICATION | PI_DOCFILECLSIDLOOKUP)
        && (OnDataReceived(&grfBSCF, &ulProgress, &ulProgressMax) == NOERROR)) )
    {
        hr = _pProtSnk->ReportData( grfBSCF, ulProgress, ulProgressMax);
    }
    else
    */
    {
        hr = _pProtSnk->ReportData( grfBSCF, ulProgress, ulProgressMax);
    }

    PerfDbgLog1(tagCTransaction, this, "-CMimeHandlerTest1::ReportData (hr:%lx)", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CMimeHandlerTest1::ReportResult
//
//  Synopsis:
//
//  Arguments:  [DWORD] --
//              [dwError] --
//              [wzResult] --
//
//  Returns:
//
//  History:    11-07-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CMimeHandlerTest1::ReportResult(HRESULT hrResult, DWORD dwError, LPCWSTR wzResult)
{
    PerfDbgLog(tagCTransaction, this, "+CMimeHandlerTest1::ReportResult");
    HRESULT hr = NOERROR;

    hr = _pProtSnk->ReportResult(hrResult, dwError, wzResult);
    
    PerfDbgLog1(tagCTransaction, this, "-CMimeHandlerTest1::ReportResult (hr:%lx)", hr);
    return hr;
}

STDMETHODIMP CMimeHandlerTest1::Initialize(DWORD dwMode, DWORD dwOptions, IUnknown *pUnk, IOInetProtocol *pProt, IOInetProtocolSink *pProtSnk)
{
    HRESULT hr = NOERROR;
    _dwMode = dwMode;
    _pUnk = pUnk;
    _pProt = pProt;
    _pProtSnk = pProtSnk;
    if (_pProtSnk)
    {
        _pProtSnk->AddRef();
    }
    if (_pUnk)
    {
        _pUnk->AddRef();
    }
    
    _dwOInetBdgFlags = dwOptions;
    if (_dwOInetBdgFlags & (PI_MIMEVERIFICATION | PI_DOCFILECLSIDLOOKUP))
    {
        _cbBufferSize = DATASNIFSIZEDOCFILE_MIN; 
        _pBuffer = (LPBYTE) new BYTE[_cbBufferSize];

        if (!_pBuffer)
        {
            _cbBufferSize = 0;
            hr = E_OUTOFMEMORY;
        }
        _cbDataSniffMin = _cbBufferSize;
    }
    TransAssert((_pUnk && _pProt && _pProtSnk));
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\eapp\precomp1.inc ===
#//+---------------------------------------------------------------
#//
#//  File:      precomp1.inc
#//
#//  Contents:  directives for global precompiled include file when the
#//             sources file is two directories below com (or wherever
#//             this file is located).  We could easily have precomp3 and
#//             precomp4 for other areas.The urlint.* files should not
#//             otherwise be mentioned in the sources files.
#//
#//
#//----------------------------------------------------------------

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\..\inc\eapp.h
PRECOMPILED_TARGET=$(GPCH_BUILD)\$(_OBJ_DIR)\*\eapp.pch
PRECOMPILED_OPTION=/Yueapp.h /Fp$(GPCH_BUILD)\$(_OBJ_DIR)\*\eapp.pch
PRECOMPILED_OBJ=$(GPCH_BUILD)\$(_OBJ_DIR)\*\eapp.obj


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\eapp\plugdll.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       plugdll.cxx
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    11-07-1996   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------
#include <eapp.h>


#define SZFILTERROOT        "PROTOCOLS\\Filter\\"
#define SZPROTOCOLROOT      "PROTOCOLS\\Handler\\"
#define SZCLASS             "CLSID"
#define SZHANDLER           "HANDLER"

#ifdef EAPP_TEST
const GUID CLSID_ResProtocol        = {0x79eaca00, 0xbaf9, 0x11ce, {0x8c, 0x82, 0x00, 0xaa, 0x00, 0x4b, 0xa9, 0x0b}};
const GUID CLSID_OhServNameSp       = {0x79eaca01, 0xbaf9, 0x11ce, {0x8c, 0x82, 0x00, 0xaa, 0x00, 0x4b, 0xa9, 0x0b}};
const GUID CLSID_MimeHandlerTest1   = {0x79eaca02, 0xbaf9, 0x11ce, {0x8c, 0x82, 0x00, 0xaa, 0x00, 0x4b, 0xa9, 0x0b}};


const GUID CLSID_NotificaitonTest1  = {0xc733e501, 0x576e, 0x11d0, {0xb2, 0x8c, 0x00, 0xc0, 0x4f, 0xd7, 0xcd, 0x22}};
const GUID CLSID_NotificaitonTest2  = {0xc733e502, 0x576e, 0x11d0, {0xb2, 0x8c, 0x00, 0xc0, 0x4f, 0xd7, 0xcd, 0x22}};
const GUID CLSID_NotificaitonTest3  = {0xc733e503, 0x576e, 0x11d0, {0xb2, 0x8c, 0x00, 0xc0, 0x4f, 0xd7, 0xcd, 0x22}};
const GUID CLSID_NotificaitonTest4  = {0xc733e504, 0x576e, 0x11d0, {0xb2, 0x8c, 0x00, 0xc0, 0x4f, 0xd7, 0xcd, 0x22}};
#endif // EAPP_TEST

//****************************** CLSID for pluggable protocols and filters
const GUID CLSID_StdEncodingFilterFac= {0x54c37cd0, 0xd944, 0x11d0, {0xa9, 0xf4, 0x00, 0x60, 0x97, 0x94, 0x23, 0x11}};
const GUID CLSID_DeCompMimeFilter   = {0x8f6b0360, 0xb80d, 0x11d0, {0xa9, 0xb3, 0x00, 0x60, 0x97, 0x94, 0x23, 0x11}};
const GUID CLSID_CdlProtocol        = {0x3dd53d40, 0x7b8b, 0x11d0, {0xb0, 0x13, 0x00, 0xaa, 0x00, 0x59, 0xce, 0x02}};
const GUID CLSID_ClassInstallFilter = {0x32b533bb, 0xedae, 0x11d0, {0xbd, 0x5a, 0x0, 0xaa, 0x0, 0xb9, 0x2a, 0xf1}};

DECLARE_INFOLEVEL(EProt)
HINSTANCE g_hInst = NULL;

HINSTANCE g_hInst_LZDHtml = NULL;
HINSTANCE g_hInst_Deflate = NULL;
HINSTANCE g_hInst_GZIP = NULL;

// global variables
CRefCount g_cRef(0);        // global dll refcount

#define DLL_NAME      "plugprot.dll"

STDAPI_(BOOL) TlsDllMain(HINSTANCE hDll, DWORD dwReason, LPVOID lpvReserved);

#ifdef EAPP_TEST
#define HANDLER_RES                            SZPROTOCOLROOT"res"
#define PROTOCOL_RES_CLSID                     "{79eaca00-baf9-11ce-8c82-00aa004ba90b}"
#define PROTOCOL_RES_CLSID_REGKEY              "CLSID\\"PROTOCOL_RES_CLSID
#define PROTOCOL_RES_DESCRIP                   "res: Asychronous Pluggable Protocol Handler"

// protocols
//***** PROTOCOL_RES ENTRIES *****
const REGENTRY rgClassesRes[] =
{
    STD_ENTRY(PROTOCOL_RES_CLSID_REGKEY, PROTOCOL_RES_DESCRIP),
    STD_ENTRY(PROTOCOL_RES_CLSID_REGKEY"\\InprocServer32", "%s"DLL_NAME),
        { KEYTYPE_STRING, PROTOCOL_RES_CLSID_REGKEY"\\InprocServer32", "ThreadingModel", REG_SZ, (BYTE*)"Apartment" },
};

const REGENTRY rgHandlerRes   [] = { STD_ENTRY(HANDLER_RES  , PROTOCOL_RES_DESCRIP  ), { KEYTYPE_STRING, HANDLER_RES  , "CLSID", REG_SZ, (BYTE*)PROTOCOL_RES_CLSID   } };

#define NAMESPACE_OHSERV                SZNAMESPACEROOT"http\\ohserv"
#define NAMESPACE_OHSERV_DESCRIP       "Asychronous Pluggable NameSpace Handler for http to ohserv"
#define NAMESPACE_OHSERV_CLSID         "{79eaca01-baf9-11ce-8c82-00aa004ba90b}"
#define NAMESPACE_OHSERV_CLSID_REGKEY  "CLSID\\"NAMESPACE_OHSERV_CLSID
#define NAMESPACE_OHSERV_PROTOCOL       NAMESPACE_OHSERV

const REGENTRY rgClassesOhserv[] =
{
    STD_ENTRY(NAMESPACE_OHSERV_CLSID_REGKEY, NAMESPACE_OHSERV_DESCRIP),
    STD_ENTRY(NAMESPACE_OHSERV_CLSID_REGKEY"\\InprocServer32", "%s"DLL_NAME),
        { KEYTYPE_STRING, NAMESPACE_OHSERV_CLSID_REGKEY"\\InprocServer32", "ThreadingModel", REG_SZ, (BYTE*)"Apartment" },
};

const REGENTRY rgNameSpaceOhserv  [] = 
{ 
    STD_ENTRY(NAMESPACE_OHSERV , NAMESPACE_OHSERV_DESCRIP  ), 
    { KEYTYPE_STRING, NAMESPACE_OHSERV , "CLSID", REG_SZ, (BYTE*)NAMESPACE_OHSERV_CLSID   } 
};


#define PROT_FILTER_TEST1               SZFILTERROOT"text/html"
#define PROT_FILTER_TEST1_DESCRIP       "Asychronous Pluggable Mime Handler for text/mhtml"
#define PROT_FILTER_TEST1_CLSID         "{79eaca02-baf9-11ce-8c82-00aa004ba90b}"
#define PROT_FILTER_TEST1_CLSID_REGKEY  "CLSID\\"PROT_FILTER_TEST1_CLSID
#define PROT_FILTER_TEST1_PROTOCOL      PROT_FILTER_TEST1

const REGENTRY rgClassesMimeHandlerTest1[] =
{
    STD_ENTRY(PROT_FILTER_TEST1_CLSID_REGKEY, PROT_FILTER_TEST1_DESCRIP),
    STD_ENTRY(PROT_FILTER_TEST1_CLSID_REGKEY"\\InprocServer32", "%s"DLL_NAME),
        { KEYTYPE_STRING, PROT_FILTER_TEST1_CLSID_REGKEY"\\InprocServer32", "ThreadingModel", REG_SZ, (BYTE*)"Apartment" },
};

const REGENTRY rgMimeHandlerTest1  [] = 
{ 
    STD_ENTRY(PROT_FILTER_TEST1 , PROT_FILTER_TEST1_DESCRIP  ), 
    { KEYTYPE_STRING, PROT_FILTER_TEST1 , "CLSID", REG_SZ, (BYTE*)PROT_FILTER_TEST1_CLSID   } 
};
#endif // EAPP_TEST

//*************************** Registry keys for CDL protocol handler

#define HANDLER_CDL                            SZPROTOCOLROOT"cdl"
#define PROTOCOL_CDL_CLSID                     "{3dd53d40-7b8b-11D0-b013-00aa0059ce02}"
#define PROTOCOL_CDL_CLSID_REGKEY              "CLSID\\"PROTOCOL_CDL_CLSID
#define PROTOCOL_CDL_DESCRIP                   "CDL: Asychronous Pluggable Protocol Handler"

const REGENTRY rgHandlerCdl[] = 
{ 
    STD_ENTRY(HANDLER_CDL  , PROTOCOL_CDL_DESCRIP  ), 
        { KEYTYPE_STRING, HANDLER_CDL  , "CLSID", REG_SZ, (BYTE*)PROTOCOL_CDL_CLSID   } 
};

const REGENTRY rgClassesCdl[] =
{
    STD_ENTRY(PROTOCOL_CDL_CLSID_REGKEY, PROTOCOL_CDL_DESCRIP),
    STD_ENTRY(PROTOCOL_CDL_CLSID_REGKEY"\\InprocServer32", "%s"DLL_NAME),
        { KEYTYPE_STRING, PROTOCOL_CDL_CLSID_REGKEY"\\InprocServer32", "ThreadingModel", REG_SZ, (BYTE*)"Apartment" },
};

//*************************** Registry keys for Class Install Handler protocol filter

#define PROT_FILTER_CLASS               SZFILTERROOT"Class Install Handler"
#define PROT_FILTER_CLASS_DESCRIP       "AP Class Install Handler filter"
#define PROT_FILTER_CLASS_CLSID         "{32B533BB-EDAE-11d0-BD5A-00AA00B92AF1}"
#define PROT_FILTER_CLASS_CLSID_REGKEY  "CLSID\\"PROT_FILTER_CLASS_CLSID
#define PROT_FILTER_CLASS_PROTOCOL      PROT_FILTER_CLASS

const REGENTRY rgClassesMimeInstallHandler[] =
{
    STD_ENTRY(PROT_FILTER_CLASS_CLSID_REGKEY, PROT_FILTER_CLASS_DESCRIP),
    STD_ENTRY(PROT_FILTER_CLASS_CLSID_REGKEY"\\InprocServer32", "%s"DLL_NAME),
        { KEYTYPE_STRING, PROT_FILTER_CLASS_CLSID_REGKEY"\\InprocServer32", "ThreadingModel", REG_SZ, (BYTE*)"Apartment" },
};

const REGENTRY rgMimeInstallHandler[] = 
{ 
    STD_ENTRY(PROT_FILTER_CLASS , PROT_FILTER_CLASS_DESCRIP  ), 
        { KEYTYPE_STRING, PROT_FILTER_CLASS, "CLSID", REG_SZ, (BYTE*)PROT_FILTER_CLASS_CLSID   } 
};

//*************************** Registry keys for ENC & Deflate protocol filters

#define PROT_FILTER_ENC                 SZFILTERROOT"lzdhtml"
#define PROT_FILTER_ENC_DESCRIP         "AP lzdhtml encoding/decoding Filter"
#define PROT_FILTER_ENC_CLSID           "{8f6b0360-b80d-11d0-a9b3-006097942311}"
#define PROT_FILTER_ENC_CLSID_REGKEY    "CLSID\\"PROT_FILTER_ENC_CLSID
#define PROT_FILTER_ENC_PROTOCOL        PROT_FILTER_ENC

const REGENTRY rgClassesMimeHandlerEnc[] =
{
    STD_ENTRY(PROT_FILTER_ENC_CLSID_REGKEY, PROT_FILTER_ENC_DESCRIP),
    STD_ENTRY(PROT_FILTER_ENC_CLSID_REGKEY"\\InprocServer32", "%s"DLL_NAME),
        { KEYTYPE_STRING, PROT_FILTER_ENC_CLSID_REGKEY"\\InprocServer32", "ThreadingModel", REG_SZ, (BYTE*)"Apartment" },
};

const REGENTRY rgMimeHandlerEnc  [] = 
{ 
    STD_ENTRY(PROT_FILTER_ENC , PROT_FILTER_ENC_DESCRIP  ), 
    { KEYTYPE_STRING, PROT_FILTER_ENC , "CLSID", REG_SZ, (BYTE*)PROT_FILTER_ENC_CLSID   } 
};

#define PROT_FILTER_DEFLATE            SZFILTERROOT"deflate"
#define PROT_FILTER_DEFLATE_DESCRIP    "AP Deflate Encoding/Decoding Filter "
#define PROT_FILTER_DEFLATE_CLSID      "{8f6b0360-b80d-11d0-a9b3-006097942311}"

const REGENTRY rgDeflateEnc  [] = 
{ 
    STD_ENTRY(PROT_FILTER_DEFLATE , PROT_FILTER_DEFLATE_DESCRIP  ), 
    { KEYTYPE_STRING, PROT_FILTER_DEFLATE , "CLSID", REG_SZ, (BYTE*)PROT_FILTER_DEFLATE_CLSID   } 
};

#define PROT_FILTER_GZIP               SZFILTERROOT"gzip"
#define PROT_FILTER_GZIP_DESCRIP       "AP GZIP Encoding/Decoding Filter "
#define PROT_FILTER_GZIP_CLSID         "{8f6b0360-b80d-11d0-a9b3-006097942311}"

const REGENTRY rgGZIPEnc  [] = 
{ 
    STD_ENTRY(PROT_FILTER_GZIP , PROT_FILTER_GZIP_DESCRIP  ), 
    { KEYTYPE_STRING, PROT_FILTER_GZIP , "CLSID", REG_SZ, (BYTE*)PROT_FILTER_GZIP_CLSID   } 
};

#define STD_ENC_FAC_CLSID           "{54c37cd0-d944-11d0-a9f4-006097942311}" 
#define STD_ENC_FAC_CLSID_REGKEY    "CLSID\\"STD_ENC_FAC_CLSID
const REGENTRY rgClassesStdEncFac[] =
{
    STD_ENTRY(STD_ENC_FAC_CLSID_REGKEY"\\InprocServer32", "%s"DLL_NAME),
        { KEYTYPE_STRING, STD_ENC_FAC_CLSID_REGKEY"\\InprocServer32", "ThreadingModel", REG_SZ, (BYTE*)"Apartment" },
};




#ifdef EAPP_TEST
// notificaition sink

#define NOTIFICATION_SINK_TEST1_DESCRIP                      "Notification Sink Test1"
#define NOTIFICATION_SINK_TEST1_CLSID                        "{c733e501-576e-11d0-b28c-00c04fd7cd22}"
#define NOTIFICATION_SINK_TEST1_CLSID_REGKEY                 "CLSID\\"NOTIFICATION_SINK_TEST1_CLSID
#define NOTIFICATION_SINK_TEST1_CLSID_REGKEY                 "CLSID\\"NOTIFICATION_SINK_TEST1_CLSID

const REGENTRY rgNotSinkTest1[] =
{
    //***** NOTIFICATION_SINK_TEST1 ENTRIES *****
    STD_ENTRY(NOTIFICATION_SINK_TEST1_CLSID_REGKEY, NOTIFICATION_SINK_TEST1_DESCRIP),
    STD_ENTRY(NOTIFICATION_SINK_TEST1_CLSID_REGKEY"\\InprocServer32", "%s"DLL_NAME),
        { KEYTYPE_STRING, NOTIFICATION_SINK_TEST1_CLSID_REGKEY"\\InprocServer32", "ThreadingModel", REG_SZ, (BYTE*)"Apartment" },
};


#define NOTIFICATION_SINK_TEST2_DESCRIP                      "Notification Sink Test2"
#define NOTIFICATION_SINK_TEST2_CLSID                        "{c733e502-576e-11d0-b28c-00c04fd7cd22}"
#define NOTIFICATION_SINK_TEST2_CLSID_REGKEY                 "CLSID\\"NOTIFICATION_SINK_TEST2_CLSID
#define NOTIFICATION_SINK_TEST2_CLSID_REGKEY                 "CLSID\\"NOTIFICATION_SINK_TEST2_CLSID

const REGENTRY rgNotSinkTest2[] =
{
    //***** NOTIFICATION_SINK_TEST2 ENTRIES *****
    STD_ENTRY(NOTIFICATION_SINK_TEST2_CLSID_REGKEY, NOTIFICATION_SINK_TEST2_DESCRIP),
    STD_ENTRY(NOTIFICATION_SINK_TEST2_CLSID_REGKEY"\\InprocServer32", "%s"DLL_NAME),
        { KEYTYPE_STRING, NOTIFICATION_SINK_TEST2_CLSID_REGKEY"\\InprocServer32", "ThreadingModel", REG_SZ, (BYTE*)"Apartment" },
};


#define NOTIFICATION_SINK_TEST3_DESCRIP                      "Notification Sink Test3"
#define NOTIFICATION_SINK_TEST3_CLSID                        "{c733e503-576e-11d0-b28c-00c04fd7cd22}"
#define NOTIFICATION_SINK_TEST3_CLSID_REGKEY                 "CLSID\\"NOTIFICATION_SINK_TEST3_CLSID
#define NOTIFICATION_SINK_TEST3_CLSID_REGKEY                 "CLSID\\"NOTIFICATION_SINK_TEST3_CLSID

const REGENTRY rgNotSinkTest3[] =
{
    //***** NOTIFICATION_SINK_TEST3 ENTRIES *****
    STD_ENTRY(NOTIFICATION_SINK_TEST3_CLSID_REGKEY, NOTIFICATION_SINK_TEST3_DESCRIP),
    STD_ENTRY(NOTIFICATION_SINK_TEST3_CLSID_REGKEY"\\InprocServer32", "%s"DLL_NAME),
        { KEYTYPE_STRING, NOTIFICATION_SINK_TEST3_CLSID_REGKEY"\\InprocServer32", "ThreadingModel", REG_SZ, (BYTE*)"Apartment" },
};


#define NOTIFICATION_SINK_TEST4_DESCRIP                      "Notification Sink Test4"
#define NOTIFICATION_SINK_TEST4_CLSID                        "{c733e504-576e-11d0-b28c-00c04fd7cd22}"
#define NOTIFICATION_SINK_TEST4_CLSID_REGKEY                 "CLSID\\"NOTIFICATION_SINK_TEST4_CLSID
#define NOTIFICATION_SINK_TEST4_CLSID_REGKEY                 "CLSID\\"NOTIFICATION_SINK_TEST4_CLSID

const REGENTRY rgNotSinkTest4[] =
{
    //***** NOTIFICATION_SINK_TEST4 ENTRIES *****
    STD_ENTRY(NOTIFICATION_SINK_TEST4_CLSID_REGKEY, NOTIFICATION_SINK_TEST4_DESCRIP),
    STD_ENTRY(NOTIFICATION_SINK_TEST4_CLSID_REGKEY"\\InprocServer32", "%s"DLL_NAME),
        { KEYTYPE_STRING, NOTIFICATION_SINK_TEST4_CLSID_REGKEY"\\InprocServer32", "ThreadingModel", REG_SZ, (BYTE*)"Apartment" },
};
#endif // EAPP_TEST



const REGENTRYGROUP rgRegEntryGroups[] = {

#ifdef EAPP_TEST
    { HKEY_CLASSES_ROOT, rgClassesRes,      ARRAYSIZE(rgClassesRes) },
    { HKEY_CLASSES_ROOT, rgHandlerRes  ,    ARRAYSIZE(rgHandlerRes) },

    { HKEY_CLASSES_ROOT, rgClassesOhserv,   ARRAYSIZE(rgClassesOhserv) },
    { HKEY_CLASSES_ROOT, rgNameSpaceOhserv, ARRAYSIZE(rgNameSpaceOhserv) },

    { HKEY_CLASSES_ROOT, rgMimeHandlerTest1,        ARRAYSIZE(rgMimeHandlerTest1) },
    { HKEY_CLASSES_ROOT, rgClassesMimeHandlerTest1, ARRAYSIZE(rgClassesMimeHandlerTest1) },

    { HKEY_CLASSES_ROOT, rgNotSinkTest1  ,  ARRAYSIZE(rgNotSinkTest1) },
    { HKEY_CLASSES_ROOT, rgNotSinkTest2  ,  ARRAYSIZE(rgNotSinkTest2) },
    { HKEY_CLASSES_ROOT, rgNotSinkTest3  ,  ARRAYSIZE(rgNotSinkTest3) },
    { HKEY_CLASSES_ROOT, rgNotSinkTest4  ,  ARRAYSIZE(rgNotSinkTest4) },
#endif //EAPP_TEST

    { HKEY_CLASSES_ROOT, rgMimeHandlerEnc,        ARRAYSIZE(rgMimeHandlerEnc) },
    { HKEY_CLASSES_ROOT, rgClassesMimeHandlerEnc, ARRAYSIZE(rgClassesMimeHandlerEnc) },

    { HKEY_CLASSES_ROOT, rgDeflateEnc,        ARRAYSIZE(rgDeflateEnc) },
    { HKEY_CLASSES_ROOT, rgGZIPEnc,  ARRAYSIZE(rgGZIPEnc) },
    { HKEY_CLASSES_ROOT, rgClassesStdEncFac,  ARRAYSIZE(rgClassesStdEncFac) },
    
    { HKEY_CLASSES_ROOT, rgClassesMimeInstallHandler,      ARRAYSIZE(rgClassesMimeInstallHandler) },
    { HKEY_CLASSES_ROOT, rgMimeInstallHandler,             ARRAYSIZE(rgMimeInstallHandler) },

    { HKEY_CLASSES_ROOT, rgClassesCdl,      ARRAYSIZE(rgClassesCdl) },
    { HKEY_CLASSES_ROOT, rgHandlerCdl  ,    ARRAYSIZE(rgHandlerCdl) },

    { NULL, NULL, 0 }       // terminator
};


//+---------------------------------------------------------------------------
//
//  Function:   DllAddRef
//
//  Synopsis:
//
//  Arguments:  [void] --
//
//  Returns:
//
//  History:    11-07-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
void DllAddRef(void)
{
    g_cRef++;
}

//+---------------------------------------------------------------------------
//
//  Function:   DllRelease
//
//  Synopsis:
//
//  Arguments:  [void] --
//
//  Returns:
//
//  History:    11-07-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
void DllRelease(void)
{
    EProtAssert((g_cRef > 0));
    if (g_cRef > 0)
    {
        g_cRef--;
    }
}

//+---------------------------------------------------------------------------
//
//  Operator:   new
//
//  Synopsis:
//
//  Arguments:  [size] --
//
//  Returns:
//
//  History:    11-07-96   JohannP (Johann Posch)   Created
//
//  Notes:      BUBUG: get and use IMalloc
//
//----------------------------------------------------------------------------
void * _cdecl operator new(size_t size)
{
    void * pBuffer;
    pBuffer = CoTaskMemAlloc(size);
    if (pBuffer)
    {
        memset(pBuffer,0, size);
    }
    return pBuffer;
}

//+---------------------------------------------------------------------------
//
//  Operator:   delete
//
//  Synopsis:
//
//  Arguments:  [lpv] --
//
//  Returns:
//
//  History:    2-14-96   JohannP (Johann Posch)   Created
//
//  Notes:      BUBUG: get and use IMalloc
//
//----------------------------------------------------------------------------
void _cdecl operator delete(void *lpv)
{
    if (lpv == NULL)
    {
        return;
    }

    CoTaskMemFree(lpv);
}

//+-------------------------------------------------------------------------
//
//  Function:   DllGetClassObject
//
//  Synopsis:   Dll entry point
//
//  Arguments:  [clsid] - class id for new class
//              [iid] - interface required of class
//              [ppv] - where to put new interface
//
//  Returns:    S_OK - class object created successfully created.
//
//  History:    11-07-96   JohannP (Johann Posch)   Created
//
//--------------------------------------------------------------------------
STDAPI DllGetClassObject(REFCLSID clsid, REFIID iid, void **ppv)
{
    EProtDebugOut((DEB_PLUGPROT, "API _IN DllGetClassObject\n"));

    HRESULT hr = E_FAIL;

#ifdef EAPP_TEST
    if (   (clsid == CLSID_ResProtocol)
        || (clsid == CLSID_OhServNameSp)
        || (clsid == CLSID_NotificaitonTest1)
        || (clsid == CLSID_NotificaitonTest2)
        || (clsid == CLSID_NotificaitonTest3)
        || (clsid == CLSID_NotificaitonTest4)
        || (clsid == CLSID_CdlProtocol)
        || (clsid == CLSID_DeCompMimeFilter)
        || (clsid == CLSID_MimeHandlerTest1)
        || (clsid == CLSID_StdEncodingFilterFac)
        || (clsid == CLSID_ClassInstallFilter) )
#else
    if(    (clsid == CLSID_DeCompMimeFilter)
        || (clsid == CLSID_StdEncodingFilterFac)
        || (clsid == CLSID_CdlProtocol)
        || (clsid == CLSID_ClassInstallFilter) )
#endif // EAPP_TEST
    {
        CUrlClsFact *pCF = NULL;
        hr = CUrlClsFact::Create(clsid, &pCF);
        if (hr == NOERROR)
        {
            EProtAssert((pCF != NULL));
            hr = pCF->QueryInterface(iid, ppv);
            pCF->Release();
        }
    }

    EProtDebugOut((DEB_PLUGPROT, "API OUT DllGetClassObject (hr:%lx, ppv:%p)\n",hr,*ppv));
    return hr;
}
//+-------------------------------------------------------------------------
//
//  Function:   DllMain
//
//  Synopsis:
//
//  Arguments:  [hDll]          - a handle to the dll instance
//              [dwReason]      - the reason LibMain was called
//              [lpvReserved]   - NULL - called due to FreeLibrary
//                              - non-NULL - called due to process exit
//
//  Returns:    TRUE on success, FALSE otherwise
//
//  Notes:
//
//              The officially approved DLL entrypoint name is DllMain. This
//              entry point will be called by the CRT Init function.
//
//  History:    11-07-96   JohannP (Johann Posch)   Created
//
//--------------------------------------------------------------------------
BOOL WINAPI DllMain(HINSTANCE hInstance,DWORD dwReason,LPVOID lpvReserved)
{
    BOOL fResult = TRUE;
    switch (dwReason)
    {
    case DLL_PROCESS_ATTACH:
#if DBG==1
        {
            EProtInfoLevel = (DWORD) GetProfileIntA("UrlMon","EProt", (DEB_ERROR | DEB_WARN));
        }
#endif //DBG==1
        g_hInst = hInstance;
        //tsaMain.InitApp(NULL);

        //fResult = TlsDllMain(hInstance, dwReason, lpvReserved);
        break;

    case DLL_PROCESS_DETACH:
        if(g_hInst_LZDHtml) 
        {
            FreeLibrary(g_hInst_LZDHtml);
        }
        if(g_hInst_Deflate)
        {
            FreeLibrary(g_hInst_Deflate);
        }
        if(g_hInst_GZIP)
        {
            FreeLibrary(g_hInst_GZIP);
        }

        // Fall through

    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:
        //fResult = TlsDllMain(hInstance, dwReason, lpvReserved);
        break;

    }
    return fResult;
}

//+---------------------------------------------------------------------------
//
//  Function:   DllCanUnloadNow
//
//  Synopsis:
//
//  Arguments:  [void] --
//
//  Returns:
//
//  History:    11-07-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI DllCanUnloadNow(void)
{
    return (g_cRef ? S_FALSE : S_OK);
}

//+---------------------------------------------------------------------------
//
//  Function:   DllRegisterServer
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    10-07-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI DllRegisterServer()
{
    EProtDebugOut((DEB_PLUGPROT, "API _IN DllRegisterServer\n"));
    HRESULT hr;


    hr = HrDllRegisterServer(rgRegEntryGroups, g_hInst, NULL /*pfnLoadString*/);


    EProtDebugOut((DEB_PLUGPROT, "API OUT DllRegisterServer (hr:%lx)\n",hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   DllUnregisterServer
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    11-07-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI DllUnregisterServer()
{
    EProtDebugOut((DEB_PLUGPROT, "API _IN DllUnregisterServer\n"));
    HRESULT hr;

    hr = HrDllUnregisterServer(rgRegEntryGroups, g_hInst, NULL /*pfnLoadString*/);

    EProtDebugOut((DEB_PLUGPROT, "API OUT DllUnregisterServer (hr:%lx)\n",hr));
    return hr;
}


#if DBG==1

#include <sem.hxx>
CMutexSem   mxs;

IDebugOut *v_pEProtDbgOut = NULL;

LPCWSTR v_gDbgFacilitieNames[] =
{
     L"*/*"
    ,L"EProt"
    ,NULL
};

void EProtUrlSpy(int iOption, const char *pscFormat, ...)
{
    static char szOutBuffer[2048];
    CLock       lck(mxs);
    DWORD tid = GetCurrentThreadId();
    DWORD cbBufLen;
    sprintf(szOutBuffer,"%08x> ", tid );
    cbBufLen = strlen(szOutBuffer);

    va_list args;
    if (iOption & EProtInfoLevel)
    {
        va_start(args, pscFormat);
        wvsprintf(szOutBuffer + cbBufLen, pscFormat, args);
        va_end(args);
        UrlSpySendEntry(v_pEProtDbgOut, szOutBuffer, tid, iOption, 0);
    }
}

void UrlSpySendEntry(IDebugOut *pDbgOut, LPSTR szOutBuffer, DWORD ThreadId, DWORD dwFlags, DWORD dwReserved)
{
    if (pDbgOut)
    {
        pDbgOut->SendEntry(ThreadId, dwFlags, szOutBuffer, dwReserved);
    }
    else
    {
        OutputDebugString(szOutBuffer);
    }
}

HRESULT RegisterDebugOut(LPCWSTR pwzName, DWORD dwOptions, IDebugOut *pDbgOut, DWORD dwReserved)
{
    if (pwzName)
    {

        if (   (!wcsicmp(pwzName, L"*/*"))
            || (!wcsicmp(pwzName, L"EProt")) )
        {
            EProtInfoLevel = dwOptions;
            if (v_pEProtDbgOut)
            {
                v_pEProtDbgOut->Release();
                v_pEProtDbgOut = NULL;
            }
            if (pDbgOut)
            {

                v_pEProtDbgOut = pDbgOut;
                pDbgOut->AddRef();
            }

        }

    }

    return NOERROR;
}



void PerfDbgLogFn(int tag, void * pvObj, const char * pchFmt, ...)
{
    static char szOutBuffer[2048];
    static DWORD * apiLevel[] = { &EProtInfoLevel };
    static IDebugOut ** apDbgOut[] = { &v_pEProtDbgOut };
    int iIndex = min(tag >> DEB_LEVEL_SHIFT, 0);
    int iLevel = *apiLevel[iIndex];

    if ((tag & iLevel) == 0)
        return;

    CLock lck(mxs);
    DWORD tid = GetCurrentThreadId();
    DWORD cbBufLen;
    IDebugOut * pDbgOut = *apDbgOut[iIndex];

    sprintf(szOutBuffer, "%08x> %p %s", tid, pvObj,
        *pchFmt == '+' ? "_IN " : (*pchFmt == '-' ? "OUT " : ""));
    cbBufLen = strlen(szOutBuffer);

    if (*pchFmt == '+' || *pchFmt == '-')
        pchFmt += 1;

    va_list args;
    va_start(args, pchFmt);
    vsprintf(szOutBuffer + cbBufLen, pchFmt, args);
    lstrcat(szOutBuffer, "\n");
    va_end(args);
    UrlSpySendEntry(pDbgOut, szOutBuffer, tid, tag & DEB_LEVEL_MASK, 0);
}

#endif //DBG==1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\eapp\nspohsrv.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       resprot.cxx
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    11-07-1996   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------
#include <eapp.h>


//+---------------------------------------------------------------------------
//
//  Method:     COhServNameSp::Start
//
//  Synopsis:
//
//  Arguments:  [pwzUrl] --
//              [pTrans] --
//              [pOIBindInfo] --
//              [grfSTI] --
//              [dwReserved] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP COhServNameSp::Start(LPCWSTR pwzUrl, IOInetProtocolSink *pProt, IOInetBindInfo *pOIBindInfo,
                          DWORD grfSTI, DWORD dwReserved)
{
    EProtDebugOut((DEB_PLUGPROT, "%p _IN COhServNameSp::Start\n", this));
    HRESULT hr = NOERROR;
    WCHAR    wzURL[MAX_URL_SIZE];

    EProtAssert((!_pProtSink && pOIBindInfo && pProt));
    EProtAssert((_pwzUrl == NULL));

    hr = CBaseProtocol::Start(pwzUrl,pProt, pOIBindInfo, grfSTI, dwReserved);

    if ( (grfSTI & PI_PARSE_URL) )
    {
        hr =  ParseAndStart(FALSE);
    }
    else if (hr == NOERROR)
    {
        // asked to go async as soon as possible
        // use the switch mechanism which will \
        // call back later on ::Continue
        if (grfSTI & PI_FORCE_ASYNC)
        {
            hr = E_PENDING;
            PROTOCOLDATA protdata;
            protdata.grfFlags = PI_FORCE_ASYNC;
            protdata.dwState = RES_STATE_BIND;
            protdata.pData = 0;
            protdata.cbData = 0;

            _pProtSink->Switch(&protdata);
        }
        else
        {
            hr =  ParseAndStart(TRUE);
        }
    }

    EProtDebugOut((DEB_PLUGPROT, "%p OUT COhServNameSp::Start (hr:%lx)\n",this, hr));
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     COhServNameSp::Continue
//
//  Synopsis:
//
//  Arguments:  [pStateInfoIn] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP COhServNameSp::Continue(PROTOCOLDATA *pStateInfoIn)
{
    EProtDebugOut((DEB_PLUGPROT, "%p _IN COhServNameSp::Continue\n", this));
    HRESULT hr = E_FAIL;

    EProtAssert((!pStateInfoIn->pData && pStateInfoIn->cbData && (pStateInfoIn->dwState == RES_STATE_BIND)));

    if (pStateInfoIn->dwState == RES_STATE_BIND)
    {
        hr =  ParseAndStart();
    }

    EProtDebugOut((DEB_PLUGPROT, "%p OUT COhServNameSp::Continue (hr:%lx)\n",this, hr));
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     COhServNameSp::Read
//
//  Synopsis:
//
//  Arguments:  [ULONG] --
//              [ULONG] --
//              [pcbRead] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP COhServNameSp::Read(void *pv,ULONG cb,ULONG *pcbRead)
{
    EProtDebugOut((DEB_PLUGPROT, "%p _IN COhServNameSp::Read (cb:%ld)\n", this,cb));
    HRESULT hr = NOERROR;

    if (_pProt)
    {
        hr = _pProt->Read(pv, cb, pcbRead);
    }
    else
    {
        hr = S_FALSE;
    }

    EProtDebugOut((DEB_PLUGPROT, "%p OUT COhServNameSp::Read (pcbRead:%ld, hr:%lx)\n",this,*pcbRead, hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     COhServNameSp::Seek
//
//  Synopsis:
//
//  Arguments:  [DWORD] --
//              [ULARGE_INTEGER] --
//              [plibNewPosition] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:      WORK: not done
//
//----------------------------------------------------------------------------
STDMETHODIMP COhServNameSp::Seek(LARGE_INTEGER dlibMove,DWORD dwOrigin,ULARGE_INTEGER *plibNewPosition)
{
    EProtDebugOut((DEB_PLUGPROT, "%p _IN COhServNameSp::Seek\n", this));
    HRESULT hr = NOERROR;

    if (_pProt)
    {
        hr = _pProt->Seek(dlibMove, dwOrigin, plibNewPosition);
    }
    else
    {
        hr = S_FALSE;
    }


    EProtDebugOut((DEB_PLUGPROT, "%p OUT COhServNameSp::Seek (hr:%lx)\n",this, hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     COhServNameSp::LockRequest
//
//  Synopsis:
//
//  Arguments:  [dwOptions] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP COhServNameSp::LockRequest(DWORD dwOptions)
{
    EProtDebugOut((DEB_PLUGPROT, "%p _IN COhServNameSp::LockRequest\n", this));

    HRESULT hr = NOERROR;

    if (_pProt)
    {
        hr = _pProt->LockRequest(dwOptions);
    }

    EProtDebugOut((DEB_PLUGPROT, "%p OUT COhServNameSp::LockRequest (hr:%lx)\n",this, hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     COhServNameSp::UnlockRequest
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP COhServNameSp::UnlockRequest()
{
    EProtDebugOut((DEB_PLUGPROT, "%p _IN COhServNameSp::UnlockRequest\n", this));
    HRESULT hr = NOERROR;

    if (_pProt)
    {
        hr = _pProt->UnlockRequest();
    }


    EProtDebugOut((DEB_PLUGPROT, "%p OUT COhServNameSp::UnlockRequest (hr:%lx)\n",this, hr));
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     COhServNameSp::COhServNameSp
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    1-27-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
COhServNameSp::COhServNameSp(REFCLSID rclsid, IUnknown *pUnkOuter, IUnknown **ppUnkInner) : CBaseProtocol(rclsid, pUnkOuter, ppUnkInner)
{
    EProtDebugOut((DEB_PLUGPROT, "%p _IN/OUT     COhServNameSp::COhServNameSp \n", this));
}

//+---------------------------------------------------------------------------
//
//  Method:     COhServNameSp::~COhServNameSp
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    11-09-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
COhServNameSp::~COhServNameSp()
{

    EProtDebugOut((DEB_PLUGPROT, "%p _IN/OUT COhServNameSp::~COhServNameSp \n", this));
}


//+---------------------------------------------------------------------------
//
//  Method:     COhServNameSp::ParseAndStart
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    11-09-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP COhServNameSp::ParseAndStart(BOOL fBind)
{
    EProtDebugOut((DEB_PLUGPROT, "%p _IN COhServNameSp::ParseAndStart\n", this));

    HRESULT hr = INET_E_USE_DEFAULT_PROTOCOLHANDLER;

    WCHAR wzUrl[MAX_URL_SIZE];

    LPWSTR pwzOhservHttp = L"http://ohserv";
    LPWSTR pwzOhservFile = L"file://\\\\ohserv\\http";
    LPWSTR pwzOhservRoot = L"\\\\ohserv\\http";
    ULONG cServerLen = wcslen(pwzOhservHttp);

    do
    {
        if ( wcsnicmp(_wzFullURL, pwzOhservHttp, cServerLen) )
        {
            // not http://ohserv - return default error
            break;
        }

        // find the file name and path
        LPWSTR pwzRest = _wzFullURL + cServerLen;

        EProtAssert((pwzRest));

        wcscpy(wzUrl, pwzOhservRoot);
        wcscat(wzUrl, pwzRest);

        DWORD dwAttr = 0;
        {
            char szUrl[MAX_URL_SIZE];
            W2A(wzUrl, szUrl, MAX_URL_SIZE);

            dwAttr = GetFileAttributes(szUrl);
        }

        if (   (dwAttr == 0xffffffff)
            || (dwAttr & FILE_ATTRIBUTE_DIRECTORY)
           )
        {
            break;
        }


        wcscpy(wzUrl, pwzOhservFile);
        wcscat(wzUrl, pwzRest);

        // create an APP file
        {
            IClassFactory *pCF = 0;
            hr = CoCreateInstance(CLSID_FileProtocol, NULL, CLSCTX_INPROC_SERVER,IID_IClassFactory, (void**)&pCF);
            if (hr == NOERROR)
            {
                IUnknown *pUnk = 0;
                //IOInetProtocol *pProt = 0;


                EProtAssert((pCF));

                hr = pCF->CreateInstance((IOInetProtocol *)this, IID_IUnknown, (void **)&_pUnkInner);

                if (hr == NOERROR)
                {
                    EProtAssert((_pUnkInner));
                    hr = (_pUnkInner)->QueryInterface(IID_IOInetProtocol, (void **) &_pProt);
                }

                // create an instance without aggregation
                if (hr == CLASS_E_NOAGGREGATION)
                {
                    hr = pCF->CreateInstance(NULL, IID_IOInetProtocol, (void **) &_pProt);
                }

                pCF->Release();

                {
                    hr = _pProt->Start(wzUrl, _pProtSink, _pOIBindInfo, _grfSTI, 0);
                }

                if (hr != NOERROR)
                {
                    hr = INET_E_USE_DEFAULT_PROTOCOLHANDLER;
                }

           }
        }

        break;

    }  while (1);


    if (hr == MK_E_SYNTAX)
    {
        _pProtSink->ReportResult(hr, 0, 0);
    }

    EProtDebugOut((DEB_PLUGPROT, "%p OUT COhServNameSp::ParseAndStart (hr:%lx)\n", this,hr));
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\eapp\resprot.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       resprot.cxx
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    11-07-1996   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------
#include <eapp.h>
#include <tchar.h>

#define MAX_ID 10000

#define WITH_TAGS

//+---------------------------------------------------------------------------
//
//  Method:     CResProtocol::Start
//
//  Synopsis:
//
//  Arguments:  [pwzUrl] --
//              [pTrans] --
//              [pOIBindInfo] --
//              [grfSTI] --
//              [dwReserved] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CResProtocol::Start(LPCWSTR pwzUrl, IOInetProtocolSink *pTrans, IOInetBindInfo *pOIBindInfo,
                          DWORD grfSTI, DWORD dwReserved)
{
    EProtDebugOut((DEB_PLUGPROT, "%p _IN CResProtocol::Start\n", this));
    HRESULT hr = NOERROR;
    WCHAR    wzURL[MAX_URL_SIZE];

    EProtAssert((!_pProtSink && pOIBindInfo && pTrans));
    EProtAssert((_pwzUrl == NULL));

    hr = CBaseProtocol::Start(pwzUrl,pTrans, pOIBindInfo, grfSTI, dwReserved);

    if ( (grfSTI & PI_PARSE_URL) )
    {
        hr =  ParseAndBind(FALSE);
    }
    else if (hr == NOERROR)
    {
        // asked to go async as soon as possible
        // use the switch mechanism which will \
        // call back later on ::Continue
        if (grfSTI & PI_FORCE_ASYNC)
        {
            hr = E_PENDING;
            PROTOCOLDATA protdata;
            protdata.grfFlags = PI_FORCE_ASYNC;
            protdata.dwState = RES_STATE_BIND;
            protdata.pData = 0;
            protdata.cbData = 0;

            _pProtSink->Switch(&protdata);
        }
        else
        {
            hr =  ParseAndBind(TRUE);
        }
    }

    EProtDebugOut((DEB_PLUGPROT, "%p OUT CResProtocol::Start (hr:%lx)\n",this, hr));
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CResProtocol::Continue
//
//  Synopsis:
//
//  Arguments:  [pStateInfoIn] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CResProtocol::Continue(PROTOCOLDATA *pStateInfoIn)
{
    EProtDebugOut((DEB_PLUGPROT, "%p _IN CResProtocol::Continue\n", this));
    HRESULT hr = E_FAIL;

    EProtAssert((!pStateInfoIn->pData && pStateInfoIn->cbData && (pStateInfoIn->dwState == RES_STATE_BIND)));

    if (pStateInfoIn->dwState == RES_STATE_BIND)
    {
        hr =  ParseAndBind();
    }

    EProtDebugOut((DEB_PLUGPROT, "%p OUT CResProtocol::Continue (hr:%lx)\n",this, hr));
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CResProtocol::Read
//
//  Synopsis:
//
//  Arguments:  [ULONG] --
//              [ULONG] --
//              [pcbRead] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CResProtocol::Read(void *pv,ULONG cb,ULONG *pcbRead)
{
    EProtDebugOut((DEB_PLUGPROT, "%p _IN CResProtocol::Read (cb:%ld)\n", this,cb));
    HRESULT hr = NOERROR;

    if (_cbBuffer > _cbPos)
    {
        ULONG cbCopy = (cb < (_cbBuffer - _cbPos)) ? cb :  _cbBuffer - _cbPos;

        memcpy((LPVOID)pv, ((LPBYTE)_pBuffer) + _cbPos, cbCopy);

        _cbPos += cbCopy;

        *pcbRead = cbCopy;

        hr =  (_cbPos < _cbBuffer) ? S_OK : S_FALSE;
    }
    else
    {
        hr = S_FALSE;
    }

    EProtDebugOut((DEB_PLUGPROT, "%p OUT CResProtocol::Read (pcbRead:%ld, hr:%lx)\n",this,*pcbRead, hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CResProtocol::Seek
//
//  Synopsis:
//
//  Arguments:  [DWORD] --
//              [ULARGE_INTEGER] --
//              [plibNewPosition] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:      WORK: not done
//
//----------------------------------------------------------------------------
STDMETHODIMP CResProtocol::Seek(LARGE_INTEGER dlibMove,DWORD dwOrigin,ULARGE_INTEGER *plibNewPosition)
{
    EProtDebugOut((DEB_PLUGPROT, "%p _IN CResProtocol::Seek\n", this));
    HRESULT hr = NOERROR;

    if (dwOrigin == STREAM_SEEK_SET)
    {
        if (dlibMove.LowPart >= 0)
        {
            _cbPos = dlibMove.LowPart;

            if (plibNewPosition)
            {
                plibNewPosition->HighPart = 0;
                plibNewPosition->LowPart = _cbPos;
            }
        }
        else
        {
            hr = STG_E_INVALIDPOINTER;
        }
    }
    else
    {
        hr = E_NOTIMPL;
    }

    EProtDebugOut((DEB_PLUGPROT, "%p OUT CResProtocol::Seek (hr:%lx)\n",this, hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CResProtocol::LockRequest
//
//  Synopsis:
//
//  Arguments:  [dwOptions] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CResProtocol::LockRequest(DWORD dwOptions)
{
    EProtDebugOut((DEB_PLUGPROT, "%p _IN CResProtocol::LockRequest\n", this));

    HRESULT hr = NOERROR;

    if (OpenTempFile())
    {
        DWORD dwWrite;
        if (!WriteFile(_hFile, _pBuffer, _cbBuffer, &dwWrite,NULL))
        {
            hr = E_FAIL;
        }
        CloseTempFile();
    }

    EProtDebugOut((DEB_PLUGPROT, "%p OUT CResProtocol::LockRequest (hr:%lx)\n",this, hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CResProtocol::UnlockRequest
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CResProtocol::UnlockRequest()
{
    EProtDebugOut((DEB_PLUGPROT, "%p _IN CResProtocol::UnlockRequest\n", this));
    HRESULT hr = NOERROR;

    //CloseTempFile();

    EProtDebugOut((DEB_PLUGPROT, "%p OUT CResProtocol::UnlockRequest (hr:%lx)\n",this, hr));
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CResProtocol::CResProtocol
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    1-27-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
CResProtocol::CResProtocol(REFCLSID rclsid, IUnknown *pUnkOuter, IUnknown **ppUnkInner) : CBaseProtocol(rclsid, pUnkOuter, ppUnkInner)
{
    EProtDebugOut((DEB_PLUGPROT, "%p _IN CResProtocol::CResProtocol \n", this));

    _hInst = NULL;
    _cbBuffer = 0;
    _pBuffer = 0;
    _hgbl = 0;
    _cbPos = 0;

    EProtDebugOut((DEB_PLUGPROT, "%p OUT CResProtocol::CResProtocol \n", this));
}

//+---------------------------------------------------------------------------
//
//  Method:     CResProtocol::~CResProtocol
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    11-09-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
CResProtocol::~CResProtocol()
{

    if (_hgbl)
    {
        UnlockResource(_hgbl);
    }
    if (_hInst)
    {
        FreeLibrary(_hInst);
    }

    EProtDebugOut((DEB_PLUGPROT, "%p _IN/OUT CResProtocol::~CResProtocol \n", this));
}

//+---------------------------------------------------------------------------
//
//  Method:     CResProtocol::GetResource
//
//  Synopsis:
//
//  Arguments:  [pwzFileName] --
//              [pwzResName] --
//              [pwzResType] --
//
//  Returns:
//
//  History:    11-09-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CResProtocol::GetResource(LPCWSTR pwzFileName, LPCWSTR pwzResName, LPCWSTR pwzResType, LPCWSTR pwzMime)
{
    EProtDebugOut((DEB_PLUGPROT, "CResProtocol::GetResource\n)"));
    HRESULT     hr = NOERROR;
    DWORD       dwError = 0;
    HRSRC       hrsrc;

    LPSTR pszFileName =  DupW2A(pwzFileName );
    LPSTR pszResName  =  DupW2A(pwzResName  );
    LPSTR pszResType  =  DupW2A(pwzResType  );


    if (!pszFileName || !pszResName || !pszResType)
    {
        hr = E_OUTOFMEMORY;
    }
    else do
    {
        _pProtSink->ReportProgress(BINDSTATUS_SENDINGREQUEST, pwzResName);

        _hInst = LoadLibraryEx(pszFileName, NULL, DONT_RESOLVE_DLL_REFERENCES);
        if (!_hInst)
        {
            hr = INET_E_RESOURCE_NOT_FOUND;
            dwError = GetLastError();
            break;
        }

        if (!wcscmp(pwzResName, L"?"))
        {
            for (int i = 0 ; i < MAX_ID; i++)
            {
                hrsrc = FindResource(_hInst, (LPSTR)MAKEINTRESOURCE(i), pszResType);

                if (hrsrc)
                {
                    EProtDebugOut((DEB_PLUGPROT, "CResProtocol::GetResource (szResName:#%ld, wzRestype:%s\n)",i,pszResType));
                    i = MAX_ID;
                }
            }
        }
        else
        {
            hrsrc = FindResource(_hInst, pszResName, pszResType);
        }

        if (!hrsrc)
        {
            hr = INET_E_OBJECT_NOT_FOUND;
            dwError = GetLastError();
            break;
        }

        _hgbl = LoadResource(_hInst, hrsrc);
        if (!_hgbl)
        {
            hr = INET_E_DATA_NOT_AVAILABLE;
            dwError = GetLastError();
            break;
        }

        _pBuffer = LockResource(_hgbl);
        if (!_pBuffer)
        {
            hr = INET_E_DATA_NOT_AVAILABLE;
            dwError = GetLastError();
            break;
        }

        _cbBuffer = SizeofResource(_hInst, hrsrc);


        if (_grfBindF & INTERNET_FLAG_NEED_FILE)
        {
            LockRequest(0);
        }

#ifdef UNUSED
        if (OpenTempFile())
        {
            DWORD dwWrite;
            if (!WriteFile(_hFile, _pBuffer, _cbBuffer, &dwWrite,NULL))
            {
                dwError = GetLastError();
                break;
            }
            CloseTempFile();
        }
#endif //UNUSED

        hr = NOERROR;
        break;

    }  while (1);

    if (dwError || (hr != NOERROR))
    {
        _pProtSink->ReportResult(hr, dwError, 0);
    }
    else
    {
        if (pwzMime)
        {
            _pProtSink->ReportProgress(BINDSTATUS_MIMETYPEAVAILABLE, pwzMime);
        }

        _bscf |= BSCF_LASTDATANOTIFICATION | BSCF_DATAFULLYAVAILABLE;
        _pProtSink->ReportData(_bscf, _cbBuffer, _cbBuffer);
    }

    if (pszFileName)
    {
        delete pszFileName;
    }

    if (pszResName)
    {
        delete pszResName;
    }

    if (pszResType)
    {
        delete pszResType;
    }


    EProtDebugOut((DEB_PLUGPROT, "%p OUT CResProtocol::GetResource (hr:%lx)\n",this, hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CResProtocol::ParseAndBind
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    11-09-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CResProtocol::ParseAndBind(BOOL fBind)
{
    EProtDebugOut((DEB_PLUGPROT, "%p _IN CResProtocol::ParseAndBind\n", this));

    HRESULT hr = MK_E_SYNTAX;

    WCHAR wzlURL[MAX_URL_SIZE];

    wcscpy(wzlURL, _wzFullURL);


    do
    {
        // check if protocol part
        LPWSTR pwz = wcschr(wzlURL, ':');

        pwz++;

        if (wcsnicmp(pwz, L"//", 2) && wcsnicmp(pwz, L"\\\\", 2))
        {
            break;
        }

        // find the file name and path
        LPWSTR pwzFileName = pwz + 2;

        EProtAssert((pwzFileName));

        // the file is
        LPWSTR pwz1 = wcsrchr(wzlURL, '/');

        if (!pwz1)
        {
            break;
        }

        *pwz1 = '\0';
        pwz1++;

        if (!*pwz1)
        {
            break;
        }
#ifdef WITH_TAGS
        LPWSTR pwzResDelimiter = wcschr(pwz1, '?');

        if (!pwzResDelimiter)
        {
            break;
        }

        LPWSTR pwzResTag = wcsstr(pwz1, L"name:");

        if (!pwzResTag)
        {
            break;
        }

        LPWSTR pwzTypeTag = wcsstr(pwz1, L"type:");

        if (!pwzTypeTag)
        {
            break;
        }

        LPWSTR pwzMimeTag = wcsstr(pwz1, L"mime:");

        // get the resource name
        LPWSTR pwzResName = wcschr(pwzResTag, ':');
        pwzResName++;

        //find the end of the resource name
        LPWSTR pwzResType = wcschr(pwzTypeTag, ':');
        pwzResType++;

        LPWSTR pwzMime = 0;
        if (pwzMimeTag)
        {
            pwzMime = wcschr(pwzMimeTag, ':');
            pwzMime++;
            *pwzMimeTag = 0;
        }

        *pwzResTag = 0;
        *pwzTypeTag = 0;


#else
        // find the delimiter for the private part
        LPWSTR pwzResName = wcschr(pwz1, '?');

        if (!pwzResName)
        {
            break;
        }

        // get the resource name
        pwzResName++;

        //find the end of the resource name
        LPWSTR pwzResType = wcschr(pwzResName, ' ');

        if (!pwzResType)
        {
            break;
        }

        *pwzResType = '\0';
        pwzResType++;
        EProtDebugOut((DEB_PLUGPROT, "CResProtocol::GetResource (wzResName:%ws,pwzResType:%ws\n)",pwzResName,pwzResType));


        /*
        {
            pwzResType =  (LPWSTR)MAKEINTRESOURCE(RT_ICON);
            EProtDebugOut((DEB_PLUGPROT, "CResProtocol::GetResource (wzResName:%ws,pwzResType:RT_ICON\n)",pwzResName));
        }
        */
#endif //WITH_TAGS


        EProtAssert(((WCHAR *)pwzFileName && (WCHAR *)pwzResName));
        if (fBind && pwzFileName && pwzResName && pwzResType)
        {
            hr = GetResource(pwzFileName, pwzResName, pwzResType, pwzMime);
        }

        break;

    }  while (1);


    if (hr == MK_E_SYNTAX)
    {
        _pProtSink->ReportResult(hr, 0, 0);
    }

    EProtDebugOut((DEB_PLUGPROT, "%p OUT CResProtocol::ParseAndBind (hr:%lx)\n", this,hr));
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\eapp\protbase.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       protbase.cxx
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    11-07-1996   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------
#include <eapp.h>

//+---------------------------------------------------------------------------
//
//  Method:     CBaseProtocol::QueryInterface
//
//  Synopsis:
//
//  Arguments:  [riid] --
//              [ppvObj] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBaseProtocol::QueryInterface(REFIID riid, void **ppvObj)
{
    VDATEPTROUT(ppvObj, void *);
    VDATETHIS(this);
    HRESULT hr = NOERROR;

    EProtDebugOut((DEB_PLUGPROT, "%p _IN CBaseProtocol::QueryInterface\n", this));

    hr = _pUnkOuter->QueryInterface(riid, ppvObj);

    EProtDebugOut((DEB_PLUGPROT, "%p OUT CBaseProtocol::QueryInterface (hr:%lx\n", this,hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   CBaseProtocol::AddRef
//
//  Synopsis:
//
//  Arguments:  [ULONG] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CBaseProtocol::AddRef(void)
{
    EProtDebugOut((DEB_PLUGPROT, "%p _IN CBaseProtocol::AddRef\n", this));

    LONG lRet = _pUnkOuter->AddRef();

    EProtDebugOut((DEB_PLUGPROT, "%p OUT CBaseProtocol::AddRef (cRefs:%ld)\n", this,lRet));
    return lRet;
}

//+---------------------------------------------------------------------------
//
//  Function:   CBaseProtocol::Release
//
//  Synopsis:
//
//  Arguments:  [ULONG] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CBaseProtocol::Release(void)
{
    EProtDebugOut((DEB_PLUGPROT, "%p _IN CBaseProtocol::Release\n", this));

    LONG lRet = _pUnkOuter->Release();

    EProtDebugOut((DEB_PLUGPROT, "%p OUT CBaseProtocol::Release (cRefs:%ld)\n",this,lRet));
    return lRet;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBaseProtocol::Start
//
//  Synopsis:
//
//  Arguments:  [pwzUrl] --
//              [pTrans] --
//              [pOIBindInfo] --
//              [grfSTI] --
//              [dwReserved] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBaseProtocol::Start(LPCWSTR pwzUrl, IOInetProtocolSink *pTrans, IOInetBindInfo *pOIBindInfo,
                          DWORD grfSTI, DWORD_PTR dwReserved)
{
    EProtDebugOut((DEB_PLUGPROT, "%p _IN CBaseProtocol::Start\n", this));
    HRESULT hr = NOERROR;

    EProtAssert((!_pProtSink && pOIBindInfo && pTrans));
    EProtAssert((_pwzUrl == NULL));


    if ( !(grfSTI & PI_PARSE_URL))
    {
        _pProtSink = pTrans;
        _pProtSink->AddRef();

        _pOIBindInfo =  pOIBindInfo;
        _pOIBindInfo->AddRef();
    }

    _BndInfo.cbSize = sizeof(BINDINFO);
    hr = pOIBindInfo->GetBindInfo(&_grfBindF, &_BndInfo);

    // Do we need to append the extra data to the url?
    if (_BndInfo.szExtraInfo)
    {
        // append extra info at the end of the url
        // Make sure we don't overflow the URL
        if (wcslen(_BndInfo.szExtraInfo) + wcslen(pwzUrl) >= MAX_URL_SIZE)
        {
            hr = E_INVALIDARG;
            goto End;
        }

        wcscpy(_wzFullURL, pwzUrl);

        // Append the extra data to the url.  Note that we have already
        // checked for overflow, so we need not worry about it here.
        wcscat(_wzFullURL + wcslen(_wzFullURL), _BndInfo.szExtraInfo);
    }
    else
    {
        // Make sure we don't overflow the URL
        if (wcslen(pwzUrl) + 1 > MAX_URL_SIZE)
        {
            hr = E_INVALIDARG;
            goto End;
        }
        wcscpy(_wzFullURL, pwzUrl);
    }

    if ( !(grfSTI & PI_PARSE_URL))
    {
        // save the URL
        _pwzUrl = OLESTRDuplicate((LPCWSTR)pwzUrl);
    }

    _grfSTI = grfSTI;

End:

    EProtDebugOut((DEB_PLUGPROT, "%p OUT CBaseProtocol::Start (hr:%lx)\n",this, hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBaseProtocol::Continue
//
//  Synopsis:
//
//  Arguments:  [pStateInfoIn] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBaseProtocol::Continue(PROTOCOLDATA *pStateInfoIn)
{
    EProtDebugOut((DEB_PLUGPROT, "%p _IN CBaseProtocol::Continue\n", this));

    HRESULT hr = E_FAIL;

    EProtDebugOut((DEB_PLUGPROT, "%p OUT CBaseProtocol::Continue (hr:%lx)\n",this, hr));
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CBaseProtocol::Abort
//
//  Synopsis:
//
//  Arguments:  [hrReason] --
//              [dwOptions] --
//
//  Returns:
//
//  History:    11-09-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBaseProtocol::Abort(HRESULT hrReason, DWORD dwOptions)
{
    EProtDebugOut((DEB_PLUGPROT, "%p _IN CBaseProtocol::Abort\n", this));
    HRESULT hr = NOERROR;

    EProtAssert((_pProtSink));

    hr = _pProtSink->ReportResult(E_ABORT, 0, 0);

    EProtDebugOut((DEB_PLUGPROT, "%p OUT CBaseProtocol::Abort (hr:%lx)\n",this, hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBaseProtocol::Terminate
//
//  Synopsis:
//
//  Arguments:  [dwOptions] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBaseProtocol::Terminate(DWORD dwOptions)
{
    EProtDebugOut((DEB_PLUGPROT, "%p _IN CBaseProtocol::Terminate\n", this));
    HRESULT hr = NOERROR;

    EProtAssert((_pProtSink));

    if (_pProt)
    {
        _pProt->Terminate(dwOptions);
        _pProt->Release();
        _pProt = NULL;
    }

    if (_pOIBindInfo)
    {
        _pOIBindInfo->Release();
        _pOIBindInfo = NULL;
    }
    if (_pProtSink)
    {
        _pProtSink->Release();
        _pProtSink = NULL;
    }

#if DBG == 1
    if ( _BndInfo.stgmedData.tymed != TYMED_NULL )
        EProtDebugOut((DEB_PLUGPROT, "%p --- CBaseProtocol::Terminate ReleaseStgMedium (%p)\n", this,_BndInfo.stgmedData));
#endif

    ReleaseBindInfo(&_BndInfo);

    EProtDebugOut((DEB_PLUGPROT, "%p OUT CBaseProtocol::Terminate (hr:%lx)\n",this, hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBaseProtocol::Suspend
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBaseProtocol::Suspend()
{
    EProtDebugOut((DEB_PLUGPROT, "%p _IN CBaseProtocol::Suspend\n", this));

    HRESULT hr = E_NOTIMPL;

    EProtDebugOut((DEB_PLUGPROT, "%p OUT CBaseProtocol::Suspend (hr:%lx)\n",this, hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBaseProtocol::Resume
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBaseProtocol::Resume()
{
    EProtDebugOut((DEB_PLUGPROT, "%p _IN CBaseProtocol::Resume\n", this));

    HRESULT hr = E_NOTIMPL;

    EProtDebugOut((DEB_PLUGPROT, "%p OUT CBaseProtocol::Resume (hr:%lx)\n",this, hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBaseProtocol::SetPriority
//
//  Synopsis:
//
//  Arguments:  [nPriority] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBaseProtocol::SetPriority(LONG nPriority)
{
    EProtDebugOut((DEB_PLUGPROT, "%p _IN CBaseProtocol::SetPriority\n", this));

    HRESULT hr = E_NOTIMPL;

    EProtDebugOut((DEB_PLUGPROT, "%p OUT CBaseProtocol::SetPriority (hr:%lx)\n",this, hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBaseProtocol::GetPriority
//
//  Synopsis:
//
//  Arguments:  [pnPriority] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBaseProtocol::GetPriority(LONG * pnPriority)
{
    EProtDebugOut((DEB_PLUGPROT, "%p _IN CBaseProtocol::GetPriority\n", this));

    HRESULT hr = E_NOTIMPL;

    EProtDebugOut((DEB_PLUGPROT, "%p OUT CBaseProtocol::GetPriority (hr:%lx)\n",this, hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBaseProtocol::Read
//
//  Synopsis:
//
//  Arguments:  [ULONG] --
//              [ULONG] --
//              [pcbRead] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBaseProtocol::Read(void *pv,ULONG cb,ULONG *pcbRead)
{
    EProtDebugOut((DEB_PLUGPROT, "%p _IN CBaseProtocol::Read\n", this));

    HRESULT hr = E_FAIL;

    EProtDebugOut((DEB_PLUGPROT, "%p OUT CBaseProtocol::Read (hr:%lx)\n",this, hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBaseProtocol::Seek
//
//  Synopsis:
//
//  Arguments:  [DWORD] --
//              [ULARGE_INTEGER] --
//              [plibNewPosition] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBaseProtocol::Seek(LARGE_INTEGER dlibMove,DWORD dwOrigin,ULARGE_INTEGER *plibNewPosition)
{
    EProtDebugOut((DEB_PLUGPROT, "%p _IN CBaseProtocol::Seek\n", this));

    HRESULT hr = E_FAIL;

    EProtDebugOut((DEB_PLUGPROT, "%p OUT CBaseProtocol::Seek (hr:%lx)\n",this, hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBaseProtocol::LockRequest
//
//  Synopsis:
//
//  Arguments:  [dwOptions] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBaseProtocol::LockRequest(DWORD dwOptions)
{
    EProtDebugOut((DEB_PLUGPROT, "%p _IN CBaseProtocol::LockRequest\n", this));

    HRESULT hr = NOERROR;

    EProtDebugOut((DEB_PLUGPROT, "%p OUT CBaseProtocol::LockRequest (hr:%lx)\n",this, hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBaseProtocol::UnlockRequest
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBaseProtocol::UnlockRequest()
{
    EProtDebugOut((DEB_PLUGPROT, "%p _IN CBaseProtocol::UnlockRequest\n", this));
    HRESULT hr = NOERROR;

    CloseTempFile();

    EProtDebugOut((DEB_PLUGPROT, "%p OUT CBaseProtocol::UnlockRequest (hr:%lx)\n",this, hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBaseProtocol::Prepare
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    11-07-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBaseProtocol::Prepare()
{
    EProtDebugOut((DEB_PLUGPROT, "%p _IN CBaseProtocol::Prepare\n", this));
    HRESULT hr = NOERROR;

    EProtAssert((  IsApartmentThread() ));


    EProtDebugOut((DEB_PLUGPROT,"%p OUT CBaseProtocol::Prepare (hr:%lx)\n",this, hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBaseProtocol::Continue
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    11-09-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBaseProtocol::Continue()
{
    EProtDebugOut((DEB_PLUGPROT, "%p _IN CBaseProtocol::Continue\n", this));
    HRESULT hr = NOERROR;

    EProtAssert((  !IsApartmentThread() ));

    _dwThreadID = GetCurrentThreadId();

    EProtDebugOut((DEB_PLUGPROT,"%p OUT CBaseProtocol::Continue (hr:%lx)\n",this, hr));
    return hr;
}

STDMETHODIMP CBaseProtocol::QueryService(REFGUID rsid, REFIID riid, void ** ppvObj)
{
    EProtDebugOut((DEB_PLUGPROT, "%p _IN CBaseProtocol::QueryService \n", this));
    HRESULT     hr = NOERROR;
    VDATETHIS(this);
    EProtAssert((ppvObj));

    *ppvObj = 0;

    if (riid == IID_IHttpNegotiate)
    {
        IServiceProvider *pServProv = 0;

        if ((hr = _pUnkInner->QueryInterface(IID_IServiceProvider, (void **)&pServProv)) == NOERROR)
        {
            // hand back oo
            if ((hr = pServProv->QueryService(rsid, riid, ppvObj)) == NOERROR)
            {
                _pHttpNeg = new CHttpNegotiate((IHttpNegotiate *)*ppvObj);
                if (_pHttpNeg)
                {
                    *ppvObj = _pHttpNeg;
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
            }

            pServProv->Release();
        }

    }
    else
    {
        IServiceProvider *pServProv = 0;

        if ((hr = _pUnkInner->QueryInterface(IID_IServiceProvider, (void **)&pServProv)) == NOERROR)
        {
            hr = pServProv->QueryService(rsid, riid, ppvObj);

            pServProv->Release();
        }
    }

    EProtAssert(( (hr == E_NOINTERFACE) || ((hr == NOERROR) && *ppvObj) ));

    EProtDebugOut((DEB_PLUGPROT, "%p OUT CBaseProtocol::QueryService (hr:%lx) \n", this, hr));
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CBaseProtocol::CBaseProtocol
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    1-27-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
CBaseProtocol::CBaseProtocol(REFCLSID rclsid, IUnknown *pUnkOuter, IUnknown **ppUnkInner) : _CRefs(), _pclsidProtocol(rclsid), _Unknown()
{
    EProtDebugOut((DEB_PLUGPROT, "%p _IN CBaseProtocol::CBaseProtocol \n", this));
    _dwThreadID = GetCurrentThreadId();
    _bscf = BSCF_FIRSTDATANOTIFICATION;
    _pOIBindInfo = 0;


    if (!pUnkOuter)
    {
        pUnkOuter = &_Unknown;
    }
    else
    {
        EProtAssert((ppUnkInner));
        if (ppUnkInner)
        {
            *ppUnkInner =  &_Unknown;
            _CRefs = 0;
        }
    }

    _pUnkOuter = pUnkOuter;

    EProtDebugOut((DEB_PLUGPROT, "%p OUT CBaseProtocol::CBaseProtocol \n", this));
}

//+---------------------------------------------------------------------------
//
//  Method:     CBaseProtocol::~CBaseProtocol
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    11-09-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
CBaseProtocol::~CBaseProtocol()
{

    if (_pUnkInner)
    {
        _pUnkInner->Release();
    }
    if (_pwzUrl)
    {
        delete _pwzUrl;
    }

    EProtAssert(( _hFile == NULL));

    if (_szTempFile[0] != '\0')
    {
        DeleteFile(_szTempFile);
    }

    EProtDebugOut((DEB_PLUGPROT, "%p _IN/OUT CBaseProtocol::~CBaseProtocol \n", this));
}

//+---------------------------------------------------------------------------
//
//  Method:     CBaseProtocol::CPrivUnknown::QueryInterface
//
//  Synopsis:
//
//  Arguments:  [riid] --
//              [ppvObj] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBaseProtocol::CPrivUnknown::QueryInterface(REFIID riid, void **ppvObj)
{
    VDATEPTROUT(ppvObj, void *);
    VDATETHIS(this);
    HRESULT hr = NOERROR;

    EProtDebugOut((DEB_PLUGPROT, "%p _IN CBaseProtocol::CPrivUnknown::QueryInterface\n", this));
    CBaseProtocol *pCBaseProtocol = GETPPARENT(this, CBaseProtocol, _Unknown);

    *ppvObj = NULL;

    if ((riid == IID_IUnknown) || (riid == IID_IOInetProtocol) || (riid == IID_IOInetProtocolRoot) )
    {
        *ppvObj = (IOInetProtocol *) pCBaseProtocol;
        pCBaseProtocol->AddRef();
    }
    else if (riid == IID_IOInetThreadSwitch)
    {
        *ppvObj = (IOInetThreadSwitch *)pCBaseProtocol;
        pCBaseProtocol->AddRef();
    }
    else if (riid == IID_IServiceProvider)
    {
        *ppvObj = (IServiceProvider *)pCBaseProtocol;
        pCBaseProtocol->AddRef();
    }
    else if (pCBaseProtocol->_pUnkInner)
    {
        hr = pCBaseProtocol->_pUnkInner->QueryInterface(riid, ppvObj);
    }
    else
    {
        hr = E_NOINTERFACE;
    }

    EProtDebugOut((DEB_PLUGPROT, "%p OUT CBaseProtocol::CPrivUnknown::QueryInterface (hr:%lx\n", this,hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   CBaseProtocol::CPrivUnknown::AddRef
//
//  Synopsis:
//
//  Arguments:  [ULONG] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CBaseProtocol::CPrivUnknown::AddRef(void)
{
    EProtDebugOut((DEB_PLUGPROT, "%p _IN CBaseProtocol::CPrivUnknown::AddRef\n", this));

    LONG lRet = ++_CRefs;

    EProtDebugOut((DEB_PLUGPROT, "%p OUT CBaseProtocol::CPrivUnknown::AddRef (cRefs:%ld)\n", this,lRet));
    return lRet;
}
//+---------------------------------------------------------------------------
//
//  Function:   CBaseProtocol::Release
//
//  Synopsis:
//
//  Arguments:  [ULONG] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CBaseProtocol::CPrivUnknown::Release(void)
{
    EProtDebugOut((DEB_PLUGPROT, "%p _IN CBaseProtocol::CPrivUnknown::Release\n", this));

    CBaseProtocol *pCBaseProtocol = GETPPARENT(this, CBaseProtocol, _Unknown);

    LONG lRet = --_CRefs;

    if (lRet == 0)
    {
        delete pCBaseProtocol;
    }

    EProtDebugOut((DEB_PLUGPROT, "%p OUT CBaseProtocol::CPrivUnknown::Release (cRefs:%ld)\n",this,lRet));
    return lRet;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBaseProtocol::OpenTempFile
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    11-09-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL CBaseProtocol::OpenTempFile()
{
    EProtDebugOut((DEB_PLUGPROT, "%p _IN CBaseProtocol::OpenTempFile\n", this));

    HANDLE hTempFile;
    BOOL fRet = FALSE;

    static char szTempPath[MAX_PATH+32] = {0};


    if (!szTempPath[0])
    {
        GetTempPath(MAX_PATH, szTempPath);
    }

    if (GetTempFileName(szTempPath, "Res", 0, _szTempFile))
    {
        // the file should be delete
        DWORD dwFileAtr = FILE_ATTRIBUTE_TEMPORARY;

        EProtDebugOut((DEB_PLUGPROT, "%p +++ CBaseProtocol::OpenTempFile (szFile:%s)\n",this, _szTempFile));
        hTempFile = CreateFile(_szTempFile, GENERIC_WRITE,FILE_SHARE_READ, NULL,CREATE_ALWAYS,dwFileAtr, NULL);

        if (hTempFile == INVALID_HANDLE_VALUE)
        {
            _hFile = NULL;
        }
        else
        {
            WCHAR    wzTempFile[MAX_PATH];
            A2W(_szTempFile,wzTempFile,MAX_PATH);

            _pProtSink->ReportProgress(BINDSTATUS_CACHEFILENAMEAVAILABLE, wzTempFile);
            _hFile = hTempFile;
            fRet = TRUE;
        }
    }

    EProtDebugOut((DEB_PLUGPROT, "%p OUT CBaseProtocol::OpenTempFile (_szTempFile:%s, fRet:%d)\n",this, _szTempFile, fRet));
    return fRet;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBaseProtocol::CloseTempFile
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    1-27-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL CBaseProtocol::CloseTempFile()
{
    EProtDebugOut((DEB_PLUGPROT, "%p _IN CBaseProtocol::CloseTempFile\n", this));

    BOOL fRet = FALSE;

    if (_hFile)
    {
        CloseHandle(_hFile);
        _hFile = 0;
        fRet = TRUE;
    }

    EProtDebugOut((DEB_PLUGPROT, "%p OUT CBaseProtocol::CloseTempFile (fRet:%d)\n",this, fRet));
    return fRet;
}

//+---------------------------------------------------------------------------
//
//  Function:   CreateAPP
//
//  Synopsis:
//
//  Arguments:  [rclsid] --
//              [pUnkOuter] --
//              [riid] --
//              [ppUnk] --
//
//  Returns:
//
//  History:    11-09-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CreateAPP(REFCLSID rclsid, IUnknown *pUnkOuter, REFIID riid, IUnknown **ppUnk)
{
    EProtDebugOut((DEB_PLUGPROT, "API _IN CreateKnownProtocolInstance\n"));
    HRESULT hr = NOERROR;

    EProtAssert((ppUnk));

    if (!ppUnk || (pUnkOuter && (riid != IID_IUnknown)) )
    {
        // Note: aggregation only works if asked for IUnknown
        EProtAssert((FALSE && "Dude, look up aggregation rules - need to ask for IUnknown"));
        hr = E_INVALIDARG;
    }
    else
    {
        CBaseProtocol *pCBaseProtocol = NULL;

        if (rclsid == CLSID_CdlProtocol)
        {
            pCBaseProtocol = new CCdlProtocol(CLSID_CdlProtocol,pUnkOuter, ppUnk);
        }

#ifdef TEST_EAPP
        else if (rclsid == CLSID_OhServNameSp)
        {
            pCBaseProtocol = new COhServNameSp(CLSID_OhServNameSp,pUnkOuter, ppUnk);
        }
        else if (rclsid == CLSID_MimeHandlerTest1)
        {
            pCBaseProtocol = new CMimeHandlerTest1(CLSID_MimeHandlerTest1,pUnkOuter, ppUnk);
        }
        else if (rclsid == CLSID_ResProtocol)
        {
            pCBaseProtocol = new CResProtocol(CLSID_ResProtocol,pUnkOuter, ppUnk);
        }
#endif

        if (pCBaseProtocol)
        {
            if (riid == IID_IUnknown)
            {

            }
            else if (riid == IID_IOInetProtocol)
            {
                // ok, got the right interface already
                *ppUnk = (IOInetProtocol *)pCBaseProtocol;
            }
            else
            {
                hr = pCBaseProtocol->QueryInterface(riid, (void **)ppUnk);
                // remove extra refcount
                pCBaseProtocol->Release();
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    EProtDebugOut((DEB_PLUGPROT, "API OUT CreateKnownProtocolInstance(hr:%lx)\n", hr));
    return hr;
}

HRESULT CBaseProtocol::ObtainService(REFGUID rsid, REFIID riid, void ** ppvObj)
{
    EProtDebugOut((DEB_PLUGPROT, "%p _IN CBaseProtocol::ObtainService \n", this));
    HRESULT     hr = NOERROR;
    VDATETHIS(this);
    LPVOID pvLocal = NULL;

#ifdef unusedXXX
    CBSCNode   *pNode;
    pNode = _pCBSCNode;

    if (riid == IID_IHttpNegotiate)
    {
        *ppvObj = (void*)(IHttpNegotiate *) this;
        AddRef();

        // loop once to get all interfaces
        if (!_fHttpNegotiate)
        {
            while (pNode)
            {
                if (   (pNode->GetBSCB()->QueryInterface(riid, &pvLocal) == NOERROR)
                    || (   pNode->GetServiceProvider()
                        && (pNode->GetHttpNegotiate() == NULL)
                        && (pNode->GetServiceProvider()->QueryService(riid, riid, &pvLocal)) == NOERROR)
                    )
                {
                    // Note: the interface is addref'd by QI or QS
                    pNode->SetHttpNegotiate((IHttpNegotiate *)pvLocal);
                }

                pNode = pNode->GetNextNode();
            }

            _fHttpNegotiate = TRUE;
        }
    }
    else if (riid == IID_IAuthenticate)
    {
        *ppvObj = (void*)(IAuthenticate *) this;
        AddRef();

        if (!_fAuthenticate)
        {
            while (pNode)
            {
                if (   (pNode->GetBSCB()->QueryInterface(riid, &pvLocal) == NOERROR)
                    || (   pNode->GetServiceProvider()
                        && (pNode->GetAuthenticate() == NULL)
                        && (pNode->GetServiceProvider()->QueryService(riid, riid, &pvLocal)) == NOERROR)
                    )
                {
                    // Note: the interface is addref'd by QI or QS
                    pNode->SetAuthenticate((IAuthenticate *)pvLocal);
                }

                pNode = pNode->GetNextNode();
            }

            _fAuthenticate = TRUE;
        }

    }
    else
    {
        *ppvObj = NULL;
        hr = E_NOINTERFACE;

        while (pNode)
        {
            if (   (pNode->GetBSCB()->QueryInterface(riid, &pvLocal) == NOERROR)
                || (   pNode->GetServiceProvider()
                    && (pNode->GetServiceProvider()->QueryService(riid, riid, &pvLocal)) == NOERROR)
                )
            {
                *ppvObj = pvLocal;
                hr = NOERROR;
                // Note: the interface is addref'd by QI or QS
                // stop looking at other nodes for this service
                pNode = NULL;
            }

            if (pNode)
            {
                pNode = pNode->GetNextNode();
            }
        }
    }
#endif //unused

    EProtDebugOut((DEB_PLUGPROT, "%p OUT CBaseProtocol::ObtainService (hr:%lx) \n", this, hr));
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CHttpNegotiate::QueryInterface
//
//  Synopsis:
//
//  Arguments:  [riid] --
//              [ppvObj] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CHttpNegotiate::QueryInterface(REFIID riid, void **ppvObj)
{
    VDATEPTROUT(ppvObj, void *);
    VDATETHIS(this);
    HRESULT hr = NOERROR;

    EProtDebugOut((DEB_PLUGPROT, "%p _IN CHttpNegotiate::QueryInterface\n", this));

    if ((riid == IID_IUnknown) || (riid == IID_IHttpNegotiate))
    {
        *ppvObj = (IHttpNegotiate *) this;
        AddRef();
    }
    else
    {
        hr = E_NOINTERFACE;
    }

    EProtDebugOut((DEB_PLUGPROT, "%p OUT CHttpNegotiate::QueryInterface (hr:%lx\n", this,hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   CHttpNegotiate::AddRef
//
//  Synopsis:
//
//  Arguments:  [ULONG] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CHttpNegotiate::AddRef(void)
{
    EProtDebugOut((DEB_PLUGPROT, "%p _IN CHttpNegotiate::AddRef\n", this));

    LONG lRet = ++_CRefs;

    EProtDebugOut((DEB_PLUGPROT, "%p OUT CHttpNegotiate::AddRef (cRefs:%ld)\n", this,lRet));
    return lRet;
}

//+---------------------------------------------------------------------------
//
//  Function:   CHttpNegotiate::Release
//
//  Synopsis:
//
//  Arguments:  [ULONG] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CHttpNegotiate::Release(void)
{
    EProtDebugOut((DEB_PLUGPROT, "%p _IN CHttpNegotiate::Release\n", this));

    LONG lRet = --_CRefs;

    if (lRet == 0)
    {
        delete this;
    }

    EProtDebugOut((DEB_PLUGPROT, "%p OUT CHttpNegotiate::Release (cRefs:%ld)\n",this,lRet));
    return lRet;
}

//+---------------------------------------------------------------------------
//
//  Method:     CHttpNegotiate::BeginningTransaction
//
//  Synopsis:
//
//  Arguments:  [szURL] --
//              [szHeaders] --
//              [dwReserved] --
//              [pszAdditionalHeaders] --
//
//  Returns:
//
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CHttpNegotiate::BeginningTransaction(LPCWSTR szURL, LPCWSTR szHeaders,
            DWORD dwReserved, LPWSTR *pszAdditionalHeaders)
{
    EProtDebugOut((DEB_PLUGPROT, "%p _IN CHttpNegotiate::BeginningTransaction (szURL:%ws, szHeaders:%ws)\n", this, szURL, szHeaders));
    VDATETHIS(this);
    HRESULT    hr = NOERROR;
    LPWSTR     szTmp = NULL, szNew = NULL, szRunning = NULL;

    EProtAssert((szURL));


    EProtDebugOut((DEB_PLUGPROT, "%p OUT CHttpNegotiate::BeginningTransaction (pszAdditionalHeaders:%ws )\n", this, *pszAdditionalHeaders));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CHttpNegotiate::OnResponse
//
//  Synopsis:
//
//  Arguments:  [LPCWSTR] --
//              [szResponseHeaders] --
//              [LPWSTR] --
//              [pszAdditionalRequestHeaders] --
//
//  Returns:
//
//  History:    4-05-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CHttpNegotiate::OnResponse(DWORD dwResponseCode,LPCWSTR wzResponseHeaders,
                        LPCWSTR wzRequestHeaders,LPWSTR *pszAdditionalRequestHeaders)
{
    EProtDebugOut((DEB_PLUGPROT, "%p _IN CHttpNegotiate::OnResponse\n", this));
    VDATETHIS(this);
    HRESULT    hr;
    LPWSTR     szTmp = NULL, szNew = NULL, szRunning = NULL;

    hr = IsStatusOk(dwResponseCode) ? S_OK : S_FALSE;

    EProtDebugOut((DEB_PLUGPROT, "%p OUT CHttpNegotiate::OnResponse\n", this));
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\iapp\cnet.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       cnet.cxx
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    12-04-95   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------
#include <iapp.h>
#include <winineti.h>   // contains bogus INTERNET_FLAG_NO_UI
#include <shlwapip.h>

CMutexSem g_mxsSession; // single access to InternetOpen


PerfDbgTag(tagCINet,    "Urlmon", "Log CINet",         DEB_PROT);
PerfDbgTag(tagCINetErr, "Urlmon", "Log CINet Errors",  DEB_PROT|DEB_ERROR);
LONG UrlMonInvokeExceptionFilter( DWORD lCode, LPEXCEPTION_POINTERS lpep );
DWORD StrLenMultiByteWithMlang(LPCWSTR, DWORD);
BOOL  ConvertUnicodeUrl(LPCWSTR, LPSTR, INT, DWORD, BOOL, BOOL*);
DWORD CountUnicodeToUtf8(LPCWSTR, DWORD, BOOL);
extern BOOL g_bGlobalUTF8Enabled;

#define INTERNET_POLICIES_KEY    "SOFTWARE\\Policies\\Microsoft\\Windows\\CurrentVersion\\Internet Settings"

typedef UINT (WINAPI *GetSystemWow64DirectoryPtr) (LPTSTR lpBuffer, UINT uSize);

// Need this in GetUserAgentString.
HRESULT CallRegInstall(LPSTR szSection);

HRESULT EnsureSecurityManager ();

class CInetState
{
    enum WHAT_STATE
    {
         INETSTATE_NONE      = 0
        ,INETSTATE_SET       = 1
        ,INETSTATE_HANDLED   = 2
    };

public:
    void SetState(DWORD dwState)
    {
        DEBUG_ENTER((DBG_APP,
                    None,
                    "CInetState::SetState",
                    "this=%#x, %#x",
                    this, dwState
                    ));
                    
        CLock lck(_mxs);
        _dwState = dwState;
        _What = INETSTATE_SET;

        DEBUG_LEAVE(0);
    }
    HRESULT HandleState()
    {
        DEBUG_ENTER((DBG_APP,
                    Hresult,
                    "CInetState::HandleState",
                    "this=%#x",
                    this
                    ));
                    
        HRESULT hr = NOERROR;
        DWORD dwStateNow;
        BOOL fPropagate;

        {
            CLock lck(_mxs);
            dwStateNow = _dwState;
            fPropagate = (_What == INETSTATE_SET) ? TRUE : FALSE;
            _What = INETSTATE_HANDLED;
        }

        if (fPropagate)
        {
            hr = PropagateStateChange(dwStateNow);
        }

        DEBUG_LEAVE(hr);
        return hr;
    }

    HRESULT PropagateStateChange(DWORD dwState);

    CInetState()
    {
        DEBUG_ENTER((DBG_APP,
                    None,
                    "CInetState::CInetState",
                    "this=%#x",
                    this
                    ));
                    
        _dwState = 0;
        _What = INETSTATE_NONE;

        DEBUG_LEAVE(0);
    }

    ~CInetState()
    {
        DEBUG_ENTER((DBG_APP,
                    None,
                    "CInetState::~CInetState",
                    "this=%#x",
                    this
                    ));
    
        DEBUG_LEAVE(0);
    }

private:
    CMutexSem   _mxs;
    DWORD       _dwState;
    WHAT_STATE  _What;
};

//+---------------------------------------------------------------------------
//
//  Method:     CInetState::PropagateStateChange
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    1-22-1997   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CInetState::PropagateStateChange(DWORD dwWhat)
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CInetState::PropagateStateChange",
                "this=%#x, %#x",
                this, dwWhat
                ));
                    
    PerfDbgLog(tagCINet, this, "+CInetState::PropagateStateChange");
    HRESULT hr = NOERROR;

//  BUGBUG: IE5 need to implement these!
#if 0
    if (dwWhat & INTERNET_STATE_CONNECTED)
    {
        NotfDeliverNotification(
                                NOTIFICATIONTYPE_CONNECT_TO_INTERNET  // REFNOTIFICATIONTYPE rNotificationType
                               ,CLSID_PROCESS_BROADCAST     // REFCLSID            rClsidDest
                               ,(DELIVERMODE)0              // DELIVERMODE         deliverMode
                               ,0                           // DWORD               dwReserved
                               );

    }
    if (dwWhat & INTERNET_STATE_DISCONNECTED)
    {
        NotfDeliverNotification(
                                NOTIFICATIONTYPE_DISCONNECT_FROM_INTERNET  // REFNOTIFICATIONTYPE rNotificationType
                               ,CLSID_PROCESS_BROADCAST     // REFCLSID            rClsidDest
                               ,(DELIVERMODE)0              // DELIVERMODE         deliverMode
                               ,0                           // DWORD               dwReserved
                               );
    }
    if (dwWhat & INTERNET_STATE_DISCONNECTED_BY_USER)
    {
        NotfDeliverNotification(
                                NOTIFICATIONTYPE_CONFIG_CHANGED  // REFNOTIFICATIONTYPE rNotificationType
                               ,CLSID_PROCESS_BROADCAST     // REFCLSID            rClsidDest
                               ,(DELIVERMODE)0              // DELIVERMODE         deliverMode
                               ,0                           // DWORD               dwReserved
                               );

    }

    #ifdef _with_idle_and_busy_
        //
        // NOTE: wininet will send idle with every state change
        //       will be fixed by RFirth
        if (dwWhat & INTERNET_STATE_IDLE)
        {
            NotfDeliverNotification(
                                    NOTIFICATIONTYPE_INET_IDLE  // REFNOTIFICATIONTYPE rNotificationType
                                   ,CLSID_PROCESS_BROADCAST     // REFCLSID            rClsidDest
                                   ,(DELIVERMODE)0              // DELIVERMODE         deliverMode
                                   ,0                           // DWORD               dwReserved
                                   );
        }
        if (dwWhat & INTERNET_STATE_BUSY)
        {
            NotfDeliverNotification(
                                    NOTIFICATIONTYPE_INET_BUSY  // REFNOTIFICATIONTYPE rNotificationType
                                   ,CLSID_PROCESS_BROADCAST     // REFCLSID            rClsidDest
                                   ,(DELIVERMODE)0              // DELIVERMODE         deliverMode
                                   ,0                           // DWORD               dwReserved
                                   );

        }
    #endif //_with_idle_and_busy_

#endif // 0
    PerfDbgLog1(tagCINet, this, "-CInetState:PropagateStateChange (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//
// REMOVE THIS joHANNP
//

extern  LPSTR               g_pszUserAgentString;
HINTERNET                   g_hSession;
CInetState                  g_cInetState;

char vszLocationTag[] = "Location: ";

static DWORD dwLstError;

typedef struct tagProtocolInfo
{
    LPWSTR          pwzProtocol;
    LPSTR           pszProtocol;
    DWORD           dwId;
    CLSID           *pClsID;
    int             protlen;
} ProtocolInfo;



extern IInternetSecurityManager* g_pSecurityManager; // to handle GetSecurityId for cookies fix.

/*
    This function is not heavy on error-checking:
    The ASSERTS in the code MUST be satisfied for this function to work

    NOTE: don't care about OPAQUE urls since they are NOT http by definition.
 */

enum ComparisonState
{
    seenZone=1,
    seen1Dot,
    seen2Dots,
    seen3Dots,
    domainSame
};

#define MAKELOWER(val) (((val) > 'a') ? (val) : ((val)-'A'+'a'))

BOOL IsKnown2ndSubstring(BYTE* pStart, BYTE* pEnd)
{
    static const char *s_pachSpecialDomains[] = {"COM",     "EDU",      "NET",      "ORG",      "GOV",      "MIL",      "INT"};
    static const DWORD s_padwSpecialDomains[] = {0x00636f6d, 0x00656475, 0x006e6574, 0x006f7267, 0x00676f76, 0x006d696c, 0x00696e74};
    BOOL bKnown = FALSE;
    int nLen = (int) (pEnd-pStart+1);

    if ((nLen==2) && !StrCmpNI((LPCSTR)pStart, "CO", nLen))
    {
        bKnown = TRUE;
    }
    else if (nLen==3)
    {
        DWORD dwExt, dwByte;

        dwByte = *pStart++;
        dwExt = MAKELOWER(dwByte);
        dwExt <<= 8;
        dwByte = *pStart++;
        dwExt |= MAKELOWER(dwByte);
        dwExt <<= 8;
        dwByte = *pStart++;
        dwExt |= MAKELOWER(dwByte);

        for (int i=0; i<sizeof(s_padwSpecialDomains);)
        {
            if (dwExt == s_padwSpecialDomains[i++])
            {
                bKnown = TRUE;
                break;
            }
        }
    }

    return bKnown;
}
    
BOOL SecurityIdsMatch(BYTE* pbSecurityId1, DWORD dwLen1, BYTE* pbSecurityId2, DWORD dwLen2)
{
    //ASSERT((pbSecurityId1 && pbSecurityId2 && (dwLen1 > 0) && (dwLen2 > 0)));

    ComparisonState currState;
    BOOL bRetval = FALSE;
    //BOOL bRetval = ((dwLen1 == dwLen2) && (0 == memcmp(pbSecurityId1, pbSecurityId2, dwLen1)));

    BYTE *pCurr1, *pCurr2;
    DWORD dwDomainLen1, dwDomainLen2; //sizes of securityId w/o protocol.
    
    pCurr1 = pbSecurityId1;
    while(*pCurr1++ != ':');
    dwDomainLen1 = (DWORD)(pCurr1-pbSecurityId1);

    pCurr2 = pbSecurityId2;
    while(*pCurr2++ != ':');
    dwDomainLen2 = (DWORD)(pCurr2-pbSecurityId2);
    
    DEBUG_ENTER((DBG_APP,
                Bool,
                "SecurityIdsMatch",
                "%#x, %d, domainLen=%d %#x, %d, domainLen=%d",
                pbSecurityId1, dwLen1, dwDomainLen1, pbSecurityId2, dwLen2, dwDomainLen2
                ));

    BYTE *pBase1, *pBase2;
    BYTE bLeftByte, bRightByte;
    DWORD cbSubstring1 = 0;
    BYTE *pSubstring2Start = NULL;
    BYTE *pSubstring2End = NULL;
    
    //pCurr1 is the shorter one
    if (dwDomainLen1 < dwDomainLen2)
    {
        pCurr1 = pbSecurityId1+dwLen1-1-sizeof(DWORD);
        pBase1 = pbSecurityId1;
        pCurr2 = pbSecurityId2+dwLen2-1-sizeof(DWORD);
        pBase2 = pbSecurityId2;
    }
    else
    {
        pCurr2 = pbSecurityId1+dwLen1-1-sizeof(DWORD);
        pBase2 = pbSecurityId1;
        pCurr1 = pbSecurityId2+dwLen2-1-sizeof(DWORD);
        pBase1 = pbSecurityId2;
    }
    
    /* compare zone dword 
    if (memcmp(pCurr1, pCurr2, sizeof(DWORD)))
        goto End;
     */
     
    /* compare domains */
    currState = seenZone;
    while ((pCurr1 > pBase1) && (pCurr2 > pBase2))
    {
        if ((bLeftByte=*pCurr1--) == (bRightByte=*pCurr2--))
        {
            /* valid assumption? no ':' in domain name */
            //ASSERT(((currState==seenZone) && (bLeftByte == ':')))
            
            if ((bLeftByte == '.') && (currState < seen3Dots))
            {
                currState = (ComparisonState)(currState+1);
                switch (currState)
                {
                case seen1Dot:
                    pSubstring2End = pCurr1;
                    break;
                case seen2Dots:
                    pSubstring2Start = pCurr1+2;
                    break;
                }
            }
            else if (bLeftByte == ':')
            {
                currState = domainSame;
                break;
            }
            else if (currState == seenZone)
                cbSubstring1++;
        }
        else
            break;
    }

    switch (currState)
    {
    case seenZone:
    /* NOTE: this rules out http:ieinternal and http:foo.ieinternal not to be INCLUDED */
    /* The alternative is to risk http:com and http:www.microsoft.com */
        goto End;
    case seen1Dot:
    /*  INCLUDE http:microsoft.com and http:www.microsoft.com, 
         ( http:a.micro.com and http:b.micro.com included by seen2Dots )
        
        EXCLUDE http:co.uk and http:www.microsoft.co.uk 
        and all else
        eg. http:amicrosoft.com and http:www.microsoft.com
            &
            http:microsoft.com and http:amicrosoft.com
     */
        if ((bLeftByte != ':') || (bRightByte != '.') || ((cbSubstring1 == 2) && IsKnown2ndSubstring(pCurr1+2, pSubstring2End)))
            goto End;
        break;
    case seen2Dots:
    /*  INCLUDE http:ood.microsoft.com and http:food.microsoft.com
        INCLUDE http:a.co.uk and http:b.a.co.uk
        
        EXCLUDE http:www.microsoft.co.uk and http:www.amicrosoft.co.uk
     */
        if ((cbSubstring1 == 2) && IsKnown2ndSubstring(pSubstring2Start, pSubstring2End) && ((bLeftByte != ':') || (bRightByte != '.')))
            goto End;
        break;
    case seen3Dots:
    /*  INCLUDES all cases including 
            http:food.microsoft.co.uk and http:drink.microsoft.co.uk */
    case domainSame:
    /*  INCLUDES all equal domain cases of all substring sizes, including intranet sites */
        break;
    }

    /* no longer compare the protocols.
       if we get to this point, then the SecurityId's match.
     */
    bRetval = TRUE;
    
End:    
    DEBUG_LEAVE(bRetval);

    return bRetval;
}

BOOL SecurityIdContainsScheme(BYTE* pbSecurityId, DWORD dwLen)
{
    BYTE* pCurr = pbSecurityId;
    BOOL fRet = TRUE;

    while ( (DWORD)(pCurr-pbSecurityId) < dwLen )
    {
        if (*pCurr++ == ':')
        {
            goto End;
            break;
        }
    }
    fRet = FALSE;

End:
    return fRet;
}
    
//returns S_OK if they match, 
//        S_FALSE if they don't ( i.e. THIRD PARTY )
STDAPI CompareSecurityIds(BYTE* pbSecurityId1, DWORD dwLen1, BYTE* pbSecurityId2, DWORD dwLen2, DWORD dwReserved)
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CompareSecurityIds",
                "%#x, %#x, %#x, %#x, %#x",
                pbSecurityId1, dwLen1, pbSecurityId2, dwLen2, dwReserved
                ));
                
    HRESULT hr = E_INVALIDARG;
    BOOL fRet;

    //parameter validation
    if ((dwLen1 <= 0) || (!pbSecurityId1) || (dwLen2 <= 0) || (!pbSecurityId2))
        goto End;

    if (!SecurityIdContainsScheme(pbSecurityId1, dwLen1) ||
        !SecurityIdContainsScheme(pbSecurityId2, dwLen2))
            goto End;

    fRet = SecurityIdsMatch(pbSecurityId1, dwLen1, pbSecurityId2, dwLen2);

    if (fRet == TRUE)
        hr = S_OK;
    else
        hr = S_FALSE;
        
End:
    DEBUG_LEAVE(hr);
    return hr;
}

BOOL CINet::IsThirdPartyUrl(LPCWSTR pwszUrl)
{
    DEBUG_ENTER((DBG_APP,
                Bool,
                "CINet::IsThirdPartyUrl",
                "this=%#x, %.80wq",
                this, pwszUrl
                ));
                
    BOOL bRetval = TRUE; // be safe or sorry?
    HRESULT hr = NOERROR;
    BYTE            bSID[MAX_SIZE_SECURITY_ID];
    DWORD           cbSID = MAX_SIZE_SECURITY_ID;

    if(!SUCCEEDED(hr = EnsureSecurityManager()))
    {
        goto End;
    }

    if (_pbRootSecurityId == NULL)
    {
//        ASSERT(FALSE);
        goto End;
    }
    else if (_pbRootSecurityId == INVALID_P_ROOT_SECURITY_ID)
    {
        bRetval = FALSE;
        goto End;
    }
      
    hr = g_pSecurityManager->GetSecurityId( pwszUrl, bSID, &cbSID, 0 );

    if (FAILED(hr))
        goto End;

    bRetval = !SecurityIdsMatch(bSID, cbSID, _pbRootSecurityId, _cbRootSecurityId);

End:
    DEBUG_LEAVE(bRetval);
    return bRetval;

}
        
BOOL CINet::IsThirdPartyUrl(LPCSTR pszUrl)
{
    DEBUG_ENTER((DBG_APP,
                Bool,
                "CINet::IsThirdPartyUrl",
                "this=%#x, %.80q",
                this, pszUrl
                ));
                
    WCHAR pwszUrl[MAX_URL_SIZE];
    BOOL bRetval = TRUE; // be safe or sorry?

    if(MultiByteToWideChar(CP_ACP, 0, pszUrl, -1, pwszUrl, MAX_URL_SIZE))
        bRetval = IsThirdPartyUrl(pwszUrl);

    DEBUG_LEAVE(bRetval);
    return bRetval;
}

//+---------------------------------------------------------------------------
//
//  Function:   CreateKnownProtocolInstance
//
//  Synopsis:
//
//  Arguments:  [dwProtId] --
//              [rclsid] --
//              [pUnkOuter] --
//              [riid] --
//              [ppUnk] --
//
//  Returns:
//
//  History:    11-01-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CreateKnownProtocolInstance(DWORD dwProtId, REFCLSID rclsid, IUnknown *pUnkOuter, REFIID riid, IUnknown **ppUnk)
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CreateKnownProtocolInstance",
                "%#x, %#x, %#x, %#x, %#x",
                dwProtId, &rclsid, pUnkOuter, &riid, ppUnk
                ));
                
    PerfDbgLog(tagCINet, NULL, "+CreateKnownProtocolInstance");
    HRESULT hr = NOERROR;
    CINet *pCINet = NULL;

    PProtAssert((ppUnk));

    if (!ppUnk || (pUnkOuter && (riid != IID_IUnknown)) )
    {
        // Note: aggregation only works if asked for IUnknown
        PProtAssert((FALSE && "Dude, look up aggregation rules - need to ask for IUnknown"));
        hr = E_INVALIDARG;
    }
    #if 0
    else if (riid == IID_IOInetProtocolInfo)
    {
        PProtAssert((dwProtId != DLD_PROTOCOL_NONE));
        COInetProtocolInfo *pProtInfo = new COInetProtocolInfo(dwProtId);
        if (pProtInfo)
        {
            hr = pProtInfo->QueryInterface(IID_IOInetProtocolInfo, (void **)ppUnk);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    #endif // 0
    else if (dwProtId != DLD_PROTOCOL_NONE)
    {
        CINet *pCINet = NULL;

        switch (dwProtId)
        {
        case  DLD_PROTOCOL_LOCAL  :
        case  DLD_PROTOCOL_FILE   :
            pCINet = new CINetFile(CLSID_FileProtocol,pUnkOuter);
        break;
        case  DLD_PROTOCOL_HTTP   :
            pCINet = new CINetHttp(CLSID_HttpProtocol,pUnkOuter);
        break;
        case  DLD_PROTOCOL_FTP    :
            pCINet = new CINetFtp(CLSID_FtpProtocol,pUnkOuter);
        break;
        case  DLD_PROTOCOL_GOPHER :
            pCINet = new CINetGopher(CLSID_GopherProtocol,pUnkOuter);
        break;
        case  DLD_PROTOCOL_HTTPS  :
            pCINet = new CINetHttpS(CLSID_HttpSProtocol,pUnkOuter);
        break;
        case  DLD_PROTOCOL_STREAM :
            pCINet = new CINetStream(CLSID_MkProtocol,pUnkOuter);
        break;
        default:
            PProtAssert((FALSE));
            hr = E_FAIL;
        }

        if (hr == NOERROR)
        {
            if (pCINet)
            {
                if (riid == IID_IUnknown)
                {
                    // pCINet has refcount of 1 now

                    // get the pUnkInner
                    // pUnkInner does not addref pUnkOuter
                    if (pUnkOuter && ppUnk)
                    {
                        *ppUnk = pCINet->GetIUnkInner(TRUE);
                        // addref the outer object since releasing pCINet will go cause a release on pUnkOuter
                        TransAssert((*ppUnk));
                    }
                }
                else
                {
                    if (riid == IID_IOInetProtocol)
                    {
                        // ok, got the right interface already
                        *ppUnk = (IOInetProtocol *)pCINet;
                    }
                    else
                    {
                        hr = pCINet->QueryInterface(riid, (void **)ppUnk);
                        // remove extra refcount
                        pCINet->Release();
                    }
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }

        }
    }
    else
    {
        //load the protocol by looking up the registry
        hr = E_FAIL;
    }


    PerfDbgLog1(tagCINet, NULL, "-CreateKnownProtocolInstance(hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

ProtocolInfo rgKnownProts[] =
{
     { L"http"  , "http"   , DLD_PROTOCOL_HTTP   , (CLSID *) &CLSID_HttpProtocol  , sizeof("http")   - 1 }
    ,{ L"file"  , "file"   , DLD_PROTOCOL_FILE   , (CLSID *) &CLSID_FileProtocol  , sizeof("file")   - 1 }
    ,{ L"ftp"   , "ftp"    , DLD_PROTOCOL_FTP    , (CLSID *) &CLSID_FtpProtocol   , sizeof("ftp")    - 1 }
    ,{ L"https" , "https"  , DLD_PROTOCOL_HTTPS  , (CLSID *) &CLSID_HttpSProtocol , sizeof("http")   - 1 }
    ,{ L"mk"    , "mk"     , DLD_PROTOCOL_STREAM , (CLSID *) &CLSID_MkProtocol    , sizeof("mk")     - 1 }
    ,{ L"gopher", "Gopher" , DLD_PROTOCOL_GOPHER , (CLSID *) &CLSID_GopherProtocol, sizeof("gopher") - 1 }
    ,{ L"local" , "local"  , DLD_PROTOCOL_LOCAL  , (CLSID *) &CLSID_FileProtocol  , sizeof("local")  - 1 }
};

typedef struct tagInterErrorToHResult
{
    DWORD   dwError;
    HRESULT hresult;
} InterErrorToHResult;

InterErrorToHResult INetError[] =
{
     0                                        ,NOERROR
    ,ERROR_INTERNET_OUT_OF_HANDLES            ,INET_E_DOWNLOAD_FAILURE
    ,ERROR_INTERNET_TIMEOUT                   ,INET_E_CONNECTION_TIMEOUT
    ,ERROR_INTERNET_EXTENDED_ERROR            ,INET_E_DOWNLOAD_FAILURE
    ,ERROR_INTERNET_INTERNAL_ERROR            ,INET_E_DOWNLOAD_FAILURE
    ,ERROR_INTERNET_INVALID_URL               ,INET_E_INVALID_URL
    ,ERROR_INTERNET_UNRECOGNIZED_SCHEME       ,INET_E_UNKNOWN_PROTOCOL
    ,ERROR_INTERNET_NAME_NOT_RESOLVED         ,INET_E_RESOURCE_NOT_FOUND
    ,ERROR_INTERNET_PROTOCOL_NOT_FOUND        ,INET_E_UNKNOWN_PROTOCOL
    ,ERROR_INTERNET_INVALID_OPTION            ,INET_E_DOWNLOAD_FAILURE
    ,ERROR_INTERNET_BAD_OPTION_LENGTH         ,INET_E_DOWNLOAD_FAILURE
    ,ERROR_INTERNET_OPTION_NOT_SETTABLE       ,INET_E_DOWNLOAD_FAILURE
    ,ERROR_INTERNET_SHUTDOWN                  ,INET_E_DOWNLOAD_FAILURE
    ,ERROR_INTERNET_INCORRECT_USER_NAME       ,INET_E_DOWNLOAD_FAILURE
    ,ERROR_INTERNET_INCORRECT_PASSWORD        ,INET_E_DOWNLOAD_FAILURE
    ,ERROR_INTERNET_LOGIN_FAILURE             ,INET_E_DOWNLOAD_FAILURE
    ,ERROR_INTERNET_INVALID_OPERATION         ,INET_E_DOWNLOAD_FAILURE
    ,ERROR_INTERNET_OPERATION_CANCELLED       ,INET_E_DOWNLOAD_FAILURE
    ,ERROR_INTERNET_INCORRECT_HANDLE_TYPE     ,INET_E_DOWNLOAD_FAILURE
    ,ERROR_INTERNET_INCORRECT_HANDLE_STATE    ,INET_E_DOWNLOAD_FAILURE
    ,ERROR_INTERNET_NOT_PROXY_REQUEST         ,INET_E_DOWNLOAD_FAILURE
    ,ERROR_INTERNET_REGISTRY_VALUE_NOT_FOUND  ,INET_E_DOWNLOAD_FAILURE
    ,ERROR_INTERNET_BAD_REGISTRY_PARAMETER    ,INET_E_DOWNLOAD_FAILURE
    ,ERROR_INTERNET_NO_DIRECT_ACCESS          ,INET_E_DOWNLOAD_FAILURE
    ,ERROR_INTERNET_NO_CONTEXT                ,INET_E_DOWNLOAD_FAILURE
    ,ERROR_INTERNET_NO_CALLBACK               ,INET_E_DOWNLOAD_FAILURE
    ,ERROR_INTERNET_REQUEST_PENDING           ,INET_E_DOWNLOAD_FAILURE
    ,ERROR_INTERNET_INCORRECT_FORMAT          ,INET_E_DOWNLOAD_FAILURE
    ,ERROR_INTERNET_ITEM_NOT_FOUND            ,INET_E_OBJECT_NOT_FOUND
    ,ERROR_INTERNET_CANNOT_CONNECT            ,INET_E_RESOURCE_NOT_FOUND
    ,ERROR_INTERNET_CONNECTION_ABORTED        ,INET_E_DOWNLOAD_FAILURE
    ,ERROR_INTERNET_CONNECTION_RESET          ,INET_E_DOWNLOAD_FAILURE
    ,ERROR_INTERNET_FORCE_RETRY               ,INET_E_DOWNLOAD_FAILURE
    ,ERROR_INTERNET_INVALID_PROXY_REQUEST     ,INET_E_DOWNLOAD_FAILURE
    ,ERROR_INTERNET_NEED_UI                   ,INET_E_DOWNLOAD_FAILURE
    ,0                                        ,INET_E_DOWNLOAD_FAILURE
    ,ERROR_INTERNET_HANDLE_EXISTS             ,INET_E_DOWNLOAD_FAILURE
    ,ERROR_INTERNET_SEC_CERT_DATE_INVALID     ,INET_E_SECURITY_PROBLEM
    ,ERROR_INTERNET_SEC_CERT_CN_INVALID       ,INET_E_SECURITY_PROBLEM
    ,ERROR_INTERNET_HTTP_TO_HTTPS_ON_REDIR    ,INET_E_DOWNLOAD_FAILURE
    ,ERROR_INTERNET_HTTPS_TO_HTTP_ON_REDIR    ,INET_E_DOWNLOAD_FAILURE
    ,ERROR_INTERNET_MIXED_SECURITY            ,INET_E_SECURITY_PROBLEM
    ,ERROR_INTERNET_CHG_POST_IS_NON_SECURE    ,INET_E_SECURITY_PROBLEM
    ,ERROR_INTERNET_POST_IS_NON_SECURE        ,INET_E_SECURITY_PROBLEM
    ,ERROR_INTERNET_CLIENT_AUTH_CERT_NEEDED   ,INET_E_SECURITY_PROBLEM
    ,ERROR_INTERNET_INVALID_CA                ,INET_E_SECURITY_PROBLEM
    ,ERROR_INTERNET_CLIENT_AUTH_NOT_SETUP     ,INET_E_SECURITY_PROBLEM
    ,ERROR_INTERNET_SEC_CERT_REV_FAILED       ,INET_E_SECURITY_PROBLEM
    ,ERROR_INTERNET_SEC_CERT_REVOKED          ,INET_E_SECURITY_PROBLEM
    ,ERROR_INTERNET_FORTEZZA_LOGIN_NEEDED     ,INET_E_SECURITY_PROBLEM
    ,ERROR_INTERNET_ASYNC_THREAD_FAILED       ,INET_E_DOWNLOAD_FAILURE
    ,ERROR_INTERNET_REDIRECT_SCHEME_CHANGE    ,INET_E_DOWNLOAD_FAILURE
};

// list of non-sequential errors
InterErrorToHResult INetErrorExtended[] =
{
     ERROR_FTP_TRANSFER_IN_PROGRESS           ,INET_E_DOWNLOAD_FAILURE
    ,ERROR_FTP_DROPPED                        ,INET_E_DOWNLOAD_FAILURE
    ,ERROR_GOPHER_PROTOCOL_ERROR              ,INET_E_DOWNLOAD_FAILURE
    ,ERROR_GOPHER_NOT_FILE                    ,INET_E_DOWNLOAD_FAILURE
    ,ERROR_GOPHER_DATA_ERROR                  ,INET_E_DOWNLOAD_FAILURE
    ,ERROR_GOPHER_END_OF_DATA                 ,INET_E_DOWNLOAD_FAILURE
    ,ERROR_GOPHER_INVALID_LOCATOR             ,INET_E_DOWNLOAD_FAILURE
    ,ERROR_GOPHER_INCORRECT_LOCATOR_TYPE      ,INET_E_DOWNLOAD_FAILURE
    ,ERROR_GOPHER_NOT_GOPHER_PLUS             ,INET_E_DOWNLOAD_FAILURE
    ,ERROR_GOPHER_ATTRIBUTE_NOT_FOUND         ,INET_E_DOWNLOAD_FAILURE
    ,ERROR_GOPHER_UNKNOWN_LOCATOR             ,INET_E_DOWNLOAD_FAILURE
    ,ERROR_HTTP_HEADER_NOT_FOUND              ,INET_E_DOWNLOAD_FAILURE
    ,ERROR_HTTP_DOWNLEVEL_SERVER              ,INET_E_DOWNLOAD_FAILURE
    ,ERROR_HTTP_INVALID_SERVER_RESPONSE       ,INET_E_DOWNLOAD_FAILURE
    ,ERROR_HTTP_INVALID_HEADER                ,INET_E_DOWNLOAD_FAILURE
    ,ERROR_HTTP_INVALID_QUERY_REQUEST         ,INET_E_DOWNLOAD_FAILURE
    ,ERROR_HTTP_HEADER_ALREADY_EXISTS         ,INET_E_DOWNLOAD_FAILURE
    ,ERROR_HTTP_REDIRECT_FAILED               ,INET_E_REDIRECT_FAILED
    ,ERROR_HTTP_REDIRECT_NEEDS_CONFIRMATION   ,INET_E_DOWNLOAD_FAILURE
    ,ERROR_INTERNET_SECURITY_CHANNEL_ERROR    ,INET_E_DOWNLOAD_FAILURE
    ,ERROR_INTERNET_UNABLE_TO_CACHE_FILE      ,INET_E_DOWNLOAD_FAILURE
    ,ERROR_INTERNET_TCPIP_NOT_INSTALLED       ,INET_E_DOWNLOAD_FAILURE
    ,ERROR_HTTP_NOT_REDIRECTED                ,INET_E_DOWNLOAD_FAILURE
    ,ERROR_INTERNET_HTTPS_HTTP_SUBMIT_REDIR   ,INET_E_DOWNLOAD_FAILURE
};

//+---------------------------------------------------------------------------
//
//  Function:   IsKnownOInetProtocolClass
//
//  Synopsis:
//
//  Arguments:  [pclsid] --
//
//  Returns:
//
//  History:    11-01-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD IsKnownOInetProtocolClass(CLSID *pclsid)
{
    DEBUG_ENTER((DBG_APP,
                Dword,
                "IsKnownOInetProtocolClass",
                "%#x",
                pclsid
                ));
                
    PProtAssert((pclsid));
    DWORD dwRet = DLD_PROTOCOL_NONE;
    int i = 0;
    int cSize = sizeof(rgKnownProts)/sizeof(ProtocolInfo);

    if (pclsid)
    {
        for (i = 0; i < cSize; ++i)
        {
            if (*pclsid == *rgKnownProts[i].pClsID)
            {
                dwRet = rgKnownProts[i].dwId;
                i = cSize;
            }
        }
    }

    DEBUG_LEAVE(dwRet);
    return dwRet;
}

//+---------------------------------------------------------------------------
//
//  Function:   IsKnownProtocol
//
//  Synopsis:   looks up if an protocol handler exist for a given url
//
//  Arguments:  [wzProtocol] --
//
//  Returns:
//
//  History:    11-01-1996   JohannP (Johann Posch)   Created
//
//  Notes:      used at many place inside urlmon
//
//----------------------------------------------------------------------------
DWORD IsKnownProtocol(LPCWSTR wzProtocol)
{
    DEBUG_ENTER((DBG_APP,
                Dword,
                "IsKnownProtocol",
                "%#.80wq",
                wzProtocol
                ));
                
    DWORD dwRet = DLD_PROTOCOL_NONE;
    int i = 0;
    int cSize = sizeof(rgKnownProts)/sizeof(ProtocolInfo);

    for (i = 0; i < cSize; ++i)
    {
        if (!StrCmpNICW(wzProtocol, rgKnownProts[i].pwzProtocol, rgKnownProts[i].protlen))
        {
            dwRet = rgKnownProts[i].dwId;

            if ((DLD_PROTOCOL_HTTP == dwRet) &&
                ((wzProtocol[4] == L's') ||
                 (wzProtocol[4] == L'S')))

            {
                dwRet = DLD_PROTOCOL_HTTPS;
            }
            break;
        }
    }

    DEBUG_LEAVE(dwRet);
    return dwRet;
}

//+---------------------------------------------------------------------------
//
//  Function:   GetKnownOInetProtocolClsID
//
//  Synopsis:
//
//  Arguments:  [dwProtoId] --
//
//  Returns:
//
//  History:    11-01-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
CLSID *GetKnownOInetProtocolClsID(DWORD dwProtoId)
{
    DEBUG_ENTER((DBG_APP,
                Pointer,
                "GetKnownOInetProtocolClsID",
                "%#x",
                dwProtoId
                ));
                
    PerfDbgLog1(tagCINet, NULL, "GetKnownOInetProtocolClsID (dwProtoId:%lx)", dwProtoId);
    CLSID *pclsid = 0;

    int cSize = sizeof(rgKnownProts)/sizeof(ProtocolInfo);

    for (int i = 0; i < cSize; ++i)
    {
        if (dwProtoId == rgKnownProts[i].dwId )
        {
            pclsid = rgKnownProts[i].pClsID;
            i = cSize;
        }
    }

    DEBUG_LEAVE(pclsid);
    return pclsid;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINet::QueryInterface
//
//  Synopsis:
//
//  Arguments:  [riid] --
//              [ppvObj] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CINet::QueryInterface(REFIID riid, void **ppvObj)
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINet::IUnknown::QueryInterface",
                "this=%#x, %#x, %#x",
                this, &riid, ppvObj
                ));
                
    VDATEPTROUT(ppvObj, void *);
    VDATETHIS(this);
    HRESULT hr = NOERROR;

    PerfDbgLog(tagCINet, this, "+CINet::QueryInterface");

    if (riid == IID_IOInetPriority)
    {
        *ppvObj = (IOInetPriority *) this;
        AddRef();
    }
    else
    {
        hr = _pUnkOuter->QueryInterface(riid, ppvObj);
    }

    PerfDbgLog1(tagCINet, this, "-CINet::QueryInterface (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   CINet::AddRef
//
//  Synopsis:
//
//  Arguments:  [ULONG] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CINet::AddRef(void)
{
    DEBUG_ENTER((DBG_APP,
                Dword,
                "CINet::IUnknown::AddRef",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCINet, this, "+CINet::AddRef");

    LONG lRet = _pUnkOuter->AddRef();

    PerfDbgLog1(tagCINet, this, "-CINet::AddRef (cRefs:%ld)", lRet);

    DEBUG_LEAVE(lRet);
    return lRet;
}

//+---------------------------------------------------------------------------
//
//  Function:   CINet::Release
//
//  Synopsis:
//
//  Arguments:  [ULONG] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CINet::Release(void)
{
    DEBUG_ENTER((DBG_APP,
                Dword,
                "CINet::IUnknown::Release",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCINet, this, "+CINet::Release");

    LONG lRet = _pUnkOuter->Release();

    PerfDbgLog1(tagCINet, this, "-CINet::Release (cRefs:%ld)", lRet);

    DEBUG_LEAVE(lRet);
    return lRet;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINet::Start
//
//  Synopsis:
//
//  Arguments:  [pwzUrl] --
//              [pTrans] --
//              [pOIBindInfo] --
//              [grfSTI] --
//              [dwReserved] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CINet::Start(LPCWSTR pwzUrl, IOInetProtocolSink *pTrans, IOInetBindInfo *pOIBindInfo,
                          DWORD grfSTI, DWORD_PTR dwReserved)
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINet::IInternetProtocolRoot::Start",
                "this=%#x, %.200wq, %#x, %#x, %#x, %#x",
                this, pwzUrl, pTrans, pOIBindInfo, grfSTI, dwReserved
                ));
                
    PerfDbgLog(tagCINet, this, "+CINet::Start");
    HRESULT hr = NOERROR;
    //char    szURL[MAX_URL_SIZE];
    DWORD   dwUrlSize = 0;
    DWORD dwMaxUTF8Len = 0;
    BOOL    fUTF8Enabled = FALSE;
    BOOL    fUTF8Required = FALSE;


    PProtAssert((!_pCTrans && pOIBindInfo && pTrans));
    PProtAssert((_pwzUrl == NULL));


    if ( !(grfSTI & PI_PARSE_URL))
    {
        _pCTrans = pTrans;
        _pCTrans->AddRef();

        _pOIBindInfo =  pOIBindInfo;
        _pOIBindInfo->AddRef();

        _pwzUrl = OLESTRDuplicate((LPWSTR)pwzUrl);
    }

    _BndInfo.cbSize = sizeof(BINDINFO);

    hr = pOIBindInfo->GetBindInfo(&_grfBindF, &_BndInfo);
    
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "EXTERNAL_CLIENT::GetBindInfo",
                "this=%#x, flags=%#x, pBindInfo=%#x",
                this, _grfBindF, pOIBindInfo
                ));

    DEBUG_LEAVE(hr);
    
    if( hr != NOERROR )
    {
        goto End;
    }

    /************************************************************************
    // szURL does not seem to be used, am I missing something?
    // szURL is 2K buffer on stack! Let's remove this code at all.
    // DanpoZ (98/02/20)

    // Do we need to append the extra data to the url?
    if (_BndInfo.szExtraInfo)
    {
        // append extra info at the end of the url
        // Make sure we don't overflow the URL
        if (CchWzLen(_BndInfo.szExtraInfo) + CchWzLen(pwzUrl) >= MAX_URL_SIZE)
        {
            hr = E_INVALIDARG;
            goto End;
        }

        W2A(pwzUrl, szURL, MAX_URL_SIZE, _BndInfo.dwCodePage);

        // Append the extra data to the url.  Note that we have already
        // checked for overflow, so we need not worry about it here.
        W2A(_BndInfo.szExtraInfo, szURL + CchSzLen(szURL), MAX_URL_SIZE, _BndInfo.dwCodePage);
    }
    else
    {
        // Make sure we don't overflow the URL
        if (CchWzLen(pwzUrl) + 1 > MAX_URL_SIZE)
        {
            hr = E_INVALIDARG;
            goto End;
        }
        W2A(pwzUrl, szURL, MAX_URL_SIZE, _BndInfo.dwCodePage);
    }
    ************************************************************************/

    // no need to check the length of pwzUrl, this has been done already
    if( !_BndInfo.dwCodePage )
        _BndInfo.dwCodePage = GetACP();


    // utf8 enabled?
    fUTF8Enabled = UTF8Enabled();

    if( fUTF8Enabled )
    {
        dwUrlSize = CountUnicodeToUtf8(pwzUrl, wcslen(pwzUrl), TRUE);
        DWORD dwMB = StrLenMultiByteWithMlang(pwzUrl, _BndInfo.dwCodePage);
        if( dwMB > dwUrlSize )
        {
            dwUrlSize = dwMB;
        }
    }
    else
    {
        dwUrlSize = StrLenMultiByteWithMlang(pwzUrl, _BndInfo.dwCodePage);
    }

    if( !dwUrlSize )
    {
        hr = E_INVALIDARG;
        goto End;
    }


    if( CUrlInitBasic(dwUrlSize) )
    {
        //W2A(pwzUrl, _pszBaseURL, dwUrlSize, _BndInfo.dwCodePage);
        ConvertUnicodeUrl(
                pwzUrl,                 // (IN)  unicode URL
                _pszBaseURL,            // (OUT) multibyte URL
                dwUrlSize,              // (IN)  multibyte URL length
                _BndInfo.dwCodePage,    // (IN)  codepage
                fUTF8Enabled,           // (IN)  UTF-8 conversion enabled?
                &fUTF8Required
                );
    }
    else
    {
        hr = E_OUTOFMEMORY;
        goto End;
    }

    {
        // Init the Embedded Filter
        if( _pEmbdFilter )
        {
            delete _pEmbdFilter;
            _pEmbdFilter = NULL;
        }
        _pEmbdFilter = new CINetEmbdFilter( this, _pCTrans );
        if( !_pEmbdFilter )
        {
            hr = E_OUTOFMEMORY;
            goto End;
        }
        if(!_pEmbdFilter->IsInited())
        {
            delete _pEmbdFilter;
            _pEmbdFilter = NULL;
            hr = E_OUTOFMEMORY;
            goto End;
        }

        // For sanity checks later via IsEmbdFilterOk():
        _dwEmbdFilter = *(DWORD *)_pEmbdFilter;
    }

    if (!ParseUrl(fUTF8Required, pwzUrl, _BndInfo.dwCodePage))
    {
        _hrError = INET_E_INVALID_URL;
        hr = MK_E_SYNTAX;
    }
    else if ( !(grfSTI & PI_PARSE_URL))
    {
        g_cInetState.HandleState();
        PProtAssert((_pCTrans));
        if( !(_grfBindF & BINDF_FROMURLMON) && IsEmbdFilterOk() )
        {
            _pEmbdFilter->ReportProgress(BINDSTATUS_DIRECTBIND, 0);
        }
        hr = INetAsyncStart();
    }
End:

    PerfDbgLog1(tagCINet, this, "-CINet::Start (hr:%lx)", hr);
    if( hr == E_PENDING )
    {
        // hack, CTransact will warp E_PENDING with NOERROR and return
        // it to client, if we do not have CTrans wrapper (not aggregrated)
        // we should return NOERROR.
        if( _pUnkOuter == &_Unknown )
        {
            hr = NOERROR;
        }
    }

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINet::Continue
//
//  Synopsis:
//
//  Arguments:  [pStateInfoIn] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CINet::Continue(PROTOCOLDATA *pStateInfoIn)
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINet::IInternetProtocolRoot::Continue",
                "this=%#x, %#x",
                this, pStateInfoIn
                ));
                
    HRESULT hr = E_FAIL;
    if(IsEmbdFilterOk())
        hr = _pEmbdFilter->Continue(pStateInfoIn);

    DEBUG_LEAVE(hr);
    return hr;
}

STDMETHODIMP CINet::MyContinue(PROTOCOLDATA *pStateInfoIn)
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINet::MyContinue",
                "this=%#x, %#x",
                this, pStateInfoIn
                ));
                
    PerfDbgLog(tagCINet, this, "+CINet::Continue");
    HRESULT hr = NOERROR;

    PProtAssert((pStateInfoIn->pData && !pStateInfoIn->cbData));

    // check if the inete state changed
    g_cInetState.HandleState();

    OnINetInternal((DWORD_PTR) pStateInfoIn->pData);

    if( !(_grfBindF & BINDF_FROMURLMON) )
    {
        //
        // if the BindInfo is created from heap by CINet
        // we need to delete it from here
        //
        delete pStateInfoIn;
    }

    PerfDbgLog1(tagCINet, this, "-CINet::Continue (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CINet::Abort
//
//  Synopsis:
//
//  Arguments:  [hrReason] --
//              [dwOptions] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CINet::Abort(HRESULT hrReason, DWORD dwOptions)
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINet::IInternetProtocolRoot::Abort",
                "this=%#x, %#x, %#x",
                this, hrReason, dwOptions
                ));
                
    HRESULT hr = NOERROR;
    if( _pEmbdFilter )
    {
        hr = _pEmbdFilter->Abort(hrReason, dwOptions);
    }

    DEBUG_LEAVE(hr);
    return hr;
}

STDMETHODIMP CINet::MyAbort(HRESULT hrReason, DWORD dwOptions)
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINet::MyAbort",
                "this=%#x, %#x, %#x",
                this, hrReason, dwOptions
                ));
                
    PerfDbgLog(tagCINet, this, "+CINet::Abort");
    HRESULT hr = NOERROR;

    PProtAssert((_pCTrans));

    hr = ReportResultAndStop(hrReason);

    PerfDbgLog1(tagCINet, this, "-CINet::Abort (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINet::Terminate
//
//  Synopsis:
//
//  Arguments:  [dwOptions] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CINet::Terminate(DWORD dwOptions)
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINet::IInternetProtocolRoot::Terminate",
                "this=%#x, %#x",
                this, dwOptions
                ));
                
    // in case we failed on :Start, _pEmbdFilter is
    // not in place, however, Terminate might be
    // called so we have to call MyTerminate directly
    HRESULT hr = NOERROR;
    if( _pEmbdFilter )
    {
        hr = _pEmbdFilter->Terminate(dwOptions);
    }
    else
    {
        hr = MyTerminate(dwOptions);
    }

    DEBUG_LEAVE(hr);
    return hr;
}

/*
 * This function will only be called into after MyTerminate has been called -
 *  since only InternetCloseHandle called in MyTerminate should trigger a handle-closing callback.
 *
 *  No synchronization may be required because :
 *
 *  1. all operations at this point using the handle should have
        been done with since the handle has been destroyed ( hence no Reads in progress. )
    2. if we find that we need to synchronize access to this, we must correspondinly synchronize
        all access to the _pCTrans object from CINet.  Hopefully, this is not required because 
        we should get handleclosing callback from wininet only after we have exited all callbacks.
    3. the only other place _pCTrans can be touched from is Reads from above which shouldn't be 
        happening if this is closed as a result of being aborted or terminated cleanly.
 *
    The objective of this new function is to let the _pCTrans connection live until wininet is done
    with context use - else witness ugly race condition in bug 2270.

    ReleaseBindInfo() happening here to get around bug 19809, which again is triggered by IBinding::Abort
    situations in stress.
 */
 
VOID CINet::ReleaseTransAndBindInfo()
{
    DEBUG_ENTER((DBG_APP,
                None,
                "CINet::ReleaseTransAndBindInfo",
                "this=%#x, %#x",
                this, _pCTrans
                ));

    if (!_fHandlesRecycled)
    {
        PProtAssert((_pCTrans));
        PProtAssert((_dwState == INetState_DONE) || (_dwState == INetState_ERROR));
        PProtAssert((_dwIsA == DLD_PROTOCOL_HTTP) || (_dwIsA == DLD_PROTOCOL_HTTPS) || (_dwIsA == DLD_PROTOCOL_FILE) || (_dwIsA == DLD_PROTOCOL_GOPHER));
        // Hopefully, this stays an assert.
        //  scenario where abort is called before/during the OpenRequest/OpenUrl call.
        PProtAssert((_HandleStateRequest == HandleState_Closed)); 

        if (_pCTrans)
        {
            _pCTrans->Release();
            _pCTrans = NULL;
        }
        
        ReleaseBindInfo(&_BndInfo);
    }

    DEBUG_LEAVE(0);
}
    
STDMETHODIMP CINet::MyTerminate(DWORD dwOptions)
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINet::MyTerminate",
                "this=%#x, %#x",
                this, dwOptions
                ));
                
    PerfDbgLog(tagCINet, this, "+CINet::Terminate");
    HRESULT hr = NOERROR;
    BOOL fReleaseBindInfo = FALSE;

    //should be called once
    PProtAssert((_pCTrans));

    if (_pOIBindInfo)
    {
        _pOIBindInfo->Release();
        _pOIBindInfo = NULL;
    }

    if (_pServiceProvider)
    {
        _pServiceProvider->Release();
        _pServiceProvider = NULL;
    }

    if (_pCTrans)
    {
        // release all the handles if unless
        // the request was locked
        if (!_fLocked && !_hLockHandle)
        {
            TerminateRequest();
        }

        // sync block
        {
            CLock lck(_mxs);    // only one thread should be in here

            if ((_dwState != INetState_DONE) && (_dwState != INetState_ERROR))
            {
                _dwState = INetState_DONE;
            }

            if (    (_dwIsA == DLD_PROTOCOL_FILE)
                ||  (_dwIsA == DLD_PROTOCOL_LOCAL)
                ||  (_dwIsA == DLD_PROTOCOL_STREAM)
                ||  _fHandlesRecycled
                ||  (_HandleStateServer == HandleState_Aborted))
            {
                fReleaseBindInfo = TRUE;
                _pCTrans->Release();
                _pCTrans = NULL;
            }
        }

    }

#if DBG == 1
    if ( _BndInfo.stgmedData.tymed != TYMED_NULL )
        PerfDbgLog1(tagCINet, this, "--- CINet::Stop ReleaseStgMedium (%lx)", _BndInfo.stgmedData);
#endif

    if (    fReleaseBindInfo
        ||  (_dwIsA == DLD_PROTOCOL_FILE)
        ||  (_dwIsA == DLD_PROTOCOL_LOCAL)
        ||  (_dwIsA == DLD_PROTOCOL_STREAM)
        ||  _fHandlesRecycled
        ||  (_HandleStateServer == HandleState_Aborted))
    {
        ReleaseBindInfo(&_BndInfo);
    }

    PerfDbgLog1(tagCINet, this, "-CINet::Terminate (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINet::Suspend
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CINet::Suspend()
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINet::IInternetProtocolRoot::Suspend",
                "this=%#x",
                this
                ));
                
    HRESULT hr = _pEmbdFilter->Suspend();

    DEBUG_LEAVE(hr);
    return hr;
}

STDMETHODIMP CINet::MySuspend()
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINet::MySuspend",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCINet, this, "+CINet::Suspend");

    HRESULT hr = E_NOTIMPL;

    PerfDbgLog1(tagCINet, this, "-CINet::Suspend (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINet::Resume
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CINet::Resume()
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINet::IInternetProtocolRoot::Resume",
                "this=%#x",
                this
                ));
                
    HRESULT hr = _pEmbdFilter->Resume();

    DEBUG_LEAVE(hr);
    return hr;
}

STDMETHODIMP CINet::MyResume()
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINet::MyResume",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCINet, this, "+CINet::Resume");

    HRESULT hr = E_NOTIMPL;

    PerfDbgLog1(tagCINet, this, "-CINet::Resume (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINet::SetPriority
//
//  Synopsis:
//
//  Arguments:  [nPriority] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CINet::SetPriority(LONG nPriority)
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINet::IInternetPriority::SetPriority",
                "this=%#x, %#x",
                this, nPriority
                ));
                
    PerfDbgLog1(tagCINet, this, "+CINet::SetPriority (%ld)", nPriority);

    HRESULT hr = S_OK;

    _nPriority = nPriority;

    PerfDbgLog1(tagCINet, this, "-CINet::SetPriority (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINet::GetPriority
//
//  Synopsis:
//
//  Arguments:  [pnPriority] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CINet::GetPriority(LONG * pnPriority)
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINet::IInternetPriority::GetPriority",
                "this=%#x, %#x",
                this, pnPriority
                ));
                
    PerfDbgLog(tagCINet, this, "+CINet::GetPriority");

    HRESULT hr = S_OK;

    *pnPriority = _nPriority;

    PerfDbgLog1(tagCINet, this, "-CINet::GetPriority (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINet::Read
//
//  Synopsis:
//
//  Arguments:  [ULONG] --
//              [ULONG] --
//              [pcbRead] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CINet::Read(void *pv,ULONG cb,ULONG *pcbRead)
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINet::IInternetProtocol::Read",
                "this=%#x, %#x, %#x, %#x",
                this, pv, cb, pcbRead
                ));
                
    HRESULT hr =  _pEmbdFilter->Read(pv, cb, pcbRead);

    DEBUG_LEAVE(hr);
    return hr;
}

STDMETHODIMP CINet::MyRead(void *pv,ULONG cb,ULONG *pcbRead)
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINet::MyRead",
                "this=%#x, %#x, %#x, %#x",
                this, pv, cb, pcbRead
                ));
                
    PerfDbgLog(tagCINet, this, "+CINet::Read");
    HRESULT hr = NOERROR;

    if(GetBindFlags() & BINDF_DIRECT_READ)
    {
        hr = ReadDirect((BYTE *)pv, cb, pcbRead);
    }
    else
    {
        hr = ReadDataHere((BYTE *)pv, cb, pcbRead);
    }

    PerfDbgLog1(tagCINet, this, "-CINet::Read (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINet::Seek
//
//  Synopsis:
//
//  Arguments:  [DWORD] --
//              [ULARGE_INTEGER] --
//              [plibNewPosition] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CINet::Seek(LARGE_INTEGER dlibMove,DWORD dwOrigin,ULARGE_INTEGER *plibNewPosition)
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINet::IInternetProtocol::Seek",
                "this=%#x, %#x, %#x, %#x",
                this, dlibMove, dwOrigin, plibNewPosition
                ));
                
    HRESULT hr = _pEmbdFilter->Seek(dlibMove, dwOrigin, plibNewPosition);

    DEBUG_LEAVE(hr);
    return hr;
}

STDMETHODIMP CINet::MySeek(LARGE_INTEGER dlibMove,DWORD dwOrigin,ULARGE_INTEGER *plibNewPosition)
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINet::MySeek",
                "this=%#x, %#x, %#x, %#x",
                this, dlibMove, dwOrigin, plibNewPosition
                ));
                
    PerfDbgLog(tagCINet, this, "+CINet::Seek");
    HRESULT hr;

    hr = INetSeek(dlibMove, dwOrigin,plibNewPosition);

    PerfDbgLog1(tagCINet, this, "-CINet::Seek (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINet::LockRequest
//
//  Synopsis:
//
//  Arguments:  [dwOptions] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CINet::LockRequest(DWORD dwOptions)
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINet::IInternetProtocol::LockRequest",
                "this=%#x, %#x",
                this, dwOptions
                ));
                
    HRESULT hr = _pEmbdFilter->LockRequest(dwOptions);

    DEBUG_LEAVE(hr);
    return hr;
}

STDMETHODIMP CINet::MyLockRequest(DWORD dwOptions)
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINet::MyLockRequest",
                "this=%#x, %#x",
                this, dwOptions
                ));
                
    PerfDbgLog(tagCINet, this, "+CINet::LockRequest");
    HRESULT hr = NOERROR;

    hr = LockFile(FALSE);

    PerfDbgLog1(tagCINet, this, "-CINet::LockRequest (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINet::UnlockRequest
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CINet::UnlockRequest()
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINet::IInternetProtocol::UnlockRequest",
                "this=%#x",
                this
                ));
                
    HRESULT hr = _pEmbdFilter->UnlockRequest();

    DEBUG_LEAVE(hr);
    return hr;
}

STDMETHODIMP CINet::MyUnlockRequest()
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINet::MyUnlockRequest",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCINet, this, "+CINet::UnlockRequest");
    HRESULT hr = NOERROR;

    TerminateRequest();
    hr = UnlockFile();

    PerfDbgLog1(tagCINet, this, "-CINet::UnlockRequest (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CINet::QueryOption
//
//  Synopsis:
//
//  Arguments:  [dwOption] --
//              [pBuffer] --
//              [pcbBuf] --
//
//  Returns:
//
//  History:    4-16-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CINet::QueryOption(DWORD dwOption, LPVOID pBuffer, DWORD *pcbBuf)
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINet::IWininetInfo::QueryOption",
                "this=%#x, %#x, %#x, %#x",
                this, dwOption, pBuffer, pcbBuf
                ));
                
    PerfDbgLog1(tagCINet, this, "+CINet::QueryOptions dwOption:%ld", dwOption);
    HRESULT hr;

    if (!pcbBuf || (*pcbBuf == 0))
    {
        hr = E_INVALIDARG;
    }
    else if (!_hRequest)
    {
        *pcbBuf = 0;
        hr = E_FAIL;
    }
    else if (dwOption == WININETINFO_OPTION_LOCK_HANDLE)
    {
        if (    *pcbBuf >= sizeof(HANDLE)
            &&  InternetLockRequestFile(_hRequest, (HANDLE *)pBuffer))
        {
            *pcbBuf = sizeof(HANDLE);
            hr = S_OK;
        }
        else
        {
            *pcbBuf = 0;
            hr = E_FAIL;
        }
    }
    else
    {
        if (InternetQueryOption(_hRequest, dwOption, pBuffer, pcbBuf))
        {
            hr = S_OK;
        }
        else
        {
            hr = S_FALSE;
        }
    }

    PerfDbgLog2(tagCINet, this, "-CINet::QueryOptions (hr:%lx,szStr:%s)", hr, pBuffer);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINet::QueryInfo
//
//  Synopsis:
//
//  Arguments:  [dwOption] --
//              [pBuffer] --
//              [pcbBuf] --
//              [pdwFlag] --
//
//  Returns:
//
//  History:    4-16-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CINet::QueryInfo(DWORD dwOption, LPVOID pBuffer, DWORD *pcbBuf, DWORD *pdwFlags, DWORD *pdwReserved)
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINet::IWininetHttpInfo::QueryInfo",
                "this=%#x, %#x, %#x, %#x, %#x, %#x",
                this, dwOption, pBuffer, pcbBuf, pdwFlags, pdwReserved
                ));
                
    PerfDbgLog1(tagCINet, this, "+CINet::QueryInfo dwOption:%ld", dwOption);
    HRESULT hr;

    if (!pcbBuf)
    {
        hr = E_INVALIDARG;
    }
    else if (!_hRequest)
    {
        *pcbBuf = 0;
        hr = E_FAIL;
    }
    else
    {
        if (HttpQueryInfo(_hRequest, dwOption, pBuffer, pcbBuf, pdwFlags))
        {
            hr = S_OK;
        }
        else
        {
            if (pBuffer  && (*pcbBuf >= sizeof(HRESULT)) )
            {
                HRESULT *phr = (HRESULT *)pBuffer;
                *phr = HRESULT_FROM_WIN32(GetLastError());
                *pcbBuf = sizeof(HRESULT);
            }
            hr = S_FALSE;
        }
    }

    PerfDbgLog2(tagCINet, this, "-CINet::QueryInfo (hr:%lx,szStr:%s)", hr, XDBG(pBuffer&&!hr?pBuffer:"",""));

    DEBUG_LEAVE(hr);
    return hr;
}

STDMETHODIMP CINet::Prepare()
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINet::IInternetThreadSwitch::Prepare",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCINet, this, "+CINet::Prepare");
    HRESULT hr = NOERROR;

    PerfDbgLog1(tagCINet, this, "-CINet::Prepare (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

STDMETHODIMP CINet::Continue()
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINet::IInternetThreadSwitch::Continue",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCINet, this, "+CINet::Continue");
    HRESULT hr = NOERROR;

    _dwThreadID = GetCurrentThreadId();

    PerfDbgLog1(tagCINet, this, "-CINet::Continue (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINet::CINet
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    1-27-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
CINet::CINet(REFCLSID rclsid, IUnknown *pUnkOuter) : _CRefs(), _CRefsHandles(0), _cReadCount(0), _pclsidProtocol(rclsid), _Unknown()
{
    DEBUG_ENTER((DBG_APP,
                None,
                "CINet::CINet",
                "this=%#x, %#x, %#x",
                this, &rclsid, pUnkOuter
                ));
                
    PerfDbgLog(tagCINet, this, "+CINet::CINet");
    _dwEmbdFilter = NULL;
    _pEmbdFilter = NULL;
    
    _dwState = INetState_START;
    _dwIsA = DLD_PROTOCOL_NONE;
    _fRedirected = FALSE;
    _fP2PRedirected = FALSE;
    _fLocked = FALSE;
    _fFilenameReported = FALSE;
    _fHandlesRecycled = FALSE;
    _fSendAgain = FALSE;
    _fSendRequestAgain = FALSE;
    _hLockHandle = NULL;
    _hFile = NULL;
    _dwThreadID = GetCurrentThreadId();
    _fDone = 0;
    _hwndAuth = NULL;
    _bscf = BSCF_FIRSTDATANOTIFICATION;
    _pOIBindInfo = 0;
    _pszUserAgentStr = 0;
    _nPriority = THREAD_PRIORITY_NORMAL;
    _cbSizeLastReportData = 0;
    _fForceSwitch = FALSE;
    _cbAuthenticate = 0;
    _cbProxyAuthenticate = 0;

    _fDoSimpleRetry = FALSE;

    if (!pUnkOuter)
    {
        pUnkOuter = &_Unknown;
    }
    _pUnkOuter = pUnkOuter;
    _pWindow = 0;

    _hServer = 0;
    _hRequest = 0;


    PerfDbgLog(tagCINet, this, "-CINet::CINet");

    DEBUG_LEAVE(0);
}

CINet::~CINet()
{
    DEBUG_ENTER((DBG_APP,
                None,
                "CINet::~CINet",
                "this=%#x",
                this
                ));
                
    delete _pwzUrl;
#if DBG == 1
    _pwzUrl = NULL;
#endif
    delete _pszUserAgentStr;

    // release Embedded Filter
    if( _pEmbdFilter )
    {
        CINetEmbdFilter* pEmbdFilter = _pEmbdFilter;
        _pEmbdFilter = NULL;
        delete pEmbdFilter;
    }

    PerfDbgLog(tagCINet, this, "CINet::~CINet");

    DEBUG_LEAVE(0);
}

// Helper function for _pEmbdFilter sanity check:
bool CINet::IsEmbdFilterOk()
{
    if(_pEmbdFilter && !::IsBadReadPtr(_pEmbdFilter, sizeof(DWORD)) && *(DWORD *)_pEmbdFilter == _dwEmbdFilter)
        return true;

    // Shouldn't happen, but is happening in rare cases.
    // Filter got released because someone likely deleted an incorrect offset. 
    PProtAssert((FALSE));
    PerfDbgLog(tagCINet, this, "+CINet::IsEmbdFilterOk: EmbedFilter missing, recreating.");
    
    if(_pCTrans)
    {
        CLock lck(_mxs);    // only one thread should be in here
        // Do the check again just in case we have two threads entering:
        if(_pEmbdFilter && !::IsBadReadPtr(_pEmbdFilter, sizeof(DWORD)) && *(DWORD *)_pEmbdFilter == _dwEmbdFilter)
            return true;

        // Release _pCTrans to compensate for the AddRef in 
        // the CINetEmbdFilter constructor, since the CINetEmbdFilter destructor would not have been called:
        _pCTrans->Release();

        // Recreate the filter here if possible:
        _pEmbdFilter = new CINetEmbdFilter( this, _pCTrans );
        if( !_pEmbdFilter || !_pEmbdFilter->IsInited())
        {
            // Something failed (deleting NULL is fine): 
            delete _pEmbdFilter;
            goto End;
        }
        // For sanity checks later via IsEmbdFilterOk():
        _dwEmbdFilter = *(DWORD *)_pEmbdFilter;
        return true;
    }

End:
    PerfDbgLog(tagCINetErr, this, "+CINet::IsEmbdFilterOk: Unable to recreate EmbedFilter, possibly out of memory.");
    SetINetState(INetState_ERROR);
    // Null out and return false:
    _pEmbdFilter = NULL; 
    return false;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINet::ReportResultAndStop
//
//  Synopsis:   Post the termination package
//
//  Arguments:  [hr] --
//
//  Returns:
//
//  History:    1-27-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINet::ReportResultAndStop(HRESULT hr, ULONG ulProgress,ULONG ulProgressMax, LPWSTR pwzStr)
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINet::ReportResultAndStop",
                "this=%#x, %#x, %#x, %#x, %.80wq",
                this, hr, ulProgress, ulProgressMax, pwzStr
                ));
                
    PerfDbgLog1(tagCINet, this, "+CINet::ReportResultAndStop (hr:%lx)", hr);

    HRESULT hrOut = NOERROR;
    BOOL fReportResult = FALSE;
    BOOL fReportData = FALSE;


    {
        CLock lck(_mxs);    // only one thread should be in here

        // set the state to error and report error
        // must go in queue since other messages might be ahead
        if ((_dwState != INetState_DONE) && (_dwState != INetState_ERROR))
        {
            _hrINet = hr;
            _dwState = (hr != NOERROR) ? INetState_ERROR : INetState_DONE;
            if (_dwState == INetState_DONE)
            {
                if (ulProgress == 0)
                {
                    ulProgress = _cbTotalBytesRead;
                    ulProgressMax = _cbDataSize;
                }
                if ( ( (ulProgress != _cbSizeLastReportData ) ||
                       (!ulProgress && !ulProgressMax)           ) &&
                     ( _grfBindF & BINDF_FROMURLMON ) )
                {
                    //
                    // last notification
                    // NOTE: we need to report data for empty page
                    //       we might have report this data already,
                    //       so check for the _cbSizeLastReportData
                    //       if they are same, do not report data
                    //       again. (this might give hard time for
                    //       IEFeatuer handler )
                    //
                    _bscf |= BSCF_LASTDATANOTIFICATION;
                    fReportData = TRUE;
                }

                //
                // HACK: for prodegy's ocx
                // if we have not send out ReportData(BSCF_LAST...) and
                // we are doing BindToStorage but the data has been
                // reported, we have to report it again with LAST flag
                // tuned on
                //
                if( !fReportData &&
                    !(_bscf & BSCF_LASTDATANOTIFICATION ) &&
                    !(_BndInfo.dwOptions & BINDINFO_OPTIONS_BINDTOOBJECT) )
                {
                    // need to send out last notifiation for whatever
                    // client depend on it...
                    _bscf |= BSCF_LASTDATANOTIFICATION;
                    fReportData = TRUE;
                }
            }
            else if (_dwState == INetState_ERROR)
            {
                SetINetState(INetState_ERROR);
            }

            PProtAssert((_pCTrans));
            fReportResult = TRUE;
        }
    }

    if (_pCTrans)
    {
        if (fReportData)
        {
            _cbSizeLastReportData = ulProgress;
            _pEmbdFilter->ReportData(_bscf, ulProgress, ulProgressMax);
        }
        // teminate might have occured on ReportData
        if (fReportResult && _pCTrans)
        {
            _pEmbdFilter->ReportResult(hr,_dwResult,pwzStr);
        }

        if( !fReportResult )
        {
            hrOut = INET_E_RESULT_DISPATCHED;
        }
    }

    PerfDbgLog1(tagCINet, this, "-CINet::ReportResultAndStop (hrOut:%lx)", hrOut);

    DEBUG_LEAVE(hrOut);
    return hrOut;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINet::ReportNotification
//
//  Synopsis:
//
//  Arguments:  [NMsg] --
//
//  Returns:
//
//  History:    1-27-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINet::ReportNotification(BINDSTATUS NMsg, LPCSTR szStr)
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINet::ReportNotification",
                "this=%#x, %#x, %.80q",
                this, NMsg, szStr
                ));
                
    PerfDbgLog1(tagCINet, this, "+CINet::ReportNotification (NMsg:%lx)", NMsg);
    HRESULT hr = E_FAIL;

    BOOL fReport = FALSE;
    LPWSTR pwzStr = 0;

    { // ssync block begin
        CLock lck(_mxs);    // only one thread should be in here

        if ((_dwState != INetState_DONE) && (_dwState != INetState_ERROR))
        {
            if (szStr)
            {
                pwzStr = DupA2W((const LPSTR)szStr);
            }
            if (szStr && !pwzStr)
            {
                hr = E_OUTOFMEMORY;
            }
            else
            {
                fReport = TRUE;
            }
        }
    } // sync block end

    if (fReport)
    {
        if ( _pCTrans && IsEmbdFilterOk() )
        {
            hr = _pEmbdFilter->ReportProgress((ULONG)NMsg, pwzStr);
        }
    }

    delete pwzStr;

    PerfDbgLog(tagCINet, this, "-CINet::ReportNotification");

    DEBUG_LEAVE(hr);
    return hr;
}

HRESULT CINet::ReportNotificationW(BINDSTATUS NMsg, LPCWSTR wzStr)
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINet::ReportNotificationW",
                "this=%#x, %#x, %.80q",
                this, NMsg, wzStr
                ));
                
    PerfDbgLog1(tagCINet, this, "+CINet::ReportNotificationW (NMsg:%lx)", NMsg);
    HRESULT hr = E_FAIL;

    BOOL fReport = FALSE;

    { // ssync block begin
        CLock lck(_mxs);    // only one thread should be in here

        if ((_dwState != INetState_DONE) && (_dwState != INetState_ERROR))
            fReport = TRUE;

    } // sync block end

    if (fReport)
    {
        if ( _pCTrans && _pEmbdFilter )
        {
            hr = _pEmbdFilter->ReportProgress((ULONG)NMsg, wzStr);
        }
    }

    PerfDbgLog(tagCINet, this, "-CINet::ReportNotificationW");

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINet::SetPending
//
//  Synopsis:
//
//  Arguments:  [hrNew] --
//
//  Returns:
//
//  History:    3-28-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINet::SetStatePending(HRESULT hrNew)
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINet::SetStatePending",
                "this=%#x, %#x",
                this, hrNew
                ));
                
    CLock lck(_mxs);    // only one thread should be in here
    HRESULT hr;

    PerfDbgLog2(tagCINet, this, "CINet::SetStatePending (hrOld:%lx, hrNew:%lx)", _hrPending, hrNew);

    //BUGBUG: turn this assertion on again
    PProtAssert(( (   ((_hrPending != E_PENDING) && (hrNew == E_PENDING))
                   || ((_hrPending == E_PENDING) && (hrNew != E_PENDING))) ));

    hr = _hrPending;
    _hrPending = hrNew;

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINet::GetStatePending
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    4-08-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINet::GetStatePending()
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINet::GetStatePending",
                "this=%#x",
                this
                ));
                
    CLock lck(_mxs);    // only one thread should be in here
    //PerfDbgLog1(tagCINet, this, "CINet::GetStatePending (hr:%lx)", _hrPending);

    DEBUG_LEAVE(_hrPending);
    return _hrPending;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINet::SetByteCountReadyToRead
//
//  Synopsis:
//
//  Arguments:  [cbReadyReadNow] --
//
//  Returns:
//
//  History:    6-25-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
void CINet::SetByteCountReadyToRead(LONG cbReadyReadNow)
{
    DEBUG_ENTER((DBG_APP,
                None,
                "CINet::SetByteCountReadyToRead",
                "this=%#x, %#x",
                this, cbReadyReadNow
                ));
                
    CLock lck(_mxs);    // only one thread should be in here
    PerfDbgLog3(tagCINet, this, "CINet::SetByteCountReadyToRead (cbReadReturn:%ld, cbReadyRead:%ld, cbReadyLeft:%ld)",
                    _cbReadyToRead, cbReadyReadNow, _cbReadyToRead + cbReadyReadNow);
    _cbReadyToRead += cbReadyReadNow ;

    DEBUG_LEAVE(0);
}

//+---------------------------------------------------------------------------
//
//  Method:     CINet::GetByteCountReadyToRead
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    6-25-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
ULONG CINet::GetByteCountReadyToRead()
{
    DEBUG_ENTER((DBG_APP,
                None,
                "CINet::GetByteCountReadyToRead",
                "this=%#x",
                this
                ));
                
    CLock lck(_mxs);    // only one thread should be in here
    PerfDbgLog1(tagCINet, this, "CINet::GetByteCountReadyToRead (_cbReadyToRead:%ld)", _cbReadyToRead);

    DEBUG_LEAVE(_cbReadyToRead);
    return _cbReadyToRead;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINet::SetINetState
//
//  Synopsis:
//
//  Arguments:  [inState] --
//
//  Returns:
//
//  History:    2-25-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
INetState CINet::SetINetState(INetState inState)
{
    DEBUG_ENTER((DBG_APP,
                Dword,
                "CINet::SetINetState",
                "this=%#x, %#x",
                this, inState
                ));
                
    CLock lck(_mxs);    // only one thread should be in here
    PerfDbgLog1(tagCINet, this, "+CINet::SetINetState (State:%lx)", inState);

    INetState in = _INState;
    _INState = inState;

    PerfDbgLog1(tagCINet, this, "-CINet::SetINetState (hr:%lx)", in);

    DEBUG_LEAVE(in);
    return in;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINet::GetINetState
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    2-25-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
INetState CINet::GetINetState()
{
    DEBUG_ENTER((DBG_APP,
                Dword,
                "CINet::GetINetState",
                "this=%#x",
                this
                ));
                
    CLock lck(_mxs);    // only one thread should be in here
    PerfDbgLog(tagCINet, this, "+CINet::GetINetState");

    INetState in = _INState;

    PerfDbgLog1(tagCINet, this, "-CINet::GetINetState (hr:%lx)", in);

    DEBUG_LEAVE(in);
    return in;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINet::INetAsyncStart
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  History:    1-27-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINet::INetAsyncStart()
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINet::INetAsyncStart",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCINet, this, "+CINet::INetAsyncStart");
    HRESULT hr = NOERROR;
    BOOL fAsyncStart = FALSE;

    // guard the object
    PrivAddRef();

    if (fAsyncStart)
    {
        // post notification for next step
        SetINetState(INetState_START);
        TransitState(INetState_START);
    }
    else
    {
        hr = INetAsyncOpen();
    }

    if (_hrError != INET_E_OK)
    {
        if (hr != S_OK && hr != E_PENDING && hr != INET_E_DONE)
        {
            PProtAssert((  (hr >= INET_E_ERROR_FIRST && hr <= INET_E_ERROR_LAST)
                         ||(hr == E_OUTOFMEMORY)
                         ||(hr == E_ABORT)
                         ));

            ReportResultAndStop(hr);
        }
        else
        {
            // he will do inetdone notifications
            ReportResultAndStop(NOERROR);
        }
    }

    PrivRelease();

    PerfDbgLog1(tagCINet, this, "-CINet::INetAsyncStart (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CINet::OnINetStart
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    1-27-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINet::OnINetStart()
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINet::OnINetStart",
                "this=%#x",
                this
                ));
                
    HRESULT hr;
    PerfDbgLog(tagCINet, this, "+CINet::OnINetStart");

    // nothing to do - just call
    hr = INetAsyncOpen();

    PerfDbgLog1(tagCINet, this, "-CINet::OnINetStart (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINet::INetAsyncOpen
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    1-27-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINet::INetAsyncOpen()
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINet::INetAsyncOpen",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCINet, this, "+CINet::INetAsyncOpen");
    PProtAssert((GetStatePending() == NOERROR));
    DWORD dwFlags = INTERNET_FLAG_ASYNC;
    DWORD dwBindF = 0;

    HRESULT hr = NOERROR;

    if (g_hSession == NULL)
    {
        // Only 1 thread should be in here, this is to protect
        // two global variables g_hSession and g_pszUserAgentString
        {
            CLock lck(g_mxsSession);
            if( g_hSession == NULL )
            {
                SetINetState(INetState_OPEN_REQUEST);

                PerfDbgLog1(tagCINet, this, "___ INetAysncOpen calling InternetOpen %ld", GetTickCount());
                SetStatePending(E_PENDING);

                g_hSession = InternetOpen(
                    GetUserAgentString()
                    , INTERNET_OPEN_TYPE_PRECONFIG
                    , NULL
                    , NULL
                    , dwFlags);
                PerfDbgLog1(tagCINet, this, "___ INetAysncOpen done InternetOpen %ld", GetTickCount());

                if (g_hSession == NULL)
                {
                    dwLstError = GetLastError();
                    if (dwLstError == ERROR_IO_PENDING)
                    {
                        hr = E_PENDING;
                    }
                    else
                    {
                        SetStatePending(NOERROR);
                        hr = _hrError = INET_E_NO_SESSION;
                        SetBindResult(dwLstError, hr);
                    }
                }
                else
                {
                    if (g_pszUserAgentString)
                    {
                        // Open was successful, so we don't need the replacement
                        // User Agent string anymore.

                        delete g_pszUserAgentString;
                        g_pszUserAgentString = NULL;
                    }

                    SetStatePending(NOERROR);
                    InternetSetStatusCallbackA(g_hSession, CINetCallback);
                    hr = INetAsyncConnect();
                }
            }
            else
            {
                hr = INetAsyncConnect();
            }
        } // single access block
    }
    else
    {
        hr = INetAsyncConnect();
    }

    PerfDbgLog1(tagCINet, this, "-CINet::INetAsyncOpen (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINet::OnINetAsyncOpen
//
//  Synopsis:
//
//  Arguments:  [dwResult] --
//
//  Returns:
//
//  History:    1-27-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINet::OnINetAsyncOpen(DWORD_PTR dwResult)
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINet::OnINetAsyncOpen",
                "this=%#x, %#x",
                this, dwResult
                ));
                
    PerfDbgLog(tagCINet, this, "+CINet::OnINetAsyncOpen");
    HRESULT hr = NOERROR;

    PProtAssert((GetStatePending() == E_PENDING));
    // set state to normal - no pending transaction
    SetStatePending(NOERROR);

    if (dwResult)
    {
        // set the handle and the callback
        g_hSession = (HINTERNET) dwResult;
        InternetSetStatusCallbackA(g_hSession, CINetCallback);
    }
    // notification for next request
    TransitState(INetState_OPEN_REQUEST);

    PerfDbgLog1(tagCINet, this, "-CINet::OnINetAsyncOpen (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINet::INetAsyncConnect
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    1-27-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINet::INetAsyncConnect()
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINet::INetAsyncConnect",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCINet, this, "+CINet::INetAsyncConnect");
    PProtAssert((GetStatePending() == NOERROR));

    HRESULT hr = NOERROR;
    BOOL fRestarted;
    DWORD dwBindF = 0;
    DWORD dwService = INTERNET_SERVICE_HTTP;

    // get the open flags

    dwBindF = GetBindFlags();

    if (dwBindF & BINDF_GETNEWESTVERSION)
    {
        _dwOpenFlags |= INTERNET_FLAG_RELOAD;
        PerfDbgLog1(tagCINet, this, "***CINet::****RELOAD***** %lx", dwBindF);

    }
    else
    {
        PerfDbgLog1(tagCINet, this, "---CINet::----NO-RELOAD %lx --", dwBindF);
    }

    if (dwBindF & BINDF_NOWRITECACHE)
    {
        _dwOpenFlags |= INTERNET_FLAG_DONT_CACHE ;
    }

    if (dwBindF & BINDF_NEEDFILE)
    {
        PerfDbgLog(tagCINet, this, "CINet::INetAsyncConnect: turn on: INTERNET_FLAG_NEED_FILE");
        _dwOpenFlags |= INTERNET_FLAG_NEED_FILE;
    }

    if (dwBindF & (BINDF_NO_UI | BINDF_SILENTOPERATION))
    {
        _dwOpenFlags |= INTERNET_FLAG_NO_UI;
    }

    // BUGBUG OFFLINE, RELOAD, RESYNCHRONIZE and HYPERLINK are mutually
    // exclusive. But inside wininet there is priority, so
    // the priority is OFFLINE, RELOAD, RESYNCHRONIZE, HYPERLINK in that order

    if (dwBindF & BINDF_RESYNCHRONIZE)
    {
        // caller asking to do if-modified-since

        _dwOpenFlags |= INTERNET_FLAG_RESYNCHRONIZE;
    }

    if (dwBindF & BINDF_HYPERLINK)
    {
        // caller says this is a hyperlink access

        _dwOpenFlags |= INTERNET_FLAG_HYPERLINK;
    }

    if (dwBindF & BINDF_FORMS_SUBMIT)
    {
        // caller says this is a forms submit.
        _dwOpenFlags |= INTERNET_FLAG_FORMS_SUBMIT;
    }

    if (dwBindF & BINDF_OFFLINEOPERATION )
    {
        _dwOpenFlags |= INTERNET_FLAG_OFFLINE;
    }

    // connect flags
    if (dwBindF & BINDF_OFFLINEOPERATION )
    {
        _dwConnectFlags |= INTERNET_FLAG_OFFLINE;
    }

    if (dwBindF & BINDF_PRAGMA_NO_CACHE )
    {
        _dwOpenFlags |= INTERNET_FLAG_PRAGMA_NOCACHE;
    }

    if( dwBindF & BINDF_GETFROMCACHE_IF_NET_FAIL)
    {
        _dwOpenFlags |= INTERNET_FLAG_CACHE_IF_NET_FAIL;
    }

    if( dwBindF & BINDF_FWD_BACK )
    {
        _dwOpenFlags |= INTERNET_FLAG_FWD_BACK;
    }

    // additional wininet flags are passed with bindinfo
    if( _BndInfo.dwOptions == BINDINFO_OPTIONS_WININETFLAG )
    {
        _dwOpenFlags |= _BndInfo.dwOptionsFlags;
    }


    SetINetState(INetState_CONNECT_REQUEST);

    PrivAddRef(TRUE);

    _HandleStateServer = HandleState_Pending;
    SetStatePending(E_PENDING);

    HINTERNET hServerTmp = InternetConnect(
            g_hSession,                             // hInternetSession
            GetServerName(),                        // lpszServerName
            _ipPort,                                // nServerPort
            (_pszUserName[0])?_pszUserName:NULL,    // lpszUserName
            (_pszPassword[0])?_pszPassword:NULL,    // lpszPassword
            dwService,                              // INTERNET_SERVICE_HTTP
            _dwConnectFlags,                        // dwFlags
            (DWORD_PTR) this
    );
    //
    // Note: do not remove this state setting here!
    //       there is a timing window - needs to
    //       be fixed in wininet/urlmon!!!
    SetINetState(INetState_CONNECT_REQUEST);

    if ( hServerTmp == 0)
    {
        dwLstError = GetLastError();
        if (dwLstError == ERROR_IO_PENDING)
        {
            // wait async for the handle
            hr = E_PENDING;
        }
        else
        {
            PrivRelease(TRUE);
            SetStatePending(NOERROR);
            hr = _hrError = INET_E_CANNOT_CONNECT;
            SetBindResult(dwLstError, hr);
        }
    }
    else
    {
        _hServer = hServerTmp;
        SetStatePending(NOERROR);
        // wininet holds on to CINet - Release called on the callback on close handle
        _HandleStateServer = HandleState_Initialized;
        PerfDbgLog1(tagCINet, this, "=== CINet::INetAsyncConnect (hServer:%lx)", _hServer);
        PProtAssert((_hServer));
        hr = INetAsyncOpenRequest();
    }

    PerfDbgLog1(tagCINet, this, "-CINet::INetAsyncConnect (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINet::OnINetConnect
//
//  Synopsis:
//
//  Arguments:  [dwResult] --
//
//  Returns:
//
//  History:    1-27-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINet::OnINetConnect(DWORD_PTR dwResult)
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINet::OnINetConnect",
                "this=%#x, %#x",
                this, dwResult
                ));
                
    PerfDbgLog(tagCINet, this, "+CINet::OnINetConnect");
    HRESULT hr = NOERROR;

    PProtAssert((GetStatePending() == E_PENDING));
    // set state to normal - no pending transaction
    SetStatePending(NOERROR);
    TransAssert((_hServer == 0));

    if (dwResult)
    {
        CLock lck(_mxs);    // only one thread should be in here
        if (_HandleStateServer == HandleState_Pending)
        {
            TransAssert((_hServer == 0));
            // set the server handle
            _HandleStateServer = HandleState_Initialized;
            _hServer = (HANDLE)dwResult;
        }

        // wininet holds on to CINet - Release called on the callback on close handle
        PerfDbgLog1(tagCINet, this, "=== CINet::OnINetConnect (hServer:%lx)", _hServer);
    }

    if (_hServer)
    {
        TransitState(INetState_CONNECT_REQUEST);
    }
    else
    {
        PProtAssert((_HandleStateServer == HandleState_Aborted));
        PrivRelease(TRUE);
    }

    PerfDbgLog1(tagCINet, this, "-CINet::OnINetConnect (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINet::INetAsyncOpenRequest
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    1-27-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINet::INetAsyncOpenRequest()
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINet::INetAsyncOpenRequest",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCINet, this, "+CINet::INetAsyncOpenRequest");

    HRESULT hr = E_FAIL;

    PerfDbgLog1(tagCINet, this, "-CINet::INetAsyncOpenRequest (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINet::OnINetOpenRequest
//
//  Synopsis:
//
//  Arguments:  [dwResult] --
//
//  Returns:
//
//  History:    1-27-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINet::OnINetOpenRequest(DWORD_PTR dwResult)
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINet::OnINetOpenRequest",
                "this=%#x, %#x",
                this, dwResult
                ));
                
    PerfDbgLog1(tagCINet, this, "+CINet::OnINetOpenRequest (dwResult:%lx)", dwResult);
    HRESULT hr = NOERROR;

    PProtAssert((GetStatePending() == E_PENDING));
    // set state to normal - no pending transaction
    SetStatePending(NOERROR);
    TransAssert((_hRequest == 0));

    if (dwResult)
    {
        CLock lck(_mxs);    // only one thread should be in here

        if (_HandleStateRequest == HandleState_Pending)
        {
            // set the request handle
            _HandleStateRequest = HandleState_Initialized;
            _hRequest = (HANDLE)dwResult;
            PProtAssert((_hServer != _hRequest));
        }
    }

    if (_hRequest)
    {
        if (_fUTF8hack)
        {
            DWORD dwSendUTF8 = 1;
            InternetSetOption(_hRequest, INTERNET_OPTION_SEND_UTF8_SERVERNAME_TO_PROXY, &dwSendUTF8, sizeof(DWORD));
        }
        
        hr = INetAsyncSendRequest();
    }
    else
    {
        PProtAssert((_HandleStateRequest == HandleState_Aborted));
        PrivRelease(TRUE);
    }

    PerfDbgLog1(tagCINet, this, "-CINet::OnINetOpenRequest (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;

}

//+---------------------------------------------------------------------------
//
//  Method:     CINet::INetAsyncSendRequest
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    1-27-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINet::INetAsyncSendRequest()
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINet::INetAsyncSendRequest",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCINet, this, "+CINet::INetAsyncSendRequest");

    HRESULT hr = E_FAIL;

    PerfDbgLog1(tagCINet, this, "-CINet::INetAsyncSendRequest (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINet::OnINetSendRequest
//
//  Synopsis:
//
//  Arguments:  [dwResult] --
//
//  Returns:
//
//  History:    1-27-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINet::OnINetSendRequest( DWORD dwResult)
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINet::OnINetSendRequest",
                "this=%#x, %#x",
                this, dwResult
                ));
                
    PerfDbgLog(tagCINet, this, "+CINet::OnINetSendRequest");
    HRESULT hr = NOERROR;

    PProtAssert((GetStatePending() == E_PENDING));
    // set state to normal - no pending transaction
    SetStatePending(NOERROR);

    _dwSendRequestResult = dwResult;
    _lpvExtraSendRequestResult = NULL;

    if( dwResult == ERROR_INTERNET_FORCE_RETRY )
    {
        PerfDbgLog(tagCINet, this, "  --dwResult = FORCE_RETRY! ");
        _fSendRequestAgain = TRUE;
    }

    if (OperationOnAparmentThread(INetState_SEND_REQUEST))
    {
        // query for content-encoding header, if we find one,
        // we will have to force TransitState to do thread switching
        // since the compression filter can not be loaded on worker
        // thread
        char szEncType[SZMIMESIZE_MAX] = "";
        DWORD cbLen = sizeof(szEncType);
        if( _hRequest &&
            HttpQueryInfo(_hRequest, HTTP_QUERY_CONTENT_ENCODING,
                          szEncType, &cbLen, NULL) )
        {
            if( cbLen && szEncType[0] )
                _fForceSwitch = TRUE;
        }

        // if sec problem shows up on UI thread, we need to
        // force switch
        switch(_dwSendRequestResult)
        {
            case ERROR_INTERNET_SEC_CERT_DATE_INVALID     :
            case ERROR_INTERNET_SEC_CERT_CN_INVALID       :
            case ERROR_INTERNET_HTTP_TO_HTTPS_ON_REDIR    :
            case ERROR_INTERNET_HTTPS_TO_HTTP_ON_REDIR    :
            case ERROR_INTERNET_HTTPS_HTTP_SUBMIT_REDIR   :
            case ERROR_HTTP_REDIRECT_NEEDS_CONFIRMATION   :
            case ERROR_INTERNET_INVALID_CA                :
            case ERROR_INTERNET_CLIENT_AUTH_CERT_NEEDED   :
            case ERROR_INTERNET_FORTEZZA_LOGIN_NEEDED     :
            case ERROR_INTERNET_FORCE_RETRY               :
            case ERROR_INTERNET_SEC_CERT_ERRORS           :
            case ERROR_INTERNET_SEC_CERT_REV_FAILED       :
            case ERROR_INTERNET_SEC_CERT_REVOKED          :
                _fForceSwitch = TRUE;
        }


        TransitState(INetState_SEND_REQUEST);
    }
    else if (!IsUpLoad())
    {
        hr = INetQueryInfo();
    }
    else
    {
        if( _fSendRequestAgain )
        {
            _fCompleted = FALSE;
            _fSendAgain = TRUE;
            _fSendRequestAgain = FALSE;
            hr = INetAsyncSendRequest();
        }
    }

    PerfDbgLog1(tagCINet, this, "-CINet::OnINetSendRequest (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINet::OnINetSuspendSendRequest
//
//  Synopsis:   called on a wininet callback to indicate the suspentition
//               of request processing until UI is displayed to the user.
//
//  Arguments:  [dwResult] -- error code to generate dialog for
//              [lpvExtraResult] -- extra void pointer used pass dialog specific data
//
//  Returns:
//
//  History:    5-24-98   ArthurBi (Arthur Bierer)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINet::OnINetSuspendSendRequest(DWORD dwResult, LPVOID lpvExtraResult)
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINet::OnINetSuspendSendRequest",
                "this=%#x, %#x, %#x",
                this, dwResult, lpvExtraResult
                ));
                
    PerfDbgLog(tagCINet, this, "+CINet::OnINetSuspendSendRequest");
    HRESULT hr = NOERROR;

    PProtAssert((GetStatePending() == E_PENDING));

    // set state to normal - no pending transaction
    SetStatePending(NOERROR);

    _dwSendRequestResult = dwResult;
    _lpvExtraSendRequestResult = lpvExtraResult;

    //if (OperationOnAparmentThread(INetState_SEND_REQUEST))

    // even though we're not doing auth, we need to do UI
    _hrINet = INET_E_AUTHENTICATION_REQUIRED;
    TransitState(INetState_DISPLAY_UI, TRUE);

    PerfDbgLog1(tagCINet, this, "-CINet::OnINetSuspendSendRequest (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CINet::INetStateChange
//
//  Synopsis:   called on the apartment thread
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    1-22-1997   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINet::INetStateChange()
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINet::INetStateChange",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCINet, this, "+CINet::INetStateChange");

    HRESULT hr = NOERROR;

    g_cInetState.HandleState();

    PerfDbgLog1(tagCINet, this, "-CINet::INetStateChange (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINet::OnINetStateChange
//
//  Synopsis:   called on the wininet worker thread whenever the
//              wininet state changes
//
//  Arguments:  [dwResult] --
//
//  Returns:
//
//  History:    1-22-1997   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINet::OnINetStateChange( DWORD dwResult)
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINet::OnINetStateChange",
                "this=%#x, %#x",
                this, dwResult
                ));
                
    PerfDbgLog(tagCINet, this, "+CINet::OnINetStateChange");
    HRESULT hr = NOERROR;

    // set the new state and ping the apartment thread
    g_cInetState.SetState(dwResult);

    TransitState(INetState_INETSTATE_CHANGE);

    PerfDbgLog1(tagCINet, this, "-CINet::OnINetStateChange (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINet::INetQueryInfo
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    1-27-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINet::INetQueryInfo()
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINet::INetQueryInfo",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCINet, this, "+CINet::INetQueryInfo");

    HRESULT hr = NOERROR;

    // Here we check if we need to do redirection, or
    // whether authentication is needed etc.
    if (!IsUpLoad())
    {
        hr = QueryInfoOnResponse();
    }
    if (hr == NOERROR)
    {
        // read more data from wininet
        hr = INetRead();
    }
    else if (hr == S_FALSE)
    {
        // S_FALSE means successful redirecting occured
        hr = NOERROR;
    }

    if (_hrError != INET_E_OK)
    {
        // we need to terminate here
        ReportResultAndStop(hr);
    }
    PerfDbgLog1(tagCINet, this, "-CINet::INetQueryInfo (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINet::OnINetRead
//
//  Synopsis:
//
//  Arguments:  [dwResult] --
//
//  Returns:
//
//  History:    1-27-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINet::OnINetRead(DWORD_PTR dwResult)
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINet::OnINetRead",
                "this=%#x, %#x",
                this, dwResult
                ));
                
    PerfDbgLog(tagCINet, this, "+CINet::OnINetRead");
    HRESULT hr = NOERROR;

    PProtAssert((GetStatePending() == E_PENDING));
    // set state to normal - no pending transaction
    SetStatePending(NOERROR);

    if (OperationOnAparmentThread(INetState_SEND_REQUEST))
    {
        TransitState(INetState_READ);
    }
    else
    {
        hr = INetRead();
    }

    PerfDbgLog1(tagCINet, this, "-CINet::OnINetRead (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINet::INetRead
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    1-27-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINet::INetRead()
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINet::INetRead",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCINet, this, "+CINet::INetRead");
    HRESULT hr = NOERROR;

    if (IsUpLoad())
    {
        hr = INetWrite();
    }
    else if(GetBindFlags() & BINDF_DIRECT_READ)
    {
        hr = INetReadDirect();
    }
    else
    {
        // this is the no-copy case
        // read data to users buffer
        hr = INetDataAvailable();
    }

    if (_hrError != INET_E_OK)
    {
        // we need to terminate here
        ReportResultAndStop((_hrError == INET_E_DONE) ? NOERROR : _hrError);
    }

    PerfDbgLog1(tagCINet, this, "-CINet::INetRead (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}
//+---------------------------------------------------------------------------
//
//  Method:     CINet::INetwrite
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    1-27-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINet::INetWrite()
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINet::INetWrite",
                "this=%#x",
                this
                ));
                
    HRESULT hr = E_FAIL;

    TransAssert((FALSE && "HAS TO BE OVERWRITTEN"));

    DEBUG_LEAVE(hr);
    return hr;
}

#define COOKIES_BLOCKED_STRING "CookiesBlocked"

BINDSTATUS BindStatusFromCookieAction(DWORD dwCookieAction)
{
    BINDSTATUS nMsg;
    
    switch(dwCookieAction)
    {
        case COOKIE_STATE_PROMPT:
            nMsg = BINDSTATUS_COOKIE_STATE_PROMPT;
            break;
        case COOKIE_STATE_ACCEPT:
            nMsg = BINDSTATUS_COOKIE_STATE_ACCEPT;
            break;
        case COOKIE_STATE_REJECT:
            nMsg = BINDSTATUS_COOKIE_STATE_REJECT;
            break;
        case COOKIE_STATE_LEASH:
            nMsg = BINDSTATUS_COOKIE_STATE_LEASH;
            break;
        case COOKIE_STATE_DOWNGRADE:
            nMsg = BINDSTATUS_COOKIE_STATE_DOWNGRADE;
            break;
        default:
            nMsg = BINDSTATUS_COOKIE_STATE_UNKNOWN;
            break;
    }

    return nMsg;
}

HRESULT CINet::OnCookieNotification(DWORD dwStatus, IN LPVOID pvInfo)
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINet::OnCookieNotification",
                "this=%#x, %#x, %#x",
                this, dwStatus, pvInfo
                ));

    HRESULT hr = ERROR_SUCCESS;

    BINDSTATUS nMsg;
    DWORD dwBlock = 0;

    switch (dwStatus)
    {
        case INTERNET_STATUS_P3P_HEADER:
        {
            TransAssert(pvInfo && "pvInfo should be a pointer to the P3P header");

            hr = ReportNotification(BINDSTATUS_P3P_HEADER, (LPSTR)pvInfo);
            break;
        }

        case INTERNET_STATUS_P3P_POLICYREF:
        {
            TransAssert(pvInfo && "pvInfo should be pointer to policy-ref URL");

            if (char *pszPolicyRef = (char*) pvInfo)
                hr = ReportNotification(BINDSTATUS_POLICY_HREF, (LPSTR)pszPolicyRef);

            break;
        }

        case INTERNET_STATUS_COOKIE_HISTORY:
        {
            InternetCookieHistory *pPastActions = (InternetCookieHistory*) pvInfo;

            if (!pPastActions)
                break;

            if (pPastActions->fAccepted)
                ReportNotification(BINDSTATUS_COOKIE_STATE_ACCEPT, NULL);

            if (pPastActions->fLeashed)
                ReportNotification(BINDSTATUS_COOKIE_STATE_LEASH, NULL);    

            if (pPastActions->fDowngraded)
                ReportNotification(BINDSTATUS_COOKIE_STATE_DOWNGRADE, NULL);

            if (pPastActions->fRejected)
                ReportNotification(BINDSTATUS_COOKIE_STATE_REJECT, NULL);

            break;
        }

        case INTERNET_STATUS_COOKIE_SENT:
        {
            OutgoingCookieState* pOutgoing = (OutgoingCookieState *)pvInfo;

            TransAssert(pOutgoing && "pvInfo should be OutgoingCookieState*");
            
            if (pOutgoing->cSent)
            {
                hr = ReportNotification(BINDSTATUS_COOKIE_SENT, pOutgoing->pszLocation);
            }
            if (pOutgoing->cSuppressed)
            {
                hr = ReportNotification(BINDSTATUS_COOKIE_SUPPRESSED, pOutgoing->pszLocation);
            }
            break;
        }
        
        case INTERNET_STATUS_COOKIE_RECEIVED:
        {
            IncomingCookieState* pIncoming = (IncomingCookieState *)pvInfo;

            TransAssert(pIncoming && "pvInfo should be OutgoingCookieState*");
            
            if (pIncoming->cAccepted)
                hr = ReportNotification(BINDSTATUS_COOKIE_STATE_ACCEPT, pIncoming->pszLocation);
            
            if (SUCCEEDED(hr) && pIncoming->cLeashed)
                hr = ReportNotification(BINDSTATUS_COOKIE_STATE_LEASH, pIncoming->pszLocation);
            
            if (SUCCEEDED(hr) && pIncoming->cDowngraded)
                hr = ReportNotification(BINDSTATUS_COOKIE_STATE_DOWNGRADE, pIncoming->pszLocation);

            if (SUCCEEDED(hr) && pIncoming->cBlocked)
                hr = ReportNotification(BINDSTATUS_COOKIE_STATE_REJECT, pIncoming->pszLocation);
               
            break;
        }

        default:
            TransAssert(FALSE);
            break;
    }
    
    DEBUG_LEAVE(hr);
    return hr;
}    
#define HRESULT_FROM_WININET(pv)     HRESULT_FROM_WIN32( (((LPINTERNET_ASYNC_RESULT) (pv) )->dwError) )

//+---------------------------------------------------------------------------
//
//  Method:     CINet::CINetCallback
//
//  Synopsis:
//
//  Arguments:  [hInternet] --
//              [dwContext] --
//              [dwStatus] --
//              [pvInfo] --
//              [dwStatusLen] --
//
//  Returns:
//
//  History:    1-27-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
VOID CALLBACK CINet::CINetCallback(IN HINTERNET hInternet, IN DWORD_PTR dwContext,
                           IN DWORD dwStatus, IN LPVOID pvInfo, IN DWORD dwStatusLen)
{
    DEBUG_ENTER((DBG_APP,
                None,
                "CINet::CINetCallback",
                "%#x, %#x, %#x, %#x, %#x",
                hInternet, dwContext, dwStatus, pvInfo, dwStatusLen
                ));
                
    // If this is a request, then we know the cookie type
    CINet *pCINet = (CINet *) dwContext;
    HRESULT hrError = INET_E_OK;

    //
    // handle callback without a context
    if (!dwContext)
    {
        switch (dwStatus)
        {
        default:
            //PProtAssert((FALSE));
        break;

        case INTERNET_STATUS_STATE_CHANGE :
        {
            DWORD dwState = *(DWORD *) pvInfo;

            g_cInetState.SetState(dwState);
        }
        break;
        }   // end switch
    }
    else
    {
        PerfDbgLog2(tagCINet, pCINet, "+CINet::CINetCallback Status:%ld, State:%ld",
            dwStatus, pCINet->_INState);

        DWORD_PTR dwAsyncResult;

        // from here the original thread needs to be told of various things
        // such as errors, operation done etc.
        PProtAssert((pCINet));

        // guard this call - request might be aborted
        //pCINet->AddRef();

        DWORD dwFault;
#ifdef INET_CALLBACK_EXCEPTION
        _try
#endif // INET_CALLBACK_EXCEPTION
        {

            switch (dwStatus)
            {
            // the net connection state changed
            case INTERNET_STATUS_STATE_CHANGE :
            {
                DWORD dwState = *(DWORD *) pvInfo;
                pCINet->OnINetStateChange(dwState);
            }
            break;

            // callback to put up UI
            case INTERNET_STATUS_USER_INPUT_REQUIRED:
            {
                // guard this call - request might be aborted
                pCINet->PrivAddRef();

                PProtAssert(pCINet->_INState == INetState_SEND_REQUEST);
                //PProtAssert(!((LPINTERNET_ASYNC_RESULT)pvInfo)->dwResult);

                LPVOID lpvSendRequestResultData = (LPVOID) ((LPINTERNET_ASYNC_RESULT)pvInfo)->dwResult;
                DWORD dwSendRequestResult = ((LPINTERNET_ASYNC_RESULT) (pvInfo) )->dwError;

                // handle the error here in particular pass on info for zone crossing
                pCINet->OnINetSuspendSendRequest(dwSendRequestResult, lpvSendRequestResultData);

                // unguard - release
                pCINet->PrivRelease();
            }
            break;

            // request completed
            case INTERNET_STATUS_REQUEST_COMPLETE:
            {
                // guard this call - request might be aborted
                pCINet->PrivAddRef();
                if (pCINet->_INState != INetState_ERROR)
                {
                    PProtAssert((pCINet->GetStatePending() == E_PENDING));
                }

                switch (pCINet->_INState)
                {
                case INetState_OPEN_REQUEST:
                    // the internet session handle is supposed to be returned
                    dwAsyncResult = ((LPINTERNET_ASYNC_RESULT)pvInfo)->dwResult;
                    if (dwAsyncResult)
                    {
                        // got the internet session handle back
                        pCINet->OnINetAsyncOpen(dwAsyncResult);
                    }
                    else
                    {
                        hrError = pCINet->SetBindResult(((LPINTERNET_ASYNC_RESULT) (pvInfo))->dwError, INET_E_NO_SESSION);
                    }
                break;

                case INetState_CONNECT_REQUEST:
                    // the server handle is supposed to be returned
                    dwAsyncResult = ((LPINTERNET_ASYNC_RESULT)pvInfo)->dwResult;
                    if (dwAsyncResult)
                    {
                        pCINet->OnINetConnect(dwAsyncResult);
                    }
                    else
                    {
                        hrError = pCINet->SetBindResult(((LPINTERNET_ASYNC_RESULT) (pvInfo))->dwError,INET_E_CANNOT_CONNECT);
                    }
                break;

                case INetState_PROTOPEN_REQUEST:
                    // the request handle is suppost to be returned
                    dwAsyncResult = ((LPINTERNET_ASYNC_RESULT)pvInfo)->dwResult;
                    if (dwAsyncResult)
                    {
                        pCINet->OnINetOpenRequest(dwAsyncResult);
                    }
                    else
                    {
                        hrError = pCINet->SetBindResult(((LPINTERNET_ASYNC_RESULT) (pvInfo))->dwError,INET_E_OBJECT_NOT_FOUND);
                    }
                break;

                case INetState_SEND_REQUEST:
                {
                    // SendRequest returns a BOOL
                    dwAsyncResult = ((LPINTERNET_ASYNC_RESULT)pvInfo)->dwResult;
                    if (dwAsyncResult)
                    {
                        // pass on 0 and look up the status code with HttpQueryInfo
                        pCINet->OnINetSendRequest(0);
                    }
                    else
                    {
                        DWORD dwSendRequestResult = ((LPINTERNET_ASYNC_RESULT) (pvInfo) )->dwError;
                        // handle the error here in particular pass on info for zone crossing
                        if (dwSendRequestResult)
                        {
                            // handle the sendrequest result
                            // zone crossing
                            switch (dwSendRequestResult)
                            {
                            case ERROR_INTERNET_SEC_CERT_DATE_INVALID     :
                            case ERROR_INTERNET_SEC_CERT_CN_INVALID       :
                            case ERROR_INTERNET_HTTP_TO_HTTPS_ON_REDIR    :
                            case ERROR_INTERNET_HTTPS_TO_HTTP_ON_REDIR    :
                            case ERROR_INTERNET_HTTPS_HTTP_SUBMIT_REDIR   :
                            case ERROR_HTTP_REDIRECT_NEEDS_CONFIRMATION   :
                            case ERROR_INTERNET_INVALID_CA                :
                            case ERROR_INTERNET_CLIENT_AUTH_CERT_NEEDED   :
                            case ERROR_INTERNET_FORTEZZA_LOGIN_NEEDED     :
                            case ERROR_INTERNET_FORCE_RETRY               :
                            case ERROR_INTERNET_SEC_CERT_ERRORS           :
                            case ERROR_INTERNET_SEC_CERT_REV_FAILED       :
                            case ERROR_INTERNET_SEC_CERT_REVOKED          :
                            case ERROR_INTERNET_LOGIN_FAILURE_DISPLAY_ENTITY_BODY:

                                pCINet->OnINetSendRequest(dwSendRequestResult);
                            break;
                            default:
                                hrError = pCINet->SetBindResult(((LPINTERNET_ASYNC_RESULT) (pvInfo))->dwError);
                            break;
                            }
                        }
                        else
                        {
                            hrError = pCINet->SetBindResult(((LPINTERNET_ASYNC_RESULT) (pvInfo))->dwError);
                        }
                    }
                }
                break;

                case INetState_READ:
                    // InternetRead returns TRUE of FALSE
                    dwAsyncResult = ((LPINTERNET_ASYNC_RESULT)pvInfo)->dwResult;
                    if (dwAsyncResult)
                    {
                        pCINet->OnINetRead(dwAsyncResult);
                    }
                    else
                    {
                        hrError = pCINet->SetBindResult(((LPINTERNET_ASYNC_RESULT) (pvInfo))->dwError);
                    }
                break;

                case INetState_DATA_AVAILABLE:
                {
                    DWORD_PTR dwResult = ((LPINTERNET_ASYNC_RESULT)(pvInfo))->dwResult;

                    if (dwResult)
                    {
                        DWORD dwBytes = ((LPINTERNET_ASYNC_RESULT) (pvInfo) )->dwError;
                        pCINet->OnINetDataAvailable(dwBytes);
                    }
                    else
                    {
                        hrError = pCINet->SetBindResult(((LPINTERNET_ASYNC_RESULT) (pvInfo))->dwError);
                    }
                }
                break;

                case INetState_READ_DIRECT:
                {
                    pCINet->OnINetReadDirect(0);
                }
                break;

                case INetState_DATA_AVAILABLE_DIRECT:
                {
                    PProtAssert((FALSE));
                }
                break;

                default:
                break;
                }

                // unguard - release
                pCINet->PrivRelease();

            }
            break;

            case INTERNET_STATUS_RESOLVING_NAME          :
            {
                // get server name or proxy as string
                //pCINet->ReportNotification(Notify_FindingServer, (LPSTR) pvInfo);
                pCINet->ReportNotification(BINDSTATUS_FINDINGRESOURCE, (LPSTR) pvInfo);
            }
            break;

            case INTERNET_STATUS_DETECTING_PROXY         :
            {
                // indicate that auto-proxy detection is in progress
                pCINet->ReportNotification(BINDSTATUS_PROXYDETECTING, (LPSTR) NULL);
            }
            break;

            case INTERNET_STATUS_CONNECTING_TO_SERVER    :
            {
                // get ip address as string
                //pCINet->ReportNotification(Notify_Connecting, (LPSTR) pvInfo);
                pCINet->ReportNotification(BINDSTATUS_CONNECTING, (LPSTR) pvInfo);
            }
            break;

            case INTERNET_STATUS_SENDING_REQUEST         :
            {
                // no data passed back
                //pCINet->ReportNotification(Notify_SendingRequest);
                pCINet->ReportNotification(BINDSTATUS_SENDINGREQUEST);
            }
            break;

            case INTERNET_STATUS_REDIRECT                :
            {
                PerfDbgLog1(tagCINet, pCINet, "+CINet::CINetCallback Redirected by WinINet (szRedirectUrl:%s)", (LPSTR) pvInfo);

                // pvinfo contains the new url
                pCINet->OnRedirect((LPSTR) pvInfo);
            }
            break;

            case INTERNET_STATUS_HANDLE_CLOSING          :
            {
                if ((*(LPHINTERNET)pvInfo) == pCINet->_hServer)
                {
                    hrError = INET_E_OK;
                    PerfDbgLog1(tagCINet, pCINet, "=== CINet::CINetCallback (Close Service Handle:%lx)", (*(LPHINTERNET) pvInfo));
                    PProtAssert((pCINet->_HandleStateServer == HandleState_Closed));
                    // this is the connect handle - call Release
                    pCINet->_hServer = 0;
                    pCINet->PrivRelease(TRUE);

                }
                else if ((*(LPHINTERNET)pvInfo) == pCINet->_hRequest)
                {
                    hrError = INET_E_OK;
                    PerfDbgLog1(tagCINet, pCINet, "=== CINet::CINetCallback (Close Request Handle:%lx)", (*(LPHINTERNET) pvInfo));
                    PProtAssert(( pCINet->_HandleStateRequest == HandleState_Closed));
                    // this is the connect handle - call Release
                    pCINet->_hRequest = 0;
                    pCINet->ReleaseTransAndBindInfo();
                    pCINet->PrivRelease(TRUE);
                }

            }
            break;

            case INTERNET_STATUS_COOKIE_SENT:
            case INTERNET_STATUS_COOKIE_RECEIVED:
            case INTERNET_STATUS_COOKIE_HISTORY:
            case INTERNET_STATUS_PRIVACY_IMPACTED:
            case INTERNET_STATUS_P3P_HEADER:
            case INTERNET_STATUS_P3P_POLICYREF:
            {
                pCINet->OnCookieNotification(dwStatus, pvInfo);
            }
            break;
            
            case INTERNET_STATUS_HANDLE_CREATED          :
            case INTERNET_STATUS_NAME_RESOLVED           :
            case INTERNET_STATUS_CONNECTED_TO_SERVER     :
            case INTERNET_STATUS_REQUEST_SENT            :
            case INTERNET_STATUS_RECEIVING_RESPONSE      :
            case INTERNET_STATUS_RESPONSE_RECEIVED       :
            case INTERNET_STATUS_CTL_RESPONSE_RECEIVED   :
            case INTERNET_STATUS_PREFETCH                :
            case INTERNET_STATUS_CLOSING_CONNECTION      :
            case INTERNET_STATUS_CONNECTION_CLOSED       :

            default:
            {
                //handle other status here
            }

            } // end switch

            if (hrError != INET_E_OK)
            {
                PerfDbgLog2(tagCINet, pCINet, "=== CINet::CINetCallback _hrINet:%lx, ERROR: %lx",
                    pCINet->_hrINet, hrError);
                // we need to terminate here
                pCINet->ReportResultAndStop(pCINet->_hrINet);
            }
            // unguard - release
            //pCINet->Release();

        }
#ifdef INET_CALLBACK_EXCEPTION
        _except(UrlMonInvokeExceptionFilter(GetExceptionCode(), GetExceptionInformation()))
        {
            dwFault = GetExceptionCode();

            #if DBG == 1
            //
            // UrlMon catches exceptions when the client generates them. This is so we can
            // cleanup properly, and allow urlmon to continue.
            //
            if (   dwFault == STATUS_ACCESS_VIOLATION
                || dwFault == 0xC0000194 /*STATUS_POSSIBLE_DEADLOCK*/
                || dwFault == 0xC00000AA /*STATUS_INSTRUCTION_MISALIGNMENT*/
                || dwFault == 0x80000002 /*STATUS_DATATYPE_MISALIGNMENT*/ )
            {
                WCHAR iidName[256];
                iidName[0] = 0;
                char achProgname[256];
                achProgname[0] = 0;

                GetModuleFileNameA(NULL,achProgname,sizeof(achProgname));
                DbgLog2(tagCINetErr, NULL,
                               "NotificationMgr has caught a fault 0x%08x on behalf of application %s",
                               dwFault, achProgname);
                //TransAssert((!"The application has faulted processing. Check the kernel debugger for useful output.URLMon can continue but you probably want to stop and debug the application."));

            }
            #endif
        }
#ifdef unix
        __endexcept
#endif /* unix */
#endif INET_CALLBACK_EXCEPTION
    }

    PerfDbgLog1(tagCINet, pCINet, "-CINet::CINetCallback (hrError:%lx)", hrError);

    DEBUG_LEAVE(0);
}


//+---------------------------------------------------------------------------
//
//  Method:     CINet::TransitState
//
//  Synopsis:
//
//  Arguments:  [dwState] --
//
//  Returns:
//
//  History:    1-27-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
void CINet::TransitState(DWORD dwState, BOOL fAsync)
{
    DEBUG_ENTER((DBG_APP,
                None,
                "CINet::TransitState",
                "this=%#x, %#x, %B",
                this, dwState, fAsync
                ));
                
    PerfDbgLog(tagCINet, this, "+CINet::TransitState");

    if ((_dwState != INetState_DONE) && (_dwState != INetState_ERROR))
    {
        BINDSTATUS NMsg = (BINDSTATUS) ((fAsync) ? BINDSTATUS_INTERNALASYNC : BINDSTATUS_INTERNAL);
        DWORD dwFlags = 0;

        if (   NMsg == BINDSTATUS_INTERNALASYNC
            || NMsg == BINDSTATUS_ERROR
            || NMsg == BINDSTATUS_INTERNALASYNC)
        {
            dwFlags |= PI_FORCE_ASYNC;
        }
        if (   (dwState == INetState_AUTHENTICATE)
            || (dwState == INetState_DISPLAY_UI))
        {
            dwFlags |= PD_FORCE_SWITCH;
        }


        if( _grfBindF & BINDF_FROMURLMON )
        {
            CStateInfo CSI = CStateInfo(NMsg, dwFlags, (LPVOID)(ULongToPtr((ULONG)dwState)));
            if( _pCTrans )
            {
                _pCTrans->Switch(&CSI);
            }
        }
        else
        {
            CStateInfo* pCSI = new CStateInfo(NMsg, dwFlags, (LPVOID)(ULongToPtr((ULONG)dwState)));
            if( !pCSI )
            {
                ReportResultAndStop(E_OUTOFMEMORY);
            }
            else
            {
                if( dwFlags & PD_FORCE_SWITCH || _fForceSwitch )
                {
                    if( _pCTrans )
                    {
                        _pCTrans->Switch(pCSI);
                    }
                }
                else
                {
                    Continue(pCSI);
                }
            }
        }
    }

    PerfDbgLog(tagCINet, this, "-CINet::TransitState");

    DEBUG_LEAVE(0);
}

//+---------------------------------------------------------------------------
//
//  Method:     CINet::OnINetInternal
//
//  Synopsis:
//
//  Arguments:  [dwState] --
//
//  Returns:
//
//  History:    1-27-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
void CINet::OnINetInternal(DWORD_PTR dwState)
{
    DEBUG_ENTER((DBG_APP,
                None,
                "CINet::OnINetInternal",
                "this=%#x, %#x",
                this, dwState
                ));
                
    PerfDbgLog(tagCINet, this, "+CINet::OnINetInternal");

    HRESULT hr = NOERROR;

    if ((_dwState != INetState_DONE) && (_dwState != INetState_ERROR))
    {
        switch (dwState)
        {
        case INetState_START           :
            // is requested
            hr = INetAsyncOpen();
            break;
        case INetState_OPEN_REQUEST    :
            hr = INetAsyncConnect();
            break;
        case INetState_CONNECT_REQUEST :
            hr = INetAsyncOpenRequest();
            break;
        case INetState_PROTOPEN_REQUEST:
            hr = INetAsyncSendRequest();
            break;
        case INetState_SEND_REQUEST    :
            if( _fSendRequestAgain )
            {
                _fCompleted = FALSE;
                _fSendAgain = TRUE;
                _fSendRequestAgain = FALSE;
                hr = INetAsyncSendRequest();
            }
            else
            {
                hr = INetQueryInfo();
            }
            break;
        case INetState_DISPLAY_UI      :
            hr = INetDisplayUI();
            break;
        case INetState_AUTHENTICATE    :
            hr = INetAuthenticate();
            break;
        case INetState_READ            :
            hr = INetRead();
            break;
        case INetState_READ_DIRECT     :
            hr = INetReadDirect();
            break;
        case INetState_DATA_AVAILABLE  :
            hr = INetReportAvailableData();
            break;
        case INetState_INETSTATE_CHANGE:
            hr = INetStateChange();
            break;
        case INetState_DONE            :
            break;
        default:
            break;
        }
    }
    /*
    else
    {
        PProtAssert((FALSE && "Unknown state"));
    }
    */

    if ((hr != NOERROR) && (hr != E_PENDING))
    {
        ReportResultAndStop(hr);
    }

    PerfDbgLog(tagCINet, this, "-CINet::OnINetInternal");

    DEBUG_LEAVE(0);
}


//+---------------------------------------------------------------------------
//
//  Method:     CINet::TerminateRequest
//
//  Synopsis:   Close the server and request handle - wininet will make a
//              callback on each handle closed
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    1-27-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
void CINet::TerminateRequest()
{
    DEBUG_ENTER((DBG_APP,
                None,
                "CINet::TerminateRequest",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCINet, this, "+CINet::TerminateRequest");
    CLock lck(_mxs);    // only one thread should be in here

    if ((_HandleStateRequest == HandleState_Initialized))
    {
        PProtAssert((_hRequest));
        _HandleStateRequest = HandleState_Closed;
        InternetCloseHandle(_hRequest);
        //_hRequest = 0;
    }
    else if ((_HandleStateRequest == HandleState_Pending))
    {
        _HandleStateRequest = HandleState_Aborted;
    }

    if (_HandleStateServer == HandleState_Initialized)
    {
        PerfDbgLog1(tagCINet, this, "=== CINet::TerminateRequest InternetCloseHandle (hServer:%lx)", _hServer);
        _HandleStateServer = HandleState_Closed;

        if (_hServer)
        {
            // the handle can be NULL
            // in case we got aborted during the
            // pending open request
            InternetCloseHandle(_hServer);
        }
    }
    else if ((_HandleStateServer == HandleState_Pending))
    {
        _HandleStateServer = HandleState_Aborted;
    }

    PerfDbgLog(tagCINet, this, "-CINet::TerminateRequest");

    DEBUG_LEAVE(0);
}

//+---------------------------------------------------------------------------
//
//  Method:     CINet::FindTagInHeader
//
//  Synopsis:
//
//  Arguments:  [lpszBuffer] --
//              [lpszTag] --
//
//  Returns:
//
//  History:    1-27-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
LPSTR CINet::FindTagInHeader(LPCSTR lpszBuffer, LPCSTR lpszTag)
{
    DEBUG_ENTER((DBG_APP,
                String,
                "CINet::FindTagInHeader",
                "this=%#x, %.80q, %.80q",
                this, lpszBuffer, lpszTag
                ));
                
    PerfDbgLog(tagCINet, this, "+CINet::FindTagInHeader");
    LPCSTR p;
    int i, cbTagLen;

    cbTagLen = strlen(lpszTag);
    for (p = lpszBuffer; i = strlen(p); p += (i + 1))
    {
        if (!StrCmpNI(p, lpszTag, cbTagLen))
        {

            DEBUG_LEAVE((LPSTR)p);
            return (LPSTR)p;
        }
    }

    PerfDbgLog(tagCINet, this, "-CINet::FindTagInHeader");

    DEBUG_LEAVE(NULL);
    return NULL;
}


//+---------------------------------------------------------------------------
//
//  Method:     CINet::INetDataAvailable
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    2-23-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINet::INetDataAvailable()
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINet::INetDataAvailable",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCINet, this, "+CINet::INetDataAvailable");

    HRESULT hr = NOERROR;
    BOOL fRet = FALSE;

    PProtAssert((GetStatePending() == NOERROR));
    SetINetState(INetState_DATA_AVAILABLE);

    if (!_fFilenameReported)
    {
        char szFilename[MAX_PATH];

        HRESULT hr1 = GetUrlCacheFilename(szFilename, MAX_PATH);

        if (hr1 == NOERROR && szFilename[0] != '\0' )
        {
            ReportNotification(BINDSTATUS_CACHEFILENAMEAVAILABLE, (LPSTR) szFilename);
            _fFilenameReported = TRUE;
        }
    }

    // check if all data were read of the current buffer
    SetStatePending(E_PENDING);

    fRet = InternetQueryDataAvailable(_hRequest, &_cbReadReturn, 0, 0);

    if (fRet == FALSE)
    {
        dwLstError = GetLastError();
        if (dwLstError == ERROR_IO_PENDING)
        {
            hr = E_PENDING;
        }
        else
        {
            SetStatePending(NOERROR);
            hr = _hrError = INET_E_DATA_NOT_AVAILABLE;
        }
    }
    else
    {
        SetByteCountReadyToRead(_cbReadReturn);
        SetStatePending(NOERROR);

        if (_cbReadReturn == 0)
        {
            // done
            _fDone = 1;
        }

        hr = INetReportAvailableData();
    }

    PerfDbgLog1(tagCINet, this, "-CINet::INetDataAvailable (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINet::OnINetDataAvailable
//
//  Synopsis:
//
//  Arguments:  [dwResult] --
//
//  Returns:
//
//  History:    2-23-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINet::OnINetDataAvailable( DWORD dwResult)
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINet::OnINetDataAvailable",
                "this=%#x, %#x",
                this, dwResult
                ));
                
    PerfDbgLog1(tagCINet, this, "+CINet::OnINetDataAvailable (dwAvailable:%ld)", dwResult);
    HRESULT hr = NOERROR;

    PProtAssert((GetStatePending() == E_PENDING));

    SetByteCountReadyToRead(dwResult);

    if (dwResult == 0)
    {
        // done
        _fDone = 1;
    }

    // set state to normal - no pending transaction
    SetStatePending(NOERROR);

    // notification for next request
    TransitState(INetState_DATA_AVAILABLE);


    PerfDbgLog1(tagCINet, this, "-CINet::OnINetDataAvailable (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINet::INetReportAvailableData
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    2-23-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINet::INetReportAvailableData()
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINet::INetReportAvailableData",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCINet, this, "+CINet::INetReportAvailableData");
    HRESULT hr = NOERROR;
    DWORD dwError;
    ULONG cbBytesAvailable = 0;

    //BUGBUG: we hit this assertion sometimes.
    //PProtAssert((GetStatePending() == NOERROR));

    _hrError = INET_E_OK;

    if ((GetStatePending() == E_PENDING))
    {
        // nothing to do - data for this notfication
        // already received
    }
    else if ((cbBytesAvailable = GetByteCountReadyToRead()) != 0)
    {
        if (   _fDone
            || (   _cbTotalBytesRead
                  && _cbDataSize
                  && (_cbTotalBytesRead == _cbDataSize)))
        {

            _hrError = INET_E_DONE;
        }
        else
        {
            if(_cbDataSize && (_cbDataSize < (cbBytesAvailable + _cbTotalBytesRead)))
            {
                _cbDataSize = cbBytesAvailable + _cbTotalBytesRead;
            }

            if (_bscf & BSCF_DATAFULLYAVAILABLE)
            {
                _bscf |= BSCF_LASTDATANOTIFICATION;
                _bscf &= ~BSCF_FIRSTDATANOTIFICATION;
            }
            // BUG-WORK pCTrans migh be gone by now
            _cbSizeLastReportData = cbBytesAvailable + _cbTotalBytesRead;
            hr = _pEmbdFilter->ReportData(_bscf, cbBytesAvailable + _cbTotalBytesRead, _cbDataSize);

            if (_bscf & BSCF_FIRSTDATANOTIFICATION)
            {
                _bscf &= ~BSCF_FIRSTDATANOTIFICATION;
                _bscf |= BSCF_INTERMEDIATEDATANOTIFICATION;
            }
        }

    }
    else if (   _fDone
             || (   _cbTotalBytesRead
                 && _cbDataSize
                 && (_cbTotalBytesRead == _cbDataSize)))
    {
        if (_cbDataSize == 0)
        {
            _cbDataSize = _cbTotalBytesRead;
        }

        PerfDbgLog2(tagCINet, this, "=== CINet::INetReportAvailableData DONE! (cbTotalBytesRead:%ld, cbDataSize:%ld)", _cbTotalBytesRead, _cbDataSize);
        // now we should have all data
        PProtAssert(( (   ( _cbDataSize == 0)
                       || ((_cbDataSize != 0) && (_cbTotalBytesRead == _cbDataSize)))
                     && "Did not get all data!!"));


        _hrError = INET_E_DONE;
    }

    if (_hrError != INET_E_OK)
    {
        _bscf |= BSCF_LASTDATANOTIFICATION;
        if (_pCTrans )
        {
            _cbSizeLastReportData = _cbTotalBytesRead;
            hr = _pEmbdFilter->ReportData(_bscf, _cbTotalBytesRead, _cbDataSize);

        }
        hr = NOERROR;
    }

    PerfDbgLog2(tagCINet, this, "-CINet::INetReportAvailableData (_hrError:%lx, hr:%lx)", _hrError, hr);

    DEBUG_LEAVE(hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CINet::ReadDataHere
//
//  Synopsis:
//
//  Arguments:  [pBuffer] --
//              [cbBytes] --
//              [pcbBytes] --
//
//  Returns:
//
//  History:    2-13-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINet::ReadDataHere(BYTE *pBuffer, DWORD cbBytes, DWORD *pcbBytes)
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINet::ReadDataHere",
                "this=%#x, pBuffer, cbBytes, pcbBytes",
                this, pBuffer, cbBytes, pcbBytes
                ));
                
    PerfDbgLog(tagCINet, this, "+CINet::ReadDataHere");
    HRESULT hr = NOERROR;
    DWORD dwError;

    *pcbBytes = 0;
    ULONG cbReadReturn = 0;
    ULONG dwReturned = 0;
    ULONG dwReturnedTotal = 0;
    ULONG dwBytesLeft = cbBytes;

    //BUGBUG: turn this assertion on again
    //PProtAssert((GetStatePending() == NOERROR));

    if (_hrError == INET_E_DONE)
    {
        // means end of file
        hr = S_FALSE;
    }
    else if (GetStatePending() != NOERROR)
    {
        hr = E_PENDING;
    }
    else
    {
        _hrError = INET_E_OK;
        do
        {
            if ((cbReadReturn = GetByteCountReadyToRead()) == 0)
            {
                BOOL fRet;

                PerfDbgLog(tagCINet, this, "CINet::ReadDataHere -> InternetQueryDataAvailable");
                PProtAssert((GetStatePending() == NOERROR));
                SetStatePending(E_PENDING);
                fRet = InternetQueryDataAvailable(_hRequest, &_cbReadReturn,0 ,0);

                if (fRet == FALSE)
                {
                    dwLstError = GetLastError();
                    if (dwLstError == ERROR_IO_PENDING)
                    {
                        hr = E_PENDING;
                    }
                    else
                    {
                        SetStatePending(NOERROR);
                        hr = _hrError = INET_E_DATA_NOT_AVAILABLE;
                    }
                }
                else
                {
                    SetByteCountReadyToRead(_cbReadReturn);
                    SetStatePending(NOERROR);
                    if (_cbReadReturn == 0)
                    {
                        // download completed - no more data available
                        hr = _hrError = INET_E_DONE;
                    }
                }

                PerfDbgLog2(tagCINet, this, "CINet::ReadDataHere == InternetQueryDataAvailable (fRet:%d, _cbReadReturn:%ld)", fRet, _cbReadReturn);
            }

            // in case of noerror read the bits
            if ((hr == NOERROR) && (_hrError == INET_E_OK))
            {
                cbReadReturn = GetByteCountReadyToRead();
                PProtAssert((GetStatePending() == NOERROR));

                // get the read buffer from the trans data object
                PProtAssert(((pBuffer != NULL) && (cbBytes > 0)));
                PProtAssert((cbReadReturn > 0));

                dwBytesLeft = cbBytes - dwReturnedTotal;
                if (dwBytesLeft > cbReadReturn)
                {
                    dwBytesLeft = cbReadReturn;
                }

                PProtAssert(( dwBytesLeft <= (cbBytes - dwReturnedTotal) ));

                dwReturned = 0;
                PerfDbgLog1(tagCINet, this, "CINet::ReadDataHere -> InternetReadFile (dwBytesLeft:%ld)", dwBytesLeft);
                if (!InternetReadFile(_hRequest, pBuffer + dwReturnedTotal, dwBytesLeft, &dwReturned))
                {
                    dwError = GetLastError();
                    if (dwError != ERROR_IO_PENDING)
                    {
                        hr = _hrError = INET_E_DOWNLOAD_FAILURE;
                        DbgLog3(tagCINetErr, this, "CINet::ReadDataHere failed: (dwError:%lx, hr:%lx, hrError:%lx)",
                                                    dwError, hr, _hrError);

                    }
                    else
                    {
                        // Note: BIG ERROR - we need to shut down now
                        // wininet is using the client buffer and the client is not
                        // aware that the buffer is used during the pending time
                        //
                        DbgLog(tagCINetErr, this, "CINet::ReadDataHere - InternetReadFile returned E_PENDING!!!");
                        PProtAssert((FALSE &&  "CINet::ReadDataHere - InternetReadFile returned E_PENDING!!!"));

                        hr = _hrError = INET_E_DOWNLOAD_FAILURE;
                    }

                    PerfDbgLog1(tagCINet, this, "CINet::ReadDataHere == InternetReadFile (dwError:%lx)", dwError);

                }
                else
                {
                    PerfDbgLog3(tagCINet, this, "CINet::ReadDataHere == InternetReadFile ==> (cbBytes:%ld, dwReturned:%ld,_cbReadReturn:%ld)",
                        cbBytes, dwReturned,_cbReadReturn);

                    PProtAssert((  (cbBytes + dwReturnedTotal) >= dwReturned ));

                    if (dwReturned == 0)
                    {
                        hr = _hrError = INET_E_DONE;
                    }
                    else
                    {
                        hr = NOERROR;
                    }

                    dwReturnedTotal += dwReturned;
                    cbReadReturn -= dwReturned;
                    SetByteCountReadyToRead(-(LONG)dwReturned);
                    _cbTotalBytesRead += dwReturned;
                }
            }  // read case - bits available

            PerfDbgLog4(tagCINet, this, "CINet::ReadDataHere ooo InternetReadFile ==>(cbBytes:%ld, dwReturned:%ld,cbReadReturn:%ld,dwReturnedTotal:%ld)",
                cbBytes, dwReturned,cbReadReturn,dwReturnedTotal);

        } while ((hr == NOERROR) && (dwReturnedTotal < cbBytes));

        PProtAssert((dwReturnedTotal <= cbBytes));
        *pcbBytes = dwReturnedTotal;

        if (hr == INET_E_DONE)
        {
            hr = (dwReturnedTotal) ? S_OK : S_FALSE;
        }
    }

    // Note: stop the download in case of DONE or ERROR!
    if (_hrError != INET_E_OK)
    {
        ReportResultAndStop((hr == S_FALSE) ? NOERROR : hr,  _cbTotalBytesRead, _cbDataSize);
    }

    PerfDbgLog4(tagCINet, this, "-CINet::ReadDataHere (_hrError:%lx, [hr:%lx,cbBytesAsked:%ld,cbBytesReturned:%ld])",
        _hrError, hr, cbBytes, *pcbBytes);

    DEBUG_LEAVE(hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CINet::OperationOnAparmentThread
//
//  Synopsis:
//
//  Arguments:  [dwState] --
//
//  Returns:
//
//  History:    1-27-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL CINet::OperationOnAparmentThread(DWORD dwState)
{
    DEBUG_ENTER((DBG_APP,
                Bool,
                "CINet::OperationOnAparmentThread",
                "this=%#x, %#x",
                this, dwState
                ));
                
    PerfDbgLog(tagCINet, this, "+CINet::OperationOnAparmentThread");
    BOOL fRet = FALSE;
    switch (dwState)
    {
    case INetState_OPEN_REQUEST:
        break;
    case INetState_CONNECT_REQUEST:
        break;
    case INetState_PROTOPEN_REQUEST:
        break;
    case INetState_SEND_REQUEST:
        break;
    case INetState_READ:
    case INetState_READ_DIRECT:
        fRet = TRUE;
        break;
    default:
        fRet = TRUE;
        break;
    }
    //return fRet;

    PerfDbgLog(tagCINet, this, "-CINet::OperationOnAparmentThread");

    DEBUG_LEAVE(TRUE);
    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINet::OperationOnAparmentThread
//
//  Synopsis:
//
//  Returns:
//
//  History:    10-27-98   DanpoZ (Danpo Zhang)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL CINet::UTF8Enabled()
{
    DEBUG_ENTER((DBG_APP,
                Bool,
                "CINet::UTF8Enabled",
                "this=%#x",
                this
                ));
                
    BOOL bRet = FALSE;
    // do not enable utf8 on file or ftp protocol
    if( _dwIsA == DLD_PROTOCOL_FILE ||
        _dwIsA == DLD_PROTOCOL_FTP  )
    {
        goto exit;
    }

    // default to per-machine utf-8 setting
    bRet = g_bGlobalUTF8Enabled;

    // per-binding flag
    if( _BndInfo.dwOptions & BINDINFO_OPTIONS_ENABLE_UTF8)
    {
        bRet = TRUE;
    }

    if( _BndInfo.dwOptions & BINDINFO_OPTIONS_DISABLE_UTF8)
    {
        bRet = FALSE;
    }

    if( _BndInfo.dwOptions & BINDINFO_OPTIONS_USE_IE_ENCODING)
    {
        DWORD dwIE;
        DWORD dwOutLen = sizeof(DWORD);
        HRESULT hr = UrlMkGetSessionOption(
            URLMON_OPTION_URL_ENCODING,
            &dwIE,
            sizeof(DWORD),
            &dwOutLen,
            NULL );

        if( hr == NOERROR )
        {
            if( dwIE == URL_ENCODING_ENABLE_UTF8 )
            {
                bRet = TRUE;
            }
            else if( dwIE == URL_ENCODING_DISABLE_UTF8 )
            {
                bRet = FALSE;
            }
        }
    }

exit:

    DEBUG_LEAVE(bRet);
    return bRet;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINet::QueryInfoOnResponse
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    1-27-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINet::QueryInfoOnResponse()
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINet::QueryInfoOnResponse",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCINet, this, "+CINet::QueryInfoOnResponse");
    HRESULT hr = NOERROR;

    DWORD dwFlags;
    DWORD cbLen = sizeof(dwFlags);

    // See if it is from the cache
    if (InternetQueryOption(_hRequest, INTERNET_OPTION_REQUEST_FLAGS, &dwFlags, &cbLen))
    {
        if (dwFlags & INTERNET_REQFLAG_FROM_CACHE)
        {
            _dwCacheFlags |= INTERNET_REQFLAG_FROM_CACHE;
            // set flag that data are from cache
            _bscf |= BSCF_DATAFULLYAVAILABLE;
        }
    }

    hr =  QueryStatusOnResponse();
    if (hr == NOERROR)
    {
        hr = QueryHeaderOnResponse();
    }

    if (_hrError != INET_E_OK)
    {
        SetINetState(INetState_DONE);
    }

    PerfDbgLog1(tagCINet, this, "-CINet::QueryInfoOnResponse (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINet::QueryStatusOnResponse
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    1-27-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINet::QueryStatusOnResponse()
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINet::QueryStatusOnResponse",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCINet, this, "+CINet::QueryStatusOnResponse");

    PProtAssert((FALSE));

    PerfDbgLog1(tagCINet, this, "-CINet::QueryStatusOnResponse hr:%lx", E_FAIL);

    DEBUG_LEAVE(E_FAIL);
    return E_FAIL;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINet::QueryStatusOnResponseDefault
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    1-27-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINet::QueryStatusOnResponseDefault(DWORD dwStat)
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINet::QueryStatusOnResponseDefault",
                "this=%#x, %#x",
                this, dwStat
                ));
                
    PerfDbgLog(tagCINet, this, "+CINet::QueryStatusOnResponseDefault");

    PProtAssert((FALSE));

    PerfDbgLog1(tagCINet, this, "-CINet::QueryStatusOnResponseDefault hr:%lx", E_FAIL);

    DEBUG_LEAVE(E_FAIL);
    return E_FAIL;
}


//+---------------------------------------------------------------------------
//
//  Method:     CINet::QueryHeaderOnResponse
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    1-27-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINet::QueryHeaderOnResponse()
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINet::QueryHeaderOnResponse",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCINet, this, "+CINet::QueryHeaderOnResponse");

    PProtAssert((FALSE));

    PerfDbgLog1(tagCINet, this, "-CINet::QueryHeaderOnResponse hr:%lx", E_FAIL);

    DEBUG_LEAVE(E_FAIL);
    return E_FAIL;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINet::RedirectRequest
//
//  Synopsis:
//
//  Arguments:  [lpszBuffer] --
//              [pdwBuffSize] --
//
//  Returns:
//
//  History:    1-27-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINet::RedirectRequest(LPSTR lpszBuffer, DWORD *pdwBuffSize, DWORD dwStatus)
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINet::RedirectRequest",
                "this=%#x, %#x, %#x, %d",
                this, lpszBuffer, pdwBuffSize, dwStatus
                ));
                
    PerfDbgLog(tagCINet, this, "+CINet::RedirectRequest");

    PProtAssert((FALSE));

    PerfDbgLog1(tagCINet, this, "-CINet::RedirectRequest(fRet:%ld)", FALSE);

    DEBUG_LEAVE(E_FAIL);
    return E_FAIL;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINet::AuthenticationRequest
//
//  Synopsis:
//
//  Arguments:  [lpszBuffer] --
//              [pdwBuffSize] --
//
//  Returns:
//
//  History:    2-06-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINet::AuthenticationRequest()
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINet::AuthenticationRequest",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCINet, this, "+CINet::AuthenticationRequest");
    HRESULT hr = NOERROR;
    DWORD dwError;

    LPWSTR pwzUsername = NULL;
    LPWSTR pwzPassword = NULL;

    DWORD  dwBindF = GetBindFlags();


    PerfDbgLog2(tagCINet, this, "<1> _cbProxyAuthenticate:%d _cbAuthenticate:%d",
               _cbProxyAuthenticate, _cbAuthenticate);
    if (_fProxyAuth ?  (_cbProxyAuthenticate >= AUTHENTICATE_MAX):(_cbAuthenticate >= AUTHENTICATE_MAX))
    {
        // NOTE: set the error to noerror and
        // continue reading data and show the 401 contained
        _hrINet = hr = NOERROR;
    }
    else
    {
        if (_hwndAuth == NULL)
        {
            IAuthenticate *pPInfo;
            DbgLog(tagCINetErr, this, "+CINet::AuthenticationRequest: QS for IAuthenticate");
            hr = QueryService(IID_IAuthenticate, (void **)&pPInfo);
            if (hr == NOERROR)
            {
                PProtAssert((pPInfo));
                hr = pPInfo->Authenticate(&_hwndAuth, &pwzUsername, &pwzPassword);
                pPInfo->Release();
            }
        }

        if (hr == NOERROR)
        {
            _hrINet = hr = E_ACCESSDENIED;

            if (pwzUsername && pwzPassword)
            {
                // set the username and password
                // and retry sendrequest

                LPSTR pszUsername = DupW2A(pwzUsername);
                LPSTR pszPassword = DupW2A(pwzPassword);

                if (pszUsername)
                {
                    InternetSetOption(_hRequest, INTERNET_OPTION_USERNAME, pszUsername, strlen(pszUsername)+1);
                    delete pszUsername;
                }
                if (pszPassword)
                {
                    InternetSetOption(_hRequest, INTERNET_OPTION_PASSWORD, pszPassword, strlen(pszPassword)+1);
                    delete pszPassword;
                }

                // if we got username & pwd, only try once
                _fProxyAuth ?  _cbProxyAuthenticate = AUTHENTICATE_MAX :
                                _cbAuthenticate = AUTHENTICATE_MAX;
                _hrINet = hr = RPC_E_RETRY;
                PerfDbgLog2(tagCINet, this, "<2> _cbProxyAuthenticate:%d _cbAuthenticate:%d",
                       _cbProxyAuthenticate, _cbAuthenticate);
        }

            if (   (_hwndAuth || (_hwndAuth == (HWND)-1) )
                && (_pCAuthData == NULL)
                && (hr != RPC_E_RETRY) )

            {
                PProtAssert((_pCAuthData == NULL));
                _pCAuthData = new CAuthData(this);
            }

            if (   (_hwndAuth || (_hwndAuth == (HWND)-1) )
                && _pCAuthData
                && (hr != RPC_E_RETRY) )
            {
                BOOL fRetry = FALSE;
                BOOL fDeleteAuthData = TRUE;
                DWORD dwFlags = (  FLAGS_ERROR_UI_FILTER_FOR_ERRORS | FLAGS_ERROR_UI_FLAGS_CHANGE_OPTIONS
                                 | FLAGS_ERROR_UI_FLAGS_GENERATE_DATA | FLAGS_ERROR_UI_SERIALIZE_DIALOGS);

                if ((dwBindF & BINDF_NO_UI) || (dwBindF & BINDF_SILENTOPERATION))
                {
                    dwFlags |= FLAGS_ERROR_UI_FLAGS_NO_UI;
                }

                if (_hwndAuth == (HWND)-1)
                {
                    _hwndAuth = 0;
                }

                do
                {
                    _fProxyAuth ? _cbProxyAuthenticate++ : _cbAuthenticate++;
                    PerfDbgLog2(tagCINet, this, "<3> _cbProxyAuthenticate:%d _cbAuthenticate:%d",
                               _cbProxyAuthenticate, _cbAuthenticate);

                    dwError = InternetErrorDlg(_hwndAuth,_hRequest,ERROR_SUCCESS,dwFlags,(LPVOID *)&_pCAuthData);

                    switch (dwError)
                    {
                    case ERROR_CANCELLED :
                        // wininet should never return cancelled here
                        PProtAssert((FALSE));
                    case ERROR_SUCCESS  :
                        // NOTE: succes and cancel means display the content according to ArthurBi
                        // continue reading data and show the 401 contained
                        _hrINet = hr = NOERROR;
                        break;

                    case ERROR_INTERNET_FORCE_RETRY :
                        _hrINet = hr = RPC_E_RETRY;
                        break;

                    case ERROR_INTERNET_DIALOG_PENDING :
                        // a dialog is up on another thread
                        // start wating on the callback
                        SetINetState(INetState_AUTHENTICATE);
                        SetStatePending(E_PENDING);
                        _fProxyAuth ? _cbProxyAuthenticate-- : _cbAuthenticate--;
                        PerfDbgLog2(tagCINet, this, "<4> _cbProxyAuthenticate:%d _cbAuthenticate:%d",
                                   _cbProxyAuthenticate, _cbAuthenticate);
                        fDeleteAuthData = FALSE;
                        _hrINet = hr = E_PENDING;
                        break;

                    case ERROR_INTERNET_RETRY_DIALOG:
                        _fProxyAuth ? _cbProxyAuthenticate-- : _cbAuthenticate--;
                        PerfDbgLog2(tagCINet, this, "<5> _cbProxyAuthenticate:%d _cbAuthenticate:%d",
                                   _cbProxyAuthenticate, _cbAuthenticate);
                        fRetry = TRUE;
                        break;

                    default:
                        _hrINet = hr = E_ACCESSDENIED;
                        break;
                    }

                } while (fRetry);

                if (fDeleteAuthData)
                {
                    delete _pCAuthData;
                    _pCAuthData = NULL;
                }

            }
        }
        else
        {
            _hrINet = hr = E_ACCESSDENIED;
        }

        if (hr == RPC_E_RETRY)
        {
            _hrINet = NOERROR;
            _fCompleted = FALSE;
            _fSendAgain = TRUE;
            if (IsA() == DLD_PROTOCOL_FTP || IsA() == DLD_PROTOCOL_GOPHER)
            {
                // Retry InternetOpenUrl using the updated auth info.
                _fDoSimpleRetry = TRUE;
                hr = INetAsyncOpenRequest();
            }
            else
            {
                hr = INetAsyncSendRequest();
            }
        }
        else if (hr == E_PENDING)
        {
            // do nothing and wait for async completion
        }
        else if (   (hr != HRESULT_FROM_WIN32(ERROR_CANCELLED))
                 && (hr != NOERROR))
        {
            // set the error to access denied
            _hrINet = hr = E_ACCESSDENIED;
        }
    }

    if (pwzUsername)
    {
        delete pwzUsername;
    }
    if (pwzPassword)
    {
        delete pwzPassword;
    }

    PerfDbgLog1(tagCINet, this, "-CINet::AuthenticationRequest(hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINet::GetUrlCacheFilename
//
//  Synopsis:
//
//  Arguments:  [szFilename] --
//              [dwSize] --
//
//  Returns:
//
//  History:    2-28-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINet::GetUrlCacheFilename(LPSTR szFilename, DWORD dwSize)
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINet::GetUrlCacheFilename",
                "this=%#x, %#x, %#x",
                this, szFilename, dwSize
                ));
                
    PerfDbgLog(tagCINet, this, "+CINet::GetUrlCacheFilename");
    HRESULT hr = NOERROR;
    BOOL fRet = FALSE;
    DWORD dwSizeLocal = dwSize;
    DWORD dwError = 0;

    if (dwSize)
    {
        szFilename[0] = '\0';
    }

    if (   !(GetBindFlags() & BINDF_NOWRITECACHE)
        ||  (GetBindFlags() & BINDF_NEEDFILE))
    {
        fRet = InternetQueryOption(_hRequest, INTERNET_OPTION_DATAFILE_NAME, szFilename, &dwSizeLocal);

        if (!fRet && (GetBindFlags() & BINDF_NEEDFILE))
        {
            dwError = GetLastError();
            hr = INET_E_DATA_NOT_AVAILABLE;
            SetBindResult(dwError, hr);
            if (dwSize)
            {
                szFilename[0] = '\0';
            }
        }
    }

    PerfDbgLog3(tagCINet, this, "-CINet::GetUrlCacheFilename (hr:%lx,fRet%d; szFilename:%s)", hr, fRet, szFilename);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINet::LockFile
//
//  Synopsis:
//
//  Arguments:  [szFilename] --
//              [dwSize] --
//
//  Returns:
//
//  History:    8-13-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINet::LockFile(BOOL fRetrieve)
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINet::LockFile",
                "this=%#x, %B",
                this, fRetrieve
                ));
                
    PerfDbgLog(tagCINet, this, "+CINet::LockFile");
    HRESULT hr = NOERROR;
    BOOL fRet = FALSE;

    if (fRetrieve)
    {
        DWORD dwCacheEntryInfoBufferSize = MAX_URL_SIZE + MAX_PATH + sizeof(INTERNET_CACHE_ENTRY_INFO) + 2;
        INTERNET_CACHE_ENTRY_INFO *pCacheEntryInfo = (INTERNET_CACHE_ENTRY_INFO *)new CHAR [dwCacheEntryInfoBufferSize];
        DWORD dwError = 0;
        if (   (_fLocked == FALSE)
            && (pCacheEntryInfo != NULL)
            && (RetrieveUrlCacheEntryFileA( _pszFullURL, pCacheEntryInfo, &dwCacheEntryInfoBufferSize, 0)))
        {
            _fLocked = TRUE;
        }

        if (pCacheEntryInfo != NULL)
        {
            delete pCacheEntryInfo;
        }
    }
    else if ((_hLockHandle == NULL) && _hRequest)
    {
        if (InternetLockRequestFile(_hRequest, &_hLockHandle))
        {
            PProtAssert((_hLockHandle));
        }
    }

    PerfDbgLog2(tagCINet, this, "-CINet::LockFile (hr:%lx,fRet%d)", hr, fRet);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINet::UnlockFile
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    8-13-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINet::UnlockFile()
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINet::UnlockFile",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCINet, this, "IN CINet::UnlockFile");
    HRESULT hr = NOERROR;

    if (_fLocked)
    {
        UnlockUrlCacheEntryFileA(_pszFullURL, 0);
        _fLocked = FALSE;
    }
    else if (_hLockHandle)
    {
        if (InternetUnlockRequestFile(_hLockHandle))
        {
            _hLockHandle = NULL;
        }
    }

    PerfDbgLog1(tagCINet, this, "-CINet::UnlockFile (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINet::HResultFromInternetError
//
//  Synopsis:   maps the dwStatus ERROR_INTERNET_XXX do an hresult
//
//  Arguments:  [dwStatus] --
//
//  Returns:
//
//  History:    3-22-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINet::HResultFromInternetError(DWORD dwStatus)
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINet::HResultFromInternetError",
                "this=%#x, %#x",
                this, dwStatus
                ));
                
    PerfDbgLog(tagCINet, this, "+CINet::HResultFromInternetError");
    // dwResult is out of our know table
    HRESULT hr = INET_E_DOWNLOAD_FAILURE;
    ULONG   ulIndex = dwStatus - INTERNET_ERROR_BASE;

    PProtAssert((ulIndex > 0));
    BOOL fTable1 = (ulIndex > 0 && ulIndex < sizeof(INetError)/sizeof(InterErrorToHResult));
    DWORD dwTable2Size = sizeof(INetErrorExtended)/sizeof(InterErrorToHResult);
    BOOL fTable2 = FALSE;

    if (!fTable1)
    {
        fTable2 = (dwStatus <= INetErrorExtended[dwTable2Size].dwError);
    }
    if (fTable1)
    {
        // sequential table
        hr = INetError[ulIndex].hresult;
    }
    else if (fTable2)
    {
        // walk the table
        for (DWORD i = 0; i < dwTable2Size; i++)
        {
            if (INetErrorExtended[i].dwError == dwStatus)
            {
                hr = INetErrorExtended[i].hresult;
                break;
            }
        }
    }

    PerfDbgLog1(tagCINet, this, "-CINet::HResultFromInternetError (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}
//+---------------------------------------------------------------------------
//
//  Function:   SetBindResult
//
//  Synopsis:
//
//  Arguments:  [dwResult] --
//
//  Returns:
//
//  History:    5-10-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINet::SetBindResult(DWORD dwResult, HRESULT hrSuggested)
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINet::SetBindResult",
                "this=%#x, %#x, %#x",
                this, dwResult, hrSuggested
                ));
                
    PerfDbgLog2(tagCINet, this, "+CINet::SetBindResult(dwResult:%ld, hrSuggested:%lx)", dwResult, hrSuggested);
    HRESULT hr = NOERROR;

    PProtAssert((_pszResult == NULL));
    _pszResult = NULL;
    _dwResult = dwResult;

    // only find hresult in the mapping table
    // if no erro was suggested
    if (hrSuggested == NOERROR)
    {
        hr = _hrINet = HResultFromInternetError(_dwResult);
    }
    else
    {
         hr = _hrINet = hrSuggested;
    }

    PerfDbgLog3(tagCINet, this, "-CINet::SetBindResult (dwResult:%ld, _hrINet:%lx,  hr:%lx)", dwResult, _hrINet, hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINet::GetBindResult
//
//  Synopsis:   returns the protocol specific error
//
//  Arguments:  [pclsidProtocol] --
//              [pdwResult] --
//              [DWORD] --
//              [pdwReserved] --
//
//  Returns:
//
//  History:    4-16-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINet::GetBindResult(CLSID *pclsidProtocol, DWORD *pdwResult, LPWSTR *pszResult, DWORD *pdwReserved)
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINet::GetBindResult",
                "this=%#x, %#x, %#x, %#x, %#x",
                this, pclsidProtocol, pdwResult, pszResult, pdwReserved
                ));
                
    PerfDbgLog(tagCINet, this, "+CINet::GetBindResult");
    HRESULT hr = NOERROR;

    PProtAssert((pclsidProtocol && pdwResult && pszResult));

    *pclsidProtocol = _pclsidProtocol;
    *pdwResult = _dwResult;
    if (_pszResult)
    {
        // the client is supposted to free the string
        *pszResult = new WCHAR [strlen(_pszResult) + 1];
        if (*pszResult)
        {
            A2W(_pszResult, *pszResult, strlen(_pszResult));
        }
    }
    else
    {
        *pszResult = NULL;
    }

    PerfDbgLog2(tagCINet, this, "-CINet::GetBindResult (dwResult:%lx, szStr:%ws)", _dwResult, pszResult);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINet::OnRedirected
//
//  Synopsis:   Called on wininet worker thread when wininet does a redirect.
//              Sends notification to apartment thread.
//
//  Arguments:  [szNewUrl] --
//
//  Returns:
//
//  History:    4-17-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINet::OnRedirect(LPSTR szNewUrl)
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINet::OnRedirect",
                "this=%#x, %.80q",
                this, szNewUrl
                ));
                
    PerfDbgLog1(tagCINet, this, "+CINet::OnRedirect (szNewUrl:%s)",szNewUrl);
    HRESULT hr = NOERROR;

    PProtAssert((szNewUrl && "WinINet reports redirect with redirect URL"));

    if (szNewUrl)
    {
        _fRedirected = TRUE;
        ReportNotification(BINDSTATUS_REDIRECTING, szNewUrl);
    }

    LONG lThirdParty;
    if (IsThirdPartyUrl(szNewUrl))
    {
        lThirdParty = 1;
        //MessageBoxA( 0, szNewUrl, "redirect: THIRDPARTY!", 0 );
        InternetSetOption(_hRequest, INTERNET_OPTION_COOKIES_3RD_PARTY, &lThirdParty, sizeof(LONG));
    }
    else
    {
        lThirdParty = 0;
        //MessageBoxA( 0, szNewUrl, "redirect: NOT THIRDPARTY!", 0 );
        InternetSetOption(_hRequest, INTERNET_OPTION_COOKIES_3RD_PARTY, &lThirdParty, sizeof(LONG));
    }
    
    PerfDbgLog1(tagCINet, this, "-CINet::OnRedirect(hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   AppendToString
//
//  Synopsis:   Fast append of src to dest, reallocing of dest if necessary.
//
//
//  Arguments:  [IN/OUT] pszDest
//              [IN/OUT] pcbDest
//              [IN/OUT] pcbAlloced
//              [IN]     szSrc
//              [IN]     cbSrc
//
//  Returns:    TRUE/FALSE
//
//  History:    6-2-97   Adriaan Canter (AdriaanC)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL AppendToString(LPSTR* pszDest, LPDWORD pcbDest,
                    LPDWORD pcbAlloced, LPSTR szSrc, DWORD cbSrc)
{
    DEBUG_ENTER((DBG_APP,
                Bool,
                "AppendToString",
                "%#x, %#x, %#x, %.80q, %#x",
                pszDest, pcbDest, pcbAlloced, szSrc, cbSrc
                ));
                
    DWORD cbNew = *pcbDest + cbSrc;

    if (cbNew > *pcbAlloced)
    {
        DWORD cbNewAlloc  = *pcbAlloced + (cbSrc < MAX_PATH ? MAX_PATH : cbSrc);
        LPSTR szNew = (LPSTR) new CHAR[cbNewAlloc];
        if (!szNew)
        {

            DEBUG_LEAVE(FALSE);
            return FALSE;
        }
        memcpy(szNew, *pszDest, *pcbDest);
        delete [] *pszDest;
        *pszDest = szNew;
        *pcbAlloced = cbNewAlloc;
    }

     memcpy(*pszDest + *pcbDest, szSrc, cbSrc);
    *pcbDest = cbNew;

    DEBUG_LEAVE(TRUE);
    return TRUE;
}

#ifdef unix
#include <sys/utsname.h>
#endif /* unix */
//+---------------------------------------------------------------------------
//
//  Function:   GetUserAgentString
//
//  Synopsis:   Gets the user agent string from the registry. If entry is
//              the default string is returned.
//
//  Arguments:  (none)
//
//  Returns:    Allocated user agent string.
//
//  History:    5-13-96   JohannP (Johann Posch)   Created
//              6-02-97   AdriaanC (Adriaan Canter) Mods for mult reg entries.
//
//              6-25-97   AdriaanC (Adriaan Canter) Further mods described below.
//
//              12-18-98  Adriaanc (Adriaan Canter) - Versioned base values for
//                        IE5 and added a versioned IE5 location for token values
//                        which will get read in addition to common (IE4) location.
//
//  Notes:      User Agent string madness: We now generate the User Agent string
//              from diverse entries in the registry. We first scan HKCU for base
//              keys, falling back to HKLM if not found, or finally, defaults.
//              For Pre and Post platform we now pickup all entries in both HKCU
//              and HKLM. Finally, for back compatibility we enumerate a list of
//              tokens (such as MSN 2.0, MSN 2.1, etc) from UA Tokens in the HKLM
//              registry under Internet Settings, and if any of these tokens are
//              found in the *old* HKCU location User Agent String we insert them
//              into the pre platform portion of the generated user agent string.
//              This was specifically done for MSN which has been fixing up the old
//              registry location and depends on these tokens being found in the
//              User Agent string.
//
//----------------------------------------------------------------------------
LPCSTR GetUserAgentString()
{
    DEBUG_ENTER((DBG_APP,
                String,
                "GetUserAgentString",
                NULL
                ));
                
    // Reg keys.
    #define INTERNET_SETTINGS_KEY_SZ  "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Internet Settings"
    #define USER_AGENT_KEY_SZ         "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\User Agent"
    #define USER_AGENT_KEY5_SZ        "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\5.0\\User Agent"
    #define USER_AGENT_SZ             "User Agent"
    #define PRE_PLATFORM_KEY_SZ       "Pre Platform"
    #define POST_PLATFORM_KEY_SZ      "Post Platform"
    #define UA_TOKENS_KEY_SZ          "UA Tokens"

    // Base UA key strings.
    #define UA_KEY_SZ NULL
    #define COMPATIBLE_KEY_SZ   "Compatible"
    #define VERSION_KEY_SZ      "Version"
    #define PLATFORM_KEY_SZ     "Platform"

    // Base UA value strings.
    #define UA_VAL_SZ           "Mozilla/4.0"
    #define COMPATIBLE_VAL_SZ   "compatible"
    #define VERSION_VAL_SZ      "MSIE 6.0"

    // Their lengths.
    #define UA_VAL_LEN           (sizeof(UA_VAL_SZ) - 1)
    #define COMPATIBLE_VAL_LEN   (sizeof(COMPATIBLE_VAL_SZ) - 1)
    #define VERSION_VAL_LEN      (sizeof(VERSION_VAL_SZ) - 1)


    // If we encounter a failure in constructing the string, send this.
    #ifdef _WIN64
    #define DEFAULT_UA_STRING UA_VAL_SZ" ("COMPATIBLE_VAL_SZ"; "VERSION_VAL_SZ"; Win64)"
    #else
    #define DEFAULT_UA_STRING UA_VAL_SZ" ("COMPATIBLE_VAL_SZ"; "VERSION_VAL_SZ")"
    #endif

    // Used for backing up user agent string.
    #define IE4_UA_BACKUP_FLAG     "IE5_UA_Backup_Flag"
    #define BACKUP_USER_AGENT_SZ    "BackupUserAgent"

    #define COMPAT_MODE_TOKEN      "compat"
    #define NUM_UA_KEYS            4

    BOOL bSuccess = TRUE;
    INT i, nBaseKeys;
    DWORD dwIndex, dwType, cbBuf, cbUA, cbTotal;
    LPSTR szUA, szBuf, pszWinVer;
    OSVERSIONINFO osVersionInfo;

    // Reg handles.
    HKEY hHKCU_ISKey;
    HKEY hHKCU_UAKey;
    HKEY hHKLM_UAKey;
    HKEY hHKCU_UA5Key;
    HKEY hHKLM_UA5Key;
    HKEY hPreKey;
    HKEY hPostKey;
    HKEY hTokensKey;

    // Set all regkeys to invalid handle.
    hHKCU_ISKey = hHKLM_UAKey = hHKCU_UAKey = hHKLM_UA5Key = hHKCU_UA5Key
        = hPreKey = hPostKey = hTokensKey = (HKEY) INVALID_HANDLE_VALUE;

    // The UA keys are iterated in loops below; Keep an array
    // of pointers to the HKLMUA, HKCUUA, HKLMUA5 and HKCUUA5 locations
    // to use as alias in the loop. NOTE!! - Do not change the ordering.
    HKEY *phUAKeyArray[NUM_UA_KEYS];
    phUAKeyArray[0] = &hHKLM_UAKey;
    phUAKeyArray[1] = &hHKCU_UAKey;
    phUAKeyArray[2] = &hHKLM_UA5Key;
    phUAKeyArray[3] = &hHKCU_UA5Key;

    // Platform strings.
    LPSTR szWin32 = "Win32";
    LPSTR szWin95 = "Windows 95";
    LPSTR szWin98 = "Windows 98";
    LPSTR szMillennium = "Windows 98; Win 9x 4.90";
    LPSTR szWinNT = "Windows NT";
    //for WinNT appended with version numbers
    //Note: Limitation on total# of digits in Major+Minor versions=8.
    //length = sizeof("Windows NT"+" "+majorverstring+"."+minorverstring
    //Additional allowance is made for Win64 token. 
    #define WINNT_VERSION_STRING_MAX_LEN     32

    char szWinNTVer[WINNT_VERSION_STRING_MAX_LEN];

#ifdef unix
    CHAR szUnixPlatformName[SYS_NMLN*4+3+1]; // 4 substrings,3 spaces, 1 NULL
#endif /* unix */

    // Arrays of base keys, values and lengths.
    LPSTR szBaseKeys[] =   {UA_KEY_SZ,  COMPATIBLE_KEY_SZ,  VERSION_KEY_SZ};
    LPSTR szBaseValues[] = {UA_VAL_SZ,  COMPATIBLE_VAL_SZ,  VERSION_VAL_SZ};
    DWORD cbBaseValues[] = {UA_VAL_LEN, COMPATIBLE_VAL_LEN, VERSION_VAL_LEN};

    nBaseKeys = sizeof(szBaseKeys) / sizeof(LPSTR);

    cbUA = 0;
    cbTotal = cbBuf = MAX_PATH;
    szBuf = szUA = 0;

    // User agent string already exists.
    if (g_pszUserAgentString != NULL)
    {
        szUA = g_pszUserAgentString;
        goto End;
    }

    // Max size for any one field from registry is MAX_PATH.
    szUA = new CHAR[MAX_PATH];
    szBuf = new CHAR[MAX_PATH];
    if (!szUA || !szBuf)
    {
        bSuccess = FALSE;
        goto End;
    }

    // Open all 4 User Agent reg keys (HKLMUA, HKCUUA, HKLMUA5, HKCUUA5).
    if (RegOpenKeyEx(HKEY_CURRENT_USER, USER_AGENT_KEY_SZ, 0, KEY_QUERY_VALUE, &hHKCU_UAKey) != ERROR_SUCCESS)
        hHKCU_UAKey = (HKEY)INVALID_HANDLE_VALUE;

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, USER_AGENT_KEY_SZ, 0, KEY_QUERY_VALUE, &hHKLM_UAKey) != ERROR_SUCCESS)
        hHKLM_UAKey = (HKEY)INVALID_HANDLE_VALUE;

    if (RegOpenKeyEx(HKEY_CURRENT_USER, USER_AGENT_KEY5_SZ, 0, KEY_QUERY_VALUE, &hHKCU_UA5Key) != ERROR_SUCCESS)
        hHKCU_UA5Key = (HKEY)INVALID_HANDLE_VALUE;

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, USER_AGENT_KEY5_SZ, 0, KEY_QUERY_VALUE, &hHKLM_UA5Key) != ERROR_SUCCESS)
        hHKLM_UA5Key = (HKEY)INVALID_HANDLE_VALUE;

    // Get user agent, compatible and version strings from IE 5.0 location.
    // IE6 and on must revise this location.
    for (i = 0; i < nBaseKeys; i++)
    {
        if ((hHKCU_UA5Key != INVALID_HANDLE_VALUE) && RegQueryValueEx(hHKCU_UA5Key, szBaseKeys[i],
            NULL, &dwType, (LPBYTE) szBuf, &(cbBuf = MAX_PATH)) == ERROR_SUCCESS
            && cbBuf > 1)
        {
            // Got from HKCU registry.
            if (!(bSuccess = AppendToString(&szUA, &cbUA,
                &cbTotal, szBuf, cbBuf - 1)))
                goto End;
        }
        else if ((hHKLM_UA5Key != INVALID_HANDLE_VALUE) && RegQueryValueEx(hHKLM_UA5Key, szBaseKeys[i],
            NULL, &dwType, (LPBYTE) szBuf, &(cbBuf = MAX_PATH)) == ERROR_SUCCESS
            && cbBuf > 1)
        {
            // Got from HKLM registry.
            if (!(bSuccess = AppendToString(&szUA, &cbUA,
                &cbTotal, szBuf, cbBuf - 1)))
                goto End;
        }
        else
        {
            // Got from defaults.
            if (!(bSuccess = AppendToString(&szUA, &cbUA, &cbTotal,
                szBaseValues[i], cbBaseValues[i])))
                goto End;
        }

        // Formating.
        if (!(bSuccess = AppendToString(&szUA, &cbUA,
            &cbTotal, (i == 0 ? " (" : "; "), 2)))
            goto End;
    }

    // Leave the four UA keys open; Proceed to open HKLM tokens key to scan
    // to scan and open Internet Settings HKCU key to read legacy UA string.

    // Tokens to scan for from the old registry location to include
    // in the user agent string: These are enumerated from UA Tokens,
    // scanned for in the old location and added to the pre platform.
    if (hHKLM_UAKey != INVALID_HANDLE_VALUE)
        RegOpenKeyEx(hHKLM_UAKey, UA_TOKENS_KEY_SZ, 0, KEY_QUERY_VALUE, &hTokensKey);

    if (hTokensKey != INVALID_HANDLE_VALUE)
    {
        CHAR szOldUserAgentString[MAX_PATH];

        // Read in the old user agent string from HKCU
        RegOpenKeyEx(HKEY_CURRENT_USER, INTERNET_SETTINGS_KEY_SZ, 0, KEY_QUERY_VALUE, &hHKCU_ISKey);

        if ((hHKCU_ISKey != INVALID_HANDLE_VALUE) && RegQueryValueEx(hHKCU_ISKey, USER_AGENT_SZ,
            NULL, &dwType, (LPBYTE) szOldUserAgentString, &(cbBuf = MAX_PATH)) == ERROR_SUCCESS
            && cbBuf > 1)
        {
            // Close the HKCU Internet Settings key.
            RegCloseKey(hHKCU_ISKey);
            hHKCU_ISKey = (HKEY) INVALID_HANDLE_VALUE;

            // Got old user agent string from HKCU registry. Enumerate the values in UA Tokens
            // and see if any exist in the old string and if so, add them to the current string.
            dwIndex = 0;
#ifndef unix
            while (RegEnumValue(hTokensKey, dwIndex++, szBuf, &(cbBuf = MAX_PATH - 4),  /* sizeof(' ' + "; ") */
                    NULL, NULL, NULL, NULL) == ERROR_SUCCESS)
            {
                // eg; find a token enumerated from UA Tokens
                // Mozilla/4.0 (compatible; MSIE 4.0b2; MSN2.5; Windows NT)
                //                                     ^
                //                                     szBuf
                if (cbBuf)
                {
                    // Fix up token to include leading
                    // space and trailing semi-colon before strstr.
                    CHAR szToken[MAX_PATH];
                    szToken[0] = ' ';
                    memcpy(szToken+1, szBuf, cbBuf);
                    memcpy(szToken + 1 + cbBuf, "; ", sizeof("; "));

                    // Found a match - insert this token into user agent string.
                    if (strstr(szOldUserAgentString, szToken))
                    {
                        if (!(bSuccess = AppendToString(&szUA, &cbUA, &cbTotal, szBuf, cbBuf)))
                            goto End;

                        if (!(bSuccess = AppendToString(&szUA, &cbUA, &cbTotal, "; ", 2)))
                            goto End;
                    }
                }
            }
#endif /* !unix */
        }

        RegCloseKey(hTokensKey);
        hTokensKey = (HKEY) INVALID_HANDLE_VALUE;
    }


    // Pre platform strings - get from HKCUUA, HKLMUA,
    // HKLMUA5 and HKCUUA5 locations. These are additive;
    // order is not important.
    for (i = 0; i < NUM_UA_KEYS; i++)
    {
        if (*(phUAKeyArray[i]) == INVALID_HANDLE_VALUE)
            continue;

        RegOpenKeyEx(*(phUAKeyArray[i]),
            PRE_PLATFORM_KEY_SZ, 0, KEY_QUERY_VALUE, &hPreKey);

        if (hPreKey != INVALID_HANDLE_VALUE)
        {
            dwIndex = 0;
            while (RegEnumValue(hPreKey, dwIndex++, szBuf, &(cbBuf = MAX_PATH),
                                NULL, NULL, NULL, NULL) == ERROR_SUCCESS)
            {
                if (cbBuf)
                {
                    // Got from registry and non null.
                    if (!(bSuccess = AppendToString(&szUA, &cbUA, &cbTotal, szBuf, cbBuf)))
                        goto End;
                    if (!(bSuccess = AppendToString(&szUA, &cbUA, &cbTotal, "; ", 2)))
                        goto End;
                }
                cbBuf = MAX_PATH;
            }

            // Close pre platform key; User agent keys still open.
            RegCloseKey(hPreKey);
            hPreKey = (HKEY) INVALID_HANDLE_VALUE;
        }
    }


    // Platform string. This is read from the IE 5.0 location only. IE6 and later
    // must revise this. If no platform value read from registry, get from OS.
    if (hHKCU_UA5Key != INVALID_HANDLE_VALUE && RegQueryValueEx(hHKCU_UA5Key, PLATFORM_KEY_SZ,
        NULL, &dwType, (LPBYTE) szBuf, &(cbBuf = MAX_PATH)) == ERROR_SUCCESS)
    {
        // Got from HKCU.
        if (!(bSuccess = AppendToString(&szUA, &cbUA, &cbTotal, szBuf, cbBuf -1)))
            goto End;
    }
    else if (hHKLM_UA5Key != INVALID_HANDLE_VALUE && RegQueryValueEx(hHKLM_UA5Key, PLATFORM_KEY_SZ,
             NULL, &dwType, (LPBYTE) szBuf, &(cbBuf = MAX_PATH)) == ERROR_SUCCESS)
    {
        // Got from HKLM
        if (!(bSuccess = AppendToString(&szUA, &cbUA, &cbTotal, szBuf, cbBuf -1)))
            goto End;
    }
    else
    {
        // Couldn't get User Agent value from registry.
        // Set the default value.
        osVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
        if (GetVersionEx(&osVersionInfo))
        {
#ifndef unix
            // Platform ID is either Win95 or WinNT.
            if(VER_PLATFORM_WIN32_NT == osVersionInfo.dwPlatformId)
            {
                Assert(osVersionInfo.dwMajorVersion < 10000 &&
                       osVersionInfo.dwMinorVersion < 10000);
                /* Check for WIN64, adding another token if necessary */
                LPSTR szWin64Token = "; Win64";
                LPSTR szWow64Token = "; WOW64";

                SYSTEM_INFO SysInfo;

                GetSystemInfo(&SysInfo);
                bool fWin64 = ((SysInfo.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_AMD64) ||
                               (SysInfo.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_IA64));
                bool fWow64 = FALSE;

                // There is no easy way to determine whether a 32-bit app is running on a 32-bit OS
                // or Wow64.  The recommended approach (Q275217) to determine this is to see if
                // GetSystemWow64DirectoryA is implemented in kernel32.dll and to see if the function
                // succeeds.  If it succeeds, then we're running on a 64-bit processor.
                if (!fWin64 && SysInfo.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_INTEL)
                {
                    char directoryPath[MAX_PATH];
                    HMODULE hModule;
                    GetSystemWow64DirectoryPtr func;

                    hModule = GetModuleHandle("kernel32.dll");
                    func = (GetSystemWow64DirectoryPtr) GetProcAddress(hModule, "GetSystemWow64DirectoryA");
                    if (func && func(directoryPath, sizeof(directoryPath)))
                    {
                        fWow64 = TRUE;
                    }
                }

                LPSTR sz64Str = NULL;
                if( fWin64)
                    sz64Str = szWin64Token;
                else if( fWow64)
                    sz64Str = szWow64Token;
                else
                    sz64Str = "";

                memset(szWinNTVer, 0, WINNT_VERSION_STRING_MAX_LEN);
                wsprintfA(szWinNTVer, 
                          "%s %u.%u%s",
                          szWinNT,
                          osVersionInfo.dwMajorVersion,
                          osVersionInfo.dwMinorVersion,
                          sz64Str);

                pszWinVer = szWinNTVer;
            }
            else
            {
                if(osVersionInfo.dwMinorVersion >= 10)
                {
                    if(osVersionInfo.dwMinorVersion >= 90)
                    {
                        // Millennium
                        pszWinVer = szMillennium;
                    }
                    else
                    {
                        // Win98
                        pszWinVer = szWin98;
                    }
                }
                else
                {
                    // Win95
                    pszWinVer = szWin95;
                }
            }
#else
            struct utsname uName;
            if(uname(&uName) > -1)
            {
                strcpy(szUnixPlatformName,uName.sysname);
                strcat(szUnixPlatformName," ");
                strcat(szUnixPlatformName,uName.release);
                strcat(szUnixPlatformName," ");
                strcat(szUnixPlatformName,uName.machine);
                strcat(szUnixPlatformName,"; X11");
                pszWinVer = &szUnixPlatformName[0];
            }
            else
                pszWinVer = "Generic Unix";
#endif /* unix */
        }
        else
        {
            // GetVersionEx failed! - set Platform to Win32.
            pszWinVer = szWin32;
        }
        if (!(bSuccess = AppendToString(&szUA, &cbUA, &cbTotal,
            pszWinVer, strlen(pszWinVer))))
            goto End;
    }

    // Post platform strings - get from HKCUUA, HKLMUA,
    // HKLMUA5 and HKCUUA5 locations. These are additive;
    // order is not important. Special case the IE4
    // compat token. IE6 and later must do this also.
    for (i = 0; i < NUM_UA_KEYS; i++)
    {
        if (*(phUAKeyArray[i]) == INVALID_HANDLE_VALUE)
            continue;

        RegOpenKeyEx(*(phUAKeyArray[i]),
            POST_PLATFORM_KEY_SZ, 0, KEY_QUERY_VALUE, &hPostKey);

        if (hPostKey != INVALID_HANDLE_VALUE)
        {
            dwIndex = 0;
            while (RegEnumValue(hPostKey, dwIndex++, szBuf, &(cbBuf = MAX_PATH),
                            NULL, NULL, NULL, NULL) == ERROR_SUCCESS)
            {
                // We need to special case the IE4 compat mode token in the
                // first two keys in phUAKeyArray[];
                if (cbBuf && ((i > 1) || strcmp(szBuf, COMPAT_MODE_TOKEN)))
                {
                    // Got from registry and non null.
                    if (!(bSuccess = AppendToString(&szUA, &cbUA, &cbTotal, "; ", 2)))
                        goto End;
                    if (!(bSuccess = AppendToString(&szUA, &cbUA, &cbTotal, szBuf, cbBuf)))
                        goto End;
                }
                cbBuf = MAX_PATH;
            }

            // Close post platform key; User agent keys still open.
            RegCloseKey(hPostKey);
            hPostKey = (HKEY) INVALID_HANDLE_VALUE;
        }
    }
    // Terminate with ")\0"
    if (!(bSuccess = AppendToString(&szUA, &cbUA, &cbTotal, ")", 2)))
        goto End;

    for (i = 0; i < NUM_UA_KEYS; i++)
    {
        if (*(phUAKeyArray[i]) != INVALID_HANDLE_VALUE)
        {
            RegCloseKey(*(phUAKeyArray[i]));
            *(phUAKeyArray[i]) = (HKEY) INVALID_HANDLE_VALUE;
        }
    }

    // Finally, write out the generated user agent string in the old location.
    if (bSuccess)
    {
        // Remember the computed user agent string for later.
        g_pszUserAgentString = szUA;
    }

End:

    // Cleanup.

    delete [] szBuf;

    if (!bSuccess)
    {
        delete [] szUA;

        DEBUG_LEAVE(DEFAULT_UA_STRING);
        return DEFAULT_UA_STRING;
    }

    DEBUG_LEAVE(szUA);
    return szUA;
}


//+---------------------------------------------------------------------------
//
//  Method:     ObtainUserAgentString
//
//  Synopsis:
//
//  Returns:
//
//  History:   08-07-1997   DanpoZ (Danpo Zhang) Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI ObtainUserAgentString(DWORD dwOption, LPSTR pszUAOut, DWORD *cbSize )
{
    DEBUG_ENTER_API((DBG_API,
                    Hresult,
                    "ObtainUserAgentString",
                    "%#x, %#x, %#x",
                    dwOption, pszUAOut, cbSize
                    ));
                
    // since GetUserAgentString may change some global variable,
    // this API needs to add a global mutex to protect them
    CLock lck(g_mxsSession);

    HRESULT hr = NOERROR;
    if( pszUAOut && cbSize )
    {
        LPSTR   pcszUA = (LPSTR)GetUserAgentString();
        DWORD   cbLen = strlen(pcszUA);

        if( *cbSize <= cbLen )
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            strcpy(pszUAOut, pcszUA);
        }
        *cbSize = cbLen + 1;

    }
    else
    {
        hr = E_INVALIDARG;
    }

    DEBUG_LEAVE_API(hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CINet::InternetAuthNotifyCallback
//
//  Synopsis:
//
//  Arguments:  [dwContext] --
//              [dwAction] --
//              [lpReserved] --
//
//  Returns:
//
//  History:    10-10-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD CALLBACK CINet::InternetAuthNotifyCallback(DWORD_PTR dwContext, DWORD dwAction, LPVOID lpReserved)
{
    DEBUG_ENTER((DBG_APP,
                Dword,
                "CINet::InternetAuthNotifyCallback",
                "%#x, %#x, %#x",
                dwContext, dwAction, lpReserved
                ));
                
    // If this is a request, then we know the cookie type
    CINet *pCINet = (CINet *) dwContext;
    PerfDbgLog2(tagCINet, pCINet, "+CINet::InternetAuthNotifyCallback Action:%ld, State:%ld",
        dwAction, pCINet->_INState);

    PProtAssert((lpReserved == NULL));

    DWORD dwRes = ERROR_SUCCESS;

    switch (dwAction)
    {
    case ERROR_SUCCESS  :
        // should never be returned here
        PProtAssert((FALSE));

    case ERROR_CANCELLED :
        // NOTE: succes and cancel means display the content according to ArthurBi
        // continue reading data and show the 401 contained
        pCINet->_hrINet = NOERROR;
        // Why do we inc the count here??
        pCINet->_fProxyAuth ? pCINet->_cbProxyAuthenticate++ : pCINet->_cbAuthenticate++;
        break;

    case ERROR_INTERNET_RETRY_DIALOG:
        pCINet->_hrINet = INET_E_AUTHENTICATION_REQUIRED;
        break;

    case ERROR_INTERNET_FORCE_RETRY :
        pCINet->_hrINet = RPC_E_RETRY;
        pCINet->_fProxyAuth ? pCINet->_cbProxyAuthenticate++ : pCINet->_cbAuthenticate++;
        break;

    default:
        pCINet->_hrINet = E_ACCESSDENIED;
        break;
    }

    pCINet->OnINetAuthenticate(dwAction);

    PerfDbgLog2(tagCINet, pCINet, "-CINet::InternetAuthNotifyCallback (pCINet->_hrINet:%lx, dwResult:%lx)", pCINet->_hrINet,dwRes);

    DEBUG_LEAVE(dwRes);
    return dwRes;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINet::OnINetAuthenticate
//
//  Synopsis:
//
//  Arguments:  [dwResult] --
//
//  Returns:
//
//  History:    10-10-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINet::OnINetAuthenticate(DWORD dwResult)
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINet::OnINetAuthenticate",
                "this=%#x, %#x",
                this, dwResult
                ));
                
    PerfDbgLog(tagCINet, this, "+CINet::OnINetAuthenticate");
    HRESULT hr = NOERROR;

    PProtAssert((GetStatePending() == E_PENDING));
    // set state to normal - no pending transaction
    SetStatePending(NOERROR);
    PProtAssert((_INState == INetState_AUTHENTICATE));

    if (dwResult)
    {
        TransitState(INetState_AUTHENTICATE, TRUE);
    }

    PerfDbgLog1(tagCINet, this, "-CINet::OnINetAuthenticate (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINet::INetAuthenticate
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    10-10-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINet::INetAuthenticate()
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINet::INetAuthenticate",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCINet, this, "+CINet::INetAuthenticate");
    PProtAssert((GetStatePending() == NOERROR));

    HRESULT hr = NOERROR;
    DWORD dwOperation;

    PProtAssert((GetStatePending() == NOERROR));


    if (_hrINet == INET_E_AUTHENTICATION_REQUIRED)
    {
        // bring up the internet errro dialog
        hr = AuthenticationRequest();

        if ((hr != NOERROR) && (hr != E_PENDING))
        {
            _hrError = INET_E_AUTHENTICATION_REQUIRED;
        }
        else
        {
            _hrError = INET_E_OK;
        }

    }

    if (hr == NOERROR)
    {
        if (_hrINet == RPC_E_RETRY)
        {
            // retry the send/request
            _hrINet = NOERROR;
            _fCompleted = FALSE;
            _fSendAgain = TRUE;
            hr = INetAsyncSendRequest();
        }
        else if (_hrINet == NOERROR)
        {
            hr = QueryStatusOnResponseDefault(0);
            if( hr == NOERROR )
            {
                hr = QueryHeaderOnResponse();
                if (hr == NOERROR)
                {
                    // read more data from wininet
                    hr = INetRead();
                }
            }
        }
        else
        {
            // this will report the hresult return from the dialog
            hr = _hrINet;
        }
    }

    PerfDbgLog1(tagCINet, this, "-CINet::INetAuthenticate (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINet::INetResumeAsyncRequest
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    1-27-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINet::INetResumeAsyncRequest(DWORD dwResultCode)
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINet::INetResumeAsyncRequest",
                "this=%#x, %#x",
                this, dwResultCode
                ));
                
    PerfDbgLog(tagCINet, this, "+CINet::INetResumeAsyncRequest");

    HRESULT hr = NOERROR;
    BOOL fRestarted;
    BOOL fRet;
    PProtAssert((GetStatePending() == NOERROR));

    SetINetState(INetState_SEND_REQUEST);
    {
        SetStatePending(E_PENDING);

        fRet = ResumeSuspendedDownload(_hRequest,
                        dwResultCode
                        );

        if (fRet == FALSE)
        {
            dwLstError = GetLastError();
            if (dwLstError == ERROR_IO_PENDING)
            {
                // wait async for the handle
                hr = E_PENDING;
            }
            else
            {
                SetStatePending(NOERROR);
                hr = _hrError = INET_E_DOWNLOAD_FAILURE;
                SetBindResult(dwLstError,hr);
                PerfDbgLog3(tagCINet, this, "CINet::INetResumeAsyncRequest (fRet:%d, _hrError:%lx, LstError:%ld)", fRet, _hrError, dwLstError);
            }
        }
        else
        {
            SetStatePending(NOERROR);
        }
    }

    if (_hrError != INET_E_OK)
    {
        // we need to terminate here
        ReportResultAndStop(hr);
    }

    PerfDbgLog1(tagCINet, this, "-CINet::INetResumeAsyncRequest (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CINet::INetDisplayUI
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    10-10-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINet::INetDisplayUI()
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINet::INetDisplayUI",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCINet, this, "+CINet::INetDisplayUI");
    PProtAssert((GetStatePending() == NOERROR));

    HRESULT hr = NOERROR;
    DWORD dwOperation;
    DWORD dwResultCode = ERROR_SUCCESS;

    PProtAssert((GetStatePending() == NOERROR));
    DWORD  dwBindF = GetBindFlags();


    if (_hrINet == INET_E_AUTHENTICATION_REQUIRED)
    {
        HWND hwnd = 0;
        hr = NOERROR;
        // Get a window handle. QueryService on IWindowForBindingUI
        // to get a window object first if necessary.
        if (_pWindow == NULL)
        {
            hr = QueryService(IID_IWindowForBindingUI, (void **) &_pWindow);
        }
        // If we don't already have a window handle, get one from the interface.
        if (!hwnd && _pWindow)
        {
            hr = _pWindow->GetWindow(IID_IHttpSecurity, &hwnd);
            PProtAssert((   (hr == S_FALSE) && (hwnd == NULL)
                         || (hr == S_OK) && (hwnd != NULL)));
        }

        if (hwnd && (hr == S_OK))
        {
            DWORD dwFlags = FLAGS_ERROR_UI_SERIALIZE_DIALOGS;
            if ((dwBindF & BINDF_NO_UI) || (dwBindF & BINDF_SILENTOPERATION))
            {
                dwFlags |= FLAGS_ERROR_UI_FLAGS_NO_UI;
            }

            dwResultCode =
                InternetErrorDlg( hwnd, _hRequest, _dwSendRequestResult, dwFlags, &_lpvExtraSendRequestResult);


            if ( dwResultCode == ERROR_CANCELLED || dwResultCode == ERROR_SUCCESS )
            {
                // hack-hack alert, if _lpvExtraSendRequestResult non-null we change behavior
                if ( !(dwResultCode == ERROR_SUCCESS && _lpvExtraSendRequestResult != NULL) )
                {
                    dwResultCode = ERROR_INTERNET_OPERATION_CANCELLED;
                }
            }

            _hrINet = RPC_E_RETRY;
            hr = NOERROR;
        }
        else if (_dwSendRequestResult == ERROR_HTTP_COOKIE_NEEDS_CONFIRMATION ||
                 _dwSendRequestResult == ERROR_HTTP_COOKIE_NEEDS_CONFIRMATION_EX)
        {
            //fix to prevent heap trashing in wininet.b#86959
            dwResultCode = ERROR_HTTP_COOKIE_DECLINED;
            _hrINet = RPC_E_RETRY;
            hr = NOERROR;
        }

        if ((hr != NOERROR) && (hr != E_PENDING))
        {
            _hrError = INET_E_AUTHENTICATION_REQUIRED;
        }
        else
        {
            _hrError = INET_E_OK;
        }
    }

    if (hr == NOERROR)
    {
        if (_hrINet == RPC_E_RETRY)
        {
            // retry the send/request
            _hrINet = NOERROR;

            // hack-arama around to allow CD-ROM dialog to still work
            if ( _dwSendRequestResult == ERROR_INTERNET_INSERT_CDROM )
            {
                hr = INetAsyncSendRequest();
            }
            else
            {
                hr = INetResumeAsyncRequest(dwResultCode);
            }
        }
        else
        {
            // this will report the hresult return from the dialog
            hr = _hrINet;
        }
    }

    PerfDbgLog1(tagCINet, this, "-CINet::INetDisplayUI (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CINet::INetSeek
//
//  Synopsis:
//
//  Arguments:  [DWORD] --
//              [ULARGE_INTEGER] --
//              [plibNewPosition] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINet::INetSeek(LARGE_INTEGER dlibMove,DWORD dwOrigin,ULARGE_INTEGER *plibNewPosition)
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINet::INetSeek",
                "this=%#x, %#x, %#x, %#x",
                this, dlibMove, dwOrigin, plibNewPosition
                ));
                
    PerfDbgLog(tagCINet, this, "+CINet::INetSeek");
    HRESULT hr = E_FAIL;

    // each protocol has to overwrite this method if
    // seek is supported

    DWORD dwResult = InternetSetFilePointer(
                                      _hRequest
                                     ,dlibMove.LowPart
                                     ,0
                                     ,dwOrigin
                                     ,0
                                     );

    PerfDbgLog1(tagCINet, this, "-CINet::INetSeek (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINet::IsUpLoad
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    4-28-1997   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL CINet::IsUpLoad()
{
    DEBUG_ENTER((DBG_APP,
                Bool,
                "CINet::IsUpLoad",
                "this=%#x",
                this
                ));
                
    BINDINFO *pBndInfo = GetBindInfo();
    BOOL fRet = (   (pBndInfo->dwBindVerb != BINDVERB_GET)
            && (pBndInfo->stgmedData.tymed == TYMED_ISTREAM)
            && !_fCompleted
            && !_fRedirected);

    DEBUG_LEAVE(fRet);
    return fRet;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINet::CPrivUnknown::QueryInterface
//
//  Synopsis:
//
//  Arguments:  [riid] --
//              [ppvObj] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CINet::CPrivUnknown::QueryInterface(REFIID riid, void **ppvObj)
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINet::CPrivUnknown::IUnknown::QueryInterface",
                "this=%#x, %#x, %#x",
                this, &riid, ppvObj
                ));
                
    VDATEPTROUT(ppvObj, void *);
    VDATETHIS(this);
    HRESULT hr = NOERROR;

    PerfDbgLog(tagCINet, this, "+CINet::CPrivUnknown::QueryInterface");
    CINet *pCINet = GETPPARENT(this, CINet, _Unknown);

    *ppvObj = NULL;

    if ((riid == IID_IUnknown) || (riid == IID_IOInetProtocol) || (riid == IID_IOInetProtocolRoot) )
    {
        *ppvObj = (IOInetProtocol *) pCINet;
        pCINet->AddRef();
    }
    else if ( ( IsEqualIID(riid, IID_IWinInetInfo)||
                IsEqualIID(riid, IID_IWinInetHttpInfo) ) &&
              ( !IsEqualIID(CLSID_FileProtocol, pCINet->_pclsidProtocol) ) )

    {
        *ppvObj = (void FAR *) (IWinInetHttpInfo *)pCINet;
        pCINet->AddRef();
    }
    else if (riid == IID_IOInetThreadSwitch)
    {
        *ppvObj = (IOInetThreadSwitch *)pCINet;
        pCINet->AddRef();
    }
    else
    {
        hr = E_NOINTERFACE;
    }

    PerfDbgLog1(tagCINet, this, "-CINet::CPrivUnknown::QueryInterface (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   CINet::CPrivUnknown::AddRef
//
//  Synopsis:
//
//  Arguments:  [ULONG] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CINet::CPrivUnknown::AddRef(void)
{
    DEBUG_ENTER((DBG_APP,
                Dword,
                "CINet::CPrivUnknown::IUnknown::AddRef",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCINet, this, "+CINet::CPrivUnknown::AddRef");

    LONG lRet = ++_CRefs;

    PerfDbgLog1(tagCINet, this, "-CINet::CPrivUnknown::AddRef (cRefs:%ld)", lRet);

    DEBUG_LEAVE(lRet);
    return lRet;
}
//+---------------------------------------------------------------------------
//
//  Function:   CINet::Release
//
//  Synopsis:
//
//  Arguments:  [ULONG] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CINet::CPrivUnknown::Release(void)
{
    DEBUG_ENTER((DBG_APP,
                Dword,
                "CINet::CPrivUnknown::IUnknown::Release",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCINet, this, "+CINet::CPrivUnknown::Release");

    CINet *pCINet = GETPPARENT(this, CINet, _Unknown);

    LONG lRet = --_CRefs;

    if (lRet == 0)
    {
        delete pCINet;
    }

    PerfDbgLog1(tagCINet, this, "-CINet::CPrivUnknown::Release (cRefs:%ld)", lRet);

    DEBUG_LEAVE(lRet);
    return lRet;
}


//+---------------------------------------------------------------------------
//
//  Method:     CINet::OnINetReadDirect
//
//  Synopsis:
//
//  Arguments:  [dwResult] --
//
//  Returns:
//
//  History:    4-28-1997   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINet::OnINetReadDirect(DWORD dwResult)
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINet::OnINetReadDirect",
                "this=%#x, %#x",
                this, dwResult
                ));
                
    PerfDbgLog(tagCINet, this, "+CINet::OnINetReadDirect");
    HRESULT hr = NOERROR;

    PProtAssert((GetStatePending() == E_PENDING));
    // set state to normal - no pending transaction
    SetStatePending(NOERROR);

    if (OperationOnAparmentThread(INetState_SEND_REQUEST))
    {
        TransitState(INetState_READ_DIRECT);
    }
    else
    {
        hr = INetReadDirect();
    }

    PerfDbgLog1(tagCINet, this, "-CINet::OnINetReadDirect (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINet::INetReadDirect
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    4-28-1997   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINet::INetReadDirect()
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINet::INetReadDirect",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCINet, this, "+CINet::INetReadDirect");
    HRESULT hr = NOERROR;
    DWORD dwError;
    ULONG cbBytesAvailable = 1;
    ULONG cbBytesReport = 0;
    SetINetState(INetState_READ_DIRECT);

    //BUGBUG: we hit this assertion sometimes.
    //PProtAssert((GetStatePending() == NOERROR));

    _hrError = INET_E_OK;

    if (!_fFilenameReported)
    {
        char szFilename[MAX_PATH];

        HRESULT hr1 = GetUrlCacheFilename(szFilename, MAX_PATH);

        if (hr1 == NOERROR && szFilename[0] != '\0')
        {
            ReportNotification(BINDSTATUS_CACHEFILENAMEAVAILABLE, (LPSTR) szFilename);
            _fFilenameReported = TRUE;
        }
    }

    if ((GetStatePending() == E_PENDING))
    {
        // nothing to do - data for this notfication
        // already received
        DbgLog(tagCINetErr, this, "CINet::INetReadDirect E_PENIDNG");

    }
    else
    {
        if (   _fDone
            || (   _cbTotalBytesRead
                  && _cbDataSize
                  && (_cbTotalBytesRead == _cbDataSize)))
        {

            _hrError = INET_E_DONE;
            _pEmbdFilter->ReportData(_bscf, cbBytesAvailable, _cbDataSize);
            ReportResultAndStop(NOERROR, _cbTotalBytesRead, _cbDataSize);
            hr = NOERROR;
        }
        else
        {

            if (_bscf & BSCF_DATAFULLYAVAILABLE)
            {
                _bscf |= BSCF_LASTDATANOTIFICATION;
                _bscf &= ~BSCF_FIRSTDATANOTIFICATION;
                cbBytesReport = cbBytesAvailable + _cbTotalBytesRead;
                if (IsEmbdFilterOk() )
                {
                    _pEmbdFilter->ReportData(_bscf, cbBytesReport, _cbDataSize);
                }
                ReportResultAndStop(NOERROR, cbBytesReport, _cbDataSize);
            }
            else
            {
                _bscf |= BSCF_AVAILABLEDATASIZEUNKNOWN;
                cbBytesReport = cbBytesAvailable + _cbTotalBytesRead;
                if (_pCTrans && IsEmbdFilterOk() )
                {
                    _cbSizeLastReportData = cbBytesReport;
                    hr = _pEmbdFilter->ReportData(_bscf, cbBytesReport, _cbDataSize);
                }
            }

            if (_bscf & BSCF_FIRSTDATANOTIFICATION)
            {
                _bscf &= ~BSCF_FIRSTDATANOTIFICATION;
                _bscf |= BSCF_INTERMEDIATEDATANOTIFICATION;
            }
        }
    }

    PerfDbgLog2(tagCINet, this, "-CINet::INetReadDirect (_hrError:%lx, hr:%lx)", _hrError, hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINet::ReadDirect
//
//  Synopsis:
//
//  Arguments:  [pBuffer] --
//              [cbBytes] --
//              [pcbBytes] --
//
//  Returns:
//
//  History:    4-28-1997   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINet::ReadDirect(BYTE *pBuffer, DWORD cbBytes, DWORD *pcbBytes)
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINet::ReadDirect",
                "this=%#x, %#x, %#x, %#x",
                this, pBuffer, cbBytes, pcbBytes
                ));
                
    PerfDbgLog(tagCINet, this, "+CINet::ReadDirect");
    HRESULT hr = NOERROR;
    DWORD dwError;

    *pcbBytes = 0;
    ULONG dwReturned = 0;

    //BUGBUG: turn this assertion on again
    //PProtAssert((GetStatePending() == NOERROR));

    if (_hrError == INET_E_DONE)
    {
        // means end of file
        hr = S_FALSE;
    }
    else if (GetStatePending() != NOERROR)
    {
        hr = E_PENDING;
    }
    else
    {
        _hrError = INET_E_OK;
        PProtAssert(((pBuffer != NULL) && (cbBytes > 0)));
        //PerfDbgLog1(tagCINet, this, "CINet::ReadDirect -> InternetReadFile (dwBytesLeft:%ld)", dwBytesLeft);

        LPINTERNET_BUFFERSA pIB = &_inetBufferSend;
        pIB->dwStructSize = sizeof (INTERNET_BUFFERSA);
        pIB->Next = 0;
        pIB->lpcszHeader = 0;
        pIB->dwHeadersLength = 0;
        pIB->dwHeadersTotal = 0;
        pIB->lpvBuffer = pBuffer;
        pIB->dwBufferLength = cbBytes;
        pIB->dwBufferTotal = 0;
        pIB->dwOffsetLow = 0;
        pIB->dwOffsetHigh = 0;


        dwReturned = 0;
        PProtAssert((GetStatePending() == NOERROR));
        SetStatePending(E_PENDING);

        if (!InternetReadFileExA(
                             _hRequest       //IN HINTERNET hFile,
                            ,pIB             // OUT LPINTERNET_BUFFERSA lpBuffersOut,
                            ,IRF_NO_WAIT     //    IN DWORD dwFlags,
                            ,0               //    IN DWORD dwContext
                            ))
        {
            //
            // async completion
            //
            dwError = GetLastError();
            if (dwError != ERROR_IO_PENDING)
            {
                hr = _hrError = INET_E_DOWNLOAD_FAILURE;
                DbgLog3(tagCINetErr, this, "CINet::ReadDirect failed: (dwError:%lx, hr:%lx, hrError:%lx)",
                                            dwError, hr, _hrError);
            }
            else
            {
                hr = E_PENDING;
            }
        }
        else
        {
            //
            // sync completion
            //
            SetStatePending(NOERROR);
            //
            dwReturned = pIB->dwBufferLength;
            _cbTotalBytesRead += dwReturned;
            *pcbBytes = dwReturned;

            PerfDbgLog3(tagCINet, this, "CINet::ReadDirect == InternetReadFileEx ==> (cbBytes:%ld, dwReturned:%ld,_cbTotalBytesRead:%ld)",
                cbBytes, dwReturned,_cbTotalBytesRead);


            if (dwReturned == 0)
            {
                // eof
                hr = _hrError = INET_E_DONE;
                //TransDebugOut((DEB_TRACE, "%p _IN CINetStream::INetSeek\n", this));
                PProtAssert(( (   (_cbDataSize && (_cbDataSize == _cbTotalBytesRead))
                               || (!_cbDataSize)) &&  "WinInet returned incorrent amount of data!!" ));
            }
            else
            {
                hr = NOERROR;
            }

        }  // read case - bits available

        *pcbBytes = dwReturned;

        if (hr == INET_E_DONE)
        {
            hr = (dwReturned) ? S_OK : S_FALSE;
        }
    }

    // Note: stop the download in case of DONE or ERROR!
    if (_hrError != INET_E_OK)
    {
        ReportResultAndStop((hr == S_FALSE) ? NOERROR : hr);
    }

    PerfDbgLog4(tagCINet, this, "-CINet::ReadDirect (_hrError:%lx, [hr:%lx,cbBytesAsked:%ld,cbBytesReturned:%ld])",
        _hrError, hr, cbBytes, *pcbBytes);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINet::GetUserAgentString
//
//  Synopsis:
//
//  Arguments:  [pBuffer] --
//              [cbBytes] --
//              [pcbBytes] --
//
//  Returns:
//
//  History:    4-28-1997   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
LPSTR CINet::GetUserAgentString()
{
    DEBUG_ENTER((DBG_APP,
                String,
                "CINet::GetUserAgentString",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCINet, this, "+CINet::GetUserAgentString");
    HRESULT hr = NOERROR;
    ULONG ulCount = 0;
    LPWSTR pwzStr = 0;
    LPSTR pszStr = 0;


    hr = _pOIBindInfo->GetBindString(BINDSTRING_USER_AGENT, (LPWSTR *)&pwzStr, 1, &ulCount);

    if ((hr == NOERROR) && ulCount)
    {
        PProtAssert((pwzStr));
        delete _pszUserAgentStr;
        pszStr = _pszUserAgentStr  = DupW2A(pwzStr);
    }
    else
    {
        pszStr = (LPSTR)::GetUserAgentString();
    }


    PerfDbgLog1(tagCINet, this, "-CINet::GetUserAgentString (pszStr:%s)", pszStr);

    DEBUG_LEAVE(pszStr);
    return pszStr;
}


BOOL GlobalUTF8Enabled()
{
    DEBUG_ENTER((DBG_APP,
                Bool,
                "GlobalUTF8Enabled",
                NULL
                ));
                
    // read the IE5 B2 global reg key
    DWORD dwErr = ERROR_SUCCESS;
    BOOL  fRet = FALSE;
    HKEY  hKeyClient;
    DWORD dwUTF8 = 0;
    DWORD dwSize = sizeof(DWORD);
    DWORD dwType;

    dwErr = RegOpenKeyEx(
                HKEY_CURRENT_USER,
                INTERNET_POLICIES_KEY,
                0,
                KEY_QUERY_VALUE,
                &hKeyClient
            );
    if( dwErr == ERROR_SUCCESS )
    {
        dwErr = RegQueryValueEx(
                hKeyClient,
                "EnableUTF8",
                0,
                &dwType,
                (LPBYTE)&dwUTF8,
                &dwSize
        );

        if( dwErr == ERROR_SUCCESS && dwUTF8 )
        {
            fRet = TRUE;
        }
        RegCloseKey(hKeyClient);
    }

    DEBUG_LEAVE(fRet);
    return fRet;
}

// Enabled by adding a DWORD value "MBCSServername" with non=zero value under POLICY key
BOOL GlobalUTF8hackEnabled()
{
    DEBUG_ENTER((DBG_APP,
                Bool,
                "GlobalUTF8hackEnabled",
                NULL
                ));
                
    DWORD dwErr = ERROR_SUCCESS;
    BOOL  fRet = TRUE;
    HKEY  hKeyClient;
    DWORD dwUTF8 = 0;
    DWORD dwSize = sizeof(DWORD);
    DWORD dwType;

    dwErr = RegOpenKeyEx(
                HKEY_CURRENT_USER,
                INTERNET_POLICIES_KEY,
                0,
                KEY_QUERY_VALUE,
                &hKeyClient
            );
    if( dwErr == ERROR_SUCCESS )
    {
        dwErr = RegQueryValueEx(
                hKeyClient,
                "MBCSServername",
                0,
                &dwType,
                (LPBYTE)&dwUTF8,
                &dwSize
        );

        if( dwErr == ERROR_SUCCESS && !dwUTF8 )
        {
            fRet = FALSE;
        }
        RegCloseKey(hKeyClient);
    }

    DEBUG_LEAVE(fRet);
    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\iapp\cnetsimp.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       cnetftp.cxx
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    2-06-96   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------
#include <iapp.h>
#ifdef unix
#include <unistd.h>
#endif /* unix */

#include <shlwapip.h>

static DWORD dwLstError;

PerfDbgTag(tagCINetFile,    "Urlmon", "Log CINetFile",         DEB_PROT);
    DbgTag(tagCINetFileErr, "Urlmon", "Log CINetFile Errors",  DEB_PROT|DEB_ERROR);
PerfDbgTag(tagCINetSimple,  "Urlmon", "Log CINetSimple",       DEB_PROT);

#ifdef unix
extern "C" void unixForceAutoProxSync();
#endif /* unix */

LPWSTR FindFileExtensionW(LPWSTR pwzFileName)
{
    DEBUG_ENTER((DBG_APP,
                Pointer,
                "FindFileExtensionW",
                "%.80wq",
                pwzFileName
                ));
                
    LPWSTR pStr = NULL;
    LPWSTR lpF = pwzFileName + wcslen(pwzFileName); //Point to null

    if (lpF)
    {
        //Strip all trailing dots.
        for (lpF--; lpF >= pwzFileName && (*lpF == L'.' || *lpF == L' '); lpF --)
            *lpF = 0;

        for (; lpF >= pwzFileName && *lpF != L'.'; lpF --)
            if (*lpF == L'\\')
                return NULL;
    }

    if (lpF > pwzFileName)
    {
        pStr = lpF;
    }

    DEBUG_LEAVE(pStr);
    return pStr;

}

//+---------------------------------------------------------------------------
//
//  Method:     CINetFile::CINetFile
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    2-06-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
CINetFile::CINetFile(REFCLSID rclsid, IUnknown *pUnkOuter) : CINet(rclsid,pUnkOuter)
{
    DEBUG_ENTER((DBG_APP,
                None,
                "CINetFile::CINetFile",
                "this=%#x, %#x, %#x",
                this, &rclsid, pUnkOuter
                ));
                
    PerfDbgLog(tagCINetFile, this, "+CINetFile::CINetFile");

    _dwIsA = DLD_PROTOCOL_FILE;
    _wzFileName[0] = '\0';
    
    PerfDbgLog(tagCINetFile, this, "-CINetFile::CINetFile");

    DEBUG_LEAVE(0);
}

//+---------------------------------------------------------------------------
//
//  Method:     CINetFile::~CINetFile
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    2-06-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
CINetFile::~CINetFile()
{
    DEBUG_ENTER((DBG_APP,
                None,
                "CINetFile::~CINetFile",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCINetFile, this, "+CINetFile::~CINetFile");

    if (_hFile && (_hFile != INVALID_HANDLE_VALUE))
    {
        CloseHandle(_hFile);
    }

    _wzFileName[0] = '\0';
    PerfDbgLog(tagCINetFile, this, "-CINetFile::~CINetFile");

    DEBUG_LEAVE(0);
}

//+---------------------------------------------------------------------------
//
//  Method:     CINetFile::INetAsyncOpen
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    2-06-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINetFile::INetAsyncOpen()
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINetFile::INetAsyncOpen",
                "this=%#x",
                this
                ));
                
    HRESULT hr = NOERROR;
    DWORD dwAttr;
    PerfDbgLog1(tagCINetFile, this, "+CINetFile::INetAsyncOpen(szObject:%ws)", GetObjectNameW());

    ReportNotification(BINDSTATUS_SENDINGREQUEST, GetServerName());

    // nothing to do - just call
    dwAttr = GetFileAttributesWrapW(GetObjectNameW());

#ifdef unix
    unixForceAutoProxSync();
    if(access(GetObjectName(),R_OK) == -1)
    {
        SetLastError(ERROR_ACCESS_DENIED);
        dwAttr = 0xffffffff;
    }
#endif /* unix */

    if (   (dwAttr != 0xffffffff)
        && !(dwAttr & FILE_ATTRIBUTE_DIRECTORY)
       )
    {
        HANDLE htemp = 0;
        DWORD dwSize = 0;
        {
            WIN32_FIND_DATAW finddata;

            htemp = FindFirstFileWrapW(GetObjectNameW(), &finddata);
            dwSize = finddata.nFileSizeLow;
        }
        _cbTotalBytesRead = dwSize;
        _cbDataSize = dwSize;

        if (htemp  && (htemp != INVALID_HANDLE_VALUE))
        {
            ReportNotificationW(BINDSTATUS_CACHEFILENAMEAVAILABLE, GetObjectNameW());
            
            // if the file has a file extension, try to
            // determine the MIME type that way...
            //
            LPWSTR pwsz = GetObjectNameW();
            pwsz = FindFileExtensionW(pwsz);
            if (pwsz)
            {
                char psz[MAX_PATH];
                psz[0] = '\0';

                W2A(pwsz, psz, MAX_PATH);
                char szMime[MAX_PATH];
                DWORD cb = MAX_PATH;

                if (SUCCEEDED(GetMimeFromExt(psz,szMime,&cb)))
                {
                    if( _grfBindF & BINDF_FROMURLMON )
                    {
                        ReportNotification(BINDSTATUS_VERIFIEDMIMETYPEAVAILABLE, szMime);
                    }
                    else
                    {
                        ReportNotification(BINDSTATUS_MIMETYPEAVAILABLE, szMime);

                    }
    
                }
            }

            if (_pCTrans)
            {
                _bscf |= BSCF_LASTDATANOTIFICATION;
                _pCTrans->ReportData(_bscf, _cbTotalBytesRead, _cbDataSize);
                ReportResultAndStop(NOERROR, _cbTotalBytesRead, _cbDataSize );
            }                
         
            _hrError = INET_E_DONE;
            hr = NOERROR;
            FindClose(htemp);
        }
        else
        {
            SetCNetBindResult(GetLastError());
            hr = _hrError = INET_E_DATA_NOT_AVAILABLE;
        }
    }
    else if(   (dwAttr != 0xffffffff)
            && (dwAttr & FILE_ATTRIBUTE_DIRECTORY) )
    {
        hr = _hrError = INET_E_REDIRECT_TO_DIR;
    }
    else
    {
        // BUGBUG do authentication if this call failed due to
        // net permission being denied
        DbgLog2(tagCINetFileErr, this, "-CINetFile::INetAsyncOpen failed (dwAttr:%ld,filename:%ws)",dwAttr,GetObjectNameW());

        // If you pass \\servername to GetFileAttributesWrap, on NT4 it will return ERROR_FILE_NOT_FOUND
        // but ERROR_INVALID_NAME on all other platforms.
        // We remap this error so that iframes can navigate to \\servername on NT4
        // Reference: IE5/102590
        DWORD dwError = GetLastError();
        if ((dwError==ERROR_FILE_NOT_FOUND)  
            && PathIsUNCServer(GetObjectName()))
        {
            dwError = ERROR_INVALID_NAME;
        }
        // set the exact error for GetBindResult
        SetCNetBindResult(dwError);
        hr = _hrError = INET_E_RESOURCE_NOT_FOUND;
    }

    PerfDbgLog1(tagCINetFile, this, "-CINetFile::INetAsyncOpen (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINetFile::Read
//
//  Synopsis:
//
//  Arguments:  [pBuffer] --
//              [cbBytes] --
//              [pcbBytes] --
//
//  Returns:
//
//  History:    2-13-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CINetFile::Read(void *pBuffer, DWORD cbBytes, DWORD *pcbBytes)
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINetFile::IInternetProtocol::Read",
                "this=%#x, %#x, %#x, %#x",
                this, pBuffer, cbBytes, pcbBytes
                ));
                
    PerfDbgLog(tagCINetFile, this, "+CINetFile::Read");
    HRESULT hr = NOERROR;

    PProtAssert((cbBytes && pcbBytes));

    if (!_hFile)
    {
        LPWSTR wszFile = GetObjectNameW();

        PProtAssert((wszFile));

        if (wszFile)
        {
            // fill the internal buffer for data sniffing
            _hFile = CreateFileWrapW(wszFile, GENERIC_READ,
                            FILE_SHARE_READ | FILE_SHARE_WRITE, NULL,OPEN_EXISTING,
                            FILE_ATTRIBUTE_NORMAL, NULL);

        }

    }

    if (_hFile != INVALID_HANDLE_VALUE)
    {
        DWORD dwRead;
        if (ReadFile(_hFile, pBuffer, cbBytes, &dwRead, NULL))
        {
            *pcbBytes = dwRead;
            if (cbBytes != dwRead)
            {
                hr = S_FALSE;
            }
        }
        else
        {
            DbgLog2(tagCINetFileErr, this, " -CINetFile::Read could not read file (sniffing:%ld) (hr:%lx)", dwRead, hr);
            SetCNetBindResult(GetLastError());
            hr = _hrError = INET_E_DATA_NOT_AVAILABLE;
            ReportResultAndStop(hr);
        }
    }
    else
    {
        SetCNetBindResult(GetLastError());
        hr = _hrError = INET_E_DATA_NOT_AVAILABLE;
        ReportResultAndStop(hr);
        DbgLog2(tagCINetFileErr, this, "-CINetFile::Read could not open (file:%ws, hr:%lx)", GetObjectNameW(), hr);
    }

    PerfDbgLog4(tagCINetFile, this, "-CINetFile::Read (_hrError:%lx, [hr:%lx,cbBytesAsked:%ld,cbBytesReturned:%ld])",
                                    _hrError, hr, cbBytes, *pcbBytes);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINetFile::LockFile
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  History:    8-13-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINetFile::LockFile(BOOL fRetrieve)
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINetFile::LockFile",
                "this=%#x, %B",
                this, fRetrieve
                ));
                
    PerfDbgLog(tagCINetFile, this, "+CINetFile::LockFile");
    HRESULT hr = NOERROR;

    if (!_hFile )
    {
        _hFile = CreateFileWrapW( GetObjectNameW(), GENERIC_READ,
                    FILE_SHARE_READ | FILE_SHARE_WRITE, NULL,OPEN_EXISTING,
                    FILE_ATTRIBUTE_NORMAL, NULL);
    }

    if (_hFile != INVALID_HANDLE_VALUE)
    {
        _fLocked = TRUE;
    }

    PerfDbgLog1(tagCINetFile, this, "-CINetFile::LockFile (hr:%lx,)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINetFile::UnlockFile
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    8-13-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINetFile::UnlockFile()
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINetFile::UnlockFile",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCINetFile, this, "IN CINetFile::UnlockFile");
    HRESULT hr = NOERROR;

    if (_fLocked)
    {
        PProtAssert((_hFile));
        CloseHandle(_hFile);
        _hFile = NULL;
        _fLocked = FALSE;
    }

    PerfDbgLog1(tagCINetFile, this, "-CINetFile::UnlockFile (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CINetSimple::CINetSimple
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    2-06-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
CINetSimple::CINetSimple(REFCLSID rclsid, IUnknown *pUnkOuter) : CINet(rclsid,pUnkOuter)
{
    DEBUG_ENTER((DBG_APP,
                None,
                "CINetSimple::CINetSimple",
                "this=%#x, %#x, %#x",
                this, &rclsid, pUnkOuter
                ));
                
    PerfDbgLog(tagCINetSimple, this, "+CINetSimple::CINetSimple");

    _dwState = INetState_START;
    _dwIsA = DLD_PROTOCOL_NONE;

    PerfDbgLog(tagCINetSimple, this, "-CINetSimple::CINetSimple");

    DEBUG_LEAVE(0);
}

//+---------------------------------------------------------------------------
//
//  Method:     CINetSimple::~CINetSimple
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    2-06-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
CINetSimple::~CINetSimple()
{
    DEBUG_ENTER((DBG_APP,
                None,
                "CINetSimple::~CINetSimple",
                "this=%#x",
                this
                ));

    DEBUG_LEAVE(0);
}

//+---------------------------------------------------------------------------
//
//  Method:     CINetSimple::INetAsyncOpenRequest
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    1-27-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINetSimple::INetAsyncOpenRequest()
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINetSimple::INetAsyncOpenRequest",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCINetSimple, this, "+CINetSimple::INetAsyncOpenRequest");
    HRESULT hr = NOERROR;
    DWORD dwBindF = 0;

    SetINetState(INetState_PROTOPEN_REQUEST);
    PProtAssert((g_hSession != NULL));

    if (_hRequest && _fDoSimpleRetry)
    {
        // Abort the previous request if needed.
        // Note:  This is CINetSimple, so the behavior of closing the previous
        //        handle and retrying only applies to FTP and gopher requests.
        _fDoSimpleRetry = FALSE;
        _fHandlesRecycled = TRUE;
        TerminateRequest();
    }
 
    // get the open flags
    dwBindF = GetBindFlags();

    if (dwBindF & BINDF_GETNEWESTVERSION)
    {
        _dwOpenFlags |= INTERNET_FLAG_RELOAD;
    }

    if (   (dwBindF & BINDF_NOWRITECACHE)
        //BUG-WORK
        //&& !_pCTransData->IsFileRequired()
        )
    {
        _dwOpenFlags |= INTERNET_FLAG_DONT_CACHE ;
    }

    // BUGBUG OFFLINE, RELOAD, RESYNCHRONIZE and HYPERLINK are mutually
    // exclusive. But inside wininet there is priority, so
    // the priority is OFFLINE, RELOAD, RESYNCHRONIZE, HYPERLINK in that order

    if (dwBindF & BINDF_RESYNCHRONIZE)
    {
        // caller asking to do if-modified-since
        _dwOpenFlags |= INTERNET_FLAG_RESYNCHRONIZE;
    }

    if (dwBindF & BINDF_HYPERLINK)
    {
        // caller syas this is a hyperlink access
        _dwOpenFlags |= INTERNET_FLAG_HYPERLINK;
    }


    PrivAddRef();
    _HandleStateRequest = HandleState_Pending;

    // we always request keep-alive, use an existing connection (FTP) and
    // passive mode transfers (also FTP)
    _dwOpenFlags |= INTERNET_FLAG_KEEP_CONNECTION
                    | INTERNET_FLAG_EXISTING_CONNECT | INTERNET_FLAG_PASSIVE;

    HINTERNET hRequestTmp = InternetOpenUrl(g_hSession, _pszFullURL, NULL, 0, _dwOpenFlags, (DWORD_PTR) this);
    if ( hRequestTmp == 0)
    {
        dwLstError = GetLastError();
        if (dwLstError == ERROR_IO_PENDING)
        {
            // wait async for the handle
            hr = E_PENDING;
            SetStatePending(E_PENDING);

        }
        else
        {
            _hrError = INET_E_CANNOT_CONNECT;
            hr = E_FAIL;
        }
    }
    else
    {
        _hRequest = hRequestTmp;
        _HandleStateRequest = HandleState_Initialized;
        hr = INetAsyncSendRequest();
    }

    if (_hrError != INET_E_OK)
    {
        // we need to terminate here
        ReportResultAndStop(NOERROR);
    }

    PerfDbgLog1(tagCINetSimple, this, "-CINetSimple::INetAsyncOpenRequest (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINetSimple::INetAsyncSendRequest
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    1-27-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINetSimple::INetAsyncSendRequest()
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINetSimple::INetAsyncSendRequest",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCINetSimple, this, "+CINetSimple::INetAsyncSendRequest");

    HRESULT hr = NOERROR;
    hr = QueryStatusOnResponse();
    
    if (! _fDoSimpleRetry && hr == NOERROR)
    {

        SetINetState(INetState_SEND_REQUEST);

        if (OperationOnAparmentThread(INetState_SEND_REQUEST))
        {
            TransitState(INetState_READ);
        }
        else
        {
            hr = INetRead();
        }
    }
    
    if (_hrError != INET_E_OK)
    {
        // we need to terminate here
        ReportResultAndStop(NOERROR);
    }

    PerfDbgLog1(tagCINetSimple, this, "-CINetSimple::INetAsyncSendRequest (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINetSimple::INetAsyncConnect
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    1-27-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINetSimple::INetAsyncConnect()
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINetSimple::INetAsyncConnect",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCINetSimple, this, "+CINetSimple::INetAsyncConnect");
    HRESULT hr = NOERROR;

    //just go into OpenRequest state
    hr = INetAsyncOpenRequest();

    PerfDbgLog1(tagCINetSimple, this, "-CINetSimple::INetAsyncConnect (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CINetSimple::QueryStatusOnResponse
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    11-14-97   OliverW (Oliver Wallace)   Created
//              09-18-98   MeadH (Mead Himelstein) copy over to shipping code
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINetSimple::QueryStatusOnResponse()
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINetSimple::QueryStatusOnResponse",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCINetSimple, this, "+CINetSimple::QueryStatusOnResponse");
    HRESULT hr = NOERROR;

    DWORD dwStatus = 0;
    DWORD cbLen = sizeof(DWORD);

    if (HttpQueryInfo(
            _hRequest,
            HTTP_QUERY_STATUS_CODE | HTTP_QUERY_FLAG_NUMBER,
            (LPVOID) &dwStatus,
            &cbLen,
            NULL
            ))
    {
        if (dwStatus == HTTP_STATUS_PROXY_AUTH_REQ)
        {
            _hrINet = INET_E_AUTHENTICATION_REQUIRED;
            TransitState(INetState_AUTHENTICATE, TRUE);
            hr = E_PENDING;
        }
    }

    PerfDbgLog1(tagCINetSimple, this, "-CINetSimple::QueryStatusOnResponse (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}



//+---------------------------------------------------------------------------
//
//  Method:     CINetSimple::QueryStatusOnResponseDefault
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    2-02-98   OliverW   Created
//              09-18-98   MeadH (Mead Himelstein) copy over to shipping code
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINetSimple::QueryStatusOnResponseDefault(DWORD dwStat)
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINetSimple::QueryStatusOnResponseDefault",
                "this=%#x, %#x",
                this, dwStat
                ));
                
    PerfDbgLog(tagCINetSimple, this, "+CINetSimple::QueryStatusOnResponseDefault");
    PerfDbgLog1(tagCINetSimple, this, "-CINetSimple::QueryStatusOnResponseDefault (hr:%lx)", NOERROR);

    DEBUG_LEAVE(NOERROR);
    return NOERROR;
}

    

//+---------------------------------------------------------------------------
//
//  Method:     CINetSimple::QueryHeaderOnResponse
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    2-02-98   OliverW   Created
//              09-18-98   MeadH (Mead Himelstein) copy over to shipping code
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINetSimple::QueryHeaderOnResponse()
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINetSimple::QueryHeaderOnResponse",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCINetSimple, this, "+CINetSimple::QueryHeaderOnResponse");
    PerfDbgLog1(tagCINetSimple, this, "-CINetSimple::QueryHeaderOnResponse (hr:%lx)", NOERROR);

    DEBUG_LEAVE(NOERROR);
    return NOERROR;
}



//+---------------------------------------------------------------------------
//
//  Method:     CINetFtp::CINetFtp
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    2-06-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
CINetFtp::CINetFtp(REFCLSID rclsid, IUnknown *pUnkOuter) : CINetSimple(rclsid, pUnkOuter)
{
    DEBUG_ENTER((DBG_APP,
                None,
                "CINetFtp::CINetFtp",
                "this=%#x, %#x, %#x",
                this, &rclsid, pUnkOuter
                ));
                
    PerfDbgLog(tagCINetSimple, this, "+CINetFtp::CINetFtp");

    _dwIsA = DLD_PROTOCOL_FTP;

    PerfDbgLog(tagCINetSimple, this, "-CINetFtp::CINetFtp");

    DEBUG_LEAVE(0);
}

//+---------------------------------------------------------------------------
//
//  Method:     CINetFtp::INetAsyncSendRequest
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    3-13-98   VincentR  Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINetFtp::INetAsyncSendRequest()
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINetFtp::INetAsyncSendRequest",
                "this=%#x",
                this
                ));
                
    HRESULT hr = NOERROR;
    

    DWORD dwLowSize = 0;
    DWORD dwHighSize = 0;
    
    dwLowSize = FtpGetFileSize(_hRequest, &dwHighSize);
    if(dwLowSize != 0xffffffff)
        _cbDataSize = dwLowSize;

    hr = CINetSimple::INetAsyncSendRequest();

    DEBUG_LEAVE(hr);
    return(hr);
}

//+---------------------------------------------------------------------------
//
//  Method:     CINetFtp::~CINetFtp
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    2-06-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
CINetFtp::~CINetFtp()
{
    DEBUG_ENTER((DBG_APP,
                None,
                "CINetFtp::~CINetFtp",
                "this=%#x",
                this
                ));

    DEBUG_LEAVE(0);
}


//+---------------------------------------------------------------------------
//
//  Method:     CINetGopher::CINetGopher
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    2-06-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
CINetGopher::CINetGopher(REFCLSID rclsid, IUnknown *pUnkOuter) : CINetSimple(rclsid,pUnkOuter)
{
    DEBUG_ENTER((DBG_APP,
                None,
                "CINetGopher::CINetGopher",
                "this=%#x, %#x, %#x",
                this, &rclsid, pUnkOuter
                ));
                
    PerfDbgLog(tagCINetSimple, this, "+CINetGopher::CINetGopher");

    _dwIsA = DLD_PROTOCOL_GOPHER;

    PerfDbgLog(tagCINetSimple, this, "-CINetGopher::CINetGopher");

    DEBUG_LEAVE(0);
}

//+---------------------------------------------------------------------------
//
//  Method:     CINetGopher::~CINetGopher
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    2-06-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
CINetGopher::~CINetGopher()
{
    DEBUG_ENTER((DBG_APP,
                None,
                "CINetGopher::~CINetGopher",
                "this=%#x",
                this
                ));

    DEBUG_LEAVE(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\eapp\selfreg.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       selfreg.cxx
//
//  Contents:   Taken from Office96
//              Source file for the common self registration code used by all the
//              sub projects of Sweeper project. They are
//              UrlMon
//              UrlMnPrx
//
//  Exports:    HrDllRegisterServer()
//              HrDllUnregisterServer()
//
//  Classes:
//
//  Functions:
//
//  History:    5-03-96   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------
#include <eapp.h>

HINSTANCE g_hinstDll = NULL;
PFNLOADSTRING g_pfnLoadString = NULL;

//+---------------------------------------------------------------------------
//
//  Function:   GetDllFullPath
//
//  Synopsis:
//
//  Arguments:  [lpszExeName] --
//              [cch] --
//
//  Returns:
//
//  History:         95    OfficeXX                 created
//              5-03-96   JohannP (Johann Posch)   port urlmon
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL GetDllFullPath( LPSTR lpszExeName, DWORD cch )
{
    if ( NULL == g_hinstDll )
    {
        EProtAssert(( FALSE && "NULL hInst"));
        return FALSE;
    }

    *lpszExeName = NULL;

    if ( GetModuleFileName( g_hinstDll, lpszExeName, cch ) == 0)
    {
        EProtAssert(( FALSE && "GetModuleFileName Failed"));
        return FALSE;
    }

    return TRUE;
}


inline BOOL IsASeparator( char ch )
{
    return (ch == '\\' || ch == '/' || ch == ':');
}

//+---------------------------------------------------------------------------
//
//  Function:   ParseAFileName
//
//  Synopsis:
//
//  Arguments:  [szFileName] --
//              [piRetLen] --
//
//  Returns:
//
//  History:         95    OfficeXX                 created
//              5-03-96   JohannP (Johann Posch)   port urlmon
//
//  Notes:
//
//----------------------------------------------------------------------------
LPSTR ParseAFileName( LPSTR szFileName, int *piRetLen)
{
    LPSTR pszFile;

    // Start at the end of the filename.
    pszFile = szFileName + ( lstrlen(szFileName) - 1 );

    // Back up to a '\\' or beginning or something!! We just want a file
    // name!. Whatever comes first.
    while ( pszFile > szFileName && !IsASeparator(*pszFile ) )
        pszFile = CharPrev(szFileName, pszFile);

    if ( pszFile != szFileName )
        pszFile = CharNext(pszFile);

    if ( piRetLen )
        *piRetLen = lstrlen(pszFile);

    return pszFile;
}


//+---------------------------------------------------------------------------
//
//  Function:   FRegisterEntries
//
//  Synopsis:   FRegisterEntries: Register a group of reg entries off a base key.
//
//  Arguments:  [hkRoot] --
//              [rgEntries] --
//              [dwEntries] --
//              [pszPath] --
//              [pszBinderName] --
//
//  Returns:
//
//  History:         95    OfficeXX                 created
//              5-03-96   JohannP (Johann Posch)   port urlmon
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL FRegisterEntries(HKEY hkRoot, const REGENTRY rgEntries[],
                    DWORD dwEntries, char *pszPath, char *pszBinderName)
{
    HKEY    hkey = NULL;
    LONG    lRet;
    char    szValue[1024];
    char    szResString[1024];
    char    szKeyName[1024];
    BOOL    fRet = FALSE;
    int         i;

    for (i = 0; i < (int)dwEntries; i++)
    {
        // We work with a copy of the entry, since we might modify it
        REGENTRY reCurrentEntry = rgEntries[i];

        if (reCurrentEntry.iKeyType ==  KEYTYPE_RESID)
        {
            int cch;
            if (g_pfnLoadString == NULL)
                return FALSE;
            cch = g_pfnLoadString(g_hinstDll, (UINT)reCurrentEntry.pszKey, szKeyName,
                    sizeof(szKeyName));
            if (cch > 0 && cch <= 1024)
            {
                reCurrentEntry.pszKey = szKeyName;
            }
            else
            {
                EProtAssert(( FALSE && "LoadString Failed ( 1)"));
                continue;
            }
        }

        lRet = RegCreateKey(hkRoot, reCurrentEntry.pszKey, &hkey);

        if (lRet != ERROR_SUCCESS)
        {
            EProtAssert(( FALSE && "RegCreateKey Failed ( 1)"));
            continue;
        }

         // If the type is REG_RESID, then pbData holds the resource ID.  We
         // load the resource string, then modify our reCurrentEntry to point
         // to it.

        if (reCurrentEntry.dwType == REG_RESID)
        {
            int cch;
            if (g_pfnLoadString == NULL)
                return FALSE;

            cch = g_pfnLoadString(g_hinstDll, (UINT)reCurrentEntry.pbData, szResString,
                    sizeof(szResString));
            if (cch > 0 && cch <= 1024)
            {
                reCurrentEntry.dwType = REG_SZ;
                reCurrentEntry.pbData = (BYTE*) szResString;
            }
            else
            {
                EProtAssert(( FALSE && "LoadString Failed (2)"));
                reCurrentEntry.pbData = NULL;
            }
        }


        // Set the value if there is one
        if (reCurrentEntry.pbData != NULL || reCurrentEntry.dwType != REG_SZ)
        {
            switch (reCurrentEntry.dwType)
            {
                case REG_SZ:
                    // Replace the first %s with the path, and the second
                    // %s with the name of the binder app (may not do anything).
                    if (pszPath != NULL && pszBinderName != NULL)
                    {
                        wsprintf(szValue, (char*)reCurrentEntry.pbData, pszPath,
                            pszBinderName);

                        lRet = RegSetValueEx(hkey, reCurrentEntry.pszValueName, 0,
                            REG_SZ, (BYTE*)szValue, lstrlen(szValue)+1);
#if DBG == 1
                        if ( ERROR_SUCCESS != lRet )
                            EProtAssert(( FALSE && "RegSetValueEx Failed ( 1)"));
#endif
                    }
                    break;

                case REG_DWORD:
                    lRet = RegSetValueEx(hkey, reCurrentEntry.pszValueName, 0,
                        REG_DWORD,  (BYTE*)&reCurrentEntry.pbData, sizeof(DWORD));

#if DBG == 1
                    if ( ERROR_SUCCESS != lRet )
                        EProtAssert(( FALSE && "RegSetValueEx Failed (2)"));
#endif
                    break;

                default:
                    EProtAssert(( FALSE && "Unexpected reg entry type"));
                    // Unexpected type: ignore
                    break;
            }
        }

        // Close the subkey
        RegCloseKey(hkey);
        hkey = NULL;
    }

    fRet = TRUE;

    // Close the base key if it was open
    if (hkey)
        RegCloseKey(hkey);

    return fRet;
}


/*
 * FRegisterEntryGroups: Register several groups of reg entries.
 */
BOOL FRegisterEntryGroups(const REGENTRYGROUP *rgRegEntryGroups,
    char *pszPath, char *pszBinderName)
{
    BOOL fError = FALSE;
    int i;

    // Keep going even if we get some errors
    for (i=0; rgRegEntryGroups[i].hkRoot != NULL; i++)
    {
        if (!FRegisterEntries(rgRegEntryGroups[i].hkRoot, rgRegEntryGroups[i].rgEntries,
            rgRegEntryGroups[i].dwEntries,pszPath, pszBinderName))
        {
            fError = TRUE;
        }
    }

    return !fError;
}

//+---------------------------------------------------------------------------
//
//  Function:   FDeleteEntries
//
//  Synopsis:   Delete a group of reg entries off a base key.
//
//  Arguments:  [hkRoot] --
//              [rgEntries] --
//              [dwEntries] --
//
//  Returns:
//
//  History:         95    OfficeXX                 created
//              5-03-96   JohannP (Johann Posch)   port urlmon
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL FDeleteEntries(HKEY hkRoot, const REGENTRY rgEntries[], DWORD dwEntries)
{
    LONG    lRet;
    int         i;
    char    szKeyName[1024];
    PSTR    pKey;

    // Delete in reverse order, to kill children before parent
    for (i = (int)dwEntries - 1; i >= 0; i--)
    {
        pKey = NULL;

        if (rgEntries[i].iKeyType ==  KEYTYPE_RESID)
        {
            int cch;
            cch = g_pfnLoadString(g_hinstDll, (UINT)rgEntries[i].pszKey, szKeyName,
                    sizeof(szKeyName));
            if (cch > 0 && cch <= 1024)
            {
                pKey = szKeyName;
            }
        else
            {
                EProtAssert(( FALSE && "LoadString Failed (FDeleteEntries)"));
                continue;
            }
        }
        else
        {
            if ( KEYTYPE_STRING != rgEntries[i].iKeyType )
            {
                EProtAssert(( FALSE && "Unknown Key Type"));
                continue;
            }
            pKey = rgEntries[i].pszKey;
        }

        if (pKey != NULL)
        {
            // Delete the current key if it has no subkeys.
            // Ignore the return value.
            lRet = RegDeleteKey(hkRoot, pKey);
        }
    }

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Function:   FDeleteEntryGroups
//
//  Synopsis:   Delete the base keys of all the given groups.

//
//  Arguments:  [rgRegEntryGroups] --
//
//  Returns:
//
//  History:         95    OfficeXX                 created
//              5-03-96   JohannP (Johann Posch)   port urlmon
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL FDeleteEntryGroups(const REGENTRYGROUP *rgRegEntryGroups)
{
    BOOL fError = FALSE;

    // Keep going even if we get some errors
    for (int i=0; rgRegEntryGroups[i].hkRoot != NULL; i++)
    {
        if (!FDeleteEntries(rgRegEntryGroups[i].hkRoot,
            rgRegEntryGroups[i].rgEntries,
            rgRegEntryGroups[i].dwEntries))
        {
            fError = TRUE;
        }
    }

    return !fError;
}


#ifdef NOT_USED
/*
 * FDeleteSubtree - Delete given key and all subkeys
 */
BOOL FDeleteSubtree(HKEY hkRoot, char *pszKey)
{
    HKEY        hkey = NULL;
    LONG        lRet;
    char        szSubKey[MAX_PATH];

    lRet = RegOpenKey(hkRoot, pszKey, &hkey);
    if (lRet != ERROR_SUCCESS)
        goto End;

    // remove all subkeys
    for (;;)
{
        lRet = RegEnumKey(hkey, 0, szSubKey, sizeof szSubKey);

        if (lRet == ERROR_NO_MORE_ITEMS)
            break;

        if (lRet != ERROR_SUCCESS)
            goto End;

        if (!FDeleteSubtree(hkey, szSubKey))
            goto End;
}

End:
    if (hkey != NULL)
        RegCloseKey (hkey);

    lRet = RegDeleteKey(hkRoot, pszKey);

    return (lRet == ERROR_SUCCESS);
}
#endif // NOT_USED



//+---------------------------------------------------------------------------
//
//  Function:   HrDllRegisterServer
//
//  Synopsis:   registers an entrygroup
//
//  Arguments:  [HINSTANCE] --
//              [hinstDll] --
//              [pfnLoadString] --
//              [pszAppName] --
//
//  Returns:
//
//  History:         95    OfficeXX                 created
//              5-03-96   JohannP (Johann Posch)   port urlmon
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT HrDllRegisterServer(const REGENTRYGROUP *rgRegEntryGroups,HINSTANCE hinstDll,
                            PFNLOADSTRING pfnLoadString, char *pszAppName)
{
    // REVIEW: for Windows dll, do we want to register full path?
    BOOL    fRet = TRUE;
    char    szFullPath[MAX_PATH];
    char    szFileName[MAX_PATH];
    char    *pszFileName;

    g_hinstDll = hinstDll;
    if ((g_pfnLoadString = pfnLoadString) == NULL)
        // set the pointer to windows LoadString() api
        g_pfnLoadString = (PFNLOADSTRING) LoadString;

    if (!GetDllFullPath(szFullPath, MAX_PATH))
        return E_FAIL;

    pszFileName = ParseAFileName(szFullPath, NULL);

    if (pszAppName != NULL)
        lstrcpy(szFileName, pszAppName);
    else
        lstrcpy(szFileName, pszFileName);

    // Terminate the path at the file name
    *pszFileName = '\0';
    fRet = FRegisterEntryGroups(rgRegEntryGroups, szFullPath, szFileName);

    g_hinstDll = NULL;
    g_pfnLoadString = NULL;
    return fRet ? NOERROR : E_FAIL;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrDllUnregisterServer
//
//  Synopsis:   unregisters an entrygroup
//
//  Arguments:  [HINSTANCE] --
//              [hinstDll] --
//              [pfnLoadString] --
//
//  Returns:
//
//  History:         95    OfficeXX                 created
//              5-03-96   JohannP (Johann Posch)   port urlmon
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT HrDllUnregisterServer(const REGENTRYGROUP *rgRegEntryGroups,HINSTANCE hinstDll, PFNLOADSTRING pfnLoadString)
{
    g_hinstDll = hinstDll;
    if ((g_pfnLoadString = pfnLoadString) == NULL)
        // set the pointer to windows LoadString() api
        g_pfnLoadString = (PFNLOADSTRING) LoadString;

    FDeleteEntryGroups(rgRegEntryGroups);

    g_hinstDll = NULL;
    g_pfnLoadString = NULL;

    return NOERROR;
}




=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\eapp\urlcf.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       urlcf.cxx
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    12-22-95   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------
#include <eapp.h>

#ifdef EAPP_TEST
const GUID CLSID_ResProtocol =     {0x79eaca00, 0xbaf9, 0x11ce, {0x8c, 0x82, 0x00, 0xaa, 0x00, 0x4b, 0xa9, 0x0b}};
const GUID CLSID_OhServNameSp =    {0x79eaca01, 0xbaf9, 0x11ce, {0x8c, 0x82, 0x00, 0xaa, 0x00, 0x4b, 0xa9, 0x0b}};
const GUID CLSID_MimeHandlerTest1= {0x79eaca02, 0xbaf9, 0x11ce, {0x8c, 0x82, 0x00, 0xaa, 0x00, 0x4b, 0xa9, 0x0b}};

const GUID CLSID_NotificaitonTest1  = {0xc733e501, 0x576e, 0x11d0, {0xb2, 0x8c, 0x00, 0xc0, 0x4f, 0xd7, 0xcd, 0x22}};
const GUID CLSID_NotificaitonTest2  = {0xc733e502, 0x576e, 0x11d0, {0xb2, 0x8c, 0x00, 0xc0, 0x4f, 0xd7, 0xcd, 0x22}};
const GUID CLSID_NotificaitonTest3  = {0xc733e503, 0x576e, 0x11d0, {0xb2, 0x8c, 0x00, 0xc0, 0x4f, 0xd7, 0xcd, 0x22}};
const GUID CLSID_NotificaitonTest4  = {0xc733e504, 0x576e, 0x11d0, {0xb2, 0x8c, 0x00, 0xc0, 0x4f, 0xd7, 0xcd, 0x22}};
#endif // EAPP_TEST

const GUID CLSID_StdEncodingFilterFac= {0x54c37cd0, 0xd944, 0x11d0, {0xa9, 0xf4, 0x00, 0x60, 0x97, 0x94, 0x23, 0x11}};
const GUID CLSID_CdlProtocol  =    {0x3dd53d40, 0x7b8b, 0x11d0, {0xb0, 0x13, 0x00, 0xaa, 0x00, 0x59, 0xce, 0x02}};
const GUID CLSID_DeCompMimeFilter   = {0x8f6b0360, 0xb80d, 0x11d0, {0xa9, 0xb3, 0x00, 0x60, 0x97, 0x94, 0x23, 0x11}};
const GUID CLSID_ClassInstallFilter = {0x32b533bb, 0xedae, 0x11d0, {0xbd, 0x5a, 0x0, 0xaa, 0x0, 0xb9, 0x2a, 0xf1}};

#ifdef EAPP_TEST
HRESULT CreateNotificationTest(DWORD dwId, REFCLSID rclsid, IUnknown *pUnkOuter, REFIID riid, IUnknown **ppUnk);
#endif

//+---------------------------------------------------------------------------
//
//  Method:     CUrlClsFact::Create
//
//  Synopsis:
//
//  Arguments:  [clsid] --
//              [ppCF] --
//
//  Returns:
//
//  History:    12-22-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CUrlClsFact::Create(REFCLSID clsid, CUrlClsFact **ppCF)
{
    EProtDebugOut((DEB_PLUGPROT, "NULL _IN CUrlClsFact::Create\n"));
    HRESULT hr = NOERROR;
    CUrlClsFact * pCF =  NULL;

#ifdef EAPP_TEST
    if (   (clsid == CLSID_ResProtocol)
        || (clsid == CLSID_OhServNameSp)
       )
    {
        pCF = (CUrlClsFact *) new CUrlClsFact(clsid);
    }
    else if
        (
            (clsid == CLSID_NotificaitonTest1)
         || (clsid == CLSID_NotificaitonTest2)
         || (clsid == CLSID_NotificaitonTest3)
         || (clsid == CLSID_NotificaitonTest4)
         || (clsid == CLSID_DeCompMimeFilter )
         || (clsid == CLSID_MimeHandlerTest1)
         )
    {
        pCF = (CUrlClsFact *) new CUrlClsFact(clsid);
    }
#endif

    if(   (clsid == CLSID_DeCompMimeFilter )
       || (clsid == CLSID_StdEncodingFilterFac)
       || (clsid == CLSID_ClassInstallFilter)
       || (clsid == CLSID_CdlProtocol)
       )
    {
        pCF = (CUrlClsFact *) new CUrlClsFact(clsid);
    }


    if (pCF == NULL)
    {
        hr = E_OUTOFMEMORY;
    }
    else
    {
        *ppCF = pCF;
    }

    EProtDebugOut((DEB_PLUGPROT, "%p OUT CUrlClsFact::Create (hr:%lx\n", pCF,hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CUrlClsFact::CUrlClsFact
//
//  Synopsis:   constructor
//
//  Arguments:  [clsid] --
//
//  Returns:
//
//  History:    12-22-95   JohannP (Johann Posch)   Created
//
//  Notes:      we need to keep a refcount on the dll if for each object given to
//              outside, including ClassFactories.
//              The corresponding DllRelease is in the destructor
//
//----------------------------------------------------------------------------
CUrlClsFact::CUrlClsFact(REFCLSID clsid) : _CRefs(), _CLocks(0)
{
    _ClsID =  clsid;
    DllAddRef();
}

//+---------------------------------------------------------------------------
//
//  Method:     CUrlClsFact::~CUrlClsFact
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    12-22-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
CUrlClsFact::~CUrlClsFact()
{
    DllRelease();
}

//+---------------------------------------------------------------------------
//
//  Method:     CUrlClsFact::CreateInstance
//
//  Synopsis:   creates an instance of an Explode Object
//
//  Arguments:  [pUnkOuter] -- controlling unknown (must be NULL)
//              [riid] --      id of desired interface
//              [ppv] --       pointer to receive the interface
//
//  Returns:
//
//  History:    12-22-95   JohannP (Johann Posch)   Created
//
//  Notes:      S_OK - success
//              CLASS_E_NOAGGREATION - the caller tried to aggregate
//              CLASS_E_CLASSNOTAVAILABLE - couldn't initialize the class
//              E_OUTOFMEMORY - not enough memory to instantiate class
//
//----------------------------------------------------------------------------
STDMETHODIMP CUrlClsFact::CreateInstance(LPUNKNOWN pUnkOuter, REFIID riid, LPVOID * ppv)
{
    EProtDebugOut((DEB_PLUGPROT, "%p _IN CUrlClsFact::CreateInstance\n", this));
    HRESULT hr = NOERROR;
    // Class factory init time, the pointer to the creation function of
    // the object is given.  Use that to create the object

    //DumpIID(riid);
    //DumpIID(_rClsID);

    if (riid == IID_IClassFactory)
    {
        *ppv = (IClassFactory *)this;
        AddRef();
    }

    else if (   (_ClsID == CLSID_CdlProtocol)
        )
    {
        hr = CreateAPP(_ClsID, pUnkOuter, riid, (IUnknown **)ppv);
    }

#ifdef EAPP_TEST
    else if (   (_ClsID == CLSID_ResProtocol)
             || (_ClsID == CLSID_OhServNameSp)
             || (_ClsID == CLSID_MimeHandlerTest1)
            )

    {
        hr = CreateAPP(_ClsID, pUnkOuter, riid, (IUnknown **)ppv);
    }
    else if(   (_ClsID == CLSID_NotificaitonTest1)
            || (_ClsID == CLSID_NotificaitonTest2)
            || (_ClsID == CLSID_NotificaitonTest3)
            || (_ClsID == CLSID_NotificaitonTest4))
    {

     //   hr = CreateNotificationTest(
     //       0, _ClsID, pUnkOuter, riid, (IUnknown **)ppv);

        hr = E_FAIL;
    }
#endif
    else if (_ClsID == CLSID_ClassInstallFilter)
    {
        hr = CLASS_E_CLASSNOTAVAILABLE;
        if (pUnkOuter)
            hr = CLASS_E_NOAGGREGATION;
        else
        {
            CClassInstallFilter *pCIF = NULL;
            pCIF = new CClassInstallFilter();
            *ppv = (LPVOID)(IOInetProtocol *)pCIF;
            if (!*ppv)
                hr = E_OUTOFMEMORY;
            else
                hr = S_OK;
        }
    }
    else if( _ClsID == CLSID_DeCompMimeFilter)
    {
        hr = CLASS_E_CLASSNOTAVAILABLE;
        if( pUnkOuter)
            hr = CLASS_E_NOAGGREGATION;
        else
        {
            CMimeFt*    pMft = NULL;
            hr = CMimeFt::Create(&pMft);
            if( (hr == NOERROR) && pMft )
            {
                hr = pMft->QueryInterface(riid, ppv);
                pMft->Release();
            }
        }
    }
    else if( _ClsID == CLSID_StdEncodingFilterFac)
    {
        hr = CLASS_E_CLASSNOTAVAILABLE;
        if( pUnkOuter)
            hr = CLASS_E_NOAGGREGATION;
        else
        {
            *ppv = NULL;
            *ppv = new CEncodingFilterFactory;
            if( *ppv == NULL )
                hr = E_OUTOFMEMORY;
            else
                hr = ((IEncodingFilterFactory*)(*ppv))->AddRef();                
        }
    
    }


    EProtDebugOut((DEB_PLUGPROT, "%p OUT CUrlClsFact::CreateInstance (hr:%lx)\n", this,hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CUrlClsFact::LockServer
//
//  Synopsis:   locks the server, preventing it from being unloaded
//
//  Arguments:  [fLock] -- TRUE to lock, FALSE to unlock
//
//  Returns:
//
//  History:    12-22-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CUrlClsFact::LockServer(BOOL fLock)
{
    EProtDebugOut((DEB_PLUGPROT, "%p _IN CUrlClsFact::LockServer\n", this));
    HRESULT hr = NOERROR;
    if (fLock)
    {
        if (++_CLocks == 1)
        {
            DllAddRef();
        }
    }
    else
    {
        EProtAssert((_CLocks > 0));
        if (_CLocks > 0)
        {
            if (--_CLocks == 0)
            {
                DllRelease();
            }
        }
    }

    EProtDebugOut((DEB_PLUGPROT, "%p OUT CUrlClsFact::LockServer (hr:%lx)\n", this,hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CUrlClsFact::QueryInterface
//
//  Synopsis:
//
//  Arguments:  [riid] --
//              [ppvObj] --
//
//  Returns:
//
//  History:    12-22-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CUrlClsFact::QueryInterface(REFIID riid, void **ppvObj)
{
    VDATEPTROUT(ppvObj, void *);
    HRESULT hr = NOERROR;
    EProtDebugOut((DEB_PLUGPROT, "%p _IN CUrlClsFact::QueryInterface\n", this));

    if (   riid == IID_IUnknown
        || riid == IID_IClassFactory)
    {
        *ppvObj = this;
    }
    else
    {
        *ppvObj = NULL;
        hr = E_NOINTERFACE;
    }
    if (hr == NOERROR)
    {
        AddRef();
    }

    EProtDebugOut((DEB_PLUGPROT, "%p OUT CUrlClsFact::QueryInterface (hr:%lx\n", this,hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   CUrlClsFact::AddRef
//
//  Synopsis:
//
//  Arguments:  [ULONG] --
//
//  Returns:
//
//  History:    12-22-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CUrlClsFact::AddRef(void)
{
    EProtDebugOut((DEB_PLUGPROT, "%p _IN CUrlClsFact::AddRef\n", this));

    LONG lRet = ++_CRefs;

    EProtDebugOut((DEB_PLUGPROT, "%p OUT CUrlClsFact::AddRef (cRefs:%ld)\n", this,lRet));
    return lRet;
}

//+---------------------------------------------------------------------------
//
//  Function:   CUrlClsFact::Release
//
//  Synopsis:
//
//  Arguments:  [ULONG] --
//
//  Returns:
//
//  History:    12-22-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CUrlClsFact::Release(void)
{
    EProtDebugOut((DEB_PLUGPROT, "%p _IN CUrlClsFact::Release\n", this));

    LONG lRet = --_CRefs;

    if (_CRefs == 0)
    {
        delete this;
    }

    EProtDebugOut((DEB_PLUGPROT, "%p OUT CUrlClsFact::Release (cRefs:%ld)\n", this,lRet));
    return lRet;
}

#if DBG==1
HRESULT DumpIID(REFIID riid)
{

    HRESULT hr;
    LPOLESTR pszStr = NULL;

#ifdef EAPP_TEST
    hr = StringFromCLSID(riid, &pszStr);
    EProtDebugOut((DEB_PLUGPROT, "API >>> DumpIID (riid:%ws) \n", pszStr));
#endif // EAPP_TEST

    if (pszStr)
    {
        delete pszStr;
    }
    return hr = NOERROR;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\iapp\cnethttp.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       cnethttp.cxx
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    2-06-96   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------
#include <iapp.h>
#include "shlwapip.h"
#ifndef unix
#include "..\trans\transact.hxx"
#include "..\trans\oinet.hxx"
#else
#include "../trans/transact.hxx"
#include "../trans/oinet.hxx"
#endif /* unix */

PerfDbgTag(tagCINetHttp, "Urlmon", "Log CINetHttp", DEB_PROT);

extern LPSTR g_pszUAInfoString;
static CHAR  gszAcceptEncHeaders[] = "Accept-Encoding: gzip, deflate";

// http specifics
static char vszGet[]    = "GET";
static char vszPost[]   = "POST";
static char vszPut[]    = "PUT";
static char vszAttachment[] = "attachment";
static char vszFileName[] = "filename";
static DWORD dwLstError;
DWORD GetRedirectSetting();

// list of content-type we should not apply content-encoding onto it.
static LPSTR  vszIgnoreContentEnc[] =
{
     "application/x-tar"
    ,"x-world/x-vrml"
    ,"application/zip"
    ,"application/x-gzip"
    ,"application/x-zip-compressed"
    ,"application/x-compress"
    ,"application/x-compressed"
    ,"application/x-spoon"
    , 0
};

BOOL IgnoreContentEncoding(LPSTR szContentType, LPSTR szEnc, LPSTR szAccept)
{
    DEBUG_ENTER((DBG_APP,
                Bool,
                "IgnoreContentEncoding",
                "%.80q, %.80q, %.80q",
                szContentType, szEnc, szAccept
                ));
                
    BOOL bRet = FALSE;

    if( szEnc && szAccept && !StrStrI(szAccept, szEnc) )
    {
        //
        // some of the old web server will ignore the schemas indicated at
        // Accept-Endocing: header, we need to add another check here
        // to make sure the server returned content-encoding is the
        // one we supported, otherwise, we will not init the decoder
        //
        bRet = TRUE;
    }

    if( !bRet )
    {
        for( int i = 0; vszIgnoreContentEnc[i]; i++)
        {
            if(!StrCmpI(szContentType, vszIgnoreContentEnc[i]) )
            {
                bRet = TRUE;
                break;
            }
        }
    }

    DEBUG_LEAVE(bRet);
    return bRet;
}




//+---------------------------------------------------------------------------
//
//  Function:   GetRedirectSetting
//
//  Synopsis:   Reads the registry UrlMon Setting of Redirect
//
//  Arguments:  (none)
//
//  Returns:    0 if redirect should be done by WinINet,
//              1 if should be done by UrlMon
//
//  History:    4-22-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD GetRedirectSetting()
{
    DEBUG_ENTER((DBG_APP,
                Dword,
                "GetRedirectSetting",
                NULL
                ));
                
    HKEY hUrlMonKey = NULL;
    DWORD dwType;
    static DWORD dwValue = 0xffffffff;

    if (dwValue == 0xffffffff)
    {
        DWORD dwValueLen = sizeof(DWORD);
        dwValue = 0;

        #define szUrlMonKey "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\UrlMon Settings"
        #define szRedirect  "Redirect"

        if (RegOpenKeyEx(HKEY_CURRENT_USER, szUrlMonKey, 0, KEY_QUERY_VALUE, &hUrlMonKey) == ERROR_SUCCESS)
        {
            if (RegQueryValueEx(hUrlMonKey, szRedirect, NULL, &dwType, (LPBYTE)&dwValue, &dwValueLen) != ERROR_SUCCESS)
            {
                dwValue = 0;
            }
            RegCloseKey(hUrlMonKey);
        }
    }

    DEBUG_LEAVE(dwValue);
    return dwValue;
}

// max version strlen = (5)"HTTP/" + (4)digits + (1)'.' + (4)digits + (1)'\0'
#define MAXVERSIONLEN 15
BOOL RequestUsedHttp10( 
    IN HINTERNET hHttpRequest
)
{
    DEBUG_ENTER((DBG_APP,
                Bool,
                "RequestUsedHttp10",
                "%#x",
                hHttpRequest
                ));
                
    char lpszHttpVersion[MAXVERSIONLEN];
    DWORD dwLen = MAXVERSIONLEN;
    BOOL fRet = FALSE;

    if (HttpQueryInfo(
            hHttpRequest, 
            HTTP_QUERY_FLAG_REQUEST_HEADERS | HTTP_QUERY_VERSION,
            (LPVOID)lpszHttpVersion,
            &dwLen,
            NULL))
    {
        if (0 == StrCmpNI("HTTP/1.0", lpszHttpVersion, dwLen))
            fRet = TRUE;
    }

    DEBUG_LEAVE(fRet);
    return fRet;
}
               
//+---------------------------------------------------------------------------
//
//  Method:     CINetHttp::CINetHttp
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    2-06-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
CINetHttp::CINetHttp(REFCLSID rclsid, IUnknown *pUnkOuter) : CINet(rclsid,pUnkOuter)
{
    DEBUG_ENTER((DBG_APP,
                None,
                "CINetHttp::CINetHttp",
                "this=%#x, %#x, %#x",
                this, &rclsid, pUnkOuter
                ));
                
    PerfDbgLog(tagCINetHttp, this, "+CINetHttp::CINetHttp");

    _pHttpNeg = NULL;
    _pHttpNeg2 = NULL;
    _dwIsA = DLD_PROTOCOL_HTTP;
    _dwBufferSize = 0;
    _pBuffer = 0;
    _pszVerb = 0;
    _f2ndCacheKeySet = FALSE;


    PerfDbgLog(tagCINetHttp, this, "-CINetHttp::CINetHttp");

    DEBUG_LEAVE(0);
}

//----------------------------------------------------------------------------
//
//  Method:     CINetHttp::~CINetHttp
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    2-06-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
CINetHttp::~CINetHttp()
{
    DEBUG_ENTER((DBG_APP,
                None,
                "CINetHttp::~CINetHttp",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCINetHttp, this, "+CINetHttp::~CINetHttp");
    PProtAssert(( !_hRequest ));
    PProtAssert(( !_hServer ));

    delete [] _pBuffer;
    delete [] _pszHeader;
    delete [] _pszSendHeader;
    delete [] _pwzAddHeader;
    delete [] _pszVerb;
    if (_pbRootSecurityId != INVALID_P_ROOT_SECURITY_ID)
        delete [] _pbRootSecurityId;
    
    PProtAssert((_pHttpNeg == NULL));
    PProtAssert((_pHttpNeg2 == NULL));
    PProtAssert((_pWindow == NULL));
    PProtAssert(( _pHttSecurity == NULL));

    PerfDbgLog(tagCINetHttp, this, "-CINetHttp::~CINetHttp");

    DEBUG_LEAVE(0);
}

//+---------------------------------------------------------------------------
//
//  Method:     CINetHttp::INetAsyncOpenRequest
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    1-27-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINetHttp::INetAsyncOpenRequest()
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINetHttp::INetAsyncOpenRequest",
                "this=%#x",
                this
                ));
                
    PerfDbgLog1(tagCINetHttp, this, "+CINetHttp::INetAsyncOpenRequest (_szObject:%s)", GetObjectName());
    HRESULT hr = NOERROR;
    DWORD dwBindF = 0;
    const ULONG culSize = 256;
    ULONG ulSize = culSize;
    LPCSTR rgszAcceptStr[culSize] = { 0 };
    LPWSTR rgwzStr[culSize];

    SetINetState(INetState_PROTOPEN_REQUEST);
    PProtAssert((g_hSession != NULL));
    PProtAssert((GetStatePending() == NOERROR));

    if (_pOIBindInfo)
    {
        LPWSTR *pwzStr;
        IEnumString *pEnumString = NULL;
        ULONG ulCount = culSize;

        hr = _pOIBindInfo->GetBindString(BINDSTRING_ACCEPT_MIMES, (LPWSTR *)rgwzStr, ulSize, &ulCount);

        if (hr == NOERROR)
        {
            ULONG c = 0;

            for (c = 0; c < ulCount; c++)
            {
                rgszAcceptStr[c] = (LPCSTR) DupW2A(rgwzStr[c]);
                delete rgwzStr[c];
                rgwzStr[c] = 0;
            }
            rgszAcceptStr[c] = 0;
        }
        else
        if( hr == INET_E_USE_DEFAULT_SETTING )
        {
            rgszAcceptStr[0] = (LPCSTR) DupW2A(L"*/*");
            rgszAcceptStr[1] = NULL;
            hr = NOERROR;
        }

    }
    if (hr != NOERROR)
    {
        hr = INET_E_NO_VALID_MEDIA;
        _hrError = INET_E_NO_VALID_MEDIA;
    }
    else if (!_hServer)
    {
        // the download was probably aborted
        if (_hrError == NOERROR)
        {
            SetBindResult(ERROR_INVALID_HANDLE, hr);
            hr = _hrError = INET_E_CANNOT_CONNECT;
        }
        else
        {
            hr = _hrError;
        }
    }
    else
    {
        PProtAssert((_hServer));

        //PProtAssert((ppszAcceptStr && *ppszAcceptStr));

        #if DBG==1
        {
            LPSTR *pszMime = (LPSTR *) &rgszAcceptStr;
            while (*pszMime)
            {
                PerfDbgLog1(tagCINetHttp, this, "=== CTransData::GetAcceptStr (szMime:%s)", *pszMime);
                pszMime++;
            }
        }
        #endif


        dwBindF = GetBindFlags();

        if (dwBindF & BINDF_IGNORESECURITYPROBLEM)
        {
            _dwOpenFlags |= INTERNET_FLAG_IGNORE_CERT_CN_INVALID;
            _dwOpenFlags |= INTERNET_FLAG_IGNORE_CERT_DATE_INVALID;
            _dwOpenFlags |= INTERNET_FLAG_IGNORE_REDIRECT_TO_HTTPS;
            _dwOpenFlags |= INTERNET_FLAG_IGNORE_REDIRECT_TO_HTTP;
        }

        if (dwBindF & BINDF_ENFORCERESTRICTED)
        {
            _dwOpenFlags |= INTERNET_FLAG_RESTRICTED_ZONE;
        }
      

        if (GetRedirectSetting() != 0)
        {
            DbgLog(tagCINetHttp, this, "=== CINet::INetAsyncOpenRequest redirect done by UrlMon!");
            _dwOpenFlags |= INTERNET_FLAG_NO_AUTO_REDIRECT;
        }
        else
        {
            DbgLog(tagCINetHttp, this, "=== CINet::INetAsyncOpenRequest redirect done by WinINet!");
        }

        //
        // we always request keep-alive
        //
        _dwOpenFlags |= INTERNET_FLAG_KEEP_CONNECTION;

        //
        // Notify wininet if this is a multipart upload so it doesn't
        // add a terminating 0x0d 0x0a to the first send
        //
	    BINDINFO *pBndInfo = GetBindInfo();
        if (IsUpLoad()
			// Add in extra check to make TYMED_ISTREAM work the same as 
			// TYMED_HGLOBAL for verbs that require a body, other than POST.
			// We might consider doing away with this IF statement in the future:
			&& (pBndInfo->dwBindVerb == BINDVERB_POST))
        
        {
            _dwOpenFlags |= INTERNET_FLAG_NO_AUTO_REDIRECT;
            //BUGBUG: is the flag below needed?
            //_dwOpenFlags |= INTERNET_FLAG_MULTIPART;
        }



        PrivAddRef(TRUE);
        SetStatePending(E_PENDING);

        _HandleStateRequest = HandleState_Pending;
        HINTERNET hRequestTmp = HttpOpenRequest(
                        _hServer,                   // hHttpSession
                        GetVerb(),                  // lpszVerb
                        GetObjectName(),            // lpszObjectName
                        NULL, //HTTP_VERSION,       // lpszVersion
                        NULL,                       // lpszReferer
                        rgszAcceptStr,              // lplpszAcceptTypes
                        _dwOpenFlags,               // flag
                        (DWORD_PTR) this            // context
                        );
        if ( hRequestTmp == 0)
        {
            dwLstError = GetLastError();
            if (dwLstError == ERROR_IO_PENDING)
            {
                // wait async for the handle
                hr = E_PENDING;
            }
            else
            {
                PrivRelease(TRUE);
                SetStatePending(NOERROR);
                hr = _hrError = INET_E_RESOURCE_NOT_FOUND;
                SetBindResult(dwLstError,hr);
            }
        }
        else
        {
            _hRequest = hRequestTmp; 
            SetStatePending(NOERROR);
            _HandleStateRequest = HandleState_Initialized;

            if (_fUTF8hack)
            {
                DWORD dwSendUTF8 = 1;
                InternetSetOption(_hRequest, INTERNET_OPTION_SEND_UTF8_SERVERNAME_TO_PROXY, &dwSendUTF8, sizeof(DWORD));
                InternetSetOption(_hRequest, INTERNET_OPTION_CODEPAGE, &_dwServerCodePage, sizeof(DWORD));
            }

            hr = INetAsyncSendRequest();
        }

        {
            LPSTR  *pszMime = (LPSTR *) &rgszAcceptStr;
            while (*pszMime)
            {
                LPSTR pszDel = *pszMime;
                delete pszDel;
                pszMime++;
            }
        }
    }

    PerfDbgLog1(tagCINetHttp, this, "-CINetHttp::INetAsyncOpenRequest (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINetHttp::INetAsyncSendRequest
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    1-27-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINetHttp::INetAsyncSendRequest()
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINetHttp::INetAsyncSendRequest",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCINetHttp, this, "+CINetHttp::INetAsyncSendRequest");

    HRESULT hr = NOERROR;
    BOOL fRestarted;
    BOOL fRet;
    PProtAssert((GetStatePending() == NOERROR));

    SetINetState(INetState_SEND_REQUEST);

    LPVOID pBuffer = 0;
    DWORD  dwBufferSize = 0;
    LPSTR szVerb = GetVerb();

    //
    // BUGBUG: move this into GetAdditionalHeader
    //
    if (_fRedirected == TRUE || (_cbProxyAuthenticate + _cbAuthenticate))
    {
        if (_pszSendHeader)
        {
            delete _pszSendHeader;
            _pszSendHeader = NULL;
        }

    }

    if (_fRedirected == FALSE && !(_cbProxyAuthenticate + _cbAuthenticate))
    {
        GetAdditionalHeader();
    }

    if (_fRedirected == FALSE || _fP2PRedirected )
    {
        // Note: the buffer returned here will be freed
        // by the destructor
        GetDataToSend(&pBuffer, &dwBufferSize);
        _fP2PRedirected = FALSE;
    }

    // Call HttpNeg only the first time in case of authentication
    // i.e. both Auth counts == 0 ?
    if (!(_cbAuthenticate || _cbProxyAuthenticate))     {
        //BUGBUG: does BeginingTrans need to be called for
        // redirect and authentication resends?
        if (_fRedirected == FALSE)
            hr = HttpNegBeginningTransaction();
        // Note: the header is appended to the AddHeader
    }

    HttpNegGetRootSecurityId();
    LONG lThirdParty;
    if (IsThirdPartyUrl(GetUrl()))
    {
        lThirdParty = 1;
        //MessageBoxW( 0, GetUrl(), L"cnethttp: THIRDPARTY!", 0 );
        InternetSetOption(_hRequest, INTERNET_OPTION_COOKIES_3RD_PARTY, &lThirdParty, sizeof(LONG));
    }
    else
    {
        lThirdParty = 0;
        //MessageBoxW( 0, GetUrl(), L"cnethttp: NOT THIRDPARTY!", 0 );
        InternetSetOption(_hRequest, INTERNET_OPTION_COOKIES_3RD_PARTY, &lThirdParty, sizeof(LONG));
    }    
    
    if (hr == E_ABORT)
    {
        _hrError = hr;
        SetBindResult(ERROR_CANCELLED,hr);
    }
    else
    {
        PerfDbgLog1(tagCINetHttp, this, "+CINetHttp::INetAsyncSendRequest HttpSendRequest (_pszSendHeader:%s)", XDBG(_pszSendHeader,""));

        if (GetBindInfo()->dwBindVerb == BINDVERB_POST && !_f2ndCacheKeySet)
        {
            // WININET request: send SECONDARY_CACHE_KEY only once
            ULONG ulCount = 0;
            LPWSTR pwzPostCookieStr = 0;
            HRESULT hr1 = _pOIBindInfo->GetBindString(BINDSTRING_POST_COOKIE, (LPWSTR *)&pwzPostCookieStr, 1, &ulCount);
            if ((hr1 == NOERROR) && pwzPostCookieStr)
            {
                // BUGBUG: trident return s_ok and no string
                PProtAssert((pwzPostCookieStr));
                LPSTR pszStr = DupW2A(pwzPostCookieStr);
                if (pszStr)
                {
                    _f2ndCacheKeySet = TRUE;
                    InternetSetOption(_hRequest, INTERNET_OPTION_SECONDARY_CACHE_KEY, pszStr, strlen(pszStr));
                    delete pszStr;
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                    _hrError = INET_E_DOWNLOAD_FAILURE;
                    SetBindResult(hr,hr);
                }
                delete pwzPostCookieStr;
            }

        }

        /************ enable this after wininet sniff checked in *******
        // set option for data sniff
        DWORD dwDataSniff = 1;
        InternetSetOption(_hRequest, INTERNET_OPTION_DATASNIFF, &dwDataSniff, sizeof(DWORD));
        ****************************************************************/

        InternetSetOption(_hRequest, INTERNET_OPTION_REQUEST_PRIORITY, &_nPriority, sizeof(LONG));

        if (_fRedirected || !_fUTF8hack)
        {
            /*
                This is used in wininet now only to convert the MBCS servername supplied to UTF8
                to send to the proxy if needed
             */
            InternetSetOption(_hRequest, INTERNET_OPTION_CODEPAGE, &_BndInfo.dwCodePage, sizeof(DWORD));
        }
        
        SetStatePending(E_PENDING);

        if (hr == NOERROR)
        {
            if (IsUpLoad())
            {
                // post verb
                // DWORD dwSendFlags = HSR_ASYNC | HSR_CHUNKED | HSR_INITIATE;
                DWORD dwSendFlags = HSR_CHUNKED | HSR_INITIATE;
                DWORD dwSendContext = 0;

                if (!_pStm)
                {
                    BINDINFO *pBI = GetBindInfo();
                    if (pBI && pBI->stgmedData.tymed == TYMED_ISTREAM)
                            {
                        _pStm = pBI->stgmedData.pstm;
                    }
                }
                if (_pStm)
                {
                    hr = GetNextSendBuffer(&_inetBufferSend,_pStm, TRUE);
                }

                fRet = HttpSendRequestExA(
                          _hRequest               // IN HINTERNET hRequest,
                         ,&_inetBufferSend         // IN LPINTERNET_BUFFERSA lpBuffersIn OPTIONAL,
                         , NULL                   // OUT lpBuffersOut not used
                         ,dwSendFlags             // IN DWORD dwFlags,
                         ,dwSendContext           // IN DWORD dwContext
                            );
            }
            else
            {
                DWORD dwError;

                // Allow ERROR_INTERNET_INSERT_CDROM to be returned from HttpSendRequest
#ifdef MSNJIT
                DWORD dwErrorMask = INTERNET_ERROR_MASK_INSERT_CDROM | INTERNET_ERROR_MASK_COMBINED_SEC_CERT | INTERNET_ERROR_MASK_NEED_MSN_SSPI_PKG;
#else                
                DWORD dwErrorMask = INTERNET_ERROR_MASK_INSERT_CDROM | INTERNET_ERROR_MASK_COMBINED_SEC_CERT;
#endif                
                dwErrorMask = dwErrorMask | INTERNET_ERROR_MASK_LOGIN_FAILURE_DISPLAY_ENTITY_BODY;

                InternetSetOption(_hRequest, INTERNET_OPTION_ERROR_MASK, &dwErrorMask, sizeof(DWORD));

                fRet = HttpSendRequest(_hRequest,
                       _pszSendHeader,                     // additional headers
                       (_pszSendHeader) ? (ULONG)-1L : 0L, // size of additional headers data
                       pBuffer,                            // Optional data (POST or put)
                       dwBufferSize);                      // optional data length

                PerfDbgLog(tagCINetHttp, this, "-CINetHttp::INetAsyncSendRequest HttpSendRequest");

            }   // end else

            if (fRet == FALSE)
            {
                dwLstError = GetLastError();
                if (dwLstError == ERROR_IO_PENDING)
                {
                    // wait async for the handle
                    hr = E_PENDING;
                }
                else if (dwLstError == ERROR_INTERNET_INSERT_CDROM)
                {
                    _hrINet = INET_E_AUTHENTICATION_REQUIRED;
                    _dwSendRequestResult = ERROR_INTERNET_INSERT_CDROM;
                    _lpvExtraSendRequestResult = NULL;
                    TransitState(INetState_DISPLAY_UI, TRUE);
                    hr = E_PENDING;
                    fRet = TRUE;
                }
                else
                {
                    SetStatePending(NOERROR);
                    hr = _hrError = INET_E_DOWNLOAD_FAILURE;
                    SetBindResult(dwLstError,hr);
                    PerfDbgLog3(tagCINetHttp, this, "CINetHttp::INetAsyncSendRequest (fRet:%d, _hrError:%lx, LstError:%ld)", fRet, _hrError, dwLstError);
                }
            }
            else
            {
                SetStatePending(NOERROR);

                // in case of redirect, we need to reset all the
                // _dwSendRequestResult from previous callback
                _dwSendRequestResult = 0;
                _lpvExtraSendRequestResult = NULL;
                hr = INetQueryInfo();
            }
        }
    }


    if (_hrError != INET_E_OK)
    {
        // we need to terminate here
        ReportResultAndStop(hr);
    }

    PerfDbgLog1(tagCINetHttp, this, "-CINetHttp::INetAsyncSendRequest (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINetHttp::QueryStatusOnResponse
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    2-06-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINetHttp::QueryStatusOnResponse()
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINetHttp::QueryStatusOnResponse",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCINetHttp, this, "+CINetHttp::QueryStatusOnResponse");
    HRESULT hr = NOERROR;

    DWORD dwStatus;
    char szBuffer[max(2 * MAX_URL_SIZE, 400)];
    DWORD cbBufferLen = sizeof(szBuffer);
    DWORD cbLen = cbBufferLen;

    if (_dwSendRequestResult)
    {
        // handle the sendrequest result
        // zone crossing
        switch (_dwSendRequestResult)
        {
        case ERROR_INTERNET_SEC_CERT_DATE_INVALID     :
        case ERROR_INTERNET_SEC_CERT_CN_INVALID       :
        case ERROR_INTERNET_HTTP_TO_HTTPS_ON_REDIR    :
        case ERROR_INTERNET_HTTPS_TO_HTTP_ON_REDIR    :
        case ERROR_INTERNET_HTTPS_HTTP_SUBMIT_REDIR   :
        case ERROR_HTTP_REDIRECT_NEEDS_CONFIRMATION   :
        case ERROR_INTERNET_INVALID_CA                :
        case ERROR_INTERNET_CLIENT_AUTH_CERT_NEEDED   :
        case ERROR_INTERNET_FORTEZZA_LOGIN_NEEDED     :
        case ERROR_INTERNET_SEC_CERT_ERRORS           :
        case ERROR_INTERNET_SEC_CERT_REV_FAILED       :
        case ERROR_INTERNET_SEC_CERT_REVOKED          :
        {
            hr = HttpSecurity(_dwSendRequestResult);

            if ((hr != NOERROR) && (hr != E_PENDING))
            {
                _hrError = INET_E_AUTHENTICATION_REQUIRED;
            }
            else
            {
                _hrError = INET_E_OK;
            }

        }
        break;

        case ERROR_INTERNET_LOGIN_FAILURE_DISPLAY_ENTITY_BODY :
        {
            _hrError = INET_E_OK;
            hr = NOERROR; 
        }
        break;

#ifdef MSNJIT        
        case ERROR_INTERNET_NEED_MSN_SSPI_PKG     :
        {
            const GUID MSN_AUTH_GUID = 
            { 0x6fab99d0, 0xbab8, 0x11d1, {0x99, 0x4a, 0x00, 0xc0, 0x4f, 0x98, 0xbb, 0xc9} };

            HWND hWnd = NULL;
            DWORD dwJITFlags = 0;
            
            uCLSSPEC classpec;
            classpec.tyspec=TYSPEC_TYPELIB;
            classpec.tagged_union.typelibID = (GUID)MSN_AUTH_GUID;

            QUERYCONTEXT qc;
            memset(&qc, 0, sizeof(qc));

            // fill in the minimum version number of the component you need
            //qc.dwVersionHi = 
            //qc.dwVersionLo = 
            hr = FaultInIEFeature(hWnd, &classpec, &qc, dwJITFlags);

            if (hr == S_OK)
            {
                hr = INET_E_AUTHENTICATION_REQUIRED;
            }
            else 
            {
                hr = E_ABORT;
            }
        }

        break;
#endif
        default:
        break;
        }

    }
    else if (HttpQueryInfo(_hRequest, HTTP_QUERY_STATUS_CODE, szBuffer,&cbLen, NULL))
    {
        dwStatus = atoi(szBuffer);
        _fProxyAuth = FALSE;
        switch (dwStatus)
        {
        case HTTP_STATUS_DENIED:
        {
            _hrINet = INET_E_AUTHENTICATION_REQUIRED;
            TransitState(INetState_AUTHENTICATE, TRUE);
            hr = E_PENDING;
        }
        break;
        case HTTP_STATUS_PROXY_AUTH_REQ :
        {
            _hrINet = INET_E_AUTHENTICATION_REQUIRED;
            TransitState(INetState_AUTHENTICATE, TRUE);
            _fProxyAuth = TRUE;
            hr = E_PENDING;
        }
        break;
        case HTTP_STATUS_MOVED:
        case HTTP_STATUS_REDIRECT:
        case HTTP_STATUS_REDIRECT_METHOD:
        case HTTP_STATUS_REDIRECT_KEEP_VERB:
        {
            cbLen = cbBufferLen;
            hr = RedirectRequest(szBuffer, &cbLen, dwStatus);
            if ((hr != S_FALSE) &&  (hr != NOERROR) && (hr != E_PENDING))
            {
                _hrError = INET_E_INVALID_URL;
            }
            else
            {
                _hrError = INET_E_OK;
                hr = S_FALSE;
                SetINetState(INetState_DONE);
            }
        }
        break;
        case HTTP_STATUS_NO_CONTENT:
        {
            BINDINFO *pBndInfo = GetBindInfo();

            if (pBndInfo && pBndInfo->dwBindVerb != BINDVERB_CUSTOM)
            {
                hr = _hrError = E_ABORT;
                SetBindResult(ERROR_CANCELLED, hr);
            }
            else
            {
                hr = QueryStatusOnResponseDefault(dwStatus);
            }
        }
        break;
        default:
        {
            hr = QueryStatusOnResponseDefault(dwStatus);
        }
        break;
        }
    }

    if (_hrError != INET_E_OK)
    {
        SetINetState(INetState_DONE);
    }

    PerfDbgLog1(tagCINetHttp, this, "-CINetHttp::QueryStatusOnResponse (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINetHttp::QueryStatusOnResponseDefault
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    2-06-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINetHttp::QueryStatusOnResponseDefault(DWORD dwStat)
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINetHttp::QueryStatusOnResponseDefault",
                "this=%#x, %#x",
                this, dwStat
                ));
                
    PerfDbgLog(tagCINetHttp, this, "+CINetHttp::QueryStatusOnResponseDefault");
    HRESULT hr = NOERROR;

    DWORD dwStatus = 0;
    char szBuffer[max(2 * MAX_URL_SIZE, 400)];
    DWORD cbBufferLen = sizeof(szBuffer);
    DWORD cbLen = cbBufferLen;

    if( !dwStat )
    {
        if (HttpQueryInfo(_hRequest, HTTP_QUERY_STATUS_CODE, szBuffer,&cbLen, NULL))
        {
            dwStatus = atoi(szBuffer);
        }
    }
    else
    {
        dwStatus = dwStat;
    }

    if( dwStatus )
    {
        #if DBG==1
        if ( !((dwStatus >= HTTP_STATUS_OK) && (dwStatus <= HTTP_STATUS_GATEWAY_TIMEOUT)) )
        {
            DbgLog1(DEB_PROT|DEB_TRACE, this, "CINetHttp::QueryStatusOnResponse (dwStatus:%lx)", dwStatus);
        }
        PProtAssert((   (dwStatus >= HTTP_STATUS_BEGIN) && (dwStatus <= HTTP_STATUS_END)
                         && L"WinINet returned an invalid status code: please contact a WININET developer" ));
        #endif //DBG==1

        // check if we got redirected from a file to a directory
        {
            cbLen = cbBufferLen;
            InternetQueryOption(_hRequest, INTERNET_OPTION_URL, szBuffer, &cbLen);
            if (cbLen)
            {
                BOOL fRedirected;
                fRedirected = strcmp(szBuffer, _pszFullURL);

                if (fRedirected)
                {
                    cbLen = cbBufferLen;
                    hr = RedirectRequest(szBuffer, &cbLen, dwStatus);

                    if ((hr != NOERROR) && (hr != E_PENDING))
                    {
                        if (hr != INET_E_DOWNLOAD_FAILURE)
                        {
                            _hrError = INET_E_INVALID_URL;
                        }
                    // else set nothing
                    }
                    else
                    {
                        _hrError = INET_E_OK;
                    }
                }
            }
        }

        cbLen = cbBufferLen;
        
        BOOL fRet = HttpQueryInfo(_hRequest, HTTP_QUERY_RAW_HEADERS_CRLF, szBuffer,&cbLen, NULL);
        BOOL fDeleteBuffer = FALSE;
        LPSTR lpszBuffer;
        
        if (!fRet)
        {
            DWORD dwError = GetLastError();

            if (dwError == ERROR_INSUFFICIENT_BUFFER)
            {
                lpszBuffer = new char[cbLen];
                if (!lpszBuffer)
                {
                    hr = E_OUTOFMEMORY;
                    goto End;
                }
                fDeleteBuffer = TRUE;
                fRet = HttpQueryInfo(_hRequest, HTTP_QUERY_RAW_HEADERS_CRLF, lpszBuffer, &cbLen, NULL);
            }
        }
        else
            lpszBuffer = szBuffer;

        if (fRet)
        {
            if (IsStatusOk(dwStatus))
            {
                hr = HttpNegOnHeadersAvailable(dwStatus, lpszBuffer);
            }
            else
            {
                hr = ErrorHandlingRequest(dwStatus, lpszBuffer);
                if ((hr != NOERROR) && (hr != E_PENDING))
                {
                    _hrError = hr;
                }
                else
                {
                    _hrError = INET_E_OK;
                }
            }
            
            if (hr == E_ABORT)
            {
                SetBindResult(ERROR_CANCELLED,hr);
            }
        }

        if (fDeleteBuffer)
            delete lpszBuffer;
    }
    
End:
    PerfDbgLog1(tagCINetHttp, this, "-CINetHttp::QueryStatusOnResponseDefault (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CINetHttp::QueryHeaderOnResponse
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    2-06-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINetHttp::QueryHeaderOnResponse()
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINetHttp::QueryHeaderOnResponse",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCINetHttp, this, "+CINetHttp::QueryHeaderOnResponse");
    HRESULT hr = NOERROR;
    DWORD dwStatus;
    char szBuffer[max(2 * MAX_URL_SIZE, 400)];
    DWORD cbBufferLen = sizeof(szBuffer);
    DWORD dwFlags;
    char szMIMEType[SZMIMESIZE_MAX] = "";
    char szENCType[SZMIMESIZE_MAX] = "";
    BOOL fContentDisp = FALSE;

    // Get file length
    if(HttpQueryInfo(_hRequest, HTTP_QUERY_CONTENT_LENGTH, szBuffer,&cbBufferLen, NULL))
    {
        _cbDataSize = atoi(szBuffer);
    }

    // Get Content-Disposition
    szBuffer[0] = '\0';
    cbBufferLen = sizeof(szBuffer);

    if(HttpQueryInfo(
            _hRequest,
            HTTP_QUERY_CONTENT_DISPOSITION,
            szBuffer,
            &cbBufferLen,
            NULL) )
    {
        // Search for :Attachment, if found, report it
        if( StrStrI(szBuffer, vszAttachment) )
        {
            char  szName[MAX_PATH];
            char *pName = NULL;

            // propogate the filename if available
            if( StrStrI(szBuffer, vszFileName) )
            {
                DWORD cbNameLen;

                szName[0] = '\0';
                cbNameLen = sizeof(szName);

                if(InternetQueryOption(_hRequest, INTERNET_OPTION_DATAFILE_NAME, szName, &cbNameLen))
                    pName = PathFindFileName(szName);
            }

            ReportNotification(BINDSTATUS_CONTENTDISPOSITIONATTACH, (pName?pName:NULL));
        }
        
        if( StrStrI(szBuffer, vszFileName) )
        {
            fContentDisp = TRUE;
        }
    }

    // Get Accept-Ranges 
    szBuffer[0] = '\0';
    cbBufferLen = sizeof(szBuffer);
    if(HttpQueryInfo(
            _hRequest,
            HTTP_QUERY_ACCEPT_RANGES,
            szBuffer,
            &cbBufferLen,
            NULL) )
    {
        ReportNotification(BINDSTATUS_ACCEPTRANGES, NULL);
    }

    // mimetype
    cbBufferLen = sizeof(szMIMEType);
    szMIMEType[0] = 0;
    HttpQueryInfo(_hRequest, HTTP_QUERY_CONTENT_TYPE, szMIMEType, &cbBufferLen, NULL);
    if (cbBufferLen && (szMIMEType[0] != 0))
    {
        //BUG-WORK
        //_pCTransData->SetMimeType(szMIMEType);
        //_pCTrans->ReportProgress();
        DbgLog1(DEB_PROT|DEB_TRACE, this,
                "CINetHttp::QueryHeaderOnResponse MIME TYPE(szMime:%s)!",
                szMIMEType);

        // work around image display problem, turn off report mime type
        // for direct binding
        if( _grfBindF & BINDF_FROMURLMON)
        {
            ReportNotification(BINDSTATUS_MIMETYPEAVAILABLE,szMIMEType);
        }
        else
        {
            ReportNotification(BINDSTATUS_RAWMIMETYPE, szMIMEType);
        }

        /*** enable this block after wininet data sniff checked in ****
        if( _cbDataSize )
        {

            // datasniff enabled ?
            DWORD dwDataSniff = 0;
            DWORD dwSize = sizeof(DWORD);

            if( InternetQueryOption(
                    _hRequest,
                    INTERNET_OPTION_DATASNIFF,
                    &dwDataSniff,
                    &dwSize ) )

            {
                char szVCType[SZMIMESIZE_MAX] = "";
                cbBufferLen = SZMIMESIZE_MAX;

                InternetQueryOption(
                    _hRequest,
                    INTERNET_OPTION_VERIFIED_CONTENT_TYPE,
                    szVCType,
                    &cbBufferLen );

            }
        }
        ****************************************************************/
    }
    else
    {
        DbgLog1(DEB_PROT|DEB_TRACE, this,
                "CINetHttp::QueryHeaderOnResponse NO MIME TYPE (szUrl:%s)!",
                GetBaseURL());
        //BUGBUG: need data sniffing later on
        //_pCTransData->SetMimeType("text/html");
        // work around image display problem, turn off report mime type
        // for direct binding
        if( _grfBindF & BINDF_FROMURLMON)
        {
            ReportNotification(BINDSTATUS_MIMETYPEAVAILABLE,"text/html");
        }
    }

    // content encoding
    HttpQueryInfo(_hRequest, HTTP_QUERY_CONTENT_ENCODING, szENCType, &cbBufferLen, NULL);
    if (cbBufferLen && (szENCType[0] != 0))
    {
        DbgLog1(DEB_PROT|DEB_TRACE, this,
                "CINetHttp::QueryHeaderOnResponse ENCODING TYPE(szEnc :%s)!",
                szENCType);
        //
        // existing http servers may mishandle the content-encoding
        // header,  we have to taken care of the following cases:
        //
        // 1. we do not send Accept-Encoding header(http1.1 disabled),
        //    however, server sends back Content-Encoding: foo
        //    (_pszHeaders contains the accept-encoding info, so if
        //     this is null, we should not invoke the decoder )
        //
        // 2. we send Accept-Encoding: A, server sends back
        //    Content-Encoding: B, this is a protocol violation
        //    IgnoreContentEncoding() takes care of that, it compares
        //    the _pszHeader and szENCType, and we should not invoke
        //    the decoder if they are mis-matched
        //
        // 3. server sends out content-encoding, but what they really
        //    mean is that let the application (e.g. gunzip.exe) to
        //    handle the compressed file, we can add the check for
        //    content-type, for a list of content-type we do not
        //    understand (e.g. application/x-compress, x-world/x-vrml..)
        //    do not invoke the decoder
        //

        //    Wininet changes http version if http1.1 over proxy is disabled.
        //    This happens only after httpSendRequest is called, which is when
        //    Urlmon might have passed in the Accept-Encoding headers.
        //    If we did pass in the headers, we need to make sure that they 
        //    were not stripped out because wininet finally used Http 1.0.
        
        if( _pszHeader && !RequestUsedHttp10(_hRequest) &&    
            !IgnoreContentEncoding(szMIMEType, szENCType, _pszHeader) )
        {
            ReportNotification(BINDSTATUS_ENCODING, szENCType);

            // Load The decompression handler now...
            COInetSession       *pCOInetSession = NULL;
            IOInetProtocol      *pProtHandler = NULL;
            IOInetProtocolSink  *pProtSnkHandler = NULL;
            IOInetBindInfo      *pBindInfo = NULL;
            LPWSTR              pwzStr = DupA2W(szENCType);
            CLSID               clsid;

            hr = GetCOInetSession(0,&pCOInetSession,0);
            if( hr == NOERROR )
            {
                hr = pCOInetSession->CreateHandler(
                    pwzStr, 0, 0, &pProtHandler, &clsid);

                if( hr == NOERROR )
                {
                    hr = pProtHandler->QueryInterface(
                        IID_IOInetProtocolSink, (void **) &pProtSnkHandler);


                    //hr = QueryInterface(
                    //    IID_IOInetBindInfo, (void **) &pBindInfo);
                }

                if( hr == NOERROR )
                {
                    HRESULT hr2 = NOERROR;
                    hr2 = _pEmbdFilter->SwitchSink(pProtSnkHandler);
                    if( hr2 == NOERROR )
                    {
                        hr = _pEmbdFilter->StackFilter(
                            pwzStr, pProtHandler, pProtSnkHandler, _pOIBindInfo );
                    }
                }

                if( pBindInfo )
                {
                    pBindInfo->Release();
                }
            }

            if( szMIMEType[0] != '\0' )
            {
                ReportNotification(BINDSTATUS_MIMETYPEAVAILABLE,szMIMEType);
            }

            if(fContentDisp)
            {
                // Get Content-Disposition
                szBuffer[0] = '\0';
                cbBufferLen = sizeof(szBuffer);

                if(InternetQueryOption(_hRequest, INTERNET_OPTION_DATAFILE_NAME, szBuffer, &cbBufferLen))
                {
                    ReportNotification(BINDSTATUS_CONTENTDISPOSITIONATTACH, PathFindFileName(szBuffer));
                }
            }
            // urlmon will create a decompressed cache-file, so we should not
            // report the compressed file name to the client.
            _fFilenameReported = TRUE;

            if (pwzStr)
            {
                delete pwzStr;
            }
        }
    }

#ifdef TEST_STACK_FILTER_ONE
    //test for stackable filter..
    //need to include mft.hxx for sample implementation of the filter
    {
        IOInetProtocol* pFilter = (IOInetProtocol*) new CMft;
        IOInetProtocolSink* pFilterSink = NULL;
        pFilter->QueryInterface(
            IID_IOInetProtocolSink, (void**)&pFilterSink);

        // connect the last filter sink with pFilter's Sink
        HRESULT hr2 = NOERROR;
        hr2 = _pEmbdFilter->SwitchSink(pFilterSink);

        if( hr2 == NOERROR )
        {
            hr = _pEmbdFilter->StackFilter(NULL, pFilter, NULL, NULL);
        }

        // this object gets created here, pFilter gets AddRef'd during
        // the StackFilter(), we should release the additional Ref Count
        // here
        // this does not apply to the first filter stacked
        if( _pEmbdFilter->FilterStacked() > 1 )
        {
            pFilter->Release();
        }
    }
#endif

#ifdef TEST_STACK_FILTER_TWO
    {
        // another one...
        IOInetProtocol* pFilter_2 = (IOInetProtocol*) new CMft;
        IOInetProtocolSink* pFilterSink_2 = NULL;
        pFilter_2->QueryInterface(
            IID_IOInetProtocolSink, (void**)&pFilterSink_2);

        // connect the last filter sink with pFilter's Sink
        HRESULT hr3 = NOERROR;
        hr3 = _pEmbdFilter->SwitchSink(pFilterSink_2);

        if( hr3 == NOERROR )
        {
            hr = _pEmbdFilter->StackFilter(NULL, pFilter_2, NULL, NULL);
        }

        // this object gets created here, pFilter gets AddRef'd during
        // the StackFilter(), we should release the additional Ref Count
        // here
        // this does not apply to the first filter stacked
        if( _pEmbdFilter->FilterStacked() > 1 )
        {
            pFilter_2->Release();
        }
    }
#endif

    if (_hrError != INET_E_OK)
    {
        SetINetState(INetState_DONE);
        hr = S_FALSE;
    }

    PerfDbgLog2(tagCINetHttp, this, "-CINetHttp::QueryHeaderOnResponse (hr:%lx, _cbDataSize:%ld)", hr, _cbDataSize);

    DEBUG_LEAVE(hr);
    return hr;

}

//+---------------------------------------------------------------------------
//
//  Method:     CINetHttp::RedirectRequest
//
//  Synopsis:
//
//  Arguments:  [lpszBuffer] --
//              [pdwBuffSize] --
//
//  Returns:
//
//  History:    2-06-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINetHttp::RedirectRequest(LPSTR lpszBuffer, DWORD *pdwBuffSize, DWORD dwStatus)
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINetHttp::RedirectRequest",
                "this=%#x, %#x, %#x, %d",
                this, lpszBuffer, pdwBuffSize, dwStatus
                ));
                
    PerfDbgLog(tagCINetHttp, this, "+CINetHttp::RedirectRequest");
    HRESULT hr = INET_E_DOWNLOAD_FAILURE;

    char *pszHeader;
    DWORD cbBufferLen;
    BOOL fDeleteBuffer = FALSE;
    BOOL fRet = FALSE;
    
    // we assume when we get here that we have recieved a redirection
    // now we are going to see where we need to do the next send

    cbBufferLen = *pdwBuffSize;

    if (cbBufferLen <= strlen(vszLocationTag))
    {
        goto End;
    }
    strcpy(lpszBuffer, vszLocationTag);

    fRet = HttpQueryInfo(_hRequest, HTTP_QUERY_RAW_HEADERS, lpszBuffer,&cbBufferLen, NULL);

    if (!fRet)
    {
        DWORD dwError = GetLastError();

        if (dwError == ERROR_INSUFFICIENT_BUFFER)
        {
            lpszBuffer = new char[cbBufferLen];
            if (!lpszBuffer)
            {
                hr = E_OUTOFMEMORY;
                goto End;
            }
            fDeleteBuffer = TRUE;
            fRet = HttpQueryInfo(_hRequest, HTTP_QUERY_RAW_HEADERS, lpszBuffer, &cbBufferLen, NULL);
            dwError = GetLastError();
        }
    }    

    if (fRet)
    {
        LPSTR  pszRedirect = 0;
        pszHeader = FindTagInHeader(lpszBuffer, vszLocationTag);
        if (!pszHeader)
        {
            goto End;
        }

        //Bug 21294:  204 responses sometimes have Location: headers, which may not mean redirects.
        //To prevent a bogus redirection message, ensure that the comparison with wininet's url
        //is made after stripping username and password from the original url, since wininet returns
        //the url without these.
        //Don't make this check if it's one of the 3** or username/password not in url.
        if ((dwStatus < HTTP_STATUS_AMBIGUOUS) &&
            (_pszUserName[0] || _pszPassword[0]))
        {
            CHAR* szUrlmonUrl = new CHAR[INTERNET_MAX_URL_LENGTH];
            CHAR* szWininetUrl = new CHAR[INTERNET_MAX_URL_LENGTH];
            DWORD dwUrlmonSize = INTERNET_MAX_URL_LENGTH;
            DWORD dwWininetSize = INTERNET_MAX_URL_LENGTH;
            BOOL bIdentical = FALSE;
            URL_COMPONENTS url;
            
            if (!szUrlmonUrl || !szWininetUrl)
                goto deleteUrls;
                
            memset(&url, 0, sizeof(URL_COMPONENTS));
            
            url.dwStructSize = sizeof(url);
            url.lpszScheme = _pszProtocol;
            url.lpszHostName = _pszServerName;
            url.lpszUrlPath = _pszObject;
            url.nPort = _ipPort;

            if (InternetCreateUrl(&url, 0, szUrlmonUrl, &dwUrlmonSize) &&
                InternetQueryOption(_hRequest, INTERNET_OPTION_URL, szWininetUrl, &dwWininetSize))
            {
                if ((dwUrlmonSize == dwWininetSize)
                    && !strcmp(szUrlmonUrl, szWininetUrl))
                {
                    bIdentical = TRUE;
                }
                
                DEBUG_ENTER((DBG_APP,
                            Bool,
                            "CINetHttp::RedirectRequestComparison",
                            "this=%#x, %.80q, %d, %.80q, %d",
                            this, szUrlmonUrl, dwUrlmonSize, szWininetUrl, dwWininetSize
                            ));
                            
                DEBUG_LEAVE(bIdentical);
            }
            
            deleteUrls:
            if (szUrlmonUrl)
                delete [] szUrlmonUrl;
            if (szWininetUrl)
                delete [] szWininetUrl;

            if (bIdentical)
                goto End;
        }

        if (dwStatus < HTTP_STATUS_AMBIGUOUS)
        {
            //Bug 33662: Location: headers are only allowed to be absolute URIs
            //check for relative URI and, if found, pretend doesn't exist for 2** status codes.
            
            char* pszHostname = new char[MAX_URL_SIZE];
            DWORD dwHostname = MAX_URL_SIZE;
            HRESULT hrTemp;

            if (!pszHostname)
            {
                hr = E_OUTOFMEMORY;
                goto End;
            }
            hrTemp = UrlGetPartA(pszHeader + strlen(vszLocationTag), pszHostname, &dwHostname, URL_PART_HOSTNAME, 0);

            delete [] pszHostname;
            
            if (FAILED(hrTemp))
            {
                //this is a relative URI since hostname couldn't be found.
                //hr remains INET_E_DOWNLOAD_FAILURE
                goto End;
            }
        }
        
        //
        // _pszPartURL get allocated here!
        //
        if( _pszPartURL )
        {
            delete [] _pszPartURL;
            _pszPartURL = NULL;
        }

        DWORD dwPartUrlLen = strlen( (pszHeader + strlen(vszLocationTag) ) );
        if( dwPartUrlLen > MAX_URL_SIZE)
        {
            hr = INET_E_DOWNLOAD_FAILURE;
            goto End;
        }

        _pszPartURL = new char[dwPartUrlLen + 1];
        if( !_pszPartURL )
        {
            hr = E_OUTOFMEMORY;
            goto End;
        }

        strcpy(_pszPartURL, pszHeader + strlen(vszLocationTag));

        DbgLog1(DEB_PROT|DEB_TRACE, this, "=== CINetHttp::RedirectRequest (Location:%s)", _pszPartURL);

        _fRedirected = TRUE;
        hr = S_FALSE;

        if (!ParseUrl())
        {
            pszRedirect = _pszPartURL;
        }
        else
        {
            pszRedirect = _pszFullURL;
        }

        PProtAssert((pszRedirect));
        ReportResultAndStop(INET_E_REDIRECTING, 0, 0, DupA2W(pszRedirect));
    }
End:
    if (fDeleteBuffer)
        delete lpszBuffer;
        
    PerfDbgLog1(tagCINetHttp, this, "-CINetHttp::RedirectRequest(hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CINetHttp::ErrorHandlingRequest
//
//  Synopsis:
//
//  Arguments:  [dwstatus] --
//              [szBuffer] --
//
//  Returns:
//
//  History:    2-28-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINetHttp::ErrorHandlingRequest(DWORD dwStatus, LPSTR szBuffer)
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINetHttp::ErrorHandlingRequest",
                "this=%#x, %#x, %.80q",
                this, dwStatus, szBuffer
                ));
                
    PerfDbgLog1(tagCINetHttp, this, "+CINetHttp::ErrorHandlingRequest (dwStatus:%ld)", dwStatus);
    HRESULT hr = NOERROR;

    PProtAssert((szBuffer));
    hr = HttpNegOnError(dwStatus,szBuffer);

    if (hr == E_RETRY)
    {
        _hrINet = NOERROR;
        hr = INetAsyncSendRequest();
    }
    else if (hr == E_ABORT)
    {
        _hrINet = E_ABORT;
    }
    else if (hr == S_FALSE)
    {
        // the error was not handled - stop download
        _hrINet = hr = HResultFromHttpStatus(dwStatus);
    }
    else
    {
        _hrINet = hr;
    }

    PerfDbgLog1(tagCINetHttp, this, "-CINetHttp::ErrorHandlingRequest(hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CINetHttp::GetVerb
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    2-05-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
LPSTR CINetHttp::GetVerb()
{
    DEBUG_ENTER((DBG_APP,
                String,
                "CINetHttp::GetVerb",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCINetHttp, this, "+CINetHttp::GetVerb");
    LPSTR pszRes = vszGet;

    if (_fRedirected == TRUE)
    {
        // for HTTP 1.1, we have to check if this is an POST->POST redirect
        INTERNET_VERSION_INFO   httpVersion;
        DWORD                   dwBufferSize = sizeof(INTERNET_VERSION_INFO);
        if(    InternetQueryOption( _hRequest, INTERNET_OPTION_HTTP_VERSION, &httpVersion, &dwBufferSize )
            && httpVersion.dwMajorVersion >= 1
            && httpVersion.dwMinorVersion >= 1 )
        {
            CHAR    szVerb[16];
            DWORD   dwIndex;
            DWORD   dwLength = sizeof(szVerb);
            if(    HttpQueryInfo(_hRequest, HTTP_QUERY_REQUEST_METHOD, szVerb, &dwLength, &dwIndex)
                && !lstrcmp(szVerb, vszPost) )
            {
                // HACK HACK HACK !!
                // Double check the status code to see if this is a real POST
                // there is a HttpQueryInfo() bug which will send verb=POST
                // on a POST->GET Redirect
                //

                DWORD dwStatus = 0;
                if (   HttpQueryInfo(
                           _hRequest,
                           HTTP_QUERY_STATUS_CODE | HTTP_QUERY_FLAG_NUMBER,
                           &dwStatus ,&dwLength, NULL)
                    && dwStatus == HTTP_STATUS_REDIRECT_KEEP_VERB )
                {
                    _fP2PRedirected = TRUE;
                    pszRes = vszPost;
                }
            }
        }
    }
    else
    {
        BINDINFO *pBndInfo = GetBindInfo();

        if (pBndInfo)
        {
            switch (pBndInfo->dwBindVerb)
            {
            case BINDVERB_GET      :
                pszRes = vszGet;
                break;
            case BINDVERB_POST     :
                pszRes = vszPost;
                break;
            case BINDVERB_PUT      :
                pszRes = vszPut;
                break;
            case BINDVERB_CUSTOM   :
                {
                    //BUGBUG: custom verb support
                    if (!_pszVerb && pBndInfo->szCustomVerb)
                    {
                        pszRes = _pszVerb = DupW2A(pBndInfo->szCustomVerb);
                    }
                    else if(_pszVerb)
                    {
                        pszRes = _pszVerb;
                    }
                }
                break;
            }
        }
    }

    PerfDbgLog1(tagCINetHttp, this, "-CINetHttp::GetVerb (szRes:%s)", pszRes);

    DEBUG_LEAVE(pszRes);
    return pszRes;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINetHttp::GetAdditionalHeader
//
//  Synopsis:
//
//  Arguments:  [ppszRes] --
//              [pdwSize] --
//
//  Returns:
//
//  History:    2-05-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINetHttp::GetAdditionalHeader()
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINetHttp::GetAdditionalHeader",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCINetHttp, this, "+CINetHttp::GetAdditionalHeader");

    DWORD dwSizeData = 0;
    DWORD dwSizeHeader = 0;
    LPSTR szLocal;

    szLocal = g_pszUAInfoString;

    dwSizeHeader += strlen(szLocal);

    ULONG   dwSizeEncHeader = 0;

    PProtAssert((_pOIBindInfo));
    // only send Accept-Encoding header with HTTP 1.1 or higher
    INTERNET_VERSION_INFO   httpVersion;
    DWORD                   dwBufferSize = sizeof(INTERNET_VERSION_INFO);
    if(     _hRequest
         && _pOIBindInfo
         && InternetQueryOption( _hRequest, INTERNET_OPTION_HTTP_VERSION, &httpVersion, &dwBufferSize )
         && httpVersion.dwMajorVersion >= 1
         && httpVersion.dwMinorVersion >= 1 )
    {
        dwSizeEncHeader = 1;
        dwSizeHeader += strlen(gszAcceptEncHeaders);
    }

    // delete the old header and allocate a new buffer
    if (_pszHeader)
    {
        delete _pszHeader;
        _pszHeader = 0;
    }

    if (dwSizeHeader || dwSizeEncHeader)
    {
        _pszHeader = new CHAR [dwSizeHeader + 1];
    }

    if (_pszHeader)
    {
        if (szLocal && szLocal[0] != 0)
        {
            strcat(_pszHeader, szLocal);
        }

        if( dwSizeEncHeader)
        {
            strcat(_pszHeader, gszAcceptEncHeaders);
        }
    }

    PerfDbgLog2(tagCINetHttp, this, "-CINetHttp::GetAdditionalHeader (pStr:>%s<, hr:%lx)", XDBG(_pszHeader,""), NOERROR);

    DEBUG_LEAVE(NOERROR);
    return NOERROR;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINetHttp::GetDataToSend
//
//  Synopsis:
//
//  Arguments:  [ppBuffer] --
//              [pdwSize] --
//
//  Returns:
//
//  History:    2-05-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINetHttp::GetDataToSend(LPVOID *ppBuffer, DWORD *pdwSize)
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINetHttp::GetDataToSend",
                "this=%#x, %#x, %#x",
                this, ppBuffer, pdwSize
                ));
                
    HRESULT hr = INET_E_DOWNLOAD_FAILURE;
    PerfDbgLog(tagCINetHttp, this, "+CINetHttp::GetDataToSend");

    *ppBuffer = NULL;
    *pdwSize  = 0;
    BINDINFO *pBndInfo = GetBindInfo();

    if (pBndInfo)
    {
        switch (pBndInfo->dwBindVerb)
        {
        default:
        case BINDVERB_CUSTOM   :
        case BINDVERB_POST     :
        case BINDVERB_PUT      :
        {
            if (pBndInfo->stgmedData.tymed == TYMED_HGLOBAL)
            {
                *ppBuffer = pBndInfo->stgmedData.hGlobal;
                *pdwSize = pBndInfo->cbstgmedData;
                hr = NOERROR;
            }
        }
        break;
        case BINDVERB_GET     :
        // nothing should be uploaded
        break;
        }
    }

    PerfDbgLog3(tagCINetHttp, this, "-CINetHttp::GetDataToSend (pBuffer:%lx, dwSize:%ld, hr:%lx)", *ppBuffer, *pdwSize, hr);

    DEBUG_LEAVE(hr);
    return hr;
}

HRESULT CINetHttp::HttpNegGetRootSecurityId()
{
    HRESULT hr = NOERROR;
    BYTE            bRootSID[MAX_SIZE_SECURITY_ID];

    if (_pbRootSecurityId == NULL)
    {
        if (_pHttpNeg2 == NULL)
        {
        /*
            if (_pHttpNeg == NULL)
                hr = QueryService(IID_IHttpNegotiate, (void **) &_pHttpNeg);
                
            if (!_pHttpNeg || (hr != NOERROR))
                goto End;
         */
            hr = QueryService(IID_IHttpNegotiate2, (void **) &_pHttpNeg2);
            if (!_pHttpNeg2)
            {
                _pbRootSecurityId = INVALID_P_ROOT_SECURITY_ID;
                goto End;
            }
        }

        _cbRootSecurityId = MAX_SIZE_SECURITY_ID;
        hr = _pHttpNeg2->GetRootSecurityId( bRootSID, &_cbRootSecurityId, 0 );

        if (FAILED(hr))
        {
            _pbRootSecurityId = INVALID_P_ROOT_SECURITY_ID;
            goto End;
        }
        
        if (_cbRootSecurityId <= 0)
            goto End;
            
        _pbRootSecurityId = new BYTE[_cbRootSecurityId];
        if (!_pbRootSecurityId)
            goto End;

        memcpy (_pbRootSecurityId, bRootSID, _cbRootSecurityId);
    }
    
End:
    return hr;
}    


//+---------------------------------------------------------------------------
//
//  Method:     CINetHttp::HttpNegBeginningTransaction
//
//  Synopsis:
//
//  Arguments:  [szURL] --
//              [DWORD] --
//              [dwReserved] --
//              [pszAdditionalHeaders] --
//
//  Returns:
//
//  History:    2-08-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINetHttp::HttpNegBeginningTransaction()
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINetHttp::HttpNegBeginningTransaction",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCINetHttp, this, "+CINetHttp::HttpNegBeginningTransaction");
    HRESULT hr = NOERROR;
    LPWSTR pwzAddHeaders = NULL;

    if (_pHttpNeg == NULL)
    {
        hr = QueryService(IID_IHttpNegotiate, (void **) &_pHttpNeg);
    }
    if (_pHttpNeg && (hr == NOERROR))
    {
        LPWSTR pwzUrl = GetUrl();
        LPWSTR pwzHeaders = NULL;
        DWORD dwlen = 0;
        if (_pszHeader)
        {
            dwlen = strlen(_pszHeader);
            pwzHeaders = new WCHAR [dwlen +1];
            if (pwzHeaders == NULL)
            {
                hr = E_OUTOFMEMORY;
                goto End;

            }
            A2W(_pszHeader, pwzHeaders,dwlen + 1);

        }

        PProtAssert((pwzUrl));
        hr = _pHttpNeg->BeginningTransaction(pwzUrl, pwzHeaders, NULL, &pwzAddHeaders);

        if (SUCCEEDED(hr) )
        {
            if (pwzAddHeaders)
            {
                // add the additional length
                dwlen += wcslen(pwzAddHeaders) * sizeof(WCHAR);
            }

            if (dwlen)
            {

                if (_pszSendHeader)
                {
                    if (strlen(_pszSendHeader) < (dwlen + 1))
                    {
                        // delete the old header
                        delete _pszSendHeader;
                        // allocate a new one
                        _pszSendHeader = new CHAR [dwlen + 1];
                    }
                }
                else
                {
                    _pszSendHeader = new CHAR [dwlen + 1];
                }

                if (_pszSendHeader)
                {
                    if ( pwzAddHeaders )
                    {
                        W2A(pwzAddHeaders, _pszSendHeader, dwlen + 1);

                        // append the original header
                        if (_pszHeader)
                        {
                            strcat(_pszSendHeader,_pszHeader);
                        }
                    }
                    else
                    {
                        // no additional header
                        strcpy(_pszSendHeader, _pszHeader);
                    }
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }

                // delete the wchar header
                if (pwzHeaders)
                {
                    delete pwzHeaders;
                }
            }
        }


    }
    else
    {
        PProtAssert((_pHttpNeg == NULL));
    }

End:

    // delete this buffer
    if (pwzAddHeaders)
    {
        delete pwzAddHeaders;
    }

    PerfDbgLog(tagCINetHttp, this, "-CINetHttp::HttpNegBeginningTransaction");

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINetHttp::HttpNegOnHeadersAvailable
//
//  Synopsis:
//
//  Arguments:  [dwResponseCode] --
//              [szHeaders] --
//
//  Returns:
//
//  History:    2-08-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINetHttp::HttpNegOnHeadersAvailable(DWORD dwResponseCode, LPSTR szResponseHeader)
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINetHttp::HttpNegOnHeadersAvailable",
                "this=%#x, %#x, %.80q",
                this, dwResponseCode, szResponseHeader
                ));
                
    PerfDbgLog2(tagCINetHttp, this, "+CINetHttp::HttpNegOnHeadersAvailable (dwResponseCode:%lx) (szResponseHeader:%s)", dwResponseCode, XDBG(szResponseHeader,""));
    HRESULT hr = NOERROR;

    PProtAssert((szResponseHeader != NULL));

    if (_pHttpNeg)
    {

        LPWSTR pwzResponseHeader;
        DWORD dwlen = strlen(szResponseHeader);

        pwzResponseHeader = new WCHAR [dwlen +1];
        if (pwzResponseHeader == NULL)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            PProtAssert((pwzResponseHeader));
            A2W(szResponseHeader, pwzResponseHeader, dwlen + 1);
            if( _pHttpNeg )
            {
                hr = _pHttpNeg->OnResponse(dwResponseCode, pwzResponseHeader,NULL ,NULL);
            }

            // the only valid return code is NOERROR
            PProtAssert((hr == NOERROR && "HttpNegotiate::OnHeaders returned ivalid hresult"));
            PProtAssert((pwzResponseHeader));

            delete pwzResponseHeader;
        }
    }

    PerfDbgLog1(tagCINetHttp, this, "-CINetHttp::HttpNegOnHeadersAvailable (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINetHttp::HttpNegOnError
//
//  Synopsis:
//
//  Arguments:  [dwResponseCode] --
//              [szResponseHeaders] --
//              [pszAdditionalRequestHeaders] --
//
//  Returns:
//
//  History:    2-08-96   JohannP (Johann Posch)   Created
//
//  Notes:      return S_FALSE as default - will stop download
//              and map to INET_E hresult
//----------------------------------------------------------------------------
HRESULT CINetHttp::HttpNegOnError(DWORD dwResponseCode, LPSTR szResponseHeader)
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINetHttp::HttpNegOnError",
                "this=%#x, %#x, %.80q",
                this, dwResponseCode, szResponseHeader
                ));
                
    PerfDbgLog(tagCINetHttp, this, "+CINetHttp::HttpNegOnError");
    HRESULT hr = S_FALSE;

    PProtAssert((szResponseHeader != NULL));

    if (_pHttpNeg)
    {
        LPWSTR pwzNewSendHeader = 0;
        LPWSTR pwzSendHeader = 0;
        LPWSTR pwzResponseHeader = 0;
        DWORD dwLenSendHeader = 0;
        DWORD dwLenResponseHeader = 0;

        if (_pszSendHeader)
        {
            dwLenSendHeader = strlen(_pszSendHeader);
            pwzSendHeader = new WCHAR [dwLenSendHeader + 1];
        }

        if (pwzSendHeader)
        {
            A2W(_pszSendHeader, pwzSendHeader, dwLenSendHeader + 1);
        }

        if (szResponseHeader)
        {
            dwLenResponseHeader = strlen(szResponseHeader);
            pwzResponseHeader = new WCHAR [dwLenResponseHeader + 1];
        }

        if (pwzResponseHeader)
        {
            A2W(szResponseHeader, pwzResponseHeader, dwLenResponseHeader + 1);
        }

        if( _pHttpNeg )
        {
            hr = _pHttpNeg->OnResponse(dwResponseCode, pwzResponseHeader,pwzSendHeader ,&pwzNewSendHeader);
        }

        if (pwzSendHeader)
        {
            delete pwzSendHeader;
            pwzSendHeader = 0;
        }

        if (pwzResponseHeader)
        {
            delete pwzResponseHeader;
            pwzResponseHeader = 0;
        }

        if ((hr == NOERROR) && (pwzNewSendHeader != NULL))
        {
            LPSTR pszNewSendHeader = 0;
            DWORD dwLen = wcslen(pwzNewSendHeader);
            DWORD dwLen1 = 0;
            if (_pszSendHeader)
            {
                dwLen1 = strlen(_pszSendHeader);
                PProtAssert((dwLen + dwLen1));

                pszNewSendHeader = new CHAR [dwLen + dwLen1 + 1];

                if (pszNewSendHeader)
                {
                    strcpy(pszNewSendHeader, _pszSendHeader);
                    W2A(pwzNewSendHeader,pszNewSendHeader + dwLen1, dwLen + 1);

                    // retry the call
                    hr = E_RETRY;
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
            }
            else
            {
                hr = S_FALSE;
            }
        }
        else
        {
            // we should not have headers
            PProtAssert((pwzNewSendHeader == NULL));
            if (pwzNewSendHeader)
            {
                delete pwzNewSendHeader;
            }
        }
    }
    else
    {
        // the error should be mapped to an INET_E hresult
        hr = S_FALSE;
    }

    PerfDbgLog1(tagCINetHttp, this, "-CINetHttp::HttpNegOnError (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINet::SecurityProblem
//
//  Synopsis:
//
//  Arguments:  [lpszBuffer] --
//              [pdwBuffSize] --
//
//  Returns:
//
//  History:    2-06-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINetHttp::HttpSecurity(DWORD dwProblem)
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINetHttp::HttpSecurity",
                "this=%#x, %#x",
                this, dwProblem
                ));
                
    PerfDbgLog(tagCINetHttp, this, "+CINetHttp::HttpSecurity");
    HRESULT hr = NOERROR;
    HWND hwnd;

    hr = HttpSecurityProblem(&hwnd, dwProblem);

    if (hr == NOERROR)
    {
        if (hwnd)
        {
            DWORD  dwBindF = GetBindFlags();
            DWORD dwFlags = (FLAGS_ERROR_UI_FLAGS_CHANGE_OPTIONS | FLAGS_ERROR_UI_FLAGS_GENERATE_DATA );

            if ((dwBindF & BINDF_NO_UI) || (dwBindF & BINDF_SILENTOPERATION))
            {
                dwFlags |= FLAGS_ERROR_UI_FLAGS_NO_UI;
            }


            DWORD dwError;

            if (SUCCEEDED(ZonesSecurityCheck(hwnd, dwProblem, &dwError)))
            {
                // dwError will be set by ZonesSecurityCheck.
            }
            else
            {
                dwError = InternetErrorDlg(hwnd, _hRequest, dwProblem, dwFlags,NULL);
            }

            switch (dwError)
            {
            case ERROR_CANCELLED :
                _hrINet = hr = E_ABORT;
                break;

            case ERROR_SUCCESS  :
                _hrINet = hr = E_RETRY;
                break;

            default:
                _hrINet = hr = E_ABORT;
                break;
            }
        }
        else
        {
            hr = INET_E_SECURITY_PROBLEM;
        }
    }
    else if (hr == E_ABORT)
    {
        _hrINet = E_ABORT;
    }

    if (hr == E_RETRY)
    {
        _hrINet = NOERROR;
        hr = INetAsyncSendRequest();
    }
    else if (hr == E_ABORT)
    {
        _hrINet = E_ABORT;
    }
    else if (hr != NOERROR )
    {
        // set the error to access denied
        _hrINet = hr = INET_E_SECURITY_PROBLEM;
    }

    PerfDbgLog1(tagCINetHttp, this, "-CINetHttp::HttpSecurity(hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINet::ZonesSecurityCheck
//
//  Synopsis:
//
//  Arguments:  [hwnd] --
//              [dwProblem] --
//              [pdwError] --
//
//  Returns:   SUCCESS if it was able to decide the action, INET_E_DEFAULT_ACTION otherwise.
//
//  History:    8-14-97   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

HRESULT CINetHttp::ZonesSecurityCheck(HWND hWnd, DWORD dwProblem, DWORD *pdwError)
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINetHttp::ZonesSecurityCheck",
                "this=%#x, %#x, %#x, %#x",
                this, hWnd, dwProblem, pdwError
                ));
                
    PerfDbgLog(tagCINetHttp, this, "+CINetHttp::HttpSecurity");
    HRESULT hr = INET_E_DEFAULT_ACTION;

    if (pdwError == NULL)
    {
        TransAssert(FALSE);

        DEBUG_LEAVE(E_INVALIDARG);
        return E_INVALIDARG;
    }

    // Right now the only error we check for is the redirect confirmation error.
    if (dwProblem == ERROR_HTTP_REDIRECT_NEEDS_CONFIRMATION ||
        dwProblem == ERROR_INTERNET_HTTPS_HTTP_SUBMIT_REDIR)
    {
        IInternetSecurityManager *pSecMgr = NULL;

        if (SUCCEEDED(CoCreateInstance(CLSID_InternetSecurityManager, NULL,
                        CLSCTX_INPROC_SERVER, IID_IInternetSecurityManager, (void **)&pSecMgr)))
        {
            char szUrl[MAX_URL_SIZE];
            WCHAR wzUrl[MAX_URL_SIZE];
            DWORD cbLen = MAX_URL_SIZE;
            DWORD dwPolicy;

            TransAssert(pSecMgr != NULL);

            InternetQueryOption(_hRequest, INTERNET_OPTION_URL, szUrl, &cbLen);

            // First check if the redirect is to the same server. If that is the 
            // case we don't need to warn because we already did the first time around.

            if (dwProblem == ERROR_HTTP_REDIRECT_NEEDS_CONFIRMATION)
            {
                URL_COMPONENTS uc = { 0 };

                uc.dwStructSize = sizeof(uc);
                uc.dwHostNameLength = 1;     // So we get back the host name. 

                if ( InternetCrackUrl(szUrl, 0, 0, &uc) && 
                      (StrCmpNI(uc.lpszHostName, GetServerName(), uc.dwHostNameLength) == 0)
                   )
                {
                    *pdwError = ERROR_SUCCESS;
                    hr = S_OK;
                }
            }
            
            if (hr == INET_E_DEFAULT_ACTION)             
            {
                // Convert to widechar so we can call the security manager. 
                MultiByteToWideChar(CP_ACP, 0, szUrl, -1, wzUrl, MAX_URL_SIZE);

                PARSEDURL pu;
                pu.cbSize = sizeof(pu);

                DWORD dwPUAflags = (GetBindFlags() & BINDF_ENFORCERESTRICTED) ? PUAF_ENFORCERESTRICTED : 0;
                
                if (SUCCEEDED(ParseURLA(szUrl, &pu)) && pu.nScheme == URL_SCHEME_HTTPS)
                {
                    // The forms submit zones policies are only supposed to apply to
                    // unencrypted posts. We will allow these to be posted silently.
                    *pdwError = ERROR_SUCCESS;
                    hr = S_OK ;
                }
                else if (SUCCEEDED(pSecMgr->ProcessUrlAction(wzUrl, URLACTION_HTML_SUBMIT_FORMS_TO,
                                (BYTE *)&dwPolicy, sizeof(dwPolicy), NULL, 0, dwPUAflags | PUAF_NOUI, 0)))
                {
                    DWORD dwPermissions = GetUrlPolicyPermissions(dwPolicy);
                    // If it is allow or deny don't call InternetErrorDlg, unless it is a encrypted to
                    // unencrypted redir in which case we still need to warn the user..
                    if (dwPermissions == URLPOLICY_ALLOW && dwProblem != ERROR_INTERNET_HTTPS_HTTP_SUBMIT_REDIR)
                    {
                        *pdwError = ERROR_SUCCESS;
                        hr = S_OK;
                    }
                    else if (dwPermissions == URLPOLICY_DISALLOW)
                    {
                        *pdwError = ERROR_CANCELLED;
                        hr = S_OK;
                    }
                }
            }

            pSecMgr->Release();
        }
    }

    PerfDbgLog1(tagCINetHttp, this, "-CINetHttp::ZonesSecurityCheck(hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINetHttp::HttpSecurityProblem
//
//  Synopsis:   QI's for HttpSecurity or IWindow
//
//  Arguments:  [phwnd] -- window handle for security dialog
//
//  Returns:    S_OK if dialog should be displayed
//
//  History:    2-08-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINetHttp::HttpSecurityProblem(HWND* phwnd, DWORD dwProblem)
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINetHttp::HttpSecurityProblem",
                "this=%#x, %#x, %#x",
                this, phwnd, dwProblem
                ));
                
    PerfDbgLog(tagCINetHttp, this, "+CINetHttp::HttpSecurityProblem");
    HRESULT hr = NOERROR;
    *phwnd = 0;

    if (_pHttSecurity == NULL)
    {
        hr = QueryService(IID_IHttpSecurity, (void **) &_pHttSecurity);
    }

    if ((hr == NOERROR) && _pHttSecurity)
    {
         hr = _pHttSecurity->OnSecurityProblem(dwProblem);
         if (hr == S_OK)
         {
             // client wants to continue
         }
         else if (hr == S_FALSE)
         {
             // client does not care
             hr = _pHttSecurity->GetWindow(IID_IHttpSecurity, phwnd);
             UrlMkAssert((   ((hr == S_FALSE) && (*phwnd == NULL))
                          || ((hr == NOERROR) && (*phwnd != NULL)) ));
         }
         else if (hr != E_ABORT)
         {
             UrlMkAssert((FALSE && "Invalid result on IHttSecurity->OnSecurityProblem"));
         }
    }
    else
    {
        if (_pWindow == NULL)
        {
            hr = QueryService(IID_IWindowForBindingUI, (void **) &_pWindow);
        }
        else
            hr = NOERROR; //We need to reset this hr, since we cached _pWindow

        if ((hr == NOERROR) && _pWindow)
        {
             hr = _pWindow->GetWindow(IID_IHttpSecurity, phwnd);
             UrlMkAssert((   (hr == S_FALSE) && (*phwnd == NULL)
                          || (hr == S_OK) && (*phwnd != NULL)));
        }
    }

    PerfDbgLog2(tagCINetHttp, this, "-CINetHttp::HttpSecurityProblem (hr:%lx, hwnd:%lx)", hr, *phwnd);

    DEBUG_LEAVE(hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CINetHttp::HResultFromInternetError
//
//  Synopsis:
//
//  Arguments:  [dwStatus] --
//
//  Returns:
//
//  History:    3-22-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINetHttp::HResultFromHttpStatus(DWORD dwStatus)
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINetHttp::HResultFromHttpStatus",
                "this=%#x, %#x",
                this, dwStatus
                ));
                
    PerfDbgLog(tagCINetHttp, this, "+CINetHttp::HResultFromHttpStatus");
    HRESULT hr = NOERROR;
    switch(dwStatus)
    {
    case  HTTP_STATUS_OK                :
    case  HTTP_STATUS_NOT_MODIFIED      :
    case  HTTP_STATUS_RETRY_WITH        :
        hr = NOERROR;
    break;

    case  HTTP_STATUS_NOT_FOUND :
        hr = INET_E_OBJECT_NOT_FOUND;
    break;

    case  HTTP_STATUS_NONE_ACCEPTABLE   :
        // comes back if server can not handle mime type
        hr = INET_E_NO_VALID_MEDIA;
    break;

    case  HTTP_STATUS_SERVICE_UNAVAIL   :
        hr = INET_E_INVALID_REQUEST;
        break;

    case  HTTP_STATUS_GATEWAY_TIMEOUT  :
    case  HTTP_STATUS_REQUEST_TIMEOUT  :
        hr = INET_E_CONNECTION_TIMEOUT;
        break;

    case  HTTP_STATUS_CREATED           :
    case  HTTP_STATUS_ACCEPTED          :
    case  HTTP_STATUS_PARTIAL           :
    case  HTTP_STATUS_NO_CONTENT        :
    case  HTTP_STATUS_AMBIGUOUS         :
    case  HTTP_STATUS_MOVED             :
    case  HTTP_STATUS_REDIRECT          :
    case  HTTP_STATUS_REDIRECT_METHOD   :
    case  HTTP_STATUS_REDIRECT_KEEP_VERB:
    case  HTTP_STATUS_BAD_REQUEST       :
    case  HTTP_STATUS_DENIED            :
    case  HTTP_STATUS_PAYMENT_REQ       :
    case  HTTP_STATUS_FORBIDDEN         :
    case  HTTP_STATUS_BAD_METHOD        :
    case  HTTP_STATUS_PROXY_AUTH_REQ    :
    case  HTTP_STATUS_CONFLICT          :
    case  HTTP_STATUS_GONE              :
    case  HTTP_STATUS_LENGTH_REQUIRED   :
    case  HTTP_STATUS_SERVER_ERROR      :
    case  HTTP_STATUS_NOT_SUPPORTED     :
    case  HTTP_STATUS_BAD_GATEWAY       :
    default:
        //PProtAssert((FALSE && "Mapping Ineternet error to generic hresult!"));
        hr = INET_E_DOWNLOAD_FAILURE;
        DbgLog2(DEB_PROT|DEB_TRACE, this, "=== Mapping Internet error to generic hresult!(dwStatus:%ld, hr:%lx)", dwStatus, hr);
        break;
    }

    PerfDbgLog1(tagCINetHttp, this, "-CINetHttp::HResultFromHttpStatus (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINetHttp::Terminate
//
//  Synopsis:   Close the server and request handle - wininet will make a
//              callback on each handle closed
//
//  Arguments:  [dwOptions] --
//
//  Returns:
//
//  History:    07-27-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CINetHttp::Terminate(DWORD dwOptions)
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINetHttp::Terminate",
                "this=%#x, %#x",
                this, dwOptions
                ));
                
    PerfDbgLog(tagCINetHttp, this, "+CINetHttp::Terminate");
    HRESULT hr = NOERROR;
    //PProtAssert(( IsApartmentThread() ));

    if (_pHttpNeg)
    {
        PerfDbgLog1(tagCINetHttp, this, "=== CINetHttp::Terminate Release on _pHttpNeg (%lx)", _pHttpNeg);
        _pHttpNeg->Release();
        _pHttpNeg = NULL;
    }
    
    if (_pHttpNeg2)
    {
        PerfDbgLog1(tagCINetHttp, this, "=== CINetHttp::Terminate Release on _pHttpNeg2 (%lx)", _pHttpNeg2);
        _pHttpNeg2->Release();
        _pHttpNeg2 = NULL;
    }
    
    if (_pWindow)
    {
        PerfDbgLog1(tagCINetHttp, this, "+CINetHttp::Terminate Release on _pWindow (%lx)", _pWindow);
        _pWindow->Release();
        _pWindow = NULL;
    }

    if (_pHttSecurity)
    {
        PerfDbgLog1(tagCINetHttp, this, "+CINetHttp::Terminate Release on _pHttSecurity (%lx)", _pHttSecurity);
        _pHttSecurity->Release();
        _pHttSecurity = NULL;
    }

    hr = CINet::Terminate(dwOptions);

    PerfDbgLog1(tagCINetHttp, this, "-CINetHttp::Terminate (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CINetHttpS::CINetHttpS
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    2-06-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
CINetHttpS::CINetHttpS(REFCLSID rclsid, IUnknown *pUnkOuter) : CINetHttp(rclsid,pUnkOuter)
{
    DEBUG_ENTER((DBG_APP,
                None,
                "CINetHttpS::CINetHttpS",
                "this=%#x, %#x, %#x",
                this, &rclsid, pUnkOuter
                ));
                
    PerfDbgLog(tagCINetHttp, this, "+CINetHttpS::CINetHttpS");

    _dwIsA = DLD_PROTOCOL_HTTPS;
    _dwConnectFlags = INTERNET_FLAG_SECURE;
    _dwOpenFlags = INTERNET_FLAG_SECURE;

    PerfDbgLog(tagCINetHttp, this, "-CINetHttpS::CINetHttpS");

    DEBUG_LEAVE(0);
}

//+---------------------------------------------------------------------------
//
//  Method:     CINetHttpS::~CINetHttpS
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    2-06-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
CINetHttpS::~CINetHttpS()
{
    DEBUG_ENTER((DBG_APP,
                None,
                "CINetHttpS::~CINetHttpS",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCINetHttp, this, "+CINetHttpS::~CINetHttpS");

    PerfDbgLog(tagCINetHttp, this, "-CINetHttpS::~CINetHttpS");

    DEBUG_LEAVE(0);
}

//+---------------------------------------------------------------------------
//
//  Method:     CINetHttp::INetWrite
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    1-27-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINetHttp::INetWrite()
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINetHttp::INetWrite",
                "this=%#x",
                this
                ));
                
    TransDebugOut((DEB_PROT, "%p OUT CINetHttp::INetWrite\n", this));
    HRESULT hr = NOERROR;

    BOOL fRet;
    DWORD dwSendFlags = HSR_CHUNKED | HSR_INITIATE;
    DWORD dwSendContext = 0;

    // If our caller gave us a TYMED_ISTREAM, then we need to pick it up
    // now.
    if (!_pStm)
    {
        BINDINFO *pBI = GetBindInfo();
        if (pBI && pBI->stgmedData.tymed == TYMED_ISTREAM)
        {
            _pStm = pBI->stgmedData.pstm;
        }
    }

    TransAssert((_pStm));
    if( _fSendAgain && _pStm )
    {
        LARGE_INTEGER        li;
        li.LowPart = 0;
        li.HighPart = 0;
        hr = _pStm->Seek(li, STREAM_SEEK_SET, NULL);
        if( SUCCEEDED(hr) )
        {
            _fSendEnd = FALSE;
        }
        else
        {
            _fCompleted = TRUE;
        }

        _fSendAgain = FALSE;
    }

    // loop until pending
    if (_fSendEnd)
    {
        _hrError = INET_E_DONE;
    }
    else do
    {
        _dwBytesSent = 0;

        SetStatePending(E_PENDING);

        hr = GetNextSendBuffer(&_inetBufferSend,_pStm);
        if (FAILED(hr))
        {
            break;
        }

        if (hr == S_FALSE)
        {
            // end of stream
            _fCompleted = TRUE;
        }

        if (!_fCompleted)
        {
            if (_inetBufferSend.dwBufferLength)
            {
                fRet = InternetWriteFile(
                            _hRequest           //IN HINTERNET hFile,
                            ,_inetBufferSend.lpvBuffer         //IN LPCVOID lpBuffer,
                            ,_inetBufferSend.dwBufferLength    //IN DWORD dwNumberOfBytesToWrite,
                            ,&_dwBytesSent       //OUT LPDWORD lpdwNumberOfBytesWritten
                            );
            }
            else
            {
                fRet = TRUE;
            }
        }
        else
        {
            fRet = HttpEndRequestA(
                         _hRequest              //IN HINTERNET hRequest,
                        ,NULL
                        ,dwSendFlags            //IN DWORD dwFlags,
                        ,dwSendContext          //IN DWORD dwContext

                        );

            _fSendEnd = TRUE;
        }

        //PerfDbgLog(tagCINetHttp, this, "-CINetHttp::INetAsyncSendRequest HttpSendRequest");

        if (fRet == FALSE)
        {
            DWORD dwLstError = GetLastError();
            if (dwLstError == ERROR_IO_PENDING)
            {
                // wait async for the handle
                hr = E_PENDING;
            }
            else
            {
                SetStatePending(NOERROR);
                hr = _hrError = INET_E_DOWNLOAD_FAILURE;
                SetBindResult(dwLstError,hr);
                //PerfDbgLog3(tagCINetHttp, this, "CINetHttp::INetAsyncSendRequest (fRet:%d, _hrError:%lx, LstError:%ld)", fRet, _hrError, dwLstError);
            }
        }
        else
        {
            SetStatePending(NOERROR);
        }

    } while ((fRet == TRUE) && (_fCompleted == FALSE));

    if (_hrError != INET_E_OK)
    {
        // we need to terminate here
        ReportResultAndStop((_hrError == INET_E_DONE) ? NOERROR : _hrError);
    }

    TransDebugOut((DEB_PROT, "%p OUT CINetHttp::INetWrite (hr:%lx)\n", this, hr));

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINetHttp::GetNextSendBuffer
//
//  Synopsis:
//
//  Arguments:  [pIB] --
//              [pStm] --
//              [fFirst] --
//
//  Returns:
//
//  History:    4-28-1997   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINetHttp::GetNextSendBuffer(INTERNET_BUFFERS *pIB, IStream *pStm, BOOL fFirst)
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINetHttp::GetNextSendBuffer",
                "this=%#x, %#x, %#x, %B",
                this, pIB, pStm, fFirst
                ));
                
    TransDebugOut((DEB_PROT, "%p OUT CINetHttp::GetNextSendBuffer\n", this));
    HRESULT hr = NOERROR;

    TransAssert(pIB);

    do
    {
        BINDINFO *pBndInfo = GetBindInfo();
        DWORD dwBufferFilled = 0;

        if (!pStm)
        {
            hr = E_FAIL;
            break;
        }

        if (!fFirst)
        {
            TransAssert((_pBuffer));
            hr = pStm->Read(_pBuffer, _dwBufferSize, &dwBufferFilled);

            if (FAILED(hr))
            {
                break;
            }
            else if (!dwBufferFilled)
            {
            	hr = S_FALSE;
            }
        }
        else
        {
            LARGE_INTEGER        li;
            li.LowPart = 0;
            li.HighPart = 0;

            // We do not need to addref this here
            pStm->Seek(li, STREAM_SEEK_SET, NULL);

            if( !_pBuffer )
            {
                _pBuffer = new char [SENDBUFFER_MAX];

                if (!_pBuffer)
                {
                    hr = E_OUTOFMEMORY;
                    break;
                }
                _dwBufferSize = SENDBUFFER_MAX;
            }
        }

        pIB->dwStructSize = sizeof (INTERNET_BUFFERSA);
        pIB->Next = 0;
        pIB->lpcszHeader = (fFirst) ? _pszSendHeader : 0;
        pIB->dwHeadersLength = (fFirst) ? ((_pszSendHeader) ? (ULONG)-1L : 0L) : 0;
        pIB->dwHeadersTotal = (fFirst) ? ((_pszSendHeader) ? (ULONG)-1L : 0L) : 0;
        pIB->lpvBuffer = (fFirst) ? 0 : _pBuffer;
        pIB->dwBufferLength = (fFirst) ? 0 : dwBufferFilled;
        pIB->dwBufferTotal = (fFirst) ? pBndInfo->cbstgmedData : 0; // :_dwBufferSize;
        pIB->dwOffsetLow = 0;
        pIB->dwOffsetHigh = 0;

        break;
    } while (TRUE);

    TransDebugOut((DEB_PROT, "%p OUT CINetHttp::GetNextSendBuffer (hr:%lx)\n", this, hr));

    DEBUG_LEAVE(hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\iapp\cnetstrm.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       cnetstrm.cxx
//
//  Contents:   Implements the stream: protocol
//
//  Classes:    CINetStream
//
//  Functions:
//
//  History:    5/3/96 Created Craig Critchley [craigc]
//
//----------------------------------------------------------------------------
#include <iapp.h>
#include <shlwapip.h>

PerfDbgTag(tagCINetStream, "Urlmon", "Log CINetStream", DEB_PROT);

//+---------------------------------------------------------------------------
//
//  Method:     CINetStream::CINetStream
//
//  Synopsis:   Constructs a stream protcol object
//
//  Arguments:  rclsid
//
//  Returns:
//
//  History:    5/3/96 Created Craig Critchley [craigc]
//
//  Notes:
//
//----------------------------------------------------------------------------
CINetStream::CINetStream(REFCLSID rclsid, IUnknown *pUnkOuter) : CINet(rclsid,pUnkOuter)
{
    DEBUG_ENTER((DBG_APP,
                None,
                "CINetStream::CINetStream",
                "this=%#x, %#x, %#x",
                this, &rclsid, pUnkOuter
                ));
                
    PerfDbgLog(tagCINetStream, this, "CINetStream::CINetStream");
    _dwIsA = DLD_PROTOCOL_STREAM;
    _pstm = NULL;

    DEBUG_LEAVE(0);
}

//+---------------------------------------------------------------------------
//
//  Method:     CINetStream::~CINetStream
//
//  Synopsis:   destroys a stream protocol object
//
//  Arguments:
//
//  Returns:
//
//  History:    5/3/96 Created Craig Critchley [craigc]
//
//  Notes:
//
//----------------------------------------------------------------------------
CINetStream::~CINetStream()
{
    DEBUG_ENTER((DBG_APP,
                None,
                "CINetStream::~CINetStream",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCINetStream, this, "CINetStream::~CInetStream");
    if (_pstm)
    {
        _pstm->Release();
    }

    DEBUG_LEAVE(0);
}

//+---------------------------------------------------------------------------
//
//  Method:     CINetStream::INetAsyncOpen
//
//  Synopsis:   opens and synchronously downloads data from a stream
//
//  Arguments:  rclsid
//
//  Returns:
//
//  History:    5/3/96 Created Craig Critchley [craigc]
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINetStream::INetAsyncOpen()
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINetStream::INetAsyncOpen",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCINetStream, this, "+CINetStream::INetAsyncOpen");
    IBindCtx * pbc = 0;
    IMoniker * pmk = 0;
    IStream * pstm = 0;
    IParseDisplayName * pParser = 0;
    STATSTG stat;
    CLSID clsid;
    CHAR szDisplayName[MAX_PATH];
    WCHAR wzDisplayName[MAX_PATH];
    WCHAR wzProgId[MAX_PATH];
    LPSTR pa, psz;
    LPWSTR pwz, pwzI;
    int cch;
    HRESULT hr = E_NOTIMPL;
    ULONG cchE;
    BOOL fGotMIMEType = FALSE;
    ULONG cchServerName, cchObjectName;

    ReportNotification(BINDSTATUS_SENDINGREQUEST);

    // need one of these
    //
    if (FAILED(hr = CreateBindCtx(0,&pbc)))
        goto End;

    //   form is mk:@progid:moniker
    //
    cchServerName = strlen(GetServerName());
    cchObjectName = strlen(GetObjectName());

    if ((cchServerName + cchObjectName) >= MAX_PATH)
    {
        hr = E_FAIL;
        goto End;
    }

    strcpy(szDisplayName,GetServerName());
    strcat(szDisplayName,psz = GetObjectName());

    // if the moniker has a file extension, try to
    // determine the MIME type that way...
    //
    psz = FindFileExtension(psz);
    if (psz)
    {
        char szMime[MAX_PATH];
        DWORD cb = MAX_PATH;

        if (SUCCEEDED(GetMimeFromExt(psz,szMime,&cb)))
        {
            ReportNotification(BINDSTATUS_MIMETYPEAVAILABLE, szMime);
            fGotMIMEType = TRUE;
        }
    }

    A2W(szDisplayName,wzDisplayName,MAX_PATH);

    //   find progid
    //
    for (pwz = wzDisplayName, pwzI = wzProgId; *pwz; pwz++)
    {
        if (*pwz == '@')
        {
            pwzI = wzProgId;
        }
        else if (*pwz == ':')
        {
            *pwzI = 0;

            // the remainder may have a filename with a useful
            // extension... just in case, set the filename...
            //
            LPSTR pszStr = DupW2A(pwz+1);
            if (pszStr)
            {
                ReportNotification(BINDSTATUS_CACHEFILENAMEAVAILABLE, pszStr);
                delete pszStr;
            }

            break;
        }
        else
        {
            *pwzI++ = *pwz;
        }
    }

#if 0
    if (FAILED(hr = MkParseDisplayName(pbc,wzDisplayName,&cchE,&pmk)) && pmk)
        goto End;
#else
    // BUGBUG
    //
    //   MkParseDisplayName was opening another instance of app
    //   force inproc server.  ick.
    //

    if (FAILED(hr = CLSIDFromProgID(wzProgId,&clsid)))
    {
        goto End;
    }

    if (FAILED(hr = CoCreateInstance(clsid,0,CLSCTX_INPROC_SERVER,
                                     IID_IParseDisplayName,(void**)&pParser)))
    {
        goto End;
    }

    PProtAssert((pParser));

    if (FAILED(hr = pParser->ParseDisplayName(pbc,wzDisplayName,&cchE,&pmk)))
    {
        goto End;
    }

    PProtAssert((pmk));

#endif

    if (FAILED(hr = pmk->BindToStorage(pbc,0,IID_IStream,(void**)&pstm)))
    {
        hr = INET_E_RESOURCE_NOT_FOUND;
        goto End;
    }

    PProtAssert((hr != MK_S_ASYNCHRONOUS));
    PProtAssert((pstm));

    _pstm = pstm;
    _pstm->AddRef();

    // now we have a stream - stuff it into the trans data
    //
    if (FAILED(hr = pstm->Stat(&stat,STATFLAG_NONAME)))
    {
        goto End;
    }

    _cbTotalBytesRead = stat.cbSize.LowPart;
    _cbDataSize = stat.cbSize.LowPart;

    ReportResultAndStop(NOERROR, _cbTotalBytesRead, _cbDataSize );

    _hrError = INET_E_DONE;

    End:

    if (FAILED(hr))
    {
        SetCNetBindResult(GetLastError());
        hr = _hrError = INET_E_RESOURCE_NOT_FOUND;
        ReportResultAndStop(_hrError);
    }

    // play nice, no leaks
    //
    if (pParser)
    {
        pParser->Release();
    }

    if (pmk)
    {
        pmk->Release();
    }
    if (pbc)
    {
        pbc->Release();
    }
    if (pstm)
    {
        pstm->Release();
    }

    // make sure I set this any way I get out
    //
    PProtAssert((hr != E_NOTIMPL));

    PerfDbgLog1(tagCINetStream, this, "-CINetStream::INetAsyncOpen (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINetStream::Read
//
//  Synopsis:
//
//  Arguments:  [pBuffer] --
//              [cbBytes] --
//              [pcbBytes] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CINetStream::Read(void *pBuffer, DWORD cbBytes, DWORD *pcbBytes)
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINetStream::IInternetProtocol::Read",
                "this=%#x, %#x, %#x, %#x",
                this, pBuffer, cbBytes, pcbBytes
                ));
                
    PerfDbgLog(tagCINetStream, this, "+CINetStream::Read");
    HRESULT hr = E_FAIL;

    PProtAssert((cbBytes && pcbBytes));


    if (_pstm)
    {
        hr = _pstm->Read(pBuffer,cbBytes,pcbBytes);
    }

    PerfDbgLog4(tagCINetStream, this, "-CINetStream::Read (_hrError:%lx, [hr:%lx,cbBytesAsked:%ld,cbBytesReturned:%ld])",
        _hrError, hr, cbBytes, *pcbBytes);

    DEBUG_LEAVE(hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CINetStream::INetSeek
//
//  Synopsis:
//
//  Arguments:  [DWORD] --
//              [ULARGE_INTEGER] --
//              [plibNewPosition] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINetStream::INetSeek(LARGE_INTEGER dlibMove,DWORD dwOrigin,ULARGE_INTEGER *plibNewPosition)
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINetStream::INetSeek",
                "this=%#x",
                this, dlibMove, dwOrigin, plibNewPosition
                ));
                
    PerfDbgLog(tagCINetStream, this, "+CINetStream::INetSeek");
    HRESULT hr = E_FAIL;

    if (_pstm)
    {
        hr = _pstm->Seek(dlibMove, dwOrigin, plibNewPosition);
    }

    PerfDbgLog1(tagCINetStream, this, "-CINetStream::INetSeek (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINetStream::LockFile
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  History:    8-13-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINetStream::LockFile(BOOL fRetrieve)
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINetStream::LockFile",
                "this=%#x, %B",
                this, fRetrieve
                ));
                
    PerfDbgLog(tagCINetStream, this, "+CINetStream::LockFile");
    HRESULT hr = NOERROR;

    // nothing to do for now

    PerfDbgLog1(tagCINetStream, this, "-CINetStream::LockFile (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINetStream::UnlockFile
//
//  Synopsis:   unlocks the file
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    8-13-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINetStream::UnlockFile()
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINetStream::UnlockFile",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCINetStream, this, "+CINetStream::UnlockFile");
    HRESULT hr = NOERROR;

    // nothing to do for now

    PerfDbgLog1(tagCINetStream, this, "-CINetStream::UnlockFile (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\iapp\precomp1.inc ===
#//+---------------------------------------------------------------
#//
#//  File:      precomp1.inc
#//
#//  Contents:  directives for global precompiled include file when the
#//             sources file is two directories below com (or wherever
#//             this file is located).  We could easily have precomp3 and
#//             precomp4 for other areas.The urlint.* files should not
#//             otherwise be mentioned in the sources files.
#//
#//
#//----------------------------------------------------------------

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\..\inc\iapp.h
PRECOMPILED_TARGET=$(GPCH_BUILD)\$(_OBJ_DIR)\*\iapp.pch
PRECOMPILED_OPTION=/Yuiapp.h /Fp$(GPCH_BUILD)\$(_OBJ_DIR)\*\iapp.pch
PRECOMPILED_OBJ=$(GPCH_BUILD)\$(_OBJ_DIR)\*\iapp.obj


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\idl\makeidl.inc ===
# DEST_TREE is set by the calling makefile

UMON_DEST=..\inc\$(DEST_TREE)

!ifndef MIDL
MIDL = midl.exe
!endif

#
# BUGBUG - We want to compile these IDL files /Oi but the interpretor
# cannot handle error_status_t parameters.  When it can, change /Os to /Oi
#
MIDL_FLAGS= \
 -Zp8 \
 -I$(INCLUDES) \
 -Os \
 -oldnames \
 -char unsigned \
 -error allocation \
 -ms_ext -c_ext \
 $(C_DEFINES) \
 -cpp_cmd $(TARGET_CPP)

CSWITCH=-prefix cstub _

urlmon.h:  ..\urlmon.idl
     $(MIDL) $(MIDL_FLAGS) \
        -cstub $(UMON_DEST)\umon_c.c    \
        -sstub $(UMON_DEST)\umon_s.c    \
        ..\urlmon.idl

allidl:   urlmon.h

clean:
          erase urlmon.h   >NUL 2>NUL

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\idl\makefile.inc ===
SDKINC = $(BASEDIR)\public\sdk\inc

$(SDKINC)\urlmon.idl: urlmon.idl
        copy urlmon.idl $(SDKINC)\urlmon.idl
        copy urlmon.idl $(SDKINC)\chicago\urlmon.idl

$(SDKINC)\chicago\urlmon.h: $(SDKINC)\urlmon.h
        copy $(SDKINC)\urlmon.h $(SDKINC)\chicago\urlmon.h

urlmki.idl: $(BASEDIR)\inetcore\published\inc\urlmki.idl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\inc\agent.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       trans.h
//
//  Contents:   precompiled header file for the trans directory
//
//  Classes:
//
//  Functions:
//
//  History:    12-22-95   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------

//#include <afx.h>
//#include <afxcoll.h>
#include "..\agent\stdafx.h"
#include <urlmon.hxx>
//#include "..\agent\agent.hxx"
#include "..\agent\courier.hxx"
//#include <tls.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\iapp\curl.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       curl.cxx
//
//  Contents:   handle url parsing and context urls parsing
//
//  Classes:
//
//  Functions:
//
//  History:    2-20-96   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------
#include <iapp.h>
#include <shlwapi.h>
#include <shlwapip.h>

PerfDbgTag(tagCUrl,    "Urlmon", "Log CUrl",     DEB_PROT);
PerfDbgTag(tagCUrlApi, "Urlmon", "Log CUrl API", DEB_ASYNCAPIS);

//+---------------------------------------------------------------------------
//
//  Function: IsStreamEnabled
//
//  Synopsis: returns TRUE iff the registry key for the mk: protocol is set
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:   6-7-96   craigc          Created
//
//  Notes:
//
//----------------------------------------------------------------------------
extern BOOL g_bGlobalUTF8hackEnabled;
BOOL StringContainsHighAnsiW(LPCWSTR);

BOOL IsStreamEnabled()
{
    DEBUG_ENTER((DBG_APP,
                Bool,
                "IsStreamEnabled",
                NULL
                ));
                
    HKEY    hk;
    char    szBuf[256];
    DWORD   dwType;
    DWORD   dwSize;
    const char    szKey[] = "SOFTWARE\\Microsoft\\Internet Explorer";
    const char    szValue[] = "MkEnabled";
    const char    szYes[] = "yes";

    static BOOL   fChecked = FALSE;
    static BOOL   fEnabled = FALSE;

    CMutexSem mxs;
    CLock lck(mxs);

    if (fChecked)
    {
        DEBUG_LEAVE(fEnabled);
        return fEnabled;
    }

    if (RegOpenKey(HKEY_LOCAL_MACHINE, szKey, &hk) != ERROR_SUCCESS)
    {
        DEBUG_LEAVE(FALSE);
        return( FALSE );
    }
    
    dwSize = sizeof(szBuf);
    if (RegQueryValueEx( hk, szValue, NULL, &dwType, (BYTE*)szBuf, &dwSize ) != ERROR_SUCCESS)
    {
        RegCloseKey( hk );

        DEBUG_LEAVE(FALSE);
        return( FALSE );
    }
    RegCloseKey( hk );

    fEnabled = (dwSize && (lstrcmpi( szYes, szBuf ) == 0));
    fChecked = TRUE;

    DEBUG_LEAVE(fEnabled);
    return fEnabled;
}

//
//  GetUrlScheme() returns one of the URL_SCHEME_* constants as
//  defined in shlwapip.h
//  example "http://foo" returns URL_SCHEME_HTTP
//
DWORD GetUrlScheme(IN LPCTSTR pcszUrl)
{
    DEBUG_ENTER((DBG_APP,
                Dword,
                "GetUrlScheme",
                "%#x",
                pcszUrl
                ));
                
    if(pcszUrl)
    {
        PARSEDURL pu;
        pu.cbSize = sizeof(pu);
        if(SUCCEEDED(ParseURL(pcszUrl, &pu)))
        {
            DEBUG_LEAVE(pu.nScheme);
            return pu.nScheme;
        }
    }

    DEBUG_LEAVE(URL_SCHEME_INVALID);
    return URL_SCHEME_INVALID;
}


//+---------------------------------------------------------------------------
//
//  Method:     CUrl::CUrl
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    2-20-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
CUrl::CUrl()
{
    DEBUG_ENTER((DBG_APP,
                None,
                "CUrl::CUrl",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCUrl, this, "+CUrl::CUrl");

    _pszBaseURL      = NULL;
    _pszPartURL      = NULL;
    _pszFullURL      = NULL;
    _pszProtocol     = NULL;
    _pszServerName   = NULL;
    _pszUserName     = NULL;
    _pszPassword     = NULL;
    _pszObject       = NULL;
    _pBasicAllocUnit = NULL;

    _ipPort = 0;
    _dwProto = 0;

    _fUTF8hack = FALSE;
    _pszUTF8ServerName = NULL;
    _dwServerCodePage = 0;
    
    PerfDbgLog(tagCUrl, this, "-CUrl::CUrl");

    DEBUG_LEAVE(0);
}

BOOL
CUrl::CUrlInitBasic(DWORD dwBaseUrlSize)
{
    DEBUG_ENTER((DBG_APP,
                Bool,
                "CUrl::CUrlInitBasic",
                "this=%#x, %#x",
                this, dwBaseUrlSize
                ));
                
    //
    // basic allocation contains the following fields:  
    //
    //  _pszServerName - URL_FIELD_SIZE
    //  _pszUserName   - URL_FIELD_SIZE
    //  _pszPassword   - URL_FIELD_SIZE
    //  _pszProtocol   - 12
    //  _pszBaseURL    - dwBaseUrlSize + 1
    //
    BOOL fRet = FALSE;
    DWORD dwBasicUnitSize = (3 * (URL_FIELD_SIZE)) + 12 + dwBaseUrlSize + 1;
    _pBasicAllocUnit = new char[dwBasicUnitSize];

    if( _pBasicAllocUnit )
    {
        _pszServerName = _pBasicAllocUnit;
        _pszUserName   = _pszServerName + URL_FIELD_SIZE;
        _pszPassword   = _pszUserName   + URL_FIELD_SIZE;
        _pszProtocol   = _pszPassword   + URL_FIELD_SIZE;
        _pszBaseURL    = _pszProtocol   + 12;

        *_pszServerName = '\0';
        *_pszUserName   = '\0';
        *_pszPassword   = '\0';
        *_pszProtocol   = '\0';
        *_pszBaseURL    = '\0';

        fRet = TRUE;
    }

    DEBUG_LEAVE(fRet);
    return fRet;
}

BOOL
CUrl::CUrlInitAll()
{
    DEBUG_ENTER((DBG_APP,
                Bool,
                "CUrl::CUrlInitAll",
                "this=%#x",
                this
                ));
                
    // backword compatibility init all with URL_MAX_LENGTH
    BOOL fRet = FALSE;
    fRet = CUrlInitBasic(MAX_URL_SIZE);

    if( fRet )
    { 
        _pszPartURL = new char[MAX_URL_SIZE + 1];
        _pszFullURL = new char[MAX_URL_SIZE + 1];
        _pszObject  = new char[MAX_URL_SIZE + 1];
    
        if( !_pszPartURL || !_pszFullURL || !_pszObject )
        {

            if (_pszPartURL)
                delete _pszPartURL;

            if (_pszFullURL)
                delete _pszFullURL;

            if (_pszObject)
                delete _pszObject;

            _pszPartURL = NULL;
            _pszFullURL = NULL;
            _pszObject  = NULL;

            fRet = FALSE; 
        }
        else
        {
            *_pszPartURL = '\0';
            *_pszFullURL = '\0';
            *_pszObject  = '\0';
        }
    }

    DEBUG_LEAVE(fRet);
    return fRet;
}

CUrl::~CUrl()
{
    DEBUG_ENTER((DBG_APP,
                None,
                "CUrl::~CUrl",
                "this=%#x",
                this
                ));
                
    if( _pBasicAllocUnit )
    {
        delete [] _pBasicAllocUnit;
    }
    if( _pszPartURL )
    {
        delete [] _pszPartURL;
    }
    if( _pszFullURL )
    {
        delete [] _pszFullURL;
    }
    if( _pszObject )
    {
        delete [] _pszObject;
    }
    if( _pszUTF8ServerName )
    {
        delete [] _pszUTF8ServerName;
    }

    DEBUG_LEAVE(0);
}

//+---------------------------------------------------------------------------
//
//  Function:   ParseUrl
//
//  Synopsis:   Breaks down a URL and puts servername, objectname and port
//              into the download structure.
//
//  Arguments:
//
//
//  Returns:    TRUE if the URL was successfully parsed.
//
//  History:    Created    Unknown
//              02-20-95   JohannP (Johann Posch)   Created Class
//              03-20-95   JoeS    (Joe Souza)      Special FILE: syntaxes
//
//  Notes:      URL should have already been parsed earlier by ConstructURL.
//              This function will crack the URL.
//
//----------------------------------------------------------------------------
BOOL CUrl::ParseUrl(BOOL fUTF8Required, LPCWSTR pwzUrl, DWORD dwCodePage)
{
    DEBUG_ENTER((DBG_APP,
                Bool,
                "CUrl::ParseUrl",
                "this=%#x, %B",
                this, fUTF8Required
                ));
                
    PerfDbgLog1(tagCUrl, this, "+CUrl::ParseUrl Base:[%s]", _pszBaseURL);
    BOOL            fRet = TRUE;
    URL_COMPONENTS  url;
    DWORD           cchFullURL;
    LPSTR           szTemp;
    CHAR *          pch;
    DWORD           dwFullUrlLen;

    _fUTF8hack = FALSE; //possibly set true later in the function for non-redirect codepath.

    if (_pszPartURL && _pszPartURL[0] != '\0' )  // This string will be set for redirects.
    {
        //
        // we need re-alloc _pszFullURL and _pszObject, since
        // the the size can grow!
        //
        dwFullUrlLen = strlen(_pszBaseURL) + strlen(_pszPartURL) + 1;
        if(dwFullUrlLen > MAX_URL_SIZE)
        {
            dwFullUrlLen = MAX_URL_SIZE + 1;
        } 

        if( _pszFullURL )
        {
            delete [] _pszFullURL;
            _pszFullURL = NULL;
            _pszFullURL = new char[dwFullUrlLen];
        }

        if( _pszObject )
        {
            delete [] _pszObject;
            _pszObject = NULL;
            _pszObject = new char[dwFullUrlLen];
        }

        if( !_pszFullURL || !_pszObject  )
        {
            fRet = FALSE;
            goto Exit;
        }

        cchFullURL = dwFullUrlLen; 

        if(FAILED(UrlCombine(_pszBaseURL, _pszPartURL, _pszFullURL, &cchFullURL, URL_FILE_USE_PATHURL)))
        {
            fRet = FALSE;
            PProtAssert(FALSE && "Combine failed in ParseUrl!\n");

            goto Exit;
        }
    }
    else
    {
        // FullURL is BaseURL
        dwFullUrlLen = strlen(_pszBaseURL) + 1;
        if( !_pszFullURL )
        {
            _pszFullURL = new char[dwFullUrlLen];
        }

        if( !_pszObject )
        {
            _pszObject = new char[dwFullUrlLen];
        }

        if( !_pszFullURL || !_pszObject  )
        {
            fRet = FALSE;
            goto Exit;
        }

        lstrcpy(_pszFullURL, _pszBaseURL);
    }

    // Trim off intra-page link.
    //
    // NB: Don't use ExtraInfo below to do this because you will
    // also lose search string this way.
    //
    // Also, we need to do this before we decode the URL below,
    // so that we don't trim off the wrong '#' if there was one
    // encoded in the URL path.
    //
    //  UrlGetLocation() will intelligently find the fragment
    //  some schemes do not use the # as a fragment identifier.
    //  it returns a pointer to the #
    //

    if(pch = (CHAR *)UrlGetLocation(_pszFullURL))
    {
        *pch = TEXT('\0');
    }


    _dwProto = ProtoFromString(_pszFullURL);

    if (_dwProto == DLD_PROTOCOL_NONE)
    {
        fRet = FALSE;
        goto Exit;
    }

    
    if(DLD_PROTOCOL_FILE == _dwProto)
    {
        //
        // at this point, _pszFullURL and _pszObject should be all
        // allocated with size of dwFullUrlLen
        //
        DWORD cchObject = dwFullUrlLen;

        //do file stuff here
        fRet = SUCCEEDED(PathCreateFromUrl(_pszFullURL, _pszObject, &cchObject, 0));

    }
    else
    {
        //
        //  BUGBUG - InternetCrackUrl alters the original url - zekel - 25-JUL-97
        //  ICU is poorly behaved, and it unescapes the server and username
        //  components insitu regardless of whether it was requested or not
        //  this means that if you pass in http://host%76/, the url on return
        //  is http://hostv76/.  it happens that if you create the URL from the 
        //  components given, you will get the correct URL, but crack doesnt understand
        //  all URLs.  it is too late in the game to change the behavior of ICU,
        //  because wininet internally depends on the behavior.
        //  so our solution is to create a temp buffer that can be messed with
        //  and then throw it away after we are done.
        //
        LPSTR pszTemp = StrDup(_pszFullURL);

        if (pszTemp)
        {
            url.dwStructSize = sizeof(url);

            url.lpszScheme = _pszProtocol;
            url.dwSchemeLength =12;

            url.lpszHostName = _pszServerName;
            url.dwHostNameLength = URL_FIELD_SIZE;

            url.lpszUserName = _pszUserName;
            url.dwUserNameLength = URL_FIELD_SIZE;

            url.lpszPassword = _pszPassword;
            url.dwPasswordLength = URL_FIELD_SIZE;

            url.lpszUrlPath = _pszObject;
            url.dwUrlPathLength = dwFullUrlLen;

            url.lpszExtraInfo = NULL;
            url.dwExtraInfoLength = 0;

            fRet = InternetCrackUrl(pszTemp, 0, (_dwProto == DLD_PROTOCOL_STREAM ? ICU_DECODE : 0), &url);

            _ipPort = url.nPort;

        /*
            Code to pass in an MBCS servername to wininet always when this fix enabled 
            to get around the UTF8-servername bugs. - I-DNS fix.
         */

            if( fUTF8Required 
                && g_bGlobalUTF8hackEnabled
                && fRet
                && ((_dwProto == DLD_PROTOCOL_HTTP) 
                    || (_dwProto == DLD_PROTOCOL_HTTPS))
              )
            {
                DWORD dwHostname = MAX_URL_SIZE;
                WCHAR* pwzHostname = new WCHAR[MAX_URL_SIZE];
                char* pszHostname = new char[MAX_URL_SIZE];
                HRESULT hrTemp;

                // This is NOT a loop - just an urlmon-style coding convention to avoid deep if-else-nesting.
                do
                {
                    fRet = FALSE;
                    
                    if (!pwzHostname || !pszHostname)
                    {
                        break;
                    }
                    
                    hrTemp = UrlGetPartW(pwzUrl, pwzHostname, &dwHostname, URL_PART_HOSTNAME, 0);
                    if (FAILED(hrTemp))
                    {
                        break;
                    }

                    if (!StringContainsHighAnsiW(pwzHostname))
                    {
                        // home free! - no high ansi in servername.
                        fRet = TRUE;
                        break;
                    }

                    if (dwCodePage == CP_UTF8)
                    {
                        dwCodePage = GetACP();
                    }
                    
                    W2A(pwzHostname, pszHostname, MAX_URL_SIZE, dwCodePage);
                    
                    // Cache the UTF8 servername if we need it.
                    // This field is set only once ( not on redirects ),
                    // so release only in destructor.
                    
                    _pszUTF8ServerName = new char[url.dwHostNameLength+1];
                    if (!_pszUTF8ServerName)
                    {
                        break;
                    }
                    
                    lstrcpy(_pszUTF8ServerName, _pszServerName);
                    
                    // now clobber it with the MBCS servername
                    
                    //Compat: match side-effect of calling InternetCrackUrl
                    
                    dwHostname = URL_FIELD_SIZE;
                    hrTemp = UrlUnescapeA(pszHostname, _pszServerName, &dwHostname, 0);
                    if(FAILED(hrTemp))
                    {
                        break;
                    }

                    // now put the original _pszFullURL back together with the MBCS servername
                    // instead of the UTF8 servername since wininet will have this.

                    url.lpszHostName = _pszServerName;
                    url.dwHostNameLength = dwHostname;

                    url.lpszUserName = NULL;
                    url.dwUserNameLength = 0;

                    url.lpszPassword = NULL;
                    url.dwPasswordLength = 0;
                    
                    if (!InternetCreateUrl(&url, 0, _pszFullURL, &dwFullUrlLen))
                    {
                        if (GetLastError() != ERROR_INSUFFICIENT_BUFFER)
                        {
                            break;
                        }
                        
                        delete [] _pszFullURL;
                        _pszFullURL = new char[++dwFullUrlLen];

                        if (!_pszFullURL || !InternetCreateUrl(&url, 0, _pszFullURL, &dwFullUrlLen))
                        {
                            break;
                        }
                    }

                    // At this point, everything is right.
                    // 1. _pszFullURL has the same url as wininet.
                    // 2. _pszServerName has the MBCS hostname
                    // 3. _pszUTF8ServerName has the UTF8 hostname that would have gone to the proxy (if needed)

                    _dwServerCodePage = dwCodePage;
                    _fUTF8hack = TRUE;

                    fRet = TRUE;
                    break;
                }
                while(TRUE);
                
                if (pwzHostname)
                    delete [] pwzHostname;
                if (pszHostname)
                    delete [] pszHostname;            
            }
                
            LocalFree(pszTemp);
        }
        else
            fRet = FALSE;
    }


Exit:

    PerfDbgLog1(tagCUrl, this, "-CUrl::ParseUrl Full:[%s]", _pszFullURL);

    DEBUG_LEAVE(fRet);
    return(fRet);
}

//+---------------------------------------------------------------------------
//
//  Method:     CUrl::ProtoFromString
//
//  Synopsis:
//
//  Arguments:  [lpszProtocol] --
//
//  Returns:
//
//  History:    Created   Unknown
//              2-20-96   JohannP (Johann Posch)   Modified for class
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD CUrl::ProtoFromString(LPSTR lpszProtocol)
{
    DEBUG_ENTER((DBG_APP,
                Dword,
                "CUrl::ProtoFromString",
                "this=%#x, %.80q",
                this, lpszProtocol
                ));

    DWORD dwRetVal = DLD_PROTOCOL_NONE;
    PerfDbgLog1(tagCUrl, this, "CUrl::ProtoFromString [%s]", lpszProtocol);

    switch (GetUrlScheme(lpszProtocol))
    {
    case URL_SCHEME_HTTPS:
        dwRetVal = DLD_PROTOCOL_HTTPS;
        break;
    
    case URL_SCHEME_HTTP:
        dwRetVal = DLD_PROTOCOL_HTTP;
        break;

    case URL_SCHEME_FTP:
        dwRetVal = DLD_PROTOCOL_FTP;
        break;

    case URL_SCHEME_GOPHER:
        dwRetVal = DLD_PROTOCOL_GOPHER;
        break;
    
    case URL_SCHEME_FILE:
        dwRetVal = DLD_PROTOCOL_FILE;
        break;

    case URL_SCHEME_LOCAL:
        dwRetVal = DLD_PROTOCOL_LOCAL;
        break;
        
    case URL_SCHEME_MK:
        if(IsStreamEnabled())
            dwRetVal = DLD_PROTOCOL_STREAM;
        break;

    }

    DEBUG_LEAVE(dwRetVal);
    return dwRetVal;
}


// Helper API's

//+---------------------------------------------------------------------------
//
//  Function:   ConstructURL
//
//  Synopsis:
//
//  Arguments:  [pBC] -- Pointer to BindCtx
//              [pURLBase] -- Pointer to Base URL [IN]
//              [pURLRelative] -- Pointer to Relative URL [IN]
//              [pURLFull] -- Pointer to resultant complete URL [OUT]
//
//  Returns:
//
//  History:    02-21-96    JoeS    (Joe Souza)     Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI ConstructURL(LPBC pBC, LPMONIKER pmkContext, LPMONIKER pmkToLeft,
            LPWSTR pwzURLRelative, LPWSTR pwzURLFull, DWORD cURLSize,
            DWORD dwFlags)
{
    DEBUG_ENTER_API((DBG_API,
                Hresult,
                "ConstructURL",
                "%#x, %#x, %#x, %.80wq, %.80wq, %#x, %#x",
                pBC, pmkContext, pmkToLeft, pwzURLRelative, pwzURLFull, cURLSize, dwFlags
                ));
                
    PerfDbgLog2(tagCUrlApi, NULL, "+ConstructURL (rel:%ws, pmk:%lx)", pwzURLRelative, pmkContext);
    HRESULT     hr = NOERROR;
    DWORD       dwMnk = 0;
    LPMONIKER   pmkCtx = NULL;
    LPWSTR      wzURLBase = NULL;
    WCHAR       wszURLFull[MAX_URL_SIZE + 1];
    DWORD       cchURLFull;
    DWORD       cbSize;
    BOOL        bParseOk = FALSE;
    DWORD       dwCUFlags = URL_FILE_USE_PATHURL;

    if (dwFlags & CU_STANDARD_FORM)
    {
        dwCUFlags = 0;
    }

    if (!pwzURLRelative || !pwzURLFull || !cURLSize)
    {
        hr = E_INVALIDARG;
        goto ConstructExit;
    }

    pwzURLFull[0] = 0;

    if (!pmkContext && pBC)
    {
        // No Context Moniker was specified, so try to get one of those.

        hr = pBC->GetObjectParam(SZ_URLCONTEXT, (IUnknown **)&pmkCtx);
        if (hr != NOERROR)
        {
            pmkCtx = NULL;
        }
    }
    else if (pmkContext)
    {
        pmkCtx = pmkContext;
    }
    else if (pmkToLeft)
    {
        pmkCtx = pmkToLeft;
    }

    if (pmkCtx)
    {
        // There is a Context Moniker.  Make sure it is a URL moniker and
        // if it is, get the base URL from it.

        pmkCtx->IsSystemMoniker(&dwMnk);
        if (dwMnk == MKSYS_URLMONIKER)
        {
            hr = pmkCtx->GetDisplayName(pBC, NULL, &wzURLBase);
        }
    }

    hr = NOERROR;

    if (wzURLBase)
    {
        DWORD dwSizeIn = MAX_URL_SIZE;
        cchURLFull = MAX_URL_SIZE;
        bParseOk = SUCCEEDED(OInetCombineUrl(wzURLBase, pwzURLRelative, dwCUFlags, pwzURLFull, dwSizeIn, &cchURLFull, 0));

    }
    else if (dwFlags & CU_CANONICALIZE)
    {
        DWORD dwSizeIn = MAX_URL_SIZE;
        cchURLFull = MAX_URL_SIZE;
        bParseOk = SUCCEEDED(OInetParseUrl(pwzURLRelative,PARSE_CANONICALIZE, dwCUFlags, pwzURLFull, dwSizeIn,&cchURLFull,0));
    }
    else
    {
        // We did not combine a relative and a base URL, and caller
        // does not want to canonicalize, so we just copy the given URL
        // into the return buffer.
#ifndef unix
        wcsncpy(pwzURLFull, pwzURLRelative, cURLSize / 2);
#else
        wcsncpy(pwzURLFull, pwzURLRelative, cURLSize / sizeof(wchar_t));
#endif /* unix */
        goto ConstructExit;
    }


    if (!bParseOk || !wcslen(pwzURLFull))
    {
        hr = MK_E_SYNTAX;
    }

ConstructExit:

    if (wzURLBase)
    {
        delete wzURLBase;
    }

    PerfDbgLog2(tagCUrlApi, NULL, "-ConstructURL [%ws], hr:%lx", pwzURLFull, hr);

    DEBUG_LEAVE_API(hr);
    return hr;
}



//+---------------------------------------------------------------------------
//
// UTF-8 code from wininet written by RFirth
//
//----------------------------------------------------------------------------
DWORD
CountUnicodeToUtf8(
    IN LPCWSTR pwszIn,
    IN DWORD dwInLen,
    IN BOOL bEncode
    )

/*++

Routine Description:

    Count number of BYTEs required for UTF-8 conversion of UNICODE string. Count
    is terminated after dwInLen characters

Arguments:

    pwszIn  - pointer to input wide-character string

    dwInLen - number of characters in pwszIn

    bEncode - TRUE if we are to hex encode characters >= 0x80

Return Value:

    DWORD   - number of BYTEs required for conversion

--*/

{
    DEBUG_ENTER((DBG_APP,
                Dword,
                "CountUnicodeToUtf8",
                "%.80wq, %#x, %B",
                pwszIn, dwInLen, bEncode
                ));
                
    PProtAssert(pwszIn != NULL);
    PProtAssert(dwInLen != 0);

    DWORD dwCount = 0;
    DWORD oneCharLen = bEncode ? 3 : 1;
    DWORD twoCharLen = 2 * oneCharLen;

    //
    // N.B. code arranged to reduce number of jumps in loop to 1 (while)
    //

    do {

        WORD wchar = *pwszIn++;

        dwCount += (wchar & 0xF800) ? oneCharLen : 0;
        dwCount += ((wchar & 0xFF80) ? 0xFFFFFFFF : 0) & (twoCharLen - 1);
        ++dwCount;
    } while (--dwInLen != 0);

    DEBUG_LEAVE(dwCount);
    return dwCount;
}

DWORD
ConvertUnicodeToUtf8(
    IN LPCWSTR pwszIn,
    IN DWORD dwInLen,
    OUT LPBYTE pszOut,
    IN DWORD dwOutLen,
    IN BOOL bEncode
    )

/*++

Routine Description:

    Convert a string of UNICODE characters to UTF-8:

        0000000000000000..0000000001111111: 0xxxxxxx
        0000000010000000..0000011111111111: 110xxxxx 10xxxxxx
        0000100000000000..1111111111111111: 1110xxxx 10xxxxxx 10xxxxxx

Arguments:

    pwszIn      - pointer to input wide-character string

    dwInLen     - number of CHARACTERS in pwszIn INCLUDING terminating NUL

    pszOut      - pointer to output narrow-character buffer

    dwOutLen    - number of BYTEs in pszOut

    bEncode     - TRUE if we are to hex encode characters >= 0x80

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INSUFFICIENT_BUFFER
                    Not enough space in pszOut to store results

--*/

{
    DEBUG_ENTER((DBG_APP,
                Dword,
                "CountUnicodeToUtf8",
                "%.80wq, %#x, %#x, %#x, %B",
                pwszIn, dwInLen, pszOut, dwOutLen, bEncode
                ));
                
    PProtAssert(pwszIn != NULL);
    PProtAssert((int)dwInLen > 0);
    PProtAssert(pszOut != NULL);
    PProtAssert((int)dwOutLen > 0);

    DWORD outputSize = bEncode ? 3 : 1;
    static char hexArray[] = "0123456789ABCDEF";

    while (dwInLen-- && dwOutLen) {

        WORD wchar = *pwszIn++;
        BYTE bchar;

        if (wchar <= 0x007F) {
            *pszOut++ = (BYTE)(wchar);
            --dwOutLen;
            continue;
        }

        BYTE lead = ((wchar >= 0x0800) ? 0xE0 : 0xC0);
        int shift = ((wchar >= 0x0800) ? 12 : 6);

        bchar = lead | (BYTE)(wchar >> shift);
        if (bEncode) {
            *pszOut++ = '%';
            *pszOut++ = hexArray[bchar >> 4];
            bchar = hexArray[bchar & 0x0F];
        }
        *pszOut++ = bchar;

        if (wchar >= 0x0800) {
            bchar = 0x80 | (BYTE)((wchar >> 6) & 0x003F);
            if (bEncode) {
                *pszOut++ = '%';
                *pszOut++ = hexArray[bchar >> 4];
                bchar = hexArray[bchar & 0x0F];
            }
            *pszOut++ = bchar;
        }
        
        bchar = 0x80 | (BYTE)(wchar & 0x003F);
        if (bEncode) {
            *pszOut++ = '%';
            *pszOut++ = hexArray[bchar >> 4];
            bchar = hexArray[bchar & 0x0F];
        }
        *pszOut++ = bchar;
    }

    DEBUG_LEAVE(ERROR_SUCCESS);
    return ERROR_SUCCESS;
}

BOOL
StringContainsHighAnsi(
    IN LPSTR pszIn,
    IN DWORD dwInLen
    )

/*++

Routine Description:

    Determine if string contains ANSI characters in range 0x80..0xFF. Search is
    stopped when we hit the first high-ANSI character, when we hit the terminator
    or when we have decremented dwInLen to zero

Arguments:

    pszIn   - pointer to string to test

    dwInLen - length of pszIn

Return Value:

    BOOL
        TRUE    - pszIn contains one or more high-ANSI characters

        FALSE   - pszIn (or substring of length dwInLen) does not contain
                  high-ANSI characters

--*/

{
    DEBUG_ENTER((DBG_APP,
                Bool,
                "StringContainsHighAnsi",
                "%.80q, %#x",
                pszIn, dwInLen
                ));
                
    PProtAssert(pszIn != NULL);
    PProtAssert(dwInLen != 0);

    // only need to search the base portion 
    while (dwInLen-- && *pszIn && *pszIn != '?') {
        if (*pszIn++ & 0x80) {

            DEBUG_LEAVE(TRUE);
            return TRUE;
        }
    }

    DEBUG_LEAVE(FALSE);
    return FALSE;
}


BOOL
StringContainsHighAnsiW(
    IN LPCWSTR pwzIn
    )
/*--
    Unicode version of StringContainsHighAnsi()
--*/
{
    DEBUG_ENTER((DBG_APP,
                Bool,
                "StringContainsHighAnsiW",
                "%.80wq",
                pwzIn
                ));
                
    PProtAssert(pwzIn != NULL);

    // only need to search the base portion 
    while (*pwzIn && *pwzIn != L'?') 
    {
        if (*pwzIn >= 0x80) 
        {
            DEBUG_LEAVE(TRUE);
            return TRUE;
        }
        pwzIn++;
    }

    DEBUG_LEAVE(FALSE);
    return FALSE;
}


BOOL
ConvertUnicodeUrl(
    LPCWSTR pwzFrom, 
    LPSTR   pszTo,
    INT     cchTo,
    DWORD   dwCodePage,
    BOOL    fUTF8Enabled,
    BOOL*   pfUTF8Required
    
    )
{
    DEBUG_ENTER((DBG_APP,
                Bool,
                "ConvertUnicodeUrl",
                "%.80wq, %.80q, %#x, %#x, %B",
                pwzFrom, pszTo, cchTo, dwCodePage, fUTF8Enabled
                ));
                
    BOOL fSuccess = FALSE;

    //
    // In multibyte string, if we have any bytes(in the base url portion)
    // over 0x80, we will have to convert the base portion to utf-8
    // (leave the query portion as multi-byte)
    //
    // S_FALSE from the conversion above indicates that some wide chars couldn't be
    // mapped to the destination code page

    *pfUTF8Required = FALSE;

    if( fUTF8Enabled && StringContainsHighAnsiW(pwzFrom))
    {
        *pfUTF8Required = TRUE;
        // utf-8 conversion

        //
        // do we have a query portion? (by searching the UNICODE URL string
        // for '?') also we can get the UNICODED string's BasePortion 
        // URL Length 
        // 
        DWORD  dwBaseUrlLen = 0;        // BasePortion length (in UNICODE)
        LPWSTR pBase = (LPWSTR) pwzFrom;
        while( *pBase && *pBase != '?')
        {
            pBase++;
            dwBaseUrlLen++;
        }

        DWORD  dwMBQryUrlLen  = 0;      // QueryPortion length (in Multibyte)
        LPSTR  pszQry = NULL;           // multibyte query string 
        if (*pBase)
        {
            //
            // we have a query portion, need to get length of
            // multi-byte query portion
            // In this case, we don't care whether or not pszTo is able to convert 
            // everything
            W2A(pBase, pszTo, cchTo, dwCodePage);
            dwMBQryUrlLen = strlen(pszTo);
            pszQry = pszTo;
        }
        
        //
        // we are converting the base portion of UNICODE URL to UTF-8 
        // count UTF-8 string length for base url
        //
        DWORD dwUTF8Len = CountUnicodeToUtf8(pwzFrom, dwBaseUrlLen, TRUE);

        //
        // allocate buffer for whole converted string 
        // Buffer size = UTF8_BaseURL_Len + MultiByte_Query_Len + '\0'
        //
        DWORD dwUTFBufferSize = dwUTF8Len + dwMBQryUrlLen + 1;

        // 
        // the size can not exceed incoming buffer size ccTo
        //
        if( dwUTFBufferSize > (DWORD)(cchTo + 1) )
        {
            //
            // fallback to IE4 behavior - sending multi-byte string
            //
            goto cleanup;
        }

        char* pszUTF8 = new char[dwUTFBufferSize];
        if( !pszUTF8 )
        {
            //
            // if we failed to allocate, we automatically
            // fallback to IE4 behavior - sending multi-byte string
            //
            goto cleanup;
        }
        memset(pszUTF8, 0, dwUTFBufferSize); 

        // Coverting UNICODE->UTF8
        DWORD dwError;
        dwError = ConvertUnicodeToUtf8( pwzFrom, 
                                        dwBaseUrlLen, 
                                        (LPBYTE)pszUTF8, 
                                        dwUTF8Len,
                                        TRUE );
        if( dwError != ERROR_SUCCESS )
        {
            //
            // if we failed, delete temp string and fallback to IE4
            // behavior - sending multi-byte string
            //
            delete [] pszUTF8;
            goto cleanup;
        } 

        //
        // copy over the Multi-byte query string to final buffer
        //
        if( pszQry )
        {
            LPSTR pszURL = pszUTF8 + dwUTF8Len;       
            while( dwMBQryUrlLen-- )
            {
                *pszURL = *pszQry;
                pszURL++;
                pszQry++;    
            }
        }

        //
        // we are done, copy the content from temp buffer to 
        // szTo 
        //
        StrCpyN(pszTo, pszUTF8, dwUTFBufferSize);

        // delete temp utf8 buffer 
        delete [] pszUTF8;
        fSuccess = TRUE;
    }
    
cleanup:
    if (!fSuccess)
    {
        // Unicode->Multibyte 
        // IE4 behaviour. Shoot.
        W2A(pwzFrom, pszTo, cchTo, dwCodePage);
    }

    DEBUG_LEAVE(TRUE);
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\inc\compress.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       compress.h
//
//  Contents:   precompiled header file for compress directory
//
//  Classes:
//
//  Functions:
//
//  History:    07-14-97   DanpoZ (Danpo Zhang)   Created
//
//----------------------------------------------------------------------------
extern "C"
{
#ifdef unix
#include "../compress/gzip/api_int.h"
#else
#include "..\compress\gzip\api_int.h"
#endif /* !unix */
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\inc\courier.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       trans.h
//
//  Contents:   precompiled header file for the trans directory
//
//  Classes:
//
//  Functions:
//
//  History:    12-22-95   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------

//#include "..\courier\stdafx.h"
#include <urlmon.hxx>
#include "..\courier\courier.hxx"
#include <tls.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\inc\crtsubst.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    crtsubst.h

Abstract:

    Maps some CRT functions to Win32 calls

Author:

    Rajeev Dujari (rajeevd) 04-Apr-1996

Revision History:

    04-Apr-1997 vincentr
        Copied from wininet
    04-Apr-1996 rajeevd
        Created
--*/

#ifndef _CRTSUBSTR_H
#define _CRTSUBSTR_H

#include <shlwapi.h>

#ifndef unix 
/*
   On NT, kernel32 forwards RtlMoveMemory to ntdll.
   On 95, kernel32 has RtlMoveMemory but ntdll doesn't.
   Override the NT headers forwarding at compile time.
*/
#ifdef RtlMoveMemory
#undef RtlMoveMemory
#ifdef __cplusplus
extern "C" {
#endif
void RtlMoveMemory (void *, const void *, unsigned long);
#ifdef __cplusplus
}
#endif
#endif

/* WARNING: Be careful mapping CRT strncpy to Win32 lstrcpyn.

   strncpy  (dst, "bar", 2);  // dst will get 'b', 'a'
   lstrcpyn (dst, "bar" 2);   // dst will get 'b',  0

   strncpy  (dst, "bar", 6);  // dst will get 'b', 'a', 'r', 0, 0, 0
   lstrcpyn (dst, "bar", 6);  // dst will get 'b', 'a', 'r', 0
*/

#undef free
#undef malloc
#undef memmove
#undef strdup
#undef stricmp
#undef _stricmp
#undef strlwr
#undef _strlwr
#undef strupr
#undef tolower
#undef toupper
#undef wcslen
#undef wcscmp
#undef wcscpy
#undef wcsncpy
#undef wcscat
#undef wcschr
#undef wcsrchr
#undef wcsstr
#undef _wcsicmp
#undef _wcsnicmp
#undef _strstr
#undef strstr
#undef _strchr
#undef strchr
#undef _strrchr
#undef strrchr
#undef __atoi
#undef _atoi
#undef atoi
#undef atol
#undef _strncat
#undef strncat
#undef _strncpy
#undef strncpy
#undef _strnicmp
#undef strnicmp
#undef _strncmp
#undef strncmp
#undef sprintf
#undef vsprintf
#undef wvsprintf

#define free(ptr)         LocalFree((HLOCAL) ptr)
#define malloc(size)      ((PVOID)LocalAlloc(LMEM_FIXED, size))
#define memmove(m1,m2,n)  RtlMoveMemory (m1,m2,n)
#define strdup(s)         NewString(s)
#define stricmp(s1,s2)    lstrcmpi(s1,s2)
#define _stricmp(s1,s2)   lstrcmpi(s1,s2)
#define strlwr(s)         CharLower(s)
#define _strlwr(s)        CharLower(s)
#define strupr(s)         CharUpper(s)
#define tolower(c)        ((BYTE) CharLower((LPSTR) ((DWORD)((BYTE)(c) & 0xff))))
#define toupper(c)        ((BYTE) CharUpper((LPSTR) ((DWORD)((BYTE)(c) & 0xff))))
#define wcslen(s)         lstrlenW(s)
#define wcscmp            StrCmpW
#define wcscpy            StrCpyW
#define wcsncpy(s1, s2, n) StrCpyNW(s1, s2, n)
#define wcscat            StrCatW
#define wcschr            StrChrW
#define wcsrchr(s, c)     StrRChrW(s, NULL, c)
#define wcsstr            StrStrW
#define _wcsicmp          StrCmpIW
#define _wcsnicmp         StrCmpNIW
#define _strstr           StrStr
#define strstr            StrStr
#define _strchr           StrChr
#define strchr            StrChr
#define _strrchr(s, c)    StrRChr(s, NULL, c)
#define strrchr(s, c)     StrRChr(s, NULL, c)
#define __atoi            StrToInt
#define _atoi             StrToInt
#define atoi              StrToInt
#define atol              StrToInt
#define strncat           StrNCat
#define _strncat          StrNCat
#define strncpy           StrNCpy
#define _strncpy          StrNCpy
#define strnicmp          StrCmpNI
#define _strnicmp         StrCmpNI
#define strncmp           StrCmpN
#define _strncmp          StrCmpN
#define sprintf           w4sprintf
#define vsprintf          w4vsprintf
#define wvsprintf         w4vsprintf

#undef itoa
#undef ultoa

#define itoa(val,s,n)     _itoa(val,s,n)
#define ultoa(val,s,n)    _ultoa(val,s,n)

#endif /* unix */

#endif // _CRTSUBSTR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\inc\iapp.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       iapp.h
//
//  Contents:   precompiled header file for the trans directory
//
//  Classes:
//
//  Functions:
//
//  History:    12-22-95   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------

#include <urlmon.hxx>
#ifndef unix
#include "..\iapp\curl.hxx"
#include "..\iapp\cnet.hxx"
#else
#include "../iapp/curl.hxx"
#include "../iapp/cnet.hxx"
#endif /* unix */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\inc\delaydll.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       delaydll.h
//
//  Contents:   precompiled headers for delayed dll 
//
//  Classes:
//
//  Functions:
//
//  History:    12-22-95   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------
#ifndef DELAY_DLL_H
#define DELAY_DLL_H

#include "oautdll.hxx"

extern COleAutDll   g_OleAutDll;

#pragma warning(disable:4005)
#define VariantClear            g_OleAutDll.VariantClear 
#define VariantInit             g_OleAutDll.VariantInit
#define VariantCopy             g_OleAutDll.VariantCopy
#define VariantChangeType       g_OleAutDll.VariantChangeType
#define SysAllocStringByteLen   g_OleAutDll.SysAllocStringByteLen
#define SysAllocString          g_OleAutDll.SysAllocString
#define SysStringByteLen        g_OleAutDll.SysStringByteLen
#define SysFreeString           g_OleAutDll.SysFreeString
#define LoadTypeLib             g_OleAutDll.LoadTypeLib
#pragma warning(default:4005)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\inc\inetdbg.h ===
/*++

Module Name:

    inetdbg.h

Abstract:

    Manifests, macros, types and prototypes for Windows Internet client DLL
    debugging functions

Author:

    Venkatraman Kudallur (venkatk) 3-10-2000
    ( Ripped off from Wininet )

Revision History:

    3-10-2000 venkatk
        Created

--*/

#ifndef _INETDBG_H_
#define _INETDBG_H_ 1

#if defined(__cplusplus)
extern "C" {
#endif

//
// misc. debug manifests
//

#define DEBUG_WAIT_TIME     (2 * 60 * 1000)

//
// Checked builds get INET_DEBUG set by default; retail builds get no debugging
// by default
//

#if DBG

#if !defined(INET_DEBUG)

#define INET_DEBUG          1

#endif // INET_DEBUG

#else

#if !defined(INET_DEBUG)

#define INET_DEBUG          0

#endif // INET_DEBUG

#endif // DBG

//
// types
//

//
// DEBUG_FUNCTION_RETURN_TYPE - Type of result (scalar) that a function returns
//

#ifdef ENABLE_DEBUG

typedef enum {
    None,
    Bool,
    Int,
    Dword,
    Hresult,
    String,
    Handle,
    Pointer
} DEBUG_FUNCTION_RETURN_TYPE;


#define INTERNET_DEBUG_CONTROL_DEFAULT      (DBG_THREAD_INFO       \
                                            | DBG_CALL_DEPTH        \
                                            | DBG_ENTRY_TIME        \
                                            | DBG_PARAMETER_LIST    \
                                            | DBG_TO_FILE           \
                                            | DBG_INDENT_DUMP       \
                                            | DBG_SEPARATE_APIS     \
                                            | DBG_AT_ERROR_LEVEL    \
                                            | DBG_NO_ASSERT_BREAK   \
                                            | DBG_DUMP_LENGTH       \
                                            | DBG_NO_LINE_NUMBER    \
                                            | DBG_ASYNC_ID          \
                                            )
#define INTERNET_DEBUG_CATEGORY_DEFAULT     DBG_ANY
#define INTERNET_DEBUG_ERROR_LEVEL_DEFAULT  DBG_INFO

//
// options. These are the option values to use with InternetQueryOption()/
// InternetSetOption() to get/set the information described herein
//

#define INTERNET_OPTION_GET_DEBUG_INFO      1001
#define INTERNET_OPTION_SET_DEBUG_INFO      1002
#define INTERNET_OPTION_GET_HANDLE_COUNT    1003
#define INTERNET_OPTION_GET_TRIGGERS        1004
#define INTERNET_OPTION_SET_TRIGGERS        1005
#define INTERNET_OPTION_RESET_TRIGGERS      1006

#define INTERNET_FIRST_DEBUG_OPTION         INTERNET_OPTION_GET_DEBUG_INFO
#define INTERNET_LAST_DEBUG_OPTION          INTERNET_OPTION_RESET_TRIGGERS

//
// debug levels
//

#define DBG_INFO            0
#define DBG_WARNING         1
#define DBG_ERROR           2
#define DBG_FATAL           3
#define DBG_ALWAYS          99

//
// debug control flags - these flags control where the debug output goes (file,
// debugger, console) and how it is formatted
//

#define DBG_THREAD_INFO     0x00000001  // dump the thread id
#define DBG_CALL_DEPTH      0x00000002  // dump the call level
#define DBG_ENTRY_TIME      0x00000004  // dump the local time when the function is called
#define DBG_PARAMETER_LIST  0x00000008  // dump the parameter list
#define DBG_TO_DEBUGGER     0x00000010  // output via OutputDebugString()
#define DBG_TO_CONSOLE      0x00000020  // output via printf()
#define DBG_TO_FILE         0x00000040  // output via fprintf()
#define DBG_FLUSH_OUTPUT    0x00000080  // fflush() after every fprintf()
#define DBG_INDENT_DUMP     0x00000100  // indent dumped data to current level
#define DBG_SEPARATE_APIS   0x00000200  // empty line after leaving each API
#define DBG_AT_ERROR_LEVEL  0x00000400  // always output diagnostics >= InternetDebugErrorLevel
#define DBG_NO_ASSERT_BREAK 0x00000800  // don't call DebugBreak() in InternetAssert()
#define DBG_DUMP_LENGTH     0x00001000  // dump length information when dumping data
#define DBG_NO_LINE_NUMBER  0x00002000  // don't dump line number info
#define DBG_APPEND_FILE     0x00004000  // append to the log file (default is truncate)
#define DBG_LEVEL_INDICATOR 0x00008000  // dump error level indicator (E for Error, etc.)
#define DBG_DUMP_API_DATA   0x00010000  // dump data at API level (InternetReadFile(), etc.)
#define DBG_DELTA_TIME      0x00020000  // dump times as millisecond delta if DBG_ENTRY_TIME
#define DBG_CUMULATIVE_TIME 0x00040000  // dump delta time from start of trace if DBG_ENTRY_TIME
#define DBG_FIBER_INFO      0x00080000  // dump the fiber address if DBG_THREAD_INFO
#define DBG_THREAD_INFO_ADR 0x00100000  // dump INTERNET_THREAD_INFO address if DBG_THREAD_INFO
#define DBG_ARB_ADDR        0x00200000  // dump ARB address if DBG_THREAD_INFO
#define DBG_ASYNC_ID        0x00400000  // dump async ID
#define DBG_REQUEST_HANDLE  0x00800000  // dump request handle
#define DBG_TRIGGER_ON      0x10000000  // function is an enabling trigger
#define DBG_TRIGGER_OFF     0x20000000  // function is a disabling trigger
#define DBG_NO_DATA_DUMP    0x40000000  // turn off all data dumping
#define DBG_NO_DEBUG        0x80000000  // turn off all debugging

//
// debug category flags - these control what category of information is output
//

#define DBG_NOTHING         0x00000000  // internal
#define DBG_REGISTRY        0x00000001  //
#define DBG_TRANS           0x00000002  //
#define DBG_BINDING         0x00000004  //
#define DBG_STORAGE         0x00000008  //
#define DBG_TRANSDAT        0x00000010  //
#define DBG_API             0x00000020  //
#define DBG_DOWNLOAD        0x00000040  // 
#define DBG_APP             0x00000080  //
#define DBG_MONIKER         0x00000100  //
#define DBG_TRANSMGR        0x00000200  //
#define DBG_CALLBACK        0x00000400  //
#define DBG_19              0x00000800  //
#define DBG_18              0x00001000  //
#define DBG_17              0x00002000  //
#define DBG_16              0x00004000  //
#define DBG_15              0x00008000  //
#define DBG_14              0x00010000  //
#define DBG_13              0x00020000  //
#define DBG_12              0x00040000  //
#define DBG_11              0x00080000  //
#define DBG_10              0x00100000  //
#define DBG_9               0x00200000  //
#define DBG_8               0x00400000  //
#define DBG_7               0x00800000  //
#define DBG_6               0x01000000  //
#define DBG_5               0x02000000  //
#define DBG_4               0x04000000  //
#define DBG_3               0x08000000  //
#define DBG_2               0x10000000  //
#define DBG_1               0x20000000  //
#define DBG_ANY             0xFFFFFFFF  //

//
// _DEBUG_URLMON_FUNC_RECORD - for each thread, we maintain a LIFO stack of these,
// describing the functions we have visited
//

typedef struct _DEBUG_URLMON_FUNC_RECORD {

    //
    // Stack - a LIFO stack of debug records is maintained in the debug version
    // of the INTERNET_THREAD_INFO
    //

    struct _DEBUG_URLMON_FUNC_RECORD* Stack;

    //
    // Category - the function's category flag(s)
    //

    DWORD Category;

    //
    // ReturnType - type of value returned by function
    //

    DEBUG_FUNCTION_RETURN_TYPE ReturnType;

    //
    // Function - name of the function
    //

    LPCSTR Function;

    //
    // LastTime - if we are dumping times as deltas, keeps the last tick count
    //

    DWORD LastTime;

} DEBUG_URLMON_FUNC_RECORD, *LPDEBUG_URLMON_FUNC_RECORD;

//
// data
//

extern DWORD InternetDebugErrorLevel;
extern DWORD InternetDebugControlFlags;
extern DWORD InternetDebugCategoryFlags;
extern DWORD InternetDebugBreakFlags;

//
// prototypes
//

//
// inetdbg.cxx
//

VOID
InternetDebugInitialize(
    VOID
    );

VOID
InternetDebugTerminate(
    VOID
    );

BOOL
InternetOpenDebugFile(
    VOID
    );

BOOL
InternetReopenDebugFile(
    IN LPSTR Filename
    );

VOID
InternetCloseDebugFile(
    VOID
    );

VOID
InternetFlushDebugFile(
    VOID
    );

VOID
InternetDebugSetControlFlags(
    IN DWORD dwFlags
    );

VOID
InternetDebugResetControlFlags(
    IN DWORD dwFlags
    );

VOID
InternetDebugEnter(
    IN DWORD Category,
    IN DEBUG_FUNCTION_RETURN_TYPE ReturnType,
    IN LPCSTR Function,
    IN LPCSTR ParameterList,
    IN ...
    );

VOID
InternetDebugLeave(
    IN DWORD_PTR Variable,
    IN LPCSTR Filename,
    IN DWORD LineNumber
    );

VOID
InternetDebugError(
    IN DWORD Error
    );

VOID
InternetDebugPrint(
    IN LPSTR Format,
    ...
    );

VOID
InternetDebugPrintValist(
    IN LPSTR Format,
    IN va_list valist
    );

VOID
InternetDebugPrintf(
    IN LPSTR Format,
    IN ...
    );

VOID
InternetDebugOut(
    IN LPSTR Buffer,
    IN BOOL Assert
    );

VOID
InternetDebugDump(
    IN LPSTR Text,
    IN LPBYTE Address,
    IN DWORD Size
    );

DWORD
InternetDebugDumpFormat(
    IN LPBYTE Address,
    IN DWORD Size,
    IN DWORD ElementSize,
    OUT LPSTR Buffer
    );

VOID
InternetAssert(
    IN LPSTR Condition,
    IN LPSTR Filename,
    IN DWORD LineNumber
    );

VOID
InternetGetDebugVariable(
    IN LPSTR lpszVariableName,
    OUT LPDWORD lpdwVariable
    );

LPSTR
InternetMapError(
    IN DWORD Error
    );

int dprintf(char *, ...);

LPSTR
SourceFilename(
    LPSTR Filespec
    );

VOID
InitSymLib(
    VOID
    );

VOID
TermSymLib(
    VOID
    );

LPSTR
GetDebugSymbol(
    DWORD Address,
    LPDWORD Offset
    );

VOID
x86SleazeCallStack(
    OUT LPVOID * lplpvStack,
    IN DWORD dwStackCount,
    IN LPVOID * Ebp
    );

VOID
x86SleazeCallersAddress(
    LPVOID* pCaller,
    LPVOID* pCallersCaller
    );

#else  //ENABLE_DEBUG

#define dprintf (VOID)

#endif //ENABLE_DEBUG

//
// macros
//

#ifdef ENABLE_DEBUG

//
// INET_DEBUG_START - initialize debugging support
//

#define INET_DEBUG_START() \
    InternetDebugInitialize()

//
// INET_DEBUG_FINISH - terminate debugging support
//

#define INET_DEBUG_FINISH() \
    InternetDebugTerminate()

//
// INET_ASSERT - The standard assert, redefined here because Win95 doesn't have
// RtlAssert
//

#if defined(DISABLE_ASSERTS)

#define INET_ASSERT(test) \
    /* NOTHING */

#else // defined(DISABLE_ASSERTS)

#define INET_ASSERT(test) \
    do if (!(test)) { \
        InternetAssert(#test, __FILE__, __LINE__); \
    } while (0)

#endif // defined(DISABLE_ASSERTS)

#else // end #ifdef ENABLE_DEBUG

#define INET_DEBUG_START() \
    /* NOTHING */

#define INET_DEBUG_FINISH() \
    /* NOTHING */

#define INET_ASSERT(test) \
    do { } while(0) /* NOTHING */

#endif // end #ifndef ENABLE_DEBUG

//
// INET_DEBUG_ASSERT - assert only if INET_DEBUG is set
//

#if INET_DEBUG
#define INET_DEBUG_ASSERT(cond) INET_ASSERT(cond)
#else
#define INET_DEBUG_ASSERT(cond) /* NOTHING */
#endif

#if INET_DEBUG

//
// IF_DEBUG_CODE - always on if INET_DEBUG is set
//

#define IF_DEBUG_CODE() \
    if (1)

//
// IF_DEBUG - only execute following code if the specific flag is set
//

#define IF_DEBUG(x) \
    if (InternetDebugCategoryFlags & DBG_ ## x)

//
// IF_DEBUG_CONTROL - only execute if control flag is set
//

#define IF_DEBUG_CONTROL(x) \
    if (InternetDebugControlFlags & DBG_ ## x)

//
// DEBUG_ENTER - creates an INTERNET_DEBUG_RECORD for this function
//

#if defined(RETAIL_LOGGING)

#define DEBUG_ENTER(ParameterList) \
    /* NOTHING */

#define DEBUG_ENTER_API(ParameterList) \
    InternetDebugEnter ParameterList

#else // defined(RETAIL_LOGGING)

#define DEBUG_ENTER_API DEBUG_ENTER
#define DEBUG_ENTER(ParameterList) \
    InternetDebugEnter ParameterList

#endif // defined(RETAIL_LOGGING)

//
// DEBUG_LEAVE - destroys this function's INTERNET_DEBUG_RECORD
//

#if defined(RETAIL_LOGGING)

#define DEBUG_LEAVE(Variable) \
    /* NOTHING */

#define DEBUG_LEAVE_API(Variable) \
    InternetDebugLeave((DWORD_PTR)Variable, __FILE__, __LINE__)

#else // defined(RETAIL_LOGGING)

#define DEBUG_LEAVE_API DEBUG_LEAVE
#define DEBUG_LEAVE(Variable) \
    InternetDebugLeave((DWORD_PTR)Variable, __FILE__, __LINE__)

#endif // defined(RETAIL_LOGGING)

//
// DEBUG_ERROR - displays an error and its symbolic name
//

#define DEBUG_ERROR(Category, Error) \
    if (InternetDebugCategoryFlags & DBG_ ## Category) { \
        InternetDebugError(Error); \
    }

//
// DEBUG_PRINT - print debug info if we are at the correct level or we are
// requested to always dump information at, or above, InternetDebugErrorLevel
//

#if defined(RETAIL_LOGGING)

#define DEBUG_PRINT(Category, ErrorLevel, Args) \
    /* NOTHING */

#define DEBUG_PRINT_API(Category, ErrorLevel, Args) \
    if (((InternetDebugCategoryFlags & DBG_ ## Category) \
        && (DBG_ ## ErrorLevel >= InternetDebugErrorLevel)) \
    || ((InternetDebugControlFlags & DBG_AT_ERROR_LEVEL) \
        && (DBG_ ## ErrorLevel >= InternetDebugErrorLevel))) { \
        InternetDebugPrint Args; \
    }

#else // defined(RETAIL_LOGGING)

#define DEBUG_PRINT_API DEBUG_PRINT
#define DEBUG_PRINT(Category, ErrorLevel, Args) \
    if (((InternetDebugCategoryFlags & DBG_ ## Category) \
        && (DBG_ ## ErrorLevel >= InternetDebugErrorLevel)) \
    || ((InternetDebugControlFlags & DBG_AT_ERROR_LEVEL) \
        && (DBG_ ## ErrorLevel >= InternetDebugErrorLevel))) { \
        InternetDebugPrint Args; \
    }

#endif // defined(RETAIL_LOGGING)

//
// DEBUG_PUT - prints formatted string to debug output stream
//

#if defined(RETAIL_LOGGING)

#define DEBUG_PUT(Args) \
    /* NOTHING */

#else // defined(RETAIL_LOGGING)

#define DEBUG_PUT(Args) \
    InternetDebugPrintf Args

#endif // defined(RETAIL_LOGGING)

//
// DEBUG_DUMP - dump data
//

#if defined(RETAIL_LOGGING)

#define DEBUG_DUMP(Category, Text, Address, Length) \
    /* NOTHING */

#define DEBUG_DUMP_API(Category, Text, Address, Length) \
    if (InternetDebugCategoryFlags & DBG_ ## Category) { \
        InternetDebugDump(Text, (LPBYTE)Address, Length); \
    }

#else // defined(RETAIL_LOGGING)

#define DEBUG_DUMP_API DEBUG_DUMP
#define DEBUG_DUMP(Category, Text, Address, Length) \
    if (InternetDebugCategoryFlags & DBG_ ## Category) { \
        InternetDebugDump(Text, (LPBYTE)Address, Length); \
    }

#endif // defined(RETAIL_LOGGING)

//
// DEBUG_BREAK - break into debugger if break flag is set for this module
//

#define DEBUG_BREAK(Module) \
    if (InternetDebugBreakFlags & DBG_ ## Module) { \
        InternetDebugPrintf("Breakpoint. File %s Line %d\n", \
                            __FILE__, \
                            __LINE__ \
                            ); \
        DebugBreak(); \
    }

//
// WAIT_FOR_SINGLE_OBJECT - perform WaitForSingleObject and check we didn't
// get a timeout
//

#define WAIT_FOR_SINGLE_OBJECT(Object, Error) \
    Error = WaitForSingleObject((Object), DEBUG_WAIT_TIME); \
    if (Error == WAIT_TIMEOUT) { \
        InternetDebugPrintf("single object timeout\n"); \
        DebugBreak(); \
    }

//
// DEBUG_WAIT_TIMER - create DWORD variable for holding time
//

#define DEBUG_WAIT_TIMER(TimerVar) \
    DWORD TimerVar

//
// DEBUG_START_WAIT_TIMER - get current tick count
//

#define DEBUG_START_WAIT_TIMER(TimerVar) \
    TimerVar = GetTickCountWrap()

//
// DEBUG_CHECK_WAIT_TIMER - get the current number of ticks, subtract from the
// previous value recorded by DEBUG_START_WAIT_TIMER and break to debugger if
// outside the predefined range
//

#define DEBUG_CHECK_WAIT_TIMER(TimerVar, MilliSeconds) \
    TimerVar = (GetTickCountWrap() - TimerVar); \
    if (TimerVar > MilliSeconds) { \
        InternetDebugPrintf("Wait time (%d mSecs) exceeds acceptable value (%d mSecs)\n", \
                            TimerVar, \
                            MilliSeconds \
                            ); \
        DebugBreak(); \
    }

#define DEBUG_DATA(Type, Name, InitialValue) \
    Type Name = InitialValue

#define DEBUG_DATA_EXTERN(Type, Name) \
    extern Type Name

#define DEBUG_LABEL(label) \
    label:

#define DEBUG_GOTO(label) \
    goto label

#define DEBUG_ONLY(x) \
    x

#if defined(i386)

#define GET_CALLERS_ADDRESS(p, pp)  x86SleazeCallersAddress(p, pp)
#define GET_CALL_STACK(p)           x86SleazeCallStack((LPVOID *)&p, ARRAY_ELEMENTS(p), 0)

#else // defined(i386)

#define GET_CALLERS_ADDRESS(p, pp)
#define GET_CALL_STACK(p)

#endif // defined(i386)

#else // end #if INET_DEBUG

#define IF_DEBUG_CODE() \
    if (0)

#define IF_DEBUG(x) \
    if (0)

#define IF_DEBUG_CONTROL(x) \
    if (0)

#define DEBUG_ENTER(ParameterList) \
    /* NOTHING */

#define DEBUG_ENTER_API(ParameterList) \
    /* NOTHING */

#define DEBUG_LEAVE(Variable) \
    /* NOTHING */

#define DEBUG_LEAVE_API(Variable) \
    /* NOTHING */

#define DEBUG_ERROR(Category, Error) \
    /* NOTHING */

#define DEBUG_PRINT(Category, ErrorLevel, Args) \
    /* NOTHING */

#define DEBUG_PRINT_API(Category, ErrorLevel, Args) \
    /* NOTHING */

#define DEBUG_PUT(Args) \
    /* NOTHING */

#define DEBUG_DUMP(Category, Text, Address, Length) \
    /* NOTHING */

#define DEBUG_DUMP_API(Category, Text, Address, Length) \
    /* NOTHING */

#define DEBUG_BREAK(module) \
    /* NOTHING */

#define WAIT_FOR_SINGLE_OBJECT(Object, Error) \
    Error = WaitForSingleObject((Object), INFINITE)

#define DEBUG_WAIT_TIMER(TimerVar) \
    /* NOTHING */

#define DEBUG_START_WAIT_TIMER(TimerVar) \
    /* NOTHING */

#define DEBUG_CHECK_WAIT_TIMER(TimerVar, MilliSeconds) \
    /* NOTHING */

#define DEBUG_DATA(Type, Name, InitialValue) \
    /* NOTHING */

#define DEBUG_DATA_EXTERN(Type, Name) \
    /* NOTHING */

#define DEBUG_LABEL(label) \
    /* NOTHING */

#define DEBUG_GOTO(label) \
    /* NOTHING */

#define DEBUG_ONLY(x) \
    /* NOTHING */

#endif // INET_DEBUG

#if defined(__cplusplus)
}
#endif

#endif //ifndef _INETDBG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\inc\eapp.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       iapp.h
//
//  Contents:   precompiled header file for the trans directory
//
//  Classes:
//
//  Functions:
//
//  History:    12-22-95   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------

#include <urlmon.hxx>
#include <compress.h>
#ifdef unix
#include "../eapp/cmimeft.hxx"
#include "../eapp/ccodeft.hxx"
#include "../eapp/protbase.hxx"
#include "../eapp/cdlbsc.hxx"
#include "../eapp/cdlprot.hxx"
#include "../eapp/clshndlr.hxx"
#else
#include "..\eapp\cmimeft.hxx"
#include "..\eapp\ccodeft.hxx"
#include "..\eapp\protbase.hxx"
#include "..\eapp\cdlbsc.hxx"
#include "..\eapp\cdlprot.hxx"
#include "..\eapp\clshndlr.hxx"
#endif /* unix */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\inc\debug.h ===
//+----------------------------------------------------------------------------
//
//	File:
//		debug.h
//
//	Contents:
//		macros and declarations for debug support--all are appropriately
//		defined to nothing when not doing debug build
//
//	Classes:
//
//	Functions:
//
//	History:
//		12/30/93 - ChrisWe - added file prologue; defined _DEBUG when
//			DBG==1; added "const" to ASSERTDATA macro
//
//-----------------------------------------------------------------------------


#ifndef _DEBUG_H_
#define _DEBUG_H_

#include <debnot.h>

#ifndef RC_INVOKED
#ifdef _DEBUG
#define DBGSTATE " Debug is on"
#else
#define DBGSTATE " Debug is off"
#endif
#endif  /* RC_INVOKED */

#ifndef _CAIRO_
#include <ole2dbg.h>
#endif

//these are bogus APIs (they do nothing)
STDAPI_(BOOL) ValidateAllObjects( BOOL fSuspicious );
STDAPI_(void) DumpAllObjects( void );

#ifdef _DEBUG
BOOL InstallHooks(void);
BOOL UnInstallHooks(void);

#undef ASSERTDATA
#define ASSERTDATA

#undef AssertSz
#define AssertSz(a,b) ((a) ? NOERROR : FnAssert(#a, b, __FILE__, __LINE__))
#undef Puts
#define Puts(s) OutputDebugString(TEXT(s))

#else   //  !_DEBUG

#define ASSERTDATA
#define AssertSz(a, b) ((void)0)
#define Puts(s) ((void)0)

#endif  //  _DEBUG


// special Assert for asserts below (since the expression is so large)
// REVIEW, shouldn't these be in the debug.h file?
#ifdef _DEBUG
#define AssertOut(a, b) { if (!(a)) FnAssert(szCheckOutParam, b, __FILE__, __LINE__); }
#else
#define AssertOut(a, b) ((void)0)
#endif

#define AssertOutPtrParam(hr, p) \
	AssertOut(SUCCEEDED(hr) && IsValidPtrIn(p, sizeof(OLECHAR)) || \
	FAILED(hr) && (p) == NULL, \
	szBadOutParam)

#define AssertOutPtrIface(hr, p) \
	AssertOut(SUCCEEDED(hr) && IsValidInterface(p) || \
	FAILED(hr) && (p) == NULL, \
	szBadOutIface)

#define AssertOutPtrFailed(p) \
	AssertOut((p) == NULL, \
	szNonNULLOutPtr)

#define AssertOutStgmedium(hr, pstgm) \
	AssertOut(SUCCEEDED(hr) && (pstgm)->tymed != TYMED_NULL || \
	FAILED(hr) && (pstgm)->tymed == TYMED_NULL, \
	szBadOutStgm)


// assert data for above assert out macros; once per dll
// Note that since these are only used in asserts, we leave them as ANSI
#define ASSERTOUTDATA \
    char szCheckOutParam[] = "check out param"; \
    char szBadOutParam[] = "Out pointer param conventions not followed"; \
    char szBadOutIface[] = "Out pointer interface conventions not followed"; \
    char szNonNULLOutPtr[] = "Out pointer not NULL on error"; \
    char szBadOutStgm[] = "Out stgmed param conventions not followed";

extern char szCheckOutParam[];
extern char szBadOutParam[];
extern char szBadOutIface[];
extern char szNonNULLOutPtr[];
extern char szBadOutStgm[];


#ifdef __cplusplus

interface IDebugStream;

/*
 *  Class CBool wraps boolean values in such a way that they are
 *  readily distinguishable fron integers by the compiler so we can
 *  overload the stream << operator.
 */

class FAR CBool
{
    BOOL value;
public:
    CBool (BOOL& b) {value = b;}
    operator BOOL( void ) { return value; }
};


/*
 *  Class CHwnd wraps HWND values in such a way that they are
 *  readily distinguishable from UINTS by the compiler so we can
 *  overload the stream << operator
 */

class FAR CHwnd
{
	HWND m_hwnd;
	public:
		CHwnd (HWND hwnd) {m_hwnd = hwnd; }
		operator HWND( void ) {return m_hwnd;}
};

/*
 * Class CAtom wraps ATOM values in such a way that they are
 *  readily distinguishable from UINTS by the compiler so we can
 *  overload the stream << operator
 */

class FAR CAtom
{
	ATOM m_atom;
	public:
		CAtom (ATOM atom) {m_atom = atom; }
		operator ATOM( void ) {return m_atom; }
};

/*
 *  IDebugStream is a stream to be used for debug output.  One
 *  implementation uses the OutputDebugString function of Windows.
 *
 *  The style is modeled on that of AT&T streams, and so uses
 *  overloaded operators.  You can write to a stream in the
 *  following ways:
 *
 *    *pdbstm << pUnk;  // calls the IDebug::Dump function to
 *                      display the object, if IDebug is supported.
 *    int n;
 *    *pdbstm << n;     // writes n in decimal
 *
-
 *    *pdbstm << sz;    // writes a string
 *
 *    CBool b(TRUE);
 *    *pdbstm << b;     // writes True or False
 *
 *    void FAR * pv;
 *    *pdbstm << pv;    // writes the address pv in hex
 *
 *    TCHAR ch;
 *    *pdbstm << ch;    // writes the character
 *
 *    ATOM atom;
 *    *pdbstm << CAtom(atom);	// writes the string extracted from the atom
 *
 *    HWND hwnd;
 *    *pdbstm << CHwnd(hwnd);  // writes the info about a window handle
 *
 *  These can be chained together, as such (somewhat artificial
 *  example):
 *
 *    REFCLSID rclsid;
 *    pUnk->GetClass(&rclsid);
 *    *pdbstm << rclsid << " at " << (void FAR *)pUnk <<':' << pUnk;
 *
 *  This produces something like:
 *
 *    CFoo at A7360008: <description of object>
 *
 *  The other useful feature is the Indent and UnIndent functions
 *  which allow an object to print some information, indent, print
 *  the info on its member objects, and unindent.  This gives
 *  nicely formatted output.
 *
 *  WARNING:  do not (while implementing Dump) write
 *
 *    *pdbstm << pUnkOuter
 *
 *  since this will do a QueryInterface for IDebug, and start
 *  recursing!  It is acceptable to write
 *
 *    *pdbstm << (VOID FAR *)pUnkOuter
 *
 *  as this will simply write the address of pUnkOuter.
 *
 */


interface IDebugStream : public IUnknown
{
    STDMETHOD_(IDebugStream&, operator << ) ( IUnknown FAR * pDebug ) = 0;
    STDMETHOD_(IDebugStream&, operator << ) ( REFCLSID rclsid ) = 0;
    STDMETHOD_(IDebugStream&, operator << ) ( int n ) = 0;
    STDMETHOD_(IDebugStream&, operator << ) ( long l ) = 0;
    STDMETHOD_(IDebugStream&, operator << ) ( ULONG l ) = 0;
    STDMETHOD_(IDebugStream&, operator << ) ( LPCTSTR sz ) = 0;
    STDMETHOD_(IDebugStream&, operator << ) ( TCHAR ch ) = 0;
    STDMETHOD_(IDebugStream&, operator << ) ( void FAR * pv ) = 0;
    STDMETHOD_(IDebugStream&, operator << ) ( CBool b ) = 0;
    STDMETHOD_(IDebugStream&, operator << ) ( CHwnd hwnd ) = 0;
    STDMETHOD_(IDebugStream&, operator << ) ( CAtom atom ) = 0;
    STDMETHOD_(IDebugStream&, Tab )( void ) = 0;
    STDMETHOD_(IDebugStream&, Indent )( void ) = 0;
    STDMETHOD_(IDebugStream&, UnIndent )( void ) = 0;
    STDMETHOD_(IDebugStream&, Return )( void ) = 0;
    STDMETHOD_(IDebugStream&, LF )( void ) = 0;
};

STDAPI_(IDebugStream FAR*) MakeDebugStream( short margin=70, short tabsize=4, BOOL fHeader=1);


interface IDebug
{
    STDMETHOD_(void, Dump )( IDebugStream FAR * pdbstm ) = 0;
    STDMETHOD_(BOOL, IsValid )( BOOL fSuspicious = FALSE ) = 0;

#ifdef NEVER
    __export IDebug(void);
    __export ~IDebug(void);
private:

#ifdef _DEBUG
    IDebug FAR * pIDPrev;
    IDebug FAR * pIDNext;

    friend void STDAPICALLTYPE DumpAllObjects( void );
    friend BOOL STDAPICALLTYPE ValidateAllObjects( BOOL fSuspicious );
#endif // _DEBUG
#endif // NEVER
};

/*************************************************************************
** The following functions can be used to log debug messages to a file
**    and simutaneously write them to the dbwin debug window.
**    The CDebugStream implementation automatically writes to a debug
**    log file called "debug.log" in the current working directory.
**    NOTE: The functions are only intended for C programmers. C++
**    programmers should use the "MakeDebugStream" instead.
*************************************************************************/

// Open a log file.
STDAPI_(HFILE) DbgLogOpen(LPCTSTR lpszFile, LPCTSTR lpszMode);

// Close the log file.
STDAPI_(void) DbgLogClose(HFILE fh);

// Write to debug log and debug window (used with cvw.exe or dbwin.exe).
STDAPI_(void) DbgLogOutputDebugString(HFILE fh, LPCTSTR lpsz);

// Write to debug log only.
STDAPI_(void) DbgLogWrite(HFILE fh, LPCTSTR lpsz);

// Write the current Date and Time to the log file.
STDAPI_(void) DbgLogTimeStamp(HFILE fh, LPCTSTR lpsz);

// Write a banner separater to the log to separate sections.
STDAPI_(void) DbgLogWriteBanner(HFILE fh, LPCTSTR lpsz);




/*
 *  STDDEBDECL macro - helper for debug declaration
 *
 */

#ifdef _DEBUG

        #define STDDEBDECL(ignore, classname ) implement CDebug:public IDebug { public: \
            CDebug( C##classname FAR * p##classname ) { m_p##classname = p##classname;} \
            ~CDebug(void) {} \
            STDMETHOD_(void, Dump)(IDebugStream FAR * pdbstm ); \
            STDMETHOD_(BOOL, IsValid)(BOOL fSuspicious ); \
            private: C##classname FAR* m_p##classname; }; \
            DECLARE_NC(C##classname, CDebug) \
            CDebug m_Debug;

    #define CONSTRUCT_DEBUG m_Debug(this),

#else //        _DEBUG

//      no debugging
#define STDDEBDECL(cclassname,classname)
#define CONSTRUCT_DEBUG

#endif  //      _DEBUG

#endif // __cplusplus

#endif // !_DEBUG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\inc\mluisupp.h ===
#ifndef _INC_MLUISUPP
#define _INC_MLUISUPP

#include <shlwapi.h>
#include <shlwapip.h>

#ifdef __cplusplus
extern "C"
{
#endif

//+------------------------------------------------------------------
// Multilang Pluggable UI support
// inline functions defs (to centralize code)
// copied over from shell\inc\mluisupp.h with unneeded stuff removed.
//+------------------------------------------------------------------

#ifdef UNICODE
#define MLLoadString            MLLoadStringW
#define MLLoadShellLangString   MLLoadShellLangStringW
#define MLLoadResources         MLLoadResourcesW
#else
#define MLLoadString            MLLoadStringA
#define MLLoadShellLangString   MLLoadShellLangStringA
#define MLLoadResources         MLLoadResourcesA
#endif

void        MLFreeResources(HINSTANCE hinstParent);
HINSTANCE   MLGetHinst();
HINSTANCE   MLLoadShellLangResources();
void        ResWinHelp(HWND hwnd, int ids, int id2, DWORD_PTR dwp);

#ifdef MLUI_MESSAGEBOX
int         MLShellMessageBox(HWND hWnd, LPCTSTR pszMsg, LPCTSTR pszTitle, UINT fuStyle, ...);
#endif

//
// The following should be both A and W suffixed
//

int         MLLoadStringA(UINT id, LPSTR sz, UINT cchMax);
int         MLLoadStringW(UINT id, LPWSTR sz, UINT cchMax);

int         MLLoadShellLangStringA(UINT id, LPSTR sz, UINT cchMax);
int         MLLoadShellLangStringW(UINT id, LPWSTR sz, UINT cchMax);

void        MLLoadResourcesA(HINSTANCE hinstParent, LPSTR pszLocResDll);
void        MLLoadResourcesW(HINSTANCE hinstParent, LPWSTR pszLocResDll);

//
// End of: The following should be both A and W suffixed
//

#ifdef MLUI_INIT

// WARNING: do not attempt to access any of these members directly
// these members may not be initialized until appropriate accessors
// are called, for example hinstLocRes won't be intialized until
// you call MLGetHinst()... so just call the accessor.
struct tagMLUI_INFO
{
    HINSTANCE   hinstLocRes;
    HINSTANCE   hinstParent;
    WCHAR       szLocResDll[MAX_PATH];
    DWORD       dwCrossCodePage;
} g_mluiInfo;


// REARCHITECT: These aren't thread safe... Do they need to be?
//
void MLLoadResourcesA(HINSTANCE hinstParent, LPSTR pszLocResDll)
{
    if (g_mluiInfo.hinstLocRes == NULL)
    {
#ifdef MLUI_SUPPORT
        // plugUI: resource dll == ?
        // resource dll must be dynamically determined and loaded.
        // but we are NOT allowed to LoadLibrary during process attach.
        // therefore we cache the info we need and load later when
        // the first resource is requested.
        SHAnsiToUnicode(pszLocResDll, g_mluiInfo.szLocResDll, sizeof(g_mluiInfo.szLocResDll)/sizeof(g_mluiInfo.szLocResDll[0]));
        g_mluiInfo.hinstParent = hinstParent;
        g_mluiInfo.dwCrossCodePage = ML_CROSSCODEPAGE;
#else
        // non-plugUI: resource dll == parent dll
        g_mluiInfo.hinstLocRes = hinstParent;
#endif
    }
}

void MLLoadResourcesW(HINSTANCE hinstParent, LPWSTR pszLocResDll)
{
    if (g_mluiInfo.hinstLocRes == NULL)
    {
#ifdef MLUI_SUPPORT
        // plugUI: resource dll == ?
        // resource dll must be dynamically determined and loaded.
        // but we are NOT allowed to LoadLibrary during process attach.
        // therefore we cache the info we need and load later when
        // the first resource is requested.
        StrCpyNW(g_mluiInfo.szLocResDll, pszLocResDll, sizeof(g_mluiInfo.szLocResDll)/sizeof(g_mluiInfo.szLocResDll[0]));
        g_mluiInfo.hinstParent = hinstParent;
        g_mluiInfo.dwCrossCodePage = ML_CROSSCODEPAGE;
#else
        // non-plugUI: resource dll == parent dll
        g_mluiInfo.hinstLocRes = hinstParent;
#endif
    }
}

void
MLFreeResources(HINSTANCE hinstParent)
{
    if (g_mluiInfo.hinstLocRes != NULL &&
        g_mluiInfo.hinstLocRes != hinstParent)
    {
        MLClearMLHInstance(g_mluiInfo.hinstLocRes);
        g_mluiInfo.hinstLocRes = NULL;
    }
}

// this is a private internal helper.
// don't you dare call it from anywhere except at
// the beginning of new ML* functions in this file
__inline void
_MLResAssure()
{
#ifdef MLUI_SUPPORT
    if(g_mluiInfo.hinstLocRes == NULL)
    {
        g_mluiInfo.hinstLocRes = MLLoadLibraryW(g_mluiInfo.szLocResDll,
                                               g_mluiInfo.hinstParent,
                                               g_mluiInfo.dwCrossCodePage);

        // we're guaranteed to at least have resources in the install language
        ASSERT(g_mluiInfo.hinstLocRes != NULL);
    }
#endif
}

int
MLLoadStringA(UINT id, LPSTR sz, UINT cchMax)
{
    _MLResAssure();
    return LoadStringA(g_mluiInfo.hinstLocRes, id, sz, cchMax);
}

int
MLLoadStringW(UINT id, LPWSTR sz, UINT cchMax)
{
    _MLResAssure();
    return LoadStringWrapW(g_mluiInfo.hinstLocRes, id, sz, cchMax);
}

int
MLLoadShellLangStringA(UINT id, LPSTR sz, UINT cchMax)
{
    HINSTANCE   hinstShellLangRes;
    int         nRet;

    hinstShellLangRes = MLLoadShellLangResources();
    
    nRet = LoadStringA(hinstShellLangRes, id, sz, cchMax);

    MLFreeLibrary(hinstShellLangRes);

    return nRet;
}

int
MLLoadShellLangStringW(UINT id, LPWSTR sz, UINT cchMax)
{
    HINSTANCE   hinstShellLangRes;
    int         nRet;

    hinstShellLangRes = MLLoadShellLangResources();
    
    nRet = LoadStringWrapW(hinstShellLangRes, id, sz, cchMax);

    MLFreeLibrary(hinstShellLangRes);

    return nRet;
}

HINSTANCE
MLGetHinst()
{
    _MLResAssure();
    return g_mluiInfo.hinstLocRes;
}

HINSTANCE
MLLoadShellLangResources()
{
    HINSTANCE hinst;
    
    hinst = MLLoadLibraryW(g_mluiInfo.szLocResDll,
                           g_mluiInfo.hinstParent,
                           ML_SHELL_LANGUAGE);

    // we're guaranteed to at least have resources in the install language
    // unless we're 100% toasted

    return hinst;
}

BOOL
MLWinHelpWrap(HWND hwndCaller,
                   LPCTSTR lpszHelp,
                   UINT uCommand,
                   DWORD_PTR dwData)
{
    BOOL    fRet;

#ifdef MLUI_SUPPORT
    fRet = MLWinHelp(hwndCaller,
                     lpszHelp,
                     uCommand,
                     dwData);
#else
    fRet = WinHelp(hwndCaller,
                   lpszHelp,
                   uCommand,
                   dwData);
#endif

    return fRet;
}

LPTSTR LoadSz(UINT idString, LPTSTR lpszBuf, UINT cbBuf)
{
    // Clear the buffer and load the string
    if ( lpszBuf )
    {
        *lpszBuf = '\0';
        MLLoadString( idString, lpszBuf, cbBuf );
    }
    return lpszBuf;
}

void ResWinHelp(HWND hwnd, int ids, int id2, DWORD_PTR dwp)
{
    TCHAR szSmallBuf[50+1];
    MLWinHelpWrap((HWND)hwnd, LoadSz(ids,szSmallBuf,sizeof(szSmallBuf)),
            id2, (DWORD_PTR)dwp);
}
#endif  // MLUI_INIT

#ifdef __cplusplus
};
#endif

#endif  // _INC_MLUISUPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\inc\map_kv.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       map_kv.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    10-29-1996   JohannP (Johann Posch)   taken from OLE
//
//----------------------------------------------------------------------------
#ifndef __MAP_KV_H__
#define __MAP_KV_H__

typedef void FAR* POSITION;
#define BEFORE_START_POSITION ((POSITION)(ULONG_PTR)-1L)


/////////////////////////////////////////////////////////////////////////////
// class CMapKeyToValue - a mapping from 'KEY's to 'VALUE's, passed in as
// pv/cb pairs.  The keys can be variable length, although we optmizize the
// case when they are all the same.
//
/////////////////////////////////////////////////////////////////////////////

STDAPI_(UINT) MKVDefaultHashKey(LPVOID pKey, UINT cbKey);
DECLARE_HANDLE(HMAPKEY);
typedef UINT (STDAPICALLTYPE FAR* LPFNHASHKEY)(LPVOID, UINT);

class FAR CMapKeyToValue
{
public:
        CMapKeyToValue(UINT cbValue, UINT cbKey = 0,
                int nBlockSize=10,
                LPFNHASHKEY lpfnHashKey = NULL,
                UINT nHashSize = 17);
        ~CMapKeyToValue();

        // number of elements
        int     GetCount() const { return m_nCount; }
        BOOL    IsEmpty() const { return m_nCount == 0; }

        // Lookup; return FALSE if not found
        BOOL    Lookup(LPVOID pKey, UINT cbKey, LPVOID pValue) const;
        BOOL    LookupHKey(HMAPKEY hKey, LPVOID pValue) const;
        BOOL    LookupAdd(LPVOID pKey, UINT cbKey, LPVOID pValue) const;

        // add a new (key, value) pair; return FALSE if out of memory
        BOOL    SetAt(LPVOID pKey, UINT cbKey, LPVOID pValue);
        BOOL    SetAtHKey(HMAPKEY hKey, LPVOID pValue);

        // removing existing (key, ?) pair; return FALSE if no such key
        BOOL    RemoveKey(LPVOID pKey, UINT cbKey);
        BOOL    RemoveHKey(HMAPKEY hKey);
        void    RemoveAll();

        // iterating all (key, value) pairs
        POSITION GetStartPosition() const
                        { return (m_nCount == 0) ? (POSITION)NULL : BEFORE_START_POSITION; }
        void    GetNextAssoc(POSITION FAR* pNextPosition, LPVOID pKey,
                                UINT FAR* pcbKey, LPVOID pValue) const;

        // return HMAPKEY for given key; returns NULL if not currently in map
        HMAPKEY GetHKey(LPVOID pKey, UINT cbKey) const;

        void    AssertValid() const;
#ifndef unix
private:
#else
    // If this was not made public we get complier warnings
    // that CKeyWrap is not accessible from CAssoc declared below
    // which means global functions cant return CNode pointers
public:
#endif /* unix */
        // abstracts, somewhat, variable and fixed sized keys; size is really
        // m_cbKeyInAssoc.
        union CKeyWrap
        {
                BYTE rgbKey[sizeof(LPVOID) + sizeof(UINT)];
                struct
                {
                        LPVOID pKey;
                        UINT cbKey;
                }
#ifdef unix
                n 
#endif /* unix */
                ;
        };
        // Association of one key and one value; NOTE: even though in general
        // the size of the key and value varies, for any given map,
        // the size of an assoc is fixed.
        struct CAssoc
        {
                CAssoc  FAR* pNext;
                UINT    nHashValue; // needed for efficient iteration
                CKeyWrap key;           // size is really m_cbKeyInAssoc
                // BYTE rgbValue[m_cbValue];
        };
#ifdef unix
private:
#endif /* unix */
        UINT    SizeAssoc() const
                { return sizeof(CAssoc)-sizeof(CKeyWrap) + m_cbKeyInAssoc + m_cbValue; }
        CAssoc  FAR* NewAssoc(UINT hash, LPVOID pKey, UINT cbKey, LPVOID pValue);
        void    FreeAssoc(CAssoc FAR* pAssoc);
        BOOL    CompareAssocKey(CAssoc FAR* pAssoc, LPVOID pKey, UINT cbKey) const;
        CAssoc  FAR* GetAssocAt(LPVOID pKey, UINT cbKey, UINT FAR& nHash) const;

        BOOL    SetAssocKey(CAssoc FAR* pAssoc, LPVOID pKey, UINT cbKey) const;
        void    GetAssocKeyPtr(CAssoc FAR* pAssoc, LPVOID FAR* ppKey,UINT FAR* pcbKey) const;
        void    FreeAssocKey(CAssoc FAR* pAssoc) const;
        void    GetAssocValuePtr(CAssoc FAR* pAssoc, LPVOID FAR* ppValue) const;
        void    GetAssocValue(CAssoc FAR* pAssoc, LPVOID pValue) const;
        void    SetAssocValue(CAssoc FAR* pAssoc, LPVOID pValue) const;

        BOOL    InitHashTable();

        UINT    m_cbValue;
        UINT    m_cbKey;                        // variable length if 0
        UINT    m_cbKeyInAssoc;         // always non-zero

        CAssoc  FAR* FAR* m_pHashTable;
        UINT    m_nHashTableSize;
        LPFNHASHKEY m_lpfnHashKey;

        int     m_nCount;
        CAssoc  FAR* m_pFreeList;
        struct CPlex FAR* m_pBlocks;
        int     m_nBlockSize;
};


#endif // !__MAP_KV_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\inc\notiftn.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       trans.h
//
//  Contents:   precompiled header file for the trans directory
//
//  Classes:
//
//  Functions:
//
//  History:    12-22-95   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------

#include <urlmon.hxx>
#include <tls.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\inc\mon.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       iapp.h
//
//  Contents:   precompiled header file for the trans directory
//
//  Classes:
//
//  Functions:
//
//  History:    12-22-95   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------

#include <urlmon.hxx>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\inc\trans.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       trans.h
//
//  Contents:   precompiled header file for the trans directory
//
//  Classes:
//
//  Functions:
//
//  History:    12-22-95   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------

#include <urlmon.hxx>
#ifndef unix
#include "..\trans\transact.hxx"
#include "..\trans\bindctx.hxx"
#else
#include "../trans/transact.hxx"
#include "../trans/bindctx.hxx"
#endif /* unix */
#include <tls.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\inc\tls.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       tls.h
//
//  Contents:   Manage thread local storage for UrlMon.
//              The non-inline routines are in ..\mon\tls.cxx
//  Classes:
//
//  Functions:
//
//  History:    12-02-95   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------

#ifndef _TLS_H_
#define _TLS_H_

#include "clist.hxx"
#include "cookie.hxx"
#include "inetdbg.h"

class CTransactionMgr;
class CCDLPacketMgr;
class CCodeDownload;
class CDownload;
// notification/scheduler

//+---------------------------------------------------------------------------
//
// forward declarations (in order to avoid type casting when accessing
// data members of the SOleTlsData structure).
//
//+---------------------------------------------------------------------------

extern DWORD  gTlsIndex;                    // global Index for TLS

//+---------------------------------------------------------------------------
//
//  Enum:       URLMKTLSFLAGS
//
//  Synopsys:   bit values for dwFlags field of SUrlMkTlsData. If you just want
//              to store a BOOL in TLS, use this enum and the dwFlag field.
//
//+---------------------------------------------------------------------------
typedef enum tagURLMKTLSFLAGS
{
    URLMKTLS_LOCALTID        = 1,  // whether TID is in current process or not
    URLMKTLS_UUIDINITIALIZED = 2,  // whether logical thread was init'd
    URLMKTLS_INTHREADDETACH  = 4,  // Whether we are in thread detach. Needed
                                   // due to NT's special thread detach rules.
}  URLMKTLSFLAGS;


//+---------------------------------------------------------------------------
//
//  Structure:  SUrlMkTlsData
//
//  Synopsis:   structure holding per thread state needed by UrlMon
//
//+---------------------------------------------------------------------------
typedef struct tagSUrlMkTlsData
{
    DWORD               dwApartmentID;      // Per thread "process ID"
    DWORD               dwFlags;            // see URLMKTLSFLAGS above
    HWND                hwndUrlMkNotify;    // notification window
    LONG                cDispatchLevel;     // dispatch nesting level

    CTransactionMgr    *pCTransMgr;         // transaction manager

#ifdef PER_THREAD
    CMediaTypeHolder   *pCMediaHolder;      // media types register per apartment
#endif //PER_THREAD

    CList<CCodeDownload *,CCodeDownload *>*
                        pCodeDownloadList;  // linked list of pointers to
                                            // CCodeDownload objects ongoing on
                                            // this thread
    CCookie<CDownload*> *pTrustCookie;

                                            // only the cookie owner can do
                                            // setup/winverifytrust
                                            // Others wait for the
                                            // cookie to enter these phases
                                            // Cookie availabilty is posted
                                            // as a msg. We can't uses any
                                            // regular sync apis as this
                                            // is protecting execution by the
                                            // same thread in a diff msg.
    CCookie<CCodeDownload*>
                        *pSetupCookie;


    CCDLPacketMgr       *pCDLPacketMgr;     // per thread packet manager
                                            // A packet is a unit
                                            // of work that takes time eg.
                                            // trust verifcation of a piece
                                            // setup of a piece or INF
                                            // processing of one piece.
                                            // To be able to have the
                                            // client be responsive with UI
                                            // and abort capabilty we need
                                            // to split out work into as
                                            // small units as possible
                                            // and queue up these packets
                                            // Packets get run on a timer per
                                            // thread.
    CList<LPCWSTR ,LPCWSTR >*
                        pRejectedFeaturesList;
                                            // linked list of pointers to
                                            // features or code downloads that
                                            // the use has explicitly rejected
                                            // on this thread

#if DBG==1
    LONG                cTraceNestingLevel; // call nesting level for UrlMonTRACE
#endif

#ifdef ENABLE_DEBUG
    DWORD ThreadId;
    LPDEBUG_URLMON_FUNC_RECORD Stack;
    int CallDepth;
    int IndentIncrement;    

    DWORD StartTime;
    DWORD StopTime;

    DWORD MajorCategoryFlags;
    DWORD MinorCategoryFlags;
#endif //ENABLE_DEBUG

} SUrlMkTlsData;

//+---------------------------------------------------------------------------
//
//  class       CUrlMkTls
//
//  Synopsis:   class to abstract thread-local-storage in UrlMon.
//
//  Notes:      To use Tls in UrlMon, functions should define an instance of
//              this class on their stack, then use the -> operator on the
//              instance to access fields of the SOleTls structure.
//
//              There are two instances of the ctor. One just Assert's that
//              the SUrlMkTlsData has already been allocated for this thread. Most
//              internal code should use this ctor, since we can assert that if
//              the thread made it this far into our code, tls has already been
//              checked.
//
//              The other ctor will check if SUrlMkTlsData exists, and attempt to
//              allocate and initialize it if it does not. This ctor will
//              return an HRESULT. Functions that are entry points to UrlMon
//              should use this version.
//
//  History:    12-02-95   JohannP (Johann Posch)   Created
//
//+---------------------------------------------------------------------------
class CUrlMkTls
{
public:
    CUrlMkTls(HRESULT &hr);

    // to get direct access to the data structure
    SUrlMkTlsData * operator->(void);

private:

    HRESULT      TLSAllocData(); // allocates an SUrlMkTlsData structure

    SUrlMkTlsData * _pData;       // ptr to UrlMon TLS data
};

//+---------------------------------------------------------------------------
//
//  Method:     CUrlMkTls::CUrlMkTls
//
//  Synopsis:   ctor for UrlMon Tls object.
//
//  Notes:      Peripheral UrlMon code that can not assume that some outer-layer
//              function has already verified the existence of the SUrlMkTlsData
//              structure for the current thread should use this version of
//              the ctor.
//
//  History:    12-02-95   JohannP (Johann Posch)   Created
//
//+---------------------------------------------------------------------------
inline CUrlMkTls::CUrlMkTls(HRESULT &hr)
{
    _pData = (SUrlMkTlsData *) TlsGetValue(gTlsIndex);
    if (_pData)
        hr = S_OK;
    else
        hr = TLSAllocData();
}

//+---------------------------------------------------------------------------
//
//  Member:     CUrlMkTls::operator->(void)
//
//  Synopsis:   returns ptr to the data structure
//
//  History:    12-02-95   JohannP (Johann Posch)   Created
//
//+---------------------------------------------------------------------------
inline SUrlMkTlsData * CUrlMkTls::operator->(void)
{
    return _pData;
}



typedef struct URLMON_TS
{
    DWORD           _dwTID;
    HWND            _hwndNotify;
    URLMON_TS*      _pNext;
} URLMON_TS, *LPURLMON_TS;

#endif // _TLS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\inc\urlb.h ===
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <errno.h>
#include <io.h>

#include <ole2.h>
#include <shellapi.h>
#include <urlmon.h>
//#include <webchk.h>
#include <wininet.h>
#include "com.hxx"
//#include "urlint.h"

#include "urlmon.hxx"
#include "..\urlbind\urlbind.hxx"
#include "..\urlbind\threads.hxx"
#include "..\urlbind\acceptor.hxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\inc\urlint.h ===
//+---------------------------------------------------------------------------
    //
    //  Microsoft Windows
    //  Copyright (C) Microsoft Corporation, 1992 - 1995.
    //
    //  File:       urlint.h
    //
    //  Contents:   internal include file for ulrmon project
    //
    //  Classes:
    //
    //  Functions:
    //
    //  History:    10-25-95   JohannP (Johann Posch)   Created
    //
    //----------------------------------------------------------------------------
    #ifndef _URLINT_H_
    #define _URLINT_H_
    #define _WITH_INTERNET_URL_ZONES_
    #ifdef ALPHA    // required for Wx86 support
    #include <nt.h>
    #include <ntrtl.h>
    #include <nturtl.h>
    #endif
    #include <urlmki.h>
    #include <debug.h>
    #include <valid.h>
    #include <perftags.h>
    #include <crtsubst.h>
    #include <inetdbg.h> //for DEBUG_* macros/functions
        
    #ifndef ARRAYSIZE
    #define ARRAYSIZE(a)    (sizeof(a)/sizeof(a[0]))
    #endif
    
    #if DBG==1
    #define XDBG(dbg,nondbg)    dbg
    #else
    #define XDBG(dbg,nondbg)    nondbg
    #endif
    
    #if DBG == 1
    //interface IDebugOut : public IUnknown
    #undef INTERFACE
    #define INTERFACE   IDebugOut
    DECLARE_INTERFACE_(IDebugOut,IUnknown)
    {
        // *** IUnknown methods ***
        STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
        STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
        STDMETHOD_(ULONG,Release) (THIS) PURE;
    
        // *** IDebugOut methods ***
        STDMETHOD_(void, SendEntry) (THIS_ DWORD ThreadId, DWORD dwFlags, LPCSTR pstr, DWORD dwReserved) PURE;
    };
    
    
    #undef INTERFACE
    #define INTERFACE   IDebugRegister
    DECLARE_INTERFACE_(IDebugRegister,IUnknown)
    {
        // *** IUnknown methods ***
        STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
        STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
        STDMETHOD_(ULONG,Release) (THIS) PURE;
    
        // *** IDebugRegister methods ***
        STDMETHOD(GetFacilities) (THIS_ LPCWSTR *ppwzNames, DWORD *pcNames, DWORD dwReserved) PURE;
        STDMETHOD(Register) (THIS_ LPCWSTR pwzName, IDebugOut *pDbgOut, DWORD dwFlags, DWORD dwReserved) PURE;
    };
    
    // each thread can have it's own IDebugOut interface
    EXTERN_C HRESULT RegisterDebugOut(LPCWSTR pwzName, DWORD dwOptions, IDebugOut *pDbgOut, DWORD dwReserved);
    void UrlSpySendEntry(IDebugOut *pDbgOut, LPSTR szOutBuffer, DWORD ThreadId = 0, DWORD dwFlags = 0, DWORD dwReserved = 0);
    void UrlSpyFn(int iOption, const char *pscFormat, ...);
    
    #define PerfDbgTag(tag, szOwner, szDescrip, iOption) int tag = iOption;
    #define     DbgTag(tag, szOwner, szDescrip, iOption) int tag = iOption;
    #define PerfDbgExtern(tag) extern int tag;
    #define     DbgExtern(tag) extern int tag;
    #define PerfDbgLog(tag,pv,f) PerfDbgLogFn(tag,pv,f)
    #define PerfDbgLog1(tag,pv,f,a1) PerfDbgLogFn(tag,pv,f,a1)
    #define PerfDbgLog2(tag,pv,f,a1,a2) PerfDbgLogFn(tag,pv,f,a1,a2)
    #define PerfDbgLog3(tag,pv,f,a1,a2,a3) PerfDbgLogFn(tag,pv,f,a1,a2,a3)
    #define PerfDbgLog4(tag,pv,f,a1,a2,a3,a4) PerfDbgLogFn(tag,pv,f,a1,a2,a3,a4)
    #define PerfDbgLog5(tag,pv,f,a1,a2,a3,a4,a5) PerfDbgLogFn(tag,pv,f,a1,a2,a3,a4,a5)
    #define PerfDbgLog6(tag,pv,f,a1,a2,a3,a4,a5,a6) PerfDbgLogFn(tag,pv,f,a1,a2,a3,a4,a5,a6)
    #define PerfDbgLog7(tag,pv,f,a1,a2,a3,a4,a5,a6,a7) PerfDbgLogFn(tag,pv,f,a1,a2,a3,a4,a5,a6,a7)
    #define PerfDbgLog8(tag,pv,f,a1,a2,a3,a4,a5,a6,a7,a8) PerfDbgLogFn(tag,pv,f,a1,a2,a3,a4,a5,a6,a7,a8)
    #define PerfDbgLog9(tag,pv,f,a1,a2,a3,a4,a5,a6,a7,a8,a9) PerfDbgLogFn(tag,pv,f,a1,a2,a3,a4,a5,a6,a7,a8,a9)
    #define PerfDbgLogN(x) PerfDbgLogFn x
    #define     DbgLog(tag,pv,f) PerfDbgLogFn(tag,pv,f)
    #define     DbgLog1(tag,pv,f,a1) PerfDbgLogFn(tag,pv,f,a1)
    #define     DbgLog2(tag,pv,f,a1,a2) PerfDbgLogFn(tag,pv,f,a1,a2)
    #define     DbgLog3(tag,pv,f,a1,a2,a3) PerfDbgLogFn(tag,pv,f,a1,a2,a3)
    #define     DbgLog4(tag,pv,f,a1,a2,a3,a4) PerfDbgLogFn(tag,pv,f,a1,a2,a3,a4)
    #define     DbgLog5(tag,pv,f,a1,a2,a3,a4,a5) PerfDbgLogFn(tag,pv,f,a1,a2,a3,a4,a5)
    #define     DbgLog6(tag,pv,f,a1,a2,a3,a4,a5,a6) PerfDbgLogFn(tag,pv,f,a1,a2,a3,a4,a5,a6)
    #define     DbgLog7(tag,pv,f,a1,a2,a3,a4,a5,a6,a7) PerfDbgLogFn(tag,pv,f,a1,a2,a3,a4,a5,a6,a7)
    #define     DbgLog8(tag,pv,f,a1,a2,a3,a4,a5,a6,a7,a8) PerfDbgLogFn(tag,pv,f,a1,a2,a3,a4,a5,a6,a7,a8)
    #define     DbgLog9(tag,pv,f,a1,a2,a3,a4,a5,a6,a7,a8,a9) PerfDbgLogFn(tag,pv,f,a1,a2,a3,a4,a5,a6,a7,a8,a9)
    #define     DbgLogN(x) PerfDbgLogFn x
    void    PerfDbgLogFn(int tag, void * pvObj, const char * pchFmt, ...);
    
    #   define DEB_LEVEL_SHIFT      28
    #   define DEB_LEVEL_MASK       0x0FFFFFFF
    
        DECLARE_DEBUG(UrlMk)
    #   define UrlMkUrlSpy          UrlSpyFn
    #   define UrlMkDebugOut(x)     UrlMkUrlSpy x
    #   define UrlMkAssert(x)       Win4Assert(x)
    #   define UrlMkVerify(x)       UrlMkAssert(x)
    #   define DEB_URLMK_LEVEL      0x00000000
    #   define DEB_ASYNCAPIS        (DEB_USER1 | DEB_URLMK_LEVEL)
    #   define DEB_URLMON           (DEB_USER2 | DEB_URLMK_LEVEL)
    #   define DEB_ISTREAM          (DEB_USER3 | DEB_URLMK_LEVEL)
    #   define DEB_DLL              (DEB_USER4 | DEB_URLMK_LEVEL)
    #   define DEB_FORMAT           (DEB_USER5 | DEB_URLMK_LEVEL)
    #   define DEB_CODEDL           (DEB_USER6 | DEB_URLMK_LEVEL)
    
        DECLARE_DEBUG(Trans)
    #   define TransUrlSpy          UrlSpyFn
    #   define TransDebugOut(x)     TransUrlSpy x
    #   define TransAssert(x)       Win4Assert(x)
    #   define TransVerify(x)       TransAssert(x)
    #   define DEB_TRANS_LEVEL      0x10000000
    #   define DEB_BINDING          (DEB_USER1 | DEB_TRANS_LEVEL)
    #   define DEB_TRANS            (DEB_USER2 | DEB_TRANS_LEVEL)
    #   define DEB_TRANSPACKET      (DEB_USER3 | DEB_TRANS_LEVEL)
    #   define DEB_DATA             (DEB_USER4 | DEB_TRANS_LEVEL)
    #   define DEB_TRANSMGR         (DEB_USER5 | DEB_TRANS_LEVEL)
    #   define DEB_SESSION          (DEB_USER6 | DEB_TRANS_LEVEL)
    
        DECLARE_DEBUG(PProt)
    #   define PProtUrlSpy          UrlSpyFn
    #   define PProtDebugOut(x)     PProtUrlSpy x
    #   define PProtAssert(x)       Win4Assert(x)
    #   define PProtVerify(x)       PProtAssert(x)
    #   define DEB_PROT_LEVEL       0x20000000
    #   define DEB_PROT             (DEB_USER1 | DEB_PROT_LEVEL)
    #   define DEB_PROTHTTP         (DEB_USER2 | DEB_PROT_LEVEL)
    #   define DEB_PROTFTP          (DEB_USER3 | DEB_PROT_LEVEL)
    #   define DEB_PROTGOPHER       (DEB_USER4 | DEB_PROT_LEVEL)
    #   define DEB_PROTSIMP         (DEB_USER5 | DEB_PROT_LEVEL)
    
        DECLARE_DEBUG(Notf)
    #   define NotfUrlSpy          UrlSpyFn
    #   define NotfDebugOut(x)     NotfUrlSpy x
    #   define NotfAssert(x)       Win4Assert(x)
    #   define NotfVerify(x)       NotfAssert(x)
    #   define DEB_NOTF_LEVEL       0x30000000
    
    #   define DEB_NOTF_1             (DEB_USER1  | DEB_NOTF_LEVEL)
    #   define DEB_NOTF_2             (DEB_USER2  | DEB_NOTF_LEVEL)
    #   define DEB_NOTF_3             (DEB_USER3  | DEB_NOTF_LEVEL)
    #   define DEB_NOTF_4             (DEB_USER4  | DEB_NOTF_LEVEL)
    #   define DEB_NOTF_5             (DEB_USER5  | DEB_NOTF_LEVEL)
    #   define DEB_NOTF_6             (DEB_USER6  | DEB_NOTF_LEVEL)
    #   define DEB_NOTF_7             (DEB_USER7  | DEB_NOTF_LEVEL)
    #   define DEB_NOTF_8             (DEB_USER8  | DEB_NOTF_LEVEL)
    #   define DEB_NOTF_9             (DEB_USER9  | DEB_NOTF_LEVEL)
    #   define DEB_NOTF_10            (DEB_USER10 | DEB_NOTF_LEVEL)
    #   define DEB_NOTF_11            (DEB_USER11 | DEB_NOTF_LEVEL)
    #   define DEB_NOTF_12            (DEB_USER12 | DEB_NOTF_LEVEL)
    #   define DEB_NOTF_13            (DEB_USER13 | DEB_NOTF_LEVEL)
    #   define DEB_NOTF_14            (DEB_USER14 | DEB_NOTF_LEVEL)
    #   define DEB_NOTF_15            (DEB_USER15 | DEB_NOTF_LEVEL)
    
        DECLARE_DEBUG(EProt)
    #   define EProtUrlSpy          UrlSpyFn
    #   define EProtDebugOut(x)     EProtUrlSpy x
    #   define EProtAssert(x)       Win4Assert(x)
    #   define EProtVerify(x)       EProtAssert(x)
    #   define DEB_EPROT_LEVEL      0x40000000
    #   define DEB_PLUGPROT         (DEB_USER1  | DEB_EPROT_LEVEL)
    #   define DEB_BASE             (DEB_USER2  | DEB_EPROT_LEVEL)
    
        DECLARE_DEBUG(TNotf)
    #   define TNotfUrlSpy         UrlSpyFn
    #   define TNotfDebugOut(x)    TNotfUrlSpy x
    #   define TNotfAssert(x)      Win4Assert(x)
    #   define TNotfVerify(x)      TNotfAssert(x)
    #   define DEB_TNOTF_LEVEL     0x50000000
    
    #   define DEB_TNOTF_1            (DEB_USER1  | DEB_TNOTF_LEVEL)
    #   define DEB_TNOTF_2            (DEB_USER2  | DEB_TNOTF_LEVEL)
    #   define DEB_TNOTF_3            (DEB_USER3  | DEB_TNOTF_LEVEL)
    #   define DEB_TNOTF_4            (DEB_USER4  | DEB_TNOTF_LEVEL)
    #   define DEB_TNOTF_5            (DEB_USER5  | DEB_TNOTF_LEVEL)
    #   define DEB_TNOTF_6            (DEB_USER6  | DEB_TNOTF_LEVEL)
    #   define DEB_TNOTF_7            (DEB_USER7  | DEB_TNOTF_LEVEL)
    #   define DEB_TNOTF_8            (DEB_USER8  | DEB_TNOTF_LEVEL)
    #   define DEB_TNOTF_9            (DEB_USER9  | DEB_TNOTF_LEVEL)
    #   define DEB_TNOTF_10           (DEB_USER10 | DEB_TNOTF_LEVEL)
    #   define DEB_TNOTF_11           (DEB_USER11 | DEB_TNOTF_LEVEL)
    #   define DEB_TNOTF_12           (DEB_USER12 | DEB_TNOTF_LEVEL)
    #   define DEB_TNOTF_13           (DEB_USER13 | DEB_TNOTF_LEVEL)
    #   define DEB_TNOTF_14           (DEB_USER14 | DEB_TNOTF_LEVEL)
    #   define DEB_TNOTF_15           (DEB_USER15 | DEB_TNOTF_LEVEL)
    
    #   define PPKG_DUMP(ptr, params)       ptr->Dump params
    #   define PLIST_DUMP(ptr, params)      ptr->Dump params
    #   define LIST_DUMP(obj, params)       obj.Dump params
    #   define SPEW_TIME(params)            SpewTime params
    
    #else
    
    #define PerfDbgTag(tag, szOwner, szDescrip, iOption) PerfTag(tag, szOwner, szDescrip)
    #define     DbgTag(tag, szOwner, szDescrip, iOption)
    #define PerfDbgExtern(tag) PerfExtern(tag)
    #define     DbgExtern(tag)
    #define PerfDbgLog(tag,pv,f) PerfLog(tag,pv,f)
    #define PerfDbgLog1(tag,pv,f,a1) PerfLog1(tag,pv,f,a1)
    #define PerfDbgLog2(tag,pv,f,a1,a2) PerfLog2(tag,pv,f,a1,a2)
    #define PerfDbgLog3(tag,pv,f,a1,a2,a3) PerfLog3(tag,pv,f,a1,a2,a3)
    #define PerfDbgLog4(tag,pv,f,a1,a2,a3,a4) PerfLog4(tag,pv,f,a1,a2,a3,a4)
    #define PerfDbgLog5(tag,pv,f,a1,a2,a3,a4,a5) PerfLog5(tag,pv,f,a1,a2,a3,a4,a5)
    #define PerfDbgLog6(tag,pv,f,a1,a2,a3,a4,a5,a6) PerfLog6(tag,pv,f,a1,a2,a3,a4,a5,a6)
    #define PerfDbgLog7(tag,pv,f,a1,a2,a3,a4,a5,a6,a7) PerfLog7(tag,pv,f,a1,a2,a3,a4,a5,a6,a7)
    #define PerfDbgLog8(tag,pv,f,a1,a2,a3,a4,a5,a6,a7,a8) PerfLog8(tag,pv,f,a1,a2,a3,a4,a5,a6,a7,a8)
    #define PerfDbgLog9(tag,pv,f,a1,a2,a3,a4,a5,a6,a7,a8,a9) PerfLog9(tag,pv,f,a1,a2,a3,a4,a5,a6,a7,a8,a9)
    #define PerfDbgLogN(x) PerfLogFn x
    #define     DbgLog(tag,pv,f)
    #define     DbgLog1(tag,pv,f,a1)
    #define     DbgLog2(tag,pv,f,a1,a2)
    #define     DbgLog3(tag,pv,f,a1,a2,a3)
    #define     DbgLog4(tag,pv,f,a1,a2,a3,a4)
    #define     DbgLog5(tag,pv,f,a1,a2,a3,a4,a5)
    #define     DbgLog6(tag,pv,f,a1,a2,a3,a4,a5,a6)
    #define     DbgLog7(tag,pv,f,a1,a2,a3,a4,a5,a6,a7)
    #define     DbgLog8(tag,pv,f,a1,a2,a3,a4,a5,a6,a7,a8)
    #define     DbgLog9(tag,pv,f,a1,a2,a3,a4,a5,a6,a7,a8,a9)
    #define     DbgLogN(x)
    
    #define PPKG_DUMP(ptr, params)
    #define PLIST_DUMP(ptr, params)
    #define LIST_DUMP(obj, params)
    #define SPEW_TIME(params)
    
    #if DBGASSERT == 1
    
    #   define UrlMkAssert(x)  (void) ((x) || (DebugBreak(),0))
    #   define TransAssert(x)  (void) ((x) || (DebugBreak(),0))
    #   define PProtAssert(x)  (void) ((x) || (DebugBreak(),0))
    #   define EProtAssert(x)  (void) ((x) || (DebugBreak(),0))
    #   define NotfAssert(x)   (void) ((x) || (DebugBreak(),0))
    
    #   define UrlMkDebugOut(x)
    #   define UrlMkVerify(x)         x
    
    #   define TransDebugOut(x)
    #   define TransVerify(x)         x
    
    #   define PProtDebugOut(x)
    #   define PProtVerify(x)         x
    
    #   define NotfDebugOut(x)
    #   define NotfVerify(x)          x
    
    #   define TNotfDebugOut(x)
    #   define TNotfVerify(x)         x
    
    #else
    
    #   define UrlMkDebugOut(x)
    #   define UrlMkAssert(x)
    #   define UrlMkVerify(x)         x
    
    #   define TransDebugOut(x)
    #   define TransAssert(x)
    #   define TransVerify(x)         x
    
    #   define PProtDebugOut(x)
    #   define PProtAssert(x)
    #   define PProtVerify(x)         x
    
    #   define NotfDebugOut(x)
    #   define NotfAssert(x)
    #   define NotfVerify(x)          x
    
    #   define TNotfDebugOut(x)
    #   define TNotfAssert(x)
    #   define TNotfVerify(x)         x
    
    #   define EProtDebugOut(x)
    #   define EProtAssert(x)
    #   define EProtVerify(x)         x
    
    #endif
    #endif
    
    HRESULT GetClassMime(LPSTR pszMime, CLSID *pclsid, BOOL fIgnoreMimeClsid=FALSE);
    STDAPI GetClassFileOrMime2(LPBC pBC, LPCWSTR pwzFilename, LPVOID pBuffer, DWORD cbSize,
        LPCWSTR pwzMimeIn, DWORD dwReserved, CLSID *pclsid, BOOL fIgnoreMimeClsid);
    HWND GetThreadNotificationWnd(BOOL fCreate = TRUE);
    
    // messages for URLMON's private window on client's thread
    #define WM_URLMON_BASE                  WM_USER+100
    #define WM_TRANS_FIRST                  WM_URLMON_BASE+1
    #define WM_TRANS_PACKET                 WM_URLMON_BASE+1
    #define WM_TRANS_NOPACKET               WM_URLMON_BASE+2
    #define WM_TRANS_OUTOFMEMORY            WM_URLMON_BASE+3
    #define WM_TRANS_INTERNAL               WM_URLMON_BASE+4
    #define WM_CODE_DOWNLOAD_SETUP          WM_URLMON_BASE+5
    #define WM_CODE_DOWNLOAD_TRUST_PIECE    WM_URMLON_BASE+6
    #define WM_CODE_DOWNLOAD_PROCESS_PIECE  WM_URLMON_BASE+7
    #define WM_CODE_DOWNLOAD_PROCESS_INF    WM_URLMON_BASE+8
    #define WM_THREADPACKET_POST            WM_URLMON_BASE+9
    #define WM_THREADPACKET_SEND            WM_URLMON_BASE+10
    #define WM_THREADPACKET_NOTIFY          WM_URLMON_BASE+11
    #define WM_THREADPACKET_INPUTSYNC       WM_URLMON_BASE+12
    #define WM_PROCESSPACKET_POST           WM_URLMON_BASE+13
    #define WM_PROCESSPACKET_SEND           WM_URLMON_BASE+14
    #define WM_PROCESSWAKEUP                WM_URLMON_BASE+15
    #define WM_THREADPACKET_PRIVATE3        WM_URLMON_BASE+16
    #define WM_SYNC_DEF_PROC_NOTIFICATIONS  WM_URLMON_BASE+17
    #define WM_TRANS_LAST                   WM_URLMON_BASE+17

    #define NOTF_SCHED_TIMER                0xABC123
    #define NOTF_DELAY_TIMER                0xDEF456
    
    #define IID_IAsyncURLMoniker    IID_IMoniker
    #define E_RETRY                 RPC_E_RETRY
    
    #ifdef UNUSED
    #undef VDATEPTROUT
    #undef VDATEPTRIN
    #undef VDATEIFACE
    #undef VDATEIID
    
    #define VDATEPTROUT(p, n)
    #define VDATEPTRIN(p, n)
    #define VDATETHIS(t)
    #define VDATEIFACE(x)
    #define VDATEIID(x)
    #endif //UNUSED
    
    #ifndef VDATETHIS
    #define VDATETHIS(t) VDATEIFACE(t)
    #endif
    
    // prototypes
    
    EXTERN_C const IID IID_IAsyncBindCtx;
    
    
    // Internal Helper API's
    void DllAddRef(void);
    void DllRelease(void);
    
    #undef  URLMONOFFSETOF
    #define URLMONOFFSETOF(t,f)   ((DWORD_PTR)(&((t*)0)->f))
   
    #define REG_BSCB_HOLDER          OLESTR("_BSCB_Holder_")
    #define REG_ENUMFORMATETC        OLESTR("_EnumFORMATETC_")
    #define REG_MEDIA_HOLDER         OLESTR("_Media_Holder_")
    #define SZ_TRANSACTIONDATA       OLESTR("_ITransData_Object_")
    #define SZ_TRANSACTION           OLESTR("_ITransaction_Object_")
    #define SZ_BINDING               OLESTR("CBinding Context")
    #define SZ_IUNKNOWN_PTR          OLESTR("IUnknown Pointer")
    
    #if DBG==1
    HRESULT DumpIID(REFIID riid);
    #else
    #define DumpIID(x)
    #endif
    
    // Needed for linking with static C runtime LIBCMT.LIB
    // Remove when linking to external C runtime DLL
    //#define strnicmp _strnicmp
    #define wcsnicmp _wcsnicmp
    //#define itoa _itoa
    //#define stricmp _stricmp        // URLBIND uses this one.
    #define wcsicmp _wcsicmp
    
    // old flags used inside urlmon
    typedef enum
    {
        BSCO_ONSTARTBINDING     = 0x00000001,
        BSCO_GETPRIORITY        = 0x00000002,
        BSCO_ONLOWRESOURCE      = 0x00000004,
        BSCO_ONPROGRESS         = 0x00000008,
        BSCO_ONSTOPBINDING      = 0x00000010,
        BSCO_GETBINDINFO        = 0x00000020,
        BSCO_ONDATAAVAILABLE    = 0x00000040,
        BSCO_ONOBJECTAVAILABLE  = 0x00000080,
        BSCO_ALLONIBSC          = 0x000000FF,
        BSCO_ALLONIBDGSITE      = 0x0000001F
    } BSCO_OPTION;
    
    // flags for the reserved parameter dwReserved of GetClassFileOrMime API
    typedef enum
    {
        GETCLASSFILEORMIME_IGNOREPLUGIN      = 0x00000001
    } GETCLASSFILEORMIME_FLAGS;
    
    #endif //_URLINT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\inc\wregint.h ===
#ifndef _REG_API_DEFINED_
#define _REG_API_DEFINED_

#ifdef unused
#define RegConnectRegistry  RegConnectRegistryW
#define RegConnectRegistry  RegConnectRegistryA
#define RegCreateKey  RegCreateKeyW
#define RegCreateKey  RegCreateKeyA
#define RegCreateKeyEx  RegCreateKeyExW
#define RegCreateKeyEx  RegCreateKeyExA
#define RegDeleteKey  RegDeleteKeyW
#define RegDeleteKey  RegDeleteKeyA
#define RegDeleteValue  RegDeleteValueW
#define RegDeleteValue  RegDeleteValueA
#define RegEnumKey  RegEnumKeyW
#define RegEnumKey  RegEnumKeyA
#define RegEnumKeyEx  RegEnumKeyExW
#define RegEnumKeyEx  RegEnumKeyExA
#define RegEnumValue  RegEnumValueW
#define RegEnumValue  RegEnumValueA
#define RegLoadKey  RegLoadKeyW
#define RegLoadKey  RegLoadKeyA
#define RegOpenKey  RegOpenKeyW
#define RegOpenKey  RegOpenKeyA
#define RegOpenKeyEx  RegOpenKeyExW
#define RegOpenKeyEx  RegOpenKeyExA
#define RegQueryInfoKey  RegQueryInfoKeyW
#define RegQueryInfoKey  RegQueryInfoKeyA
#define RegQueryValue  RegQueryValueW
#define RegQueryValue  RegQueryValueA
#define RegQueryMultipleValues  RegQueryMultipleValuesW
#define RegQueryMultipleValues  RegQueryMultipleValuesA
#define RegQueryValueEx  RegQueryValueExW
#define RegQueryValueEx  RegQueryValueExA
#define RegReplaceKey  RegReplaceKeyW
#define RegReplaceKey  RegReplaceKeyA
#define RegRestoreKey  RegRestoreKeyW
#define RegRestoreKey  RegRestoreKeyA
#define RegSaveKey  RegSaveKeyW
#define RegSaveKey  RegSaveKeyA
#define RegSetValue  RegSetValueW
#define RegSetValue  RegSetValueA
#define RegSetValueEx  RegSetValueExW
#define RegSetValueEx  RegSetValueExA
#define RegUnLoadKey  RegUnLoadKeyW
#define RegUnLoadKey  RegUnLoadKeyA
#define InitiateSystemShutdown  InitiateSystemShutdownW
#define InitiateSystemShutdown  InitiateSystemShutdownA
#define AbortSystemShutdown  AbortSystemShutdownW
#define AbortSystemShutdown  AbortSystemShutdownA


#undef RegConnectRegistry
#undef RegCreateKey
#undef RegCreateKeyEx
#undef RegDeleteKey
#undef RegDeleteValue
#undef RegEnumKey
#undef RegEnumKeyEx
#undef RegEnumValue
#undef RegLoadKey
#undef RegOpenKey
#undef RegOpenKeyEx
#undef RegQueryInfoKey
#undef RegQueryValue
#undef RegQueryMultipleValues
#undef RegQueryValueEx
#undef RegReplaceKey
#undef RegRestoreKey
#undef RegSaveKey
#undef RegSetValue
#undef RegSetValueEx
#undef RegUnLoadKey
#undef InitiateSystemShutdown
#undef AbortSystemShutdown

#endif //unused

#pragma warning(disable:4005)               // re-enable below


#include "..\utils\wreg.hxx"
extern CRegistryA *g_vpReg;


#define RegConnectRegistry            (g_vpReg)->ConnectRegistry
#define RegCloseKey                   (g_vpReg)->CloseKey
#define RegCreateKey                  (g_vpReg)->CreateKey
#define RegCreateKeyEx                (g_vpReg)->CreateKeyEx
#define RegDeleteKey                  (g_vpReg)->DeleteKey
#define RegDeleteValue                (g_vpReg)->DeleteValue
#define RegEnumKey                    (g_vpReg)->EnumKey
#define RegEnumKeyEx                  (g_vpReg)->EnumKeyEx
#define RegEnumValue                  (g_vpReg)->EnumValue
#define RegFlushKey                   (g_vpReg)->FlushKey
#define RegLoadKey                    (g_vpReg)->LoadKey
#define RegOpenKey                    (g_vpReg)->OpenKey
#define RegOpenKeyEx                  (g_vpReg)->OpenKeyEx
#define RegQueryInfoKey               (g_vpReg)->QueryInfoKey
#define RegQueryValue                 (g_vpReg)->QueryValue
#define RegQueryMultipleValues        (g_vpReg)->QueryMultipleValues
#define RegQueryValueEx               (g_vpReg)->QueryValueEx
#define RegReplaceKey                 (g_vpReg)->ReplaceKey
#define RegRestoreKey                 (g_vpReg)->RestoreKey
#define RegSaveKey                    (g_vpReg)->SaveKey
#define RegSetValue                   (g_vpReg)->SetValue
#define RegSetValueEx                 (g_vpReg)->SetValueEx
#define RegUnLoadKey                  (g_vpReg)->UnLoadKey

#pragma warning(default:4005)               // re-enable below

#endif //_REG_API_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\inc\verurlmk.h ===
#ifdef RC_INVOKED

#include <winver.h>
#include <ntverp.h>

#define VER_FILEVERSION         VER_PRODUCTBUILD
#define VER_FILEVERSION_STR     VER_PRODUCTVERSION_STR

#define VER_PRODUCTNAME_STR      "Microsoft URL Moniker 1.0 for Windows NT(TM) Operating System\0"
#define VER_COMPANYNAME_STR      "Microsoft Corporation\0"
#define VER_LEGALTRADEMARKS_STR  "Microsoft\256 is a registered trademark of Microsoft Corporation. Windows NT(TM) is a trademark of Microsoft Corporation\0"
#define VER_LEGALCOPYRIGHT_STR   "Copyright \251 Microsoft Corp. 1995\0"
#define VER_COMMENT_STR          "Microsoft URL Moniker 1.0 for Windows NT(TM) Operating System\0"
#define VER_FILETYPE             VFT_DLL
#define VER_FILESUBTYPE          0
#define VER_FILEFLAGSMASK        VS_FFI_FILEFLAGSMASK
#define VER_FILEFLAGS            0L
#define VER_FILEOS               VOS_NT_WINDOWS32
#define VER_FILEDESCRIPTION_STR  "Microsoft URL Moniker 4.70 for Windows NT(TM) Operating System\0"

#endif /* RC_INVOKED */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\inc\wcheckcb.h ===
#ifndef __CONTROL_REFRESH_CALLBACK__
#define __CONTROL_REFRESH_CALLBACK__

#include <webcheck.h>
#include <objidl.h>
#include <wininet.h>

#define CALLBACK_OBJ_CLSID "{5DFE9E81-46E4-11d0-94E8-00AA0059CE02}"
extern const CLSID CLSID_ControlRefreshCallback;


/******************************************************************************
   Class factory for callback object
******************************************************************************/
STDMETHODIMP CreateCallbackClassFactory(IClassFactory** ppCF);

class CCallbackObjFactory : public IClassFactory
{
public:

    // constructor
    CCallbackObjFactory();

    // IUnknown Methods
    STDMETHODIMP QueryInterface(REFIID iid, void** ppvObject);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // IClassFactory Methods
    STDMETHODIMP CreateInstance(LPUNKNOWN pUnkOuter, REFIID riid, LPVOID* ppv);
    STDMETHODIMP LockServer(BOOL fLock);

private:

    // destructor
    ~CCallbackObjFactory();

    // data members
    UINT   m_cRef;         // object refcount
    UINT   m_cLocks;        // dll lock refcount
};


/******************************************************************************
   Callback object class
******************************************************************************/
class CControlRefreshCallback : public IPersistStream,
                                public IWebCheckAdviseSink
{

public:

    // constructor
    CControlRefreshCallback();

    // passing information to this callback object
    STDMETHODIMP SetInfo(REFCLSID rclsidControl, LPCWSTR lpwszURL);

    // IUnknown Methods
    STDMETHODIMP QueryInterface(REFIID iid, void** ppvObject);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // IPersistStream Methods
    STDMETHODIMP GetClassID(CLSID* pClassID);
    STDMETHODIMP IsDirty(void);
    STDMETHODIMP Load(IStream* pStm);
    STDMETHODIMP Save(IStream* pStm, BOOL fClearDirty);
    STDMETHODIMP GetSizeMax(ULARGE_INTEGER* pcbSize);

    // IWebCheckAdviseSink Methods
    STDMETHODIMP UpdateBegin(long lCookie, SCODE scReason, BSTR lpURL);
    STDMETHODIMP UpdateEnd(long lCookie, SCODE scReason);
    STDMETHODIMP UpdateProgress(long lCookie, long lCurrent, long lMax);

protected:

    // Update flag in registry to indicate a new version of control
    // has arrived
//    HRESULT UpdateControlInCacheFlag(SCODE scReason) const;
    HRESULT DownloadControl() const;

protected:

    // destructor
    ~CControlRefreshCallback();

    // ref. count
    UINT m_cRef;

    // clsid of control this callback obj deals with
    CLSID m_clsidCtrl;

    // URL of control this callback obj deals with
    WCHAR m_wszURL[INTERNET_MAX_URL_LENGTH];
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\inc\valid.h ===
#if DBG==1 && defined(WIN32) && !defined(_CHICAGO_)
#define VDATEHEAP() if( !HeapValidate(GetProcessHeap(),0,0)){ DebugBreak();}
#else
#define VDATEHEAP()
#endif  //  DBG==1 && defined(WIN32) && !defined(_CHICAGO_)

#define IsValidPtrIn(pv,cb)  ((pv == NULL) || !IsBadReadPtr ((pv),(cb)))
#define IsValidPtrOut(pv,cb) (!IsBadWritePtr((pv),(cb)))

STDAPI_(BOOL) IsValidInterface( void FAR* pv );


#if DBG==1
// for performance, do not do in retail builds
STDAPI_(BOOL) IsValidIid( REFIID riid );
#else
#define IsValidIid(x) (TRUE)
#endif

#ifdef _DEBUG

//** POINTER IN validation macros:
#define VDATEPTRIN( pv, TYPE ) \
        if (!IsValidPtrIn( (pv), sizeof(TYPE))) \
    return (FnAssert(#pv,"Invalid in ptr", __FILE__, __LINE__),ResultFromScode(E_INVALIDARG))
#define GEN_VDATEPTRIN( pv, TYPE, retval) \
        if (!IsValidPtrIn( (pv), sizeof(TYPE))) \
    return (FnAssert(#pv,"Invalid in ptr", __FILE__, __LINE__), retval)
#define VOID_VDATEPTRIN( pv, TYPE ) \
        if (!IsValidPtrIn( (pv), sizeof(TYPE))) {\
    FnAssert(#pv,"Invalid in ptr", __FILE__, __LINE__); return; }

//** POINTER IN validation macros for single entry/single exit functions
//** uses a goto instead of return
#define VDATEPTRIN_LABEL(pv, TYPE, label, retVar) \
        if (!IsValidPtrIn((pv), sizeof(TYPE))) \
        { retVar = (FnAssert(#pv, "Invalid in ptr", __FILE__, __LINE__), ResultFromScode(E_INVALIDARG)); \
         goto label; }
#define GEN_VDATEPTRIN_LABEL(pv, TYPE, retval, label, retVar) \
        if (!IsValidPtrIn((pv), sizeof(TYPE))) \
        { retVar = (FnAssert(#pv, "Invalid in ptr", __FILE__, __LINE__), retval); \
         goto label; }
#define VOID_VDATEPTRIN_LABEL(pv, TYPE, label) \
        if (!IsValidPtrIn((pv), sizeof(TYPE))) \
        { FnAssert(#pv, "Invalid in ptr", __FILE__, __LINE__); goto label; }

//** POINTER OUT validation macros:
#define VDATEPTROUT( pv, TYPE ) \
        if (!IsValidPtrOut( (pv), sizeof(TYPE))) \
    return (FnAssert(#pv,"Invalid out ptr", __FILE__, __LINE__),ResultFromScode(E_INVALIDARG))
#define GEN_VDATEPTROUT( pv, TYPE, retval ) \
        if (!IsValidPtrOut( (pv), sizeof(TYPE))) \
    return (FnAssert(#pv,"Invalid out ptr", __FILE__, __LINE__), retval)

//** POINTER OUT validation macros for single entry/single exit functions
//** uses a goto instead of return
#define VDATEPTROUT_LABEL( pv, TYPE, label, retVar ) \
        if (!IsValidPtrOut( (pv), sizeof(TYPE))) \
        { retVar = (FnAssert(#pv,"Invalid out ptr", __FILE__, __LINE__),ResultFromScode(E_INVALIDARG)); \
         goto label; }
#define GEN_VDATEPTROUT_LABEL( pv, TYPE, retval, label, retVar ) \
        if (!IsValidPtrOut( (pv), sizeof(TYPE))) \
        { retVar = (FnAssert(#pv,"Invalid out ptr", __FILE__, __LINE__),retval); \
         goto label; }

//** INTERFACE validation macro:
#define GEN_VDATEIFACE( pv, retval ) \
        if (!IsValidInterface(pv)) \
    return (FnAssert(#pv,"Invalid interface", __FILE__, __LINE__), retval)
#define VDATEIFACE( pv ) \
        if (!IsValidInterface(pv)) \
    return (FnAssert(#pv,"Invalid interface", __FILE__, __LINE__),ResultFromScode(E_INVALIDARG))
#define VOID_VDATEIFACE( pv ) \
        if (!IsValidInterface(pv)) {\
    FnAssert(#pv,"Invalid interface", __FILE__, __LINE__); return; }

//** INTERFACE validation macros for single entry/single exit functions
//** uses a goto instead of return
#define GEN_VDATEIFACE_LABEL( pv, retval, label, retVar ) \
        if (!IsValidInterface(pv)) \
        { retVar = (FnAssert(#pv,"Invalid interface", __FILE__, __LINE__),retval); \
         goto label; }
#define VDATEIFACE_LABEL( pv, label, retVar ) \
        if (!IsValidInterface(pv)) \
        { retVar = (FnAssert(#pv,"Invalid interface", __FILE__, __LINE__),ResultFromScode(E_INVALIDARG)); \
         goto label; }
#define VOID_VDATEIFACE_LABEL( pv, label ) \
        if (!IsValidInterface(pv)) {\
        FnAssert(#pv,"Invalid interface", __FILE__, __LINE__); goto label; }

//** INTERFACE ID validation macro:
// Only do this in debug build
#define VDATEIID( iid ) if (!IsValidIid( iid )) \
    return (FnAssert(#iid,"Invalid iid", __FILE__, __LINE__),ResultFromScode(E_INVALIDARG))
#define GEN_VDATEIID( iid, retval ) if (!IsValidIid( iid )) {\
    FnAssert(#iid,"Invalid iid", __FILE__, __LINE__); return retval; }

//** INTERFACE ID validation macros for single entry/single exit functions
//** uses a goto instead of return
#define VDATEIID_LABEL( iid, label, retVar ) if (!IsValidIid( iid )) \
        {retVar = (FnAssert(#iid,"Invalid iid", __FILE__, __LINE__),ResultFromScode(E_INVALIDARG)); \
         goto label; }
#define GEN_VDATEIID_LABEL( iid, retval, label, retVar ) if (!IsValidIid( iid )) {\
        FnAssert(#iid,"Invalid iid", __FILE__, __LINE__); retVar = retval;  goto label; }
#else



//  --assertless macros for non-debug case
//** POINTER IN validation macros:
#define VDATEPTRIN( pv, TYPE ) if (!IsValidPtrIn( (pv), sizeof(TYPE))) \
    return (ResultFromScode(E_INVALIDARG))
#define GEN_VDATEPTRIN( pv, TYPE, retval ) if (!IsValidPtrIn( (pv), sizeof(TYPE))) \
    return (retval)
#define VOID_VDATEPTRIN( pv, TYPE ) if (!IsValidPtrIn( (pv), sizeof(TYPE))) {\
    return; }

//** POINTER IN validation macros for single entry/single exit functions
//** uses a goto instead of return
#define VDATEPTRIN_LABEL(pv, TYPE, label, retVar) \
        if (!IsValidPtrIn((pv), sizeof(TYPE))) \
        { retVar = ResultFromScode(E_INVALIDARG); \
         goto label; }
#define GEN_VDATEPTRIN_LABEL(pv, TYPE, retval, label, retVar) \
        if (!IsValidPtrIn((pv), sizeof(TYPE))) \
        { retVar = retval; \
         goto label; }
#define VOID_VDATEPTRIN_LABEL(pv, TYPE, label) \
        if (!IsValidPtrIn((pv), sizeof(TYPE))) \
        { goto label; }

//** POINTER OUT validation macros:
#define VDATEPTROUT( pv, TYPE ) if (!IsValidPtrOut( (pv), sizeof(TYPE))) \
    return (ResultFromScode(E_INVALIDARG))

#define GEN_VDATEPTROUT( pv, TYPE, retval ) if (!IsValidPtrOut( (pv), sizeof(TYPE))) \
    return (retval)

//** POINTER OUT validation macros for single entry/single exit functions
//** uses a goto instead of return
#define VDATEPTROUT_LABEL( pv, TYPE, label, retVar ) \
        if (!IsValidPtrOut( (pv), sizeof(TYPE))) \
        { retVar = ResultFromScode(E_INVALIDARG); \
         goto label; }
#define GEN_VDATEPTROUT_LABEL( pv, TYPE, retval, label, retVar ) \
        if (!IsValidPtrOut( (pv), sizeof(TYPE))) \
        { retVar = retval; \
         goto label; }

//** INTERFACE validation macro:
#define VDATEIFACE( pv ) if (!IsValidInterface(pv)) \
    return (ResultFromScode(E_INVALIDARG))
#define VOID_VDATEIFACE( pv ) if (!IsValidInterface(pv)) \
    return;
#define GEN_VDATEIFACE( pv, retval ) if (!IsValidInterface(pv)) \
    return (retval)

//** INTERFACE validation macros for single entry/single exit functions
//** uses a goto instead of return
#define GEN_VDATEIFACE_LABEL( pv, retval, label, retVar ) \
        if (!IsValidInterface(pv)) \
        { retVar = retval; \
         goto label; }
#define VDATEIFACE_LABEL( pv, label, retVar ) \
        if (!IsValidInterface(pv)) \
        { retVar = ResultFromScode(E_INVALIDARG); \
         goto label; }
#define VOID_VDATEIFACE_LABEL( pv, label ) \
        if (!IsValidInterface(pv)) {\
         goto label; }

//** INTERFACE ID validation macro:
// do not do in retail build. This code USED to call a bogus version of
// IsValidIID that did no work. Now we are faster and no less stable than before.
#define VDATEIID( iid )             ((void)0)
#define GEN_VDATEIID( iid, retval ) ((void)0);

//** INTERFACE ID validation macros for single entry/single exit functions
//** uses a goto instead of return
#define VDATEIID_LABEL( iid, label, retVar ) if (!IsValidIid( iid )) \
        {retVar = ResultFromScode(E_INVALIDARG); \
         goto label; }
#define GEN_VDATEIID_LABEL( iid, retval, label, retVar ) if (!IsValidIid( iid )) {\
        retVar = retval;  goto label; }

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\mon\casyncmk.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       CAsyncMk.cxx
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    10-25-95   JohannP (Johann Posch)   Created
//
//  Note: this class servers as a base class for async moniker
//
//----------------------------------------------------------------------------
#include <urlint.h>
#include "casyncmk.hxx"

//  The derived class must implement this method
inline HRESULT DerivedMustImplement( void )
{
    return E_NOTIMPL;
}

STDMETHODIMP CAsyncMoniker::QueryInterface
    (REFIID riid, LPVOID FAR* ppvObj)
{
    VDATETHIS(this);
    UrlMkDebugOut((DEB_ASYNCMONIKER, "%p IN CAsyncMoniker::QueryInterface\n", this));

    HRESULT hresult = NOERROR;
    // Do not validate input as it has already been validated
    // by derived classes.

    if (   IsEqualIID(riid, IID_IMoniker)
        || IsEqualIID(riid, IID_IUnknown)
        || IsEqualIID(riid, IID_IPersistStream)
        || IsEqualIID(riid, IID_IInternalMoniker)
        || IsEqualIID(riid, IID_IAsyncMoniker)
        || IsEqualIID(riid, IID_IAsyncURLMoniker)
       )
    {
        *ppvObj = this;
        InterlockedIncrement((long *)&m_refs);
    }
    else
    {
        *ppvObj = NULL;
        hresult = E_NOINTERFACE;
    }

    UrlMkDebugOut((DEB_ASYNCMONIKER, "%p OUT CAsyncMoniker::QueryInterface\n", this));
    return hresult;
}

STDMETHODIMP_(ULONG) CAsyncMoniker::AddRef ()
{
    ULONG crefs;
    UrlMkDebugOut((DEB_ASYNCMONIKER, "%p IN CAsyncMoniker::AddRef(%ld)\n", this, m_refs));

    crefs = InterlockedIncrement((long *)&m_refs);

    UrlMkDebugOut((DEB_ASYNCMONIKER, "%p OUT CAsyncMoniker::AddRef(%ld)\n", this, m_refs));
    return crefs;
}

STDMETHODIMP CAsyncMoniker::IsDirty (THIS)
{
    VDATETHIS(this);
    //  monikers are immutable so they are either always dirty or never dirty.
    HRESULT hresult = S_FALSE;
    UrlMkDebugOut((DEB_ASYNCMONIKER, "IN  CAsyncMoniker::(%p)\n", this));

    UrlMkDebugOut((DEB_ASYNCMONIKER, "OUT CAsyncMoniker::(%p) hr (%x)\n", this, hresult));
    return hresult;
}

STDMETHODIMP CAsyncMoniker::Load (THIS_ LPSTREAM pStm)
{
    VDATETHIS(this);
    UrlMkDebugOut((DEB_ASYNCMONIKER, "IN/OUT CAsyncMoniker::(%p) hr=E_NOTIMPL\n", this));
    return DerivedMustImplement();
}

STDMETHODIMP CAsyncMoniker::Save (THIS_ LPSTREAM pStm,
            BOOL fClearDirty)
{
    VDATETHIS(this);
    UrlMkDebugOut((DEB_ASYNCMONIKER, "IN/OUT CAsyncMoniker::(%p) hr=E_NOTIMPL\n", this));
    return DerivedMustImplement();
}

STDMETHODIMP CAsyncMoniker::GetSizeMax (THIS_ ULARGE_INTEGER FAR * pcbSize)
{
    VDATETHIS(this);
    UrlMkDebugOut((DEB_ASYNCMONIKER, "IN/OUT CAsyncMoniker::(%p) hr=E_NOTIMPL\n", this));
    return DerivedMustImplement();
}

    // *** IMoniker methods ***
STDMETHODIMP CAsyncMoniker::BindToObject (THIS_ LPBC pbc, LPMONIKER pmkToLeft,
    REFIID riidResult, LPVOID FAR* ppvResult)
{
    VDATETHIS(this);
    UrlMkDebugOut((DEB_ASYNCMONIKER, "IN/OUT CAsyncMoniker::(%p) hr=E_NOTIMPL\n", this));
    return DerivedMustImplement();
}

STDMETHODIMP CAsyncMoniker::BindToStorage (THIS_ LPBC pbc, LPMONIKER pmkToLeft,
    REFIID riid, LPVOID FAR* ppvObj)
{
    VDATETHIS(this);
    UrlMkDebugOut((DEB_ASYNCMONIKER, "IN/OUT CAsyncMoniker::(%p) hr=E_NOTIMPL\n", this));
    return DerivedMustImplement();
}

STDMETHODIMP CAsyncMoniker::Reduce (THIS_ LPBC pbc, DWORD dwReduceHowFar, LPMONIKER FAR*
    ppmkToLeft, LPMONIKER FAR * ppmkReduced)
{
    VDATETHIS(this);
    *ppmkReduced = this;
    AddRef();
    return ResultFromScode(MK_S_REDUCED_TO_SELF);
}

STDMETHODIMP CAsyncMoniker::ComposeWith (THIS_ LPMONIKER pmkRight, BOOL fOnlyIfNotGeneric,
    LPMONIKER FAR* ppmkComposite)
{
    VDATETHIS(this);
    UrlMkDebugOut((DEB_ASYNCMONIKER, "IN/OUT CAsyncMoniker::(%p) hr=E_NOTIMPL\n", this));
    return DerivedMustImplement();
}

STDMETHODIMP CAsyncMoniker::Enum (THIS_ BOOL fForward, LPENUMMONIKER FAR* ppenumMoniker)
{
    VDATETHIS(this);
    UrlMkDebugOut((DEB_ASYNCMONIKER, "IN/OUT CAsyncMoniker::(%p) hr=E_NOTIMPL\n", this));
    return DerivedMustImplement();
}

STDMETHODIMP CAsyncMoniker::IsEqual (THIS_ LPMONIKER pmkOtherMoniker)
{
    VDATETHIS(this);
    UrlMkDebugOut((DEB_ASYNCMONIKER, "IN/OUT CAsyncMoniker::(%p) hr=E_NOTIMPL\n", this));
    return DerivedMustImplement();
}

STDMETHODIMP CAsyncMoniker::Hash (THIS_ LPDWORD pdwHash)
{
    VDATETHIS(this);
    UrlMkDebugOut((DEB_ASYNCMONIKER, "IN/OUT CAsyncMoniker::(%p) hr=E_NOTIMPL\n", this));
    return DerivedMustImplement();
}

STDMETHODIMP CAsyncMoniker::GetTimeOfLastChange (THIS_ LPBC pbc, LPMONIKER pmkToLeft,
    FILETIME FAR* pfiletime)
{
    VDATETHIS(this);
    UrlMkDebugOut((DEB_ASYNCMONIKER, "IN/OUT CAsyncMoniker::(%p) hr=E_NOTIMPL\n", this));
    return DerivedMustImplement();
}

STDMETHODIMP CAsyncMoniker::Inverse (THIS_ LPMONIKER FAR* ppmk)
{
    VDATETHIS(this);
    *ppmk = NULL;
    return ResultFromScode(MK_E_NOINVERSE);
}

STDMETHODIMP CAsyncMoniker::CommonPrefixWith (LPMONIKER pmkOther, LPMONIKER FAR*
    ppmkPrefix)
{
    VDATETHIS(this);
    UrlMkDebugOut((DEB_ASYNCMONIKER, "IN/OUT CAsyncMoniker::(%p) hr=E_NOTIMPL\n", this));
    return DerivedMustImplement();
}

STDMETHODIMP CAsyncMoniker::RelativePathTo (THIS_ LPMONIKER pmkOther, LPMONIKER FAR*
    ppmkRelPath)
{
    VDATETHIS(this);
    UrlMkDebugOut((DEB_ASYNCMONIKER, "IN/OUT CAsyncMoniker::(%p) hr=E_NOTIMPL\n", this));
    return DerivedMustImplement();
}

STDMETHODIMP CAsyncMoniker::GetDisplayName (THIS_ LPBC pbc, LPMONIKER pmkToLeft,
    LPWSTR FAR* lplpszDisplayName)
{
    VDATETHIS(this);
    UrlMkDebugOut((DEB_ASYNCMONIKER, "IN/OUT CAsyncMoniker::(%p) hr=E_NOTIMPL\n", this));
    return DerivedMustImplement();
}

STDMETHODIMP CAsyncMoniker::ParseDisplayName (THIS_ LPBC pbc, LPMONIKER pmkToLeft,
    LPWSTR lpszDisplayName, ULONG FAR* pchEaten,
    LPMONIKER FAR* ppmkOut)
{
    VDATETHIS(this);
    UrlMkDebugOut((DEB_ASYNCMONIKER, "IN/OUT CAsyncMoniker::(%p) hr=E_NOTIMPL\n", this));
    return DerivedMustImplement();
}

STDMETHODIMP CAsyncMoniker::IsSystemMoniker (THIS_ LPDWORD pdwMksys)
{
    VDATEPTROUT (pdwMksys, DWORD);
    *pdwMksys = 0;

    return NOERROR;
}

STDMETHODIMP CAsyncMoniker::IsRunning (THIS_ LPBC pbc, LPMONIKER pmkToLeft,
              LPMONIKER pmkNewlyRunning)
{
    VDATETHIS(this);
    VDATEIFACE (pbc);
    LPRUNNINGOBJECTTABLE pROT;
    HRESULT hresult = S_FALSE;

    return hresult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\mon\enumfetc.cxx ===
//+---------------------------------------------------------------------------
//
//  Function:   CEnumFmtEtc
//
//  Synopsis:   Implements the IEnumFormatEtc.
//              Used by the urlmon by dataobject and CreateEnumFormatEtc
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    12-22-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
#include <mon.h>

PerfDbgTag(tagCEnumFmtEtc, "Urlmon", "Log CEnumFmtEtc", DEB_FORMAT);

//+---------------------------------------------------------------------------
//
//  Method:     CEnumFmtEtc::Create
//
//  Synopsis:
//
//  Arguments:  [cfmtetc] --
//              [rgfmtetc] --
//
//  Returns:
//
//  History:    12-22-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
CEnumFmtEtc * CEnumFmtEtc::Create(UINT cfmtetc, FORMATETC* rgfmtetc)
{
    PerfDbgLog(tagCEnumFmtEtc, NULL, "+CEnumFmtEtc::Create");
    CEnumFmtEtc * pCEnumFEtc = NULL;

    if (cfmtetc >= 1)
    {
        // only create an enumerator if at least one element
        pCEnumFEtc = new CEnumFmtEtc();
        if (pCEnumFEtc)
        {
            if (pCEnumFEtc->Initialize(cfmtetc, rgfmtetc, 0) == FALSE)
            {
                delete pCEnumFEtc;
                pCEnumFEtc = NULL;
            }
        }
    }

    PerfDbgLog1(tagCEnumFmtEtc, NULL, "-CEnumFmtEtc::Create pEnum->(%lx)", pCEnumFEtc);
    return pCEnumFEtc;
}

//+---------------------------------------------------------------------------
//
//  Method:     CEnumFmtEtc::Initialize
//
//  Synopsis:   set the size and position
//
//  Arguments:  [cfmtetc] -- number of elements
//              [iPos] --    position of enumerator
//
//  Returns:    true on success
//
//  History:    12-22-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL CEnumFmtEtc::Initialize(UINT cfmtetc, FORMATETC* rgfmtetc,  UINT iPos)
{
    LONG cbSize =  sizeof(FORMATETC) * cfmtetc;
    _iNext = iPos;
    _cElements = cfmtetc;

    _pFmtEtc = (FORMATETC *) new FORMATETC [cfmtetc];
    if (_pFmtEtc)
    {
        memcpy(_pFmtEtc, rgfmtetc, cbSize);
        _cElements = cfmtetc;
    }
    else
    {
        _cElements = 0;
    }

    return _cElements != 0;
}
//+---------------------------------------------------------------------------
//
//  Method:     CEnumFmtEtc::QueryInterface
//
//  Synopsis:
//
//  Arguments:  [riid] --
//              [ppvObj] --
//
//  Returns:
//
//  History:    12-22-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CEnumFmtEtc::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    PerfDbgLog(tagCEnumFmtEtc, this, "+CEnumFmtEtc::QueryInterface");
    HRESULT hr = NOERROR;

    if (   (riid == IID_IUnknown)
        || (riid == IID_IEnumFORMATETC))
    {
        *ppvObj = this;
        AddRef();
    }
    else
    {
        *ppvObj = NULL;
        hr = E_NOINTERFACE;
    }

    PerfDbgLog(tagCEnumFmtEtc, this, "-CEnumFmtEtc::QueryInterface");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   CEnumFmtEtc::AddRef
//
//  Synopsis:
//
//  Arguments:  [ULONG] --
//
//  Returns:
//
//  History:    12-22-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CEnumFmtEtc::AddRef(void)
{
    GEN_VDATEPTRIN(this,ULONG,0L);
    LONG lRet = ++_CRefs;
    PerfDbgLog1(tagCEnumFmtEtc, this, "CEnumFmtEtc::AddRef(%ld)", lRet);
    return lRet;
}

//+---------------------------------------------------------------------------
//
//  Function:   CEnumFmtEtc::Release
//
//  Synopsis:
//
//  Arguments:  [ULONG] --
//
//  Returns:
//
//  History:    12-22-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CEnumFmtEtc::Release(void)
{
    GEN_VDATEPTRIN(this,ULONG,0L);
    PerfDbgLog(tagCEnumFmtEtc, this, "+CEnumFmtEtc::Release");

    LONG lRet = --_CRefs;
    if (_CRefs == 0)
    {
        delete this;
    }

    PerfDbgLog1(tagCEnumFmtEtc, this, "-CEnumFmtEtc::Release(%ld)", lRet);
    return lRet;
}

//+---------------------------------------------------------------------------
//
//  Method:     CEnumFmtEtc::Next
//
//  Synopsis:
//
//  Arguments:  [celt] --
//              [rgelt] --
//              [pceltFetched] --
//
//  Returns:
//
//  History:    12-22-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CEnumFmtEtc::Next(ULONG celt, FORMATETC * rgelt, ULONG * pceltFetched)
{
    PerfDbgLog(tagCEnumFmtEtc, this, "+CEnumFmtEtc::Next");
    HRESULT hr;

    if (!rgelt)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        for (ULONG i = 0; (i < celt) && (_iNext < _cElements); i++)
        {
            rgelt[i] = *(_pFmtEtc + _iNext++);
        }

        if (pceltFetched)
        {
            *pceltFetched = i;
        }

        hr = ((i == celt) ? NOERROR : S_FALSE);

    }

    PerfDbgLog1(tagCEnumFmtEtc, this, "-CEnumFmtEtc::Next (hr:%lx)", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CEnumFmtEtc::Skip
//
//  Synopsis:
//
//  Arguments:  [celt] --
//
//  Returns:
//
//  History:    12-22-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CEnumFmtEtc::Skip(ULONG celt)
{
    PerfDbgLog(tagCEnumFmtEtc, this, "+CEnumFmtEtc::Skip");
    HRESULT hr;

    _iNext += celt;

    if (_iNext <= _cElements)
    {
        hr = NOERROR;
    }
    else
    {
        _iNext = _cElements;
        hr = S_FALSE;
    }
    PerfDbgLog1(tagCEnumFmtEtc, this, "-CEnumFmtEtc::Skip (hr:%lx)", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CEnumFmtEtc::Reset
//
//  Synopsis:
//
//  Arguments:  [void] --
//
//  Returns:
//
//  History:    12-22-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CEnumFmtEtc::Reset(void)
{
    PerfDbgLog(tagCEnumFmtEtc, this, "+CEnumFmtEtc::Reset");
    _iNext = 0;
    PerfDbgLog1(tagCEnumFmtEtc, this, "-CEnumFmtEtc::Reset (hr:%lx)", S_OK);
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Method:     CEnumFmtEtc::Clone
//
//  Synopsis:
//
//  Arguments:  [ppenum] --
//
//  Returns:
//
//  History:    12-22-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CEnumFmtEtc::Clone(IEnumFORMATETC ** ppenum)
{
    PerfDbgLog(tagCEnumFmtEtc, this, "+CEnumFmtEtc::Clone");
    HRESULT hr;
    if (ppenum)
    {
        CEnumFmtEtc * pCEnumFEtc;
        TransAssert((_cElements > 0));

        pCEnumFEtc = new CEnumFmtEtc();
        if (pCEnumFEtc)
        {
            if (pCEnumFEtc->Initialize(_cElements, _pFmtEtc, _iNext) == FALSE)
            {
                delete pCEnumFEtc;
                pCEnumFEtc = NULL;
            }
            else
            {
                *ppenum = pCEnumFEtc;
            }
        }
        hr = ((*ppenum != NULL) ? NOERROR : E_OUTOFMEMORY);

    }
    else
    {
        hr = E_INVALIDARG;
    }

    PerfDbgLog1(tagCEnumFmtEtc, this, "-CEnumFmtEtc::Clone (hr:%lx)", hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\mon\guids.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       GUIDS.C
//
//  Contents:   Defines GUIDS used in this DLL.
//
//  Classes:
//
//  Functions:
//
//  History:    11-02-95   JoeS (Joe Souza)     Created
//
//----------------------------------------------------------------------------
#include <urlint.h>


#ifdef __cplusplus
extern "C" {
#endif

// CLSIDs of the classes implemented in this dll
//DEFINE_GUID(CLSID_URLMoniker, 0x79eac9e0, 0xbaf9, 0x11ce, 0x8c, 0x82, 0x00, 0xaa, 0x00, 0x4b, 0xa9, 0x0b);


#ifndef GUID_DEFINED
#define GUID_DEFINED

typedef struct _GUID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} GUID;
#endif // GUID_DEFINED

const GUID CLSID_StdURLMoniker =
{
    0x79eac9d0, 0xbaf9, 0x11ce, {0x8c, 0x82, 0x00, 0xaa, 0x00, 0x4b, 0xa9, 0x0b }
};
const GUID CLSID_StdURLProtocol =
{
    0x79eac9e1, 0xbaf9, 0x11ce, {0x8c, 0x82, 0x00, 0xaa, 0x00, 0x4b, 0xa9, 0x0b}
};

const GUID CLSID_PSUrlMonProxy =
{
    0x79eac9f1, 0xbaf9, 0x11ce, {0x8c, 0x82, 0x00, 0xaa, 0x00, 0x4b, 0xa9, 0x0b}
};



#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\mon\authent.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       AUTHENT.CXX
//
//  Contents:   Code to handle multiplexing multiple concurrent
//              IAuthenticate interfaces.
//
//  Classes:    CBasicAuthHolder
//
//  Functions:
//
//  History:    02-05-96    JoeS (Joe Souza)    Created
//
//----------------------------------------------------------------------------

#include <urlint.h>
#include <urlmon.hxx>
#include "authent.hxx"

CBasicAuthHolder::CBasicAuthHolder(void) : _CRefs()
{
    _pCBasicAuthNode = NULL;
    _cElements = 0;
}

STDMETHODIMP CBasicAuthHolder::QueryInterface(REFIID riid, void **ppvObj)
{
    VDATEPTROUT(ppvObj, void *);
    VDATETHIS(this);
    HRESULT hr = NOERROR;

    UrlMkDebugOut((DEB_BINDING, "%p _IN CBasicAuthHolder::QueryInterface\n", this));

    *ppvObj = NULL;
    if (riid == IID_IAuthenticate)
    {
        *ppvObj = this;
        AddRef();
    }
    else
    {
        hr = E_NOINTERFACE;
        CBasicAuthNode  *pNode;

        pNode = _pCBasicAuthNode;

        while (pNode)
        {
            hr = pNode->GetBasicAuthentication()->QueryInterface(riid, ppvObj);

            if (hr == NOERROR)
            {
                pNode = NULL;
            }
            else
            {
                pNode = pNode->GetNextNode();
            }
        }
    }

    UrlMkDebugOut((DEB_BINDING, "%p OUT CBasicAuthHolder::QueryInterface (hr:%lx\n", this,hr));
    return hr;
}

STDMETHODIMP_(ULONG) CBasicAuthHolder::AddRef(void)
{
    UrlMkDebugOut((DEB_BINDING, "%p _IN CBasicAuthHolder::AddRef\n", this));

    LONG lRet = ++_CRefs;

    UrlMkDebugOut((DEB_BINDING, "%p OUT CBasicAuthHolder::AddRef (cRefs:%ld)\n", this,lRet));
    return lRet;
}

STDMETHODIMP_(ULONG) CBasicAuthHolder::Release(void)
{
    UrlMkDebugOut((DEB_BINDING, "%p _IN CBasicAuthHolder::Release\n", this));
    UrlMkAssert((_CRefs > 0));

    LONG lRet = --_CRefs;

    if (_CRefs == 0)
    {
        RemoveAllNodes();
        delete this;
    }

    UrlMkDebugOut((DEB_BINDING, "%p OUT CBasicAuthHolder::Release (cRefs:%ld)\n",this,lRet));
    return lRet;
}

HRESULT CBasicAuthHolder::Authenticate(HWND* phwnd, LPWSTR *pszUsername,
            LPWSTR *pszPassword)
{
    UrlMkDebugOut((DEB_BINDING, "%p _IN CBasicAuthHolder::Authenticate\n", this));
    VDATETHIS(this);
    HRESULT         hr = NOERROR;
    CBasicAuthNode  *pNode;

    pNode = _pCBasicAuthNode;

    while (pNode)
    {
        hr = pNode->GetBasicAuthentication()->Authenticate(phwnd, pszUsername, pszPassword);
        if (hr == S_OK)
        {
            break;
        }

        pNode = pNode->GetNextNode();
    }

    UrlMkDebugOut((DEB_BINDING, "%p OUT CBasicAuthHolder::Authenticate\n", this));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBasicAuthHolder::AddNode
//
//  Synopsis:
//
//  Arguments:  [pIBasicAuth] --
//
//  Returns:
//
//  History:
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CBasicAuthHolder::AddNode(IAuthenticate *pIBasicAuth)
{
    UrlMkDebugOut((DEB_BINDING, "%p _IN CBasicAuthHolder::AddNode \n", this));
    HRESULT hr = NOERROR;

    CBasicAuthNode *pFirstNode = _pCBasicAuthNode;
    CBasicAuthNode *pNode;

    // Allocate memory for new pNode member.

    pNode = new CBasicAuthNode(pIBasicAuth);

    if (!pNode)
    {
        hr = E_OUTOFMEMORY;
    }
    else
    {
        UrlMkDebugOut((DEB_BINDING, "%p IN  CBasicAuthHolder::AddNode (New Node:%p, IBasicAuth:%p) \n",
                                        this, pNode,pNode->GetBasicAuthentication() ));

        // if a node is already
        if (pFirstNode)
        {
            pNode->SetNextNode(pFirstNode);
        }

        // the new node is the first node
        _pCBasicAuthNode = pNode;
        _cElements++;
    }

    UrlMkDebugOut((DEB_BINDING, "%p OUT CBasicAuthHolder::AddNode (NewNode:%p, hr:%lx) \n", this, pNode, hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBasicAuthHolder::RemoveAllNodes
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  History:
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CBasicAuthHolder::RemoveAllNodes(void)
{
    UrlMkDebugOut((DEB_BINDING, "%p _IN CBasicAuthHolder::RemoveAllNodes\n", this));
    HRESULT hr = S_OK;

    CBasicAuthNode *pNode = _pCBasicAuthNode;
    CBasicAuthNode *pNextNode = NULL;

    while (pNode)
    {
        pNextNode = pNode->GetNextNode();

        // release the object
        pNode->GetBasicAuthentication()->Release();
        UrlMkDebugOut((DEB_BINDING, "%p OUT CBasicAuthHolder::RemoveAllNodes (Delete Node:%p, IBasicAuth:%p) \n",
                        this, pNode, pNode->GetBasicAuthentication()));
        delete pNode;
        _cElements--;

        pNode = pNextNode;
    }

    _pCBasicAuthNode = NULL;
    UrlMkAssert((_cElements == 0));

    UrlMkDebugOut((DEB_BINDING, "%p OUT CBasicAuthHolder::RemoveAllNodes (hr:%lx) \n", this, hr));
    return hr;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\mon\httpcls.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       HTTPCLS.CXX
//
//  Contents:   Implements the HTTPMoniker class, which is derived from
//              the CAsyncMoniker class.
//
//  Classes:    HTTPMoniker
//
//  Functions:
//
//  History:    11-02-95   JoeS (Joe Souza)     Created
//
//----------------------------------------------------------------------------

#include <urlint.h>
#include "urlapi.hxx"
#include "casyncmk.hxx"
#include "httpcls.hxx"

STDMETHODIMP_(ULONG) HTTPMoniker::Release(void)
{
    // Decrement refcount, destroy object if refcount goes to zero.
    // Return the new refcount.

    if (!(--m_refs))
    {
        delete this;
        return(0);
    }

    return(m_refs);
}

STDMETHODIMP HTTPMoniker::GetClassID(CLSID *pClassID)
{
    VDATEPTRIN(pClassID, CLSID);

    *pClassID = CLSID_StdURLMoniker;
    return(NOERROR);
}

STDMETHODIMP HTTPMoniker::BindToStorage (THIS_ LPBC pbc, LPMONIKER pmkToLeft,
    REFIID riid, LPVOID FAR* ppvObj)
{
    VDATEPTROUT(ppvObj, LPVOID);
    *ppvObj = NULL;
    VDATEIFACE(pbc);
    if (pmkToLeft)
        VDATEIFACE(pmkToLeft);

    HRESULT hresult = NOERROR;

    //if (!::CreateURLBinding(pbc, this, m_pwzURL))
    //if (!CreateURLBinding(pbc, this, m_pwzURL))
    //    hresult = E_OUTOFMEMORY;    // BUGBUG: Should we use a better error code?

    // BUGBUG: Must attach riid interface to new storage, and return storage
    // object in ppvObj.  (I.e. get temp file name and call StgOpenStorage, etc.

    return(hresult);
}

STDMETHODIMP HTTPMoniker::ParseDisplayName (THIS_ LPBC pbc, LPMONIKER pmkToLeft,
    LPWSTR lpszDisplayName, ULONG FAR* pchEaten,
    LPMONIKER FAR* ppmkOut)
{
    VDATEPTROUT(ppmkOut, LPMONIKER);
    *ppmkOut = NULL;
    VDATEIFACE(pbc);
    if (pmkToLeft)
        VDATEIFACE(pmkToLeft);
    VDATEPTRIN(lpszDisplayName, char);
    VDATEPTROUT(pchEaten, ULONG);

    HRESULT hresult = NOERROR;
    int     len;

    if (m_pwzURL)
        delete [] m_pwzURL;

    len = wcslen(lpszDisplayName);

    m_pwzURL = new WCHAR [len + 1];
    if (!m_pwzURL)
        return(E_OUTOFMEMORY);
    wcscpy(m_pwzURL, lpszDisplayName);

    *pchEaten = len;
    *ppmkOut = this;
    AddRef();
    return(hresult);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\mon\media.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       media.cxx
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    1-20-96   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------
#include <mon.h>

PerfDbgTag(tagMedia,    "Urlmon", "Log Media methods", DEB_FORMAT);
PerfDbgTag(tagMediaApi, "Urlmon", "Log Media API",     DEB_ASYNCAPIS);

#if 1
CHAR vszTextPlain[] =                   "text/plain";
CHAR vszTextRichText[] =                "text/richtext";
CHAR vszImageXBitmap[] =                "image/x-xbitmap";
CHAR vszApplicationPostscript[] =       "application/postscript";
CHAR vszApplicationBase64[] =           "application/base64";
CHAR vszApplicationMacBinhex[] =        "application/macbinhex40";
CHAR vszApplicationPdf[] =              "application/pdf";
CHAR vszAudioAiff[] =                   "audio/x-aiff";
CHAR vszAudioBasic[] =                  "audio/basic";
CHAR vszAudioWav[] =                    "audio/wav";
CHAR vszImageGif[] =                    "image/gif";
CHAR vszImagePJpeg[] =                  "image/pjpeg";
CHAR vszImageJpeg[] =                   "image/jpeg";
CHAR vszImageTiff[] =                   "image/tiff";
CHAR vszImagePng[] =                    "image/x-png";
CHAR vszImagePng2[] =                   "image/png";
CHAR vszImageBmp[] =                    "image/bmp";
CHAR vszImageJG[] =                     "image/x-jg";
CHAR vszImageArt[] =                    "image/x-art";
CHAR vszImageEmf[] =                    "image/x-emf";
CHAR vszImageWmf[] =                    "image/x-wmf";
CHAR vszVideoAvi[] =                    "video/avi";
CHAR vszVideoMS[] =                     "video/x-msvideo";
CHAR vszVideoMpeg[] =                   "video/mpeg";
CHAR vszApplicationCompressed[] =       "application/x-compressed";
CHAR vszApplicationZipCompressed[] =    "application/x-zip-compressed";
CHAR vszApplicationGzipCompressed[] =   "application/x-gzip-compressed";
CHAR vszApplicationMSDownload[] =       "application/x-msdownload";
CHAR vszApplicationJava[] =             "application/java";
CHAR vszApplicationOctetStream[] =      "application/octet-stream";
CHAR vszTextHTML[] =                    "text/html";
CHAR vszApplicationCDF[] =              "application/x-cdf";
CHAR vszApplicationCommonDataFormat[] = "application/x-netcdf";
CHAR vszTextScriptlet[] =               "text/scriptlet";
#endif

const GUID IID_IMediaHolder =  {0x79eac9ce, 0xbaf9, 0x11ce, {0x8c, 0x82, 0x00, 0xaa, 0x00, 0x4b, 0xa9, 0x0b}};

#define XCLSID_MsHtml  {0x25336920, 0x03F9, 0x11cf, {0x8F, 0xD0, 0x00, 0xAA, 0x00, 0x68, 0x6F, 0x13}}
#define XCLSID_CDFVIEW {0xf39a0dc0, 0x9cc8, 0x11d0, {0xa5, 0x99, 0x0, 0xc0, 0x4f, 0xd6, 0x44, 0x33}}

BOOL g_fDefaultMediaRegistered = FALSE;
static MediaInfo rgMediaInfo[] =
{
       { vszTextHTML                    , 0, DATAFORMAT_TEXTORBINARY,   XCLSID_MsHtml, 0x00000070 ,0 ,CLSCTX_INPROC  }
      ,{ vszTextPlain                   , 0, DATAFORMAT_AMBIGUOUS,      {0} ,0 ,0 ,0  }
      ,{ vszTextRichText                , 0, DATAFORMAT_TEXT,           {0} ,0 ,0 ,0  }
      ,{ vszImageXBitmap                , 0, DATAFORMAT_TEXT,           {0} ,0 ,0 ,0  }
      ,{ vszApplicationPostscript       , 0, DATAFORMAT_TEXT,           {0} ,0 ,0 ,0  }
      ,{ vszApplicationBase64           , 0, DATAFORMAT_TEXT,           {0} ,0 ,0 ,0  }
      ,{ vszApplicationMacBinhex        , 0, DATAFORMAT_TEXT,           {0} ,0 ,0 ,0  }
      ,{ vszApplicationPdf              , 0, DATAFORMAT_BINARY,         {0} ,0 ,0 ,0  }
      ,{ vszAudioAiff                   , 0, DATAFORMAT_BINARY,         {0} ,0 ,0 ,0  }
      ,{ vszAudioBasic                  , 0, DATAFORMAT_BINARY,         {0} ,0 ,0 ,0  }
      ,{ vszAudioWav                    , 0, DATAFORMAT_BINARY,         {0} ,0 ,0 ,0  }
      ,{ vszImageGif                    , 0, DATAFORMAT_BINARY,         {0} ,0 ,0 ,0  }
      ,{ vszImagePJpeg                  , 0, DATAFORMAT_BINARY,         {0} ,0 ,0 ,0  }
      ,{ vszImageJpeg                   , 0, DATAFORMAT_BINARY,         {0} ,0 ,0 ,0  }
      ,{ vszImageTiff                   , 0, DATAFORMAT_BINARY,         {0} ,0 ,0 ,0  }
      ,{ vszImagePng                    , 0, DATAFORMAT_BINARY,         {0} ,0 ,0 ,0  }
      ,{ vszImagePng2                   , 0, DATAFORMAT_BINARY,         {0} ,0 ,0 ,0  }
      ,{ vszImageBmp                    , 0, DATAFORMAT_BINARY,         {0} ,0 ,0 ,0  }
      ,{ vszImageJG                     , 0, DATAFORMAT_BINARY,         {0} ,0 ,0 ,0  }
      ,{ vszImageArt                    , 0, DATAFORMAT_BINARY,         {0} ,0 ,0 ,0  }
      ,{ vszImageEmf                    , 0, DATAFORMAT_BINARY,         {0} ,0 ,0 ,0  }
      ,{ vszImageWmf                    , 0, DATAFORMAT_BINARY,         {0} ,0 ,0 ,0  }
      ,{ vszVideoAvi                    , 0, DATAFORMAT_BINARY,         {0} ,0 ,0 ,0  }
      ,{ vszVideoMS                     , 0, DATAFORMAT_BINARY,         {0} ,0 ,0 ,0  }
      ,{ vszVideoMpeg                   , 0, DATAFORMAT_BINARY,         {0} ,0 ,0 ,0  }
      ,{ vszApplicationCompressed       , 0, DATAFORMAT_BINARY,         {0} ,0 ,0 ,0  }
      ,{ vszApplicationZipCompressed    , 0, DATAFORMAT_BINARY,         {0} ,0 ,0 ,0  }
      ,{ vszApplicationGzipCompressed   , 0, DATAFORMAT_BINARY,         {0} ,0 ,0 ,0  }
      ,{ vszApplicationJava             , 0, DATAFORMAT_BINARY,         {0} ,0 ,0 ,0  }
      ,{ vszApplicationMSDownload       , 0, DATAFORMAT_BINARY,         {0} ,0 ,0 ,0  }
      ,{ vszApplicationOctetStream      , 0, DATAFORMAT_AMBIGUOUS,      {0} ,0 ,0 ,0  }
      ,{ vszApplicationCDF              , 0, DATAFORMAT_TEXT,           XCLSID_CDFVIEW ,(MI_GOTCLSID | MI_CLASSLOOKUP) ,0 ,CLSCTX_INPROC  }
      ,{ vszApplicationCommonDataFormat , 0, DATAFORMAT_AMBIGUOUS,      {0} ,0 ,0 ,0  }
      ,{ vszTextScriptlet               , 0, DATAFORMAT_TEXT,           {0} ,0 ,0 ,0  }
};

CMediaTypeHolder *g_pCMHolder = NULL;

//+---------------------------------------------------------------------------
//
//  Function:   GetMediaTypeHolder
//
//  Synopsis:   Retrieves the media type holder for this apartment
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    1-20-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
CMediaTypeHolder *GetMediaTypeHolder()
{
    PerfDbgLog(tagMediaApi, NULL, "+GetMediaTypeHolder");
#ifdef PER_THREAD
    CUrlMkTls tls;

    CMediaTypeHolder *pCMHolder;

    if ((pCMHolder = tls->pCMediaHolder) == NULL)
    {
        tls->pCMediaHolder = pCMHolder = new CMediaTypeHolder();
    }
#else
    CLock lck(g_mxsMedia);

    if (g_pCMHolder == NULL)
    {
        g_pCMHolder = new CMediaTypeHolder();
    }

#endif //PER_THREAD

    PerfDbgLog1(tagMediaApi, NULL, "-GetMediaTypeHolder (pCMHolder:%lx)", g_pCMHolder);
    return g_pCMHolder;
}


void CMediaType::Initialize(LPSTR szType, CLIPFORMAT cfFormat)
{

    _pszType  = szType;
    _cfFormat = cfFormat;
}

void CMediaType::Initialize(CLIPFORMAT cfFormat, CLSID *pClsID)
{
    _pszType  = NULL;
    _cfFormat = cfFormat;
    _clsID = *pClsID;
    _dwInitFlags |= MI_GOTCLSID;
}


CMediaTypeHolder::CMediaTypeHolder() : _CRefs()
{
    _pCMTNode = NULL;
}

CMediaTypeHolder::~CMediaTypeHolder()
{
    CMediaTypeNode  *pCMTNode, *pNext;

    pCMTNode = _pCMTNode;

    // Delete everything that was allocated by Register.

    while (pCMTNode)
    {
        pNext = pCMTNode->GetNextNode();
        delete pCMTNode;
        pCMTNode = pNext;
    }

    _pCMTNode = NULL;
}

//+---------------------------------------------------------------------------
//
//  Method:     CMediaTypeHolder::RegisterW
//
//  Synopsis:
//
//  Arguments:  [ctypes] --
//              [rgszTypes] --
//              [rgcfTypes] --
//
//  Returns:
//
//  History:    3-22-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CMediaTypeHolder::RegisterW(UINT ctypes, const LPCWSTR* rgszTypes, CLIPFORMAT* rgcfTypes)
{
    PerfDbgLog(tagMedia, this, "+CMediaTypeHolder::Register");
    HRESULT hr = NOERROR;

    UINT i;

    if (ctypes)
    {
        ULONG           ulSize;
        LPCWSTR         pwzStr;
        LPSTR           pszStr;
        LPSTR           pszHelp;

        LPSTR           pszTextBuffer;
        CMediaType      *pCMType;
        CMediaTypeNode  *pCMTNode;

        // Calculate size of single buffer needed to hold all strings.

        for (ulSize = i = 0; i < ctypes; i++)
        {
            pwzStr = *(rgszTypes + i);
            ulSize += wcslen(pwzStr) + 1;
            //PerfDbgLog2(tagMedia, this, "CMTHolder::Register(sz:%ws; len:%ld)", pszStr, ulSize));
        }

        pszTextBuffer = pszStr = new CHAR[ulSize];
        if (!pszTextBuffer)
        {
            hr = E_OUTOFMEMORY;
            goto RegisterExit;
        }

        pCMType = new CMediaType[ctypes];
        if (!pCMType)
        {
            delete pszTextBuffer;
            hr = E_OUTOFMEMORY;
            goto RegisterExit;
        }

        pCMTNode = new CMediaTypeNode(pCMType, pszTextBuffer, ctypes, _pCMTNode);
        if (!pCMTNode)
        {
            delete pCMType;
            delete pszTextBuffer;
            hr = E_OUTOFMEMORY;
            goto RegisterExit;
        }

        pszHelp = pszStr;

        for (i = 0; i < ctypes; i++)
        {
            pwzStr = *(rgszTypes + i);
            //wcscpy(pszHelp, pszStr);
            W2A(pwzStr, pszHelp, wcslen(pwzStr) + 1);
            (pCMType + i)->Initialize(pszHelp, *(rgcfTypes + i));
            pszHelp += strlen(pszHelp) + 1;
        }

        // New node is first on list.

        _pCMTNode = pCMTNode;
    }

RegisterExit:

    PerfDbgLog1(tagMedia, this, "-CMediaTypeHolder::Register (hr:%lx)", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CMediaTypeHolder::Register
//
//  Synopsis:
//
//  Arguments:  [ctypes] --
//              [rgszTypes] --
//              [rgcfTypes] --
//
//  Returns:
//
//  History:    3-22-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CMediaTypeHolder::Register(UINT ctypes, const LPCSTR* rgszTypes, CLIPFORMAT* rgcfTypes)
{
    PerfDbgLog(tagMedia, this, "+CMediaTypeHolder::Register");
    HRESULT hr = NOERROR;

    UINT i;

    if (ctypes)
    {
        ULONG           ulSize;
        LPCSTR          pszStr;
        LPSTR           pszNewStr;
        LPSTR           pszHelp;

        LPSTR           pszTextBuffer;
        CMediaType      *pCMType;
        CMediaTypeNode  *pCMTNode;

        // Calculate size of single buffer needed to hold all strings.

        for (ulSize = i = 0; i < ctypes; i++)
        {
            pszStr = *(rgszTypes + i);
            ulSize += strlen(pszStr) + 1;
            //PerfDbgLog2(tagMedia, this, "CMTHolder::Register(sz:%s; len:%ld)", pszStr, ulSize));
        }

        pszTextBuffer = pszNewStr = new CHAR[ulSize];
        if (!pszTextBuffer)
        {
            hr = E_OUTOFMEMORY;
            goto RegisterExit;
        }

        pCMType = new CMediaType[ctypes];
        if (!pCMType)
        {
            delete pszTextBuffer;
            hr = E_OUTOFMEMORY;
            goto RegisterExit;
        }

        pCMTNode = new CMediaTypeNode(pCMType, pszTextBuffer, ctypes, _pCMTNode);
        if (!pCMTNode)
        {
            delete pCMType;
            delete pszTextBuffer;
            hr = E_OUTOFMEMORY;
            goto RegisterExit;
        }

        pszHelp = pszNewStr;

        for (i = 0; i < ctypes; i++)
        {
            pszStr = *(rgszTypes + i);

            StrNCpy(pszHelp, pszStr, strlen(pszStr) + 1);
            *(rgcfTypes + i) = (CLIPFORMAT) RegisterClipboardFormat(pszStr);

            (pCMType + i)->Initialize(pszHelp, *(rgcfTypes + i));
            pszHelp += strlen(pszHelp) + 1;
        }

        // New node is first on list.

        if (!_pCMTNode)
        {
            _pCMTNode = pCMTNode;
        }
        else
        {
            CMediaTypeNode  *pCMTNext = _pCMTNode->GetNextNode();
            _pCMTNode->SetNextNode(pCMTNode);
            pCMTNode->SetNextNode(pCMTNext);
        }

    }

RegisterExit:

    PerfDbgLog1(tagMedia, this, "-CMediaTypeHolder::Register (hr:%lx)", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CMediaTypeHolder::Register
//
//  Synopsis:
//
//  Arguments:  [ctypes] --
//              [rgszTypes] --
//              [rgcfTypes] --
//
//  Returns:
//
//  History:    3-22-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CMediaTypeHolder::RegisterMediaInfo(UINT ctypes, MediaInfo *pMediaInfo, BOOL fFree)
{
    PerfDbgLog(tagMedia, this, "+CMediaTypeHolder::RegisterMediaInfo");
    HRESULT hr = NOERROR;

    UINT i;

    if (ctypes)
    {
        CMediaType      *pCMType;
        CMediaTypeNode  *pCMTNode;

        // Calculate size of single buffer needed to hold all strings.

        pCMType = (CMediaType *)pMediaInfo;
        if (!pCMType)
        {
            goto RegisterExit;
        }

        pCMTNode = new CMediaTypeNode(pCMType, NULL, ctypes, _pCMTNode, FALSE);
        if (!pCMTNode)
        {
            hr = E_OUTOFMEMORY;
            goto RegisterExit;
        }

        for (i = 0; i < ctypes; i++)
        {
            CMediaType *pCMT = (pCMType + i);
            CLIPFORMAT cf = (CLIPFORMAT) RegisterClipboardFormat(pCMT->GetTypeString());
            pCMT->SetClipFormat(cf);
        }

        // New node is first on list.
        _pCMTNode = pCMTNode;
    }

RegisterExit:

    PerfDbgLog1(tagMedia, this, "-CMediaTypeHolder::RegisterMediaInfo (hr:%lx)", hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CMediaTypeHolder::FindCMediaType
//
//  Synopsis:
//
//  Arguments:  [pszMimeStr] --
//              [ppCMType] --
//
//  Returns:
//
//  History:    3-26-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CMediaTypeHolder::FindCMediaType(CLIPFORMAT cfFormat, CMediaType **ppCMType)
{
    PerfDbgLog(tagMedia, this, "+CMediaTypeHolder::FindCMediaType");
    HRESULT         hr = E_INVALIDARG;
    CMediaTypeNode  *pCMTNode;
    CMediaType      *pCMType;
    UINT            i;

    UrlMkAssert((ppCMType));
    *ppCMType = NULL;

    pCMTNode = _pCMTNode;

    if (!pCMTNode)
    {
        hr = E_FAIL;
    }
    else while (pCMTNode)
    {
        pCMType = pCMTNode->GetMediaTypeArray();

        for (i = 0; i < pCMTNode->GetElementCount(); i++)
        {
            if (cfFormat == (pCMType + i)->GetClipFormat())
            {
                *ppCMType = pCMType + i;
                hr = NOERROR;
                break;
            }
        }

        if (*ppCMType)
        {
            break;
        }

        pCMTNode = pCMTNode->GetNextNode();
    }

    PerfDbgLog1(tagMedia, this, "-CMediaTypeHolder::FindCMediaType (hr:%lx)", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CMediaTypeHolder::FindCMediaType
//
//  Synopsis:
//
//  Arguments:  [pszMimeStr] --
//              [ppCMType] --
//
//  Returns:
//
//  History:    3-28-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CMediaTypeHolder::FindCMediaType(LPCSTR pszMimeStr, CMediaType **ppCMType)
{
    PerfDbgLog(tagMedia, this, "+CMediaTypeHolder::FindCMediaType");
    HRESULT         hr = E_INVALIDARG;
    CMediaTypeNode  *pCMTNode;
    CMediaType      *pCMType;
    UINT            i;

    *ppCMType = NULL;

    pCMTNode = _pCMTNode;

    if (!pCMTNode)
    {
        hr = E_FAIL;
    }
    else while (pCMTNode)
    {
        pCMType = pCMTNode->GetMediaTypeArray();

        for (i = 0; i < pCMTNode->GetElementCount(); i++)
        {
            if (!stricmp(pszMimeStr, (pCMType + i)->GetTypeString()))
            {
                *ppCMType = pCMType + i;
                hr = NOERROR;
                break;
            }
        }

        if (*ppCMType)
        {
            break;
        }

        pCMTNode = pCMTNode->GetNextNode();
    }

    PerfDbgLog1(tagMedia, this, "-CMediaTypeHolder::FindCMediaType (hr:%lx)", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CMediaTypeHolder::QueryInterface
//
//  Synopsis:
//
//  Arguments:  [riid] --
//              [ppv] --
//
//  Returns:
//
//  History:    11-11-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CMediaTypeHolder::QueryInterface( REFIID riid, void **ppv )
{
    HRESULT     hr = NOERROR;

    PerfDbgLog2(tagMedia, this, "+CMediaTypeHolder::QueryInterface (%lx, %lx)", riid, ppv);

    if (   IsEqualIID(riid, IID_IUnknown)
        || IsEqualIID(riid, IID_IMediaHolder))
    {
        *ppv = (void FAR *)this;
        AddRef();
    }
    else
    {
        *ppv = NULL;
        hr = E_NOINTERFACE;
    }

    PerfDbgLog2(tagMedia, this, "-CMediaTypeHolder::QueryInterface (%lx)[%lx]", hr, *ppv);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CMediaTypeHolder::AddRef
//
//  Synopsis:
//
//  Arguments:  [void] --
//
//  Returns:
//
//  History:    11-11-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CMediaTypeHolder::AddRef( void )
{
    LONG lRet = _CRefs++;
    PerfDbgLog1(tagMedia, this, "CMediaTypeHolder::AddRef (%ld)", lRet);
    return lRet;
}

//+---------------------------------------------------------------------------
//
//  Method:     CMediaTypeHolder::Release
//
//  Synopsis:
//
//  Arguments:  [void] --
//
//  Returns:
//
//  History:    11-11-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CMediaTypeHolder::Release( void )
{
    PerfDbgLog(tagMedia, this, "+CMediaTypeHolder::Release");

    LONG lRet = --_CRefs;
    if (_CRefs == 0)
    {
        delete this;
    }
    PerfDbgLog1(tagMedia, this, "-CMediaTypeHolder::Release (%ld)", lRet);
    return lRet;
}

//+---------------------------------------------------------------------------
//
//  Method:     CMediaTypeHolder::RegisterClassMapping
//
//  Synopsis:   registers a class mapping for given mimes strings
//
//  Arguments:  [ctypes] --
//              [rgszNames] --
//              [rgClsIDs] --
//              [dwReserved] --
//
//  Returns:
//
//  History:    8-20-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CMediaTypeHolder::RegisterClassMapping (DWORD ctypes, LPCSTR rgszNames[], CLSID rgClsIDs[], DWORD dwReserved)
{
    PerfDbgLog(tagMedia, this, "+CMediaTypeHolder::RegisterClassMapping");

    HRESULT hr = RegisterClass(ctypes, rgszNames, rgClsIDs );

    PerfDbgLog1(tagMedia, this, "-CMediaTypeHolder::RegisterClassMapping (hr:%lX)", hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CMediaTypeHolder::FindClassMapping
//
//  Synopsis:   returns the class for a given mime if registered
//
//  Arguments:  [szMime] --
//              [pClassID] --
//              [dwReserved] --
//
//  Returns:
//
//  History:    8-20-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CMediaTypeHolder::FindClassMapping(LPCSTR szMime, CLSID *pClassID, DWORD dwReserved)
{
    PerfDbgLog(tagMedia, this, "+CMediaTypeHolder::FindClassMapping");
    HRESULT hr = NOERROR;
    CLIPFORMAT cfTypes = CF_NULL;

    TransAssert((pClassID));
    *pClassID = CLSID_NULL;

    cfTypes = (CLIPFORMAT) RegisterClipboardFormat(szMime);
    if (cfTypes != CF_NULL)
    {
        CMediaType  *pCMType = NULL;
        hr = FindCMediaType(cfTypes, &pCMType);
        if (hr == NOERROR)
        {
            TransAssert((pCMType));
            hr = pCMType->GetClsID(pClassID);
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

    PerfDbgLog1(tagMedia, this, "-CMediaTypeHolder::FindClassMapping (hr:%lx)", hr);
    return hr;
}



//+---------------------------------------------------------------------------
//
//  Method:     CMediaTypeHolder::RegisterClass
//
//  Synopsis:
//
//  Arguments:  [ctypes] --
//              [rgszTypes] --
//              [rgcfTypes] --
//
//  Returns:
//
//  History:    3-22-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CMediaTypeHolder::RegisterClass(UINT ctypes, const LPCSTR* rgszTypes, CLSID *rgclsID)
{
    PerfDbgLog(tagMedia, this, "+CMediaTypeHolder::RegisterClass");
    HRESULT hr = NOERROR;

    UINT i;

    if (ctypes)
    {
        ULONG           ulSize;
        CMediaType      *pCMType;
        CMediaTypeNode  *pCMTNode;

        // Calculate size of single buffer needed to hold all strings.

        pCMType = new CMediaType[ctypes];
        if (!pCMType)
        {
            hr = E_OUTOFMEMORY;
            goto RegisterExit;
        }

        pCMTNode = new CMediaTypeNode(pCMType, NULL, ctypes, _pCMTNode);
        if (!pCMTNode)
        {
            delete pCMType;
            hr = E_OUTOFMEMORY;
            goto RegisterExit;
        }
        for (i = 0; i < ctypes; i++)
        {
            CLIPFORMAT cfTypes;
            LPCSTR pszStr = *(rgszTypes + i);

            cfTypes = (CLIPFORMAT) RegisterClipboardFormat(pszStr);
            pCMType[i].Initialize(cfTypes,(rgclsID + i));
        }

        // New node is first on list.
        _pCMTNode = pCMTNode;
    }

RegisterExit:

    PerfDbgLog1(tagMedia, this, "-CMediaTypeHolder::RegisterClass (hr:%lx)", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   RegisterDefaultMediaType
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    3-28-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT RegisterDefaultMediaType()
{
    PerfDbgLog(tagMediaApi, NULL, "+RegisterDefaultMediaType");

    HRESULT hr = InternalRegisterDefaultMediaType();

    PerfDbgLog(tagMediaApi, NULL, "-RegisterDefaultMediaType");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   InternalRegisterDefaultMediaType
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    7-24-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT InternalRegisterDefaultMediaType()
{
    HRESULT hr = NOERROR;
    PerfDbgLog(tagMediaApi, NULL, "+InternalRegisterDefaultMediaType");
    static DWORD s_dwfHonorTextPlain = 42;
    CLock lck(g_mxsMedia);

    // Provide a registry hook for enabling urlmon to honor
    // text/plain, rather than defer to the extension.
    // Previously, this was considered ambiguous due to compat
    // reasons with older servers sending this for unknown content types.
    //
    // TODO:  Consider making this the default behavior because
    //        other browsers (e.g. Nav 4.61) are moving in this
    //        direction.
    if (s_dwfHonorTextPlain == 42)
    {
        HKEY hKey;
        DWORD dwType;
        DWORD dwSize = sizeof(s_dwfHonorTextPlain);
        s_dwfHonorTextPlain = 0;

        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, "Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings", 0, KEY_QUERY_VALUE, &hKey))
        {
            if (ERROR_SUCCESS != RegQueryValueEx(hKey, TEXT("IsTextPlainHonored"), NULL, &dwType, (LPBYTE)&s_dwfHonorTextPlain, &dwSize))
                s_dwfHonorTextPlain = 0;

            RegCloseKey(hKey);
        }
        // rgMediaInfo is a static global, so we only need to do this once.
        if (s_dwfHonorTextPlain)
        {
            DWORD d = 0;
            dwSize = sizeof(rgMediaInfo)/sizeof(MediaInfo);
            for (d = 0; d < dwSize; d++)
            {
                if (!lstrcmp(vszTextPlain, rgMediaInfo[d]._pszType))
                {
                    rgMediaInfo[d]._dwDataFormat = DATAFORMAT_TEXTORBINARY;  // remove the ambiguity
                    break;
                }
            }
        }
    }

    if (g_fDefaultMediaRegistered == FALSE)
    {
        CMediaTypeHolder *pCMHolder;
        g_fDefaultMediaRegistered = TRUE;

        pCMHolder = GetMediaTypeHolder();

        if (pCMHolder)
        {
            DWORD dwSize =sizeof(rgMediaInfo)/sizeof(MediaInfo);
            hr = pCMHolder->RegisterMediaInfo(dwSize,rgMediaInfo,FALSE);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    PerfDbgLog(tagMediaApi, NULL, "-InternalRegisterDefaultMediaType");
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   FindMediaType
//
//  Synopsis:
//
//  Arguments:  [pwzType] --
//              [cfType] --
//
//  Returns:
//
//  History:    3-22-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT FindMediaType(LPCSTR pszType, CLIPFORMAT *cfType)
{
    HRESULT hr = E_OUTOFMEMORY;
    PerfDbgLog(tagMediaApi, NULL, "+FindMediaType");
    CMediaTypeHolder *pCMHolder;
    CLock lck(g_mxsMedia);

    UrlMkAssert((cfType));

    InternalRegisterDefaultMediaType();

    if ((pszType == NULL) || (cfType == CF_NULL))
    {
        hr = E_INVALIDARG;
    }
    else if ((pCMHolder = GetMediaTypeHolder()) != NULL)
    {

        CMediaType  *pCMType;
        *cfType = CF_NULL;

        hr = pCMHolder->FindCMediaType(pszType, &pCMType);
        if (hr == NOERROR)
        {
            *cfType = pCMType->GetClipFormat();
        }
    }
    else
    {
        hr = E_FAIL;
    }

    PerfDbgLog(tagMediaApi, NULL, "-FindMediaType");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   FindMediaTypeW
//
//  Synopsis:
//
//  Arguments:  [pwzType] --
//              [cfType] --
//
//  Returns:
//
//  History:    3-22-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT FindMediaTypeW(LPCWSTR pwzType, CLIPFORMAT *pcfType)
{
    HRESULT hr = E_NOTIMPL;
    PerfDbgLog(tagMediaApi, NULL, "+FindMediaTypeW");
    CMediaTypeHolder *pCMHolder;
    CLock lck(g_mxsMedia);

    char szMime[SZMIMESIZE_MAX];
    W2A(pwzType, szMime, SZMIMESIZE_MAX);

    if (FindMediaType((LPCSTR)szMime,pcfType) != NOERROR)
    {
        *pcfType = (CLIPFORMAT) RegisterClipboardFormat(szMime);
        hr = NOERROR;
    }

    PerfDbgLog(tagMediaApi, NULL, "-FindMediaTypeW");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   FindMediaString
//
//  Synopsis:
//
//  Arguments:  [cfFormat] --
//              [ppStr] --
//
//  Returns:
//
//  History:    3-29-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT FindMediaString(CLIPFORMAT cfFormat, LPSTR *ppStr)
{
    HRESULT hr = E_OUTOFMEMORY;
    PerfDbgLog1(tagMediaApi, NULL, "+FindMediaString (cfFormat:%d)", cfFormat);
    CMediaTypeHolder *pCMHolder;
    CLock lck(g_mxsMedia);

    UrlMkAssert((cfFormat));

    InternalRegisterDefaultMediaType();

    if ((pCMHolder = GetMediaTypeHolder()) != NULL)
    {
        CMediaType  *pCMType = NULL;
        hr = pCMHolder->FindCMediaType(cfFormat, &pCMType);
        if ((hr == NOERROR) && pCMType)
        {
            *ppStr = pCMType->GetTypeString();
            UrlMkAssert((*ppStr));
        }
        else
        {
            hr = E_FAIL;
        }
    }
    else
    {
        hr = E_FAIL;
    }

    PerfDbgLog2(tagMediaApi, NULL, "-FindMediaString (clFormat:%d -> szMime:%s)",cfFormat,hr?"":*ppStr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   FindMediaTypeFormat
//
//  Synopsis:
//
//  Arguments:  [pszType] --
//              [cfType] --
//              [pdwFormat] --
//
//  Returns:
//
//  History:    7-23-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT FindMediaTypeFormat(LPCWSTR pwzType, CLIPFORMAT *cfType, DWORD *pdwFormat)
{
    HRESULT hr = E_OUTOFMEMORY;
    PerfDbgLog(tagMediaApi, NULL, "+FindMediaTypeFormat");
    CMediaTypeHolder *pCMHolder;
    CLock lck(g_mxsMedia);

    UrlMkAssert((cfType));

    LPSTR pszType = DupW2A(pwzType);

    InternalRegisterDefaultMediaType();

    if ((pszType == NULL) || (cfType == CF_NULL) || (!pdwFormat))
    {
        hr = E_INVALIDARG;
    }
    else if ((pCMHolder = GetMediaTypeHolder()) != NULL)
    {

        CMediaType  *pCMType;
        *cfType = CF_NULL;

        hr = pCMHolder->FindCMediaType(pszType, &pCMType);
        if (hr == NOERROR)
        {
            *cfType = pCMType->GetClipFormat();
            *pdwFormat = pCMType->GetDataFormat();
        }
    }
    else
    {
        hr = E_FAIL;
    }

    if (pszType)
    {
        delete pszType;
    }

    PerfDbgLog4(tagMediaApi, NULL, "-FindMediaTypeFormat (hr:%lx Mime:%ws, cf:%ld, DataFormat:%ld)",
        hr, pwzType, cfType, *pdwFormat);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   FindMediaTypeClassInfo
//
//  Synopsis:
//
//  Arguments:  [pszType] --
//              [pclsid] --
//              [pdwClsCtx] --
//
//  Returns:
//
//  History:    7-23-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT FindMediaTypeClassInfo(LPCSTR pszType, LPCSTR pszFileName, LPCLSID pclsid, DWORD *pdwClsCtx, DWORD dwFlags)
{
    HRESULT hr = E_OUTOFMEMORY;
    PerfDbgLog(tagMediaApi, NULL,"+FindMediaTypeClassInfo\n");
    CMediaTypeHolder *pCMHolder;
    BOOL fChecked = FALSE;
    CLock lck(g_mxsMedia);

    UrlMkAssert((pclsid));

    InternalRegisterDefaultMediaType();

    if ((pszType == NULL) || (!pclsid))
    {
        hr = E_INVALIDARG;
    }
    else if ((pCMHolder = GetMediaTypeHolder()) != NULL)
    {

        CMediaType  *pCMType;
        *pclsid = CLSID_NULL;

        hr = pCMHolder->FindCMediaType(pszType, &pCMType);
        if ( hr == NOERROR && !(dwFlags & MIMEFLAGS_IGNOREMIME_CLASSID) ) 
        {
            fChecked = TRUE;

            hr = pCMType->GetClsID(pclsid);

            if (hr == NOERROR)
            {
                hr = pCMType->GetClsCtx(pdwClsCtx);
                if (hr != NOERROR)
                {
                    hr = GetClsIDInfo(pclsid, 0, pdwClsCtx);
                    if (hr == NOERROR)
                    {
                        pCMType->SetClsCtx(*pdwClsCtx);
                    }
                }
            }
            else if (!pCMType->IsLookupDone())
            {
                pCMType->SetLookupDone();
                
                //
                // find the clsid and clsctx
                DWORD dwMimeFlags = 0;
                hr = GetMimeInfo((LPSTR)pszType, pclsid, FALSE, &dwMimeFlags);
                
                if (hr == NOERROR)
                {
                    pCMType->SetMimeInfo(*pclsid, dwMimeFlags);
                    hr = GetClsIDInfo(pclsid, 0, pdwClsCtx);
                    if (hr == NOERROR)
                    {
                        pCMType->SetClsCtx(*pdwClsCtx);
                    }
                } 
            
                // no class found yet - try the filename
                
                if (hr != NOERROR && pszFileName)
                {
                    WCHAR wzFileName[MAX_PATH];
                    
                    A2W((LPSTR)pszFileName,wzFileName, MAX_PATH);
                    
                    hr = GetClassFile(wzFileName, pclsid);

                    if (hr == NOERROR)
                    {
                        // do not trust filename-app/oc combination
                        // example: a.doc and a.xls are both marked as app/oc
                        if( strcmp(pszType, "application/octet-stream"))
                        {
                            
                            // found a class for this mime
                            pCMType->SetMimeInfo(*pclsid, dwMimeFlags);
                            hr = GetClsIDInfo(pclsid, 0, pdwClsCtx);
                            if (hr == NOERROR)
                            {
                                pCMType->SetClsCtx(*pdwClsCtx);
                            }
                        }
                        else
                        {
                            pCMType->SetLookupDone(FALSE);
                        }
    
                    }
                }
            }
        }
        
        if (   (hr != NOERROR || (dwFlags & MIMEFLAGS_IGNOREMIME_CLASSID) ) 
            && !fChecked )
        {
            hr = GetClassMime((LPSTR)pszType, pclsid, (dwFlags & MIMEFLAGS_IGNOREMIME_CLASSID));
        }
        
    }
    else
    {
        hr = E_FAIL;
    }

    PerfDbgLog1(tagMediaApi, NULL, "-FindMediaTypeClassInfo (hr:%lx)\n",hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\mon\precomp1.inc ===
#//+---------------------------------------------------------------
#//
#//  File:      precomp1.inc
#//
#//  Contents:  directives for global precompiled include file when the
#//             sources file is two directories below com (or wherever
#//             this file is located).  We could easily have precomp3 and
#//             precomp4 for other areas.The urlint.* files should not
#//             otherwise be mentioned in the sources files.
#//
#//
#//----------------------------------------------------------------

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\..\inc\mon.h
PRECOMPILED_TARGET=$(GPCH_BUILD)\$(_OBJ_DIR)\*\mon.pch
PRECOMPILED_OPTION=/Yumon.h /Fp$(GPCH_BUILD)\$(_OBJ_DIR)\*\mon.pch
PRECOMPILED_OBJ=$(GPCH_BUILD)\$(_OBJ_DIR)\*\mon.obj


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\mon\httpneg.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       HTTPNEG.CXX
//
//  Contents:   Code to handle multiplexing multiple concurrent
//              IHttpNegotiate interfaces.
//
//  Classes:    CHttpNegHolder
//
//  Functions:
//
//  History:    01-30-96    JoeS (Joe Souza)    Created
//
//----------------------------------------------------------------------------

#include <urlint.h>
#include <urlmon.hxx>
#include "httpneg.hxx"

CHttpNegHolder::CHttpNegHolder(void) : _CRefs()
{
    _pCHttpNegNode = NULL;
    _cElements = 0;
}

STDMETHODIMP CHttpNegHolder::QueryInterface(REFIID riid, void **ppvObj)
{
    VDATEPTROUT(ppvObj, void *);
    VDATETHIS(this);
    HRESULT hr = NOERROR;

    UrlMkDebugOut((DEB_BINDING, "%p _IN CHttpNegHolder::QueryInterface\n", this));

    *ppvObj = NULL;
    if (riid == IID_IHttpNegotiate)
    {
        *ppvObj = this;
        AddRef();
    }
    else
    {
        hr = E_NOINTERFACE;
        CHttpNegNode   *pNode;

        pNode = _pCHttpNegNode;

        while (pNode)
        {
            hr = pNode->GetHttpNegotiate()->QueryInterface(riid, ppvObj);

            if (hr == NOERROR)
            {
                pNode = NULL;
            }
            else
            {
                pNode = pNode->GetNextNode();
            }
        }
    }

    UrlMkDebugOut((DEB_BINDING, "%p OUT CHttpNegHolder::QueryInterface (hr:%lx\n", this,hr));
    return hr;
}

STDMETHODIMP_(ULONG) CHttpNegHolder::AddRef(void)
{
    UrlMkDebugOut((DEB_BINDING, "%p _IN CHttpNegHolder::AddRef\n", this));

    LONG lRet = ++_CRefs;

    UrlMkDebugOut((DEB_BINDING, "%p OUT CHttpNegHolder::AddRef (cRefs:%ld)\n", this,lRet));
    return lRet;
}

STDMETHODIMP_(ULONG) CHttpNegHolder::Release(void)
{
    UrlMkDebugOut((DEB_BINDING, "%p _IN CHttpNegHolder::Release\n", this));
    UrlMkAssert((_CRefs > 0));

    LONG lRet = --_CRefs;

    if (_CRefs == 0)
    {
        RemoveAllNodes();
        delete this;
    }

    UrlMkDebugOut((DEB_BINDING, "%p OUT CHttpNegHolder::Release (cRefs:%ld)\n",this,lRet));
    return lRet;
}

HRESULT CHttpNegHolder::BeginningTransaction(LPCWSTR szURL, LPCWSTR szHeaders,
            DWORD dwReserved, LPWSTR *pszAdditionalHeaders)
{
    UrlMkDebugOut((DEB_BINDING, "%p _IN CHttpNegHolder::BeginningTransaction (szURL:%ws, szHeaders:%ws)\n", this, szURL, szHeaders));
    VDATETHIS(this);
    HRESULT         hr = NOERROR;
    CHttpNegNode    *pNode;
    LPWSTR          szTmp = NULL, szNew = NULL, szRunning = NULL;

    pNode = _pCHttpNegNode;

    while (pNode)
    {
        hr = pNode->GetHttpNegotiate()->BeginningTransaction(szURL, szHeaders, dwReserved, &szNew);
        UrlMkDebugOut((DEB_BINDING, "%p === CHttpNegHolder::BeginningTransaction (szNew:%ws )\n", this, szNew));

        if (hr == NOERROR && szNew != NULL && szRunning != NULL)
        {
            szTmp = szRunning;
            szRunning = new WCHAR [wcslen(szTmp) + 1 + wcslen(szNew) + 1];
            if (szRunning)
            {
                if (szTmp)
                {
                    wcscpy(szRunning, szTmp);
                    wcscat(szRunning, szNew);
                }
                else
                {
                    wcscpy(szRunning, szNew);
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }

            delete szTmp;
            delete szNew;

            if (hr != NOERROR)
            {
                goto BegTransExit;
            }
        }
        else
        {
            szRunning = szNew;
        }

        pNode = pNode->GetNextNode();
    }

    *pszAdditionalHeaders = szRunning;

BegTransExit:

    UrlMkDebugOut((DEB_BINDING, "%p OUT CHttpNegHolder::BeginningTransaction (pszAdditionalHeaders:%ws )\n", this, *pszAdditionalHeaders));
    return hr;
}

HRESULT CHttpNegHolder::OnResponse(DWORD dwResponseCode,LPCWSTR szResponseHeaders,
                        LPCWSTR szRequestHeaders,LPWSTR *pszAdditionalRequestHeaders)
{
    UrlMkDebugOut((DEB_BINDING, "%p _IN CHttpNegHolder::OnError\n", this));
    VDATETHIS(this);
    HRESULT         hr = NOERROR;
    CHttpNegNode    *pNode;
    LPWSTR          szTmp = NULL, szNew = NULL, szRunning = NULL;

    pNode = _pCHttpNegNode;

    while (pNode)
    {
        hr = pNode->GetHttpNegotiate()->OnResponse(dwResponseCode, szResponseHeaders, szRequestHeaders, &szNew);
        if (hr == NOERROR && szNew != NULL && szRunning != NULL)
        {
            szTmp = szRunning;
            szRunning = new WCHAR [wcslen(szTmp) + 1 + wcslen(szNew) + 1];
            if (szRunning)
            {
                if (szTmp)
                {
                    wcscpy(szRunning, szTmp);
                    wcscat(szRunning, szNew);
                }
                else
                {
                    wcscpy(szRunning, szNew);
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }

            delete szTmp;
            delete szNew;

            if (hr != NOERROR)
            {
                goto OnErrorExit;
            }
        }
        else
        {
            szRunning = szNew;
        }

        pNode = pNode->GetNextNode();
    }

    *pszAdditionalRequestHeaders = szRunning;

    if (hr == E_NOTIMPL)
    {
        hr = NOERROR;
    }

OnErrorExit:

    UrlMkDebugOut((DEB_BINDING, "%p OUT CHttpNegHolder::OnError\n", this));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CHttpNegHolder::AddNode
//
//  Synopsis:
//
//  Arguments:  [pIHttpNeg] --
//
//  Returns:
//
//  History:
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CHttpNegHolder::AddNode(IHttpNegotiate *pIHttpNeg)
{
    UrlMkDebugOut((DEB_BINDING, "%p _IN CHttpNegHolder::AddNode \n", this));
    HRESULT hr = NOERROR;

    CHttpNegNode *pFirstNode = _pCHttpNegNode;
    CHttpNegNode *pNode;

    // Allocate memory for new pNode member.

    pNode = new CHttpNegNode(pIHttpNeg);

    if (!pNode)
    {
        hr = E_OUTOFMEMORY;
    }
    else
    {
        UrlMkDebugOut((DEB_BINDING, "%p IN  CHttpNegHolder::AddNode (New Node:%p, IHttpNeg:%p) \n",
                                        this, pNode,pNode->GetHttpNegotiate() ));

        // if a node is already
        if (pFirstNode)
        {
            pNode->SetNextNode(pFirstNode);
        }

        // the new node is the first node
        _pCHttpNegNode = pNode;
        _cElements++;
    }

    UrlMkDebugOut((DEB_BINDING, "%p OUT CHttpNegHolder::AddNode (NewNode:%p, hr:%lx) \n", this, pNode, hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CHttpNegHolder::RemoveAllNodes
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  History:
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CHttpNegHolder::RemoveAllNodes(void)
{
    UrlMkDebugOut((DEB_BINDING, "%p _IN CHttpNegHolder::RemoveAllNodes\n", this));
    HRESULT hr = S_OK;

    CHttpNegNode *pNode = _pCHttpNegNode;
    CHttpNegNode *pNextNode = NULL;

    while (pNode)
    {
        pNextNode = pNode->GetNextNode();

        // release the object
        pNode->GetHttpNegotiate()->Release();
        UrlMkDebugOut((DEB_BINDING, "%p OUT CHttpNegHolder::RemoveAllNodes (Delete Node:%p, IHttpNeg:%p) \n",
                        this, pNode, pNode->GetHttpNegotiate()));
        delete pNode;
        _cElements--;

        pNode = pNextNode;
    }

    _pCHttpNegNode = NULL;
    UrlMkAssert((_cElements == 0));

    UrlMkDebugOut((DEB_BINDING, "%p OUT CHttpNegHolder::RemoveAllNodes (hr:%lx) \n", this, hr));
    return hr;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\mon\tls.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       tls.cxx
//
//  Contents:   Thread Local Storage initialization and cleanup.
//
//  Classes:
//
//  Functions:
//
//  History:    12-02-95   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------
#include <mon.h>
#ifndef unix
#include "..\trans\transact.hxx"
#include "..\download\cdl.h"
#else
#include "../trans/transact.hxx"
#include "../download/cdl.h"
#endif /* unix */
#include <tls.h>

PerfDbgExtern(tagUrlDll)
DbgTag(tagUrlDllErr,  "Urlmon", "Log CBinding Errors", DEB_BINDING|DEB_ERROR);

// Thread Local Storage index.
DWORD gTlsIndex;
HINSTANCE g_hInst = 0;
HANDLE g_hHeap = 0;     // used for tls data

// Heap Handle
extern  HANDLE    g_hHeap;
#define HEAP_SERIALIZE 0
BOOL UnregisterUrlMkWndClass();
HRESULT DeleteOInetSession(DWORD dwReserved);

extern  URLMON_TS*  g_pHeadURLMONTSList;


HRESULT AddTSToList(URLMON_TS* pts)
{
    CLock lck(g_mxsMedia);
    pts->_pNext = g_pHeadURLMONTSList;
    g_pHeadURLMONTSList = pts;

    return NOERROR;
}

HRESULT RemoveTSFromList(DWORD tid)
{
    // this can only be called from ThreadDetach time
    CLock lck(g_mxsMedia);
    URLMON_TS*  pts = NULL;
    URLMON_TS*  ptsPrev = NULL;
    pts = g_pHeadURLMONTSList;

    while( pts )
    {
        if( pts->_dwTID == tid )
        {
            if( ptsPrev == NULL )
            {
                // this is the head of the list
                g_pHeadURLMONTSList = pts->_pNext;
            }
            else
            {
                ptsPrev->_pNext = pts->_pNext;
            }

            // destroy the window
            // can only be called from current thread

            DestroyWindow(pts->_hwndNotify);

            // delete pts
            delete pts;

            break;
        }

        // advance
        ptsPrev = pts;
        pts = pts->_pNext;
    }

    return NOERROR;
}

URLMON_TS* GetTS(DWORD tid)
{
    CLock lck(g_mxsMedia);
    URLMON_TS*  pts = NULL;
    pts = g_pHeadURLMONTSList;

    while( pts )
    {
        if( pts->_dwTID == tid )
        {
            break;
        }

        // advance
        pts = pts->_pNext;
    }

    return pts;
}

HRESULT CleanupTSOnProcessDetach()
{
    CLock lck(g_mxsMedia);

    URLMON_TS*  pts = NULL;
    URLMON_TS*  ptsToFree = NULL;
    pts = g_pHeadURLMONTSList;

    while( pts )
    {
        if( pts->_dwTID == GetCurrentThreadId() )
        {
            // destroy the window (the owner thread can do so)
            DestroyWindow(pts->_hwndNotify);
            DbgLog2(
                tagUrlDllErr,
                NULL,
                ">>> tid: %lx -> DestroyWindow :%p",
                pts->_dwTID,
                pts->_hwndNotify
            );
        }
        else
        {
            // we are on a thread different from the window owner
            // so we can only Post message

            // set wndproc to user32's
            SetWindowLongPtr(
                pts->_hwndNotify,
                GWLP_WNDPROC,
                (LONG_PTR)DefWindowProc);

            // post message
            PostMessage(pts->_hwndNotify, WM_CLOSE, 0, 0);
            DbgLog2(
                tagUrlDllErr,
                NULL,
                ">>> tid: %lx -> PostMessage WM_CLOSE :%p",
                pts->_dwTID,
                pts->_hwndNotify
            );
        }

        // save this pts since we are to free it
        ptsToFree = pts;

        // walk down the list
        pts = pts->_pNext;

        // free the pts
        if( ptsToFree )
        {
            delete ptsToFree;
            ptsToFree = NULL;
        }
    }

    // mark list empty
    g_pHeadURLMONTSList = NULL;

    return NOERROR;
}


//+-------------------------------------------------------------------------
//
//  Function:   TLSAllocData
//
//  Synopsis:   Allocates the thread local storage block
//
//  Returns:    S_OK - allocated the data
//              E_OUTOFMEMORY - could not allocate the data
//
//--------------------------------------------------------------------------
HRESULT CUrlMkTls::TLSAllocData(void)
{
    Win4Assert(TlsGetValue(gTlsIndex) == 0);
    Win4Assert(g_hHeap != NULL);

    _pData = (SUrlMkTlsData *) HeapAlloc(g_hHeap, HEAP_SERIALIZE,
                                       sizeof(SUrlMkTlsData));

    if (_pData)
    {
        // This avoids having to set most fields to NULL, 0, etc and
        // is needed cause on debug builds memory is not guaranteed to
        // be zeroed.

        memset(_pData, 0, sizeof(SUrlMkTlsData));

        // fill in the non-zero values

        _pData->dwFlags = URLMKTLS_LOCALTID;

#ifdef ENABLE_DEBUG
        _pData->ThreadId = GetCurrentThreadId();
#endif // ENABLE_DEBUG

        // store the data ptr in TLS
        if (TlsSetValue(gTlsIndex, _pData))
        {
            return S_OK;
        }

        // error, cleanup and fallthru to error exit
        HeapFree(g_hHeap, HEAP_SERIALIZE, _pData);
        _pData = NULL;
    }

    UrlMkDebugOut((DEB_TRACE, "TLSAllocData failed.\n"));
    return E_OUTOFMEMORY;
}

//+---------------------------------------------------------------------------
//
//  Function:   DoThreadCleanup
//
//  Synopsis:   Called to perform cleanup on all this threads data
//              structures, and to call CoUninitialize() if needed.
//
//              Could be called by DLL_THREAD_DETACH or DLL_PROCESS_DETACH
//
//
//----------------------------------------------------------------------------
extern CMutexSem g_mxsTransMgr;
void DoThreadCleanup(BOOL bInThreadDetach)
{
    SUrlMkTlsData *pTls = (SUrlMkTlsData *) TlsGetValue(gTlsIndex);

    if (pTls != NULL)
    {

        // Because of the DLL unload rules in NT we need to be careful
        // what we do in clean up. We notify the routines with special
        // behavior here.

        pTls->dwFlags |= URLMKTLS_INTHREADDETACH;

        if (pTls->pCTransMgr != NULL)
        {
            // If the Release() returns non-zero, 
            // AND we're not really in ThreadDetach, then we have other references on 
            // the Transaction Manager.  Put back our reference and leave.
            //
            if (bInThreadDetach == FALSE)
            {
                CLock lck(g_mxsTransMgr);
                
                if (pTls->pCTransMgr->Release())
                {
                    pTls->pCTransMgr->AddRef();
                    pTls->dwFlags &= ~URLMKTLS_INTHREADDETACH;
                    goto Exit;
                }
            }
            else
            {
               pTls->pCTransMgr->Release();
            }
        }

        if (pTls->pCodeDownloadList != NULL)
        {
            delete pTls->pCodeDownloadList;
        }

        if (pTls->pRejectedFeaturesList != NULL)
        {
            LISTPOSITION curpos;
            LPCWSTR pwszRejectedFeature = NULL;
            int iNumRejected;
            int i;

            iNumRejected = pTls->pRejectedFeaturesList->GetCount();
            curpos = pTls->pRejectedFeaturesList->GetHeadPosition();

            // walk thru all the rejected features in the thread and delete
            for (i=0; i < iNumRejected; i++) {

                pwszRejectedFeature = pTls->pRejectedFeaturesList->GetNext(curpos);
                delete (LPWSTR)pwszRejectedFeature;

            }


            delete pTls->pRejectedFeaturesList;

        }

        if (pTls->pSetupCookie != NULL)
        {
            delete pTls->pSetupCookie;
        }

        if (pTls->pTrustCookie != NULL)
        {
            delete pTls->pTrustCookie;
        }

        if (pTls->pCDLPacketMgr != NULL)
        {
            delete pTls->pCDLPacketMgr;
        }

#ifdef PER_THREAD
        if (pTls->pCMediaHolder != NULL)
        {
            delete pTls->pCMediaHolder;
        }
#endif //PER_THREAD

        // reset the index so we dont find this data again.
        TlsSetValue(gTlsIndex, NULL);

        // cleanup hwnd (not on TLS, but on urlmon's global table)
        DWORD tid = GetCurrentThreadId();
        if( GetTS(tid))
        {
            RemoveTSFromList(tid);
        }

        if (pTls->hwndUrlMkNotify != NULL)
        {
            DbgLog1(tagUrlDllErr, NULL, "ASSERT!!! tld: %lx ->hwnd !NULL", tid);

        }

        /*******************************************************************
        if (pTls->hwndUrlMkNotify != NULL)
        {
            HWND h = pTls->hwndUrlMkNotify;
            DestroyWindow(pTls->hwndUrlMkNotify);
        }
        ********************************************************************/

        HeapFree(g_hHeap, HEAP_SERIALIZE, pTls);
    }
    // else
    // there is no TLS for this thread, so there can't be anything
    // to cleanup.

Exit:;
}

//+-------------------------------------------------------------------------
//
//  Function:   TlsDllMain
//
//  Synopsis:   Dll entry point
//
//  Arguments:  [hIntance]      -- a handle to the dll instance
//              [dwReason]      -- the reason LibMain was called
//              [lpvReserved]   - NULL - called due to FreeLibrary
//                              - non-NULL - called due to process exit
//
//  Returns:    TRUE on success, FALSE otherwise
//
//  Notes:      other one time initialization occurs in ctors for
//              global objects
//
//  WARNING:    if we are called because of FreeLibrary, then we should do as
//              much cleanup as we can. If we are called because of process
//              termination, we should not do any cleanup, as other threads in
//              this process will have already been killed, potentially while
//              holding locks around resources.
//
//
//--------------------------------------------------------------------------
STDAPI_(BOOL) TlsDllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpvReserved )
{
    BOOL fResult = FALSE;

    #if DBG==1 || defined(PERFTAGS)
    if (dwReason == DLL_THREAD_ATTACH || dwReason == DLL_THREAD_DETACH)
        PerfDbgLog1(tagUrlDll, NULL, "+TlsDllMain %s", dwReason == DLL_THREAD_ATTACH ?
            "DLL_THREAD_ATTACH" : "DLL_THREAD_DETACH");
    #endif

    switch (dwReason)
    {
    case DLL_THREAD_ATTACH:

        // new thread is starting
        {
            HRESULT hr;
            CUrlMkTls tls(hr);
            if (FAILED(hr))
            {
                goto ret;
            }
        }
        break;

    case DLL_THREAD_DETACH:
        // Thread is exiting, clean up resources associated with threads.
        DoThreadCleanup(TRUE);
        break;

    case DLL_PROCESS_ATTACH:

        // Initial setup. Get a thread local storage index for use by OLE
        g_hInst = hInstance;
        if ((g_hHeap = GetProcessHeap()) == 0)
        {
            // can continue E_OUTOFMEMORY;
            UrlMkAssert("Call GetProcessHeap failed.");
            goto ret;
        }
        gTlsIndex = TlsAlloc();
        if (gTlsIndex == 0xffffffff)
        {
            UrlMkAssert("Could not get TLS Index.");
            goto ret;
        }
        {
            HRESULT hr;
            CUrlMkTls tls(hr);
            if (FAILED(hr))
            {
                goto ret;
            }
        }
        break;

    case DLL_PROCESS_DETACH:

        UrlMkDebugOut((DEB_DLL,"DLL_PROCESS_DETACH:\n"));
        //if (NULL == lpvReserved)
        {
            // exiting because of FreeLibrary, so try to cleanup

            // DLL_PROCESS_DETACH is called when we unload. The thread that is
            // currently calling has not done thread specific cleanup yet.
            //

            DoThreadCleanup(TRUE);

            UnregisterUrlMkWndClass();

            if (g_pCMHolder != NULL)
            {
                UrlMkDebugOut((DEB_DLL | DEB_ITRACE,">>> DoThreadCleanup delete process pCMediaHolder:%p \n", g_pCMHolder));
                delete g_pCMHolder;
                g_pCMHolder = 0;
            }
            DeleteOInetSession(0);

            if (g_hSession)
            {
                // BUGBUG: do not close the session handle - check with RFirth
                InternetCloseHandle(g_hSession);
                g_hSession = NULL;
            }

            TlsFree(gTlsIndex);

        }
        UrlMkDebugOut((DEB_DLL,"DLL_PROCESS_DETACH: done\n"));

        break;
    }

    fResult = TRUE;

ret:
    #if DBG==1 || defined(PERFTAGS)
    if (dwReason == DLL_THREAD_ATTACH || dwReason == DLL_THREAD_DETACH)
        PerfDbgLog(tagUrlDll, NULL, "-TlsDllMain");
    #endif

    return fResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\mon\mpxbsc.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       MPXBSC.CXX
//
//  Contents:   Code to handle multiplexing multiple concurrent
//              IBindStatusCallback interfaces.
//
//  Classes:    CBSCHolder
//
//  Functions:
//
//  History:    01-04-96    JoeS (Joe Souza)    Created
//              01-15-96    JohannP (Johann Posch)  Modified to new IBSC
//
//----------------------------------------------------------------------------
#include <mon.h>
#include "mpxbsc.hxx"

PerfDbgTag(tagCBSCHolder, "Urlmon", "Log CBSCHolder", DEB_BINDING);

HRESULT GetObjectParam(IBindCtx *pbc, LPOLESTR pszKey, REFIID riid, IUnknown **ppUnk);

//+---------------------------------------------------------------------------
//
//  Function:   UrlMonInvokeExceptionFilterMSN
//
//  Synopsis:
//
//  Arguments:  [lCode] --
//              [lpep] --
//
//  Returns:
//
//  History:    8-25-97   DanpoZ(Danpo Zhang)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
LONG UrlMonInvokeExceptionFilterMSN( DWORD lCode, LPEXCEPTION_POINTERS lpep )
{
    DEBUG_ENTER((DBG_CALLBACK,
                Int,
                "UrlMonInvokeExceptionFilterMSN",
                "%#x, %#x",
                lCode, lpep
                ));
                
#if DBG == 1
    DbgLog2(tagCBSCHolder, NULL, "Exception 0x%#x at address 0x%#x",
               lCode, lpep->ExceptionRecord->ExceptionAddress);
    DebugBreak();
#endif
    LONG exr = EXCEPTION_CONTINUE_EXECUTION;

    if( lCode == STATUS_ACCESS_VIOLATION )
    {
        char achProgname[256];
        achProgname[0] = 0;
        GetModuleFileNameA(NULL,achProgname,sizeof(achProgname));

        if( StrStrI(achProgname, "msnviewr.exe") )
        {
            exr = EXCEPTION_EXECUTE_HANDLER;
        }
    }

    DEBUG_LEAVE(exr);
    return exr;
}

//+---------------------------------------------------------------------------
//
//  Function:   GetBSCHolder
//
//  Synopsis:   Returns a holder for IBindStatusCallback
//
//  Arguments:  [pBC] --
//              [ppCBSHolder] --
//
//  Returns:
//
//  History:
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT GetBSCHolder(LPBC pBC, CBSCHolder **ppCBSHolder)
{
    DEBUG_ENTER((DBG_CALLBACK,
                Hresult,
                "GetBSCHolder",
                "%#x, %#x",
                pBC, ppCBSHolder
                ));
                
    PerfDbgLog(tagCBSCHolder, NULL, "+GetBSCHolder");
    UrlMkAssert((ppCBSHolder != NULL));

    HRESULT hr;
    CBSCHolder *pCBSCBHolder = NULL;

    hr = GetObjectParam(pBC, REG_BSCB_HOLDER, IID_IBindStatusCallbackHolder, (IUnknown **)&pCBSCBHolder);
    if (pCBSCBHolder == NULL)
    {
        pCBSCBHolder = new CBSCHolder;
        if (!pCBSCBHolder)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            hr = pBC->RegisterObjectParam(REG_BSCB_HOLDER, (IBindStatusCallback *) pCBSCBHolder);
            *ppCBSHolder = pCBSCBHolder;
        }
    }
    else
    {
        *ppCBSHolder = pCBSCBHolder;
    }

    PerfDbgLog1(tagCBSCHolder, NULL, "-GetBSCHolder (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

CBSCHolder::CBSCHolder(void) : _CRefs(), _cElements(0)
{
    DEBUG_ENTER((DBG_CALLBACK,
                None,
                "CBSCHolder::CBSCHolder",
                "this=%#x",
                this
                ));
                
    _pCBSCNode = NULL;
    _fBindStarted = FALSE;
    _fBindStopped = FALSE;
    _fHttpNegotiate = FALSE;
    _fAuthenticate  = FALSE;

    _fHttpNegotiate2 = FALSE;

    DEBUG_LEAVE(0);
}

CBSCHolder::~CBSCHolder(void)
{
    DEBUG_ENTER((DBG_CALLBACK,
                None,
                "CBSCHolder::~CBSCHolder",
                "this=%#x",
                this
                ));
                
    CBSCNode *pNode, *pNextNode;

    pNode = _pCBSCNode;

    while (pNode)
    {
        pNextNode = pNode->GetNextNode();
        delete pNode;
        pNode = pNextNode;
    }

    DEBUG_LEAVE(0);
}

STDMETHODIMP CBSCHolder::QueryInterface(REFIID riid, void **ppvObj)
{
    DEBUG_ENTER((DBG_CALLBACK,
                Hresult,
                "CBSCHolder::IUnknown::QueryInterface",
                "this=%#x, %#x, %#x",
                this, &riid, ppvObj
                ));
                
    VDATEPTROUT(ppvObj, void *);
    VDATETHIS(this);
    HRESULT hr = NOERROR;
    PerfDbgLog(tagCBSCHolder, this, "+CBSCHolder::QueryInterface");

    if (   (riid == IID_IUnknown)
        || (riid == IID_IBindStatusCallback)
        || (riid == IID_IBindStatusCallbackHolder) )
    {
        // the holder is not marshalled!!
        *ppvObj = (void*)(IBindStatusCallback *) this;
    }
    else if (riid == IID_IServiceProvider)
    {
        *ppvObj = (void*)(IServiceProvider *) this;
    }
    else if (riid == IID_IHttpNegotiate)
    {
        *ppvObj = (void*)(IHttpNegotiate *) this;
    }
    else if (riid == IID_IHttpNegotiate2)
    {
        *ppvObj = (void*)(IHttpNegotiate2 *) this;
    }
    else if (riid == IID_IAuthenticate)
    {
        *ppvObj = (void*)(IAuthenticate *) this;
    }
    else
    {
        *ppvObj = NULL;
        hr = E_NOINTERFACE;
    }

    if (hr == NOERROR)
    {
        AddRef();
    }

    PerfDbgLog1(tagCBSCHolder, this, "-CBSCHolder::QueryInterface (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

STDMETHODIMP_(ULONG) CBSCHolder::AddRef(void)
{
    DEBUG_ENTER((DBG_CALLBACK,
                Dword,
                "CBSCHolder::IUnknown::AddRef",
                "this=%#x",
                this
                ));
                
    LONG lRet = ++_CRefs;
    PerfDbgLog1(tagCBSCHolder, this, "CBSCHolder::AddRef (cRefs:%ld)", lRet);

    DEBUG_LEAVE(lRet);
    return lRet;
}

STDMETHODIMP_(ULONG) CBSCHolder::Release(void)
{
    DEBUG_ENTER((DBG_CALLBACK,
                Dword,
                "CBSCHolder::IUnknown::Release",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCBSCHolder, this, "+CBSCHolder::Release");
    UrlMkAssert((_CRefs > 0));

    LONG lRet = --_CRefs;

    if (_CRefs == 0)
    {
        delete this;
    }

    PerfDbgLog1(tagCBSCHolder, this, "-CBSCHolder::Release (cRefs:%ld)",lRet);

    DEBUG_LEAVE(lRet);
    return lRet;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBSCHolder::GetBindInfo
//
//  Synopsis:
//
//  Arguments:  [grfBINDINFOF] --
//              [pbindinfo] --
//
//  Returns:
//
//  History:
//
//  Notes:      Only the first BSC which also receives data gets called
//
//----------------------------------------------------------------------------
HRESULT CBSCHolder::GetBindInfo(DWORD *grfBINDINFOF,BINDINFO * pbindinfo)
{
    DEBUG_ENTER((DBG_CALLBACK,
                Hresult,
                "CBSCHolder::IBindStatusCallback::GetBindInfo",
                "this=%#x, %#x, %#x",
                this, grfBINDINFOF, pbindinfo
                ));
                
    PerfDbgLog(tagCBSCHolder, this, "+CBSCHolder::GetBindInfo");
    HRESULT     hr = E_FAIL;
    CBSCNode   *pNode;

    pNode = _pCBSCNode;

    if (pNode && (pNode->GetFlags() & BSCO_GETBINDINFO))
    {
        UrlMkAssert(( pbindinfo && (pbindinfo->cbSize == sizeof(BINDINFO)) ));

        DEBUG_ENTER((DBG_CALLBACK,
                    Hresult,
                    "EXTERNAL_CLIENT::IBindStatusCallback::GetBindInfo",
                    "this=%#x, %#x, %#x",
                    pNode->GetBSCB(), grfBINDINFOF, pbindinfo
                    ));
                    
        // We only call the first link for GetBindInfo.
        hr = pNode->GetBSCB()->GetBindInfo(grfBINDINFOF, pbindinfo);
        
        DEBUG_LEAVE(hr);
    }
    else
    {
        UrlMkAssert((FALSE && "Not IBSC node called on GetBindInfo"));
    }

    PerfDbgLog2(tagCBSCHolder, this, "-CBSCHolder::CallGetBindInfo (grfBINDINFOF:%lx, hr:%lx)", grfBINDINFOF,  hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBSCHolder::OnStartBinding
//
//  Synopsis:
//
//  Arguments:  [grfBINDINFOF] --
//              [pib] --
//
//  Returns:
//
//  History:
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CBSCHolder::OnStartBinding(DWORD grfBINDINFOF, IBinding * pib)
{
    DEBUG_ENTER((DBG_CALLBACK,
                Hresult,
                "CBSCHolder::IBindStatusCallback::OnStartBinding",
                "this=%#x, %#x, %#x",
                this, grfBINDINFOF, pib
                ));
                
    PerfDbgLog(tagCBSCHolder, this, "+CBSCHolder::OnStartBinding");
    VDATETHIS(this);

    HRESULT     hr = E_FAIL;
    CBSCNode   *pNode;
    BOOL        fFirstNode = TRUE;

    _fBindStarted = TRUE;

    pNode = _pCBSCNode;

    while (pNode)
    {
        grfBINDINFOF = pNode->GetFlags();

        if (fFirstNode)
        {
            grfBINDINFOF |= (BSCO_ONDATAAVAILABLE | BSCO_ONOBJECTAVAILABLE);
        }
        else
        {
            grfBINDINFOF &= ~(BSCO_ONDATAAVAILABLE | BSCO_ONOBJECTAVAILABLE);
        }

        DbgLog1(tagCBSCHolder, this, "CBSCHolder::OnStartBinding on (IBSC:%lx)", pNode->GetBSCB());

        DEBUG_ENTER((DBG_CALLBACK,
                    Hresult,
                    "EXTERNAL_CLIENT::IBindStatusCallback::OnStartBinding",
                    "this=%#x, %#x, %#x",
                    pNode->GetBSCB(), grfBINDINFOF, pib
                    ));
                    
        hr = pNode->GetBSCB()->OnStartBinding(grfBINDINFOF, pib);

        DEBUG_LEAVE(hr);
        
        pNode = pNode->GetNextNode();
        fFirstNode = FALSE;
    }

    // BUGBUG: hr is set to return code only from last node we called.
    // Is this what we want?
    // What if one of the earlier nodes failed?

    PerfDbgLog1(tagCBSCHolder, this, "-CBSCHolder::OnStartBinding (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBSCHolder::OnProgress
//
//  Synopsis:
//
//  Arguments:  [ULONG] --
//              [ulProgressMax] --
//              [ulStatusCode] --
//              [szStatusText] --
//
//  Returns:
//
//  History:
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CBSCHolder::OnProgress(ULONG ulProgress,ULONG ulProgressMax,
                               ULONG ulStatusCode, LPCWSTR szStatusText)
{
    DEBUG_ENTER((DBG_CALLBACK,
                Hresult,
                "CBSCHolder::IBindStatusCallback::OnProgress",
                "this=%#x, %#x, %#x, %#x, %.80wq",
                this, ulProgress, ulProgressMax, ulStatusCode, szStatusText
                ));
                
    PerfDbgLog4(tagCBSCHolder, this, "+CBSCHolder::OnProgress (StatusCode:%ld, StatusText:%ws, Progress:%ld, ProgressMax:%ld)",
        ulStatusCode, szStatusText?szStatusText:L"", ulProgress, ulProgressMax);
    VDATETHIS(this);
    HRESULT     hr = NOERROR;
    CBSCNode   *pNode;

    pNode = _pCBSCNode;

    while (pNode)
    {
        if (pNode->GetFlags() & BSCO_ONPROGRESS)
        {
            DEBUG_ENTER((DBG_CALLBACK,
                        Hresult,
                        "EXTERNAL_CLIENT::IBindStatusCallback::OnProgress",
                        "this=%#x, %#x, %#x, %#x, %.80wq",
                        pNode->GetBSCB(), ulProgress, ulProgressMax, ulStatusCode, szStatusText
                        ));
                        
            hr = pNode->GetBSCB()->OnProgress(ulProgress, ulProgressMax, ulStatusCode,szStatusText);

            DEBUG_LEAVE(hr);
        }

        pNode = pNode->GetNextNode();
    }

    // BUGBUG: hr is set to return code only from last node we called.
    // Is this what we want?
    // What if one of the earlier nodes failed?

    PerfDbgLog1(tagCBSCHolder, this, "-CBSCHolder::OnProgress (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBSCHolder::OnDataAvailable
//
//  Synopsis:
//
//  Arguments:  [DWORD] --
//              [FORMATETC] --
//              [pformatetc] --
//              [pstgmed] --
//
//  Returns:
//
//  History:
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CBSCHolder::OnDataAvailable(DWORD grfBSC,DWORD dwSize,FORMATETC *pformatetc, STGMEDIUM *pstgmed)
{
    DEBUG_ENTER((DBG_CALLBACK,
                Hresult,
                "CBSCHolder::IBindStatusCallback::OnDataAvailable",
                "this=%#x, %#x, %#x, %#x, %#x",
                this, grfBSC, dwSize, pformatetc, pstgmed
                ));

    PerfDbgLog(tagCBSCHolder, this, "+CBSCHolder::OnDataAvailable");
    VDATETHIS(this);
    HRESULT     hr = E_FAIL;
    CBSCNode   *pNode;

    pNode = _pCBSCNode;

    if (pNode && (pNode->GetFlags() & BSCO_ONDATAAVAILABLE))
    {
        DEBUG_ENTER((DBG_CALLBACK,
                    Hresult,
                    "EXTERNAL_CLIENT::IBindStatusCallback::OnDataAvailable",
                    "this=%#x, %#x, %#x, %#x, %#x",
                    pNode->GetBSCB(), grfBSC, dwSize, pformatetc, pstgmed
                    ));
                    
        hr = pNode->GetBSCB()->OnDataAvailable(grfBSC, dwSize, pformatetc, pstgmed);

        DEBUG_LEAVE(hr);
        
        //hr = NOERROR; //Trident BTS->BTO
    }

    PerfDbgLog1(tagCBSCHolder, this, "-CBSCHolder::OnDataAvailable (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBSCHolder::OnObjectAvailable
//
//  Synopsis:
//
//  Arguments:  [riid] --
//              [punk] --
//
//  Returns:
//
//  History:
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CBSCHolder::OnObjectAvailable(REFIID riid, IUnknown *punk)
{
    DEBUG_ENTER((DBG_CALLBACK,
                Hresult,
                "CBSCHolder::IBindStatusCallback::OnObjectAvailable",
                "this=%#x, %#x, %#x",
                this, &riid, punk
                ));

    PerfDbgLog(tagCBSCHolder, this, "+CBSCHolder::OnObjectAvailable");
    VDATETHIS(this);
    CBSCNode   *pNode;

    pNode = _pCBSCNode;

    if (pNode && (pNode->GetFlags() & BSCO_ONOBJECTAVAILABLE))
    {
        DEBUG_ENTER((DBG_CALLBACK,
                    Hresult,
                    "EXTERNAL_CLIENT::IBindStatusCallback::OnObjectAvailable",
                    "this=%#x, %#x, %#x",
                    pNode->GetBSCB(), &riid, punk
                    ));
                
        HRESULT hr = pNode->GetBSCB()->OnObjectAvailable(riid, punk);

        DEBUG_LEAVE(hr);
    }

    PerfDbgLog(tagCBSCHolder, this, "-CBSCHolder::OnObjectAvailable (hr:0)");

    DEBUG_LEAVE(NOERROR);
    return NOERROR;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBSCHolder::OnLowResource
//
//  Synopsis:
//
//  Arguments:  [reserved] --
//
//  Returns:
//
//  History:
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CBSCHolder::OnLowResource(DWORD reserved)
{
    DEBUG_ENTER((DBG_CALLBACK,
                Hresult,
                "CBSCHolder::IBindStatusCallback::OnLowResource",
                "this=%#x, %#x",
                this, reserved
                ));
                
    PerfDbgLog(tagCBSCHolder, this, "+CBSCHolder::OnLowResource");
    VDATETHIS(this);
    HRESULT     hr = E_FAIL;
    CBSCNode   *pNode;

    pNode = _pCBSCNode;

    while (pNode)
    {
        if (pNode->GetFlags() & BSCO_ONLOWRESOURCE)
        {
            DEBUG_ENTER((DBG_CALLBACK,
                        Hresult,
                        "EXTERNAL_CLIENT::IBindStatusCallback::OnLowResource",
                        "this=%#x, %#x",
                        pNode->GetBSCB(), reserved
                        ));
                
            hr = pNode->GetBSCB()->OnLowResource(reserved);

            DEBUG_LEAVE(hr);
        }

        pNode = pNode->GetNextNode();
    }

    // BUGBUG: hr is set to return code only from last node we called.
    // Is this what we want?
    // What if one of the earlier nodes failed?

    PerfDbgLog1(tagCBSCHolder, this, "-CBSCHolder::OnLowResource (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBSCHolder::OnStopBinding
//
//  Synopsis:
//
//  Arguments:  [LPCWSTR] --
//              [szError] --
//
//  Returns:
//
//  History:
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CBSCHolder::OnStopBinding(HRESULT hrRes,LPCWSTR szError)
{
    DEBUG_ENTER((DBG_CALLBACK,
                Hresult,
                "CBSCHolder::IBindStatusCallback::OnStopBinding",
                "this=%#x, %#x, %.80wq",
                this, hrRes, szError
                ));
                
    PerfDbgLog(tagCBSCHolder, this, "+CBSCHolder::OnStopBinding");
    HRESULT     hr = E_FAIL;
    CBSCNode   *pNode;
    CBSCNode   *pNodeNext;
    DWORD      dwFault;

    VDATETHIS(this);

    _fBindStopped = TRUE;   // Allow consumer to remove node on OnStopBinding.

    pNode = _pCBSCNode;

        while (pNode)
        {
            // save the next node since this node
            // we using now might get deleted
            // by RevokeBindStatusCallback
            pNodeNext = pNode->GetNextNode();

            pNode->SetLocalFlags(NODE_FLAG_REMOVEOK);

            PerfDbgLog2(tagCBSCHolder, this, "+CBSCHolder::OnStopBinding calling (Node:%lx, IBSC:%lx)",
            pNode,pNode->GetBSCB());

            // IE4 bug #32739, the CBSC might no longer be there (MSN) 
            _try
            {
                DEBUG_ENTER((DBG_CALLBACK,
                            Hresult,
                            "EXTERNAL_CLIENT::IBindStatusCallback::OnStopBinding",
                            "this=%#x, %#x, %.80wq",
                            pNode->GetBSCB(), hrRes, szError
                            ));
                            
                hr = pNode->GetBSCB()->OnStopBinding(hrRes, szError);

                DEBUG_LEAVE(hr);
            }
            //_except(UrlMonInvokeExceptionFilterMSN(GetExceptionCode(), GetExceptionInformation()))
            __except(EXCEPTION_EXECUTE_HANDLER)
            {
                DEBUG_LEAVE(hr);
                
                #if DBG == 1
                {
                    dwFault = GetExceptionCode();
                    DbgLog1(tagCBSCHolder, this, "fault 0x%08x at OnStopBinding", dwFault);
                }
                #endif
            }
#ifdef unix
            __endexcept
#endif /* unix */
            PerfDbgLog1(tagCBSCHolder, this, "-CBSCHolder::OnStopBinding done (Node:%lx)", pNode);

            pNode = pNodeNext;
        }

    // Reset bind active flags.

    _fBindStarted = FALSE;
    _fBindStopped = FALSE;

    // BUGBUG: hr is set to return code only from last node we called.
    // Is this what we want?
    // What if one of the earlier nodes failed?

    PerfDbgLog1(tagCBSCHolder, this, "-CBSCHolder::OnStopBinding (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBSCHolder::GetPriority
//
//  Synopsis:
//
//  Arguments:  [pnPriority] --
//
//  Returns:
//
//  History:
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CBSCHolder::GetPriority(LONG * pnPriority)
{
    DEBUG_ENTER((DBG_CALLBACK,
                Hresult,
                "CBSCHolder::IBindStatusCallback::GetPriority",
                "this=%#x, %#x",
                this, pnPriority
                ));

    PerfDbgLog(tagCBSCHolder, this, "+CBSCHolder::GetPriority");
    HRESULT     hr = E_FAIL;
    CBSCNode   *pNode;

    pNode = _pCBSCNode;

    if (pNode && (pNode->GetFlags() & BSCO_GETPRIORITY))
    {
        DEBUG_ENTER((DBG_CALLBACK,
                    Hresult,
                    "EXTERNAL_CLIENT::IBindStatusCallback::GetPriority",
                    "this=%#x, %#x",
                    pNode->GetBSCB(), pnPriority
                    ));
                    
        hr = pNode->GetBSCB()->GetPriority(pnPriority);

        DEBUG_LEAVE(hr);
    }

    PerfDbgLog1(tagCBSCHolder, this, "-CBSCHolder::GetPriority (hr:%lx)", hr);

    DEBUG_LEAVE(S_FALSE);
    return S_FALSE;
}


//+---------------------------------------------------------------------------
//
//  Method:     CBSCHolder::QueryService
//
//  Synopsis:
//
//  Arguments:  [rsid] --
//              [iid] --
//              [ppvObj] --
//
//  Returns:
//
//  History:    4-05-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CBSCHolder::QueryService(REFGUID rsid, REFIID riid, void ** ppvObj)
{
    DEBUG_ENTER((DBG_CALLBACK,
                Hresult,
                "CBSCHolder::IServiceProvider::QueryService",
                "this=%#x, %#x, %#x, %#x",
                this, &rsid, &riid, ppvObj
                ));
                
    PerfDbgLog(tagCBSCHolder, this, "+CBSCHolder::QueryService");
    HRESULT     hr = NOERROR;
    VDATETHIS(this);
    UrlMkAssert((ppvObj));

    *ppvObj = 0;

    hr = ObtainService(rsid, riid, ppvObj);
    UrlMkAssert(( (hr == E_NOINTERFACE) || ((hr == NOERROR) && *ppvObj) ));

    PerfDbgLog1(tagCBSCHolder, this, "-CBSCHolder::QueryService (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBSCHolder::BeginningTransaction
//
//  Synopsis:
//
//  Arguments:  [szURL] --
//              [szHeaders] --
//              [dwReserved] --
//              [pszAdditionalHeaders] --
//
//  Returns:
//
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CBSCHolder::BeginningTransaction(LPCWSTR szURL, LPCWSTR szHeaders,
            DWORD dwReserved, LPWSTR *pszAdditionalHeaders)
{
    DEBUG_ENTER((DBG_CALLBACK,
                Hresult,
                "CBSCHolder::IHttpNegotiate::BeginningTransaction",
                "this=%#x, %.80wq, %.80wq, %#x, %#x",
                this, szURL, szHeaders, dwReserved, pszAdditionalHeaders
                ));
                
    PerfDbgLog2(tagCBSCHolder, this, "+CBSCHolder::BeginningTransaction (szURL:%ws, szHeaders:%ws)", szURL, XDBG(szHeaders,""));
    VDATETHIS(this);
    HRESULT    hr = NOERROR;
    CBSCNode   *pNode;
    LPWSTR     szTmp = NULL, szNew = NULL, szRunning = NULL;

    pNode = _pCBSCNode;
    UrlMkAssert((szURL));

    while (pNode)
    {
        if (pNode->GetHttpNegotiate())
        {
            DEBUG_ENTER((DBG_CALLBACK,
                        Hresult,
                        "EXTERNAL_CLIENT::IHttpNegotiate::BeginningTransaction",
                        "this=%#x, %.80wq, %.80wq, %#x, %#x",
                        pNode->GetHttpNegotiate(), szURL, szHeaders, dwReserved, pszAdditionalHeaders
                        ));
                
            hr = pNode->GetHttpNegotiate()->BeginningTransaction(szURL, szHeaders, dwReserved, &szNew);

            DEBUG_LEAVE(hr);
            
            PerfDbgLog2(tagCBSCHolder, this, "CBSCHolder::BeginningTransaction (IHttpNegotiate:%lx, szNew:%ws)",
                pNode->GetHttpNegotiate(), XDBG(szNew,L""));

            // shdocvw might return uninitialized hr, so we
            // should just check for szNew not NULL and reset hr
            if( hr != NOERROR && szNew != NULL )
            {
                hr = NOERROR;
            }

            if (hr == NOERROR && szNew != NULL && szRunning != NULL)
            {
                szTmp = szRunning;
                szRunning = new WCHAR [wcslen(szTmp) + 1 + wcslen(szNew) + 1];
                if (szRunning)
                {
                    if (szTmp)
                    {
                        wcscpy(szRunning, szTmp);
                        wcscat(szRunning, szNew);
                    }
                    else
                    {
                        wcscpy(szRunning, szNew);
                    }
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }

                delete szTmp;
                delete szNew;

                if (hr != NOERROR)
                {
                    goto BegTransExit;
                }
            }
            else
            {
                szRunning = szNew;
            }
        }

        pNode = pNode->GetNextNode();
    }

    *pszAdditionalHeaders = szRunning;

BegTransExit:
    PerfDbgLog1(tagCBSCHolder, this, "-CBSCHolder::BeginningTransaction (pszAdditionalHeaders:%ws)", (hr || !*pszAdditionalHeaders) ? L"":*pszAdditionalHeaders);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBSCHolder::OnResponse
//
//  Synopsis:
//
//  Arguments:  [LPCWSTR] --
//              [szResponseHeaders] --
//              [LPWSTR] --
//              [pszAdditionalRequestHeaders] --
//
//  Returns:
//
//  History:    4-05-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CBSCHolder::OnResponse(DWORD dwResponseCode,LPCWSTR wzResponseHeaders,
                        LPCWSTR wzRequestHeaders,LPWSTR *pszAdditionalRequestHeaders)
{
    DEBUG_ENTER((DBG_CALLBACK,
                Hresult,
                "CBSCHolder::IHttpNegotiate::OnResponse",
                "this=%#x, %#x, %.80wq, %.80wq, %#x",
                this, dwResponseCode, wzResponseHeaders, wzRequestHeaders, pszAdditionalRequestHeaders
                ));
                
    PerfDbgLog(tagCBSCHolder, this, "+CBSCHolder::OnResponse");
    VDATETHIS(this);
    HRESULT    hr;
    CBSCNode   *pNode;
    LPWSTR     szTmp = NULL, szNew = NULL, szRunning = NULL;

    pNode = _pCBSCNode;

    hr = (IsStatusOk(dwResponseCode)) ? S_OK : S_FALSE;

    while (pNode)
    {
        if (pNode->GetHttpNegotiate())
        {
            PerfDbgLog1(tagCBSCHolder, this, "+CBSCHolder::OnResponse on Node: %lx", pNode);
            
            DEBUG_ENTER((DBG_CALLBACK,
                        Hresult,
                        "EXTERNAL_CLIENT::IHttpNegotiate::OnResponse",
                        "this=%#x, %#x, %.80wq, %.80wq, %#x",
                        pNode->GetHttpNegotiate(), dwResponseCode, wzResponseHeaders, wzRequestHeaders, pszAdditionalRequestHeaders
                        ));
                        
            hr = pNode->GetHttpNegotiate()->OnResponse(dwResponseCode, wzResponseHeaders, wzRequestHeaders, &szNew);
    
            DEBUG_LEAVE(hr);
            
            PerfDbgLog2(tagCBSCHolder, this, "-CBSCHolder::OnResponse on Node: %lx, hr:%lx", pNode, hr);
            if (hr == NOERROR && szNew != NULL && szRunning != NULL)
            {
                szTmp = szRunning;
                szRunning = new WCHAR [wcslen(szTmp) + 1 + wcslen(szNew) + 1];
                if (szRunning)
                {
                    if (szTmp)
                    {
                        wcscpy(szRunning, szTmp);
                        wcscat(szRunning, szNew);
                    }
                    else
                    {
                        wcscpy(szRunning, szNew);
                    }
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }

                delete szTmp;
                delete szNew;

                if (hr != NOERROR)
                {
                    goto OnErrorExit;
                }
            }
            else
            {
                szRunning = szNew;
            }
        }
        pNode = pNode->GetNextNode();
    }

    if (pszAdditionalRequestHeaders)
    {
        *pszAdditionalRequestHeaders = szRunning;
    }

    if (hr == E_NOTIMPL)
    {
        hr = NOERROR;
    }

OnErrorExit:

    PerfDbgLog(tagCBSCHolder, this, "-CBSCHolder::OnResponse");

    DEBUG_LEAVE(hr);
    return hr;
}

HRESULT CBSCHolder::GetRootSecurityId(BYTE* pbSecurityId, DWORD* cbSecurityId, 
            DWORD_PTR dwReserved)
{
    DEBUG_ENTER((DBG_CALLBACK,
                Hresult,
                "CBSCHolder::IHttpNegotiate2::GetRootSecurityId",
                "this=%#x, %#x, %#x, %#x",
                this, pbSecurityId, cbSecurityId, dwReserved
                ));
                
    PerfDbgLog(tagCBSCHolder, this, "+CBSCHolder::GetRootSecurityId");
    VDATETHIS(this);
    HRESULT hr = E_FAIL;
    CBSCNode *pNode;
    pNode = _pCBSCNode;

    while (pNode)
    {
        if (pNode->GetHttpNegotiate2())
        {
            DEBUG_ENTER((DBG_CALLBACK,
                        Hresult,
                        "EXTERNAL_CLIENT::IHttpNegotiate2::GetRootSecurityId",
                        "this=%#x, %#x, %#x, %#x",
                        pNode->GetHttpNegotiate2(), pbSecurityId, cbSecurityId, dwReserved
                        ));
                        
            hr = pNode->GetHttpNegotiate2()->GetRootSecurityId( pbSecurityId, cbSecurityId, dwReserved );

            DEBUG_LEAVE(hr);
            
            if (SUCCEEDED(hr))
            {
                break;
            }
        }

        pNode = pNode->GetNextNode();
    }

    PerfDbgLog(tagCBSCHolder, this, "-CBSCHolder::Authenticate");

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBSCHolder::Authenticate
//
//  Synopsis:
//
//  Arguments:  [phwnd] --
//              [pszUsername] --
//              [pszPassword] --
//
//  Returns:
//
//  History:
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CBSCHolder::Authenticate(HWND* phwnd, LPWSTR *pszUsername,
            LPWSTR *pszPassword)
{
    DEBUG_ENTER((DBG_CALLBACK,
                Hresult,
                "CBSCHolder::IAuthenticate::Authenticate",
                "this=%#x, %#x, %#x, %#x",
                this, phwnd, pszUsername, pszPassword
                ));
                
    PerfDbgLog(tagCBSCHolder, this, "+CBSCHolder::Authenticate");
    VDATETHIS(this);
    HRESULT hr = NOERROR;
    CBSCNode *pNode;
    pNode = _pCBSCNode;

    while (pNode)
    {
        if (pNode->GetAuthenticate())
        {
            DEBUG_ENTER((DBG_CALLBACK,
                        Hresult,
                        "EXTERNAL_CLIENT::IAuthenticate::Authenticate",
                        "this=%#x, %#x, %#x, %#x",
                        pNode->GetAuthenticate(), phwnd, pszUsername, pszPassword
                        ));
                        
            hr = pNode->GetAuthenticate()->Authenticate(phwnd, pszUsername, pszPassword);

            DEBUG_LEAVE(hr);
            
            if (hr == S_OK)
            {
                break;
            }
        }

        pNode = pNode->GetNextNode();
    }

    PerfDbgLog(tagCBSCHolder, this, "-CBSCHolder::Authenticate");

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBSCHolder::AddNode
//
//  Synopsis:
//
//  Arguments:  [pIBSC] --
//              [grfFlags] --
//
//  Returns:
//
//  History:
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CBSCHolder::AddNode(IBindStatusCallback *pIBSC, DWORD grfFlags)
{
    DEBUG_ENTER((DBG_CALLBACK,
                Hresult,
                "CBSCHolder::AddNode",
                "this=%#x, %#x, %#x",
                this, pIBSC, grfFlags
                ));
                
    PerfDbgLog(tagCBSCHolder, this, "+CBSCHolder::AddNode");
    HRESULT hr = NOERROR;
    CLock lck(_mxs);

    CBSCNode *pFirstNode = _pCBSCNode;
    CBSCNode *pNode;
    CBSCNode *pNodeTmp;
    LPVOID pvLocal = NULL;

    // No new nodes allowed after binding has started.
    if (_fBindStarted)
    {
        hr = E_FAIL;
        goto AddNodeExit;
    }

    // Allocate memory for new pNode member.
    pNode = new CBSCNode(pIBSC, grfFlags);

    if (!pNode)
    {
        hr = E_OUTOFMEMORY;
    }
    else
    {
        // addref the IBSC pointer
        pIBSC->AddRef();

        // QI for IServiceProvider - QI addref IBSC
        if (pIBSC->QueryInterface(IID_IServiceProvider, &pvLocal) == NOERROR)
        {
            pNode->SetServiceProvider((IServiceProvider *)pvLocal);
        }

        PerfDbgLog3(tagCBSCHolder, this, "CBSCHolder::AddNode (New Node:%lx, IBSC:%lx, IServiceProvider:%lx)",
            pNode, pNode->GetBSCB(), pvLocal);

        // If we have a node already
        if (pFirstNode)
        {
            if (pNode->GetFlags() & BSCO_ONDATAAVAILABLE)
            {
                // If the new node gets the data, link it first.

                pNode->SetNextNode(pFirstNode);
                _pCBSCNode = pNode;
            }
            else
            {
                // The new node does not get data, link it second in list.

                pNodeTmp = pFirstNode->GetNextNode();

                pFirstNode->SetNextNode(pNode);
                pNode->SetNextNode(pNodeTmp);
            }
        }
        else
        {
            _pCBSCNode = pNode;
        }

        _cElements++;
    }

AddNodeExit:

    PerfDbgLog2(tagCBSCHolder, this, "-CBSCHolder::AddNode (NewNode:%lx, hr:%lx)", pNode, hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBSCHolder::RemoveNode
//
//  Synopsis:
//
//  Arguments:  [pIBSC] --
//
//  Returns:
//
//  History:
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CBSCHolder::RemoveNode(IBindStatusCallback *pIBSC)
{
    DEBUG_ENTER((DBG_CALLBACK,
                Hresult,
                "CBSCHolder::RemoveNode",
                "this=%#x, %#x",
                this, pIBSC
                ));
                
    PerfDbgLog1(tagCBSCHolder, this, "+CBSCHolder::RemoveNode (IBSC:%lx)", pIBSC);
    HRESULT hr = E_FAIL;
    CLock lck(_mxs);

    CBSCNode *pNextNode = NULL;
    CBSCNode *pPrevNode = _pCBSCNode;

    // If binding has started, removal of nodes not allowed until binding stops.

    if (_fBindStarted && !_fBindStopped)
    {
        UrlMkAssert((FALSE && "IBSC in use - can not be revoked"));

        goto RemoveNodeExit;
    }

    if (pPrevNode)
    {
        pNextNode = pPrevNode->GetNextNode();
    }
    else
    {
        TransAssert((_cElements == 0));
        hr = S_FALSE;
        goto RemoveNodeExit;
    }

    if (_pCBSCNode->GetBSCB() == pIBSC)
    {
        UrlMkAssert((_pCBSCNode->GetBSCB() == pIBSC));
        if (!_fBindStarted || _pCBSCNode->CheckLocalFlags(NODE_FLAG_REMOVEOK))
        {
            PerfDbgLog2(tagCBSCHolder, this, "CBSCHolder::RemoveNode (Delete Node:%lx, IBSC:%lx)",
                _pCBSCNode, _pCBSCNode->GetBSCB());

            // release all obtained objects in the disdructor
            delete _pCBSCNode;

            _pCBSCNode = pNextNode;
            _cElements--;

            if (_cElements == 0)
            {
                hr = S_FALSE;
            }
            else
            {
                hr = S_OK;
            }
        }
    }
    else while (pNextNode)
    {
        PerfDbgLog2(tagCBSCHolder, this, "CBSCHolder::RemoveNode (pNextNode:%lx, pNextNode->pIBSC:%lx)",pNextNode,pNextNode->GetBSCB());

        if (pNextNode->GetBSCB() == pIBSC && (!_fBindStarted || pNextNode->CheckLocalFlags(NODE_FLAG_REMOVEOK)))
        {
            //we found the Node
            if (pPrevNode)
            {
                pPrevNode->SetNextNode(pNextNode->GetNextNode());
            }

            PerfDbgLog2(tagCBSCHolder, this, "CBSCHolder::RemoveNode (Delete Node:%lx, IBSC:%lx)",
                pNextNode,pNextNode->GetBSCB());

            // release all obtained objects in the disdructor
            delete pNextNode;

            hr = S_OK;
            _cElements--;

            UrlMkAssert((_cElements > 0));

            break;
        }
        else
        {
            pPrevNode = pNextNode;
            pNextNode = pNextNode->GetNextNode();
        }
        UrlMkAssert((hr == S_OK && "Node not found"));
    }

RemoveNodeExit:

    PerfDbgLog1(tagCBSCHolder, this, "-CBSCHolder::RemoveNode (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBSCHolder::SetMainNode
//
//  Synopsis:
//
//  Arguments:  [pIBSC] --
//              [ppIBSCPrev] --
//
//  Returns:
//
//  History:    5-08-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CBSCHolder::SetMainNode(IBindStatusCallback *pIBSC, IBindStatusCallback **ppIBSCPrev)
{
    DEBUG_ENTER((DBG_CALLBACK,
                Hresult,
                "CBSCHolder::SetMainNode",
                "this=%#x, %#x, #x",
                this, pIBSC, ppIBSCPrev
                ));
                
    PerfDbgLog(tagCBSCHolder, this, "+CBSCHolder::SetMainNode");
    HRESULT hr = NOERROR;
    CLock lck(_mxs);

    CBSCNode *pFirstNode = _pCBSCNode;
    CBSCNode *pNode;
    CBSCNode *pNodeTmp;
    LPVOID pvLocal = NULL;

    // No new nodes allowed after binding has started.
    if (_fBindStarted)
    {
        hr = E_FAIL;
        goto GetFirsNodeExit;
    }
    if (pFirstNode)
    {
        IBindStatusCallback *pBSC = pFirstNode->GetBSCB();

        // addref the node here and return it
        if (ppIBSCPrev)
        {
            pBSC->AddRef();
            *ppIBSCPrev = pBSC;
        }

        hr = RemoveNode(pBSC);
    }

    pFirstNode = _pCBSCNode;

    // Allocate memory for new pNode member.
    pNode = new CBSCNode(pIBSC, BSCO_ALLONIBSC);

    if (!pNode)
    {
        hr = E_OUTOFMEMORY;
    }
    else
    {
        // addref the IBSC pointer
        pIBSC->AddRef();
        hr = NOERROR;

        // QI for IServiceProvider - QI addref IBSC
        if (pIBSC->QueryInterface(IID_IServiceProvider, &pvLocal) == NOERROR)
        {
            pNode->SetServiceProvider((IServiceProvider *)pvLocal);
        }

        PerfDbgLog3(tagCBSCHolder, this, "CBSCHolder::SetMainNode (New Node:%lx, IBSC:%lx, IServiceProvider:%lx)",
            pNode, pNode->GetBSCB(), pvLocal);

        // If we have a node already
        if (pFirstNode)
        {
            if (pNode->GetFlags() & BSCO_ONDATAAVAILABLE)
            {
                // If the new node gets the data, link it first.

                pNode->SetNextNode(pFirstNode);
                _pCBSCNode = pNode;
            }
            else
            {
                // The new node does not get data, link it second in list.

                pNodeTmp = pFirstNode->GetNextNode();

                pFirstNode->SetNextNode(pNode);
                pNode->SetNextNode(pNodeTmp);
            }
        }
        else
        {
            _pCBSCNode = pNode;
        }

        _cElements++;
    }
GetFirsNodeExit:

    PerfDbgLog2(tagCBSCHolder, this, "-CBSCHolder::SetMainNode (NewNode:%lx, hr:%lx)", pNode, hr);

    DEBUG_LEAVE(hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CBSCHolder::ObtainService
//
//  Synopsis:   Retrieves the requested service with QI and QueryService
//              for all nodes. The interfaces is addref'd and kept in the node.
//
//  Arguments:  [rsid] --
//              [riid] --
//
//  Returns:
//
//  History:    4-09-96   JohannP (Johann Posch)   Created
//
//  Notes:      The obtained interfaces are released in the disdructor of the
//              CNode.
//
//----------------------------------------------------------------------------
HRESULT CBSCHolder::ObtainService(REFGUID rsid, REFIID riid, void ** ppvObj)
{
    DEBUG_ENTER((DBG_CALLBACK,
                Hresult,
                "CBSCHolder::ObtainService",
                "this=%#x, %#x, #x, %#x",
                this, &rsid, &riid, ppvObj
                ));
                
    PerfDbgLog(tagCBSCHolder, this, "+CBSCHolder::ObtainService");
    HRESULT     hr = NOERROR;
    CBSCNode   *pNode;
    VDATETHIS(this);
    LPVOID pvLocal = NULL;

    pNode = _pCBSCNode;

    // the old code was under the assumption that rsid was always the same
    // as riid. it checked riid when it should have been checking rsid, and it
    // always passed riid on in the place of rsid! All callers that I've
    // seen that use IID_IHttpNegotiate and IID_IAuthenticate pass the
    // same iid in both rsid and riid, so fixing this should be safe.
    if (rsid == IID_IHttpNegotiate)
    {
        *ppvObj = (void*)(IHttpNegotiate *) this;
        AddRef();

        // loop once to get all interfaces
        if (!_fHttpNegotiate)
        {
            while (pNode)
            {
                if (   (pNode->GetBSCB()->QueryInterface(riid, &pvLocal) == NOERROR)
                    || (   pNode->GetServiceProvider()
                        && (pNode->GetHttpNegotiate() == NULL)
                        && (pNode->GetServiceProvider()->QueryService(rsid, riid, &pvLocal)) == NOERROR)
                    )
                {
                    // Note: the interface is addref'd by QI or QS
                    pNode->SetHttpNegotiate((IHttpNegotiate *)pvLocal);
                }

                pNode = pNode->GetNextNode();
            }

            _fHttpNegotiate = TRUE;
        }
    }
    else if (rsid == IID_IAuthenticate)
    {
        *ppvObj = (void*)(IAuthenticate *) this;
        AddRef();

        if (!_fAuthenticate)
        {
            while (pNode)
            {
                if (   (pNode->GetBSCB()->QueryInterface(riid, &pvLocal) == NOERROR)
                    || (   pNode->GetServiceProvider()
                        && (pNode->GetAuthenticate() == NULL)
                        && (pNode->GetServiceProvider()->QueryService(rsid, riid, &pvLocal)) == NOERROR)
                    )
                {
                    // Note: the interface is addref'd by QI or QS
                    pNode->SetAuthenticate((IAuthenticate *)pvLocal);
                }

                pNode = pNode->GetNextNode();
            }

            _fAuthenticate = TRUE;
        }

    }
    else if (rsid == IID_IHttpNegotiate2)
    {
        *ppvObj = (void*)(IHttpNegotiate2 *) this;
        AddRef();

        // loop once to get all interfaces
        if (!_fHttpNegotiate2)
        {
            while (pNode)
            {
                if (   (pNode->GetBSCB()->QueryInterface(riid, &pvLocal) == NOERROR)
                    || (   pNode->GetServiceProvider()
                        && (pNode->GetHttpNegotiate2() == NULL)
                        && (pNode->GetServiceProvider()->QueryService(rsid, riid, &pvLocal)) == NOERROR)
                    )
                {
                    // Note: the interface is addref'd by QI or QS
                    pNode->SetHttpNegotiate2((IHttpNegotiate2 *)pvLocal);
                }

                pNode = pNode->GetNextNode();
            }

            _fHttpNegotiate2 = TRUE;
        }
    }
    else
    {
        *ppvObj = NULL;
        hr = E_NOINTERFACE;

        while (pNode)
        {
            // old urlmon code did a QueryInterface on this object (CBSCHolder)
            // without regard to rsid. That's QueryService badness, but CINet
            // (and several other places) call QueryService using the same rsid/riid
            // (in this case IID_IHttpSecurity) and *expect* the below QI to pick
            // the interface off the BSCB. We should create an URLMON service id
            // that means "ask the BSCB for this interface" and use that...
            if (    (pNode->GetBSCB()->QueryInterface(riid, &pvLocal) == NOERROR)
                 || (pNode->GetServiceProvider()
                 && (pNode->GetServiceProvider()->QueryService(rsid, riid, &pvLocal)) == NOERROR)
                )
            {
                *ppvObj = pvLocal;
                hr = NOERROR;
                // Note: the interface is addref'd by QI or QS
                // stop looking at other nodes for this service
                pNode = NULL;
            }

            if (pNode)
            {
                pNode = pNode->GetNextNode();
            }
        }
    }

    PerfDbgLog1(tagCBSCHolder, this, "-CBSCHolder::ObtainService (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\mon\urlguids.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       urlguids.cxx
//
//  Contents:   Defines GUIDS used in this DLL.
//
//
//  History:    10-02-1996   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------
//#include <urlint.h>


#ifdef __cplusplus
extern "C" {
#endif


#ifndef GUID_DEFINED
#define GUID_DEFINED

typedef struct _GUID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} GUID;
#endif // GUID_DEFINED


const GUID CLSID_MsHtml           = { 0x25336920, 0x03F9, 0x11cf, {0x8F, 0xD0, 0x00, 0xAA, 0x00, 0x68, 0x6F, 0x13} };
const GUID IID_ITransactionData   = { 0x79eac9cf, 0xbaf9, 0x11ce, {0x8c, 0x82, 0x00, 0xaa, 0x00, 0x4b, 0xa9, 0x0b} };
const GUID IID_ITransProtocolSink = { 0x7291765a, 0xa83f, 0x401d, {0x81, 0xa6, 0x11, 0x2c, 0x3a, 0x46, 0x8a, 0x7b} };

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\mon\urldll.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       urldll.cxx
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    10-25-95   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------
#include <mon.h>
#include "urlcf.hxx"
#include "selfreg.hxx"
#include <delaydll.h>
#include <tls.h>
#include <commctrl.h>
#include <shfusion.h>

#define MLUI_INIT
#include "mluisupp.h"

#ifdef _SBS_
#include "sbsclsid.hxx"
#else
#include "clsid.hxx"
#endif //_SBS_

//
// Downlevel delay load support (we forward to shlwapi)
//
#include <delayimp.h>

PfnDliHook __pfnDliFailureHook;

#ifdef unix
#define DllMain DllMainInternal
#endif /* unix */

COleAutDll  g_OleAutDll;

PerfDbgTag(tagUrlDll, "Urlmon", "Log DllMain", DEB_URLMON);

DECLARE_INFOLEVEL(UrlMk)
DECLARE_INFOLEVEL(Trans)
DECLARE_INFOLEVEL(PProt)
DECLARE_INFOLEVEL(Notf)
DECLARE_INFOLEVEL(EProt)
DECLARE_INFOLEVEL(TNotf)

extern HINSTANCE g_hInst;
extern HMODULE   g_hLibPluginOcx;
extern HMODULE   g_hLibMlang;
extern ULONG     Win4AssertLevel;
extern IEnumFORMATETC *g_pEFmtETC;

DWORD g_dwSettings = 0;
BOOL  g_bCanUseSimpleBinding = TRUE;
BOOL  CanUseSimpleBinding();
BOOL  g_bHasMimeHandlerForTextHtml = TRUE;
LONG  g_cTransLevelHandler = 0;
BOOL  g_bGlobalUTF8Enabled = FALSE;
BOOL  g_bGlobalUTF8hackEnabled = TRUE;
BOOL  GlobalUTF8Enabled();
BOOL  GlobalUTF8hackEnabled();
BOOL  g_bNT5OrGreater = FALSE;

URLMON_TS* g_pHeadURLMONTSList; 
HRESULT    CleanupTSOnProcessDetach();
BOOL  g_bUseImprovedZoneCheck;
BOOL  CanUseImprovedZoneCheck();


// defined in calldatax.c
EXTERN_C HRESULT PrxDllGetClassObject(REFCLSID clsid, REFIID iid, void **ppv);
EXTERN_C HRESULT PrxDllRegisterServer();
EXTERN_C HRESULT PrxDllUnregisterServer();
EXTERN_C HRESULT PrxDllMain(HINSTANCE hInstance,DWORD dwReason,LPVOID lpvReserved);

// defined in zoneutil.c
EXTERN_C HRESULT ZonesDllInstall(BOOL bInstall, LPCWSTR pwStr);

// global variables
CRefCount g_cRef(0);        // global dll refcount
CMutexSem g_mxsMedia;       // single access to media holder

LPSTR g_pszUserAgentString = NULL;  // Per-process configurable User Agent string
IInternetSecurityManager *g_pSecurityManager = NULL; 
LPSTR g_pszUAInfoString = NULL;
LPSTR GetUAInfoString(void);


STDAPI_(BOOL) TlsDllMain(HINSTANCE hDll, DWORD dwReason, LPVOID lpvReserved);


#define STDCOURIER_CLSID                        "{c733e4af-576e-11d0-b28c-00c04fd7cd22}"
#define STDCOURIER_CLSID_REGKEY                 "CLSID\\"STDCOURIER_CLSID
#define STDCOURIER_CLSID_REGKEY                 "CLSID\\"STDCOURIER_CLSID
#define STDCOURIER_DESCRIP                      "Thread NotificationMgr"

const REGENTRY rgStdNotificationMgr[] =
{
    //***** STDCOURIER ENTRIES *****
    STD_ENTRY(STDCOURIER_CLSID_REGKEY, STDCOURIER_DESCRIP),
    STD_ENTRY(STDCOURIER_CLSID_REGKEY"\\InprocServer32", "%s"URLMON_NAME),
        { KEYTYPE_STRING, STDCOURIER_CLSID_REGKEY"\\InprocServer32", "ThreadingModel", REG_SZ, (BYTE*)"Apartment" },
};


///* Registration of urlmon class
// HKEY_CLASSES_ROOT
const REGENTRY rgClassesRoot[] =
{
    //***** URLMONIKER ENTRIES *****
    STD_ENTRY(URLMONIKER_CLSID_REGKEY, URLMONIKER_DESCRIP),
    STD_ENTRY(URLMONIKER_CLSID_REGKEY"\\InprocServer32", "%s"URLMON_NAME),
        { KEYTYPE_STRING, URLMONIKER_CLSID_REGKEY"\\InprocServer32", "ThreadingModel", REG_SZ, (BYTE*)"Apartment" },
};

const REGENTRY rgClassesSoftDist[] =
{
    //***** SOFTDIST ENTRIES *****
    STD_ENTRY(SOFTDIST_CLSID_REGKEY, SOFTDIST_DESCRIP),
    STD_ENTRY(SOFTDIST_CLSID_REGKEY"\\InprocServer32", "%s"URLMON_NAME),
        { KEYTYPE_STRING, SOFTDIST_CLSID_REGKEY"\\InprocServer32", "ThreadingModel", REG_SZ, (BYTE*)"Apartment" },
};

const REGENTRY rgClassesSecMgr[] =
{
    //***** SECMGR ENTRIES *****
    STD_ENTRY(SECMGR_CLSID_REGKEY, SECMGR_DESCRIP),
    STD_ENTRY(SECMGR_CLSID_REGKEY"\\InprocServer32", "%s"URLMON_NAME),
        { KEYTYPE_STRING, SECMGR_CLSID_REGKEY"\\InprocServer32", "ThreadingModel", REG_SZ, (BYTE*)"Both" },
};

const REGENTRY rgClassesZoneMgr[] =
{
    //***** ZONEMGR ENTRIES *****
    STD_ENTRY(ZONEMGR_CLSID_REGKEY, ZONEMGR_DESCRIP),
    STD_ENTRY(ZONEMGR_CLSID_REGKEY"\\InprocServer32", "%s"URLMON_NAME),
        { KEYTYPE_STRING, ZONEMGR_CLSID_REGKEY"\\InprocServer32", "ThreadingModel", REG_SZ, (BYTE*)"Both" },
};

const REGENTRY rgClassesBindCtx[] =
{
    //***** URLBINDCTX ENTRIES *****
    STD_ENTRY(URLBINDCTX_CLSID_REGKEY, URLBINDCTX_DESCRIP),
    STD_ENTRY(URLBINDCTX_CLSID_REGKEY"\\InprocServer32", "%s"URLMON_NAME),
        { KEYTYPE_STRING, URLBINDCTX_CLSID_REGKEY"\\InprocServer32", "ThreadingModel", REG_SZ, (BYTE*)"Apartment" },
};

// Registration of proxy/stub class id
const REGENTRY rgPSFactory[] =
{
    //***** URLMONIKER PS ENTRIES *****
    STD_ENTRY(URLMONIKER_PS_CLSID_REGKEY, URLMONIKER_PS_DESCRIP),
    STD_ENTRY(URLMONIKER_PS_CLSID_REGKEY"\\InprocServer32", "%s"URLMON_NAME),
        { KEYTYPE_STRING, URLMONIKER_PS_CLSID_REGKEY"\\InprocServer32", "ThreadingModel", REG_SZ, (BYTE*)"Apartment" },
};

// protocols
const REGENTRY rgClassesHttp[] =
{
    //***** PROTOCOL_HTTP ENTRIES *****
    STD_ENTRY(PROTOCOL_HTTP_CLSID_REGKEY, PROTOCOL_HTTP_DESCRIP),
    STD_ENTRY(PROTOCOL_HTTP_CLSID_REGKEY"\\InprocServer32", "%s"URLMON_NAME),
        { KEYTYPE_STRING, PROTOCOL_HTTP_CLSID_REGKEY"\\InprocServer32", "ThreadingModel", REG_SZ, (BYTE*)"Apartment" },
};
const REGENTRY rgClassesFtp[] =
{
    //***** PROTOCOL_FTP ENTRIES *****
    STD_ENTRY(PROTOCOL_FTP_CLSID_REGKEY, PROTOCOL_FTP_DESCRIP),
    STD_ENTRY(PROTOCOL_FTP_CLSID_REGKEY"\\InprocServer32", "%s"URLMON_NAME),
        { KEYTYPE_STRING, PROTOCOL_FTP_CLSID_REGKEY"\\InprocServer32", "ThreadingModel", REG_SZ, (BYTE*)"Apartment" },
};

const REGENTRY rgClassesGopher[] =
{
    //***** PROTOCOL_GOPHER ENTRIES *****
    STD_ENTRY(PROTOCOL_GOPHER_CLSID_REGKEY, PROTOCOL_GOPHER_DESCRIP),
    STD_ENTRY(PROTOCOL_GOPHER_CLSID_REGKEY"\\InprocServer32", "%s"URLMON_NAME),
        { KEYTYPE_STRING, PROTOCOL_GOPHER_CLSID_REGKEY"\\InprocServer32", "ThreadingModel", REG_SZ, (BYTE*)"Apartment" },
};

const REGENTRY rgClassesHttpS[] =
{
    //***** PROTOCOL_HTTPS ENTRIES *****
    STD_ENTRY(PROTOCOL_HTTPS_CLSID_REGKEY, PROTOCOL_HTTPS_DESCRIP),
    STD_ENTRY(PROTOCOL_HTTPS_CLSID_REGKEY"\\InprocServer32", "%s"URLMON_NAME),
        { KEYTYPE_STRING, PROTOCOL_HTTPS_CLSID_REGKEY"\\InprocServer32", "ThreadingModel", REG_SZ, (BYTE*)"Apartment" },
};

const REGENTRY rgClassesMk[] =
{
    //***** PROTOCOL_MK ENTRIES *****
    STD_ENTRY(PROTOCOL_MK_CLSID_REGKEY, PROTOCOL_MK_DESCRIP),
    STD_ENTRY(PROTOCOL_MK_CLSID_REGKEY"\\InprocServer32", "%s"URLMON_NAME),
        { KEYTYPE_STRING, PROTOCOL_MK_CLSID_REGKEY"\\InprocServer32", "ThreadingModel", REG_SZ, (BYTE*)"Apartment" },
};

const REGENTRY rgClassesFile[] =
{
    //***** PROTOCOL_FILE ENTRIES *****
    STD_ENTRY(PROTOCOL_FILE_CLSID_REGKEY, PROTOCOL_FILE_DESCRIP),
    STD_ENTRY(PROTOCOL_FILE_CLSID_REGKEY"\\InprocServer32", "%s"URLMON_NAME),
        { KEYTYPE_STRING, PROTOCOL_FILE_CLSID_REGKEY"\\InprocServer32", "ThreadingModel", REG_SZ, (BYTE*)"Apartment" },
};



#define HANDLER_HTTP        SZPROTOCOLROOT"http"
#define HANDLER_FTP         SZPROTOCOLROOT"ftp"
#define HANDLER_GOPHER      SZPROTOCOLROOT"gopher"
#define HANDLER_HTTPS       SZPROTOCOLROOT"https"
#define HANDLER_MK          SZPROTOCOLROOT"mk"
#define HANDLER_FILE        SZPROTOCOLROOT"file"
#define HANDLER_LOCAL       SZPROTOCOLROOT"local"


//const REGENTRY rgHandler[] = { STD_ENTRY(HANDLER_HTTP, PROTOCOL_HTTP_DESCRIP), { KEYTYPE_STRING, HANDLER_HTTP, "CLSID", REG_SZ, (BYTE*)PROTOCOL_HTTP_CLSID } };
const REGENTRY rgHandlerHttp   [] = { STD_ENTRY(HANDLER_HTTP  , PROTOCOL_HTTP_DESCRIP  ), { KEYTYPE_STRING, HANDLER_HTTP  , "CLSID", REG_SZ, (BYTE*)PROTOCOL_HTTP_CLSID   } };
const REGENTRY rgHandlerFtp    [] = { STD_ENTRY(HANDLER_FTP   , PROTOCOL_FTP_DESCRIP   ), { KEYTYPE_STRING, HANDLER_FTP   , "CLSID", REG_SZ, (BYTE*)PROTOCOL_FTP_CLSID    } };
const REGENTRY rgHandlerGopher [] = { STD_ENTRY(HANDLER_GOPHER, PROTOCOL_GOPHER_DESCRIP), { KEYTYPE_STRING, HANDLER_GOPHER, "CLSID", REG_SZ, (BYTE*)PROTOCOL_GOPHER_CLSID } };
const REGENTRY rgHandlerHttpS  [] = { STD_ENTRY(HANDLER_HTTPS , PROTOCOL_HTTPS_DESCRIP ), { KEYTYPE_STRING, HANDLER_HTTPS , "CLSID", REG_SZ, (BYTE*)PROTOCOL_HTTPS_CLSID  } };
const REGENTRY rgHandlerMk     [] = { STD_ENTRY(HANDLER_MK    , PROTOCOL_MK_DESCRIP    ), { KEYTYPE_STRING, HANDLER_MK    , "CLSID", REG_SZ, (BYTE*)PROTOCOL_MK_CLSID     } };
const REGENTRY rgHandlerFile   [] = { STD_ENTRY(HANDLER_FILE  , PROTOCOL_FILE_DESCRIP  ), { KEYTYPE_STRING, HANDLER_FILE  , "CLSID", REG_SZ, (BYTE*)PROTOCOL_FILE_CLSID   } };
const REGENTRY rgHandlerLocal  [] = { STD_ENTRY(HANDLER_LOCAL , PROTOCOL_FILE_DESCRIP  ), { KEYTYPE_STRING, HANDLER_LOCAL , "CLSID", REG_SZ, (BYTE*)PROTOCOL_FILE_CLSID   } };


// From PlugProt.dll (merge)
#define SZFILTERROOT        "PROTOCOLS\\Filter\\"
#define SZPROTOCOLROOT      "PROTOCOLS\\Handler\\"
#define SZCLASS             "CLSID"
#define SZHANDLER           "HANDLER"

EXTERN_C const GUID CLSID_StdEncodingFilterFac;  
EXTERN_C const GUID CLSID_DeCompMimeFilter;    
EXTERN_C const GUID CLSID_CdlProtocol;   
EXTERN_C const GUID CLSID_ClassInstallFilter; 

//*************************** Registry keys for CDL protocol handler


const REGENTRY rgHandlerCdl[] = 
{ 
    STD_ENTRY(HANDLER_CDL  , PROTOCOL_CDL_DESCRIP  ), 
        { KEYTYPE_STRING, HANDLER_CDL  , "CLSID", REG_SZ, (BYTE*)PROTOCOL_CDL_CLSID   } 
};

const REGENTRY rgClassesCdl[] =
{
    STD_ENTRY(PROTOCOL_CDL_CLSID_REGKEY, PROTOCOL_CDL_DESCRIP),
    STD_ENTRY(PROTOCOL_CDL_CLSID_REGKEY"\\InprocServer32", "%s"URLMON_NAME),
        { KEYTYPE_STRING, PROTOCOL_CDL_CLSID_REGKEY"\\InprocServer32", "ThreadingModel", REG_SZ, (BYTE*)"Apartment" },
};

//*************************** Registry keys for Class Install Handler protocol filter


const REGENTRY rgClassesMimeInstallHandler[] =
{
    STD_ENTRY(PROT_FILTER_CLASS_CLSID_REGKEY, PROT_FILTER_CLASS_DESCRIP),
    STD_ENTRY(PROT_FILTER_CLASS_CLSID_REGKEY"\\InprocServer32", "%s"URLMON_NAME),
        { KEYTYPE_STRING, PROT_FILTER_CLASS_CLSID_REGKEY"\\InprocServer32", "ThreadingModel", REG_SZ, (BYTE*)"Apartment" },
};

const REGENTRY rgMimeInstallHandler[] = 
{ 
    STD_ENTRY(PROT_FILTER_CLASS , PROT_FILTER_CLASS_DESCRIP  ), 
        { KEYTYPE_STRING, PROT_FILTER_CLASS, "CLSID", REG_SZ, (BYTE*)PROT_FILTER_CLASS_CLSID   } 
};

//*************************** Registry keys for ENC & Deflate protocol filters


const REGENTRY rgClassesMimeHandlerEnc[] =
{
    STD_ENTRY(PROT_FILTER_ENC_CLSID_REGKEY, PROT_FILTER_ENC_DESCRIP),
    STD_ENTRY(PROT_FILTER_ENC_CLSID_REGKEY"\\InprocServer32", "%s"URLMON_NAME),
        { KEYTYPE_STRING, PROT_FILTER_ENC_CLSID_REGKEY"\\InprocServer32", "ThreadingModel", REG_SZ, (BYTE*)"Apartment" },
};

const REGENTRY rgMimeHandlerEnc  [] = 
{ 
    STD_ENTRY(PROT_FILTER_ENC , PROT_FILTER_ENC_DESCRIP  ), 
    { KEYTYPE_STRING, PROT_FILTER_ENC , "CLSID", REG_SZ, (BYTE*)PROT_FILTER_ENC_CLSID   } 
};


const REGENTRY rgDeflateEnc  [] = 
{ 
    STD_ENTRY(PROT_FILTER_DEFLATE , PROT_FILTER_DEFLATE_DESCRIP  ), 
    { KEYTYPE_STRING, PROT_FILTER_DEFLATE , "CLSID", REG_SZ, (BYTE*)PROT_FILTER_DEFLATE_CLSID   } 
};


const REGENTRY rgGZIPEnc  [] = 
{ 
    STD_ENTRY(PROT_FILTER_GZIP , PROT_FILTER_GZIP_DESCRIP  ), 
    { KEYTYPE_STRING, PROT_FILTER_GZIP , "CLSID", REG_SZ, (BYTE*)PROT_FILTER_GZIP_CLSID   } 
};

const REGENTRY rgClassesStdEncFac[] =
{
    STD_ENTRY(STD_ENC_FAC_CLSID_REGKEY"\\InprocServer32", "%s"URLMON_NAME),
        { KEYTYPE_STRING, STD_ENC_FAC_CLSID_REGKEY"\\InprocServer32", "ThreadingModel", REG_SZ, (BYTE*)"Apartment" },
};


const REGENTRYGROUP rgRegEntryGroups[] = {
    { HKEY_CLASSES_ROOT, rgStdNotificationMgr,      ARRAYSIZE(rgStdNotificationMgr) },
    { HKEY_CLASSES_ROOT, rgClassesRoot,     ARRAYSIZE(rgClassesRoot) },
    { HKEY_CLASSES_ROOT, rgClassesSoftDist,  ARRAYSIZE(rgClassesSoftDist) },
    { HKEY_CLASSES_ROOT, rgClassesSecMgr,   ARRAYSIZE(rgClassesSecMgr) },
    { HKEY_CLASSES_ROOT, rgClassesZoneMgr,   ARRAYSIZE(rgClassesZoneMgr) },
    { HKEY_CLASSES_ROOT, rgClassesBindCtx,  ARRAYSIZE(rgClassesBindCtx) },
    { HKEY_CLASSES_ROOT, rgPSFactory,       ARRAYSIZE(rgPSFactory) },
    { HKEY_CLASSES_ROOT, rgClassesHttp,     ARRAYSIZE(rgClassesHttp) },
    { HKEY_CLASSES_ROOT, rgClassesFtp,      ARRAYSIZE(rgClassesFtp) },
    { HKEY_CLASSES_ROOT, rgClassesGopher,   ARRAYSIZE(rgClassesGopher) },
    { HKEY_CLASSES_ROOT, rgClassesHttpS,    ARRAYSIZE(rgClassesHttpS) },
    { HKEY_CLASSES_ROOT, rgClassesMk,       ARRAYSIZE(rgClassesMk) },
    { HKEY_CLASSES_ROOT, rgClassesFile,     ARRAYSIZE(rgClassesFile) },

    { HKEY_CLASSES_ROOT, rgHandlerHttp  ,   ARRAYSIZE(rgHandlerHttp  ) },
    { HKEY_CLASSES_ROOT, rgHandlerFtp   ,   ARRAYSIZE(rgHandlerFtp   ) },
    { HKEY_CLASSES_ROOT, rgHandlerGopher,   ARRAYSIZE(rgHandlerGopher) },
    { HKEY_CLASSES_ROOT, rgHandlerHttpS ,   ARRAYSIZE(rgHandlerHttpS ) },
    { HKEY_CLASSES_ROOT, rgHandlerMk    ,   ARRAYSIZE(rgHandlerMk    ) },
    { HKEY_CLASSES_ROOT, rgHandlerFile  ,   ARRAYSIZE(rgHandlerFile  ) },
    { HKEY_CLASSES_ROOT, rgHandlerLocal ,   ARRAYSIZE(rgHandlerLocal ) },
    { HKEY_CLASSES_ROOT, rgMimeHandlerEnc,        ARRAYSIZE(rgMimeHandlerEnc) },
    { HKEY_CLASSES_ROOT, rgClassesMimeHandlerEnc, ARRAYSIZE(rgClassesMimeHandlerEnc) },

    { HKEY_CLASSES_ROOT, rgDeflateEnc,        ARRAYSIZE(rgDeflateEnc) },
    { HKEY_CLASSES_ROOT, rgGZIPEnc,  ARRAYSIZE(rgGZIPEnc) },
    { HKEY_CLASSES_ROOT, rgClassesStdEncFac,  ARRAYSIZE(rgClassesStdEncFac) },
    
    { HKEY_CLASSES_ROOT, rgClassesMimeInstallHandler,      ARRAYSIZE(rgClassesMimeInstallHandler) },
    { HKEY_CLASSES_ROOT, rgMimeInstallHandler,             ARRAYSIZE(rgMimeInstallHandler) },

    { HKEY_CLASSES_ROOT, rgClassesCdl,      ARRAYSIZE(rgClassesCdl) },
    { HKEY_CLASSES_ROOT, rgHandlerCdl  ,    ARRAYSIZE(rgHandlerCdl) },
#ifdef TEST_JOHANNP
#if DBG==1
    { HKEY_CLASSES_ROOT, rgNameSpaceTest1 ,   ARRAYSIZE(rgNameSpaceTest1 ) },
    { HKEY_CLASSES_ROOT, rgNameSpaceTest2 ,   ARRAYSIZE(rgNameSpaceTest2 ) },
#endif // DBG
#endif //TEST_JOHANNP
    { NULL, NULL, 0 }       // terminator
};


const REGENTRYGROUP rgRegEntryGroupsDel[] = {
    { HKEY_CLASSES_ROOT, rgStdNotificationMgr,      ARRAYSIZE(rgStdNotificationMgr) },
    { HKEY_CLASSES_ROOT, rgClassesRoot,     ARRAYSIZE(rgClassesRoot) },
    { HKEY_CLASSES_ROOT, rgClassesSoftDist,  ARRAYSIZE(rgClassesSoftDist) },
    { HKEY_CLASSES_ROOT, rgClassesSecMgr,   ARRAYSIZE(rgClassesSecMgr) },
    { HKEY_CLASSES_ROOT, rgClassesZoneMgr,   ARRAYSIZE(rgClassesZoneMgr) },
    { HKEY_CLASSES_ROOT, rgClassesBindCtx,  ARRAYSIZE(rgClassesBindCtx) },
    { HKEY_CLASSES_ROOT, rgPSFactory,       ARRAYSIZE(rgPSFactory) },
    { HKEY_CLASSES_ROOT, rgClassesHttp,     ARRAYSIZE(rgClassesHttp) },
    { HKEY_CLASSES_ROOT, rgClassesFtp,      ARRAYSIZE(rgClassesFtp) },
    { HKEY_CLASSES_ROOT, rgClassesGopher,   ARRAYSIZE(rgClassesGopher) },
    { HKEY_CLASSES_ROOT, rgClassesHttpS,    ARRAYSIZE(rgClassesHttpS) },
    { HKEY_CLASSES_ROOT, rgClassesMk,       ARRAYSIZE(rgClassesMk) },
    { HKEY_CLASSES_ROOT, rgClassesFile,     ARRAYSIZE(rgClassesFile) },

    { HKEY_CLASSES_ROOT, rgHandlerFtp   ,   ARRAYSIZE(rgHandlerFtp   ) },
    { HKEY_CLASSES_ROOT, rgHandlerGopher,   ARRAYSIZE(rgHandlerGopher) },
    { HKEY_CLASSES_ROOT, rgHandlerMk    ,   ARRAYSIZE(rgHandlerMk    ) },
    { HKEY_CLASSES_ROOT, rgHandlerFile  ,   ARRAYSIZE(rgHandlerFile  ) },
    { HKEY_CLASSES_ROOT, rgHandlerLocal ,   ARRAYSIZE(rgHandlerLocal ) },
    { HKEY_CLASSES_ROOT, rgMimeHandlerEnc,        ARRAYSIZE(rgMimeHandlerEnc) },
    { HKEY_CLASSES_ROOT, rgClassesMimeHandlerEnc, ARRAYSIZE(rgClassesMimeHandlerEnc) },

    { HKEY_CLASSES_ROOT, rgDeflateEnc,        ARRAYSIZE(rgDeflateEnc) },
    { HKEY_CLASSES_ROOT, rgGZIPEnc,  ARRAYSIZE(rgGZIPEnc) },
    { HKEY_CLASSES_ROOT, rgClassesStdEncFac,  ARRAYSIZE(rgClassesStdEncFac) },
    
    { HKEY_CLASSES_ROOT, rgClassesMimeInstallHandler,      ARRAYSIZE(rgClassesMimeInstallHandler) },
    { HKEY_CLASSES_ROOT, rgMimeInstallHandler,             ARRAYSIZE(rgMimeInstallHandler) },

    { HKEY_CLASSES_ROOT, rgClassesCdl,      ARRAYSIZE(rgClassesCdl) },
    { HKEY_CLASSES_ROOT, rgHandlerCdl  ,    ARRAYSIZE(rgHandlerCdl) },
#ifdef TEST_JOHANNP
#if DBG==1
    { HKEY_CLASSES_ROOT, rgNameSpaceTest1 ,   ARRAYSIZE(rgNameSpaceTest1 ) },
    { HKEY_CLASSES_ROOT, rgNameSpaceTest2 ,   ARRAYSIZE(rgNameSpaceTest2 ) },
#endif // DBG
#endif //TEST_JOHANNP
    { NULL, NULL, 0 }       // terminator
};


//+---------------------------------------------------------------------------
//
//  Function:   DllAddRef
//
//  Synopsis:
//
//  Arguments:  [void] --
//
//  Returns:
//
//  History:    12-10-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
void DllAddRef(void)
{
    g_cRef++;
}

//+---------------------------------------------------------------------------
//
//  Function:   DllRelease
//
//  Synopsis:
//
//  Arguments:  [void] --
//
//  Returns:
//
//  History:    12-10-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
void DllRelease(void)
{
    UrlMkAssert((g_cRef > 0));
    if (g_cRef > 0)
    {
        g_cRef--;
    }
}

//+---------------------------------------------------------------------------
//
//  Operator:   new
//
//  Synopsis:
//
//  Arguments:  [size] --
//
//  Returns:
//
//  History:    12-10-95   JohannP (Johann Posch)   Created
//
//  Notes:      BUBUG: get and use IMalloc
//
//----------------------------------------------------------------------------
void * _cdecl operator new(size_t size)
{
    void * pBuffer;
    pBuffer = CoTaskMemAlloc(size);
    if (pBuffer)
    {
        memset(pBuffer,0, size);
    }
    return pBuffer;
}

void * _cdecl operator new(size_t sizeEl, ULONG cEl)
{
    void * pBuffer;
    size_t size = sizeEl * cEl;
    pBuffer = CoTaskMemAlloc(size);
    if (pBuffer)
    {
        memset(pBuffer,0, size);
    }
    return pBuffer;
}


//+---------------------------------------------------------------------------
//
//  Operator:   delete
//
//  Synopsis:
//
//  Arguments:  [lpv] --
//
//  Returns:
//
//  History:    2-14-96   JohannP (Johann Posch)   Created
//
//  Notes:      BUBUG: get and use IMalloc
//
//----------------------------------------------------------------------------
void _cdecl operator delete(void *lpv)
{
    //UrlMkAssert((lpv != NULL));
    if (lpv == NULL)
    {
        return;
    }

    CoTaskMemFree(lpv);
}

#ifdef UNUSED
//
int _cdecl _purecall( void )
{
    UrlMkAssert(FALSE);
    return 0;
}

#endif //UNUSED

//+-------------------------------------------------------------------------
//
//  Function:   DllGetClassObject
//
//  Synopsis:   Dll entry point
//
//  Arguments:  [clsid] - class id for new class
//              [iid] - interface required of class
//              [ppv] - where to put new interface
//
//  Returns:    S_OK - class object created successfully created.
//
//
//--------------------------------------------------------------------------
STDAPI DllGetClassObject(REFCLSID clsid, REFIID iid, void **ppv)
{
    UrlMkDebugOut((DEB_URLMON, "API _IN DllGetClassObject\n"));

    HRESULT hr = E_NOTIMPL;

    if (   (clsid == CLSID_StdURLMoniker)
        || (clsid == CLSID_UrlMkBindCtx)
        || (clsid == CLSID_HttpSProtocol )
        || (clsid == CLSID_HttpProtocol  )
        || (clsid == CLSID_FtpProtocol   )
        || (clsid == CLSID_GopherProtocol)
        || (clsid == CLSID_FileProtocol  )
        || (clsid == CLSID_MkProtocol    )
        || (clsid == CLSID_SoftDistExt    )
        || (clsid == CLSID_InternetSecurityManager     )
        || (clsid == CLSID_InternetZoneManager    )
        || (clsid == CLSID_DeCompMimeFilter)
        || (clsid == CLSID_StdEncodingFilterFac)
        || (clsid == CLSID_CdlProtocol)
        || (clsid == CLSID_ClassInstallFilter) 
       )
    {
        CUrlClsFact *pCF = NULL;
        hr = CUrlClsFact::Create(clsid, &pCF);
        if (hr == NOERROR)
        {
            UrlMkAssert((pCF != NULL));
            hr = pCF->QueryInterface(iid, ppv);
            pCF->Release();
        }
    }
    else
    {
        hr = PrxDllGetClassObject(clsid, iid, ppv);
    }

    DumpIID(clsid);

    UrlMkDebugOut((DEB_URLMON, "API OUT DllGetClassObject (hr:%lx, ppv:%p)\n",hr,*ppv));
    return hr;
}

void SetupDelayloadErrorHandler()
{
    __pfnDliFailureHook = (PfnDliHook)GetProcAddress(GetModuleHandleA("shlwapi.dll"), "DelayLoadFailureHook");
}

//+-------------------------------------------------------------------------
//
//  Function:   DllMain
//
//  Synopsis:
//
//  Arguments:  [hDll]          - a handle to the dll instance
//              [dwReason]      - the reason LibMain was called
//              [lpvReserved]   - NULL - called due to FreeLibrary
//                              - non-NULL - called due to process exit
//
//  Returns:    TRUE on success, FALSE otherwise
//
//  Notes:
//
//              The officially approved DLL entrypoint name is DllMain. This
//              entry point will be called by the CRT Init function.
//
//
//--------------------------------------------------------------------------
BOOL WINAPI DllMain(HINSTANCE hInstance,DWORD dwReason,LPVOID lpvReserved)
{
    BOOL fResult = TRUE;
    UrlMkDebugOut((DEB_DLL,"DllMain:%lx\n", dwReason));

    PrxDllMain(hInstance, dwReason, lpvReserved);

    switch (dwReason)
    {
    case DLL_PROCESS_ATTACH:
#if DBG==1
        {
            UrlMkInfoLevel = (DWORD) GetProfileIntA("UrlMon","UrlMk", (DEB_ERROR | DEB_WARN)) & DEB_LEVEL_MASK;
            TransInfoLevel = (DWORD) GetProfileIntA("UrlMon","Trans", (DEB_ERROR | DEB_WARN)) & DEB_LEVEL_MASK;
            PProtInfoLevel = (DWORD) GetProfileIntA("UrlMon","PProt", (DEB_ERROR | DEB_WARN)) & DEB_LEVEL_MASK;
            NotfInfoLevel  = (DWORD) GetProfileIntA("UrlMon","Notf",  (DEB_ERROR | DEB_WARN)) & DEB_LEVEL_MASK;
            EProtInfoLevel = (DWORD) GetProfileIntA("UrlMon","EProt", (DEB_ERROR | DEB_WARN)) & DEB_LEVEL_MASK;
            TNotfInfoLevel = (DWORD) GetProfileIntA("UrlMon","TNotf",  (DEB_ERROR | DEB_WARN)) & DEB_LEVEL_MASK;
            g_dwSettings   = (DWORD) GetProfileIntA("UrlMon","Global", (DEB_ERROR | DEB_WARN));
            Win4AssertLevel= (ULONG) GetProfileIntA("UrlMon","AssertLevel", 0);

        // enable encoding handler
        // g_dwSettings |= 0x00100000;
        }
#endif //DBG==1
        SHFusionInitializeFromModule((HMODULE)hInstance);
        SetupDelayloadErrorHandler();

        PerfDbgLog(tagUrlDll, NULL, "+URLMON DLL_PROCESS_ATTACH");
        g_pszUserAgentString = NULL;
        g_pszUAInfoString = GetUAInfoString();
        // We ignore the return code of ZonesInit because other parts of urlmon
        // could still function fine if we can't init zones. 
        ZonesInit( );

        g_bCanUseSimpleBinding = CanUseSimpleBinding();
        g_bGlobalUTF8Enabled = GlobalUTF8Enabled();
        g_bGlobalUTF8hackEnabled = GlobalUTF8hackEnabled();
        g_bUseImprovedZoneCheck = CanUseImprovedZoneCheck();
        g_pHeadURLMONTSList = NULL; 

        OSVERSIONINFO osvi;

        osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    
        if (GetVersionEx(&osvi))
        {
            g_bNT5OrGreater = (osvi.dwPlatformId == VER_PLATFORM_WIN32_NT) && (osvi.dwMajorVersion >= 5);
        }

        fResult = TlsDllMain(hInstance, dwReason, lpvReserved);

        MLLoadResources(hInstance, TEXT("inetcplc.dll"));
        
        //debug log related stuff
        INET_DEBUG_START();
        
        PerfDbgLog(tagUrlDll, NULL, "-URLMON DLL_PROCESS_ATTACH");
        break;

    case DLL_PROCESS_DETACH:
        if (g_pszUserAgentString != NULL)
        {
            delete g_pszUserAgentString;
            g_pszUserAgentString = NULL;
        }
        if (g_pSecurityManager)
        {
            g_pSecurityManager->Release();
            g_pSecurityManager = NULL;
        }
        if (g_pszUAInfoString != NULL)
        {
            delete g_pszUAInfoString;
            g_pszUAInfoString = NULL;
        }

        if (g_hLibPluginOcx)
        {
            FreeLibrary(g_hLibPluginOcx);
        }

        if (g_hLibMlang)
        {
            FreeLibrary(g_hLibMlang);
        }

        ZonesUnInit( );

        g_bCanUseSimpleBinding = TRUE;

        if (g_pEFmtETC)
        {
            g_pEFmtETC->Release();
        }

        if(g_pHeadURLMONTSList) 
        {
            //
            // if    lpvReserved == NULL   - called due to FreeLibrary
            // else                        - called due to process Terminate
            //
            // Since we are using SendMessage to kill the thread notification 
            // window, we should only do that when FreeLibraray() happens
            //
            if( !lpvReserved )
            {
                CleanupTSOnProcessDetach();   
            }
        }
        
        MLFreeResources(hInstance);

        //debug log related stuff
        INET_DEBUG_FINISH();

        // Fall through

    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:
        fResult = TlsDllMain(hInstance, dwReason, lpvReserved);

        if (dwReason==DLL_PROCESS_DETACH)
        {
            SHFusionUninitialize();
        }
    }
    UrlMkDebugOut((DEB_DLL,"DllMain: done\n"));

    return fResult;
}

//+---------------------------------------------------------------------------
//
//  Function:   DllCanUnloadNow
//
//  Synopsis:
//
//  Arguments:  [void] --
//
//  Returns:
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI DllCanUnloadNow(void)
{
    return (g_cRef ? S_FALSE : S_OK);
}

//+---------------------------------------------------------------------------
//
//  Function:   DllRegisterServer
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    5-03-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI DllRegisterServer()
{
    UrlMkDebugOut((DEB_URLMON, "API _IN DllRegisterServer\n"));
    HRESULT hr;

    // don't register the proxies now
    // PrxDllRegisterServer();
    PrxDllRegisterServer();

    hr = HrDllRegisterServer(rgRegEntryGroups, g_hInst, NULL /*pfnLoadString*/);


    UrlMkDebugOut((DEB_URLMON, "API OUT DllRegisterServer (hr:%lx)\n",hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   DllUnregisterServer
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    5-03-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI DllUnregisterServer()
{
    UrlMkDebugOut((DEB_URLMON, "API _IN DllUnregisterServer\n"));
    HRESULT hr;

    // don't register the proxies now
    //PrxDllUnregisterServer();
    hr = HrDllUnregisterServer(rgRegEntryGroupsDel, g_hInst, NULL /*pfnLoadString*/);

    UrlMkDebugOut((DEB_URLMON, "API OUT DllUnregisterServer (hr:%lx)\n",hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   DllRegisterServerEx
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    5-03-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI DllRegisterServerEx()
{
    UrlMkDebugOut((DEB_URLMON, "API _IN DllRegisterServerEx\n"));

    HRESULT hr = E_NOTIMPL;

    UrlMkDebugOut((DEB_URLMON, "API OUT DllRegisterServerEx (hr:%lx)\n",hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   DllInstall
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    6-17-97   SanjayS (Sanjay Shenoy)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI DllInstall(BOOL bInstall, LPCWSTR pwStr)
{
    UrlMkDebugOut((DEB_URLMON, "API _IN DllInstall\n"));

#ifdef UNIX
    /*
     * On Unix, regsetup always passes in L"" for pwStr.
     */
    HRESULT hr;

    if (pwStr && !wcscmp(pwStr, L""))
       hr = ZonesDllInstall(bInstall, L"HKCU");
    else
       hr = ZonesDllInstall(bInstall, pwStr);
#else
    HRESULT hr = ZonesDllInstall(bInstall, pwStr);
#endif /* UNIX */

    UrlMkDebugOut((DEB_URLMON, "API OUT DllInstall (hr:%lx)\n", hr));
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   CoBuildVersion
//
//  Synopsis:   Return build version DWORD
//
//  Returns:    DWORD hiword = 23
//              DWORD loword = build number
//
//  Notes:      The high word must always be constant for a given platform.
//              For Win16 it must be exactly 23 (because that's what 16-bit
//              OLE 2.01 shipped with).  We can choose a different high word
//              for other platforms.  The low word must be greater than 639
//              (also because that's what 16-bit OLE 2.01 shipped with).
//
//--------------------------------------------------------------------------

STDAPI_(DWORD)  UrlMkBuildVersion( VOID )
{
    WORD wLowWord;
    WORD wHighWord;


    wHighWord = 23;
    //wLowWord  = rmm;    //  from ih\verole.h
    wLowWord  = 1;    //  from ih\verole.h

    //Win4Assert(wHighWord == 23 && "CoBuildVersion high word magic number");
    //Win4Assert(wLowWord > 639 && "CoBuildVersion low word not large enough");

    DWORD dwVersion;

    dwVersion = MAKELONG(wLowWord, wHighWord);

    return dwVersion;
}

//+---------------------------------------------------------------------------
//
//  Function:   GetUAInfoString
//
//  Synopsis:   Creates the extra UA header string
//
//  Arguments:
//
//  Returns:    pointer to newly allocated string
//
//  History:    5-27-96   JoeS (Joe Souza)  Created
//
//  Notes:
//
//----------------------------------------------------------------------------
LPSTR GetUAInfoString(void)
{
    BOOL    bRet;

    CHAR    szINTEL[] = "x86";
    CHAR    szMIPS[] = "MIPS";
    CHAR    szALPHA[] = "Alpha";
    CHAR    szPPC[] = "PPC";
    CHAR    *pszProcessorString = szINTEL;

    CHAR    szExtraUAInfo[] = "UA-CPU: %s\r\n";
    #define SZUSERAGENTMAX 256
    static char vszBuffer[SZUSERAGENTMAX] = "";

    LPSTR   pszTmp;
    BOOL    fIsNT = FALSE;

    // Get all needed info.
    OSVERSIONINFO   osvi;
    SYSTEM_INFO si;

    {
        memset(&osvi, 0, sizeof(osvi));

        osvi.dwOSVersionInfoSize = sizeof(osvi);
        GetVersionEx(&osvi);
        if (osvi.dwPlatformId == VER_PLATFORM_WIN32_NT)
        {
            // We are running on NT
            fIsNT = TRUE;
            memset(&si, 0, sizeof(si));

            GetSystemInfo(&si);

            switch (si.wProcessorArchitecture)
            {
            case PROCESSOR_ARCHITECTURE_MIPS:
                pszProcessorString = szMIPS;
                break;

            case PROCESSOR_ARCHITECTURE_ALPHA:
                pszProcessorString = szALPHA;
                break;

            case PROCESSOR_ARCHITECTURE_PPC:
                pszProcessorString = szPPC;
                break;
            }
        }
    }

    // Build header string.
    wsprintf(vszBuffer, szExtraUAInfo, pszProcessorString);

    pszTmp = new CHAR [strlen(vszBuffer) + 1];

    if (pszTmp )
    { 
        if(fIsNT && si.wProcessorArchitecture != PROCESSOR_ARCHITECTURE_INTEL )
            strcpy(pszTmp, vszBuffer);
        else 
            pszTmp[0] = '\0';
    }

    return pszTmp;
}

#if DBG==1

#include <sem.hxx>
CMutexSem   mxs;

IDebugOut *v_pPProtDbgOut = NULL;
IDebugOut *v_pTransDbgOut = NULL;
IDebugOut *v_pUrlMkDbgOut = NULL;
IDebugOut *v_pNotfDbgOut = NULL;
IDebugOut *v_pEProtDbgOut = NULL;
IDebugOut *v_pTNotfDbgOut = NULL;

void UrlSpyFn(int iOption, const char *pscFormat, ...)
{
    CLock lck(mxs);
    
    static char szOutBuffer[2048];
    static DWORD * apiLevel[] = { &UrlMkInfoLevel, &TransInfoLevel, &PProtInfoLevel, &NotfInfoLevel, &EProtInfoLevel, &TNotfInfoLevel };
    static IDebugOut ** apDbgOut[] = { &v_pUrlMkDbgOut, &v_pTransDbgOut, &v_pPProtDbgOut,&v_pNotfDbgOut, &v_pEProtDbgOut, &v_pTNotfDbgOut };
    int iIndex = iOption >> DEB_LEVEL_SHIFT;
    int iLevel = *apiLevel[iIndex];

    if ((iOption & iLevel) == 0)
        return;

    DWORD tid = GetCurrentThreadId();
    DWORD cbBufLen;
    IDebugOut * pDbgOut = *apDbgOut[iIndex];

    wsprintf(szOutBuffer, "%08x> ", tid);
    cbBufLen = strlen(szOutBuffer);

    va_list args;
    va_start(args, pscFormat);
    vsprintf(szOutBuffer + cbBufLen, pscFormat, args);
    va_end(args);
    UrlSpySendEntry(pDbgOut, szOutBuffer, tid, iOption & DEB_LEVEL_MASK, 0);
}

void PerfDbgLogFn(int tag, void * pvObj, const char * pchFmt, ...)
{
    CLock lck(mxs);
    
    static char szOutBuffer[2048];
    static DWORD * apiLevel[] = { &UrlMkInfoLevel, &TransInfoLevel, &PProtInfoLevel, &NotfInfoLevel, &EProtInfoLevel, &TNotfInfoLevel };
    static IDebugOut ** apDbgOut[] = { &v_pUrlMkDbgOut, &v_pTransDbgOut, &v_pPProtDbgOut, &v_pEProtDbgOut };
    int iIndex = min(tag >> DEB_LEVEL_SHIFT, 2);
    int iLevel = *apiLevel[iIndex];

    if ((tag & iLevel) == 0)
        return;

    DWORD tid = GetCurrentThreadId();
    DWORD cbBufLen;
    IDebugOut * pDbgOut = *apDbgOut[iIndex];

    sprintf(szOutBuffer, "%08x> %p %s", tid, pvObj,
        *pchFmt == '+' ? "_IN " : (*pchFmt == '-' ? "OUT " : ""));
    cbBufLen = strlen(szOutBuffer);

    if (*pchFmt == '+' || *pchFmt == '-')
        pchFmt += 1;

    va_list args;
    va_start(args, pchFmt);
    vsprintf(szOutBuffer + cbBufLen, pchFmt, args);
    lstrcat(szOutBuffer, "\n");
    va_end(args);
    UrlSpySendEntry(pDbgOut, szOutBuffer, tid, tag & DEB_LEVEL_MASK, 0);
}

void UrlSpySendEntry(IDebugOut *pDbgOut, LPSTR szOutBuffer, DWORD ThreadId, DWORD dwFlags, DWORD dwReserved)
{
    if (pDbgOut)
    {
        pDbgOut->SendEntry(ThreadId, dwFlags, szOutBuffer, dwReserved);
    }
    else
    {
        OutputDebugString(szOutBuffer);
    }
}

HRESULT RegisterDebugOut(LPCWSTR pwzName, DWORD dwOptions, IDebugOut *pDbgOut, DWORD dwReserved)
{
    if (pwzName)
    {

        if (!wcsicmp(pwzName, L"UrlMk"))
        {
            UrlMkInfoLevel = dwOptions;
            if (v_pUrlMkDbgOut)
            {
                v_pUrlMkDbgOut->Release();
                v_pUrlMkDbgOut = NULL;
            }
            if (pDbgOut)
            {

                v_pUrlMkDbgOut = pDbgOut;
                pDbgOut->AddRef();
            }

        }
        if (!wcsicmp(pwzName, L"Trans"))
        {
            TransInfoLevel = dwOptions;
            if (v_pTransDbgOut)
            {
                v_pTransDbgOut->Release();
                v_pTransDbgOut = NULL;
            }
            if (pDbgOut)
            {

                v_pTransDbgOut = pDbgOut;
                pDbgOut->AddRef();
            }

        }
        if (!wcsicmp(pwzName, L"PProt"))
        {
            PProtInfoLevel = dwOptions;
            if (v_pPProtDbgOut)
            {
                v_pPProtDbgOut->Release();
                v_pPProtDbgOut = NULL;
            }
            if (pDbgOut)
            {

                v_pPProtDbgOut = pDbgOut;
                pDbgOut->AddRef();
            }

        }
        if (!wcsicmp(pwzName, L"Notf"))
        {
            NotfInfoLevel = dwOptions;
            if (v_pNotfDbgOut)
            {
                v_pNotfDbgOut->Release();
                v_pNotfDbgOut = NULL;
            }
            if (pDbgOut)
            {

                v_pNotfDbgOut = pDbgOut;
                pDbgOut->AddRef();
            }

        }
        if (!wcsicmp(pwzName, L"EProt"))
        {
            EProtInfoLevel = dwOptions;
            if (v_pEProtDbgOut)
            {
                v_pEProtDbgOut->Release();
                v_pEProtDbgOut = NULL;
            }
            if (pDbgOut)
            {

                v_pEProtDbgOut = pDbgOut;
                pDbgOut->AddRef();
            }

        }
        if (!wcsicmp(pwzName, L"TNotf"))
        {
            TNotfInfoLevel = dwOptions;
            if (v_pTNotfDbgOut)
            {
                v_pTNotfDbgOut->Release();
                v_pTNotfDbgOut = NULL;
            }
            if (pDbgOut)
            {

                v_pTNotfDbgOut = pDbgOut;
                pDbgOut->AddRef();
            }

        }


    }

    return NOERROR;
}


#endif //DBG==1

/*
const REGENTRY rgClassesRes[] =
{
    //***** PROTOCOL_RES ENTRIES *****
    STD_ENTRY(PROTOCOL_RES_CLSID_REGKEY, PROTOCOL_RES_DESCRIP),
    STD_ENTRY(PROTOCOL_RES_CLSID_REGKEY"\\InprocServer32", "%s"URLMON_NAME),
        { KEYTYPE_STRING, PROTOCOL_RES_CLSID_REGKEY"\\InprocServer32", "ThreadingModel", REG_SZ, (BYTE*)"Apartment" },
};
*/

/*
const REGENTRY rgClasses[] =
{
    //***** URLMONIKER ENTRIES *****
        STD_ENTRY(URLMONIKER_CLSID_REGKEY, URLMONIKER_DESCRIP),
        STD_ENTRY(URLMONIKER_CLSID_REGKEY"\\InprocServer32", "%s"URLMON_NAME),
{ KEYTYPE_STRING, URLMONIKER_CLSID_REGKEY"\\InprocServer32", "ThreadingModel", REG_SZ, (BYTE*)"Apartment" },
};
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\mon\urlapi.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       UrlApi.cxx
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    10-25-95   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------
#include <mon.h>
#include <shlwapip.h>
#include "urlapi.hxx"
#include "httpneg.hxx"
#include "mpxbsc.hxx"
#ifndef unix
#include "..\trans\transact.hxx"
#include "..\trans\bindctx.hxx"
#include "..\trans\urlmk.hxx"
#else
#include "../trans/transact.hxx"
#include "../trans/bindctx.hxx"
#include "../trans/urlmk.hxx"
#endif /* unix */

PerfDbgTag(tagUrlApi, "Urlmon", "Log UrlMon API", DEB_ASYNCAPIS);

// API defined in trans\oinet.cxx
BOOL IsOInetProtocol(IBindCtx*, LPCWSTR);

//+---------------------------------------------------------------------------
//
//  Function:   CreateURLMoniker
//
//  Synopsis:   Create a new empty URL Moniker object
//
//  Arguments:  [pMkCtx] -- the context moniker
//              [szUrl] --  url string
//              [ppmk] --   new moniker
//
//  Returns:
//
//  History:    12-13-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI CreateURLMoniker(LPMONIKER pMkCtx, LPCWSTR szUrl, LPMONIKER FAR * ppMk)
{
    DEBUG_ENTER_API((DBG_API,
                    Hresult,
                    "CreateURLMoniker",
                    "%#x, %.80wq, %#x",
                    pMkCtx, szUrl, ppMk
                    ));

    HRESULT hr = CreateURLMonikerEx(pMkCtx, szUrl, ppMk, URL_MK_LEGACY);

    DEBUG_LEAVE_API(hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   CreateURLMonikerEx
//
//  Synopsis:   Create a new empty URL Moniker object
//
//  Arguments:  [pMkCtx] -- the context moniker
//              [szUrl] --  url string
//              [ppmk] --   new moniker
//              [dwflags] -- controlling flags
//
//  Returns:
//
//  History:    12-13-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI CreateURLMonikerEx(LPMONIKER pMkCtx, LPCWSTR szUrl, LPMONIKER FAR * ppMk, DWORD dwFlags)
{
    DEBUG_ENTER_API((DBG_API,
                    Hresult,
                    "CreateURLMonikerEx",
                    "%#x, %.200wq, %#x, %08x",
                    pMkCtx, szUrl, ppMk, dwFlags
                    ));

    VDATEPTROUT(ppMk,LPMONIKER);
    VDATEPTRIN(szUrl,WCHAR);
    PerfDbgLog2(tagUrlApi, NULL, "+CreateURLMoniker (szUrl%ws, pMkCtx:%lx)",szUrl?szUrl:L"<NULL PATH>", pMkCtx);
    HRESULT hr = NOERROR;
    LPWSTR  szUrlLocal = NULL;
    WCHAR   wzUrlStr[MAX_URL_SIZE + 1];
    CUrlMon * pUMk = NULL;
    DWORD   dwCUFlags = (dwFlags & URL_MK_UNIFORM) ? CU_STANDARD_FORM : 0;

    if (dwFlags & URL_MK_NO_CANONICALIZE)
        dwCUFlags |= CU_NO_CANONICALIZE;
    else
        dwCUFlags |= CU_CANONICALIZE;
        
    hr = ConstructURL(NULL, pMkCtx, NULL, (LPWSTR)szUrl, wzUrlStr,
            sizeof(wzUrlStr), dwCUFlags);

    if (hr != NOERROR)
    {
        goto CreateExit;
    }

    szUrlLocal = new WCHAR [wcslen(wzUrlStr) + 1];
    if (szUrlLocal)
    {
        wcscpy(szUrlLocal, wzUrlStr);

        if ((pUMk = new CUrlMon(szUrlLocal)) == NULL)
        {
            hr = E_OUTOFMEMORY;
        }

        // CUrlmon has refcount of 1 now
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

CreateExit:

    *ppMk = pUMk;

    PerfDbgLog2(tagUrlApi, NULL, "-CreateURLMoniker(%ws, Mnk:%lx)",wzUrlStr?wzUrlStr:L"<NULL PATH>",pUMk);

    DEBUG_LEAVE_API(hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   MkParseDisplayNameEx
//
//  Synopsis:
//
//  Arguments:  [pbc] --
//              [pszName] --
//              [pchEaten] --
//              [ppmk] --
//
//  Returns:
//
//  History:    12-13-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI MkParseDisplayNameEx(LPBC pbc, LPCWSTR szDispName, ULONG *pchEaten, LPMONIKER *ppmk)
{
    DEBUG_ENTER_API((DBG_API,
                    Hresult,
                    "MkParseDisplayNameEx",
                    "%#x, %.80wq, %#x, %#x",
                    pbc, szDispName, pchEaten, ppmk
                    ));

    VDATEPTROUT(ppmk, LPMONIKER);
    VDATEPTROUT(pchEaten, ULONG);
    VDATEIFACE(pbc);
    VDATEPTRIN(szDispName, WCHAR);
    HRESULT hr = NOERROR;
    WCHAR   wzUrlStr[MAX_URL_SIZE + 1];
    PerfDbgLog1(tagUrlApi, NULL, "+MkParseDisplayNameEx(%ws)",szDispName);


    // No need to canonicalize the URL here.  It will be done later by
    // CreateURLMoniker call below.

    hr = ConstructURL(pbc, NULL, NULL, (LPWSTR)szDispName, wzUrlStr,
            sizeof(wzUrlStr), CU_NO_CANONICALIZE);

    // for unknown protocol (not registered)
    // instead of returning a Moniker which will fail on the Bind
    // we should call the system's MkParseDisplayName()
    if( hr == NOERROR )
    {
        // this is an internal API defined at trans\oinet.cxx
        if(!IsOInetProtocol(pbc, wzUrlStr))
        {
            // for Office backward compatibility...
            if( !StrCmpNIW(wzUrlStr, L"telnet", (sizeof("telnet") - 1) ) )
            {
                hr = NOERROR;
            }
            else
            {
                hr = INET_E_UNKNOWN_PROTOCOL;
            }
        }
    }

    if (hr == NOERROR)
    {
        IMoniker *pmk = NULL;
        // create a URL Moniker and call ParseDisplayName
        hr = CreateURLMoniker(NULL, wzUrlStr, &pmk);
        if (hr == NOERROR)
        {
            *pchEaten = wcslen(szDispName);
            *ppmk = pmk;
        }
        else
        {
            *pchEaten = 0;
            *ppmk = NULL;
        }
    }
    else
    {
        // call the standard OLE parser
        hr = MkParseDisplayName(pbc, szDispName, pchEaten, ppmk);
    }

    PerfDbgLog1(tagUrlApi, NULL, "-MkParseDisplayNameEx(%ws)",szDispName);
    
    DEBUG_LEAVE_API(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   CreateAsyncBindCtx
//
//  Synopsis:
//
//  Arguments:  [reserved] --
//              [pBSCb] --
//              [ppBC] --
//
//  Returns:
//
//  History:    10-25-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI CreateAsyncBindCtx(DWORD reserved, IBindStatusCallback *pBSCb, IEnumFORMATETC *pEnum, IBindCtx **ppBC)
{
    DEBUG_ENTER_API((DBG_API,
                    Hresult,
                    "CreateAsyncBindCtx",
                    "%#x, %#x, %#x, %#x",
                    reserved, pBSCb, pEnum, ppBC
                    ));

    PerfDbgLog1(tagUrlApi, NULL, "+CreateAsyncBindCtx(%lx)",pBSCb);
    HRESULT hr = NOERROR;
    IUnknown *pUnk;


    if (pBSCb == NULL || ppBC == NULL)
    {
        hr = E_INVALIDARG;
        goto End;
    }

    hr = CreateBindCtx(reserved, ppBC);
    if (hr == NOERROR)
    {
        BIND_OPTS BindOpts;
        BindOpts.cbStruct = sizeof(BIND_OPTS);
        BindOpts.grfFlags = BIND_MAYBOTHERUSER;
        BindOpts.grfMode = STGM_READWRITE | STGM_SHARE_EXCLUSIVE;
        BindOpts.dwTickCountDeadline = 0L;

        ((IBindCtx *)*ppBC)->SetBindOptions(&BindOpts);

        // Register the IBindStatusCallback in the bind context.
        if (pBSCb != NULL)
        {
            CBSCHolder *pCBSCHolder;

            hr = GetBSCHolder(*ppBC, &pCBSCHolder);

            if (hr == NOERROR)
            {
                //hr = pCBSCHolder->AddNode(pBSCb, BSCO_ALLONIBSC);
                hr = pCBSCHolder->SetMainNode(pBSCb, 0);
                pCBSCHolder->Release();
            }
        }
        if ((hr == NOERROR) && (pEnum != NULL))
        {
            hr = RegisterFormatEnumerator(*ppBC, pEnum, 0);
        }
    }

End:

    PerfDbgLog1(tagUrlApi, NULL, "-CreateAsyncBindCtx(%lx)",pBSCb);

    DEBUG_LEAVE_API(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   CreateAsyncBindCtxEx
//
//  Synopsis:
//
//  Arguments:  [pbc] --
//              [dwOptions] --
//              [pBSCb] --
//              [pEnum] --
//              [ppBC] --
//              [reserved] --
//
//  Returns:
//
//  History:    10-09-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI CreateAsyncBindCtxEx(IBindCtx *pbc, DWORD dwOptions, IBindStatusCallback *pBSCb, IEnumFORMATETC *pEnum, IBindCtx **ppBC, DWORD reserved)
{
    DEBUG_ENTER_API((DBG_API,
                    Hresult,
                    "CreateAsyncBindCtxEx",
                    "%#x, %#x, %#x, %#x, %#x, %#x",
                    pbc, dwOptions, pBSCb, pEnum, ppBC, reserved
                    ));

    PerfDbgLog1(tagUrlApi, NULL, "+CreateAsyncBindCtxEx(%lx)",pBSCb);
    HRESULT hr = NOERROR;
    IUnknown *pUnk;
    CBindCtx *pCBCtx = NULL;


    if (ppBC == NULL)
    {
        hr = E_INVALIDARG;
    }
    else 
    {
        hr = CBindCtx::Create(&pCBCtx, pbc);
        if (hr == NOERROR)
        {

            *ppBC = pCBCtx;
            BIND_OPTS BindOpts;
            BindOpts.cbStruct = sizeof(BIND_OPTS);
            BindOpts.grfFlags = BIND_MAYBOTHERUSER;
            BindOpts.grfMode = STGM_READWRITE | STGM_SHARE_EXCLUSIVE;
            BindOpts.dwTickCountDeadline = 0L;

            ((IBindCtx *)*ppBC)->SetBindOptions(&BindOpts);

            // Register the IBindStatusCallback in the bind context.
            if (pBSCb != NULL)
            {
                CBSCHolder *pCBSCHolder;

                hr = GetBSCHolder(*ppBC, &pCBSCHolder);

                if (hr == NOERROR)
                {
                    //hr = pCBSCHolder->AddNode(pBSCb, BSCO_ALLONIBSC);
                    hr = pCBSCHolder->SetMainNode(pBSCb, 0);
                    pCBSCHolder->Release();
                }
            }
            if ((hr == NOERROR) && (pEnum != NULL))
            {
                hr = RegisterFormatEnumerator(*ppBC, pEnum, 0);
            }
        }
    }

    PerfDbgLog1(tagUrlApi, NULL, "-CreateAsyncBindCtxEx(%lx)",pBSCb);

    DEBUG_LEAVE_API(hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   IsAsyncMoniker
//
//  Synopsis:
//
//  Arguments:  [pmk] --
//
//  Returns:
//
//  History:    2-13-96   JohannP (Johann Posch)   Created
//              3-05-96   JoePe - Changed to use QI for IID_IAsyncMoniker
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI IsAsyncMoniker(IMoniker* pmk)
{
    DEBUG_ENTER_API((DBG_API,
                    Hresult,
                    "IsAsyncMoniker",
                    "%#x",
                    pmk
                    ));

    PerfDbgLog1(tagUrlApi, NULL, "+IsAsyncMoniker(%lx)", pmk);
    HRESULT hr = NOERROR;

    if (pmk)
    {
        IUnknown *punk;
        hr = pmk->QueryInterface(IID_IAsyncMoniker, (void**)&punk);
        if (hr == S_OK)
        {
            punk->Release();
        }
        else
        {
            hr = S_FALSE;
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

    PerfDbgLog2(tagUrlApi, NULL, "-IsAsyncMoniker(%lx, hr:%lx)",pmk, hr);
    
    DEBUG_LEAVE_API(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   RegisterBindStatusCallback
//
//  Synopsis:
//
//  Arguments:  [pBC] --
//              [pBSCb] --
//              [reserved] --
//
//  Returns:
//
//  History:    12-13-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI RegisterBindStatusCallback(LPBC pBC, IBindStatusCallback *pBSCb,IBindStatusCallback **ppBSCBPrev, DWORD reserved)
{
    DEBUG_ENTER_API((DBG_API,
                    Hresult,
                    "RegisterBindStatusCallback",
                    "%#x, %#x, %#x, %#x",
                    pBC, pBSCb, ppBSCBPrev, reserved
                    ));

    HRESULT hr;
    PerfDbgLog2(tagUrlApi, NULL, "+RegisterBindStatusCallback(pBC:%lx, pBSCb:%lx)",pBC,pBSCb);

    if (ppBSCBPrev)
    {
        *ppBSCBPrev = NULL;
    }

    // Register the IBindStatusCallback in the bind context.
    if (pBSCb != NULL && pBC != NULL)
    {
        CBSCHolder *pCBSCHolder;
        IBindStatusCallback *pBSCBUnused = NULL;

        // Note: get the previous register IBSC - this
        //       might be actual a marshaled object
        //
        if (ppBSCBPrev)
        {
            // ask for the IBSC and NOT the holder since the holder does NOT get marshaled
            hr = GetObjectParam(pBC, REG_BSCB_HOLDER, IID_IBindStatusCallback, (IUnknown **)ppBSCBPrev);
            PerfDbgLog1(tagUrlApi, NULL, "=== RegisterBindStatusCallback (pBSCBPrev:%lx)",*ppBSCBPrev);
        }

        hr = GetBSCHolder(pBC, &pCBSCHolder);
        if (hr == NOERROR)
        {
            hr = pCBSCHolder->SetMainNode(pBSCb, &pBSCBUnused);
            pCBSCHolder->Release();
        }

        if (pBSCBUnused)
        {
            if (ppBSCBPrev && *ppBSCBPrev)
            {
                (*ppBSCBPrev)->Release();
            }

            if (ppBSCBPrev)
            {
                *ppBSCBPrev = pBSCBUnused;
            }
            else
            {
                pBSCBUnused->Release();
            }
        }
    }
    else
    {
        UrlMkAssert((pBSCb != NULL && pBC != NULL && "Invalid argument passed in RegisterBindStatusCallback"));
        hr = E_INVALIDARG;
    }

    PerfDbgLog1(tagUrlApi, NULL, "-RegisterBindStatusCallback(hr:%lx)",hr);
    
    DEBUG_LEAVE_API(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   RevokeBindStatusCallback
//
//  Synopsis:
//
//  Arguments:  [pBC] --
//              [pBSCb] --
//              [reserved] --
//
//  Returns:
//
//  History:    12-13-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI RevokeBindStatusCallback(LPBC pBC, IBindStatusCallback *pBSCb)
{
    DEBUG_ENTER_API((DBG_API,
                    Hresult,
                    "RevokeBindStatusCallback",
                    "%#x, %#x",
                    pBC, pBSCb
                    ));
                    
    HRESULT hr;
    PerfDbgLog2(tagUrlApi, NULL, "+RevokeBindStatusCallback(pBC:%lx, pBSCb:%lx)",pBC,pBSCb);
    CBSCHolder *pCBSCHolder;

    if (pBSCb != NULL && pBC != NULL)
    {
        hr = GetBSCHolder(pBC, &pCBSCHolder);
        if (hr == NOERROR)
        {
            hr = pCBSCHolder->RemoveNode(pBSCb);
            if (hr == S_FALSE)
            {
                // remove the holder from this bind context
                // the holder will be deleted since by the
                // last release
                PerfDbgLog2(tagUrlApi, NULL, "===  RevokeBindStatusCallback Revoke Holder Start (pBndCtx:%lx, -> %lx)",pBC, pBSCb);
                hr = pBC->RevokeObjectParam(REG_BSCB_HOLDER);
                PerfDbgLog2(tagUrlApi, NULL, "===  RevokeBindStatusCallback Revoke Holder Done (pBndCtx:%lx, -> %lx)",pBC, pBSCb);
            }
            else
            {
                hr = NOERROR;
            }
            pCBSCHolder->Release();
        }
    }
    else
    {
        UrlMkAssert((pBSCb != NULL && pBC != NULL && "Invalid argument passed in RevokeBindStatusCallback"));
        hr = E_INVALIDARG;
    }

    PerfDbgLog2(tagUrlApi, NULL, "-RevokeBindStatusCallback(%lx, hr:%lx)",pBSCb, hr);
    
    DEBUG_LEAVE_API(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   GetClassURL
//
//  Synopsis:
//
//  Arguments:  [szURL] --
//              [pClsID] --
//
//  Returns:
//
//
//  Notes:      BUGBUG: do we have to implement this api? Is it really needed?
//
//----------------------------------------------------------------------------
STDAPI GetClassURL(LPCWSTR szURL, CLSID *pClsID)
{
    DEBUG_ENTER_API((DBG_API,
                    Hresult,
                    "GetClassURL",
                    "%.80wq, %#x",
                    szURL, pClsID
                    ));
 
    HRESULT hr = E_NOTIMPL;
    PerfDbgLog(tagUrlApi, NULL, "+GetClassURL");

    PerfDbgLog(tagUrlApi, NULL, "-GetClassURL");
    
    DEBUG_LEAVE_API(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   RegisterMediaTypesW
//
//  Synopsis:   registers a media types for the current apartment
//
//  Arguments:  [ctypes] --
//              [rgszTypes] --
//              [rgcfTypes] --
//
//  Returns:
//
//  History:    1-20-96   JohannP (Johann Posch)   Created
//
//  Notes:      Media types are registered on apartment level
//
//----------------------------------------------------------------------------
HRESULT RegisterMediaTypesW(UINT ctypes, const LPCWSTR* rgszTypes, CLIPFORMAT* rgcfTypes)
{
    DEBUG_ENTER_API((DBG_API,
                    Hresult,
                    "RegisterMediaTypesW",
                    "%u, %#x, %#x",
                    ctypes, rgszTypes, rgcfTypes
                    ));
 
    HRESULT hr = E_NOTIMPL;
    PerfDbgLog(tagUrlApi, NULL, "+RegisterMediaTypesW");
    CMediaTypeHolder *pCMHolder;
    CLock lck(g_mxsMedia);

#ifdef UNUSED
    pCMHolder = GetMediaTypeHolder();

    if (pCMHolder)
    {
        hr = pCMHolder->Register(ctypes, rgszTypes, rgcfTypes);
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
#endif //UNUSED

    PerfDbgLog(tagUrlApi, NULL, "-RegisterMediaTypesW");
    
    DEBUG_LEAVE_API(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   RegisterMediaTypes
//
//  Synopsis:   registers a media types for the current apartment
//
//  Arguments:  [ctypes] --
//              [rgszTypes] --
//              [rgcfTypes] --
//
//  Returns:
//
//  History:    1-20-96   JohannP (Johann Posch)   Created
//
//  Notes:      Media types are registered on apartment level
//
//----------------------------------------------------------------------------
HRESULT RegisterMediaTypes(UINT ctypes, const LPCSTR* rgszTypes, CLIPFORMAT* rgcfTypes)
{
    DEBUG_ENTER_API((DBG_API,
                    Hresult,
                    "RegisterMediaTypes",
                    "%u, %#x, %#x",
                    ctypes, rgszTypes, rgcfTypes
                    ));
 
    HRESULT hr;
    PerfDbgLog(tagUrlApi, NULL, "+RegisterMediaTypes");
    CMediaTypeHolder *pCMHolder;
    CLock lck(g_mxsMedia);

    if (ctypes > 0)
    {
        pCMHolder = GetMediaTypeHolder();

        if (pCMHolder)
        {
            hr = pCMHolder->Register(ctypes, rgszTypes, rgcfTypes);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }


    PerfDbgLog(tagUrlApi, NULL, "-RegisterMediaTypes");
    
    DEBUG_LEAVE_API(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   RegisterMediaTypeClass
//
//  Synopsis:
//
//  Arguments:  [UINT] --
//              [ctypes] --
//              [rgszTypes] --
//              [rgclsID] --
//              [reserved] --
//
//  Returns:
//
//  History:    3-26-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI RegisterMediaTypeClass(LPBC pBC,UINT ctypes,  const LPCSTR* rgszTypes, CLSID *rgclsID, DWORD reserved)
{
    DEBUG_ENTER_API((DBG_API,
                    Hresult,
                    "RegisterMediaTypeClass",
                    "%#x, %u, %#x, %#x, %#x",
                    pBC, ctypes, rgszTypes, rgclsID, reserved
                    ));
 
    HRESULT hr = E_FAIL;
    PerfDbgLog(tagUrlApi, NULL, "+RegisterMediaTypeClass");
    IMediaHolder *pIMHolder = NULL;

    if (ctypes > 0)
    {
        hr = GetObjectParam(pBC, REG_MEDIA_HOLDER, IID_IMediaHolder, (IUnknown**)&pIMHolder);

        if (pIMHolder == NULL)
        {
            pIMHolder = new CMediaTypeHolder();
            if (pIMHolder)
            {
                hr = pBC->RegisterObjectParam(REG_MEDIA_HOLDER, pIMHolder);
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

    if (hr == NOERROR)
    {
        UrlMkAssert((pIMHolder));
        hr = pIMHolder->RegisterClassMapping(ctypes,(const char **) rgszTypes, rgclsID, 0);
    }

    if (pIMHolder)
    {
        pIMHolder->Release();
    }

    PerfDbgLog(tagUrlApi, NULL, "-RegisterMediaTypeClass");
    
    DEBUG_LEAVE_API(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   FindMediaTypeClass
//
//  Synopsis:
//
//  Arguments:  [pBC] --
//              [pszType] --
//              [pclsID] --
//              [reserved] --
//
//  Returns:
//
//  History:    3-26-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI FindMediaTypeClass(LPBC pBC, LPCSTR pszType, CLSID *pclsID, DWORD reserved)
{
    DEBUG_ENTER_API((DBG_API,
                    Hresult,
                    "FindMediaTypeClass",
                    "%#x, %.80q, %#x, %#x",
                    pBC, pszType, pclsID, reserved
                    ));
 
    HRESULT hr = NOERROR;
    PerfDbgLog(tagUrlApi, NULL, "+FindMediaTypeClass");
    IMediaHolder *pIMHolder;
    CLIPFORMAT cfTypes = CF_NULL;

    TransAssert((pclsID));
    *pclsID = CLSID_NULL;

    cfTypes = (CLIPFORMAT) RegisterClipboardFormat(pszType);
    if (cfTypes != CF_NULL)
    {
        hr = GetObjectParam(pBC, REG_MEDIA_HOLDER, IID_IMediaHolder, (IUnknown**)&pIMHolder);

        if (pIMHolder)
        {
            hr = pIMHolder->FindClassMapping(pszType, pclsID, 0);
            pIMHolder->Release();
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

    PerfDbgLog1(tagUrlApi, NULL, "-FindMediaTypeClass (hr:%lx)", hr);
    
    DEBUG_LEAVE_API(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   CreateFormatEnumerator
//
//  Synopsis:
//
//  Arguments:  [cfmtetc] --
//              [rgfmtetc] --
//              [ppenumfmtetc] --
//
//  Returns:
//
//  History:    12-22-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CreateFormatEnumerator( UINT cfmtetc, FORMATETC* rgfmtetc, IEnumFORMATETC** ppenumfmtetc)
{
    DEBUG_ENTER_API((DBG_API,
                    Hresult,
                    "CreateFormatEnumerator",
                    "%u, %#x, %#x",
                    cfmtetc, rgfmtetc, ppenumfmtetc
                    ));
 
    HRESULT hr = NOERROR;
    PerfDbgLog(tagUrlApi, NULL, "+CreateFormatEnumerator");

    if (ppenumfmtetc != NULL)
    {
        CEnumFmtEtc *pCEnum;
        pCEnum = CEnumFmtEtc::Create(cfmtetc, rgfmtetc);
        if (pCEnum)
        {
            *ppenumfmtetc = (IEnumFORMATETC *)pCEnum;
        }
        else
        {
            *ppenumfmtetc = NULL;
            hr = E_FAIL;
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

    PerfDbgLog(tagUrlApi, NULL, "-CreateFormatEnumerator");
    
    DEBUG_LEAVE_API(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   BindAsyncMoniker
//
//  Synopsis:
//
//  Arguments:  [pmk] --
//              [grfOpt] --
//              [iidResult] --
//              [ppvResult] --
//
//  Returns:
//
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI BindAsyncMoniker (LPMONIKER pmk, DWORD grfOpt, IBindStatusCallback *pIBSCb, REFIID iidResult, LPVOID FAR* ppvResult)
{
    DEBUG_ENTER_API((DBG_API,
                    Hresult,
                    "BindAsyncMoniker",
                    "%#x, %#x, %#x, %#x, %#x",
                    pmk, grfOpt, pIBSCb, iidResult, ppvResult
                    ));
 
    VDATEPTROUT(ppvResult,LPVOID);
    *ppvResult = NULL;
    VDATEIFACE(pmk);
    VDATEIID(iidResult);

    LPBC pbc = NULL;
    HRESULT hr = E_INVALIDARG;
    PerfDbgLog1(tagUrlApi, NULL, "+BindAsyncMoniker(%lx)",pmk);

    if (pmk)
    {
        hr = CreateAsyncBindCtx(0, pIBSCb, NULL, &pbc);
        if (hr == NOERROR)
        {
            hr = pmk->BindToObject(pbc, NULL, iidResult, ppvResult);
            pbc->Release();

        }
    }

    PerfDbgLog1(tagUrlApi, NULL, "-BindAsyncMoniker(%lx)",pmk);
    
    DEBUG_LEAVE_API(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   RegisterFormatEnumerator
//
//  Synopsis:
//
//  Arguments:  [pBC] --
//              [pEFetc] --
//              [reserved] --
//
//  Returns:
//
//  History:    1-19-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI RegisterFormatEnumerator(LPBC pBC, IEnumFORMATETC *pEFetc, DWORD reserved)
{
    DEBUG_ENTER_API((DBG_API,
                    Hresult,
                    "RegisterFormatEnumerator",
                    "%#x, %#x, %#x",
                    pBC, pEFetc, reserved
                    ));
 
    HRESULT hr = E_INVALIDARG;
    PerfDbgLog1(tagUrlApi, NULL, "+RegisterFormatEnumerator(%lx)",pBC);

    if (pBC)
    {
        hr = pBC->RegisterObjectParam(REG_ENUMFORMATETC, pEFetc);
    }

    PerfDbgLog1(tagUrlApi, NULL, "-RegisterFormatEnumerator(%lx)",pBC);
    
    DEBUG_LEAVE_API(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   RevokeFormatEnumerator
//
//  Synopsis:
//
//  Arguments:  [pBC] --
//              [pEFetc] --
//
//  Returns:
//
//  History:    1-19-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI RevokeFormatEnumerator(LPBC pBC, IEnumFORMATETC *pEFetc)
{
    DEBUG_ENTER_API((DBG_API,
                    Hresult,
                    "RevokeFormatEnumerator",
                    "%#x, %#x",
                    pBC, pEFetc
                    ));
 
    HRESULT hr = E_INVALIDARG;
    PerfDbgLog1(tagUrlApi, NULL, "+RevokeFormatEnumerator(%lx)",pBC);

    if (pBC)
    {
        hr = pBC->RevokeObjectParam(REG_ENUMFORMATETC);
    }

    PerfDbgLog1(tagUrlApi, NULL, "-RevokeFormatEnumerator(%lx)",pBC);
    
    DEBUG_LEAVE_API(hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\mon\selfreg.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       selfreg.cxx
//
//  Contents:   Taken from Office96
//              Source file for the common self registration code used by all the
//              sub projects of Sweeper project. They are
//              UrlMon
//              UrlMnPrx
//
//  Exports:    HrDllRegisterServer()
//              HrDllUnregisterServer()
//
//  Classes:
//
//  Functions:
//
//  History:    5-03-96   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------
#include <mon.h>
#include "selfreg.hxx"

HINSTANCE g_hinstDll = NULL;
PFNLOADSTRING g_pfnLoadString = NULL;

//+---------------------------------------------------------------------------
//
//  Function:   GetDllFullPath
//
//  Synopsis:
//
//  Arguments:  [lpszExeName] --
//              [cch] --
//
//  Returns:
//
//  History:         95    OfficeXX                 created
//              5-03-96   JohannP (Johann Posch)   port urlmon
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL GetDllFullPath( LPSTR lpszExeName, DWORD cch )
{
    if ( NULL == g_hinstDll )
    {
        UrlMkAssert(( FALSE && "NULL hInst"));
        return FALSE;
    }

    *lpszExeName = NULL;

    if ( GetModuleFileName( g_hinstDll, lpszExeName, cch ) == 0)
    {
        UrlMkAssert(( FALSE && "GetModuleFileName Failed"));
        return FALSE;
    }

    return TRUE;
}


inline BOOL IsASeparator( char ch )
{
    return (ch == '\\' || ch == '/' || ch == ':');
}

//+---------------------------------------------------------------------------
//
//  Function:   ParseAFileName
//
//  Synopsis:
//
//  Arguments:  [szFileName] --
//              [piRetLen] --
//
//  Returns:
//
//  History:         95    OfficeXX                 created
//              5-03-96   JohannP (Johann Posch)   port urlmon
//
//  Notes:
//
//----------------------------------------------------------------------------
LPSTR ParseAFileName( LPSTR szFileName, int *piRetLen)
{
    LPSTR pszFile;

    // Start at the end of the filename.
    pszFile = szFileName + ( lstrlen(szFileName) - 1 );

    // Back up to a '\\' or beginning or something!! We just want a file
    // name!. Whatever comes first.
    while ( pszFile > szFileName && !IsASeparator(*pszFile ) )
        pszFile = CharPrev(szFileName, pszFile);

    if ( pszFile != szFileName )
        pszFile = CharNext(pszFile);

    if ( piRetLen )
        *piRetLen = lstrlen(pszFile);

    return pszFile;
}


//+---------------------------------------------------------------------------
//
//  Function:   FRegisterEntries
//
//  Synopsis:   FRegisterEntries: Register a group of reg entries off a base key.
//
//  Arguments:  [hkRoot] --
//              [rgEntries] --
//              [dwEntries] --
//              [pszPath] --
//              [pszBinderName] --
//
//  Returns:
//
//  History:         95    OfficeXX                 created
//              5-03-96   JohannP (Johann Posch)   port urlmon
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL FRegisterEntries(HKEY hkRoot, const REGENTRY rgEntries[],
                    DWORD dwEntries, char *pszPath, char *pszBinderName)
{
    HKEY    hkey = NULL;
    LONG    lRet;
    char    szValue[1024];
    char    szResString[1024];
    char    szKeyName[1024];
    BOOL    fRet = FALSE;
    int         i;

    for (i = 0; i < (int)dwEntries; i++)
    {
        // We work with a copy of the entry, since we might modify it
        REGENTRY reCurrentEntry = rgEntries[i];

        if (reCurrentEntry.iKeyType ==  KEYTYPE_RESID)
        {
            int cch;
            if (g_pfnLoadString == NULL)
                return FALSE;
            cch = g_pfnLoadString(g_hinstDll, (UINT) PtrToUlong(reCurrentEntry.pszKey), szKeyName,
                    sizeof(szKeyName));
            if (cch > 0 && cch <= 1024)
            {
                reCurrentEntry.pszKey = szKeyName;
            }
            else
            {
                UrlMkAssert(( FALSE && "LoadString Failed ( 1)"));
                continue;
            }
        }

        lRet = RegCreateKey(hkRoot, reCurrentEntry.pszKey, &hkey);

        if (lRet != ERROR_SUCCESS)
        {
            UrlMkAssert(( FALSE && "RegCreateKey Failed ( 1)"));
            continue;
        }

         // If the type is REG_RESID, then pbData holds the resource ID.  We
         // load the resource string, then modify our reCurrentEntry to point
         // to it.

        if (reCurrentEntry.dwType == REG_RESID)
        {
            int cch;
            if (g_pfnLoadString == NULL)
                return FALSE;

            cch = g_pfnLoadString(g_hinstDll, (UINT) PtrToUlong(reCurrentEntry.pbData), szResString,
                    sizeof(szResString));
            if (cch > 0 && cch <= 1024)
            {
                reCurrentEntry.dwType = REG_SZ;
                reCurrentEntry.pbData = (BYTE*) szResString;
            }
            else
            {
                UrlMkAssert(( FALSE && "LoadString Failed (2)"));
                reCurrentEntry.pbData = NULL;
            }
        }


        // Set the value if there is one
        if (reCurrentEntry.pbData != NULL || reCurrentEntry.dwType != REG_SZ)
        {
            switch (reCurrentEntry.dwType)
            {
                case REG_SZ:
                    // Replace the first %s with the path, and the second
                    // %s with the name of the binder app (may not do anything).
                    if (pszPath != NULL && pszBinderName != NULL)
                    {
                        wsprintf(szValue, (char*)reCurrentEntry.pbData, pszPath,
                            pszBinderName);

                        lRet = RegSetValueEx(hkey, reCurrentEntry.pszValueName, 0,
                            REG_SZ, (BYTE*)szValue, lstrlen(szValue)+1);
#if DBG == 1
                        if ( ERROR_SUCCESS != lRet )
                            UrlMkAssert(( FALSE && "RegSetValueEx Failed ( 1)"));
#endif
                    }
                    break;

                case REG_DWORD:
                    lRet = RegSetValueEx(hkey, reCurrentEntry.pszValueName, 0,
                        REG_DWORD,  (BYTE*)&reCurrentEntry.pbData, sizeof(DWORD));

#if DBG == 1
                    if ( ERROR_SUCCESS != lRet )
                        UrlMkAssert(( FALSE && "RegSetValueEx Failed (2)"));
#endif
                    break;

                default:
                    UrlMkAssert(( FALSE && "Unexpected reg entry type"));
                    // Unexpected type: ignore
                    break;
            }
        }

        // Close the subkey
        RegCloseKey(hkey);
        hkey = NULL;
    }

    fRet = TRUE;

    // Close the base key if it was open
    if (hkey)
        RegCloseKey(hkey);

    return fRet;
}


/*
 * FRegisterEntryGroups: Register several groups of reg entries.
 */
BOOL FRegisterEntryGroups(const REGENTRYGROUP *rgRegEntryGroups,
    char *pszPath, char *pszBinderName)
{
    BOOL fError = FALSE;
    int i;

    // Keep going even if we get some errors
    for (i=0; rgRegEntryGroups[i].hkRoot != NULL; i++)
    {
        if (!FRegisterEntries(rgRegEntryGroups[i].hkRoot, rgRegEntryGroups[i].rgEntries,
            rgRegEntryGroups[i].dwEntries,pszPath, pszBinderName))
        {
            fError = TRUE;
        }
    }

    return !fError;
}

//+---------------------------------------------------------------------------
//
//  Function:   FDeleteEntries
//
//  Synopsis:   Delete a group of reg entries off a base key.
//
//  Arguments:  [hkRoot] --
//              [rgEntries] --
//              [dwEntries] --
//
//  Returns:
//
//  History:         95    OfficeXX                 created
//              5-03-96   JohannP (Johann Posch)   port urlmon
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL FDeleteEntries(HKEY hkRoot, const REGENTRY rgEntries[], DWORD dwEntries)
{
    LONG    lRet;
    int         i;
    char    szKeyName[1024];
    PSTR    pKey;

    // Delete in reverse order, to kill children before parent
    for (i = (int)dwEntries - 1; i >= 0; i--)
    {
        pKey = NULL;

        if (rgEntries[i].iKeyType ==  KEYTYPE_RESID)
        {
            int cch;
            cch = g_pfnLoadString(g_hinstDll, (UINT) PtrToUlong(rgEntries[i].pszKey), szKeyName,
                    sizeof(szKeyName));
            if (cch > 0 && cch <= 1024)
            {
                pKey = szKeyName;
            }
        else
            {
                UrlMkAssert(( FALSE && "LoadString Failed (FDeleteEntries)"));
                continue;
            }
        }
        else
        {
            if ( KEYTYPE_STRING != rgEntries[i].iKeyType )
            {
                UrlMkAssert(( FALSE && "Unknown Key Type"));
                continue;
            }
            pKey = rgEntries[i].pszKey;
        }

        if (pKey != NULL)
        {
            // Delete the current key if it has no subkeys.
            // Ignore the return value.
            lRet = RegDeleteKey(hkRoot, pKey);
        }
    }

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Function:   FDeleteEntryGroups
//
//  Synopsis:   Delete the base keys of all the given groups.

//
//  Arguments:  [rgRegEntryGroups] --
//
//  Returns:
//
//  History:         95    OfficeXX                 created
//              5-03-96   JohannP (Johann Posch)   port urlmon
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL FDeleteEntryGroups(const REGENTRYGROUP *rgRegEntryGroups)
{
    BOOL fError = FALSE;

    // Keep going even if we get some errors
    for (int i=0; rgRegEntryGroups[i].hkRoot != NULL; i++)
    {
        if (!FDeleteEntries(rgRegEntryGroups[i].hkRoot,
            rgRegEntryGroups[i].rgEntries,
            rgRegEntryGroups[i].dwEntries))
        {
            fError = TRUE;
        }
    }

    return !fError;
}


#ifdef NOT_USED
/*
 * FDeleteSubtree - Delete given key and all subkeys
 */
BOOL FDeleteSubtree(HKEY hkRoot, char *pszKey)
{
    HKEY        hkey = NULL;
    LONG        lRet;
    char        szSubKey[MAX_PATH];

    lRet = RegOpenKey(hkRoot, pszKey, &hkey);
    if (lRet != ERROR_SUCCESS)
        goto End;

    // remove all subkeys
    for (;;)
{
        lRet = RegEnumKey(hkey, 0, szSubKey, sizeof szSubKey);

        if (lRet == ERROR_NO_MORE_ITEMS)
            break;

        if (lRet != ERROR_SUCCESS)
            goto End;

        if (!FDeleteSubtree(hkey, szSubKey))
            goto End;
}

End:
    if (hkey != NULL)
        RegCloseKey (hkey);

    lRet = RegDeleteKey(hkRoot, pszKey);

    return (lRet == ERROR_SUCCESS);
}
#endif // NOT_USED



//+---------------------------------------------------------------------------
//
//  Function:   HrDllRegisterServer
//
//  Synopsis:   registers an entrygroup
//
//  Arguments:  [HINSTANCE] --
//              [hinstDll] --
//              [pfnLoadString] --
//              [pszAppName] --
//
//  Returns:
//
//  History:         95    OfficeXX                 created
//              5-03-96   JohannP (Johann Posch)   port urlmon
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT HrDllRegisterServer(const REGENTRYGROUP *rgRegEntryGroups,HINSTANCE hinstDll,
                            PFNLOADSTRING pfnLoadString, char *pszAppName)
{
    // REVIEW: for Windows dll, do we want to register full path?
    BOOL    fRet = TRUE;
    char    szFullPath[MAX_PATH];
    char    szFileName[MAX_PATH];
    char    *pszFileName;

    g_hinstDll = hinstDll;
    if ((g_pfnLoadString = pfnLoadString) == NULL)
        // set the pointer to windows LoadString() api
        g_pfnLoadString = (PFNLOADSTRING) LoadString;

    if (!GetDllFullPath(szFullPath, MAX_PATH))
        return E_FAIL;

    pszFileName = ParseAFileName(szFullPath, NULL);

    if (pszAppName != NULL)
        lstrcpy(szFileName, pszAppName);
    else
        lstrcpy(szFileName, pszFileName);

    // Terminate the path at the file name
    *pszFileName = '\0';
#ifdef UNIX
    /* On Unix, we find the location of the dll using LD_LIBRARY_PATH
     * which is included in the wrapper script
     * So, we do not want to specify the whole path for the dll in the
     * registry.
     */
    *szFullPath = '\0';
#endif /* UNIX */
    fRet = FRegisterEntryGroups(rgRegEntryGroups, szFullPath, szFileName);

    g_hinstDll = NULL;
    g_pfnLoadString = NULL;
    return fRet ? NOERROR : E_FAIL;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrDllUnregisterServer
//
//  Synopsis:   unregisters an entrygroup
//
//  Arguments:  [HINSTANCE] --
//              [hinstDll] --
//              [pfnLoadString] --
//
//  Returns:
//
//  History:         95    OfficeXX                 created
//              5-03-96   JohannP (Johann Posch)   port urlmon
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT HrDllUnregisterServer(const REGENTRYGROUP *rgRegEntryGroups,HINSTANCE hinstDll, PFNLOADSTRING pfnLoadString)
{
    g_hinstDll = hinstDll;
    if ((g_pfnLoadString = pfnLoadString) == NULL)
        // set the pointer to windows LoadString() api
        g_pfnLoadString = (PFNLOADSTRING) LoadString;

    FDeleteEntryGroups(rgRegEntryGroups);

    g_hinstDll = NULL;
    g_pfnLoadString = NULL;

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\mon\urlcf.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       urlcf.cxx
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    12-22-95   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------
#include <mon.h>
#include <eapp.h>
#include "urlcf.hxx"
#ifndef unix
#include "..\eapp\protbase.hxx"
#include "..\trans\urlmk.hxx"
#include "..\trans\bindctx.hxx"
#include "..\trans\oinet.hxx"
#include "..\download\cdl.h"
#else
#include "../eapp/protbase.hxx"
#include "../trans/urlmk.hxx"
#include "../trans/bindctx.hxx"
#include "../trans/oinet.hxx"
#include "../download/cdl.h"
#endif /* unix */

//+---------------------------------------------------------------------------
//
//  Method:     CUrlClsFact::Create
//
//  Synopsis:
//
//  Arguments:  [clsid] --
//              [ppCF] --
//
//  Returns:
//
//  History:    12-22-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CUrlClsFact::Create(REFCLSID clsid, CUrlClsFact **ppCF)
{
    UrlMkDebugOut((DEB_URLMON, "NULL _IN CUrlClsFact::Create\n"));
    HRESULT hr = NOERROR;
    CUrlClsFact * pCF =  NULL;

    DWORD dwId = IsKnownOInetProtocolClass( (CLSID*)&clsid );

    if (   (dwId != DLD_PROTOCOL_NONE)
        || (clsid == CLSID_StdURLMoniker)
        || (clsid == CLSID_UrlMkBindCtx)
        || (clsid == CLSID_StdURLProtocol)
        || (clsid == CLSID_SoftDistExt)
        || (clsid == CLSID_DeCompMimeFilter)
        || (clsid == CLSID_StdEncodingFilterFac)
        || (clsid == CLSID_ClassInstallFilter)
        || (clsid == CLSID_CdlProtocol)
        || (clsid == CLSID_InternetSecurityManager)
        || (clsid == CLSID_InternetZoneManager)
       )
    {
        pCF = (CUrlClsFact *) new CUrlClsFact(clsid, dwId);
    }

    if (pCF == NULL)
    {
        hr = E_OUTOFMEMORY;
    }
    else
    {
        *ppCF = pCF;
    }

    UrlMkDebugOut((DEB_URLMON, "%p OUT CUrlClsFact::Create (hr:%lx\n", pCF,hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CUrlClsFact::CUrlClsFact
//
//  Synopsis:   constructor
//
//  Arguments:  [clsid] --
//
//  Returns:
//
//  History:    12-22-95   JohannP (Johann Posch)   Created
//
//  Notes:      we need to keep a refcount on the dll if for each object given to
//              outside, including ClassFactories.
//              The corresponding DllRelease is in the destructor
//
//----------------------------------------------------------------------------
CUrlClsFact::CUrlClsFact(REFCLSID clsid, DWORD dwId) : _CRefs(), _CLocks(0)
{
    _ClsID =  clsid;
    _dwId = dwId;

    DllAddRef();
}

//+---------------------------------------------------------------------------
//
//  Method:     CUrlClsFact::~CUrlClsFact
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    12-22-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
CUrlClsFact::~CUrlClsFact()
{
    DllRelease();
}

//+---------------------------------------------------------------------------
//
//  Method:     CUrlClsFact::CreateInstance
//
//  Synopsis:   creates an instance of an Explode Object
//
//  Arguments:  [pUnkOuter] -- controlling unknown (must be NULL)
//              [riid] --      id of desired interface
//              [ppv] --       pointer to receive the interface
//
//  Returns:
//
//  History:    12-22-95   JohannP (Johann Posch)   Created
//
//  Notes:      S_OK - success
//              CLASS_E_NOAGGREATION - the caller tried to aggregate
//              CLASS_E_CLASSNOTAVAILABLE - couldn't initialize the class
//              E_OUTOFMEMORY - not enough memory to instantiate class
//
//----------------------------------------------------------------------------
STDMETHODIMP CUrlClsFact::CreateInstance(LPUNKNOWN pUnkOuter, REFIID riid, LPVOID * ppv)
{
    //UrlMkDebugOut((DEB_URLMON, "%p _IN CUrlClsFact::CreateInstance\n", this));
    HRESULT hr = NOERROR;
    // Class factory init time, the pointer to the creation function of
    // the object is given.  Use that to create the object

    //DumpIID(riid);
    //DumpIID(_rClsID);

    if (riid == IID_IClassFactory)
    {
        *ppv = (IClassFactory *)this;
        AddRef();
    }
    else if (_dwId != DLD_PROTOCOL_NONE)
    {
        hr = CreateKnownProtocolInstance(_dwId, _ClsID, pUnkOuter, riid, (IUnknown **)ppv);
    }
    else if (_ClsID == CLSID_StdURLMoniker)
    {
        CUrlMon * pMnk = NULL;
        LPWSTR szUrl = NULL;

        if ((pMnk = new CUrlMon(szUrl)) != NULL)
        {
            hr = pMnk->QueryInterface(riid, ppv);
            pMnk->Release();
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }

    }
    else if (_ClsID == CLSID_UrlMkBindCtx)
    {
        CBindCtx *pCBCtx = NULL;

        hr = CBindCtx::Create(&pCBCtx);

        if (hr == NOERROR)
        {
            TransAssert((pCBCtx));
            hr = pCBCtx->QueryInterface(riid, ppv);
            pCBCtx->Release();
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }

    }
    else if (_ClsID == CLSID_StdURLProtocol)
    {
        // BUGBUG: add protocol here

    }
    else if (_ClsID == CLSID_InternetSecurityManager)
    {
        hr = InternetCreateSecurityManager(pUnkOuter, riid, ppv, 0);
    }
    else if (_ClsID == CLSID_InternetZoneManager)
    {
        hr = InternetCreateZoneManager(pUnkOuter, riid, ppv, 0);
    }
    else if (_ClsID == CLSID_SoftDistExt)
    {
        CSoftDist * pSoftDist = NULL;

        if ((pSoftDist = new CSoftDist()) != NULL)
        {
            hr = pSoftDist->QueryInterface(riid, ppv);
            pSoftDist->Release();
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }

    }
    else if( _ClsID == CLSID_DeCompMimeFilter)
    {
        hr = CLASS_E_CLASSNOTAVAILABLE;
        if( pUnkOuter)
            hr = CLASS_E_NOAGGREGATION;
        else
        {
            CMimeFt*    pMft = NULL;
            hr = CMimeFt::Create(&pMft);
            if( (hr == NOERROR) && pMft )
            {
                hr = pMft->QueryInterface(riid, ppv);
                pMft->Release();
            }
        }
    }
    else if( _ClsID == CLSID_StdEncodingFilterFac)
    {
        hr = CLASS_E_CLASSNOTAVAILABLE;
        if( pUnkOuter)
            hr = CLASS_E_NOAGGREGATION;
        else
        {
            *ppv = NULL;
            *ppv = new CEncodingFilterFactory;
            if( *ppv == NULL )
                hr = E_OUTOFMEMORY;
            else
                hr = ((IEncodingFilterFactory*)(*ppv))->AddRef();                
        }
    
    }
    else if( _ClsID == CLSID_ClassInstallFilter)
    {
        hr = CLASS_E_CLASSNOTAVAILABLE;
        if (pUnkOuter)
            hr = CLASS_E_NOAGGREGATION;
        else
        {
            CClassInstallFilter *pCIF = NULL;
            pCIF = new CClassInstallFilter();
            *ppv = (LPVOID)(IOInetProtocol *)pCIF;
            if (!*ppv)
                hr = E_OUTOFMEMORY;
            else
                hr = S_OK;
        }
    }
    else if (_ClsID == CLSID_CdlProtocol)
    {
        hr = CreateAPP(_ClsID, pUnkOuter, riid, (IUnknown **)ppv);
    }

    UrlMkDebugOut((DEB_URLMON, "%p OUT CUrlClsFact::CreateInstance (hr:%lx)\n", this,hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CUrlClsFact::LockServer
//
//  Synopsis:   locks the server, preventing it from being unloaded
//
//  Arguments:  [fLock] -- TRUE to lock, FALSE to unlock
//
//  Returns:
//
//  History:    12-22-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CUrlClsFact::LockServer(BOOL fLock)
{
    UrlMkDebugOut((DEB_URLMON, "%p _IN CUrlClsFact::LockServer\n", this));
    HRESULT hr = NOERROR;
    if (fLock)
    {
        if (++_CLocks == 1)
        {
            DllAddRef();
        }
    }
    else
    {
        UrlMkAssert((_CLocks > 0));
        if (_CLocks > 0)
        {
            if (--_CLocks == 0)
            {
                DllRelease();
            }
        }
    }

    UrlMkDebugOut((DEB_URLMON, "%p OUT CUrlClsFact::LockServer (hr:%lx)\n", this,hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CUrlClsFact::QueryInterface
//
//  Synopsis:
//
//  Arguments:  [riid] --
//              [ppvObj] --
//
//  Returns:
//
//  History:    12-22-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CUrlClsFact::QueryInterface(REFIID riid, void **ppvObj)
{
    VDATEPTROUT(ppvObj, void *);
    HRESULT hr = NOERROR;
    UrlMkDebugOut((DEB_URLMON, "%p _IN CUrlClsFact::QueryInterface\n", this));

    if (   riid == IID_IUnknown
        || riid == IID_IClassFactory)
    {
        *ppvObj = this;
    }
    else
    {
        *ppvObj = NULL;
        hr = E_NOINTERFACE;
    }
    if (hr == NOERROR)
    {
        AddRef();
    }

    UrlMkDebugOut((DEB_URLMON, "%p OUT CUrlClsFact::QueryInterface (hr:%lx\n", this,hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   CUrlClsFact::AddRef
//
//  Synopsis:
//
//  Arguments:  [ULONG] --
//
//  Returns:
//
//  History:    12-22-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CUrlClsFact::AddRef(void)
{
    UrlMkDebugOut((DEB_URLMON, "%p _IN CUrlClsFact::AddRef\n", this));

    LONG lRet = ++_CRefs;

    UrlMkDebugOut((DEB_URLMON, "%p OUT CUrlClsFact::AddRef (cRefs:%ld)\n", this,lRet));
    return lRet;
}

//+---------------------------------------------------------------------------
//
//  Function:   CUrlClsFact::Release
//
//  Synopsis:
//
//  Arguments:  [ULONG] --
//
//  Returns:
//
//  History:    12-22-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CUrlClsFact::Release(void)
{
    UrlMkDebugOut((DEB_URLMON, "%p _IN CUrlClsFact::Release\n", this));

    LONG lRet = --_CRefs;

    if (_CRefs == 0)
    {
        delete this;
    }

    UrlMkDebugOut((DEB_URLMON, "%p OUT CUrlClsFact::Release (cRefs:%ld)\n", this,lRet));
    return lRet;
}

#if DBG==1
HRESULT DumpIID(REFIID riid)
{

    HRESULT hr;
    LPOLESTR pszStr = NULL;
    hr = StringFromCLSID(riid, &pszStr);
    UrlMkDebugOut((DEB_BINDING, "API >>> DumpIID (riid:%ws) \n", pszStr));

    if (pszStr)
    {
        delete pszStr;
    }
    return hr;
}
#endif


#ifdef FOR_SHDOCVW
//+---------------------------------------------------------------------------
//
//  Function:   GetObjectOffFileMoniker
//
//  Synopsis:   tries to create on object using a file moniker
//              this is a work around for OLE
//
//  Arguments:  [pMnk] --
//              [REFIID] --
//              [riid] --
//              [ppv] --
//
//  Returns:
//
//  History:    3-10-96   JohannP (Johann Posch)   Created
//
//  Notes:      See comments inside function
//
//----------------------------------------------------------------------------
HRESULT GetObjectOffFileMoniker(IMoniker *pMnk, IBindCtx *pbc,REFIID riid, void **ppv)
{
    HRESULT hr = E_FAIL;
    DWORD dwMnk;
    LPWSTR      wzFilename = NULL;
    CLSID       * pClsID = NULL;
    IUnknown    * pUnk = NULL;
    IPersistFile *pPersistFile = NULL;
    BIND_OPTS     bindopts;

    bindopts.cbStruct = sizeof(BIND_OPTS);
    hr = pbc->GetBindOptions(&bindopts);


    pMnk->IsSystemMoniker(&dwMnk);

    if (dwMnk != MKSYS_FILEMONIKER)
    {
        goto Done;
    }

    //get path and filename
    hr = pMnk->GetDisplayName(NULL, NULL, &wzFilename);
    if (wzFilename == NULL)
    {
        goto Done;
    }

    // try to find class
    hr = GetClassFile(wzFilename, pClsID);
    if (hr != NOERROR)
    {
        goto Done;
    }

    // create object
    hr = CoCreateInstance(*pClsID, NULL, CLSCTX_INPROC_SERVER |CLSCTX_LOCAL_SERVER,
                            riid, (void**)&pUnk);

    if (hr != NOERROR)
    {
        goto Done;
    }

    // ask for the IPersistFile interface
    hr = pUnk->QueryInterface(IID_IPersistFile, (void**)&pPersistFile);
    if (hr != NOERROR)
    {
        goto Done;
    }
    // load the object
    hr = pPersistFile->Load(wzFilename, bindopts.grfMode);

Done:
    if (hr != NOERROR)
    {
        if (pUnk)
        {
            pUnk->Release();
        }
    }
    else
    {
        *ppv = (void *)pUnk;
    }

    if (pPersistFile)
    {
        pPersistFile->Release();
    }
    if (pClsID)
    {
        delete pClsID;
    }
    if (wzFilename)
    {
        delete wzFilename;
    }

    return hr;
}
#endif //FOR_SHDOCVW
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\perf\condown\condown.cpp ===
#undef UNICODE
#include "urlmon.h"
#include "wininet.h"
#include "commctrl.h"
#include "windows.h"
#include <stdio.h>
#include "initguid.h"
#include "hlink.h"
///#include "hlguids.h"

#ifdef PRODUCT_PROF
extern "C" void _stdcall StartCAP(void);
extern "C" void _stdcall StopCAP(void);
extern "C" void _stdcall SuspendCAP(void);
extern "C" void _stdcall ResumeCAP(void);
extern "C" void _stdcall StartCAPAll(void);
extern "C" void _stdcall StopCAPAll(void);
#else
#define StartCAP()
#define StopCAP()
#define SuspendCAP()
#define ResumeCAP()
#define StartCAPAll()
#define StopCAPAll()
#endif

typedef BOOL (WINAPI *PFNSPA)(HANDLE, DWORD);
typedef HRESULT (WINAPI * pfnCreateURLMoniker)(IMoniker *, LPCWSTR, IMoniker **);
typedef HRESULT (WINAPI * pfnRegisterBindStatusCallback)(LPBC, IBindStatusCallback *, IBindStatusCallback **, DWORD);

typedef struct
{
    TCHAR*   pBuf;      //Actual buffer to hold data
    DWORD    lNumRead;  //number of bytes read in buffer
    void*    pNext;     //Pointer to next buffer
} buffer;


HINSTANCE g_hUrlMon = NULL;
pfnCreateURLMoniker g_pfnCreateURLMoniker = NULL;
pfnRegisterBindStatusCallback g_pfnRegisterBindStatusCallback = NULL;

#define _HRESULT_TYPEDEF_(_sc) ((HRESULT)_sc)

#define DO_DOWNLOAD   WM_USER + 10
#define DOWNLOAD_DONE WM_USER + 11

#pragma warning(disable:4100)

// ---------------------------------------------------------------------------
#define DBG_ERROR            0x80000000

// verbose flags
#define DBG_RESULTS          0x01
#define DBG_DEBUG            0x02
#define DBG_INFO             0x04
#define DBG_STARTBINDING     0x08
#define DBG_STOPBINDING      0x10
#define DBG_ONPROGRESS       0x20
#define DBG_ONAVAIL          0x40
#define DBG_BREAKONERROR     0x80

#define DBG_ALLVALID         DBG_RESULTS | DBG_DEBUG | DBG_STARTBINDING | DBG_STOPBINDING | DBG_ONPROGRESS | DBG_ONAVAIL

DWORD g_dwDbgFlags = DBG_RESULTS;
// ---------------------------------------------------------------------------

const INT MAX_BUF_SIZE = 1024 * 16;
const INT BUF_SIZE = 2 * 1024;
const INT URL_MAX = 4;
const INT BUF_NUM = 16*4;
const DWORD TIMEOUT = 10000000;
const INT LDG_DONE = 1;
const INT LDG_STARTED = 0;
const INT PRI_LOW = 1;
const INT PRI_MED = 2;
const INT PRI_HI  = 3;

DWORD dwBegin_Time = 0;
DWORD dwEnd_Time;
DWORD dwTot_Time;
BOOL bDelim = FALSE;
DWORD dwNum_Opens = 1;
DWORD dwBuf_Size = BUF_SIZE;
DWORD dwBytes_Read = 0;
DWORD dwMax_Simul_Downloads = URL_MAX;
DWORD g_dwCacheFlag = BINDF_NOWRITECACHE | BINDF_GETNEWESTVERSION;
char *pFilename = NULL;
char *pInFile = NULL;
char *g_pRunStr = NULL;
char *g_pTestName = NULL;
char g_CmdLine[1024];
TCHAR sUrl[(INTERNET_MAX_URL_LENGTH+1)];
TCHAR* g_pBuf = NULL;

// %%Classes: ----------------------------------------------------------------

class CInfo 
{
public:
    CInfo();
    ~CInfo();
    INT      incDownloads(void) { return m_iDownloads++; }
    INT      decDownloads(void) { return m_iDownloads--; }
    INT      getDownloads(void) { return m_iDownloads; }

    HANDLE           m_hCompleteEvent;
    CRITICAL_SECTION m_csInfo;        //for critical section
    HANDLE           m_hMaxDownloadSem;
    buffer*          m_pPool;         //Pointer to current available buffer in pool
    void*            m_pdFirst;       //pointer to the first element
private:
    INT              m_iDownloads;    //number of current downloads
};

class CDownload 
{
  public:
    CDownload(LPSTR sName, CInfo* pcInfo);
    ~CDownload();
    HRESULT      doDownload(void);
    INT          getStatus(void) { return m_iStatus; }
    INT          getPriority(void) { return m_iPriority; }
#ifdef USE_POOL
    INT          releasePool(void);
#endif

    WCHAR                m_pUrl[(INTERNET_MAX_URL_LENGTH+1)];
#ifdef USE_POOL    
    buffer*              m_pbStartBuffer; //first buffer to hold data
    buffer*              m_pbCurBuffer;   //Current Buffer
#endif    
    CInfo*               m_pcInfo;  
    void*                m_pdNext;        //pointer to next element
    INT                  m_iStatus;       //the url's status
    INT                  m_iPriority;     //the url's priority
    DWORD                lNumRead;  //number of bytes read in buffer for this download
    
  private:
    IMoniker*            m_pMoniker;
    IBindCtx*            m_pBindCtx;
    IBindStatusCallback* m_pBindCallback;
};


class CBindStatusCallback : public IBindStatusCallback 
{
  public:
    // IUnknown methods
    STDMETHODIMP    QueryInterface(REFIID riid,void ** ppv);
    STDMETHODIMP_(ULONG)    AddRef()    { return m_cRef++; }
    STDMETHODIMP_(ULONG)    Release()   { if (--m_cRef == 0) { delete this; return 0; } return m_cRef; }

    // IBindStatusCallback methods
    STDMETHODIMP    OnStartBinding(DWORD dwReserved, IBinding* pbinding);
    STDMETHODIMP    GetPriority(LONG* pnPriority);
    STDMETHODIMP    OnLowResource(DWORD dwReserved);
    STDMETHODIMP    OnProgress(ULONG ulProgress, ULONG ulProgressMax, ULONG ulStatusCode,
                        LPCWSTR pwzStatusText);
    STDMETHODIMP    OnStopBinding(HRESULT hrResult, LPCWSTR szError);
    STDMETHODIMP    GetBindInfo(DWORD* pgrfBINDF, BINDINFO* pbindinfo);
    STDMETHODIMP    OnDataAvailable(DWORD grfBSCF, DWORD dwSize, FORMATETC *pfmtetc,
                        STGMEDIUM* pstgmed);
    STDMETHODIMP    OnObjectAvailable(REFIID riid, IUnknown* punk);

    // constructors/destructors
    CBindStatusCallback(CDownload* pcDownload);
    ~CBindStatusCallback();

    
    // data members
    DWORD           m_cRef;
    IBinding*       m_pBinding;
    IStream*        m_pStream;
    DWORD           m_cbOld;
    CDownload*      m_pcDownload;
};


// ---------------------------------------------------------------------------
// ---------------------------------------------------------------------------
INT dprintf(DWORD dwFlags, TCHAR *fmt, ... ) 
{
    INT      ret = 0;
    va_list  marker;
    TCHAR     szBuffer[256];

    if(dwFlags & (g_dwDbgFlags | DBG_ERROR))
    {
        va_start( marker, fmt );
        ret = vsprintf( szBuffer, fmt, marker );
        OutputDebugString( szBuffer );
        printf(szBuffer);

        if(g_dwDbgFlags & DBG_BREAKONERROR)
            DebugBreak();
    }
    return ret; 
}

// ---------------------------------------------------------------------------
// ---------------------------------------------------------------------------
void SetSingleProcessorAffinity()
{
    PFNSPA pfn;

    pfn = (PFNSPA)GetProcAddress(GetModuleHandleA("KERNEL32.DLL"),
            "SetProcessAffinityMask");

    if (pfn)
    {
        pfn(GetCurrentProcess(), 1);
    }
}


// ---------------------------------------------------------------------------
// ---------------------------------------------------------------------------
HRESULT LoadUrlMon()
{
    g_hUrlMon = (HINSTANCE)LoadLibraryA("URLMON.DLL");

    if (g_hUrlMon == NULL)
    {
        dprintf(DBG_ERROR, "LoadLibraryA of URLMON.DLL failed\n");
        return(E_FAIL);
    }

    g_pfnCreateURLMoniker = (pfnCreateURLMoniker)GetProcAddress(g_hUrlMon, "CreateURLMoniker");
    
    if (g_pfnCreateURLMoniker == NULL)
    {
        dprintf(DBG_ERROR, "GetProcAddress CreateURLMoniker failed\n");
        return(E_FAIL);
    }

    g_pfnRegisterBindStatusCallback = (pfnRegisterBindStatusCallback)GetProcAddress(g_hUrlMon, "RegisterBindStatusCallback");

    if (g_pfnRegisterBindStatusCallback == NULL)
    {
        dprintf(DBG_ERROR, "GetProcAddress RegisterBindStatusCallback failed\n");
        return(E_FAIL);
    }

    return(S_OK);
}

// ---------------------------------------------------------------------------
// ---------------------------------------------------------------------------
void UnloadUrlMon()
{
    if (g_hUrlMon)
    {
        FreeLibrary(g_hUrlMon);
    }
}

// ===========================================================================
//                     CBindStatusCallback Implementation
// ===========================================================================

// ---------------------------------------------------------------------------
// %%Function: CBindStatusCallback::CBindStatusCallback
// ---------------------------------------------------------------------------
CBindStatusCallback::CBindStatusCallback(CDownload* pcDownload)
{
    m_pBinding = NULL;
    m_pStream = NULL;
    m_cRef = 1;
    m_cbOld = 0;
    m_pcDownload = pcDownload;
}  // CBindStatusCallback

// ---------------------------------------------------------------------------
// %%Function: CBindStatusCallback::~CBindStatusCallback
// ---------------------------------------------------------------------------
CBindStatusCallback::~CBindStatusCallback()
{
}  // ~CBindStatusCallback

// ---------------------------------------------------------------------------
// %%Function: CBindStatusCallback::QueryInterface
// ---------------------------------------------------------------------------
 STDMETHODIMP
CBindStatusCallback::QueryInterface(REFIID riid, void** ppv)
{
    *ppv = NULL;

    if (riid==IID_IUnknown || riid==IID_IBindStatusCallback) 
    {
        *ppv = this;
        AddRef();
        return S_OK;    
    }
    return E_NOINTERFACE;
 }  // CBindStatusCallback::QueryInterface

 // ---------------------------------------------------------------------------
 // %%Function: CBindStatusCallback::OnStartBinding
 // ---------------------------------------------------------------------------
 STDMETHODIMP CBindStatusCallback::OnStartBinding(DWORD dwReserved, IBinding* pBinding)
 {
    if (m_pBinding != NULL)
        m_pBinding->Release();

    m_pBinding = pBinding;

    if (m_pBinding != NULL) 
        m_pBinding->AddRef();

    m_pcDownload->m_pcInfo->incDownloads();

    if(g_dwDbgFlags)    
        dprintf(DBG_STOPBINDING, "OnStartBinding getDownloads()=%d\n", m_pcDownload->m_pcInfo->getDownloads());
    return S_OK;

 }  // CBindStatusCallback::OnStartBinding

 // ---------------------------------------------------------------------------
 // %%Function: CBindStatusCallback::GetPriority
 // ---------------------------------------------------------------------------
 STDMETHODIMP CBindStatusCallback::GetPriority(LONG* pnPriority)
 {
     return E_NOTIMPL;
 }  // CBindStatusCallback::GetPriority

 // ---------------------------------------------------------------------------
 // %%Function: CBindStatusCallback::OnLowResource
 // ---------------------------------------------------------------------------
 STDMETHODIMP CBindStatusCallback::OnLowResource(DWORD dwReserved)
 {
     return E_NOTIMPL;
 }  // CBindStatusCallback::OnLowResource

 // ---------------------------------------------------------------------------
 // %%Function: CBindStatusCallback::OnProgress
 // ---------------------------------------------------------------------------
 
STDMETHODIMP CBindStatusCallback::OnProgress(ULONG ulProgress, ULONG ulProgressMax, ULONG ulStatusCode, LPCWSTR szStatusText)
{
    TCHAR sz[255];
    if(szStatusText != NULL) {
         WideCharToMultiByte(CP_ACP, 0, szStatusText, -1, sz, 255,0,0);
    }
    if(g_dwDbgFlags)    
        dprintf(DBG_ONPROGRESS, "OnProgress: %d(%s) %d of %d\n", ulStatusCode, sz, ulProgress, (ulProgress>ulProgressMax)?ulProgress:ulProgressMax);
    return(NOERROR);
}  // CBindStatusCallback::OnProgress

 // ---------------------------------------------------------------------------
 // %%Function: CBindStatusCallback::OnStopBinding
 // ---------------------------------------------------------------------------
 STDMETHODIMP CBindStatusCallback::OnStopBinding(HRESULT hrStatus, LPCWSTR pszError)
 {
     if (hrStatus != S_OK) 
     {
        if(g_dwDbgFlags & DBG_DEBUG)
        {
             TCHAR sUrl[(INTERNET_MAX_URL_LENGTH+1)];
             TCHAR sErr[1024];
             WideCharToMultiByte(CP_ACP, 0, m_pcDownload->m_pUrl, -1, 
                 sUrl, INTERNET_MAX_URL_LENGTH, 0, 0);
             WideCharToMultiByte(CP_ACP, 0, pszError, -1, 
                sErr, 1024, 0, 0);
             dprintf(DBG_ERROR, "*** ERROR *** %s OnStopBinding download failed. Status=%x Err=%s\n", sUrl, hrStatus, sErr);
         }
     }
     if (m_pBinding)	
     {
         m_pBinding->Release();
         m_pBinding = NULL;
     }
     
     m_pcDownload->m_pcInfo->decDownloads();
     if(g_dwDbgFlags)    
        dprintf(DBG_STOPBINDING, "OnStopBinding hrStatus=%d getDownloads()=%d\n", hrStatus, m_pcDownload->m_pcInfo->getDownloads());

     if(m_pcDownload->m_pcInfo->getDownloads() == 0) 
     {
         SetEvent(m_pcDownload->m_pcInfo->m_hCompleteEvent);
     }         

     return S_OK;
 }  // CBindStatusCallback::OnStopBinding


 // ---------------------------------------------------------------------------
 // %%Function: CBindStatusCallback::GetBindInfo
 // ---------------------------------------------------------------------------
 STDMETHODIMP CBindStatusCallback::GetBindInfo(DWORD* pgrfBINDF, BINDINFO* pBindInfo)
 {
     *pgrfBINDF = BINDF_ASYNCHRONOUS | BINDF_ASYNCSTORAGE | BINDF_PULLDATA;
     *pgrfBINDF |= g_dwCacheFlag;
     pBindInfo->cbSize = sizeof(BINDINFO);
     pBindInfo->szExtraInfo = NULL;
     memset(&pBindInfo->stgmedData, 0, sizeof(STGMEDIUM));
     pBindInfo->grfBindInfoF = 0;
     pBindInfo->dwBindVerb = BINDVERB_GET;
     pBindInfo->szCustomVerb = NULL;
     return S_OK;
 }  // CBindStatusCallback::GetBindInfo

 // ---------------------------------------------------------------------------
 // %%Function: CBindStatusCallback::OnDataAvailable
 // ---------------------------------------------------------------------------
 
 
STDMETHODIMP CBindStatusCallback::OnDataAvailable(DWORD grfBSCF, DWORD dwSize, FORMATETC* pfmtetc, STGMEDIUM* pstgmed)
{
    DWORD dwRead = dwSize - m_cbOld; // Amount to be read
    HRESULT hr = S_OK;

     // Get the Stream passed

     if(g_dwDbgFlags)
        dprintf(DBG_ONAVAIL, "OnDataAvailable(grfBSCF=%d pStream=0x%x dwRead=%d dwSize=%d pfmtetc=0x%x, pstgmed=0x%x\n",
            grfBSCF, m_pStream, dwRead, dwSize, pfmtetc, pstgmed);
    
     if (!m_pStream && pstgmed->tymed == TYMED_ISTREAM)
     {
         m_pStream = pstgmed->pstm;
     }

     // If there is some data to be read then go ahead and read
     if (m_pStream && dwRead) 
     {
         while(hr!=E_PENDING) 
         {
#ifdef USE_POOL    
             if(m_pcDownload->m_pcInfo->m_pPool) 
             {
                 //if pool ready
                 EnterCriticalSection(&(m_pcDownload->m_pcInfo->m_csInfo));    
                 if(!m_pcDownload->m_pbStartBuffer) 
                 {    
                     // if the first time
                     m_pcDownload->m_pbStartBuffer = 
                         m_pcDownload->m_pbCurBuffer = 
                         m_pcDownload->m_pcInfo->m_pPool;
                     m_pcDownload->m_pcInfo->m_pPool = 
                         (buffer *)m_pcDownload->m_pcInfo->m_pPool->pNext;
                     m_pcDownload->m_pbStartBuffer->pNext = NULL;    
                 }
                 else 
                 {
                     m_pcDownload->m_pbCurBuffer->pNext = 
                         m_pcDownload->m_pcInfo->m_pPool;
                     m_pcDownload->m_pcInfo->m_pPool =
                     (buffer *)m_pcDownload->m_pcInfo->m_pPool->pNext;
                     m_pcDownload->m_pbCurBuffer = (buffer *) m_pcDownload->m_pbCurBuffer->pNext;
                     m_pcDownload->m_pbCurBuffer->pNext = NULL;
                 }   
                 LeaveCriticalSection(&(m_pcDownload->m_pcInfo->m_csInfo));   
             }    
             else 
             {
                 //allocate buffers on the fly
                 if(!m_pcDownload->m_pbStartBuffer) 
                 {    
                     // if the first time
                     m_pcDownload->m_pbStartBuffer = m_pcDownload->m_pbCurBuffer =  new buffer;
                     if(!m_pcDownload->m_pbCurBuffer)
                     {
                         dprintf(DBG_ERROR, "*** ERROR *** on buff alloc\n");
                         return S_FALSE;
                     }
                     m_pcDownload->m_pbCurBuffer->pBuf = new TCHAR[dwBuf_Size];

                     if(!m_pcDownload->m_pbCurBuffer->pBuf)
                     {
                         dprintf(DBG_ERROR, "*** ERROR *** on buf alloc\n");
                         return S_FALSE;
                     }
                 
                     m_pcDownload->m_pbStartBuffer->pNext = NULL;        
                 }
             
                 else 
                 {    
                     m_pcDownload->m_pbCurBuffer->pNext = new buffer;
                     if(!m_pcDownload->m_pbCurBuffer->pNext)
                     {
                         dprintf(DBG_ERROR, "*** ERROR *** on buff alloc\n");
                         return S_FALSE;
                     }
                     m_pcDownload->m_pbCurBuffer = (buffer *) m_pcDownload->m_pbCurBuffer->pNext;
                     m_pcDownload->m_pbCurBuffer->pBuf = new TCHAR[dwBuf_Size];
                     if(!m_pcDownload->m_pbCurBuffer->pBuf)
                     {
                         dprintf(DBG_ERROR, "*** ERROR *** on buf alloc\n");
                         return S_FALSE;
                     }
                 
                     m_pcDownload->m_pbCurBuffer->pNext = NULL;
                 }
             }
#endif
             if(dwBegin_Time == 0)
                 dwBegin_Time = GetTickCount();

#ifdef USE_POOL    
             hr = m_pStream->Read(m_pcDownload->m_pbCurBuffer->pBuf,             
                 dwBuf_Size, &(m_pcDownload->m_pbCurBuffer->lNumRead));
             if(g_dwDbgFlags)
             {
                  dprintf(DBG_INFO & DBG_DEBUG, "Stream->Read Size=%d Read=%d hr=0x%x\n", dwBuf_Size, m_pcDownload->m_pbCurBuffer->lNumRead, hr);
                  if(hr != S_OK && hr != E_PENDING && hr != S_FALSE)
                    dprintf(DBG_ERROR, "************ Stream->Read hr=0x%x\n", hr);
             }
#else                 
             hr = m_pStream->Read(g_pBuf, dwBuf_Size, &(m_pcDownload->lNumRead));
             if(g_dwDbgFlags)
             {
                  dprintf(DBG_INFO & DBG_DEBUG, "Stream->Read Size=%d Read=%d hr=0x%x\n", dwBuf_Size, m_pcDownload->lNumRead, hr);
                  if(hr != S_OK && hr != E_PENDING && hr != S_FALSE)
                    dprintf(DBG_ERROR, "************ Stream->Read hr=0x%x\n", hr);
             }
#endif                 
             
             //need to check for error if read reaches end of stream
             if(hr == S_FALSE) 
             {
                 break;            
             }
#ifdef USE_POOL    
             if (m_pcDownload->m_pbCurBuffer->lNumRead > 0) 
             {
                 m_cbOld += m_pcDownload->m_pbCurBuffer->lNumRead;
             }
#else
             if (m_pcDownload->lNumRead > 0) 
             {
                 m_cbOld += m_pcDownload->lNumRead;
             }
#endif
         }
     }//     if(m_pstm && dwRead)

     if (BSCF_LASTDATANOTIFICATION & grfBSCF) 
     {
         WideCharToMultiByte(CP_ACP, 0, m_pcDownload->m_pUrl, -1, 
             sUrl, INTERNET_MAX_URL_LENGTH, 0, 0);
         if(g_dwDbgFlags && !bDelim)
            dprintf(DBG_INFO, "Status: %s downloaded.\n", sUrl);
//         m_pcDownload->m_pcInfo->decDownloads();
    
         m_pcDownload->m_iStatus = LDG_DONE;

         if(!ReleaseSemaphore(m_pcDownload->m_pcInfo->m_hMaxDownloadSem,1,NULL)) 
         {
             dprintf(DBG_ERROR, "*** ERROR *** ReleaseSemaphore failed!\n");
             return S_FALSE; 
         }

         dwBytes_Read += m_cbOld;  // accum buf size that was downloaded
     }
     return S_OK;
}  // CBindStatusCallback::OnDataAvailable

// ---------------------------------------------------------------------------
// %%Function: CBindStatusCallback::OnObjectAvailable
// ---------------------------------------------------------------------------
 STDMETHODIMP
CBindStatusCallback::OnObjectAvailable(REFIID riid, IUnknown* punk)
{
    return E_NOTIMPL;
}  // CBindStatusCallback::OnObjectAvailable

// ===========================================================================
//                           CDownload Implementation
// ===========================================================================

// ---------------------------------------------------------------------------
// %%Function: CDownload::CDownload
// ---------------------------------------------------------------------------
CDownload::CDownload(LPSTR sName, CInfo* pcInfo)
{
    MultiByteToWideChar(CP_ACP, 0, sName, -1, m_pUrl, INTERNET_MAX_URL_LENGTH);  
    m_pMoniker = 0;
    m_pBindCtx = 0;
    m_pBindCallback = 0;
    m_pdNext = NULL;

    m_iStatus = LDG_STARTED;
    m_iPriority = PRI_MED;
    m_pcInfo = pcInfo;
#ifdef USE_POOL    
    m_pbStartBuffer = m_pbCurBuffer = NULL;
#endif    

}  // CDownload

// ---------------------------------------------------------------------------
// %%Function: CDownload::~CDownload
// ---------------------------------------------------------------------------
CDownload::~CDownload()
{
    buffer* pbLastBuf = NULL;

    if (m_pMoniker)
        m_pMoniker->Release();
    if (m_pBindCtx)
        m_pBindCtx->Release();
    if (m_pBindCallback)
        m_pBindCallback->Release();
    delete m_pcInfo;

#ifdef USE_POOL    
    if(m_pbStartBuffer)
    {
        while(m_pbStartBuffer->lNumRead != 0 && 
            m_pbStartBuffer->lNumRead <= dwBuf_Size) 
        {
            delete m_pbStartBuffer->pBuf;
            pbLastBuf = m_pbStartBuffer;
            m_pbStartBuffer = (buffer *)m_pbStartBuffer->pNext;   
            delete pbLastBuf;   
        }   
    }
#endif
    GlobalFree(m_pUrl);
}  // ~CDownload

// ---------------------------------------------------------------------------
// %%Function: CDownload::DoDownload
// ---------------------------------------------------------------------------
 

HRESULT CDownload::doDownload(void) 
{
    IStream*        pstm;
    HRESULT         hr;

    hr = g_pfnCreateURLMoniker(NULL, m_pUrl, &m_pMoniker);
    if (FAILED(hr)) 
    {
        dprintf(DBG_ERROR, "*** ERROR *** doDownload CreateURLMoniker failed hr=0x%x\n", hr);
        goto LErrExit;    
    }
            
    m_pBindCallback = new CBindStatusCallback(this);

    if (m_pBindCallback == NULL) 
    {
        dprintf(DBG_ERROR, "*** ERROR *** doDownload CBindStatusCallback failed hr=0x%x\n", hr);
        hr = E_OUTOFMEMORY;
        goto LErrExit;        
    }

    hr = CreateBindCtx(0, &m_pBindCtx);
    if (FAILED(hr)) 
    {
        dprintf(DBG_ERROR, "*** ERROR *** doDownload CreateBindCtx failed hr=0x%x\n", hr);
        goto LErrExit;      
    }

    hr = g_pfnRegisterBindStatusCallback(
        m_pBindCtx, 
        m_pBindCallback, 
        0, 0L);
        
    if (FAILED(hr)) 
    {
        dprintf(DBG_ERROR, "*** ERROR *** doDownload RegisterBindStatusCallback failed hr=0x%x\n", hr);
        goto LErrExit;    
    }
    
    hr = m_pMoniker->BindToStorage(
        m_pBindCtx, 
        0, 
        IID_IStream, 
        (void**)&pstm);
    if (FAILED(hr)) 
    {
        dprintf(DBG_ERROR, "*** ERROR *** doDownload BindToStorage failed hr=0x%x\n", hr);
        goto LErrExit;    
    }
    
    return(hr);

LErrExit:
    if (m_pBindCtx != NULL) 
    {
        m_pBindCtx->Release();
        m_pBindCtx = NULL;
        }
    if (m_pBindCallback != NULL) 
    {
        m_pBindCallback->Release();
        m_pBindCallback = NULL;
        }
    if (m_pMoniker != NULL) 
    {
        m_pMoniker->Release();
        m_pMoniker = NULL;
        }
    return hr;
}

// ---------------------------------------------------------------------------
// %%Function: CDownload::releasePool
// ---------------------------------------------------------------------------
#ifdef USE_POOL
INT CDownload::releasePool()
{
    buffer *pbStart;

    EnterCriticalSection(&(m_pcInfo->m_csInfo));

    while(m_pbStartBuffer) 
    {
        // remember the start buf
        pbStart = (buffer *) m_pbStartBuffer->pNext;
        // adjust the start
        m_pbStartBuffer = (buffer *) m_pbStartBuffer->pNext;

        //insert the buffer at the beginning of the pool
        pbStart->pNext = m_pcInfo->m_pPool;

        // update the pool
        m_pcInfo->m_pPool = pbStart;
    }

    LeaveCriticalSection(&(m_pcInfo->m_csInfo));
    return TRUE;
}
#endif

// ===========================================================================
//                           CInfo Implementation
// ===========================================================================

// ---------------------------------------------------------------------------
// %%Function: CInfo::CInfo
// ---------------------------------------------------------------------------
CInfo::CInfo()
{
#ifdef USE_POOL    
    INT i;

    buffer* pStartBuffer = NULL;
#endif

    m_hCompleteEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (!m_hCompleteEvent) 
    {
        dprintf(DBG_ERROR, "*** ERROR *** on create Event!\n");
    }

    InitializeCriticalSection(&(m_csInfo));

    m_hMaxDownloadSem = CreateSemaphore(NULL,dwMax_Simul_Downloads,dwMax_Simul_Downloads, NULL);
    if(!m_hMaxDownloadSem) 
    {
        dprintf(DBG_ERROR, "*** ERROR *** CreateSem failed!\n");
    }

#ifdef USE_POOL    
    pStartBuffer = m_pPool = new buffer; 
    if(!m_pPool)
        return;

    m_pPool->pBuf = new TCHAR[dwBuf_Size]; 
    if (!m_pPool->pBuf)
        return;

    m_pPool->lNumRead = 0;
#endif    

    m_iDownloads = 0;

#ifdef USE_POOL    
    m_pPool->pNext = NULL;
    for(i=1; i<BUF_NUM; i++) 
    {
        m_pPool->pNext = new buffer;
        if (!m_pPool->pNext)
            return;

        m_pPool = (buffer *)m_pPool->pNext;
        m_pPool->pBuf = new TCHAR[dwBuf_Size];
        
        if (!m_pPool->pBuf)
            return;

        m_pPool->lNumRead = 0;
        m_pPool->pNext = NULL;
    }

    m_pPool = pStartBuffer;
#endif    
    return;
}  // CInfo

// ---------------------------------------------------------------------------
// %%Function: CInfo::~CInfo
// ---------------------------------------------------------------------------
CInfo::~CInfo()
{
    buffer *pLastBuf;

    while(m_pPool) 
    {
        delete m_pPool->pBuf;
        pLastBuf = m_pPool;
        m_pPool = (buffer *)m_pPool->pNext;   
        delete pLastBuf;
    }
    delete this;
}  // ~CInfo



// ===========================================================================
//                  User Interface and Initialization Routines
// ===========================================================================

//----------------------------------------------------------------------------
//  Procedure:   DownloadThread
//  Purpose:     Opens internet connection and downloads URL.  Saves
//               URL to pOutQ (one chunk per buffer).
//  Arguments:   outQ
//  Return Val:  TRUE or FALSE based on error
//----------------------------------------------------------------------------

DWORD DownloadThread(LPDWORD lpdwParam) 
{

    INT retVal;
    MSG msg;
    CDownload *pcDownload = (CDownload *) lpdwParam;

    SetEvent(pcDownload->m_pcInfo->m_hCompleteEvent);
    if(g_dwDbgFlags)    
        dprintf(DBG_INFO, "DownloadThread: m_hCompleteEvent set.\n");

    StartCAP();

    for (;;)
    {
        SuspendCAP();

        retVal = GetMessage(&msg, NULL, 0, 0);

        ResumeCAP();

        if(retVal == -1) 
        {
            dprintf(DBG_ERROR, "*** ERROR *** on GetMessage\n");
            break;
        }
        if(retVal == FALSE) 
        {
            msg.message = DOWNLOAD_DONE;
        }
        pcDownload = (CDownload *) msg.wParam;
        switch(msg.message) 
        {
        case DOWNLOAD_DONE:
            delete pcDownload;
            if(g_dwDbgFlags)    
                dprintf(DBG_INFO, "DownloadThread: exit\n");
            return TRUE;
            break;
        
        case DO_DOWNLOAD:
            if(FAILED(pcDownload->doDownload()))
            {
                return FALSE;
            }
            break;
        default:
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }    
    return TRUE;
}

//==================================================================
void Display_Usage(char **argv)
{
    printf("\nUsage: %s -fURLname [options]\n", argv[0]);
    printf("\n          -iInputFileName [options]\n");
    printf("\n\t options:\n");
    printf("\t\t -l   - read buffer length\n");
    printf("\t\t -m   - maximum number of simultaneous downloads\n");
    printf("\t\t -n## - number of times to download\n");
    printf("\t\t -z   - comma delimited format\n");
    printf("\t\t -c   - write to cache (default is NOWRITECACHE)\n");
    printf("\t\t -g   - read from cache (default is GETNEWESTVERSION)\n");
    printf("\t\t -d   - direct read (default uses QueryDataAvailable)\n");
    printf("\t\t -1   - single processor affinity (default multiprocessor)\n");
    printf("\t\t -x#  - verbose flags (default=0x%x)\n", g_dwDbgFlags);
    printf("\t\t\t Results          0x%02x\n",DBG_RESULTS);
    printf("\t\t\t Debug            0x%02x\n",DBG_DEBUG);
    printf("\t\t\t Info             0x%02x\n",DBG_INFO);
    printf("\t\t\t StartBinding     0x%02x\n",DBG_STARTBINDING);
    printf("\t\t\t StopBinding      0x%02x\n",DBG_STOPBINDING);
    printf("\t\t\t OnProgress       0x%02x\n",DBG_ONPROGRESS);
    printf("\t\t\t OnDataAvailable  0x%02x\n",DBG_ONAVAIL);
    printf("\t\t\t Break on Errors  0x%02x\n",DBG_BREAKONERROR);
}

//==================================================================
BOOL Process_Command_Line(int argcIn, char **argvIn)
{
    BOOL bRC = TRUE;
    int argc = argcIn;
    char **argv = argvIn;
    DWORD dwLen = 0;

    *g_CmdLine = '\0';
    
    argv++; argc--;
    while( argc > 0 && argv[0][0] == '-' )  
    {
        switch (argv[0][1]) 
        {
            case 'c':
                g_dwCacheFlag &= ~BINDF_NOWRITECACHE;
                break;
            case 'g':
                g_dwCacheFlag &= ~BINDF_GETNEWESTVERSION;
                break;
            case 'd':
                g_dwCacheFlag |= BINDF_DIRECT_READ;
                break;
            case 'f':
                pFilename = &argv[0][2];
                break;
            case 'i':
                pInFile = &argv[0][2];
                break;
            case 'n':
                dwNum_Opens = atoi(&argv[0][2]);
                break;
            case 'l':
                dwBuf_Size =  atoi(&argv[0][2]);
                if(dwBuf_Size > MAX_BUF_SIZE)
                    dwBuf_Size = MAX_BUF_SIZE;
                break;
            case 'm':
                dwMax_Simul_Downloads = atoi(&argv[0][2]);
                break;
            case 'r':
                g_pRunStr = &argv[0][2];
                break;
            case 't':
                g_pTestName = &argv[0][2];
                break;
            case 'z':
                bDelim = TRUE;
                break;
            case '1':
                SetSingleProcessorAffinity();
                break;
            case 'x':
                sscanf(&argv[0][2], "%x", &g_dwDbgFlags);
                if(!(g_dwDbgFlags & (DBG_ALLVALID)))
                {
                    printf("Invalid verbose flags %x\n", g_dwDbgFlags);
                    Display_Usage(argvIn);
                    bRC = FALSE;
                }
                break;
            default:
                Display_Usage(argvIn);
                bRC = FALSE;
        }
        if(bRC)
        {
            dwLen += lstrlen(argv[0]) + 1;   // length of arg and space
            if(dwLen < ((sizeof(g_CmdLine)/sizeof(g_CmdLine[0]))-1))
            {
                lstrcat(g_CmdLine, ",");
                lstrcat(g_CmdLine, argv[0]);
            }
        }
        
        argv++; argc--;
    }

    if(!pFilename && !pInFile)
    {
        Display_Usage(argvIn);
        bRC = FALSE;
    }

    return(bRC);
}

//----------------------------------------------------------------------------
// Function:  WinMain
// Purpose:   main entry procedure
// Args:      none
// RetVal:    TRUE or FALSE based on error
//----------------------------------------------------------------------------
//int WINAPI WinMain(HINSTANCE hinst, HINSTANCE hinstPrev, LPSTR szCmdLine, int nCmdShow)
int __cdecl main(INT argc, TCHAR *argv[]) //for console
{
    CDownload*      pcDownload = NULL;
    CDownload*      pcdFirst = NULL;
    CInfo*          pcInfo = NULL;
    DWORD           dwThreadID;
    DWORD           dwCnt;
    HANDLE          hDownloadThread;
    INT             iError;
    char            szName[MAX_PATH];
    __int64         ibeg, iend, ifrq;
    float fKB;
    float fSec;
    float fKBSec;

    if(!Process_Command_Line(argc, argv))
        exit(0);

    pcInfo = new CInfo();
    g_pBuf = new TCHAR[dwBuf_Size];

    if(!pcInfo) 
    {
        dprintf(DBG_ERROR, "*** ERROR *** generating pool!\n");
        return(0);
    }

    dwCnt = 0;
    if(pFilename)
    {
        while(dwCnt++ < dwNum_Opens)
        {    

            if(g_dwCacheFlag & BINDF_NOWRITECACHE)
                lstrcpy(szName, pFilename);
            else
                wsprintf(szName, "%s.%d", pFilename, dwCnt);

            if(!pcDownload) 
            {
                pcdFirst = pcDownload = new CDownload(szName, pcInfo);
                pcDownload->m_pcInfo->m_pdFirst = pcDownload;
            }
            else 
            {
                pcDownload->m_pdNext = new CDownload(szName, pcInfo);
                pcDownload = (CDownload *) pcDownload->m_pdNext;
            }

            if(!pcDownload)
            {
                dprintf(DBG_ERROR, "*** ERROR *** initializing pcDownload!\n");
                return(0);
            }
        }
    }
    else if(pInFile)    // Process input file
    {
        FILE *fp;

        while(dwCnt++ < dwNum_Opens) 
        {
            if((fp = fopen(pInFile, "r")) == NULL) 
            {
                dprintf(DBG_ERROR, "*** ERROR *** opening file\n");
                return(0);
            }

            while(fgets(szName, INTERNET_MAX_URL_LENGTH, fp) != NULL) 
            {
                if(szName[0] != '#') 
                {
                    szName[strlen(szName) - sizeof(char)] = '\0';

                    if(!pcDownload) 
                    {
                        pcdFirst = pcDownload = new CDownload(szName, pcInfo);
                        pcDownload->m_pcInfo->m_pdFirst = pcDownload;
                    }
                    else 
                    {
                        pcDownload->m_pdNext = new CDownload(szName, pcInfo);
                        pcDownload = (CDownload *) pcDownload->m_pdNext;
                    }

                    if(!pcDownload)
                    {
                        dprintf(DBG_ERROR, "*** ERROR *** initializing pcDownload!\n");
                        return(0);
                    }
                }
            }

            fclose(fp);
        }
    }

    pcDownload = (CDownload *) pcDownload->m_pcInfo->m_pdFirst;

    if (LoadUrlMon() != S_OK)
    {
        dprintf(DBG_ERROR, "*** ERROR *** LoadUrlMon() failed\n");
        return(0);
    }

    if (CoInitialize(NULL) != S_OK) 
    {
        dprintf(DBG_ERROR, "*** ERROR *** CoInitialize() failed\n");
        return(0);
    }

    pcDownload->m_pcInfo->m_hCompleteEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

    if (!pcDownload->m_pcInfo->m_hCompleteEvent) 
    {
        dprintf(DBG_ERROR, "*** ERROR *** on create Event!\n");
    }

    hDownloadThread = CreateThread(NULL,
        0,
        (LPTHREAD_START_ROUTINE)DownloadThread,
        (LPVOID)pcDownload,
        0,
        &dwThreadID );

    if (!hDownloadThread) 
    {
        dprintf(DBG_ERROR, "*** ERROR *** Could not create Thread\n");
        return(0);
    }

    if(WaitForSingleObject(pcDownload->m_pcInfo->m_hCompleteEvent, TIMEOUT)
        == WAIT_TIMEOUT) 
    {
        dprintf(DBG_ERROR, "*** ERROR *** timeout on init\n");
    }
    Sleep(100);

    QueryPerformanceCounter((LARGE_INTEGER *)&ibeg);

    while(pcDownload) 
    {
        if(WaitForSingleObject(pcDownload->m_pcInfo->m_hMaxDownloadSem, TIMEOUT) 
            == WAIT_TIMEOUT) 
        {
            dprintf(DBG_ERROR, "*** ERROR *** timeout on Sem\n");
        }

        if(g_dwDbgFlags)
        {
            TCHAR sz[255];
            WideCharToMultiByte(CP_ACP, 0, pcDownload->m_pUrl, -1, sz, 255,0,0);
            dprintf(DBG_INFO, "main: PostThreadMessage DO_DOWNLOAD %s\n", sz);
        }
        if(!PostThreadMessage(dwThreadID, DO_DOWNLOAD, (WPARAM) pcDownload, 0))
        {
            iError = GetLastError();
            dprintf(DBG_ERROR, "*** Error *** on PostThreadMessage(0x%X, %ld, 0x%lX, 0) [GLE=%d]\n", 
                dwThreadID, DO_DOWNLOAD, pcDownload, iError);
            return(0);
        }
        pcDownload = (CDownload *) pcDownload->m_pdNext;    
    }  
    //wait for completion downloads at one time
    if(WaitForSingleObject(pcdFirst->m_pcInfo->m_hCompleteEvent, TIMEOUT) == WAIT_TIMEOUT) 
    {
        dprintf(DBG_ERROR, "*** ERROR *** timeout on Sem\n");
    }

    QueryPerformanceCounter((LARGE_INTEGER *) &iend);
    QueryPerformanceFrequency((LARGE_INTEGER *) &ifrq);

    dwTot_Time = (DWORD)((iend - ibeg) * 1000 / ifrq);
    if(dwTot_Time == 0)
     dwTot_Time = 1;
    fKB = ((float)dwBytes_Read)/1024;
    fSec = ((float)dwTot_Time)/1000;
    fKBSec = fKB / fSec;
    if(!bDelim)
    {
        dprintf(DBG_RESULTS, "Downloaded: %s\r\n", sUrl);
        dprintf(DBG_RESULTS, "%ld Bytes in %ld Milliseconds = %2.0f KB/Sec\r\n", dwBytes_Read, dwTot_Time, fKBSec );
        dprintf(DBG_RESULTS, "%ld Reads, %ld Downloads, %ld Byte Read Buffer\r\n",
            dwNum_Opens, dwMax_Simul_Downloads, dwBuf_Size);
    }
    else
        dprintf(DBG_RESULTS, "%s, %s, %ld, %ld, %2.0f %s\n", 
            g_pTestName ?g_pTestName :"urlmon",
            g_pRunStr ?g_pRunStr :"1",
            dwTot_Time, dwBytes_Read, fKBSec, g_CmdLine );

    if(g_dwDbgFlags)    
        dprintf(DBG_INFO, "realized finished on data ready\n");

    if(!PostThreadMessage(dwThreadID, DOWNLOAD_DONE, (WPARAM) pcDownload, 0))
    {
        iError = GetLastError();
        dprintf(DBG_ERROR, "*** Error *** on PostThreadMessage(0x%X, %ld, 0x%lX, 0) [GLE=%d]\n", 
            dwThreadID, DOWNLOAD_DONE, pcDownload, iError);
        return(0);
    }
    if(WaitForSingleObject(hDownloadThread, TIMEOUT) == WAIT_TIMEOUT) 
    {
        dprintf(DBG_ERROR, "*** ERROR *** timeout on DownloadThread exit\n");
    }
   
    CloseHandle(hDownloadThread);
    CoUninitialize();
    UnloadUrlMon();

    if(g_dwDbgFlags)    
        dprintf(DBG_INFO, "main: exit\n");

    return(1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\perf\oinetperf\precomp1.inc ===
#//+---------------------------------------------------------------
#//
#//  File:      precomp1.inc
#//
#//  Contents:  directives for global precompiled include file when the
#//             sources file is two directories below com (or wherever
#//             this file is located).  We could easily have precomp3 and
#//             precomp4 for other areas.The urlint.* files should not
#//             otherwise be mentioned in the sources files.
#//
#//
#//----------------------------------------------------------------

PRECOMPILED_CXX=1
#PRECOMPILED_INCLUDE=..\..\inc\urlb.h
#PRECOMPILED_TARGET=$(GPCH_BUILD)\$(_OBJ_DIR)\*\urlb.pch
#PRECOMPILED_OPTION=/Yuurlb.h /Fp$(GPCH_BUILD)\$(_OBJ_DIR)\*\urlb.pch
#PRECOMPILED_OBJ=$(GPCH_BUILD)\$(_OBJ_DIR)\*\urlb.obj
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\proxy\call_as.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       call_as.c wrapper functions for urlmon
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    1-08-96   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------
#include <urlint.h>
#include "transmit.h"

//+---------------------------------------------------------------------------
//
//  Function:   IBindHost_MonikerBindToStorage_Proxy
//
//  Synopsis:
//
//  Arguments:  [This] --
//              [pMk] --
//              [pBC] --
//              [pBSC] --
//              [riid] --
//              [ppvObj] --
//
//  Returns:
//
//  History:    7-23-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IBindHost_MonikerBindToStorage_Proxy(
    IBindHost __RPC_FAR * This,
    /* [in] */ IMoniker __RPC_FAR *pMk,
    /* [in] */ IBindCtx __RPC_FAR *pBC,
    /* [in] */ IBindStatusCallback __RPC_FAR *pBSC,
    /* [in] */ REFIID riid,
    /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObj)
{
    HRESULT hr;
    TransDebugOut((DEB_DATA,"%p _IN IBindHost_MonikerBindToStorage_Proxy\n",This));
    *ppvObj = 0;

    hr = IBindHost_RemoteMonikerBindToStorage_Proxy(This, pMk, pBC, pBSC, riid, (IUnknown **)ppvObj);

    TransDebugOut((DEB_DATA,"%p OUT IBindHost_MonikerBindToStorage_Proxy (hr:%lx)\n",This, hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   IBindHost_MonikerBindToStorage_Stub
//
//  Synopsis:
//
//  Arguments:  [This] --
//              [pMk] --
//              [pBC] --
//              [pBSC] --
//              [riid] --
//              [ppUnk] --
//
//  Returns:
//
//  History:    7-23-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IBindHost_MonikerBindToStorage_Stub(
    IBindHost __RPC_FAR * This,
    /* [unique][in] */ IMoniker __RPC_FAR *pMk,
    /* [unique][in] */ IBindCtx __RPC_FAR *pBC,
    /* [unique][in] */ IBindStatusCallback __RPC_FAR *pBSC,
    /* [in] */         REFIID riid,
    /* [iid_is][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppUnk)
{
    HRESULT hr;
    TransDebugOut((DEB_DATA,"%p _IN IBindHost_MonikerBindToStorage_Stub\n",This));

    hr = This->MonikerBindToStorage(pMk, pBC, pBSC, riid, (void **)ppUnk);

    if (FAILED(hr))
    {
        TransAssert((*ppUnk == 0));
        *ppUnk = 0;
    }

    TransDebugOut((DEB_DATA,"%p OUT IBindHost_MonikerBindToStorage_Stub (hr:%lx)\n",This, hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   IBindHost_MonikerBindToObject_Proxy
//
//  Synopsis:
//
//  Arguments:  [This] --
//              [pMk] --
//              [pBC] --
//              [pBSC] --
//              [riid] --
//              [ppvObj] --
//
//  Returns:
//
//  History:    7-23-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IBindHost_MonikerBindToObject_Proxy(
    IBindHost __RPC_FAR * This,
    /* [in] */ IMoniker __RPC_FAR *pMk,
    /* [in] */ IBindCtx __RPC_FAR *pBC,
    /* [in] */ IBindStatusCallback __RPC_FAR *pBSC,
    /* [in] */ REFIID riid,
    /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObj)
{
    HRESULT hr;
    TransDebugOut((DEB_DATA,"%p _IN IBindHost_MonikerBindToObject_Proxy\n",This));

    *ppvObj = 0;
    hr = IBindHost_RemoteMonikerBindToObject_Proxy(This, pMk, pBC, pBSC, riid, (IUnknown **)ppvObj);

    TransDebugOut((DEB_DATA,"%p OUT IBindHost_MonikerBindToObject_Proxy (hr:%lx)\n",This, hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   IBindHost_MonikerBindToObject_Stub
//
//  Synopsis:
//
//  Arguments:  [This] --
//              [pMk] --
//              [pBC] --
//              [pBSC] --
//              [riid] --
//              [ppUnk] --
//
//  Returns:
//
//  History:    7-23-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IBindHost_MonikerBindToObject_Stub(
    IBindHost __RPC_FAR * This,
    /* [unique][in] */ IMoniker __RPC_FAR *pMk,
    /* [unique][in] */ IBindCtx __RPC_FAR *pBC,
    /* [unique][in] */ IBindStatusCallback __RPC_FAR *pBSC,
    /* [in] */          REFIID riid,
    /* [iid_is][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppUnk)
{
    HRESULT hr;
    TransDebugOut((DEB_DATA,"%p _IN IBindHost_MonikerBindToObject_Stub\n",This));

    hr = This->MonikerBindToObject(pMk, pBC, pBSC, riid, (void **)ppUnk);

    if (FAILED(hr))
    {
        TransAssert((*ppUnk == 0));
        *ppUnk = 0;
    }

    TransDebugOut((DEB_DATA,"%p OUT IBindHost_MonikerBindToObject_Stub (hr:%lx)\n",This, hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   IBindStatusCallback_GetBindInfo_Proxy
//
//  Synopsis:
//
//  Arguments:  [This] --
//              [grfBINDF] --
//              [pbindinfo] --
//
//  Returns:
//
//  History:    7-23-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IBindStatusCallback_GetBindInfo_Proxy(
    IBindStatusCallback __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *grfBINDF,
    /* [unique][out][in] */ BINDINFO __RPC_FAR *pbindinfo)
{
    TransDebugOut((DEB_DATA,"%p _IN IBindStatusCallback_GetBindInfo_Proxy\n",This));
    HRESULT hr;
    RemSTGMEDIUM RemoteMedium;
    RemSTGMEDIUM *pRemoteMedium = &RemoteMedium;
    RemBINDINFO RemoteBindInfo;
    RemBINDINFO *pRemoteBindInfo = &RemoteBindInfo;

    hr = NOERROR;
    memset(&RemoteBindInfo, 0, sizeof(RemoteBindInfo));

    __try
    {

        RemoteBindInfo.cbSize        = pbindinfo->cbSize      ;
        RemoteBindInfo.szExtraInfo   = pbindinfo->szExtraInfo ;
        RemoteBindInfo.grfBindInfoF  = pbindinfo->grfBindInfoF;
        RemoteBindInfo.dwBindVerb    = pbindinfo->dwBindVerb  ;
        RemoteBindInfo.szCustomVerb  = pbindinfo->szCustomVerb;
        RemoteBindInfo.cbstgmedData  = pbindinfo->cbstgmedData;
        RemoteBindInfo.iid  = IID_NULL;
        STGMEDIUM_to_xmit(&(pbindinfo->stgmedData), (RemSTGMEDIUM **) &pRemoteMedium);

        hr = IBindStatusCallback_RemoteGetBindInfo_Proxy(This, grfBINDF, pRemoteBindInfo,pRemoteMedium);

        if (hr == NOERROR)
        {
            pbindinfo->szExtraInfo =   pRemoteBindInfo->szExtraInfo   ;
            pbindinfo->grfBindInfoF=   pRemoteBindInfo->grfBindInfoF  ;
            pbindinfo->dwBindVerb  =   pRemoteBindInfo->dwBindVerb    ;
            pbindinfo->szCustomVerb=   pRemoteBindInfo->szCustomVerb  ;
            pbindinfo->cbstgmedData=   pRemoteBindInfo->cbstgmedData  ;

            if ( pbindinfo->cbSize > URLMONOFFSETOF(BINDINFO, dwReserved) )
            {
                pbindinfo->pUnk =  0;
                pbindinfo->dwReserved =   pRemoteBindInfo->dwReserved;
                pbindinfo->dwOptions =    pRemoteBindInfo->dwOptions ;
                pbindinfo->dwOptionsFlags = pRemoteBindInfo->dwOptionsFlags;
                pbindinfo->dwCodePage = pRemoteBindInfo->dwCodePage;
                pbindinfo->iid = IID_NULL;
            }           
            STGMEDIUM_from_xmit( (RemSTGMEDIUM *) pRemoteMedium, &(pbindinfo->stgmedData));
        }
        else
        {

        }

    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        //Just ignore the exception.
    }
#ifdef unix
    __endexcept
#endif /* unix */
    TransDebugOut((DEB_DATA,"%p OUT IBindStatusCallback_GetBindInfo_Proxy (hr:%lx)\n",This, hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   IBindStatusCallback_GetBindInfo_Stub
//
//  Synopsis:
//
//  Arguments:  [This] --
//              [grfBINDF] --
//              [pbindinfo] --
//              [pRemstgmed] --
//
//  Returns:
//
//  History:    7-23-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IBindStatusCallback_GetBindInfo_Stub(
    IBindStatusCallback __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *grfBINDF,
    /* [unique][out][in] */ RemBINDINFO __RPC_FAR *prembindinfo,
    /* [unique][out][in] */ RemSTGMEDIUM __RPC_FAR *pRemstgmed
    )
{
    TransDebugOut((DEB_DATA,"%p _IN IBindStatusCallback_GetBindInfo_Stub\n",This));
    HRESULT hr;
    BINDINFO BindInfo;
    STGMEDIUM *pstgmed = NULL;

    hr = NOERROR;
    memset(&BindInfo, 0, sizeof(BindInfo));

    __try
    {
        BindInfo.cbSize        = prembindinfo->cbSize      ;
        BindInfo.szExtraInfo   = prembindinfo->szExtraInfo ;
        BindInfo.grfBindInfoF  = prembindinfo->grfBindInfoF;
        BindInfo.dwBindVerb    = prembindinfo->dwBindVerb  ;
        BindInfo.szCustomVerb  = prembindinfo->szCustomVerb;
        BindInfo.cbstgmedData  = prembindinfo->cbstgmedData;
        BindInfo.iid           = IID_NULL;
        
        if ( prembindinfo->cbSize >= URLMONOFFSETOF(BINDINFO, dwReserved) )
        {
            BindInfo.dwOptions      = prembindinfo->dwOptions;
            BindInfo.dwOptionsFlags = prembindinfo->dwOptionsFlags;
        }

        memset(&(BindInfo.stgmedData), 0 , sizeof(BindInfo.stgmedData));
        BindInfo.stgmedData.tymed  = TYMED_NULL;

        hr = This->GetBindInfo(grfBINDF, &BindInfo);

        if (hr == NOERROR)
        {
            pstgmed = &BindInfo.stgmedData;
            TransAssert((   (pstgmed->tymed == TYMED_NULL &&  pstgmed->pUnkForRelease == NULL)
                         || (pstgmed->tymed != TYMED_NULL) ));

            if (pstgmed->tymed != TYMED_NULL)
            {
                //Convert an STGMEDIUM to a RemSTGMEDIUM
                // structure so it can be sent
                STGMEDIUM_to_xmit(pstgmed,&pRemstgmed);
            }

            prembindinfo->szExtraInfo  = BindInfo.szExtraInfo   ;
            prembindinfo->grfBindInfoF = BindInfo.grfBindInfoF  ;
            prembindinfo->dwBindVerb   = BindInfo.dwBindVerb    ;
            prembindinfo->szCustomVerb = BindInfo.szCustomVerb  ;
            prembindinfo->cbstgmedData = BindInfo.cbstgmedData  ;

            if ( prembindinfo->cbSize > URLMONOFFSETOF(BINDINFO, dwReserved) )
            {
                prembindinfo->dwReserved     = BindInfo.dwReserved;
                prembindinfo->dwOptions      = BindInfo.dwOptions;
                prembindinfo->dwOptionsFlags = BindInfo.dwOptionsFlags;
                prembindinfo->iid  = IID_NULL;
                prembindinfo->pUnk = 0;
                prembindinfo->dwCodePage     = BindInfo.dwCodePage;
            }
            
        }
    }
    __finally
    {
    }
#ifdef unix
    __endfinally
#endif /* unix */
    TransDebugOut((DEB_DATA,"%p OUT IBindStatusCallback_GetBindInfo_Stub (hr:%lx)\n",This, hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   IBindStatusCallback_OnDataAvailable_Proxy
//
//  Synopsis:
//
//  Arguments:  [This] --
//              [grfBSCF] --
//              [dwSize] --
//              [pformatetc] --
//              [pstgmed] --
//
//  Returns:
//
//  History:    7-23-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IBindStatusCallback_OnDataAvailable_Proxy(
    IBindStatusCallback __RPC_FAR * This,
    /* [in] */ DWORD grfBSCF,
    /* [in] */ DWORD dwSize,
    /* [in] */ FORMATETC __RPC_FAR *pformatetc,
    /* [in] */ STGMEDIUM __RPC_FAR *pstgmed)
{
    TransDebugOut((DEB_DATA,"%p _IN IBindStatusCallback_OnDataAvailable_Proxy\n",This));
    HRESULT hr;
    RemSTGMEDIUM *pRemoteMedium = 0;
    RemFORMATETC *pRemoteformatetc = 0;
    RemFORMATETC Remoteformatetc;

    hr = NOERROR;

    __try
    {

        Remoteformatetc.cfFormat = (DWORD)pformatetc->cfFormat;
        Remoteformatetc.ptd      = 0;
        Remoteformatetc.dwAspect = pformatetc->dwAspect;
        Remoteformatetc.lindex   = pformatetc->lindex;
        Remoteformatetc.tymed    = pformatetc->tymed;
        pRemoteformatetc = &Remoteformatetc;

        STGMEDIUM_to_xmit(pstgmed, (RemSTGMEDIUM **) &pRemoteMedium);
        hr = IBindStatusCallback_RemoteOnDataAvailable_Proxy(This, grfBSCF, dwSize,
                                    pRemoteformatetc, pRemoteMedium);

    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        //Just ignore the exception.
    }
#ifdef unix
    __endexcept
#endif /* unix */
    if(pRemoteMedium != 0)
    {
        CoTaskMemFree(pRemoteMedium);
        pRemoteMedium = 0;
    }

    TransDebugOut((DEB_DATA,"%p OUT IBindStatusCallback_OnDataAvailable_Proxy (hr:%lx)\n",This, hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   IBindStatusCallback_OnDataAvailable_Stub
//
//  Synopsis:
//
//  Arguments:  [This] --
//              [grfBSCF] --
//              [dwSize] --
//              [pformatetc] --
//              [pstgmed] --
//
//  Returns:
//
//  History:    7-23-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IBindStatusCallback_OnDataAvailable_Stub(
    IBindStatusCallback __RPC_FAR * This,
    /* [in] */ DWORD grfBSCF,
    /* [in] */ DWORD dwSize,
    /* [in] */ RemFORMATETC *pformatetc,
    /* [in] */ RemSTGMEDIUM __RPC_FAR *pstgmed)
{
    TransDebugOut((DEB_DATA,"%p _IN IBindStatusCallback_OnDataAvailable_Stub\n",This));
    HRESULT hr;
    STGMEDIUM medium;
    FORMATETC formatetc;

    hr = NOERROR;

    __try
    {
        formatetc.cfFormat = (CLIPFORMAT) pformatetc->cfFormat;
        formatetc.ptd      = NULL;
        formatetc.dwAspect = pformatetc->dwAspect;
        formatetc.lindex   = pformatetc->lindex  ;
        formatetc.tymed    = pformatetc->tymed   ;

        memset(&medium, 0, sizeof(medium));
        STGMEDIUM_from_xmit (pstgmed, &medium);
        This->OnDataAvailable(grfBSCF,  dwSize, &formatetc, &medium);
    }
    __finally
    {
        STGMEDIUM_free_inst(&medium);
    }
#ifdef unix
    __endfinally
#endif /* unix */
    TransDebugOut((DEB_DATA,"%p OUT IBindStatusCallback_OnDataAvailable_Stub (hr:%lx)\n",This, hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   IBinding_GetBindResult_Proxy
//
//  Synopsis:
//
//  Arguments:  [This] --
//              [pclsidProtocol] --
//              [pdwResult] --
//              [pszResult] --
//              [pdwReserved] --
//
//  Returns:
//
//  History:    7-25-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IBinding_GetBindResult_Proxy(
    IBinding __RPC_FAR * This,
    /* [out] */ CLSID __RPC_FAR *pclsidProtocol,
    /* [out] */ DWORD __RPC_FAR *pdwResult,
    /* [out] */ LPOLESTR __RPC_FAR *pszResult,
    /* [out][in] */ DWORD __RPC_FAR *pdwReserved)
{
    TransDebugOut((DEB_DATA,"%p _IN IBindStatusCallbackMsg_GetBindResult_Proxy\n",This));
    HRESULT hr;

    __try
    {
        hr = IBinding_RemoteGetBindResult_Proxy(
                        This,
                        pclsidProtocol,
                        pdwResult,
                        pszResult,
                        NULL);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        //Just ignore the exception.
    }
#ifdef unix
    __endexcept
#endif /* unix */

    TransDebugOut((DEB_DATA,"%p OUT IBindStatusCallbackMsg_GetBindResult_Proxy (hr:%lx)\n",This, hr));
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   IBinding_GetBindResult_Stub
//
//  Synopsis:
//
//  Arguments:  [This] --
//              [pclsidProtocol] --
//              [pdwResult] --
//              [pszResult] --
//              [dwReserved] --
//
//  Returns:
//
//  History:    7-25-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IBinding_GetBindResult_Stub(
    IBinding __RPC_FAR * This,
    /* [out] */ CLSID __RPC_FAR *pclsidProtocol,
    /* [out] */ DWORD __RPC_FAR *pdwResult,
    /* [out] */ LPOLESTR __RPC_FAR *pszResult,
    /* [in] */ DWORD dwReserved)
{
    TransDebugOut((DEB_DATA,"%p _IN IBindStatusCallbackMsg_RemoteGetBindResult_Stub\n",This));
    HRESULT hr;
    hr = NOERROR;
    MSG msg;

    __try
    {
        This->GetBindResult(
            pclsidProtocol,
            pdwResult,
            pszResult,
            NULL);
    }
    __finally
    {
    }
#ifdef unix
    __endfinally
#endif /* unix */
    TransDebugOut((DEB_DATA,"%p OUT IBindStatusCallbackMsg_RemoteGetBindResult_Stub (hr:%lx)\n",This, hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   IWinInetHttpInfo_QueryInfo_Proxy
//
//  Synopsis:
//
//  Arguments:  [This] --
//              [dwOption] --
//              [pBuffer] --
//              [pcbBuf] --
//              [pdwFlags] --
//              [pdwReserved] --
//
//  Returns:
//
//  History:    9-20-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IWinInetHttpInfo_QueryInfo_Proxy(
    IWinInetHttpInfo __RPC_FAR * This,
    /* [in] */ DWORD dwOption,
    /* [size_is][out] */ LPVOID pBuffer,
    /* [out][in] */ DWORD __RPC_FAR *pcbBuf,
    /* [out][in] */ DWORD __RPC_FAR *pdwFlags,
    /* [out][in] */ DWORD __RPC_FAR *pdwReserved)
{
    TransDebugOut((DEB_DATA,"%p _IN IWinInetHttpInfo_QueryInfo_Proxy\n",This));
    HRESULT hr;

    if (!pcbBuf || (!pBuffer &&  *pcbBuf != 0))
    {
        hr = E_INVALIDARG;
    }
    else
    {
        DWORD dwBuffer = 0;
        DWORD dwFlags = 0;
        DWORD dwReserved = 0;

        if (pdwFlags == NULL)
        {
            pdwFlags = &dwFlags;
        }

        if (pdwReserved == NULL)
        {
            pdwReserved = &dwReserved;
        }

        if (pBuffer == NULL)
        {
            pBuffer = &dwBuffer;
        }

        hr = IWinInetHttpInfo_RemoteQueryInfo_Proxy(This, dwOption, (BYTE*)pBuffer,
                                                    pcbBuf,pdwFlags,pdwReserved);
    }

    TransDebugOut((DEB_DATA,"%p OUT IWinInetHttpInfo_QueryInfo_Proxy (hr:%lx)\n",This, hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   IWinInetHttpInfo_QueryInfo_Stub
//
//  Synopsis:
//
//  Arguments:  [This] --
//              [dwOption] --
//              [pBuffer] --
//              [pcbBuf] --
//              [pdwFlags] --
//              [pdwReserved] --
//
//  Returns:
//
//  History:    9-20-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IWinInetHttpInfo_QueryInfo_Stub(
    IWinInetHttpInfo __RPC_FAR * This,
    /* [in] */ DWORD dwOption,
    /* [size_is][out] */ BYTE __RPC_FAR *pBuffer,
    /* [out][in] */ DWORD __RPC_FAR *pcbBuf,
    /* [out][in] */ DWORD __RPC_FAR *pdwFlags,
    /* [out][in] */ DWORD __RPC_FAR *pdwReserved)
{
    TransDebugOut((DEB_DATA,"%p _IN IWinInetHttpInfo_QueryInfo_Stub\n",This));
    HRESULT hr;

    hr = This->QueryInfo(dwOption, pBuffer, pcbBuf, pdwFlags, pdwReserved);

    TransDebugOut((DEB_DATA,"%p OUT IWinInetHttpInfo_QueryInfo_Stub (hr:%lx)\n",This, hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   IWinInetInfo_QueryOption_Proxy
//
//  Synopsis:
//
//  Arguments:  [This] --
//              [dwOption] --
//              [pBuffer] --
//              [pcbBuf] --
//
//  Returns:
//
//  History:    9-20-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IWinInetInfo_QueryOption_Proxy(
    IWinInetInfo __RPC_FAR * This,
    /* [in] */ DWORD dwOption,
    /* [size_is][out] */ LPVOID pBuffer,
    /* [out][in] */ DWORD *pcbBuf)
{
    TransDebugOut((DEB_DATA,"%p _IN IWinInetInfo_QueryOption_Proxy\n",This));
    HRESULT hr;

    if (!pcbBuf || (!pBuffer &&  *pcbBuf != 0))
    {
        hr = E_INVALIDARG;
    }
    else
    {
        DWORD dwBuffer = 0;

        if (pBuffer == NULL)
        {
            pBuffer = &dwBuffer;
        }

        hr = IWinInetInfo_RemoteQueryOption_Proxy(This,dwOption, (BYTE*)pBuffer,pcbBuf);
    }

    TransDebugOut((DEB_DATA,"%p OUT IWinInetInfo_QueryOption_Proxy (hr:%lx)\n",This, hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   IWinInetInfo_QueryOption_Stub
//
//  Synopsis:
//
//  Arguments:  [This] --
//              [dwOption] --
//              [pBuffer] --
//              [pcbBuf] --
//
//  Returns:
//
//  History:    9-20-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IWinInetInfo_QueryOption_Stub(
    IWinInetInfo __RPC_FAR * This,
    /* [in] */ DWORD dwOption,
    /* [size_is][out] */ BYTE __RPC_FAR *pBuffer,
    /* [out][in] */ DWORD __RPC_FAR *pcbBuf)
{
    TransDebugOut((DEB_DATA,"%p _IN IWinInetInfo_QueryOption_Stub\n",This));
    HRESULT hr;

    hr = This->QueryOption(dwOption,pBuffer,pcbBuf);

    TransDebugOut((DEB_DATA,"%p OUT IWinInetInfo_QueryOption_Stub (hr:%lx)\n",This, hr));
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\proxy\dlldatax.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       dlldatax.c
//
//  Contents:   wrapper for dlldata.c
//
//  Classes:
//
//  Functions:
//
//  History:    1-08-96   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------

#define PROXY_CLSID CLSID_PSUrlMonProxy

#define DllMain             PrxDllMain
#define DllGetClassObject   PrxDllGetClassObject
#define DllCanUnloadNow     PrxDllCanUnloadNow
#define DllRegisterServer   PrxDllRegisterServer
#define DllUnregisterServer PrxDllUnregisterServer

#include "dlldata.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\perf\oinetperf\oinet.cxx ===
#include <windows.h>
#include <ole2.h>
#include <stdio.h>
#include <urlmon.h>
#include <string.h>
#include <malloc.h>
#include <urlmon.hxx>

#define IE5

#ifdef PRODUCT_PROF
extern "C" void _stdcall StartCAP(void);
extern "C" void _stdcall StopCAP(void);
extern "C" void _stdcall SuspendCAP(void);
extern "C" void _stdcall ResumeCAP(void);
extern "C" void _stdcall StartCAPAll(void);
extern "C" void _stdcall StopCAPAll(void);
#else
#define StartCAP()
#define StopCAP()
#define SuspendCAP()
#define ResumeCAP()
#define StartCAPAll()
#define StopCAPAll()
#endif

#define FLAG_TRACE    1
#define FLAG_DUMPDATA 2
#define MAX_DOWNLOADS 2000
#define MAX_URL INTERNET_MAX_URL_LENGTH
const INT BUF_SIZE = 2 * 1024;
const INT MAX_BUF_SIZE = 1024 * 16;

BOOL g_dwVerbose = 0;
DWORD g_dwNumDownloads = 1;
DWORD g_dwDownloads = 1;
DWORD g_dwTotalBytes = 0;
DWORD g_dwCacheFlag = BINDF_NOWRITECACHE | BINDF_GETNEWESTVERSION;
DWORD dwBuf_Size = BUF_SIZE;
LPWSTR g_pwzUrl = NULL;
LPCSTR g_pInfile = NULL;
LPCSTR g_pTitle = NULL;
LPCSTR g_pRun = NULL;
LPCSTR g_pModule = NULL;
HANDLE g_hCompleted;

__int64 g_ibeg = 0, g_iend, g_ifreq;

//------------------------------------------------------------------------
//      Class:      COInetProtocolHook
//
//      Purpose:    Sample Implementation of ProtocolSink and BindInfo
//                  interface for simplified urlmon async download 
//
//      Interfaces: 
//          [Needed For All]
//                  IOInetProtocolSink
//                      - provide sink for pluggable prot's callback  
//                  IOInetBindInfo    
//                      - provide the bind options
//
//          [Needed For Http] 
//                  IServiceProvider
//                      - used to query http specific services
//                        e.g. HttpNegotiate, Authentication, UIWindow
//                  IHttpNegotiate    
//                      - http negotiation service, it has two methods, 
//                        one is the http pluggable protocol asks the 
//                        client for additional headers, the other is
//                        callback for returned http server status
//                        e.g 200, 401, etc. 
//                                                
//
//      Author:     DanpoZ (Danpo Zhang)
//
//      History:    11-20-97    Created
//                  05-19-98    Modified to act as performance test
//
//      NOTE:       IOInetXXXX == IInternetXXXX
//                  on the SDK, you will see IInternetXXXX, these are same
//                  interfaces
//
//------------------------------------------------------------------------
class COInetProtocolHook :  public IOInetProtocolSink, 
                            public IOInetBindInfo,
                            public IHttpNegotiate,
                            public IServiceProvider
{
public:
    COInetProtocolHook(HANDLE g_hCompleted, IOInetProtocol* pProt);

    virtual ~COInetProtocolHook();

    // IUnknown methods
    STDMETHODIMP QueryInterface(REFIID iid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // IOInetProtocolSink methods
    STDMETHODIMP Switch( PROTOCOLDATA *pStateInfo);
    STDMETHODIMP ReportProgress( ULONG ulStatusCode, LPCWSTR szStatusText);
    STDMETHODIMP ReportData( 
        DWORD grfBSCF, 
        ULONG ulProgress, 
        ULONG ulProgressMax
    );
    STDMETHODIMP ReportResult(
        HRESULT hrResult,
        DWORD   dwError,
        LPCWSTR wzResult
    );

    //IOInetBindInfo methods
    STDMETHODIMP GetBindInfo(
        DWORD *grfBINDF,
        BINDINFO * pbindinfo
    );
    STDMETHODIMP GetBindString(
        ULONG ulStringType,
        LPOLESTR *ppwzStr,
        ULONG cEl,
        ULONG *pcElFetched
    );

    //IService Provider methods
    STDMETHODIMP QueryService(
        REFGUID guidService,
        REFIID  riid,
        void    **ppvObj 
    );

    //IHttpNegotiate methods
    STDMETHODIMP BeginningTransaction(
        LPCWSTR szURL,
        LPCWSTR szHeaders,
        DWORD   dwReserved,
        LPWSTR  *pszAdditionalHeaders
    );

    STDMETHODIMP OnResponse(
        DWORD    dwResponseCode,
        LPCWSTR  szResponseHeaders,
        LPCWSTR  szRequestHeaders,
        LPWSTR   *pszAdditionalHeaders
    );
private:
    IOInetProtocol* _pProt; 
    HANDLE          _hCompleted;
    CRefCount       _CRefs;          
};


typedef struct tagInfo
{
    WCHAR wzUrl[INTERNET_MAX_URL_LENGTH];
    IOInetProtocol* pProt;
    COInetProtocolHook* pHook;
    IOInetProtocolSink* pSink;
    IOInetBindInfo*     pBindInfo;
} INFO, *PINFO;

typedef BOOL (WINAPI *PFNSPA)(HANDLE, DWORD);

INFO Info[MAX_DOWNLOADS];

//------------------------------------------------------------------------
//------------------------------------------------------------------------

void MylstrcpyW(WCHAR *pwd, WCHAR *pws)
{
    while (*pws)
    {
        *pwd++ = *pws++;
    }
    *pwd = 0;
}

//------------------------------------------------------------------------
//------------------------------------------------------------------------
WCHAR *MyDupA2W(LPSTR pa)
{
    int i;
    WCHAR *pw, *pwd;

    i = lstrlen(pa);
    pw = (WCHAR *)CoTaskMemAlloc((i+1) * sizeof(WCHAR));
    pwd = pw;
    while (*pa)
    {
        *pwd++ = (WCHAR)*pa++;
    }
    *pwd++ = 0;

    return pw;
}

//------------------------------------------------------------------------
//------------------------------------------------------------------------
void SetSingleProcessorAffinity()
{
    PFNSPA pfn;

    pfn = (PFNSPA)GetProcAddress(GetModuleHandleA("KERNEL32.DLL"),
            "SetProcessAffinityMask");

    if (pfn)
    {
        pfn(GetCurrentProcess(), 1);
    }
}

//------------------------------------------------------------------------
//------------------------------------------------------------------------
VOID DisplayUsage(char **argv)
{
    printf("Usage: %s /u:url [/n:# /t:Title /r:RunStr /v:#]\n", argv[0]);
    printf("       %s /i:infile [/t:Title /r:RunStr /v:#]\n", argv[0]);
    printf("   /c   - write to cache (default is NOWRITECACHE)\n");
    printf("   /g   - read from cache (default is GETNEWESTVERSION)\n");
    printf("   /d   - direct read (default uses QueryDataAvailable)\n");
    printf("   /l:# - read buffer length\n");
    printf("   /m:module - pre load module\n");
    printf("   /n:# - download # times.\n");
    printf("   /1   - single processor affinity (default multiprocessor)\n");
    printf("   /v:# - verbose level 1=trace 2=dump data\n");
}

//------------------------------------------------------------------------
//------------------------------------------------------------------------
BOOL ProcessCommandLine(int argcIn, char **argvIn)
{
    BOOL bRC = FALSE;
    int argc = argcIn;
    char **argv = argvIn;

    argv++; argc--;
    if(argc == 0)
    {
        DisplayUsage(argvIn);
        return(FALSE);
    }
    
    while( argc > 0 && argv[0][0] == '/' )  
    {
        switch (argv[0][1]) 
        {
            case 'c':
            case 'C':
                g_dwCacheFlag &= ~BINDF_NOWRITECACHE;
                break;
            case 'g':
            case 'G':
                g_dwCacheFlag &= ~BINDF_GETNEWESTVERSION;
                break;
            case 'd':
            case 'D':
                g_dwCacheFlag |= BINDF_DIRECT_READ;
                break;
            case 'i':
            case 'I':
                g_pInfile = &argv[0][3];
                bRC = TRUE;
                break;
            case 'l':
            case 'L':
                dwBuf_Size =  atoi(&argv[0][3]);
                if(dwBuf_Size > MAX_BUF_SIZE)
                    dwBuf_Size = MAX_BUF_SIZE;
                break;
            case 'm':
            case 'M':
                g_pModule = &argv[0][3];
                break;
            case 'n':
            case 'N':
                g_dwNumDownloads = (DWORD)atoi(&argv[0][3]);
				g_dwNumDownloads = max(1, g_dwNumDownloads);
				g_dwNumDownloads = min(MAX_DOWNLOADS, g_dwNumDownloads);
                break;
            case 'r':
            case 'R':
                g_pRun = &argv[0][3];
                break;
            case 't':
            case 'T':
                g_pTitle = &argv[0][3];
                break;
            case 'u':
            case 'U':
                g_pwzUrl = MyDupA2W(&argv[0][3]);
                bRC = TRUE;
                break;
            case 'v':
            case 'V':
                g_dwVerbose = (DWORD)atoi(&argv[0][3]);
                break;
            case '1':
                SetSingleProcessorAffinity();
                break;
            case '?':
            default:
                DisplayUsage(argvIn);
                bRC = FALSE;
        }
        argv++; argc--;
    }

    return(bRC);
}

//------------------------------------------------------------------------
//------------------------------------------------------------------------
BOOL BuildInfoList(PINFO pInfo, DWORD dwNumDownloads)
{
    DWORD i = 0;
    
    if(g_pInfile != NULL)
    {
        TCHAR szName[INTERNET_MAX_URL_LENGTH+1];
        FILE *fp;

        if((fp = fopen(g_pInfile, "r")) == NULL)
        {
            printf("error opening file:%s GLE=%d\n", g_pInfile, GetLastError());
            return NULL;
        }

        while(fgets(szName, INTERNET_MAX_URL_LENGTH, fp) != NULL)
        {
            if(szName[0] != '#')
            {
                szName[strlen(szName) - sizeof(char)] = '\0';

                int rc;
                rc = MultiByteToWideChar(CP_ACP, 0, szName, -1, (pInfo+i)->wzUrl, INTERNET_MAX_URL_LENGTH);
                if (!rc)
                {
                    (pInfo+i)->wzUrl[INTERNET_MAX_URL_LENGTH-1] = 0;
                    wprintf(L"BuildInfoList:string too long; truncated to %s\n", (pInfo+i)->wzUrl);
                }
                i++;
            }
        }
        
        g_dwNumDownloads = i;
        fclose(fp);
    }
    else
    {
        for(i =0; i < dwNumDownloads; i++)
        {
            MylstrcpyW((pInfo+i)->wzUrl, g_pwzUrl);
        }
    }

    g_dwDownloads = g_dwNumDownloads;

    return(TRUE);
}

//------------------------------------------------------------------------
//------------------------------------------------------------------------
HRESULT StartDownloads(IOInetSession* pSession, PINFO pInfo, DWORD dwNumDownloads)
{
    HRESULT hr = NOERROR;
    
    for(DWORD i =0; i < dwNumDownloads; i++)
    {
        // Create a pluggable protocol
            hr = pSession->CreateBinding(
                NULL,           // [in ] BindCtx, always NULL 
                (pInfo+i)->wzUrl,         // [in ] url 
                NULL,           // [in ] IUnknown for Aggregration
                NULL,           // [out] IUNknown for Aggregration
                &(pInfo+i)->pProt,         // [out] return pProt pointer 
                0               // [in ] bind option, pass 0
            );
            if(g_dwVerbose & FLAG_TRACE)
                printf("MAIN:    Session->CreateBinding: %lx\n", hr);

        // Create a protocolHook (sink) and Start the async operation
        if( hr == NOERROR )
        {
            (pInfo+i)->pHook = new COInetProtocolHook(g_hCompleted, (pInfo+i)->pProt);
            (pInfo+i)->pSink = NULL;
            (pInfo+i)->pBindInfo = NULL;
            
            if( (pInfo+i)->pHook )
            {
                hr = (pInfo+i)->pHook->QueryInterface(IID_IOInetProtocolSink, (void**)&(pInfo+i)->pSink);
                hr = (pInfo+i)->pHook->QueryInterface(IID_IOInetBindInfo, (void**)&(pInfo+i)->pBindInfo);
            }

            if( (pInfo+i)->pProt && (pInfo+i)->pSink && (pInfo+i)->pBindInfo )
            {
                hr = (pInfo+i)->pProt->Start(
                    (pInfo+i)->wzUrl,                        
                    (pInfo+i)->pSink,    
                    (pInfo+i)->pBindInfo,
                    PI_FORCE_ASYNC, 
                    0 
                );
                if(g_dwVerbose & FLAG_TRACE)
                    printf("MAIN:    pProtocol->Start: %lx\n", hr);
            }
        }
    }

    return(hr);
}

//------------------------------------------------------------------------
//------------------------------------------------------------------------
VOID CleanInfoList(PINFO pInfo, DWORD dwNumDownloads)
{
    for(DWORD i = 0; i < dwNumDownloads; i++)
    {
        if((pInfo+i)->pProt)
            (pInfo+i)->pProt->Terminate(0);
        
        if( (pInfo+i)->pSink )
        {
            (pInfo+i)->pSink->Release();
        }
        if( (pInfo+i)->pBindInfo )
        {
            (pInfo+i)->pBindInfo->Release();
        }
        if( (pInfo+i)->pHook )
        {
            (pInfo+i)->pHook->Release();
        }
        
        // release COM objects
        if( (pInfo+i)->pProt )
        {
            //
            // BUG (POSSIBLE RESOURCE LEAK) 
            // If the pProt is IE's http/gopher/ftp implementation, 
            // calling pProt->Release() now might cause resource leak
            // since pProt (although finished the download), might
            // be still waiting wininet to call back about the 
            // confirmation of the handle closing.
            // The correct time to release pProt is to wait after 
            // pProtSink get destroyed.  
            //
            (pInfo+i)->pProt->Release();
        }
    }
}

//------------------------------------------------------------------------
//
//      Purpose:    create a session object
//                  Get a pluggable procotol from the session
//                  Start the pluggable protocol async download 
//
//      Author:     DanpoZ (Danpo Zhang)
//
//      History:    11-20-97    Created
//
//------------------------------------------------------------------------
int _cdecl main(int argc, char** argv) 
{
    IOInetSession* pSession = NULL;
    IOInetProtocol* pProt = NULL;
    HRESULT hr = NOERROR;
    DWORD dwLoadTime;
    HMODULE hMod = NULL;
    
    if(!ProcessCommandLine(argc, argv))
        return 0;
        
    // Init COM
    CoInitialize(NULL); 

	if(g_pModule != NULL)
	{
		hMod = LoadLibrary(g_pModule);
	}
	
    g_hCompleted = CreateEvent(NULL, FALSE, FALSE, NULL);
    
    // Get a Session
    hr = CoInternetGetSession(0, &pSession, 0);    
    if(g_dwVerbose & FLAG_TRACE)
        printf("MAIN:    Created Session: %lx\n", hr);

    if( hr == NOERROR )
    {
        if(!BuildInfoList(&Info[0], g_dwNumDownloads))
            return(2);

        hr = StartDownloads(pSession, &Info[0], g_dwNumDownloads);
    
        if( hr == NOERROR )
        {
            // wait until the async download finishes
            WaitForSingleObject(g_hCompleted, INFINITE);
        }

        StopCAP();
		QueryPerformanceCounter((LARGE_INTEGER *)&g_iend);
        QueryPerformanceFrequency((LARGE_INTEGER *)&g_ifreq);

        dwLoadTime = (LONG)(((g_iend - g_ibeg) * 1000) / g_ifreq);
        float fKB;
        float fSec;
        float fKBSec;

        if(dwLoadTime == 0)
            dwLoadTime = 1;
        fKB = ((float)g_dwTotalBytes)/1024;
        fSec = ((float)dwLoadTime)/1000;
        fKBSec = fKB / fSec;        
        printf("%s,%s,%d,%d,%2.0f\n", 
            g_pTitle ?g_pTitle :"Oinetperf",
            g_pRun ?g_pRun :"1",
            dwLoadTime, g_dwTotalBytes, fKBSec);

        CleanInfoList(&Info[0], g_dwNumDownloads);
    
    }


    if( pSession )
    {
        pSession->Release();
    }
    
    CoTaskMemFree(g_pwzUrl);

	if((g_pModule != NULL) && (hMod != NULL))
	{
		FreeLibrary(hMod);
	}

    // kill COM 
    CoUninitialize();

    return(0); 
}


COInetProtocolHook::COInetProtocolHook
(
    HANDLE g_hCompleted, 
    IOInetProtocol* pProt
)
{
    _hCompleted = g_hCompleted;
    _pProt = pProt;
}

COInetProtocolHook::~COInetProtocolHook() 
{
    CloseHandle(_hCompleted);
}

HRESULT
COInetProtocolHook::QueryInterface(REFIID iid, void **ppvObj)
{
    HRESULT hr = NOERROR;
    *ppvObj = NULL;

    if( iid == IID_IUnknown  || iid == IID_IOInetProtocolSink )
    {
        *ppvObj = static_cast<IOInetProtocolSink*>(this);
    } 
    else
    if( iid == IID_IOInetBindInfo )
    {
        *ppvObj = static_cast<IOInetBindInfo*>(this);
    }
    else
    if( iid == IID_IServiceProvider)
    {
        *ppvObj = static_cast<IServiceProvider*>(this);
    }
    else
    if( iid == IID_IHttpNegotiate )
    {
        *ppvObj = static_cast<IHttpNegotiate*>(this);
    }
    else
    {
        hr = E_NOINTERFACE;
    }

    if( *ppvObj )
    {
        AddRef();
    }

    return hr;
}    

ULONG    
COInetProtocolHook::AddRef(void)
{
    LONG lRet = ++_CRefs;
    return lRet;
}

ULONG
COInetProtocolHook::Release(void)
{
    LONG lRet = --_CRefs;

    if (lRet == 0)
    {
        delete this;
    }

    return lRet;
}

HRESULT
COInetProtocolHook::Switch( PROTOCOLDATA *pStateInfo)
{
    printf("Are you crazy? I don't know how to do Thread switching!!!\n"); 
    return E_NOTIMPL;
}

HRESULT
COInetProtocolHook::ReportProgress( ULONG ulStatusCode, LPCWSTR szStatusText)
{
    switch( ulStatusCode )
    {
        case BINDSTATUS_FINDINGRESOURCE:
            if(g_dwVerbose & FLAG_TRACE)
                wprintf(
                    L"CALLBACK(ReportProgress): Resolving name %s\n", szStatusText );  
            break;

        case BINDSTATUS_CONNECTING:
        if(g_dwVerbose & FLAG_TRACE)
                wprintf(L"CALLBACK(ReportProgress): Connecting to %s\n", szStatusText );
            break;

        case BINDSTATUS_SENDINGREQUEST:
            if(g_dwVerbose & FLAG_TRACE)
                wprintf(L"CALLBACK(ReportProgress): Sending request\n");
            break;

        case BINDSTATUS_CACHEFILENAMEAVAILABLE:
            if(g_dwVerbose & FLAG_TRACE)
                wprintf(L"CALLBACK(ReportProgress): cache filename available\n");
            break;

        case BINDSTATUS_MIMETYPEAVAILABLE:
            if(g_dwVerbose & FLAG_TRACE)
                wprintf(L"CALLBACK(ReportProgress): mimetype available = %s\n", szStatusText);
            break;

        case BINDSTATUS_REDIRECTING:
            if(g_dwVerbose & FLAG_TRACE)
                 wprintf(L"CALLBACK(ReportProgress): Redirecting to %s\n", szStatusText);
            break;

        default:
            if(g_dwVerbose & FLAG_TRACE)
                 wprintf(L"CALLBACK(ReportProgress): others...\n");
            break;
    }
    return NOERROR;
}

HRESULT 
COInetProtocolHook::ReportData( 
    DWORD grfBSCF, 
    ULONG ulProgress, 
    ULONG ulProgressMax
)
{
    if(g_dwVerbose & FLAG_TRACE)
        printf("CALLBACK(ReportData) %d, %d, %d \n", grfBSCF, ulProgress, ulProgressMax);

    // Pull data via pProt->Read(), here are the possible returned 
    // HRESULT values and how we should act upon: 
    // 
    // if E_PENDING is returned:  
    //    client already get all the data in buffer, there is nothing
    //    can be done here, client should walk away and wait for the  
    //    next chuck of data, which will be notified via ReportData()
    //    callback.
    // 
    // if S_FALSE is returned:
    //    this is EOF, everything is done, however, client must wait
    //    for ReportResult() callback to indicate that the pluggable 
    //    protocol is ready to shutdown.
    // 
    // if S_OK is returned:
    //    keep on reading, until you hit E_PENDING/S_FALSE/ERROR, the deal 
    //    is that the client is supposed to pull ALL the available
    //    data in the buffer
    // 
    // if none of the above is returning:
    //    Error occured, client should decide how to handle it, most
    //    commonly, client will call pProt->Abort() to abort the download
 
    char *pBuf = (char *)_alloca(dwBuf_Size);
    HRESULT hr = NOERROR;
    ULONG cbRead;

    while( hr == S_OK )       
    {
        cbRead = 0;

		if (g_ibeg == 0)
		{
			QueryPerformanceCounter((LARGE_INTEGER *)&g_ibeg);
			StartCAP();
		}


        // pull data

        if(g_dwVerbose & FLAG_TRACE)
        {
            printf("MAIN:    pProtocol->Read attempting %d bytes\n", dwBuf_Size);
        }

        hr = _pProt->Read((void*)pBuf, dwBuf_Size, &cbRead);
        if( (hr == S_OK || hr == E_PENDING || hr == S_FALSE) && cbRead )
        {
            if( g_dwVerbose & FLAG_DUMPDATA )
            {
                for( ULONG i = 0; i < cbRead; i++)
                {
                    printf("%c", pBuf[i]);    
                }    
            }

            if(g_dwVerbose & FLAG_TRACE)
            {
                printf("MAIN:    pProtocol->Read %d bytes\n", cbRead);
            }
            g_dwTotalBytes += cbRead;
        }
    }

    if( hr == S_FALSE )
    {
        if(g_dwVerbose & FLAG_TRACE)
            printf("MAIN:    pProtocol->Read returned EOF \n");
    }
    else 
    if( hr != E_PENDING )
    {
        if(g_dwVerbose & FLAG_TRACE)
        {
            printf("MAIN:    pProtocol->Read returned Error %1x \n, hr");
            printf("MAIN:    pProtocol->Abort called \n", hr);
        }
        _pProt->Abort(hr, 0);
    }

    return NOERROR;
}

HRESULT
COInetProtocolHook::ReportResult(
    HRESULT hrResult,
    DWORD   dwError,
    LPCWSTR wzResult
)
{
    // This is the last call back from the pluggable protocol, 
    // this call is equivlant to the IBindStatusCallBack::OnStopBinding()
    // it basically tells you that the pluggable protocol is ready
    // to shutdown

    if(g_dwVerbose & FLAG_TRACE)
        printf("CALLBACK(ReportResult): Download completed with status %1x\n", hrResult);

    // set event to the main thread
    if(InterlockedDecrement((LONG*)&g_dwDownloads ) == 0)
        SetEvent(g_hCompleted);
            
    return NOERROR;
}

HRESULT
COInetProtocolHook::GetBindInfo(
    DWORD *grfBINDF,
    BINDINFO * pbindinfo
)
{
    HRESULT hr = NOERROR;
    
//    *grfBINDF = BINDF_DIRECT_READ | BINDF_ASYNCHRONOUS | BINDF_PULLDATA;
//    *grfBINDF = BINDF_ASYNCHRONOUS | BINDF_ASYNCSTORAGE | BINDF_PULLDATA;
    *grfBINDF = BINDF_ASYNCHRONOUS | BINDF_ASYNCSTORAGE | BINDF_PULLDATA | BINDF_IGNORESECURITYPROBLEM;
    *grfBINDF |= g_dwCacheFlag;

    // for HTTP GET,  VERB is the only field we interested
    // for HTTP POST, BINDINFO will point to Storage structure which 
    //                contains data
    BINDINFO bInfo;
    ZeroMemory(&bInfo, sizeof(BINDINFO));

    // all we need is size and verb field
    bInfo.cbSize = sizeof(BINDINFO);
    bInfo.dwBindVerb = BINDVERB_GET;

    // src -> dest 
    hr = CopyBindInfo(&bInfo, pbindinfo ); 

    return hr;
}


static LPSTR g_szAcceptStrAll = "*/*";
HRESULT
COInetProtocolHook::GetBindString(
    ULONG ulStringType,
    LPOLESTR *ppwzStr,
    ULONG cEl,
    ULONG *pcElFetched
)
{

    HRESULT hr = INET_E_USE_DEFAULT_SETTING;

    switch (ulStringType)
    {
    case BINDSTRING_HEADERS     :
    case BINDSTRING_EXTRA_URL   :
    case BINDSTRING_LANGUAGE    :
    case BINDSTRING_USERNAME    :
    case BINDSTRING_PASSWORD    :
    case BINDSTRING_ACCEPT_ENCODINGS:
    case BINDSTRING_URL:
    case BINDSTRING_USER_AGENT  :
    case BINDSTRING_POST_COOKIE :
    case BINDSTRING_POST_DATA_MIME:
        break;

    case BINDSTRING_ACCEPT_MIMES:
        // IE4's http pluggable protocol implementation does not 
        // honer INET_E_USE_DEFAULT_SETTING returned by this function 
        // starting from IE5, client can just return the USE_DEFAULT 
        
// use for ie5 so we don't need a seperate bin for ie4  // #ifndef IE5
        // this will be freed by the caller
        *(ppwzStr + 0) = MyDupA2W(g_szAcceptStrAll);
        *(ppwzStr + 1) = NULL;
        *pcElFetched = 1;
        
        hr = NOERROR;
//#endif

        break;

    default:
        break; 
    }

    return hr;
}


HRESULT
COInetProtocolHook::QueryService(
    REFGUID guidService,
    REFIID  riid,
    void    **ppvObj 
)
{
    HRESULT hr = E_NOINTERFACE;
    *ppvObj = NULL;
    if( guidService == IID_IHttpNegotiate )
    {
        *ppvObj = static_cast<IHttpNegotiate*>(this);
    }
   
    if( *ppvObj )
    {
        AddRef();
        hr = NOERROR;
    } 
    
    
    return hr;
}


HRESULT
COInetProtocolHook::BeginningTransaction(
    LPCWSTR szURL,
    LPCWSTR szHeaders,
    DWORD   dwReserved,
    LPWSTR  *pszAdditionalHeaders
)
{
    if(g_dwVerbose & FLAG_TRACE)
        printf("HTTPNEGOTIATE: Additional Headers? - No \n"); 
    *pszAdditionalHeaders = NULL;
    return NOERROR;
}

HRESULT
COInetProtocolHook::OnResponse(
    DWORD    dwResponseCode,
    LPCWSTR  szResponseHeaders,
    LPCWSTR  szRequestHeaders,
    LPWSTR   *pszAdditionalHeaders
)
{
    if(g_dwVerbose & FLAG_TRACE)
        printf("HTTPNEGOTIATE: Http server response code %d\n", dwResponseCode);
    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\proxy\transmit.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994.
//
//  File:       transmit.h
//
//  Contents:   Function prototypes for STGMEDIUM marshalling.
//
//  Functions:  STGMEDIUM_to_xmit
//              STGMEDIUM_from_xmit
//              STGMEDIUM_free_inst
//
//  History:    May-10-94   ShannonC    Created
//
//--------------------------------------------------------------------------
EXTERN_C void __RPC_API STGMEDIUM_to_xmit (STGMEDIUM *pinst, RemSTGMEDIUM **ppxmit);
EXTERN_C void __RPC_API STGMEDIUM_from_xmit (RemSTGMEDIUM __RPC_FAR *pxmit, STGMEDIUM __RPC_FAR *pinst);
EXTERN_C void __RPC_API STGMEDIUM_free_inst(STGMEDIUM *pinst);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\proxy\daytona\makefile.inc ===
$(O)\urlmki_p.c : ..\..\idl\$(O)\urlmki_p.c
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\proxy\transmit.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       transmit.cxx
//
//  Contents:   Transmit_as routines for oleprx32.dll.
//
//  Functions:  operator new
//              operator delete
//              EXCEPINFO_to_xmit
//              EXCEPINFO_from_xmit
//              EXCEPINFO_free_inst
//              EXCEPINFO_free_xmit
//              HGLOBAL_to_xmit
//              HGLOBAL_from_xmit
//              HGLOBAL_free_inst
//              HGLOBAL_free_xmit
//              HMETAFILEPICT_to_xmit
//              HMETAFILEPICT_from_xmit
//              HMETAFILEPICT_free_inst
//              HMETAFILEPICT_free_xmit
//              HENHMETAFILE_to_xmit
//              HENHMETAFILE_from_xmit
//              HENHMETAFILE_free_inst
//              HENHMETAFILE_free_xmit
//              HBITMAP_to_xmit
//              HBITMAP_from_xmit
//              HBITMAP_free_inst
//              HBITMAP_free_xmit
//              HBRUSH_to_xmit
//              HBRUSH_from_xmit
//              HBRUSH_free_inst
//              HBRUSH_free_xmit
//              STGMEDIUM_to_xmit
//              STGMEDIUM_from_xmit
//              STGMEDIUM_free_inst
//              STGMEDIUM_free_xmit
//              HACCEL_to_xmit
//              HACCEL_from_xmit
//              HACCEL_free_inst
//              HACCEL_free_xmit
//              UINT_to_xmit
//              UINT_from_xmit
//              UINT_free_inst
//              UINT_free_xmit
//              WPARAM_to_xmit
//              WPARAM_from_xmit
//              WPARAM_free_inst
//              WPARAM_free_xmit
//
//  History:    24-Aug-93   ShannonC    Created
//              24-Nov-93   ShannonC    Added HGLOBAL
//              14-May-94   DavePl      Added HENHMETAFILE
//              18-May-94   ShannonC    Added HACCEL, UINT, WPARAM
//              19-May-94   DavePl      Added HENHMETAFILE to STGMEDIUM code
//              25-May-96   JohannP     Moved to urlmon; minor modifications
//
//--------------------------------------------------------------------------
#include "stdrpc.hxx"
#pragma hdrstop

#include "objbase.h"
#include "transmit.h"
#include "crtsubst.h"

#ifndef _CHICAGO_
    HBRUSH     OleGdiConvertBrush(HBRUSH hbrush);
    HBRUSH     OleGdiCreateLocalBrush(HBRUSH hbrushRemote);
#endif  // _CHICAGO_


void __RPC_USER HENHMETAFILE_to_xmit (HENHMETAFILE __RPC_FAR *pHEnhMetafile,
    RemHENHMETAFILE __RPC_FAR * __RPC_FAR *ppxmit);
void __RPC_USER HENHMETAFILE_from_xmit( RemHENHMETAFILE __RPC_FAR *pxmit,
    HENHMETAFILE __RPC_FAR *pHEnhMetafile );
void __RPC_USER HENHMETAFILE_free_xmit( RemHENHMETAFILE __RPC_FAR *pxmit);
void __RPC_USER HPALETTE_to_xmit (HPALETTE __RPC_FAR *pHPALETTE,
    RemHPALETTE __RPC_FAR * __RPC_FAR *ppxmit);
void __RPC_USER HPALETTE_from_xmit( RemHPALETTE __RPC_FAR *pxmit,
    HPALETTE __RPC_FAR *pHPALETTE );
void __RPC_USER HPALETTE_free_xmit( RemHPALETTE __RPC_FAR *pxmit);
void __RPC_USER HPALETTE_free_inst( HPALETTE __RPC_FAR *pHPALETTE);




WINOLEAPI_(void) ReleaseStgMedium(LPSTGMEDIUM pStgMed);

// BUGBUG: setting NTDEBUG=retail does not build this retail, so i cant
//     use DBG to conditionally generate this code, hence i must
//     disable it for now.
//
// #if DBG==1
// #define Assert(a) ((a) ? NOERROR : FnAssert(#a, NULL, __FILE__, __LINE__))
// #else
#define Assert(a) ((void)0)
// #endif

#pragma code_seg(".orpc")

// we dont need these when we are in with ole32.dll
#if 0
//+-------------------------------------------------------------------------
//
//  Function:  operator new
7//
//  Synopsis:  Override operator new so we don't need C runtime library.
//
//--------------------------------------------------------------------------
void *
_CRTAPI1
operator new (size_t size)
{
    return CoTaskMemAlloc(size);
}


//+-------------------------------------------------------------------------
//
//  Function:  operator delete
//
//  Synopsis:  Override operator delete so we don't need C runtime library.
//
//--------------------------------------------------------------------------
void
_CRTAPI1
operator delete (void * pObj)
{
    CoTaskMemFree(pObj);
}
#endif

//+-------------------------------------------------------------------------
//
//  class:  CPunkForRelease
//
//  purpose:    special IUnknown for remoted STGMEDIUMs
//
//  history:    02-Mar-94   Rickhi      Created
//
//  notes:  This class is used to do the cleanup correctly when certain
//      types of storages are passed between processes or machines
//      in Nt.
//
//      GLOBAL, GDI, and BITMAP handles cannot be passed between
//      processes, so we actually copy the whole data and create a
//      new handle in the receiving process. However, STGMEDIUMs have
//      this weird behaviour where if PunkForRelease is non-NULL then
//      the sender is responsible for cleanup, not the receiver. Since
//      we create a new handle in the receiver, we would leak handles
//      if we didnt do some special processing.  So, we do the
//      following...
//
//          During STGMEDIUM_from_xmit, if there is a pUnkForRelease
//          replace it with a CPunkForRelease.  When Release is called
//          on the CPunkForRelease, do the necessary cleanup work,
//          then call the real PunkForRelease.
//
//+-------------------------------------------------------------------------

class   CPunkForRelease : public IUnknown
{
public:
    CPunkForRelease(STGMEDIUM *pStgMed);

    //  IUnknown Methods
    STDMETHOD(QueryInterface)(REFIID riid, void **ppunk);
    STDMETHOD_(ULONG, AddRef)(void);
    STDMETHOD_(ULONG, Release)(void);

private:
    ~CPunkForRelease(void);

    ULONG       _cRefs;                 //  reference count
    STGMEDIUM   _stgmed;                //  storage medium
    IUnknown  * _pUnkForRelease;        //  real pUnkForRelease
};


inline CPunkForRelease::CPunkForRelease(STGMEDIUM *pStgMed) :
    _cRefs(1),
    _stgmed(*pStgMed)
{
    //  NOTE: we assume the caller has verified pStgMed is not NULL,
    //  and the pUnkForRelease is non-null, otherwise there is no
    //  point in constructing this object.  The tymed must also be
    //  one of the special ones.

    Assert(pStgMed);
    Assert(pStgMed->tymed == TYMED_HGLOBAL ||
       pStgMed->tymed == TYMED_GDI  ||
       pStgMed->tymed == TYMED_MFPICT  ||
       pStgMed->tymed == TYMED_ENHMF);

    _pUnkForRelease = pStgMed->pUnkForRelease;
}


inline CPunkForRelease::~CPunkForRelease()
{
    //  since we really have our own copies of these handles, just
    //  pretend like the callee is responsible for the release, and
    //  recurse into ReleaseStgMedium to do the cleanup.

    _stgmed.pUnkForRelease = NULL;
    ReleaseStgMedium(&_stgmed);

    //  release the callers punk
    _pUnkForRelease->Release();
}

STDMETHODIMP_(ULONG) CPunkForRelease::AddRef(void)
{
    InterlockedIncrement((LONG *)&_cRefs);
    return _cRefs;
}

STDMETHODIMP_(ULONG) CPunkForRelease::Release(void)
{
    if (InterlockedDecrement((LONG *)&_cRefs) == 0)
    {
    delete this;
    return 0;
    }
    else
    return _cRefs;
}

STDMETHODIMP CPunkForRelease::QueryInterface(REFIID riid, void **ppv)
{
    if (IsEqualIID(riid, IID_IUnknown))
    {
    *ppv = (void *)(IUnknown *) this;
    AddRef();
    return S_OK;
    }
    else
    {
    *ppv = NULL;
    return E_NOINTERFACE;
    }
}



#ifdef UNUSED
//+-------------------------------------------------------------------------
//
//  Function:   EXCEPINFO_to_xmit
//
//  Synopsis:   Convert an EXCEPINFO to a RemEXCEPINFO structure so it can be sent
//                              over the network.
//
//--------------------------------------------------------------------------
void __RPC_USER EXCEPINFO_to_xmit (EXCEPINFO *pinst, RemEXCEPINFO **ppxmit)
{
    unsigned int cSource = 0;
    unsigned int cDescription = 0;
    unsigned int cHelpFile = 0;
    unsigned int *pCount;
    wchar_t *pTemp;

    if(pinst->pfnDeferredFillIn)
    {
    //Fill in the EXCEPINFO structure.
    (pinst->pfnDeferredFillIn) (pinst);
    }

    //Calculate the total size of the strings.
    if(pinst->bstrSource)
    {
    pCount = (unsigned int *) pinst->bstrSource;
    pCount--;
    cSource = *pCount;
    }

    if(pinst->bstrDescription)
    {
    pCount = (unsigned int *) pinst->bstrDescription;
    pCount--;
    cDescription = *pCount;
    }

    if(pinst->bstrHelpFile)
    {
    pCount = (unsigned int *) pinst->bstrHelpFile;
    pCount--;
    cHelpFile = *pCount;
    }

    *ppxmit = (RemEXCEPINFO *) NdrOleAllocate(sizeof(RemEXCEPINFO) +
                          ((cSource + cDescription + cHelpFile) * sizeof(wchar_t)));
    (*ppxmit)->wCode = pinst->wCode;
    (*ppxmit)->wReserved = pinst->wReserved;
    (*ppxmit)->dwHelpContext = pinst->dwHelpContext;
    (*ppxmit)->scode = pinst->scode;
    (*ppxmit)->cSource = cSource;
    (*ppxmit)->cDescription = cDescription;
    (*ppxmit)->cHelpFile = cHelpFile;

    pTemp = (*ppxmit)->strings;
    if(pinst->bstrSource)
    {
    memcpy(pTemp, pinst->bstrSource, (*ppxmit)->cSource * sizeof(wchar_t));
    pTemp += cSource;
    }

    if(pinst->bstrDescription)
    {
    memcpy(pTemp, pinst->bstrDescription, (*ppxmit)->cDescription * sizeof(wchar_t));
    pTemp += cDescription;
    }

    if(pinst->bstrHelpFile)
    {
    memcpy(pTemp, pinst->bstrHelpFile, (*ppxmit)->cHelpFile * sizeof(wchar_t));
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   EXCEPINFO_from_xmit
//
//  Synopsis:   Convert a RemEXCEPINFO structure to an EXCEPINFO.
//
//--------------------------------------------------------------------------
void __RPC_USER EXCEPINFO_from_xmit (RemEXCEPINFO *pxmit, EXCEPINFO *pinst)
{
    wchar_t *pTemp;
    unsigned int *pCount;

    pinst->wCode = pxmit->wCode;
    pinst->wReserved = pxmit->wReserved;
    pinst->bstrSource = 0;
    pinst->bstrDescription = 0;
    pinst->bstrHelpFile = 0;
    pinst->dwHelpContext = pxmit->dwHelpContext;
    pinst->pvReserved = 0;
    pinst->pfnDeferredFillIn = 0;
    pinst->scode = pxmit->scode;

    //unmarshal BSTRs
    pTemp = pxmit->strings;

    if(pxmit->cSource)
    {
    pCount = (unsigned int *) NdrOleAllocate(sizeof(int) + pxmit->cSource * sizeof(wchar_t) + sizeof(wchar_t));

    //set the BSTR count.
    *pCount = pxmit->cSource;
    pCount++;
    pinst->bstrSource = (BSTR) pCount;

    //copy the BSTR characters
    memcpy(pinst->bstrSource, pTemp, pxmit->cSource * sizeof(wchar_t));

    //zero-terminate the BSTR.
    pinst->bstrSource[pxmit->cSource] = 0;

    //advance the data pointer.
    pTemp += pxmit->cSource;
    }

    if(pxmit->cDescription)
    {
    pCount = (unsigned int *) NdrOleAllocate(sizeof(int) + pxmit->cDescription * sizeof(wchar_t) + sizeof(wchar_t));

    //set the character count.
    *pCount = pxmit->cDescription;
    pCount++;
    pinst->bstrDescription = (BSTR) pCount;

    //copy the characters
    memcpy(pinst->bstrDescription, pTemp, pxmit->cDescription *sizeof(wchar_t));

    //zero-terminate the BSTR.
    pinst->bstrDescription[pxmit->cDescription] = 0;

    //advance the data pointer.
    pTemp += pxmit->cDescription;
    }

    if(pxmit->cHelpFile)
    {
    pCount = (unsigned int *) NdrOleAllocate(sizeof(int) + pxmit->cHelpFile * sizeof(wchar_t) + sizeof(wchar_t));

    //set the BSTR count.
    *pCount = pxmit->cHelpFile;
    pCount++;
    pinst->bstrHelpFile = (BSTR) pCount;

    //copy the BSTR characters
    memcpy(pinst->bstrHelpFile, pTemp, pxmit->cHelpFile * sizeof(wchar_t));

    //zero-terminate the BSTR.
    pinst->bstrHelpFile[pxmit->cHelpFile] = 0;

    //advance the data pointer.
    pTemp += pxmit->cHelpFile;
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   EXCEPINFO_free_inst
//
//  Synopsis:   Free the contents of an EXCEPINFO structure.
//
//--------------------------------------------------------------------------
void __RPC_USER EXCEPINFO_free_inst (EXCEPINFO *pinst)
{
    unsigned int *pInt;

    if(pinst)
    {
    if(pinst->bstrSource)
    {
        pInt = (unsigned int *) pinst->bstrSource;
        pInt--;
        NdrOleFree(pInt);
    }

    if(pinst->bstrDescription)
    {
        pInt = (unsigned int *) pinst->bstrDescription;
        pInt--;
        NdrOleFree(pInt);
    }

    if(pinst->bstrHelpFile)
    {
        pInt = (unsigned int *) pinst->bstrHelpFile;
        pInt--;
        NdrOleFree(pInt);
    }
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   EXCEPINFO_free_xmit
//
//  Synopsis:   Free a RemEXCEPINFO previously obtained via EXCEPINFO_to_xmit.
//
//--------------------------------------------------------------------------
void __RPC_USER EXCEPINFO_free_xmit (RemEXCEPINFO *pxmit)
{
    if(pxmit)
    {
    NdrOleFree(pxmit);
    }
}

#endif //UNUSED
//+-------------------------------------------------------------------------
//
//  Function:   HGLOBAL_to_xmit
//
//  Synopsis:   Convert an HGLOBAL to a RemHGLOBAL structure so it can be sent
//              over the network.
//
//  Derivation: We get the size of the global memory block,
//              allocate a RemHGLOBAL structure, then copy the contents
//              of the global memory block into the RemHGLOBAL structure.
//
//--------------------------------------------------------------------------

void __RPC_USER HGLOBAL_to_xmit (HGLOBAL *pinst, RemHGLOBAL **ppxmit)
{
    HGLOBAL hGlobal = *pinst;

    //calculate size - we give a null hGlobal a size of zero
    DWORD cbData = (DWORD) ((hGlobal)?GlobalSize(hGlobal):0);

    //allocate memory
    *ppxmit = (RemHGLOBAL *) NdrOleAllocate(sizeof(RemHGLOBAL) + cbData);

    // save size of variable length data
    (*ppxmit)->cbData = cbData;

    if (hGlobal != NULL)
    {
    // There is an hglobal to transmit
    (*ppxmit)->fNullHGlobal = FALSE;

    // Remember that an HGLOBAL can be alloc'd to zero size. So we
    // check whether there is anything to copy.
    if (cbData != 0)
    {
        // Copy the data
        void *pData = GlobalLock(hGlobal);
        memcpy((*ppxmit)->data, pData, cbData);
        GlobalUnlock(hGlobal);
    }
    }
    else
    {
    (*ppxmit)->fNullHGlobal = TRUE;
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   HGLOBAL_from_xmit
//
//  Synopsis:   Convert a RemHGLOBAL structure to an HGLOBAL.
//
//  Derivation: We get the data size, allocate a global memory block,
//                              then copy the data from the RemHGLOBAL structure to
//                              the global memory block.
//
//--------------------------------------------------------------------------
void __RPC_USER HGLOBAL_from_xmit (RemHGLOBAL __RPC_FAR *pxmit, HGLOBAL __RPC_FAR *pinst)
{
    // Default to NULL hglobal
    HGLOBAL hGlobal = NULL;
    void *pData;

    //allocate memory
    if (!pxmit->fNullHGlobal)
    {
    hGlobal = GlobalAlloc(GMEM_MOVEABLE, pxmit->cbData);

    if(hGlobal)
    {
        //copy the data
        pData = GlobalLock(hGlobal);
        if(pData)
        {
        memcpy(pData, pxmit->data, pxmit->cbData);
        GlobalUnlock(hGlobal);
        }
    }
    else
    {
        RpcRaiseException(E_OUTOFMEMORY);
    }
    }

    *pinst = hGlobal;
}

//+-------------------------------------------------------------------------
//
//  Function:   HGLOBAL_free_inst
//
//  Synopsis:   Free an HGLOBAL.
//
//--------------------------------------------------------------------------
void __RPC_USER HGLOBAL_free_inst(HGLOBAL *pinst)
{
    if(pinst)
    {
    if(*pinst)
    {
        GlobalFree(*pinst);
    }
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   HGLOBAL_free_xmit
//
//  Synopsis:   Free a RemHGLOBAL previously obtained via HGLOBAL_to_xmit.
//
//--------------------------------------------------------------------------
void __RPC_USER HGLOBAL_free_xmit(RemHGLOBAL *pxmit)
{
    if(pxmit != 0)
        NdrOleFree(pxmit);
}


//+-------------------------------------------------------------------------
//
//  Function:   HMETAFILEPICT_to_xmit
//
//  Synopsis:   Converts a metafilepict handle into a global handle
//              that can be remoted
//
//  Arguments:  [pHMetafilePict]-- pointer to the original metafile handle
//              [ppxmit]        -- set to point to the transmitted value
//
//  Returns:    void
//
//  Algorithm:  calls a private gdi api to convert the handle
//
//  History:    16-Nov-93 alexgo    created
//              07-Jan-94 rickhi    copy the metafile
//
//  Notes:
//
//--------------------------------------------------------------------------

void __RPC_USER HMETAFILEPICT_to_xmit (HMETAFILEPICT __RPC_FAR *pHMetafilePict,
    RemHMETAFILEPICT __RPC_FAR * __RPC_FAR *ppxmit)
{
#ifdef NEW_GDI_MARSHALLING
    //  CODEWORK: we can use this in the Daytona and Local Cairo case,
    //            but not in Chicago or remote Cairo

    //calculate size
    DWORD cbData = sizeof(long);

    //allocate memory
    *ppxmit = (RemHMETAFILEPICT *) NdrOleAllocate(sizeof(RemHMETAFILEPICT) + cbData);

    if (*ppxmit)
    {
    //copy data
    (*ppxmit)->cbData = cbData;
    // BUGBUG: enable this code!
    //long lData = (long)OleGdiConvertMetaFilePict(*(HANDLE *)pHMetafilePict);

    memcpy((*ppxmit)->data, &lData, cbData);
    }
    else
    {
    RpcRaiseException(E_OUTOFMEMORY);
    }

#else

    //  lock the data
    METAFILEPICT *pmfp = (METAFILEPICT *)GlobalLock(*(HANDLE *)pHMetafilePict);

    if (pmfp)
    {
    // calculate the size needed to hold the windows metafile
    DWORD cbData = GetMetaFileBitsEx(pmfp->hMF, 0, NULL);

    // allocate memory
    *ppxmit = (RemHMETAFILEPICT *) NdrOleAllocate(sizeof(RemHMETAFILEPICT) + cbData);

    // copy data
    (*ppxmit)->cbData = cbData;
    (*ppxmit)->mm     = pmfp->mm;
    (*ppxmit)->xExt   = pmfp->xExt;
    (*ppxmit)->yExt   = pmfp->yExt;

    GetMetaFileBitsEx(pmfp->hMF, cbData, &((*ppxmit)->data[0]));

    GlobalUnlock(*(HANDLE *)pHMetafilePict);
    }
    else
    {
    RpcRaiseException(E_OUTOFMEMORY);
    }

#endif
}

//+-------------------------------------------------------------------------
//
//  Function:   HMETAFILEPICT_from_xmit
//
//  Synopsis:   Converts a global metafilepict handle into a metafile
//              handle that a process can use
//
//  Arguments:  [pxmit]         -- the transmitted global handle
//              [pHMetafilePict]-- where to put the local metafilepict handle
//
//  Returns:    void
//
//  Algorithm:  calls a private gdi api to convert the global handle
//
//  History:    16-Nov-93 alexgo    created
//              07-Jan-94 rickhi    copy the metafile
//
//  Notes:
//
//--------------------------------------------------------------------------

void __RPC_USER HMETAFILEPICT_from_xmit( RemHMETAFILEPICT __RPC_FAR *pxmit,
    HMETAFILEPICT __RPC_FAR *pHMetafilePict )
{
#ifdef  NEW_GDI_MARSHALLLING
    //  CODEWORK: we can use this in the Daytona and Local Cairo case,
    //            but not in Chicago or remote Cairo

    long lh;
    memcpy(&lh, pxmit->data, pxmit->cbData);
    *pHMetafilePict = (HMETAFILE)GdiCreateLocalMetaFilePict(
                (HANDLE)lh);
#else

    // allocate memory
    HGLOBAL hGlobal = GlobalAlloc(GMEM_MOVEABLE, sizeof(METAFILEPICT));
    *pHMetafilePict = hGlobal;

    if(hGlobal)
    {
    //copy the data
    METAFILEPICT *pmfp = (METAFILEPICT *)GlobalLock(hGlobal);
    if(pmfp)
    {
        pmfp->mm     = pxmit->mm;
        pmfp->xExt   = pxmit->xExt;
        pmfp->yExt   = pxmit->yExt;

        //  create a windows metatfile from the data
        pmfp->hMF = SetMetaFileBitsEx(pxmit->cbData, pxmit->data);
        GlobalUnlock(hGlobal);
    }
    }
    else
    {
    RpcRaiseException(E_OUTOFMEMORY);
    }

#endif
}

//+-------------------------------------------------------------------------
//
//  Function:   HMETAFILEPICT_free_xmit
//
//  Synopsis:   Free's the global metafilepict handle that gets remoted
//
//  Arguments:  [pxmit]         -- the transmitted metafilepict handle
//
//  Returns:    void
//
//  History:    16-Nov-93 alexgo    created
//
//  Notes:
//
//--------------------------------------------------------------------------

void __RPC_USER HMETAFILEPICT_free_xmit( RemHMETAFILEPICT __RPC_FAR *pxmit)
{
    if(pxmit != 0)
        NdrOleFree(pxmit);
}

//+-------------------------------------------------------------------------
//
//  Function:   HMETAFILEPICT_free_inst
//
//  Synopsis:   does nothing, as no memory is allocated
//
//  Arguments:  [pHMetafilePict]        -- pointer to the metafilepict
//
//  Returns:    void
//
//  Algorithm:
//
//  History:    16-Nov-93 alexgo    created
//
//  Notes:
//
//--------------------------------------------------------------------------

void __RPC_USER HMETAFILEPICT_free_inst( HMETAFILEPICT __RPC_FAR *pHMetafilePict)
{
    METAFILEPICT *pmf;

    if(*pHMetafilePict)
    {
    pmf = (METAFILEPICT *) GlobalLock(*pHMetafilePict);
    if(pmf)
    {
        DeleteMetaFile(pmf->hMF);
        GlobalUnlock(*pHMetafilePict);
    }
    GlobalFree(*pHMetafilePict);
    }
}


#ifndef NEW_GDI_MARSHALLLING
//+-------------------------------------------------------------------------
//
//  Function:   GetColorTableSize
//
//  Synopsis:   computes the size of the color table using the info in
//      the supplied BITMAPINFO
//
//  Arguments:  [pbmi]   -- pointer to the BITMAPINFO for the bitmap
//
//  Returns:    size of the color table
//
//+-------------------------------------------------------------------------

ULONG  GetColorTableSize(BITMAPINFO *pbmi)
{
    // compute size of memory needed. it must account for the header
    // info, color table, and bitmap, as well as the RemHBITMAP.

    ULONG ulColorTableSize;
    if (pbmi->bmiHeader.biClrUsed)
    {
    // biClrUsed contains number of RGBQUADs used
    ulColorTableSize = pbmi->bmiHeader.biClrUsed;
    }
    else if (pbmi->bmiHeader.biCompression == BI_BITFIELDS)
    {
    // size is 3 DWORD color masks. sizeof(DWORD) == sizeof(RGBQUAD)
    ulColorTableSize = 3;
    }
    else
    {
    // compute number of RGBQUADs from biBitCount
    ulColorTableSize = (pbmi->bmiHeader.biBitCount == 24) ? 0 :
               (1<<pbmi->bmiHeader.biBitCount);
    }

    return (ulColorTableSize * sizeof(RGBQUAD));
}
#endif


//+-------------------------------------------------------------------------
//
//  Function:   HBITMAP_to_xmit
//
//  Synopsis:   Converts a bitmap handle into a global handle
//              that can be remoted
//
//  Arguments:  [pBitmap]       -- pointer to the original bitmap handle
//              [ppxmit]        -- set to point to the transmitted value
//
//  Returns:    void
//
//  Algorithm:  calls a private gdi api to convert the handle
//
//  History:    16-Nov-93 alexgo    created
//              07-Jan-94 rickhi    copy the bitmap
//              12-Aug-94 davepl    Rewrote OLD_GDI_MARSHALLING section
//
//  Notes:      CODEWORK: this code specifically does not account for OS2
//              style DIBs.  Verify this is OK.  Unless the Windows APIs
//              deal with OS2 bitmaps on their own...
//
//--------------------------------------------------------------------------

void __RPC_USER HBITMAP_to_xmit (HBITMAP __RPC_FAR *pBitmap,
    RemHBITMAP __RPC_FAR * __RPC_FAR *ppxmit)
{
#ifdef  NEW_GDI_MARSHALLLING
    //  CODEWORK: we can use this in the Daytona and Local Cairo case,
    //            but not in Chicago or remote Cairo

    //calculate size
    DWORD cbData = sizeof(long);

    //allocate memory
    *ppxmit = (RemHBITMAP *) NdrOleAllocate(sizeof(RemHBITMAP) + cbData);

    if (*ppxmit)
    {
    //copy data
    (*ppxmit)->cbData = cbData;
    long lData = (long)GdiConvertBitmap(*pBitmap);
    memcpy((*ppxmit)->data, &lData, cbData);
    }
    else
    {
    RpcRaiseException(E_OUTOFMEMORY);
    }

#else

    BITMAP bm;
    HBITMAP hBitmap = (HBITMAP) * pBitmap;

    // Get information about the bitmap

#if defined(_CHICAGO_)
    if (FALSE == GetObjectA(hBitmap, sizeof(BITMAP), &bm))
#else
    if (FALSE == GetObject(hBitmap, sizeof(BITMAP), &bm))
#endif
    {
        RpcRaiseException(HRESULT_FROM_WIN32(GetLastError()));
    }

    // Allocate space for the raw bitmap bits and the bm structure, plus
    // the RemHBITMAP structure all at once.

    DWORD dwCount = bm.bmPlanes * bm.bmHeight * bm.bmWidthBytes;
    *ppxmit = (RemHBITMAP *) (BYTE *) NdrOleAllocate(sizeof(RemHBITMAP)
                                                     + dwCount + sizeof(bm));

    if (NULL == *ppxmit)
    {
        RpcRaiseException(E_OUTOFMEMORY);
    }

    // lpBits points to the portion of the RemHBITMAP structure where
    // we will store the BITMAP structure and raw bits

    BYTE * lpBits = (BYTE *) &(*ppxmit)->data[0];

    // Get the raw bits.  Offset sizeof(BITMAP) into the buffer so
    // that we can stick the BITMAP struct at the front before
    // transmission

    if (0 == GetBitmapBits(hBitmap, dwCount, lpBits + sizeof(bm)))
    {
        NdrOleFree(*ppxmit);
        *ppxmit = NULL;
        RpcRaiseException(HRESULT_FROM_WIN32(GetLastError()));
    }

    // Stuff the bm structure in before the bits

    memcpy(lpBits, (void *) &bm, sizeof(bm));

    (*ppxmit)->cbData = dwCount + sizeof(bm);

#endif
}

//+-------------------------------------------------------------------------
//
//  Function:   HBITMAP_from_xmit
//
//  Synopsis:   Converts a global bitmap handle into a bitmap
//              handle that a process can use
//
//  Arguments:  [pxmit]         -- the transmitted global handle
//              [pBitmap]       -- where to put the local bitmap handle
//
//  Returns:    void
//
//  Algorithm:  Creates a local bitmap and then associates the remote
//              bitmap with the local one.
//
//  History:    16-Nov-93 alexgo    created
//              07-Jan-94 rickhi    copy the bitmap
//              12-Aug-94 davepl    rewrote the OLD_GDI_MARSHALLING section
//
//  Notes:
//
//--------------------------------------------------------------------------

void __RPC_USER HBITMAP_from_xmit( RemHBITMAP __RPC_FAR *pxmit,
    HBITMAP __RPC_FAR *pBitmap )
{
#ifdef  NEW_GDI_MARSHALLLING
    //  CODEWORK: we can use this in the Daytona and Local Cairo case,
    //            but not in Chicago or remote Cairo

    ULONG hLocal = (ULONG)GdiCreateLocalBitmap();

    ULONG lh;
    memcpy(&lh, pxmit->data, pxmit->cbData);

    GdiAssociateObject(hLocal, lh);
    *pBitmap = (HBITMAP)hLocal;

#else

    BITMAP * pbm    = (BITMAP *) &(pxmit->data[0]);
    BYTE   * lpBits = ((BYTE *) pbm) + sizeof(BITMAP);

    // Create a bitmap based on the BITMAP structure and the raw bits in
    // the transmission buffer

    *pBitmap = CreateBitmap(pbm->bmWidth,
                            pbm->bmHeight,
                            pbm->bmPlanes,
                            pbm->bmBitsPixel,
                            (void *) lpBits);

    // If no bitmap came back, raise an exception rather than just returning

    if (NULL == *pBitmap)
    {
        RpcRaiseException(HRESULT_FROM_WIN32(GetLastError()));
    }


#endif
}

//+-------------------------------------------------------------------------
//
//  Function:   HBITMAP_free_xmit
//
//  Synopsis:   Free's the buffer used to serialize the bitmap
//
//  Effects:
//
//  Arguments:  [pxmit]         -- the transmitted bitmap serialized buffer
//
//  Returns:    void
//
//  History:    dd-mmm-yy Author    Comment
//              16-Nov-93 alexgo    created
//
//  Notes:
//
//--------------------------------------------------------------------------

void __RPC_USER HBITMAP_free_xmit( RemHBITMAP __RPC_FAR *pxmit)
{
    if(pxmit != 0)
        NdrOleFree(pxmit);
}

//+-------------------------------------------------------------------------
//
//  Function:   HBITMAP_free_inst
//
//  Synopsis:   Destroys the bitmap object
//
//  Arguments:  [pBitmap]       -- pointer to the bitmap handle
//
//  Returns:    void
//
//  History:    dd-mmm-yy Author    Comment
//              16-Nov-93 alexgo    created
//
//  Notes:
//
//--------------------------------------------------------------------------

void __RPC_USER HBITMAP_free_inst( HBITMAP __RPC_FAR *pBitmap)
{
    DeleteObject(*pBitmap);
}


//+-------------------------------------------------------------------------
//
//  Function:   HBRUSH_to_xmit
//
//  Synopsis:   Converts a brush handle into a global handle
//              that can be remoted
//
//  Arguments:  [pBrush]        -- pointer to the original brush handle
//              [ppxmit]        -- set to point to the transmitted value
//
//  Returns:    void
//
//  Algorithm:  calls a private gdi api to convert the handle
//
//  History:    dd-mmm-yy Author    Comment
//              16-Nov-93 alexgo    created
//
//  Notes:
//
//--------------------------------------------------------------------------

void __RPC_USER HBRUSH_to_xmit (HBRUSH __RPC_FAR *pBrush,
    RemHBRUSH __RPC_FAR * __RPC_FAR *ppxmit)
{
#ifndef _CHICAGO_
    //  CODEWORK: we can use this in the Daytona and Local Cairo case,
    //            but not in Chicago or remote Cairo

    //calculate size
    DWORD cbData = sizeof(long);

    //allocate memory
    *ppxmit = (RemHBRUSH *) NdrOleAllocate(sizeof(RemHBRUSH) + cbData);

    if (*ppxmit)
    {
    //copy data
    (*ppxmit)->cbData = cbData;

    // BUGBUG: enable this code!
    //long lData = (long)OleGdiConvertBrush(*pBrush);
    //memcpy((*ppxmit)->data, &lData, cbData);
    }
    else
    {
    RpcRaiseException(E_OUTOFMEMORY);
    }
#endif
}

//+-------------------------------------------------------------------------
//
//  Function:   HBRUSH_from_xmit
//
//  Synopsis:   Converts a global brush handle into a brush
//              handle that a process can use
//
//  Arguments:  [pxmit]         -- the transmitted global handle
//              [pBrush]        -- where to put the local brush handle
//
//  Returns:    void
//
//  Algorithm:  calls a private gdi api to convert the global handle
//
//  History:    dd-mmm-yy Author    Comment
//              16-Nov-93 alexgo    created
//
//  Notes:
//
//--------------------------------------------------------------------------

void __RPC_USER HBRUSH_from_xmit( RemHBRUSH __RPC_FAR *pxmit,
    HBRUSH __RPC_FAR *phBrush )
{
#ifndef _CHICAGO_
    //  CODEWORK: we can use this in the Daytona and Local Cairo case,
    //            but not in Chicago or remote Cairo

    // BUGBUG: enable this code!
    //*phBrush = OleGdiCreateLocalBrush((HBRUSH)(pxmit->data));
    *phBrush = NULL;

#endif
}

//+-------------------------------------------------------------------------
//
//  Function:   HBRUSH_free_xmit
//
//  Synopsis:   Free's the global brush handle that gets remoted
//
//  Arguments:  [pxmit]         -- the transmitted brush handle
//
//  Returns:    void
//
//  History:    dd-mmm-yy Author    Comment
//              16-Nov-93 alexgo    created
//
//  Notes:
//
//--------------------------------------------------------------------------

void __RPC_USER HBRUSH_free_xmit( RemHBRUSH __RPC_FAR *pxmit)
{
#ifndef _CHICAGO_
    if(pxmit != 0)
        NdrOleFree(pxmit);
#endif
}

//+-------------------------------------------------------------------------
//
//  Function:   HBRUSH_free_inst
//
//  Synopsis:   Delete an HBRUSH.
//
//  Arguments:  [pBrush]        -- pointer to the metafile
//
//  Returns:    void
//
//  History:    dd-mmm-yy Author    Comment
//              16-Nov-93 alexgo    created
//
//  Notes:
//
//--------------------------------------------------------------------------

void __RPC_USER HBRUSH_free_inst( HBRUSH __RPC_FAR *pBrush)
{
#ifndef _CHICAGO_
    DeleteObject(*pBrush);
#endif
}

/***************************************************************************/
STDMETHODIMP_(ULONG) CStreamOnMessage::AddRef( THIS )
{
  return ref_count += 1;
}

/***************************************************************************/
STDMETHODIMP CStreamOnMessage::Clone(THIS_ IStream * *ppstm)
{
  return ResultFromScode(E_NOTIMPL);
}

/***************************************************************************/
STDMETHODIMP CStreamOnMessage::Commit(THIS_ DWORD grfCommitFlags)
{
  return ResultFromScode(E_NOTIMPL);
}

/***************************************************************************/
STDMETHODIMP CStreamOnMessage::CopyTo(THIS_ IStream *pstm,
                  ULARGE_INTEGER cb,
                  ULARGE_INTEGER *pcbRead,
                  ULARGE_INTEGER *pcbWritten)
{
  return ResultFromScode(E_NOTIMPL);
}

/***************************************************************************/
CStreamOnMessage::CStreamOnMessage(unsigned char **ppMessageBuffer)
    : ref_count(1), ppBuffer(ppMessageBuffer), cbMaxStreamLength(0xFFFFFFFF)
{
    pStartOfStream = *ppMessageBuffer;
}

/***************************************************************************/
STDMETHODIMP CStreamOnMessage::LockRegion(THIS_ ULARGE_INTEGER libOffset,
                  ULARGE_INTEGER cb,
                  DWORD dwLockType)
{
  return ResultFromScode(E_NOTIMPL);
}

/***************************************************************************/
STDMETHODIMP CStreamOnMessage::QueryInterface( REFIID riid, LPVOID FAR* ppvObj)
{
  if (IsEqualIID(riid, IID_IUnknown))
  {
    *ppvObj = (IUnknown *) this;
    ref_count += 1;
    return ResultFromScode(S_OK);
  }
  else if (IsEqualIID(riid, IID_IStream))
  {
    *ppvObj = (IStream *) this;
    ref_count += 1;
    return ResultFromScode(S_OK);
  }
  else
    return ResultFromScode(E_NOINTERFACE);
}

/***************************************************************************/
STDMETHODIMP CStreamOnMessage::Read(THIS_ VOID HUGEP *pv,
                  ULONG cb, ULONG *pcbRead)
{
  memcpy( pv, *ppBuffer, cb );
  *ppBuffer += cb;
  if (pcbRead != NULL)
    *pcbRead = cb;
  return ResultFromScode(S_OK);
}

/***************************************************************************/
STDMETHODIMP_(ULONG) CStreamOnMessage::Release( THIS )
{
  ref_count -= 1;
  if (ref_count == 0)
  {
    delete this;
    return 0;
  }
  else
    return ref_count;

}

/***************************************************************************/
STDMETHODIMP CStreamOnMessage::Revert(THIS)
{
  return ResultFromScode(E_NOTIMPL);
}

/***************************************************************************/
STDMETHODIMP CStreamOnMessage::Seek(THIS_ LARGE_INTEGER dlibMove,
                  DWORD dwOrigin,
                  ULARGE_INTEGER *plibNewPosition)
{
  ULONG   pos;

  // Verify that the offset isn't out of range.
  if (dlibMove.HighPart != 0)
    return ResultFromScode( E_FAIL );

  // Determine the new seek pointer.
  switch (dwOrigin)
  {
    case STREAM_SEEK_SET:
      pos = dlibMove.LowPart;
      break;

    case STREAM_SEEK_CUR:
      /* Must use signed math here. */
      pos = (ULONG) (*ppBuffer - pStartOfStream);
      if ((long) dlibMove.LowPart < 0 &&
      pos < (unsigned long) - (long) dlibMove.LowPart)
    return ResultFromScode( E_FAIL );
      pos += (long) dlibMove.LowPart;
      break;

    case STREAM_SEEK_END:
        return ResultFromScode(E_NOTIMPL);
    break;

    default:
      return ResultFromScode( E_FAIL );
  }

  // Set the seek pointer.
  *ppBuffer = pStartOfStream + pos;
  if (plibNewPosition != NULL)
  {
    plibNewPosition->LowPart = pos;
    plibNewPosition->HighPart = 0;
  }
  return ResultFromScode(S_OK);
}

/***************************************************************************/
STDMETHODIMP CStreamOnMessage::SetSize(THIS_ ULARGE_INTEGER libNewSize)
{
  return ResultFromScode(E_NOTIMPL);
}

/***************************************************************************/
STDMETHODIMP CStreamOnMessage::Stat(THIS_ STATSTG *pstatstg, DWORD grfStatFlag)
{
  return ResultFromScode(E_NOTIMPL);
}

/***************************************************************************/
STDMETHODIMP CStreamOnMessage::UnlockRegion(THIS_ ULARGE_INTEGER libOffset,
                  ULARGE_INTEGER cb,
                  DWORD dwLockType)
{
  return ResultFromScode(E_NOTIMPL);
}

/***************************************************************************/
STDMETHODIMP CStreamOnMessage::Write(THIS_ VOID const HUGEP *pv,
                  ULONG cb,
                  ULONG *pcbWritten)
{
  // Write the data.
  memcpy( *ppBuffer, pv, cb );
  if (pcbWritten != NULL)
    *pcbWritten = cb;
  *ppBuffer += cb;
  return ResultFromScode(S_OK);
}


//+-------------------------------------------------------------------------
//
//  Function:   STGMEDIUM_to_xmit
//
//  Synopsis:   Convert an STGMEDIUM to a RemSTGMEDIUM structure so it can be sent
//                              over the network.
//
//                              The marshalled STGMEDIUM looks like this:
//                              RemSTGMEDIUM | data from union | data from pUnkForRelease
//--------------------------------------------------------------------------

void __RPC_USER STGMEDIUM_to_xmit (STGMEDIUM *pinst, RemSTGMEDIUM **ppxmit)
{
    unsigned char *pData;
    RemHGLOBAL *pRemHGLOBAL;
    RemHBITMAP *pRemHBITMAP;
    RemHPALETTE *pRemHPALETTE;
    RemHMETAFILEPICT *pRemHMETAFILEPICT;
    RemHENHMETAFILE *pRemHENHMETAFILE;

    long size;
    unsigned long count;
    unsigned long cbInterface;
    HRESULT hr = S_OK;
    DWORD *pcbData;
    DWORD *pcbSize;
    DWORD cbData;
    unsigned char *pStart;

    // If the TYMED for the STGMEDIUM is TYMED_GDI, we need a bit more information
    // (ie: what _kind_ of GDI object it is).  The field is unused for anything
    // except TYMED_GDI

    DWORD dwHandleType = 0;

    //calculate size of marshalled STGMEDIUM.
    size = sizeof(RemSTGMEDIUM);

    //add the size of data[].
    switch(pinst->tymed)
    {
    case TYMED_NULL:
        break;
    case TYMED_MFPICT:
        HMETAFILEPICT_to_xmit(&pinst->hMetaFilePict, &pRemHMETAFILEPICT);
        size += sizeof(RemHMETAFILEPICT) + pRemHMETAFILEPICT->cbData;
        break;
    case TYMED_ENHMF:
        HENHMETAFILE_to_xmit(&pinst->hEnhMetaFile, &pRemHENHMETAFILE);
        size += sizeof(RemHENHMETAFILE) + pRemHENHMETAFILE->cbData;
        break;
    case TYMED_GDI:

        // A GDI object is not necesarrily a BITMAP.  Therefore, we handle
        // those types we know about based on the object type, and reject
        // those which we do not support.

        switch(GetObjectType( (HGDIOBJ) pinst->hGlobal ))
        {
            case OBJ_BITMAP:

                HBITMAP_to_xmit(&pinst->hBitmap, &pRemHBITMAP);
                size += sizeof(RemHBITMAP) + pRemHBITMAP->cbData;
                dwHandleType = OBJ_BITMAP;
                break;

            case OBJ_PAL:

                HPALETTE_to_xmit((HPALETTE *) &pinst->hBitmap, &pRemHPALETTE);
                size += sizeof(RemHPALETTE) + pRemHPALETTE->cbData;
                dwHandleType = OBJ_PAL;
                break;

            default:
                RpcRaiseException(DV_E_TYMED);
        }
        break;

    case TYMED_HGLOBAL:
        HGLOBAL_to_xmit(&pinst->hGlobal, &pRemHGLOBAL);
        size += sizeof(RemHGLOBAL) + pRemHGLOBAL->cbData;
        break;
    case TYMED_FILE:
        count = wcslen(pinst->lpszFileName) + 1;
        size += 4; //allocate room for character count.
        size += count * sizeof(wchar_t);
        break;
    case TYMED_ISTREAM:
        size += 4;
        if(pinst->pstm)
        {
            //Align the buffer on an 4 byte boundary.
            size += 3;
            size &= (unsigned int)0xfffffffc;

            //Allocate space for the length and array bounds.
            size += 8;

            hr = CoGetMarshalSizeMax(&cbInterface, IID_IStream, pinst->pstm, MSHCTX_LOCAL, 0, MSHLFLAGS_NORMAL);
            if(hr == S_OK)
            size += cbInterface;
        }
        break;
    case TYMED_ISTORAGE:
        size += 4;
        if(pinst->pstg)
        {
            //Align the buffer on an 4 byte boundary.
            size += 3;
            size &= (unsigned int)0xfffffffc;

            //Allocate space for the length and array bounds.
            size += 8;

            hr = CoGetMarshalSizeMax(&cbInterface, IID_IStorage, pinst->pstg, MSHCTX_LOCAL, 0, MSHLFLAGS_NORMAL);
            if(hr == S_OK)
            size += cbInterface;
        }
        break;
    default:
        break;
    }


    //Allocate space for pUnkForRelease.
    if(pinst->pUnkForRelease)
    {
        //Align the buffer on an 4 byte boundary.
        size += 3;
        size &= (unsigned int)0xfffffffc;

        //Allocate space for the length and array bounds.
        size += 8;

        hr = CoGetMarshalSizeMax(&cbInterface, IID_IUnknown, pinst->pUnkForRelease, MSHCTX_NOSHAREDMEM, 0, MSHLFLAGS_NORMAL);
    if(hr == S_OK)
    {
        size += cbInterface;
    }
    }

    //allocate memory
    *ppxmit = (RemSTGMEDIUM *) NdrOleAllocate(size);

    //Marshal STGMEDIUM
    (*ppxmit)->tymed = pinst->tymed;
    //SUNDOWN: typecast problem
    (*ppxmit)->pData = PtrToUlong(pinst->hGlobal);
    (*ppxmit)->pUnkForRelease = PtrToUlong(pinst->pUnkForRelease);
    (*ppxmit)->cbData = size - sizeof(RemSTGMEDIUM);
    (*ppxmit)->dwHandleType = dwHandleType;

    pData = (*ppxmit)->data;

    switch(pinst->tymed)
    {
    case TYMED_NULL:
        break;
    case TYMED_MFPICT:
        //Note that we called HMETAFILEPICT_to_xmit earlier so we could
        //get the size.
        memcpy(pData, pRemHMETAFILEPICT, sizeof(RemHMETAFILEPICT) + pRemHMETAFILEPICT->cbData);
        pData += sizeof(RemHMETAFILEPICT) + pRemHMETAFILEPICT->cbData;
        HMETAFILEPICT_free_xmit(pRemHMETAFILEPICT);
        break;
    case TYMED_ENHMF:
        memcpy(pData, pRemHENHMETAFILE, sizeof(RemHENHMETAFILE) + pRemHENHMETAFILE->cbData);
        pData += sizeof(RemHENHMETAFILE) + pRemHENHMETAFILE->cbData;
        HENHMETAFILE_free_xmit(pRemHENHMETAFILE);
        break;
    case TYMED_HGLOBAL:
        //Note that we called HGLOBAL_to_xmit earlier so we could
        //get the size.
        memcpy(pData, pRemHGLOBAL, sizeof(RemHGLOBAL) + pRemHGLOBAL->cbData);
    pData += sizeof(RemHGLOBAL) + pRemHGLOBAL->cbData;
        HGLOBAL_free_xmit(pRemHGLOBAL);
        break;

    case TYMED_GDI:

        switch(dwHandleType)
        {
        case OBJ_BITMAP:

            memcpy(pData, pRemHBITMAP, sizeof(RemHBITMAP) + pRemHBITMAP->cbData);
            pData += sizeof(RemHBITMAP) + pRemHBITMAP->cbData;
            HBITMAP_free_xmit(pRemHBITMAP);
            break;

        case OBJ_PAL:

            memcpy(pData, pRemHPALETTE, sizeof(RemHPALETTE) + pRemHPALETTE->cbData);
            pData += sizeof(RemHPALETTE) + pRemHPALETTE->cbData;
            HPALETTE_free_xmit(pRemHPALETTE);
        }

        break;

    case TYMED_FILE:
        //copy the length.
        memcpy(pData, &count, sizeof(count));
        pData += sizeof(count);

        //copy the string.
    memcpy(pData, pinst->lpszFileName, count * sizeof(wchar_t));
        pData += count * sizeof(wchar_t);
        break;
    case TYMED_ISTREAM:
        if(pinst->pstm)
        {
            CStreamOnMessage stream((unsigned char **) &pData);

            //Align the buffer on an 4 byte boundary
            *(unsigned long FAR *)&pData += 3;
            *(unsigned long FAR *)&pData &= 0xfffffffc;

            //Leave space for cbData.
            pcbData = (DWORD *) pData;
            *(unsigned long FAR *)&pData += 4;

            //Leave space for size.
            pcbSize = (DWORD *) pData;
        *(unsigned long FAR *)&pData += 4;

            pStart = (unsigned char *) pData;

            hr = CoMarshalInterface(&stream, IID_IStream, pinst->pstm, MSHCTX_LOCAL, 0, MSHLFLAGS_NORMAL);
            if(hr != S_OK)
            {
                RpcRaiseException(hr);
            }

            cbData = (DWORD) (pData - pStart);
            *pcbData = cbData;
            *pcbSize = cbData;
        }
        break;
    case TYMED_ISTORAGE:
        if(pinst->pstg)
        {
            CStreamOnMessage stream((unsigned char **) &pData);

            //Align the buffer on an 4 byte boundary
            *(unsigned long FAR *)&pData += 3;
            *(unsigned long FAR *)&pData &= 0xfffffffc;

            //Leave space for cbData.
            pcbData = (DWORD *) pData;
            *(unsigned long FAR *)&pData += 4;

            //Leave space for size.
            pcbSize = (DWORD *) pData;
            *(unsigned long FAR *)&pData += 4;

            pStart = (unsigned char *) pData;

            hr = CoMarshalInterface(&stream, IID_IStorage, pinst->pstg, MSHCTX_LOCAL, 0, MSHLFLAGS_NORMAL);
            if(hr != S_OK)
            {
                RpcRaiseException(hr);
            }

            cbData = (DWORD) (pData - pStart);
            *pcbData = cbData;
            *pcbSize = cbData;
        }
        break;
    default:
        break;
    }


    if(pinst->pUnkForRelease)
    {
        CStreamOnMessage stream((unsigned char **) &pData);

        //Align the buffer on an 4 byte boundary
        *(unsigned long FAR *)&pData += 3;
        *(unsigned long FAR *)&pData &= 0xfffffffc;

        //Leave space for cbData.
        pcbData = (DWORD *) pData;
        *(unsigned long FAR *)&pData += 4;

        //Leave space for size.
        pcbSize = (DWORD *) pData;
        *(unsigned long FAR *)&pData += 4;

        pStart = (unsigned char *) pData;

        hr = CoMarshalInterface(&stream, IID_IUnknown, pinst->pUnkForRelease, MSHCTX_NOSHAREDMEM, 0, MSHLFLAGS_NORMAL);
        if(hr != S_OK)
        {
            RpcRaiseException(hr);
        }

        cbData = (DWORD) (pData - pStart);
        *pcbData = cbData;
        *pcbSize = cbData;
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   STGMEDIUM_from_xmit
//
//  Synopsis:   Convert a RemSTGMEDIUM structure to an STGMEDIUM.
//
//--------------------------------------------------------------------------
void __RPC_USER STGMEDIUM_from_xmit (RemSTGMEDIUM __RPC_FAR *pxmit, STGMEDIUM __RPC_FAR *pinst)
{
    HRESULT hr = S_OK;
    unsigned char *pData;

    pinst->tymed = pxmit->tymed;
    pData = pxmit->data;

    switch(pinst->tymed)
    {
    case TYMED_NULL:
    break;

    case TYMED_MFPICT:
    HMETAFILEPICT_from_xmit((RemHMETAFILEPICT *)pData, &pinst->hMetaFilePict);
    pData += sizeof(RemHMETAFILEPICT) + ((RemHMETAFILEPICT *)pData)->cbData;
    break;

    case TYMED_ENHMF:
    HENHMETAFILE_from_xmit((RemHENHMETAFILE *)pData, &pinst->hEnhMetaFile);
    pData += sizeof(RemHENHMETAFILE) + ((RemHENHMETAFILE *)pData)->cbData;
    break;

    case TYMED_HGLOBAL:
    HGLOBAL_from_xmit((RemHGLOBAL *)pData, &pinst->hGlobal);
    pData += sizeof(RemHGLOBAL) + ((RemHGLOBAL *)pData)->cbData;
    break;

    // When unmarshalling a STGMEDIUM with TYMED_GDI, we need to know
    // what kind of GDI object is packaged, so we inspect the dwHandleType
    // field which was set during the marshalling of the STGMEDIUM

    case TYMED_GDI:

    switch(pxmit->dwHandleType)
    {
        case OBJ_BITMAP:

            HBITMAP_from_xmit((RemHBITMAP *)pData, &pinst->hBitmap);
            pData += sizeof(RemHBITMAP) + ((RemHBITMAP *)pData)->cbData;
            break;

        case OBJ_PAL:

            HPALETTE_from_xmit((RemHPALETTE *)pData, (HPALETTE *) &pinst->hBitmap);
            pData += sizeof(RemHPALETTE) + ((RemHPALETTE *)pData)->cbData;
            break;

        default:

            RpcRaiseException(DV_E_TYMED);
    }
    break;


    case TYMED_FILE:
    {
        unsigned long count;

        //unmarshal the count.
        memcpy(&count, pData, sizeof(count));
        pData += sizeof(count);

        //allocate memory.
        pinst->lpszFileName = (wchar_t *)NdrOleAllocate(count * sizeof(wchar_t));

        //copy the string.
        memcpy(pinst->lpszFileName, pData, count * sizeof(wchar_t));
        pData += count * sizeof(wchar_t);
    }
    break;

    case TYMED_ISTREAM:

    if (pxmit->pData)
    {
    CStreamOnMessage stream(&pData);

    //Align the buffer on an 4 byte boundary
    *(unsigned long FAR *)&pData += 3;
    *(unsigned long FAR *)&pData &= 0xfffffffc;

    //Skip over cbData.
    *(unsigned long FAR *)&pData += 4;

    //Skip over cbSize.
    *(unsigned long FAR *)&pData += 4;

    hr = CoUnmarshalInterface(&stream, IID_IStream,
                  (void **) &pinst->pstm);
    if(hr != S_OK)
    {
        RpcRaiseException(hr);
    }
    }
    else
    {
    pinst->pstm = NULL;
    }
    break;

    case TYMED_ISTORAGE:

    if (pxmit->pData)
    {
    CStreamOnMessage stream(&pData);

    //Align the buffer on an 4 byte boundary
    *(unsigned long FAR *)&pData += 3;
    *(unsigned long FAR *)&pData &= 0xfffffffc;

    //Skip over cbData.
    *(unsigned long FAR *)&pData += 4;

    //Skip over cbSize.
    *(unsigned long FAR *)&pData += 4;

    hr = CoUnmarshalInterface(&stream, IID_IStorage,
                  (void **) &pinst->pstg);
    if(hr != S_OK)
    {
        RpcRaiseException(hr);
    }
    }
    else
    {
    pinst->pstg = NULL;
    }

    break;
    default:
    break;
    }


    pinst->pUnkForRelease = NULL;

    if(pxmit->pUnkForRelease)
    {
    CStreamOnMessage stream(&pData);

    //Align the buffer on an 4 byte boundary
    *(unsigned long FAR *)&pData += 3;
    *(unsigned long FAR *)&pData &= 0xfffffffc;

    //Skip over cbData.
    *(unsigned long FAR *)&pData += 4;

    //Skip over cbSize.
    *(unsigned long FAR *)&pData += 4;

    hr = CoUnmarshalInterface(&stream, IID_IUnknown, (void **) &pinst->pUnkForRelease);
    if(hr != S_OK)
    {
        RpcRaiseException(hr);
    }

    //  replace the punkForRelease with our custom release
    //  handler for special situations.

    if (pinst->tymed == TYMED_HGLOBAL ||
        pinst->tymed == TYMED_MFPICT  ||
        pinst->tymed == TYMED_ENHMF   ||
        pinst->tymed == TYMED_GDI)
    {
        IUnknown *punkTmp = (IUnknown *) new CPunkForRelease(pinst);
        if (!punkTmp)
        {
        RpcRaiseException(E_OUTOFMEMORY);
        }
        pinst->pUnkForRelease = punkTmp;
    }
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   STGMEDIUM_free_inst
//
//  Synopsis:   Free the contents of an STGMEDIUM structure.
//
//--------------------------------------------------------------------------

void __RPC_USER STGMEDIUM_free_inst(STGMEDIUM *pinst)
{
    if(pinst)
    {
    if (pinst->tymed == TYMED_FILE)
    {
        NdrOleFree(pinst->lpszFileName);
        pinst->lpszFileName = NULL;

        if (pinst->pUnkForRelease)
        {
        pinst->pUnkForRelease->Release();
        pinst->pUnkForRelease = 0;
        }
    }
    else
    {
        ReleaseStgMedium(pinst);
    }
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   STGMEDIUM_free_xmit
//
//  Synopsis:   Free a RemSTGMEDIUM previously obtained from STGMEDIUM_to_xmit.
//
//--------------------------------------------------------------------------
void __RPC_USER STGMEDIUM_free_xmit(RemSTGMEDIUM *pxmit)
{
    if(pxmit)
    {
    NdrOleFree(pxmit);
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   SNB_to_xmit
//
//  Synopsis:   Converts an SNB structure to a remotable structure
//
//  Arguments:  [pSNB]   -- pointer to the original SNB
//              [ppxmit] -- set to point to the transmitted value
//
//  Returns:    void
//
//  Algorithm:
//
//  History:    10-01-94    rickhi  Created
//
//  Notes:
//
//--------------------------------------------------------------------------

void __RPC_USER SNB_to_xmit (SNB __RPC_FAR *pSNB,
    RemSNB __RPC_FAR * __RPC_FAR *ppxmit)
{
    // calculate the size of the structure needed. add 1 for the NULL
    // terminator

    ULONG ulCntStr = 0;
    ULONG ulCntChar = 0;

    if (pSNB && *pSNB)
    {
    // compute the number of strings and the total number of
    // characters in all the strings.
    SNB snb = *pSNB;

    WCHAR *psz = *snb;
    while (psz)
    {
        ulCntChar += wcslen(psz) + 1;
        ulCntStr++;
        snb++;
        psz = *snb;
    }
    }

    // allocate memory
    RemSNB *pRemSNB = (RemSNB *) NdrOleAllocate(sizeof(RemSNB) +
                        ulCntChar * sizeof(WCHAR));

    if (pRemSNB)
    {
    // copy the data
    pRemSNB->ulCntStr  = ulCntStr;
    pRemSNB->ulCntChar = ulCntChar;

    if (pSNB && *pSNB)
    {
        // copy the string ptrs into the new structure
        SNB snb = *pSNB;

        WCHAR *pszSrc;
        WCHAR *pszTgt = pRemSNB->rgString;
        while (pszSrc = *snb++)
        {
        ULONG ulLen = wcslen(pszSrc) + 1;
        memcpy(pszTgt, pszSrc, ulLen * sizeof(WCHAR));
        pszTgt += ulLen;
        }
    }

    *ppxmit = pRemSNB;
    }
    else
    {
    RpcRaiseException(E_OUTOFMEMORY);
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   SNB_from_xmit
//
//  Synopsis:   converts a RemSNB to an SNB
//
//  Arguments:  [pxmit] -- the transmitted RemSNB
//              [pSNB]  -- where to put the local SNB
//
//  Returns:    void
//
//  History:    10-Jan-94 rickhi    created
//
//  Notes:
//
//--------------------------------------------------------------------------

void __RPC_USER SNB_from_xmit( RemSNB __RPC_FAR *pxmit,
    SNB __RPC_FAR *pSNB )
{
    if (pxmit)
    {
    if (pxmit->ulCntStr == 0)
    {
        *pSNB = NULL;
        return;
    }

    SNB snb = (SNB) NdrOleAllocate((pxmit->ulCntStr+1) * sizeof(WCHAR *) +
            pxmit->ulCntChar * sizeof(WCHAR));

    //  set the out parameter
    *pSNB = snb;

    if (snb)
    {
        // create the pointer array
        WCHAR *pszSrc = pxmit->rgString;
        WCHAR *pszTgt = (WCHAR *)(snb + pxmit->ulCntStr + 1);

        for (ULONG i = pxmit->ulCntStr; i>0; i--)
        {
        *snb++ = pszTgt;

        ULONG ulLen = wcslen(pszSrc) + 1;
        pszSrc += ulLen;
        pszTgt += ulLen;
        }

        *snb++ = NULL;

        // copy the actual strings
        memcpy(snb, pxmit->rgString, pxmit->ulCntChar * sizeof(WCHAR));
    }
    else
    {
        RpcRaiseException(E_OUTOFMEMORY);
    }
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   SNB_free_xmit
//
//  Synopsis:   Free's the memory for the RemSNB structure
//
//  Arguments:  [pxmit]  -- the transmitted SNB to free
//
//  Returns:    void
//
//  History:    10-Jan-94 rickhi    created
//
//--------------------------------------------------------------------------

void __RPC_USER SNB_free_xmit( RemSNB __RPC_FAR *pxmit)
{
    if(pxmit != 0)
        NdrOleFree(pxmit);
}

//+-------------------------------------------------------------------------
//
//  Function:   SNB_free_inst
//
//  Synopsis:   Deletes an SNB.
//
//  Arguments:  [pSNB]  -- pointer to the SNB to free
//
//  Returns:    void
//
//  History:    10-Jan-94 created       created
//
//--------------------------------------------------------------------------

void __RPC_USER SNB_free_inst( SNB __RPC_FAR *pSNB)
{
    if (pSNB)
    {
    NdrOleFree(*pSNB);
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   HMENU_to_xmit
//
//  Synopsis:   Convert an HMENU to a long.
//
//  Notes:      Both the source process and the destination process must
//              reside on the same machine.  This code assumes that the
//              destination process can use the HMENU received from
//              the source process.
//
//--------------------------------------------------------------------------
EXTERN_C void __RPC_USER HMENU_to_xmit(HMENU *pHandle, LONG_PTR **ppLong)
{
    *(ppLong) = (LONG_PTR*) NdrOleAllocate(sizeof(LONG_PTR));
    **ppLong = (LONG_PTR) *(pHandle);
}

//+-------------------------------------------------------------------------
//
//  Function:   HMENU_from_xmit
//
//  Synopsis:   Convert a long to an HMENU.
//
//--------------------------------------------------------------------------
EXTERN_C void __RPC_USER HMENU_from_xmit(LONG_PTR *pLong, HMENU *pHandle)
{
    *(pHandle) = (HMENU) *(pLong);
}

//+-------------------------------------------------------------------------
//
//  Function:   HMENU_free_inst
//
//  Synopsis:   Does nothing.
//
//--------------------------------------------------------------------------
EXTERN_C void __RPC_USER HMENU_free_inst(HMENU *pHandle)
{
}

//+-------------------------------------------------------------------------
//
//  Function:   HMENU_free_xmit
//
//  Synopsis:   Free a pointer to a long.
//
//--------------------------------------------------------------------------
EXTERN_C void __RPC_USER HMENU_free_xmit(long *pLong)
{
    if(pLong != 0)
        NdrOleFree(pLong);
}

EXTERN_C void __RPC_USER HOLEMENU_to_xmit (HOLEMENU *pinst, RemHGLOBAL **ppxmit)
{
    HGLOBAL_to_xmit((HGLOBAL *)pinst, ppxmit);
}

EXTERN_C void __RPC_USER HOLEMENU_from_xmit (RemHGLOBAL __RPC_FAR *pxmit, HOLEMENU __RPC_FAR *pinst)
{
    HGLOBAL_from_xmit (pxmit, (HGLOBAL __RPC_FAR *)pinst);
}

EXTERN_C void __RPC_USER HOLEMENU_free_inst(HOLEMENU *pinst)
{
    HGLOBAL_free_inst((HGLOBAL *)pinst);
}

EXTERN_C void __RPC_USER HOLEMENU_free_xmit(RemHGLOBAL *pxmit)
{
    HGLOBAL_free_xmit(pxmit);
}

//+-------------------------------------------------------------------------
//
//  Function:   HWND_to_xmit
//
//  Synopsis:   Convert an HWND to a long.
//
//  Notes:      Both the source process and the destination process must
//              reside on the same machine.  This code assumes that the
//              destination process can use the HWND received from
//              the source process.
//
//--------------------------------------------------------------------------
EXTERN_C void __RPC_USER HWND_to_xmit(HWND *pHandle, LONG_PTR **ppLong)
{
    *(ppLong) = (LONG_PTR*) NdrOleAllocate(sizeof(LONG_PTR));
    **ppLong = (LONG_PTR) *(pHandle);
}

//+-------------------------------------------------------------------------
//
//  Function:   HWND_from_xmit
//
//  Synopsis:   Convert a long to an HWND.
//
//--------------------------------------------------------------------------
EXTERN_C void __RPC_USER HWND_from_xmit(LONG_PTR *pLong, HWND *pHandle)
{
    *(pHandle) = (HWND) *(pLong);
}

//+-------------------------------------------------------------------------
//
//  Function:   HWND_free_inst
//
//  Synopsis:   Does nothing.
//
//--------------------------------------------------------------------------
EXTERN_C void __RPC_USER HWND_free_inst(HWND *pHandle)
{
}

//+-------------------------------------------------------------------------
//
//  Function:   HWND_free_xmit
//
//  Synopsis:   Free a pointer to a long.
//
//--------------------------------------------------------------------------
EXTERN_C void __RPC_USER HWND_free_xmit(long *pLong)
{
    if(pLong != 0)
        NdrOleFree(pLong);
}

//+-------------------------------------------------------------------------
//
//  Function:   HENHMETAFILE_to_xmit
//
//  Synopsis:   Converts an enhanced metafile handle into a serial buffer
//              that can be remoted
//
//  Arguments:  [pHEnhMetafile] -- pointer to the original emf handle
//              [ppxmit]        -- set to point to the transmitted value
//
//  Returns:    void
//
//  History:    14-Nov-94   DavePl  Created
//
//
//--------------------------------------------------------------------------

void __RPC_USER HENHMETAFILE_to_xmit (HENHMETAFILE __RPC_FAR *pHEnhMetafile,
    RemHENHMETAFILE __RPC_FAR * __RPC_FAR *ppxmit)
{
    // A few inefficient temp vars here to avoid ugly casts later

    HENHMETAFILE hemf = *pHEnhMetafile;

    // Calculate the number of bytes we need in order to serialize the
    // metafile to memory

    DWORD cbData = GetEnhMetaFileBits(hemf, 0, NULL);
    if (cbData == 0)
    {
        RpcRaiseException(HRESULT_FROM_WIN32(GetLastError()));
    }

    // Allocate the appropriate number of bytes

    *ppxmit = (RemHENHMETAFILE *)
        NdrOleAllocate(sizeof(RemHENHMETAFILE) + cbData);


    // If the allocation was successful, get the bits into our buffer.
    // Otherwise, throw an exception

    if (*ppxmit)
    {
    if (0==GetEnhMetaFileBits(hemf, cbData, &((*ppxmit)->data[0])))
        {
            NdrOleFree(*ppxmit);
            *ppxmit = NULL;

            RpcRaiseException(HRESULT_FROM_WIN32(GetLastError()));
        }
        (*ppxmit)->cbData = cbData;
    }
    else
    {
        RpcRaiseException(E_OUTOFMEMORY);
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   HENHMETAFILE_from_xmit
//
//  Synopsis:   Converts a serialized enhanced metafile into an emf handle
//              that is usable by applications
//
//  Arguments:  [pxmit]         -- the transmitted global handle
//              [pHEnhMetafile] -- where to put the local metafilepict handle
//
//  Returns:    void
//
//  History:    14-May-94 DavePl    Created
//
//--------------------------------------------------------------------------

void __RPC_USER HENHMETAFILE_from_xmit( RemHENHMETAFILE __RPC_FAR *pxmit,
    HENHMETAFILE __RPC_FAR *pHEnhMetafile )
{

    // Generate a handle to the enhanced metafile by doing a
    // Setbits on the raw data

    *pHEnhMetafile = SetEnhMetaFileBits(pxmit->cbData, pxmit->data);

    if (NULL == *pHEnhMetafile)
    {
        RpcRaiseException(HRESULT_FROM_WIN32(GetLastError()));
    }

}

//+-------------------------------------------------------------------------
//
//  Function:   HENHMETAFILE_free_xmit
//
//  Synopsis:   Free's the remote data
//
//  Arguments:  [pxmit]         -- the transmitted data
//
//  Returns:    void
//
//  History:    14-May-94     DavePl    Created
//
//--------------------------------------------------------------------------

void __RPC_USER HENHMETAFILE_free_xmit( RemHENHMETAFILE __RPC_FAR *pxmit)
{
    if(pxmit != 0)
        NdrOleFree(pxmit);
}

//+-------------------------------------------------------------------------
//
//  Function:   HMETAFILEPICT_free_inst
//
//  Synopsis:   destroys the metafile
//
//  Arguments:  [pHEnhMetafile]        -- handle to the enhanced metafile
//
//  Returns:    void
//
//  Algorithm:
//
//  History:    14-May-94     DavePl    Created
//
//--------------------------------------------------------------------------

void __RPC_USER HENHMETAFILE_free_inst( HENHMETAFILE __RPC_FAR *pHEnhMetafile)
{
    DeleteEnhMetaFile (*pHEnhMetafile);
}

//+-------------------------------------------------------------------------
//
//  Function:   HPALETTE_to_xmit
//
//  Synopsis:   Converts a palette into a serialized buffer
//              that can be remoted
//
//  Arguments:  [pHPALETTE] -- pointer to the original palette handle
//              [ppxmit]    -- set to point to the transmitted value
//
//  Returns:    void
//
//  History:    11-Aug-94   DavePl  Created
//
//
//--------------------------------------------------------------------------

void __RPC_USER HPALETTE_to_xmit (HPALETTE __RPC_FAR *pHPALETTE,
    RemHPALETTE __RPC_FAR * __RPC_FAR *ppxmit)
{
    // Determine the number of color entries in the palette
    DWORD cEntries = GetPaletteEntries(*pHPALETTE, 0, 0, NULL);

    // Calculate the resultant data size
    DWORD cbData = cEntries * sizeof(PALETTEENTRY);

    // Allocate space for the struct and the entries
    *ppxmit = (RemHPALETTE *) NdrOleAllocate(sizeof(RemHPALETTE) + cbData);

    if (NULL == *ppxmit)
    {
        RpcRaiseException(E_OUTOFMEMORY);
    }

    if (cbData)
    {
        if (0 == GetPaletteEntries(*pHPALETTE,
                                   0,
                                   cEntries,
                                   (PALETTEENTRY *) &((*ppxmit)->data[0])))
        {
            NdrOleFree(*ppxmit);
            *ppxmit = NULL;
            RpcRaiseException(HRESULT_FROM_WIN32(GetLastError()));
        }
    }

    (*ppxmit)->cbData = cbData;

}

//+-------------------------------------------------------------------------
//
//  Function:   HPALETTE_from_xmit
//
//  Synopsis:   Converts a serialized palette into an palette handle
//              that is usable by applications
//
//  Arguments:  [pxmit]         -- the transmitted buffer
//              [pHPALETTE]     -- where to put the local palette handle
//
//  Returns:    void
//
//  History:    11-Aug-94 DavePl    Created
//
//--------------------------------------------------------------------------

void __RPC_USER HPALETTE_from_xmit( RemHPALETTE __RPC_FAR *pxmit,
    HPALETTE __RPC_FAR *pHPALETTE )
{
    DWORD cEntries = pxmit->cbData / sizeof(PALETTEENTRY);
    LOGPALETTE * pLogPal;

    // If there are 0 color entries, we need to allocate the LOGPALETTE
    // structure with the one dummy entry (it's a variably sized struct).
    // Otherwise, we need to allocate enough space for the extra n-1
    // entries at the tail of the structure

    if (0 == cEntries)
    {
        pLogPal = (LOGPALETTE *) NdrOleAllocate(sizeof(LOGPALETTE));
    }
    else
    {
        pLogPal = (LOGPALETTE *) NdrOleAllocate(sizeof(LOGPALETTE) +
                                          (cEntries - 1) * sizeof(PALETTEENTRY));

        // If there are entries, and if we have a buffer, move the
        // entries into out LOGPALETTE structure

        if (pLogPal)
        {
            memcpy(&(pLogPal->palPalEntry[0]), pxmit->data, pxmit->cbData);
        }
    }

    // If we didn't get a buffer at all...

    if (NULL == pLogPal)
    {
        RpcRaiseException(E_OUTOFMEMORY);
    }

    // Fill in the rest of the structure

    pLogPal->palVersion = 0x300;
    pLogPal->palNumEntries = (unsigned short) cEntries;

    // Attempt to create the palette

    *pHPALETTE = CreatePalette(pLogPal);

    // Success or failure, we're done with the LOGPALETTE structure

    NdrOleFree(pLogPal);

    // If the creation failed, raise an exception

    if (NULL == *pHPALETTE)
    {
        RpcRaiseException(HRESULT_FROM_WIN32(GetLastError()));
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   HPALETTE_free_xmit
//
//  Synopsis:   Frees the remote data
//
//  Arguments:  [pxmit]         -- the transmitted data
//
//  Returns:    void
//
//  History:    11-Aug-94     DavePl    Created
//
//--------------------------------------------------------------------------

void __RPC_USER HPALETTE_free_xmit( RemHPALETTE __RPC_FAR *pxmit)
{
    if(NULL != pxmit)
    {
        NdrOleFree(pxmit);
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   HPALETTE_free_inst
//
//  Synopsis:   destroys the palette
//
//  Arguments:  [pHPALETTE]        -- handle to the palette
//
//  Returns:    void
//
//  Algorithm:
//
//  History:    11-Aug-94     DavePl    Created
//
//--------------------------------------------------------------------------

void __RPC_USER HPALETTE_free_inst( HPALETTE __RPC_FAR *pHPALETTE)
{
    DeleteObject( (HGDIOBJ) *pHPALETTE);
}

//+-------------------------------------------------------------------------
//
//  Function:   HACCEL_to_xmit
//
//  Synopsis:   Convert an HACCEL to a long.
//
//  Notes:      Both the source process and the destination process must
//              reside on the same machine.  This code assumes that the
//              destination process can use the HACCEL received from
//              the source process.
//
//--------------------------------------------------------------------------
EXTERN_C void __RPC_USER HACCEL_to_xmit(HACCEL *phAccel, LONG_PTR **ppLong)
{
    *ppLong = (LONG_PTR*) NdrOleAllocate(sizeof(LONG_PTR));
    **ppLong = (LONG_PTR) *phAccel;
}

//+-------------------------------------------------------------------------
//
//  Function:   HACCEL_from_xmit
//
//  Synopsis:   Convert a long to an HACCEL.
//
//--------------------------------------------------------------------------
EXTERN_C void __RPC_USER HACCEL_from_xmit(LONG_PTR *pLong, HACCEL *pHandle)
{
    *pHandle = (HACCEL) *pLong;
}

//+-------------------------------------------------------------------------
//
//  Function:   HACCEL_free_inst
//
//  Synopsis:   Does nothing.
//
//--------------------------------------------------------------------------
EXTERN_C void __RPC_USER HACCEL_free_inst(HACCEL *pHandle)
{
}

//+-------------------------------------------------------------------------
//
//  Function:   HACCEL_free_xmit
//
//  Synopsis:   Free a pointer to a long.
//
//--------------------------------------------------------------------------
EXTERN_C void __RPC_USER HACCEL_free_xmit(long *pLong)
{
    if(pLong != 0)
        NdrOleFree(pLong);
}

//+-------------------------------------------------------------------------
//
//  Function:   UINT_to_xmit
//
//  Synopsis:   Convert a UINT to a 32 bit long.
//
//--------------------------------------------------------------------------
EXTERN_C void __RPC_USER UINT_to_xmit(UINT *pUint, unsigned long **ppLong)
{
    *ppLong = (unsigned long *) NdrOleAllocate(sizeof(long));
    **ppLong = (unsigned long) *pUint;
}

//+-------------------------------------------------------------------------
//
//  Function:   UINT_from_xmit
//
//  Synopsis:   Convert a 32 bit long to a UINT.
//
//--------------------------------------------------------------------------
EXTERN_C void __RPC_USER UINT_from_xmit(
    unsigned long __RPC_FAR *pLong,
    UINT __RPC_FAR *pUint
    )
{
    *pUint = (UINT) *pLong;
}

//+-------------------------------------------------------------------------
//
//  Function:   UINT_free_inst
//
//  Synopsis:   Does nothing.
//
//--------------------------------------------------------------------------
EXTERN_C void __RPC_USER UINT_free_inst(UINT *pHandle)
{
}

//+-------------------------------------------------------------------------
//
//  Function:   UINT_free_xmit
//
//  Synopsis:   Free a pointer to a long.
//
//--------------------------------------------------------------------------
EXTERN_C void __RPC_USER UINT_free_xmit(unsigned long *pLong)
{
    if(pLong != 0)
        NdrOleFree(pLong);
}

//+-------------------------------------------------------------------------
//
//  Function:   WPARAM_to_xmit
//
//  Synopsis:   Convert a WPARAM to a 32 bit long.
//
//--------------------------------------------------------------------------
EXTERN_C void __RPC_USER WPARAM_to_xmit(WPARAM *pHandle, unsigned long **ppLong)
{
    *ppLong = (unsigned long *) NdrOleAllocate(sizeof(unsigned long));
    **ppLong = (unsigned long) *pHandle;
}

//+-------------------------------------------------------------------------
//
//  Function:   WPARAM_from_xmit
//
//  Synopsis:   Convert a 32 bit long to a WPARAM.
//
//--------------------------------------------------------------------------
EXTERN_C void __RPC_USER WPARAM_from_xmit(unsigned long *pLong, WPARAM *pHandle)
{
    *pHandle = (WPARAM) *pLong;
}

//+-------------------------------------------------------------------------
//
//  Function:   WPARAM_free_inst
//
//  Synopsis:   Does nothing.
//
//--------------------------------------------------------------------------
EXTERN_C void __RPC_USER WPARAM_free_inst(WPARAM *pHandle)
{
}

//+-------------------------------------------------------------------------
//
//  Function:   WPARAM_free_xmit
//
//  Synopsis:   Free a pointer to a long.
//
//--------------------------------------------------------------------------
EXTERN_C void __RPC_USER WPARAM_free_xmit(unsigned long *pLong)
{
    if(pLong != 0)
        NdrOleFree(pLong);
}


#ifdef UNUSED
//+-------------------------------------------------------------------------
// new code
//+-------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//
//  Function:   STGMEDIUM_to_xmit
//
//  Synopsis:   Convert an STGMEDIUM to a RemBINDINFO structure so it can be sent
//                              over the network.
//
//                              The marshalled BINDINFO looks like this:
//                              RemBINDINFO | data from union | data from pUnkForRelease
//--------------------------------------------------------------------------

void __RPC_USER BINDINFO_to_xmit (BINDINFO *pinst, RemBINDINFO **ppxmit)
{
    unsigned char *pData;
    RemHGLOBAL *pRemHGLOBAL;
    RemHBITMAP *pRemHBITMAP;
    RemHPALETTE *pRemHPALETTE;
    RemHMETAFILEPICT *pRemHMETAFILEPICT;
    RemHENHMETAFILE *pRemHENHMETAFILE;

    long size;
    unsigned long count;
    unsigned long cbInterface;
    HRESULT hr = S_OK;
    DWORD *pcbData;
    DWORD *pcbSize;
    DWORD cbData;
    unsigned char *pStart;

    // If the TYMED for the BINDINFO is TYMED_GDI, we need a bit more information
    // (ie: what _kind_ of GDI object it is).  The field is unused for anything
    // except TYMED_GDI

    DWORD dwHandleType = 0;

    //calculate size of marshalled BINDINFO.
    size = sizeof(RemBINDINFO);

    //add the size of data[].
    switch(pinst->tymed)
    {
    case TYMED_NULL:
        break;
    case TYMED_MFPICT:
        HMETAFILEPICT_to_xmit(&pinst->hMetaFilePict, &pRemHMETAFILEPICT);
        size += sizeof(RemHMETAFILEPICT) + pRemHMETAFILEPICT->cbData;
        break;
    case TYMED_ENHMF:
        HENHMETAFILE_to_xmit(&pinst->hEnhMetaFile, &pRemHENHMETAFILE);
        size += sizeof(RemHENHMETAFILE) + pRemHENHMETAFILE->cbData;
        break;
    case TYMED_GDI:

        // A GDI object is not necesarrily a BITMAP.  Therefore, we handle
        // those types we know about based on the object type, and reject
        // those which we do not support.

        switch(GetObjectType( (HGDIOBJ) pinst->hGlobal ))
        {
            case OBJ_BITMAP:

                HBITMAP_to_xmit(&pinst->hBitmap, &pRemHBITMAP);
                size += sizeof(RemHBITMAP) + pRemHBITMAP->cbData;
                dwHandleType = OBJ_BITMAP;
                break;

            case OBJ_PAL:

                HPALETTE_to_xmit((HPALETTE *) &pinst->hBitmap, &pRemHPALETTE);
                size += sizeof(RemHPALETTE) + pRemHPALETTE->cbData;
                dwHandleType = OBJ_PAL;
                break;

            default:
                RpcRaiseException(DV_E_TYMED);
        }
        break;

    case TYMED_HGLOBAL:
        HGLOBAL_to_xmit(&pinst->hGlobal, &pRemHGLOBAL);
        size += sizeof(RemHGLOBAL) + pRemHGLOBAL->cbData;
        break;
    case TYMED_FILE:
        count = wcslen(pinst->lpszFileName) + 1;
        size += 4; //allocate room for character count.
        size += count * sizeof(wchar_t);
        break;
    case TYMED_ISTREAM:
        size += 4;
        if(pinst->pstm)
        {
            //Align the buffer on an 4 byte boundary.
            size += 3;
            size &= (unsigned int)0xfffffffc;

            //Allocate space for the length and array bounds.
            size += 8;

            hr = CoGetMarshalSizeMax(&cbInterface, IID_IStream, pinst->pstm, MSHCTX_LOCAL, 0, MSHLFLAGS_NORMAL);
            if(hr == S_OK)
            size += cbInterface;
        }
        break;
    case TYMED_ISTORAGE:
        size += 4;
        if(pinst->pstg)
        {
            //Align the buffer on an 4 byte boundary.
            size += 3;
            size &= (unsigned int)0xfffffffc;

            //Allocate space for the length and array bounds.
            size += 8;

            hr = CoGetMarshalSizeMax(&cbInterface, IID_IStorage, pinst->pstg, MSHCTX_LOCAL, 0, MSHLFLAGS_NORMAL);
            if(hr == S_OK)
            size += cbInterface;
        }
        break;
    default:
        break;
    }


    //Allocate space for pUnkForRelease.
    if(pinst->pUnkForRelease)
    {
        //Align the buffer on an 4 byte boundary.
        size += 3;
        size &= (unsigned int)0xfffffffc;

        //Allocate space for the length and array bounds.
        size += 8;

        hr = CoGetMarshalSizeMax(&cbInterface, IID_IUnknown, pinst->pUnkForRelease, MSHCTX_NOSHAREDMEM, 0, MSHLFLAGS_NORMAL);
    if(hr == S_OK)
    {
        size += cbInterface;
    }
    }

    //allocate memory
    *ppxmit = (RemBINDINFO *) NdrOleAllocate(size);

    //Marshal BINDINFO
    (*ppxmit)->tymed = pinst->tymed;
    (*ppxmit)->pData = (unsigned long) pinst->hGlobal;
    (*ppxmit)->pUnkForRelease = (unsigned long) pinst->pUnkForRelease;
    (*ppxmit)->cbData = size - sizeof(RemBINDINFO);
    (*ppxmit)->dwHandleType = dwHandleType;

    pData = (*ppxmit)->data;

    switch(pinst->tymed)
    {
    case TYMED_NULL:
        break;
    case TYMED_MFPICT:
        //Note that we called HMETAFILEPICT_to_xmit earlier so we could
        //get the size.
        memcpy(pData, pRemHMETAFILEPICT, sizeof(RemHMETAFILEPICT) + pRemHMETAFILEPICT->cbData);
        pData += sizeof(RemHMETAFILEPICT) + pRemHMETAFILEPICT->cbData;
        HMETAFILEPICT_free_xmit(pRemHMETAFILEPICT);
        break;
    case TYMED_ENHMF:
        memcpy(pData, pRemHENHMETAFILE, sizeof(RemHENHMETAFILE) + pRemHENHMETAFILE->cbData);
        pData += sizeof(RemHENHMETAFILE) + pRemHENHMETAFILE->cbData;
        HENHMETAFILE_free_xmit(pRemHENHMETAFILE);
        break;
    case TYMED_HGLOBAL:
        //Note that we called HGLOBAL_to_xmit earlier so we could
        //get the size.
        memcpy(pData, pRemHGLOBAL, sizeof(RemHGLOBAL) + pRemHGLOBAL->cbData);
    pData += sizeof(RemHGLOBAL) + pRemHGLOBAL->cbData;
        HGLOBAL_free_xmit(pRemHGLOBAL);
        break;

    case TYMED_GDI:

        switch(dwHandleType)
        {
        case OBJ_BITMAP:

            memcpy(pData, pRemHBITMAP, sizeof(RemHBITMAP) + pRemHBITMAP->cbData);
            pData += sizeof(RemHBITMAP) + pRemHBITMAP->cbData;
            HBITMAP_free_xmit(pRemHBITMAP);
            break;

        case OBJ_PAL:

            memcpy(pData, pRemHPALETTE, sizeof(RemHPALETTE) + pRemHPALETTE->cbData);
            pData += sizeof(RemHPALETTE) + pRemHPALETTE->cbData;
            HPALETTE_free_xmit(pRemHPALETTE);
        }

        break;

    case TYMED_FILE:
        //copy the length.
        memcpy(pData, &count, sizeof(count));
        pData += sizeof(count);

        //copy the string.
    memcpy(pData, pinst->lpszFileName, count * sizeof(wchar_t));
        pData += count * sizeof(wchar_t);
        break;
    case TYMED_ISTREAM:
        if(pinst->pstm)
        {
            CStreamOnMessage stream((unsigned char **) &pData);

            //Align the buffer on an 4 byte boundary
            *(unsigned long FAR *)&pData += 3;
            *(unsigned long FAR *)&pData &= 0xfffffffc;

            //Leave space for cbData.
            pcbData = (DWORD *) pData;
            *(unsigned long FAR *)&pData += 4;

            //Leave space for size.
            pcbSize = (DWORD *) pData;
        *(unsigned long FAR *)&pData += 4;

            pStart = (unsigned char *) pData;

            hr = CoMarshalInterface(&stream, IID_IStream, pinst->pstm, MSHCTX_LOCAL, 0, MSHLFLAGS_NORMAL);
            if(hr != S_OK)
            {
                RpcRaiseException(hr);
            }

            cbData = (DWORD) (pData - pStart);
            *pcbData = cbData;
            *pcbSize = cbData;
        }
        break;
    case TYMED_ISTORAGE:
        if(pinst->pstg)
        {
            CStreamOnMessage stream((unsigned char **) &pData);

            //Align the buffer on an 4 byte boundary
            *(unsigned long FAR *)&pData += 3;
            *(unsigned long FAR *)&pData &= 0xfffffffc;

            //Leave space for cbData.
            pcbData = (DWORD *) pData;
            *(unsigned long FAR *)&pData += 4;

            //Leave space for size.
            pcbSize = (DWORD *) pData;
            *(unsigned long FAR *)&pData += 4;

            pStart = (unsigned char *) pData;

            hr = CoMarshalInterface(&stream, IID_IStorage, pinst->pstg, MSHCTX_LOCAL, 0, MSHLFLAGS_NORMAL);
            if(hr != S_OK)
            {
                RpcRaiseException(hr);
            }

            cbData = (DWORD) (pData - pStart);
            *pcbData = cbData;
            *pcbSize = cbData;
        }
        break;
    default:
        break;
    }


    if(pinst->pUnkForRelease)
    {
        CStreamOnMessage stream((unsigned char **) &pData);

        //Align the buffer on an 4 byte boundary
        *(unsigned long FAR *)&pData += 3;
        *(unsigned long FAR *)&pData &= 0xfffffffc;

        //Leave space for cbData.
        pcbData = (DWORD *) pData;
        *(unsigned long FAR *)&pData += 4;

        //Leave space for size.
        pcbSize = (DWORD *) pData;
        *(unsigned long FAR *)&pData += 4;

        pStart = (unsigned char *) pData;

        hr = CoMarshalInterface(&stream, IID_IUnknown, pinst->pUnkForRelease, MSHCTX_NOSHAREDMEM, 0, MSHLFLAGS_NORMAL);
        if(hr != S_OK)
        {
            RpcRaiseException(hr);
        }

        cbData = (DWORD) (pData - pStart);
        *pcbData = cbData;
        *pcbSize = cbData;
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   BINDINFO_from_xmit
//
//  Synopsis:   Convert a RemBINDINFO structure to an BINDINFO.
//
//--------------------------------------------------------------------------
void __RPC_USER BINDINFO_from_xmit (RemBINDINFO __RPC_FAR *pxmit, BINDINFO __RPC_FAR *pinst)
{
    HRESULT hr = S_OK;
    unsigned char *pData;

    pinst->tymed = pxmit->tymed;
    pData = pxmit->data;

    switch(pinst->tymed)
    {
    case TYMED_NULL:
    break;

    case TYMED_MFPICT:
    HMETAFILEPICT_from_xmit((RemHMETAFILEPICT *)pData, &pinst->hMetaFilePict);
    pData += sizeof(RemHMETAFILEPICT) + ((RemHMETAFILEPICT *)pData)->cbData;
    break;

    case TYMED_ENHMF:
    HENHMETAFILE_from_xmit((RemHENHMETAFILE *)pData, &pinst->hEnhMetaFile);
    pData += sizeof(RemHENHMETAFILE) + ((RemHENHMETAFILE *)pData)->cbData;
    break;

    case TYMED_HGLOBAL:
    HGLOBAL_from_xmit((RemHGLOBAL *)pData, &pinst->hGlobal);
    pData += sizeof(RemHGLOBAL) + ((RemHGLOBAL *)pData)->cbData;
    break;

    // When unmarshalling a BINDINFO with TYMED_GDI, we need to know
    // what kind of GDI object is packaged, so we inspect the dwHandleType
    // field which was set during the marshalling of the BINDINFO

    case TYMED_GDI:

    switch(pxmit->dwHandleType)
    {
        case OBJ_BITMAP:

            HBITMAP_from_xmit((RemHBITMAP *)pData, &pinst->hBitmap);
            pData += sizeof(RemHBITMAP) + ((RemHBITMAP *)pData)->cbData;
            break;

        case OBJ_PAL:

            HPALETTE_from_xmit((RemHPALETTE *)pData, (HPALETTE *) &pinst->hBitmap);
            pData += sizeof(RemHPALETTE) + ((RemHPALETTE *)pData)->cbData;
            break;

        default:

            RpcRaiseException(DV_E_TYMED);
    }
    break;


    case TYMED_FILE:
    {
        unsigned long count;

        //unmarshal the count.
        memcpy(&count, pData, sizeof(count));
        pData += sizeof(count);

        //allocate memory.
        pinst->lpszFileName = (wchar_t *)NdrOleAllocate(count * sizeof(wchar_t));

        //copy the string.
        memcpy(pinst->lpszFileName, pData, count * sizeof(wchar_t));
        pData += count * sizeof(wchar_t);
    }
    break;

    case TYMED_ISTREAM:

    if (pxmit->pData)
    {
    CStreamOnMessage stream(&pData);

    //Align the buffer on an 4 byte boundary
    *(unsigned long FAR *)&pData += 3;
    *(unsigned long FAR *)&pData &= 0xfffffffc;

    //Skip over cbData.
    *(unsigned long FAR *)&pData += 4;

    //Skip over cbSize.
    *(unsigned long FAR *)&pData += 4;

    hr = CoUnmarshalInterface(&stream, IID_IStream,
                  (void **) &pinst->pstm);
    if(hr != S_OK)
    {
        RpcRaiseException(hr);
    }
    }
    else
    {
    pinst->pstm = NULL;
    }
    break;

    case TYMED_ISTORAGE:

    if (pxmit->pData)
    {
    CStreamOnMessage stream(&pData);

    //Align the buffer on an 4 byte boundary
    *(unsigned long FAR *)&pData += 3;
    *(unsigned long FAR *)&pData &= 0xfffffffc;

    //Skip over cbData.
    *(unsigned long FAR *)&pData += 4;

    //Skip over cbSize.
    *(unsigned long FAR *)&pData += 4;

    hr = CoUnmarshalInterface(&stream, IID_IStorage,
                  (void **) &pinst->pstg);
    if(hr != S_OK)
    {
        RpcRaiseException(hr);
    }
    }
    else
    {
    pinst->pstg = NULL;
    }

    break;
    default:
    break;
    }


    pinst->pUnkForRelease = NULL;

    if(pxmit->pUnkForRelease)
    {
    CStreamOnMessage stream(&pData);

    //Align the buffer on an 4 byte boundary
    *(unsigned long FAR *)&pData += 3;
    *(unsigned long FAR *)&pData &= 0xfffffffc;

    //Skip over cbData.
    *(unsigned long FAR *)&pData += 4;

    //Skip over cbSize.
    *(unsigned long FAR *)&pData += 4;

    hr = CoUnmarshalInterface(&stream, IID_IUnknown, (void **) &pinst->pUnkForRelease);
    if(hr != S_OK)
    {
        RpcRaiseException(hr);
    }

    //  replace the punkForRelease with our custom release
    //  handler for special situations.

    if (pinst->tymed == TYMED_HGLOBAL ||
        pinst->tymed == TYMED_MFPICT  ||
        pinst->tymed == TYMED_ENHMF   ||
        pinst->tymed == TYMED_GDI)
    {
        IUnknown *punkTmp = (IUnknown *) new CPunkForRelease(pinst);
        if (!punkTmp)
        {
        RpcRaiseException(E_OUTOFMEMORY);
        }
        pinst->pUnkForRelease = punkTmp;
    }
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   BINDINFO_free_inst
//
//  Synopsis:   Free the contents of an BINDINFO structure.
//
//--------------------------------------------------------------------------

void __RPC_USER BINDINFO_free_inst(BINDINFO *pinst)
{
    if(pinst)
    {
        NdrOleFree(pinst);
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   BINDINFO_free_xmit
//
//  Synopsis:   Free a RemBINDINFO previously obtained from BINDINFO_to_xmit.
//
//--------------------------------------------------------------------------
void __RPC_USER BINDINFO_free_xmit(RemBINDINFO *pxmit)
{
    if(pxmit)
    {
        NdrOleFree(pxmit);
    }
}
#endif //UNUSED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\search\plugdll.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       plugdll.cxx
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    11-07-1996   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------
#include <urlint.h>
#include <stdio.h>
#include <sem.hxx>
#include "urlcf.hxx"
#include "selfreg.hxx"

#define SZNAMESPACEROOT "PROTOCOLS\\Name-Space Handler\\"
#define SZPROTOCOLROOT  "PROTOCOLS\\Handler\\"
#define SZCLASS         "CLSID"


// ==========================================================================================================
//
// THIS IS OUR CLSID
//
GUID CLSID_ResProtocol =     {0x79eaca01, 0xbaf9, 0x11ce, {0x8c, 0x82, 0x00, 0xaa, 0x00, 0x4b, 0xa9, 0x0b}};
//
// ==========================================================================================================


DECLARE_INFOLEVEL(UrlMk)
DECLARE_INFOLEVEL(Trans)
HINSTANCE g_hInst = NULL;

// global variables
CRefCount g_cRef(0);        // global dll refcount


#define DLL_NAME      "b4hook.dll"

STDAPI_(BOOL) TlsDllMain(HINSTANCE hDll, DWORD dwReason, LPVOID lpvReserved);


#define HANDLER_HOOK                           SZNAMESPACEROOT"Search Hook"
#define HANDLER_RES                            SZPROTOCOLROOT"search"
#define PROTOCOL_RES_CLSID                     "{79eaca01-baf9-11ce-8c82-00aa004ba90b}"
#define PROTOCOL_RES_CLSID_REGKEY              "CLSID\\"PROTOCOL_RES_CLSID
#define PROTOCOL_HOOK_DESCRIP                  "Search Hook: Asychronous Name-Space Handler"
#define PROTOCOL_RES_DESCRIP                   "search: Asychronous Pluggable Protocol Handler"

#define HANDLER_PROTOCOLS                       HANDLER_HOOK"\\Protocols"

// protocols
//***** PROTOCOL_RES ENTRIES *****
const REGENTRY rgClassesRes[] =
{
    STD_ENTRY(PROTOCOL_RES_CLSID_REGKEY, PROTOCOL_RES_DESCRIP),
    STD_ENTRY(PROTOCOL_RES_CLSID_REGKEY"\\InprocServer32", "%s"DLL_NAME),
        { KEYTYPE_STRING, PROTOCOL_RES_CLSID_REGKEY"\\InprocServer32", "ThreadingModel", REG_SZ, (BYTE*)"Apartment" },
};


const REGENTRY rgHandlerRes   [] = 
{ 
    STD_ENTRY(HANDLER_RES  , PROTOCOL_RES_DESCRIP  ), 
        { KEYTYPE_STRING, HANDLER_RES  , "CLSID", REG_SZ, (BYTE*)PROTOCOL_RES_CLSID   },
    STD_ENTRY(HANDLER_HOOK  , PROTOCOL_HOOK_DESCRIP  ), 
        { KEYTYPE_STRING, HANDLER_HOOK  , "CLSID", REG_SZ, (BYTE*)PROTOCOL_RES_CLSID   },
    STD_ENTRY(HANDLER_PROTOCOLS  , ""  ), 
        { KEYTYPE_STRING, HANDLER_PROTOCOLS  , "http", REG_SZ, (BYTE*)""   }

};

const REGENTRYGROUP rgRegEntryGroups[] = {

    { HKEY_CLASSES_ROOT, rgClassesRes,     ARRAYSIZE(rgClassesRes) },
    { HKEY_CLASSES_ROOT, rgHandlerRes  ,   ARRAYSIZE(rgHandlerRes  ) },
    { NULL, NULL, 0 }       // terminator
};


//+---------------------------------------------------------------------------
//
//  Function:   DllAddRef
//
//  Synopsis:
//
//  Arguments:  [void] --
//
//  Returns:
//
//  History:    11-07-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
void DllAddRef(void)
{
    g_cRef++;
}

//+---------------------------------------------------------------------------
//
//  Function:   DllRelease
//
//  Synopsis:
//
//  Arguments:  [void] --
//
//  Returns:
//
//  History:    11-07-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
void DllRelease(void)
{
    UrlMkAssert((g_cRef > 0));
    if (g_cRef > 0)
    {
        g_cRef--;
    }
}

//+---------------------------------------------------------------------------
//
//  Operator:   new
//
//  Synopsis:
//
//  Arguments:  [size] --
//
//  Returns:
//
//  History:    11-07-96   JohannP (Johann Posch)   Created
//
//  Notes:      BUBUG: get and use IMalloc
//
//----------------------------------------------------------------------------
void * _cdecl operator new(size_t size)
{
    void * pBuffer;
    pBuffer = CoTaskMemAlloc(size);
    if (pBuffer)
    {
        memset(pBuffer,0, size);
    }
    return pBuffer;
}

//+---------------------------------------------------------------------------
//
//  Operator:   delete
//
//  Synopsis:
//
//  Arguments:  [lpv] --
//
//  Returns:
//
//  History:    2-14-96   JohannP (Johann Posch)   Created
//
//  Notes:      BUBUG: get and use IMalloc
//
//----------------------------------------------------------------------------
void _cdecl operator delete(void *lpv)
{
    UrlMkAssert((lpv != NULL));
    if (lpv == NULL)
    {
        return;
    }

    CoTaskMemFree(lpv);
}

//+-------------------------------------------------------------------------
//
//  Function:   DllGetClassObject
//
//  Synopsis:   Dll entry point
//
//  Arguments:  [clsid] - class id for new class
//              [iid] - interface required of class
//              [ppv] - where to put new interface
//
//  Returns:    S_OK - class object created successfully created.
//
//  History:    11-07-96   JohannP (Johann Posch)   Created
//
//--------------------------------------------------------------------------
STDAPI DllGetClassObject(REFCLSID clsid, REFIID iid, void **ppv)
{
    UrlMkDebugOut((DEB_URLMON, "API _IN DllGetClassObject\n"));

    HRESULT hr = E_FAIL;

    if (clsid == CLSID_ResProtocol)
    {
        /*
        IClassFactory *pCF = NULL;

        //hr = tsaMain.GetClassFactory(&pCF);
        if (hr == NOERROR)
        {
            UrlMkAssert((pCF != NULL));
            hr = pCF->QueryInterface(iid, ppv);
            UrlMkAssert((hr == NOERROR));
            pCF->Release();
        }
        */
        CUrlClsFact *pCF = NULL;
        hr = CUrlClsFact::Create(clsid, &pCF);
        if (hr == NOERROR)
        {
            UrlMkAssert((pCF != NULL));
            hr = pCF->QueryInterface(iid, ppv);
            pCF->Release();
        }


    }


    UrlMkDebugOut((DEB_URLMON, "API OUT DllGetClassObject (hr:%lx, ppv:%p)\n",hr,*ppv));
    return hr;
}
//+-------------------------------------------------------------------------
//
//  Function:   DllMain
//
//  Synopsis:
//
//  Arguments:  [hDll]          - a handle to the dll instance
//              [dwReason]      - the reason LibMain was called
//              [lpvReserved]   - NULL - called due to FreeLibrary
//                              - non-NULL - called due to process exit
//
//  Returns:    TRUE on success, FALSE otherwise
//
//  Notes:
//
//              The officially approved DLL entrypoint name is DllMain. This
//              entry point will be called by the CRT Init function.
//
//  History:    11-07-96   JohannP (Johann Posch)   Created
//
//--------------------------------------------------------------------------
BOOL WINAPI DllMain(HINSTANCE hInstance,DWORD dwReason,LPVOID lpvReserved)
{
    BOOL fResult = TRUE;
    switch (dwReason)
    {
    case DLL_PROCESS_ATTACH:
#if DBG==1
        {
            UrlMkInfoLevel = (DWORD) GetProfileIntA("UrlMon","UrlMk", (DEB_ERROR | DEB_WARN));
            TransInfoLevel = (DWORD) GetProfileIntA("UrlMon","Trans", (DEB_ERROR | DEB_WARN));
        }
#endif //DBG==1
        g_hInst = hInstance;
        //tsaMain.InitApp(NULL);

        //fResult = TlsDllMain(hInstance, dwReason, lpvReserved);
        break;

    case DLL_PROCESS_DETACH:

        // Fall through

    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:
        //fResult = TlsDllMain(hInstance, dwReason, lpvReserved);
        break;

    }
    return fResult;
}

//+---------------------------------------------------------------------------
//
//  Function:   DllCanUnloadNow
//
//  Synopsis:
//
//  Arguments:  [void] --
//
//  Returns:
//
//  History:    11-07-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI DllCanUnloadNow(void)
{
    return (g_cRef ? S_FALSE : S_OK);
}

//+---------------------------------------------------------------------------
//
//  Function:   DllRegisterServer
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    10-07-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI DllRegisterServer()
{
    UrlMkDebugOut((DEB_URLMON, "API _IN DllRegisterServer\n"));
    HRESULT hr;


    hr = HrDllRegisterServer(rgRegEntryGroups, g_hInst, NULL /*pfnLoadString*/);


    UrlMkDebugOut((DEB_URLMON, "API OUT DllRegisterServer (hr:%lx)\n",hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   DllUnregisterServer
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    11-07-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI DllUnregisterServer()
{
    UrlMkDebugOut((DEB_URLMON, "API _IN DllUnregisterServer\n"));
    HRESULT hr;

    hr = HrDllUnregisterServer(rgRegEntryGroups, g_hInst, NULL /*pfnLoadString*/);

    UrlMkDebugOut((DEB_URLMON, "API OUT DllUnregisterServer (hr:%lx)\n",hr));
    return hr;
}


#if DBG==1

#include <sem.hxx>
CMutexSem   mxs;
void TransUrlSpy(int iOption, const char *pscFormat, ...)
{
    static char szOutBuffer[2048];
    CLock       lck(mxs);
    DWORD tid = GetCurrentThreadId();
    DWORD cbBufLen;
    sprintf(szOutBuffer,"%08x> ", tid );
    cbBufLen = strlen(szOutBuffer);

    va_list args;
    if (iOption & TransInfoLevel)
    {
        va_start(args, pscFormat);
        wvsprintf(szOutBuffer + cbBufLen, pscFormat, args);
        va_end(args);
        UrlSpySendEntry(szOutBuffer);
    }
}
void UrlMkUrlSpy(int iOption, const char *pscFormat, ...)
{
    static char szOutBuffer[2048];
    CLock       lck(mxs);
    DWORD tid = GetCurrentThreadId();
    DWORD cbBufLen;
    sprintf(szOutBuffer,"%08x> ", tid );
    cbBufLen = strlen(szOutBuffer);

    va_list args;
    if (iOption & UrlMkInfoLevel)
    {
        va_start(args, pscFormat);
        wvsprintf(szOutBuffer + cbBufLen, pscFormat, args);
        va_end(args);
        UrlSpySendEntry(szOutBuffer);
    }
}

void UrlSpy(int iOption, const char *pscFormat, ...)
{
    static char szOutBuffer[2048];
    CLock       lck(mxs);
    DWORD tid = GetCurrentThreadId();
    DWORD cbBufLen;
    //sprintf(szOutBuffer,"%08x.%08x> ", pid, tid );
    sprintf(szOutBuffer,"%08x> ", tid );
    cbBufLen = strlen(szOutBuffer);

    va_list args;
    //if (   (iOption & DEB_INVOKES) )
    {
        va_start(args, pscFormat);
        wvsprintf(szOutBuffer + cbBufLen, pscFormat, args);
        va_end(args);
        UrlSpySendEntry(szOutBuffer);
    }
}

IDebugOut *v_pDbgOut = NULL;

void UrlSpySendEntry(LPSTR szOutBuffer)
{
    if (v_pDbgOut)
    {
        v_pDbgOut->SendEntry(szOutBuffer);
    }
    {
        OutputDebugString(szOutBuffer);
    }
}

HRESULT RegisterDebugOut(IDebugOut *pDbgOut)
{
    if (v_pDbgOut)
    {
        v_pDbgOut->Release();
        v_pDbgOut = NULL;
    }
    if (pDbgOut)
    {

        v_pDbgOut = pDbgOut;
        pDbgOut->AddRef();
    }
    return NOERROR;
}


#endif //DBG==1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\search\protbase.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       protbase.cxx
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    11-07-1996   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------
#include <urlint.h>
#include <stdio.h>
#include <sem.hxx>
#include <wininet.h>
#include "urlcf.hxx"
#include "protbase.hxx"
#include "resprot.hxx"


extern GUID CLSID_ResProtocol;


//+---------------------------------------------------------------------------
//
//  Method:     CBaseProtocol::QueryInterface
//
//  Synopsis:
//
//  Arguments:  [riid] --
//              [ppvObj] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBaseProtocol::QueryInterface(REFIID riid, void **ppvObj)
{
    VDATEPTROUT(ppvObj, void *);
    VDATETHIS(this);
    HRESULT hr = NOERROR;

    TransDebugOut((DEB_PROT, "%p _IN CBaseProtocol::QueryInterface\n", this));

    hr = _pUnkOuter->QueryInterface(riid, ppvObj);

    TransDebugOut((DEB_PROT, "%p OUT CBaseProtocol::QueryInterface (hr:%lx\n", this,hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   CBaseProtocol::AddRef
//
//  Synopsis:
//
//  Arguments:  [ULONG] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CBaseProtocol::AddRef(void)
{
    TransDebugOut((DEB_PROT, "%p _IN CBaseProtocol::AddRef\n", this));

    LONG lRet = _pUnkOuter->AddRef();

    TransDebugOut((DEB_PROT, "%p OUT CBaseProtocol::AddRef (cRefs:%ld)\n", this,lRet));
    return lRet;
}

//+---------------------------------------------------------------------------
//
//  Function:   CBaseProtocol::Release
//
//  Synopsis:
//
//  Arguments:  [ULONG] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CBaseProtocol::Release(void)
{
    TransDebugOut((DEB_PROT, "%p _IN CBaseProtocol::Release\n", this));

    LONG lRet = _pUnkOuter->Release();

    TransDebugOut((DEB_PROT, "%p OUT CBaseProtocol::Release (cRefs:%ld)\n",this,lRet));
    return lRet;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBaseProtocol::Start
//
//  Synopsis:
//
//  Arguments:  [pwzUrl] --
//              [pTrans] --
//              [pOIBindInfo] --
//              [grfSTI] --
//              [dwReserved] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBaseProtocol::Start(LPCWSTR pwzUrl, IOInetProtocolSink *pTrans, IOInetBindInfo *pOIBindInfo,
                          DWORD grfSTI, DWORD dwReserved)
{
    TransDebugOut((DEB_PROT, "%p _IN CBaseProtocol::Start\n", this));
    HRESULT hr = NOERROR;

    TransAssert((!_pProtSink && pOIBindInfo && pTrans));
    TransAssert((_pszUrl == NULL));

    _pProtSink = pTrans;
    _pProtSink->AddRef();

    _BndInfo.cbSize = sizeof(BINDINFO);

    _pOIBindInfo =  pOIBindInfo;
    _pOIBindInfo->AddRef();

    hr = pOIBindInfo->GetBindInfo(&_grfBindF, &_BndInfo);

    // save the URL
    _pszUrl = DupW2A(pwzUrl);

    TransDebugOut((DEB_PROT, "%p OUT CBaseProtocol::Start (hr:%lx)\n",this, hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBaseProtocol::Continue
//
//  Synopsis:
//
//  Arguments:  [pStateInfoIn] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBaseProtocol::Continue(PROTOCOLDATA *pStateInfoIn)
{
    TransDebugOut((DEB_PROT, "%p _IN CBaseProtocol::Continue\n", this));

    HRESULT hr = E_FAIL;

    TransDebugOut((DEB_PROT, "%p OUT CBaseProtocol::Continue (hr:%lx)\n",this, hr));
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CBaseProtocol::Abort
//
//  Synopsis:
//
//  Arguments:  [hrReason] --
//              [dwOptions] --
//
//  Returns:
//
//  History:    11-09-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBaseProtocol::Abort(HRESULT hrReason, DWORD dwOptions)
{
    TransDebugOut((DEB_PROT, "%p _IN CBaseProtocol::Abort\n", this));
    HRESULT hr = NOERROR;

    if (_pProt)
        return _pProt->Abort(hrReason, dwOptions);

    TransAssert((_pProtSink));

    hr = _pProtSink->ReportResult(E_ABORT, 0, 0);

    TransDebugOut((DEB_PROT, "%p OUT CBaseProtocol::Abort (hr:%lx)\n",this, hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBaseProtocol::Terminate
//
//  Synopsis:
//
//  Arguments:  [dwOptions] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBaseProtocol::Terminate(DWORD dwOptions)
{
    TransDebugOut((DEB_PROT, "%p _IN CBaseProtocol::Terminate\n", this));
    HRESULT hr = NOERROR;

    if (_pProt)
    {
        hr = _pProt->Terminate(dwOptions);

        if (FAILED(hr))
            return hr;

        _pProt->Release();
        _pProt = NULL;
    }

    TransAssert((_pProtSink));

    if (_pOIBindInfo)
    {
        _pOIBindInfo->Release();
        _pOIBindInfo = NULL;
    }
    if (_pProtSink)
    {
        _pProtSink->Release();
        _pProtSink = NULL;
    }

#if DBG == 1
    if ( _BndInfo.stgmedData.tymed != TYMED_NULL )
        TransDebugOut((DEB_TRANS, "%p --- CBaseProtocol::Stop ReleaseStgMedium (%p)\n", this,_BndInfo.stgmedData));
#endif

    ReleaseBindInfo(&_BndInfo);

    TransDebugOut((DEB_PROT, "%p OUT CBaseProtocol::Terminate (hr:%lx)\n",this, hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBaseProtocol::Suspend
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBaseProtocol::Suspend()
{
    TransDebugOut((DEB_PROT, "%p _IN CBaseProtocol::Suspend\n", this));

    HRESULT hr = E_NOTIMPL;

    if (_pProt)
        hr = _pProt->Suspend();

    TransDebugOut((DEB_PROT, "%p OUT CBaseProtocol::Suspend (hr:%lx)\n",this, hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBaseProtocol::Resume
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBaseProtocol::Resume()
{
    TransDebugOut((DEB_PROT, "%p _IN CBaseProtocol::Resume\n", this));

    HRESULT hr = E_NOTIMPL;

    if (_pProt)
        hr = _pProt->Resume();

    TransDebugOut((DEB_PROT, "%p OUT CBaseProtocol::Resume (hr:%lx)\n",this, hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBaseProtocol::SetPriority
//
//  Synopsis:
//
//  Arguments:  [nPriority] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBaseProtocol::SetPriority(LONG nPriority)
{
    TransDebugOut((DEB_PROT, "%p _IN CBaseProtocol::SetPriority\n", this));

    HRESULT hr = E_NOTIMPL;

    TransDebugOut((DEB_PROT, "%p OUT CBaseProtocol::SetPriority (hr:%lx)\n",this, hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBaseProtocol::GetPriority
//
//  Synopsis:
//
//  Arguments:  [pnPriority] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBaseProtocol::GetPriority(LONG * pnPriority)
{
    TransDebugOut((DEB_PROT, "%p _IN CBaseProtocol::GetPriority\n", this));

    HRESULT hr = E_NOTIMPL;

    TransDebugOut((DEB_PROT, "%p OUT CBaseProtocol::GetPriority (hr:%lx)\n",this, hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBaseProtocol::Read
//
//  Synopsis:
//
//  Arguments:  [ULONG] --
//              [ULONG] --
//              [pcbRead] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBaseProtocol::Read(void *pv,ULONG cb,ULONG *pcbRead)
{
    TransDebugOut((DEB_PROT, "%p _IN CBaseProtocol::Read\n", this));

    HRESULT hr = E_FAIL;

    if (_pProt)
        hr = _pProt->Read(pv, cb, pcbRead);

    TransDebugOut((DEB_PROT, "%p OUT CBaseProtocol::Read (hr:%lx)\n",this, hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBaseProtocol::Seek
//
//  Synopsis:
//
//  Arguments:  [DWORD] --
//              [ULARGE_INTEGER] --
//              [plibNewPosition] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBaseProtocol::Seek(LARGE_INTEGER dlibMove,DWORD dwOrigin,ULARGE_INTEGER *plibNewPosition)
{
    TransDebugOut((DEB_PROT, "%p _IN CBaseProtocol::Seek\n", this));

    HRESULT hr = E_FAIL;

    if (_pProt)
        hr = _pProt->Seek(dlibMove, dwOrigin, plibNewPosition);

    TransDebugOut((DEB_PROT, "%p OUT CBaseProtocol::Seek (hr:%lx)\n",this, hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBaseProtocol::LockRequest
//
//  Synopsis:
//
//  Arguments:  [dwOptions] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBaseProtocol::LockRequest(DWORD dwOptions)
{
    TransDebugOut((DEB_PROT, "%p _IN CBaseProtocol::LockRequest\n", this));

    HRESULT hr = NOERROR;

    if (_pProt)
        hr = _pProt->LockRequest(dwOptions);

    TransDebugOut((DEB_PROT, "%p OUT CBaseProtocol::LockRequest (hr:%lx)\n",this, hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBaseProtocol::UnlockRequest
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBaseProtocol::UnlockRequest()
{
    TransDebugOut((DEB_PROT, "%p _IN CBaseProtocol::UnlockRequest\n", this));

    HRESULT hr = NOERROR;

    if (_pProt)
        hr = _pProt->UnlockRequest();

    TransDebugOut((DEB_PROT, "%p OUT CBaseProtocol::UnlockRequest (hr:%lx)\n",this, hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBaseProtocol::Prepare
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    11-07-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBaseProtocol::Prepare()
{
    TransDebugOut((DEB_PROT, "%p _IN CBaseProtocol::Prepare\n", this));
    HRESULT hr = NOERROR;

    TransAssert((  IsApartmentThread() ));


    TransDebugOut((DEB_PROT,"%p OUT CBaseProtocol::Prepare (hr:%lx)\n",this, hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBaseProtocol::Continue
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    11-09-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBaseProtocol::Continue()
{
    TransDebugOut((DEB_PROT, "%p _IN CBaseProtocol::Continue\n", this));
    HRESULT hr = NOERROR;

    TransAssert((  !IsApartmentThread() ));

    _dwThreadID = GetCurrentThreadId();

    TransDebugOut((DEB_PROT,"%p OUT CBaseProtocol::Continue (hr:%lx)\n",this, hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBaseProtocol::CBaseProtocol
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    1-27-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
CBaseProtocol::CBaseProtocol(REFCLSID rclsid, IUnknown *pUnkOuter, IUnknown **ppUnkInner) : _CRefs(), _pclsidProtocol(rclsid), _Unknown()
{
    TransDebugOut((DEB_PROT, "%p _IN CBaseProtocol::CBaseProtocol \n", this));
    _dwThreadID = GetCurrentThreadId();
    _bscf = BSCF_FIRSTDATANOTIFICATION;
    _pOIBindInfo = 0;

    _pszUrl = 0;
    _pProt = 0;

    if (!pUnkOuter)
    {
        pUnkOuter = &_Unknown;
    }
    else
    {
        TransAssert((ppUnkInner));
        if (ppUnkInner)
        {
            *ppUnkInner =  &_Unknown;
            _CRefs = 0;
        }
    }

    _pUnkOuter = pUnkOuter;

    TransDebugOut((DEB_PROT, "%p OUT CBaseProtocol::CBaseProtocol \n", this));
}

//+---------------------------------------------------------------------------
//
//  Method:     CBaseProtocol::~CBaseProtocol
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    11-09-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
CBaseProtocol::~CBaseProtocol()
{
    if (_pszUrl)
        delete _pszUrl;

    TransDebugOut((DEB_PROT, "%p _IN/OUT CBaseProtocol::~CBaseProtocol \n", this));
}

//+---------------------------------------------------------------------------
//
//  Method:     CBaseProtocol::CPrivUnknown::QueryInterface
//
//  Synopsis:
//
//  Arguments:  [riid] --
//              [ppvObj] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBaseProtocol::CPrivUnknown::QueryInterface(REFIID riid, void **ppvObj)
{
    VDATEPTROUT(ppvObj, void *);
    VDATETHIS(this);
    HRESULT hr = NOERROR;

    TransDebugOut((DEB_PROT, "%p _IN CBaseProtocol::CPrivUnknown::QueryInterface\n", this));
    CBaseProtocol *pCBaseProtocol = GETPPARENT(this, CBaseProtocol, _Unknown);

    *ppvObj = NULL;

    if ((riid == IID_IUnknown) || (riid == IID_IOInetProtocol) || (riid == IID_IOInetProtocolRoot) )
    {
        *ppvObj = (IOInetProtocol *) pCBaseProtocol;
        pCBaseProtocol->AddRef();
    }
    else if (riid == IID_IOInetThreadSwitch)
    {
        *ppvObj = (IOInetThreadSwitch *)pCBaseProtocol;
        pCBaseProtocol->AddRef();
    }
    else
    {
        hr = E_NOINTERFACE;
    }

    TransDebugOut((DEB_PROT, "%p OUT CBaseProtocol::CPrivUnknown::QueryInterface (hr:%lx\n", this,hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   CBaseProtocol::CPrivUnknown::AddRef
//
//  Synopsis:
//
//  Arguments:  [ULONG] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CBaseProtocol::CPrivUnknown::AddRef(void)
{
    TransDebugOut((DEB_PROT, "%p _IN CBaseProtocol::CPrivUnknown::AddRef\n", this));

    LONG lRet = ++_CRefs;

    TransDebugOut((DEB_PROT, "%p OUT CBaseProtocol::CPrivUnknown::AddRef (cRefs:%ld)\n", this,lRet));
    return lRet;
}
//+---------------------------------------------------------------------------
//
//  Function:   CBaseProtocol::Release
//
//  Synopsis:
//
//  Arguments:  [ULONG] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CBaseProtocol::CPrivUnknown::Release(void)
{
    TransDebugOut((DEB_PROT, "%p _IN CBaseProtocol::CPrivUnknown::Release\n", this));

    CBaseProtocol *pCBaseProtocol = GETPPARENT(this, CBaseProtocol, _Unknown);

    LONG lRet = --_CRefs;

    if (lRet == 0)
    {
        delete pCBaseProtocol;
    }

    TransDebugOut((DEB_PROT, "%p OUT CBaseProtocol::CPrivUnknown::Release (cRefs:%ld)\n",this,lRet));
    return lRet;
}


//+---------------------------------------------------------------------------
//
//  Function:   OLESTRDuplicate
//
//  Synopsis:
//
//  Arguments:  [ws] --
//
//  Returns:
//
//  History:    11-09-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
LPWSTR OLESTRDuplicate(LPWSTR ws)
{
    LPWSTR wsNew = NULL;

    if (ws)
    {
        wsNew = (LPWSTR) new  WCHAR [wcslen(ws) + 1];
        if (wsNew)
        {
            wcscpy(wsNew, ws);
        }
    }

    return wsNew;
}

//+---------------------------------------------------------------------------
//
//  Function:   DupW2A
//
//  Synopsis:   duplicates a wide string to an ansi string
//
//  Arguments:  [pwz] --
//
//  History:    7-20-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
LPSTR DupW2A(const WCHAR *pwz)
{
    LPSTR szNew = NULL;

    if (pwz)
    {
        DWORD dwlen = wcslen(pwz) + 1;
        szNew = (LPSTR) new char [dwlen];
        if (szNew)
        {
            W2A(pwz, szNew, dwlen);
        }
    }

    return szNew;
}


//+---------------------------------------------------------------------------
//
//  Function:   DupA2W
//
//  Synopsis:   duplicates an ansi string to a wide string
//
//  Arguments:  [lpszAnsi] --
//
//  History:    7-20-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
LPWSTR DupA2W(const LPSTR psz)
{
    LPWSTR wzNew = NULL;

    if (psz)
    {
        DWORD dwlen = strlen(psz) + 1;
        wzNew = (LPWSTR) new WCHAR [dwlen];
        if (wzNew)
        {
            A2W(psz, wzNew, dwlen);
        }
    }

    return wzNew;
}


//BUG-WORK remove this and link to lib
const GUID IID_IOInet                = { 0x79eac9e0, 0xbaf9, 0x11ce, {0x8c, 0x82, 0x00, 0xaa, 0x00, 0x4b, 0xa9, 0x0b} };
const GUID IID_IOInetBindInfo        = { 0x79eac9e1, 0xbaf9, 0x11ce, {0x8c, 0x82, 0x00, 0xaa, 0x00, 0x4b, 0xa9, 0x0b} };
const GUID IID_IOInetBindClient      = { 0x79eac9e2, 0xbaf9, 0x11ce, {0x8c, 0x82, 0x00, 0xaa, 0x00, 0x4b, 0xa9, 0x0b} };
const GUID IID_IOInetProtocolRoot    = { 0x79eac9e3, 0xbaf9, 0x11ce, {0x8c, 0x82, 0x00, 0xaa, 0x00, 0x4b, 0xa9, 0x0b} };
const GUID IID_IOInetProtocol        = { 0x79eac9e4, 0xbaf9, 0x11ce, {0x8c, 0x82, 0x00, 0xaa, 0x00, 0x4b, 0xa9, 0x0b} };
const GUID IID_IOInetProtocolSink    = { 0x79eac9e5, 0xbaf9, 0x11ce, {0x8c, 0x82, 0x00, 0xaa, 0x00, 0x4b, 0xa9, 0x0b} };
const GUID IID_IOInetBinding         = { 0x79eac9e6, 0xbaf9, 0x11ce, {0x8c, 0x82, 0x00, 0xaa, 0x00, 0x4b, 0xa9, 0x0b} };
const GUID IID_IOInetSession         = { 0x79eac967, 0xbaf9, 0x11ce, {0x8c, 0x82, 0x00, 0xaa, 0x00, 0x4b, 0xa9, 0x0b} };
const GUID IID_IOInetThreadSwitch    = { 0x79eac968, 0xbaf9, 0x11ce, {0x8c, 0x82, 0x00, 0xaa, 0x00, 0x4b, 0xa9, 0x0b} };
const GUID IID_IOInetBindSink        = { 0x79eac9e9, 0xbaf9, 0x11ce, {0x8c, 0x82, 0x00, 0xaa, 0x00, 0x4b, 0xa9, 0x0b} };
const GUID IID_IOInetCache           = { 0x79eac9ea, 0xbaf9, 0x11ce, {0x8c, 0x82, 0x00, 0xaa, 0x00, 0x4b, 0xa9, 0x0b} };
const GUID IID_IOInetPriority        = { 0x79eac9eb, 0xbaf9, 0x11ce, {0x8c, 0x82, 0x00, 0xaa, 0x00, 0x4b, 0xa9, 0x0b} };


//+---------------------------------------------------------------------------
//
//  Function:   CreateAPP
//
//  Synopsis:
//
//  Arguments:  [rclsid] --
//              [pUnkOuter] --
//              [riid] --
//              [ppUnk] --
//
//  Returns:
//
//  History:    11-09-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CreateAPP(REFCLSID rclsid, IUnknown *pUnkOuter, REFIID riid, IUnknown **ppUnk)
{
    TransDebugOut((DEB_PROT, "API _IN CreateKnownProtocolInstance\n"));
    HRESULT hr = NOERROR;

    TransAssert((ppUnk));

    if (!ppUnk || (pUnkOuter && (riid != IID_IUnknown)) )
    {
        // Note: aggregation only works if asked for IUnknown
        TransAssert((FALSE && "Dude, look up aggregation rules - need to ask for IUnknown"));
        hr = E_INVALIDARG;
    }
    else
    {
        CBaseProtocol *pCBaseProtocol = NULL;

        if (rclsid == CLSID_ResProtocol)
        {
            pCBaseProtocol = new CResProtocol(CLSID_ResProtocol,pUnkOuter, ppUnk);
        }

        if (pCBaseProtocol)
        {
            if (riid == IID_IUnknown)
            {

            }
            else if (riid == IID_IOInetProtocol)
            {
                // ok, got the right interface already
                *ppUnk = (IOInetProtocol *)pCBaseProtocol;
            }
            else
            {
                hr = pCBaseProtocol->QueryInterface(riid, (void **)ppUnk);
                // remove extra refcount
                pCBaseProtocol->Release();
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    TransDebugOut((DEB_PROT, "API OUT CreateKnownProtocolInstance(hr:%lx)\n", hr));
    return hr;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\search\b4hook.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       resprot.cxx
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    11-07-1996   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------
#include <urlint.h>
#include <stdio.h>
#include <sem.hxx>
#include <wininet.h>
#include "urlcf.hxx"
#include "protbase.hxx"
#include "b4hook.hxx"
#include <tchar.h>

#define MAX_ID 10000


HRESULT LookupProtocolClsIDFromReg(LPCTSTR pszUrl, CLSID *pclsid);

#define SZPROTOCOLROOT  "PROTOCOLS\\Handler\\"
#define SZCLASS         "CLSID"

#define SZMYPROTOCOL    "search"



//+---------------------------------------------------------------------------
//
//  Method:     CB4Hook::Start
//
//  Synopsis:
//
//  Arguments:  [pwzUrl] --
//              [pTrans] --
//              [pOIBindInfo] --
//              [grfSTI] --
//              [dwReserved] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CB4Hook::Start(LPCWSTR pwzUrl, IOInetProtocolSink *pTrans, IOInetBindInfo *pOIBindInfo,
                          DWORD grfSTI, DWORD dwReserved)
{
    TransDebugOut((DEB_PROT, "%p _IN CB4Hook::Start\n", this));
    HRESULT hr = NOERROR;
    CLSID clsid;

    TransAssert((!_pProtSink && pOIBindInfo && pTrans));
    TransAssert((_pszUrl == NULL));

    // have to start the base class to get the bindinfo and the full URL.

    hr = CBaseProtocol::Start(pwzUrl,pTrans, pOIBindInfo, grfSTI, dwReserved);

    if (hr == NOERROR)
    {
        // first, check if this is hookable URL.
        // return E_USEDEFAULTPROTOCAL if not.

        if ((hr = Bind()) == NOERROR)
        {
            // We need to use the new (cooked) URL if Bind() succeeded.

            if ((hr = LookupProtocolClsIDFromReg(_szNewUrl, &clsid)) == NOERROR)
            {
                IClassFactory *pCF = 0;
                hr = CoCreateInstance(clsid, NULL, CLSCTX_INPROC_SERVER,IID_IClassFactory, (void**)&pCF);
                if (hr == NOERROR)
                {
                    // Perf: 
                    // we might want to move Create/Release of the HTTP protocl handler out of
                    // Start/Terminate to Create/Release.
    
                    hr = pCF->CreateInstance(NULL, IID_IOInetProtocol, (void **)&_pProt);
                    if (hr == NOERROR)
                    {
                        // ???
                        // We also may need to implement our own IOInetBindInfo so that we
                        // can give it the new (cooked) BindInfo.

                        // We need to pass down the new (cooked) URL if Bind() succeeded.

                        LPWSTR pwzNewUrl = DupA2W(_szNewUrl);
            
                        if (pwzNewUrl)
                        {
                            hr = _pProt->Start(pwzNewUrl, pTrans, pOIBindInfo, grfSTI, dwReserved);

                            delete pwzNewUrl;
                        }
                    }
    
                    pCF->Release();
                }
    
            }
        }
    }

    TransDebugOut((DEB_PROT, "%p OUT CB4Hook::Start (hr:%lx)\n",this, hr));
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CB4Hook::Continue
//
//  Synopsis:
//
//  Arguments:  [pStateInfoIn] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CB4Hook::Continue(PROTOCOLDATA *pStateInfoIn)
{
    TransDebugOut((DEB_PROT, "%p _IN CB4Hook::Continue\n", this));
    HRESULT hr = E_FAIL;

    if (_pProt)
        hr = _pProt->Continue(pStateInfoIn);

    TransDebugOut((DEB_PROT, "%p OUT CB4Hook::Continue (hr:%lx)\n",this, hr));
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CB4Hook::Read
//
//  Synopsis:
//
//  Arguments:  [ULONG] --
//              [ULONG] --
//              [pcbRead] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CB4Hook::Read(void *pv,ULONG cb,ULONG *pcbRead)
{
    TransDebugOut((DEB_PROT, "%p _IN CB4Hook::Read (cb:%ld)\n", this,cb));
    HRESULT hr = NOERROR;

    if (_pProt)
        hr = _pProt->Read(pv, cb, pcbRead);

    TransDebugOut((DEB_PROT, "%p OUT CB4Hook::Read (pcbRead:%ld, hr:%lx)\n",this,*pcbRead, hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CB4Hook::Seek
//
//  Synopsis:
//
//  Arguments:  [DWORD] --
//              [ULARGE_INTEGER] --
//              [plibNewPosition] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:      WORK: not done
//
//----------------------------------------------------------------------------
STDMETHODIMP CB4Hook::Seek(LARGE_INTEGER dlibMove,DWORD dwOrigin,ULARGE_INTEGER *plibNewPosition)
{
    TransDebugOut((DEB_PROT, "%p _IN CB4Hook::Seek\n", this));
    HRESULT hr = NOERROR;

    if (_pProt)
        hr = _pProt->Seek(dlibMove, dwOrigin, plibNewPosition);

    TransDebugOut((DEB_PROT, "%p OUT CB4Hook::Seek (hr:%lx)\n",this, hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CB4Hook::CB4Hook
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    1-27-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
CB4Hook::CB4Hook(REFCLSID rclsid, IUnknown *pUnkOuter, IUnknown **ppUnkInner) : CBaseProtocol(rclsid, pUnkOuter, ppUnkInner)
{
    TransDebugOut((DEB_PROT, "%p _IN/OUT CB4Hook::CB4Hook \n", this));
}

//+---------------------------------------------------------------------------
//
//  Method:     CB4Hook::~CB4Hook
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    11-09-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
CB4Hook::~CB4Hook()
{
    TransDebugOut((DEB_PROT, "%p _IN/OUT CB4Hook::~CB4Hook \n", this));
}


// SUPER HACK FUNCTION because InternetCrackUrl is not very good.
// THIS FUNCTION DOES NOT CHECK THE INPUT BUFFER SIZE.
// AND CALLER MUST PROVIDE lpszUrlPath buffer for us to parse.

BOOL
MyCrackUrl(
    LPCSTR lpszUrl,
    DWORD dwUrlLength,
    DWORD dwFlags,
    LPURL_COMPONENTSA lpUC
)
{
    LPSTR pszBuf = lpUC->lpszUrlPath;
    DWORD dwSize = lpUC->dwUrlPathLength;
    BOOL ret = FALSE;

    if (pszBuf)
    {
        if (InternetCanonicalizeUrl(lpszUrl, pszBuf, &dwSize, ICU_DECODE | ICU_NO_ENCODE))
        {
            // find protocol

            LPSTR pTmp = StrChr(pszBuf, ':');

            if (pTmp)
            {
                *pTmp = '\0';

                if (lpUC->lpszScheme)
                {
                    lstrcpy(lpUC->lpszScheme, pszBuf);
                    lpUC->dwSchemeLength = pTmp - pszBuf;
                }

                pszBuf = ++pTmp;

                // skip '/'s

                while (*pszBuf && (*pszBuf == '/')) 
                    pszBuf++;

                // find host name

                pTmp = StrChr(pszBuf, '/');

                if (lpUC->lpszHostName)
                {
                    if (pTmp)
                        lpUC->dwHostNameLength = pTmp - pszBuf;
                    else
                        lpUC->dwHostNameLength = lstrlen(pszBuf);
    
                    // + 1 for the NULL terminator
    
                    lstrcpyn(lpUC->lpszHostName, pszBuf, lpUC->dwHostNameLength + 1);
                }

                // if a '/' was found, the rest is URL path

                if (pTmp)
                    lpUC->dwUrlPathLength = lstrlen(pTmp);
                else
                    lpUC->dwUrlPathLength = 0;

                lpUC->lpszUrlPath = pTmp;

                ret = TRUE;
            }
        }
    }

    return ret;
}


//+---------------------------------------------------------------------------
//
//  Method:     CB4Hook::Bind
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    11-09-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CB4Hook::Bind()
{
    TransDebugOut((DEB_PROT, "%p _IN CB4Hook::Bind (szUrl >%s< )\n", this, _pszUrl));

    HRESULT hr = INET_E_USE_DEFAULT_PROTOCOLHANDLER;
    URL_COMPONENTS uc;
    TCHAR szScheme[INTERNET_MAX_SCHEME_LENGTH];
    TCHAR szHost[INTERNET_MAX_HOST_NAME_LENGTH];
    TCHAR szURL[MAX_URL_SIZE];
    DWORD dwNeeded;
    LPSTR lpSearchName;
    LPSTR lpNewName = NULL;

    ZeroMemory(&uc, sizeof(uc));
    uc.dwStructSize = sizeof(uc);
    uc.lpszScheme = szScheme;
    uc.dwSchemeLength = ARRAYSIZE(szScheme);
    uc.lpszHostName = szHost;
    uc.dwHostNameLength = ARRAYSIZE(szHost);
    uc.lpszUrlPath = szURL;
    uc.dwUrlPathLength = ARRAYSIZE(szURL);

    // uc.dwExtraInfoLength ???

    // BUGBUG ???
    // InternetCrackUrl doesn't work with "search:\\..."

    if (MyCrackUrl(_pszUrl, 0, ICU_DECODE, &uc))
    {
        // TODO:
        // process the URL string

        if (!lstrcmpi(szScheme, SZMYPROTOCOL))
        {
            // if this is our "search:" protocol

            // BUGBUG
            // we need to look up the registry for the default protocol to use.

            uc.lpszScheme = NULL;
            uc.nScheme = INTERNET_SCHEME_HTTP;
            uc.nPort = INTERNET_DEFAULT_HTTP_PORT;

            if (uc.dwHostNameLength)
            {
                lpSearchName = uc.lpszHostName;
                uc.dwHostNameLength = 0;

                // ???
                // should we clear the UrlPath and ExtraInfo
            }
            else if (uc.dwUrlPathLength)
            {
                lpSearchName = uc.lpszUrlPath;
                uc.lpszUrlPath = NULL;
            }
            else
                lpSearchName = NULL;

            if (lpSearchName)
            {
                // apply the search.
                // ==========================================================
                if (!lstrcmpi(lpSearchName, "united airline"))
                    lpNewName = "www.ual.com";
                else if (!lstrcmpi(lpSearchName, "foo bar"))
                    lpNewName = "msw";
                // ==========================================================

                if (lpNewName)
                {
                    // this is a searchable string

                    uc.lpszHostName = lpNewName;
    
                    dwNeeded = ARRAYSIZE(_szNewUrl);
        
                    if (InternetCreateUrl(&uc, 0, _szNewUrl, &dwNeeded))
                        hr = NOERROR;
                }
            }
        }
        else if (uc.nScheme == INTERNET_SCHEME_HTTP)
        {
            lpSearchName = uc.lpszHostName;

            // apply search
            // ==========================================================
            if (!lstrcmpi(lpSearchName, "united airline"))
                lpNewName = "www.ual.com";
            else if (!lstrcmpi(lpSearchName, "foo bar"))
                lpNewName = "msw";
            // ==========================================================

            if (lpNewName)
            {
                // if search succeeded
                uc.lpszHostName = lpNewName;
                uc.dwHostNameLength = 0;
    
                dwNeeded = ARRAYSIZE(_szNewUrl);
    
                if (InternetCreateUrl(&uc, 0, _szNewUrl, &dwNeeded))
                    hr = NOERROR;
            }
        }
    }
    else
    {
        DebugBreak();

        DWORD dwError = GetLastError();
    }

    // if (hr == MK_E_SYNTAX)
    if (hr == INET_E_USE_DEFAULT_PROTOCOLHANDLER)
    {
        _pProtSink->ReportResult(hr, 0, 0);
    }

    TransDebugOut((DEB_PROT, "%p OUT CB4Hook::Bind (hr:%lx)\n", this,hr));
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   LookupProtocolClsIDFromReg
//
//  Synopsis:   finds a protocol handler class for a given URL
//
//  Arguments:  [pwzUrl] --
//              [pclsid] --
//
//  Returns:
//
//  History:    11-01-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT LookupProtocolClsIDFromReg(LPCTSTR pszUrl, CLSID *pclsid)
{
    TransDebugOut((DEB_PROT, "API _IN LookupProtocolClsIDFromReg (szUrl >%s< )\n", pszUrl));
    HRESULT hr = INET_E_UNKNOWN_PROTOCOL;
    DWORD dwType;
    TCHAR pszProt[MAX_URL_SIZE + 1];

    TransAssert((pszUrl && pclsid));

    if (pszUrl)
    {
        char szDelimiter = ':';

        lstrcpy(pszProt, pszUrl);

        LPSTR pszDel = StrChr(pszProt, szDelimiter);

        if (pszDel)
        {
            *pszDel = '\0';

            // fail if the protocol is "search" so we don't get call recursively.
            if (lstrcmpi(pszProt, SZMYPROTOCOL))
            {
                HKEY hProtocolKey = NULL;
                DWORD dwLen = 256;
                char szProtocolKey[256];

                lstrcpy(szProtocolKey, SZPROTOCOLROOT);
                lstrcat(szProtocolKey, pszProt);
    
                if (RegOpenKeyEx(HKEY_CLASSES_ROOT, szProtocolKey, 0, KEY_QUERY_VALUE, &hProtocolKey) == ERROR_SUCCESS)
                {
                    if (RegQueryValueEx(hProtocolKey, SZCLASS, NULL, &dwType, (LPBYTE)szProtocolKey, &dwLen) == ERROR_SUCCESS)
                    {
                        LPWSTR pwzClsId = DupA2W(szProtocolKey);
    
                        if (pwzClsId)
                        {
                            hr = CLSIDFromString(pwzClsId, pclsid);
                            TransDebugOut((DEB_PROT, "API FOUND LookupProtocolClsIDFromReg(hr:%lx, ClsId:%ws)\n", hr,pwzClsId));
                            delete pwzClsId;
                        }
                        else
                        {
                            hr = E_OUTOFMEMORY;
                        }
                    }
    
                    RegCloseKey(hProtocolKey);
                }
            }
        }
        else
        {
            // look up the registry
            hr = MK_E_SYNTAX;
        }
    }

    TransDebugOut((DEB_PROT, "API OUT LookupProtocolClsIDFromReg(hr:%lx)\n", hr));
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\search\resprot.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       resprot.cxx
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    11-07-1996   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------
#include <urlint.h>
#include <stdio.h>
#include <sem.hxx>
#include <wininet.h>
#include "urlcf.hxx"
#include "protbase.hxx"
#include "resprot.hxx"
#include <tchar.h>

#define MAX_ID 10000


HRESULT LookupProtocolClsIDFromReg(LPCTSTR pszUrl, CLSID *pclsid);

#define SZPROTOCOLROOT  "PROTOCOLS\\Handler\\"
#define SZCLASS         "CLSID"

#define SZMYPROTOCOL    "search"



//+---------------------------------------------------------------------------
//
//  Method:     CResProtocol::Start
//
//  Synopsis:
//
//  Arguments:  [pwzUrl] --
//              [pTrans] --
//              [pOIBindInfo] --
//              [grfSTI] --
//              [dwReserved] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CResProtocol::Start(LPCWSTR pwzUrl, IOInetProtocolSink *pTrans, IOInetBindInfo *pOIBindInfo,
                          DWORD grfSTI, DWORD dwReserved)
{
    TransDebugOut((DEB_PROT, "%p _IN CResProtocol::Start\n", this));
    HRESULT hr = NOERROR;
    CLSID clsid;

    TransAssert((!_pProtSink && pOIBindInfo && pTrans));
    TransAssert((_pszUrl == NULL));

    // have to start the base class to get the bindinfo and the full URL.

    hr = CBaseProtocol::Start(pwzUrl,pTrans, pOIBindInfo, grfSTI, dwReserved);

    if (hr == NOERROR)
    {
        // first, check if this is hookable URL.
        // return E_USEDEFAULTPROTOCAL if not.

        if ((hr = Bind()) == NOERROR)
        {
            // We need to use the new (cooked) URL if Bind() succeeded.

            if ((hr = LookupProtocolClsIDFromReg(_szNewUrl, &clsid)) == NOERROR)
            {
                IClassFactory *pCF = 0;
                hr = CoCreateInstance(clsid, NULL, CLSCTX_INPROC_SERVER,IID_IClassFactory, (void**)&pCF);
                if (hr == NOERROR)
                {
                    // Perf: 
                    // we might want to move Create/Release of the HTTP protocl handler out of
                    // Start/Terminate to Create/Release.
    
                    hr = pCF->CreateInstance(NULL, IID_IOInetProtocol, (void **)&_pProt);
                    if (hr == NOERROR)
                    {
                        // ???
                        // We also may need to implement our own IOInetBindInfo so that we
                        // can give it the new (cooked) BindInfo.

                        // We need to pass down the new (cooked) URL if Bind() succeeded.

                        LPWSTR pwzNewUrl = DupA2W(_szNewUrl);
            
                        if (pwzNewUrl)
                        {
                            hr = _pProt->Start(pwzNewUrl, pTrans, pOIBindInfo, grfSTI, dwReserved);

                            delete pwzNewUrl;
                        }
                    }
    
                    pCF->Release();
                }
    
            }
        }
    }

    TransDebugOut((DEB_PROT, "%p OUT CResProtocol::Start (hr:%lx)\n",this, hr));
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CResProtocol::Continue
//
//  Synopsis:
//
//  Arguments:  [pStateInfoIn] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CResProtocol::Continue(PROTOCOLDATA *pStateInfoIn)
{
    TransDebugOut((DEB_PROT, "%p _IN CResProtocol::Continue\n", this));
    HRESULT hr = E_FAIL;

    if (_pProt)
        hr = _pProt->Continue(pStateInfoIn);

    TransDebugOut((DEB_PROT, "%p OUT CResProtocol::Continue (hr:%lx)\n",this, hr));
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CResProtocol::Read
//
//  Synopsis:
//
//  Arguments:  [ULONG] --
//              [ULONG] --
//              [pcbRead] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CResProtocol::Read(void *pv,ULONG cb,ULONG *pcbRead)
{
    TransDebugOut((DEB_PROT, "%p _IN CResProtocol::Read (cb:%ld)\n", this,cb));
    HRESULT hr = NOERROR;

    if (_pProt)
        hr = _pProt->Read(pv, cb, pcbRead);

    TransDebugOut((DEB_PROT, "%p OUT CResProtocol::Read (pcbRead:%ld, hr:%lx)\n",this,*pcbRead, hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CResProtocol::Seek
//
//  Synopsis:
//
//  Arguments:  [DWORD] --
//              [ULARGE_INTEGER] --
//              [plibNewPosition] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:      WORK: not done
//
//----------------------------------------------------------------------------
STDMETHODIMP CResProtocol::Seek(LARGE_INTEGER dlibMove,DWORD dwOrigin,ULARGE_INTEGER *plibNewPosition)
{
    TransDebugOut((DEB_PROT, "%p _IN CResProtocol::Seek\n", this));
    HRESULT hr = NOERROR;

    if (_pProt)
        hr = _pProt->Seek(dlibMove, dwOrigin, plibNewPosition);

    TransDebugOut((DEB_PROT, "%p OUT CResProtocol::Seek (hr:%lx)\n",this, hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CResProtocol::CResProtocol
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    1-27-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
CResProtocol::CResProtocol(REFCLSID rclsid, IUnknown *pUnkOuter, IUnknown **ppUnkInner) : CBaseProtocol(rclsid, pUnkOuter, ppUnkInner)
{
    TransDebugOut((DEB_PROT, "%p _IN/OUT CResProtocol::CResProtocol \n", this));
}

//+---------------------------------------------------------------------------
//
//  Method:     CResProtocol::~CResProtocol
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    11-09-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
CResProtocol::~CResProtocol()
{
    TransDebugOut((DEB_PROT, "%p _IN/OUT CResProtocol::~CResProtocol \n", this));
}


// SUPER HACK FUNCTION because InternetCrackUrl is not very good.
// THIS FUNCTION DOES NOT CHECK THE INPUT BUFFER SIZE.
// AND CALLER MUST PROVIDE lpszUrlPath buffer for us to parse.

BOOL
MyCrackUrl(
    LPCSTR lpszUrl,
    DWORD dwUrlLength,
    DWORD dwFlags,
    LPURL_COMPONENTSA lpUC
)
{
    LPSTR pszBuf = lpUC->lpszUrlPath;
    DWORD dwSize = lpUC->dwUrlPathLength;
    BOOL ret = FALSE;

    if (pszBuf)
    {
        if (InternetCanonicalizeUrl(lpszUrl, pszBuf, &dwSize, ICU_DECODE | ICU_NO_ENCODE))
        {
            // find protocol

            LPSTR pTmp = StrChr(pszBuf, ':');

            if (pTmp)
            {
                *pTmp = '\0';

                if (lpUC->lpszScheme)
                {
                    lstrcpy(lpUC->lpszScheme, pszBuf);
                    lpUC->dwSchemeLength = pTmp - pszBuf;
                }

                pszBuf = ++pTmp;

                // skip '/'s

                while (*pszBuf && (*pszBuf == '/')) 
                    pszBuf++;

                // find host name

                pTmp = StrChr(pszBuf, '/');

                if (lpUC->lpszHostName)
                {
                    if (pTmp)
                        lpUC->dwHostNameLength = pTmp - pszBuf;
                    else
                        lpUC->dwHostNameLength = lstrlen(pszBuf);
    
                    // + 1 for the NULL terminator
    
                    lstrcpyn(lpUC->lpszHostName, pszBuf, lpUC->dwHostNameLength + 1);
                }

                // if a '/' was found, the rest is URL path

                if (pTmp)
                    lpUC->dwUrlPathLength = lstrlen(pTmp);
                else
                    lpUC->dwUrlPathLength = 0;

                lpUC->lpszUrlPath = pTmp;

                ret = TRUE;
            }
        }
    }

    return ret;
}


//+---------------------------------------------------------------------------
//
//  Method:     CResProtocol::Bind
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    11-09-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CResProtocol::Bind()
{
    TransDebugOut((DEB_PROT, "%p _IN CResProtocol::Bind (szUrl >%s< )\n", this, _pszUrl));

    // HRESULT hr = MK_E_SYNTAX;
    // HRESULT hr = INET_E_USE_DEFAULT_PROTOCOLHANDLER;
    HRESULT hr = MK_E_NOPREFIX;
    // HRESULT hr = INET_E_UNKNOWN_PROTOCOL;
    URL_COMPONENTS uc;
    TCHAR szScheme[INTERNET_MAX_SCHEME_LENGTH];
    TCHAR szHost[INTERNET_MAX_HOST_NAME_LENGTH];
    TCHAR szURL[MAX_URL_SIZE];
    DWORD dwNeeded;
    LPSTR lpSearchName;
    LPSTR lpNewName = NULL;

    ZeroMemory(&uc, sizeof(uc));
    uc.dwStructSize = sizeof(uc);
    uc.lpszScheme = szScheme;
    uc.dwSchemeLength = ARRAYSIZE(szScheme);
    uc.lpszHostName = szHost;
    uc.dwHostNameLength = ARRAYSIZE(szHost);
    uc.lpszUrlPath = szURL;
    uc.dwUrlPathLength = ARRAYSIZE(szURL);

    // uc.dwExtraInfoLength ???

    // BUGBUG ???
    // InternetCrackUrl doesn't work with "search:\\..."

    if (MyCrackUrl(_pszUrl, 0, ICU_DECODE, &uc))
    {
        // TODO:
        // process the URL string

        if (!lstrcmpi(szScheme, SZMYPROTOCOL))
        {
            // if this is our "search:" protocol

            // BUGBUG
            // we need to look up the registry for the default protocol to use.

            uc.lpszScheme = NULL;
            uc.nScheme = INTERNET_SCHEME_HTTP;
            uc.nPort = INTERNET_DEFAULT_HTTP_PORT;

            if (uc.dwHostNameLength)
            {
                lpSearchName = uc.lpszHostName;
                uc.dwHostNameLength = 0;

                // ???
                // should we clear the UrlPath and ExtraInfo
            }
            else if (uc.dwUrlPathLength)
            {
                lpSearchName = uc.lpszUrlPath;
                uc.lpszUrlPath = NULL;
            }
            else
                lpSearchName = NULL;

            if (lpSearchName)
            {
                // apply the search.
                // ==========================================================
                if (!lstrcmpi(lpSearchName, "united airline"))
                    lpNewName = "www.ual.com";
                else if (!lstrcmpi(lpSearchName, "foo bar"))
                    lpNewName = "msw";
                // ==========================================================

                if (lpNewName)
                {
                    // this is a searchable string

                    uc.lpszHostName = lpNewName;
    
                    dwNeeded = ARRAYSIZE(_szNewUrl);
        
                    if (InternetCreateUrl(&uc, 0, _szNewUrl, &dwNeeded))
                        hr = NOERROR;
                }
            }
        }
        else if (uc.nScheme == INTERNET_SCHEME_HTTP)
        {
            lpSearchName = uc.lpszHostName;

            // apply search
            // ==========================================================
            if (!lstrcmpi(lpSearchName, "united airline"))
                lpNewName = "www.ual.com";
            else if (!lstrcmpi(lpSearchName, "foo bar"))
                lpNewName = "msw";
            // ==========================================================

            if (lpNewName)
            {
                // if search succeeded
                uc.lpszHostName = lpNewName;
                uc.dwHostNameLength = 0;
    
                dwNeeded = ARRAYSIZE(_szNewUrl);
    
                if (InternetCreateUrl(&uc, 0, _szNewUrl, &dwNeeded))
                    hr = NOERROR;
            }
        }
    }
    else
    {
        DebugBreak();

        DWORD dwError = GetLastError();
    }

    if (hr != NOERROR)
    {
        _pProtSink->ReportResult(hr, 0, 0);
    }

    TransDebugOut((DEB_PROT, "%p OUT CResProtocol::Bind (hr:%lx)\n", this,hr));
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   LookupProtocolClsIDFromReg
//
//  Synopsis:   finds a protocol handler class for a given URL
//
//  Arguments:  [pwzUrl] --
//              [pclsid] --
//
//  Returns:
//
//  History:    11-01-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT LookupProtocolClsIDFromReg(LPCTSTR pszUrl, CLSID *pclsid)
{
    TransDebugOut((DEB_PROT, "API _IN LookupProtocolClsIDFromReg (szUrl >%s< )\n", pszUrl));
    HRESULT hr = INET_E_UNKNOWN_PROTOCOL;
    DWORD dwType;
    TCHAR pszProt[MAX_URL_SIZE + 1];

    TransAssert((pszUrl && pclsid));

    if (pszUrl)
    {
        char szDelimiter = ':';

        lstrcpy(pszProt, pszUrl);

        LPSTR pszDel = StrChr(pszProt, szDelimiter);

        if (pszDel)
        {
            *pszDel = '\0';

            // fail if the protocol is "search" so we don't get call recursively.
            if (lstrcmpi(pszProt, SZMYPROTOCOL))
            {
                HKEY hProtocolKey = NULL;
                DWORD dwLen = 256;
                char szProtocolKey[256];

                lstrcpy(szProtocolKey, SZPROTOCOLROOT);
                lstrcat(szProtocolKey, pszProt);
    
                if (RegOpenKeyEx(HKEY_CLASSES_ROOT, szProtocolKey, 0, KEY_QUERY_VALUE, &hProtocolKey) == ERROR_SUCCESS)
                {
                    if (RegQueryValueEx(hProtocolKey, SZCLASS, NULL, &dwType, (LPBYTE)szProtocolKey, &dwLen) == ERROR_SUCCESS)
                    {
                        LPWSTR pwzClsId = DupA2W(szProtocolKey);
    
                        if (pwzClsId)
                        {
                            hr = CLSIDFromString(pwzClsId, pclsid);
                            TransDebugOut((DEB_PROT, "API FOUND LookupProtocolClsIDFromReg(hr:%lx, ClsId:%ws)\n", hr,pwzClsId));
                            delete pwzClsId;
                        }
                        else
                        {
                            hr = E_OUTOFMEMORY;
                        }
                    }
    
                    RegCloseKey(hProtocolKey);
                }
            }
        }
        else
        {
            // look up the registry
            hr = MK_E_SYNTAX;
        }
    }

    TransDebugOut((DEB_PROT, "API OUT LookupProtocolClsIDFromReg(hr:%lx)\n", hr));
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\search\selfreg.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       selfreg.cxx
//
//  Contents:   Taken from Office96
//              Source file for the common self registration code used by all the
//              sub projects of Sweeper project. They are
//              UrlMon
//              UrlMnPrx
//
//  Exports:    HrDllRegisterServer()
//              HrDllUnregisterServer()
//
//  Classes:
//
//  Functions:
//
//  History:    5-03-96   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------
#include <urlint.h>
#include "selfreg.hxx"

HINSTANCE g_hinstDll = NULL;
PFNLOADSTRING g_pfnLoadString = NULL;

//+---------------------------------------------------------------------------
//
//  Function:   GetDllFullPath
//
//  Synopsis:
//
//  Arguments:  [lpszExeName] --
//              [cch] --
//
//  Returns:
//
//  History:         95    OfficeXX                 created
//              5-03-96   JohannP (Johann Posch)   port urlmon
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL GetDllFullPath( LPSTR lpszExeName, DWORD cch )
{
    if ( NULL == g_hinstDll )
    {
        UrlMkAssert(( FALSE && "NULL hInst"));
        return FALSE;
    }

    *lpszExeName = NULL;

    if ( GetModuleFileName( g_hinstDll, lpszExeName, cch ) == 0)
    {
        UrlMkAssert(( FALSE && "GetModuleFileName Failed"));
        return FALSE;
    }

    return TRUE;
}


inline BOOL IsASeparator( char ch )
{
    return (ch == '\\' || ch == '/' || ch == ':');
}

//+---------------------------------------------------------------------------
//
//  Function:   ParseAFileName
//
//  Synopsis:
//
//  Arguments:  [szFileName] --
//              [piRetLen] --
//
//  Returns:
//
//  History:         95    OfficeXX                 created
//              5-03-96   JohannP (Johann Posch)   port urlmon
//
//  Notes:
//
//----------------------------------------------------------------------------
LPSTR ParseAFileName( LPSTR szFileName, int *piRetLen)
{
    LPSTR pszFile;

    // Start at the end of the filename.
    pszFile = szFileName + ( lstrlen(szFileName) - 1 );

    // Back up to a '\\' or beginning or something!! We just want a file
    // name!. Whatever comes first.
    while ( pszFile > szFileName && !IsASeparator(*pszFile ) )
        pszFile = CharPrev(szFileName, pszFile);

    if ( pszFile != szFileName )
        pszFile = CharNext(pszFile);

    if ( piRetLen )
        *piRetLen = lstrlen(pszFile);

    return pszFile;
}


//+---------------------------------------------------------------------------
//
//  Function:   FRegisterEntries
//
//  Synopsis:   FRegisterEntries: Register a group of reg entries off a base key.
//
//  Arguments:  [hkRoot] --
//              [rgEntries] --
//              [dwEntries] --
//              [pszPath] --
//              [pszBinderName] --
//
//  Returns:
//
//  History:         95    OfficeXX                 created
//              5-03-96   JohannP (Johann Posch)   port urlmon
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL FRegisterEntries(HKEY hkRoot, const REGENTRY rgEntries[],
                    DWORD dwEntries, char *pszPath, char *pszBinderName)
{
    HKEY    hkey = NULL;
    LONG    lRet;
    char    szValue[1024];
    char    szResString[1024];
    char    szKeyName[1024];
    BOOL    fRet = FALSE;
    int         i;

    for (i = 0; i < (int)dwEntries; i++)
    {
        // We work with a copy of the entry, since we might modify it
        REGENTRY reCurrentEntry = rgEntries[i];

        if (reCurrentEntry.iKeyType ==  KEYTYPE_RESID)
        {
            int cch;
            if (g_pfnLoadString == NULL)
                return FALSE;
            cch = g_pfnLoadString(g_hinstDll, (UINT)reCurrentEntry.pszKey, szKeyName,
                    sizeof(szKeyName));
            if (cch > 0 && cch <= 1024)
            {
                reCurrentEntry.pszKey = szKeyName;
            }
            else
            {
                UrlMkAssert(( FALSE && "LoadString Failed ( 1)"));
                continue;
            }
        }

        lRet = RegCreateKey(hkRoot, reCurrentEntry.pszKey, &hkey);

        if (lRet != ERROR_SUCCESS)
        {
            UrlMkAssert(( FALSE && "RegCreateKey Failed ( 1)"));
            continue;
        }

         // If the type is REG_RESID, then pbData holds the resource ID.  We
         // load the resource string, then modify our reCurrentEntry to point
         // to it.

        if (reCurrentEntry.dwType == REG_RESID)
        {
            int cch;
            if (g_pfnLoadString == NULL)
                return FALSE;

            cch = g_pfnLoadString(g_hinstDll, (UINT)reCurrentEntry.pbData, szResString,
                    sizeof(szResString));
            if (cch > 0 && cch <= 1024)
            {
                reCurrentEntry.dwType = REG_SZ;
                reCurrentEntry.pbData = (BYTE*) szResString;
            }
            else
            {
                UrlMkAssert(( FALSE && "LoadString Failed (2)"));
                reCurrentEntry.pbData = NULL;
            }
        }


        // Set the value if there is one
        if (reCurrentEntry.pbData != NULL || reCurrentEntry.dwType != REG_SZ)
        {
            switch (reCurrentEntry.dwType)
            {
                case REG_SZ:
                    // Replace the first %s with the path, and the second
                    // %s with the name of the binder app (may not do anything).
                    if (pszPath != NULL && pszBinderName != NULL)
                    {
                        wsprintf(szValue, (char*)reCurrentEntry.pbData, pszPath,
                            pszBinderName);

                        lRet = RegSetValueEx(hkey, reCurrentEntry.pszValueName, 0,
                            REG_SZ, (BYTE*)szValue, lstrlen(szValue)+1);
#if DBG == 1
                        if ( ERROR_SUCCESS != lRet )
                            UrlMkAssert(( FALSE && "RegSetValueEx Failed ( 1)"));
#endif
                    }
                    break;

                case REG_DWORD:
                    lRet = RegSetValueEx(hkey, reCurrentEntry.pszValueName, 0,
                        REG_DWORD,  (BYTE*)&reCurrentEntry.pbData, sizeof(DWORD));

#if DBG == 1
                    if ( ERROR_SUCCESS != lRet )
                        UrlMkAssert(( FALSE && "RegSetValueEx Failed (2)"));
#endif
                    break;

                default:
                    UrlMkAssert(( FALSE && "Unexpected reg entry type"));
                    // Unexpected type: ignore
                    break;
            }
        }

        // Close the subkey
        RegCloseKey(hkey);
        hkey = NULL;
    }

    fRet = TRUE;

    // Close the base key if it was open
    if (hkey)
        RegCloseKey(hkey);

    return fRet;
}


/*
 * FRegisterEntryGroups: Register several groups of reg entries.
 */
BOOL FRegisterEntryGroups(const REGENTRYGROUP *rgRegEntryGroups,
    char *pszPath, char *pszBinderName)
{
    BOOL fError = FALSE;
    int i;

    // Keep going even if we get some errors
    for (i=0; rgRegEntryGroups[i].hkRoot != NULL; i++)
    {
        if (!FRegisterEntries(rgRegEntryGroups[i].hkRoot, rgRegEntryGroups[i].rgEntries,
            rgRegEntryGroups[i].dwEntries,pszPath, pszBinderName))
        {
            fError = TRUE;
        }
    }

    return !fError;
}

//+---------------------------------------------------------------------------
//
//  Function:   FDeleteEntries
//
//  Synopsis:   Delete a group of reg entries off a base key.
//
//  Arguments:  [hkRoot] --
//              [rgEntries] --
//              [dwEntries] --
//
//  Returns:
//
//  History:         95    OfficeXX                 created
//              5-03-96   JohannP (Johann Posch)   port urlmon
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL FDeleteEntries(HKEY hkRoot, const REGENTRY rgEntries[], DWORD dwEntries)
{
    LONG    lRet;
    int         i;
    char    szKeyName[1024];
    PSTR    pKey;

    // Delete in reverse order, to kill children before parent
    for (i = (int)dwEntries - 1; i >= 0; i--)
    {
        pKey = NULL;

        if (rgEntries[i].iKeyType ==  KEYTYPE_RESID)
        {
            int cch;
            cch = g_pfnLoadString(g_hinstDll, (UINT)rgEntries[i].pszKey, szKeyName,
                    sizeof(szKeyName));
            if (cch > 0 && cch <= 1024)
            {
                pKey = szKeyName;
            }
        else
            {
                UrlMkAssert(( FALSE && "LoadString Failed (FDeleteEntries)"));
                continue;
            }
        }
        else
        {
            if ( KEYTYPE_STRING != rgEntries[i].iKeyType )
            {
                UrlMkAssert(( FALSE && "Unknown Key Type"));
                continue;
            }
            pKey = rgEntries[i].pszKey;
        }

        if (pKey != NULL)
        {
            // Delete the current key if it has no subkeys.
            // Ignore the return value.
            lRet = RegDeleteKey(hkRoot, pKey);
        }
    }

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Function:   FDeleteEntryGroups
//
//  Synopsis:   Delete the base keys of all the given groups.

//
//  Arguments:  [rgRegEntryGroups] --
//
//  Returns:
//
//  History:         95    OfficeXX                 created
//              5-03-96   JohannP (Johann Posch)   port urlmon
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL FDeleteEntryGroups(const REGENTRYGROUP *rgRegEntryGroups)
{
    BOOL fError = FALSE;

    // Keep going even if we get some errors
    for (int i=0; rgRegEntryGroups[i].hkRoot != NULL; i++)
    {
        if (!FDeleteEntries(rgRegEntryGroups[i].hkRoot,
            rgRegEntryGroups[i].rgEntries,
            rgRegEntryGroups[i].dwEntries))
        {
            fError = TRUE;
        }
    }

    return !fError;
}


#ifdef NOT_USED
/*
 * FDeleteSubtree - Delete given key and all subkeys
 */
BOOL FDeleteSubtree(HKEY hkRoot, char *pszKey)
{
    HKEY        hkey = NULL;
    LONG        lRet;
    char        szSubKey[MAX_PATH];

    lRet = RegOpenKey(hkRoot, pszKey, &hkey);
    if (lRet != ERROR_SUCCESS)
        goto End;

    // remove all subkeys
    for (;;)
{
        lRet = RegEnumKey(hkey, 0, szSubKey, sizeof szSubKey);

        if (lRet == ERROR_NO_MORE_ITEMS)
            break;

        if (lRet != ERROR_SUCCESS)
            goto End;

        if (!FDeleteSubtree(hkey, szSubKey))
            goto End;
}

End:
    if (hkey != NULL)
        RegCloseKey (hkey);

    lRet = RegDeleteKey(hkRoot, pszKey);

    return (lRet == ERROR_SUCCESS);
}
#endif // NOT_USED



//+---------------------------------------------------------------------------
//
//  Function:   HrDllRegisterServer
//
//  Synopsis:   registers an entrygroup
//
//  Arguments:  [HINSTANCE] --
//              [hinstDll] --
//              [pfnLoadString] --
//              [pszAppName] --
//
//  Returns:
//
//  History:         95    OfficeXX                 created
//              5-03-96   JohannP (Johann Posch)   port urlmon
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT HrDllRegisterServer(const REGENTRYGROUP *rgRegEntryGroups,HINSTANCE hinstDll,
                            PFNLOADSTRING pfnLoadString, char *pszAppName)
{
    // REVIEW: for Windows dll, do we want to register full path?
    BOOL    fRet = TRUE;
    char    szFullPath[MAX_PATH];
    char    szFileName[MAX_PATH];
    char    *pszFileName;

    g_hinstDll = hinstDll;
    if ((g_pfnLoadString = pfnLoadString) == NULL)
        // set the pointer to windows LoadString() api
        g_pfnLoadString = (PFNLOADSTRING) LoadString;

    if (!GetDllFullPath(szFullPath, MAX_PATH))
        return E_FAIL;

    pszFileName = ParseAFileName(szFullPath, NULL);

    if (pszAppName != NULL)
        lstrcpy(szFileName, pszAppName);
    else
        lstrcpy(szFileName, pszFileName);

    // Terminate the path at the file name
    *pszFileName = '\0';
    fRet = FRegisterEntryGroups(rgRegEntryGroups, szFullPath, szFileName);

    g_hinstDll = NULL;
    g_pfnLoadString = NULL;
    return fRet ? NOERROR : E_FAIL;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrDllUnregisterServer
//
//  Synopsis:   unregisters an entrygroup
//
//  Arguments:  [HINSTANCE] --
//              [hinstDll] --
//              [pfnLoadString] --
//
//  Returns:
//
//  History:         95    OfficeXX                 created
//              5-03-96   JohannP (Johann Posch)   port urlmon
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT HrDllUnregisterServer(const REGENTRYGROUP *rgRegEntryGroups,HINSTANCE hinstDll, PFNLOADSTRING pfnLoadString)
{
    g_hinstDll = hinstDll;
    if ((g_pfnLoadString = pfnLoadString) == NULL)
        // set the pointer to windows LoadString() api
        g_pfnLoadString = (PFNLOADSTRING) LoadString;

    FDeleteEntryGroups(rgRegEntryGroups);

    g_hinstDll = NULL;
    g_pfnLoadString = NULL;

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\search\urlcf.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       urlcf.cxx
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    12-22-95   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------
#include <urlint.h>
#include <stdio.h>
#include "urlcf.hxx"

extern GUID CLSID_ResProtocol;


//+---------------------------------------------------------------------------
//
//  Method:     CUrlClsFact::Create
//
//  Synopsis:
//
//  Arguments:  [clsid] --
//              [ppCF] --
//
//  Returns:
//
//  History:    12-22-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CUrlClsFact::Create(REFCLSID clsid, CUrlClsFact **ppCF)
{
    UrlMkDebugOut((DEB_URLMON, "NULL _IN CUrlClsFact::Create\n"));
    HRESULT hr = NOERROR;
    CUrlClsFact * pCF =  NULL;

    if (    (clsid == CLSID_ResProtocol) )
    {
        pCF = (CUrlClsFact *) new CUrlClsFact(clsid);
    }

    if (pCF == NULL)
    {
        UrlMkAssert((pCF));
        hr = E_OUTOFMEMORY;
    }
    else
    {
        *ppCF = pCF;
    }

    UrlMkDebugOut((DEB_URLMON, "%p OUT CUrlClsFact::Create (hr:%lx\n", pCF,hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CUrlClsFact::CUrlClsFact
//
//  Synopsis:   constructor
//
//  Arguments:  [clsid] --
//
//  Returns:
//
//  History:    12-22-95   JohannP (Johann Posch)   Created
//
//  Notes:      we need to keep a refcount on the dll if for each object given to
//              outside, including ClassFactories.
//              The corresponding DllRelease is in the destructor
//
//----------------------------------------------------------------------------
CUrlClsFact::CUrlClsFact(REFCLSID clsid) : _CRefs(), _CLocks(0)
{
    _ClsID =  clsid;
    DllAddRef();
}

//+---------------------------------------------------------------------------
//
//  Method:     CUrlClsFact::~CUrlClsFact
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    12-22-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
CUrlClsFact::~CUrlClsFact()
{
    DllRelease();
}

//+---------------------------------------------------------------------------
//
//  Method:     CUrlClsFact::CreateInstance
//
//  Synopsis:   creates an instance of an Explode Object
//
//  Arguments:  [pUnkOuter] -- controlling unknown (must be NULL)
//              [riid] --      id of desired interface
//              [ppv] --       pointer to receive the interface
//
//  Returns:
//
//  History:    12-22-95   JohannP (Johann Posch)   Created
//
//  Notes:      S_OK - success
//              CLASS_E_NOAGGREATION - the caller tried to aggregate
//              CLASS_E_CLASSNOTAVAILABLE - couldn't initialize the class
//              E_OUTOFMEMORY - not enough memory to instantiate class
//
//----------------------------------------------------------------------------
STDMETHODIMP CUrlClsFact::CreateInstance(LPUNKNOWN pUnkOuter, REFIID riid, LPVOID * ppv)
{
    UrlMkDebugOut((DEB_URLMON, "%p _IN CUrlClsFact::CreateInstance\n", this));
    HRESULT hr = NOERROR;
    // Class factory init time, the pointer to the creation function of
    // the object is given.  Use that to create the object

    //DumpIID(riid);
    //DumpIID(_rClsID);

    if (riid == IID_IClassFactory)
    {
        *ppv = (IClassFactory *)this;
        AddRef();
    }
    else if (_ClsID == CLSID_ResProtocol)
    {

        hr = CreateAPP(_ClsID, pUnkOuter, riid, (IUnknown **)ppv);

    }

    UrlMkDebugOut((DEB_URLMON, "%p OUT CUrlClsFact::CreateInstance (hr:%lx)\n", this,hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CUrlClsFact::LockServer
//
//  Synopsis:   locks the server, preventing it from being unloaded
//
//  Arguments:  [fLock] -- TRUE to lock, FALSE to unlock
//
//  Returns:
//
//  History:    12-22-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CUrlClsFact::LockServer(BOOL fLock)
{
    UrlMkDebugOut((DEB_URLMON, "%p _IN CUrlClsFact::LockServer\n", this));
    HRESULT hr = NOERROR;
    if (fLock)
    {
        if (++_CLocks == 1)
        {
            DllAddRef();
        }
    }
    else
    {
        UrlMkAssert((_CLocks > 0));
        if (_CLocks > 0)
        {
            if (--_CLocks == 0)
            {
                DllRelease();
            }
        }
    }

    UrlMkDebugOut((DEB_URLMON, "%p OUT CUrlClsFact::LockServer (hr:%lx)\n", this,hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CUrlClsFact::QueryInterface
//
//  Synopsis:
//
//  Arguments:  [riid] --
//              [ppvObj] --
//
//  Returns:
//
//  History:    12-22-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CUrlClsFact::QueryInterface(REFIID riid, void **ppvObj)
{
    VDATEPTROUT(ppvObj, void *);
    HRESULT hr = NOERROR;
    UrlMkDebugOut((DEB_URLMON, "%p _IN CUrlClsFact::QueryInterface\n", this));

    if (   riid == IID_IUnknown
        || riid == IID_IClassFactory)
    {
        *ppvObj = this;
    }
    else
    {
        *ppvObj = NULL;
        hr = E_NOINTERFACE;
    }
    if (hr == NOERROR)
    {
        AddRef();
    }

    UrlMkDebugOut((DEB_URLMON, "%p OUT CUrlClsFact::QueryInterface (hr:%lx\n", this,hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   CUrlClsFact::AddRef
//
//  Synopsis:
//
//  Arguments:  [ULONG] --
//
//  Returns:
//
//  History:    12-22-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CUrlClsFact::AddRef(void)
{
    UrlMkDebugOut((DEB_URLMON, "%p _IN CUrlClsFact::AddRef\n", this));

    LONG lRet = ++_CRefs;

    UrlMkDebugOut((DEB_URLMON, "%p OUT CUrlClsFact::AddRef (cRefs:%ld)\n", this,lRet));
    return lRet;
}

//+---------------------------------------------------------------------------
//
//  Function:   CUrlClsFact::Release
//
//  Synopsis:
//
//  Arguments:  [ULONG] --
//
//  Returns:
//
//  History:    12-22-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CUrlClsFact::Release(void)
{
    UrlMkDebugOut((DEB_URLMON, "%p _IN CUrlClsFact::Release\n", this));

    LONG lRet = --_CRefs;

    if (_CRefs == 0)
    {
        delete this;
    }

    UrlMkDebugOut((DEB_URLMON, "%p OUT CUrlClsFact::Release (cRefs:%ld)\n", this,lRet));
    return lRet;
}

#if DBG==1
HRESULT DumpIID(REFIID riid)
{

    HRESULT hr;
    LPOLESTR pszStr = NULL;
    hr = StringFromCLSID(riid, &pszStr);
    UrlMkDebugOut((DEB_BINDING, "API >>> DumpIID (riid:%ws) \n", pszStr));

    if (pszStr)
    {
        delete pszStr;
    }
    return hr;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\stg\casynclb.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       CASYNCLB.CXX
//
//  Contents:
//
//  Classes:    Implements the IAsyncLockBytes class.
//
//  Functions:
//
//  History:    12-13-95    JoeS (Joe Souza)    Created
//
//----------------------------------------------------------------------------
#include <urlint.h>
#include <urlmon.hxx>
#include "casynclb.hxx"

CAsyncLockBytes::CAsyncLockBytes(ILockBytes *pLB) : _CRefs()
{
    _cbFillOffset.QuadPart = 0;
    _fFillDone = FALSE;
    _pLBchain = pLB;
}

STDMETHODIMP CAsyncLockBytes::QueryInterface
    (REFIID riid, LPVOID FAR* ppvObj)
{
    VDATETHIS(this);
    UrlMkDebugOut((DEB_ILOCKBYTES, "%p IN CAsyncLockBytes::QueryInterface\n", this));

    HRESULT hresult = NOERROR;

    if (   IsEqualIID(riid, IID_IUnknown)
        || IsEqualIID(riid, IID_ILockBytes)
       )
    {
        *ppvObj = (ILockBytes *)this;
    }
    else if (IsEqualIID(riid, IID_IFillLockBytes))
    {
        *ppvObj = (IFillLockBytes *)this;
    }
    else
    {
        *ppvObj = NULL;
        hresult = E_NOINTERFACE;
    }

    if (*ppvObj)
    {
        AddRef();

        if (_pLBchain)
            _pLBchain->AddRef();
    }

    UrlMkDebugOut((DEB_ILOCKBYTES, "%p OUT CAsyncLockBytes::QueryInterface\n", this));
    return hresult;
}

STDMETHODIMP_(ULONG) CAsyncLockBytes::AddRef(void)
{
    VDATETHIS(this);
    UrlMkDebugOut((DEB_ILOCKBYTES, "%p IN CAsyncLockBytes::AddRef\n", this));

    LONG lRet = ++_CRefs;

    if (_pLBchain)
        _pLBchain->AddRef();

    UrlMkDebugOut((DEB_ILOCKBYTES, "%p OUT CAsyncLockBytes::AddRef\n", this));
    return lRet;
}

STDMETHODIMP_(ULONG) CAsyncLockBytes::Release(void)
{
    VDATETHIS(this);
    UrlMkDebugOut((DEB_ILOCKBYTES, "%p IN CAsyncLockBytes::Release\n", this));
    UrlMkAssert((_CRefs > 0));

    LONG lRet = --_CRefs;

    if (_pLBchain)
        _pLBchain->Release();

    if (_CRefs == 0)
    {
        delete this;
    }

    UrlMkDebugOut((DEB_ILOCKBYTES, "%p OUT CAsyncLockBytes::Release\n", this));
    return lRet;
}

HRESULT CAsyncLockBytes::ReadAt(THIS_ ULARGE_INTEGER ulOffset, VOID HUGEP *pv,
    ULONG cb, ULONG FAR *pcbRead)
{
    HRESULT hresult = E_FAIL;

    UrlMkDebugOut((DEB_ILOCKBYTES, "%p IN CAsyncLockBytes::ReadAt\n", this));

    if (_pLBchain)
    {
#if 0
        while (TRUE)
        {
#endif
            hresult = _pLBchain->ReadAt(ulOffset, pv, cb, pcbRead);
#if 0
            if (hresult != NOERROR)
                break;

            if (*pcbRead == cb || _fFillDone)
                break;

            hresult = BlockOnIFillLockBytes(this);
            if (hresult != S_OK)
                break;
        }
#endif
    }

    UrlMkDebugOut((DEB_ILOCKBYTES, "%p OUT CAsyncLockBytes::ReadAt\n", this));
    return(hresult);
}

HRESULT CAsyncLockBytes::WriteAt(THIS_ ULARGE_INTEGER ulOffset, VOID const HUGEP *pv,
    ULONG cb, ULONG FAR *pcbWritten)
{
    HRESULT hresult = E_FAIL;

    UrlMkDebugOut((DEB_ILOCKBYTES, "%p IN CAsyncLockBytes::WriteAt\n", this));

    if (_pLBchain)
        hresult = _pLBchain->WriteAt(ulOffset, pv, cb, pcbWritten);

    UrlMkDebugOut((DEB_ILOCKBYTES, "%p OUT CAsyncLockBytes::WriteAt\n", this));
    return(hresult);
}

HRESULT CAsyncLockBytes::Flush()
{
    HRESULT hresult = E_FAIL;

    UrlMkDebugOut((DEB_ILOCKBYTES, "%p IN CAsyncLockBytes::Flush\n", this));

    if (_pLBchain)
        hresult = _pLBchain->Flush();

    UrlMkDebugOut((DEB_ILOCKBYTES, "%p OUT CAsyncLockBytes::Flush\n", this));
    return(hresult);
}

HRESULT CAsyncLockBytes::SetSize(THIS_ ULARGE_INTEGER cb)
{
    HRESULT hresult = E_FAIL;

    UrlMkDebugOut((DEB_ILOCKBYTES, "%p IN CAsyncLockBytes::SetSize\n", this));

    if (_pLBchain)
        hresult = _pLBchain->SetSize(cb);

    UrlMkDebugOut((DEB_ILOCKBYTES, "%p OUT CAsyncLockBytes::SetSize\n", this));
    return(hresult);
}

HRESULT CAsyncLockBytes::LockRegion(THIS_ ULARGE_INTEGER libOffset,
    ULARGE_INTEGER cb, DWORD dwLockType)
{
    HRESULT hresult = E_FAIL;

    UrlMkDebugOut((DEB_ILOCKBYTES, "%p IN CAsyncLockBytes::LockRegion\n", this));

    if (_pLBchain)
        hresult = _pLBchain->LockRegion(libOffset, cb, dwLockType);

    UrlMkDebugOut((DEB_ILOCKBYTES, "%p OUT CAsyncLockBytes::LockRegion\n", this));
    return(hresult);
}

HRESULT CAsyncLockBytes::UnlockRegion(THIS_ ULARGE_INTEGER libOffset,
    ULARGE_INTEGER cb, DWORD dwLockType)
{
    HRESULT hresult = E_FAIL;

    UrlMkDebugOut((DEB_ILOCKBYTES, "%p IN CAsyncLockBytes::UnlockRegion\n", this));

    if (_pLBchain)
        hresult = _pLBchain->UnlockRegion(libOffset, cb, dwLockType);

    UrlMkDebugOut((DEB_ILOCKBYTES, "%p OUT CAsyncLockBytes::UnlockRegion\n", this));
    return(hresult);
}

HRESULT CAsyncLockBytes::Stat(THIS_ STATSTG FAR *pStatStg, DWORD grfStatFlag)
{
    HRESULT hresult = E_FAIL;

    UrlMkDebugOut((DEB_ILOCKBYTES, "%p IN CAsyncLockBytes::Stat\n", this));

    if (_pLBchain)
        hresult = _pLBchain->Stat(pStatStg, grfStatFlag);

    UrlMkDebugOut((DEB_ILOCKBYTES, "%p OUT CAsyncLockBytes::Stat\n", this));
    return(hresult);
}

HRESULT CAsyncLockBytes::FillAppend(void const *pv, ULONG cb, ULONG *pcbWritten)
{
    HRESULT hresult = E_FAIL;

    UrlMkDebugOut((DEB_ILOCKBYTES, "%p IN CAsyncLockBytes::FillAppend\n", this));

    if (!_fFillDone)
    {
        hresult = WriteAt(_cbFillOffset, pv, cb, pcbWritten);
        _cbFillOffset.QuadPart += *pcbWritten;
    }

    UrlMkDebugOut((DEB_ILOCKBYTES, "%p OUT CAsyncLockBytes::FillAppend\n", this));
    return(hresult);
}

HRESULT CAsyncLockBytes::Terminate(BOOL bCanceled)
{
    UrlMkDebugOut((DEB_ILOCKBYTES, "%p IN CAsyncLockBytes::Terminate\n", this));

    _fFillDone = TRUE;

    UrlMkDebugOut((DEB_ILOCKBYTES, "%p OUT CAsyncLockBytes::Terminate\n", this));
    return(NOERROR);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\stg\cstream.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       CSTREAM.CXX
//
//  Contents:
//
//  Classes:    Implements the IStream class.
//
//  Functions:
//
//  History:    12-01-95    JoeS (Joe Souza)    Created
//
//----------------------------------------------------------------------------
#include <urlint.h>
#include <urlmon.hxx>
#include "cstream.hxx"

CStream::CStream(IStream *pStr) : _CRefs()
{
    _pStream = pStr;
}

STDMETHODIMP CStream::QueryInterface
    (REFIID riid, LPVOID FAR* ppvObj)
{
    VDATETHIS(this);
    UrlMkDebugOut((DEB_ISTREAM, "%p IN CStream::QueryInterface\n", this));

    HRESULT hresult = NOERROR;

    if (   IsEqualIID(riid, IID_IUnknown)
        || IsEqualIID(riid, IID_IStream)
       )
    {
        *ppvObj = this;
        AddRef();
    }
    else
    {
        *ppvObj = NULL;
        hresult = E_NOINTERFACE;
    }

    UrlMkDebugOut((DEB_ISTREAM, "%p OUT CStream::QueryInterface\n", this));
    return hresult;
}

STDMETHODIMP_(ULONG) CStream::AddRef(void)
{
    VDATETHIS(this);
    UrlMkDebugOut((DEB_ISTREAM, "%p IN CStream::AddRef\n", this));

    LONG lRet = ++_CRefs;

    if (_pStream)
        _pStream->AddRef();

    UrlMkDebugOut((DEB_ISTREAM, "%p OUT CStream::AddRef\n", this));
    return lRet;
}

STDMETHODIMP_(ULONG) CStream::Release(void)
{
    VDATETHIS(this);
    UrlMkDebugOut((DEB_ISTREAM, "%p IN CStream::Release\n", this));
    UrlMkAssert((_CRefs > 0));

    LONG lRet = --_CRefs;

    if (_pStream)
        _pStream->Release();

    if (_CRefs == 0)
    {
        delete this;
    }

    UrlMkDebugOut((DEB_ISTREAM, "%p OUT CStream::Release\n", this));
    return lRet;
}

HRESULT CStream::Read(THIS_ VOID HUGEP *pv, ULONG cb, ULONG FAR *pcbRead)
{
    HRESULT hresult = E_FAIL;
    ULONG   readcount;

    UrlMkDebugOut((DEB_ISTREAM, "%p IN CStream::Read\n", this));

    if (_pStream)
    {
#if 0
        while (TRUE)
        {
#endif
            hresult = _pStream->Read(pv, cb, &readcount);
            if (pcbRead)
                *pcbRead = readcount;

#if 0
            if (hresult != NOERROR)
                break;

            if (readcount == cb)
                break;

            hresult = BlockOnIFillLockBytes(this);  // BUGBUG:
            if (hresult != S_OK)
                break;
        }
#endif
    }

    UrlMkDebugOut((DEB_ISTREAM, "%p OUT CStream::Read\n", this));
    return(hresult);
}

HRESULT CStream::Write(THIS_ VOID const HUGEP *pv, ULONG cb,
            ULONG FAR *pcbWritten)
{
    HRESULT hresult = E_FAIL;

    UrlMkDebugOut((DEB_ISTREAM, "%p IN CStream::Write\n", this));

    if (_pStream)
        hresult = _pStream->Write(pv, cb, pcbWritten);

    UrlMkDebugOut((DEB_ISTREAM, "%p OUT CStream::Write\n", this));
    return(hresult);
}

HRESULT CStream::Seek(THIS_ LARGE_INTEGER dlibMove, DWORD dwOrigin,
            ULARGE_INTEGER FAR *plibNewPosition)
{
    HRESULT hresult = E_FAIL;

    UrlMkDebugOut((DEB_ISTREAM, "%p IN CStream::Seek\n", this));

    if (_pStream)
        hresult = _pStream->Seek(dlibMove, dwOrigin, plibNewPosition);

    UrlMkDebugOut((DEB_ISTREAM, "%p OUT CStream::Seek\n", this));
    return(hresult);
}

HRESULT CStream::SetSize(THIS_ ULARGE_INTEGER libNewSize)
{
    HRESULT hresult = E_FAIL;

    UrlMkDebugOut((DEB_ISTREAM, "%p IN CStream::SetSize\n", this));

    if (_pStream)
        hresult = _pStream->SetSize(libNewSize);

    UrlMkDebugOut((DEB_ISTREAM, "%p OUT CStream::SetSize\n", this));
    return(hresult);
}

HRESULT CStream::CopyTo(THIS_ LPSTREAM pStm, ULARGE_INTEGER cb,
            ULARGE_INTEGER FAR *pcbRead, ULARGE_INTEGER FAR *pcbWritten)
{
    HRESULT hresult = E_FAIL;

    UrlMkDebugOut((DEB_ISTREAM, "%p IN CStream::CopyTo\n", this));

    if (_pStream)
        hresult = _pStream->CopyTo(pStm, cb, pcbRead, pcbWritten);

    UrlMkDebugOut((DEB_ISTREAM, "%p OUT CStream::CopyTo\n", this));
    return(hresult);
}

HRESULT CStream::Commit(THIS_ DWORD dwCommitFlags)
{
    HRESULT hresult = E_FAIL;

    UrlMkDebugOut((DEB_ISTREAM, "%p IN CStream::Commit\n", this));

    if (_pStream)
        hresult = _pStream->Commit(dwCommitFlags);

    UrlMkDebugOut((DEB_ISTREAM, "%p OUT CStream::Commit\n", this));
    return(hresult);
}

HRESULT CStream::Revert(THIS)
{
    HRESULT hresult = E_FAIL;

    UrlMkDebugOut((DEB_ISTREAM, "%p IN CStream::Revert\n", this));

    if (_pStream)
        hresult = _pStream->Revert();

    UrlMkDebugOut((DEB_ISTREAM, "%p OUT CStream::Revert\n", this));
    return(hresult);
}

HRESULT CStream::LockRegion(THIS_ ULARGE_INTEGER libOffset,
            ULARGE_INTEGER cb, DWORD dwLockType)
{
    HRESULT hresult = E_FAIL;

    UrlMkDebugOut((DEB_ISTREAM, "%p IN CStream::LockRegion\n", this));

    if (_pStream)
        hresult = _pStream->LockRegion(libOffset, cb, dwLockType);

    UrlMkDebugOut((DEB_ISTREAM, "%p OUT CStream::LockRegion\n", this));
    return(hresult);
}

HRESULT CStream::UnlockRegion(THIS_ ULARGE_INTEGER libOffset,
            ULARGE_INTEGER cb, DWORD dwLockType)
{
    HRESULT hresult = E_FAIL;

    UrlMkDebugOut((DEB_ISTREAM, "%p IN CStream::UnlockRegion\n", this));

    if (_pStream)
        hresult = _pStream->UnlockRegion(libOffset, cb, dwLockType);

    UrlMkDebugOut((DEB_ISTREAM, "%p OUT CStream::UnlockRegion\n", this));
    return(hresult);
}

HRESULT CStream::Stat(THIS_ STATSTG FAR *pStatStg, DWORD grfStatFlag)
{
    HRESULT hresult = E_FAIL;

    UrlMkDebugOut((DEB_ISTREAM, "%p IN CStream::Stat\n", this));

    if (_pStream)
        hresult = _pStream->Stat(pStatStg, grfStatFlag);

    UrlMkDebugOut((DEB_ISTREAM, "%p OUT CStream::Stat\n", this));
    return(hresult);
}

HRESULT CStream::Clone(THIS_ LPSTREAM FAR *ppStm)
{
    HRESULT hresult = E_FAIL;
    IStream *pStr, *pStrTop;

    UrlMkDebugOut((DEB_ISTREAM, "%p IN CStream::Clone\n", this));

    *ppStm = NULL;

    if (_pStream)
    {
        hresult = _pStream->Clone(&pStr);
        if (hresult == S_OK)
        {
            if (!(pStrTop = new CStream(pStr)))
            {
                // BUGBUG: Delete pStr here!

                hresult = E_OUTOFMEMORY;
                goto CloneExit;
            }

            *ppStm = pStrTop;
        }
    }

CloneExit:

    UrlMkDebugOut((DEB_ISTREAM, "%p OUT CStream::Clone\n", this));
    return(hresult);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\stg\clockbyt.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       CLOCKBYT.CXX
//
//  Contents:
//
//  Classes:    Implements the ILockBytes base class.
//
//  Functions:
//
//  History:    12-01-95    JoeS (Joe Souza)    Created
//
//----------------------------------------------------------------------------
#include <urlint.h>
#include <urlmon.hxx>
#include "clockbyt.hxx"

CLockBytes::CLockBytes() : _CRefs()
{
}

STDMETHODIMP CLockBytes::QueryInterface
    (REFIID riid, LPVOID FAR* ppvObj)
{
    VDATETHIS(this);
    UrlMkDebugOut((DEB_ILOCKBYTES, "%p IN CLockBytes::QueryInterface\n", this));

    HRESULT hresult = NOERROR;

    if (   IsEqualIID(riid, IID_IUnknown)
        || IsEqualIID(riid, IID_ILockBytes)
       )
    {
        *ppvObj = this;
    }
    else
    {
        *ppvObj = NULL;
        hresult = E_NOINTERFACE;
    }

    if (*ppvObj)
        AddRef();

    UrlMkDebugOut((DEB_ILOCKBYTES, "%p OUT CLockBytes::QueryInterface\n", this));
    return hresult;
}

STDMETHODIMP_(ULONG) CLockBytes::AddRef(void)
{
    VDATETHIS(this);
    UrlMkDebugOut((DEB_ILOCKBYTES, "%p IN CLockBytes::AddRef\n", this));

    LONG lRet = ++_CRefs;

    UrlMkDebugOut((DEB_ILOCKBYTES, "%p OUT CLockBytes::AddRef\n", this));
    return lRet;
}

HRESULT CLockBytes::Flush()
{
    UrlMkDebugOut((DEB_ILOCKBYTES, "%p CLockBytes::Flush (NoOp)\n", this));
    return(NOERROR);
}

HRESULT CLockBytes::LockRegion(THIS_ ULARGE_INTEGER libOffset, ULARGE_INTEGER cb,
    DWORD dwLockType)
{
    UrlMkDebugOut((DEB_ILOCKBYTES, "%p CLockBytes::LockRegion (NoOp)\n", this));
    return(NOERROR);
}

HRESULT CLockBytes::UnlockRegion(THIS_ ULARGE_INTEGER libOffset,
    ULARGE_INTEGER cb, DWORD dwLockType)
{
    UrlMkDebugOut((DEB_ILOCKBYTES, "%p CLockBytes::UnlockRegion (NoOp)\n", this));
    return(NOERROR);
}

HRESULT CLockBytes::Stat(THIS_ STATSTG FAR *pStatStg, DWORD grfStatFlag)
{
    UrlMkDebugOut((DEB_ILOCKBYTES, "%p CLockBytes::Stat (NoOp)\n", this));
    return(STG_E_UNKNOWN);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\stg\filelb.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       FILELB.CXX
//
//  Contents:
//
//  Classes:    Implements the file-based ILockBytes class.
//
//  Functions:
//
//  History:    12-13-95    JoeS (Joe Souza)    Created
//
//----------------------------------------------------------------------------
#include <urlint.h>
#include <urlmon.hxx>
#include "clockbyt.hxx"
#include "filelb.hxx"

FileLockBytes::FileLockBytes(HANDLE filehandle) : _CRefs()
{
    _hFileHandle = filehandle;
}

STDMETHODIMP_(ULONG) FileLockBytes::Release(void)
{
    VDATETHIS(this);
    UrlMkDebugOut((DEB_ILOCKBYTES, "%p IN FileLockBytes::Release\n", this));
    UrlMkAssert((_CRefs > 0));

    LONG lRet = --_CRefs;

    if (_CRefs == 0)
    {
        if (_hFileHandle != INVALID_HANDLE_VALUE)
            CloseHandle(_hFileHandle);

        delete this;
    }

    UrlMkDebugOut((DEB_ILOCKBYTES, "%p OUT FileLockBytes::Release\n", this));
    return lRet;
}

HRESULT FileLockBytes::ReadAt(THIS_ ULARGE_INTEGER ulOffset, VOID HUGEP *pv,
    ULONG cb, ULONG FAR *pcbRead)
{
    HRESULT hresult = E_FAIL;

    UrlMkDebugOut((DEB_ILOCKBYTES, "%p IN FileLockBytes::ReadAt\n", this));

    *pcbRead = 0;

    if (!cb)
        goto ReadAtExit;

    if (_hFileHandle == INVALID_HANDLE_VALUE)
        goto ReadAtExit;

    hresult = seekfile(ulOffset);
    if (hresult != NOERROR)
        goto ReadAtExit;

    if (!ReadFile(_hFileHandle, pv, cb, pcbRead, NULL))
    {
        if (GetLastError() == ERROR_LOCK_VIOLATION)
            hresult = STG_E_ACCESSDENIED;
        else
            hresult = E_FAIL;
    }

ReadAtExit:

    UrlMkDebugOut((DEB_ILOCKBYTES, "%p OUT FileLockBytes::ReadAt\n", this));
    return(hresult);
}

HRESULT FileLockBytes::WriteAt(THIS_ ULARGE_INTEGER ulOffset, VOID const HUGEP *pv,
    ULONG cb, ULONG FAR *pcbWritten)
{
    HRESULT hresult = E_FAIL;

    UrlMkDebugOut((DEB_ILOCKBYTES, "%p IN FileLockBytes::WriteAt\n", this));

    *pcbWritten = 0;

    if (!cb)
        goto WriteAtExit;

    if (_hFileHandle == INVALID_HANDLE_VALUE)
        goto WriteAtExit;

    hresult = seekfile(ulOffset);
    if (hresult != NOERROR)
        goto WriteAtExit;

    if (!WriteFile(_hFileHandle, pv, cb, pcbWritten, NULL))
    {
        if (GetLastError() == ERROR_LOCK_VIOLATION)
            hresult = STG_E_ACCESSDENIED;
        else
            hresult = E_FAIL;
    }

WriteAtExit:

    UrlMkDebugOut((DEB_ILOCKBYTES, "%p OUT FileLockBytes::WriteAt\n", this));
    return(hresult);
}

HRESULT FileLockBytes::Flush()
{
    HRESULT hresult = E_FAIL;

    UrlMkDebugOut((DEB_ILOCKBYTES, "%p IN FileLockBytes::Flush\n", this));

    if (_hFileHandle != INVALID_HANDLE_VALUE)
    {
        if (FlushFileBuffers(_hFileHandle))
            hresult = NOERROR;
    }

    UrlMkDebugOut((DEB_ILOCKBYTES, "%p OUT FileLockBytes::Flush\n", this));
    return(hresult);
}

HRESULT FileLockBytes::SetSize(THIS_ ULARGE_INTEGER cb)
{
    HRESULT hresult = E_FAIL;

    UrlMkDebugOut((DEB_ILOCKBYTES, "%p IN FileLockBytes::SetSize\n", this));

    if (_hFileHandle == INVALID_HANDLE_VALUE)
        goto SetSizeExit;

    hresult = seekfile(cb);
    if (hresult != NOERROR)
        goto SetSizeExit;

    if (SetEndOfFile(_hFileHandle))
        hresult = NOERROR;

SetSizeExit:

    UrlMkDebugOut((DEB_ILOCKBYTES, "%p OUT FileLockBytes::SetSize\n", this));
    return(hresult);
}

HRESULT FileLockBytes::LockRegion(THIS_ ULARGE_INTEGER libOffset,
    ULARGE_INTEGER cb, DWORD dwLockType)
{
    HRESULT hresult = NOERROR;
    DWORD   offslow, offshigh, lenlow, lenhigh;

    UrlMkDebugOut((DEB_ILOCKBYTES, "%p IN FileLockBytes::LockRegion\n", this));

    if (_hFileHandle == INVALID_HANDLE_VALUE)
    {
        hresult = E_FAIL;
        goto LockRegionExit;
    }

    offshigh = *(DWORD *)(&libOffset.QuadPart + sizeof(ULONG));
    offslow = *(DWORD *)(&libOffset.QuadPart);

    lenhigh = *(DWORD *)(&cb.QuadPart + sizeof(ULONG));
    lenlow = *(DWORD *)(&cb.QuadPart);

    if (!LockFile(_hFileHandle, offslow, offshigh, lenlow, lenhigh))
    {
        if (GetLastError() == ERROR_LOCK_FAILED)
            hresult = STG_E_LOCKVIOLATION;
        else
            hresult = E_FAIL;
    }

LockRegionExit:

    UrlMkDebugOut((DEB_ILOCKBYTES, "%p OUT FileLockBytes::LockRegion\n", this));
    return(hresult);
}

HRESULT FileLockBytes::UnlockRegion(THIS_ ULARGE_INTEGER libOffset,
    ULARGE_INTEGER cb, DWORD dwLockType)
{
    HRESULT hresult = NOERROR;
    DWORD   offslow, offshigh, lenlow, lenhigh;

    UrlMkDebugOut((DEB_ILOCKBYTES, "%p IN FileLockBytes::UnlockRegion\n", this));

    if (_hFileHandle == INVALID_HANDLE_VALUE)
    {
        hresult = E_FAIL;
        goto UnlockRegionExit;
    }

    offshigh = *(DWORD *)(&libOffset.QuadPart + sizeof(ULONG));
    offslow = *(DWORD *)(&libOffset.QuadPart);

    lenhigh = *(DWORD *)(&cb.QuadPart + sizeof(ULONG));
    lenlow = *(DWORD *)(&cb.QuadPart);

    if (!UnlockFile(_hFileHandle, offslow, offshigh, lenlow, lenhigh))
    {
        if (GetLastError() == ERROR_LOCK_FAILED)
            hresult = STG_E_LOCKVIOLATION;
        else
            hresult = E_FAIL;
    }

UnlockRegionExit:

    UrlMkDebugOut((DEB_ILOCKBYTES, "%p OUT FileLockBytes::UnlockRegion\n", this));
    return(hresult);
}

HRESULT FileLockBytes::Stat(THIS_ STATSTG FAR *pStatStg, DWORD grfStatFlag)
{
    HRESULT hresult = E_FAIL;
    DWORD   sizelow, sizehigh;

    UrlMkDebugOut((DEB_ILOCKBYTES, "%p IN FileLockBytes::Stat\n", this));

    if (!pStatStg)
        goto StatExit;

    if (_hFileHandle == INVALID_HANDLE_VALUE)
        goto StatExit;

    memset(pStatStg, 0, sizeof(STATSTG));

    pStatStg->pwcsName = NULL;
    pStatStg->type = STGTY_LOCKBYTES;

    sizelow = GetFileSize(_hFileHandle, &sizehigh);
    if (sizelow == -1 && GetLastError() != NOERROR)
        goto StatExit;

    *(DWORD *)(&pStatStg->cbSize.QuadPart + sizeof(ULONG)) = sizehigh;
    *(DWORD *)(&pStatStg->cbSize.QuadPart) = sizelow;

    if (GetFileTime(_hFileHandle, &pStatStg->ctime, &pStatStg->atime, &pStatStg->mtime))
    {
        pStatStg->grfMode = GENERIC_READ | GENERIC_WRITE;
        pStatStg->grfLocksSupported = LOCK_WRITE | LOCK_EXCLUSIVE | LOCK_ONLYONCE;
        pStatStg->clsid = IID_ILockBytes;
        pStatStg->grfStateBits = 0;

        hresult = NOERROR;
    }

StatExit:

    UrlMkDebugOut((DEB_ILOCKBYTES, "%p OUT FileLockBytes::Stat\n", this));
    return(hresult);
}

HRESULT FileLockBytes::seekfile(ULARGE_INTEGER offset)
{
    HRESULT hresult = NOERROR;
    DWORD   offslow, offshigh;

    offshigh = *(DWORD *)(&offset.QuadPart + sizeof(ULONG));
    offslow = *(DWORD *)(&offset.QuadPart);

    offslow = SetFilePointer(_hFileHandle, offslow, (LONG *)&offshigh, FILE_BEGIN);
    if (offslow == -1 && GetLastError() != NO_ERROR)
        hresult = E_FAIL;

    return(hresult);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\stg\cstorage.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       CSTORAGE.CXX
//
//  Contents:
//
//  Classes:    Implements the IStorage class.
//
//  Functions:
//
//  History:    12-20-95    JoeS (Joe Souza)    Created
//
//----------------------------------------------------------------------------
#include <urlint.h>
#include <urlmon.hxx>
#include "cstorage.hxx"
#include "cstream.hxx"

// Internal Function Prototypes
CStorage    *NewCStorage(IStorage *pStg);


CStorage::CStorage(IStorage *pStorage) : _CRefs()
{
    _pStg = pStorage;
}

STDMETHODIMP CStorage::QueryInterface
    (REFIID riid, LPVOID FAR* ppvObj)
{
    VDATETHIS(this);
    UrlMkDebugOut((DEB_ISTREAM, "%p IN CStorage::QueryInterface\n", this));

    HRESULT hresult = NOERROR;

    if (   IsEqualIID(riid, IID_IUnknown)
        || IsEqualIID(riid, IID_IStream)
       )
    {
        *ppvObj = this;
        AddRef();
    }
    else
    {
        *ppvObj = NULL;
        hresult = E_NOINTERFACE;
    }

    UrlMkDebugOut((DEB_ISTREAM, "%p OUT CStorage::QueryInterface\n", this));
    return hresult;
}

STDMETHODIMP_(ULONG) CStorage::AddRef(void)
{
    VDATETHIS(this);
    UrlMkDebugOut((DEB_ISTREAM, "%p IN CStorage::AddRef\n", this));

    LONG lRet = ++_CRefs;

    if (_pStg)
        _pStg->AddRef();

    UrlMkDebugOut((DEB_ISTREAM, "%p OUT CStorage::AddRef\n", this));
    return lRet;
}

STDMETHODIMP_(ULONG) CStorage::Release(void)
{
    VDATETHIS(this);
    UrlMkDebugOut((DEB_ISTREAM, "%p IN CStorage::Release\n", this));
    UrlMkAssert((_CRefs > 0));

    LONG lRet = --_CRefs;

    if (_pStg)
        _pStg->Release();

    if (_CRefs == 0)
    {
        delete this;
    }

    UrlMkDebugOut((DEB_ISTREAM, "%p OUT CStorage::Release\n", this));
    return lRet;
}

HRESULT CStorage::CreateStream(THIS_ const OLECHAR *pwcsName, DWORD grfMode,
            DWORD dwReserved1, DWORD dwReserved2, LPSTREAM FAR *ppStm)
{
    HRESULT hresult = E_FAIL;
    IStream *pStream;

    UrlMkDebugOut((DEB_ISTREAM, "%p IN CStorage::CreateStream\n", this));

    if (_pStg)
    {
        hresult = _pStg->CreateStream(pwcsName, grfMode, dwReserved1, dwReserved2,
                    &pStream);

        if (hresult == S_OK)
        {
            if (!(*ppStm = new CStream(pStream)))
            {
                hresult = E_OUTOFMEMORY;

                // BUGBUG: Delete pStream!
            }
        }
    }

    UrlMkDebugOut((DEB_ISTREAM, "%p OUT CStorage::CreateStream\n", this));
    return(hresult);
}

HRESULT CStorage::OpenStream(THIS_ const OLECHAR *pwcsName,
            void FAR *pReserved1, DWORD grfMode, DWORD dwReserved2,
            LPSTREAM FAR *ppStm)
{
    HRESULT hresult = E_FAIL;
    IStream *pStream;

    UrlMkDebugOut((DEB_ISTREAM, "%p IN CStorage::OpenStream\n", this));

    if (_pStg)
    {
        hresult = _pStg->OpenStream(pwcsName, pReserved1, grfMode, dwReserved2,
                    &pStream);

        if (hresult == S_OK)
        {
            if (!(*ppStm = new CStream(pStream)))
            {
                hresult = E_OUTOFMEMORY;

                // BUGBUG: Delete pStream!
            }
        }
    }

    UrlMkDebugOut((DEB_ISTREAM, "%p OUT CStorage::OpenStream\n", this));
    return(hresult);
}


HRESULT CStorage::CreateStorage(THIS_ const OLECHAR *pwcsName, DWORD grfMode,
            DWORD dwReserved1, DWORD dwReserved2, LPSTORAGE FAR *ppStg)
{
    HRESULT     hresult = E_FAIL;
    IStorage    *pStorage;

    UrlMkDebugOut((DEB_ISTREAM, "%p IN CStorage::CreateStorage\n", this));

    if (_pStg)
    {
        hresult = _pStg->CreateStorage(pwcsName, grfMode, dwReserved1, dwReserved2,
                    &pStorage);

        if (hresult == S_OK)
        {
            if (!(*ppStg = ::NewCStorage(pStorage)))
            {
                hresult = E_OUTOFMEMORY;

                // BUGBUG: Delete pStorage!
            }
        }
    }

    UrlMkDebugOut((DEB_ISTREAM, "%p OUT CStorage::CreateStorage\n", this));
    return(hresult);
}

HRESULT CStorage::OpenStorage(THIS_ const OLECHAR *pwcsName,
            LPSTORAGE pstgPriority, DWORD grfMode, SNB snbExclude,
            DWORD dwReserved, LPSTORAGE FAR *ppStg)
{
    HRESULT     hresult = E_FAIL;
    IStorage    *pStorage;

    UrlMkDebugOut((DEB_ISTREAM, "%p IN CStorage::OpenStorage\n", this));

    if (_pStg)
    {
        hresult = _pStg->OpenStorage(pwcsName, pstgPriority, grfMode, snbExclude,
                    dwReserved, &pStorage);

        if (hresult == S_OK)
        {
            if (!(*ppStg = ::NewCStorage(pStorage)))
            {
                hresult = E_OUTOFMEMORY;

                // BUGBUG: Delete pStorage!
            }
        }
    }

    UrlMkDebugOut((DEB_ISTREAM, "%p OUT CStorage::OpenStorage\n", this));
    return(hresult);
}

HRESULT CStorage::CopyTo(THIS_ DWORD dwCiidExclude, IID const FAR *rgiidExclude,
            SNB snbExclude, LPSTORAGE pStgDest)
{
    HRESULT     hresult = E_FAIL;

    UrlMkDebugOut((DEB_ISTREAM, "%p IN CStorage::CopyTo\n", this));

    if (_pStg)
        hresult = _pStg->CopyTo(dwCiidExclude, rgiidExclude, snbExclude, pStgDest);

    UrlMkDebugOut((DEB_ISTREAM, "%p OUT CStorage::CopyTo\n", this));
    return(hresult);
}

HRESULT CStorage::MoveElementTo(THIS_ const OLECHAR *lpszName,
            LPSTORAGE pStgDest, const OLECHAR *lpszNewName, DWORD grfFlags)
{
    HRESULT     hresult = E_FAIL;

    UrlMkDebugOut((DEB_ISTREAM, "%p IN CStorage::MoveElementTo\n", this));

    if (_pStg)
        hresult = _pStg->MoveElementTo(lpszName, pStgDest, lpszNewName, grfFlags);

    UrlMkDebugOut((DEB_ISTREAM, "%p OUT CStorage::MoveElementTo\n", this));
    return(hresult);
}

HRESULT CStorage::Commit(THIS_ DWORD grfCommitFlags)
{
    HRESULT     hresult = E_FAIL;

    UrlMkDebugOut((DEB_ISTREAM, "%p IN CStorage::Commit\n", this));

    if (_pStg)
        hresult = _pStg->Commit(grfCommitFlags);

    UrlMkDebugOut((DEB_ISTREAM, "%p OUT CStorage::Commit\n", this));
    return(hresult);
}

HRESULT CStorage::Revert(THIS)
{
    HRESULT     hresult = E_FAIL;

    UrlMkDebugOut((DEB_ISTREAM, "%p IN CStorage::Revert\n", this));

    if (_pStg)
        hresult = _pStg->Revert();

    UrlMkDebugOut((DEB_ISTREAM, "%p OUT CStorage::Revert\n", this));
    return(hresult);
}

HRESULT CStorage::EnumElements(THIS_ DWORD dwReserved1, void FAR *pReserved2,
            DWORD dwReserved3, LPENUMSTATSTG FAR *ppenumStatStg)
{
    HRESULT     hresult = E_FAIL;

    UrlMkDebugOut((DEB_ISTREAM, "%p IN CStorage::EnumElements\n", this));

    if (_pStg)
        hresult = _pStg->EnumElements(dwReserved1, pReserved2, dwReserved3,
                    ppenumStatStg);

    UrlMkDebugOut((DEB_ISTREAM, "%p OUT CStorage::EnumElements\n", this));
    return(hresult);
}

HRESULT CStorage::DestroyElement(THIS_ const OLECHAR *pwcsName)
{
    HRESULT     hresult = E_FAIL;

    UrlMkDebugOut((DEB_ISTREAM, "%p IN CStorage::DestroyElement\n", this));

    if (_pStg)
        hresult = _pStg->DestroyElement(pwcsName);

    UrlMkDebugOut((DEB_ISTREAM, "%p OUT CStorage::DestroyElement\n", this));
    return(hresult);
}

HRESULT CStorage::RenameElement(THIS_ const OLECHAR *pwcsOldName,
            const OLECHAR *pwcsNewName)
{
    HRESULT     hresult = E_FAIL;

    UrlMkDebugOut((DEB_ISTREAM, "%p IN CStorage::RenameElement\n", this));

    if (_pStg)
        hresult = _pStg->RenameElement(pwcsOldName, pwcsNewName);

    UrlMkDebugOut((DEB_ISTREAM, "%p OUT CStorage::RenameElement\n", this));
    return(hresult);
}

HRESULT CStorage::SetElementTimes(THIS_ const OLECHAR *lpszName,
            FILETIME const FAR *pctime, FILETIME const FAR *patime,
            FILETIME const FAR *pmtime)
{
    HRESULT     hresult = E_FAIL;

    UrlMkDebugOut((DEB_ISTREAM, "%p IN CStorage::SetElementTimes\n", this));

    if (_pStg)
        hresult = _pStg->SetElementTimes(lpszName, pctime, patime, pmtime);

    UrlMkDebugOut((DEB_ISTREAM, "%p OUT CStorage::SetElementTimes\n", this));
    return(hresult);
}

HRESULT CStorage::SetClass(THIS_ REFCLSID rclsid)
{
    HRESULT     hresult = E_FAIL;

    UrlMkDebugOut((DEB_ISTREAM, "%p IN CStorage::SetClass\n", this));

    if (_pStg)
        hresult = _pStg->SetClass(rclsid);

    UrlMkDebugOut((DEB_ISTREAM, "%p OUT CStorage::SetClass\n", this));
    return(hresult);
}

HRESULT CStorage::SetStateBits(THIS_ DWORD grfStateBits, DWORD grfMask)
{
    HRESULT     hresult = E_FAIL;

    UrlMkDebugOut((DEB_ISTREAM, "%p IN CStorage::SetStateBits\n", this));

    if (_pStg)
        hresult = _pStg->SetStateBits(grfStateBits, grfMask);

    UrlMkDebugOut((DEB_ISTREAM, "%p OUT CStorage::SetStateBits\n", this));
    return(hresult);
}

HRESULT CStorage::Stat(THIS_ STATSTG FAR *pStatStg, DWORD grfStatFlag)
{
    HRESULT     hresult = E_FAIL;

    UrlMkDebugOut((DEB_ISTREAM, "%p IN CStorage::Stat\n", this));

    if (_pStg)
        hresult = _pStg->Stat(pStatStg, grfStatFlag);

    UrlMkDebugOut((DEB_ISTREAM, "%p OUT CStorage::Stat\n", this));
    return(hresult);
}

// Internal functions

CStorage    *NewCStorage(IStorage *pStg)
{
    return(new CStorage(pStg));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\stg\memlb.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       MEMLB.CXX
//
//  Contents:
//
//  Classes:    Implements the memory-based ILockBytes class.
//
//  Functions:
//
//  History:    12-13-95    JoeS (Joe Souza)    Created
//
//----------------------------------------------------------------------------
#include <urlint.h>
#include <urlmon.hxx>
#include "clockbyt.hxx"
#include "memlb.hxx"

MemLockBytes::MemLockBytes() : _CRefs()
{
    memhandle = NULL;
}

STDMETHODIMP_(ULONG) MemLockBytes::Release(void)
{
    VDATETHIS(this);
    UrlMkDebugOut((DEB_ILOCKBYTES, "%p IN MemLockBytes::Release\n", this));
    UrlMkAssert((_CRefs > 0));

    LONG lRet = --_CRefs;

    if (_CRefs == 0)
    {
        if (memhandle)
            GlobalFree(memhandle);

        delete this;
    }

    UrlMkDebugOut((DEB_ILOCKBYTES, "%p OUT MemLockBytes::Release\n", this));
    return lRet;
}

HRESULT MemLockBytes::ReadAt(THIS_ ULARGE_INTEGER ulOffset, VOID HUGEP *pv,
    ULONG cb, ULONG FAR *pcbRead)
{
    HRESULT hresult = E_FAIL;
    LPVOID  memptr;
    DWORD   memsize;
    ULONG   count;

    UrlMkDebugOut((DEB_ILOCKBYTES, "%p IN MemLockBytes::ReadAt\n", this));

    *pcbRead = 0;

    if (!cb)
        goto ReadAtExit;

    if (!memhandle)
        goto ReadAtExit;

    memsize = GlobalSize(memhandle);

    count = cb;
    if (ulOffset.QuadPart + cb > memsize)
    {
        if (ulOffset.QuadPart > memsize)
        {
            goto ReadAtExit;
        }
        else
        {
            count = memsize - (DWORD)ulOffset.QuadPart;
        }
    }

    memptr = GlobalLock(memhandle);
    if (!memptr)
        goto ReadAtExit;

    *(DWORD *)&memptr += (DWORD)ulOffset.QuadPart;
    memcpy(pv, memptr, count);
    *pcbRead = count;
    GlobalUnlock(memhandle);

    hresult = NOERROR;

ReadAtExit:

    UrlMkDebugOut((DEB_ILOCKBYTES, "%p OUT MemLockBytes::ReadAt\n", this));
    return(hresult);
}

HRESULT MemLockBytes::WriteAt(THIS_ ULARGE_INTEGER ulOffset, VOID const HUGEP *pv,
    ULONG cb, ULONG FAR *pcbWritten)
{
    HRESULT hresult = E_FAIL;
    LPVOID  memptr;
    DWORD   memsize;

    UrlMkDebugOut((DEB_ILOCKBYTES, "%p IN MemLockBytes::WriteAt\n", this));

    *pcbWritten = 0;

    if (!cb)
        goto WriteAtExit;

    if (!memhandle)
    {
        memhandle = GlobalAlloc(GMEM_MOVEABLE | GMEM_DISCARDABLE,
                        cb + (DWORD)ulOffset.QuadPart);
    }

    if (!memhandle)
        goto WriteAtExit;

    while (1)
    {
        memsize = GlobalSize(memhandle);

        if (ulOffset.QuadPart + cb > memsize)
        {
            memhandle = GlobalReAlloc(memhandle, cb + (DWORD)ulOffset.QuadPart,
                            GMEM_MOVEABLE);
        }
        else
            break;
    }

    memptr = GlobalLock(memhandle);
    if (!memptr)
        goto WriteAtExit;

    *(DWORD *)&memptr += (DWORD)ulOffset.QuadPart;
    memcpy(memptr, pv, cb);
    GlobalUnlock(memhandle);
    *pcbWritten = cb;

    hresult = NOERROR;

WriteAtExit:

    UrlMkDebugOut((DEB_ILOCKBYTES, "%p OUT MemLockBytes::WriteAt\n", this));
    return(hresult);
}

HRESULT MemLockBytes::SetSize(THIS_ ULARGE_INTEGER cb)
{
    HRESULT hresult = NOERROR;

    UrlMkDebugOut((DEB_ILOCKBYTES, "%p IN MemLockBytes::SetSize\n", this));

    if (!memhandle)
    {
        memhandle = GlobalAlloc(GMEM_MOVEABLE | GMEM_DISCARDABLE,
                        (DWORD)cb.QuadPart);
    }
    else
    {
        memhandle = GlobalReAlloc(memhandle, (DWORD)cb.QuadPart, GMEM_MOVEABLE);
    }

    if (!memhandle)
        hresult = E_FAIL;

    UrlMkDebugOut((DEB_ILOCKBYTES, "%p OUT MemLockBytes::SetSize\n", this));
    return(hresult);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\stg\precomp1.inc ===
#//+---------------------------------------------------------------
#//
#//  File:      precomp1.inc
#//
#//  Contents:  directives for global precompiled include file when the
#//             sources file is two directories below com (or wherever
#//             this file is located).  We could easily have precomp3 and
#//             precomp4 for other areas.The urlint.* files should not
#//             otherwise be mentioned in the sources files.
#//
#//
#//----------------------------------------------------------------

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\..\inc\urlint.h
PRECOMPILED_TARGET=$(GPCH_BUILD)\$(_OBJ_DIR)\*\urlint.pch
PRECOMPILED_OPTION=/Yuurlint.h /Fp$(GPCH_BUILD)\$(_OBJ_DIR)\*\urlint.pch
PRECOMPILED_OBJ=$(GPCH_BUILD)\$(_OBJ_DIR)\*\urlint.obj


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\stg\rostmfil.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       ROSTMFIL.CXX
//
//  Contents:
//
//  Classes:    Implements the CReadOnlyStreamFile class.
//
//  Functions:
//
//  History:    03-02-96    JoeS (Joe Souza)    Created
//
//----------------------------------------------------------------------------
#include <urlint.h>
#ifndef unix
#include "..\trans\transact.hxx"
#else
#include "../trans/transact.hxx"
#endif /* unix */
#include "rostmdir.hxx"
#include "rostmfil.hxx"

//+---------------------------------------------------------------------------
//
//  Method:     CReadOnlyStreamFile::GetFileName
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    7-22-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
LPWSTR CReadOnlyStreamFile::GetFileName()
{
    DEBUG_ENTER((DBG_STORAGE,
                String,
                "CReadOnlyStreamFile::GetFileName",
                "this=%#x",
                this
                ));
                
    UrlMkDebugOut((DEB_ISTREAM, "%p IN CReadOnlyStreamFile::GetFileName\n", this));
    LPWSTR pwzDupname = NULL;

    if (_pszFileName)
    {
        pwzDupname = DupA2W(_pszFileName);
    }

    UrlMkDebugOut((DEB_ISTREAM, "%p OUT CReadOnlyStreamFile::GetFileName (Filename:%ws)\n", this, pwzDupname));

    DEBUG_LEAVE(pwzDupname);
    return pwzDupname;
}


HRESULT CReadOnlyStreamFile::Create(LPSTR pszFileName, CReadOnlyStreamFile **ppCRoStm)
{
    DEBUG_ENTER((DBG_STORAGE,
                Hresult,
                "CReadOnlyStreamFile::Create",
                "%.80wq, %#x",
                pszFileName, ppCRoStm
                ));
                
    UrlMkDebugOut((DEB_ISTREAM, "%p IN CReadOnlyStreamFile::Create (pszFileName:%s)\n", NULL,pszFileName));
    HRESULT hr = NOERROR;

    *ppCRoStm = NULL;

    if (pszFileName == NULL)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        LPSTR  pszStr = new CHAR [strlen(pszFileName) + 1];

        if (pszStr == NULL)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {

            HANDLE handle = CreateFileA(pszFileName, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE,
                            NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

            if (handle == INVALID_HANDLE_VALUE)
            {
                delete pszStr;
                hr = E_FAIL;
            }
            else
            {

                strcpy(pszStr, pszFileName);
                CReadOnlyStreamFile *pCRoStm = new CReadOnlyStreamFile(pszStr, handle);

                if (pCRoStm == NULL)
                {
                    delete pszStr;
                }
                else
                {
                    *ppCRoStm = pCRoStm;
                }
            }
        }
    }
    UrlMkDebugOut((DEB_ISTREAM, "%p OUT CReadOnlyStreamFile::Create (hr:%lx)\n", *ppCRoStm, hr));

    DEBUG_LEAVE(hr);
    return hr;
}

CReadOnlyStreamFile::CReadOnlyStreamFile(LPSTR pszFileName, HANDLE handle)
                        : CReadOnlyStreamDirect(NULL, 0)
{
    DEBUG_ENTER((DBG_STORAGE,
                None,
                "CReadOnlyStreamFile::CReadOnlyStreamFile",
                "this=%#x, %.80q, %#x",
                this, pszFileName, handle
                ));
                
    UrlMkDebugOut((DEB_ISTREAM, "%p IN CReadOnlyStreamFile::CReadOnlyStreamFile (pszFileName:%s)\n", NULL,pszFileName));

    _hFileHandle = handle;
    _pszFileName = pszFileName;
    _fDataFullyAvailable = FALSE;

    UrlMkDebugOut((DEB_ISTREAM, "%p OUT CReadOnlyStreamFile::CReadOnlyStreamFile \n", this));

    DEBUG_LEAVE(0);
}

CReadOnlyStreamFile::~CReadOnlyStreamFile(void)
{
    DEBUG_ENTER((DBG_STORAGE,
                None,
                "CReadOnlyStreamFile::~CReadOnlyStreamFile",
                "this=%#x",
                this
                ));
                
    UrlMkDebugOut((DEB_ISTREAM, "%p IN CReadOnlyStreamFile::~CReadOnlyStreamFile (_pszFileName:%s)\n", this,_pszFileName));

    if (_hFileHandle != INVALID_HANDLE_VALUE)
    {
        CloseHandle(_hFileHandle);
    }

    if (_pszFileName)
    {
        delete _pszFileName;
    }

    UrlMkDebugOut((DEB_ISTREAM, "%p OUT CReadOnlyStreamFile::~CReadOnlyStreamFile\n", this));

    DEBUG_LEAVE(0);
}

HRESULT CReadOnlyStreamFile::Read(THIS_ VOID HUGEP *pv, ULONG cb, ULONG FAR *pcbRead)
{
    DEBUG_ENTER((DBG_STORAGE,
                Hresult,
                "CReadOnlyStreamFile::IStream::Read",
                "this=%#x, %#x, %x, %#x",
                this, pv, cb, pcbRead
                ));
                
    HRESULT hresult = NOERROR;
    UrlMkDebugOut((DEB_ISTREAM, "%p IN CReadOnlyStreamFile::Read (cbBuffer:%lx)\n", this,cb));

    DWORD dwRead = 0;

    if (!ReadFile(_hFileHandle, pv, cb, &dwRead, NULL))
    {
        if (GetLastError() == ERROR_LOCK_VIOLATION)
        {
            hresult = STG_E_ACCESSDENIED;
        }
        else
        {
            hresult = E_FAIL;
        }

        if (pcbRead)
        {
            *pcbRead = 0;
        }
    }
    else
    {
        if (pcbRead)
        {
            *pcbRead = dwRead;
        }

        if (dwRead == 0)
        {
            hresult = (_fDataFullyAvailable) ? S_FALSE : E_PENDING;
        }
    }

    UrlMkDebugOut((DEB_ISTREAM, "%p OUT CReadOnlyStreamFile::Read (hr:%lx, cdRead:%lx)\n", this, hresult, dwRead));

    DEBUG_LEAVE(hresult);
    return(hresult);
}

HRESULT CReadOnlyStreamFile::Seek(THIS_ LARGE_INTEGER dlibMove, DWORD dwOrigin,
            ULARGE_INTEGER FAR *plibNewPosition)
{
    DEBUG_ENTER((DBG_STORAGE,
                Hresult,
                "CReadOnlyStreamFile::IStream::Seek",
                "this=%#x, %#x, %x, %#x",
                this, dlibMove, dwOrigin, plibNewPosition
                ));
                
    HRESULT hresult = NOERROR;
    DWORD   offslow, offshigh;
    UrlMkDebugOut((DEB_ISTREAM, "%p IN CReadOnlyStreamFile::Seek\n", this));

    offshigh = dlibMove.HighPart;
    offslow = dlibMove.LowPart;

    offslow = SetFilePointer(_hFileHandle, offslow, (LONG *)&offshigh, dwOrigin);
    if (offslow == -1 && GetLastError() != NO_ERROR)
    {
        hresult = E_FAIL;
    }
    else if (plibNewPosition)
    {
        plibNewPosition->HighPart = offshigh;
        plibNewPosition->LowPart = offslow;
    }

    UrlMkDebugOut((DEB_ISTREAM, "%p OUT CReadOnlyStreamFile::Seek\n", this));

    DEBUG_LEAVE(hresult);
    return(hresult);
}

HRESULT CReadOnlyStreamFile::CopyTo(THIS_ LPSTREAM pStm, ULARGE_INTEGER cb,
            ULARGE_INTEGER FAR *pcbRead, ULARGE_INTEGER FAR *pcbWritten)
{
    DEBUG_ENTER((DBG_STORAGE,
                Hresult,
                "CReadOnlyStreamFile::IStream::CopyTo",
                "this=%#x, %#x, %x, %#x, %#x",
                this, pStm, cb, pcbRead, pcbWritten
                ));
                
    HRESULT hresult = STG_E_INSUFFICIENTMEMORY;
    LPVOID  memptr = NULL;
    DWORD   readcount, writecount;

    UrlMkDebugOut((DEB_ISTREAM, "%p IN CReadOnlyStreamFile::CopyTo\n", this));

    if (cb.HighPart || (pStm == NULL))
    {
        hresult = E_INVALIDARG;
        goto CopyToExit;
    }

    // do not need to copy to ourself
    if (pStm == this)
    {
        hresult = NOERROR;
        goto CopyToExit;
    }

    memptr = new BYTE [cb.LowPart];

    if (memptr)
    {
        if (!ReadFile(_hFileHandle, memptr, cb.LowPart, &readcount, NULL))
        {
            if (GetLastError() == ERROR_LOCK_VIOLATION)
            {
                hresult = STG_E_ACCESSDENIED;
            }
            else
            {
                hresult = E_FAIL;
            }

            goto CopyToExit;
        }

        if (pcbRead)
        {
            pcbRead->HighPart = 0;
            pcbRead->LowPart = readcount;
        }

        hresult = pStm->Write(memptr, readcount, &writecount);

        if (pcbWritten && !hresult)
        {
            pcbWritten->HighPart = 0;
            pcbWritten->LowPart = writecount;
        }
    }

CopyToExit:

    if (memptr)
    {
        delete memptr;
    }

    UrlMkDebugOut((DEB_ISTREAM, "%p OUT CReadOnlyStreamFile::CopyTo\n", this));

    DEBUG_LEAVE(hresult);
    return(hresult);
}

HRESULT CReadOnlyStreamFile::LockRegion(THIS_ ULARGE_INTEGER libOffset,
            ULARGE_INTEGER cb, DWORD dwLockType)
{
    DEBUG_ENTER((DBG_STORAGE,
                Hresult,
                "CReadOnlyStreamFile::IStream::LockRegion",
                "this=%#x, %#x, %x, %x",
                this, libOffset, cb, dwLockType
                ));
                
    UrlMkDebugOut((DEB_ISTREAM, "%p CReadOnlyStreamFile::LockRegion (NoOp)\n", this));

    DEBUG_LEAVE(E_NOTIMPL);
    return(E_NOTIMPL);
}

HRESULT CReadOnlyStreamFile::UnlockRegion(THIS_ ULARGE_INTEGER libOffset,
            ULARGE_INTEGER cb, DWORD dwLockType)
{
    DEBUG_ENTER((DBG_STORAGE,
                Hresult,
                "CReadOnlyStreamFile::IStream::UnlockRegion",
                "this=%#x, %#x, %x, %x",
                this, libOffset, cb, dwLockType
                ));
                
    UrlMkDebugOut((DEB_ISTREAM, "%p CReadOnlyStreamFile::UnlockRegion (NoOp)\n", this));

    DEBUG_LEAVE(E_NOTIMPL);
    return(E_NOTIMPL);
}

HRESULT CReadOnlyStreamFile::Stat(THIS_ STATSTG FAR *pStatStg, DWORD grfStatFlag)
{
    DEBUG_ENTER((DBG_STORAGE,
                Hresult,
                "CReadOnlyStreamFile::IStream::Stat",
                "this=%#x, %#x, %x",
                this, pStatStg, grfStatFlag
                ));
                
    HRESULT hresult = E_FAIL;
    DWORD   sizelow, sizehigh;
    UrlMkDebugOut((DEB_ISTREAM, "%p IN CReadOnlyStreamFile::Stat\n", this));

    if (pStatStg)
    {
        memset(pStatStg, 0, sizeof(STATSTG));

        pStatStg->type = STGTY_STREAM;
        pStatStg->clsid = IID_IStream;

        sizelow = GetFileSize(_hFileHandle, &sizehigh);
        if (sizelow == -1 && GetLastError() != NOERROR)
        {
            goto StatExit;
        }

        pStatStg->cbSize.HighPart = sizehigh;
        pStatStg->cbSize.LowPart = sizelow;
        pStatStg->pwcsName = GetFileName();

        if (GetFileTime(_hFileHandle, &pStatStg->ctime, &pStatStg->atime, &pStatStg->mtime))
        {
            pStatStg->grfMode = GENERIC_READ;
            pStatStg->grfLocksSupported = 0;
            pStatStg->clsid = IID_IStream;
            pStatStg->grfStateBits = 0;

            hresult = NOERROR;
        }
    }

StatExit:

    UrlMkDebugOut((DEB_ISTREAM, "%p OUT CReadOnlyStreamFile::Stat\n", this));

    DEBUG_LEAVE(hresult);
    return(hresult);
}

HRESULT CReadOnlyStreamFile::Clone(THIS_ LPSTREAM FAR *ppStm)
{
    DEBUG_ENTER((DBG_STORAGE,
                Hresult,
                "CReadOnlyStreamFile::IStream::Clone",
                "this=%#x, %#x",
                this, ppStm
                ));
                
    HRESULT hr = NOERROR;
    CReadOnlyStreamFile *pCRoStm;

    UrlMkDebugOut((DEB_ISTREAM, "%p IN CReadOnlyStreamFile::Clone\n", this));

    hr = Create(_pszFileName, &pCRoStm);

    if (hr == NOERROR)
    {
        *ppStm = pCRoStm;
    }
    else
    {
        *ppStm = NULL;
    }

    UrlMkDebugOut((DEB_ISTREAM, "%p OUT CReadOnlyStreamFile::Clone (hr:%lx)\n", this, hr));

    DEBUG_LEAVE(hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\stg\stgapi.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       STGAPI.CXX
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    12-15-95    JoeS (Joe Souza)    Created
//
//----------------------------------------------------------------------------
#include <urlint.h>
#include <urlmon.hxx>
#include "clockbyt.hxx"
#include "casynclb.hxx"
#include "filelb.hxx"
#include "memlb.hxx"
#include "stgapi.hxx"


HRESULT StgGetFillLockByteOnMem(IFillLockBytes **pFLB)
{
    DEBUG_ENTER_API((DBG_API,
                    Hresult,
                    "StgGetFillLockByteOnMem",
                    "%#x",
                    pFLB
                    ));

    HRESULT     hresult = NOERROR;
    ILockBytes  *pLB;

    *pFLB = NULL;

    if (!(pLB = new MemLockBytes))
    {
        DEBUG_LEAVE_API(E_OUTOFMEMORY);
        return(E_OUTOFMEMORY);
    }
    
    hresult = StgGetFillLockByteILockBytes(pLB, pFLB);
    if (hresult != NOERROR)
        delete pLB;

    DEBUG_LEAVE_API(hresult);
    return(hresult);
}

HRESULT StgGetFillLockByteOnFile(OLECHAR *pwcFileName, IFillLockBytes **pFLB)
{
    DEBUG_ENTER_API((DBG_API,
                    Hresult,
                    "StgGetFillLockByteOnFile",
                    "%#x, %#x",
                    pwcFileName, pFLB
                    ));
                    
    HRESULT     hresult = NOERROR;
    ILockBytes  *pLB;
    HANDLE      fhandle;

    *pFLB = NULL;

    fhandle = CreateFileW(pwcFileName, GENERIC_READ | GENERIC_WRITE,
                FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, CREATE_ALWAYS,
                FILE_ATTRIBUTE_NORMAL, NULL);

    if (fhandle == INVALID_HANDLE_VALUE)
    {
        DEBUG_LEAVE_API(E_FAIL);
        return(E_FAIL);
    }
    
    if (!(pLB = new FileLockBytes(fhandle)))
    {
        CloseHandle(fhandle);

        DEBUG_LEAVE_API(E_OUTOFMEMORY);
        return(E_OUTOFMEMORY);
    }

    hresult = StgGetFillLockByteILockBytes(pLB, pFLB);
    if (hresult != NOERROR)
        delete pLB;

    DEBUG_LEAVE_API(hresult);
    return(hresult);
}

HRESULT StgGetFillLockByteILockBytes(ILockBytes *pLB, IFillLockBytes **pFLB)
{
    DEBUG_ENTER_API((DBG_API,
                    Hresult,
                    "StgGetFillLockByteILockBytes",
                    "%#x, %#x",
                    pLB, pFLB
                    ));
                    
    IFillLockBytes  *flb;

    *pFLB = NULL;

    if (!(flb = new CAsyncLockBytes(pLB)))
    {
        DEBUG_LEAVE_API(E_OUTOFMEMORY);
        return(E_OUTOFMEMORY);
    }
    
    *pFLB = flb;

    DEBUG_LEAVE_API(NOERROR);
    return(NOERROR);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\stg\rostmdir.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       ROSTMDIR.CXX
//
//  Contents:
//
//  Classes:    Implements the CReadOnlyStreamDirect class.
//
//  Functions:
//
//  History:    12-21-95    JoeS (Joe Souza)    Created
//
//----------------------------------------------------------------------------
#include <urlint.h>
#ifndef unix
#include "..\trans\transact.hxx"
#else
#include "../trans/transact.hxx"
#endif /* unix */
#include "rostmdir.hxx"

CReadOnlyStreamDirect::CReadOnlyStreamDirect(CTransData *pCTransData, DWORD grfBindF) : _CRefs()
{
    DEBUG_ENTER((DBG_STORAGE,
                None,
                "CReadOnlyStreamDirect::CReadOnlyStreamDirect",
                "this=%#x, %#x, %#x",
                this, pCTransData, grfBindF
                ));
                
    UrlMkDebugOut((DEB_ISTREAM, "%p IN  CReadOnlyStreamDirect::CReadOnlyStreamDirect (pCTransData:%p)\n", NULL,pCTransData));

    _pCTransData = pCTransData;
    _grfBindF = grfBindF;
    if (_pCTransData)
    {
        _pCTransData->AddRef();
    }

    UrlMkDebugOut((DEB_ISTREAM, "%p OUT CReadOnlyStreamDirect::CReadOnlyStreamDirect \n", this));

    DEBUG_LEAVE(0);
}

CReadOnlyStreamDirect::~CReadOnlyStreamDirect()
{
    DEBUG_ENTER((DBG_STORAGE,
                None,
                "CReadOnlyStreamDirect::~CReadOnlyStreamDirect",
                "this=%#x",
                this
                ));
                
    UrlMkDebugOut((DEB_ISTREAM, "%p IN/OUT  CReadOnlyStreamDirect::~CReadOnlyStreamDirect\n", this));
    if (_pCTransData)
    {
        _pCTransData->Release();
    }

    DEBUG_LEAVE(0);
}

//+---------------------------------------------------------------------------
//
//  Method:     CReadOnlyStreamDirect::GetFileName
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    7-22-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
LPWSTR CReadOnlyStreamDirect::GetFileName()
{
    DEBUG_ENTER((DBG_STORAGE,
                String,
                "CReadOnlyStreamDirect::GetFileName",
                "this=%#x",
                this
                ));
                
    UrlMkDebugOut((DEB_ISTREAM, "%p IN CReadOnlyStreamDirect::GetFileName\n", this));

    LPWSTR pwzFilename = NULL;
    LPWSTR pwzDupname = NULL;

    if (_pCTransData)
    {
        pwzFilename = _pCTransData->GetFileName();
    }

    if (pwzFilename)
    {
        pwzDupname = OLESTRDuplicate(pwzFilename);
    }

    UrlMkDebugOut((DEB_ISTREAM, "%p OUT CReadOnlyStreamDirect::GetFileName (Filename:%ws)\n", this, pwzDupname));

    DEBUG_LEAVE(pwzDupname);
    return pwzDupname;
}



STDMETHODIMP CReadOnlyStreamDirect::QueryInterface
    (REFIID riid, LPVOID FAR* ppvObj)
{
    DEBUG_ENTER((DBG_STORAGE,
                Hresult,
                "CReadOnlyStreamDirect::IUnknown::QueryInterface",
                "this=%#x, %#x, %#x",
                this, &riid, ppvObj
                ));
                
    VDATETHIS(this);
    UrlMkDebugOut((DEB_ISTREAM, "%p IN CReadOnlyStreamDirect::QueryInterface\n", this));

    HRESULT hresult = NOERROR;

    if (   IsEqualIID(riid, IID_IUnknown)
        || IsEqualIID(riid, IID_IStream)
       )
    {
        *ppvObj = this;
        AddRef();
    }
    else
    {
        *ppvObj = NULL;
        hresult = E_NOINTERFACE;
    }

    UrlMkDebugOut((DEB_ISTREAM, "%p OUT CReadOnlyStreamDirect::QueryInterface\n", this));

    DEBUG_LEAVE(hresult);
    return hresult;
}

STDMETHODIMP_(ULONG) CReadOnlyStreamDirect::AddRef(void)
{
    DEBUG_ENTER((DBG_STORAGE,
                Dword,
                "CReadOnlyStreamDirect::IUnknown::AddRef",
                "this=%#x",
                this
                ));
                
    GEN_VDATEPTRIN(this,ULONG,0L);
    UrlMkDebugOut((DEB_ISTREAM, "%p IN CReadOnlyStreamDirect::AddRef\n", this));

    LONG lRet = ++_CRefs;

    UrlMkDebugOut((DEB_ISTREAM, "%p OUT CReadOnlyStreamDirect::::AddRef (%ld)\n", this, lRet));

    DEBUG_LEAVE(lRet);
    return lRet;
}

STDMETHODIMP_(ULONG) CReadOnlyStreamDirect::Release(void)
{
    DEBUG_ENTER((DBG_STORAGE,
                Dword,
                "CReadOnlyStreamDirect::IUnknown::Release",
                "this=%#x",
                this
                ));
                
    GEN_VDATEPTRIN(this,ULONG,0L);
    UrlMkDebugOut((DEB_ISTREAM, "%p IN CReadOnlyStreamDirect::Release\n", this));
    UrlMkAssert((_CRefs > 0));

    LONG lRet = --_CRefs;
    if (_CRefs == 0)
    {
        delete this;
    }

    UrlMkDebugOut((DEB_ISTREAM, "%p OUT CReadOnlyStreamDirect::Release (%ld)\n", this, lRet));

    DEBUG_LEAVE(lRet);
    return lRet;
}

HRESULT CReadOnlyStreamDirect::Read(THIS_ VOID HUGEP *pv, ULONG cb, ULONG FAR *pcbRead)
{
    DEBUG_ENTER((DBG_STORAGE,
                Hresult,
                "CReadOnlyStreamDirect::IStream::Read",
                "this=%#x, %#x, %#x, %#x",
                this, pv, cb, pcbRead
                ));
                
    HRESULT hresult = NOERROR;
    DWORD dwRead = 0;

    UrlMkDebugOut((DEB_ISTREAM, "%p IN CReadOnlyStreamDirect::Read\n", this));

    if( _pCTransData )
    {
        hresult = _pCTransData->ReadHere((LPBYTE) pv, cb, &dwRead);
        if( hresult != S_OK && hresult != E_PENDING )
        {
            // break connection with CTransData
            CTransData *pCTD = _pCTransData;
            _pCTransData = 0;
            pCTD->Release();
        }
    }
    else
    {
        hresult = S_FALSE;
        dwRead = 0;
    }

    if (pcbRead)
    {
        *pcbRead = dwRead;
    }

    UrlMkDebugOut((DEB_ISTREAM, "%p OUT CReadOnlyStreamDirect::Read\n", this));

    DEBUG_LEAVE(hresult);
    return(hresult);
}

HRESULT CReadOnlyStreamDirect::Write(THIS_ VOID const HUGEP *pv, ULONG cb,
            ULONG FAR *pcbWritten)
{
    DEBUG_ENTER((DBG_STORAGE,
                Hresult,
                "CReadOnlyStreamDirect::IStream::Write",
                "this=%#x, %#x, %#x, %#x",
                this, pv, cb, pcbWritten
                ));
                
    UrlMkDebugOut((DEB_ISTREAM, "%p CReadOnlyStreamDirect::Write (NoOp)\n", this));

    DEBUG_LEAVE(STG_E_ACCESSDENIED);
    return(STG_E_ACCESSDENIED);
}

HRESULT CReadOnlyStreamDirect::Seek(THIS_ LARGE_INTEGER dlibMove, DWORD dwOrigin,
            ULARGE_INTEGER FAR *plibNewPosition)
{
    DEBUG_ENTER((DBG_STORAGE,
                Hresult,
                "CReadOnlyStreamDirect::IStream::Seek",
                "this=%#x, %#x, %#x, %#x",
                this, dlibMove, dwOrigin, plibNewPosition
                ));
                
    HRESULT hresult = NOERROR;
    UrlMkDebugOut((DEB_ISTREAM, "%p CReadOnlyStreamDirect::Seek (NoOp)\n", this));
    
    // This is a true stream, and thus seeking is not possible.
    if( _pCTransData )
    {
        hresult = _pCTransData->Seek(dlibMove, dwOrigin, plibNewPosition);
    }
    else
    {
        hresult = S_FALSE;
    }

    DEBUG_LEAVE(hresult);
    return hresult;
}

HRESULT CReadOnlyStreamDirect::SetSize(THIS_ ULARGE_INTEGER libNewSize)
{
    DEBUG_ENTER((DBG_STORAGE,
                Hresult,
                "CReadOnlyStreamDirect::IStream::SetSize",
                "this=%#x, %#x",
                this, libNewSize
                ));
                
    UrlMkDebugOut((DEB_ISTREAM, "%p CReadOnlyStreamDirect::SetSize (NoOp)\n", this));

    // BUGBUG: Should we just return S_OK here?

    DEBUG_LEAVE(E_FAIL);
    return(E_FAIL);
}

HRESULT CReadOnlyStreamDirect::CopyTo(THIS_ LPSTREAM pStm, ULARGE_INTEGER cb,
            ULARGE_INTEGER FAR *pcbRead, ULARGE_INTEGER FAR *pcbWritten)
{
    DEBUG_ENTER((DBG_STORAGE,
                Hresult,
                "CReadOnlyStreamDirect::IStream::CopyTo",
                "this=%#x, %#x, %#x, %#x, %#x",
                this, pStm, cb, pcbRead, pcbWritten
                ));
                
    HRESULT hresult = STG_E_INSUFFICIENTMEMORY;
    LPVOID  memptr = NULL;
    DWORD   readcount, writecount;

    UrlMkDebugOut((DEB_ISTREAM, "%p IN CReadOnlyStreamDirect::CopyTo\n", this));

    if (cb.HighPart || (pStm == NULL))
    {
        hresult = E_INVALIDARG;
        goto CopyToExit;
    }

    // do not need to copy to ourself
    if (pStm == this)
    {
        hresult = NOERROR;
        goto CopyToExit;
    }

    memptr = new BYTE [cb.LowPart];

    if (memptr)
    {
        hresult = Read((LPBYTE) memptr, cb.LowPart, &readcount);
        if (hresult)
        {
            goto CopyToExit;
        }

        if (pcbRead)
        {
            pcbRead->HighPart = 0;
            pcbRead->LowPart = readcount;
        }

        hresult = pStm->Write(memptr, readcount, &writecount);

        if (pcbWritten && !hresult)
        {
            pcbWritten->HighPart = 0;
            pcbWritten->LowPart = writecount;
        }
    }

CopyToExit:

    if (memptr)
    {
        delete memptr;
    }

    UrlMkDebugOut((DEB_ISTREAM, "%p OUT CReadOnlyStreamDirect::CopyTo\n", this));

    DEBUG_LEAVE(hresult);
    return(hresult);
}

HRESULT CReadOnlyStreamDirect::Commit(THIS_ DWORD dwCommitFlags)
{
    DEBUG_ENTER((DBG_STORAGE,
                Hresult,
                "CReadOnlyStreamDirect::IStream::Commit",
                "this=%#x, %#x",
                this, dwCommitFlags
                ));
                
    UrlMkDebugOut((DEB_ISTREAM, "%p CReadOnlyStreamDirect::Commit (NoOp)\n", this));

    // This is a read-only stream, so nothing to commit.

    DEBUG_LEAVE(E_NOTIMPL);
    return(E_NOTIMPL);
}

HRESULT CReadOnlyStreamDirect::Revert(THIS)
{
    DEBUG_ENTER((DBG_STORAGE,
                Hresult,
                "CReadOnlyStreamDirect::IStream::Revert",
                "this=%#x",
                this
                ));
                
    UrlMkDebugOut((DEB_ISTREAM, "%p CReadOnlyStreamDirect::Revert (NoOp)\n", this));

    DEBUG_LEAVE(E_NOTIMPL);
    return(E_NOTIMPL);
}

HRESULT CReadOnlyStreamDirect::LockRegion(THIS_ ULARGE_INTEGER libOffset,
            ULARGE_INTEGER cb, DWORD dwLockType)
{
    DEBUG_ENTER((DBG_STORAGE,
                Hresult,
                "CReadOnlyStreamDirect::IStream::LockRegion",
                "this=%#x, %#x, %#x, %#x",
                this, libOffset, cb, dwLockType
                ));
                
    UrlMkDebugOut((DEB_ISTREAM, "%p CReadOnlyStreamDirect::LockRegion (NoOp)\n", this));

    DEBUG_LEAVE(E_NOTIMPL);
    return(E_NOTIMPL);
}

HRESULT CReadOnlyStreamDirect::UnlockRegion(THIS_ ULARGE_INTEGER libOffset,
            ULARGE_INTEGER cb, DWORD dwLockType)
{
    DEBUG_ENTER((DBG_STORAGE,
                Hresult,
                "CReadOnlyStreamDirect::IStream::UnlockRegion",
                "this=%#x, %#x, %#x, %#x",
                this, libOffset, cb, dwLockType
                ));
                
    UrlMkDebugOut((DEB_ISTREAM, "%p CReadOnlyStreamDirect::UnlockRegion (NoOp)\n", this));

    DEBUG_LEAVE(E_NOTIMPL);
    return(E_NOTIMPL);
}

HRESULT CReadOnlyStreamDirect::Stat(THIS_ STATSTG FAR *pStatStg, DWORD grfStatFlag)
{
    DEBUG_ENTER((DBG_STORAGE,
                Hresult,
                "CReadOnlyStreamDirect::IStream::Stat",
                "this=%#x, %#x, %#x",
                this, pStatStg, grfStatFlag
                ));
                
    HRESULT hresult = E_FAIL;

    UrlMkDebugOut((DEB_ISTREAM, "%p IN CReadOnlyStreamDirect::Stat\n", this));

    if (pStatStg)
    {
        memset(pStatStg, 0, sizeof(STATSTG));

        pStatStg->type = STGTY_STREAM;
        pStatStg->clsid = IID_IStream;
        pStatStg->pwcsName = GetFileName();

        hresult = NOERROR;
    }

    UrlMkDebugOut((DEB_ISTREAM, "%p OUT CReadOnlyStreamDirect::Stat\n", this));

    DEBUG_LEAVE(hresult);
    return(hresult);
}

HRESULT CReadOnlyStreamDirect::Clone(THIS_ LPSTREAM FAR *ppStm)
{
    DEBUG_ENTER((DBG_STORAGE,
                Hresult,
                "CReadOnlyStreamDirect::IStream::Clone",
                "this=%#x, %#x",
                this, ppStm
                ));
                
    HRESULT hresult = NOERROR;

    UrlMkDebugOut((DEB_ISTREAM, "%p IN CReadOnlyStreamDirect::Clone\n", this));

    if (!(*ppStm = new CReadOnlyStreamDirect(_pCTransData, _grfBindF)))
        hresult = E_OUTOFMEMORY;

    UrlMkDebugOut((DEB_ISTREAM, "%p OUT CReadOnlyStreamDirect::Clone\n", this));

    DEBUG_LEAVE(hresult);
    return(hresult);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\trans\callback.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       callback.cxx
//
//  Contents:   Callback mechanism and thread switching code
//
//  Classes:
//
//  Functions:
//
//  History:    11-11-95   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------
#include <trans.h>
#include "callback.hxx"

HRESULT CreateINetCallback(CBinding *pCBdg, DWORD *pdwContext, PFNCINETCALLBACK *pCB)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CreateINetCallback",
                "%#x, %#x, %#x, %#x",
                pCBdg, pdwContext, pCB
                ));

    DEBUG_LEAVE(NOERROR);
    return NOERROR;
}

PFNCINETCALLBACK CreateCallback(DWORD dwId, LPVOID pv)
{
    DEBUG_ENTER((DBG_TRANS,
                Pointer,
                "CreateCallback",
                "%#x, %#x",
                dwId, pv
                ));

    DEBUG_LEAVE(NULL);
    return NULL;
}


#ifdef OLD_UNUSED
void Update(CInternetTransaction *pThis,DLD *pdld, char *pszStatusText)
{
    DEBUG_ENTER((DBG_TRANS,
                None,
                "Update",
                "%#x, %#x, %#x, %#x",
                pThis, pdld, pszStatusText
                ));
                
    Assert(pThis != NULL);
    Assert(!pThis->m_fComplete);

    if (pdld == NULL)
    {
        DEBUG_LEAVE(0);
        return;
    }
    
    AssertDo(pThis->HrPostNotifications(s_WM_UPDATECALLBACK, pdld,
        pszStatusText, INLERR_OK) == NOERROR);

    DEBUG_LEAVE(0);
}


void Inetdone(CInternetTransaction *pThis, BOOL fInStartTransaction, DLD *pdld, int errCode)
{
    DEBUG_ENTER((DBG_TRANS,
                None,
                "Inetdone",
                "%#x, %B, %#x, %d",
                pThis, fInStartTransaction, pdld, errCode
                ));
                
    Assert(pThis != NULL);
    Assert(!pThis->m_fComplete);
    if (!fInStartTransaction)
    {
        Assert(pThis->m_hInet != NULL);
        if (pThis->m_hInet == NULL)
        {
            DEBUG_LEAVE(0);
            return;
        }
    }

    pThis->m_fComplete = TRUE;
    pThis->m_hInet = NULL;

    AssertDo(pThis->HrPostNotifications(s_WM_INETDONECALLBACK, pdld, "",
        errCode) == NOERROR);

    // Release the reference we had added in HrStartDataRetrieval.
    // Note: after this call, the object may no longer exist
    pThis->Release();
    
    DEBUG_LEAVE(0);
}

/*---------------------------------------------------------------------------
    CInternetTransaction::HrPostNotification

    Post a notification message to all the client requests that are
    connected to this internet transaction.
----------------------------------------------------------------- DavidEbb -*/
HRESULT CInternetTransaction::HrPostNotifications(UINT uiMsg,
    DLD *pdld, char *pszStatusText, int errCode)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CInternetTransaction::HrPostNotifications",
                "this=%#x, %#x, %#x, %.80q, %d",
                this, uiMsg, pdld, pszStatusText, errCode
                ));
                
    CALLBACKDATA *pcbd;
    CClientRequest *pcrqTmp = m_pcrqFirst;

    Assert(pdld != NULL);
    Assert(m_pcrqFirst != NULL);

    {
        // Save the file name if we don't already have it.
        if (m_wzFileName[0] == '\0')
            A2W(pdld->szTargetFile, m_wzFileName, MAX_PATH);
    }

    // Traverse the whole linked list
    while (pcrqTmp != NULL)
    {
        // Note: we need to allocate a new CALLBACKDATA structure for each
        // client request in the list, because we are giving up
        // ownership of it when we call PostMessage().
        pcbd = CreateCallBackData(pdld, pszStatusText, errCode);
        if (pcbd == NULL)
        {
            DEBUG_LEAVE(E_OUTOFMEMORY);
            return E_OUTOFMEMORY;
        }
        
        Assert(pcrqTmp->HwndGetStatusWindow() != NULL);

        // Post a message to the hidden window in the main thread.
        PostMessage(pcrqTmp->HwndGetStatusWindow(), uiMsg,(WPARAM)pcrqTmp, (LPARAM)pcbd);

        pcrqTmp = pcrqTmp->GetNextRequest();
    }

    DEBUG_LEAVE(NOERROR);
    return NOERROR;
}

#endif //OLD_UNUSED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\trans\bindctx.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       bindctx.cxx
//
//  Contents:   CBindCtx methods implementations
//              to support custom marshaling
//
//  Classes:
//
//  Functions:
//
//  History:    9-12-96   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------
#include <trans.h>
#include "bindctx.hxx"

PerfDbgTag(tagCBindCtx, "Urlmon", "Log CBindCtx", DEB_URLMON);

#define OBJECTPARAMKEYCHECK1 (_pbcRem &&  !wcscmp(pszKey, SZ_TRANSACTIONDATA))

#define OBJECTPARAMKEYCHECK2 (_pbcRem && wcscmp(pszKey, SZ_BINDING)         \
                                        && wcscmp(pszKey, REG_BSCB_HOLDER)  \
                                        && wcscmp(pszKey, REG_ENUMFORMATETC)\
                                        && wcscmp(pszKey, REG_MEDIA_HOLDER) \
                                        && wcscmp(pszKey, SZ_TRANSACTIONDATA))


//+---------------------------------------------------------------------------
//
//  Method:     CBindCtx::Create
//
//  Synopsis:
//
//  Arguments:  [ppCBCtx] --
//
//  Returns:
//
//  History:    9-12-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CBindCtx::Create(CBindCtx **ppCBCtx, IBindCtx *pbc)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CBindCtx::Create",
                "%#x, %#x",
                ppCBCtx, pbc
                ));
                
    PerfDbgLog1(tagCBindCtx, NULL, "+CBindCtx::Create (pbc:%lx)", pbc);
    HRESULT hr = NOERROR;

    *ppCBCtx = NULL;

    if (pbc == NULL)
    {
        hr = CreateBindCtx(0, &pbc);
    }
    else
    {
        // check if this is actually  a wrapped object
        // if so don't wrap it again
        hr = pbc->QueryInterface(IID_IAsyncBindCtx, (void **)ppCBCtx);
        if (hr != NOERROR)
        {
            hr = NOERROR;
            *ppCBCtx = NULL;
        }
        pbc->AddRef();
    }

    if (hr == NOERROR && *ppCBCtx == NULL)
    {
        TransAssert((pbc));
        *ppCBCtx = new CBindCtx(pbc);

        if (*ppCBCtx  == NULL)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (pbc)
    {
        pbc->Release();
    }
    PerfDbgLog2(tagCBindCtx, NULL, "-CBindCtx::Create (out:%lx,hr:%lx)", *ppCBCtx, hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBindCtx::CBindCtx
//
//  Synopsis:
//
//  Arguments:  [pbc] --
//
//  Returns:
//
//  History:    9-12-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
CBindCtx::CBindCtx(IBindCtx *pbc)
{
    DEBUG_ENTER((DBG_TRANS,
                None,
                "CBindCtx::CBindCtx",
                "this=%#x, %#x",
                this, pbc
                ));
                
    _pbcLocal = pbc;
    if (_pbcLocal)
    {
        _pbcLocal->AddRef();
    }
    _pbcRem = NULL;
    _dwThreadId = GetCurrentThreadId();
    _pCTrans = 0;
    _pCTransData = 0;
    
    DllAddRef();

    DEBUG_LEAVE(0);
}

//+---------------------------------------------------------------------------
//
//  Method:     CBindCtx::~CBindCtx
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    9-12-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
CBindCtx::~CBindCtx()
{
    DEBUG_ENTER((DBG_TRANS,
                None,
                "CBindCtx::~CBindCtx",
                "this=%#x",
                this
                ));
                
    //TransAssert(( _dwThreadId == GetCurrentThreadId() ));
    if (_pbcRem)
    {
        _pbcRem->Release();
    }
    if (_pbcLocal)
    {
        _pbcLocal->Release();
    }

    if (_pCTrans)
    {
        _pCTrans->Release();
    }
    if (_pCTransData)
    {
        _pCTransData->Release();
    }


    DllRelease();

    DEBUG_LEAVE(0);
}

//+---------------------------------------------------------------------------
//
//  Method:     CBindCtx::CanMarshalIID
//
//  Synopsis:   Checks whether this object supports marshalling this IID.
//
//  Arguments:  [riid] --
//
//  Returns:
//
//  History:    9-12-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
inline BOOL CBindCtx::CanMarshalIID(REFIID riid)
{
    DEBUG_ENTER((DBG_TRANS,
                Bool,
                "CBindCtx::CanMarshalIID",
                "this=%#x, %#x",
                this, &riid
                ));
                
    // keep this in sync with the QueryInterface
    BOOL bRet = (BOOL) (riid == IID_IBindCtx);

    DEBUG_LEAVE(bRet);
    return bRet;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBindCtx::ValidateMarshalParams
//
//  Synopsis:   Validates the standard set parameters that are passed into most
//              of the IMarshal methods
//
//  Arguments:  [riid] --
//              [pvInterface] --
//              [dwDestContext] --
//              [pvDestContext] --
//              [mshlflags] --
//
//  Returns:
//
//  History:    9-12-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CBindCtx::ValidateMarshalParams(REFIID riid,void *pvInterface,
                    DWORD dwDestContext,void *pvDestContext,DWORD mshlflags)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CBindCtx::ValidateMarshalParams",
                "this=%#x, %#x, %#x, %#x, %#x, %#x",
                this, &riid, pvInterface, dwDestContext, pvDestContext, mshlflags
                ));

    PerfDbgLog(tagCBindCtx, this, "+CBindCtx::ValidateMarshalParams");
    TransAssert(( _dwThreadId == GetCurrentThreadId() ));
    HRESULT hr = NOERROR;

    if (CanMarshalIID(riid))
    {
        UrlMkAssert((dwDestContext == MSHCTX_INPROC || dwDestContext == MSHCTX_LOCAL || dwDestContext == MSHCTX_NOSHAREDMEM));
        UrlMkAssert((mshlflags == MSHLFLAGS_NORMAL || mshlflags == MSHLFLAGS_TABLESTRONG));

        if (   (dwDestContext != MSHCTX_INPROC && dwDestContext != MSHCTX_LOCAL && dwDestContext != MSHCTX_NOSHAREDMEM)
            || (mshlflags != MSHLFLAGS_NORMAL && mshlflags != MSHLFLAGS_TABLESTRONG))
        {
            hr = E_INVALIDARG;
        }
    }
    else
    {
        hr = E_NOINTERFACE;
    }

    PerfDbgLog1(tagCBindCtx, this, "-CBindCtx::ValidateMarshalParams (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBindCtx::QueryInterface
//
//  Synopsis:
//
//  Arguments:  [riid] --
//              [ppvObj] --
//
//  Returns:
//
//  History:    9-12-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBindCtx::QueryInterface(REFIID riid, void **ppvObj)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CBindCtx::IUnknown::QueryInterface",
                "this=%#x, %#x, %#x",
                this, &riid, ppvObj
                ));
                
    VDATEPTROUT(ppvObj, void *);
    HRESULT hr = NOERROR;
    PerfDbgLog(tagCBindCtx, this, "+CBindCtx::QueryInterface");

    TransAssert(( _dwThreadId == GetCurrentThreadId() ));

    if (   riid == IID_IUnknown
        || riid == IID_IBindCtx
        || riid == IID_IAsyncBindCtx)
    {
        *ppvObj = this;
    }
    else if (riid == IID_IMarshal)
    {
        *ppvObj = (void*) (IMarshal *) this;
    }
    else
    {
        *ppvObj = NULL;
        hr = E_NOINTERFACE;
    }
    if (hr == NOERROR)
    {
        AddRef();
    }

    PerfDbgLog1(tagCBindCtx, this, "-CBindCtx::QueryInterface (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   CBindCtx::AddRef
//
//  Synopsis:
//
//  Arguments:  [ULONG] --
//
//  Returns:
//
//  History:    9-12-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CBindCtx::AddRef(void)
{
    DEBUG_ENTER((DBG_TRANS,
                Dword,
                "CBindCtx::IUnknown::AddRef",
                "this=%#x",
                this
                ));
                
    //TransAssert(( _dwThreadId == GetCurrentThreadId() ));

    LONG lRet = ++_CRefs;

    PerfDbgLog1(tagCBindCtx, this, "CBindCtx::AddRef (cRefs:%ld)", lRet);

    DEBUG_LEAVE(lRet);
    return lRet;
}

//+---------------------------------------------------------------------------
//
//  Function:   CBindCtx::Release
//
//  Synopsis:
//
//  Arguments:  [ULONG] --
//
//  Returns:
//
//  History:    9-12-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CBindCtx::Release(void)
{
    DEBUG_ENTER((DBG_TRANS,
                Dword,
                "CBindCtx::IUnknown::Release",
                "this=%#x",
                this
                ));
                
    //TransAssert(( _dwThreadId == GetCurrentThreadId() ));
    PerfDbgLog(tagCBindCtx, this, "+CBindCtx::Release");

    LONG lRet = --_CRefs;

    if (_CRefs == 0)
    {
        delete this;
    }

    PerfDbgLog1(tagCBindCtx, this, "-CBindCtx::Release (cRefs:%ld)", lRet);

    DEBUG_LEAVE(lRet);
    return lRet;
}
                                       
//+---------------------------------------------------------------------------
//
//  Method:     CBindCtx::GetObjectParam
//
//  Synopsis:
//
//  Arguments:  [pszKey] --
//              [ppunk] --
//
//  Returns:
//
//  History:    9-12-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBindCtx::GetObjectParam(LPOLESTR pszKey, IUnknown **ppunk)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CBindCtx::IBindCtx::GetObjectParam",
                "this=%#x, %#x, %#x",
                this, pszKey, ppunk
                ));
                
    HRESULT hr = NOERROR;
    PerfDbgLog3(tagCBindCtx, this, "+CBindCtx::GetObjectParam (_pbcLocal:%lx, _pbcRem:%lx, szParam:%ws)", _pbcLocal, _pbcRem, pszKey);
    UrlMkAssert((pszKey && ppunk));

    if (OBJECTPARAMKEYCHECK1)
    {
        // get the interface from the remote object
        PerfDbgLog2(tagCBindCtx, this, "=== CBindCtx::GetObjectParam (_pbcRem:%lx, szParam:%ws)", _pbcRem, pszKey);

        hr =  _pbcLocal->GetObjectParam(pszKey, ppunk);
        
        if (hr != NOERROR)
        {
            hr =  _pbcRem->GetObjectParam(pszKey, ppunk);
        }
    }
    else
    {
        hr =  _pbcLocal->GetObjectParam(pszKey, ppunk);
    }

    if ((hr != NOERROR) && OBJECTPARAMKEYCHECK2)
    {
        hr =  _pbcRem->GetObjectParam(pszKey, ppunk);
    }

    PerfDbgLog1(tagCBindCtx, this, "-CBindCtx::GetObjectParam (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBindCtx::EnumObjectParam
//
//  Synopsis:
//
//  Arguments:  [ppenum] --
//
//  Returns:
//
//  History:    9-12-96   JohannP (Johann Posch)   Created
//
//  Notes:      BUGBUG - this implementation is wrong; need to wrap
//
//----------------------------------------------------------------------------
STDMETHODIMP CBindCtx::EnumObjectParam(IEnumString **ppenum)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CBindCtx::IBindCtx::EnumObjectParam",
                "this=%#x, %#x",
                this, ppenum
                ));
                
    HRESULT hr = _pbcLocal->EnumObjectParam(ppenum);

    DEBUG_LEAVE(hr);
    return hr;
}

STDMETHODIMP CBindCtx::RevokeObjectParam(LPOLESTR pszKey)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CBindCtx::IBindCtx::RevokeObjectParam",
                "this=%#x, %#x",
                this, pszKey
                ));
                
    HRESULT hr = NOERROR;
    PerfDbgLog3(tagCBindCtx, this, "+CBindCtx::RevokeObjectParam (_pbcLocal:%lx, _pbcRem:%lx, szParam:%ws)", _pbcLocal, _pbcRem, pszKey);
    UrlMkAssert(pszKey);

    if (OBJECTPARAMKEYCHECK1)
    {
        // get the interface from the remote object
        PerfDbgLog2(tagCBindCtx, this, "=== CBindCtx::RevokeObjectParam (_pbcRem:%lx, szParam:%ws)", _pbcRem, pszKey);

        hr =  _pbcLocal->RevokeObjectParam(pszKey);
        
        if (hr != NOERROR)
        {
            hr =  _pbcRem->RevokeObjectParam(pszKey);
        }
    }
    else
    {
        hr =  _pbcLocal->RevokeObjectParam(pszKey);
    }

    if ((hr != NOERROR) && OBJECTPARAMKEYCHECK2)
    {
        hr =  _pbcRem->RevokeObjectParam(pszKey);
    }

    PerfDbgLog1(tagCBindCtx, this, "-CBindCtx::RevokeObjectParam (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
// IMarshal methods
//
//+---------------------------------------------------------------------------
//
//  Method:     CBindCtx::GetUnmarshalClass
//
//  Synopsis:
//
//  Arguments:  [riid] --
//              [pvInterface] --
//              [dwDestContext] --
//              [pvDestContext] --
//              [mshlflags] --
//              [pCid] --
//
//  Returns:
//
//  History:    9-12-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBindCtx::GetUnmarshalClass(REFIID riid,void *pvInterface,
        DWORD dwDestContext,void *pvDestContext,DWORD mshlflags,CLSID *pCid)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CBindCtx::IMarshal::GetUnmarshalClass",
                "this=%#x, %#x, %#x, %#x, %#x, %#x, %#x",
                this, &riid, pvInterface, dwDestContext, pvDestContext, mshlflags, pCid
                ));
                
    PerfDbgLog(tagCBindCtx, this, "+CBindCtx::GetUnmarshalClass");
    HRESULT hr;

    hr = ValidateMarshalParams(riid, pvInterface, dwDestContext,pvDestContext, mshlflags);
    if (hr == NOERROR)
    {
        *pCid = (CLSID) CLSID_UrlMkBindCtx;
    }

    PerfDbgLog1(tagCBindCtx, this, "-CBindCtx::GetUnmarshalClass (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBindCtx::GetMarshalSizeMax
//
//  Synopsis:
//
//  Arguments:  [void] --
//              [pvInterface] --
//              [dwDestContext] --
//              [pvDestContext] --
//              [mshlflags] --
//              [pSize] --
//
//  Returns:
//
//  History:    9-12-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBindCtx::GetMarshalSizeMax(REFIID riid,void *pvInterface,
        DWORD dwDestContext,void *pvDestContext,DWORD mshlflags,DWORD *pSize)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CBindCtx::IMarshal::GetMarshalSizeMax",
                "this=%#x, %#x, %#x, %#x, %#x, %#x, %#x",
                this, &riid, pvInterface, dwDestContext, pvDestContext, mshlflags, pSize
                ));
                
    PerfDbgLog(tagCBindCtx, this, "+CBindCtx::GetMarshalSizeMax");
    HRESULT hr;

    if (pSize == NULL)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        hr = ValidateMarshalParams(riid, pvInterface, dwDestContext,pvDestContext, mshlflags);
        if (hr == NOERROR)
        {
            hr = CoGetMarshalSizeMax(pSize, IID_IBindCtx, _pbcLocal, dwDestContext,pvDestContext,mshlflags);
            // marshal also the transaction object
            *pSize += sizeof(_pCTrans) + sizeof(DWORD);
        }
    }

    PerfDbgLog1(tagCBindCtx, this, "-CBindCtx::GetMarshalSizeMax (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBindCtx::MarshalInterface
//
//  Synopsis:
//
//  Arguments:  [REFIID] --
//              [riid] --
//              [DWORD] --
//              [void] --
//              [DWORD] --
//              [mshlflags] --
//
//  Returns:
//
//  History:    9-12-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBindCtx::MarshalInterface(IStream *pistm,REFIID riid,
                                void *pvInterface,DWORD dwDestContext,
                                void *pvDestContext,DWORD mshlflags)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CBindCtx::IMarshal::MarshalInterface",
                "this=%#x, %#x, %#x, %#x, %#x, %#x, %#x",
                this, pistm, &riid, pvInterface, dwDestContext, pvDestContext, mshlflags
                ));
                
    PerfDbgLog(tagCBindCtx, this, "+CBindCtx::MarshalInterface");
    HRESULT hr;
    BOOL fTransfered = FALSE;

    hr = ValidateMarshalParams(riid, pvInterface, dwDestContext,pvDestContext, mshlflags);
    if (hr == NOERROR)
    {
        hr = CoMarshalInterface(pistm, IID_IBindCtx, _pbcLocal, dwDestContext, pvDestContext, mshlflags);
    }

    if (   (hr == NOERROR)
        && (dwDestContext == MSHCTX_INPROC)
        && (_pCTrans != NULL) )
    {
        TransAssert((_pCTrans));
        TransAssert((_pCTransData));
        
        hr = _pCTrans->PrepareThreadTransfer();

        if (hr == NOERROR)
        {
            DWORD dwProcessId = GetCurrentProcessId();
            
            // marshal also the transaction object
            hr = pistm->Write(&_pCTrans, sizeof(_pCTrans), NULL);
            TransAssert((hr == NOERROR));
            // addref the pointer here to keep the object alive!
            // 
            _pCTrans->AddRef();

            // marshal also the transdata object
            hr = pistm->Write(&_pCTransData, sizeof(_pCTransData), NULL);
            TransAssert((hr == NOERROR));

            if (_pCTransData)
            {
                _pCTransData->PrepareThreadTransfer();

                // addref the pointer here to keep the object alive!
                // 
                _pCTransData->AddRef();
            }
            
            hr = pistm->Write(&dwProcessId, sizeof(DWORD), NULL);
            TransAssert((hr == NOERROR));
            fTransfered = TRUE;
        }
    }

    if (!fTransfered)
    {
        DWORD dwProcessId = 0;
        LPVOID pNull = NULL;
        // marshal also the transaction object
        hr = pistm->Write(&pNull, sizeof(pNull), NULL);
        TransAssert((hr == NOERROR));
        hr = pistm->Write(&pNull, sizeof(pNull), NULL);
        TransAssert((hr == NOERROR));
        hr = pistm->Write(&dwProcessId, sizeof(DWORD), NULL);
        TransAssert((hr == NOERROR));
    }

    PerfDbgLog1(tagCBindCtx, this, "-CBindCtx::MarshalInterface (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBindCtx::UnmarshalInterface
//
//  Synopsis:   Unmarshals an Urlmon interface out of a stream
//
//  Arguments:  [REFIID] --
//              [void] --
//              [ppvObj] --
//
//  Returns:
//
//  History:    9-12-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBindCtx::UnmarshalInterface(IStream *pistm,REFIID riid,void ** ppvObj)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CBindCtx::IMarshal::UnmarshalInterface",
                "this=%#x, %#x, %#x, %#x",
                this, pistm, &riid, ppvObj
                ));
                
    PerfDbgLog(tagCBindCtx, this, "+CBindCtx::UnmarshalInterface");
    HRESULT hr = NOERROR;

    TransAssert(( _dwThreadId == GetCurrentThreadId() ));

    if (ppvObj == NULL)
    {
        hr = E_INVALIDARG;
    }
    else if (! CanMarshalIID(riid))
    {
        *ppvObj = NULL;
        hr = E_NOINTERFACE;
    }
    else
    {
        *ppvObj = NULL;

        hr = CoUnmarshalInterface(pistm, IID_IBindCtx, (void **) &_pbcRem);

        // call QI to get the requested interface
        if (hr == NOERROR)
        {
            hr = QueryInterface(riid, ppvObj);

            {
                HRESULT hr1;
                DWORD dwProcessId;
                // marshal also the transaction object
                hr1 = pistm->Read(&_pCTrans, sizeof(_pCTrans), NULL);
                // Note: pTrans was addref'd as the object was marshaled            // it is now addref'd
                // keep it since we hold on to the object

                if (FAILED(hr1))
                {
                    _pCTrans = 0;
                }

                // marshal also the transdata object
                hr1 = pistm->Read(&_pCTransData, sizeof(_pCTransData), NULL);
                // Note: pTrans was addref'd as the object was marshaled            // it is now addref'd
                // keep it since we hold on to the object
                if (FAILED(hr1))
                {
                    _pCTransData = 0;
                }

                //TransAssert((hr1 == NOERROR));
                hr1 = pistm->Read(&dwProcessId, sizeof(DWORD), NULL);
                TransAssert((hr1 == NOERROR));
                if (FAILED(hr1))
                {
                    dwProcessId = 0;
                }

            }

        }
        else
        {
            TransAssert(( _pbcRem == 0));
        }

    }

    PerfDbgLog1(tagCBindCtx, this, "-CBindCtx::UnmarshalInterface (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

STDMETHODIMP CBindCtx::ReleaseMarshalData(IStream *pStm)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CBindCtx::IMarshal::ReleaseMarshalData",
                "this=%#x, %#x",
                this, pStm
                ));
                
    PerfDbgLog(tagCBindCtx, this, "CBindCtx::ReleaseMarshalData");

    DEBUG_LEAVE(NOERROR);
    return NOERROR;
}

STDMETHODIMP CBindCtx::DisconnectObject(DWORD dwReserved)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CBindCtx::IMarshal::DisconnectObject",
                "this=%#x, %#x",
                this, dwReserved
                ));
                
    PerfDbgLog(tagCBindCtx, this, "CBindCtx::DisconnectObject");

    DEBUG_LEAVE(NOERROR);
    return NOERROR;
}


//+---------------------------------------------------------------------------
//
//  Method:     CBindCtx::SetTransactionObject
//
//  Synopsis:
//
//  Arguments:  [pCTrans] --
//
//  Returns:
//
//  History:    10-09-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBindCtx::SetTransactionObject(CTransaction *pCTrans)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CBindCtx::SetTransactionObject",
                "this=%#x, %#x",
                this, pCTrans
                ));
                
    PerfDbgLog(tagCBindCtx, this, "+CBindCtx::SetTransactionObject");
    //TransAssert(( _dwThreadId == GetCurrentThreadId() ));

    if (pCTrans != _pCTrans)
    {
        if (_pCTrans)
        {
            _pCTrans->Release();
        }
        _pCTrans = pCTrans;
        if (_pCTrans)
        {
            _pCTrans->AddRef();
        }
    }

    PerfDbgLog(tagCBindCtx, this, "-CBindCtx::SetTransactionObject (hr:0)");

    DEBUG_LEAVE(NOERROR);
    return NOERROR;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBindCtx::GetTransactionObject
//
//  Synopsis:
//
//  Arguments:  [ppCTrans] --
//
//  Returns:
//
//  History:    10-09-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBindCtx::GetTransactionObject(CTransaction **ppCTrans)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CBindCtx::GetTransactionObject",
                "this=%#x, %#x",
                this, ppCTrans
                ));
                
    PerfDbgLog(tagCBindCtx, this, "+CBindCtx::GetTransactionObject");
    //TransAssert(( _dwThreadId == GetCurrentThreadId() ));

    HRESULT hr = NOERROR;
    if (_pCTrans)
    {

        *ppCTrans = _pCTrans;
        _pCTrans->AddRef();
    }
    else
    {
        hr = E_NOINTERFACE;
        *ppCTrans = NULL;
    }

    PerfDbgLog1(tagCBindCtx, this, "-CBindCtx::GetTransactionObject (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBindCtx::SetTransactionObjects
//
//  Synopsis:
//
//  Arguments:  [pCTrans] --
//
//  Returns:
//
//  History:    10-09-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBindCtx::SetTransactionObjects(CTransaction *pCTrans,CTransData *pCTransData)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CBindCtx::SetTransactionObjects",
                "this=%#x, %#x, %#x",
                this, pCTrans, pCTransData
                ));
                
    PerfDbgLog(tagCBindCtx, this, "+CBindCtx::SetTransactionObjects");
    //TransAssert(( _dwThreadId == GetCurrentThreadId() ));

    if (pCTrans != _pCTrans)
    {
        if (_pCTrans)
        {
            _pCTrans->Release();
        }
        _pCTrans = pCTrans;
        if (_pCTrans)
        {
            _pCTrans->AddRef();
        }
    }

    if (pCTransData != _pCTransData)
    {
        if (_pCTransData)
        {
            _pCTransData->Release();
        }
        _pCTransData = pCTransData;
        if (_pCTransData)
        {
            _pCTransData->AddRef();
        }
    }

    PerfDbgLog(tagCBindCtx, this, "-CBindCtx::SetTransactionObjects (hr:0)");

    DEBUG_LEAVE(NOERROR);
    return NOERROR;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBindCtx::GetTransactionObject
//
//  Synopsis:
//
//  Arguments:  [ppCTrans] --
//
//  Returns:
//
//  History:    10-09-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBindCtx::GetTransactionObjects(CTransaction **ppCTrans,CTransData **ppCTransData)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CBindCtx::GetTransactionObjects",
                "this=%#x, %#x, %#x",
                this, ppCTrans, ppCTransData
                ));
                
    PerfDbgLog(tagCBindCtx, this, "+CBindCtx::GetTransactionObjects");
    TransAssert(( _dwThreadId == GetCurrentThreadId() ));

    HRESULT hr = NOERROR;
    if (_pCTrans)
    {

        *ppCTrans = _pCTrans;
        _pCTrans->AddRef();
    }
    else
    {
        hr = E_NOINTERFACE;
        *ppCTrans = NULL;
    }

    if (_pCTransData && ppCTransData)
    {

        *ppCTransData = _pCTransData;
        _pCTransData->AddRef();
    }
    else
    {   
        if (!_pCTrans)
        {
            hr = E_NOINTERFACE;
        }
        if (ppCTransData)
        {
            *ppCTransData = NULL;
        }
    }

    PerfDbgLog1(tagCBindCtx, this, "-CBindCtx::GetTransactionObjects (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CBindCtx::SetTransData
//
//  Synopsis:
//
//  Arguments:  [pCTransData] --
//
//  Returns:
//
//  History:    10-09-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBindCtx::SetTransData(CTransData *pCTransData)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CBindCtx::SetTransData",
                "this=%#x, %#x",
                this, pCTransData
                ));
                
    PerfDbgLog(tagCBindCtx, this, "+CBindCtx::SetTransData");
    TransAssert(( _dwThreadId == GetCurrentThreadId() ));

    if (pCTransData != _pCTransData)
    {
        if (_pCTransData)
        {
            _pCTransData->Release();
        }
        _pCTransData = pCTransData;
        if (_pCTransData)
        {
            _pCTransData->AddRef();
        }
    }

    PerfDbgLog(tagCBindCtx, this, "-CBindCtx::SetTransData (hr:0)");

    DEBUG_LEAVE(NOERROR);
    return NOERROR;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBindCtx::GetTransData
//
//  Synopsis:
//
//  Arguments:  [ppCTransData] --
//
//  Returns:
//
//  History:    10-09-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBindCtx::GetTransData(CTransData **ppCTransData)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CBindCtx::GetTransData",
                "this=%#x, %#x",
                this, ppCTransData
                ));
                
    PerfDbgLog(tagCBindCtx, this, "+CBindCtx::GetTransData");
    TransAssert(( _dwThreadId == GetCurrentThreadId() ));

    HRESULT hr = NOERROR;
    if (_pCTransData)
    {

        *ppCTransData = _pCTransData;
        _pCTransData->AddRef();
    }
    else
    {
        hr = E_NOINTERFACE;
        *ppCTransData = NULL;
    }

    PerfDbgLog1(tagCBindCtx, this, "-CBindCtx::GetTransData (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\trans\cdlinfo.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       cdlinfo.cxx
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    02-20-97   t-alans (Alan Shi)   Created
//
//----------------------------------------------------------------------------

#include <trans.h>
#include <objbase.h>
#include <wchar.h>

// AS: ICodeDownloadInfo added to urlmon.idl (local change)
//     modified urlint.h to add SZ_CODEDOWNLOADINFO

//+---------------------------------------------------------------------------
//
//  Method:     CCodeDownloadInfo::CCodeDownloadInfo
//
//  Synopsis:
//
//  Arguments:  
//              
//              
//
//  Returns:
//
//  History:    01-27-1997   t-alans (Alan Shi)   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

CCodeDownloadInfo::CCodeDownloadInfo()
: _szCodeBase( NULL )
, _ulMajorVersion( 0 )
, _ulMinorVersion( 0 )
, _cRefs( 1 )
{
    DEBUG_ENTER((DBG_TRANS,
                None,
                "CCodeDownloadInfo::CCodeDownloadInfo",
                "this=%#x",
                this
                ));

    DEBUG_LEAVE(0);
}

//+---------------------------------------------------------------------------
//
//  Method:     CCodeDownloadInfo::~CCodeDownloadInfo
//
//  Synopsis:
//
//  Arguments:  
//              
//              
//
//  Returns:
//
//  History:    01-27-1997   t-alans (Alan Shi)   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

CCodeDownloadInfo::~CCodeDownloadInfo()
{
    DEBUG_ENTER((DBG_TRANS,
                None,
                "CCodeDownloadInfo::~CCodeDownloadInfo",
                "this=%#x",
                this
                ));
                
    if (_szCodeBase != NULL)
    {
        CoTaskMemFree((void *)_szCodeBase);
        _szCodeBase = NULL;
    }

    DEBUG_LEAVE(0);
}

//+---------------------------------------------------------------------------
//
//  Method:     CCodeDownloadInfo::QueryInterface
//
//  Synopsis:
//
//  Arguments:  
//              
//              
//
//  Returns:
//
//  History:    01-27-1997   t-alans (Alan Shi)   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

STDMETHODIMP CCodeDownloadInfo::QueryInterface(REFIID riid, void **ppvObj)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CCodeDownloadInfo::IUnknown::QueryInterface",
                "this=%#x, %#x, %#x",
                this, &riid, ppvObj
                ));
                
    HRESULT          hr = S_OK;

    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_ICodeDownloadInfo))
    {
        *ppvObj = (void *)this;
        AddRef();
    }
    else
    {
        *ppvObj = NULL;
        hr = E_NOINTERFACE;
    }

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CCodeDownloadInfo::AddRef
//
//  Synopsis:
//
//  Arguments:  
//              
//              
//
//  Returns:
//
//  History:    01-27-1997   t-alans (Alan Shi)   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CCodeDownloadInfo::AddRef(void)
{
    DEBUG_ENTER((DBG_TRANS,
                Dword,
                "CCodeDownloadInfo::IUnknown::AddRef",
                "this=%#x",
                this
                ));
                
    ULONG ulRet = ++_cRefs;

    DEBUG_LEAVE(hr);
    return ulRet;
}

//+---------------------------------------------------------------------------
//
//  Method:     CCodeDownloadInfo::Release
//
//  Synopsis:
//
//  Arguments:  
//              
//              
//
//  Returns:
//
//  History:    01-27-1997   t-alans (Alan Shi)   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CCodeDownloadInfo::Release(void)
{
    DEBUG_ENTER((DBG_TRANS,
                Dword,
                "CCodeDownloadInfo::IUnknown::Release",
                "this=%#x",
                this
                ));
                
    if (!--_cRefs)
    {
        delete this;
    }

    DEBUG_LEAVE(_cRefs);
    return _cRefs;
}

//+---------------------------------------------------------------------------
//
//  Method:     CCodeDownloadInfo::GetCodeBase
//
//  Synopsis:
//
//  Arguments:  
//              
//              
//
//  Returns:
//
//  History:    01-27-1997   t-alans (Alan Shi)   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

STDMETHODIMP CCodeDownloadInfo::GetCodeBase(LPWSTR *szCodeBase)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CCodeDownloadInfo::GetCodeBase",
                "this=%#x, %.80wq",
                this, szCodeBase
                ));
                
    wcscpy(*szCodeBase, _szCodeBase);

    DEBUG_LEAVE(S_OK);
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Method:     CCodeDownloadInfo::SetCodeBase
//
//  Synopsis:
//
//  Arguments:  
//              
//              
//
//  Returns:
//
//  History:    01-27-1997   t-alans (Alan Shi)   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

STDMETHODIMP CCodeDownloadInfo::SetCodeBase(LPCWSTR szCodeBase)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CCodeDownloadInfo::SetCodeBase",
                "this=%#x, %.80wq",
                this, szCodeBase
                ));
                
    HRESULT               hr = E_FAIL;
    long                  lStrlen = 0;
    
    if (_szCodeBase != NULL)
    {
        CoTaskMemFree((void *)_szCodeBase);
        _szCodeBase = NULL;
    }
#ifndef unix
    lStrlen = 2 * (wcslen(szCodeBase) + 1);
#else
    lStrlen =  sizeof(WCHAR) * (wcslen(szCodeBase) + 1);
#endif /* unix */
    _szCodeBase = (LPWSTR)CoTaskMemAlloc(lStrlen);
    hr = (_szCodeBase == NULL) ? (E_OUTOFMEMORY) : (S_OK);
    if (_szCodeBase != NULL)
    {
        wcscpy(_szCodeBase, szCodeBase);
    }

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CCodeDownloadInfo::SetMinorVersion
//
//  Synopsis:
//
//  Arguments:  
//              
//              
//
//  Returns:
//
//  History:    01-27-1997   t-alans (Alan Shi)   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

STDMETHODIMP CCodeDownloadInfo::SetMinorVersion(ULONG ulVersion)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CCodeDownloadInfo::SetMinorVersion",
                "this=%#x, %x",
                this, ulVersion
                ));
                
    _ulMinorVersion = ulVersion;

    DEBUG_LEAVE(S_OK);
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Method:     CCodeDownloadInfo::GetMinorVersion
//
//  Synopsis:
//
//  Arguments:  
//              
//              
//
//  Returns:
//
//  History:    01-27-1997   t-alans (Alan Shi)   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

STDMETHODIMP CCodeDownloadInfo::GetMinorVersion(ULONG *pulVersion)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CCodeDownloadInfo::GetMinorVersion",
                "this=%#x, %#x",
                this, pulVersion
                ));
                
    *pulVersion = _ulMinorVersion;

    DEBUG_LEAVE(S_OK);
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Method:     CCodeDownloadInfo::SetMajorVersion
//
//  Synopsis:
//
//  Arguments:  
//              
//              
//
//  Returns:
//
//  History:    01-27-1997   t-alans (Alan Shi)   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

STDMETHODIMP CCodeDownloadInfo::SetMajorVersion(ULONG ulVersion)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CCodeDownloadInfo::SetMajorVersion",
                "this=%#x, %x",
                this, ulVersion
                ));
                
    _ulMajorVersion = ulVersion;

    DEBUG_LEAVE(S_OK);
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Method:     CCodeDownloadInfo::GetMajorVersion
//
//  Synopsis:
//
//  Arguments:  
//              
//              
//
//  Returns:
//
//  History:    01-27-1997   t-alans (Alan Shi)   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

STDMETHODIMP CCodeDownloadInfo::GetMajorVersion(ULONG *pulVersion)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CCodeDownloadInfo::GetMajorVersion",
                "this=%#x, %#x",
                this, pulVersion
                ));
                
    *pulVersion = _ulMajorVersion;

    DEBUG_LEAVE(S_OK);
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Method:     CCodeDownloadInfo::GetClassID
//
//  Synopsis:
//
//  Arguments:  
//              
//              
//
//  Returns:
//
//  History:    01-27-1997   t-alans (Alan Shi)   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

STDMETHODIMP CCodeDownloadInfo::GetClassID(CLSID *clsid)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CCodeDownloadInfo::GetClassID",
                "this=%#x, %#x",
                this, clsid
                ));
                
    *clsid = _clsid;

    DEBUG_LEAVE(S_OK);
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Method:     CCodeDownloadInfo::SetClassID
//
//  Synopsis:
//
//  Arguments:  
//              
//              
//
//  Returns:
//
//  History:    01-27-1997   t-alans (Alan Shi)   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

STDMETHODIMP CCodeDownloadInfo::SetClassID(CLSID clsid)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CCodeDownloadInfo::SetClassID",
                "this=%#x, %#x",
                this, &clsid
                ));
                
    _clsid = clsid;

    DEBUG_LEAVE(S_OK);
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\trans\cnetstrm.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       cnetstrm.cxx
//
//  Contents:   Implements the stream: protocol
//
//  Classes:    CINetStream
//
//  Functions:
//
//  History:    5/3/96 Created Craig Critchley [craigc]
//
//----------------------------------------------------------------------------
#include <trans.h>


//+---------------------------------------------------------------------------
//
//  Method:     CINetStream::CINetStream
//
//  Synopsis:   Constructs a stream protcol object
//
//  Arguments:  rclsid
//
//  Returns:
//
//  History:    5/3/96 Created Craig Critchley [craigc]
//
//  Notes:
//
//----------------------------------------------------------------------------
CINetStream::CINetStream(REFCLSID rclsid, IUnknown *pUnkOuter) : CINet(rclsid,pUnkOuter)
{
    DEBUG_ENTER((DBG_TRANS,
                None,
                "CINetStream::CINetStream",
                "this=%#x, %#x, %#x",
                this, &rclsid, pUnkOuter
                ));
                
   _dwIsA = DLD_PROTOCOL_STREAM;
   _pstm = NULL;

   DEBUG_LEAVE(0);
}

//+---------------------------------------------------------------------------
//
//  Method:     CINetStream::~CINetStream
//
//  Synopsis:   destroys a stream protocol object
//
//  Arguments:
//
//  Returns:
//
//  History:    5/3/96 Created Craig Critchley [craigc]
//
//  Notes:
//
//----------------------------------------------------------------------------
CINetStream::~CINetStream()
{
    DEBUG_ENTER((DBG_TRANS,
                None,
                "CINetStream::~CINetStream",
                "this=%#x",
                this
                ));
                
    if (_pstm)
    {
        _pstm->Release();
    }

    DEBUG_LEAVE(0);
}

//+---------------------------------------------------------------------------
//
//  Method:     CINetStream::INetAsyncOpen
//
//  Synopsis:   opens and synchronously downloads data from a stream
//
//  Arguments:  rclsid
//
//  Returns:
//
//  History:    5/3/96 Created Craig Critchley [craigc]
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINetStream::INetAsyncOpen()
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CINetStream::INetAsyncOpen",
                "this=%#x",
                this
                ));
                
   IBindCtx * pbc = 0;
   IMoniker * pmk = 0;
   IStream * pstm = 0;
   IParseDisplayName * pParser = 0;
   STATSTG stat;
   CLSID clsid;
   CHAR szDisplayName[MAX_PATH];
   WCHAR wzDisplayName[MAX_PATH];
   WCHAR wzProgId[MAX_PATH];
   LPSTR pa, psz;
   LPWSTR pwz, pwzI;
   int cch;
   HRESULT hr = E_NOTIMPL;
   ULONG cchE;
   BOOL fGotMIMEType = FALSE;

   ReportNotification(BINDSTATUS_SENDINGREQUEST);

   // need one of these
   //
   if (FAILED(hr = CreateBindCtx(0,&pbc)))
      goto End;

   //   form is mk:@progid:moniker
   //
   strcpy(szDisplayName,GetServerName());
   strcat(szDisplayName,psz = GetObjectName());

   // if the moniker has a file extension, try to
   // determine the MIME type that way...
   //
   psz = FindFileExtension(psz);
   if (psz)
   {
       char szMime[MAX_PATH];
       DWORD cb = MAX_PATH;

       if (SUCCEEDED(GetMimeFromExt(psz,szMime,&cb)))
       {
           ReportNotification(BINDSTATUS_MIMETYPEAVAILABLE, szMime);
           fGotMIMEType = TRUE;
       }
   }

   A2W(szDisplayName,wzDisplayName,MAX_PATH);

   //   find progid
   //
   for (pwz = wzDisplayName, pwzI = wzProgId; *pwz; pwz++)
   {
       if (*pwz == '@')
       {
           pwzI = wzProgId;
       }
       else if (*pwz == ':')
       {
           *pwzI = 0;

           // the remainder may have a filename with a useful
           // extension... just in case, set the filename...
           //
           LPSTR pszStr = DupW2A(pwz+1);
           if (pszStr)
           {
               ReportNotification(BINDSTATUS_CACHEFILENAMEAVAILABLE, pszStr);
               delete pszStr;
           }

           break;
       }
       else
       {
           *pwzI++ = *pwz;
       }
   }

#if 0
   if (FAILED(hr = MkParseDisplayName(pbc,wzDisplayName,&cchE,&pmk)) && pmk)
       goto End;
#else
   // BUGBUG
   //
   //   MkParseDisplayName was opening another instance of app
   //   force inproc server.  ick.
   //

   if (FAILED(hr = CLSIDFromProgID(wzProgId,&clsid)))
   {
       goto End;
   }

   if (FAILED(hr = CoCreateInstance(clsid,0,CLSCTX_INPROC_SERVER,
                                    IID_IParseDisplayName,(void**)&pParser)))
   {
       goto End;
   }

   TransAssert((pParser));

   if (FAILED(hr = pParser->ParseDisplayName(pbc,wzDisplayName,&cchE,&pmk)))
   {
       goto End;
   }

   TransAssert((pmk));

#endif

   if (FAILED(hr = pmk->BindToStorage(pbc,0,IID_IStream,(void**)&pstm)))
   {
      hr = INET_E_RESOURCE_NOT_FOUND;
      goto End;
   }

   TransAssert((hr != MK_S_ASYNCHRONOUS));
   TransAssert((pstm));

   _pstm = pstm;
   _pstm->AddRef();

   // now we have a stream - stuff it into the trans data
   //
   if (FAILED(hr = pstm->Stat(&stat,STATFLAG_NONAME)))
   {
       goto End;
   }

   _cbTotalBytesRead = stat.cbSize.LowPart;
   _cbDataSize = stat.cbSize.LowPart;

   hr = _pCTrans->ReportData(BSCF_FIRSTDATANOTIFICATION | BSCF_LASTDATANOTIFICATION, stat.cbSize.LowPart,stat.cbSize.LowPart);

   _hrError = INET_E_DONE;

End:

   if (FAILED(hr))
   {
        SetCNetBindResult(GetLastError());
        _hrError = INET_E_RESOURCE_NOT_FOUND;
        ReportResultAndStop(_hrError);
   }

   // play nice, no leaks
   //
   if (pParser)
   {
      pParser->Release();
   }

   if (pmk)
   {
      pmk->Release();
   }
   if (pbc)
   {
      pbc->Release();
   }
   if (pstm)
   {
      pstm->Release();
   }

   // make sure I set this any way I get out
   //
   TransAssert((hr != E_NOTIMPL));

   DEBUG_LEAVE(hr);
   return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINetStream::ReadDataHere
//
//  Synopsis:
//
//  Arguments:  [pBuffer] --
//              [cbBytes] --
//              [pcbBytes] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINetStream::ReadDataHere(BYTE *pBuffer, DWORD cbBytes, DWORD *pcbBytes)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CINetStream::ReadDataHere",
                "this=%#x, %#x, %#x, %#x",
                this, pBuffer, cbBytes, pcbBytes
                ));
            
    TransDebugOut((DEB_PROT, "%p _IN CINetStream::ReadDataHere\n", this));
    HRESULT hr = E_FAIL;

    TransAssert((cbBytes && pcbBytes));


    if (_pstm)
    {
        hr = _pstm->Read(pBuffer,cbBytes,pcbBytes);
    }

    TransDebugOut((DEB_PROT, "%p OUT CINetStream::ReadDataHere (_hrError:%lx, [hr:%lx,cbBytesAsked:%ld,cbBytesReturned:%ld]) \n",
                                this, _hrError, hr, cbBytes, *pcbBytes));

    DEBUG_LEAVE(hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CINetStream::INetSeek
//
//  Synopsis:
//
//  Arguments:  [DWORD] --
//              [ULARGE_INTEGER] --
//              [plibNewPosition] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINetStream::INetSeek(LARGE_INTEGER dlibMove,DWORD dwOrigin,ULARGE_INTEGER *plibNewPosition)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CINetStream::INetSeek",
                "this=%#x, %#x, %#x, %#x",
                this, dlibMove, dwOrigin, plibNewPosition
                ));
                
    TransDebugOut((DEB_PROT, "%p _IN CINetStream::INetSeek\n", this));
    HRESULT hr = E_FAIL;

    if (_pstm)
    {
        hr = _pstm->Seek(dlibMove, dwOrigin, plibNewPosition);
    }

    TransDebugOut((DEB_PROT, "%p OUT CINetStream::INetSeek (hr:%lx) \n",this, hr));

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINetStream::LockFile
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  History:    8-13-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINetStream::LockFile(BOOL fRetrieve)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CINetStream::LockFile",
                "this=%#x, %B",
                this, fRetrieve
                ));
                
    TransDebugOut((DEB_PROT, "%p _IN CINetStream::LockFile\n", this));
    HRESULT hr = NOERROR;

    // nothing to do for now

    TransDebugOut((DEB_PROT,"%p OUT CINetStream::LockFile (hr:%lx)\n",this, hr));

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINetStream::UnlockFile
//
//  Synopsis:   unlocks the file
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    8-13-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINetStream::UnlockFile()
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CINetStream::UnlockFile",
                "this=%#x",
                this
                ));
                
    TransDebugOut((DEB_PROT, "%p IN CINetStream::UnlockFile\n", this));
    HRESULT hr = NOERROR;

    // nothing to do for now

    TransDebugOut((DEB_PROT,"%p OUT CINetStream::UnlockFile (hr:%lx)\n", this, hr));

    DEBUG_LEAVE(hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\trans\datasnif.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       datasnif.cxx
//
//  Contents:   Stream Mime type checking (attempts to guess the MIME type
//              of a buffer by simple pattern matching).
//
//  Classes:    CContentAnalyzer
//
//  Functions:  private:
//                CContentAnalyzer::SampleData
//                CContentAnalyzer::IsBMP
//                CContentAnalyzer::GetDataFormat
//                CContentAnalyzer::FormatAgreesWithData
//                CContentAnalyzer::MatchDWordAtOffset
//                CContentAnalyzer::FindAppFromExt
//                CContentAnalyzer::CheckTextHeaders
//                CContentAnalyzer::CheckBinaryHeaders
//
//              public:
//                CContentAnalyzer::FindMimeFromData
//                ::FindMimeFromData
//
//
//  History:    05-25-96   AdriaanC (Adriaan Canter) Created
//              07-16-96   AdriaanC (Adriaan Canter) Modified
//              08-06-96   AdriaanC (Adriaan Canter) Modified
//              08-14-96   AdriaanC (Adriaan Canter) Modified
//
//----------------------------------------------------------------------------

#include <trans.h>
#include "datasnif.hxx"
#include <shlwapip.h>
#ifdef UNIX
#include <mainwin.h>
#endif

PerfDbgTag(tagDataSniff, "Urlmon", "Log DataSniff", DEB_DATA);

// Max no. bytes to look at
#define SAMPLE_SIZE 256

// Registry Key for app/fileext associations
#define szApplicationRegistryKey "\\Shell\\Open\\Command"
#define szApplicationRegistryKey2 "\\Shell\\Connect To\\Command"
#define szMimeRegistryKey        "MIME\\Database\\Content Type\\"

// Magic header words
#define AU_SUN_MAGIC                    0x2e736e64
#define AU_SUN_INV_MAGIC                0x646e732e
#define AU_DEC_MAGIC                    0x2e736400
#define AU_DEC_INV_MAGIC                0x0064732e
#define AIFF_MAGIC                      0x464f524d
#define AIFF_INV_MAGIC                  0x4d524f46
#define AIFF_MAGIC_MORE_1               'AIFF'
#define AIFF_MAGIC_MORE_2               'AIFC'
#define RIFF_MAGIC                      0x52494646
#define AVI_MAGIC                       0x41564920
#define WAV_MAGIC                       0x57415645
#define JAVA_MAGIC                      0xcafebabe
#define MPEG_MAGIC                      0x000001b3
#define MPEG_MAGIC_2                    0x000001ba
#define EMF_MAGIC_1                     0x01000000
#define EMF_MAGIC_2                     0x20454d46
#define WMF_MAGIC                       0xd7cdc69a
#define JPEG_MAGIC_1                    0xFF
#define JPEG_MAGIC_2                    0xD8

// Magic header text
CHAR vszRichTextMagic[] =                "{\\rtf";
CHAR vszPostscriptMagic[] =              "%!";
CHAR vszBinHexMagic[] =                  "onverted with BinHex";
CHAR vszBase64Magic[] =                  "begin";
CHAR vszGif87Magic[] =                   "GIF87";
CHAR vszGif89Magic[] =                   "GIF89";
CHAR vszTiffMagic[] =                    "MM";
CHAR vszBmpMagic[] =                     "BM";
CHAR vszZipMagic[] =                     "PK";
CHAR vszExeMagic[] =                     "MZ";
CHAR vszPngMagic[] =                     "\211PNG\r\n\032\n";
CHAR vszCompressMagic[] =                "\037\235";
CHAR vszGzipMagic[] =                    "\037\213";
CHAR vszXbmMagic1[] =                    "define";
CHAR vszXbmMagic2[] =                    "width";
CHAR vszXbmMagic3[] =                    "bits";
CHAR vszPdfMagic[] =                     "%PDF";
CHAR vszJGMagic[] =                      "JG";
CHAR vszMIDMagic[] =                     "MThd";

// null MIME type
WCHAR vwzNULL[] =                        L"(null)";

// 7 bit MIME Types
WCHAR vwzTextPlain[] =                   L"text/plain";
WCHAR vwzTextRichText[] =                L"text/richtext";
WCHAR vwzImageXBitmap[] =                L"image/x-xbitmap";
WCHAR vwzApplicationPostscript[] =       L"application/postscript";
WCHAR vwzApplicationBase64[] =           L"application/base64";
WCHAR vwzApplicationMacBinhex[] =        L"application/macbinhex40";
WCHAR vwzApplicationPdf[] =              L"application/pdf";
WCHAR vwzApplicationCDF[] =              L"application/x-cdf";
WCHAR vwzApplicationNETCDF[] =           L"application/x-netcdf";
WCHAR vwzmultipartmixedreplace[] =       L"multipart/x-mixed-replace";
WCHAR vwzmultipartmixed[] =              L"multipart/mixed";
WCHAR vwzTextScriptlet[] =               L"text/scriptlet";
WCHAR vwzTextComponent[] =               L"text/x-component";
WCHAR vwzTextXML[] =                     L"text/xml";
WCHAR vwzApplicationHTA[] =              L"application/hta";

// 8 bit MIME types
WCHAR vwzAudioAiff[] =                   L"audio/x-aiff";
WCHAR vwzAudioBasic[] =                  L"audio/basic";
WCHAR vwzAudioWav[] =                    L"audio/wav";
WCHAR vwzAudioMID[] =                    L"audio/mid";
WCHAR vwzImageGif[] =                    L"image/gif";
WCHAR vwzImagePJpeg[] =                  L"image/pjpeg";
WCHAR vwzImageJpeg[] =                   L"image/jpeg";
WCHAR vwzImageTiff[] =                   L"image/tiff";
WCHAR vwzImagePng[] =                    L"image/x-png";
WCHAR vwzImageBmp[] =                    L"image/bmp";
WCHAR vwzImageJG[] =                     L"image/x-jg";
WCHAR vwzImageEmf[] =                    L"image/x-emf";
WCHAR vwzImageWmf[] =                    L"image/x-wmf";
WCHAR vwzVideoAvi[] =                    L"video/avi";
WCHAR vwzVideoMpeg[] =                   L"video/mpeg";
WCHAR vwzApplicationCompressed[] =       L"application/x-compressed";
WCHAR vwzApplicationZipCompressed[] =    L"application/x-zip-compressed";
WCHAR vwzApplicationGzipCompressed[] =   L"application/x-gzip-compressed";
WCHAR vwzApplicationJava[] =             L"application/java";
WCHAR vwzApplicationMSDownload[] =       L"application/x-msdownload";

// 7 or 8 bit MIME types
WCHAR vwzTextHTML[] =                    L"text/html";
WCHAR vwzApplicationOctetStream[] =      L"application/octet-stream";




//+---------------------------------------------------------------------------
//
//  Method:     CContentAnalyzer::SampleData
//
//  Synopsis:
//
//  Arguments:  (void)
//
//  Returns:    (void)
//
//  History:    5-25-96   AdriaanC (Adriaan Canter) Created
//
//  Notes:
//
//----------------------------------------------------------------------------
void CContentAnalyzer::SampleData()
{
    DEBUG_ENTER((DBG_TRANS,
                None,
                "CContentAnalyzer::SampleData",
                "this=%#x",
                this
                ));
                
    BOOL fFoundFirstXBitMapTag = FALSE;
    BOOL fFoundSecondXBitMapTag = FALSE;
    BOOL fFoundAsciiChar = FALSE;

    int nHTMLConfidence = 0;

    unsigned char *p = (unsigned char*) _pBuf;

    _cbNL = _cbCR = _cbFF = _cbText = _cbCtrl = _cbHigh = 0;

    // Count incidence of character types.
    for (int i = 0; i < _cbSample - 1; i++)
    {
        fFoundAsciiChar = FALSE;

        if (*p == '\n')           // new line
        {
            _cbNL++;
        }
        else if (*p == '\r')      // carriage return
        {
            _cbCR++;
        }
        else if (*p == '\f')      // form feed
        {
            _cbFF++;
        }
        else if (*p == '\t')      // tab
        {
            _cbText++;
        }
        else if (*p < 32)         // control character
        {
            _cbCtrl++;
        }
        else if (*p >= 32 && *p < 128)        // regular text
        {
            _cbText++;
            fFoundAsciiChar = TRUE;
        }
        else                      // extended text
        {
            _cbHigh++;
        }

        if (fFoundAsciiChar)
        {
            // check for html
            if (*p == '<')
            {
                if (!StrCmpNIC((char*) p+1, "?XML", sizeof("?XML") - 1) &&
                    (
                        (*(p+5) == ':') || 
                        (*(p+5) == ' ') || 
                        (*(p+5) == '\t')) )
                {
                    _fFoundXML = TRUE;
                    // don't break : for CDF
                }
                

                if (!StrCmpNIC((char*) p+1, "SCRIPTLET", sizeof("SCRIPTLET") - 1))
                {
                    _fFoundTextScriptlet = TRUE;
                    break;
                }

                if (!StrCmpNIC((char*) p+1, "HTML", sizeof("HTML") - 1)
                    || !StrCmpNIC((char*) p+1, "HEAD", sizeof("HEAD") - 1)
                    || !StrCmpNIC((char*) p+1, "TITLE", sizeof("TITLE") - 1)
                    || !StrCmpNIC((char*) p+1, "BODY", sizeof("BODY") - 1)
                    || !StrCmpNIC((char*) p+1, "SCRIPT", sizeof("SCRIPT") - 1)
                    || !StrCmpNIC((char*) p+1, "A HREF", sizeof("A HREF") - 1)
                    || !StrCmpNIC((char*) p+1, "PRE", sizeof("PRE") - 1)
                    || !StrCmpNIC((char*) p+1, "IMG", sizeof("IMG") - 1)
                    || !StrCmpNIC((char*) p+1, "PLAINTEXT", sizeof("PLAINTEXT") - 1)
                    || !StrCmpNIC((char*) p+1, "TABLE", sizeof("TABLE") - 1))
                {
                    _fFoundHTML = TRUE;
                    break;
                }
                else if (   !StrCmpNIC((char*) p+1, "HR", sizeof("HR") - 1)
                         || !StrCmpNIC((char*) p+1, "A", sizeof("A") - 1)
                         || !StrCmpNIC((char*) p+1, "/A", sizeof("/A") - 1)
                         || !StrCmpNIC((char*) p+1, "B", sizeof("B") - 1)
                         || !StrCmpNIC((char*) p+1, "/B", sizeof("/B") - 1)
                         || !StrCmpNIC((char*) p+1, "P", sizeof("P") - 1)
                         || !StrCmpNIC((char*) p+1, "/P", sizeof("/P") - 1)
                         || !StrCmpNIC((char*) p+1, "!--", sizeof("!--") - 1)
                        )
                {
                    //
                    // In order for this branch to identify this is HTML 
                    // We have to make sure:
                    //      1. some HTML control char exists
                    //      2. We've scanned the whole data block
                    //      3. 2/3 of the data should be text
                    //
                     
                    nHTMLConfidence += 50;
                    if (    nHTMLConfidence >= 100
                        &&  i == _cbSample - 1 
                        &&  _cbText >= ((_cbSample * 2) / 3)
                       )
                    {
                        _fFoundHTML = TRUE;
                        break;
                    }
                }
                if (!StrCmpNIC((char*) p+1, "CHANNEL", sizeof("CHANNEL") - 1))
                {
                    _fFoundCDF = TRUE;
                    break;
                }
        
            
            }
            else if (!StrCmpNIC((char*) p, "-->", sizeof("-->") - 1))
            {
                // comment begin
                // I really want to make sure that most of the 
                // char are printable 
                // potential issue: International code page?
                nHTMLConfidence += 50;
                if (   (nHTMLConfidence >= 100) 
                    && (i == _cbSample - 1 )
                    && (_cbText > (_cbSample * 2 /3) )
                   )
                {
                    _fFoundHTML = TRUE;
                    break;
                }
            }
            // check for xbitmap
            else if (*p == '#')
            {
                if (!StrCmpNC((char*) p+1, vszXbmMagic1, sizeof(vszXbmMagic1) - 1))
                    fFoundFirstXBitMapTag = TRUE;
            }
            else if (*p == '_' && fFoundSecondXBitMapTag)
            {
                if (!StrCmpNC((char*) p+1, vszXbmMagic3, sizeof(vszXbmMagic3) - 1))
                {
                    _fFoundXBitMap = TRUE;
                    break;
                }
            }
            else if (*p == '_' && fFoundFirstXBitMapTag)
            {
                if (!StrCmpNC((char*) p+1, vszXbmMagic2, sizeof(vszXbmMagic2) - 1))
                    fFoundSecondXBitMapTag = TRUE;
            }

            // MacBinhex
            else if (*p == 'c')
            {
                if (!StrCmpNC((char*) p+1, vszBinHexMagic, sizeof(vszBinHexMagic) - 1))
                {
                    _fFoundMacBinhex = TRUE;
                    break;
                }
            }

        }
        p++;
    }

    DEBUG_LEAVE(0);
}

//+---------------------------------------------------------------------------
//
//  Method:     CContentAnalyzer::IsBMP
//
//  Synopsis:
//
//  Arguments:  (void)
//
//  Returns:    BOOL
//
//  History:    5-25-96   AdriaanC (Adriaan Canter) Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL CContentAnalyzer::IsBMP()
{
    DEBUG_ENTER((DBG_TRANS,
                Bool,
                "CContentAnalyzer::IsBMP",
                "this=%#x",
                this
                ));
                
    BOOL bRetVal = TRUE;

    BITMAPFILEHEADER UNALIGNED *pBMFileHdr;

    if (_cbSample < 2)
    {
        bRetVal = FALSE;
    }

    // Check header
    if (StrCmpNC(_pBuf, vszBmpMagic, sizeof(vszBmpMagic) - 1))
    {
        bRetVal = FALSE;
    }

    // Sample size needs to be big enough.
    if (_cbSample < sizeof(BITMAPFILEHEADER))
    {
        bRetVal = FALSE;
    }

    pBMFileHdr = (BITMAPFILEHEADER*)(_pBuf);

#ifdef UNIX

    /* Use 14 on Unix, because we want the size without the padding
     * done on Unix. sizeof(BITMAPFILEHEADER) = 16 on Unix with padding
     */
    #define UNIX_BITMAP_HEADER_SIZE 14
    BITMAPFILEHEADER bmFileHeader;

    if(MwReadBITMAPFILEHEADER((LPBYTE)_pBuf, UNIX_BITMAP_HEADER_SIZE, &bmFileHeader))
        pBMFileHdr = &bmFileHeader;

#endif /* UNIX */

    // The reserved fields must be set to 0
    if (pBMFileHdr->bfReserved1!=0 || pBMFileHdr->bfReserved2!=0)
    {
        bRetVal = FALSE;
    }

    DEBUG_LEAVE(bRetVal);
    return bRetVal;
}

//+---------------------------------------------------------------------------
//
//  Method:     CContentAnalyzer::GetDataFormat
//
//  Synopsis:
//
//  Arguments:  (WCHAR* wzMimeType)
//
//  Returns:    BOOL dwDataFormat
//
//  History:    7-21-96   AdriaanC (Adriaan Canter) Created
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD CContentAnalyzer::GetDataFormat(LPCWSTR wzMimeType)
{
    DEBUG_ENTER((DBG_TRANS,
                Dword,
                "CContentAnalyzer::GetDataFormat",
                "this=%#x, %.80wq",
                this, wzMimeType
                ));
                
    CLIPFORMAT cfFormat;
    DATAFORMAT dwDataFormat;
    HRESULT hr;

    if (!wzMimeType)
    {
        DEBUG_LEAVE(DATAFORMAT_AMBIGUOUS);
        return DATAFORMAT_AMBIGUOUS;
    }

    if( !_wcsicmp(wzMimeType, vwzNULL) )
    {
        DEBUG_LEAVE(DATAFORMAT_AMBIGUOUS);
        return DATAFORMAT_AMBIGUOUS;
    }


    hr = FindMediaTypeFormat(wzMimeType, &cfFormat, (DWORD *)&dwDataFormat);

    if (hr == S_OK)
    {
        DEBUG_LEAVE(dwDataFormat);
        return dwDataFormat;
    }
    else
    {
        DEBUG_LEAVE(DATAFORMAT_UNKNOWN);
        return DATAFORMAT_UNKNOWN;
    }

}

//+---------------------------------------------------------------------------
//
//  Method:     CContentAnalyzer::FormatAgreesWithData
//
//  Synopsis:
//
//  Arguments:  (void)
//
//  Returns:    BOOL
//
//  History:    8-14-96   AdriaanC (Adriaan Canter) Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL CContentAnalyzer::FormatAgreesWithData(DWORD dwFormat)
{
    DEBUG_ENTER((DBG_TRANS,
                Bool,
                "CContentAnalyzer::FormatAgreesWithData",
                "this=%#x, %#x",
                this, dwFormat
                ));
                
    if (dwFormat == DATAFORMAT_TEXT && _fBinary == FALSE
        || dwFormat == DATAFORMAT_BINARY && _fBinary == TRUE
        || dwFormat == DATAFORMAT_TEXTORBINARY)
    {
        DEBUG_LEAVE(TRUE);
        return TRUE;
    }

    DEBUG_LEAVE(FALSE);
    return FALSE;
}


//+---------------------------------------------------------------------------
//
//  Method:     CContentAnalyzer::MatchDWordAtOffset
//
//  Synopsis:   Determines if a given magic word is found at
//              the specified offset.
//
//  Arguments:  (DWORD magic, int offset)
//
//  Returns:    BOOL
//
//  History:    5-25-96   AdriaanC (Adriaan Canter) Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL CContentAnalyzer::MatchDWordAtOffset(DWORD magic, int offset)
{
    DEBUG_ENTER((DBG_TRANS,
                Bool,
                "CContentAnalyzer::MatchDWordAtOffset",
                "this=%#x, %#x, %d",
                this, magic, offset
                ));
                
    BOOL bRetVal = TRUE;

    DWORD dwWord = 0;

    unsigned char* p = (unsigned char*) _pBuf;

    if (_cbSample < offset + (int) sizeof(DWORD))
    {
        DEBUG_LEAVE(FALSE);
        return FALSE;
    }

    dwWord = (p[offset] << 24)
        | (p[offset+1] << 16)
        | (p[offset+2] << 8)
        |  p[offset+3];


    if (magic != dwWord)
    {
        bRetVal = FALSE;
    }

    DEBUG_LEAVE(bRetVal);
    return bRetVal;
}


//+---------------------------------------------------------------------------
//
//  Method:     CContentAnalyzer::FindAppFromExt
//
//  Synopsis:   Determines an associated application from
//              a given file extension
//
//  Arguments:  (LPSTR pszExt, LPSTR pszCommand (command line))
//
//  Returns:    BOOL (Associated Application is found or not)
//
//  History:    7-15-96   AdriaanC (Adriaan Canter) Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL CContentAnalyzer::FindAppFromExt(LPSTR pszExt, LPSTR pszCommand, DWORD cbCommand)
{
    DEBUG_ENTER((DBG_TRANS,
                Bool,
                "CContentAnalyzer::FindAppFromExt",
                "this=%#x, %.80q, %.80q, %d",
                this, pszExt, pszCommand, cbCommand
                ));
                
    DWORD cbLen, dwType;
    CHAR szRegPath[MAX_PATH];
    BOOL fReturn = FALSE;
    HKEY hMimeKey = NULL;

    // BUGBUG - Is there a max registry path length?
    cbLen = MAX_PATH;

    // Should be a file extension
    TransAssert((pszExt[0] == '.'));

    // Open key on extension
    if (RegOpenKeyEx(HKEY_CLASSES_ROOT, pszExt, 0,
        KEY_QUERY_VALUE, &hMimeKey) == ERROR_SUCCESS)
    {
        // Find file type (txtfile, htmlfile, etc) .
        // These currently utilize a null key.
        if (RegQueryValueEx(hMimeKey, NULL, NULL, &dwType,
            (LPBYTE)szRegPath, &cbLen) == ERROR_SUCCESS)
        {
            strncat(szRegPath, szApplicationRegistryKey, MAX_PATH - strlen(szRegPath) - 1);

            HKEY hAppKey = NULL;
            cbLen = cbCommand;

            // szRegPath should now look similar to
            // "txtfile\Shell\Open\Command". Open key on szRegPath
            if (RegOpenKeyEx(HKEY_CLASSES_ROOT, szRegPath, 0,
                KEY_QUERY_VALUE, &hAppKey) == ERROR_SUCCESS) 
            {
                // Find the application command line - again, null key.
                if (RegQueryValueEx(hMimeKey, NULL, NULL, &dwType,
                    (LPBYTE)pszCommand, &cbLen) == ERROR_SUCCESS)
                {
                    // Success
                    fReturn = TRUE;
                }
                RegCloseKey(hAppKey);
            }

            else 
            {   
                // check "Shell\\Connect To\command" key - used by SmartTerm 

                // dynamic allocate szRegPath2 so that it won't take
                // unnecessary stack space - after all, this is not a 
                // common case
                CHAR* szRegPath2 = NULL;
                HKEY hAppKey2 = NULL;

                szRegPath2 = new CHAR[MAX_PATH];
                if( szRegPath2 )
                {
                    if (RegQueryValueEx(hMimeKey, NULL, NULL, &dwType,
                        (LPBYTE)szRegPath2, &cbLen) == ERROR_SUCCESS)
                    {
                        strncat(szRegPath2, szApplicationRegistryKey2, 
                            MAX_PATH - strlen(szRegPath2) - 1);
                    }
                    else
                    {
                        // this should not happen at all 
                        delete [] szRegPath2;
                        szRegPath2 = NULL;
                    }
                }

                if (szRegPath2 && 
                    RegOpenKeyEx(HKEY_CLASSES_ROOT, szRegPath2, 0, KEY_QUERY_VALUE, &hAppKey2) == ERROR_SUCCESS) 
                {
                    if (RegQueryValueEx(hMimeKey, NULL, NULL, &dwType,
                        (LPBYTE)pszCommand, &cbLen) == ERROR_SUCCESS)
                    {
                        // Success
                        fReturn = TRUE;
                    }
                    RegCloseKey(hAppKey2);

                }

                delete [] szRegPath2;
            }

        }
        RegCloseKey(hMimeKey);
    }

    DEBUG_LEAVE(fReturn);
    return fReturn;
}
//+---------------------------------------------------------------------------
//
//  Method:     CContentAnalyzer::CheckTextHeaders
//
//  Synopsis:
//
//
//  Arguments:  void
//
//  Returns:    void
//
//  History:    7-23-96   AdriaanC (Adriaan Canter) Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL CContentAnalyzer::CheckTextHeaders()
{
    DEBUG_ENTER((DBG_TRANS,
                Bool,
                "CContentAnalyzer::CheckTextHeaders",
                "this=%#x",
                this
                ));
                
    BOOL bRet = TRUE;
    // application/pdf (Acrobat)
    if (!StrCmpNC(_pBuf, vszPdfMagic, sizeof(vszPdfMagic) - 1))
    {
        _wzMimeType = vwzApplicationPdf;
    }

    // application/Postscript
    else if (!StrCmpNC(_pBuf, vszPostscriptMagic, sizeof(vszPostscriptMagic) - 1))
    {
        _wzMimeType = vwzApplicationPostscript;
    }

    // text/richtext
    else if (!StrCmpNC(_pBuf, vszRichTextMagic, sizeof(vszRichTextMagic) - 1))
    {
        _wzMimeType = vwzTextRichText;
    }

    // application/base64
    else if (!StrCmpNC(_pBuf, vszBase64Magic, sizeof(vszBase64Magic) - 1))
    {
        _wzMimeType = vwzApplicationBase64;
    }

    // No matches - assume plain text.
    else
    {
        //_wzMimeType = vwzTextPlain;
        bRet = FALSE;
    }

    DEBUG_LEAVE(bRet);
    return bRet;

}

//+---------------------------------------------------------------------------
//
//  Method:     CContentAnalyzer::CheckBinaryHeaders
//
//  Synopsis:
//
//
//  Arguments:  void
//
//  Returns:    void
//
//  History:    7-23-96   AdriaanC (Adriaan Canter) Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL CContentAnalyzer::CheckBinaryHeaders()
{
    DEBUG_ENTER((DBG_TRANS,
                Bool,
                "CContentAnalyzer::CheckBinaryHeaders",
                "this=%#x",
                this
                ));
                
    BOOL bRet = TRUE;
    // image/gif
    if (!StrCmpNIC(_pBuf, vszGif87Magic, sizeof(vszGif87Magic) - 1)
        || !StrCmpNIC(_pBuf, vszGif89Magic, sizeof(vszGif89Magic) - 1))
    {
        _wzMimeType = vwzImageGif;
    }

    // image/pjpeg
    else if ((BYTE)_pBuf[0] == JPEG_MAGIC_1 && (BYTE)_pBuf[1] == JPEG_MAGIC_2)
    {
        _wzMimeType = vwzImagePJpeg;
    }

    // img/bmp
    else if (IsBMP())
    {
        _wzMimeType = vwzImageBmp;
    }

    // audio/wav
    else if (MatchDWordAtOffset(RIFF_MAGIC, 0)
        && MatchDWordAtOffset(WAV_MAGIC, 8))
    {
        _wzMimeType = vwzAudioWav;
    }

    // audio/basic (.au files)
    else if (MatchDWordAtOffset(AU_DEC_MAGIC, 0)
           || MatchDWordAtOffset(AU_SUN_MAGIC, 0)
           || MatchDWordAtOffset(AU_DEC_INV_MAGIC, 0)
           || MatchDWordAtOffset(AU_SUN_INV_MAGIC, 0))
    {
       _wzMimeType = vwzAudioBasic;
    }

    // image/tiff
    else if (!StrCmpC(_pBuf, vszTiffMagic)) // "MM" followed by a \0
    {
        _wzMimeType = vwzImageTiff;
    }

    // application/x-msdownload
    else if (!StrCmpNC(_pBuf, vszExeMagic, sizeof(vszExeMagic) - 1))
    {
        _wzMimeType = vwzApplicationMSDownload;
    }

    // image/x-png
    else if (!StrCmpNC(_pBuf, vszPngMagic, sizeof(vszPngMagic) - 1))
    {
        _wzMimeType = vwzImagePng;
    }

    // image/x-jg
    else if (!StrCmpNC(_pBuf, vszJGMagic, sizeof(vszJGMagic) - 1)
        && (int) _pBuf[2] >= 3
        && (int) _pBuf[2] <= 31
        && _pBuf[4] == 0)
    {
        _wzMimeType = vwzImageJG;
    }

    // audio/x-aiff
    else if (MatchDWordAtOffset(AIFF_INV_MAGIC, 0))
    {
       _wzMimeType = vwzAudioAiff;
    }

    else if (MatchDWordAtOffset(AIFF_MAGIC, 0) &&
             ( MatchDWordAtOffset(AIFF_MAGIC_MORE_1, 8) ||
               MatchDWordAtOffset(AIFF_MAGIC_MORE_2, 8) ) )
    {
        //
        // according to DaveMay, the correct AIFF format would be:
        // 'FORM....AIFF' or 'FORM....AIFC'
        // Only check for 'FORM' is incorrect because .sc2 has the 
        // same sig
        //
       _wzMimeType = vwzAudioAiff;
    }

    // video/avi (or video/x-msvedio)
    else if (MatchDWordAtOffset(RIFF_MAGIC, 0)
        && MatchDWordAtOffset(AVI_MAGIC, 8))
    {
        _wzMimeType = vwzVideoAvi;
    }

    // video/mpeg
    else if (MatchDWordAtOffset(MPEG_MAGIC, 0)
            || MatchDWordAtOffset(MPEG_MAGIC_2, 0) )
    {
        _wzMimeType = vwzVideoMpeg;
    }

    // image/x-emf
    else if (MatchDWordAtOffset(EMF_MAGIC_1, 0)
        && MatchDWordAtOffset(EMF_MAGIC_2, 40))
    {
        _wzMimeType = vwzImageEmf;
    }

    // image/x-wmf
    else if (MatchDWordAtOffset(WMF_MAGIC, 0))
    {
        _wzMimeType = vwzImageWmf;
    }

    // application/java
    else if (MatchDWordAtOffset(JAVA_MAGIC, 0))
    {
        _wzMimeType = vwzApplicationJava;
    }

    // application/x-zip-compressed
    else if (!StrCmpNC(_pBuf, vszZipMagic, sizeof(vszZipMagic) - 1))
    {
        _wzMimeType = vwzApplicationZipCompressed;
    }

    // application/x-compress
    else if (!StrCmpNC(_pBuf, vszCompressMagic, sizeof(vszCompressMagic) - 1))
    {
        _wzMimeType = vwzApplicationCompressed;
    }

    // application/x-gzip
    else if (!StrCmpNC(_pBuf, vszGzipMagic, sizeof(vszGzipMagic) - 1))
    {
        _wzMimeType = vwzApplicationGzipCompressed;
    }

    // application/x-zip-compressed
    else if (!StrCmpNC(_pBuf, vszZipMagic, sizeof(vszZipMagic) - 1))
    {
        _wzMimeType = vwzApplicationZipCompressed;
    }

    // audio/mid
    else if (!StrCmpC(_pBuf, vszMIDMagic))
    {
        _wzMimeType = vwzAudioMID;
    }

    // application/pdf (Acrobat)
    else if (!StrCmpNC(_pBuf, vszPdfMagic, sizeof(vszPdfMagic) - 1))
    {
        _wzMimeType = vwzApplicationPdf;
    }

    // don't know what it is.
    else
    {
        //_wzMimeType = vwzApplicationOctetStream;
        bRet = FALSE;
    }

    DEBUG_LEAVE(bRet);
    return bRet;
}



//+---------------------------------------------------------------------------
//
//  Method:     CContentAnalyzer::FindMimeFromData
//
//  Synopsis:   Attempts to guess MIME type from buffer
//
//
//  Arguments:  pBuf, cbSample, wzSuggestedMimeType
//
//  Returns:    LPCWSTR (the MIME type guessed)
//
//  History:    5-25-96   AdriaanC (Adriaan Canter) Created
//
//  Notes:
//
//----------------------------------------------------------------------------
LPCWSTR CContentAnalyzer::FindMimeFromData(LPCWSTR wzFileName, char* pBuf,
    int cbSample, LPCWSTR wzSuggestedMimeType, DWORD grfFlags)
{
    DEBUG_ENTER((DBG_TRANS,
                Pointer,
                "CContentAnalyzer::FindMimeFromData",
                "this=%#x, %.80wq, %.80q, %d, %.80wq, %#x",
                this, wzFileName, pBuf, cbSample, wzSuggestedMimeType, grfFlags
                ));
                
    BOOL fSampledData = FALSE;
    BOOL fFoundMimeTypeFromExt = FALSE;

    CHAR* szFileExt = 0;
    CHAR szFileName[MAX_PATH];
    CHAR szMimeTypeFromExt[SZMIMESIZE_MAX];
    CHAR szCommand[MAX_PATH];
    CHAR cLastByte;

    DWORD dwMimeLen = SZMIMESIZE_MAX;
    DWORD dwExtMimeTypeDataFormat;
    DWORD dwSuggestedMimeTypeDataFormat;
    DWORD dwMimeTypeDataFormat;
    DWORD cbCommand = MAX_PATH;
    BOOL  fExtensionChecked = FALSE;

    _grfFlags = grfFlags;

    // BUGBUG - we can use this information for DBCS.
    // Remove any info appended to the suggested mime type
    // such as charset information. This is identified by ';'

    if (wzSuggestedMimeType)
    {
        WCHAR* wptr = wcsstr(wzSuggestedMimeType, L";");
        if (wptr)
        {
            *wptr = L'\0';
        }
    }

    // Check to see if the server is suggesting an unknown mime type
    dwSuggestedMimeTypeDataFormat = GetDataFormat(wzSuggestedMimeType);
    if (dwSuggestedMimeTypeDataFormat == DATAFORMAT_UNKNOWN)
    {
        // server push returns "multipart" content type 
        // this is not the real mimetype, so we have to sniff 
        // to find out the truth 
        if(    wcsicmp(wzSuggestedMimeType, vwzmultipartmixed)
            && wcsicmp(wzSuggestedMimeType, vwzmultipartmixedreplace) )
        {
            // If so, return the suggested mime type.
            _wzMimeType = (WCHAR*) wzSuggestedMimeType;

            DEBUG_LEAVE(_wzMimeType);
            return _wzMimeType;
        }
    }

/*****
    // check if we got an extension and extension mime
    // matches the suggested mime - only for text/plain
    if (    wzSuggestedMimeType 
        &&  wzFileName
        && !wcscmp(wzSuggestedMimeType,vwzTextPlain))
         
    {
        fExtensionChecked = TRUE;
        fFoundMimeTypeFromExt = FindMimeFromExt(
                                        wzFileName,
                                        szFileName,
                                        szMimeTypeFromExt,
                                        &dwExtMimeTypeDataFormat,
                                        &szFileExt
                                        );

        // If there is a mime type associated with the file
        // extension then return it.
        if (   fFoundMimeTypeFromExt
            && (dwExtMimeTypeDataFormat == dwSuggestedMimeTypeDataFormat)
            && !wcscmp(wzSuggestedMimeType,_wzMimeTypeFromExt)
            )
        {
            // If so, return the suggested mime type.
            _wzMimeType = (WCHAR*) wzSuggestedMimeType;
            return _wzMimeType;
        }
    }
*****/

    // Not enough data to tell anything
    if (!pBuf || cbSample <= 0)
    {
        _wzMimeType = (WCHAR*) wzSuggestedMimeType;

        DEBUG_LEAVE(_wzMimeType);
        return _wzMimeType;
    }

    _pBuf = pBuf;
    _cbSample = (cbSample <= SAMPLE_SIZE) ? cbSample : SAMPLE_SIZE;

    // Save off last character. Null terminate the buffer.
    cLastByte = _pBuf[_cbSample - 1];
    _pBuf[_cbSample - 1] = '\0';


    // Common cases first - check the server indicated mime type
    // for text/html, image/gif or image/[p]jpeg.
    if (   wzSuggestedMimeType
        && !StrCmpICW(wzSuggestedMimeType, vwzTextHTML))
    {
        // Sample the data. This routine also checks for the following
        // mime types which require extended scanning through the buffer:
        // text/html, image/x-xbitmap, application/macbinhex
        SampleData();
        fSampledData = TRUE;

        if (_fFoundHTML)
        {
            _wzMimeType = vwzTextHTML;
           goto exit;
        }
    }

    // image/gif
    else if (wzSuggestedMimeType
        && !wcsicmp(wzSuggestedMimeType, vwzImageGif))
    {
        if (!StrCmpNIC(_pBuf, vszGif87Magic, sizeof(vszGif87Magic) - 1)
           || !StrCmpNIC(_pBuf, vszGif89Magic, sizeof(vszGif89Magic) - 1))
        {
            _wzMimeType = vwzImageGif;
            goto exit;
        }
    }

    // image/jpeg or image/pjpeg
    else if (wzSuggestedMimeType
        && (!wcsicmp(wzSuggestedMimeType, vwzImagePJpeg)
        || !wcsicmp(wzSuggestedMimeType, vwzImageJpeg)))
    {
        if ((BYTE)_pBuf[0] == JPEG_MAGIC_1 && (BYTE)_pBuf[1] == JPEG_MAGIC_2)
        {
            _wzMimeType = vwzImagePJpeg;
            goto exit;
        }
    }


    //
    // ********************** BEGIN HACK ******************************* 
    //
    // we will remove this once tridents defined the unique signature
    // for .hta and .htc format
    //
    // DanpoZ (98.08.12) - refer to IE5 SUPERHOT bug 35478
    //
    if (wzFileName )
    {

        CHAR* szExt;
        CHAR szFile[MAX_PATH];
        W2A(wzFileName, szFile, MAX_PATH);

        if( grfFlags & FMFD_URLASFILENAME )
        {
            //
            // remove teh security context '\1' and replace it with '\0'
            // but only do this when we are using URL to replace the filename
            //
            CHAR* pch = StrChr(szFile, '\1');
            if (pch)
            {
                *pch = '\0';
            }
        }

        szExt = FindFileExtension(szFile);
        if( szExt && 
            ( !StrCmpNIC(szExt, ".hta", sizeof(".hta") - 1) ||
              !StrCmpNIC(szExt, ".htc", sizeof(".htc") - 1)  ) )
        {
            fExtensionChecked = TRUE;
            fFoundMimeTypeFromExt = FindMimeFromExt(
                                            wzFileName,
                                            szFileName,
                                            szMimeTypeFromExt,
                                            &dwExtMimeTypeDataFormat,
                                            &szFileExt
                                            );

            // If there is a mime type associated with the file
            // extension then return it.
            if (fFoundMimeTypeFromExt)
            {
                _wzMimeType = _wzMimeTypeFromExt;
                goto exit;
            }
        }
    }
    //
    // ********************** END HACK ********************************* 
    //

    // One of the following is true:

    // 1) The server indicated a common mime type (html, gif or jpeg),
    //    however, verification failed.
    // 2) The server indicated an ambiguous mime type or
    //    a known, but uncommon mime type.

    // If not done so already, sample the data.
    if (!fSampledData)
    {
        SampleData();
        fSampledData = TRUE;
    }

    // Return any mime type that was positively
    // identified during the data sampling
    if( _fFoundCDF )
    {
        _wzMimeType = vwzApplicationCDF;
        goto exit;
    }
    else if( _fFoundXML)
    {
        _wzMimeType = vwzTextXML;
        goto exit;
    }
    else if (_fFoundHTML)
    {
        _wzMimeType = vwzTextHTML;
        goto exit;
    }
    else if (_fFoundXBitMap)
    {
        _wzMimeType = vwzImageXBitmap;
        goto exit;
    }
    else if (_fFoundMacBinhex)
    {
        _wzMimeType = vwzApplicationMacBinhex;
        goto exit;
    }
    else if( _fFoundTextScriptlet )
    {
        _wzMimeType = vwzTextScriptlet;
        goto exit;
    }

    if(    !_fFoundCDF  
        && wzSuggestedMimeType
        && !wcsicmp(wzSuggestedMimeType, vwzApplicationNETCDF) 
      ) 
    {
        // only overwrite application/x-netcdf with aplication/x-cdf
        _wzMimeType = vwzApplicationNETCDF; 
        goto exit;
    }
    

    // Decide if buffer is primarily text or binary. Conduct
    // pattern matching to determine a mime type depending on the
    // finding.
    if (!_cbCtrl || _cbText + _cbFF >= 16 * (_cbCtrl + _cbHigh))
    {
        _fBinary = FALSE;
        if( !CheckTextHeaders() )
        {
            if( !CheckBinaryHeaders() )
            {
                _wzMimeType = vwzTextPlain;
            }
        }
    }
    else
    {
        _fBinary = TRUE;
        if( !CheckBinaryHeaders() )
        {
            if( !CheckTextHeaders() )
            {
                _wzMimeType = vwzApplicationOctetStream;
            }
        }
    }

    // Determine format of the mime type from data
    dwMimeTypeDataFormat = GetDataFormat(_wzMimeType);

    // If the format of the mime type found from examining the data
    // is not ambiguous, then return this mime type.
    if (dwMimeTypeDataFormat != DATAFORMAT_AMBIGUOUS)
    {
        goto exit;
    }

    // Examination of data is inconclusive.
    else
    {
        // If the suggested mime type is not ambiguous and does
        // not conflict with the data format then return it.
        if (dwSuggestedMimeTypeDataFormat != DATAFORMAT_AMBIGUOUS
            && FormatAgreesWithData(dwSuggestedMimeTypeDataFormat))
        {
            _wzMimeType = (WCHAR*) wzSuggestedMimeType;
            goto exit;
        }

        // Otherwise, attempt to obtain a mime type from any
        // file extension. If none is found, but an application
        // is registered for the file extension, return
        // application/octet-stream.


        // If there is a file extension, find any
        // associated mime type.
        if (wzFileName && !fExtensionChecked)
        {
            fExtensionChecked = TRUE;

            fFoundMimeTypeFromExt = FindMimeFromExt(
                                            wzFileName,
                                            szFileName,
                                            szMimeTypeFromExt,
                                            &dwExtMimeTypeDataFormat,
                                            &szFileExt
                                            );
        }

        // If there is a mime type associated with the file
        // extension then return it.
        if (fFoundMimeTypeFromExt)
        {
            if (dwExtMimeTypeDataFormat == DATAFORMAT_UNKNOWN)
            {
                _wzMimeType = _wzMimeTypeFromExt;
                goto exit;
            }
            else
            {
                goto exit;
            }
        }

        // Otherwise, check to see if there is an associated application.
        if (szFileExt && FindAppFromExt(szFileExt, szCommand, cbCommand))
        {
            // Found an associated application.
            _wzMimeType = vwzApplicationOctetStream;
            goto exit;
        }

        // No suggested mime type, no mime type from file extension
        // and no registered application found. Fall through and return
        // mime type found from the data
    }


    exit:
        // Replace the null termination with
        // the original character.
        _pBuf[_cbSample - 1] = cLastByte;


        DEBUG_LEAVE(_wzMimeType);
        return _wzMimeType;
}

//+---------------------------------------------------------------------------
//
//  Method:     CContentAnalyzer::FindMimeFromExt
//
//  Synopsis:
//
//  Arguments:  [wzFileName] --
//              [szFileName] --
//              [szMimeTypeFromExt] --
//              [pdwExtMimeTypeDataFormat] --
//
//  Returns:
//
//  History:    5-25-96   AdriaanC (Adriaan Canter)
//              1-28-1997   JohannP (Johann Posch)   made separate function
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL CContentAnalyzer::FindMimeFromExt(
                        LPCWSTR wzFileName,
                        CHAR *szFileName,
                        CHAR *szMimeTypeFromExt,
                        DWORD *pdwExtMimeTypeDataFormat,
                        CHAR  **ppszFileExt)
{
    DEBUG_ENTER((DBG_TRANS,
                Bool,
                "CContentAnalyzer::FindMimeFromExt",
                "this=%#x, %.80wq, %.80q, %.80q, %#x, %#x",
                this, wzFileName, szFileName, szMimeTypeFromExt, pdwExtMimeTypeDataFormat, ppszFileExt
                ));
                
    BOOL fFoundMimeTypeFromExt = FALSE;
    UrlMkAssert((wzFileName && szFileName && pdwExtMimeTypeDataFormat));
    DWORD dwMimeLen = SZMIMESIZE_MAX;
    CHAR* szFileExt = 0;

    // If there is a file extension, find any
    // associated mime type.
    W2A(wzFileName, szFileName, MAX_PATH);
    szFileExt = FindFileExtension(szFileName);
    if (szFileExt && GetMimeFromExt(szFileExt,
        szMimeTypeFromExt, &dwMimeLen) == ERROR_SUCCESS)
    {
        fFoundMimeTypeFromExt = TRUE;
        A2W(szMimeTypeFromExt, _wzMimeTypeFromExt, SZMIMESIZE_MAX);
        *pdwExtMimeTypeDataFormat = GetDataFormat(_wzMimeTypeFromExt);
    }
    if (szFileExt && ppszFileExt)
    {
        *ppszFileExt = szFileExt;
    }

    DEBUG_LEAVE(fFoundMimeTypeFromExt);
    return fFoundMimeTypeFromExt;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\trans\cdldelg.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       cdldelg.cxx
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    02-20-97   t-alans (Alan Shi)   Created
//
//----------------------------------------------------------------------------

#include <trans.h>
#include <wchar.h>

//+---------------------------------------------------------------------------
//
//  Method:     CCDLDelegate::CCDLDelegate
//
//  Synopsis:
//
//  Arguments:  
//              
//              
//
//  Returns:
//
//  History:    01-27-1997   t-alans (Alan Shi)   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

CCDLDelegate::CCDLDelegate(CBinding *pCBinding, IBindStatusCallback *pBSC)
{
    DEBUG_ENTER((DBG_TRANS,
                None,
                "CCDLDelegate::CCDLDelegate",
                "this=%#x, %#x, %#x",
                this, pCBinding, pBSC
                ));
                
    _cRef = 1;
    _pCBinding = pCBinding;
    if (_pCBinding != NULL)
    {
        _pCBinding->AddRef();
    }
    _pBSC = pBSC;
    if (_pBSC != NULL)
    {
        _pBSC->AddRef();
    }

    DEBUG_LEAVE(0);
}

//+---------------------------------------------------------------------------
//
//  Method:     CCDLDelegate::~CCDLDelegate
//
//  Synopsis:
//
//  Arguments:  
//              
//              
//
//  Returns:
//
//  History:    01-27-1997   t-alans (Alan Shi)   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

CCDLDelegate::~CCDLDelegate()
{
    DEBUG_ENTER((DBG_TRANS,
                None,
                "CCDLDelegate::~CCDLDelegate",
                "this=%#x",
                this
                ));
                
    if (_pCBinding != NULL)
    {
        _pCBinding->Release();
    }
    if (_pBSC != NULL)
    {
        _pBSC->Release();
    }

    DEBUG_LEAVE(0);
}

/*
 *
 * IUnknown Methods
 *
 */
 
//+---------------------------------------------------------------------------
//
//  Method:     CCDLDelegate::QueryInterface
//
//  Synopsis:
//
//  Arguments:  
//              
//              
//
//  Returns:
//
//  History:    01-27-1997   t-alans (Alan Shi)   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

STDMETHODIMP CCDLDelegate::QueryInterface(REFIID riid, void **ppv)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CCDLDelegate::IUnknown::QueryInterface",
                "this=%#x, %#x, %#x",
                this, &riid, ppv
                ));
                
    HRESULT          hr = E_NOINTERFACE;

    *ppv = NULL;
    if (riid == IID_IUnknown || riid == IID_IBindStatusCallback)
    {
        *ppv = (IBindStatusCallback *)this;
    }
    else if (riid == IID_IBinding)
    {
        *ppv = (IBinding *)this;
    }
    else if (riid == IID_IWindowForBindingUI)
    {
        *ppv = (IWindowForBindingUI *)this;
    }
    
    if (*ppv != NULL)
    {
        ((IUnknown *)*ppv)->AddRef();
        hr = S_OK;
    }

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CCDLDelegate::AddRef
//
//  Synopsis:
//
//  Arguments:  
//              
//              
//
//  Returns:
//
//  History:    01-27-1997   t-alans (Alan Shi)   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CCDLDelegate::AddRef()
{
    DEBUG_ENTER((DBG_TRANS,
                Dword,
                "CCDLDelegate::IUnknown::AddRef",
                "this=%#x",
                this
                ));
                
    ULONG ulRet = ++_cRef;

    DEBUG_LEAVE(ulRet);
    return ulRet;
}

//+---------------------------------------------------------------------------
//
//  Method:     CCDLDelegate::Release
//
//  Synopsis:
//
//  Arguments:  
//              
//              
//
//  Returns:
//
//  History:    01-27-1997   t-alans (Alan Shi)   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CCDLDelegate::Release()
{
    DEBUG_ENTER((DBG_TRANS,
                Dword,
                "CCDLDelegate::IUnknown::Release",
                "this=%#x",
                this
                ));
                
    if (--_cRef)
    {
        DEBUG_LEAVE(_cRef);
        return _cRef;
    }
    delete this;

    DEBUG_LEAVE(0);
    return 0;
}

/*
 *
 * IBindStatusCallback Methods
 *
 */
 
//+---------------------------------------------------------------------------
//
//  Method:     CCDLDelegate::OnStartBinding
//
//  Synopsis:
//
//  Arguments:  
//              
//              
//
//  Returns:
//
//  History:    01-27-1997   t-alans (Alan Shi)   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

STDMETHODIMP CCDLDelegate::OnStartBinding(DWORD grfBSCOption, IBinding *pib)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CCDLDelegate::IBindStatusCallback::OnStartBinding",
                "this=%#x, %#x, %#x",
                this, grfBSCOption, pib
                ));
                
    HRESULT                 hr = S_OK;

#if 0
    if (_pCBinding != NULL)
    {
        hr = _pCBinding->OnTransNotification(BINDSTATUS_???,
                                             0, 0, S_OK);
    }
#endif
    _pBinding = pib;
    if (_pBinding != NULL)
    {
        _pBinding->AddRef();
    }

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CCDLDelegate::OnStopBinding
//
//  Synopsis:
//
//  Arguments:  
//              
//              
//
//  Returns:
//
//  History:    01-27-1997   t-alans (Alan Shi)   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

STDMETHODIMP CCDLDelegate::OnStopBinding(HRESULT hresult, LPCWSTR szError)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CCDLDelegate::IBindStatusCallback::OnStopBinding",
                "this=%#x, %#x, %.80wq",
                this, hresult, szError
                ));
                
    HRESULT              hr = S_OK;

#if 0
    if (_pCBinding != NULL)
    {
        hr = _pCBinding->OnTransNotification(BINDSTATUS_CODEDOWNLOADCOMPLETE,
                                             0, 0, (LPWSTR)szError, hresult);
    }
#endif    
    if (_pBinding != NULL)
    {
        _pBinding->Release();
        _pBinding = NULL;
    }

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CCDLDelegate::OnObjectAvailable
//
//  Synopsis:
//
//  Arguments:  
//              
//              
//
//  Returns:
//
//  History:    01-27-1997   t-alans (Alan Shi)   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

STDMETHODIMP CCDLDelegate::OnObjectAvailable(REFIID riid, IUnknown *punk)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CCDLDelegate::IBindStatusCallback::OnObjectAvailable",
                "this=%#x, %#x, %#x",
                this, &riid, punk
                ));

    DEBUG_LEAVE(S_OK);
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Method:     CCDLDelegate::OnLowResource
//
//  Synopsis:
//
//  Arguments:  
//              
//              
//
//  Returns:
//
//  History:    01-27-1997   t-alans (Alan Shi)   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

STDMETHODIMP CCDLDelegate::OnLowResource(DWORD dwReserved)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CCDLDelegate::IBindStatusCallback::OnLowResource",
                "this=%#x, %#x",
                this, dwReserved
                ));

    DEBUG_LEAVE(S_OK);
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Method:     CCDLDelegate::OnProgress
//
//  Synopsis:
//
//  Arguments:  
//              
//              
//
//  Returns:
//
//  History:    01-27-1997   t-alans (Alan Shi)   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

STDMETHODIMP CCDLDelegate::OnProgress(ULONG ulProgress, ULONG ulProgressMax,
                                      ULONG ulStatusCode,
                                      LPCWSTR szStatusText)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CCDLDelegate::IBindStatusCallback::OnProgress",
                "this=%#x, %#x, %#x, %#x, %.80wq",
                this, ulProgress, ulProgressMax ulStatusCode, szStatusText
                ));
                
    HRESULT                hr = S_OK;

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CCDLDelegate::GetBindInfo
//
//  Synopsis:
//
//  Arguments:  
//              
//              
//
//  Returns:
//
//  History:    01-27-1997   t-alans (Alan Shi)   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

STDMETHODIMP CCDLDelegate::GetBindInfo(DWORD *pgrfBINDF,
                                       BINDINFO *pbindInfo)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CCDLDelegate::IBindStatusCallback::GetBindInfo",
                "this=%#x, %#x, %#x",
                this, pgrfBINDF, pbindInfo
                ));
                
    *pgrfBINDF |= BINDF_ASYNCSTORAGE;
    *pgrfBINDF |= BINDF_PULLDATA;
    *pgrfBINDF |= BINDF_ASYNCHRONOUS;

    DEBUG_LEAVE(S_OK);
    return S_OK;
} 

//+---------------------------------------------------------------------------
//
//  Method:     CCDLDelegate::OnDataAvailable
//
//  Synopsis:
//
//  Arguments:  
//              
//              
//
//  Returns:
//
//  History:    01-27-1997   t-alans (Alan Shi)   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

STDMETHODIMP CCDLDelegate::OnDataAvailable( DWORD grfBSCF, DWORD dwSize,
                                            FORMATETC *pformatetc,
                                            STGMEDIUM *pstgmed )
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CCDLDelegate::IBindStatusCallback::OnDataAvailable",
                "this=%#x, %#x, %#x, %#x, %#x",
                this, grfBSCF, dwSize, pformatetc, pstgmed
                ));
                
    DEBUG_LEAVE(S_OK);
    return S_OK;
}

/*
 *
 * IBinding Methods
 *
 */
 
// delegates all calls back to URLMon

//+---------------------------------------------------------------------------
//
//  Method:     CCDLDelegate::Abort
//
//  Synopsis:
//
//  Arguments:  
//              
//              
//
//  Returns:
//
//  History:    01-27-1997   t-alans (Alan Shi)   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

STDMETHODIMP CCDLDelegate::Abort(void)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CCDLDelegate::IBinding::Abort",
                "this=%#x",
                this
                ));
                
    HRESULT              hr = E_NOTIMPL;
    
    if (_pBinding != NULL)
    {
       hr = _pBinding->Abort();
    }

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CCDLDelegate::Suspend
//
//  Synopsis:
//
//  Arguments:  
//              
//              
//
//  Returns:
//
//  History:    01-27-1997   t-alans (Alan Shi)   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

STDMETHODIMP CCDLDelegate::Suspend(void)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CCDLDelegate::IBinding::Suspend",
                "this=%#x",
                this
                ));
                
    HRESULT              hr = E_NOTIMPL;
    
    if (_pBinding != NULL)
    {
       hr = _pBinding->Suspend();
    }

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CCDLDelegate::Resume
//
//  Synopsis:
//
//  Arguments:  
//              
//              
//
//  Returns:
//
//  History:    01-27-1997   t-alans (Alan Shi)   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

STDMETHODIMP CCDLDelegate::Resume(void)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CCDLDelegate::IBinding::Resume",
                "this=%#x",
                this
                ));
                
    HRESULT              hr = E_NOTIMPL;
    
    if (_pBinding != NULL)
    {
       hr = _pBinding->Resume();
    }

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CCDLDelegate::SetPriority
//
//  Synopsis:
//
//  Arguments:  
//              
//              
//
//  Returns:
//
//  History:    01-27-1997   t-alans (Alan Shi)   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

STDMETHODIMP CCDLDelegate::SetPriority(LONG nPriority)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CCDLDelegate::IBinding::SetPriority",
                "this=%#x, %#x",
                this, nPriority
                ));
                
    HRESULT              hr = E_NOTIMPL;
    
    if (_pBinding != NULL)
    {
       hr = _pBinding->SetPriority(nPriority);
    }

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CCDLDelegate::GetPriority
//
//  Synopsis:
//
//  Arguments:  
//              
//              
//
//  Returns:
//
//  History:    01-27-1997   t-alans (Alan Shi)   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

STDMETHODIMP CCDLDelegate::GetPriority(LONG *pnPriority)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CCDLDelegate::IBinding::GetPriority",
                "this=%#x, %#x",
                this, pnPriority
                ));
                
    HRESULT              hr = E_NOTIMPL;
    
    if (_pBinding != NULL)
    {
       hr = _pBinding->GetPriority(pnPriority);
    }

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CCDLDelegate::GetBindResult
//
//  Synopsis:
//
//  Arguments:  
//              
//              
//
//  Returns:
//
//  History:    01-27-1997   t-alans (Alan Shi)   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

STDMETHODIMP CCDLDelegate::GetBindResult(CLSID *pclsidProtocol,
                                         DWORD *pdwBindResult,
                                         LPWSTR *pszBindResult,
                                         DWORD *dwReserved )
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CCDLDelegate::IBinding::GetBindResult",
                "this=%#x, %#x, %#x, %#x, %#x",
                this, pclsidProtocol, pdwBindResult, pszBindResult, dwReserved
                ));
                
    HRESULT              hr = E_NOTIMPL;
    
    if (_pBinding != NULL)
    {
       hr = _pBinding->GetBindResult(pclsidProtocol, pdwBindResult,
                                     pszBindResult, dwReserved);
    }

    DEBUG_LEAVE(hr);
    return hr;
}

/*
 *
 * IWindowForBindingUI Methods
 *
 */

//+---------------------------------------------------------------------------
//
//  Method:     CCDLDelegate::GetWindow
//
//  Synopsis:
//
//  Arguments:  
//              
//              
//
//  Returns:
//
//  History:    01-27-1997   t-alans (Alan Shi)   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

STDMETHODIMP CCDLDelegate::GetWindow(REFGUID rguidReason,
                                     HWND __RPC_FAR *phwnd)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CCDLDelegate::IWindowForBindingUI::GetWindow",
                "this=%#x, %#x, %#x",
                this, &rguidReason, phwnd
                ));
                
    HRESULT                  hr = S_FALSE;
    IWindowForBindingUI     *pWindowForBindingUI = NULL;
    IServiceProvider        *pIServiceProvider = NULL;
    
    hr = _pBSC->QueryInterface(IID_IWindowForBindingUI,
                               (LPVOID *)&pWindowForBindingUI);
    if (FAILED(hr))
    {
        hr = _pBSC->QueryInterface(IID_IServiceProvider,
                                   (LPVOID *)&pIServiceProvider);
        if (SUCCEEDED(hr))
        {
            pIServiceProvider->QueryService(IID_IWindowForBindingUI,
                                            IID_IWindowForBindingUI,
                                            (LPVOID *)&pWindowForBindingUI);
            pIServiceProvider->Release();
        }
    }

    if (pWindowForBindingUI != NULL)
    {
        hr = pWindowForBindingUI->GetWindow(rguidReason, phwnd);
    }
    else
    {
        hr = S_FALSE;
        *phwnd = (HWND)INVALID_HANDLE_VALUE;
    }

    DEBUG_LEAVE(hr);
    return hr;

}

/*
 *
 * Helper API to do code installation
 *
 */
 
//+---------------------------------------------------------------------------
//
//  Method:     AsyncDLCodeInstall
//
//  Synopsis:
//
//  Arguments:  
//              
//              
//
//  Returns:
//
//  History:    01-27-1997   t-alans (Alan Shi)   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

STDMETHODIMP AsyncDLCodeInstall(CBinding *pCBinding,
                                IBindStatusCallback *pIBSC,
                                IBinding **ppIBinding,
                                CCodeDownloadInfo *pCDLInfo)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "AsyncDLCodeInstall",
                "%#x, %#x, %#x, %#x",
                pCBinding, pIBSC, ppIBinding, pCDLInfo
                ));
                
    HRESULT                   hr = E_FAIL;
    CCDLDelegate             *pCDLDelegate = NULL;
    IBindCtx                 *pbc = NULL;
    IMoniker                 *pIMonikerCDL = NULL;
    IStream                  *pIStream = NULL;
    WCHAR                     szDisplayName[3 * (MAX_URL_SIZE + 1)];
    CLSID                     clsid = CLSID_NULL;
    LPWSTR                    pszStr = NULL;
    WCHAR                     pszCodeBase[MAX_URL_SIZE + 1];
    DWORD                     dwMajorVersion = 0;
    DWORD                     dwMinorVersion = 0;

    pCDLDelegate = new CCDLDelegate(pCBinding, pIBSC);
    if (pCDLDelegate == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }
    *ppIBinding = pCDLDelegate;
    
    hr = CreateBindCtx(0, &pbc);
    if (SUCCEEDED(hr))
    {
        hr = RegisterBindStatusCallback(pbc, pCDLDelegate, NULL, 0);
        if (SUCCEEDED(hr))
        {
            pCDLDelegate->Release();
        }
        else
        {
            pbc->Release();
            goto Exit; 
        }

        // AS TODO: Make this smarter...

        LPWSTR pszPtr = pszCodeBase;
        pCDLInfo->GetCodeBase(&pszPtr);
        pCDLInfo->GetClassID(&clsid);
        pCDLInfo->GetMajorVersion(&dwMajorVersion);
        pCDLInfo->GetMinorVersion(&dwMinorVersion);
        HRESULT succ = StringFromCLSID(clsid, &pszStr);
        swprintf(szDisplayName, L"cdl:codebase=%s;clsid=%s;verMS=%ld;verLS=%ld"
                              , pszCodeBase, pszStr, dwMajorVersion, dwMinorVersion);
        if (pszStr != NULL)
        {
            delete pszStr;
        }

//      assert( strlen( szDisplayName <= 3 * MAX_URL_SIZE ) );
        hr = CreateURLMoniker(NULL, szDisplayName, &pIMonikerCDL);
        if (SUCCEEDED(hr))
        {
            hr = pIMonikerCDL->BindToStorage(pbc, NULL, IID_IStream,
                                             (void **)&pIStream);
            pIMonikerCDL->Release();
        }
        
    }

    if (pbc != NULL)
    {
        pbc->Release();
    }

Exit:

    DEBUG_LEAVE(hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\trans\cbinding.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       cbinding.cxx
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    11-11-95   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------
#include <trans.h>
#include "oinet.hxx"
#include "cdl.h"    // defined in urlmon\download\

// from helpers.cxx
HRESULT IsMimeHandled(LPCWSTR pwszMimeType);

// From shlwapip.h
LWSTDAPI_(HRESULT) CLSIDFromStringWrap(LPOLESTR lpsz, LPCLSID pclsid);


PerfDbgTag(tagCBinding,     "Urlmon", "Log CBinding",        DEB_BINDING);
DbgTag(tagCBindingErr,  "Urlmon", "Log CBinding Errors", DEB_BINDING|DEB_ERROR);
extern DWORD g_dwSettings;

#define MAX_PROTOCOL_LEN    32  // protocl string length in ASCII BUGBUG is there a standard?
#define PROTOCOL_DELIMITER  ':'
#define REG_PROTOCOL_HANDLER    L"ProtocolHandler"

WCHAR *rglpProto[] =
{
    L"https",
    L"http",
    L"ftp",
    L"gopher",
    L"file",
    L"local",
    L"mk",
    NULL,
};

HRESULT GetTransactionObjects(LPBC pBndCtx, LPCWSTR wzUrl, IUnknown *pUnkOuter, IUnknown **ppUnk, IOInetProtocol **ppCTrans, DWORD dwOption, CTransData **pCTransData);
BOOL PDFNeedProgressiveDownload();

EXTERN_C const GUID CLSID_MsHtml;
EXTERN_C const GUID IID_ITransactionData;


//+---------------------------------------------------------------------------
//
//  Function:   CreateURLBinding
//
//  Synopsis:
//
//  Arguments:  [lpszUrl] --
//              [pbc] --
//              [ppBdg] --
//
//  Returns:
//
//  History:    12-04-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CreateURLBinding(LPWSTR lpszUrl, IBindCtx *pbc, IBinding **ppBdg)
{
    DEBUG_ENTER_API((DBG_BINDING,
                    Hresult,
                    "CreateURLBinding",
                    "%.80wq, %#x, %#x",
                    lpszUrl, pbc, ppBdg
                    ));

    PerfDbgLog(tagCBinding, NULL, "+CreateURLBinding");
    HRESULT  hr = NOERROR;

    PerfDbgLog1(tagCBinding, NULL, "-CreateURLBinding (IBinding:%lx)", *ppBdg);

    DEBUG_LEAVE_API(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBinding::Create
//
//  Synopsis:
//
//  Arguments:  [pUnkOuter] --
//              [LPBC] --
//              [pbc] --
//
//  Returns:
//
//  History:    12-06-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CBinding::Create(IUnknown *pUnkOuter, LPCWSTR szUrl, LPBC pbc, REFIID riid, BOOL fBindToObject, CBinding **ppCBdg)
{
    DEBUG_ENTER((DBG_BINDING,
                Hresult,
                "CBinding::Create",
                "%#x, %.80wq, %#x, %#x, %B, %#x",
                pUnkOuter, szUrl, pbc, &riid, fBindToObject, ppCBdg
                ));
                    
    PerfDbgLog1(tagCBinding, NULL, "+CBinding::Create (szUrl:%ws)", szUrl);
    HRESULT hr = NOERROR;
    CBinding *pCBdg;

    UrlMkAssert((ppCBdg != NULL));

    // Create and initialize the cbinding object
    pCBdg = new CBinding(NULL);
    if (pCBdg == NULL)
    {
        hr = E_OUTOFMEMORY;
    }

    *ppCBdg = pCBdg;

    PerfDbgLog2(tagCBinding, NULL, "-CBinding::Create (hr:%lx,IBinding:%lx)", hr, pCBdg);

    DEBUG_LEAVE(hr);
    return hr;
}
//+---------------------------------------------------------------------------
//
//  Method:     CBinding::Initialize
//
//  Synopsis:
//
//  Arguments:  [szUrl] --
//              [pbc] --
//
//  Returns:
//
//  History:    12-04-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CBinding::Initialize(LPCWSTR szUrl, IBindCtx *pbc, DWORD grfBindF, REFIID riid, BOOL fBindToObject)
{
    DEBUG_ENTER((DBG_BINDING,
                Hresult,
                "CBinding::Initialize",
                "this=%#x, %.80wq, %#x, %#x, %#x, %B",
                this, szUrl, pbc, grfBindF, &riid, fBindToObject
                ));
                
    HRESULT hr = NOERROR;
    PerfDbgLog(tagCBinding, this, "+CBinding::Initialize");

    _fBindToObject = fBindToObject;

    if (fBindToObject)
    {

        // Get the bind options from the bind context
        _bindopts.cbStruct = sizeof(BIND_OPTS);
        hr = pbc->GetBindOptions(&_bindopts);
        if (FAILED(hr))
        {
            goto End;
        }
    }

    hr = CBindCtx::Create(&_pBndCtx, pbc);


    if ((hr == NOERROR) && szUrl)
    {
        TransAssert((_pBndCtx));

        int cchWideChar;

        cchWideChar  = wcslen(szUrl) + 2;
        _lpwszUrl = (LPWSTR) new WCHAR [cchWideChar];
        if( !_lpwszUrl )
        {
            hr = E_OUTOFMEMORY;
            goto End;
        }
        wcscpy(_lpwszUrl, szUrl);

        // Try to get an IBindStatusCallback  pointer from the bind context
        hr = GetObjectParam(pbc, REG_BSCB_HOLDER, IID_IBindStatusCallback, (IUnknown**)&_pBSCB);

        UrlMkAssert(( (hr == NOERROR) && _pBSCB ));

        PerfDbgLog2(tagCBinding, this, "=== CBinding::Initialize (pbc:%lx -> _pBSCB:%lx)", pbc, _pBSCB);

        hr = GetTransactionObjects(_pBndCtx, _lpwszUrl, NULL, NULL, &_pOInetBdg,OIBDG_APARTMENTTHREADED, &_pCTransData);

        if (hr == S_OK)
        {
            TransAssert((!_pCTransData));
            // create the transaction data object
            // Note: the transdat object has a refcount
            //       and must be released when done
            hr = CTransData::Create(_lpwszUrl, grfBindF, riid, _pBndCtx, _fBindToObject, &_pCTransData);
            if (FAILED(hr))
            {
                //goto End;
            }
            else
            {
                UrlMkAssert((_pCTransData != NULL && "CTransData invalid"));
                _pBndCtx->SetTransData(_pCTransData);
            }
        }
        else if (hr == S_FALSE)
        {
            UrlMkAssert((_pCTransData != NULL && "CTransData invalid"));
            if (fBindToObject)
                _grfInternalFlags |= BDGFLAGS_BTS_BTO;
            else
                _grfInternalFlags |= BDGFLAGS_ATTACHED;

            hr = _pCTransData->Initialize(_lpwszUrl, grfBindF, riid, _pBndCtx);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }

        if (_fBindToObject)
        {
            _piidRes = (IID *) &riid;
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
End:

    PerfDbgLog1(tagCBinding, this, "-CBinding::Initialize (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBinding::CBinding
//
//  Synopsis:
//
//  Arguments:  [pUnk] --
//
//  Returns:
//
//  History:    11-11-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
CBinding::CBinding(IUnknown *pUnk) : _CRefs()
{
    DEBUG_ENTER((DBG_BINDING,
                None,
                "CBinding::CBinding",
                "this=%#x, %#x",
                this, pUnk
                ));
                
    _pUnk = pUnk;
    if (_pUnk)
    {
        _pUnk->AddRef();
    }
    _dwThreadId   = GetCurrentThreadId();
    _pBSCB        = 0;
    _nPriority    = THREAD_PRIORITY_NORMAL;
    _dwState      = 0;
    _OperationState = OPS_Initialized;
    _hwndNotify   = 0;
    _grfBINDF     = 0;
    _dwLastSize   = 0;
    _lpwszUrl     = 0;
    _pOInetBdg      = 0;
    _fSentLastNotification = 0;
    _fSentFirstNotification = 0;
    _fCreateStgMed = 0;
    _fCompleteDownloadHere = FALSE;
    _fForceBindToObjFail = FALSE;
    _fAcceptRanges = FALSE;
    _fClsidFromProt = FALSE;
    _pMnk = NULL;
    _pBndCtx = NULL;
    _piidRes = (IID*)&IID_IUnknown; // NULL;
    _pUnkObject = NULL;
    _pBasicAuth = NULL;
    _hrBindResult = NOERROR;
    _hrInstantiate = NOERROR;
    _dwBindError = 0;
    _grfInternalFlags = BDGFLAGS_NOTIFICATIONS;
    _pwzRedirectUrl = 0;
    _pwzResult = 0;

    _pBindInfo = 0;
    _clsidIn = CLSID_NULL;   
    
    _fCanGetIWinInetInfo = FALSE;
    _fCanGetIWinInetHttpInfo = FALSE;

    _fBTS_BTO = FALSE;
    DEBUG_LEAVE(0);
}
//+---------------------------------------------------------------------------
//
//  Method:     CBinding::~CBinding
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    11-11-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
CBinding::~CBinding()
{
    DEBUG_ENTER((DBG_BINDING,
                None,
                "CBinding::~CBinding",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCBinding, this, "+CBinding::~CBinding");

    if (_pBindInfo)
    {
        _pBindInfo->Release();
    }

    if (_pUnk)
    {
        DbgLog(tagCBinding, this, "CBinding::~CBinding Release on _pUnk");
        _pUnk->Release();
    }

    if (_pBasicAuth)
    {
        DbgLog1(tagCBinding, this, "CBinding::~CBinding Release on _pBasicAuth (%lx)", _pBasicAuth);
        _pBasicAuth->Release();
    }

    if (_pBSCB)
    {
        DbgLog1(tagCBinding, this, "CBinding::~CBinding Release on IBSCB (%lx)", _pBSCB);
        _pBSCB->Release();
    }

    if (_pOInetBdg)
    {
        _pOInetBdg->Release();
    }

    if (_pMnk)
    {
        _pMnk->Release();
    }
    if (_pBndCtx)
    {
        _pBndCtx->Release();
    }
    if (_pCTransData)
    {
        DbgLog1(tagCBinding, this, "CBinding::~CBinding Release TransData (%lx)", _pCTransData);
        _pCTransData->Release();
    }

    if (_pUnkObject)
    {
        _pUnkObject->Release();
    }

    if (_lpwszUrl)
    {
        delete [] _lpwszUrl;
    }
    if (_pwzRedirectUrl)
    {
        delete [] _pwzRedirectUrl;
    }
    if (_pwzResult)
    {
        delete [] _pwzResult;
    }

    ReleaseBindInfo(&_BndInfo);

    PerfDbgLog(tagCBinding, this, "-CBinding::~CBinding");

    DEBUG_LEAVE(0);
}

LPWSTR CBinding::GetFileName()
{
    DEBUG_ENTER((DBG_BINDING,
                String,
                "CBinding::GetFileName",
                "this=%#x",
                this
                ));

    LPWSTR wzFilename = _pCTransData->GetFileName();

    DEBUG_LEAVE(wzFilename);
    return wzFilename;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBinding::QueryInterface
//
//  Synopsis:
//
//  Arguments:  [riid] --
//              [ppv] --
//
//  Returns:
//
//  History:    11-11-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBinding::QueryInterface( REFIID riid, void **ppv )
{
    DEBUG_ENTER((DBG_BINDING,
                Hresult,
                "CBinding::IUnknown::QueryInterface",
                "this=%#x, %#x, %#x",
                this, &riid, ppv
                ));
                
    PerfDbgLog2(tagCBinding, this, "+CBinding::QueryInterface (%lx, %lx)", riid, ppv);
    HRESULT     hr = NOERROR;
    *ppv = NULL;

    //UrlMkAssert(( !IsEqualIID(GetProtocolClassID(),CLSID_NULL) ));

    if (   IsEqualIID(riid, IID_IUnknown)
        || IsEqualIID(riid, IID_IBinding) )
    {
        *ppv = (void FAR *)(IBinding *)this;
        AddRef();
    }
    else if (IsEqualIID(riid, IID_IOInetProtocolSink))
    {
        *ppv = (void FAR *)(IOInetProtocolSink *)this;
        AddRef();
    }
    else if (IsEqualIID(riid, IID_IOInetBindInfo))
    {
        *ppv = (void FAR *)(IOInetBindInfo *)this;
        AddRef();
    }
    else if (IsEqualIID(riid, IID_IServiceProvider))
    {
        *ppv = (void FAR *)(IServiceProvider *)this;
        AddRef();
    }
    else if (IsEqualIID(riid, IID_IWinInetInfo))
    {
        if (_pOInetBdg)
        {
            IWinInetInfo    *pIWinInetInfo;
            hr = _pOInetBdg->QueryInterface(riid, (void **)&pIWinInetInfo);
            if (S_FALSE == hr) 
                hr = E_NOINTERFACE;//see bug 99754
            //dont keep the reference..release it immdly.
            if (SUCCEEDED(hr))
            {
                pIWinInetInfo->Release();
                _fCanGetIWinInetInfo = TRUE;
                *ppv = (void FAR *) (IWinInetInfo *)this;
                AddRef();
            }
        }
        else
        {
            hr = E_NOINTERFACE;
        }
    }
    else if (IsEqualIID(riid, IID_IWinInetHttpInfo))
    {
        if (_pOInetBdg)
        {
            IWinInetHttpInfo    *pIWinInetHttpInfo;
            hr = _pOInetBdg->QueryInterface(riid, (void **)&pIWinInetHttpInfo);
            if (S_FALSE == hr)
                hr = E_NOINTERFACE;//see bug 99754
            if (SUCCEEDED(hr))
            {
                pIWinInetHttpInfo->Release();
                _fCanGetIWinInetHttpInfo = TRUE;
                *ppv = (void FAR *) (IWinInetHttpInfo *)this;
                AddRef();
            }         
        }
        else
        {
            hr = E_NOINTERFACE;
        }
    }
    else
    {
        *ppv = NULL;
        hr = E_NOINTERFACE;
#if DBG==1
        //LPSTR lpszName = GetInterfaceName(riid);
        //DbgLog3(tagCBinding, this, "CBinding::QI(pUnkObj) >%s< hr:%lx [%lx]", lpszName, hr, *ppv));
#endif // DBG==1

    }

    PerfDbgLog2(tagCBinding, this, "-CBinding::QueryInterface (%lx)[%lx]", hr, *ppv);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBinding::AddRef
//
//  Synopsis:
//
//  Arguments:  [void] --
//
//  Returns:
//
//  History:    11-11-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CBinding::AddRef( void )
{
    DEBUG_ENTER((DBG_BINDING,
                Dword,
                "CBinding::IUnknown::AddRef",
                "this=%#x",
                this
                ));
                
    LONG lRet = ++_CRefs;
    PerfDbgLog1(tagCBinding, this, "CBinding::AddRef (%ld)", lRet);

    DEBUG_LEAVE(lRet);
    return lRet;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBinding::Release
//
//  Synopsis:
//
//  Arguments:  [void] --
//
//  Returns:
//
//  History:    11-11-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CBinding::Release( void )
{
    DEBUG_ENTER((DBG_BINDING,
                Dword,
                "CBinding::IUnknown::Release",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCBinding, this, "+CBinding::Release");
    LONG lRet = --_CRefs;
    if (_CRefs == 0)
    {
        delete this;
    }
    PerfDbgLog1(tagCBinding, this, "-CBinding::Release (%ld)", lRet);
    
    DEBUG_LEAVE(lRet);
    return lRet;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBinding::Abort
//
//  Synopsis:
//
//  Arguments:  [void] --
//
//  Returns:
//
//  History:    11-11-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBinding::Abort( void )
{
    DEBUG_ENTER((DBG_BINDING,
                Hresult,
                "CBinding::IBinding::Abort",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCBinding, this, "+CBinding::Abort");
    HRESULT     hr = NOERROR;
    
    // AddRef - Release pair to guard this function since it may 
    // call OnStopBinding() and client will re-enter this 
    // Object with a Release() call.

    AddRef();

    if (   (GetOperationState() < OPS_Abort)
        && (GetOperationState() > OPS_Initialized))
    {
        DbgLog(tagCBindingErr, this, ">>> CBinding::Abort");

        // Abort will call OnStopBinding
        TransAssert((_pOInetBdg));
        hr = _pOInetBdg->Abort(E_ABORT, 0);
        if( hr != INET_E_RESULT_DISPATCHED )
        {
            //
            // only set state to OPS_Abort if the the ReportResult
            // has not been dispatched already
            //
            DbgLog(tagCBindingErr, this, ">>> Result already dispatched");
            SetOperationState(OPS_Abort);
        }
    }
    else
    {
        UrlMkAssert(( (   (GetOperationState() < OPS_Stopped)
                       && (GetOperationState() > OPS_Initialized)) ));
        hr = E_FAIL;
    }

    PerfDbgLog1(tagCBinding, this, "-CBinding::Abort (hr:%lx)", hr);

    // release
    Release();

    DEBUG_LEAVE(hr);
    return hr;
}
//+---------------------------------------------------------------------------
//
//  Method:     CBinding::Suspend
//
//  Synopsis:
//
//  Arguments:  [void] --
//
//  Returns:
//
//  History:    11-11-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBinding::Suspend( void )
{
    DEBUG_ENTER((DBG_BINDING,
                Hresult,
                "CBinding::IBinding::Suspend",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCBinding, this, "+CBinding::Suspend");
    HRESULT     hr = E_FAIL;

#ifdef SUSPEND_WORKING
    if (   (GetOperationState() < OPS_Stopped)
        && (GetOperationState() > OPS_Initialized))
    {
        SetOperationState(OPS_Suspend);
    }
    else
    {
        UrlMkAssert(( (   (GetOperationState() < OPS_Stopped)
                       && (GetOperationState() > OPS_Initialized)) ));
    }
#endif //SUSPEND_WORKING

    hr = _pOInetBdg->Suspend();

#ifdef UNUSED
    UrlMkAssert((_dwState == OPS_Downloading));

    _dwState = OPS_Suspend;
    if (_pOInetBdg)
    {
        _pOInetBdg->SetOperationState(OPS_Suspend);
    }
#endif //UNUSED

    PerfDbgLog1(tagCBinding, this, "-CBinding::Suspend (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}
//+---------------------------------------------------------------------------
//
//  Method:     CBinding::Resume
//
//  Synopsis:
//
//  Arguments:  [void] --
//
//  Returns:
//
//  History:    11-11-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBinding::Resume( void )
{
    DEBUG_ENTER((DBG_BINDING,
                Hresult,
                "CBinding::IBinding::Resume",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCBinding, this, "+CBinding::Resume");
    HRESULT     hr = NOERROR;


    if (GetOperationState() == OPS_Suspend)
    {
        SetOperationState(OPS_Downloading);
    }
    else
    {
        UrlMkAssert(( GetOperationState() == OPS_Suspend ));
    }
    hr = _pOInetBdg->Resume();

    PerfDbgLog1(tagCBinding, this, "-CBinding::Resume (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}
//+---------------------------------------------------------------------------
//
//  Method:     CBinding::SetPriority
//
//  Synopsis:
//
//  Arguments:  [nPriority] --
//
//  Returns:
//
//  History:    11-11-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBinding::SetPriority(LONG nPriority)
{
    DEBUG_ENTER((DBG_BINDING,
                Hresult,
                "CBinding::IBinding::SetPriority",
                "this=%#x, %d",
                this, nPriority
                ));
                
    PerfDbgLog1(tagCBinding, this, "+CBinding::SetPriority (%ld)", nPriority);
    HRESULT     hr = NOERROR;

    _nPriority = nPriority;

    PerfDbgLog1(tagCBinding, this, "-CBinding::SetPriority (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}
//+---------------------------------------------------------------------------
//
//  Method:     CBinding::GetPriority
//
//  Synopsis:
//
//  Arguments:  [pnPriority] --
//
//  Returns:
//
//  History:    11-11-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBinding::GetPriority(LONG *pnPriority)
{
    DEBUG_ENTER((DBG_BINDING,
                Hresult,
                "CBinding::IBinding::GetPriority",
                "this=%#x, %#x",
                this, pnPriority
                ));
                
    PerfDbgLog(tagCBinding, this, "+CBinding::GetPriority");
    HRESULT     hr = NOERROR;

    if (!pnPriority)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        *pnPriority = _nPriority;
    }

    PerfDbgLog1(tagCBinding, this, "-CBinding::GetPriority (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBinding::GetBindResult
//
//  Synopsis:
//
//  Arguments:  [pnPriority] --
//
//  Returns:
//
//  History:    11-11-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBinding::GetBindResult(CLSID *pclsidProtocol, DWORD *pdwResult, LPWSTR *pszResult,DWORD *pdwReserved)
{
    DEBUG_ENTER((DBG_BINDING,
                Hresult,
                "CBinding::IBinding::GetBindResult",
                "this=%#x, %#x, %#x, %#x, %#x",
                this, pclsidProtocol, pdwResult, pszResult, pdwReserved
                ));
                
    PerfDbgLog(tagCBinding, this, "+CBinding::GetBindResult");
    HRESULT     hr = NOERROR;

    if (!pdwResult || !pszResult || pdwReserved)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        HRESULT  hrRet = NOERROR;
        *pdwResult = 0;
        *pszResult = 0;
        *pclsidProtocol = CLSID_NULL;

        if ((hrRet = GetInstantiateHresult()) != NOERROR)
        {
            *pdwResult = (DWORD) hrRet;
            TransAssert ((  (_hrBindResult == INET_E_CANNOT_INSTANTIATE_OBJECT)
                         || (_hrBindResult == INET_E_CANNOT_LOAD_DATA) ));
        }
        else if (_hrBindResult != NOERROR)
        {
            *pclsidProtocol = _clsidProtocol;
            *pszResult = OLESTRDuplicate(_pwzResult);

            UrlMkAssert(( (_dwBindError != 0) || (_hrBindResult != NOERROR) ));

            if (_dwBindError == 0)
            {
                _dwBindError = _hrBindResult;
            }
            *pdwResult = _dwBindError;
        }
    }

    PerfDbgLog3(tagCBinding, this, "-CBinding::GetBindResult (hr:%lx,_hrBindResult;%lx, pdwResult:%lx)", hr, _hrBindResult, *pdwResult);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBinding::QueryOption
//
//  Synopsis:   Calls QueryOptions on
//
//  Arguments:  [dwOption] --
//              [pBuffer] --
//              [pcbBuf] --
//
//  Returns:
//
//  History:    4-10-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBinding::QueryOption(DWORD dwOption, LPVOID pBuffer, DWORD *pcbBuf)
{
    DEBUG_ENTER((DBG_BINDING,
                Hresult,
                "CBinding::IWinInetHttpInfo::QueryOption",
                "this=%#x, %#x, %#x, %#x",
                this, dwOption, pBuffer, pcbBuf
                ));
                
    HRESULT hr = NOERROR;
    PerfDbgLog(tagCBinding, this, "+CBinding::QueryOption");
    VDATEPTROUT(pcbBuf, DWORD*);

    if (   (GetOperationState() < OPS_Stopped)
        && (GetOperationState() > OPS_Initialized))
    {
        TransAssert((_fCanGetIWinInetInfo || _fCanGetIWinInetHttpInfo));
        if (_fCanGetIWinInetInfo)
        {
            IWinInetInfo    *pIWinInetInfo;
            hr = _pOInetBdg->QueryInterface(IID_IWinInetInfo, (void **)&pIWinInetInfo);
            if (S_FALSE == hr) 
                hr = E_NOINTERFACE;//see bug 99754
            if (SUCCEEDED(hr)) 
            {
                hr = pIWinInetInfo->QueryOption(dwOption, pBuffer, pcbBuf);
                //dont keep the reference..release it immdly.
                pIWinInetInfo->Release();
            }
        }
        else if (_fCanGetIWinInetHttpInfo)
        {
            IWinInetHttpInfo    *pIWinInetHttpInfo;
            hr = _pOInetBdg->QueryInterface(IID_IWinInetHttpInfo, (void **)&pIWinInetHttpInfo);
            if (S_FALSE == hr) 
                hr = E_NOINTERFACE;//see bug 99754
            if (SUCCEEDED(hr))
            {
                hr = pIWinInetHttpInfo->QueryOption(dwOption, pBuffer, pcbBuf);
                //dont keep the reference..release it immdly.
                pIWinInetHttpInfo->Release();
            }
        }
    }
    else
    {
        hr = E_FAIL;
    }

    PerfDbgLog1(tagCBinding, this, "-CBinding::QueryOption (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBinding::QueryInfo
//
//  Synopsis:   Calls QueryInfos on
//
//  Arguments:  [dwOption] --
//              [pBuffer] --
//              [pcbBuf] --
//              [pdwFlags] --
//              [pdwReserved] --
//
//  Returns:
//
//  History:    4-10-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBinding::QueryInfo(DWORD dwOption, LPVOID pBuffer, DWORD *pcbBuf, DWORD *pdwFlags, DWORD *pdwReserved)
{
    DEBUG_ENTER((DBG_BINDING,
                Hresult,
                "CBinding::IWinInetHttpInfo::QueryInfo",
                "this=%#x, %#x, %#x, %#x, %#x, %#x",
                this, dwOption, pBuffer, pcbBuf, pdwFlags, pdwReserved
                ));
                
    HRESULT hr = NOERROR;
    PerfDbgLog(tagCBinding, this, "+CBinding::QueryInfo");
    VDATEPTROUT(pcbBuf, DWORD*);

    if (   (GetOperationState() < OPS_Stopped)
        && (GetOperationState() > OPS_Initialized))
    {
        TransAssert((_fCanGetIWinInetHttpInfo));
        IWinInetHttpInfo    *pIWinInetHttpInfo;
        hr = _pOInetBdg->QueryInterface(IID_IWinInetHttpInfo, (void **)&pIWinInetHttpInfo);
        if (S_FALSE == hr)
            hr = E_NOINTERFACE;//see bug 99754
        if (SUCCEEDED(hr))
        {
            hr = pIWinInetHttpInfo->QueryInfo(dwOption, pBuffer, pcbBuf, pdwFlags, pdwReserved);
            //dont keep the reference..release it immdly.
            pIWinInetHttpInfo->Release();
        }
    }
    else
    {
        hr = E_FAIL;
    }

    PerfDbgLog1(tagCBinding, this, "-CBinding::QueryInfo (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

// IServiceProvider methods

//+---------------------------------------------------------------------------
//
//  Method:     CBinding::QueryService
//
//  Synopsis:   Calls QueryInfos on
//
//  Arguments:  [rsid] --
//              [riid] --
//              [ppvObj] --
//
//  Returns:
//
//  History:    4-10-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT IUnknown_QueryService(IUnknown* punk, REFGUID rsid, REFIID riid, void ** ppvObj)
{
    DEBUG_ENTER((DBG_BINDING,
                Hresult,
                "IUnknown_QueryService",
                "%#x, %#x, %#x, %#x",
                punk, &rsid, &riid, ppvObj
                ));
                
    HRESULT hr = E_NOINTERFACE;

    *ppvObj = 0;

    if (punk)
    {
        IServiceProvider *pSrvPrv;
        hr = punk->QueryInterface(IID_IServiceProvider, (void **) &pSrvPrv);
        if (hr == NOERROR)
        {
            hr = pSrvPrv->QueryService(rsid,riid, ppvObj);
            pSrvPrv->Release();
        }
    }

    DEBUG_LEAVE(hr);
    return hr;
}

HRESULT CBinding::QueryService(REFGUID rsid, REFIID riid, void ** ppvObj)
{
    DEBUG_ENTER((DBG_BINDING,
                Hresult,
                "CBinding::IServiceProvider::QueryService",
                "this=%#x, %#x, %#x, %#x",
                this, &rsid, &riid, ppvObj
                ));
                
    PerfDbgLog(tagCBinding, this, "+CBinding::QueryService");
    HRESULT hr = E_NOINTERFACE;
    VDATETHIS(this);
    UrlMkAssert((ppvObj));

    hr = IUnknown_QueryService(_pBSCB, rsid, riid, ppvObj);

    PerfDbgLog1(tagCBinding, this, "-CBinding::QueryService (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}


//IOInetBindInfo methods
//+---------------------------------------------------------------------------
//
//  Method:     CBinding::GetBindInfo
//
//  Synopsis:
//
//  Arguments:  [pdwBINDF] --
//              [pbindinfo] --
//
//  Returns:
//
//  History:    11-07-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CBinding::GetBindInfo(DWORD *pdwBINDF, BINDINFO *pbindinfo)
{
    DEBUG_ENTER((DBG_BINDING,
                Hresult,
                "CBinding::IInternetBindInfo::GetBindInfo",
                "this=%#x, %#x, %#x",
                this, pdwBINDF, pbindinfo
                ));
                
    PerfDbgLog(tagCBinding, this, "+CBinding::GetBindInfo");
    HRESULT hr = NOERROR;

    TransAssert((pdwBINDF && pbindinfo));

    *pdwBINDF = _grfBINDF;
    hr = CopyBindInfo(&_BndInfo, pbindinfo ); // Src->Dest

    //for IE6 bug 1898.
    //For hglobals, copybindinfo allocates new handle and copies over the source data,
    //but uses the source as pUnkForRelease and AddRefs it.. but the source has no reference
    //to the new handle to free.
    //So free the addrefed pUnkForRelease and NULL it, so that ReleaseStgMedium() calls
    //GlobalFree().
    //There is also a bug in ReleaseBindInfo(), where we always call ReleaseStgMedium(),
    //irrespective of the pUnkForRelease member - this fix doesn't depend on that behavior,
    //but it does need the receiver of the stgmed in this bindinfo to ReleaseStgMedium() either
    //indirectly through ReleaseBindInfo() or directly.
    if (SUCCEEDED(hr))
    {
        STGMEDIUM* pStgmed = &(pbindinfo->stgmedData);
        if ( (pStgmed->tymed == TYMED_HGLOBAL) &&
             (pStgmed->hGlobal) &&
             (pStgmed->pUnkForRelease) )
        {
             pStgmed->pUnkForRelease->Release();
             pStgmed->pUnkForRelease = NULL;
        }
    }
    
    PerfDbgLog1(tagCBinding, this, "-CBinding::GetBindInfo (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBinding::GetBindString
//
//  Synopsis:
//
//  Arguments:  [ulStringType] --
//              [ppwzStr] --
//              [cEl] --
//              [pcElFetched] --
//
//  Returns:
//
//  History:    11-07-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CBinding::GetBindString(ULONG ulStringType, LPOLESTR *ppwzStr, ULONG cEl, ULONG *pcElFetched)
{
    DEBUG_ENTER((DBG_BINDING,
                Hresult,
                "CBinding::IInternetBindInfo::GetBindString",
                "this=%#x, %#x, %#x, %#x, %#x",
                this, ulStringType, ppwzStr, cEl, pcElFetched
                ));
                
    PerfDbgLog(tagCBinding, this, "+CTransaction::GetBindString");
    HRESULT hr = INET_E_USE_DEFAULT_SETTING;

    switch (ulStringType)
    {
    case BINDSTRING_HEADERS     :
        break;
    case BINDSTRING_ACCEPT_MIMES:
        hr = _pCTransData->GetAcceptMimes(ppwzStr,cEl, pcElFetched);
        break;
    case BINDSTRING_EXTRA_URL   :
        break;
    case BINDSTRING_LANGUAGE    :
        break;
    case BINDSTRING_USERNAME    :
        break;
    case BINDSTRING_PASSWORD    :
        break;
    case BINDSTRING_ACCEPT_ENCODINGS:
        break;
    case BINDSTRING_URL:
        if( _lpwszUrl )
        {
            LPWSTR pwzURL = NULL;
            pwzURL = OLESTRDuplicate(_lpwszUrl);
            if( pwzURL )
            {
                *ppwzStr = pwzURL,
                *pcElFetched = 1;
                hr = NOERROR;
            }
            else
            {
                hr = E_OUTOFMEMORY;
                *pcElFetched = 0;
            }
        }
        break;
    case BINDSTRING_USER_AGENT  :
    case BINDSTRING_POST_COOKIE :
    case BINDSTRING_POST_DATA_MIME:
        {
        hr = NOERROR;
        // QI on IBSC for interface
        if (_pBindInfo == NULL)
        {
            hr = LocalQueryInterface(IID_IInternetBindInfo, (void **)&_pBindInfo);
        }
        
        if ( (hr == NOERROR) && _pBindInfo)
        {
            hr = _pBindInfo->GetBindString(ulStringType, ppwzStr, cEl, pcElFetched);
        }
        }
        break;

    case BINDSTRING_IID:
        TransAssert(_piidRes);
        if (_piidRes)
        {
            hr = StringFromCLSID(*_piidRes, ppwzStr);
            if (pcElFetched)
            {
                *pcElFetched = (SUCCEEDED(hr)) ? (1) : (0);
            }
        }
        else
        {
            hr = E_UNEXPECTED;
            *pcElFetched = 0;
        }
        break;

    case BINDSTRING_FLAG_BIND_TO_OBJECT:
        *ppwzStr = new WCHAR[FLAG_BTO_STR_LENGTH];

        if (*ppwzStr)
        {
            if (_fBindToObject)
            {
                 StrCpyNW(*ppwzStr, FLAG_BTO_STR_TRUE,
                          lstrlenW(FLAG_BTO_STR_TRUE) + 1);
            }
            else
            {
                StrCpyNW(*ppwzStr, FLAG_BTO_STR_FALSE,
                         lstrlenW(FLAG_BTO_STR_FALSE) + 1);
            }
            *pcElFetched = 1;
            hr = S_OK;
        }
        else
        {
            *pcElFetched = 0;
            hr = E_OUTOFMEMORY;
        }
       
        break;

    case BINDSTRING_PTR_BIND_CONTEXT:
        if (!_pBndCtx) {
            hr = E_UNEXPECTED;
            *pcElFetched = 0;
        }
        else {
            *ppwzStr = new WCHAR[MAX_DWORD_DIGITS + 1];
            
            if (*ppwzStr)
            {
                wnsprintfW(*ppwzStr, MAX_DWORD_DIGITS, 
#ifdef _WIN64
                           L"%I64d", 
#else
                           L"%ld", 
#endif
                           (DWORD_PTR)_pBndCtx);

                *pcElFetched = 1;
                _pBndCtx->AddRef();
                hr = S_OK;
            }
            else
            {
                *pcElFetched = 0;
                hr = E_OUTOFMEMORY;
            }
        }

        break;

    default:
        TransAssert((FALSE));
    }

    PerfDbgLog1(tagCBinding, this, "-CBinding::GetBindString (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CBindProtocol::CBindProtocol
//
//  Synopsis:
//
//  Arguments:  [pUnk] --
//
//  Returns:
//
//  History:    11-11-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
CBindProtocol::CBindProtocol() : _CRefs()
{
    DEBUG_ENTER((DBG_BINDING,
                None,
                "CBindProtocol::CBindProtocol",
                "this=%#x",
                this
                ));
                
    _pUnk = NULL;
    
    DEBUG_LEAVE(0);
}

//+---------------------------------------------------------------------------
//
//  Method:     CBindProtocol::~CBindProtocol
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    11-11-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
CBindProtocol::~CBindProtocol()
{
    DEBUG_ENTER((DBG_BINDING,
                None,
                "CBindProtocol::~CBindProtocol",
                "this=%#x",
                this
                ));
                
    DEBUG_LEAVE(0);
}
//+---------------------------------------------------------------------------
//
//  Method:     CBindProtocol::QueryInterface
//
//  Synopsis:
//
//  Arguments:  [riid] --
//              [ppv] --
//
//  Returns:
//
//  History:    11-11-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBindProtocol::QueryInterface( REFIID riid, void **ppv )
{
    DEBUG_ENTER((DBG_BINDING,
                Hresult,
                "CBindProtocol::IUnknown::QueryInterface",
                "this=%#x, %#x, %#x",
                this, &riid, ppv
                ));
                
    HRESULT     hr = NOERROR;

    PerfDbgLog2(tagCBinding, this, "+CBindProtocol::QueryInterface (%lx, %lx)", riid, ppv);

    if (   IsEqualIID(riid, IID_IUnknown)
        || IsEqualIID(riid, IID_IBindProtocol) )
    {
        *ppv = (void FAR *)this;
        AddRef();
    }
    else
    {
        *ppv = NULL;
        hr = E_NOINTERFACE;
#if DBG==1
        //LPSTR lpszName = GetInterfaceName(riid);
        //DbgLog3(tagCBinding, this, "CBindProtocol::QI(pUnkObj) >%s< hr:%lx [%lx]", lpszName, hr, *ppv);
#endif // DBG==1

    }

    PerfDbgLog2(tagCBinding, this, "-CBindProtocol::QueryInterface (%lx)[%lx]", hr, *ppv);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBindProtocol::AddRef
//
//  Synopsis:
//
//  Arguments:  [void] --
//
//  Returns:
//
//  History:    11-11-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CBindProtocol::AddRef( void )
{
    DEBUG_ENTER((DBG_BINDING,
                Dword,
                "CBindProtocol::IUnknown::AddRef",
                "this=%#x",
                this
                ));
                
    LONG lRet = _CRefs++;
    PerfDbgLog1(tagCBinding, this, "CBindProtocol::AddRef (%ld)", lRet);

    DEBUG_LEAVE(lRet);
    return lRet;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBindProtocol::Release
//
//  Synopsis:
//
//  Arguments:  [void] --
//
//  Returns:
//
//  History:    11-11-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CBindProtocol::Release( void )
{
    DEBUG_ENTER((DBG_BINDING,
                Dword,
                "CBindProtocol::IUnknown::Release",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCBinding, this, "+CBindProtocol::Release");

    LONG lRet = --_CRefs;
    if (_CRefs == 0)
    {
        if (_pUnk)
        {
            PerfDbgLog(tagCBinding, this, "+CBindProtocol::Release _pUnk");
            _pUnk->Release();
            _pUnk = NULL;
            PerfDbgLog(tagCBinding, this, "-CBindProtocol::Release _pUnk");
        }

        delete this;
    }

    PerfDbgLog1(tagCBinding, this, "-CBindProtocol::Release (%ld)", lRet);

    DEBUG_LEAVE(lRet);
    return lRet;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBindProtocol::CreateBinding
//
//  Synopsis:
//
//  Arguments:  [url] --
//              [pBCtx] --
//              [ppBdg] --
//
//  Returns:
//
//  History:    11-11-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBindProtocol::CreateBinding(LPCWSTR szUrl, IBindCtx *pBCtx, IBinding **ppBdg)
{
    DEBUG_ENTER((DBG_BINDING,
                Dword,
                "CBindProtocol::IBindProtocol::CreateBinding",
                "this=%#x, %.80wq, %#x, %#x",
                this, szUrl, pBCtx, ppBdg
                ));
                
    PerfDbgLog(tagCBinding, this, "+CBindProtocol::CreateBinding");
    HRESULT hr = NOERROR;

    BIND_OPTS           bindopts;
    CBinding            *pCBdg = NULL;
    VDATEPTROUT(ppBdg, LPVOID);
    VDATEIFACE(pBCtx);

    *ppBdg = NULL;
    // Get the bind options from the bind context
    bindopts.cbStruct = sizeof(BIND_OPTS);
    hr = pBCtx->GetBindOptions(&bindopts);
    ChkHResult(hr);

    hr = CBinding::Create(NULL, szUrl, pBCtx, IID_IStream, FALSE, &pCBdg );
    if (hr != NOERROR)
    {
        DEBUG_LEAVE(hr);
        return hr;
    }

    // Start the download transaction
    {
        LPWSTR pwzExtra = NULL;
        hr = pCBdg->StartBinding(szUrl, pBCtx, IID_IStream, FALSE, &pwzExtra, NULL);
    }

    if (FAILED(hr))
    {
        // the transaction could not be started
        goto End;
    }

    // if the caller doesn't support IBindStatusCallback
    if ( pCBdg->IsAsyncBinding() )
    {
        // Async case: interface is passed on in OnDataAvailable
        *ppBdg = pCBdg;
    }

End:
    if (pCBdg)
    {
        pCBdg->Release();
    }

    PerfDbgLog1(tagCBinding, this, "-CBindProtocol::CreateBinding (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   GetObjectParam
//
//  Synopsis:
//
//  Arguments:  [pbc] --
//              [pszKey] --
//              [riid] --
//              [ppUnk] --
//
//  Returns:
//
//  History:    12-04-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT GetObjectParam(IBindCtx *pbc, LPOLESTR pszKey, REFIID riid, IUnknown **ppUnk)
{
    DEBUG_ENTER((DBG_BINDING,
                Hresult,
                "GetObjectParam",
                "%#x, %#x, %#x, %#x",
                pbc, pszKey, &riid, ppUnk
                ));
                
    PerfDbgLog1(tagCBinding, NULL, "+GetObjectParam (IBindCtx:%lx)", pbc);
    HRESULT hr = E_FAIL;
    IUnknown *pUnk;

    // Try to get an IUnknown pointer from the bind context
    if (pbc)
    {
        hr = pbc->GetObjectParam(pszKey, &pUnk);
    }
    if (FAILED(hr))
    {
        *ppUnk = NULL;
    }
    else
    {
        // Query for riid
        hr = pUnk->QueryInterface(riid, (void **)ppUnk);
        pUnk->Release();

        if (FAILED(hr))
        {
            *ppUnk = NULL;
            DumpIID(riid);
        }
    }

    PerfDbgLog2(tagCBinding, NULL, "-GetObjectParam (IBindCtx:%lx, hr:%lx)", pbc, hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBinding::StartBinding
//
//  Synopsis:
//
//  Arguments:  [fBindToObject] --
//
//  Returns:
//
//  History:    12-04-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CBinding::StartBinding(LPCWSTR szUrl, IBindCtx *pbc, REFIID riid, BOOL fBindToObject, LPWSTR *ppwzExtra, LPVOID *ppv )
{
    DEBUG_ENTER((DBG_BINDING,
                Hresult,
                "CBinding::StartBinding",
                "this=%#x, %.80wq, %#x, %#x, %B, %#x, %#x",
                this, szUrl, pbc, &riid, fBindToObject, ppwzExtra, ppv
                ));
                
    PerfDbgLog(tagCBinding, this, "+CBinding::StartTransaction");
    //DbgLog1(tagCBindingErr, this, ">>> CBinding::Start(url=%ws)", szUrl);
    HRESULT hr;
    BOOL fBindingStarted = FALSE;

    UrlMkAssert((ppwzExtra));
    UrlMkAssert((_pBSCB == NULL));

    do
    {
        // Try to get an IBindStatusCallback  pointer from the bind context
        hr = GetObjectParam(pbc, REG_BSCB_HOLDER, IID_IBindStatusCallback, (IUnknown**)&_pBSCB);

        if  (FAILED(hr))
        {
            break;
        }
        UrlMkAssert(( (hr == NOERROR) && _pBSCB ));

        if  (_pBSCB == NULL)
        {
            hr = E_INVALIDARG;
            break;
        }
        _fBindToObject = fBindToObject;
        if (_fBindToObject)
        {
            _grfInternalFlags |= BDGFLAGS_PARTIAL;
            _piidRes = (IID *) &riid;

            // Get the bind options from the bind context
            _bindopts.cbStruct = sizeof(BIND_OPTS);
            hr = pbc->GetBindOptions(&_bindopts);
            if (FAILED(hr))
            {
                break;
            }
        }

        hr = CBindCtx::Create(&_pBndCtx, pbc);

        if (FAILED(hr))
        {
            hr = E_OUTOFMEMORY;
            break;
        }

        {
            int cchWideChar;

            cchWideChar  = wcslen(szUrl) + 2;
            _lpwszUrl = (LPWSTR) new WCHAR [cchWideChar];
            if( !_lpwszUrl )
            {
                hr = E_OUTOFMEMORY;
                break;
            }
            wcscpy(_lpwszUrl, szUrl);
        }

        // call GetBindInfo
        _BndInfo.cbSize = sizeof(BINDINFO);

#if DBG==1
        if (_BndInfo.stgmedData.tymed != TYMED_NULL)
        {
            PerfDbgLog1(tagCBinding, this, "CBinding::StartTransaction ReleaseStgMedium (%lx)", _BndInfo.stgmedData);
        }
#endif // DBG==1

        // Make sure the BINDINFO is released and empty
        ReleaseBindInfo(&_BndInfo);

        _grfBINDF = 0;
        // call IBSC::GetBindInfo
        TransAssert((_BndInfo.stgmedData.tymed == TYMED_NULL));

        hr = CallGetBindInfo(&_grfBINDF, &_BndInfo);

        if( hr == NOERROR && !IsAsyncTransaction() )
        {
            // we need to turn off BINDF_ASYNCSTORAGE for sync binding
            _grfBINDF &= ~BINDF_ASYNCSTORAGE;
        }

        // this call should not fail
        if (FAILED(hr))
        {
            break;
        }

        // turn on direct read - not documented yet for APPs
        if (g_dwSettings & 0x20000000)
        {
            _grfBINDF |= BINDF_DIRECT_READ;
        }

        // check for extend binding (rosebud) 

        // get the bind option for extend binding (low bits)
        // the highest 16 bits is used for additional flags (e.g. wininet flag) 
        DWORD dwExtBindOption = _BndInfo.dwOptions & 0x0000ffff;
        if( dwExtBindOption && !fBindToObject)
        {
            // extend binding (rosebud)
            COInetSession* pSession = NULL;
            IOInetProtocol* pProt = NULL;

            hr = GetCOInetSession(0, &pSession, 0);
            if( hr != NOERROR )
            {
                break;
            }

            CLSID clsid = CLSID_NULL;
            DWORD dwLocation = 0;
            hr = pSession->CreateFirstProtocol(
                _lpwszUrl, NULL, NULL, &pProt, &clsid, &dwLocation, dwExtBindOption);
            pSession->Release();

            if( hr != NOERROR )
            {
                break;
            }


            StartParam param;
            param.iid =  riid;
            param.pIBindCtx = pbc; 
            param.pItf = NULL;

            // the interface ptr is returned via param.pItf
            hr = pProt->Start(_lpwszUrl, NULL, NULL, 0, (DWORD_PTR) &param );

            // release the pluggable protocol
            pProt->Release();

            if( hr == NOERROR && param.pItf )
            {
                // we are done, return the pointer
                *ppv = param.pItf;
                hr = INET_E_USE_EXTEND_BINDING;
                break; 
            }
            else
            if( hr != INET_E_USE_DEFAULT_PROTOCOLHANDLER )
            {
                break;
            }
                
            // continue with the normal binding process...
        }
        
        {
            // check for iid (only for BindToStorage)
            if( !fBindToObject && (IsRequestedIIDValid(riid) == FALSE) )
            {
                hr = E_INVALIDARG;
                break;
            }

            if (!IsOInetProtocol(pbc, szUrl))
            { 
                hr = INET_E_UNKNOWN_PROTOCOL;
                break;
            }


            DWORD dwObjectsFlags = OIBDG_APARTMENTTHREADED;
            if (_fBindToObject)
            {
                dwObjectsFlags |= BDGFLAGS_PARTIAL;
            }

            hr = GetTransactionObjects(_pBndCtx, _lpwszUrl, NULL, NULL, &_pOInetBdg, dwObjectsFlags, &_pCTransData);
        }

        if (hr == S_OK)
        {
            TransAssert((!_pCTransData));
            // create the transaction data object
            // Note: the transdat object has a refcount
            //       and must be released when done
            hr = CTransData::Create(_lpwszUrl, _grfBINDF, riid, _pBndCtx, _fBindToObject, &_pCTransData);
            if (SUCCEEDED(hr))
            {
                UrlMkAssert((_pCTransData != NULL && "CTransData invalid"));
                _pBndCtx->SetTransData(_pCTransData);
            }
        }
        else if (hr == S_FALSE)
        {
            // found an existing transaction
            UrlMkAssert((_pCTransData != NULL && "CTransData invalid"));
            if (fBindToObject)
                _grfInternalFlags |= BDGFLAGS_BTS_BTO;
            else
                _grfInternalFlags |= BDGFLAGS_ATTACHED;
    
            hr = _pCTransData->Initialize(_lpwszUrl, _grfBINDF, riid, _pBndCtx, fBindToObject);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }

        if (FAILED(hr))
        {
            break;
        }

        // hand back to pointer to of extra info
        // to update the url
        *ppwzExtra = (_BndInfo.szExtraInfo) ? _BndInfo.szExtraInfo : NULL;

        if (_pCTransData->SetDataSink(_grfBINDF) == DataSink_Unknown)
        {
            hr = E_INVALIDARG;
        }

        if (   (_pCTransData->IsFileRequired())
            || (IsKnownProtocol(_lpwszUrl) == DLD_PROTOCOL_NONE) )
        {
            PerfDbgLog(tagCBinding, this, "---TURN ON NEEDFILE!---");
            // turn on flag to request file from protocol
            _grfBINDF |= BINDF_NEEDFILE;
        }

        if (SUCCEEDED(hr))
        {
            PerfDbgLog(tagCBinding, this, "---BINDF_FROMURLMON---");
            // turn on flag indicating the binding is from urlmon
            _grfBINDF |= BINDF_FROMURLMON;

            if( _fBindToObject )
            {
                _BndInfo.dwOptions |= BINDINFO_OPTIONS_BINDTOOBJECT;
            }
        }

        if (FAILED(hr))
        {
            break;
        }

        // send the OnStartBinding notification
        hr = CallOnStartBinding(NULL, this);
        fBindingStarted = TRUE;

        // check if the user did abort
        if (SUCCEEDED(hr))
        {
            OperationState opSt = GetOperationState();
            UrlMkAssert((opSt > OPS_Initialized));

            if (opSt == OPS_Abort)
            {
                hr = E_ABORT;
            }
        }

        BOOL fIsSync = (IsAsyncTransaction() == FALSE);

        if ( SUCCEEDED(hr))
        {
            // Note: check if url got redirected
            //       and report redirection url

            if (_pwzRedirectUrl)
            {
                PerfDbgLog1(tagCBinding, this, "StartTransaction OnProgress REDIRECTING _pBSCP(%lx)", _pBSCB);
                hr = CallOnProgress( 0, 0, BINDSTATUS_REDIRECTING,_pwzRedirectUrl );
                PerfDbgLog1(tagCBinding, this, "StartTransaction OnProgress REDIRECTING _pBSCP(%lx)", _pBSCB);
            }
        }

        if (    SUCCEEDED(hr))
        {
            DWORD dwBindFlags = OIBDG_APARTMENTTHREADED | PI_MIMEVERIFICATION | PI_DOCFILECLSIDLOOKUP;

            if (fIsSync)
            {
                dwBindFlags |= PI_SYNCHRONOUS;
            }
            if(_grfBINDF & BINDF_PREFERDEFAULTHANDLER)
            {
                dwBindFlags |= BINDF_PREFERDEFAULTHANDLER;
            }
            if (_grfBINDF & BINDF_FREE_THREADED)
            {
                dwBindFlags &= ~OIBDG_APARTMENTTHREADED;
            }
            if (_fBindToObject)
            {
                dwBindFlags |= BDGFLAGS_PARTIAL | PI_CLASSINSTALL;
            }

            if (_grfInternalFlags & BDGFLAGS_BTS_BTO)
            {
                dwBindFlags |= BDGFLAGS_BTS_BTO;
            }
            
            if (_grfInternalFlags & BDGFLAGS_ATTACHED)
            {
                dwBindFlags |= BDGFLAGS_ATTACHED;
            }
            
            if (_pOInetBdg)
            {
                // Just before starting the transaction give it the priority.

                IOInetPriority * pOInetPriority = NULL;
                if (_pOInetBdg->QueryInterface(IID_IOInetPriority, (void **) &pOInetPriority) == S_OK)
                {
                    pOInetPriority->SetPriority(_nPriority);
                    pOInetPriority->Release();
                }
            }

            if (   _pCTransData->InProgress() != S_FALSE
                || !_pCTransData->IsRemoteObjectReady() )
            {
                // guard the transaction object
                // the operation might complete synchronous
                _pOInetBdg->AddRef();

                hr = _pCTransData->OnStart(_pOInetBdg);
                TransAssert((hr == NOERROR));
                if (hr == NOERROR)
                {
                    hr = _pOInetBdg->Start(_lpwszUrl, (IOInetProtocolSink *) this, (IOInetBindInfo *) this, dwBindFlags, 0);
                }

                _pOInetBdg->Release();
            }
            else
            {
                // call OnProgress for mime type and filename
                //
                DWORD dwSize = _pCTransData->GetDataSize();
                if (_pCTransData->GetMimeType())
                {
                    OnTransNotification(BINDSTATUS_MIMETYPEAVAILABLE, dwSize, dwSize, (LPWSTR)_pCTransData->GetMimeType(), NOERROR);
                }
                if (_pCTransData->GetFileName())
                {
                    OnTransNotification(BINDSTATUS_CACHEFILENAMEAVAILABLE, dwSize, dwSize, _pCTransData->GetFileName(), NOERROR );
                }
                // report data - will call OnStopBinding
                OnTransNotification(BINDSTATUS_ENDDOWNLOADDATA, dwSize, dwSize,0 , NOERROR);
            }
        }

        break;
    } while (TRUE);

    if ( FAILED(hr))
    {
        // call OnStopBinding in case of error
        HRESULT hr1 = NOERROR;
        if ((_pBSCB != NULL) && fBindingStarted)
        {
            _hrBindResult = hr;
            hr1 = CallOnStopBinding(hr, NULL);
        }
        
        if (_pOInetBdg)
        {
            _pOInetBdg->Terminate(0);
            _pOInetBdg->Release();
            _pOInetBdg = NULL;
        }
    }

    PerfDbgLog(tagCBinding, this, "-CBinding::StartTransaction");

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBinding::CompleteTransaction
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    12-22-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBinding::CompleteTransaction()
{
    DEBUG_ENTER((DBG_BINDING,
                Hresult,
                "CBinding::CompleteTransaction",
                "this=%#x",
                this
                ));
                
    HRESULT hr = NOERROR;
    PerfDbgLog(tagCBinding, this, "+CBinding::CompleteTransaction");

    if (_hrBindResult != NOERROR)
    {
        hr = _hrBindResult;
    }

    PerfDbgLog1(tagCBinding, this, "-CBinding::CompleteTransaction (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBinding::OnTransNotification
//
//  Synopsis:
//
//  Arguments:  [pCTP] --
//
//  Returns:
//
//  History:    12-11-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(BOOL) CBinding::OnTransNotification(BINDSTATUS NotMsg, DWORD dwCurrentSize, DWORD dwTotalSize,
                                                  LPWSTR pwzStr, HRESULT hrINet)
{
    DEBUG_ENTER((DBG_BINDING,
                Bool,
                "CBinding::OnTransNotification",
                "this=%#x, %#x, %#x, %#x, %.80wq, %#x",
                this, NotMsg, dwCurrentSize, dwTotalSize, pwzStr, hrINet
                ));
                
    PerfDbgLog(tagCBinding, this, "+CBinding::OnTransNotification");
    BOOL fRelease = FALSE;
    HRESULT hr = NOERROR;
    UrlMkAssert((_dwThreadId));

    if (   (   (_dwThreadId == GetCurrentThreadId())
            || (_grfBINDF & BINDF_FREE_THREADED))
        && (_grfInternalFlags & BDGFLAGS_NOTIFICATIONS)
        && (_pBSCB != NULL))
    {
        switch (NotMsg)
        {
        case BINDSTATUS_PROTOCOLCLASSID:
            UrlMkAssert((pwzStr));
            CLSIDFromString(pwzStr, &_clsidProtocol);
            break;

        case BINDSTATUS_MIMETYPEAVAILABLE:
            UrlMkAssert((pwzStr));
            _pCTransData->SetMimeType(pwzStr);
            CallOnProgress(0,0,BINDSTATUS_MIMETYPEAVAILABLE, pwzStr);
            break;

        case BINDSTATUS_CLASSIDAVAILABLE:
            UrlMkAssert((pwzStr));
            CLSIDFromString(pwzStr, &_clsidIn);
            break;

        case BINDSTATUS_IUNKNOWNAVAILABLE:
            if( _fBindToObject )
            {
                IUnknown                  *pUnk = NULL;

                _fClsidFromProt = TRUE;

                // the object should be instantiated now
                if (SUCCEEDED(hr))
                {
                    hr = _pBndCtx->GetObjectParam(SZ_IUNKNOWN_PTR, &pUnk);
                }

                if (SUCCEEDED(hr))
                {
                    // The following four lines of code are a fix for bug#89397.
                    // There are only a couple of clients who are already using
                    // this notification, so we can ensure this state change doesn't
                    // affect their protocols.
                    OperationState opSt = GetOperationState();
                    if (opSt >= OPS_StartBinding && opSt < OPS_Downloading) 
                    {
                        SetOperationState(OPS_Downloading);
                    }

                    hr = CallOnObjectAvailable(*_piidRes, pUnk);
                    pUnk->Release();
                }

                if (hr != NOERROR)
                {
                    SetInstantiateHresult(hr);
                }

                // return the download result in case if no error
                if (hr == NOERROR || GetHResult() != NOERROR)
                {
                    hr = GetHResult();
                }

                _hrBindResult = hr;
                hr = CallOnStopBinding(hr, NULL);
                fRelease = TRUE;
            }
            break;

        case BINDSTATUS_CLSIDCANINSTANTIATE:
            if(IsEqualGUID(_clsidIn, CLSID_NULL) && pwzStr)
            {
                CLSIDFromString(pwzStr, &_clsidIn);
            }
           
            if( _fBindToObject )
            {
                _fClsidFromProt = TRUE;

                // the object should be instantiated now
                hr = OnObjectAvailable(0,dwCurrentSize,dwTotalSize,TRUE);
                if (hr != NOERROR)
                {
                    SetInstantiateHresult(hr);
                }

                // return the download result in case if no error
                if (hr == NOERROR || GetHResult() != NOERROR)
                {
                    hr = GetHResult();
                }

                _hrBindResult = hr;
                hr = CallOnStopBinding(hr, NULL);
                fRelease = TRUE;
            }
            break;


        case BINDSTATUS_PROXYDETECTING :
            // indicate resolving proxyserver
            if (hrINet == NOERROR)
            {
                hr = CallOnProgress(0,0,BINDSTATUS_PROXYDETECTING,NULL );                
            }
            break;

        case BINDSTATUS_CACHEFILENAMEAVAILABLE :
            UrlMkAssert((pwzStr));
            _pCTransData->SetFileName(pwzStr);
            break;

        case BINDSTATUS_FINDINGRESOURCE   :
            // indicate resolving name - pass on server/proxy name
            if (hrINet == NOERROR)
            {
                hr = CallOnProgress(0,0,BINDSTATUS_FINDINGRESOURCE,pwzStr );
                PerfDbgLog1(tagCBinding, this, "OnTransNotification done on OnProgress _pBSCP(%lx)", _pBSCB);
            }
            break;

        case BINDSTATUS_SENDINGREQUEST  :
            // indicate resolving name - pass on server/proxy name
            if (hrINet == NOERROR)
            {
                hr = CallOnProgress(0,0,BINDSTATUS_SENDINGREQUEST,pwzStr );
                PerfDbgLog1(tagCBinding, this, "OnTransNotification done on OnProgress _pBSCP(%lx)", _pBSCB);
            }
            break;


        case BINDSTATUS_CONNECTING      :
            // inidicate progress connecting - pass on address
            if (hrINet == NOERROR)
            {
                hr = CallOnProgress(0,0,BINDSTATUS_CONNECTING, pwzStr);
                PerfDbgLog1(tagCBinding, this, "OnTransNotification done on OnProgress _pBSCP(%lx)", _pBSCB);
            }
            break;

        case BINDSTATUS_REDIRECTING     :
            if (hrINet == NOERROR)
            {
                TransAssert((pwzStr));
                PerfDbgLog1(tagCBinding, this, "OnTransNotification calling OnProgress _pBSCP(%lx)", _pBSCB);
                hr = CallOnProgress(
                            dwCurrentSize,   // ulProgress
                            dwTotalSize,     // ulProgressMax
                            BINDSTATUS_REDIRECTING,
                            pwzStr                  // new url
                            );

                PerfDbgLog1(tagCBinding, this, "OnTransNotification done on OnProgress _pBSCP(%lx)", _pBSCB);

                TransAssert((_lpwszUrl));

                {
                    DWORD dwLenOld = wcslen(_lpwszUrl);
                    DWORD dwLenNew = wcslen(pwzStr);
                    if (dwLenOld < dwLenNew)
                    {
                        delete _lpwszUrl;
                        _lpwszUrl = (LPWSTR) new WCHAR [dwLenNew + 1];

                    }
                    if (_lpwszUrl && pwzStr)
                    {
                        wcscpy(_lpwszUrl, pwzStr);
                    }
                }
                _pCTransData->SetRedirectUrl(pwzStr);
            }
            break;

        case BINDSTATUS_ENDDOWNLOADDATA:
            PerfDbgLog(tagCBinding, this, "CBinding::OnTransNotification Notify_Done");
            // more work here for data notification
            //UrlMkAssert((errCode == INLERR_OK && "Notify_Done with Error"));

            if (hrINet == NOERROR)
            {
                PerfDbgLog1(tagCBinding, this, "OnTransNotification calling OnProgress _pBSCP(%lx)", _pBSCB);

                if (!_fSentFirstNotification)
                {
                    hr = CallOnProgress(dwCurrentSize, dwTotalSize,
                                        BINDSTATUS_BEGINDOWNLOADDATA, _lpwszUrl);

                    LPCWSTR pwzFilename = _pCTransData->GetFileName();

                    // a filename is not always available
                    if (pwzFilename)
                    {
                        hr = CallOnProgress(dwCurrentSize, dwTotalSize,
                                            BINDSTATUS_CACHEFILENAMEAVAILABLE, pwzFilename);
                    }
                }

                hr = CallOnProgress(dwCurrentSize,dwTotalSize,
                                        BINDSTATUS_ENDDOWNLOADDATA,_lpwszUrl);

                PerfDbgLog1(tagCBinding, this, "OnTransNotification done on OnProgress _pBSCP(%lx)", _pBSCB);

                // In some cases (e.g. data is in cache or progress notifications
                // are disbled) we may not get progress notifications
                // We might directly get the DONE notitification

                // In anycase we do not want to send data notification if it is a
                if (!_fBindToObject)
                {
                    hr = OnDataNotification(0,dwCurrentSize,dwTotalSize, TRUE);
                }
                else
                {
                    // the object should be instanciate now
                    hr = OnObjectAvailable(0,dwCurrentSize,dwTotalSize,TRUE);
                    if (hr != NOERROR)
                    {
                        SetInstantiateHresult(hr);
                    }
                }
            }

            if (_fBTS_BTO)
            {
                //special Trident BTS->BTO scenario.
                //Trident needs to get back the INET_E_TERMINATED_BIND error message to
                //realize we understand this is where we don't double-bind
                hr = INET_E_TERMINATED_BIND;
            }
            // return the download result in case if no error
            else if (hr == NOERROR || GetHResult() != NOERROR)
            {
                hr = GetHResult();
            }

            PerfDbgLog2(tagCBinding, this, "OnTransNotification calling OnStopBinding _pBSCP(%lx) HR:%lx", _pBSCB, hr);

            _hrBindResult = hr;
            hr = CallOnStopBinding(hr, NULL);
            fRelease = TRUE;

            PerfDbgLog1(tagCBinding, this, "OnTransNotification done on OnStopBinding _pBSCP(%lx)", _pBSCB);
            break;

        case BINDSTATUS_BEGINDOWNLOADDATA:
        case BINDSTATUS_DOWNLOADINGDATA:


            PerfDbgLog(tagCBinding, this, "CBinding::OnTransNotification Notify_Update");

            // Call OnProgress once if data are from cache
            if (!_fSentFirstNotification)
            {
                if (_pCTransData->IsFromCache())
                {
                    hr = CallOnProgress(0,0,BINDSTATUS_USINGCACHEDCOPY, NULL);
                }
            }

            hr = CallOnProgress(dwCurrentSize, dwTotalSize,
                        (!_fSentFirstNotification) ? BINDSTATUS_BEGINDOWNLOADDATA : BINDSTATUS_DOWNLOADINGDATA,
                        _lpwszUrl);

            if (!_fSentFirstNotification)
            {
                LPCWSTR pwzFilename = _pCTransData->GetFileName();

                // a filename is not always available
                if (pwzFilename)
                {
                    hr = CallOnProgress(dwCurrentSize, dwTotalSize,
                                        BINDSTATUS_CACHEFILENAMEAVAILABLE, pwzFilename);
                }
            }


            PerfDbgLog1(tagCBinding, this, "OnTransNotification done on OnProgress _pBSCP(%lx)", _pBSCB);

            if (!_fBindToObject)
            {
                OnDataNotification(0,dwCurrentSize,dwTotalSize, FALSE);

                if (_fBTS_BTO)
                {
                    //special Trident BTS->BTO scenario.
                    //Trident needs to get back the INET_E_TERMINATED_BIND error message to
                    //realize we understand this is where we don't double-bind
                    
                    _hrBindResult = INET_E_TERMINATED_BIND;
                    hr = CallOnStopBinding(INET_E_TERMINATED_BIND, NULL);
                    fRelease = TRUE;
                }
            }
            else
            {

                // 
                // here is the hack for ms-its:
                // if they are sending dwCurrent==dwTotal, we need to flip
                // the FALSE to TRUE in order to make word/excel doc host
                // working under IE5 (IE5 #71203)
                //
                BOOL fFullData = FALSE;
                if( dwCurrentSize == dwTotalSize &&
                    dwCurrentSize &&
                    _lpwszUrl &&
                    wcslen(_lpwszUrl) > 7 &&
                    !StrCmpNIW(_lpwszUrl, L"ms-its:", 7) )
                {
                    fFullData = TRUE;
                }


                // check here if the object can be create already
                //hr = OnObjectAvailable(pCTP, FALSE);
                hr = OnObjectAvailable(0,dwCurrentSize,dwTotalSize, fFullData);

                // mark the transobject for completion
                if (hr == S_OK)
                {
                    hr = CallOnStopBinding(NOERROR, NULL);
                    fRelease = TRUE;
                }
                else if ((hr != S_OK ) && (hr != S_FALSE))
                {
                    _hrBindResult = hr;
                    hr = CallOnStopBinding(hr, NULL);
                    fRelease = TRUE;
                }

            }
            break;

        case BINDSTATUS_ERROR:

            PerfDbgLog2(tagCBinding, this, "CBinding::OnTransNotification Notify_Error[hr%lx, dwResutl;%lx]", _hrBindResult, _dwBindError);

            // call StopBinding witht error code
            UrlMkAssert(( (_hrBindResult != NOERROR) && (_dwBindError != 0) ));
            hr = CallOnStopBinding(_hrBindResult, NULL);
            fRelease = TRUE;
            break;

        case BINDSTATUS_RESULT:
            PerfDbgLog2(tagCBinding, this, "CBinding::OnTransNotification Notify_Error[hr%lx, dwResutl;%lx]", _hrBindResult, _dwBindError);
            if( _hrBindResult == INET_E_REDIRECT_TO_DIR )
            {
                hr = CallOnStopBinding(_hrBindResult, _pwzResult);
            }
            else
            {
                hr = CallOnStopBinding(_hrBindResult, NULL);
            }
            fRelease = TRUE;
            break;

        case BINDSTATUS_DECODING:
            hr = CallOnProgress(0,0,BINDSTATUS_DECODING,pwzStr );
            break;
            
        case BINDSTATUS_LOADINGMIMEHANDLER:
            hr = CallOnProgress(0,0,BINDSTATUS_LOADINGMIMEHANDLER,pwzStr);
            break;

        case BINDSTATUS_INTERNAL:
        case BINDSTATUS_INTERNALASYNC:
            break;

        case BINDSTATUS_CONTENTDISPOSITIONATTACH:
            _fForceBindToObjFail = TRUE;
            hr = CallOnProgress(0,0,BINDSTATUS_CONTENTDISPOSITIONATTACH, pwzStr);
            break;

        case BINDSTATUS_ACCEPTRANGES:
            _fAcceptRanges= TRUE;
            break;

        case BINDSTATUS_COOKIE_SENT:
        case BINDSTATUS_COMPACT_POLICY_RECEIVED:
        case BINDSTATUS_COOKIE_SUPPRESSED:
        case BINDSTATUS_COOKIE_STATE_UNKNOWN:
        case BINDSTATUS_COOKIE_STATE_ACCEPT:
        case BINDSTATUS_COOKIE_STATE_REJECT:
        case BINDSTATUS_COOKIE_STATE_LEASH:
        case BINDSTATUS_COOKIE_STATE_DOWNGRADE:
        case BINDSTATUS_COOKIE_STATE_PROMPT:
        case BINDSTATUS_POLICY_HREF:
        case BINDSTATUS_P3P_HEADER:
        case BINDSTATUS_SESSION_COOKIE_RECEIVED:
        case BINDSTATUS_PERSISTENT_COOKIE_RECEIVED:
        case BINDSTATUS_SESSION_COOKIES_ALLOWED:
            hr = CallOnProgress(0,0,NotMsg, pwzStr);
            break;
            
        default:
            DbgLog1(tagCBindingErr, this, "CBinding::OnTransNotification Unknown (NMsg:%lx)", NotMsg);
            UrlMkAssert((FALSE));
            break;
        }
    }

    PerfDbgLog(tagCBinding, this, "-CBinding::OnTransNotification");

    DEBUG_LEAVE(fRelease);
    return fRelease;
}




//+---------------------------------------------------------------------------
//
//  Method:     CBinding::OnDataNotification
//
//  Synopsis:
//
//  Arguments:  [pCTP] --
//              [fLastNotification] --
//
//  Returns:
//
//  History:    12-22-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBinding::OnDataNotification(DWORD grfBSCF, DWORD dwCurrentSize, DWORD dwTotalSize, BOOL fLastNotification)
{
    DEBUG_ENTER((DBG_BINDING,
                Hresult,
                "CBinding::OnDataNotification",
                "this=%#x, %#x, %#x, %#x, %B",
                this, grfBSCF, dwCurrentSize, dwTotalSize, fLastNotification
                ));
                
    HRESULT hr = NOERROR;
    PerfDbgLog3(tagCBinding, this, "+CBinding::OnDataNotification (dwLastSize:%ld, dwCurrentSize:%ld, dwTotalSize:%ld)",
        _dwLastSize, dwCurrentSize, dwTotalSize);
    STGMEDIUM *pStgMed = 0;
    FORMATETC *pFmtETC = 0;

    // We shouldn't have less data than last time
    #if 0
    UrlMkAssert((   (dwTotalSize == 0)
                 || (dwTotalSize != 0 && dwCurrentSize > _dwLastSize)
                 || (dwTotalSize == dwCurrentSize && dwCurrentSize == _dwLastSize)
                 ));
    #endif // 0
    
    // must be BindToStorage scenario
    UrlMkAssert((!_fBindToObject));
    // should never end up here after the last data notification
    //UrlMkAssert((!_fSentLastNotification));

    if (   ((dwCurrentSize > 0) || fLastNotification)
        && (!_fSentLastNotification))
    {
        grfBSCF = 0;


        // Check if this will be the first data notification
        if (!_fSentFirstNotification)
        {
            grfBSCF |= BSCF_FIRSTDATANOTIFICATION;
            _fSentFirstNotification = TRUE;
        }

        if (fLastNotification)
        {
            // Check if this will be the last data notification
            grfBSCF |= BSCF_LASTDATANOTIFICATION;
            _fSentLastNotification = TRUE;
        }
        // all other notifications are intermediate
        if (grfBSCF == 0)
        {
            grfBSCF |= BSCF_INTERMEDIATEDATANOTIFICATION;
        }

        // get the stgmed for this
        if (_fCreateStgMed == FALSE)
        {
            hr = _pCTransData->GetData(&pFmtETC, &pStgMed, grfBSCF);
            if (hr == S_OK)
            {
            	// BUGBUG: Looks like _fCreateStgMed is always going to be false. 
            	// Either the following line can be de-commented out
            	// or _fCreateStgMed can be eliminated:
                //_fCreateStgMed = TRUE;
                TransAssert((pStgMed));

		        //
		        // hold on to the stream or storage
		        //
		        if ( (_pUnkObject == NULL)
		            && (   pStgMed->tymed == TYMED_ISTREAM
		                || pStgMed->tymed == TYMED_ISTORAGE))
		        {
		            _pUnkObject = pStgMed->pstm;
		            _pUnkObject->AddRef();
		        }
            }
        }

        if ( hr == S_OK && fLastNotification )
        {
            _pCTransData->OnEndofData();
        }

        if (hr == S_OK)
        {
            PerfDbgLog5(tagCBinding, this,
                    ">>> %lx::OnDataNotification (Options:%ld,Size:%ld,FmtEtc:%lx,StgMed:%lx)",
                    _pBSCB, grfBSCF, dwCurrentSize, pFmtETC, pStgMed);

            UrlMkAssert((grfBSCF != 0));

            hr = CallOnDataAvailable(grfBSCF, dwCurrentSize, pFmtETC, pStgMed);

            if (pStgMed)
            {
                DEBUG_ENTER((DBG_BINDING,
                            None,
                            "EXTERNAL::ReleaseStgMedium",
                            "%#x",
                            pStgMed
                            ));

               ReleaseStgMedium(pStgMed);

               DEBUG_LEAVE(0);

               //NOTES:  if tymed was TYMED_FILE, lpszFilename ZEROED out,
               // else   if tymed == TYMED_STREAM, pstm NOT ZEROED out.
               //   We DEPEND on this behavior in CTransDat::GetData()
               //
               // Ideally, we should just do this-> 
               // memset( pStgMed, 0, sizeof(STGMEDIUM) );
               // and save state in the transDat object.
            }
        }
     }

    _dwLastSize = dwCurrentSize;

    PerfDbgLog2(tagCBinding, this, "-CBinding::OnDataNotification (hr:%lx, dwLastSize:%ld)", hr, _dwLastSize);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBinding::OnObjectAvailable
//
//  Synopsis:
//
//  Arguments:  [pCTP] --
//              [fLastNotification] --
//
//  Returns:
//
//  History:    12-22-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBinding::OnObjectAvailable(DWORD grfBSCF, DWORD dwCurrentSize, DWORD dwTotalSize, BOOL fLastNotification)
{
    DEBUG_ENTER((DBG_BINDING,
                Hresult,
                "CBinding::OnObjectAvailable",
                "this=%#x, %#x, %#x, %#x, %B",
                this, grfBSCF, dwCurrentSize, dwTotalSize, fLastNotification
                ));
                
    HRESULT hr = NOERROR;
    PerfDbgLog3(tagCBinding, this, "+CBinding::OnObjectAvailable (dwCurrentSize:%ld, dwTotalSize:%ld, LastNotification:%d)",
                                    dwCurrentSize, dwTotalSize, fLastNotification);
    CLSID clsid = CLSID_NULL;

    // We shouldn't have less data than last time
    UrlMkAssert((   (dwTotalSize == 0)
                 || (dwTotalSize != 0 && dwCurrentSize != 0)
                 ));

    // must be BindToObject scenario
    UrlMkAssert((_fBindToObject));

    if (!fLastNotification && !_fSentFirstNotification)
    {
        // check if we've instantiated the object yet
        if (_pUnkObject == NULL)
        {
            hr = _pCTransData->GetClassID(_clsidIn, &clsid);

            if (FAILED(hr)) {

                hr = InstallIEFeature();

                if (SUCCEEDED(hr))
                    hr = _pCTransData->GetClassID(_clsidIn, &clsid);
            }

            if( _fForceBindToObjFail )
            {
                hr = REGDB_E_CLASSNOTREG;
            }
            

            if (hr == S_OK)
            {
                // instantiate the object now and call pass it on in OnDataAvailable
                hr = InstantiateObject(&clsid, *_piidRes, &_pUnkObject, FALSE);

                if (hr == S_FALSE)
                {
                    // switch to datasink file
                    _pCTransData->SwitchDataSink(DataSink_File);

                    if( _pCTransData->IsEOFOnSwitchSink() )
                    {
                        hr = ObjectPersistMnkLoad(_pUnkObject, _fLocal, TRUE);

                        if (hr != NOERROR && hr != E_ABORT)
                        {
                            hr = ObjectPersistFileLoad(_pUnkObject);
                        }
                    }
                }

                // Don't send notifications after the 'last' one.
                if ((hr == S_OK) && (_pUnkObject != NULL))
                {
                    hr = CallOnObjectAvailable(*_piidRes,_pUnkObject);

                    // release the object in case transaction is async
                    // the object is passed back via *ppvObj in sync case
                    if (IsAsyncTransaction())
                    {
                        _pUnkObject->Release();
                        _pUnkObject = NULL;
                    }

                    UrlMkAssert((SUCCEEDED(hr)));
                    hr = S_OK;
                }
                // keep the object until all data here

            }
            else if (hr == S_FALSE)
            {
                //
                // switch the datasink to file
                //
                _pCTransData->SwitchDataSink(DataSink_File);
            }
            else
            {

                hr = REGDB_E_CLASSNOTREG;
            }
        }
        else
        {
            // we got the object loaded but have to wait until all data
            // are available
            hr = S_FALSE;
        }

        if (!_fSentFirstNotification)
        {
            _fSentFirstNotification = TRUE;
        }

    }
    else if (fLastNotification)
    {
        UrlMkAssert((!_fSentLastNotification));
        DWORD grfBSCF = 0;

        // Check if this will be the first data notification

        // Check if this will be the last data notification
        if (fLastNotification)
        {
            grfBSCF |= BSCF_LASTDATANOTIFICATION;
        }

        if (_pUnkObject == NULL)
        {
            if( _fClsidFromProt && !IsEqualGUID(_clsidIn, CLSID_NULL) )
            {
                clsid = _clsidIn;
                hr = NOERROR;
            }
            else
            {
                hr = _pCTransData->GetClassID(_clsidIn, &clsid);
            }

            if (FAILED(hr)) {
                hr = InstallIEFeature();

                if (SUCCEEDED(hr))
                    hr = _pCTransData->GetClassID(_clsidIn, &clsid);
            }

            if( _fForceBindToObjFail )
            {
                hr = REGDB_E_CLASSNOTREG;
            }
            
            if (FAILED(hr))
            {
                hr = REGDB_E_CLASSNOTREG;
            }
            else
            {
                // instanciate the object now and call pass it on in OnDataAvailable
                if( _fClsidFromProt )
                {
                    hr = CreateObject(&clsid, *_piidRes, &_pUnkObject);
                }
                else
                {
                    hr = InstantiateObject(&clsid, *_piidRes, 
                                            &_pUnkObject, TRUE);
                }
            }
        }
        else
        {
            CallOnProgress( 0, 0, BINDSTATUS_BEGINSYNCOPERATION, 0 );

            hr = ObjectPersistMnkLoad(_pUnkObject,_fLocal,TRUE);
            if (hr != NOERROR && hr != E_ABORT)
            {
                // if all bits are available
                hr = ObjectPersistFileLoad(_pUnkObject);
            }

            CallOnProgress( 0, 0, BINDSTATUS_ENDSYNCOPERATION, 0 );

        }

        // Don't send notifications after the 'last' one.
        if (   SUCCEEDED(hr)
            && (_pUnkObject != NULL)
            && !_fSentLastNotification)
        {

            BOOL  bRegisteredTransactionData = FALSE;

            // Note: register the transaction object only
            // in case we are asked to transfer it to the
            // new process/thread where no new download
            // should be started
            if (_grfBINDF & BINDF_COMPLETEDOWNLOAD)
            {
                hr = _pBndCtx->RegisterObjectParam(SZ_TRANSACTIONDATA, (ITransactionData *)_pCTransData);
                if (SUCCEEDED(hr))
                {
                    bRegisteredTransactionData = TRUE;
                }

                PerfDbgLog2(tagCBinding, this, "=== CBinding::OnObjectAvailable RegisterObjectParam SZ_TRANSACTIONDATA: pbndctx:%lx, hr:%lx)", _pBndCtx, hr);
            }

            TransAssert((hr == NOERROR));

            hr = CallOnObjectAvailable(*_piidRes,_pUnkObject);

            if (bRegisteredTransactionData)
            {
                _pBndCtx->RevokeObjectParam(SZ_TRANSACTIONDATA);
            }

            // release the object
            if (IsAsyncTransaction())
            {
                _pUnkObject->Release();
                _pUnkObject = NULL;
            }

            UrlMkAssert((SUCCEEDED(hr)));
        }
        else
        {
            // why did it fail
        }

        if (grfBSCF & BSCF_LASTDATANOTIFICATION)
        {
            _fSentLastNotification = TRUE;
        }
    }
    else
    {
        hr = S_FALSE;
    }

    _dwLastSize = dwCurrentSize;
    PerfDbgLog1(tagCBinding, this, "-CBinding::OnObjectAvailable (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBinding::InstallIEFeature
//
//  Synopsis:
//              called when you can't by comventional registry lookup means
//              find a clsid for a given mime type
//              This code then checks to see if this is an IE feature
//              and if so installs it by calling the IE JIT API.
//
//  Arguments: 
//
//  Returns:
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBinding::InstallIEFeature()
{
    DEBUG_ENTER((DBG_BINDING,
                Hresult,
                "CBinding::InstallIEFeature",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCBinding, this, "+CBinding::InstallIEFeature");
    HRESULT     hr  = INET_E_CANNOT_INSTANTIATE_OBJECT;
    uCLSSPEC classpec;
    IWindowForBindingUI *pWindowForBindingUI = NULL;
    HWND hWnd = NULL;
    REFGUID rguidReason = IID_ICodeInstall;
    LPCWSTR pwszMimeType = _pCTransData->GetMimeType();
    DWORD dwJITFlags;

    // BUGBUG: Cannot extern vwzApplicationCDF from datasnif.cxx
    // For some reason, vwzApplicationCDF contains bogus data in some scenarios!
    static WCHAR vwzAppCDF[] = L"application/x-cdf";

    if (!pwszMimeType) {
        DEBUG_LEAVE(hr);
        return hr;
    }

    if (SUCCEEDED(IsMimeHandled(pwszMimeType))) {
        
        // if the mime has been handled by an EXE out of proc
        // then fail to instantiate the obj. shdocvw will call 
        // shellexecute on this url which will succeed.
        // we assume here that we enter InstallIEfeature only
        // after a conversion MimeToClsid has failed!

        hr  = INET_E_CANNOT_INSTANTIATE_OBJECT;

        DEBUG_LEAVE(hr);
        return hr;
    }

    CallOnProgress( 0, 0, BINDSTATUS_BEGINSYNCOPERATION, 0 );

    // Get IWindowForBindingUI ptr
    hr = _pBSCB->QueryInterface(IID_IWindowForBindingUI,
            (LPVOID *)&pWindowForBindingUI);

    if (FAILED(hr)) {
        IServiceProvider *pServProv;
        hr = _pBSCB->QueryInterface(IID_IServiceProvider,
            (LPVOID *)&pServProv);

        if (hr == NOERROR) {
            pServProv->QueryService(IID_IWindowForBindingUI,IID_IWindowForBindingUI,
                (LPVOID *)&pWindowForBindingUI);
            pServProv->Release();
        }
    }

    hr = INET_E_CANNOT_INSTANTIATE_OBJECT; // init to fail

    // get hWnd
    if (pWindowForBindingUI) {
        pWindowForBindingUI->GetWindow(rguidReason, &hWnd);
        pWindowForBindingUI->Release();

        QUERYCONTEXT qc;

        memset(&qc, 0, sizeof(qc));

        // fill in the minimum version number of the component you need
        //qc.dwVersionHi = 
        //qc.dwVersionLo = 


        classpec.tyspec=TYSPEC_MIMETYPE;
        classpec.tagged_union.pMimeType=(LPWSTR)pwszMimeType;

        if (pwszMimeType) {
            dwJITFlags = (!StrCmpIW(pwszMimeType, vwzAppCDF)) ?
                         (FIEF_FLAG_FORCE_JITUI) : (0);
        }
        else {
            dwJITFlags = 0;
        }

        hr = FaultInIEFeature(hWnd, &classpec, &qc, dwJITFlags);

    }

    CallOnProgress( 0, 0, BINDSTATUS_ENDSYNCOPERATION, 0 );

    PerfDbgLog1(tagCBinding, this, "-CBinding::InstallIEFeature (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CBinding::InstantiateObject
//
//  Synopsis:
//
//  Arguments:  [pclsid] --
//              [riidResult] --
//              [ppUnk] --
//
//  Returns:
//
//  History:    1-12-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBinding::InstantiateObject(CLSID *pclsid, REFIID riidResult, IUnknown **ppUnk,BOOL fFullyAvailable)
{
    DEBUG_ENTER((DBG_BINDING,
                Hresult,
                "CBinding::InstantiateObject",
                "this=%#x, %#x, %#x, %#x, %B",
                this, pclsid, &riidResult, ppUnk, fFullyAvailable
                ));
                
    PerfDbgLog(tagCBinding, this, "+CBinding::InstantiateObject");
    HRESULT     hr;
    IUnknown    *pUnk = NULL;
    LPOLESTR    pszStr = NULL;
    BOOL        fLocal = FALSE;

    //call OnProgress with CLASSID_AVAILABLE
    hr = StringFromCLSID(*pclsid, &pszStr);
    if (hr == NOERROR)
    {
        PerfDbgLog1(tagCBinding, this, "CBinding::InstantiateObject (Class ID:%ws)", pszStr);
        hr = CallOnProgress( 0, 0, BINDSTATUS_CLASSIDAVAILABLE, pszStr );
        if(hr == E_ABORT)
            SetOperationState(OPS_Abort);
        else
            UrlMkAssert((hr == NOERROR));
    }

    if (GetOperationState() == OPS_Abort)
    {
        // stop now - the client aborted the operation
        hr = E_ABORT;
    }
    else
    {

        DumpIID(riidResult);


        CallOnProgress( 0, 0, BINDSTATUS_BEGINSYNCOPERATION, 0 );

        //  If CLSID_MsHtml object had to be created to honor scripting access
        //  before OnObjectAvailable, BINDSTATUS_CLASSIDAVAILABLE OnProgress
        //  message is signal to register such an object in bind context

        hr = _pBndCtx->GetObjectParam(L"__PrecreatedObject", &pUnk);
        if (FAILED(hr))
        {
            // call OleAutoConvert
            {
                CLSID clsidIn = *pclsid;
                CLSID clsidOut;
                hr = OleGetAutoConvert(clsidIn, &clsidOut);
                if (hr == S_OK)
                {
                    *pclsid = clsidOut;
                }
            }

            if (_grfBINDF & BINDF_GETCLASSOBJECT)
            {
                // Just want the class object
                
                DEBUG_ENTER((DBG_BINDING,
                            Hresult,
                            "EXTERNAL::CoGetClassObject",
                            "%#x, CLSCTX_INPROC_SERVER, NULL, %#x, %#x",
                            pclsid, &riidResult, &pUnk
                            ));

                hr = CoGetClassObject(*pclsid, CLSCTX_INPROC_SERVER,
                                      NULL, riidResult, (void **)&pUnk);

                DEBUG_LEAVE(hr);
                
                if (FAILED(hr))
                {
                    DEBUG_ENTER((DBG_BINDING,
                                Hresult,
                                "EXTERNAL::CoGetClassObject",
                                "%#x, CLSCTX_LOCAL_SERVER, NULL, %#x, %#x",
                                pclsid, &riidResult, &pUnk
                                ));

                    hr = CoGetClassObject(
                            *pclsid, CLSCTX_LOCAL_SERVER,
                            NULL, riidResult, (void **)&pUnk);

                    DEBUG_LEAVE(hr);
                    
                    if (FAILED(hr))
                    {
                        DEBUG_ENTER((DBG_BINDING,
                                    Hresult,
                                    "EXTERNAL::CoGetClassObject",
                                    "%#x, CLSCTX_INPROC_HANDLER, NULL, %#x, %#x",
                                    pclsid, &riidResult, &pUnk
                                    ));

                        hr = CoGetClassObject(
                            *pclsid, CLSCTX_INPROC_HANDLER,
                            NULL, riidResult, (void **)&pUnk);

                        DEBUG_LEAVE(hr);
                    }
                }
            }
            else
            {
                DEBUG_ENTER((DBG_BINDING,
                            Hresult,
                            "EXTERNAL::CoCreateInstance",
                            "%#x, CLSCTX_INPROC_SERVER, NULL, %#x, %#x",
                            pclsid, &riidResult, &pUnk
                            ));

                hr = CoCreateInstance(*pclsid, NULL, CLSCTX_INPROC_SERVER,
                                    riidResult, (void**)&pUnk);

                DEBUG_LEAVE(hr);
                
                if (FAILED(hr))
                {
                    DbgLog1(tagCBindingErr, this, "=== CBinding::InstantiateObject InProcServer (hr:%lx)", hr);
                    
                    DEBUG_ENTER((DBG_BINDING,
                                Hresult,
                                "EXTERNAL::CoCreateInstance",
                                "%#x, CLSCTX_LOCAL_SERVER, NULL, %#x, %#x",
                                pclsid, &riidResult, &pUnk
                                ));
                                
                    hr = CoCreateInstance(*pclsid, NULL, CLSCTX_LOCAL_SERVER,
                                        riidResult, (void**)&pUnk);

                    DEBUG_LEAVE(hr);
                    
                    _fLocal = fLocal = TRUE;

                    if (FAILED(hr))
                    {
                        DumpIID(*pclsid);
                        DbgLog1(tagCBindingErr, this, "=== CBinding::InstantiateObject LocalServer (hr:%lx)", hr);

                        DEBUG_ENTER((DBG_BINDING,
                                    Hresult,
                                    "EXTERNAL::CoCreateInstance",
                                    "%#x, CLSCTX_INPROC_HANDLER, NULL, %#x, %#x",
                                    pclsid, &riidResult, &pUnk
                                    ));

                        hr = CoCreateInstance(*pclsid, NULL, CLSCTX_INPROC_HANDLER, riidResult, (void**)&pUnk);

                        DEBUG_LEAVE(hr);
                        
                        _fLocal = fLocal = FALSE;
                        if( FAILED(hr))
                        {
                            DbgLog1(tagCBindingErr, this, "=== CBinding::InstantiateObject InProcHandler (hr:%lx)", hr);
                        }
                    }
                }
            }
        }

        if (SUCCEEDED(hr))
        {
            *ppUnk = pUnk;

            if (   _grfBINDF & BINDF_COMPLETEDOWNLOAD
                && IsEqualGUID(*pclsid, CLSID_MsHtml)
                && fFullyAvailable == FALSE)
            {
                hr = S_FALSE;
            }
            else
            {

                // S_FALSE means try later when all data are available
                hr = ObjectPersistMnkLoad(pUnk,_fLocal,fFullyAvailable, pclsid);

                if (hr == E_NOINTERFACE)
                {
                    if (fFullyAvailable)
                    {
                        hr = ObjectPersistFileLoad(_pUnkObject);
                    }
                    else
                    {
                        // call PersistFile::Load later
                        hr = S_FALSE;
                    }
                }
                else if (hr == S_FALSE)
                {
                    // lock the request
                    _pOInetBdg->LockRequest(0);
                    _fCompleteDownloadHere = TRUE;
                }
                else if (hr != NOERROR && hr != E_ABORT)
                {
                    //
                    // your last chance of being loaded...
                    // this was not needed for IE4 since wininet
                    // ALWAYS return async, start from IE5, wininet
                    // will return SYNC if the file is in cache
                    //
                    if (fFullyAvailable)
                    {
                        HRESULT hr2 = ObjectPersistFileLoad(_pUnkObject);
                        if( hr2 == NOERROR )
                        {
                            // if we succeeded here, needs to return NOERROR
                            hr = hr2;
                        }
                    }
                }
                // else pass back error
            }
        }
        else
        {
            SetInstantiateHresult(hr);
            hr = INET_E_CANNOT_INSTANTIATE_OBJECT;

        }
        CallOnProgress( 0, 0, BINDSTATUS_ENDSYNCOPERATION, 0 );
    }

    if (pszStr)
    {
        delete pszStr;
    }
    PerfDbgLog1(tagCBinding, this, "-CBinding::InstantiateObject (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBinding::ObjectPersistMnkLoad
//
//  Synopsis:
//
//  Arguments:  [pUnk] --
//
//  Returns:
//
//  History:    2-07-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBinding::ObjectPersistMnkLoad(IUnknown *pUnk, BOOL fLocal, BOOL fFullyAvailable, CLSID *pclsid)
{
    DEBUG_ENTER((DBG_BINDING,
                Hresult,
                "CBinding::ObjectPersistMnkLoad",
                "this=%#x, %#x, %B, %B",
                this, pUnk, fLocal, fFullyAvailable
                ));
                
    PerfDbgLog(tagCBinding, this, "+CBinding::ObjectPersistMnkLoad");
    HRESULT          hr;
    IPersistMoniker *pPersistMk = NULL;
    BIND_OPTS        bindopts;
    BOOL             bRegisteredTransactionData = FALSE;

    if (_grfBINDF & BINDF_GETCLASSOBJECT)
    {
        // GetClassObj, which means there is no need to PersistMnkLoad
        PerfDbgLog(tagCBinding, this, " ObjectPersistMnkLoad : GETCLASSOBJ");
        hr = NOERROR;
        goto exit;
    }

    DEBUG_ENTER((DBG_BINDING,
                Hresult,
                "EXTERNAL::IUnknown::QueryInterface",
                "this=%#x, IID_IPersistMoniker, %#x",
                pUnk, &pPersistMk
                ));
                            
    hr = pUnk->QueryInterface(IID_IPersistMoniker, (void**)&pPersistMk);

    DEBUG_LEAVE(hr);
    
    if (hr == NOERROR)
    {
        TransAssert((pPersistMk != NULL));
        if (!fLocal)
        {
            hr = _pBndCtx->RegisterObjectParam(SZ_BINDING, (IBinding *)this);
        }

        IUnknown *pUnk = 0;

        // remove the current bindstatuscallback
        hr = _pBndCtx->GetObjectParam(REG_BSCB_HOLDER, &pUnk);
        TransAssert((hr == NOERROR));

        hr = _pBndCtx->RevokeObjectParam(REG_BSCB_HOLDER);
        TransAssert((hr == NOERROR));

        bindopts = _bindopts;

        TransAssert(( bindopts.grfMode & (STGM_READWRITE | STGM_SHARE_EXCLUSIVE) ));

        if ( !(bindopts.grfMode & (STGM_READWRITE | STGM_SHARE_EXCLUSIVE)) )
        {
            bindopts.grfMode |= (STGM_READWRITE | STGM_SHARE_EXCLUSIVE);
        }

        // Note:
        // switch of flag do not receive notifications on this cbinding
        // BindToStorage synchronous might be called
        _grfInternalFlags &= ~BDGFLAGS_NOTIFICATIONS;

        if ( (fFullyAvailable)
             && ( ( !(_grfBINDF & BINDF_COMPLETEDOWNLOAD)
                    && _fCompleteDownloadHere )
                  ||
                  (_fLocal) 
                )
           )
        {
            _grfBINDF |= BINDF_COMPLETEDOWNLOAD;
            hr = _pBndCtx->RegisterObjectParam(SZ_TRANSACTIONDATA, (ITransactionData *)_pCTransData);
            if (SUCCEEDED(hr))
            {
                bRegisteredTransactionData = TRUE;
            }
            PerfDbgLog2(tagCBinding, this, "=== CBinding::OnObjectAvailable RegisterObjectParam SZ_TRANSACTIONDATA: pbndctx:%lx, hr:%lx)", _pBndCtx, hr);

            // swtich the _ds back to StreamOnFile so that the BindToStorage
            // can get the IStream from pbc (inproc server only)
            if( !_fLocal )
            {
                _pCTransData->SetFileAsStmFile();
            } 
        }

        LPCWSTR pwszMimeType = _pCTransData->GetMimeType();
         
        // Now, we try to shove the mimetype down the throat of pPersistMk
        IMonikerProp *pmkp = NULL;

        DEBUG_ENTER((DBG_BINDING,
                    Hresult,
                    "EXTERNAL::IUnknown::QueryInterface",
                    "this=%#x, IID_IMonikerProp, %#x (mimetype = %.80wq)",
                    pPersistMk, &pmkp, pwszMimeType
                    ));

        if (SUCCEEDED(pPersistMk->QueryInterface(IID_IMonikerProp, (void **)&pmkp)))
        {
            DEBUG_LEAVE(NOERROR);
            
            pmkp->PutProperty(MIMETYPEPROP, pwszMimeType);
        }
        else 
            DEBUG_LEAVE(E_FAIL);
        
        if( !fFullyAvailable    && 
            pwszMimeType        &&
            !StrCmpNIW( pwszMimeType, L"application/pdf", 15) )
        {
            // let's find out we are dealing with Acrobat 3.02 and above
            if( _fAcceptRanges && PDFNeedProgressiveDownload() )
            {
                if(pmkp)
                {
                    pmkp->PutProperty(USE_SRC_URL, L"1");
                }
                // this is 3.02 and above, go ahead call PMK::Load
                hr = pPersistMk->Load(
                    fFullyAvailable, GetMoniker(), _pBndCtx, bindopts.grfMode);
                
            }
            else
            {
                //
                // this is 3.0 and 3.01, 
                // or we are dealing with server does not support Range
                // don't call PMK::Load until fully available 
                //
                hr = S_FALSE;
            }
        }
        else
        {

            if( pclsid &&
                  !fFullyAvailable &&
                  IsEqualGUID(*pclsid, CLSID_PluginHost))
            {
                hr = S_FALSE;
            }
            else
            {
                DEBUG_ENTER((DBG_BINDING,
                            Hresult,
                            "EXTERNAL::IPersistMoniker::Load",
                            "this=%#x, %B, %#x, %#x, %#x",
                            pPersistMk, fFullyAvailable, GetMoniker(), _pBndCtx, bindopts.grfMode
                            ));

                hr = pPersistMk->Load(fFullyAvailable, GetMoniker(), _pBndCtx, bindopts.grfMode);

                DEBUG_LEAVE(hr);
            }
        }

        if (bRegisteredTransactionData)
        {
            _pBndCtx->RevokeObjectParam(SZ_TRANSACTIONDATA);
        }

        if (FAILED(hr))
        {
            if (hr == E_FAIL)
            {
                hr = CO_E_SERVER_EXEC_FAILURE;
            }
        }

        // Note: OnStopBinding is still called even
        // even the download finished due sync BindToStorage
        // turn the flag back on
        _grfInternalFlags |= BDGFLAGS_NOTIFICATIONS;

        if (!fLocal)
        {
            _pBndCtx->RevokeObjectParam(SZ_BINDING);
        }

        if (pUnk)
        {
            _pBndCtx->RegisterObjectParam(REG_BSCB_HOLDER, pUnk);
            pUnk->Release();
        }

        pPersistMk->Release();
        
        if(pmkp)
            pmkp->Release();
    }

exit:
    PerfDbgLog1(tagCBinding, this, "-CBinding::ObjectPersistMnkLoad (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBinding::ObjectPersistFileLoad
//
//  Synopsis:
//
//  Arguments:  [pUnk] --
//
//  Returns:
//
//  History:    2-07-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBinding::ObjectPersistFileLoad(IUnknown *pUnk)
{
    DEBUG_ENTER((DBG_BINDING,
                Hresult,
                "CBinding::ObjectPersistFileLoad",
                "this=%#x, %#x",
                this, pUnk
                ));
                
    HRESULT hr;
    PerfDbgLog1(tagCBinding, this, "+CBinding::ObjectPersistFileLoad (filename:%ws)",  GetFileName());

    IPersistFile *pPersistFile = NULL;

    DEBUG_ENTER((DBG_BINDING,
                Hresult,
                "EXTERNAL::IUnknown::QueryInterface",
                "this=%#x, IID_IPersistFile, %#x",
                pUnk, &pPersistFile
                ));

    hr = pUnk->QueryInterface(IID_IPersistFile, (void**)&pPersistFile);

    DEBUG_LEAVE(hr);
    
    if (hr == NOERROR)
    {
        DEBUG_ENTER((DBG_BINDING,
                    Hresult,
                    "EXTERNAL::IPersistFile::Load",
                    "this=%#x, %#x, %#x",
                    pPersistFile, GetFileName(), 0
                    ));
                        
        hr = pPersistFile->Load(GetFileName(), 0);

        DEBUG_LEAVE(hr);
        
        if (hr != NOERROR)
        {
            SetInstantiateHresult(hr);
            hr = INET_E_CANNOT_LOAD_DATA;
        }
        PerfDbgLog1(tagCBinding, this, "=== CBinding::ObjectPersistFileLoad (Load returned:%lx)", hr);
        pPersistFile->Release();
    }

    PerfDbgLog1(tagCBinding, this, "-CBinding::ObjectPersistFileLoad (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBinding::CallGetBindInfo
//
//  Synopsis:
//
//  Arguments:  [grfBINDINFOF] --
//              [pBdInfo] --
//
//  Returns:
//
//  History:    2-07-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBinding::CallGetBindInfo(DWORD *grfBINDINFOF, BINDINFO *pBdInfo)
{
    DEBUG_ENTER((DBG_BINDING,
                Hresult,
                "CBinding::CallGetBindInfo",
                "this=%#x, %#x, %#x",
                this, grfBINDINFOF, pBdInfo
                ));
                
    HRESULT hr = E_FAIL;
    UrlMkAssert((grfBINDINFOF != NULL));
    PerfDbgLog1(tagCBinding, this, "+CBinding::CallGetBindInfo (grfBINDINFOF:%ld)", *grfBINDINFOF);

    if (GetOperationState() == OPS_Initialized)
    {
        hr = _pBSCB->GetBindInfo(grfBINDINFOF, pBdInfo);
        SetOperationState(OPS_GetBindInfo);
    }
    else
    {
        UrlMkAssert((GetOperationState() == OPS_Initialized));
    }

    if (   (*grfBINDINFOF & BINDF_ASYNCSTORAGE)
        && (*grfBINDINFOF & BINDF_PULLDATA) )
    {
        PerfDbgLog2(tagCBinding, this, "=== grfBINDINFOF:%lx, (%s)", *grfBINDINFOF, "BINDF_ASYNCSTORAGE | BINDF_PULLDATA");
    }

    PerfDbgLog2(tagCBinding, this, "-CBinding::CallGetBindInfo (grfBINDINFOF:%lx, hr:%lx)", *grfBINDINFOF, hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBinding::CallOnStartBinding
//
//  Synopsis:
//
//  Arguments:  [grfBINDINFOF] --
//              [pib] --
//
//  Returns:
//
//  History:    2-07-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBinding::CallOnStartBinding(DWORD grfBINDINFOF, IBinding * pib)
{
    DEBUG_ENTER((DBG_BINDING,
                Hresult,
                "CBinding::CallOnStartBinding",
                "this=%#x, %#x, %#x",
                this, grfBINDINFOF, pib
                ));
                
    HRESULT hr = E_FAIL;
    PerfDbgLog1(tagCBinding, this, "+CBinding::CallOnStartBinding (grfBINDINFOF:%lx)", grfBINDINFOF);

    if (GetOperationState() == OPS_GetBindInfo)
    {
        hr = _pBSCB->OnStartBinding(NULL, this);
        SetOperationState(OPS_StartBinding);
    }
    else
    {
        UrlMkAssert((GetOperationState() == OPS_GetBindInfo));
    }


    PerfDbgLog1(tagCBinding, this, "-CBinding::CallOnStartBinding (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}
//+---------------------------------------------------------------------------
//
//  Method:     CBinding::CallOnProgress
//
//  Synopsis:
//
//  Arguments:  [ulProgress] --
//              [ulProgressMax] --
//              [ulStatusCode] --
//              [szStatusText] --
//
//  Returns:
//
//  History:    2-14-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBinding::CallOnProgress(ULONG ulProgress, ULONG ulProgressMax, ULONG ulStatusCode, LPCWSTR szStatusText)
{
    DEBUG_ENTER((DBG_BINDING,
                Hresult,
                "CBinding::CallOnProgress",
                "this=%#x, %#x, %#x, %#x, %.80wq",
                this, ulProgress, ulProgressMax, ulStatusCode, szStatusText
                ));
                
    HRESULT hr = NOERROR;
    
    PerfDbgLog(tagCBinding, this, "+CBinding::CallOnProgress");

    if ( GetOperationState() == OPS_StartBinding)
    {
        SetOperationState(OPS_Downloading);
    }

    if (GetOperationState() == OPS_Downloading)
    {
        hr = _pBSCB->OnProgress(ulProgress, ulProgressMax, ulStatusCode, szStatusText);
    }

    PerfDbgLog1(tagCBinding, this, "-CBinding::CallOnProgress hr:%lx", hr);

    DEBUG_LEAVE(hr);
    return hr;
}
//+---------------------------------------------------------------------------
//
//  Method:     CBinding::CallOnStopBinding
//
//  Synopsis:
//
//  Arguments:  [LPCWSTR] --
//              [szError] --
//
//  Returns:
//
//  History:    2-14-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBinding::CallOnStopBinding(HRESULT hrRet,LPCWSTR szError)
{
    DEBUG_ENTER((DBG_BINDING,
                Hresult,
                "CBinding::CallOnStopBinding",
                "this=%#x, %#x, %.80wq",
                this, hrRet, szError
                ));
                
    HRESULT hr = E_FAIL;
    PerfDbgLog1(tagCBinding, this, "+CBinding::CallOnStopBinding ->hrRet:%lx", hrRet);

    if (   (GetOperationState() < OPS_Stopped)
        && (GetOperationState() > OPS_Initialized))
    {
        UrlMkAssert((  (hrRet != S_FALSE && hrRet != E_FAIL) ));

        if (hrRet == E_FAIL)
        {
            hrRet = INET_E_DOWNLOAD_FAILURE;
        }
        TransAssert((    ((hr == NOERROR) && _fSentLastNotification)
                      || (hr != NOERROR) ));

        //if( _fBindToObject ) 
        //    DbgLog(tagCBindingErr, this, ">>> OnStopBinding (BindToObject)");
        //else
        //    DbgLog(tagCBindingErr, this, ">>> OnStopBinding (BindToStorage)");
        hr = _pBSCB->OnStopBinding(hrRet, NULL);
        SetOperationState(OPS_Stopped);
    }
    TransAssert((_pBndCtx));

    //TRIDENT BTS->BTO
    //Save the transaction objects for BTO
    if (!_fBTS_BTO) //(hrRet != INET_E_TERMINATED_BIND)
        _pBndCtx->SetTransactionObjects(NULL,NULL);
    

    PerfDbgLog1(tagCBinding, this, "-CBinding::CallOnStopBinding (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBinding::CallOnLowResource
//
//  Synopsis:
//
//  Arguments:  [reserved] --
//
//  Returns:
//
//  History:    2-14-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBinding::CallOnLowResource (DWORD reserved)
{
    DEBUG_ENTER((DBG_BINDING,
                Hresult,
                "CBinding::CallOnLowResource",
                "this=%#x, %#x",
                this, reserved
                ));
                
    HRESULT hr = E_FAIL;
    PerfDbgLog(tagCBinding, this, "+CBinding::CallOnLowResource");

    PerfDbgLog1(tagCBinding, this, "-CBinding::CallOnLowResource (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}
//+---------------------------------------------------------------------------
//
//  Method:     CBinding::CallGetPriority
//
//  Synopsis:
//
//  Arguments:  [pnPriority] --
//
//  Returns:
//
//  History:    2-14-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBinding::CallGetPriority (LONG * pnPriority)
{
    DEBUG_ENTER((DBG_BINDING,
                Hresult,
                "CBinding::CallGetPriority",
                "this=%#x, %#x",
                this, pnPriority
                ));
                
    HRESULT hr = E_FAIL;
    PerfDbgLog(tagCBinding, this, "+CBinding::CallGetPriority");

    PerfDbgLog1(tagCBinding, this, "-CBinding::CallGetPriority (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}
//+---------------------------------------------------------------------------
//
//  Method:     CBinding::CallOnDataAvailable
//
//  Synopsis:
//
//  Arguments:  [DWORD] --
//              [FORMATETC] --
//              [STGMEDIUM] --
//              [pStgMed] --
//
//  Returns:
//
//  History:    2-14-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBinding::CallOnDataAvailable(DWORD grfBSC,DWORD dwSize,FORMATETC *pFmtETC,STGMEDIUM *pStgMed)
{
    DEBUG_ENTER((DBG_BINDING,
                Hresult,
                "CBinding::CallOnDataAvailable",
                "this=%#x, %#x, %#x, %#x, %#x",
                this, grfBSC, dwSize, pFmtETC, pStgMed
                ));
                
    HRESULT hr = E_FAIL;
    PerfDbgLog(tagCBinding, this, "+CBinding::CallOnDataAvailable");

    if (GetOperationState() == OPS_Downloading)
    { 
        //DbgLog2(tagCBindingErr, this, ">>> OnDataAvailable (BSC=%lx size=%d)",
        //        grfBSC, dwSize);
        hr = _pBSCB->OnDataAvailable(grfBSC, dwSize, pFmtETC, pStgMed);

        if (hr == INET_E_TERMINATED_BIND)
        {
            _fBTS_BTO = TRUE;
            hr = NOERROR; //restore back to value which was previous value being returned
        }
    }
    else if (GetOperationState() == OPS_Abort)
    {
        hr = E_ABORT;
    }

    PerfDbgLog1(tagCBinding, this, "-CBinding::CallOnDataAvailable (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}
//+---------------------------------------------------------------------------
//
//  Method:     CBinding::CallOnObjectAvailable
//
//  Synopsis:
//
//  Arguments:  [IUnknown] --
//              [punk] --
//
//  Returns:
//
//  History:    2-14-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBinding::CallOnObjectAvailable (REFIID riid,IUnknown *punk)
{
    DEBUG_ENTER((DBG_BINDING,
                Hresult,
                "CBinding::CallOnObjectAvailable",
                "this=%#x, %#x, %#x",
                this, &riid, punk
                ));
                
    HRESULT hr = E_FAIL;
    PerfDbgLog(tagCBinding, this, "+CBinding::CallOnObjectAvailable");

    if (GetOperationState() == OPS_Downloading || _grfBINDF & BINDF_GETCLASSOBJECT)
    {
        hr = _pBSCB->OnObjectAvailable(riid, punk);
        SetOperationState(OPS_ObjectAvailable);
    }
    else
    {
        UrlMkAssert((GetOperationState() == OPS_Downloading));
    }

    PerfDbgLog1(tagCBinding, this, "-CBinding::CallOnObjectAvailable (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBinding::GetRequestedObject
//
//  Synopsis:
//
//  Arguments:  [pbc] --
//              [ppUnk] --
//
//  Returns:
//
//  History:    7-04-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBinding::GetRequestedObject(IBindCtx *pbc, IUnknown **ppUnk)
{
    DEBUG_ENTER((DBG_BINDING,
                Hresult,
                "CBinding::GetRequestedObject",
                "this=%#x, %#x, %#x",
                this, pbc, ppUnk
                ));
                
    HRESULT hr = NOERROR;
    PerfDbgLog(tagCBinding, this, "+CBinding::GetRequestedObject");

    UrlMkAssert((ppUnk));
    *ppUnk = NULL;

    if (_pUnkObject)
    {
        *ppUnk = _pUnkObject;
        _pUnkObject->AddRef();
    }
    else if ( IsAsyncTransaction() )
    {
        //object is not available yet
        hr = MK_S_ASYNCHRONOUS;
    }
    else
    {
        // BUGBUG: JohanP - this is bogus for the case of returning a filename in stgmed; either we return a new success code or
        // the punk of the punkforrelease of the stgmed
        hr = NOERROR;
    }

    PerfDbgLog1(tagCBinding, this, "-CBinding::GetRequestedObject (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CBinding::CallAuthenticate
//
//  Synopsis:
//
//  Arguments:  [phwnd] --
//              [LPWSTR] --
//              [pszPassword] --
//
//  Returns:
//
//  History:    2-08-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CBinding::CallAuthenticate(HWND* phwnd, LPWSTR *pszUsername,LPWSTR *pszPassword)
{
    DEBUG_ENTER((DBG_BINDING,
                Hresult,
                "CBinding::CallAuthenticate",
                "this=%#x, %#x, %#x, %#x",
                this, phwnd, pszUsername, pszPassword
                ));
                
    PerfDbgLog(tagCBinding, this, "+CBinding::CallAuthenticate");
    HRESULT         hr = NOERROR;

    if (_pBasicAuth == NULL)
    {
        hr = LocalQueryInterface(IID_IAuthenticate, (void **) &_pBasicAuth);
    }

    if ((hr == NOERROR) && _pBasicAuth)
    {
         hr = _pBasicAuth->Authenticate(phwnd, pszUsername,pszPassword);
    }
    else
    {
        UrlMkAssert((_pBasicAuth == NULL));
        *phwnd = 0;
        *pszUsername = 0;
        *pszPassword = 0;
    }

    PerfDbgLog4(tagCBinding, this, "-CBinding::CallAuthenticate (hr:%lx, hwnd:%lx, username:%ws, password:%ws)",
        hr, *phwnd, *pszUsername?*pszUsername:L"", *pszPassword?*pszPassword:L"");

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBinding::LocalQueryInterface
//
//  Synopsis:
//
//  Arguments:  [iid] --
//              [ppvObj] --
//
//  Returns:
//
//  History:    4-09-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBinding::LocalQueryInterface(REFIID riid, void **ppvObj)
{
    DEBUG_ENTER((DBG_BINDING,
                Hresult,
                "CBinding::LocalQueryInterface",
                "this=%#x, %#x, %#x",
                this, &riid, ppvObj
                ));
                
    PerfDbgLog2(tagCBinding, this, "+CBinding::LocalQueryInterface (%lx, %lx)", riid, ppvObj);
    HRESULT hr = E_NOINTERFACE;
    *ppvObj = 0;

    if (_pBSCB)
    {
        IServiceProvider *pSrvPrv;
        hr = _pBSCB->QueryInterface(IID_IServiceProvider, (void **) &pSrvPrv);
        if (hr == NOERROR)
        {
            hr = pSrvPrv->QueryService(riid,riid, ppvObj);
            pSrvPrv->Release();
        }
        else
        {
            hr = E_NOINTERFACE;
            *ppvObj = 0;
        }
    }

    PerfDbgLog2(tagCBinding, this, "-CBinding::LocalQueryInterface (%lx)[%lx]", hr, *ppvObj);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBinding::Switch
//
//  Synopsis:
//
//  Arguments:  [pStateInfo] --
//
//  Returns:
//
//  History:    4-10-1997   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBinding::Switch(PROTOCOLDATA *pStateInfo)
{
    DEBUG_ENTER((DBG_BINDING,
                Hresult,
                "CBinding::IInternetProtocolSink::Switch",
                "this=%#x, %#x",
                this, pStateInfo
                ));

    PerfDbgLog(tagCBinding, this, "+CBinding::Switch");
    HRESULT hr = E_FAIL;

    TransAssert((FALSE));

    PerfDbgLog1(tagCBinding, this, "-CBinding::Switch (%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBinding::ReportProgress
//
//  Synopsis:
//
//  Arguments:  [ulStatusCode] --
//              [szStatusText] --
//
//  Returns:
//
//  History:    4-10-1997   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBinding::ReportProgress(ULONG ulStatusCode, LPCWSTR szStatusText)
{
    DEBUG_ENTER((DBG_BINDING,
                Hresult,
                "CBinding::IInternetProtocolSink::ReportProgress",
                "this=%#x, %#x, %.80wq",
                this, ulStatusCode, szStatusText
                ));

    PerfDbgLog(tagCBinding, this, "+CBinding::ReportProgress");
    HRESULT hr = NOERROR;

    if (   (ulStatusCode == BINDSTATUS_BEGINDOWNLOADDATA)
        || (ulStatusCode == BINDSTATUS_DOWNLOADINGDATA)
        || (ulStatusCode == BINDSTATUS_ENDDOWNLOADDATA) )
    {
    }
    else
    {
        BOOL fRet = OnTransNotification(
                    (BINDSTATUS) ulStatusCode  //BINDSTATUS NotMsg,
                    ,0 //ulProgress    //DWORD dwCurrentSize,
                    ,0 //ulProgressMax //DWORD dwTotalSize,
                    ,( LPWSTR)szStatusText  //LPWSTR pwzStr,
                    ,NOERROR       //HRESULT hrINet
                    );
    }


    PerfDbgLog1(tagCBinding, this, "-CBinding::ReportProgress (%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBinding::ReportData
//
//  Synopsis:
//
//  Arguments:  [grfBSCF] --
//              [ulProgress] --
//              [ulProgressMax] --
//
//  Returns:
//
//  History:    4-10-1997   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBinding::ReportData(DWORD grfBSCF, ULONG ulProgress, ULONG ulProgressMax)
{
    DEBUG_ENTER((DBG_BINDING,
                Hresult,
                "CBinding::IInternetProtocolSink::ReportData",
                "this=%#x, %#x, %#x, %#x",
                this, grfBSCF, ulProgress, ulProgressMax
                ));
                
    PerfDbgLog(tagCBinding, this, "+CBinding::ReportData");
    HRESULT hr = NOERROR;
    BOOL fLastNotification = (grfBSCF & BSCF_LASTDATANOTIFICATION) ? TRUE : FALSE;
    ULONG ulStatusCode = BINDSTATUS_DOWNLOADINGDATA;
    ULONG dwNew;

    AddRef();

    if (grfBSCF & BSCF_LASTDATANOTIFICATION)
    {
        ulStatusCode = BINDSTATUS_ENDDOWNLOADDATA;
    }
    else if (grfBSCF & BSCF_FIRSTDATANOTIFICATION)
    {
        ulStatusCode = BINDSTATUS_BEGINDOWNLOADDATA;
    }

    HRESULT hr1 = _pCTransData->OnDataReceived(grfBSCF, ulProgress, ulProgressMax,&dwNew);
    ulProgress = dwNew;

    if (hr1 == S_FALSE)
    {
        // end of data
        ulStatusCode = BINDSTATUS_ENDDOWNLOADDATA;
    }
    else if (   (hr1 != S_NEEDMOREDATA)
             && (hr1 != E_PENDING)
             && (hr1 != NOERROR))
    {
        ulStatusCode = BINDSTATUS_ERROR;
    }

    if (hr1 != S_NEEDMOREDATA)
    {
        BOOL fRet = OnTransNotification(
                        (BINDSTATUS) ulStatusCode   //BINDSTATUS NotMsg,
                        ,ulProgress                 //DWORD dwCurrentSize,
                        ,ulProgressMax              //DWORD dwTotalSize,
                        ,NULL                       //LPWSTR pwzStr,
                        ,NOERROR                    //HRESULT hrINet
                        );
        if (fRet == TRUE)
        {
            _pCTransData->OnTerminate();
            if (_fBindToObject)
            {
                hr = S_FALSE;
                
                TransAssert((_grfInternalFlags | ~BDGFLAGS_ATTACHED));
                TransAssert((_grfInternalFlags & BDGFLAGS_PARTIAL));
                
                _pOInetBdg->Terminate(BDGFLAGS_PARTIAL);
            }
            else if(_fBTS_BTO)
            {
                _pOInetBdg->Terminate(BDGFLAGS_BTS_BTO);
            }
        }
    }

    //TRIDENT BTS->BTO
    //used to return only NOERROR and S_FALSE(only for certain BTO sitns.-not returned for BTS)
    //Return INET_E_TERMINATED_BIND to let the Trans object know about the transfer.
    if (_fBTS_BTO) 
        hr = INET_E_TERMINATED_BIND;
        
    Release();

    PerfDbgLog1(tagCBinding, this, "-CBinding::ReportData (%lx)", hr);
        
    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBinding::ReportResult
//
//  Synopsis:
//
//  Arguments:  [hrResult] --
//              [dwError] --
//              [pwzResult] --
//
//  Returns:
//
//  History:    4-10-1997   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBinding::ReportResult(HRESULT hrResult, DWORD dwError, LPCWSTR pwzResult)
{
    DEBUG_ENTER((DBG_BINDING,
                Hresult,
                "CBinding::IInternetProtocolSink::ReportResult",
                "this=%#x, %#x, %#x, %.80wq",
                this, hrResult, dwError, pwzResult
                ));
                
    PerfDbgLog(tagCBinding, this, "+CBinding::ReportResult");
    HRESULT hr = NOERROR;

    AddRef();

    _dwBindError = dwError;
    _hrBindResult = hrResult;

    if (pwzResult)
    {
        if (_pwzResult)
        {
            delete [] _pwzResult;
        }
        _pwzResult = OLESTRDuplicate((LPWSTR)pwzResult);
    }

    BOOL fRet = OnTransNotification(
                    BINDSTATUS_RESULT           //BINDSTATUS NotMsg,
                    ,0 //ulProgress             //DWORD dwCurrentSize,
                    ,0 //ulProgressMax          //DWORD dwTotalSize,
                    ,(LPWSTR)pwzResult           //LPWSTR pwzStr,
                    ,hrResult                   //HRESULT hrINet
                    );
    if (fRet == TRUE)
    {
        hr = S_FALSE;

        DWORD dwFlags = (_fBindToObject) ? BDGFLAGS_PARTIAL : 0;
        _pCTransData->OnTerminate();
        _pOInetBdg->Terminate(dwFlags);
    }
    Release();

    PerfDbgLog1(tagCBinding, this, "-CBinding::ReportResult (%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}


STDMETHODIMP CBinding::CreateObject(CLSID *pclsid, REFIID riidResult, IUnknown **ppUnk)
{
    DEBUG_ENTER((DBG_BINDING,
                Hresult,
                "CBinding::CreateObject",
                "this=%#x, %#x, %#x, %#x",
                this, pclsid, &riidResult, ppUnk
                ));
                
    PerfDbgLog(tagCBinding, this, "+CBinding::CreateObj");
    HRESULT     hr;
    IUnknown    *pUnk = NULL;

    if (GetOperationState() == OPS_Abort)
    {
        // stop now - the client aborted the operation
        hr = E_ABORT;
    }
    else
    {

        DumpIID(riidResult);

        // call OleAutoConvert
        {
            CLSID clsidIn = *pclsid;
            CLSID clsidOut;
            hr = OleGetAutoConvert(clsidIn, &clsidOut);
            if (hr == S_OK)
            {
                *pclsid = clsidOut;
            }
        }

        if (_grfBINDF & BINDF_GETCLASSOBJECT)
        {
            // Just want the class object
            hr = CoGetClassObject(*pclsid, CLSCTX_INPROC_SERVER,
                                  NULL, riidResult, (void **)&pUnk);
            if (FAILED(hr))
            {
                hr = CoGetClassObject(*pclsid, CLSCTX_LOCAL_SERVER,
                                      NULL, riidResult, (void **)&pUnk);
                if (FAILED(hr))
                {
                    hr = CoGetClassObject(*pclsid, CLSCTX_INPROC_HANDLER,
                                          NULL, riidResult, (void **)&pUnk);

                }
            }
        }
        else
        {

            hr = CoCreateInstance(*pclsid, NULL, CLSCTX_INPROC_SERVER,
                                    riidResult, (void**)&pUnk);

            if (FAILED(hr))
            {
                hr = CoCreateInstance(*pclsid, NULL, CLSCTX_LOCAL_SERVER,
                                   riidResult, (void**)&pUnk);

                if (FAILED(hr))
                {

                    hr = CoCreateInstance(*pclsid, NULL, CLSCTX_INPROC_HANDLER, 
                                       riidResult, (void**)&pUnk);

                }
            }
        }

        if (SUCCEEDED(hr))
        {
            *ppUnk = pUnk;
        }
        else
        {
            SetInstantiateHresult(hr);
            hr = INET_E_CANNOT_INSTANTIATE_OBJECT;
        }
        CallOnProgress( 0, 0, BINDSTATUS_ENDSYNCOPERATION, 0 );
    }

    PerfDbgLog1(tagCBinding, this, "-CBinding::CreateObject (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\trans\precomp1.inc ===
#//+---------------------------------------------------------------
#//
#//  File:      precomp1.inc
#//
#//  Contents:  directives for global precompiled include file when the
#//             sources file is two directories below com (or wherever
#//             this file is located).  We could easily have precomp3 and
#//             precomp4 for other areas.The urlint.* files should not
#//             otherwise be mentioned in the sources files.
#//
#//
#//----------------------------------------------------------------

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\..\inc\trans.h
PRECOMPILED_TARGET=$(GPCH_BUILD)\$(_OBJ_DIR)\*\trans.pch
PRECOMPILED_OPTION=/Yutrans.h /Fp$(GPCH_BUILD)\$(_OBJ_DIR)\*\trans.pch
PRECOMPILED_OBJ=$(GPCH_BUILD)\$(_OBJ_DIR)\*\trans.obj


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\trans\modallp.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       msgflter.cxx
//
//  Contents:   class for intellignet modal loop uses in sychronous binding
//
//  Classes:
//
//  Functions:
//
//  History:    8-21-96   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------
#include <trans.h>

//+---------------------------------------------------------------------------
//
//  Method:     CModalLoop::CModalLoop
//
//  Synopsis:
//
//  Arguments:  [phr] --
//
//  Returns:
//
//  History:    8-21-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
CModalLoop::CModalLoop(HRESULT *phr)
{
    DEBUG_ENTER((DBG_TRANS,
                None,
                "CModalLoop::CModalLoop",
                "this=%#x, %#x",
                this, phr
                ));
                
    UrlMkAssert((phr));

    // BUGBUG 3384: message filter is bogus.  Disable for now.
    // *phr = CoRegisterMessageFilter(this, &_pMsgFlter);
    _pMsgFlter = NULL;
    *phr = 0x80000000;

    DEBUG_LEAVE(0);
}

//+---------------------------------------------------------------------------
//
//  Method:     CModalLoop::~CModalLoop
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    8-21-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
CModalLoop::~CModalLoop()
{
    DEBUG_ENTER((DBG_TRANS,
                None,
                "CModalLoop::~CModalLoop",
                "this=%#x",
                this
                ));
                
    IMessageFilter *pthis;

    if (_pMsgFlter)
    {
        HRESULT hr = CoRegisterMessageFilter(_pMsgFlter, &pthis);
        // we should get back our messagefilter we installed
        // in ctor
        TransAssert(( (hr == NOERROR) && (this == pthis) ));
        _pMsgFlter->Release();
    }
    
    DEBUG_LEAVE(0);
}

//+---------------------------------------------------------------------------
//
//  Method:     CModalLoop::QueryInterface
//
//  Synopsis:
//
//  Arguments:  [riid] --
//              [ppv] --
//
//  Returns:
//
//  History:    8-21-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CModalLoop::QueryInterface( REFIID riid, void **ppv )
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CModalLoop::IUnknown::QueryInterface",
                "this=%#x, %#x, %#x",
                this, &riid, ppv
                ));
                
    HRESULT     hr = NOERROR;
    UrlMkDebugOut((DEB_BINDING, "%p _IN CModalLoop::QueryInterface (%lx, %p)\n", this, riid, ppv));

    if (   IsEqualIID(riid, IID_IUnknown)
        || IsEqualIID(riid, IID_IMessageFilter) )
    {
        *ppv = (void FAR *)(IMessageFilter *)this;
        AddRef();
    }
    else
    {
        *ppv = NULL;
        hr = E_NOINTERFACE;
    }

    UrlMkDebugOut((DEB_BINDING, "%p OUT CModalLoop::QueryInterface (%lx)[%p]\n", this, hr, *ppv));

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CModalLoop::AddRef
//
//  Synopsis:
//
//  Arguments:  [void] --
//
//  Returns:
//
//  History:    11-11-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CModalLoop::AddRef( void )
{
    DEBUG_ENTER((DBG_TRANS,
                Dword,
                "CModalLoop::IUnknown::AddRef",
                "this=%#x",
                this
                ));
                
    UrlMkDebugOut((DEB_BINDING, "%p _IN CModalLoop::AddRef\n", this));

    LONG lRet = ++_CRefs;

    UrlMkDebugOut((DEB_BINDING, "%p OUT CModalLoop::AddRef (%ld)\n", this, lRet));

    DEBUG_LEAVE(lRet);
    return lRet;
}

//+---------------------------------------------------------------------------
//
//  Method:     CModalLoop::Release
//
//  Synopsis:
//
//  Arguments:  [void] --
//
//  Returns:
//
//  History:    11-11-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CModalLoop::Release( void )
{
    DEBUG_ENTER((DBG_TRANS,
                Dword,
                "CModalLoop::IUnknown::Release",
                "this=%#x",
                this
                ));
                
    UrlMkDebugOut((DEB_BINDING, "%p _IN CModalLoop::Release\n", this));

    LONG lRet = --_CRefs;
    if (_CRefs == 0)
    {
        delete this;
    }
    UrlMkDebugOut((DEB_BINDING, "%p OUT CModalLoop::Release (%ld)\n", this, lRet));

    DEBUG_LEAVE(lRet);
    return lRet;
}

//+---------------------------------------------------------------------------
//
//  Function:   HandleInComingCall
//
//  Synopsis:
//
//  Arguments:  [DWORD] --
//
//  Returns:
//
//  History:    8-21-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(DWORD) CModalLoop::HandleInComingCall(DWORD dwCallType,HTASK htaskCaller,DWORD dwTickCount,LPINTERFACEINFO lpInterfaceInfo)
{
    DEBUG_ENTER((DBG_TRANS,
                Dword,
                "CModalLoop::HandleInComingCall",
                "this=%#x, %#x, %#x, %#x, %#x",
                this, dwCallType, htaskCaller, dwTickCount, lpInterfaceInfo
                ));
                
    DWORD dwRet = 0;
    UrlMkDebugOut((DEB_BINDING, "%p _IN CModalLoop::HandleInComingCall \n", this));

    if (_pMsgFlter)
    {
        dwRet = _pMsgFlter->HandleInComingCall(dwCallType, htaskCaller, dwTickCount, lpInterfaceInfo);
    }

    UrlMkDebugOut((DEB_BINDING, "%p OUT CModalLoop::HandleInComingCall (dwRet:%lx)\n", this, dwRet));

    DEBUG_LEAVE(dwRet);
    return dwRet;
}

//+---------------------------------------------------------------------------
//
//  Function:   RetryRejectedCall
//
//  Synopsis:
//
//  Arguments:  [DWORD] --
//
//  Returns:
//
//  History:    8-21-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(DWORD) CModalLoop::RetryRejectedCall(HTASK htaskCallee,DWORD dwTickCount,DWORD dwRejectType)
{
    DEBUG_ENTER((DBG_TRANS,
                Dword,
                "CModalLoop::RetryRejectedCall",
                "this=%#x, %#x, %#x, %#x",
                this, htaskCallee, dwTickCount, dwRejectType
                ));
                
    DWORD dwRet = 0;
    UrlMkDebugOut((DEB_BINDING, "%p _IN CModalLoop::RetryRejectedCall \n", this));

    if (_pMsgFlter)
    {
        dwRet = _pMsgFlter->RetryRejectedCall( htaskCallee, dwTickCount, dwRejectType);
    }

    UrlMkDebugOut((DEB_BINDING, "%p OUT CModalLoop::RetryRejectedCall (dwRet:%lx)\n", this, dwRet));

    DEBUG_LEAVE(dwRet);
    return dwRet;
}

//+---------------------------------------------------------------------------
//
//  Function:   MessagePending
//
//  Synopsis:
//
//  Arguments:  [DWORD] --
//
//  Returns:
//
//  History:    8-21-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(DWORD) CModalLoop::MessagePending(HTASK htaskCallee,DWORD dwTickCount,DWORD dwPendingType)
{
    DEBUG_ENTER((DBG_TRANS,
                Dword,
                "CModalLoop::MessagePending",
                "this=%#x, %#x, %#x, %#x",
                this, htaskCallee, dwTickCount, dwPendingType
                ));
                
    DWORD dwRet = 0;
    UrlMkDebugOut((DEB_BINDING, "%p _IN CModalLoop::MessagePending \n", this));

    if (_pMsgFlter)
    {
        dwRet = _pMsgFlter->MessagePending( htaskCallee, dwTickCount, dwPendingType);
    }

    UrlMkDebugOut((DEB_BINDING, "%p OUT CModalLoop::MessagePending (dwRet:%lx)\n", this, dwRet));

    DEBUG_LEAVE(dwRet);
    return dwRet;
}

//+---------------------------------------------------------------------------
//
//  Method:     CModalLoop::HandlePendingMessage
//
//  Synopsis:
//
//  Arguments:  [dwPendingType] --
//              [dwPendingRecursion] --
//              [dwReserved] --
//
//  Returns:
//
//  History:    8-21-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CModalLoop::HandlePendingMessage(DWORD dwPendingType, DWORD dwPendingRecursion, DWORD dwReserved)
{
    DEBUG_ENTER((DBG_TRANS,
                Dword,
                "CModalLoop::HandlePendingMessage",
                "this=%#x, %#x, %#x, %#x",
                this, dwPendingType, dwPendingRecursion, dwReserved
                ));
                
    HRESULT hr = NOERROR;
    DWORD dwRet = 0;
    HTASK htaskCallee = 0;
    DWORD dwTickCount = 0;

    UrlMkDebugOut((DEB_BINDING, "%p _IN CModalLoop::HandlePendingMessage \n", this));


    if (_pMsgFlter)
    {
        dwRet = _pMsgFlter->MessagePending( htaskCallee, dwTickCount, dwPendingType);
    }

    UrlMkDebugOut((DEB_BINDING, "%p OUT CModalLoop::HandlePendingMessage (dwRet:%lx)\n", this, dwRet));

    DEBUG_LEAVE(dwRet);
    return dwRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\trans\ibsc.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       cbinding.cxx
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    11-11-95   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------

#include <trans.h>

PerfDbgTag(tagCBSC, "Urlmon", "Log CBSC", DEB_BINDING);

CBSC::CBSC(Medium medium)
{
    DEBUG_ENTER((DBG_TRANS,
                None,
                "CBSC::CBSC",
                "this=%#x, %#x",
                this, medium
                ));
                
    PerfDbgLog(tagCBSC, this, "+CBSC::CBSC");
    _cRef   = 1;
    _pBdg = NULL;
    _fBindToObject = (medium == Medium_Unknown) ? TRUE : FALSE;
    _fGotStopBinding = FALSE;
    _Medium = medium;
    _pStm = NULL;
    _pStg = NULL;
    _pUnk = NULL;
    _hrResult = NOERROR;
    PerfDbgLog(tagCBSC, this, "-CBSC::CBSC");

    DEBUG_LEAVE(0);
}

CBSC::~CBSC()
{
    DEBUG_ENTER((DBG_TRANS,
                None,
                "CBSC::~CBSC",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCBSC, this, "+CBSC::~CBSC");
    if (_pStm)
    {
        _pStm->Release();
    }
    if (_pUnk)
    {
        _pUnk->Release();
    }
    PerfDbgLog(tagCBSC, this, "-CBSC::~CBSC");

    DEBUG_LEAVE(0);
}

HRESULT CBSC::GetRequestedObject(IBindCtx *pbc, void **ppvObj)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CBSC::GetRequestedObject",
                "this=%#x, %#x, %#x",
                this, pbc, ppvObj
                ));
                
    HRESULT hr = NOERROR;
    PerfDbgLog1(tagCBSC, this, "+CBSC::GetRequestedObject (_wzPath:%ws)", _wzPath);

    if (_Medium == Medium_Stream)
    {
        *ppvObj = _pStm;
        //TransAssert((_pStm));
        if (_pStm)
        {
            _pStm->AddRef();
        }
        else if (_hrResult != NOERROR)
        {
            hr = _hrResult;
        }
        else
        {
            hr = E_FAIL;
        }
    }
    else if (_Medium == Medium_Storage)
    {
        BIND_OPTS bindopts;
        bindopts.cbStruct = sizeof(BIND_OPTS);

        hr = pbc->GetBindOptions(&bindopts);
        if (hr == NOERROR)
        {
            hr = StgOpenStorage(_wzPath, NULL, bindopts.grfMode, NULL, 0, (LPSTORAGE FAR*)ppvObj );
            if (hr != NOERROR)
            {
                hr = StgOpenStorage(_wzPath, NULL, STGM_READWRITE | STGM_SHARE_DENY_NONE, NULL, 0, (LPSTORAGE FAR*)ppvObj );
            }
            if (hr != NOERROR)
            {
                hr = StgOpenStorage(_wzPath, NULL, STGM_READ | STGM_SHARE_DENY_WRITE, NULL, 0, (LPSTORAGE FAR*)ppvObj );
            }
        }
    }
    else if (_Medium == Medium_Unknown)
    {
        *ppvObj = _pUnk;
        TransAssert((_pUnk));
        if (_pUnk)
        {
            _pUnk->AddRef();
        }
        else
        {
            hr = E_FAIL;
        }
    }

    PerfDbgLog1(tagCBSC, this, "-CBSC::GetRequestedObject hr:%lx", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

STDMETHODIMP CBSC::QueryInterface(REFIID riid, void **ppvObj)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CBSC::IUnknown::QueryInterface",
                "this=%#x, %#x, %#x",
                this, &riid, ppvObj
                ));
                
    HRESULT hr = NOERROR;
    PerfDbgLog(tagCBSC, this, "+CBSC::QueryInterface");

    if (   IsEqualIID(riid, IID_IBindStatusCallback)
        || IsEqualIID(riid, IID_IUnknown))
    {
         _cRef++;   // A pointer to this object is returned
         *ppvObj = (void *)(IBindStatusCallback *)this;
    }
    else
    {
         *ppvObj = NULL;
         hr = E_NOINTERFACE;
    }

    PerfDbgLog1(tagCBSC, this, "-CBSC::QueryInterface hr:%lx", hr);

    DEBUG_LEAVE(hr);
    return hr;
}
STDMETHODIMP_(ULONG) CBSC::AddRef(void)
{
    DEBUG_ENTER((DBG_TRANS,
                Dword,
                "CBSC::IUnknown::AddRef",
                "this=%#x",
                this
                ));
                
    ULONG cRef = ++_cRef;
    PerfDbgLog1(tagCBSC, this, "CBSC::AddRef (cRef:%ld)", cRef);

    DEBUG_LEAVE(cRef);
    return cRef;
}
STDMETHODIMP_(ULONG) CBSC::Release(void)
{
    DEBUG_ENTER((DBG_TRANS,
                Dword,
                "CBSC::IUnknown::Release",
                "this=%#x",
                this
                ));
                
    ULONG cRef = 0;
    PerfDbgLog(tagCBSC, this, "+CBSC::Release");

    cRef = --_cRef;
    if (cRef == 0)
    {
        delete this;
    }

    PerfDbgLog1(tagCBSC, this, "-CBSC::Release cref:%ld", cRef);

    DEBUG_LEAVE(cRef);
    return cRef;
}


STDMETHODIMP  CBSC::GetBindInfo(
    /* [out] */ DWORD  *grfBINDINFOF,
    /* [out] */ BINDINFO  *pbindinfo)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CBSC::IBindStatusCallback::GetBindInfo",
                "this=%#x, %#x, %#x",
                this, grfBINDINFOF, pbindinfo
                ));
                
    HRESULT hr = NOERROR;
    PerfDbgLog(tagCBSC, this, "+CBSC::GetBindInfo");

    if (   (grfBINDINFOF == NULL)
        || (pbindinfo == NULL)
        || (pbindinfo->cbSize == 0)
       )

    {
        DEBUG_LEAVE(E_INVALIDARG);
        return E_INVALIDARG;
    }

    //  Nuke BINDINFO preserving cbSize;
    DWORD cbSize = pbindinfo->cbSize;
    memset(pbindinfo, 0, cbSize);
    pbindinfo->cbSize = cbSize;

    if (_Medium == Medium_Storage)
    {
        *grfBINDINFOF = 0;

    }
    else
    {
        *grfBINDINFOF = 0;
        *grfBINDINFOF |= BINDF_ASYNCSTORAGE;
        *grfBINDINFOF |= BINDF_PULLDATA;
        *grfBINDINFOF |= BINDF_NEEDFILE;

    }


    PerfDbgLog1(tagCBSC, this, "-CBSC::GetBindInfo hr:%lx", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

STDMETHODIMP  CBSC::OnStartBinding(DWORD grfBINDINFOF, IBinding  *pib)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CBSC::IBindStatusCallback::OnStartBinding",
                "this=%#x, %#x, %#x",
                this, grfBINDINFOF, pib
                ));
                
    HRESULT hr = NOERROR;
    PerfDbgLog(tagCBSC, this, "+CBSC::OnStartBinding");
    if (pib)
    {
        _pBdg = pib;
        _pBdg->AddRef();
    }

    PerfDbgLog1(tagCBSC, this, "-CBSC::OnStartBinding hr:%lx", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

STDMETHODIMP  CBSC::GetPriority(
    /* [out] */ LONG  *pnPriority)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CBSC::IBindStatusCallback::GetPriority",
                "this=%#x, %#x",
                this, pnPriority
                ));
                
    HRESULT hr = NOERROR;
    PerfDbgLog(tagCBSC, this, "+CBSC::GetPriority");

    if (pnPriority == NULL)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        *pnPriority = THREAD_PRIORITY_NORMAL;
    }

    PerfDbgLog1(tagCBSC, this, "-CBSC::GetPriority hr:%lx", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

STDMETHODIMP  CBSC::OnProgress(
    /* [in] */ ULONG ulProgress,
    /* [in] */ ULONG ulProgressMax,
    /* [in] */ ULONG ulStatusCode,
    /* [in] */ LPCWSTR szStatusText)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CBSC::IBindStatusCallback::OnProgress",
                "this=%#x, %#x, %#x, %#x, %.80wq",
                this, ulProgress, ulProgressMax, ulStatusCode, szStatusText
                ));
                
    HRESULT hr = NOERROR;
    PerfDbgLog4(tagCBSC, this, "+CBSC::OnProgress (StatusCode:%ld/%lx, Progress:%ld ProgressMax:%ld))",
        ulStatusCode, ulStatusCode, ulProgress, ulProgressMax);

    PerfDbgLog1(tagCBSC, this, "-CBSC::OnProgress hr:%lx", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

STDMETHODIMP  CBSC::OnDataAvailable(
    /* [in] */ DWORD grfBSC,
    /* [in] */ DWORD dwSize,
    /* [in] */ FORMATETC  *pFmtetc,
    /* [in] */ STGMEDIUM  *pstgmed)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CBSC::IBindStatusCallback::OnDataAvailable",
                "this=%#x, %#x, %#x, %#x, %#x",
                this, grfBSC, dwSize, pFmtetc, pstgmed
                ));
                
    HRESULT hr = NOERROR;
    HRESULT hr1 = NOERROR;
    PerfDbgLog(tagCBSC, this, "+CBSC::OnDataAvailable");

    UrlMkAssert((dwSize > 0));
    UrlMkAssert((pFmtetc != NULL && pstgmed != NULL));

    // if this is the first notification then make sure that the proper formatetc
    // is passed in.
    if (grfBSC & BSCF_FIRSTDATANOTIFICATION)
    {
        if (pFmtetc->tymed & TYMED_ISTREAM ||
            pstgmed->tymed == TYMED_ISTREAM )
        {
            STATSTG statstg;

            PerfDbgLog1(tagCBSC, this, "CBSC::OnDataAvailable - received IStream %lx", pstgmed->pstm);
            _pStm = pstgmed->pstm;
            _pStm->AddRef();

            if (pstgmed->pUnkForRelease)
            {
                _pUnk = pstgmed->pUnkForRelease;
                _pUnk->AddRef();
            }
        }
    }

    if (grfBSC & BSCF_LASTDATANOTIFICATION)
    {
        // if this is the final notification then get the data and display it

        if (_pStm)
        {
            UrlMkAssert((pFmtetc->tymed & TYMED_ISTREAM));
            //_pStm->Release();
            //_pStm = 0;
        }

        // if this is the final notification then get the data and display it

        if (pFmtetc->tymed & TYMED_FILE)
        {
            PerfDbgLog1(tagCBSC, this, "CBSC::OnDataAvailable - received File:%ws", pstgmed->lpszFileName);
            wcscpy(_wzPath, pstgmed->lpszFileName);
        }

        UrlMkAssert((_wzPath ));
    }

    PerfDbgLog1(tagCBSC, this, "-CBSC::OnDataAvailable hr:%lx", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

STDMETHODIMP  CBSC::OnLowResource(
    /* [in] */ DWORD reserved)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CBSC::IBindStatusCallback::OnLowResource",
                "this=%#x, %#x",
                this, reserved
                ));
                
    HRESULT hr = NOERROR;
    PerfDbgLog(tagCBSC, this, "+CBSC::OnLowResource");
    PerfDbgLog1(tagCBSC, this, "-CBSC::OnLowResource hr:%lx", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

STDMETHODIMP CBSC::OnStopBinding(HRESULT hresult, LPCWSTR szError)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CBSC::IBindStatusCallback::OnStopBinding",
                "this=%#x, %#x, %.80wq",
                this, hresult, szError
                ));
                
    HRESULT hr = NOERROR;
    PerfDbgLog1(tagCBSC, this, "+CBSC::OnStopBinding (hresult:%lx)", hresult);

    _fGotStopBinding = TRUE;
    _hrResult = hresult;
    if (_pBdg)
    {
        _pBdg->Release();
        _pBdg = NULL;
    }

    PerfDbgLog2(tagCBSC, this, "-CBSC::OnStopBinding (hresult:%lx) hr:%lx", hresult, hr);

    DEBUG_LEAVE(hr);
    return hr;
}

STDMETHODIMP  CBSC::OnObjectAvailable(REFIID riid, IUnknown  *punk)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CBSC::IBindStatusCallback::OnObjectAvailable",
                "this=%#x, %#x, %#x",
                this, &riid, punk
                ));
                
    HRESULT hr = NOERROR;
    PerfDbgLog(tagCBSC, this, "+CBSC::OnObjectAvailable");

    UrlMkAssert((_Medium == Medium_Unknown));
    UrlMkAssert((punk));

    punk->AddRef();
    _pUnk = punk;

    PerfDbgLog1(tagCBSC, this, "-CBSC::OnObjectAvailable hr:%lx", hr);

    DEBUG_LEAVE(hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\trans\prothndl.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       transact.cxx
//
//  Contents:   Class that performs the download of a particular request.
//
//  Classes:
//
//  Functions:
//
//  History:    12-04-95   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------
#include <trans.h>
#include <shlwapi.h>

#include "oinet.hxx"

PerfDbgTag(tagCTransaction,    "Urlmon", "Log CTransaction",        DEB_TRANS);
    DbgTag(tagCTransactionErr, "Urlmon", "Log CTransaction Errors", DEB_TRANS|DEB_ERROR);
    
HRESULT GetClassDocFileBuffer(LPVOID pbuffer, DWORD dwSize, CLSID *pclsid);
HRESULT GetCodeBaseFromDocFile(LPBYTE pBuffer, ULONG ulSize, LPWSTR *pwzClassStr, 
                               LPWSTR pwzBaseUrl, DWORD *lpdwVersionMS, DWORD *lpdwVersionLS);
HRESULT IsHandlerAvailable(LPWSTR pwzUrl, LPWSTR pwzMime, CLSID *pclsid, 
                                LPBYTE pBuffer, ULONG cbSize);

#if 0
//+---------------------------------------------------------------------------
//
//  Method:     COInetProtSnk::QueryInterface
//
//  Synopsis:
//
//  Arguments:  [riid] --
//              [ppvObj] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP COInetProtSnk::QueryInterface(REFIID riid, void **ppvObj)
{
    VDATEPTROUT(ppvObj, void *);
    VDATETHIS(this);
    HRESULT hr = NOERROR;

    PerfDbgLog(tagCTransaction, this, "+COInetProtSnk::QueryInterface");

    *ppvObj = NULL;
    if (_pUnk)
    {
        hr = _pUnk->QueryInterface(riid, ppvObj);
    }
    else
    {
        if (   (riid == IID_IUnknown)
            || (riid == IID_IOInetProtocol))
        {
            *ppvObj = (IOInetProtocol *) this;
            AddRef();
        }
        else if (riid == IID_IOInetProtocolSink)
        {
            *ppvObj = (IOInetProtocolSink *) this;
            AddRef();
        }
        else
        {
            hr = E_NOINTERFACE;
        }
    }

    PerfDbgLog1(tagCTransaction, this, "-COInetProtSnk::QueryInterface (hr:%lx)", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   COInetProtSnk::AddRef
//
//  Synopsis:
//
//  Arguments:  [ULONG] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) COInetProtSnk::AddRef(void)
{
    PerfDbgLog(tagCTransaction, this, "+COInetProtSnk::AddRef");

    LONG lRet = _pProtSnk->AddRef();

    PerfDbgLog1(tagCTransaction, this, "-COInetProtSnk::AddRef (cRefs:%ld)", lRet);
    return lRet;
}

//+---------------------------------------------------------------------------
//
//  Function:   COInetProtSnk::Release
//
//  Synopsis:
//
//  Arguments:  [ULONG] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) COInetProtSnk::Release(void)
{
    PerfDbgLog(tagCTransaction, this, "+COInetProtSnk::Release");

    LONG lRet = _pProtSnk->Release();

    PerfDbgLog1(tagCTransaction, this, "-COInetProtSnk::Release (cRefs:%ld)", lRet);
    return lRet;
}


//+---------------------------------------------------------------------------
//
//  Method:     COInetProtSnk::Switch
//
//  Synopsis:
//
//  Arguments:  [pStateInfo] --
//
//  Returns:
//
//  History:    11-07-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP COInetProtSnk::Switch(PROTOCOLDATA *pStateInfo)
{
    PerfDbgLog(tagCTransaction, this, "+COInetProtSnk::Switch");
    HRESULT hr = NOERROR;

    hr = _pProtSnk->Switch(pStateInfo);
   
    PerfDbgLog1(tagCTransaction, this, "-COInetProtSnk::Switch (hr:%lx)", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     COInetProtSnk::ReportProgress
//
//  Synopsis:
//
//  Arguments:  [NotMsg] --
//              [szStatusText] --
//
//  Returns:
//
//  History:    11-07-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP COInetProtSnk::ReportProgress(ULONG NotMsg, LPCWSTR pwzStatusText)
{
    PerfDbgLog1(tagCTransaction, this, "+COInetProtSnk::ReportProgress pwzStatusText:%ws", pwzStatusText);
    HRESULT hr = NOERROR;

    hr = _pProtSnk->ReportProgress(NotMsg, pwzStatusText);

    PerfDbgLog2(tagCTransaction, this, "-COInetProtSnk::ReportProgress (pwzStatusText:%ws, hr:%lx)", pwzStatusText, hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     COInetProtSnk::ReportData
//
//  Synopsis:
//
//  Arguments:  [grfBSCF] --
//              [ULONG] --
//              [ulProgressMax] --
//
//  Returns:
//
//  History:    11-07-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP COInetProtSnk::ReportData(DWORD grfBSCF, ULONG ulProgress,ULONG ulProgressMax)
{
    PerfDbgLog3(tagCTransaction, this, "+COInetProtSnk::ReportData(grfBSCF:%lx, ulProgress:%ld, ulProgressMax:%ld)",
                                       grfBSCF, ulProgress, ulProgressMax);
    HRESULT hr = NOERROR;

    hr = _pProtSnk->ReportData( grfBSCF, ulProgress, ulProgressMax);
  
    PerfDbgLog1(tagCTransaction, this, "-COInetProtSnk::ReportData (hr:%lx)", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     COInetProtSnk::ReportResult
//
//  Synopsis:
//
//  Arguments:  [DWORD] --
//              [dwError] --
//              [wzResult] --
//
//  Returns:
//
//  History:    11-07-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP COInetProtSnk::ReportResult(HRESULT hrResult, DWORD dwError, LPCWSTR wzResult)
{
    PerfDbgLog(tagCTransaction, this, "+COInetProtSnk::ReportResult");
    HRESULT hr = NOERROR;

    hr = _pProtSnk->ReportResult(hrResult, dwError, wzResult);
    
    PerfDbgLog1(tagCTransaction, this, "-COInetProtSnk::ReportResult (hr:%lx)", hr);
    return hr;
}
#endif // 0
//+---------------------------------------------------------------------------
//
//  Method:     COInetProt::QueryInterface
//
//  Synopsis:
//
//  Arguments:  [riid] --
//              [ppvObj] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP COInetProt::QueryInterface(REFIID riid, void **ppvObj)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "COInetProt::IUnknown::QueryInterface",
                "this=%#x, %#x, %#x",
                this, &riid, ppvObj
                ));
                
    VDATEPTROUT(ppvObj, void *);
    VDATETHIS(this);
    HRESULT hr = NOERROR;

    PerfDbgLog(tagCTransaction, this, "+COInetProt::QueryInterface");

    *ppvObj = NULL;

    if (_pUnk)
    {
        hr = _pUnk->QueryInterface(riid, ppvObj);
    }
    else
    {
        if (   (riid == IID_IUnknown)
            || (riid == IID_IOInetProtocol))
        {
            *ppvObj = (IOInetProtocol *) this;
            AddRef();
        }
        else if (riid == IID_IOInetProtocolSink)
        {
            *ppvObj = (IOInetProtocolSink *) this;
            AddRef();
        }
        else if (riid == IID_IServiceProvider)
        {
            *ppvObj = (IServiceProvider *) this;
            AddRef();
        }
        else if (riid == IID_IOInetPriority)
        {
            *ppvObj = (IOInetPriority *) this;
            AddRef();
        }
        else
        {
            hr = E_NOINTERFACE;
        }
    }


    PerfDbgLog1(tagCTransaction, this, "-COInetProt::QueryInterface (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   COInetProt::AddRef
//
//  Synopsis:
//
//  Arguments:  [ULONG] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) COInetProt::AddRef(void)
{
    DEBUG_ENTER((DBG_TRANS,
                Dword,
                "COInetProt::IUnknown::AddRef",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCTransaction, this, "+COInetProt::AddRef");

    LONG lRet;
    
    if (_pUnk)
    {
        lRet = _pUnk->AddRef();
    }
    else
    {
        lRet = ++_CRefs;
    }
    
    PerfDbgLog1(tagCTransaction, this, "-COInetProt::AddRef (cRefs:%ld)", lRet);

    DEBUG_LEAVE(lRet);
    return lRet;
}

//+---------------------------------------------------------------------------
//
//  Function:   COInetProt::Release
//
//  Synopsis:
//
//  Arguments:  [ULONG] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) COInetProt::Release(void)
{
    DEBUG_ENTER((DBG_TRANS,
                Dword,
                "COInetProt::IUnknown::Release",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCTransaction, this, "+COInetProt::Release");

    LONG lRet;
    if (_pUnk)
    {
        lRet = _pUnk->Release();
    }
    else
    {
        lRet = --_CRefs;
        if (_CRefs == 0)
        {
            //
            // release all objects
            if (_pProtSnk)
            {
                _pProtSnk->Release();
            }
            if (_pProt)
            {
                _pProt->Release();
            }

            if (_dwMode & PP_DELETE)
            {
                delete this;
            }
        }
    }

    PerfDbgLog1(tagCTransaction, this, "-COInetProt::Release (cRefs:%ld)", lRet);

    DEBUG_LEAVE(lRet);
    return lRet;
}

//+---------------------------------------------------------------------------
//
//  Method:     COInetProt::Start
//
//  Synopsis:
//
//  Arguments:  [pwzUrl] --
//              [pTrans] --
//              [pOIBindInfo] --
//              [grfSTI] --
//              [dwReserved] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP COInetProt::Start(LPCWSTR pwzUrl, IOInetProtocolSink *pOInetProtSnk, IOInetBindInfo *pOIBindInfo,
                          DWORD grfSTI, DWORD_PTR dwReserved)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "COInetProt::IInternetProtocolRoot::Start",
                "this=%#x, %.80wq, %#x, %#x, %#x, %#x",
                this, pwzUrl, pOInetProtSnk, pOIBindInfo, grfSTI, dwReserved
                ));
                
    PerfDbgLog(tagCTransaction, this, "+COInetProt::Start\n");
    HRESULT hr = NOERROR;

    TransAssert((pOIBindInfo && pOInetProtSnk && pwzUrl));

    // Just before starting the transaction give it the priority.

    IOInetPriority * pOInetPriority = NULL;
    if (_pProt->QueryInterface(IID_IOInetPriority, (void **) &pOInetPriority) == S_OK)
    {
        pOInetPriority->SetPriority(_nPriority);
        pOInetPriority->Release();
    }

    delete [] _pwzUrl;
    _pwzUrl = OLESTRDuplicate(pwzUrl);

    hr = _pProt->Start(pwzUrl, pOInetProtSnk, pOIBindInfo, grfSTI, dwReserved);
    
    PerfDbgLog1(tagCTransaction, this, "-COInetProt::Start (hr:%lx)\n", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     COInetProt::Continue
//
//  Synopsis:
//
//  Arguments:  [pStateInfoIn] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP COInetProt::Continue(PROTOCOLDATA *pStateInfoIn)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "COInetProt::IInternetProtocolRoot::Continue",
                "this=%#x, %#x",
                this, pStateInfoIn
                ));
                
    PerfDbgLog(tagCTransaction, this, "+COInetProt::Continue\n");

    HRESULT hr = _pProt->Continue(pStateInfoIn);

    PerfDbgLog1(tagCTransaction, this, "-COInetProt::Continue (hr:%lx)\n",hr);

    DEBUG_LEAVE(hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     COInetProt::Abort
//
//  Synopsis:
//
//  Arguments:  [hrReason] --
//              [dwOptions] --
//
//  Returns:
//
//  History:    11-09-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP COInetProt::Abort(HRESULT hrReason, DWORD dwOptions)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "COInetProt::IInternetProtocolRoot::Abort",
                "this=%#x, %#x, %#x",
                this, hrReason, dwOptions
                ));
                
    PerfDbgLog(tagCTransaction, this, "+COInetProt::Abort\n");
    HRESULT hr = NOERROR;

    hr = _pProt->Abort(hrReason, dwOptions);

    PerfDbgLog1(tagCTransaction, this, "-COInetProt::Abort (hr:%lx)\n", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     COInetProt::Terminate
//
//  Synopsis:
//
//  Arguments:  [dwOptions] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP COInetProt::Terminate(DWORD dwOptions)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "COInetProt::IInternetProtocolRoot::Terminate",
                "this=%#x, %#x",
                this, dwOptions
                ));
                
    PerfDbgLog(tagCTransaction, this, "+COInetProt::Terminate\n");
    HRESULT hr = NOERROR;

    TransAssert((_pProt));
    
    hr = _pProt->Terminate(dwOptions);
    SetProtocolSink(0);
    SetServiceProvider(0);

    PerfDbgLog1(tagCTransaction, this, "-COInetProt::Terminate (hr:%lx)\n", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     COInetProt::Suspend
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP COInetProt::Suspend()
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "COInetProt::IInternetProtocolRoot::Suspend",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCTransaction, this, "+COInetProt::Suspend\n");

    HRESULT hr = _pProt->Suspend();

    PerfDbgLog1(tagCTransaction, this, "-COInetProt::Suspend (hr:%lx)\n", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     COInetProt::Resume
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP COInetProt::Resume()
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "COInetProt::IInternetProtocolRoot::Resume",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCTransaction, this, "+COInetProt::Resume\n");

    HRESULT hr = _pProt->Resume();

    PerfDbgLog1(tagCTransaction, this, "-COInetProt::Resume (hr:%lx)\n", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     COInetProt::Read
//
//  Synopsis:
//
//  Arguments:  [ULONG] --
//              [ULONG] --
//              [pcbRead] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP COInetProt::Read(void *pBuffer, ULONG cbBuffer,ULONG *pcbRead)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "COInetProt::IInternetProtocol::Read",
                "this=%#x, %#x, %#x, %#x",
                this, pBuffer, cbBuffer, pcbRead
                ));
                
    PerfDbgLog(tagCTransaction, this, "+COInetProt::Read\n");
    HRESULT     hr = E_FAIL;

    BOOL fRead = TRUE;
    DWORD dwCopy = 0;
    DWORD dwCopyNew = 0;

    if ((_dwOInetBdgFlags & (PI_MIMEVERIFICATION | PI_DOCFILECLSIDLOOKUP))
        && _cbBufferUnread)
    {
        fRead = FALSE;

        // copy data form the local buffer to the provide buffer
        if (cbBuffer <= _cbBufferUnread)
        {
            dwCopy = cbBuffer;
            hr = S_OK;
        } 
        else
        {
            dwCopy = _cbBufferUnread;
            fRead = TRUE;
        }
        memcpy(pBuffer, _pBuffer+(_cbBufferFilled-_cbBufferUnread), dwCopy);
        _cbBufferUnread -= dwCopy;
    }

    if (fRead)
    {
        if (_pProt)
        {
            hr = _pProt->Read( ((LPBYTE)pBuffer) + dwCopy, cbBuffer - dwCopy, &dwCopyNew);
            _cbTotalBytesRead += dwCopyNew;
        }
        else
        {
            hr = S_FALSE;
        }
    }

    if (pcbRead)
    {
        *pcbRead = dwCopy + dwCopyNew;
    }
 

    PerfDbgLog1(tagCTransaction, this, "-COInetProt::Read (hr:%lx)\n",hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     COInetProt::Seek
//
//  Synopsis:
//
//  Arguments:  [DWORD] --
//              [ULARGE_INTEGER] --
//              [plibNewPosition] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP COInetProt::Seek(LARGE_INTEGER dlibMove,DWORD dwOrigin,ULARGE_INTEGER *plibNewPosition)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "COInetProt::IInternetProtocol::Seek",
                "this=%#x, %#x, %#x, %#x",
                this, dlibMove, dwOrigin, plibNewPosition
                ));
                
    PerfDbgLog(tagCTransaction, this, "+COInetProt::Seek\n");

    HRESULT hr = _pProt->Seek(dlibMove, dwOrigin, plibNewPosition);

    PerfDbgLog1(tagCTransaction, this, "-COInetProt::Seek (hr:%lx)\n", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     COInetProt::LockRequest
//
//  Synopsis:
//
//  Arguments:  [dwOptions] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP COInetProt::LockRequest(DWORD dwOptions)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "COInetProt::IInternetProtocol::LockRequest",
                "this=%#x, %#x",
                this, dwOptions
                ));
                
    PerfDbgLog(tagCTransaction, this, "+COInetProt::LockRequest\n");

    HRESULT hr = hr = _pProt->LockRequest(dwOptions);

    PerfDbgLog1(tagCTransaction, this, "-COInetProt::LockRequest (hr:%lx)\n",hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     COInetProt::UnlockRequest
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP COInetProt::UnlockRequest()
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "COInetProt::IInternetProtocol::UnlockRequest",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCTransaction, this, "+COInetProt::UnlockRequest\n");
    HRESULT hr = NOERROR;

    hr = _pProt->UnlockRequest();

    PerfDbgLog1(tagCTransaction, this, "-COInetProt::UnlockRequest (hr:%lx)\n", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CTransaction::OnDataReceived
//
//  Synopsis:
//
//  Arguments:  [grfBSC] --
//              [cbBytesAvailable] --
//              [dwTotalSize] --
//              [pcbNewAvailable] --
//
//  Returns:
//
//  History:    4-15-1997   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP COInetProt::OnDataReceived(DWORD *pgrfBSC, DWORD *pcbBytesAvailable, DWORD *pdwTotalSize)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "COInetProt::OnDataReceived",
                "this=%#x, %#x, %#x, %#x",
                this, pgrfBSC, pcbBytesAvailable, pdwTotalSize
                ));
                
    PerfDbgLog3(tagCTransaction, this, "+COInetProt::OnDataReceived (grfBSC:%lx,  *pcbBytesAvailable:%ld, _cbTotalBytesRead:%ld)",
                                    *pgrfBSC, *pcbBytesAvailable, _cbTotalBytesRead);
    HRESULT hr = NOERROR;
    DWORD grfBSC = *pgrfBSC;
    BOOL fEndOfData = FALSE;
    
    if (_fWaitOnHandler)
    {
        hr = S_NEEDMOREDATA;
    }
    else if (  
        ((_dwOInetBdgFlags & (PI_MIMEVERIFICATION | PI_DOCFILECLSIDLOOKUP | PI_CLASSINSTALL))
            && (!_fMimeVerified || _fNeedMoreData))
        ||
        ((_dwOInetBdgFlags & PI_CLASSINSTALL) && !_fClassInstallChecked)
            )
    {
        DWORD dwNewData = 0;
        TransAssert((_pProt && _cbDataSniffMin));

        //TransAssert((pcbBytesAvailable && *pcbBytesAvailable)); 
        //TransAssert((pdwTotalSize));

        // _cbTotalBytesRead = # of bytes read so far
        if (_cbBufferFilled < _cbDataSniffMin)
        {
            // no bytes read so far
            TransAssert((_cbTotalBytesRead < _cbDataSniffMin));
            // read data into buffer and report progess
            do
            {
                PProtAssert((_pBuffer && (_pBuffer + _cbBufferFilled) ));
                hr = _pProt->Read(_pBuffer + _cbBufferFilled, _cbBufferSize - _cbBufferFilled, &dwNewData);
                _cbTotalBytesRead += dwNewData;
                _cbBufferFilled += dwNewData;
                _cbBufferUnread += dwNewData;
            } while ((hr == S_OK) && (_cbBufferFilled < _cbDataSniffMin));

            // now check if this is docfile
            // if so download at least 2k
            if (!_fDocFile && _cbBufferFilled && (IsDocFile(_pBuffer, _cbBufferFilled) == S_OK))
            {
                _fDocFile = TRUE;
                
                // we may need to sniff to maximum to find handler

                if (_cbBufferSize < DATASNIFSIZEDOCFILE_MAX)
                {
                    LPBYTE pBufferTemp;

                    pBufferTemp = (LPBYTE) new BYTE[DATASNIFSIZEDOCFILE_MAX];
                    if (pBufferTemp)
                    {
                        memcpy(pBufferTemp, _pBuffer, _cbBufferFilled);
                        delete [] _pBuffer;
                        _pBuffer = pBufferTemp;
                        _cbBufferSize = DATASNIFSIZEDOCFILE_MAX;
                        
                        if (hr == NOERROR)
                        {
                            //since we increased the buffersize and we want to drain DATASNIFSIZEDOCFILE_MAX bytes.
                            do
                            {
                                PProtAssert((_pBuffer && (_pBuffer + _cbBufferFilled) ));
                                hr = _pProt->Read(_pBuffer + _cbBufferFilled, _cbBufferSize - _cbBufferFilled, &dwNewData);
                                _cbTotalBytesRead += dwNewData;
                                _cbBufferFilled += dwNewData;
                                _cbBufferUnread += dwNewData;
                            } while ((hr == S_OK) && (_cbBufferFilled < _cbBufferSize));                       
                        }
                    }
                }
                
                _cbDataSniffMin =  (*pdwTotalSize && *pdwTotalSize < _cbBufferSize) ? *pdwTotalSize : _cbBufferSize;                    
            }

            if ((hr == E_PENDING) && (_cbBufferFilled < _cbDataSniffMin))
            {
                // do not report anything - wait until we get more data
                // a request is pending at this time
                // need more data to sniff properly
                hr  = S_NEEDMOREDATA;
            }
            else if (hr == NOERROR || hr == E_PENDING)
            {
                TransAssert((_cbTotalBytesRead != 0));

                // report the data we have in the buffer or
                // the available #
                DWORD cbBytesReport =  (*pcbBytesAvailable > _cbTotalBytesRead) ? *pcbBytesAvailable : _cbTotalBytesRead + 1;

                if (*pdwTotalSize && ((cbBytesReport > *pdwTotalSize)))
                {
                    cbBytesReport = *pdwTotalSize;
                }
                *pcbBytesAvailable = cbBytesReport;
            }
            else if (hr == S_FALSE)
            {
                // end of stream
                *pgrfBSC |=  (BSCF_LASTDATANOTIFICATION & BSCF_DATAFULLYAVAILABLE);
                *pcbBytesAvailable = *pdwTotalSize =  _cbTotalBytesRead;
                fEndOfData = TRUE;
            }
            
            if (   (!_fMimeVerified)
                && (   (*pcbBytesAvailable >= _cbDataSniffMin)
                    || (hr == S_FALSE)) )
            {
                // enough data or end of stream
                _fMimeVerified = TRUE;
                LPWSTR  pwzStr = 0;
                DWORD dwMimeFlags = FMFD_DEFAULT;
                if( !_pwzFileName )
                {
                    dwMimeFlags = FMFD_URLASFILENAME;        
                }
                hr = FindMimeFromData(NULL, (_pwzFileName) ? _pwzFileName : _pwzUrl, _pBuffer, _cbBufferFilled, _pwzMimeSuggested, dwMimeFlags, &pwzStr, 0);

                TransAssert(pwzStr);

                // note: _pwzUrl & _pwzFileName may be used later for composing URL
                //       in code base attribute of active document (deleted in destructor)
                
                if (pwzStr)
                {
                    _fMimeReported = 1;
                    _pProtSnk->ReportProgress(BINDSTATUS_MIMETYPEAVAILABLE, pwzStr);
                }
                else
                {
                    TransAssert((!_pwzMimeSuggested));
                }

                if (pwzStr)
                {
                    delete [] _pwzMimeSuggested;
                    _pwzMimeSuggested = pwzStr;
                    pwzStr = 0;
                }

                if (   _fDocFile
                    && (_dwOInetBdgFlags & PI_DOCFILECLSIDLOOKUP))
                {
                    // find the class id and send it on
                    CLSID clsid;

                    HRESULT hr1 = GetClassDocFileBuffer(_pBuffer, _cbBufferFilled, &clsid);
                    if (hr1 == NOERROR)
                    {
                        if (_pwzStrClsId)
                        {
                            delete [] _pwzStrClsId;
                            _pwzStrClsId = NULL;
                        }
                        StringFromCLSID(clsid, &_pwzStrClsId);
                        if (_pwzStrClsId)
                        {
                            _fReportedClassId = TRUE;
                            _pProtSnk->ReportProgress(BINDSTATUS_CLASSIDAVAILABLE, _pwzStrClsId);
                        }
                    }
                }
            }
        }

        //On a BTS->BTO scenario, we should get into this loop with the lesser of DATASNIFSIZEDOCFILE_MIN or TOTAL_SIZE.
        //On a BTO scenario, the situation is the same as before, except hr=S_NEEDMOREDATA if size<DATASNIF_MIN.
        //On a BTS scenario, this block will not be entered.
        if (   (_dwOInetBdgFlags & PI_CLASSINSTALL)
            && !_fGotHandler )
        {
            _fClassInstallChecked = TRUE;
            
            BOOL fIgnoreMimeClsid = FALSE;
            DWORD dwVersionMS = 0, dwVersionLS = 0;
            LPWSTR pwzCodeBase = 0, pwzVerInfo = 0;
            CLSID clsid;
            HRESULT hr1;

            if (!_fReportedClassId && _pwzStrClsId && _pProtSnk)
            {
                _fReportedClassId = TRUE;
                _pProtSnk->ReportProgress(BINDSTATUS_CLASSIDAVAILABLE, _pwzStrClsId);
            }
            
            if (IsHandlerAvailable((_pwzFileName) ? _pwzFileName : _pwzUrl, _pwzMimeSuggested, &clsid, _pBuffer, _cbBufferFilled) == S_OK)
            {
                _fGotHandler = TRUE;
            }
            else if (_fDocFile)
            {
                // try get code base + version information
                // even if handler is installed, a newer version may be required for this doc file

                hr1 = GetCodeBaseFromDocFile(_pBuffer, _cbBufferFilled, &pwzCodeBase, _pwzUrl, &dwVersionMS, &dwVersionLS);

                // convert version info. to string
                if (SUCCEEDED(hr1) && (dwVersionMS || dwVersionLS))
                {
                    CHAR szVerInfo[MAX_PATH];

                    wsprintfA(szVerInfo,"%ld,%ld", dwVersionMS, dwVersionLS);
                    pwzVerInfo = DupA2W(szVerInfo);
                }
                
                // if failed to get codebase, keep sniffing
                // if we are at end of bits then go with out a code base

                _fNeedMoreData = FAILED(hr1) && (_cbBufferFilled < _cbDataSniffMin) && (!fEndOfData);
            }

            //BUGBUG #51944: This currently requires a DocFile and CodeBase property

            if (!_fNeedMoreData && !_fGotHandler && _fDocFile && pwzCodeBase)
            {
                LPOLESTR pwzClsId = 0;

                if (!IsEqualCLSID(clsid, CLSID_NULL))
                {
                    StringFromCLSID(clsid, &pwzClsId);
                }
                else if (_pwzMimeSuggested)
                {
                    // this is an optimization, if no CLSID and only this as mime type
                    // then we won't find anything in ObjectStore
                    if (!StrCmpNIW(_pwzMimeSuggested, L"application/octet-stream", 24))
                    {
                        _fGotHandler = TRUE;
                    }
                }

                if (!_fGotHandler && (pwzClsId || _pwzMimeSuggested))
                {
                    LPWSTR pwzClassStr = 0;
                    int cbClassStr;

                    cbClassStr = (pwzCodeBase ? lstrlenW(pwzCodeBase) : 0)
                        + (pwzClsId ? lstrlenW(pwzClsId) : 0)
                        + (_pwzMimeSuggested ? lstrlenW(_pwzMimeSuggested) : 0)
                        + (pwzVerInfo ? (lstrlenW(pwzVerInfo) + 1) : 0)
                        + 3;

                    pwzClassStr = new WCHAR[cbClassStr];

                    if (pwzClassStr)
                    {
                        //BUGBUG: This is a bit of a hack, we have a collection of
                        //info to pass into filter, we concatenate it into one long
                        //string and send it in.

                        *pwzClassStr = '\0';
                        if (pwzCodeBase && *pwzCodeBase)
                        {
                            StrCpyW(pwzClassStr, pwzCodeBase);
                        }

                        StrCatW(pwzClassStr, L"?");

                        if (pwzClsId)
                        {
                            StrCatW(pwzClassStr, pwzClsId);
                        }
                        else if (_pwzMimeSuggested)
                        {
                            StrCatW(pwzClassStr, _pwzMimeSuggested);
                        }

                        if (pwzVerInfo)
                        {
                            StrCatW(pwzClassStr, L"?");
                            StrCatW(pwzClassStr, pwzVerInfo);
                        }                               
                    
                        _pCTrans->ReportProgress(BINDSTATUS_CLASSINSTALLLOCATION, 
                                        pwzClassStr);

                        delete [] pwzClassStr;

                        // don't process this code branch again
                        _fGotHandler = TRUE;

                        // wait on more data now
                        hr = S_NEEDMOREDATA;

                       // wait on more data for future calls
                        _fWaitOnHandler = TRUE;

                        // wait for more data to sniff
                        _fNeedMoreData = TRUE;

                    }

                    delete [] pwzClsId;

                } // pwzClsId || _pwzMimeSuggested
            } // !_fNeedMoreData

            if (pwzCodeBase)
            {
                CoTaskMemFree(pwzCodeBase);
            }

            if (pwzVerInfo)
            {
                delete [] pwzVerInfo;
            }

            // if we don't need to sniff any more, curb _cbDataSniffMin
            if (_fDocFile && _fGotHandler)
            {   
                _cbDataSniffMin =  (*pdwTotalSize && *pdwTotalSize < DATASNIFSIZEDOCFILE_MIN) ? *pdwTotalSize : DATASNIFSIZEDOCFILE_MIN;
            }

            // once we have a handler we can release pwzUrl & pwzFilename
            if (_fGotHandler)
            {
                delete [] _pwzUrl;
                _pwzUrl = 0;
                delete [] _pwzFileName;
                _pwzFileName = 0;
            }

            // report the data we have in the buffer or
            // the available #
            *pcbBytesAvailable =  (*pcbBytesAvailable > _cbTotalBytesRead) ? *pcbBytesAvailable : _cbTotalBytesRead + 1;
        }  // PI_CLASSINSTALL && !_fGotHandler
  
        if (*pdwTotalSize && (*pdwTotalSize < *pcbBytesAvailable))
        {
            *pcbBytesAvailable = *pdwTotalSize;
        }
        
        if (hr == S_FALSE)
        {
            hr = NOERROR;
        }
    }
    
    {
        CLock lck(_mxs);
        _cbBytesReported = *pcbBytesAvailable;
    }
    //TransAssert((pcbBytesAvailable && *pcbBytesAvailable)); 
    //TransAssert((hr == NOERROR || hr == S_NEEDMOREDATA));

    PerfDbgLog2(tagCTransaction, this, "-COInetProt::OnDataReceived (hr:%lx, _cbBufferFilled:%ld)", hr, _cbBufferFilled);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     COInetProt::Switch
//
//  Synopsis:
//
//  Arguments:  [pStateInfo] --
//
//  Returns:
//
//  History:    11-07-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP COInetProt::Switch(PROTOCOLDATA *pStateInfo)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "COInetProt::IInternetProtocolSink::Switch",
                "this=%#x, %#x",
                this, pStateInfo
                ));
                
    PerfDbgLog(tagCTransaction, this, "+COInetProt::Switch");
    HRESULT hr = NOERROR;

    hr = _pProtSnk->Switch(pStateInfo);
   
    PerfDbgLog1(tagCTransaction, this, "-COInetProt::Switch (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     COInetProt::ReportProgress
//
//  Synopsis:
//
//  Arguments:  [NotMsg] --
//              [szStatusText] --
//
//  Returns:
//
//  History:    11-07-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP COInetProt::ReportProgress(ULONG NotMsg, LPCWSTR pwzStatusText)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "COInetProt::IInternetProtocolSink::ReportProgress",
                "this=%#x, %#x, %.80wq",
                this, NotMsg, pwzStatusText
                ));
                
    PerfDbgLog(tagCTransaction, this, "+COInetProt::ReportProgress");
    HRESULT hr = NOERROR;

    switch (NotMsg)
    {
    case BINDSTATUS_FILTERREPORTMIMETYPE:
    {
        if( _pCTrans && pwzStatusText )
        {
            // mime filter sending signal to tell us the true mime type
            _pCTrans->UpdateVerifiedMimeType(pwzStatusText);
        }
        
    }
    break;


    case BINDSTATUS_MIMETYPEAVAILABLE:
        if (_dwOInetBdgFlags & (PI_MIMEVERIFICATION | PI_DOCFILECLSIDLOOKUP | PI_CLASSINSTALL))
        {
            // report the mime later after sniffing data
            _pwzMimeSuggested = OLESTRDuplicate(pwzStatusText);
        }
        else
        {
            hr = _pProtSnk->ReportProgress(NotMsg, pwzStatusText);
        }

    break;

    case BINDSTATUS_VERIFIEDMIMETYPEAVAILABLE:
    {
        // disable mime sniffing
        _dwOInetBdgFlags &= (~PI_MIMEVERIFICATION &~PI_DOCFILECLSIDLOOKUP &~PI_CLASSINSTALL);
        hr = _pProtSnk->ReportProgress(BINDSTATUS_MIMETYPEAVAILABLE, pwzStatusText);

    }
    break;

    case BINDSTATUS_CACHEFILENAMEAVAILABLE :
        _pwzFileName = OLESTRDuplicate(pwzStatusText);
        hr = _pProtSnk->ReportProgress(NotMsg, pwzStatusText);
    break;

    case BINDSTATUS_DIRECTBIND:
        _fMimeVerified = TRUE;
    break;
    
    case BINDSTATUS_ENDDOWNLOADCOMPONENTS :
        if (_fWaitOnHandler)
        {
            // don't stall ReportData any more
            _fWaitOnHandler = FALSE;

            // we're done with our stuff, skip sniffing
            _fNeedMoreData = FALSE;
           
        }


    default:
    {
        hr = _pProtSnk->ReportProgress(NotMsg, pwzStatusText);
    }

    } // end switch
    
    PerfDbgLog1(tagCTransaction, this, "-COInetProt::ReportProgress (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     COInetProt::ReportData
//
//  Synopsis:
//
//  Arguments:  [grfBSCF] --
//              [ULONG] --
//              [ulProgressMax] --
//
//  Returns:
//
//  History:    11-07-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP COInetProt::ReportData(DWORD grfBSCF, ULONG ulProgress,ULONG ulProgressMax)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "COInetProt::IInternetProtocolSink::ReportData",
                "this=%#x, %#x, %#x, %#x",
                this, grfBSCF, ulProgress, ulProgressMax
                ));
                
    PerfDbgLog3(tagCTransaction, this, "+COInetProt::ReportData(grfBSCF:%lx, ulProgress:%ld, ulProgressMax:%ld)",
                                       grfBSCF, ulProgress, ulProgressMax);
    HRESULT hr = NOERROR, hr2;

    TransAssert((ulProgress));

    if (   ((_dwOInetBdgFlags & (PI_MIMEVERIFICATION | PI_DOCFILECLSIDLOOKUP | PI_CLASSINSTALL))
        && (!_fMimeVerified || _fNeedMoreData))
        ||
            ((_dwOInetBdgFlags & PI_CLASSINSTALL) && !_fClassInstallChecked)
       )
    {
        if (   (OnDataReceived(&grfBSCF, &ulProgress, &ulProgressMax) == NOERROR)
            && _pProtSnk 
            && (ulProgress || (!ulProgress && !ulProgressMax)) )
        {
            // OnDataReceived sniffs data and calls Read - EOF with ReportResult might occure
            //TransAssert((ulProgress));
            TransAssert((_fMimeReported));
            hr = _pProtSnk->ReportData( grfBSCF, ulProgress, ulProgressMax);
        }
    }
    else 
    {
        TransAssert((ulProgress));
        hr = _pProtSnk->ReportData( grfBSCF, ulProgress, ulProgressMax);
    }

    PerfDbgLog1(tagCTransaction, this, "-COInetProt::ReportData (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     COInetProt::ReportResult
//
//  Synopsis:
//
//  Arguments:  [DWORD] --
//              [dwError] --
//              [wzResult] --
//
//  Returns:
//
//  History:    11-07-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP COInetProt::ReportResult(HRESULT hrResult, DWORD dwError, LPCWSTR wzResult)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "COInetProt::IInternetProtocolSink::ReportResult",
                "this=%#x, %#x, %#x, %.80wq",
                this, hrResult, dwError, wzResult
                ));
                
    PerfDbgLog(tagCTransaction, this, "+COInetProt::ReportResult");
    HRESULT hr = NOERROR;

    hr = _pProtSnk->ReportResult(hrResult, dwError, wzResult);
    
    PerfDbgLog1(tagCTransaction, this, "-COInetProt::ReportResult (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     COInetProt::Initialize
//
//  Synopsis:
//
//  Arguments:  [pCTrans] --
//              [dwMode] --
//              [dwOptions] --
//              [pUnk] --
//              [pProt] --
//              [pProtSnk] --
//
//  Returns:
//
//  History:    11-07-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP COInetProt::Initialize(CTransaction *pCTrans,IServiceProvider *pSrvPrv, DWORD dwMode, DWORD dwOptions, 
                                    IUnknown *pUnk, IOInetProtocol *pProt, IOInetProtocolSink *pProtSnk, LPWSTR pwzUrl)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "COInetProt::Initialize",
                "this=%#x, %#x, %#x, %#x, %#x, %#x, %#x, %#x, %.80wq",
                this, pCTrans, pSrvPrv, dwMode, dwOptions, pUnk, pProt, pProtSnk, pwzUrl
                ));
                
    HRESULT hr = NOERROR;
    _dwMode = dwMode;
    _pUnk = pUnk;
    //_pProt = pProt;
    //_pProtSnk = pProtSnk;
    _pCTrans = pCTrans;
    _pSrvPrv = pSrvPrv;
    if (_pSrvPrv)
    {
        _pSrvPrv->AddRef();
    }
    SetProtocolSink(pProtSnk);
    SetProtocol(pProt);
    
    _dwOInetBdgFlags = dwOptions;
    if (_dwOInetBdgFlags & (PI_MIMEVERIFICATION | PI_DOCFILECLSIDLOOKUP))
    {
        ULONG cbBufferSize;
        
        TransAssert(( DATASNIFSIZE_MIN <= DATASNIFSIZEDOCFILE_MIN));

        if (_dwOInetBdgFlags & PI_CLASSINSTALL)
        {
            cbBufferSize = DATASNIFSIZEDOCFILE_MAX;
        }
        else
        {
            cbBufferSize = DATASNIFSIZEDOCFILE_MIN; //DATASNIFSIZE_MIN; 
        }

        if (cbBufferSize != _cbBufferSize)
        {
            _cbBufferSize = cbBufferSize;
            delete [] _pBuffer;
            _pBuffer = (LPBYTE) new BYTE[_cbBufferSize];
        }

        if (!_pBuffer)
        {
            _cbBufferSize = 0;
            hr = E_OUTOFMEMORY;
        }
        else
        {
            _cbDataSniffMin = DATASNIFSIZE_MIN;
        }
        
        if (pwzUrl)
        {
            delete [] _pwzUrl;
            _pwzUrl = OLESTRDuplicate(pwzUrl);
        }

    }
    TransAssert((_pProt && _pProtSnk));

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     COInetProt::QueryService
//
//  Synopsis:
//
//  Arguments:  [rsid] --
//              [riid] --
//              [ppvObj] --
//
//  Returns:
//
//  History:    11-07-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT IUnknown_QueryService(IUnknown* punk, REFGUID rsid, REFIID riid, void ** ppvObj);

HRESULT COInetProt::QueryService(REFGUID rsid, REFIID riid, void ** ppvObj)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "COInetProt::IServiceProvider::QueryService",
                "this=%#x, %#x, %#x, %#x",
                this, &rsid, &riid, ppvObj
                ));
                
    PerfDbgLog(tagCTransaction, this, "+COInetProt::QueryService");
    HRESULT     hr = NOERROR;
    VDATETHIS(this);
    TransAssert((ppvObj));

    if (_pSrvPrv)
    {
        hr = _pSrvPrv->QueryService(rsid,riid, ppvObj);
    }
    else
    {
        hr = IUnknown_QueryService(_pProtSnk, rsid, riid, ppvObj);
    }

    TransAssert(( ((hr == E_NOINTERFACE) && !*ppvObj)  || ((hr == NOERROR) && *ppvObj) ));

    PerfDbgLog1(tagCTransaction, this, "-COInetProt::QueryService (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

STDMETHODIMP COInetProt::SetPriority(LONG nPriority)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "COInetProt::IInternetPriority::SetPriority",
                "this=%#x, %#x",
                this, nPriority
                ));
                
    PerfDbgLog1(tagCTransaction, this, "+COInetProt::SetPriority (%ld)", nPriority);

    HRESULT hr = S_OK;

    _nPriority = nPriority;

    PerfDbgLog1(tagCTransaction, this, "-COInetProt::SetPriority (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

STDMETHODIMP COInetProt::GetPriority(LONG * pnPriority)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "COInetProt::IInternetPriority::GetPriority",
                "this=%#x, %#x",
                this, pnPriority
                ));
                
    PerfDbgLog(tagCTransaction, this, "+COInetProt::GetPriority");

    HRESULT hr;

    if (!pnPriority)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        *pnPriority = _nPriority;
        hr = S_OK;
    }

    PerfDbgLog1(tagCTransaction, this, "-COInetProt::GetPriority (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\trans\oinet.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       oinet.cxx
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    11-07-1996   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------
#include <trans.h>
#include "oinet.hxx"
#ifndef unix
#include "..\mon\urlcf.hxx"
#else
#include "../mon/urlcf.hxx"
#endif /* unix */
#define BREAK_ONERROR(hrBreak) if (FAILED(hrBreak)) { break; }

PerfDbgTag(tagCOInetSession, "Urlmon", "Log COInetSession", DEB_SESSION);

COInetSession *g_pCOInetSession = 0;
CMutexSem      g_mxsOInet;       // single access to media holder

#define SESSIONOPTIONF_SHORTCIRCUIT_KNOWN_PROTOCOLS      (0x00000040)
BYTE           g_bShortcircuitKnownProtocols = TRUE;

typedef enum _tagOISM_FLAG
{
    OISM_NOADDREF = 0x00000001
} OISM_FLAGS;

extern BOOL  g_bCanUseSimpleBinding;
extern LONG g_cTransLevelHandler;


//+---------------------------------------------------------------------------
//
//  Function:   CoInternetGetSession
//
//  Synopsis:   exported API
//
//  Arguments:  [ppOInetSession] --
//              [dwReserved] --
//
//  Returns:
//
//  History:    4-14-1997   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI CoInternetGetSession(DWORD dwMode, IOInetSession **ppOInetSession, DWORD dwReserved)
{
    DEBUG_ENTER_API((DBG_TRANS,
                    Hresult,
                    "CoInternetGetSession",
                    "%#x, %#x, %#x",
                    dwMode, ppOInetSession, dwReserved
                    ));
                
    HRESULT hr = NOERROR;
    PerfDbgLog(tagCOInetSession, NULL, "+CoInternetGetSession");

    COInetSession *pCOInetSession = 0;

    hr = GetCOInetSession(dwMode, &pCOInetSession, dwReserved);
    if (hr == NOERROR )
    {
        *ppOInetSession = (IOInetSession *)pCOInetSession;
    }

    PerfDbgLog1(tagCOInetSession, NULL, "-CoInternetGetSession (hr:%lx)", hr);

    DEBUG_LEAVE_API(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   DeleteOInetSession
//
//  Synopsis:   deletes the global OInetSession
//              called by tls.cxx
//
//  Arguments:  [dwReserved] --
//
//  Returns:
//
//  History:    1-22-1997   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT DeleteOInetSession(DWORD dwReserved)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "DeleteOInetSession",
                "%#x",
                dwReserved
                ));
                    
    PerfDbgLog(tagCOInetSession, NULL, "+DeleteOInetSession");
    HRESULT hr = NOERROR;
    CLock lck(g_mxsOInet);

    if (g_pCOInetSession)
    {
        delete g_pCOInetSession;
        g_pCOInetSession = 0;
    }

    PerfDbgLog1(tagCOInetSession, NULL, "-DeleteOInetSession (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   GetOInetSession
//
//  Synopsis:
//
//  Arguments:  [dwMode] --
//              [ppOInetSession] --
//              [dwReserved] --
//
//  Returns:
//
//  History:    11-07-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT GetCOInetSession(DWORD dwMode, COInetSession **ppOInetSession, DWORD dwReserved)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "GetCOInetSession",
                "%#x, %#x, %#x",
                dwMode, ppOInetSession, dwReserved
                ));
                
    HRESULT hr = NOERROR;
    PerfDbgLog(tagCOInetSession, NULL, "+GetOInetSession");
    CLock lck(g_mxsOInet);

    TransAssert(( (ppOInetSession != NULL) && (dwReserved == 0) && "Invalid argument"));

    if (ppOInetSession && !dwReserved)
    {
        if (g_pCOInetSession == 0)
        {
            hr = COInetSession::Create(0, &g_pCOInetSession);
        }

        if (g_pCOInetSession)
        {
            if (!(dwMode & OISM_NOADDREF))
            {
                g_pCOInetSession->AddRef();
            }

            *ppOInetSession = g_pCOInetSession;
        }
        else
        {
            hr =  E_OUTOFMEMORY;
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

    PerfDbgLog1(tagCOInetSession, NULL, "-GetOInetSession (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     COInetSession::Create
//
//  Synopsis:
//
//  Arguments:  [dwMode] --
//              [ppCOInetSession] --
//
//  Returns:
//
//  History:    11-15-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT COInetSession::Create(DWORD dwMode, COInetSession **ppCOInetSession)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "COInetSession::Create",
                "%#x, %#x",
                dwMode, ppCOInetSession
                ));
                
    PerfDbgLog(tagCOInetSession, NULL, "+GetOInetSession::Create");
    HRESULT hr = NOERROR;

    COInetSession *pSes = 0;

    TransAssert(( (ppCOInetSession != NULL) && (dwMode == 0) && "Invalid argument"));

    if (ppCOInetSession)
    {
        pSes = new COInetSession();

        if (pSes)
        {
            *ppCOInetSession = pSes;
        }
        else
        {
            hr =  E_OUTOFMEMORY;
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

    PerfDbgLog1(tagCOInetSession, NULL, "-GetOInetSession::Create (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     COInetSession::QueryInterface
//
//  Synopsis:
//
//  Arguments:  [riid] --
//              [ppvObj] --
//
//  Returns:
//
//  History:    1-27-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP COInetSession::QueryInterface(REFIID riid, void **ppvObj)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "COInetSession::IUnknown::QueryInterface",
                "this=%#x, %#x, %#x",
                this, &riid, ppvObj
                ));
                
    PerfDbgLog(tagCOInetSession, this, "+COInetSession::QueryInterface");
    VDATEPTROUT(ppvObj, void *);
    VDATETHIS(this);
    HRESULT hr = NOERROR;

    *ppvObj = NULL;
    if ((riid == IID_IUnknown) || (riid == IID_IOInetSession) )
    {
        *ppvObj = this;
        AddRef();
    }
    else
    {
        hr = E_NOINTERFACE;
    }

    PerfDbgLog1(tagCOInetSession, this, "-COInetSession::QueryInterface (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   COInetSession::AddRef
//
//  Synopsis:
//
//  Arguments:  [ULONG] --
//
//  Returns:
//
//  History:    1-27-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) COInetSession::AddRef(void)
{
    DEBUG_ENTER((DBG_TRANS,
                Dword,
                "COInetSession::IUnknown::AddRef",
                "this=%#x",
                this
                ));
                
    LONG lRet = ++_CRefs;
    PerfDbgLog1(tagCOInetSession, this, "COInetSession::AddRef (cRefs:%ld)", lRet);

    DEBUG_LEAVE(lRet);
    return lRet;
}

//+---------------------------------------------------------------------------
//
//  Function:   COInetSession::Release
//
//  Synopsis:
//
//  Arguments:  [ULONG] --
//
//  Returns:
//
//  History:    1-27-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) COInetSession::Release(void)
{
    DEBUG_ENTER((DBG_TRANS,
                Dword,
                "COInetSession::IUnknown::Release",
                "this=%#x",
                this
                ));
                
    LONG lRet = --_CRefs;

    if (_CRefs == 0)
    {
        // this is global
        //delete this;
    }

    PerfDbgLog1(tagCOInetSession, this, "COInetSession::Release (cRefs:%ld)", lRet);

    DEBUG_LEAVE(lRet);
    return lRet;
}

//+---------------------------------------------------------------------------
//
//  Method:     COInetSession::RegisterNameSpace
//
//  Synopsis:
//
//  Arguments:  [pUnk] --
//              [ULONG] --
//              [cProtocols] --
//
//  Returns:
//
//  History:    11-07-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP COInetSession::RegisterNameSpace(IClassFactory *pCF, REFCLSID rclsid, LPCWSTR pszProtocol,
                                               ULONG  cPatterns, const LPCWSTR *ppwzPatterns, DWORD dwReserved)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "COInetSession::IInternetSession::RegisterNameSpace",
                "this=%#x, %#x, %#x, %.80wq, %#x, %#x, %#x",
                this, pCF, &rclsid, pszProtocol, cPatterns, ppwzPatterns, dwReserved
                ));
                
    PerfDbgLog(tagCOInetSession, this, "+COInetSession::RegisterNameSpace");
    HRESULT hr = E_NOTIMPL;

    hr = _CProtMgrNameSpace.Register(pCF,rclsid, pszProtocol);
    if( hr == NOERROR && 
        (DLD_PROTOCOL_NONE != IsKnownProtocol(pszProtocol) ) )
    {
        UpdateTransLevelHandlerCount(TRUE);
    }

    PerfDbgLog1(tagCOInetSession, this, "-COInetSession::RegisterNameSpace (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     COInetSession::UnregisterNameSpace
//
//  Synopsis:
//
//  Arguments:  [pUnk] --
//
//  Returns:
//
//  History:    11-07-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP COInetSession::UnregisterNameSpace(IClassFactory *pCF, LPCWSTR pszProtocol)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "COInetSession::IInternetSession::UnregisterNameSpace",
                "this=%#x, %#x, %.80wq",
                this, pCF, pszProtocol
                ));
                
    PerfDbgLog(tagCOInetSession, this, "+COInetSession::UnregisterNameSpace");
    HRESULT hr = E_NOTIMPL;

    hr = _CProtMgrNameSpace.Unregister(pCF, pszProtocol);
    if( hr == NOERROR &&
        (DLD_PROTOCOL_NONE != IsKnownProtocol(pszProtocol) ) )
    {
        UpdateTransLevelHandlerCount(FALSE);
    }

    PerfDbgLog1(tagCOInetSession, this, "-COInetSession::UnregisterNameSpace (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     COInetSession::RegisterMimeFilter
//
//  Synopsis:
//
//  Arguments:  [const] --
//              [ULONG] --
//              [ctypes] --
//
//  Returns:
//
//  History:    11-07-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP COInetSession::RegisterMimeFilter(IClassFactory *pCF, REFCLSID rclsid, LPCWSTR pwzType)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "COInetSession::IInternetSession::RegisterMimeFilter",
                "this=%#x, %#x, %#x, %.80wq",
                this, pCF, &rclsid, pwzType
                ));
                
    PerfDbgLog(tagCOInetSession, this, "+COInetSession::RegisterMimeFilter");
    HRESULT hr;

    hr = _CProtMgrMimeFilter.Register(pCF,rclsid, pwzType);
    if( hr == NOERROR )
    {
        UpdateTransLevelHandlerCount(TRUE);
    }

    PerfDbgLog1(tagCOInetSession, this, "-COInetSession::RegisterMimeFilter (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     COInetSession::UnregisterMimeFilter
//
//  Synopsis:
//
//  Arguments:  [pUnk] --
//
//  Returns:
//
//  History:    11-07-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP COInetSession::UnregisterMimeFilter(IClassFactory *pCF, LPCWSTR pszType)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "COInetSession::IInternetSession::UnregisterMimeFilter",
                "this=%#x, %#x, %.80wq",
                this, pCF, pszType
                ));
                
    PerfDbgLog(tagCOInetSession, this, "+COInetSession::UnregisterMimeFilter");
    HRESULT hr;

    hr = _CProtMgrMimeFilter.Unregister(pCF, pszType);
    if( hr == NOERROR )
    {
        UpdateTransLevelHandlerCount(FALSE);
    }

    PerfDbgLog1(tagCOInetSession, this, "-COInetSession::UnregisterMimeFilter (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     COInetSession::CreateBinding
//
//  Synopsis:
//
//  Arguments:  [IUnknown] --
//              [REFIID] --
//              [IUnknown] --
//              [IOInetBinding] --
//              [DWORD] --
//              [dwOption] --
//
//  Returns:
//
//  History:    11-07-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP COInetSession::CreateBinding(LPBC pBC, LPCWSTR wzUrl,IUnknown *pUnkOuter,
                                        IUnknown **ppUnk,IOInetProtocol **ppOInetProt, DWORD dwOption)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "COInetSession::IInternetSession::CreateBinding",
                "this=%#x, %#x, %.80wq, %#x, %#x, %#x, %#x",
                this, pBC, wzUrl, pUnkOuter, ppUnk, ppOInetProt, dwOption
                ));
                
    PerfDbgLog(tagCOInetSession, this, "+COInetSession::CreateBinding");
    HRESULT hr = E_NOTIMPL;

    DWORD dwLocation = 0;
    CLSID clsid = CLSID_NULL; 

    // NetDocs specific hack (IEv60 Bug# 25642):
    if(!g_bShortcircuitKnownProtocols && !(dwOption & PI_PREFERDEFAULTHANDLER))
    {
        // QueryInfo with QUERY_CAN_NAVIGATE, if true (or failure), let the default action take place. 
        // If false, add a PI_PREFERDEFAULTHANDLER to dwOption to (preferably) load the internal handler.

        // Having NetDocs implement the IInternetProtocolInfo on the Class Factory instead of 
        // the APP for performance, a CoInternetQueryInfo will work in either case, because 
        // COInetSession::CreateProtocolInfo (conveniently ;-)  ) queries the Class Factory 
        // first for IInternetProtocolInfo.

        DWORD dwCanNavigate = TRUE;
        DWORD dwDummy;

        // Can NetDocs navigate?:
        HRESULT hr = /* CoInternet */ QueryInfo(
                    wzUrl,
                    QUERY_CAN_NAVIGATE,
                    0,
                    (LPVOID)&dwCanNavigate,
                    sizeof(dwCanNavigate),
                    &dwDummy,
                    0);

        if ((hr == S_OK) && (!dwCanNavigate))
            dwOption |= PI_PREFERDEFAULTHANDLER;
    }

    if (dwOption & PI_PREFERDEFAULTHANDLER)
    {
        // allow non-IE urlmon clients to load only the default handlers.
        DWORD dwProtID = IsKnownProtocol(wzUrl);
        if (dwProtID)
            hr = CreateFirstProtocol(wzUrl, NULL, NULL, ppOInetProt, &clsid, &dwLocation, BINDF_PREFERDEFAULTHANDLER);

        if (SUCCEEDED(hr))
            goto Exit;

        dwOption &= ~PI_PREFERDEFAULTHANDLER;
        clsid = CLSID_NULL;
    }
    
    if (dwOption & PI_LOADAPPDIRECT)
    {
        hr = CreateFirstProtocol(wzUrl, NULL, NULL, ppOInetProt, &clsid, &dwLocation); 
    }
    else if( pBC || !g_bCanUseSimpleBinding || g_cTransLevelHandler)
    {
        hr = GetTransactionObjects(pBC, wzUrl, pUnkOuter, ppUnk, ppOInetProt, dwOption, 0);
    }
    else
    {
        DWORD dwProtID = 0;
        dwProtID = IsKnownProtocol(wzUrl);
        if( dwProtID  )
        {
            hr = CreateFirstProtocol(wzUrl, NULL, NULL, ppOInetProt, &clsid, &dwLocation); 
        }
        else
        {
            hr = GetTransactionObjects(pBC, wzUrl, pUnkOuter, ppUnk, 
                                       ppOInetProt, dwOption, 0);

        }
    }

    PerfDbgLog1(tagCOInetSession, this, "-COInetSession::CreateBinding (hr:%lx)", hr);

Exit:
    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     COInetSession::SetSessionOption
//
//  Synopsis:
//
//  Arguments:  [LPVOID] --
//              [DWORD] --
//              [DWORD] --
//              [dwReserved] --
//
//  Returns:
//
//  History:    11-07-1996   JohannP (Johann Posch)   Created
//              02-09-2001   GaneshS (S. Ganesh)      NetDocs Hack
//                               This hack allows NetDocs to (re)set an option to prevent 
//                               short-circuit of (their overridden) known protocols, in 
//                               CoInternetQueryInfo.
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP COInetSession::SetSessionOption(DWORD dwOption,LPVOID pBuffer,DWORD dwBufferLength,DWORD dwReserved)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "COInetSession::IInternetSession::SetSessionOption",
                "this=%#x, %#x, %#x, %#x, %#x",
                this, dwOption, pBuffer, dwBufferLength, dwReserved
                ));
                
    PerfDbgLog(tagCOInetSession, this, "+COInetSession::SetSessionOption");
    HRESULT hr = E_NOTIMPL;

    if(SESSIONOPTIONF_SHORTCIRCUIT_KNOWN_PROTOCOLS == dwOption)
    {
        TransAssert(pBuffer);
        TransAssert(dwBufferLength == 1);
        g_bShortcircuitKnownProtocols = *(BYTE *)pBuffer;
        hr = S_OK;
    }

    PerfDbgLog1(tagCOInetSession, this, "-COInetSession::SetSessionOption (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     COInetSession::GetSessionOption
//
//  Synopsis:
//
//  Arguments:  [LPVOID] --
//              [DWORD] --
//              [DWORD] --
//              [dwReserved] --
//
//  Returns:
//
//  History:    11-07-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP COInetSession::GetSessionOption(DWORD dwOption,LPVOID pBuffer,DWORD *pdwBufferLength,DWORD dwReserved)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "COInetSession::IInternetSession::GetSessionOption",
                "this=%#x, %#x, %#x, %#x, %#x",
                this, dwOption, pBuffer, pdwBufferLength, dwReserved
                ));
                
    PerfDbgLog(tagCOInetSession, this, "+COInetSession::GetSessionOption");
    HRESULT hr = E_NOTIMPL;

    PerfDbgLog1(tagCOInetSession, this, "-COInetSession::GetSessionOption (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     COInetSession::ParseUrl
//
//  Synopsis:
//
//  Arguments:  [pwzUrl] --
//              [ParseAction] --
//              [dwFlags] --
//              [pwzResult] --
//              [cchResult] --
//              [dwReserved] --
//
//  Returns:
//
//  History:    4-13-1997   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP COInetSession::ParseUrl(
    LPCWSTR     pwzUrl,
    PARSEACTION ParseAction,
    DWORD       dwFlags,
    LPWSTR      pwzResult,
    DWORD       cchResult,
    DWORD      *pcchResult,
    DWORD       dwReserved
    )
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "COInetSession::IInternetProtocolInfo::ParseUrl",
                "this=%#x, %.80wq, %#x, %#x, %#x, %#x, %#x, %#x",
                this, pwzUrl, ParseAction, dwFlags, pwzResult, cchResult, pcchResult, dwReserved
                ));
                
    PerfDbgLog(tagCOInetSession, this, "+COInetSession::ParseUrl");
    HRESULT hr;
    IOInetProtocolInfo  *pProtInfo = 0;

    do
    {
        hr = CreateProtocolInfo(pwzUrl, &pProtInfo);
        BREAK_ONERROR(hr);

        hr = pProtInfo->ParseUrl(pwzUrl, ParseAction, dwFlags, pwzResult, cchResult, pcchResult, dwReserved);

        break;
    } while (TRUE);

    if (pProtInfo)
    {
        pProtInfo->Release();
    }

    if (FAILED(hr))
    {
        hr = INET_E_DEFAULT_ACTION;
    }

    PerfDbgLog1(tagCOInetSession, this, "-COInetSession::ParseUrl (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     COInetSession::CombineUrl
//
//  Synopsis:
//
//  Arguments:  [pwzBaseUrl] --
//              [pwzRelativeUrl] --
//              [dwFlags] --
//              [pwzResult] --
//              [cchResult] --
//              [dwReserved] --
//
//  Returns:
//
//  History:    4-13-1997   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP COInetSession::CombineUrl(
    LPCWSTR     pwzBaseUrl,
    LPCWSTR     pwzRelativeUrl,
    DWORD       dwFlags,
    LPWSTR      pwzResult,
    DWORD       cchResult,
    DWORD      *pcchResult,
    DWORD       dwReserved
    )
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "COInetSession::IInternetProtocolInfo::CombineUrl",
                "this=%#x, %.80wq, %.80wq, %#x, %#x, %#x, %#x, %#x",
                this, pwzBaseUrl, pwzRelativeUrl, dwFlags, pwzResult, cchResult, pcchResult, dwReserved
                ));
                
    PerfDbgLog(tagCOInetSession, this, "+COInetSession::CombineUrl");
    HRESULT hr;
    IOInetProtocolInfo  *pProtInfo = 0;

    do
    {
        hr = CreateProtocolInfo(pwzBaseUrl, &pProtInfo);
        BREAK_ONERROR(hr);

        hr = pProtInfo->CombineUrl(pwzBaseUrl, pwzRelativeUrl, dwFlags, pwzResult, cchResult, pcchResult, dwReserved);

        break;
    } while (TRUE);

    if (pProtInfo)
    {
        pProtInfo->Release();
    }

    if (FAILED(hr))
    {
        hr = INET_E_DEFAULT_ACTION;
    }

    PerfDbgLog1(tagCOInetSession, this, "-COInetSession::CombineUrl (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     COInetSession::CompareUrl
//
//  Synopsis:
//
//  Arguments:  [pwzUrl1] --
//              [pwzUrl2] --
//              [dwFlags] --
//
//  Returns:
//
//  History:    4-13-1997   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP COInetSession::CompareUrl(
    LPCWSTR pwzUrl1,
    LPCWSTR pwzUrl2,
    DWORD dwFlags
    )
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "COInetSession::IInternetProtocolInfo::CompareUrl",
                "this=%#x, %.80wq, %.80wq, %#x",
                this, pwzUrl1, pwzUrl2, dwFlags
                ));
                
    PerfDbgLog(tagCOInetSession, this, "+COInetSession::CompareUrl");
    HRESULT hr;
    IOInetProtocolInfo  *pProtInfo = 0;

    do
    {
        hr = CreateProtocolInfo(pwzUrl1, &pProtInfo);
        BREAK_ONERROR(hr);

        hr = pProtInfo->CompareUrl(pwzUrl1, pwzUrl2, dwFlags);

        break;
    } while (TRUE);

    if (pProtInfo)
    {
        pProtInfo->Release();
    }

    if (FAILED(hr))
    {
        hr = INET_E_DEFAULT_ACTION;
    }

    PerfDbgLog1(tagCOInetSession, this, "-COInetSession::CompareUrl (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     COInetSession::QueryInfo
//
//  Synopsis:
//
//  Arguments:  [pwzUrl] --
//              [dwOption] --
//              [pBuffer] --
//              [cbBuffer] --
//              [pcbBuf] --
//              [dwReserved] --
//
//  Returns:
//
//  History:    4-14-1997   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP COInetSession::QueryInfo(
    LPCWSTR pwzUrl,
    QUERYOPTION   QueryOption,
    DWORD         dwQueryFlags,
    LPVOID pBuffer,
    DWORD   cbBuffer,
    DWORD  *pcbBuf,
    DWORD   dwReserved
    )
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "COInetSession::IInternetProtocolInfo::QueryInfo",
                "this=%#x, %.80wq, %#x, %#x, %#x, %#x, %#x, %#x",
                this, pwzUrl, QueryOption, dwQueryFlags, pBuffer, cbBuffer, pcbBuf, dwReserved
                ));
                
    PerfDbgLog(tagCOInetSession, this, "+COInetSession::QueryInfo");
    HRESULT hr;
    IOInetProtocolInfo  *pProtInfo = 0;
    CLSID clsid;

    do
    {
        hr = CreateProtocolInfo(pwzUrl, &pProtInfo);
        BREAK_ONERROR(hr);

        hr = pProtInfo->QueryInfo(pwzUrl, QueryOption, dwQueryFlags, pBuffer, cbBuffer, pcbBuf, dwReserved);

        break;
    } while (TRUE);

    if (pProtInfo)
    {
        pProtInfo->Release();
    }

    if (FAILED(hr))
    {
        hr = INET_E_DEFAULT_ACTION;
    }

    PerfDbgLog1(tagCOInetSession, this, "-COInetSession::QueryInfo (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}




// internal methods

//+---------------------------------------------------------------------------
//
//  Method:     COInetSession::FindFirstCF
//
//  Synopsis:
//
//  Arguments:  [pszProt] --
//              [ppUnk] --
//              [pclsid] --
//
//  Returns:
//
//  History:    11-15-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP COInetSession::FindFirstCF(LPCWSTR pszProt, IClassFactory **ppUnk, CLSID *pclsid, 
                                        DWORD* pdwLocation, DWORD dwOpt)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "COInetSession::FindFirstCF",
                "this=%#x, %.80wq, %#x, %#x, %#x, %#x",
                this, pszProt, ppUnk, pclsid, pdwLocation, dwOpt
                ));
                
    PerfDbgLog(tagCOInetSession, this, "+COInetSession::FindFirstCF");
    HRESULT hr = INET_E_UNKNOWN_PROTOCOL;

    TransAssert(pdwLocation);
    if( dwOpt )
    {
        *ppUnk = NULL;

        // different loading mechanism
        DWORD dwEl = 1;
        DWORD dwFlags = 0;
        HRESULT hrReg = _CProtMgr.LookupClsIDFromReg(
                    pszProt, pclsid, &dwEl, &dwFlags, dwOpt);

        if( hrReg == NOERROR )
        {
            hrReg = CoGetClassObject(
                                    *pclsid, 
                                    CLSCTX_INPROC_SERVER,
                                    NULL,
                                    IID_IClassFactory, 
                                    (void**)ppUnk );

            if (hrReg == NOERROR)
            {
                hr = NOERROR;
            }
        }

        goto End;     
    }

    *pdwLocation = LOC_NAMESPACE;

    switch (*pdwLocation)
    {
    default:
        TransAssert((FALSE));
        break;
    case LOC_NAMESPACE:
        hr = _CProtMgrNameSpace.FindFirstCF(pszProt, ppUnk, pclsid);
        if (hr == NOERROR)
        {
            break;
        }
        *pdwLocation = LOC_INTERNAL;

    case LOC_INTERNAL:
        hr = FindInternalCF(pszProt, ppUnk, pclsid, pdwLocation);
        if (hr == NOERROR)
        {
            break;
        }
        *pdwLocation = LOC_EXTERNAL;

    case LOC_EXTERNAL:
        hr = _CProtMgr.FindFirstCF(pszProt, ppUnk, pclsid);
        break;
    }

End:

    PerfDbgLog1(tagCOInetSession, this, "-COInetSession::FindFirstCF (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     COInetSession::FindNextCF
//
//  Synopsis:
//
//  Arguments:  [pszProt] --
//              [ppUnk] --
//              [pclsid] --
//
//  Returns:
//
//  History:    11-15-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP COInetSession::FindNextCF(LPCWSTR pszProt, IClassFactory **ppUnk, CLSID *pclsid, DWORD* pdwLocation)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "COInetSession::FindNextCF",
                "this=%#x, %.80wq, %#x, %#x, %#x",
                this, pszProt, ppUnk, pclsid, pdwLocation
                ));
                
    PerfDbgLog(tagCOInetSession, this, "+COInetSession::FindNextCF");
    HRESULT hr = INET_E_UNKNOWN_PROTOCOL;

    TransAssert(pdwLocation);
    switch (*pdwLocation)
    {
    default:
        TransAssert((FALSE));
        break;
    case LOC_NAMESPACE:
        hr = _CProtMgrNameSpace.FindNextCF(pszProt, ppUnk, pclsid);
        if (hr == NOERROR)
        {
            break;
        }
        *pdwLocation = LOC_INTERNAL;

    case LOC_INTERNAL:

        hr = FindInternalCF(pszProt, ppUnk, pclsid, pdwLocation);
        if (hr != NOERROR)
        {
            hr = _CProtMgr.FindFirstCF(pszProt, ppUnk, pclsid);
        }
        *pdwLocation = LOC_EXTERNAL;
        break;

    case LOC_EXTERNAL:
        // valid case - just return INET_E_UNKNOWN_PROTOCOL
        break;
    }

    PerfDbgLog1(tagCOInetSession, this, "-COInetSession::FindNextCF (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     COInetSession::FindInternalCF
//
//  Synopsis:
//
//  Arguments:  [pszProt] --
//              [ppUnk] --
//              [pclsid] --
//
//  Returns:
//
//  History:    11-15-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP COInetSession::FindInternalCF(LPCWSTR pszProt, IClassFactory **ppUnk, CLSID *pclsid, DWORD* pdwLocation)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "COInetSession::FindInternalCF",
                "this=%#x, %.80wq, %#x, %#x, %#x",
                this, pszProt, ppUnk, pclsid, pdwLocation
                ));
                
    PerfDbgLog(tagCOInetSession, this, "+COInetSession::FindInternalCF");
    HRESULT hr = INET_E_UNKNOWN_PROTOCOL;

    TransAssert(pdwLocation && (*pdwLocation == LOC_INTERNAL));

    DWORD dwProtoId;

    if ((dwProtoId = IsKnownProtocol(pszProt)) != DLD_PROTOCOL_NONE)
    {

        *pclsid = *GetKnownOInetProtocolClsID(dwProtoId);

        IClassFactory *pCF = NULL;
        if (_ProtMap[dwProtoId].pCF != 0)
        {
            pCF = _ProtMap[dwProtoId].pCF;
        }
        else
        {
            pCF = (IClassFactory *) new CUrlClsFact(*pclsid, dwProtoId);
            if (pCF)
            {
                _ProtMap[dwProtoId].pCF = pCF;
            }
        }
        if (pCF)
        {
            *ppUnk = pCF;
            pCF->AddRef();
            hr = NOERROR;
        }
    }

    PerfDbgLog1(tagCOInetSession, this, "-COInetSession::FindInternalCF (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     COInetSession::CreateFirstProtocol
//
//  Synopsis:
//
//  Arguments:  [pwzUrl] --
//              [pUnkOuter] --
//              [ppUnk] --
//              [ppProt] --
//              [pclsid] --
//
//  Returns:
//
//  History:    11-15-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP COInetSession::CreateFirstProtocol(LPCWSTR pwzUrl, IUnknown *pUnkOuter, IUnknown **ppUnk,  
                                IOInetProtocol **ppProt, CLSID *pclsid, DWORD* pdwLocation, DWORD dwOpt) 
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "COInetSession::CreateFirstProtocol",
                "this=%#x, %.80wq, %#x, %#x, %#x, %#x, %#x, %#x",
                this, pwzUrl, pUnkOuter, ppUnk, ppProt, pclsid, pdwLocation, dwOpt
                ));
                
    PerfDbgLog2(tagCOInetSession, this, "+COInetSession::CreateFirstProtocol (szUrlL:%ws, pUnkOuter:%lx)", pwzUrl, pUnkOuter);
    HRESULT hr = INET_E_UNKNOWN_PROTOCOL;
    IClassFactory *pCF = 0;

    TransAssert((pwzUrl && ppProt && pclsid));
    TransAssert (( (pUnkOuter && ppUnk) || (!pUnkOuter && !ppUnk) ));
    TransAssert(pdwLocation);
    
    *pclsid = CLSID_NULL;

    // check if protocol part
    WCHAR  wzProt[ULPROTOCOLLEN];
    wcsncpy(wzProt, pwzUrl, ULPROTOCOLLEN);
    wzProt[ULPROTOCOLLEN-1] = 0;

    LPWSTR pwzProt = wcschr(wzProt, ':');
    do 
    {
        if (!pwzProt)
        {
            break;
        }
        *pwzProt = 0;

        if (dwOpt & BINDF_PREFERDEFAULTHANDLER)
        {
            DWORD tempLocation = *pdwLocation;
            *pdwLocation = LOC_INTERNAL;
            hr = FindInternalCF(wzProt, &pCF, pclsid, pdwLocation);
            if (NOERROR != hr)
            {
                *pdwLocation = tempLocation;
                dwOpt &= ~BINDF_PREFERDEFAULTHANDLER;
                hr = FindFirstCF(wzProt, &pCF, pclsid, pdwLocation, dwOpt);
            }
        }
        else
            hr = FindFirstCF(wzProt, &pCF, pclsid, pdwLocation, dwOpt);
                
        if (NOERROR == hr)
        {
            TransAssert((pCF));

            if (pUnkOuter)
            {
                TransAssert((ppUnk));
                hr = pCF->CreateInstance(pUnkOuter, IID_IUnknown, (void **)ppUnk);

                if (hr == NOERROR)
                {
                    TransAssert((*ppUnk));
                    hr = (*ppUnk)->QueryInterface(IID_IOInetProtocol, (void **) ppProt);
                }
            }
            // create an instance without aggregation
            if (!pUnkOuter || (hr == CLASS_E_NOAGGREGATION))
            {
                if( dwOpt == 1)
                {
                    hr = pCF->CreateInstance(NULL, IID_IOInetProtocolRoot, (void **)ppProt);
                }
                else
                {
                    hr = pCF->CreateInstance(NULL, IID_IOInetProtocol, (void **)ppProt);
                }
            }

            pCF->Release();
        }
        else
        {
            // look up the registry
            hr = MK_E_SYNTAX;
        }
        break;
    }
    while (TRUE);

    if (hr != NOERROR)
    {
        *ppProt = 0;
    }

    TransAssert((   (hr == NOERROR && *pclsid != CLSID_NULL)
                 || (hr != NOERROR) ));

    PerfDbgLog1(tagCOInetSession, this, "-COInetSession::CreateFirstProtocol(hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     COInetSession::CreateNextProtocol
//
//  Synopsis:
//
//  Arguments:  [pwzUrl] --
//              [pUnkOuter] --
//              [ppUnk] --
//              [ppProt] --
//              [pclsid] --
//
//  Returns:
//
//  History:    11-15-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP COInetSession::CreateNextProtocol(LPCWSTR pwzUrl, IUnknown *pUnkOuter, IUnknown **ppUnk,  
                                            IOInetProtocol **ppProt, CLSID *pclsid, DWORD* pdwLocation)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "COInetSession::CreateNextProtocol",
                "this=%#x, %.80wq, %#x, %#x, %#x, %#x, %#x",
                this, pwzUrl, pUnkOuter, ppUnk, ppProt, pclsid, pdwLocation
                ));
                
    PerfDbgLog2(tagCOInetSession, this, "+COInetSession::CreateNextProtocol (szUrlL:%ws, pUnkOuter:%lx)", pwzUrl?pwzUrl:L"", pUnkOuter);
    HRESULT hr = INET_E_UNKNOWN_PROTOCOL;

    IClassFactory *pCF = 0;

    TransAssert((pwzUrl && ppProt && pclsid));
    TransAssert (( (pUnkOuter && ppUnk) || (!pUnkOuter && !ppUnk) ));
    TransAssert(pdwLocation);
    
    *pclsid = CLSID_NULL;

    if ( (hr = FindNextCF(pwzUrl, &pCF, pclsid, pdwLocation)) == NOERROR )
    {
        TransAssert((pCF));

        if (pUnkOuter)
        {
            TransAssert((ppUnk));
            hr = pCF->CreateInstance(pUnkOuter, IID_IUnknown, (void **)ppUnk);

            if (hr == NOERROR)
            {
                TransAssert((*ppUnk));
                hr = (*ppUnk)->QueryInterface(IID_IOInetProtocol, (void **) ppProt);
            }
        }
        // create an instance without aggregation
        if (!pUnkOuter || (hr == CLASS_E_NOAGGREGATION))
        {
            hr = pCF->CreateInstance(NULL, IID_IOInetProtocol, (void **)ppProt);
        }

        pCF->Release();
    }
    else
    {
        // look up the registry
        hr = MK_E_SYNTAX;
    }

    if (hr != NOERROR)
    {
        *ppProt = 0;
    }

    TransAssert((   (hr == NOERROR && *pclsid != CLSID_NULL)
                 || (hr != NOERROR) ));

    PerfDbgLog1(tagCOInetSession, this, "-COInetSession::CreateNextProtocol(hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     COInetSession::CreateHandler
//
//  Synopsis:
//
//  Arguments:  [pwzUrl] --
//              [pUnkOuter] --
//              [ppUnk] --
//              [ppProt] --
//              [pclsid] --
//
//  Returns:
//
//  History:    11-15-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP COInetSession::CreateHandler(LPCWSTR pwzUrl, IUnknown *pUnkOuter, IUnknown **ppUnk,  
                                        IOInetProtocol **ppProt, CLSID *pclsid)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "COInetSession::CreateHandler",
                "this=%#x, %.80wq, %#x, %#x, %#x, %#x",
                this, pwzUrl, pUnkOuter, ppUnk, ppProt, pclsid
                ));
                
    PerfDbgLog2(tagCOInetSession, this, "+COInetSession::CreateHandler (szUrlL:%ws, pUnkOuter:%lx)", pwzUrl?pwzUrl:L"", pUnkOuter);
    HRESULT hr = INET_E_UNKNOWN_PROTOCOL;
    IClassFactory *pCF = 0;

    TransAssert((pwzUrl && ppProt && pclsid));
    TransAssert (( (pUnkOuter && ppUnk) || (!pUnkOuter && !ppUnk) ));

    *pclsid = CLSID_NULL;

    if ( (hr = _CProtMgrMimeFilter.FindFirstCF(pwzUrl, &pCF, pclsid)) == NOERROR )
    {
        TransAssert((pCF));

        if (pUnkOuter)
        {
            hr = pCF->CreateInstance(pUnkOuter, IID_IUnknown, (void **)ppUnk);

            if (hr == NOERROR)
            {
                TransAssert((*ppUnk));
                hr = (*ppUnk)->QueryInterface(IID_IOInetProtocol, (void **) ppProt);
            }
        }
        // create an instance without aggregation
        if (!pUnkOuter || (hr == CLASS_E_NOAGGREGATION))
        {
            hr = pCF->CreateInstance(NULL, IID_IOInetProtocol, (void **)ppProt);
        }

        pCF->Release();
    }
    else
    {
        // look up the registry
        hr = MK_E_SYNTAX;
    }

    TransAssert((   (hr == NOERROR && *pclsid != CLSID_NULL)
                 || (hr != NOERROR) ));

    PerfDbgLog1(tagCOInetSession, this, "-COInetSession::CreateHandler(hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     COInetSession::FindOInetProtocolClsID
//
//  Synopsis:
//
//  Arguments:  [pwzUrl] --
//              [pclsid] --
//
//  Returns:
//
//  History:    11-20-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP COInetSession::FindOInetProtocolClsID(LPCWSTR pwzUrl, CLSID *pclsid)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "COInetSession::FindOInetProtocolClsID",
                "this=%#x, %.80wq, %#x",
                this, pwzUrl, pclsid
                ));
                
    PerfDbgLog1(tagCOInetSession, this, "+COInetSession::FindOInetProtocolClsID (pwzUrl:%ws)", pwzUrl?pwzUrl:L"");
    HRESULT hr = INET_E_UNKNOWN_PROTOCOL;

    DWORD dwProtId = IsKnownProtocol(pwzUrl);

    DWORD dwLocation = 0;
    
    if (dwProtId != DLD_PROTOCOL_NONE)
    {
        *pclsid = *GetKnownOInetProtocolClsID(dwProtId);
        hr = NOERROR;
    }
    else
    {
        // try to find the first protocol
        {
            IClassFactory *pCF = 0;
            // check if protocol part
            WCHAR  wzProt[ULPROTOCOLLEN];
            wcsncpy(wzProt, pwzUrl, ULPROTOCOLLEN);
            wzProt[ULPROTOCOLLEN-1] = 0;

            LPWSTR pwzProt = wcschr(wzProt, ':');
            if (pwzProt)
            {
                *pwzProt = 0;
                hr = FindFirstCF(wzProt, &pCF, pclsid, &dwLocation);
            }
            
            if (pCF)
            {
                pCF->Release();
            }
        }
    
        // lookup the registry
        if (hr != NOERROR)
        {
            hr = _CProtMgr.LookupClsIDFromReg(pwzUrl, pclsid);
        }
    }

    PerfDbgLog1(tagCOInetSession, this, "-COInetSession::FindOInetProtocolClsID(hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   IsOInetProtocol
//
//  Synopsis:
//
//  Arguments:  [pwzUrl] --
//
//  Returns:
//
//  History:    11-11-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL IsOInetProtocol(IBindCtx *pbc, LPCWSTR pwzUrl)
{
    DEBUG_ENTER((DBG_TRANS,
                Bool,
                "IsOInetProtocol",
                "%#x, %.80wq",
                pbc, pwzUrl
                ));
                
    PerfDbgLog1(tagCOInetSession, NULL, "+IOInetProtocol (pwzUrl:%ws)", pwzUrl?pwzUrl:L"");
    BOOL fRet = FALSE;
    CLSID clsid;
    COInetSession *pCOInetSession = 0;
    HRESULT hr;

    // check if a BSC is registerted if not register our own one - for Office!
    IUnknown *pUnk = NULL;
    hr = GetObjectParam(pbc, REG_BSCB_HOLDER, IID_IBindStatusCallback, (IUnknown**)&pUnk);
    if (SUCCEEDED(hr))
    {
        TransAssert((pUnk));
        IServiceProvider *pServiceProv = 0;
        hr = pUnk->QueryInterface(IID_IServiceProvider,(void **) &pServiceProv);
        if (SUCCEEDED(hr))
        {
            TransAssert((pServiceProv));

            IOInetProtocol *pIOInetProt = 0;
            hr = pServiceProv->QueryService(IID_IOInetProtocol, IID_IOInetProtocol, (void **) &pIOInetProt);
            if (SUCCEEDED(hr) && pIOInetProt)
            {
                // always check for a valid out pointer - some service provider return
                // S_OK and null for the out parameter

                pIOInetProt->Release();
                fRet = TRUE;
            }
            pServiceProv->Release();
        }
        pUnk->Release();
    }

    if (   (fRet == FALSE)
        && ((GetCOInetSession(0,&pCOInetSession,0)) == NOERROR))
    {
        if (pCOInetSession->FindOInetProtocolClsID(pwzUrl, &clsid) == NOERROR)
        {
            fRet = TRUE;
        }

        pCOInetSession->Release();
    }

    PerfDbgLog1(tagCOInetSession, NULL, "-IsOInetProtocol (fRet:%ld)", fRet);

    DEBUG_LEAVE(fRet);
    return fRet;
}

//+---------------------------------------------------------------------------
//
//  Method:     COInetSession::CreateProtocolInfo
//
//  Synopsis:
//
//  Arguments:  [pwzUrl] --
//              [ppProtInfo] --
//
//  Returns:
//
//  History:    04-20-1997   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP COInetSession::CreateProtocolInfo(LPCWSTR pwzUrl, IOInetProtocolInfo **ppProtInfo)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "COInetSession::CreateProtocolInfo",
                "this=%#x, %.80wq, %#x",
                this, pwzUrl, ppProtInfo
                ));
                
    PerfDbgLog1(tagCOInetSession, this, "+COInetSession::CreateProtocolInfo (szUrlL:%ws)", pwzUrl);
    HRESULT hr = INET_E_UNKNOWN_PROTOCOL;
    IClassFactory *pCF = 0;
    CLSID clsid;

    TransAssert((pwzUrl && ppProtInfo));

    DWORD dwLocation = 0;
    
    // check if protocol part
    WCHAR  wzProt[ULPROTOCOLLEN];
    wcsncpy(wzProt, pwzUrl, ULPROTOCOLLEN);
    wzProt[ULPROTOCOLLEN-1] = 0;

    LPWSTR pwzProt = wcschr(wzProt, ':');

    do
    {
        if (!pwzProt)
        {
            break;
        }

        *pwzProt = 0;

        if ( (hr = FindFirstCF(wzProt, &pCF, &clsid, &dwLocation)) == NOERROR )
        {
            TransAssert((pCF));

            hr = pCF->QueryInterface(IID_IOInetProtocolInfo, (void **)ppProtInfo);

            if (hr != NOERROR)
            {
                hr = pCF->CreateInstance(NULL, IID_IOInetProtocolInfo, (void **)ppProtInfo);
            }

            pCF->Release();
        }
        else
        {
            // look up the registry
            hr = MK_E_SYNTAX;
        }

        if (hr != NOERROR)
        {
            *ppProtInfo = 0;
        }
        break;
    } while (TRUE);

    TransAssert((   (hr == NOERROR && clsid != CLSID_NULL)
                 || (hr != NOERROR) ));

    PerfDbgLog1(tagCOInetSession, this, "-COInetSession::CreateProtocolInfo(hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     COInetSession::CreateSecurityMgr
//
//  Synopsis:
//
//  Arguments:  [pwzUrl] --
//              [ppSecMgr] --
//
//  Returns:
//
//  History:    4-28-1997   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP COInetSession::CreateSecurityMgr(LPCWSTR pwzUrl, IInternetSecurityManager **ppSecMgr)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "COInetSession::CreateSecurityMgr",
                "this=%#x, %.80wq, %#x",
                this, pwzUrl, ppSecMgr
                ));
                
    PerfDbgLog1(tagCOInetSession, this, "+COInetSession::CreateSecurityMgr (szUrlL:%ws)", pwzUrl);
    HRESULT hr = INET_E_UNKNOWN_PROTOCOL;
    IClassFactory *pCF = 0;
    CLSID clsid;

    TransAssert((pwzUrl && ppSecMgr));

    DWORD dwLocation = 0;
    // check if protocol part
    WCHAR  wzProt[ULPROTOCOLLEN];
    wcsncpy(wzProt, pwzUrl, ULPROTOCOLLEN);
    wzProt[ULPROTOCOLLEN-1] = 0;

    LPWSTR pwzProt = wcschr(wzProt, ':');

    do
    {
        if (!pwzProt)
        {
            break;
        }

        *pwzProt = 0;

        if ( (hr = FindFirstCF(wzProt, &pCF, &clsid, &dwLocation)) == NOERROR )
        {
            TransAssert((pCF));

            hr = pCF->CreateInstance(NULL, IID_IInternetSecurityManager, (void **)ppSecMgr);

            pCF->Release();
        }
        else
        {
            // look up the registry
            hr = MK_E_SYNTAX;
        }

        if (hr != NOERROR)
        {
            *ppSecMgr = 0;
        }
        break;
    } while (TRUE);

    TransAssert((   (hr == NOERROR && clsid != CLSID_NULL)
                 || (hr != NOERROR) ));

    PerfDbgLog1(tagCOInetSession, this, "-COInetSession::CreateSecurityMgr(hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

BOOL CanUseSimpleBinding()
{
    DEBUG_ENTER((DBG_TRANS,
                Bool,
                "CanUseSimpleBinding",
                NULL
                ));
                
    HKEY hNSRoot;

    if( RegOpenKey(HKEY_CLASSES_ROOT, SZNAMESPACEROOT, &hNSRoot) 
            == ERROR_SUCCESS)
    {   
        DWORD dwIndex = 0;
        char szName[256];
        LONG ret = ERROR_SUCCESS;
        while(1) 
        {
            szName[0] = '\0';
        
            ret = RegEnumKey(hNSRoot, dwIndex, szName, 256); 
            if( ret == ERROR_SUCCESS )
            {
                if(    !StrCmpNI(szName, "http",    strlen("http")    )
                    || !StrCmpNI(szName, "ftp",     strlen("ftp")     )
                    || !StrCmpNI(szName, "gopher",  strlen("gopher")  )
                    || !StrCmpNI(szName, "https",   strlen("https")   )
                    || !StrCmpNI(szName, "file",    strlen("file")    )
                   )
                {
                    RegCloseKey(hNSRoot);

                    DEBUG_LEAVE(FALSE);
                    return FALSE;
                }

                dwIndex ++;
            }
            else
            {
                RegCloseKey(hNSRoot);

                DEBUG_LEAVE(TRUE);
                return TRUE;
            }
        }
    } 

    DEBUG_LEAVE(TRUE);
    return TRUE;
}


VOID
COInetSession::UpdateTransLevelHandlerCount(BOOL bAttach)
{
    DEBUG_ENTER((DBG_TRANS,
                None,
                "COInetSession::UpdateTransLevelHandlerCount",
                "this=%#x, %B",
                this, bAttach
                ));
                
    CLock lck(g_mxsOInet);
    if( bAttach )
    {
        g_cTransLevelHandler++;
    }
    else
    {
        g_cTransLevelHandler--;
        if( g_cTransLevelHandler < 0 )
            g_cTransLevelHandler = 0;
    }

    DEBUG_LEAVE(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\trans\protocol.h ===
// protocl.h
// This file contains templates and externs to things that are protocl specific



BOOL FBeginHttpTransaction(
   LPDLD lpDownload
   );

void TerminateHttpTransaction(
   LPDLD lpDownload
   );


BOOL FBeginFtpTransaction(
   LPDLD lpDownload
   );

void TerminateFtpTransaction(
   LPDLD lpDownload
   );


BOOL FBeginGopherTransaction(
   LPDLD lpDownload
   );

void TerminateGopherTransaction(
   LPDLD lpDownload
   );


BOOL FBeginFileTransaction(
   LPDLD lpDownload
   );

void TerminateFileTransaction(
   LPDLD lpDownload
   );

// BUGBUG couldn't we use the pdld to indicate whether this was restarted
// instead of using additional parameters?
BOOL FPreprocessHttpResponse(LPDLD	pdld, BOOL *lpfRestarted);
BOOL FPreprocessFtpResponse(LPDLD   lpDownload, BOOL *lpfRestarted);

extern char vszHttp[];
extern char vszFtp[];
extern char vszGopher[];
extern char vszFile[];
extern char vszLocal[];
extern char vszHttps[];
extern HINTERNET	vhSession;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\trans\protmgr.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       protmgr.cxx
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------
#include <trans.h>
#include <shlwapip.h>
#include "oinet.hxx"

PerfDbgTag(tagCProtMgr, "Urlmon", "Log CProtMgr", DEB_PROT);

//+---------------------------------------------------------------------------
//
//  Method:     CProtMgr::Register
//
//  Synopsis:
//
//  Arguments:  [LPOLESTR] --
//              [ULONG] --
//              [cProtocols] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CProtMgr::Register(IClassFactory *pCF, REFCLSID rclsid, LPCWSTR pszProtocol,
                                ULONG  cPatterns, const LPCWSTR *ppwzPatterns, DWORD dwReserved)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CProtMgr::Register",
                "this=%#x, %#x, %#x, %.80wq, %#x, %#x, %#x",
                this, pCF, &rclsid, pszProtocol, cPatterns, ppwzPatterns, dwReserved
                ));
                
    PerfDbgLog(tagCProtMgr, this, "+CProtMgr::Register");
    HRESULT hr = NOERROR;

    TransAssert((pCF && pszProtocol));
    CLock lck(_mxs);


    if (pCF && pszProtocol)
    {
        char szStr[ULPROTOCOLLEN];
        W2A(pszProtocol, szStr, ULPROTOCOLLEN);

        ATOM atom = AddAtom(szStr);

        CNodeData *pNodeIns = new CNodeData(atom, pCF, rclsid);

        if (pNodeIns)
        {
            if (_cElements < 0)
            {
                _cElements = 0;
            }
            pNodeIns->_pNextNode = _pNextNode;
            _pNextNode = pNodeIns;
            _cElements++;
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

    PerfDbgLog1(tagCProtMgr, this, "-CProtMgr::Register (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CProtMgr::Unregister
//
//  Synopsis:
//
//  Arguments:  [pUnk] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CProtMgr::Unregister(IClassFactory *pCF, LPCWSTR pszProtocol)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CProtMgr::Unregister",
                "this=%#x, %#x, %.80wq",
                this, pCF, pszProtocol
                ));
                
    PerfDbgLog(tagCProtMgr, this, "+CProtMgr::Unregister");
    HRESULT hr = NOERROR;

    TransAssert((pCF && pszProtocol));
    CLock lck(_mxs);

    if (pCF && pszProtocol)
    {
        char szStr[ULPROTOCOLLEN];
        W2A(pszProtocol, szStr, ULPROTOCOLLEN);
        ATOM atom = AddAtom(szStr);
        CNodeData *pNode = _pNextNode;
        CNodeData *pPrevNode = NULL;

        while (pNode)
        {
            if (pNode->_pCFProt == pCF && pNode->_atom == atom)
            {
                // found the node

                if (pPrevNode)
                {
                    pPrevNode->_pNextNode = pNode->_pNextNode;
                }
                else
                {
                    // remove first node
                    _pNextNode = pNode->_pNextNode;
                    pPrevNode = pNode->_pNextNode;
                }
                _cElements--;
                delete pNode;
                pNode = NULL;
            }
            else
            {
                pPrevNode = pNode;
                pNode = pNode->_pNextNode;
            }

        }

        //no previous node - the first
        if (pPrevNode == NULL)
        {
            _pNextNode = 0;
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

    PerfDbgLog1(tagCProtMgr, this, "-CProtMgr::Unregister (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

DWORD IsKnownHandler(LPCWSTR wzHandler);
CLSID *GetKnownHandlerClsID(DWORD dwID);

//+---------------------------------------------------------------------------
//
//  Method:     CProtMgr::FindFirstCF
//
//  Synopsis:
//
//  Arguments:  [pszProt] --
//              [ppUnk] --
//              [pclsid] --
//
//  Returns:
//
//  History:    11-16-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CProtMgr::FindFirstCF(LPCWSTR pszProt, IClassFactory **ppUnk, CLSID *pclsid)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CProtMgr::FindFirstCF",
                "this=%#x, %.80wq, %#x, %#x",
                this, pszProt, ppUnk, pclsid
                ));
                
    PerfDbgLog(tagCProtMgr, this, "+CProtMgr::FindFirstCF");
    HRESULT hr = INET_E_UNKNOWN_PROTOCOL;
    CNodeData *pNode;
    DWORD dwEl = 1;
    BOOL  fIsKnownHandler = FALSE;
    HRESULT hrGetClsId = NOERROR;

    CLock lck(_mxs);

    _pPosNode = 0;

    if (_cElements < 0)
    {
        _cElements = 0;
    }
    else if (_cElements > 0)
    {
        char szStr[ULPROTOCOLLEN];

        W2A(pszProt, szStr, ULPROTOCOLLEN);

        ATOM atom = FindAtom(szStr);

        if (atom)
        {
            pNode = _pNextNode;

            while (pNode && pNode->_atom != atom)
            {
                pNode = pNode->_pNextNode;
            }
            if (pNode)
            {
                *ppUnk = pNode->_pCFProt;
                if (*ppUnk)
                {
                    pNode->_pCFProt->AddRef();
                    *pclsid = pNode->_clsidProt;
                    hr = NOERROR;
                }
                else
                {
                    hr = INET_E_UNKNOWN_PROTOCOL;
                }
            }
        }
    }


    if( hr != NOERROR)
    {
        DWORD dwID = 0;
        dwID = IsKnownHandler(pszProt);
        if( dwID)
        {
            *pclsid = *GetKnownHandlerClsID(dwID);
            fIsKnownHandler = TRUE;
        }
        else
        {
            hrGetClsId = LookupClsIDFromReg(pszProt, pclsid, &dwEl);
        }
    }

    if (   (hr != NOERROR) && (hrGetClsId == NOERROR) )
    {
        IClassFactory *pCF = 0;
        hr = CoGetClassObject(*pclsid, CLSCTX_INPROC_SERVER,NULL,IID_IClassFactory, (void**)&pCF);
        if (hr == NOERROR)
        {
            *ppUnk = pCF;
            
            if(fIsKnownHandler)
            { 
                char szStr[ULPROTOCOLLEN];

                W2A(pszProt, szStr, ULPROTOCOLLEN);

                *ppUnk = pCF;

                ATOM atom = AddAtom(szStr);
                pNode = new CNodeData(atom, pCF, *pclsid);

                if (pNode)
                {
                    pNode->_pNextNode = _pNextNode;
                    _pNextNode = pNode;
                    _cElements++;
                }
                // no release of CF since it is given out
            }

        }
    }

    PerfDbgLog1(tagCProtMgr, this, "-CProtMgr::FindFirstCF (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CProtMgr::FindNextCF
//
//  Synopsis:
//
//  Arguments:  [pszProt] --
//              [ppUnk] --
//              [pclsid] --
//
//  Returns:
//
//  History:    11-16-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CProtMgr::FindNextCF(LPCWSTR pszProt, IClassFactory **ppUnk, CLSID *pclsid)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CProtMgr::FindNextCF",
                "this=%#x, %.80wq, %#x, %#x",
                this, pszProt, ppUnk, pclsid
                ));
                
    PerfDbgLog(tagCProtMgr, this, "+CProtMgr::FindNextCF");
    HRESULT hr = INET_E_UNKNOWN_PROTOCOL;

    TransAssert((FALSE));

    PerfDbgLog1(tagCProtMgr, this, "-CProtMgr::FindNextCF (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CProtMgr::LookupClsIDFromReg
//
//  Synopsis:
//
//  Arguments:  [pwzProt] --
//              [pclsid] --
//              [pcClsIds] --
//
//  Returns:
//
//  History:    11-20-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CProtMgr::LookupClsIDFromReg(LPCWSTR pwzProt, CLSID *pclsid, DWORD *pcClsIds, DWORD *pdwFlags, DWORD dwOpt)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CProtMgr::LookupClsIDFromReg",
                "this=%#x, %.80wq, %#x, %#x, %#x, %#x",
                this, pwzProt, pclsid, pcClsIds, pdwFlags, dwOpt
                ));
                
    PerfDbgLog1(tagCProtMgr, this, "+CProtMgr::LookupClsIDFromReg (pszProt:%ws)", pwzProt);
    HRESULT hr = INET_E_UNKNOWN_PROTOCOL;

    DWORD dwType;

    TransAssert((pwzProt && pclsid));

    if (pwzProt)
    {
        char pszProt[ULPROTOCOLLEN+1];

        W2A(pwzProt, pszProt, ULPROTOCOLLEN);
        pszProt[ULPROTOCOLLEN] = '\0';

        char szDelimiter = ':';

        LPSTR pszDel = StrChr(pszProt, szDelimiter);

        if (pszDel)
        {
            *pszDel = '\0';
        }

        DWORD dwLen = 256;
        char szProtocolKey[256];
        char szCLSID[256];

        strcpy(szProtocolKey, SZ_SH_PROTOCOLROOT);
        strcat(szProtocolKey, pszProt);

        char pszOptFlag[16];


        if(dwOpt)
        {
            wsprintf(pszOptFlag, "\\0x%08x", dwOpt);
            strcat(szProtocolKey, pszOptFlag); 
        }

        if (SHRegGetUSValue(
                    szProtocolKey, 
                    SZCLASS, 
                    NULL, 
                    (LPBYTE)szCLSID, 
                    &dwLen,
                    FALSE, 
                    NULL, 
                    0) == ERROR_SUCCESS)
        {
            hr = CLSIDFromStringA(szCLSID, pclsid);
            PerfDbgLog2(
                    tagCProtMgr, 
                    this, 
                    "API FOUND LookupProtocolClsIDFromReg(hr:%lx, ClsId:%s)", 
                    hr, 
                    szCLSID);
        }

    }

    PerfDbgLog1(tagCProtMgr, this, "-CProtMgr::LookupClsIDFromReg (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CProtMgrNameSpace::ShouldLookupRegistry
//
//  Synopsis:
//
//  Arguments:  [pszProt] --
//
//  Returns:    S_OK if registry should be looked up, S_FALSE if not. E_* if it encounters an error
//              of some sort. 
//
//  History:    11-16-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CProtMgrNameSpace::ShouldLookupRegistry(LPCWSTR pszProt)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CProtMgrNameSpace::ShouldLookupRegistry",
                "this=%#x, %.80wq",
                this, pszProt
                ));

    PerfDbgLog1(tagCProtMgr, this, "+CProtMgr::ShouldLookupRegistry (pszProt:%ws)", pszProt);
    HRESULT hr = E_FAIL;

    if (pszProt == NULL)
    {
        DEBUG_LEAVE(E_INVALIDARG);
        return E_INVALIDARG;
    }

 
    BOOL bFound = FALSE;
    for (CProtocolData *pCurrent = _pProtList ; pCurrent != NULL; pCurrent = pCurrent->GetNext())
    {
        // Found the protocol.
        if (0 == StrCmpICW(pszProt, pCurrent->GetProtocol()))
        {
            bFound = TRUE;
            break;
        }    
    }

    if (bFound)
    {
        hr = S_FALSE;
    }
    else
    {
        // Append to list.                  
        CProtocolData *pProtNew = new CProtocolData;
        if (pProtNew != NULL)
        {
            if (pProtNew->Init(pszProt, _pProtList))
            {
                _pProtList = pProtNew;
                hr = S_OK;
            }
            else 
            {
                // only way init can fail today is if we are out of memory
                delete pProtNew;
                hr = E_OUTOFMEMORY;
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;   
        }
    }

    PerfDbgLog1(tagCProtMgr, this, "-CProtMgr::ShouldLookupRegistry (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

                                  
//+---------------------------------------------------------------------------
//
//  Method:     CProtMgrNameSpace::FindFirstCF
//
//  Synopsis:
//
//  Arguments:  [pszProt] --
//              [ppUnk] --
//              [pclsid] --
//
//  Returns:
//
//  History:    11-16-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CProtMgrNameSpace::FindFirstCF(LPCWSTR pszProt, IClassFactory **ppUnk, CLSID *pclsid)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CProtMgrNameSpace::FindFirstCF",
                "this=%#x, %.80wq, %#x, %#x",
                this, pszProt, ppUnk, pclsid
                ));
                
    PerfDbgLog1(tagCProtMgr, this, "+CProtMgrNameSpace::FindFirstCF (pszProt:%ws)", pszProt);
    HRESULT hr = INET_E_UNKNOWN_PROTOCOL;

    CLock lck(_mxs);

    _pPosNode = 0;

    //
    // check the registered protocols first
    //
    if (_cElements > 0)
    {
        char szStr[ULPROTOCOLLEN];
        W2A(pszProt, szStr, ULPROTOCOLLEN);
        ATOM atom = FindAtom(szStr);

        if (atom)
        {
            _pPosNode = _pNextNode;

            while (_pPosNode && _pPosNode->_atom != atom)
            {
                _pPosNode = _pPosNode->_pNextNode;
            }
        }

    }
    
    //
    // look up the registry once
    //
    if (   (!_pPosNode)
        && (ShouldLookupRegistry(pszProt) == S_OK))
    {
        // BUG-WORK: 64 plugable namespace are max!
        CLSID rgclsid[64];
        DWORD dwEl = 64;

        if ((hr = LookupClsIDFromReg(pszProt, rgclsid, &dwEl)) == NOERROR)
        {
            char szStr[ULPROTOCOLLEN];

            W2A(pszProt, szStr, ULPROTOCOLLEN);

            ATOM atom = AddAtom(szStr);

            for (DWORD i = 0; i < dwEl; i++)
            {
                CLSID *pclsid = &rgclsid[i];
                CNodeData *pNodeIns = new CNodeData(atom, NULL, *pclsid);

                if (pNodeIns)
                {
                    pNodeIns->_pNextNode = _pNextNode;
                    _pNextNode = pNodeIns;
                    _cElements++;
                }

                if (!_pPosNode)
                {
                    _pPosNode = pNodeIns;
                }
            }

        }
    }
    /*
    else if (_cElements > 0)
    {
        char szStr[ULPROTOCOLLEN];
        W2A(pszProt, szStr, ULPROTOCOLLEN);
        ATOM atom = FindAtom(szStr);

        if (atom)
        {
            _pPosNode = _pNextNode;

            while (_pPosNode && _pPosNode->_atom != atom)
            {
                _pPosNode = _pPosNode->_pNextNode;
            }
        }

    }
    */

    if (_pPosNode)
    {
        *pclsid = _pPosNode->_clsidProt;

        if (_pPosNode->_pCFProt == NULL)
        {
            IClassFactory *pCF = 0;
            hr = CoGetClassObject(*pclsid, CLSCTX_INPROC_SERVER,NULL,IID_IClassFactory, (void**)&pCF);
            if (hr == NOERROR)
            {
                *ppUnk = pCF;//make sure we don't cache the class factory.
            }
        }
        else
        {
            *ppUnk = _pPosNode->_pCFProt;
            _pPosNode->_pCFProt->AddRef();
            hr = NOERROR;
        }
        //advance to the next node for further findnextcf calls
        _pPosNode = _pPosNode->_pNextNode;
    }

    PerfDbgLog1(tagCProtMgr, this, "-CProtMgrNameSpace::FindFirstCF (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CProtMgrNameSpace::FindNextCF
//
//  Synopsis:
//
//  Arguments:  [pszProt] --
//              [ppUnk] --
//              [pclsid] --
//
//  Returns:
//
//  History:    11-16-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CProtMgrNameSpace::FindNextCF(LPCWSTR pszProt, IClassFactory **ppUnk, CLSID *pclsid)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CProtMgrNameSpace::FindNextCF",
                "this=%#x, %.80wq, %#x, %#x",
                this, pszProt, ppUnk, pclsid
                ));
                
    PerfDbgLog(tagCProtMgr, this, "+CProtMgrNameSpace::FindNextCF");
    HRESULT hr = INET_E_UNKNOWN_PROTOCOL;
    CLock lck(_mxs);

    if (_cElements > 0 && _pPosNode)
    {
        char szStr[ULPROTOCOLLEN];
        W2A(pszProt, szStr, ULPROTOCOLLEN);

        ATOM atom = FindAtom(szStr);

        if (atom)
        {
            do
            {
                // find next matching node
                while (_pPosNode && _pPosNode->_atom != atom)
                {
                    _pPosNode = _pPosNode->_pNextNode;
                }

                if (_pPosNode)
                {
                    IClassFactory *pCF = 0;
                    *pclsid = _pPosNode->_clsidProt;

                    if (_pPosNode->_pCFProt == NULL)
                    {
                        hr = CoGetClassObject(*pclsid, CLSCTX_INPROC_SERVER,NULL,IID_IClassFactory, (void**)&pCF);
                        if (hr == NOERROR)
                        {
                            *ppUnk = pCF;//make sure we don't cache the class factory.
                        }
                    }
                    else
                    {
                        *ppUnk = _pPosNode->_pCFProt;
                        _pPosNode->_pCFProt->AddRef();
                        hr = NOERROR;
                    }
                    //advance to the next node for further findnextcf calls
                    _pPosNode = _pPosNode->_pNextNode;
                }

            } while (hr != NOERROR && _pPosNode);
        }
    }

    PerfDbgLog1(tagCProtMgr, this, "-CProtMgrNameSpace::FindNextCF (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CProtMgrNameSpace::LookupClsIDFromReg
//
//  Synopsis:
//
//  Arguments:  [pszProt] --
//              [ppclsid] --
//              [pcClsIds] --
//
//  Returns:
//
//  History:    11-20-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CProtMgrNameSpace::LookupClsIDFromReg(LPCWSTR pwzProt, CLSID *ppclsid, DWORD *pcClsIds, DWORD *pdwFlags, DWORD dwOpt)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CProtMgrNameSpace::LookupClsIDFromReg",
                "this=%#x, %.80wq, %#x, %#x, %#x, %#x",
                this, pwzProt, ppclsid, pcClsIds, pdwFlags, dwOpt
                ));
                
    PerfDbgLog1(tagCProtMgr, this, "+CProtMgrNameSpace::LookupClsIDFromReg (pwzProt:%ws)", pwzProt);
    HRESULT hr = INET_E_UNKNOWN_PROTOCOL;
    DWORD dwType;
    DWORD cFound = 0;
    HKEY hNameSpaceKey = NULL;

    TransAssert((pwzProt && ppclsid));

    char pszProt[ULPROTOCOLLEN];

    W2A(pwzProt, pszProt, ULPROTOCOLLEN);

    char szDelimiter = ':';

    LPSTR pszDel = StrChr(pszProt, szDelimiter);

    if (pszDel)
    {
        *pszDel = '\0';
    }


    #define LENNAMEMAX 256
    DWORD dwLen = LENNAMEMAX;
    DWORD dwLenName = LENNAMEMAX;
    char szNameSpaceKey[LENNAMEMAX];
    char szName[LENNAMEMAX];

    strcpy(szNameSpaceKey, SZNAMESPACEROOT);

    LPSTR pszKey = szNameSpaceKey + strlen(szNameSpaceKey);

    if (RegOpenKeyEx(HKEY_CLASSES_ROOT, szNameSpaceKey, 0, KEY_READ | KEY_QUERY_VALUE, &hNameSpaceKey) != ERROR_SUCCESS)
    {
        TransAssert((hNameSpaceKey == NULL));
    }

    if (hNameSpaceKey)
    {
        HKEY hProtKey = NULL;
        DWORD dwIndex = 0;
        DWORD dwCheck = 2;

        do
        {
            *pszKey = '\0';
            LPSTR pszKeyProt = pszKey;

            if (dwCheck == 2)
            {
                strcat(pszKeyProt, pszProt);
            }
            else if (dwCheck == 1)
            {
                strcat(pszKeyProt, SZALL);
            }
            else
            {
                TransAssert((FALSE));
            }
            strcat(pszKeyProt, "\\");


            if (RegOpenKeyEx(HKEY_CLASSES_ROOT, szNameSpaceKey, 0, KEY_READ | KEY_QUERY_VALUE, &hProtKey) != ERROR_SUCCESS)
            {
                hProtKey = 0;
            }
            dwCheck--;


            if (hProtKey)
            {
                DWORD dwResult;
                dwLenName = LENNAMEMAX;
                LPSTR pszName = szNameSpaceKey + strlen(szNameSpaceKey);
                dwIndex = 0;

                // enum all sub keys
                while (   (dwResult = (RegEnumKeyEx(hProtKey, dwIndex, szName, &dwLenName, 0, 0, 0, 0)) == ERROR_SUCCESS)
                       && (cFound < *pcClsIds)
                    )
                {
                    BOOL fFound = FALSE;
                    HKEY hNameKey = NULL;
                    *pszName = '\0';
                    strcat(pszName, szName);

                    // open the Name-Space Handler root + protocols
                    if (RegOpenKeyEx(HKEY_CLASSES_ROOT, szNameSpaceKey, 0, KEY_QUERY_VALUE, &hNameKey) == ERROR_SUCCESS)
                    {
                        DWORD dwLenClass = LENNAMEMAX;
                        char szClass[LENNAMEMAX];
                        // get the class id
                        if (RegQueryValueEx(hNameKey, SZCLASS, NULL, &dwType, (LPBYTE)szClass, &dwLenClass) == ERROR_SUCCESS)
                        {
                            hr = CLSIDFromStringA(szClass, (ppclsid + cFound));
                            if (hr == NOERROR)
                            {
                                cFound++;
                            }

                            DbgLog2(tagCProtMgr, this, "LookupNameSpaceClsIDFromReg(hr:%lx, ClsId:%s) >FOUND<", hr, szClass);
                        }
                        RegCloseKey(hNameKey);

                    }

                    dwIndex++;
                    dwLenName = LENNAMEMAX;
                }
                RegCloseKey(hProtKey);
            }

        } while (dwCheck);

        RegCloseKey(hNameSpaceKey);
    }

    if (cFound)
    {
        *pcClsIds = cFound;
        hr = NOERROR;
    }
    
    PerfDbgLog1(tagCProtMgr, this, "-CProtMgrNameSpace::LookupClsIDFromReg (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CProtMgrMimeHandler::LookupClsIDFromReg
//
//  Synopsis:
//
//  Arguments:  [pwzMime] --
//              [pclsid] --
//              [pcClsIds] --
//
//  Returns:
//
//  History:    11-20-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CProtMgrMimeHandler::LookupClsIDFromReg(LPCWSTR pwzMime, CLSID *pclsid, DWORD *pcClsIds, DWORD *pdwFlags, DWORD dwOpt)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CProtMgrNameSpace::LookupClsIDFromReg",
                "this=%#x, %.80wq, %#x, %#x, %#x, %#x",
                this, pwzMime, pclsid, pcClsIds, pdwFlags, dwOpt
                ));
                
    PerfDbgLog1(tagCProtMgr, this, "+CProtMgrMimeHandler::LookupClsIDFromReg (pwzMime:%ws)", pwzMime);
    HRESULT hr = INET_E_UNKNOWN_PROTOCOL;

    HKEY hMimeKey = NULL;
    DWORD dwError;
    DWORD dwType;
    char szValue[256];
    DWORD dwValueLen = 256;
    char szKey[SZMIMESIZE_MAX + 256];

    TransAssert((pwzMime));

    char szStr[ULPROTOCOLLEN+1];
    W2A(pwzMime, szStr, ULPROTOCOLLEN);
    szStr[ULPROTOCOLLEN] = 0;

    strcpy(szKey, SZ_SH_FILTERROOT);
    strcat(szKey, szStr);

    if (SHRegGetUSValue(
                    szKey, 
                    SZCLASS, 
                    NULL, 
                    (LPBYTE)szValue, 
                    &dwValueLen,
                    FALSE, 
                    NULL, 
                    0) == ERROR_SUCCESS)
    {
            hr = CLSIDFromStringA(szValue, pclsid);
            PerfDbgLog2(
                    tagCProtMgr, 
                    this, 
                    "API FOUND LookupFilterClsIDFromReg(hr:%lx, ClsId:%s)", 
                    hr, 
                    szValue);
    }


    // there are some machine incorrectly installed text/html and point to 
    // PlugProt.dll and urlmon.dll. so if we find out the ksy is point to
    // these dll, we still return error, otherwise (the key might be 
    // installed by 3rd party) we uses the key.
    // const GUID CLSID_MimeHandlerTest1   = {0x79eaca02, 0xbaf9, 0x11ce, {0x8c, 0x82, 0x00, 0xaa, 0x00, 0x4b, 0xa9, 0x0b}};
    if(    !wcsicmp(pwzMime, L"text/html") 
        && IsEqualGUID(*pclsid ,CLSID_ClassInstallFilter )  
      )
    {
        hr = INET_E_UNKNOWN_PROTOCOL;
        *pclsid = CLSID_NULL;
    }

    PerfDbgLog1(tagCProtMgr, this, "-CProtMgrMimeHandler::LookupClsIDFromReg (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\trans\transact.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       transact.cxx
//
//  Contents:   Class that performs the download of a particular request.
//
//  Classes:
//
//  Functions:
//
//  History:    12-04-95   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------
#include <trans.h>
#include "oinet.hxx"

static CHAR gwzAcceptEncHeaders[] = "Accept-Encoding: gzip, deflate";
extern BOOL g_bHasMimeHandlerForTextHtml;

extern  IInternetSecurityManager*   g_pSecurityManager;
extern  CMutexSem                   g_mxsSession;

PerfDbgExtern(tagCTransaction);
    DbgExtern(tagCTransactionErr);

HRESULT GetClassDocFileBuffer(LPVOID pbuffer, DWORD dwSize, CLSID *pclsid);
extern DWORD g_dwSettings;

#if DBG==1

#else
#define USE_NOTIFICATION_EXCEPTION_FILTER   //Not in this lifetime
#endif //


#define szHKSniffFlag   "Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings"
#define szHKSniffValue  "SniffDocFile"

BOOL IsSpecialUrl(WCHAR *pchURL);

//+---------------------------------------------------------------------------
//
//  Method:     CTransData::QueryInterface
//
//  Synopsis:
//
//  Arguments:  [riid] --
//              [ppvObj] --
//
//  Returns:
//
//  History:    1-27-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CTransaction::QueryInterface(REFIID riid, void **ppvObj)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CTransaction::IUnknown::QueryInterface",
                "this=%#x, %#x, %#x",
                this, &riid, ppvObj
                ));
                
    VDATEPTROUT(ppvObj, void *);
    VDATETHIS(this);
    HRESULT hr = NOERROR;

    PerfDbgLog(tagCTransaction, this, "+CTransaction::QueryInterface");

    *ppvObj = NULL;
    hr = _pUnkOuter->QueryInterface(riid, ppvObj);

    PerfDbgLog1(tagCTransaction, this, "-CTransaction::QueryInterface (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   CTransaction::AddRef
//
//  Synopsis:
//
//  Arguments:  [ULONG] --
//
//  Returns:
//
//  History:    1-27-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CTransaction::AddRef(void)
{
    DEBUG_ENTER((DBG_TRANS,
                Dword,
                "CTransaction::IUnknown::AddRef",
                "this=%#x",
                this
                ));

    LONG lRet = ++_CRefs;
    PerfDbgLog1(tagCTransaction, this, "CTransaction::AddRef (cRefs:%ld)", lRet);

    DEBUG_LEAVE(lRet);
    return lRet;
}

//+---------------------------------------------------------------------------
//
//  Function:   CTransaction::Release
//
//  Synopsis:
//
//  Arguments:  [ULONG] --
//
//  Returns:
//
//  History:    1-27-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CTransaction::Release(void)
{
    DEBUG_ENTER((DBG_TRANS,
                Dword,
                "CTransaction::IUnknown::Release",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCTransaction, this, "+CTransaction::Release");

    LONG lRet = --_CRefs;

    if (_CRefs == 0)
    {
        delete this;
    }

    PerfDbgLog1(tagCTransaction, this, "-CTransaction::Release (cRefs:%ld)", lRet);

    DEBUG_LEAVE(lRet);
    return lRet;
}

//+---------------------------------------------------------------------------
//
//  Method:     CTransaction::Switch
//
//  Synopsis:
//
//  Arguments:  [pStateInfo] --
//
//  Returns:
//
//  History:    11-07-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CTransaction::Switch(PROTOCOLDATA *pStateInfo)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CTransaction::IInternetProtocolSink::Switch",
                "this=%#x, %#x",
                this, pStateInfo
                ));

    PerfDbgLog(tagCTransaction, this, "+CTransaction::Switch");
    HRESULT hr = NOERROR;

    DWORD grfFlags = pStateInfo->grfFlags;
    AddRef();

    if (IsFreeThreaded())
    {
        if (grfFlags & PD_FORCE_SWITCH)
        {
            CTransPacket * pCTP = new CTransPacket(pStateInfo);

            if (pCTP)
            {
                hr = _pClntProtSink->Switch(pCTP);
            }
        }
        else
        {
            // handle request on this thread
            _pProt->Continue(pStateInfo);
        }
    }
    else
    {
        CTransPacket *pCTP = new CTransPacket(pStateInfo);

        if (pCTP)
        {
            AddCTransPacket(pCTP);

            if ((grfFlags & PI_FORCE_ASYNC) || !IsApartmentThread())
            {
                _cPostedMsg++;
                AddRef();
                /****
                PerfDbgLog4(tagCTransaction, this, "CINet:%lx === PostMessage (Msg:%#x) WM_TRANS_PACKET - dwCurrentSize:%ld, dwTotalSize:%ld",
                    _pProt, XDBG(++_wTotalPostedMsg,0), pCTP->_dwCurrentSize, pCTP->_dwTotalSize);
                ****/
                PostMessage(_hwndNotify, WM_TRANS_PACKET, (WPARAM) (WPARAM)GetTotalPostedMsgId(), (LPARAM)this);
            }
            else
            {
                OnINetCallback();
            }
        }
    }
    Release();

    PerfDbgLog1(tagCTransaction, this, "-CTransaction::Switch (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CTransaction::ReportProgress
//
//  Synopsis:
//
//  Arguments:  [NotMsg] --
//              [szStatusText] --
//
//  Returns:
//
//  History:    11-07-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CTransaction::ReportProgress(ULONG NotMsg, LPCWSTR szStatusText)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CTransaction::IInternetProtocolSink::ReportProgress",
                "this=%#x, %#x, %.80wq",
                this, NotMsg, szStatusText
                ));


    AddRef();
    PerfDbgLog(tagCTransaction, this, "+CTransaction::ReportProgress");
    HRESULT hr = NOERROR;

    if (PreDispatch() != S_OK)
    {
        // nothing to do any more!
    }
    else if (IsFreeThreaded())
    {
        // handle request on this thread
        hr = DispatchReport((BINDSTATUS) NotMsg, _grfBSCF, _ulCurrentSize, _ulTotalSize, (LPWSTR)szStatusText, 0);
    }
    else
    {
        CTransPacket *pCTP = new CTransPacket( (BINDSTATUS) NotMsg, NOERROR, szStatusText, _ulCurrentSize, _ulTotalSize);

        if (pCTP)
        {
        #if DBG==1
            DWORD dwCurrentSizePerf = pCTP->_dwCurrentSize;
            DWORD dwTotalSizePerf = pCTP->_dwTotalSize;
        #elif defined(PERFTAGS)
            DWORD dwCurrentSizePerf = pCTP->_dwCurrentSize;
            DWORD dwTotalSizePerf = pCTP->_dwTotalSize;
        #endif
            
            //BUGBUG: this is a hack where small doc files are loaded in one swipe and
            //the class install filter is not loaded because an BINDSTATUS_ENDDOWNLOAD
            //already occurs in transaction packet list.
            if (NotMsg == BINDSTATUS_CLASSINSTALLLOCATION)
            {
                AddCTransPacket(pCTP, FALSE);
            }
            else
            {
                AddCTransPacket(pCTP);
            }

            if (!IsApartmentThread())
            {
                _cPostedMsg++;
                AddRef();
                PerfDbgLog4(tagCTransaction, this, "CINet:%lx === PostMessage (Msg:%#x) WM_TRANS_PACKET - dwCurrentSize:%ld, dwTotalSize:%ld",
                                _pProt, XDBG(++_wTotalPostedMsg,0), dwCurrentSizePerf, dwTotalSizePerf);
                PostMessage(_hwndNotify, WM_TRANS_PACKET, (WPARAM)GetTotalPostedMsgId(), (LPARAM)this);

            }
            else
            {
                OnINetCallback();
            }
        }
    }

    PostDispatch();

    Release();
    PerfDbgLog1(tagCTransaction, this, "-CTransaction::ReportProgress (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CTransaction::ReportData
//
//  Synopsis:
//
//  Arguments:  [grfBSCF] --
//              [ULONG] --
//              [ulProgressMax] --
//
//  Returns:
//
//  History:    11-07-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CTransaction::ReportData(DWORD grfBSCF, ULONG ulProgress,ULONG ulProgressMax)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CTransaction::IInternetProtocolSink::ReportData",
                "this=%#x, %#x, %u, %u",
                this, grfBSCF, ulProgress, ulProgressMax
                ));


    PerfDbgLog3(tagCTransaction, this, "+CTransaction::ReportData(grfBSCF:%lx, ulProgress:%ld, ulProgressMax:%ld)",
                                       grfBSCF, ulProgress, ulProgressMax);

    HRESULT hr = NOERROR;
    BOOL fAsync = FALSE;

    BINDSTATUS bndStatus = BINDSTATUS_DOWNLOADINGDATA;
    AddRef();

    if (   (PreDispatch() == S_OK)
        && (   (_ulCurrentSize <= ulProgress)
             || (    (grfBSCF & BSCF_LASTDATANOTIFICATION)
                 && !(_grfBSCF & BSCF_LASTDATANOTIFICATION))
             || (grfBSCF & BSCF_ASYNCDATANOTIFICATION)
            ))
    {

        if (grfBSCF & BSCF_FIRSTDATANOTIFICATION)
        {
            bndStatus = BINDSTATUS_BEGINDOWNLOADDATA;
            _grfBSCF |= BSCF_FIRSTDATANOTIFICATION;
        }

        if (grfBSCF & BSCF_LASTDATANOTIFICATION)
        {
            bndStatus = BINDSTATUS_ENDDOWNLOADDATA;
            _grfBSCF |= BSCF_LASTDATANOTIFICATION;
        }

        if (grfBSCF & BSCF_DATAFULLYAVAILABLE)
        {
            _grfBSCF |= BSCF_DATAFULLYAVAILABLE;
        }

        if (grfBSCF & BSCF_ASYNCDATANOTIFICATION)
        {
            fAsync = TRUE;
        }

        _ulCurrentSize = ulProgress;
        _ulTotalSize  = ulProgressMax;
        TransAssert((   (_ulTotalSize == 0)
                     || (_ulCurrentSize <= _ulTotalSize) ));

        if (IsFreeThreaded())
        {
            hr = DispatchReport(bndStatus, _grfBSCF, _ulCurrentSize, _ulTotalSize, 0, 0);
        }
        else
        {
            CTransPacket *pCTP = new CTransPacket(bndStatus, NOERROR, NULL, _ulCurrentSize, _ulTotalSize);

            if (pCTP)
            {
            #if DBG==1
                DWORD dwCurrentSizePerf = pCTP->_dwCurrentSize;
                DWORD dwTotalSizePerf = pCTP->_dwTotalSize;
            #elif defined(PERFTAGS)
                DWORD dwCurrentSizePerf = pCTP->_dwCurrentSize;
                DWORD dwTotalSizePerf = pCTP->_dwTotalSize;
            #endif
                AddCTransPacket(pCTP);

                if (!IsApartmentThread() || fAsync)
                {
                    _cPostedMsg++;
                    AddRef();
                    PerfDbgLog4(tagCTransaction, this, "CINet:%lx === PostMessage (Msg:%#x) WM_TRANS_PACKET - dwCurrentSize:%ld, dwTotalSize:%ld",
                                    _pProt, XDBG(++_wTotalPostedMsg,0), dwCurrentSizePerf, dwTotalSizePerf);
                    PostMessage(_hwndNotify, WM_TRANS_PACKET, (WPARAM) (WPARAM)GetTotalPostedMsgId(), (LPARAM)this);

                }
                else
                {
                    OnINetCallback();
                }
            }
        }
    }

    PostDispatch();

    Release();

    PerfDbgLog1(tagCTransaction, this, "-CTransaction::ReportData (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CTransaction::OnDataReceived
//
//  Synopsis:
//
//  Arguments:  [grfBSC] --
//              [cbBytesAvailable] --
//              [dwTotalSize] --
//              [pcbNewAvailable] --
//
//  Returns:
//
//  History:    4-15-1997   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CTransaction::OnDataReceived(DWORD *pgrfBSC, DWORD *pcbBytesAvailable, DWORD *pdwTotalSize) //, DWORD *pcbNewAvailable)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CTransaction::OnDataReceived",
                "this=%#x, %#x, %#x, %#x",
                this, pgrfBSC, pcbBytesAvailable, pdwTotalSize
                ));
                
    PerfDbgLog3(tagCTransaction, this, "+CTransaction::OnDataReceived (grfBSC:%lx,  cbBytesAvailable:%ld, _cbTotalBytesRead:%ld)",
                                    *pgrfBSC, *pcbBytesAvailable, _cbTotalBytesRead);
    HRESULT hr = NOERROR;
    DWORD grfBSC = *pgrfBSC;
    DWORD cbBytesAvailable = *pcbBytesAvailable;
    DWORD dwTotalSize = *pdwTotalSize;
    DWORD *pcbNewAvailable = &cbBytesAvailable;

    *pcbNewAvailable = cbBytesAvailable;

    do
    {
        // check if mimeverification was requested
        //
        if (!(_dwOInetBdgFlags & (PI_MIMEVERIFICATION | PI_DOCFILECLSIDLOOKUP)) )
        {
            break;
        }
        // get the buffer
        //
        if (!_pBuffer)
        {
            _cbBufferSize = DATASNIFSIZEDOCFILE_MIN; //DATASNIFSIZE_MIN;
            _pBuffer = (LPBYTE) new BYTE[_cbBufferSize];
        }
        if (!_pBuffer)
        {
            hr = E_OUTOFMEMORY;
            break;
        }


        DWORD dwNewData = 0;
        TransAssert((_pProt && _cbDataSniffMin));

        // _cbTotalBytesRead = # of bytes read so far
        if (_cbTotalBytesRead < _cbDataSniffMin)
        {
            // no bytes read so far
            TransAssert((_cbTotalBytesRead < _cbDataSniffMin));
            // read data into buffer and report progess
            do
            {
                hr = _pProt->Read(_pBuffer + _cbBufferFilled, _cbBufferSize - _cbBufferFilled, &dwNewData);
                _cbTotalBytesRead += dwNewData;
                _cbBufferFilled += dwNewData;
            } while ((hr == S_OK) && (_cbTotalBytesRead < _cbDataSniffMin));

            // now check if this is docfile
            // if so download at least 2k
            if (!_fDocFile && _cbBufferFilled && (IsDocFile(_pBuffer, _cbBufferFilled) == S_OK))
            {
                _fDocFile = TRUE;
                _cbDataSniffMin =  (dwTotalSize && dwTotalSize < DATASNIFSIZEDOCFILE_MIN) ? dwTotalSize : DATASNIFSIZEDOCFILE_MIN;
            }

            if ((hr == E_PENDING) && (_cbTotalBytesRead < _cbDataSniffMin))
            {
                // do not report anything - wait until we get more data
                // a request is pending at this time
                // need more data to sniff properly
                hr  = S_NEEDMOREDATA;
            }
            else if (hr == NOERROR || hr == E_PENDING)
            {
                TransAssert((_cbTotalBytesRead != 0));

                // report the data we have in the buffer or
                // the available #
                DWORD cbBytesReport =  (cbBytesAvailable > _cbTotalBytesRead) ? cbBytesAvailable : _cbTotalBytesRead + 1;

                if (dwTotalSize && ((cbBytesReport > dwTotalSize)))
                {
                    cbBytesReport =  dwTotalSize;
                }
                *pcbNewAvailable = cbBytesReport;
            }
            else if (hr == S_FALSE)
            {
                // end of stream
                *pgrfBSC |=  (BSCF_LASTDATANOTIFICATION & BSCF_DATAFULLYAVAILABLE);
                *pcbBytesAvailable = *pdwTotalSize =  _cbTotalBytesRead;
            }

            if (   (!_fMimeVerified)
                && (   (*pcbNewAvailable >= _cbDataSniffMin)
                    || (hr == S_FALSE)) )
            {
                // enough data or end of stream
                _fMimeVerified = TRUE;
                LPWSTR  pwzStr = 0;
                FindMimeFromData(NULL, _pwzFileName,_pBuffer, _cbBufferFilled, _pwzMimeSuggested, 0, &pwzStr, 0);

                if (pwzStr)
                {
                    _pClntProtSink->ReportProgress(BINDSTATUS_MIMETYPEAVAILABLE, pwzStr);
                } 
                else
                {
                    TransAssert((!_pwzMimeSuggested));
                }

                if (pwzStr)
                {
                    delete [] _pwzMimeSuggested;
                    _pwzMimeSuggested = pwzStr;
                    pwzStr = 0;
                }

                if (   _fDocFile
                    && (_dwOInetBdgFlags & PI_DOCFILECLSIDLOOKUP))
                {
                    // find the class id and send it on
                    CLSID clsid;

                    HRESULT hr1 = GetClassDocFileBuffer(_pBuffer, _cbBufferFilled, &clsid);
                    if (hr1 == NOERROR)
                    {
                        LPOLESTR pwzStrClsId;
                        StringFromCLSID(clsid, &pwzStrClsId);
                        if (pwzStrClsId)
                        {
                           _pClntProtSink->ReportProgress(BINDSTATUS_CLASSIDAVAILABLE, pwzStrClsId);
                        }
                        delete [] pwzStrClsId;
                    }
                }
                delete [] pwzStr;

            }
            hr = NOERROR;
        }
        //TransAssert((cbBytesAvailable <= *pcbNewAvailable));
        if (cbBytesAvailable > *pcbNewAvailable)
        {
            *pcbNewAvailable = cbBytesAvailable;
        }
        if (dwTotalSize && (dwTotalSize < *pcbNewAvailable))
        {
            *pcbNewAvailable = dwTotalSize;
        }
    
        break;
    } while (TRUE);

    {
        CLock lck(_mxs);
        _cbBytesReported = *pcbNewAvailable;
        *pdwTotalSize = dwTotalSize;
    }

    PerfDbgLog2(tagCTransaction, this, "-CTransaction::OnDataReceived (hr:%lx, _cbBufferFilled:%lx)", hr, _cbBufferFilled);

    DEBUG_LEAVE(hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CTransaction::ReportResult
//
//  Synopsis:
//
//  Arguments:  [DWORD] --
//              [dwError] --
//              [wzResult] --
//
//  Returns:
//
//  History:    11-07-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CTransaction::ReportResult(HRESULT hrResult, DWORD dwError, LPCWSTR wzResult)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CTransaction::IInternetProtocolSink::ReportResult",
                "this=%#x, %#x, %#x, %.80wq",
                this, hrResult, dwError, wzResult
                ));

    PerfDbgLog3(tagCTransaction, this, "+CTransaction::ReportResult [hr:%lX, dwError;%lX (%ld)]", hrResult, dwError, dwError);
    HRESULT hr = NOERROR;

    AddRef();

    BOOL fReport = FALSE;
    
    {   //BEGIN SYNC BLOCK
        CLock lck(_mxsBind);
        if (!_fResultReported)
        {
            _fResultReported = TRUE;
            fReport = TRUE;
        }
    }   // END SYNC BLOCK

    if (fReport)
    {
        _hrResult = hrResult;
        _dwResult = dwError;

        if (_pwzResult)
        {
            delete [] _pwzResult;
        }
        _pwzResult = OLESTRDuplicate((LPWSTR)wzResult);

        if (IsFreeThreaded())
        {

            // handle request on this thread
            hr = DispatchReport(BINDSTATUS_RESULT, _grfBSCF, _ulCurrentSize, _ulTotalSize, _pwzResult, _dwResult, _hrResult);
        }
        else
        {
            CTransPacket *pCTP = new CTransPacket( (BINDSTATUS) ((_hrResult == NOERROR) ? BINDSTATUS_RESULT : BINDSTATUS_ERROR),
                                                    _hrResult, _pwzResult, _ulCurrentSize, _ulTotalSize, _dwResult);

            if (pCTP)
            {
            #if DBG==1
                DWORD dwCurrentSizePerf = pCTP->_dwCurrentSize;
                DWORD dwTotalSizePerf = pCTP->_dwTotalSize;
            #elif defined(PERFTAGS)
                DWORD dwCurrentSizePerf = pCTP->_dwCurrentSize;
                DWORD dwTotalSizePerf = pCTP->_dwTotalSize;
            #endif
                AddCTransPacket(pCTP);

                if (!IsApartmentThread() || 
                    _fForceAsyncReportResult || 
                    ((_hrResult==INET_E_REDIRECTING) && (_dwOInetBdgFlags & PI_SYNCHRONOUS)))
                {
                    _cPostedMsg++;
                    AddRef();
                    PerfDbgLog4(tagCTransaction, this, "CINet:%lx === PostMessage (Msg:%#x) WM_TRANS_PACKET - dwCurrentSize:%ld, dwTotalSize:%ld",
                                    _pProt, XDBG(++_wTotalPostedMsg,0), dwCurrentSizePerf, dwTotalSizePerf);
                    PostMessage(_hwndNotify, WM_TRANS_PACKET, (WPARAM) (WPARAM)GetTotalPostedMsgId(), (LPARAM)this);

                }
                else
                {
                    OnINetCallback();
                }
            }
        }
    }
    else
    {
        // should not happen with our protocols
        hr = E_FAIL;
    }
    
    Release();

    PerfDbgLog1(tagCTransaction, this, "-CTransaction::ReportResult (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CTransaction::QueryBindFlags
//
//  Synopsis:
//
//  Arguments:  [DWORD* ] -- emits binding flags
//
//  Returns:
//
//  History:    04-07-2000   RajeevD (Rajeev Dujari)   Created
//
//  Notes: Hack for netdocs to grab binding flags.
//
//----------------------------------------------------------------------------
STDMETHODIMP CTransaction::QueryBindFlags (DWORD* pdwFlags)
{
    *pdwFlags = _dwOInetBdgFlags;
    return S_OK;
}


// protocolinfo methods

//+---------------------------------------------------------------------------
//
//  Method:     CTransaction::Authenticate
//
//  Synopsis:
//
//  Arguments:  [phwnd] --
//              [LPWSTR] --
//              [pszPassword] --
//
//  Returns:
//
//  History:    11-07-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CTransaction::Authenticate(HWND* phwnd, LPWSTR *pszUsername,LPWSTR *pszPassword)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CTransaction::IAuthenticate::Authenticate",
                "this=%#x, %#x, %#x, %#x",
                this, phwnd, pszUsername, pszPassword
                ));
                
    PerfDbgLog(tagCTransaction, this, "+CTransaction::Authenticate");
    HRESULT hr = E_FAIL;
    IAuthenticate *pBasicAuth = 0;

    AddRef();
    hr = QueryService(IID_IAuthenticate,IID_IAuthenticate, (void **) &pBasicAuth);

    if ((hr == NOERROR) && pBasicAuth)
    {
         hr = pBasicAuth->Authenticate(phwnd, pszUsername,pszPassword);
    }
    else
    {
        UrlMkAssert((pBasicAuth == NULL));
        *phwnd = 0;
        *pszUsername = 0;
        *pszPassword = 0;
    }
    Release();

    PerfDbgLog1(tagCTransaction, this, "-CTransaction::Authenticate (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CTransaction::QueryOption
//
//  Synopsis:
//
//  Arguments:  [dwOption] --
//              [pBuffer] --
//              [pcbBuf] --
//
//  Returns:
//
//  History:    11-07-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CTransaction::QueryOption(DWORD dwOption, LPVOID pBuffer, DWORD *pcbBuf)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CTransaction::QueryOption",
                "this=%#x, %#x, %#x, %#x",
                this, dwOption, pBuffer, pcbBuf
                ));
                
    PerfDbgLog(tagCTransaction, this, "+CTransaction::QueryOption");
    HRESULT hr = E_FAIL;
    if (_pProt)
    {
        if (!_pInetInfo)
        {
            hr = _pProt->QueryInterface(IID_IWinInetInfo, (void **) &_pInetInfo);
            TransAssert(( (hr == NOERROR && _pInetInfo) || (hr != NOERROR && !_pInetInfo) ));
            if ((hr == NOERROR) && _pUnkInner)
            {
                Release();
            }

        }

        if (_pInetInfo)
        {

            hr = _pInetInfo->QueryOption(dwOption, pBuffer, pcbBuf);
        }
    }
    PerfDbgLog1(tagCTransaction, this, "-CTransaction::QueryOption (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CTransaction::QueryInfo
//
//  Synopsis:
//
//  Arguments:  [dwOption] --
//              [pBuffer] --
//              [pcbBuf] --
//              [pdwFlags] --
//              [pdwReserved] --
//
//  Returns:
//
//  History:    11-07-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CTransaction::QueryInfo(DWORD dwOption, LPVOID pBuffer, DWORD *pcbBuf, DWORD *pdwFlags, DWORD *pdwReserved)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CTransaction::QueryInfo",
                "this=%#x, %#x, %#x, %#x, %#x, %#x",
                this, dwOption, pBuffer, pcbBuf, pdwFlags, pdwReserved
                ));
                
    PerfDbgLog(tagCTransaction, this, "+CTransaction::QueryInfo");
    HRESULT hr = E_FAIL;
    if (_pProt)
    {
        if (!_pInetHttpInfo)
        {
            hr = _pProt->QueryInterface(IID_IWinInetHttpInfo, (void **) &_pInetHttpInfo);
            TransAssert(( (hr == NOERROR && _pInetHttpInfo) || (hr != NOERROR && !_pInetHttpInfo) ));
            if ((hr == NOERROR) && _pUnkInner)
            {
                Release();
            }

        }
        if (_pInetHttpInfo)
        {
            hr = _pInetHttpInfo->QueryInfo(dwOption, pBuffer, pcbBuf, pdwFlags, pdwReserved);
        }
    }

    PerfDbgLog1(tagCTransaction, this, "-CTransaction::QueryInfo (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//IOInetBindInfo methods
//+---------------------------------------------------------------------------
//
//  Method:     CTransaction::GetBindInfo
//
//  Synopsis:
//
//  Arguments:  [pdwBINDF] --
//              [pbindinfo] --
//
//  Returns:
//
//  History:    11-07-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CTransaction::GetBindInfo(DWORD *pdwBINDF, BINDINFO *pbindinfo)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CTransaction::IInternetBindInfo::GetBindInfo",
                "this=%#x, %#x, %#x",
                this, pdwBINDF, pbindinfo
                ));
                
    PerfDbgLog(tagCTransaction, this, "+CTransaction::GetBindInfo");
    HRESULT hr = NOERROR;

    TransAssert((pdwBINDF && pbindinfo));

    TransAssert((_pClntBindInfo));
    hr = _pClntBindInfo->GetBindInfo(pdwBINDF, pbindinfo);

    if (SUCCEEDED(hr))
    {
        PerfDbgLog(tagCTransaction, this, "---CTrans::BINDF_FROMURLMON---");
        *pdwBINDF |= BINDF_FROMURLMON;
    }

    // never do a post on redirect
    if (_pwzRedirectUrl)
    {
        if( pbindinfo && (pbindinfo->dwBindVerb == BINDVERB_POST) )
        {
            pbindinfo->dwBindVerb = BINDVERB_GET;
        }
    }

    PerfDbgLog1(tagCTransaction, this, "-CTransaction::GetBindInfo (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CTransaction::GetBindString
//
//  Synopsis:
//
//  Arguments:  [ulStringType] --
//              [ppwzStr] --
//              [cEl] --
//              [pcElFetched] --
//
//  Returns:
//
//  History:    11-07-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CTransaction::GetBindString(ULONG ulStringType, LPOLESTR *ppwzStr, ULONG cEl, ULONG *pcElFetched)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CTransaction::IInternetBindInfo::GetBindString",
                "this=%#x, %#x, #%#x, %u, %#x",
                this, ulStringType, ppwzStr, cEl, pcElFetched
                ));
                
    PerfDbgLog(tagCTransaction, this, "+CTransaction::GetBindString");
    HRESULT hr = INET_E_USE_DEFAULT_SETTING;

    // we handles the encoding here
   
    if (    _fEncodingHandlerEnabled  
         && ulStringType == BINDSTRING_ACCEPT_ENCODINGS
         && ppwzStr
         && cEl )
    {
        LPWSTR pwzAcpHeaders = NULL;
        pwzAcpHeaders = DupA2W(gwzAcceptEncHeaders);
        
        if( pwzAcpHeaders ) 
        {
            *ppwzStr =  pwzAcpHeaders;
            *pcElFetched = 1;
            hr = NOERROR;
        }
        else
        {
            hr = E_OUTOFMEMORY;
            *pcElFetched = 0;
        }
    }
    else
    {

        TransAssert((_pClntBindInfo));
    
        hr = _pClntBindInfo->GetBindString(ulStringType, ppwzStr, cEl, pcElFetched);

        PerfDbgLog1(tagCTransaction, this, "-CTransaction::GetBindString (hr:%lx)", hr);
    }


    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CTransaction::QueryService
//
//  Synopsis:
//
//  Arguments:  [rsid] --
//              [riid] --
//              [ppvObj] --
//
//  Returns:
//
//  History:    11-07-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT IUnknown_QueryService(IUnknown* punk, REFGUID rsid, REFIID riid, void ** ppvObj);

HRESULT CTransaction::QueryService(REFGUID rsid, REFIID riid, void ** ppvObj)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CTransaction::IServiceProvider::QueryService",
                "this=%#x, %#x, %#x, %#x",
                this, &rsid, &riid, ppvObj
                ));
                
    PerfDbgLog(tagCTransaction, this, "+CTransaction::QueryService");
    HRESULT     hr = NOERROR;
    VDATETHIS(this);
    TransAssert((ppvObj));

    hr = IUnknown_QueryService(_pClntProtSink, rsid, riid, ppvObj);

    TransAssert(( ((hr == E_NOINTERFACE) && !*ppvObj)  || ((hr == NOERROR) && *ppvObj) ));

    PerfDbgLog1(tagCTransaction, this, "-CTransaction::QueryService (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CTransaction::CTransaction
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    12-11-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
CTransaction::CTransaction(DWORD grfFlags, LPBYTE pByte, ULONG cbSizeBuffer, IUnknown *pUnkOuter)
                          :  _CRefs(), _cPacketsInList(0), _cPostedMsg(0)
                          ,  _CProtEmbed(), _CProtClsInstaller()
{
    DEBUG_ENTER((DBG_TRANS,
                None,
                "CTransaction::CTransaction",
                "this=%#x, %#x, %#x, %#x, %#x",
                this, grfFlags, pByte, cbSizeBuffer, pUnkOuter
                ));

    _flags = 0;

    if (!pUnkOuter)
    {
        pUnkOuter = &_Unknown;
    }
    _pUnkOuter = pUnkOuter;


    _pCTransNext = NULL;
    _pClntProtSink = NULL;
    _hwndNotify = NULL;
    _pCTransMgr = GetThreadTransactionMgr();
    _State = TransSt_None;
    _cBdgRefs = 0;
    _pCTPHead = NULL;
    _pCTPTail = NULL;
    _pCTPCur = NULL;
    _fDispatch = FALSE;
    _ThreadTransferState = TS_None;
    _fResultReported = FALSE;
    _fTerminated = FALSE;
    _fTerminating = FALSE;
    _fResultDispatched = FALSE;
    _fResultReceived = TRUE;
    _hrResult = NOERROR;
    _dwResult = 0;
    _dwPacketsTotal = 0;
    _grfInternalFlags = 0;
    _pProt = NULL;
    _clsidProtocol = CLSID_NULL;
    _pBndInfo = NULL;
    _pInetInfo = NULL;
    _pInetHttpInfo = NULL;
    _pBndCtx = NULL;
    _dwThreadId = GetCurrentThreadId();
    _dwProcessId = GetCurrentProcessId();
    _grfBSCF = 0;
    _pUnkInner = 0;
    _dwOInetBdgFlags = grfFlags;

    _pBuffer = pByte;                   // DNLD_BUFFER_SIZE  size buffer
    _cbBufferSize  = cbSizeBuffer;
    _cbTotalBytesRead = 0 ;
    _cbBufferFilled = 0;                //how much of the buffer is in use
    _pwzUrl = 0;
    _pwzRedirectUrl = 0;
    _dwTerminateOptions = 0;
    _cbDataSniffMin = DATASNIFSIZE_MIN;
    _fDocFile = FALSE;
    _fMimeVerified = FALSE;
    _fAttached = FALSE;
    _fLocked = FALSE;
    _fModalLoopRunning = FALSE;
    _fUnlocked = FALSE;
    _fMimeHandlerEnabled = TRUE;
    _fEncodingHandlerEnabled = TRUE;
    _fClsInstallerHandlerEnabled = TRUE;
    _fMimeHandlerLoaded = FALSE;
    _pwzFileName = 0;
    _pwzAttachmentName = 0;
    _pwzMimeSuggested = 0; 
    _fProtEmbed = TRUE;
    _fStarting = FALSE;
    _fReceivedAbort = FALSE;
    _fReceivedTerminate = FALSE;
    _hrAbort = NOERROR;
    _dwAbort = 0;
    _dwDispatchLevel = 0;
    _fForceAsyncReportResult = FALSE;
    _fPreferDefaultHandler = FALSE;
    _pwzResult = NULL;
    
#if DBG==1
    _wTotalPostedMsg = 0;
#endif
    _pClntBindInfo = 0;

     _nPriority = THREAD_PRIORITY_NORMAL;
     
     _fContentDispositionAttach = FALSE;
     _fAcceptRanges = FALSE;
    
    DEBUG_LEAVE(0);
}

//+---------------------------------------------------------------------------
//
//  Method:     CTransaction::~CTransaction
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    12-11-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
CTransaction::~CTransaction()
{
    DEBUG_ENTER((DBG_TRANS,
                None,
                "CTransaction::~CTransaction",
                "this=%#x",
                this
                ));

    PerfDbgLog1(tagCTransaction, this, "+CTransaction::~CTransaction [Url:%ws]", _pwzUrl);

    if (_fLocked && _pProt)
    {
        _pProt->UnlockRequest();
    }
        
    if (_pBuffer)
    {
        delete [] _pBuffer;
    }

    if (_pwzRedirectUrl)
    {
        delete [] _pwzRedirectUrl;
    }

    if (_pwzUrl)
    {
        delete [] _pwzUrl;
    }

    if (_pwzFileName)
    {
        delete [] _pwzFileName;
    }

    if (_pwzAttachmentName)
    {
        delete [] _pwzAttachmentName;
    }

    if (_pwzMimeSuggested)
    {
        delete [] _pwzMimeSuggested;
    }

    if (_pwzProtClsId)
    {
        delete [] _pwzProtClsId;
    }

    if (_pwzResult)
    {
        delete [] _pwzResult;
    }
    
    // Remove ourselves from the global internet transaction list.
    // We should always be in the list.
    if (_pCTransMgr)
    {
        _pCTransMgr->RemoveTransaction(this);
        _pCTransMgr = NULL;
    }

    // Release any leftover packets

    while (_pCTPHead)
    {
        CTransPacket * pCTP = _pCTPHead;
        _pCTPHead = pCTP->GetNext();
        delete pCTP;
    }

    if (_pBndCtx)
    {
        _pBndCtx->Release();
    }

    if (_pClntBindInfo)
    {
        _pClntBindInfo->Release();
        _pClntBindInfo = 0;
    }

    if (_pClntProtSink)
    {
        _pClntProtSink->Release();
    }

    if (_pProt && !_pUnkInner)
    {
        _pProt->Release();
    }
    _pProt = NULL;

    if (_pInetInfo && !_pUnkInner)
    {
        _pInetInfo->Release();
    }
    _pInetInfo = NULL;

    if (_pInetHttpInfo && !_pUnkInner)
    {
        _pInetHttpInfo->Release();
    }
    _pInetHttpInfo = NULL;

    if (_pUnkInner)
    {
        PerfDbgLog1(tagCTransaction, this, "+CTransaction::~CTransaction release pUnkInner (pCINet:%lx)", _pProt);
        _pUnkInner->Release();
        _pUnkInner = NULL;
    }

    if (_pBndInfo)
    {
        //  BINDINFO_FIX(laszlog) 8-18-96

#if DBG == 1
        if (_pBndInfo->stgmedData.tymed != TYMED_NULL)
        {
            PerfDbgLog1(tagCTransaction, this, "+CTransaction::~CTransaction ReleaseStgMedium (%lx)", _pBndInfo->stgmedData);
        }
#endif

        ReleaseBindInfo(_pBndInfo);

        delete _pBndInfo;
    }

    PerfDbgLog(tagCTransaction, this, "-CTransaction::~CTransaction");

    DEBUG_LEAVE(0);
}

//+---------------------------------------------------------------------------
//
//  Method:     CTransaction::Create
//
//  Synopsis:   Creates and initializes a new transaction object
//
//  Arguments:  [pCBdg] --
//              [fConvertData] --
//              [ppCTrans] --
//
//  Returns:
//
//  History:    12-07-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CTransaction::Create(IBindCtx *pBC, DWORD grfFlags, IUnknown *pUnkOuter, IUnknown **ppUnk, CTransaction **ppCTrans)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CTransaction::Create",
                "%#x, %#x, %#x, %#x, %#x",
                pBC, grfFlags, pUnkOuter, ppUnk, ppCTrans
                ));
                
    PerfDbgLog(tagCTransaction, NULL, "+CTransaction::Create");

    HRESULT hr = NOERROR;
    TransAssert((ppCTrans != NULL));

    // Create the object
    CTransaction *pCTrans = new CTransaction(grfFlags, NULL, 0, pUnkOuter);

    if (pCTrans)
    {
        // notification window is needed for apartment threaded case
        if  (    (grfFlags & OIBDG_APARTMENTTHREADED )
             &&  (pCTrans->GetNotificationWnd() == NULL))
        {
            delete pCTrans;
            *ppCTrans = NULL;
            hr = E_FAIL;
        }
        else
        {
            // set the cbinding assosiated with it
            pCTrans->SetState(TransSt_Initialized);
            *ppCTrans = pCTrans;
            
            // pCTrans has refcount of 1 now
            // get the pUnkInner; pUnkInner does not addref pUnkOuter
            if (pUnkOuter && ppUnk)
            {
                *ppUnk = pCTrans->GetIUnkInner();
                // addref the outer object since releasing pCINet will go cause a release on pUnkOuter
                PProtAssert((*ppUnk));
            }
        }

    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    PerfDbgLog1(tagCTransaction, NULL, "-CTransaction::Create (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CTransaction::GetTransBindInfo
//
//  Synopsis:   Get the transaction bindinfo
//              Called to pass bindinfo on in IBSC::GetBindInfo and
//              also called by CINet
//
//  Arguments:
//
//  Returns:
//
//  History:    1-16-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BINDINFO *CTransaction::GetTransBindInfo()
{
    DEBUG_ENTER((DBG_TRANS,
                Pointer,
                "CTransaction::GetTransBindInfo",
                "this=%#x",
                this
                ));

    if (_pBndInfo == NULL)
    {
        _pBndInfo = new BINDINFO;

        if (_pBndInfo)
        {
            _pBndInfo->cbSize = sizeof(BINDINFO);
            _pBndInfo->szExtraInfo = 0;
            _pBndInfo->grfBindInfoF = 0;
        }
    }
    else
    {
        _pBndInfo->cbSize = sizeof(BINDINFO);
    }

    DEBUG_LEAVE(_pBndInfo);
    return _pBndInfo;
}


//+---------------------------------------------------------------------------
//
//  Method:     CTransaction::RestartOperation
//
//  Synopsis:   Starts the asycn transaction operation
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    12-07-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CTransaction::RestartOperation(LPWSTR pwzURL, DWORD dwCase)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CTransaction::RestartOperation",
                "this=%#x, %.80wq, %#x",
                this, pwzURL, dwCase
                ));
                
    PerfDbgLog(tagCTransaction, this, "+CTransaction::RestartOperation");

    HRESULT     hr = NOERROR;
    VDATETHIS(this);
    COInetSession *pCOInetSession = 0;
    IOInetProtocol *pProt = 0;

    DWORD dwLocation = 0;
    
    AddRef();

    do
    {

        if (GetState() == TransSt_OperationFinished)
        {
            hr = E_FAIL;
            break;
        }
        
        //
        // case: Start of Transaction
        //

        //TransAssert((_pClntProtSink == NULL));
        BOOL fFirstCreated = FALSE;

        if (dwCase != 0x00000001)
        {
            hr = E_INVALIDARG;
            break;
        }

        // We must have at least one node in the client request linked list
        TransAssert((_pClntProtSink != NULL));
        TransAssert((_pUnkInner == 0));
        TransAssert((_pProt));

        hr = QueryService(IID_IOInetProtocol, IID_IOInetProtocol ,(void **)&pProt);

        if (hr != NOERROR)
        {
            if ((hr = GetCOInetSession(0,&pCOInetSession,0)) == NOERROR)
            {
                DWORD dwOption = _fPreferDefaultHandler ? BINDF_PREFERDEFAULTHANDLER : 0;
                hr = pCOInetSession->CreateFirstProtocol(pwzURL, (IOInetBindInfo *) this, &_pUnkInner, &pProt, &_clsidProtocol, &dwLocation, dwOption);
                fFirstCreated = TRUE;
                if ((hr == NOERROR) && _pUnkInner)
                {
                    TransAssert((pProt));
                    pProt->Release();
                }
            }
        }
        else
        {
            // bugbug: find the correct cls id here.
            _clsidProtocol = CLSID_FtpProtocol;
        }

        if (hr != NOERROR)
        {
            TransAssert((!pProt && !_pUnkInner));
            pProt = 0;
            _pUnkInner = 0;
            break;
        }

        BOOL fNext;
        TransAssert((pProt));
        do  // loop over protocols
        {
            fNext = FALSE;
            TransAssert((hr == NOERROR));
            
            // Start the download operation
            TransAssert((pProt != NULL));
 
            {
                delete [] _pwzProtClsId;
                _pwzProtClsId =  0;

                HRESULT hr1 = StringFromCLSID(_clsidProtocol, &_pwzProtClsId);
                if (SUCCEEDED(hr1))
                {
                    _pClntProtSink->ReportProgress(BINDSTATUS_PROTOCOLCLASSID, _pwzProtClsId);
                }
            }

            SetState(TransSt_OperationStarted);


            if (_fProtEmbed)
            {
                _CProtEmbed.SetProtocol(pProt);
            }
            else
            {
                _pProt = pProt;
            }
            _fResultReported = FALSE;

            hr = pProt->Start(pwzURL, this, (IOInetBindInfo *)this, 0,0);

            if (hr == E_PENDING)
            {
                hr = NOERROR;
            }
            else if (hr == INET_E_USE_DEFAULT_PROTOCOLHANDLER)
            {
                fNext = TRUE;

                if (!_pUnkInner)
                {
                    pProt->Release();
                }

                if( _fProtEmbed )
                {
                    _CProtEmbed.SetProtocol(NULL);
                }

                pProt = 0;
                if (_pUnkInner)
                {
                    _pUnkInner->Release();
                    _pUnkInner = 0;
                }

                // bugbug: need to reset the protocol inside the embed protocol handler
                

                if (!fFirstCreated)
                {
                    DWORD dwOption = _fPreferDefaultHandler ? BINDF_PREFERDEFAULTHANDLER : 0;
                    hr = pCOInetSession->CreateFirstProtocol(pwzURL, (IOInetBindInfo *) this, &_pUnkInner, &pProt, &_clsidProtocol, &dwLocation, dwOption);
                    fFirstCreated = TRUE;
                }
                else
                {
                    hr = pCOInetSession->CreateNextProtocol(pwzURL, (IOInetBindInfo *) this, &_pUnkInner, &pProt, &_clsidProtocol, &dwLocation);
                }

                if (hr != NOERROR)
                {
                    TransAssert((!pProt && !_pUnkInner));
                    pProt = 0;
                    _pUnkInner = 0;
                    fNext = FALSE;

                }
                else if (_pUnkInner)
                {
                    // release the extra addref - aggregation
                    Release();
                }
            }
            else if (hr != NOERROR)
            {
                // do not allow pending packages be dispatched
                // any more
                fNext = FALSE;
                _fDispatch = TRUE;
                
                if (pProt)
                {
                    // Bug# 18869: If pwzURL ends up redirecting again (in other words, 
                    // a nested call to CTransaction::RestartOperation again), and the URL 
                    // redirected to errors out, Terminate() would be called within the 
                    // nested call. Now when the pProt->Start() method propogates that error
                    // from that nested call, and this section of code is hit again, _pClntProtSink
                    // has already been released (and nulled) by the nested CTransaction::RestartOperation.
                    // Alternatively, _fResultDispatched could be checked for TRUE:
                    if(_pClntProtSink)
                    {
                        if( hr == INET_E_REDIRECT_TO_DIR && _pwzRedirectUrl)
                        {
                            _pClntProtSink->ReportResult(hr, 0, _pwzRedirectUrl);
                        }
                        else
                        {
                            _pClntProtSink->ReportResult(_hrResult, _dwResult, 0);
                        }
                    }
                    _fResultDispatched = TRUE;
                    Terminate(0);
                }
            }

        } while  (fNext == TRUE);

        if (   (_dwOInetBdgFlags & PI_SYNCHRONOUS)
            && SUCCEEDED(hr) 
            && (_fModalLoopRunning == FALSE))
        {
            // complet the binding in case of sychronous bind
            TransAssert((_dwOInetBdgFlags & OIBDG_APARTMENTTHREADED));
            _fModalLoopRunning = TRUE;
            hr = CompleteOperation(_dwOInetBdgFlags & (BDGFLAGS_ATTACHED|BDGFLAGS_BTS_BTO));
            _fModalLoopRunning = FALSE;
        }
        
        break;
    } while (TRUE);

    if (pCOInetSession)
    {
        pCOInetSession->Release();
    }

    Release();

    PerfDbgLog1(tagCTransaction, this, "-CTransaction::RestartOperation (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//
// Create global security manager object on demand.
//
HRESULT EnsureSecurityManager ()
{
    if(g_pSecurityManager == NULL)
    {
        // Only 1 thread should be in here, this is to protect
        // global variable g_pSecurityManager
        CLock lck(g_mxsSession);

        if (g_pSecurityManager == NULL)
            return CoInternetCreateSecurityManager( NULL, &g_pSecurityManager, 0);
    }

    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Method:     CTransaction::Redirect
//
//  Synopsis:   creates a new cinet object
//
//  Arguments:  [szUrl] --
//
//  Returns:
//
//  History:    7-17-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CTransaction::Redirect(LPWSTR pwzUrl)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CTransaction::Redirect",
                "this=%#x, %.80wq",
                this, pwzUrl
                ));
                
    PerfDbgLog1(tagCTransaction, this, "+CTransaction::Redirect (szUrlL:%ws)", pwzUrl);
    HRESULT hr = NOERROR;

    TransAssert((pwzUrl != NULL));
    CLSID clsid;

    // Check to see if a non-"special" URL is redirecting to a "special" URL
    //
    if (!IsSpecialUrl(_pwzUrl)         // The original URL
        && IsSpecialUrl(pwzUrl))       // The redirected URL
    {
        // Check the registry workaround
        //
        static DWORD bAllowRedirectToScript = 2;

        if (bAllowRedirectToScript == 2)
        {
            // Read the key and set the static
            BOOL fDefault = FALSE;
            DWORD dwSize = sizeof(DWORD);
            
            SHRegGetUSValue(
                    "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Internet Settings",
                    "AllowRedirectToScript", 
                    NULL, 
                    (LPBYTE) &bAllowRedirectToScript, 
                    &dwSize, 
                    FALSE, 
                    (LPVOID) &fDefault, 
                    sizeof(fDefault));
        }

        // If it's not allowed, abort the transaction
        //
        if (!bAllowRedirectToScript)
        {
            // Can't redirect to a scripting URL.
            //
            hr = E_ACCESSDENIED;
        }
    }

    // NOTICE-2002/03/04-ganeshs - NTRAID#NTBUG9-556240 - Security: Block redirects to local machine
    // 
    if(SUCCEEDED(hr) && SUCCEEDED(hr = EnsureSecurityManager()))
    {
        // Set conservative defaults:
        DWORD dwZoneIDSource = URLZONE_UNTRUSTED;
        DWORD dwZoneIDTarget = URLZONE_LOCAL_MACHINE;

        if (SUCCEEDED(hr = g_pSecurityManager->MapUrlToZone(pwzUrl, &dwZoneIDTarget, 0))
            && (dwZoneIDTarget == URLZONE_LOCAL_MACHINE) 
            && (SUCCEEDED(hr = g_pSecurityManager->MapUrlToZone(_pwzUrl, &dwZoneIDSource, 0))))
        {

            if (dwZoneIDSource != URLZONE_LOCAL_MACHINE 
                && dwZoneIDSource != URLZONE_INTRANET 
                && dwZoneIDSource != URLZONE_TRUSTED) 
            {
                // Block redirect:
                hr = E_ACCESSDENIED;
            }
        }
    }

    if(!SUCCEEDED(hr))
    {
        Abort(hr, 0);
    }
    else
    {
        {
            COInetSession *pCOInetSession = 0;
            if ((hr = GetCOInetSession(0,&pCOInetSession,0)) == NOERROR)
            {
                hr = pCOInetSession->FindOInetProtocolClsID(pwzUrl, &clsid);
                pCOInetSession->Release();
            }
        }

        if (hr == NOERROR)
        {
            //
            // remove remaining packages from the queue
            //
            {
                CTransPacket *pCTP = 0;

                while ((pCTP = GetNextCTransPacket()) != NULL)
                {
                    // delete the data now
                    delete pCTP;
                }
            }

            IOInetProtocol *pCINetOld = _pProt;

            if (_pInetInfo && !_pUnkInner)
            {
                _pInetInfo->Release();
            }
            _pInetInfo = NULL;

            if (_pInetHttpInfo && !_pUnkInner)
            {
                _pInetHttpInfo->Release();
            }
            _pInetHttpInfo = NULL;

            //
            // no post on redirect
            if (_pBndInfo && (_pBndInfo->dwBindVerb == BINDVERB_POST))
            {
                _pBndInfo->dwBindVerb = BINDVERB_GET;
            }
            if (_fProtEmbed)
            {
                IOInetProtocol *pProt = 0;

                hr = _CProtEmbed.GetProtocol(&pProt);
                if (hr == NOERROR)
                {
                    pProt->Terminate(0);
                    pProt->Release();
                }
                _CProtEmbed.SetProtocol(0);
                if (_pUnkInner)
                {
                    //PerfDbgLog2(tagCTransaction, this, "+CTransaction::~CTransaction Nulling (pCINet:%lx, hServer:%lx)", _pProt, _pProt->_hServer);
                    _pUnkInner->Release();
                    _pUnkInner = NULL;
                }
            }
            else
            {
                _pProt->Terminate(0);

                if (_pProt && !_pUnkInner)
                {
                    //PerfDbgLog2(tagCTransaction, this, "+CTransaction::~CTransaction Nulling (pCINet:%lx, hServer:%lx)", _pProt, _pProt->_hServer);
                    _pProt->Release();
                }
                _pProt = NULL;

                if (_pUnkInner)
                {
                    //PerfDbgLog2(tagCTransaction, this, "+CTransaction::~CTransaction Nulling (pCINet:%lx, hServer:%lx)", _pProt, _pProt->_hServer);
                    _pUnkInner->Release();
                    _pUnkInner = NULL;
                }
            }
            
            SetState(TransSt_Initialized);
            hr = RestartOperation(pwzUrl,0x00000001);
             
        }
    }

    PerfDbgLog1(tagCTransaction, this, "-CTransaction::Redirect(hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CTransaction::AddClientOInet
//
//  Synopsis:   Adds clients OInet interfaces.
//
//  Arguments:  [pCBdg] --
//
//  Returns:
//
//  History:
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CTransaction::AddClientOInet(IOInetProtocolSink *pOInetProtSink, IOInetBindInfo *pOInetBindInfo)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CTransaction::AddClientOInet",
                "this=%#x, %#x, %#x",
                this, pOInetProtSink, pOInetBindInfo
                ));
                
    PerfDbgLog2(tagCTransaction, this, "+CTransaction::AddClientOInet, pProtocolSink:%lx, pBindInfo:%lx", pOInetProtSink, pOInetBindInfo);

    TransAssert((pOInetProtSink && pOInetBindInfo));
    
    RemoveClientOInet();

    if (_fProtEmbed)
    {
        _CProtEmbed.SetProtocolSink(pOInetProtSink);
        _pClntProtSink = &_CProtEmbed;
        _cBdgRefs++;
    }
    else
    {
        _cBdgRefs++;
        _pClntProtSink = pOInetProtSink;
        pOInetProtSink->AddRef();
    }
    
    _pClntBindInfo = pOInetBindInfo;
    pOInetBindInfo->AddRef();

    PerfDbgLog(tagCTransaction, this, "-CTransaction::AddClientOInet");

    DEBUG_LEAVE(NOERROR);
    return NOERROR;
}

//+---------------------------------------------------------------------------
//
//  Method:     CTransaction::RemoveClientOInet
//
//  Synopsis:   Removes OInetProtocolSink and OInetBindInfo interfaces. 
//
//  Arguments:  
//
//  Returns:
//
//  History:    2-02-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CTransaction::RemoveClientOInet()
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CTransaction::RemoveClientOInet",
                "this=%#x",
                this
                ));
                
    PerfDbgLog1(tagCTransaction, this, "+CTransaction::RemoveClientOInet _pClntProtSink:%lx", _pClntProtSink);
    HRESULT hr = NOERROR;
    BOOL fRelease = FALSE;

    if (_fProtEmbed && _cBdgRefs)
    {
        _CProtEmbed.SetProtocolSink(0);
        _CProtEmbed.SetServiceProvider(0);
        _pClntProtSink = 0;
        _cBdgRefs--;
    }
    else if (_pClntProtSink)
    {
        _pClntProtSink->Release();
        _pClntProtSink = 0;
        _cBdgRefs--;
        fRelease = TRUE;
    }
    
    if (_pClntBindInfo)
    {
        _pClntBindInfo->Release();
        _pClntBindInfo = 0;
    }

    TransAssert((_pClntProtSink == 0 && _cBdgRefs == 0));

    hr = (fRelease) ? S_OK : S_FALSE;

    PerfDbgLog2(tagCTransaction, this, "-CTransaction::RemoveClientOInet (_pClntProtSink:%lx, hr:%lx)", _pClntProtSink, hr);

    DEBUG_LEAVE(hr);
    return hr;
}

#if 0
//+---------------------------------------------------------------------------
//
//  Method:     CTransaction::RemoveAllCBindings
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    2-02-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CTransaction::RemoveAllCBindings()
{
    PerfDbgLog(tagCTransaction, this, "+CTransaction::RemoveAllCBindings");
    HRESULT hr = NOERROR;
    CBinding *pCBdg;
    CBinding *pCBdgNext;

    TransAssert((_pClntProtSink == 0 &&    _cBdgRefs == 0));
    /*
    
    TransAssert((   (_cBdgRefs == 0 && _pClntProtSink == NULL)
                 || (_cBdgRefs != 0 && _pClntProtSink != NULL) ));

    if (_pClntProtSink)
    {
        _pClntProtSink->Release();
        _pClntProtSink = 0;
        _cBdgRefs--;

    }

    // the list should be empty now
    DbgLog1(tagCTransaction, this, "=== CTransaction::RemoveAllCBindings Removing transaction, cRefs:%ld", _cBdgRefs);
    TransAssert((_cBdgRefs == 0));
    TransAssert((_pCTransMgr));

    // remove the transaction if no cbindings left
    //_pCTransMgr->RemoveTransaction(this);
    //_pCTransMgr = NULL;

    _pClntProtSink = NULL;
    */
    
    PerfDbgLog(tagCTransaction, this, "-CTransaction::RemoveAllCBindings");
    return hr;
}
#endif // 0
//+---------------------------------------------------------------------------
//
//  Method:     CTransaction::MyPeekMessage
//
//  Synopsis:   This function is called whenever we want to do a PeekMessage.
//              It has special handling for WM_QUIT messages.
//
//  Arguments:  [pMsg] - message structure
//              [hWnd] - window to peek on
//              [min/max] - min and max message numbers
//              [wFlag] - peek flags
//
//  Returns:    TRUE  - a message is available
//              FALSE - no messages available
//
//  Algorithm:
//
//  History:    7-26-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CTransaction::MyPeekMessage(MSG *pMsg, HWND hwnd, UINT min, UINT max, WORD wFlag)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CTransaction::MyPeekMessage",
                "this=%#x, %#x, %#x, %#x, %#x, %#x",
                this, pMsg, hwnd, min, max, wFlag
                ));
                
    HRESULT hr = S_OK;
    BOOL fRet = PeekMessage(pMsg, hwnd, min, max, wFlag);
    if (fRet)
    {
        PerfDbgLog3(tagCTransaction, this, "MyPeekMessage: hwnd:%#x, msg:%#x time:%#x", pMsg->hwnd, pMsg->message, pMsg->time);
        if (pMsg->message == WM_QUIT)
        {
            PostQuitMessage((int)pMsg->wParam);
            hr  = S_FALSE;
        }
    }
    else
    {
        hr = E_FAIL;
    }

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CTransaction::CompleteOperation
//
//  Synopsis:   Simple modal loop
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    12-13-95   JohannP (Johann Posch)   Created
//
//  Notes:      BUGBUG: NOT COMPLETE YET!
//
//----------------------------------------------------------------------------
HRESULT CTransaction::CompleteOperation(BOOL fNested)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CTransaction::CompleteOperation",
                "this=%#x, %B",
                this, fNested
                ));
                
    PerfDbgLog(tagCTransaction, this, "+CTransaction::CompleteOperation");

    MSG msg;
    HRESULT hr = NO_ERROR;

    CUrlMkTls tls(hr);
    LONG cDispatchLevel;
    BOOL fDispatch = _fDispatch;

    if (hr == NOERROR)
    {
        HRESULT hr1 = NOERROR;
        HRESULT hrPeek;

        CModalLoop MsgFlter(&hr1);

        AddRef();
        cDispatchLevel = tls->cDispatchLevel;

        TransAssert((cDispatchLevel >= 0));
        tls->cDispatchLevel++;

        if (fNested)
        {
            fDispatch = _fDispatch;
            _fDispatch = FALSE;
        }

        // run the modal loop in case we have a IMessageFilter
        if (hr1 == NOERROR)
        {
            DWORD dwWakeReason = WAIT_TIMEOUT;
            DWORD dwInput = QS_ALLINPUT;
            DWORD dwWaitTime = 1000;
            DWORD dwIBSCLevel = (tls->cDispatchLevel > 1)
                                    ? IBSCLEVEL_TOPLEVEL : IBSCLEVEL_NESTED;

            while (GetState() != TransSt_OperationFinished)
            {
                dwWakeReason = MsgWaitForMultipleObjects(0, 0, FALSE, dwWaitTime, dwInput);

                if (   (dwWakeReason == (WAIT_OBJECT_0 + 0))
                    || (dwWakeReason == WAIT_TIMEOUT))
                {
                    DWORD dwStatus = GetQueueStatus(QS_ALLINPUT);


                    // some messages are in the queue
                    if (dwStatus)
                    {

                        while ((hrPeek = MyPeekMessage(&msg, _hwndNotify, WM_USER, WM_TRANS_LAST, PM_REMOVE | PM_NOYIELD)) == S_OK)
                        {
                            TranslateMessage(&msg);
                            DispatchMessage(&msg);
                        }
                        if (hrPeek == S_FALSE)
                        {
                            hr  = S_FALSE;
                            goto End;
                        }
                        // call MessagePending on
                        MsgFlter.HandlePendingMessage(dwStatus,cDispatchLevel,0);

                    }
                }
            }
        }
        else
        {
            // just run a dispatch loop for our own messages
            while (GetState() != TransSt_OperationFinished)
            {
                // wake up every 5 seconds
                // this is needed since our msg might be dispatched somewhere else
                // on the stack inside the protocol
                DWORD dwWaitTime = 5000;
                //changed QS_ALLINPUT to QS_POSTMESSAGE so that we wake up only for new posted messages.
                //QS_ALLINPUT was making us return as soon as there were any messges in the queue.
                //Ideally, we only want to wait for posted messages for the _hwndNotify handle in the WM_USER
                //to WM_TRANS_LAST range.
                DWORD dwWakeReason = MsgWaitForMultipleObjects(0, 0, FALSE, dwWaitTime, QS_POSTMESSAGE);


                if (dwWakeReason == (WAIT_OBJECT_0 + 0))
                {
                    while ((hrPeek = MyPeekMessage(&msg, _hwndNotify, WM_USER, WM_TRANS_LAST, PM_REMOVE | PM_NOYIELD)) == S_OK)
                    {
                        TranslateMessage(&msg);
                        DispatchMessage(&msg);
                    }
                    if (hrPeek == S_FALSE)
                    {
                        hr  = S_FALSE;
                        goto End;
                    }
                }
                else if (dwWakeReason == WAIT_TIMEOUT)
                {
                    // nothing to do here
                }
            }
        }

        hr = GetHResult();

        //
        // dispatch all the other notification messages
        //
        while ((hrPeek = MyPeekMessage(&msg, _hwndNotify, WM_USER, WM_TRANS_LAST, PM_REMOVE | PM_NOYIELD)) == S_OK)
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }

    End:
        if (fNested)
        {
            _fDispatch = fDispatch;
        }

        // reset the dispatch level
        tls->cDispatchLevel--;
        Release();
    }

    PerfDbgLog1(tagCTransaction, this, "-CTransaction::CompleteOperation (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CTransaction::PrepareThreadTransfer
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    10-09-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CTransaction::PrepareThreadTransfer()
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CTransaction::PrepareThreadTransfer",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCTransaction, this, "+CTransaction::PrepareThreadTransfer");
    TransAssert(( IsApartmentThread() ));
    TransAssert((_ThreadTransferState == TS_None));

    HRESULT hr = E_OUTOFMEMORY;

    if (   _ThreadTransferState == TS_None
        && _pCTPCur)
    {
        // make a copy of the current packet
        // this packet will be send to the new
        // thread once the transfer completed

        _pCTPTransfer = new CTransPacket( (BINDSTATUS) BINDSTATUS_INTERNAL);

        if (_pCTPTransfer)
        {
            hr = NOERROR;
            *_pCTPTransfer = *_pCTPCur;

            _ThreadTransferState = TS_Prepared;

            if (_pProt)
            {
                IOInetThreadSwitch *pOInetThS;
                HRESULT hr1 = _pProt->QueryInterface(IID_IOInetThreadSwitch,(void **) &pOInetThS);

                if (hr1 == NOERROR)
                {
                    TransAssert((pOInetThS));
                    pOInetThS->Prepare();
                    pOInetThS->Release();
                }
            }
        }
    }

    PerfDbgLog(tagCTransaction, this, "-CTransaction::PrepareThreadTransfer");

    DEBUG_LEAVE(hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CTransaction::ThreadTransfer
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    10-09-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CTransaction::ThreadTransfer()
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CTransaction::ThreadTransfer",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCTransaction, this, "+CTransaction::ThreadTransfer");
    TransAssert(( !IsApartmentThread() ));
    TransAssert((_ThreadTransferState == TS_Prepared));

    HRESULT hr = NOERROR;

    if (_ThreadTransferState == TS_Prepared)
    {
        _hwndNotify = GetThreadNotificationWnd();

        // check the threadID and set the new window
        _dwThreadId = GetCurrentThreadId();

        _ThreadTransferState = TS_Completed;
        TransAssert((_pCTPTransfer));
        if (_pCTPTransfer)
        {
            CTransPacket *pCTP = _pCTPTransfer;
            #if DBG==1
                DWORD dwCurrentSizePerf = pCTP->_dwCurrentSize;
                DWORD dwTotalSizePerf = pCTP->_dwTotalSize;
            #elif defined(PERFTAGS)
                DWORD dwCurrentSizePerf = pCTP->_dwCurrentSize;
                DWORD dwTotalSizePerf = pCTP->_dwTotalSize;
            #endif
            _pCTPTransfer = NULL;

            AddCTransPacket(pCTP, FALSE);
            {
                _cPostedMsg++;
                AddRef();
                PerfDbgLog4(tagCTransaction, this, "CINet:%lx === CTransaction::ThreadTransfer (Msg:%#x) WM_TRANS_PACKET - dwCurrentSize:%ld, dwTotalSize:%ld",
                    _pProt, XDBG(++_wTotalPostedMsg,0), dwCurrentSizePerf, dwTotalSizePerf);
                #if DBG==1
                PostMessage(_hwndNotify, WM_TRANS_PACKET, (WPARAM)_wTotalPostedMsg, (LPARAM)this);
                #else
                PostMessage(_hwndNotify, WM_TRANS_PACKET, (WPARAM) 0, (LPARAM)this);
                #endif

            }
            {
                IOInetThreadSwitch *pOInetThS;
                HRESULT hr1 =_pProt->QueryInterface(IID_IOInetThreadSwitch,(void **) &pOInetThS);

                if (hr1 == NOERROR)
                {
                    TransAssert((pOInetThS));
                    pOInetThS->Continue();
                    pOInetThS->Release();
                }
            }
        }
    }

    PerfDbgLog(tagCTransaction, this, "-CTransaction::ThreadTransfer");

    DEBUG_LEAVE(hr);
    return hr;
}

/* this code path valid only for Trident BTS -> Shdocvw BTO */
void CTransaction::ResumeDispatchingPackets()
{
    DEBUG_ENTER((DBG_TRANS,
                None,
                "CTransaction::ResumeDispatchingPackets",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCTransaction, this, "+CTransaction::ResumeReadingPackets");
    TransAssert(( IsApartmentThread() ));

    TransAssert((_pCTPTransfer));
    if (_pCTPTransfer)
    {
        CTransPacket *pCTP = _pCTPTransfer;
        #if DBG==1
            DWORD dwCurrentSizePerf = pCTP->_dwCurrentSize;
            DWORD dwTotalSizePerf = pCTP->_dwTotalSize;
        #elif defined(PERFTAGS)
            DWORD dwCurrentSizePerf = pCTP->_dwCurrentSize;
            DWORD dwTotalSizePerf = pCTP->_dwTotalSize;
        #endif
        _pCTPTransfer = NULL;

        AddCTransPacket(pCTP, FALSE);
        
        // report AcceptRanges and ContentDispositionAttach.       
        {
            CTransPacket *pCTP;
            
            if (_fAcceptRanges)
            {
                pCTP = new CTransPacket( 
                    BINDSTATUS_ACCEPTRANGES, NOERROR, NULL, _ulCurrentSize, _ulTotalSize);
                if (pCTP)
                    AddCTransPacket(pCTP, FALSE);
            }

            if (_fContentDispositionAttach)
            {
                pCTP = new CTransPacket( 
                    BINDSTATUS_CONTENTDISPOSITIONATTACH, NOERROR, (_pwzFileName?_pwzFileName:_pwzAttachmentName), _ulCurrentSize, _ulTotalSize);
                if (pCTP)
                    AddCTransPacket(pCTP, FALSE);
            }
        }
        
        
        _fDispatch = FALSE;
        {
            _cPostedMsg++;
            AddRef();
            PerfDbgLog4(tagCTransaction, this, "CINet:%lx === CTransaction::ThreadTransfer (Msg:%#x) WM_TRANS_PACKET - dwCurrentSize:%ld, dwTotalSize:%ld",
                _pProt, XDBG(++_wTotalPostedMsg,0), dwCurrentSizePerf, dwTotalSizePerf);
            #if DBG==1
            PostMessage(_hwndNotify, WM_TRANS_PACKET, (WPARAM)_wTotalPostedMsg, (LPARAM)this);
            #else
            PostMessage(_hwndNotify, WM_TRANS_PACKET, (WPARAM) 0, (LPARAM)this);
            #endif

        }
    }
    
    PerfDbgLog(tagCTransaction, this, "-CTransaction::ResumeDispatchingPackets");

    DEBUG_LEAVE(0);
    return;
}

/* this code path valid only for Trident BTS -> Shdocvw BTO */
void CTransaction::SuspendDispatchingPackets(CTransPacket* pCTP)
{
    DEBUG_ENTER((DBG_TRANS,
                None,
                "CTransaction::SuspendDispatchingPackets",
                "this=%#x",
                this
                ));
                
    _pCTPTransfer = new CTransPacket( (BINDSTATUS) BINDSTATUS_INTERNAL);

    if (_pCTPTransfer)
        *_pCTPTransfer = *pCTP;

    DEBUG_LEAVE(0);
    return;
}

#ifdef UNUSED
//+---------------------------------------------------------------------------
//
//  Method:     CTransaction::TransmitPaket
//
//  Synopsis:
//
//  Arguments:  [uiMsg] --
//              [pdld] --
//
//  Returns:
//
//  History:    12-08-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CTransaction::TransmitPacket(BINDSTATUS NMsg, CINet * pCINet, LPCWSTR szStr,DWORD cbAvailable, DWORD cbTotal)
{
    PerfDbgLog(tagCTransaction, this, "+CTransaction::TransmitPacket");

    HRESULT hr = NOERROR;

    _dwPacketsTotal++;

    CTransPacket *pCTP = new CTransPacket(NMsg, NOERROR, szStr,cbAvailable,cbTotal);

    if (pCTP)
    {
    #if DBG==1
        DWORD dwCurrentSizePerf = pCTP->_dwCurrentSize;
        DWORD dwTotalSizePerf = pCTP->_dwTotalSize;
    #elif defined(PERFTAGS)
        DWORD dwCurrentSizePerf = pCTP->_dwCurrentSize;
        DWORD dwTotalSizePerf = pCTP->_dwTotalSize;
    #endif
        if (cbAvailable)
        {
            pCTP->_dwCurrentSize = cbAvailable;
        }
        if (cbTotal)
        {
            pCTP->_dwTotalSize = cbTotal;
        }

        AddCTransPacket(pCTP);

        if ( pCTP->IsLastNotMsg() || !IsApartmentThread() ||  pCTP->IsAsyncNotMsg() )
        {
            _cPostedMsg++;
            AddRef();
            PerfDbgLog4(tagCTransaction, this, "CINet:%lx === CTransaction::TransmitPacket (Msg:%#x) WM_TRANS_PACKET - dwCurrentSize:%ld, dwTotalSize:%ld",
                _pProt, XDBG(++_wTotalPostedMsg,0), dwCurrentSizePerf, dwTotalSizePerf);
            #if DBG==1
            PostMessage(_hwndNotify, WM_TRANS_PACKET, (WPARAM)_wTotalPostedMsg, (LPARAM)this);
            #else
            PostMessage(_hwndNotify, WM_TRANS_PACKET, (WPARAM) 0, (LPARAM)this);
            #endif

        }
        else
        {
            OnINetCallback();
        }

    }
    else
    {
        // post message indicating the packet could not be allocated
        PostMessage(_hwndNotify, WM_TRANS_OUTOFMEMORY, (WPARAM)NULL, (LPARAM)this);
        hr = E_OUTOFMEMORY;
    }

    PerfDbgLog(tagCTransaction, this, "-CTransaction::TransmitPacket");
    return hr;
}
#endif //UNUSED

//+---------------------------------------------------------------------------
//
//  Method:     CTransaction::DispatchReport
//
//  Synopsis:
//
//  Arguments:  [NotMsg] --
//              [grfBSCF] --
//              [dwCurrentSize] --
//              [dwTotalSize] --
//              [pwzStr] --
//              [dwError] --
//              [hrReport] --
//
//  Returns:
//
//  History:    4-15-1997   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CTransaction::DispatchReport(BINDSTATUS NotMsg, DWORD grfBSCF, DWORD dwCurrentSize, DWORD dwTotalSize, LPCWSTR pwzStr, DWORD dwError, HRESULT hresult)
                                               
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CTransaction::DispatchReport",
                "this=%#x, %#x, %#x, %#x, %#x, %.80wq, %#x, %#x",
                this, NotMsg, grfBSCF, dwCurrentSize, dwTotalSize, pwzStr, dwError, hresult
                ));
                
    PerfDbgLog1(tagCTransaction, this, "+CTransaction::DispatchReport [NotMsg:%lx]", NotMsg);
    HRESULT hr = NOERROR;
    IOInetProtocolSink *pCBdg = _pClntProtSink;
    static const WCHAR *wzClsStr = L"Class Install Handler ";

    if (_fTerminated || !_pClntProtSink)
    {
        // nothing to do
        if (   !_fTerminated
            && (   (BINDSTATUS_RESULT == NotMsg)
                || (BINDSTATUS_ERROR == NotMsg)) )
        {
           _fResultDispatched =  TRUE;
           Terminate(0);
        }
    }
    else
    {
        // clean out the old transfer state
        //
        if (_ThreadTransferState == TS_Completed)
        {
            _ThreadTransferState = TS_None;
        }

        switch (NotMsg)
        {
        case BINDSTATUS_BEGINDOWNLOADDATA:
            if (_dwOInetBdgFlags & PI_DATAPROGRESS)
            {
                pCBdg->ReportProgress(NotMsg, pwzStr);
            }
        case BINDSTATUS_DOWNLOADINGDATA:
        case BINDSTATUS_ENDDOWNLOADDATA:
        {
            //
            // check amount of data an verify mime is requested
            //
            if (OnDataReceived(&grfBSCF, &dwCurrentSize, &dwTotalSize) == NOERROR)
            {
                if (   (NotMsg == BINDSTATUS_ENDDOWNLOADDATA)
                    && (_dwOInetBdgFlags & PI_DATAPROGRESS))
                {
                    pCBdg->ReportProgress(NotMsg, pwzStr);
                }
                hr = pCBdg->ReportData(grfBSCF, dwCurrentSize, dwTotalSize);
            }
        }
        break;
        case BINDSTATUS_REDIRECTING     :
        {
            // report the progress on the redirect url
            TransAssert((pwzStr));
            hr = pCBdg->ReportProgress(NotMsg, pwzStr);
            SetRedirectUrl((LPWSTR)pwzStr);
        }
        break;
        case BINDSTATUS_RESULT:
        case BINDSTATUS_ERROR:
        {
            if (   (hresult == INET_E_REDIRECTING)
                && (pwzStr))
            {
                // Note: it is legal here NOT to have a redirect url
                // if wininet does redirct and it fails it  will reprot this error.
                
                // report progress on redirect and to the redirect
                hr = pCBdg->ReportProgress(BINDSTATUS_REDIRECTING, pwzStr);
                SetRedirectUrl((LPWSTR)pwzStr);
                hr = Redirect((LPWSTR)pwzStr);
                if (   (hr != NOERROR) 
                    && (hr != E_PENDING)
                    && !_fResultDispatched)
                {
                    _fResultDispatched = TRUE;
                    hr = pCBdg->ReportResult(hr, 0, 0);
                }
            }
            else
            {
                _fResultDispatched = TRUE;
                hr = pCBdg->ReportResult(_hrResult, _dwResult, pwzStr);
            }
            
        }
        break;

        case BINDSTATUS_ENCODING:
        {
            /****
            // load the encode filter here
            TransAssert((pwzStr));

            if (_fEncodingHandlerEnabled && pwzStr)
            {
                  // disable data sniff on _CProtEmbed
                  DWORD dwEmbedBndFlags = _CProtEmbed.GetOInetBindFlags();
                  dwEmbedBndFlags &= (~PI_MIMEVERIFICATION & ~PI_DOCFILECLSIDLOOKUP & ~PI_CLASSINSTALL);
                  _CProtEmbed.SetOInetBindFlags(dwEmbedBndFlags);
                 _CProtEncoding.Initialize(this, 0, PP_PRE_SWITCH, _dwOInetBdgFlags, 0, _pProt, _pClntProtSink, 0);
                //hr = LoadHandler(pwzStr, &_CProtEncoding, 0);
                LoadHandler(pwzStr, &_CProtEncoding, 0);
            }
            ***/
        }
        break;

        case BINDSTATUS_CLASSINSTALLLOCATION:
            TransAssert((pwzStr));
            if (_fClsInstallerHandlerEnabled && pwzStr)
            {
                _CProtClsInstaller.Initialize(this, 0, PP_PRE_SWITCH, _dwOInetBdgFlags, 0, _pProt, _pClntProtSink, 0);
                LPWSTR pwzClsURL = 0;
                
                pwzClsURL = new WCHAR[lstrlenW(_pwzUrl) + lstrlenW(pwzStr) + lstrlenW(wzClsStr) + 2]; // +1 for NULL, +1 for another NULL after _pwzUrl

                if (pwzClsURL)
                {
                    StrCpyW(pwzClsURL, wzClsStr);

                    StrCatW(pwzClsURL, _pwzUrl);
                    StrCatW(pwzClsURL, L" ");
                    StrCatW(pwzClsURL, pwzStr);

                    pwzClsURL[lstrlenW(wzClsStr) - 1] = L'\0';
                    pwzClsURL[lstrlenW(_pwzUrl) + lstrlenW(wzClsStr)] = L'\0';
                    
                    hr = LoadHandler(pwzClsURL, &_CProtClsInstaller, 0);
                
                    delete [] pwzClsURL;
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
            }

            // tell sink to stop waiting on handler (since we're broken)
            if (FAILED(hr))
            {   
                pCBdg->ReportProgress(BINDSTATUS_ENDDOWNLOADCOMPONENTS,NULL);   
            }

        break;

        case BINDSTATUS_CLASSIDAVAILABLE:
            TransAssert((pwzStr));
            hr = pCBdg->ReportProgress(NotMsg, pwzStr);
        break;
        
        case BINDSTATUS_MIMETYPEAVAILABLE:
            TransAssert((pwzStr));
            if ( _fMimeHandlerEnabled && pwzStr && _fProtEmbed && 
                 !_fMimeHandlerLoaded)
            {
                //
                // load a mime filter with the embedded prot class
                if( StrCmpNIW( pwzStr, L"text/html", 9) )
                {
                    hr = LoadHandler(pwzStr, &_CProtEmbed, 0);
                    if (hr == NOERROR)
                    {
                        pCBdg->ReportProgress(BINDSTATUS_LOADINGMIMEHANDLER, NULL);
                        _fMimeHandlerLoaded = TRUE;
                    }
                }
                else
                {
                    //
                    // special treatment for text/html to speed up the
                    // main IE download path 
                    //
                    if(g_bHasMimeHandlerForTextHtml)
                    {
                        hr = LoadHandler(pwzStr, &_CProtEmbed, 0);
                        if (hr == NOERROR)
                        {
                            pCBdg->ReportProgress(BINDSTATUS_LOADINGMIMEHANDLER, NULL);
                            _fMimeHandlerLoaded = TRUE;
                        }
                        else
                        {
                            // to account for cases where the mime type has additional
                            // attribute=value pairs after text/html.  
                            // ( RFC for HTTP 1.1 provides for this. )
                            // eg. Content-Type: text/html; charset=ISO-8859-4
                            if ( StrCmpNIW(pwzStr, L"text/html;", 10) )                            
                                g_bHasMimeHandlerForTextHtml = FALSE;
                            else
                            {
                                hr = LoadHandler(L"text/html", &_CProtEmbed, 0);
                                if (hr == NOERROR)
                                {
                                    pCBdg->ReportProgress(BINDSTATUS_LOADINGMIMEHANDLER, NULL);
                                    _fMimeHandlerLoaded = TRUE;
                                }
                                else
                                    g_bHasMimeHandlerForTextHtml = FALSE;
                            }
                        }
                    }
                    
                }

            }

            if (_dwOInetBdgFlags & (PI_MIMEVERIFICATION | PI_DOCFILECLSIDLOOKUP))
            {
                // report the mime later after sniffing data
                _pwzMimeSuggested = OLESTRDuplicate((LPWSTR)pwzStr);
            }
            else
            {
                hr = pCBdg->ReportProgress(NotMsg, pwzStr);
            }

        break;

        case BINDSTATUS_VERIFIEDMIMETYPEAVAILABLE:
        {
            TransAssert((pwzStr));
            if (_fMimeHandlerEnabled && pwzStr && _fProtEmbed && !_fMimeHandlerLoaded)
            {
                // load a mime filter with the embedded prot class
                hr = LoadHandler(pwzStr, &_CProtEmbed, 0);
                if (hr == NOERROR)
                {
                    pCBdg->ReportProgress(BINDSTATUS_LOADINGMIMEHANDLER, NULL);
                    _fMimeHandlerLoaded = TRUE;
                }

            }

            // disable datasniff on _CProtEmbed so we are able to pass through
            DWORD dwEmbedBndFlags = _CProtEmbed.GetOInetBindFlags();
            dwEmbedBndFlags &= (~PI_MIMEVERIFICATION &~PI_DOCFILECLSIDLOOKUP &~PI_CLASSINSTALL);
            _CProtEmbed.SetOInetBindFlags(dwEmbedBndFlags);

            // the mime filter may already updated the mime type
            // if we are already verified, then ignore this one
            if( _fMimeHandlerLoaded && _fMimeVerified && _pwzMimeSuggested )
            {
                hr = pCBdg->ReportProgress( 
                    BINDSTATUS_MIMETYPEAVAILABLE, _pwzMimeSuggested);
            }
            else
            {
                _pwzMimeSuggested = OLESTRDuplicate((LPWSTR)pwzStr);
                _fMimeVerified = TRUE;

                // we should only report BINDSTATUS_MIMETYPEAVAILABLE 
                // (BINDSTATUS_VERIFIEDMIMETYPEAVAILABLE stops at here)
                hr = pCBdg->ReportProgress(BINDSTATUS_MIMETYPEAVAILABLE, pwzStr);
            }
        }    
        break;

        case BINDSTATUS_CACHEFILENAMEAVAILABLE :
            TransAssert((pwzStr));
            if (_pwzFileName)
                delete [] _pwzFileName;
            _pwzFileName = OLESTRDuplicate((LPWSTR)pwzStr);
            hr = pCBdg->ReportProgress(NotMsg, pwzStr);
            break;

        case BINDSTATUS_CONTENTDISPOSITIONATTACH:
            _fContentDispositionAttach = TRUE;
            if (_pwzAttachmentName)
                delete [] _pwzAttachmentName;
            if (pwzStr)
                _pwzAttachmentName = OLESTRDuplicate((LPWSTR)pwzStr);
            else
                _pwzAttachmentName = NULL;
            hr = pCBdg->ReportProgress(NotMsg, pwzStr);
            break;
            
        case BINDSTATUS_ACCEPTRANGES:
            _fAcceptRanges = TRUE;
            hr = pCBdg->ReportProgress(NotMsg, pwzStr);
            break;
            
        default:
        {
            hr = pCBdg->ReportProgress(NotMsg, pwzStr);
        }

        } // end switch
    }

    PerfDbgLog1(tagCTransaction, this, "-CTransaction::DispatchReport (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

STDMETHODIMP CTransaction::PreDispatch()
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CTransaction::PreDispatch",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCTransaction, this, "+CTransaction::PreDispatch");
    HRESULT hr = S_OK;

    {   // single access block
        CLock lck(_mxsBind);
        if (_fTerminated || _fTerminating)
        {
            hr = S_FALSE;
        }
        else
        {
            _dwDispatchLevel++;
        }
    }
    
    PerfDbgLog1(tagCTransaction, this, "-CTransaction::PreDispatch (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

STDMETHODIMP CTransaction::PostDispatch()
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CTransaction::PostDispatch",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCTransaction, this, "+CTransaction::PostDispatch");
    HRESULT hr = NOERROR;
    BOOL fCallTerminate = FALSE;


    {   // single access block
        CLock lck(_mxsBind);
        _dwDispatchLevel--;
        fCallTerminate = _fReceivedTerminate;
        _fReceivedTerminate = FALSE;
    }

    if (fCallTerminate)
    {
        Terminate(_dwTerminateOptions);
    }

    PerfDbgLog1(tagCTransaction, this, "-CTransaction::PostDispatch (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CTransaction::DispatchPacket
//
//  Synopsis:
//
//  Arguments:  [pCTPIn] --
//
//  Returns:
//
//  History:    2-02-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CTransaction::DispatchPacket(CTransPacket *pCTPIn)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CTransaction::DispatchPacket",
                "this=%#x, %#x",
                this, pCTPIn
                ));
                
    PerfDbgLog2(tagCTransaction, this, "+CTransaction::DispatchPacket [pCTPIn:%lx, NotMsg:%lx]", pCTPIn, pCTPIn->GetNotMsg());
    HRESULT hr = NOERROR;
    
    // the packet should be in the list
    TransAssert((_fDispatch == TRUE));
    TransAssert((_pCTPCur == NULL && pCTPIn));
    _pCTPCur = pCTPIn;

    hr = DispatchReport(pCTPIn->GetNotMsg(), _grfBSCF, pCTPIn->_dwCurrentSize, pCTPIn->_dwTotalSize, pCTPIn->_pwzStr, pCTPIn->_dwResult, pCTPIn->_hrResult);

    _pCTPCur = NULL;

    PerfDbgLog1(tagCTransaction, this, "-CTransaction::DispatchPacket (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CTransaction::OnINetCallback
//
//  Synopsis:
//
//  Arguments:  [pCTPIn] --
//
//  Returns:
//
//  History:    12-11-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CTransaction::OnINetCallback(BOOL fFromMsgQueue)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CTransaction::OnINetCallback",
                "this=%#x, %B",
                this, fFromMsgQueue
                ));
                
    PerfDbgLog(tagCTransaction, this, "+CTransaction::OnINetCallback");
    HRESULT hrRelease = NOERROR;
    CTransPacket *pCTP = NULL;

    if (fFromMsgQueue)
    {
        _cPostedMsg--;
    }

    // the packet should be in the list
    if (   IsApartmentThread()
        && (_fDispatch == FALSE)
        && GotCTransPacket() )
    {
        _fDispatch = TRUE;
        BOOL fDispatch = (_ThreadTransferState == TS_None) || (_ThreadTransferState == TS_Completed);

        ThreadSwitchState TSState = _ThreadTransferState;

        // multiple packets migth be dispatched -
        // therefor the list of packets might be empty

        while (   fDispatch
               && ((pCTP = GetNextCTransPacket()) != NULL))
        {
            if (pCTP->GetNotMsg() == BINDSTATUS_INTERNAL)
            {
                OnINetInternalCallback(pCTP);
            }
            else
            {
                hrRelease = DispatchPacket(pCTP);
            }

            if (   (TSState == TS_None)
                && (_ThreadTransferState == TS_Prepared))
            {
                // do not dispatch any further packages on this thread
                // wait until the transfer completes
                fDispatch = FALSE;
            }

            //TRIDENT BTS->BTO
            if (hrRelease == INET_E_TERMINATED_BIND)
            {
                SuspendDispatchingPackets(pCTP);
                
                fDispatch = FALSE;
            }

            // delete the data now
            delete pCTP;
        }

        if (hrRelease == INET_E_TERMINATED_BIND)
            hrRelease = NOERROR; //TRIDENT BTS->BTO reset hrRelease 
        else
            _fDispatch = FALSE;
    }

    PerfDbgLog1(tagCTransaction, this, "-CTransaction::OnINetCallback (hr:%lx)", hrRelease);

    DEBUG_LEAVE(hrRelease);
    return hrRelease;
}

//+---------------------------------------------------------------------------
//
//  Method:     CTransaction::OnINetInternalCallback
//
//  Synopsis:
//
//  Arguments:  [dwState] --
//              [fFromMsgQueue] --
//
//  Returns:
//
//  History:    3-05-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CTransaction::OnINetInternalCallback(CTransPacket *pCTPIn)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CTransaction::OnINetInternalCallback",
                "this=%#x, %#x",
                this, pCTPIn
                ));
                
    PerfDbgLog(tagCTransaction, this, "+CTransaction::OnINetInternalCallback");
    HRESULT hr = NOERROR;
    TransAssert((IsApartmentThread()));
    TransAssert((_pProt));

    _cPostedMsg--;
    _pProt->Continue(pCTPIn);

    PerfDbgLog1(tagCTransaction, this, "-CTransaction::OnINetInternalCallback (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   UrlMonInvokeExceptionFilter
//
//  Synopsis:
//
//  Arguments:  [lCode] --
//              [lpep] --
//
//  Returns:
//
//  History:    2-14-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
LONG UrlMonInvokeExceptionFilter( DWORD lCode, LPEXCEPTION_POINTERS lpep )
{
    DEBUG_ENTER((DBG_TRANS,
                Int,
                "UrlMonInvokeExceptionFilter",
                "%#x, %#x",
                lCode, lpep
                ));
                
#if DBG == 1
    DbgLog2(tagCTransactionErr, NULL, "Exception 0x%#x at address 0x%#x",
               lCode, lpep->ExceptionRecord->ExceptionAddress);
    DebugBreak();
#endif

    DEBUG_LEAVE(EXCEPTION_EXECUTE_HANDLER);
    return EXCEPTION_EXECUTE_HANDLER;
}

//+---------------------------------------------------------------------------
//
//  Function:   TransactionWndProc
//
//  Synopsis:   the transaction callback function
//
//  Arguments:  [hWnd] --
//              [WPARAM] --
//              [wParam] --
//              [lParam] --
//
//  Returns:
//
//  History:    12-02-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
LRESULT CALLBACK TransactionWndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    DEBUG_ENTER((DBG_TRANS,
                Dword,
                "TransactionWndProc",
                "%#x, %#u, %#x, %#x",
                hWnd, msg, wParam, lParam
                ));

    if ((msg >= WM_TRANS_FIRST && msg <= WM_TRANS_LAST))
    {
        switch (msg)
        {
        case WM_TRANS_PACKET:
        {
           DWORD dwFault;
           CTransaction  *pCTrans = (CTransaction *) lParam;
#ifdef WITH_EXCEPTION
           _try
#endif //WITH_EXCEPTION
            {
                TransAssert((pCTrans != NULL));
                PerfDbgLog1(tagCTransaction, pCTrans, "+CTransaction::TransactionWndProc (Msg:%#x)", wParam);

                pCTrans->OnINetCallback(TRUE);

                if (pCTrans->Release() == 0)
                {
                    DbgLog(tagCTransaction, pCTrans, "=== CTransaction::TransactionWndProc Last Release!");
                    pCTrans = 0;
                }

                PerfDbgLog1(tagCTransaction, pCTrans, "-CTransaction::TransactionWndProc (Msg:%#x) WM_TRANS_PACKET", wParam);
            }
#ifdef WITH_EXCEPTION
            _except(UrlMonInvokeExceptionFilter(GetExceptionCode(), GetExceptionInformation()))
            {
                dwFault = GetExceptionCode();

                #if DBG == 1
                //
                // UrlMon catches exceptions when the client generates them. This is so we can
                // cleanup properly, and allow urlmon to continue.
                //
                if (   dwFault == STATUS_ACCESS_VIOLATION
                    || dwFault == 0xC0000194 /*STATUS_POSSIBLE_DEADLOCK*/
                    || dwFault == 0xC00000AA /*STATUS_INSTRUCTION_MISALIGNMENT*/
                    || dwFault == 0x80000002 /*STATUS_DATATYPE_MISALIGNMENT*/ )
                {
                    WCHAR iidName[256];
                    iidName[0] = 0;
                    char achProgname[256];
                    achProgname[0] = 0;

                    GetModuleFileNameA(NULL,achProgname,sizeof(achProgname));
                    DbgLog2(tagCTransactionErr, pCTrans,
                                   "UrlMon has caught a fault 0x%08x on behalf of application %s",
                                   dwFault, achProgname);

                }
                #endif
            }
#ifdef unix
            __endexcept
#endif /* unix */
#endif //WITH_EXCEPTION
        }
        break;
        case WM_TRANS_NOPACKET:
        case WM_TRANS_OUTOFMEMORY:
            // tell the
            break;
        case WM_TRANS_INTERNAL:
            {
                TransAssert((FALSE));
            }
            break;

        }
    }

    DWORD lResult = (DWORD)DefWindowProc(hWnd, msg, wParam, lParam);

    DEBUG_LEAVE(lResult);
    return lResult;
}


//+---------------------------------------------------------------------------
//
//  Method:     CTransaction::AddCTransPacket
//
//  Synopsis:
//
//  Arguments:  [pCTP] --
//
//  Returns:
//
//  History:    12-11-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
void CTransaction::AddCTransPacket(CTransPacket *pCTP, BOOL fTail)
{
    DEBUG_ENTER((DBG_TRANS,
                None,
                "CTransaction::AddCTransPacket",
                "this=%#x, %#x, %B",
                this, pCTP, fTail
                ));

    PerfDbgLog(tagCTransaction, this, "+CTransaction::AddCTransPacket");
    CLock lck(_mxs);
    //TransAssert((pCTP != NULL && (pCTP->GetNotMsg() > Notify_None && pCTP->GetNotMsg() <= Notify_Internal) ));

    if (fTail)
    {

        if (_pCTPHead == NULL)
        {
            TransAssert((_pCTPTail == NULL));
            TransAssert((_cPacketsInList == 0));
            _pCTPHead = pCTP;
            _pCTPTail = pCTP;
            _pCTPTail->SetNext(NULL);

        }
        else
        {
            _pCTPTail->SetNext(pCTP);
            _pCTPTail = pCTP;
        }
    }
    else
    {
        // add it at the front
        if (_pCTPHead == NULL)
        {
            TransAssert((_pCTPTail == NULL));
            TransAssert((_cPacketsInList == 0));
            _pCTPHead = pCTP;
            _pCTPTail = pCTP;
            _pCTPTail->SetNext(NULL);

        }
        else
        {
            pCTP->SetNext(_pCTPHead);
            _pCTPHead = pCTP;
        }
    }
    _cPacketsInList++;
    TransAssert((_cPacketsInList > 0));

    PerfDbgLog3(tagCTransaction, this, "-CTransaction::AddCTransPacket [pCTP(%lx)[%lx], cPackets:%ld] ",
        pCTP, pCTP->GetNotMsg(),_cPacketsInList);
        
    DEBUG_LEAVE(0);
}

//+---------------------------------------------------------------------------
//
//  Method:     CTransaction::GetNextCTransPacket
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    12-11-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
CTransPacket *CTransaction::GetNextCTransPacket()
{
    DEBUG_ENTER((DBG_TRANS,
                Pointer,
                "CTransaction::GetNextCTransPacket",
                "this=%#x",
                this
                ));

    PerfDbgLog(tagCTransaction, this, "+CTransaction::GetNextCTransPacket");
    CLock lck(_mxs);
    CTransPacket *pCTP;

    pCTP = _pCTPHead;
    if (_pCTPHead == NULL)
    {
        TransAssert((_pCTPTail == NULL));
        TransAssert((_cPacketsInList == 0));
    }
    else if (_pCTPHead == _pCTPTail)
    {
        TransAssert((_pCTPTail->GetNext() == NULL));
        // only one packet in fifo
        _pCTPHead = _pCTPTail = NULL;
    }
    else
    {
        _pCTPHead = _pCTPHead->GetNext();
    }

    if (pCTP)
    {
        _cPacketsInList--;
    }

    //TransAssert((   (pCTP == NULL) || (pCTP != NULL && (pCTP->GetNotMsg() > Notify_None && pCTP->GetNotMsg() <= Notify_Internal)) ));

    TransAssert((   ((pCTP == NULL) && (_cPacketsInList == 0))
                 || ((pCTP != NULL) && (_cPacketsInList >= 0)) ));

    /*
    TransAssert((   ((pCTP == NULL) && (_cPacketsInList == 0))
                 || ((pCTP != NULL) && (_cPacketsInList >= 0))
                 || ((pCTP != NULL) && (_cPacketsInList == 0) && ((pCTP->GetNotMsg() == Notify_None) || (pCTP->GetNotMsg() == Notify_Error )))
               ));
    */


    PerfDbgLog2(tagCTransaction, this, "-CTransaction::GetNextCTransPacket [pCTP(%lx), cPackets:%ld] ",
        pCTP, _cPacketsInList);
        
    DEBUG_LEAVE(pCTP);
    return pCTP;
}

//+---------------------------------------------------------------------------
//
//  Method:     CTransaction::GotCTransPacket
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    12-11-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL CTransaction::GotCTransPacket()
{
    DEBUG_ENTER((DBG_TRANS,
                Bool,
                "CTransaction::GotCTransPacket",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCTransaction, this, "+CTransaction::GotCTransPacket");
    CLock lck(_mxs);
    BOOL fGot = _pCTPHead ? true : false;
    PerfDbgLog(tagCTransaction, this, "-CTransaction::GotCTransPacket");
        
    DEBUG_LEAVE(fGot);
    return fGot;
}

CTransPacket::CTransPacket(PROTOCOLDATA *pSI)
{
    DEBUG_ENTER((DBG_TRANS,
                None,
                "CTransPacket::CTransPacket",
                "this=%#x, %#x",
                this, pSI
                ));

    TransAssert((pSI));
    grfFlags    = pSI->grfFlags;
    dwState     = pSI->dwState ;
    pData       = pSI->pData   ;
    cbData      = pSI->cbData  ;

    _dwCurrentSize  = 0;
    _dwTotalSize    = 0;
    _dwResult       = 0;
    _pwzStr         = 0;
    _hrResult       = 0;
    _NotMsg         = (BINDSTATUS) BINDSTATUS_INTERNAL;
        
    DEBUG_LEAVE(0);
}

//+---------------------------------------------------------------------------
//
//  Method:     CTransPacket::CTransPacket
//
//  Synopsis:
//
//  Arguments:  [NMsg] --
//              [hrRet] --
//              [szStr] --
//              [cbAvailable] --
//              [cbTotal] --
//
//  Returns:
//
//  History:    11-09-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
CTransPacket::CTransPacket(BINDSTATUS NMsg, HRESULT hrRet, LPCWSTR szStr, DWORD cbAvailable, DWORD cbTotal, DWORD dwResult)
{
    DEBUG_ENTER((DBG_TRANS,
                None,
                "CTransPacket::CTransPacket",
                "this=%#x, %#x, %#x, %.80wq, %#x, %#x, %#x",
                this, NMsg, hrRet, szStr, cbAvailable, cbTotal, dwResult
                ));
                
    PerfDbgLog1(tagCTransaction, this, "+CTransPacket::CTransPacket (NMsg:%lx)", NMsg);

    _dwCurrentSize = cbAvailable;
    _dwTotalSize = cbTotal;
    _hrResult = hrRet;
    _pCTPNext = NULL;
    _NotMsg = NMsg;
    _pwzStr = NULL;
    _dwResult = dwResult;

    if (szStr)
    {
        _pwzStr = OLESTRDuplicate( (LPWSTR)szStr );
    }

    dwState = _NotMsg;
    pData = this;
    cbData = sizeof(CTransPacket);
    grfFlags = 0;

    PerfDbgLog(tagCTransaction, this, "-CTransPacket::CTransPacket");
        
    DEBUG_LEAVE(0);
}

CTransPacket& CTransPacket::operator=(const CTransPacket& CTPSrc)
{
    DEBUG_ENTER((DBG_TRANS,
                None,
                "CTransPacket::operator=",
                "this=%#x, %#x",
                this, CTPSrc
                ));

    if (&CTPSrc != this)
    {
        grfFlags    = CTPSrc.grfFlags;
        dwState     = CTPSrc.dwState ;
        pData       = CTPSrc.pData   ;
        cbData      = CTPSrc.cbData  ;

        _dwCurrentSize  = CTPSrc._dwCurrentSize;
        _dwTotalSize    = CTPSrc._dwTotalSize;
        _dwResult       = CTPSrc._dwResult;
        _pwzStr         = NULL;
        _hrResult       = CTPSrc._hrResult;
        _NotMsg         = CTPSrc._NotMsg;
        _pCTPNext       = CTPSrc._pCTPNext;
        
        if (CTPSrc._pwzStr)
        {
            _pwzStr = OLESTRDuplicate( CTPSrc._pwzStr );
        }
    }

    DEBUG_LEAVE(0);
    return *this;
}

//+---------------------------------------------------------------------------
//
//  Method:     CTransPacket::~CTransPacket
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    12-11-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
CTransPacket::~CTransPacket()
{
    DEBUG_ENTER((DBG_TRANS,
                None,
                "CTransPacket::~CTransPacket",
                "this=%#x",
                this
                ));

    PerfDbgLog(tagCTransaction, this, "+CTransPacket::~CTransPacket");

    if (_pwzStr)
    {
        delete _pwzStr;
    }

    PerfDbgLog(tagCTransaction, this, "-CTransPacket::~CTransPacket");
        
    DEBUG_LEAVE(0);
}


//+---------------------------------------------------------------------------
//
//  Method:     CTransaction::CPrivUnknown::QueryInterface
//
//  Synopsis:
//
//  Arguments:  [riid] --
//              [ppvObj] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CTransaction::CPrivUnknown::QueryInterface(REFIID riid, void **ppvObj)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CTransaction::CPrivUnknown::IUnknown::QueryInterface",
                "this=%#x, %#x, %#x",
                this, &riid, ppvObj
                ));

    VDATEPTROUT(ppvObj, void *);
    VDATETHIS(this);
    HRESULT hr = NOERROR;

    PerfDbgLog(tagCTransaction, this, "+CTransaction::CPrivUnknown::QueryInterface");
    CTransaction *pCTrans = GETPPARENT(this, CTransaction, _Unknown);

    *ppvObj = NULL;
    if ((riid == IID_IUnknown) || (riid == IID_IOInetProtocolSink) )
    {
        *ppvObj = (IOInetProtocolSink *) pCTrans;
        pCTrans->AddRef();
    }
    else if (riid == IID_IOInetBindInfo)
    {
        *ppvObj = (IOInetBindInfo *) pCTrans;
        pCTrans->AddRef();
    }
    else if (riid == IID_IServiceProvider)
    {
        *ppvObj = (IServiceProvider *) pCTrans;
        pCTrans->AddRef();
    }
    else if (riid == IID_IAuthenticate)
    {
        *ppvObj = (IAuthenticate *) pCTrans;
        pCTrans->AddRef();
    }
    else if (riid == IID_IOInetProtocol)
    {
        *ppvObj = (IOInetProtocol *) pCTrans;
        pCTrans->AddRef();
    }
    else if (riid == IID_IOInetPriority)
    {
        *ppvObj = (IOInetPriority *) pCTrans;
        pCTrans->AddRef();
    }
    else if (riid == IID_ITransProtocolSink)
    {
        *ppvObj = (ITransProtocolSink *) pCTrans;
        pCTrans->AddRef();
    }
    else if (riid == IID_IWrappedProtocol)
    {
        *ppvObj = (IWrappedProtocol *) pCTrans;
        pCTrans->AddRef();
    }
    else if (pCTrans->_pUnkInner)
    {
        hr = pCTrans->_pUnkInner->QueryInterface(riid, ppvObj);
    }
    else
    {
        hr = E_NOINTERFACE;
    }

    PerfDbgLog1(tagCTransaction, this, "-CTransaction::CPrivUnknown::QueryInterface (hr:%lx)", hr);
        
    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   CTransaction::CPrivUnknown::AddRef
//
//  Synopsis:
//
//  Arguments:  [ULONG] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CTransaction::CPrivUnknown::AddRef(void)
{
    DEBUG_ENTER((DBG_TRANS,
                Dword,
                "CTransaction::CPrivUnknown::AddRef",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCTransaction, this, "+CTransaction::CPrivUnknown::IUnknown::AddRef");

    LONG lRet = ++_CRefs;

    PerfDbgLog1(tagCTransaction, this, "-CTransaction::CPrivUnknown::AddRef (cRefs:%ld)", lRet);
        
    DEBUG_LEAVE(lRet);
    return lRet;
}
//+---------------------------------------------------------------------------
//
//  Function:   CTransaction::Release
//
//  Synopsis:
//
//  Arguments:  [ULONG] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CTransaction::CPrivUnknown::Release(void)
{
    DEBUG_ENTER((DBG_TRANS,
                Dword,
                "CTransaction::CPrivUnknown::IUnknown::Release",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCTransaction, this, "+CTransaction::CPrivUnknown::Release");

    CTransaction *pCTransaction = GETPPARENT(this, CTransaction, _Unknown);

    LONG lRet = --_CRefs;

    if (lRet == 0)
    {
        delete pCTransaction;
    }

    PerfDbgLog1(tagCTransaction, this, "-CTransaction::CPrivUnknown::Release (cRefs:%ld)", lRet);
        
    DEBUG_LEAVE(lRet);
    return lRet;
}

//+---------------------------------------------------------------------------
//
//  Method:     CTransaction::OnAttach
//
//  Synopsis:
//
//  Arguments:  [pwzURL] --
//              [pOInetBindInfo] --
//              [pOInetProtSink] --
//              [riid] --
//              [grfOptions] --
//              [pClsidProtocol] --
//              [dwReserved] --
//
//  Returns:
//
//  History:    4-10-1997   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CTransaction::OnAttach(LPCWSTR pwzURL, IOInetBindInfo *pOInetBindInfo, IOInetProtocolSink *pOInetProtSink, DWORD grfOptions, DWORD_PTR dwReserved)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CTransaction::OnAttach",
                "this=%#x, %.80wq, %#x, %#x, %#x, %#x",
                this, pwzURL, pOInetBindInfo, pOInetProtSink, grfOptions, dwReserved
                ));
                
    PerfDbgLog(tagCTransaction, this, "+CTransaction::OnAttach");
    HRESULT     hr = NOERROR;
    VDATETHIS(this);
    do
    {
        hr = NOERROR;
        if (_pwzProtClsId)
        {
            pOInetProtSink->ReportProgress(BINDSTATUS_PROTOCOLCLASSID, _pwzProtClsId);
        }

        if (_pwzRedirectUrl)
        {
            pOInetProtSink->ReportProgress(BINDSTATUS_REDIRECTING,_pwzRedirectUrl);
        }

        if (   (grfOptions & (PI_MIMEVERIFICATION | PI_DOCFILECLSIDLOOKUP))
            && _fMimeVerified
            && _pwzMimeSuggested)
        {
            pOInetProtSink->ReportProgress(BINDSTATUS_MIMETYPEAVAILABLE, _pwzMimeSuggested);
        }

        if (_fMimeHandlerLoaded)
        {
            pOInetProtSink->ReportProgress(BINDSTATUS_LOADINGMIMEHANDLER, NULL);
        }                        

        if (_pwzFileName)
        {
            pOInetProtSink->ReportProgress(BINDSTATUS_CACHEFILENAMEAVAILABLE, _pwzFileName);
        }

        // report data now
        // Shdocvw BTO->BTS case
        if (!IsApartmentThread())
        {
            ThreadTransfer();
        }
        // Shdocvw BTO -> Trident BTS case
        else if (_pCTPCur)
        {
            HRESULT hr1;
            hr1 = DispatchReport(_pCTPCur->GetNotMsg(),_grfBSCF, _pCTPCur->_dwCurrentSize, _pCTPCur->_dwTotalSize, _pCTPCur->_pwzStr, 0);
        }
        // Trident BTS-> Shdocvw BTO
        else if (_grfInternalFlags & BDGFLAGS_BTS_BTO)
        {
            ResumeDispatchingPackets();
        }
        
        break;
    } while (TRUE);

    PerfDbgLog1(tagCTransaction, this, "-CTransaction::OnAttach (hr:%lx)", hr);
        
    DEBUG_LEAVE(hr);
    return hr;
}


//
//  IOInetProtocol
//
//+---------------------------------------------------------------------------
//
//  Method:     CTransaction::Start
//
//  Synopsis:
//
//  Arguments:  [pwzURL] --
//              [pOInetProtSink] --
//              [pOInetBindInfo] --
//              [grfOptions] --
//              [dwReserved] --
//
//  Returns:
//
//  History:    4-10-1997   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CTransaction::Start(LPCWSTR pwzURL, IOInetProtocolSink *pOInetProtSink,
                                 IOInetBindInfo *pOInetBindInfo, DWORD grfOptions, DWORD_PTR dwReserved)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CTransaction::IInternetProtocolRoot::Start",
                "this=%#x, %.80wq, %#x, %#x, %#x, %#x",
                this, pwzURL, pOInetProtSink, pOInetBindInfo, grfOptions, dwReserved
                ));


    PerfDbgLog(tagCTransaction, this, "+CTransaction::Start");
    HRESULT     hr = NOERROR;
    VDATETHIS(this);
    COInetSession *pCOInetSession = 0;
    DWORD dwLocation = 0;
    
    AddRef();

    do
    {
        if (   !pwzURL
            || !pOInetBindInfo
            || !pOInetProtSink
           )
        {
            hr = E_INVALIDARG;
            break;
        }
        if (GetState() == TransSt_OperationFinished)
        {
            hr = E_FAIL;
            break;
        }

        _fPreferDefaultHandler = (grfOptions & BINDF_PREFERDEFAULTHANDLER)?TRUE:FALSE;
        //
        //  case Attachment
        //
        if (GetState() == TransSt_OperationStarted)
        {
            {   // single access block
                CLock lck(_mxsBind);

                TransAssert((grfOptions & (BDGFLAGS_ATTACHED|BDGFLAGS_BTS_BTO)));
                
                if (grfOptions & BDGFLAGS_PARTIAL)
                {
                    _grfInternalFlags |= BDGFLAGS_PARTIAL;
                }
                
/* False asserts after Trident BTS->BTO
                TransAssert((_grfInternalFlags & BDGFLAGS_PARTIAL));
                TransAssert((!_fAttached));
 */
                _fAttached = TRUE;
                if (grfOptions & BDGFLAGS_ATTACHED)
                {
                    _grfInternalFlags &= ~BDGFLAGS_BTS_BTO;
                    _grfInternalFlags |= BDGFLAGS_ATTACHED;
                }
                else if (grfOptions & BDGFLAGS_BTS_BTO)
                {
                    _grfInternalFlags |= BDGFLAGS_BTS_BTO;
                    _CProtEmbed.InitAttachedBindToObject();
                }
                
                if (_fProtEmbed)
                {
                    // no sniffing in this object
                    _dwOInetBdgFlags = (grfOptions & ~(PI_MIMEVERIFICATION | PI_DOCFILECLSIDLOOKUP | PI_CLASSINSTALL));
                }
                else
                {
                    _dwOInetBdgFlags = (grfOptions | PI_DATAPROGRESS);
                }


                AddClientOInet(pOInetProtSink, pOInetBindInfo);
         
            }
            
            hr = OnAttach(pwzURL, pOInetBindInfo, pOInetProtSink, grfOptions, dwReserved);
            break;
        }

        if (grfOptions & PI_NOMIMEHANDLER)
                _fMimeHandlerEnabled = FALSE;

        //
        // case: Start of Transaction
        //

        TransAssert((_pClntProtSink == NULL));
        BOOL fFirstCreated = FALSE;

        {   // single access block
            CLock lck(_mxsBind);

            int cchUrlLen;

            cchUrlLen  = wcslen(pwzURL) + 1;
            _pwzUrl = (LPWSTR) new WCHAR [cchUrlLen];
            if (!_pwzUrl)
            {
                hr = E_OUTOFMEMORY;
                break;
            }

            wcscpy(_pwzUrl, pwzURL);
            
            TransAssert((_pClntProtSink == 0 && _cBdgRefs == 0));
            
            AddClientOInet(pOInetProtSink, pOInetBindInfo);

            if (grfOptions & BDGFLAGS_PARTIAL)
            {
                _grfInternalFlags |= BDGFLAGS_PARTIAL;
            }

            if (_fProtEmbed)
            {
                // no sniffing in this object
                _dwOInetBdgFlags = (grfOptions & ~(PI_MIMEVERIFICATION | PI_DOCFILECLSIDLOOKUP | PI_CLASSINSTALL));
            }
            else
            {
                _dwOInetBdgFlags = (grfOptions | PI_DATAPROGRESS);
            }

        } // end single access

        // 
        // OE4( yet another shipped-so-we-can't-fix product ) will assume
        // ReportResult is always Async (urlmon post a message), because
        // they will do TWO reportResult, if we don't do Async, Terminate
        // will called before the first ReportResult returns, which cleans
        // up everything, when OE4 calls back with second ReportResult, they
        // will fault in urlmon.
        // 
        LONG dwMS = sizeof("mhtml:") - 1;
        if( wcslen(_pwzUrl) >= dwMS && !StrCmpNIW(_pwzUrl, L"mhtml:", dwMS) ) 
        {
            _fForceAsyncReportResult = TRUE;
        }
   
    

        // We must have at least one node in the client request linked list
        TransAssert((_pClntProtSink != NULL));

        hr = QueryService(IID_IOInetProtocol, IID_IOInetProtocol ,(void **)&_pProt);
        // work around InfoViewer bug(IE4 RAID #53224), 
        // they will return NOERROR with _pProt=NULL on QueryService()
        if( hr == NOERROR && _pProt == NULL)
        {
            hr = E_NOINTERFACE;
        }

        if (hr != NOERROR)
        {
            if ((hr = GetCOInetSession(0,&pCOInetSession,0)) == NOERROR)
            {
                DWORD dwOption = _fPreferDefaultHandler ? BINDF_PREFERDEFAULTHANDLER : 0;
                hr = pCOInetSession->CreateFirstProtocol(pwzURL, (IOInetBindInfo *) this, &_pUnkInner, &_pProt, &_clsidProtocol, &dwLocation, dwOption);
                fFirstCreated = TRUE;
                if ((hr == NOERROR) && _pUnkInner)
                {
                    TransAssert((_pProt));
                    _pProt->Release();
                }
            }
        }
        else
        {
            // bugbug: find the correct cls id here.
            _clsidProtocol = CLSID_FtpProtocol;
        }

        if (hr != NOERROR)
        {
            TransAssert((!_pProt && !_pUnkInner));
            _pProt = 0;
            _pUnkInner = 0;
            break;
        }

        BOOL fNext;
        BOOL fProtEmbedded = FALSE; // embed only once
        TransAssert((_pProt));
        do  // loop over protocols
        {
            fNext = FALSE;
            TransAssert((hr == NOERROR));
            
            // Start the download operation
            TransAssert((_pProt != NULL));
            TransAssert(( !IsEqualIID(GetProtocolClassID(),CLSID_NULL) ));

            {
                delete [] _pwzProtClsId;
                _pwzProtClsId =  0;

                HRESULT hr1 = StringFromCLSID(_clsidProtocol, &_pwzProtClsId);
                if (SUCCEEDED(hr1))
                {
                    pOInetProtSink->ReportProgress(BINDSTATUS_PROTOCOLCLASSID, _pwzProtClsId);
                }
            }

            SetState(TransSt_OperationStarted);


            IOInetProtocol* pProtNotAgged = NULL; 
            if (_fProtEmbed && !fProtEmbedded)
            {
                _CProtEmbed.Initialize(this, 0, PP_PRE_SWITCH, grfOptions, 0, _pProt, pOInetProtSink, (LPWSTR )pwzURL);
                _pClntProtSink = (IOInetProtocolSink *)&_CProtEmbed;
                
                if (_pUnkInner)
                {
                    // release the protocol we loaded
                    _pProt->Release();
                }
                else
                {
                    // hold on to the non-aggregrated original prot, 
                    // we will need to release it in case of we don't use 
                    // this protocol 
                    pProtNotAgged = _pProt; 
                }

                _pProt = &_CProtEmbed;
                fProtEmbedded = TRUE;
                if (_pUnkInner)
                {
                    // extra addref for second pointer to this class
                    _pProt->AddRef();
                }
            
            }

            // Just before starting the transaction give it the priority.

            IOInetPriority * pOInetPriority = NULL;
            if (_pProt->QueryInterface(IID_IOInetPriority, (void **) &pOInetPriority) == S_OK)
            {
                pOInetPriority->SetPriority(_nPriority);
                pOInetPriority->Release();
            }

            {   // single access block
                CLock lck(_mxsBind);
                _fStarting = TRUE;
            }

            hr = _pProt->Start(pwzURL, this, (IOInetBindInfo *)this, 0,0);

            {   // single access block
                CLock lck(_mxsBind);
                _fStarting = FALSE;
            }

            if (_fReceivedAbort && (hr != NOERROR))
            {
                Abort(_hrAbort, _dwAbort);
            }
            else if (hr == E_PENDING)
            {
                hr = NOERROR;
            }
            else if (hr == INET_E_USE_DEFAULT_PROTOCOLHANDLER)
            {
                fNext = TRUE;
                AddRef();

                if (!_pUnkInner)
                {
                    _pProt->Release();
                }
                if (fProtEmbedded)
                {
                    if(pProtNotAgged)
                    {
                        pProtNotAgged->Release(); 
                        pProtNotAgged = 0;
                    }
                    _CProtEmbed.SetProtocol(NULL);
                }
                fProtEmbedded = FALSE;
                _pProt = 0;

                if (_pUnkInner)
                {
                    _pUnkInner->Release();
                    _pUnkInner = 0;
                }

                // bugbug: need to reset the protocol inside the embed protocol handler

                if (!fFirstCreated)
                {
                    DWORD dwOption = _fPreferDefaultHandler ? BINDF_PREFERDEFAULTHANDLER : 0;
                    hr = pCOInetSession->CreateFirstProtocol(pwzURL, (IOInetBindInfo *) this, &_pUnkInner, &_pProt, &_clsidProtocol, &dwLocation, dwOption);
                    fFirstCreated = TRUE;
                }
                else
                {
                    hr = pCOInetSession->CreateNextProtocol(pwzURL, (IOInetBindInfo *) this, &_pUnkInner, &_pProt, &_clsidProtocol, &dwLocation);
                }
                
                if (hr != NOERROR)
                {
                    TransAssert((!_pProt && !_pUnkInner));
                    _pProt = 0;
                    _pUnkInner = 0;
                    fNext = FALSE;

                }
                else if (_pUnkInner)
                {
                    // release the extra addref - aggregation
                    Release();
                }

            }
            else if (hr != NOERROR)
            {
                // do not allow pending packages be dispatched
                // any more
                fNext = FALSE;
                _fDispatch = TRUE;
                if (_pProt && !_fTerminated)
                {
                    _fResultDispatched = TRUE;

                    if (fProtEmbedded)
                    {
                        _pClntProtSink->ReportResult(_hrResult, _dwResult, 0);
                    }
                    else
                    {
                        pOInetProtSink->ReportResult(_hrResult, _dwResult, 0);
                    }
                    Terminate(0);
                }
            }

            if(pProtNotAgged)
            {
                pProtNotAgged->Release(); 
                pProtNotAgged = 0;
            }
            
        } while  (fNext == TRUE);

        if (   (grfOptions & PI_SYNCHRONOUS)
            && SUCCEEDED(hr) 
            && (_fModalLoopRunning == FALSE))
        {
            // complet the binding in case of sychronous bind
            TransAssert((grfOptions & OIBDG_APARTMENTTHREADED));
            _fModalLoopRunning = TRUE;
            hr = CompleteOperation(grfOptions & (BDGFLAGS_ATTACHED|BDGFLAGS_BTS_BTO));
            _fModalLoopRunning = FALSE;
        }

        break;
    } while (TRUE);

    if (pCOInetSession)
    {
        pCOInetSession->Release();
    }

    Release();

    PerfDbgLog1(tagCTransaction, this, "-CTransaction::Start (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CTransaction::Continue
//
//  Synopsis:
//
//  Arguments:  [pStateInfo] --
//
//  Returns:
//
//  History:    4-10-1997   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CTransaction::Continue(PROTOCOLDATA *pStateInfo)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CTransaction::IInternetProtocolRoot::Continue",
                "this=%#x, %#x",
                this, pStateInfo
                ));

    PerfDbgLog(tagCTransaction, this, "+CTransaction::Continue");
    VDATETHIS(this);

    HRESULT hr = NOERROR;

    hr = _pProt->Continue(pStateInfo);

    delete (CTransPacket *)pStateInfo;

    PerfDbgLog1(tagCTransaction, this, "-CTransaction::Continue (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CTransaction::Abort
//
//  Synopsis:
//
//  Arguments:  [hrReason] --
//              [dwOptions] --
//
//  Returns:
//
//  History:    4-10-1997   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CTransaction::Abort(HRESULT hrReason, DWORD dwOptions)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CTransaction::IInternetProtocolRoot::Abort",
                "this=%#x, %#x, %#x",
                this, hrReason, dwOptions
                ));

    PerfDbgLog(tagCTransaction, this, "+CTransaction::Abort");
    VDATETHIS(this);

    HRESULT hr = NOERROR;
    BOOL fAbort = FALSE;
    {   // single access block

        CLock lck(_mxsBind);

        if (!_fAborted && !_fTerminated && _pProt && (_ThreadTransferState == TS_None))
        {
            _fReceivedAbort = TRUE;
            _hrAbort = hrReason;
            _dwAbort = dwOptions;
            // terminate might complete async!
            if (hrReason == NOERROR)
            {
                hrReason = E_ABORT;
            }
            if (!_fStarting)
            {
                _fAborted = TRUE;
                fAbort = TRUE;
            }
        }
    } // end single access

    if (fAbort)
    {
        hr = _pProt->Abort(hrReason, dwOptions);
        if( hr == INET_E_RESULT_DISPATCHED )
        {
            //
            // CINet already dispatch the ReportResult and it
            // is currently in the CTrans's msg queue, we need to 
            // reset those flag so that when the ReportResult
            // finally get processed, we won't get confused 
            // (Terminate gets called)
            //  
            _fAborted = FALSE;
            _fReceivedAbort = FALSE;
        }
    }

    PerfDbgLog1(tagCTransaction, this, "-CTransaction::Abort (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CTransaction::Terminate
//
//  Synopsis:
//
//  Arguments:  [dwOptions] --
//
//  Returns:
//
//  History:    4-10-1997   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CTransaction::Terminate(DWORD dwOptions)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CTransaction::IInternetProtocolRoot::Terminate",
                "this=%#x, %#x",
                this, dwOptions
                ));

    PerfDbgLog(tagCTransaction, this, "+CTransaction::Terminate");
    VDATETHIS(this);
    HRESULT hr = E_FAIL;
    BOOL fTotalTerminate = FALSE;

    do 
    {

        {   // single access block
            CLock lck(_mxsBind);

            if (_fTerminated)
            {
                break;
            }

            if (_dwDispatchLevel)
            {
                _fReceivedTerminate = TRUE;
                _dwTerminateOptions = dwOptions;
                break;
            }
            else
            {
                _fTerminating = TRUE;
            }
            fTotalTerminate = _fTerminated;

            TransAssert((  (dwOptions == BDGFLAGS_PARTIAL)
                         || (dwOptions == BDGFLAGS_ATTACHED)
                         || (dwOptions == BDGFLAGS_BTS_BTO)
                         || (dwOptions == 0) ));
                         
            //TransAssert((_grfInternalFlags & BDGFLAGS_PARTIAL));

            if (dwOptions & BDGFLAGS_PARTIAL)
            {
                // remove the first sink
                // 
                if (!(_grfInternalFlags & BDGFLAGS_ATTACHED))
                {
                    // the new sink is not yet attached
                    TransAssert((_cBdgRefs == 1));
                    RemoveClientOInet();

                    // now make sure we shut down this on case no thread transfer is going on
                    if (_ThreadTransferState == TS_None)
                    {
                        _fAborted = TRUE;
                    }
                    
                }
                else
                {
                   TransAssert((   ((_cBdgRefs == 1) && (_pClntProtSink != 0)) 
                                || ((_cBdgRefs == 0) && (_pClntProtSink == 0)) ));
                }
            }
            else if (dwOptions & BDGFLAGS_ATTACHED)
            {
                TransAssert((_cBdgRefs == 1));
                RemoveClientOInet();
            }
            else if (dwOptions & BDGFLAGS_BTS_BTO)
            {
                TransAssert((_cBdgRefs == 1));
                RemoveClientOInet();
            }
            else
            {
                // nothing to do here
            }
            
        }

        if (   !fTotalTerminate
            && (_fResultDispatched || _fAborted))
        {
            fTotalTerminate = TRUE;
            
            hr = NOERROR;
            RemoveClientOInet();

            //
            // release pointers from the APP
            //
            if (_pInetInfo && !_pUnkInner)
            {
                _pInetInfo->Release();
                _pInetInfo = NULL;
            }

            if (_pInetHttpInfo && !_pUnkInner)
            {
                _pInetHttpInfo->Release();
                _pInetHttpInfo = NULL;
            }
                    
            if (_pProt)
            {
                _pProt->Terminate(0);
            }

            if (_pBndInfo)
            {
                //
                #if DBG == 1
                if (_pBndInfo->stgmedData.tymed != TYMED_NULL)
                {
                    PerfDbgLog1(tagCTransaction, this, "+CTransaction::Terminate ReleaseStgMedium (%lx)", _pBndInfo->stgmedData);
                }
                #endif
                ReleaseBindInfo(_pBndInfo);
                delete _pBndInfo;
                _pBndInfo = NULL;
            }
            if (_fProtEmbed && _pUnkInner && !_fLocked && !_fUnlocked)
            {
                // remove extra refcount
                _pProt->Release();
            }
            
            //
            //
            SetState(TransSt_OperationFinished);

            TransAssert((_cBdgRefs == 0));
            //TransAssert(( _fAborted || (!_fAborted && (_cPacketsInList == 0)) ));
        }
        
        {   // single access block
            CLock lck(_mxsBind);
            _fTerminating = FALSE;
            if (fTotalTerminate)
            {
                _fTerminated = TRUE;
            }
        }
        
        break;
    } while (TRUE);

    PerfDbgLog1(tagCTransaction, this, "-CTransaction::Terminate (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CTransaction::Suspend
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    4-10-1997   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CTransaction::Suspend()
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CTransaction::IInternetProtocolRoot::Suspend",
                "this=%#x",
                this
                ));

    PerfDbgLog(tagCTransaction, this, "+CTransaction::Suspend");
    VDATETHIS(this);
    CLock lck(_mxsBind);

    HRESULT hr = NOERROR;

    if( _pProt )
    {
        hr = _pProt->Suspend();
    }
    else
    {
        hr = E_NOTIMPL;
    }

    PerfDbgLog1(tagCTransaction, this, "-CTransaction::Suspend (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CTransaction::Resume
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    4-10-1997   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CTransaction::Resume()
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CTransaction::IInternetProtocolRoot::Resume",
                "this=%#x",
                this
                ));

    PerfDbgLog(tagCTransaction, this, "+CTransaction::Resume");
    VDATETHIS(this);
    CLock lck(_mxsBind);

    HRESULT hr = NOERROR;

    hr = _pProt->Resume();

    PerfDbgLog1(tagCTransaction, this, "-CTransaction::Resume (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CTransaction::Read
//
//  Synopsis:
//
//  Arguments:  [pBuffer] --
//              [cbBuffer] --
//              [pcbRead] --
//
//  Returns:
//
//  History:    4-10-1997   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CTransaction::Read(void *pBuffer, ULONG cbBuffer, ULONG *pcbRead)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CTransaction::IInternetProtocol::Read",
                "this=%#x, %#x, %#x, %#x",
                this, pBuffer, cbBuffer, pcbRead
                ));

    PerfDbgLog(tagCTransaction, this, "+CTransaction::Read");
    HRESULT     hr = E_FAIL;
    VDATETHIS(this);
    CLock lck(_mxsBind);

    BOOL fRead = TRUE;
    DWORD dwCopy = 0;
    DWORD dwCopyNew = 0;
    
    if (   (_dwOInetBdgFlags & (PI_MIMEVERIFICATION | PI_DOCFILECLSIDLOOKUP))
             && (_cbBufferFilled))
    {
        fRead = FALSE;

        // copy data form the local buffer to the provide buffer
        if (cbBuffer < _cbBufferFilled)
        {
            dwCopy = cbBuffer;
            memcpy(pBuffer, _pBuffer, cbBuffer);
            // move the memory to the front
            memcpy(_pBuffer, _pBuffer + cbBuffer, _cbBufferFilled - cbBuffer);
            _cbBufferFilled -= cbBuffer;
            hr = S_OK;
        }
        else if (cbBuffer == _cbBufferFilled)
        {
            dwCopy = _cbBufferFilled;
            memcpy(pBuffer, _pBuffer, _cbBufferFilled);
            _cbBufferFilled = 0;
            hr = S_OK;
        }
        else
        {
            //
            // user buffer is greater than what is available in
            //
            dwCopy = _cbBufferFilled;
            memcpy(pBuffer, _pBuffer, _cbBufferFilled);
            _cbBufferFilled = 0;
            fRead = TRUE;
            hr = E_PENDING;
        }
    }

    if (fRead == TRUE)
    {
        if (_pProt)
        {
            hr = _pProt->Read( ((LPBYTE)pBuffer) + dwCopy, cbBuffer - dwCopy, &dwCopyNew);
            _cbTotalBytesRead += dwCopyNew;
        }
        else
        {
            hr = S_FALSE;
        }
    }

    if (pcbRead)
    {
        *pcbRead = dwCopy + dwCopyNew;
    }

    PerfDbgLog4(tagCTransaction, this, "-CTransaction::Read (hr:%lx, cbRead:%lx, _cbTotalBytesRead:%lx, _cbBytesReported:%lx)",
                                        hr, *pcbRead, _cbTotalBytesRead, _cbBytesReported);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CTransaction::Seek
//
//  Synopsis:
//
//  Arguments:  [dlibMove] --
//              [dwOrigin] --
//              [plibNewPosition] --
//
//  Returns:
//
//  History:    4-10-1997   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CTransaction::Seek(LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER *plibNewPosition)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CTransaction::IInternetProtocol::Seek",
                "this=%#x, %#x, %#x, %#x",
                this, dlibMove, dwOrigin, plibNewPosition
                ));
                
    PerfDbgLog(tagCTransaction, this, "+CTransaction::Seek");
    VDATETHIS(this);
    CLock lck(_mxsBind);

    HRESULT hr = NOERROR;

    hr = _pProt->Seek(dlibMove, dwOrigin, plibNewPosition);

    PerfDbgLog1(tagCTransaction, this, "-CTransaction::Seek (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CTransaction::LockRequest
//
//  Synopsis:
//
//  Arguments:  [dwOptions] --
//
//  Returns:
//
//  History:    4-10-1997   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CTransaction::LockRequest(DWORD dwOptions)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CTransaction::IInternetProtocol::LockRequest",
                "this=%#x, %#x",
                this, dwOptions
                ));
                
    PerfDbgLog(tagCTransaction, this, "+CTransaction::LockRequest");
    VDATETHIS(this);
    CLock lck(_mxsBind);

    HRESULT hr = NOERROR;

    hr = _pProt->LockRequest(dwOptions);
    if (SUCCEEDED(hr))
    {
        _fLocked = TRUE;
    }

    PerfDbgLog1(tagCTransaction, this, "-CTransaction::LockRequest (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CTransaction::UnlockRequest
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    4-10-1997   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CTransaction::UnlockRequest()
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CTransaction::IInternetProtocol::UnlockRequest",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCTransaction, this, "+CTransaction::UnlockRequest");
    VDATETHIS(this);
    CLock lck(_mxsBind);

    HRESULT hr = NOERROR;

    hr = _pProt->UnlockRequest();
    if (SUCCEEDED(hr))
    {
        _fLocked = FALSE;
        _fUnlocked = TRUE;
        if (_fProtEmbed && _pUnkInner)
        {
            // remove extra refcount to the protocol
            _pProt->Release();
        }
    }

    PerfDbgLog1(tagCTransaction, this, "-CTransaction::UnlockRequest (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CTransaction::SetPriority
//
//  Synopsis:
//
//  Arguments:  [nPriority] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CTransaction::SetPriority(LONG nPriority)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CTransaction::IInternetPriority::SetPriority",
                "this=%#x, %d",
                this, nPriority
                ));
                
    PerfDbgLog1(tagCTransaction, this, "+CTransaction::SetPriority (%ld)", nPriority);

    HRESULT hr = S_OK;

    _nPriority = nPriority;

    PerfDbgLog1(tagCTransaction, this, "-CTransaction::SetPriority (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CTransaction::GetPriority
//
//  Synopsis:
//
//  Arguments:  [pnPriority] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CTransaction::GetPriority(LONG * pnPriority)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CTransaction::IInternetPriority::GetPriority",
                "this=%#x, %#x",
                this, pnPriority
                ));
                
    PerfDbgLog(tagCTransaction, this, "+CTransaction::GetPriority");

    HRESULT hr;

    if (!pnPriority)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        *pnPriority = _nPriority;
        hr = S_OK;
    }

    PerfDbgLog1(tagCTransaction, this, "-CTransaction::GetPriority (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CTransaction::LoadHandler
//
//  Synopsis:
//
//  Arguments:  [pwzStr] --
//
//  Returns:
//
//  History:    4-10-1997   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CTransaction::LoadHandler(LPCWSTR pwzURL, COInetProt *pCProtHndl, DWORD dwMode)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CTransaction::LoadHandler",
                "this=%#x, %.80wq, %#x, %#x",
                this, pwzURL, pCProtHndl, dwMode
                ));
                
    PerfDbgLog(tagCTransaction, this, "+CTransaction::LoadHandler");

    HRESULT     hr = NOERROR;
    VDATETHIS(this);
    
    IOInetProtocol      *pProtHandler = 0;
    IOInetProtocolSink  *pProtSnkHandler = 0;

    IOInetProtocolSink  *pProtSnkHandlerToMe = 0;
    IOInetProtocol      *pProtHandlerToMe = 0;
    
    COInetSession       *pCOInetSession = 0;
    CLSID                clsidHandler;

    PROTOCOLFILTERDATA FilterData = {sizeof(PROTOCOLFILTERDATA), 0 ,0, 0,0};
    
    hr = E_FAIL;

    do
    {
        if (!pwzURL || !pCProtHndl)
        {
            hr = E_INVALIDARG;
            break;
        }

        if (!_fProtEmbed)
        {
            // can not load a handler without the embedded object
            break;
        }

        if ((hr = GetCOInetSession(0,&pCOInetSession,0)) != NOERROR)
        {
            break;
        }
        hr = pCOInetSession->CreateHandler(pwzURL, 0, 0, &pProtHandler, &clsidHandler);
        if (FAILED(hr))
        {
            break;
        }
        //
        // get the interfaces for the handler
        //
        TransAssert((pProtHandler));

        FilterData.pProtocolSink = 0;
        FilterData.pProtocol = 0;
        FilterData.pUnk = 0;
        FilterData.dwFilterFlags = 0;

        if (_dwOInetBdgFlags & PI_PASSONBINDCTX)
        {
            // do not need to addref pointer
            FilterData.pUnk = _pBndCtx;
        }
        

        hr = pProtHandler->QueryInterface(IID_IOInetProtocolSink, (void **) &pProtSnkHandler);
        if (hr != NOERROR)
        {
            break;
        }
        // set up the handler now
        {
            DWORD dwOptions = 0;
            TransAssert((pProtSnkHandler));
            pProtHandlerToMe = (IOInetProtocol *) pCProtHndl;
            pProtSnkHandlerToMe = (IOInetProtocolSink *) pCProtHndl;
            FilterData.pProtocol = pProtHandlerToMe;
            _pClntProtSink = pProtSnkHandler;
            _pProt = pProtHandler; 
        }
        
        hr = pProtHandler->Start(pwzURL, pProtSnkHandlerToMe, (IOInetBindInfo *)this, PI_FILTER_MODE | PI_FORCE_ASYNC, (DWORD_PTR) &FilterData);

        if (hr == NOERROR)
        {
        }   
        else if (hr == E_PENDING)
        {   
            // send on the first junk of data
        
            hr = NOERROR;
        }
        else
        {
            pProtHandler->Release();
            pProtHandler = 0;
        }

        break;
    } while (TRUE);

    if (pCOInetSession)
    {
        pCOInetSession->Release();
    }

    if (pProtHandler)
    {
        pProtHandler->Release();
    }

    PerfDbgLog1(tagCTransaction, this, "-CTransaction:: (hr:%lx)", hr);
        
    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CTransaction::UpdateVerifiedMimeType
//
//  Synopsis:
//
//  Arguments:  [pwzMime] --
//
//  Returns:
//
//  History:    5-20-1998   DanpoZ (Danpo Zhang)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
void CTransaction::UpdateVerifiedMimeType(LPCWSTR pwzMime)
{
    DEBUG_ENTER((DBG_TRANS,
                None,
                "CTransaction::UpdateVerifiedMimeType",
                "this=%#x, %.80wq",
                this, pwzMime
                ));
                
    if( pwzMime )
    {

        if( _pwzMimeSuggested )
        {
            delete [] _pwzMimeSuggested;
        }

        _pwzMimeSuggested = OLESTRDuplicate((LPWSTR)pwzMime);
        _fMimeVerified = TRUE;
    }
        
    DEBUG_LEAVE(0);
}


HRESULT CTransaction::GetWrapperCode(LONG * pnCode, DWORD_PTR dwReserved)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CTransaction::IWrappedProtocol::GetWrapperCode",
                 "this=%#x, %#x, %#x",
                this, pnCode, dwReserved
                ));
                
    PerfDbgLog(tagCTransaction, this, "+CTransaction::GetWrapperCode");

    HRESULT hr;

    if(!pnCode)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        *pnCode = 0;
        hr = S_OK;
    }

    PerfDbgLog1(tagCTransaction, this, "-CTransaction::GetWrapperCode (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\trans\transdat.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       transdata.cxx
//
//  Contents:   Contains the module which provide data passed on in OnDataAvailable
//
//  Classes:
//
//  Functions:
//
//  History:    12-07-95   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------
#include <trans.h>
#ifndef unix
#include "..\stg\rostmdir.hxx"
#include "..\stg\rostmfil.hxx"
#else
#include "../stg/rostmdir.hxx"
#include "../stg/rostmfil.hxx"
#endif /* unix */

PerfDbgTag(tagCTransData,    "Urlmon", "Log CTransData",        DEB_DATA);
    DbgTag(tagCTransDataErr, "Urlmon", "Log CTransData Errors", DEB_DATA|DEB_ERROR);

HRESULT FindMediaType(LPCSTR pszType, CLIPFORMAT *cfType);
HRESULT FindMediaTypeW(LPCWSTR pwzType, CLIPFORMAT *cfType);

static LPSTR g_szCF_NULL = "*/*";

char  szContent[]           = "Content Type";
char  szClassID[]           = "CLSID";
char  szFlags[]             = "Flags";
char  szExtension[]         = "Extension";
char  szMimeKey[]           = "MIME\\Database\\Content Type\\";
const ULONG ulMimeKeyLen    = ((sizeof(szMimeKey)/sizeof(char))-1);

// The byte combination that identifies that a file is a storage of
// some kind
const BYTE SIGSTG[] = {0xd0, 0xcf, 0x11, 0xe0, 0xa1, 0xb1, 0x1a, 0xe1};
const BYTE CBSIGSTG = sizeof(SIGSTG);


#define CBSNIFFDATA_MAX 256

#ifdef DBG
char *szDataSinkName[] =
{
     "Unknown"
    ,"StreamNoCopyData"
    ,"File"
    ,"Storage"
    ,"StreamOnFile"
    ,"StreamBindToObject"
    ,"GenericStream"
};

#define GetDataSinkName(ds) szDataSinkName[ds]

#else

#define GetDataSinkName(ds) ""

#endif


//+---------------------------------------------------------------------------
//
//  Method:     CTransData::CTransData
//
//  Synopsis:
//
//  Arguments:  [pTrans] --
//              [DWORD] --
//              [dwSizeBuffer] --
//              [fBindToObject] --
//
//  Returns:
//
//  History:    1-27-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
CTransData::CTransData(CTransaction *pTrans, LPBYTE pByte,DWORD dwSizeBuffer, BOOL fBindToObject) : _CRefs()
{
    DEBUG_ENTER((DBG_TRANSDAT,
                None,
                "CTransData::CTransData",
                "this=%#x, %#x, %#x, %#x, %B",
                this, pTrans, pByte, dwSizeBuffer, fBindToObject
                ));
                
    _TransDataState = TransData_Initialized;
    _wzMime[0] = '\0';
    _wzFileName[0]= 0;
    _pwzUrl = 0;
    _pwzRedirectUrl = 0;
    _pStgMed = 0;
    _lpBuffer = pByte;
    _cbBufferSize = dwSizeBuffer;
    _cbDataSize = 0;
    _cbTotalBytesRead = 0;
    _cbReadReturn = 0;
    _cbBufferFilled = 0;
    _cbDataSniffMin = DATASNIFSIZE_MIN;
    _pEnumFE = 0;
    _pStgMed = NULL;
    _pProt = NULL;

    _fBindToObject = fBindToObject; //Flag changes on attachment.. Use sparingly.
    _fMimeTypeVerified = TRUE;
    _fDocFile = FALSE;
    _fInitialized = FALSE;
    _fRemoteReady = FALSE;
    _fCache = FALSE;
    _fLocked = FALSE;
    _fFileAsStmOnFile = FALSE;
    _fEOFOnSwitchSink = FALSE; 

    _hFile = NULL;
    _cbBytesReported = 0;
    _dwAttached = 0;
    _grfBindF  = 0;
    _grfBSC = 0;

    DEBUG_LEAVE(0);
}

//+---------------------------------------------------------------------------
//
//  Method:     CTransData::~CTransData
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    1-27-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
CTransData::~CTransData()
{
    DEBUG_ENTER((DBG_TRANSDAT,
                None,
                "CTransData::~CTransData",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCTransData, this, "+CTransData::~CTransData");

    if (_pwzUrl)
    {
        delete [] _pwzUrl;
    }

    if (_pwzRedirectUrl)
    {
        delete [] _pwzRedirectUrl;
    }
    
    if (_pProt)
    {
        if (_fLocked)
        {
            _pProt->UnlockRequest();
        }
        _pProt->Release();
        _pProt = NULL;
    }

    if (_pBndCtx)
    {
        _pBndCtx->Release();
    }

    if (_pStgMed)
    {
        TransAssert((   (_pStgMed->pUnkForRelease == NULL)
                     || (_pStgMed->pUnkForRelease == this)));

        if (_pStgMed->tymed == TYMED_ISTREAM)
        {
            _pStgMed->pstm->Release();
        }
        else if (_pStgMed->tymed == TYMED_FILE)
        {
            if (_pStgMed->lpszFileName)
            {
                delete _pStgMed->lpszFileName;
            }
        }
        else if (_pStgMed->tymed == TYMED_ISTORAGE)
        {
            _pStgMed->pstg->Release();
        }

        DbgLog1(tagCTransData, this, "=== CTransData::~CTransData: (pStgMed:%lx)", _pStgMed);
        delete _pStgMed;
        _pStgMed = NULL;
    }

    if (_hFile)
    {
        DbgLog1(tagCTransData, this, "=== CTransData::~CTransData (CloseHandle(%lx)", _hFile);
        CloseHandle(_hFile);
        _hFile = NULL;
    }

    if (_lpBuffer)
    {
        delete _lpBuffer;
    }

    PerfDbgLog(tagCTransData, this, "-CTransData::~CTransData");
    
    DEBUG_LEAVE(0);
}

//+---------------------------------------------------------------------------
//
//  Method:     CTransData::QueryInterface
//
//  Synopsis:
//
//  Arguments:  [riid] --
//              [ppvObj] --
//
//  Returns:
//
//  History:    1-27-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CTransData::QueryInterface(REFIID riid, void **ppvObj)
{
    DEBUG_ENTER((DBG_TRANSDAT,
                Hresult,
                "CTransData::IUnknown::QueryInterface",
                "this=%#x, %#x, %#x",
                this, &riid, ppvObj
                ));
                
    VDATEPTROUT(ppvObj, void *);
    VDATETHIS(this);
    HRESULT hr = NOERROR;

    PerfDbgLog(tagCTransData, this, "+CTransData::QueryInterface");

    *ppvObj = NULL;
    if ((riid == IID_IUnknown) || (riid == IID_ITransactionData))
    {
        *ppvObj = this;
        AddRef();
    }
    else
    {
        hr = E_NOINTERFACE;
    }

    PerfDbgLog1(tagCTransData, this, "-CTransData::QueryInterface (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   CTransData::AddRef
//
//  Synopsis:
//
//  Arguments:  [ULONG] --
//
//  Returns:
//
//  History:    1-27-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CTransData::AddRef(void)
{
    DEBUG_ENTER((DBG_TRANSDAT,
                Dword,
                "CTransData::IUnknown::AddRef",
                "this=%#x",
                this
                ));
                
    LONG lRet = ++_CRefs;
    PerfDbgLog1(tagCTransData, this, "CTransData::AddRef (cRefs:%ld)", lRet);

    DEBUG_LEAVE(lRet);
    return lRet;
}

//+---------------------------------------------------------------------------
//
//  Function:   CTransData::Release
//
//  Synopsis:
//
//  Arguments:  [ULONG] --
//
//  Returns:
//
//  History:    1-27-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CTransData::Release(void)
{
    DEBUG_ENTER((DBG_TRANSDAT,
                Dword,
                "CTransData::IUnknown::Release",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCTransData, this, "+CTransData::Release");

    LONG lRet = --_CRefs;

    if (_CRefs == 0)
    {
        delete this;
    }

    PerfDbgLog1(tagCTransData, this, "-CTransData::Release (cRefs:%ld)", lRet);

    DEBUG_LEAVE(lRet);
    return lRet;
}

//+---------------------------------------------------------------------------
//
//  Method:     CTransData::GetTransactionData
//
//  Synopsis:
//
//  Arguments:  [pwzUrl] --
//              [ppwzFilename] --
//              [ppwzMime] --
//              [pdwSizeTotal] --
//              [pdwSizeAvailable] --
//              [dwReserved] --
//
//  Returns:
//
//  History:    9-09-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CTransData::GetTransactionData(LPCWSTR pwzUrl, LPOLESTR *ppwzFilename, LPOLESTR *ppwzMime,
                                            DWORD *pdwSizeTotal, DWORD *pdwSizeAvailable, DWORD  dwReserved)
{
    DEBUG_ENTER((DBG_TRANSDAT,
                Hresult,
                "CTransData::GetTransactionData",
                "this=%#x, %.80wq, %#x, %#x, %#x, %#x, %#x",
                this, pwzUrl, ppwzFilename, ppwzMime, pdwSizeTotal, pdwSizeAvailable, dwReserved
                ));
                
    PerfDbgLog(tagCTransData, this, "+CTransData::GetTransactionData");
    HRESULT hr = NOERROR;
    TransAssert((pwzUrl && ppwzFilename && ppwzMime && pdwSizeTotal && pdwSizeAvailable ));
    TransAssert((_wzFileName[0] != 0));


    if  (ppwzFilename && ppwzMime && pdwSizeTotal && pdwSizeAvailable)
    {
        LPWSTR pwzUrlLocal = GetUrl();
        TransAssert((pwzUrlLocal));

        DbgLog2(tagCTransData, this, "=== CTransData::GetTransactionData (pwzUrlLocal:%ws, pwzUrl:%ws)", pwzUrlLocal, pwzUrl);

        if (!wcscmp(pwzUrl, _pwzUrl) || (_pwzRedirectUrl && !wcscmp(pwzUrl, _pwzRedirectUrl)))
        {
            *ppwzFilename = OLESTRDuplicate(_wzFileName);

            *ppwzMime = OLESTRDuplicate(_wzMime);

            if (_cbDataSize)
            {
                *pdwSizeTotal  = _cbDataSize;
            }
            else
            {
                *pdwSizeTotal  = _cbTotalBytesRead;
            }
            *pdwSizeAvailable = _cbTotalBytesRead;

        }
        else
        {
            *ppwzFilename = 0;
            *ppwzMime = NULL;
            *pdwSizeTotal = 0;
            *pdwSizeAvailable = 0;
            hr = E_INVALIDARG;
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

    PerfDbgLog5(tagCTransData, this, "-CTransData::GetTransactionData (hr:%lx, Filename:%ws, Mime:%ws, _cbDataSize:%ld, _cbTotalBytesRead:%ld)",
        hr, XDBG(*ppwzFilename,L""), XDBG(*ppwzMime,L""), _cbDataSize, _cbTotalBytesRead);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CTransData::Create
//
//  Synopsis:   Set up the transaction data object.
//
//  Arguments:  [pTrans] -- pointer to transaction
//              [riid] --   riid the users passed in
//              [ppCTD] --  the transdata object passed back
//
//  Returns:
//
//  History:    1-18-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CTransData::Create(LPCWSTR pwUrl, DWORD grfBindF, REFIID riid, IBindCtx *pBndCtx,
                                BOOL fBindToObject, CTransData **ppCTD)
{
    DEBUG_ENTER((DBG_TRANSDAT,
                Hresult,
                "CTransData::Create",
                "%.80wq, %#x, %#x, %#x, %B, %#x",
                pwUrl, grfBindF, &riid, pBndCtx, fBindToObject, ppCTD
                ));
                
    HRESULT hr = NOERROR;
    PerfDbgLog1(tagCTransData, NULL, "+CTransData::Create(fBindToObject:%d)", fBindToObject);
    CTransData *pCTData;

    LPBYTE   lpBuffer;
    ULONG    cbBufferSize;
    cbBufferSize = DNLD_BUFFER_SIZE;

    TransAssert((DATASNIFSIZEDOCFILE_MIN <= cbBufferSize));
    lpBuffer = (LPBYTE) new BYTE[cbBufferSize];
    pCTData = new CTransData(NULL,lpBuffer,cbBufferSize, fBindToObject);

    if (lpBuffer && pCTData)
    {
        *ppCTD = pCTData;
        pCTData->Initialize(pwUrl, grfBindF, riid, pBndCtx);

        // Try to get an IEnumFORMATETC pointer from the bind context
        //hr = GetObjectParam(pbc, REG_ENUMFORMATETC, IID_IEnumFORMATETC, (IUnknown**)&_pEnumFE);
    }
    else
    {
        if (pCTData)
        {
            delete pCTData;
        }
        else if (lpBuffer)
        {
            delete lpBuffer;
        }

        hr = E_OUTOFMEMORY;
        *ppCTD = 0;
    }

    PerfDbgLog2(tagCTransData, NULL, "-CTransData::Create (out:%lx,hr:%lx)", *ppCTD, hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CTransData::Initialize
//
//  Synopsis:
//
//  Arguments:  [riid] --
//
//  Returns:
//
//  History:    1-27-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CTransData::Initialize(LPCWSTR pwzUrl, DWORD grfBindF, REFIID riid, IBindCtx *pBndCtx, BOOL fBindToObject)
{
    DEBUG_ENTER((DBG_TRANSDAT,
                Hresult,
                "CTransData::Initialize",
                "this=%#x, %.80wq, %#x, %#x, %#x, %B",
                this, pwzUrl, grfBindF, &riid, pBndCtx, fBindToObject
                ));
                
    PerfDbgLog(tagCTransData, this, "+CTransData::Initialize");
    HRESULT hr = NOERROR;

    if (_fInitialized == FALSE)
    {
        _ds = DataSink_Unknown;
        _formatetc.tymed = TYMED_NULL;
        _grfBindF = grfBindF;
        _pBndCtx = pBndCtx;
        _pBndCtx->AddRef();
        
        _pwzUrl = OLESTRDuplicate((LPWSTR)pwzUrl);
        if (!_pwzUrl) 
        {
            hr = E_OUTOFMEMORY;
        }

        if (SUCCEEDED(hr))
        {
            if (_fBindToObject)
            {
                _formatetc.tymed = TYMED_ISTREAM;
                _ds = DataSink_Unknown;
            }
            else if (riid == IID_IUnknown)
            {
                // this is the BindToStorage
                _formatetc.tymed = TYMED_FILE;
                _ds = DataSink_File;
            }
            else if (riid == IID_IStream)
            {
                // We do not know yet which kind of stream
                // SetDataSink will determine this.

                _formatetc.tymed = TYMED_ISTREAM;
                _ds = DataSink_StreamOnFile;
            }
            else if (riid == IID_IStorage)
            {
                BIND_OPTS bindopts;
                bindopts.cbStruct = sizeof(BIND_OPTS);
                hr = pBndCtx->GetBindOptions(&bindopts);
                _grfMode = bindopts.grfMode;

                _formatetc.tymed = TYMED_ISTORAGE;
                _ds = DataSink_Storage;

            }
            else
            {
                // this call should fail
                hr = E_INVALIDARG;
                TransAssert((FALSE && "Unknown data sink for this request!"));
            }
        }
        
        if (SUCCEEDED(hr))
        {
            HRESULT hr1;
            ITransactionData *pCTransData = NULL;
            LPWSTR pwzFilename = NULL;
            LPWSTR pwzMime = NULL;

            hr1 = GetObjectParam(pBndCtx, SZ_TRANSACTIONDATA, IID_ITransactionData, (IUnknown **)&pCTransData);
            DbgLog2(tagCTransData, this, "=== CTransData::Initialize GetObjectParam: pbndctx:%lx, hr:%lx)", pBndCtx, hr1);

            if (SUCCEEDED(hr1))
            {
                TransAssert((pCTransData));
                hr1 = pCTransData->GetTransactionData(_pwzUrl,&pwzFilename, &pwzMime, &_cbDataSize, &_cbTotalBytesRead, 0);
                DbgLog5(tagCTransData, this, "=== CTransData::Initialize GetTransactionData (hr:%lx, Filename:%ws, Mime:%ws, _cbDataSize:%ld, _cbTotalBytesRead:%ld)", hr1, pwzFilename, pwzMime, _cbDataSize, _cbTotalBytesRead);
                pCTransData->Release();
            }


            if (SUCCEEDED(hr1) )
            {
                // set the url filename
                SetFileName(pwzFilename);
                if (pwzMime)
                {
                    SetMimeType(pwzMime);
                    _fMimeTypeVerified = TRUE;
                }
                _fRemoteReady = TRUE;

                if (pwzMime)
                {
                    delete pwzMime;
                }
                if (pwzFilename)
                {
                    delete pwzFilename;
                }
            }
        }
        _fInitialized = TRUE;
    }
    else
    {
        _dwAttached++;
        
        if (_pBndCtx)
        {
            _pBndCtx->Release();
        }

        _pBndCtx = pBndCtx;

        if (_pBndCtx)
        {
            _pBndCtx->AddRef();
        }

        // no set up the righte datasink
        if (fBindToObject)
        {
            _fBindToObject = TRUE;
            SwitchDataSink(DataSink_StreamBindToObject);
        }
        else if (riid == IID_IUnknown)
        {
            SwitchDataSink(DataSink_File);
        }
        else if (   (riid == IID_IStream)
                 && (grfBindF & BINDF_NEEDFILE))
        {
            SwitchDataSink(DataSink_StreamOnFile);
        }

    }

    PerfDbgLog3(tagCTransData, this, "-CTransData::Initialize (_formatetc.tymed:%ld, _ds:%lx, hr:%lx)", _formatetc.tymed,_ds, hr);

    DEBUG_LEAVE(hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CTransData::PrepareThreadTransfer
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  History:    10-09-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CTransData::PrepareThreadTransfer()
{
    DEBUG_ENTER((DBG_TRANSDAT,
                Hresult,
                "CTransData::PrepareThreadTransfer",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCTransData, this, "+CTransData::PrepareThreadTransfer");
    HRESULT hr = NOERROR;

    if (_pBndCtx)
    {
        _pBndCtx->Release();
        _pBndCtx = NULL;
    }

    PerfDbgLog1(tagCTransData, this, "-CTransData::PrepareThreadTransfer (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CTransData::GetDataSink
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    2-22-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
DataSink CTransData::GetDataSink()
{
    DEBUG_ENTER((DBG_TRANSDAT,
                Pointer,
                "CTransData::GetDataSink",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCTransData, this, "+CTransData::GetDataSink");
    DataSink dsRet = DataSink_Unknown;

    if (_ds == DataSink_Unknown)
    {
        DWORD dwBindF = GetBindFlags();

        if (   (dwBindF & BINDF_ASYNCSTORAGE)
            && (dwBindF & BINDF_PULLDATA)
            && (_formatetc.tymed == TYMED_ISTREAM))
        {
            dsRet = _ds = DataSink_StreamNoCopyData;
        }
    }
    else
    {
        dsRet = _ds;
    }

    PerfDbgLog1(tagCTransData, this, "-CTransData::GetDataSink (dsRet:%lx)", dsRet);

    DEBUG_LEAVE(dsRet);
    return dsRet;
}

//+---------------------------------------------------------------------------
//
//  Method:     CTransData::SetDataSink
//
//  Synopsis:
//
//  Arguments:  [dwBindF] --
//
//  Returns:
//
//  History:    2-25-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
DataSink CTransData::SetDataSink(DWORD dwBindF)
{
    DEBUG_ENTER((DBG_TRANSDAT,
                Pointer,
                "CTransData::SetDataSink",
                "this=%#x, %#x",
                this, dwBindF
                ));
                
    PerfDbgLog1(tagCTransData, this, "+CTransData::SetDataSink (_ds:%lx)", _ds);

    TransAssert((_formatetc.tymed != TYMED_NULL));
    _grfBindF = dwBindF;

    switch (_ds)
    {
    case DataSink_Unknown:
    {
        if (_fBindToObject)
        {
            TransAssert((_formatetc.tymed == TYMED_ISTREAM));
            _ds = DataSink_StreamBindToObject;
        }
    }
    break;
    case DataSink_File:
    {
        TransAssert((_formatetc.tymed == TYMED_FILE));

    }
    break;
    case DataSink_StreamOnFile:
    {
        TransAssert((_formatetc.tymed == TYMED_ISTREAM));
        if ((dwBindF & BINDF_ASYNCSTORAGE) && (dwBindF & BINDF_PULLDATA))  
        {
            _ds = DataSink_StreamNoCopyData;
        }
    }
    break;

    case DataSink_StreamBindToObject:
    {
        TransAssert((_formatetc.tymed == TYMED_ISTREAM));
        TransAssert((_fBindToObject == TRUE));

        if (IsObjectReady() == NOERROR)
        {
            // 
            // change it to file - stream on file will be opened
            //
            _ds = DataSink_StreamOnFile;
        }
        else if ((dwBindF & BINDF_ASYNCSTORAGE) && (dwBindF & BINDF_PULLDATA))
        {
            _ds = DataSink_StreamNoCopyData;
        }

    }
    break;

    case DataSink_Storage:
    {
        TransAssert((_formatetc.tymed == TYMED_ISTORAGE));
    }
    break;

    case DataSink_GenericStream:
    {
        TransAssert((_formatetc.tymed == TYMED_ISTREAM));
    }
    break;

    default:
        TransAssert((FALSE && "CTransData::SetDataSink -- Invalid data location"));
    break;
    }

    PerfDbgLog1(tagCTransData, this, "-CTransData::SetDataSink (_ds:%lx)", _ds);

    DEBUG_LEAVE(_ds);
    return _ds;
}

//+---------------------------------------------------------------------------
//
//  Method:     CTransData::SwitchDataSink
//
//  Synopsis:
//
//  Arguments:  [dwBindF] --
//
//  Returns:
//
//  History:    2-25-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
DataSink CTransData::SwitchDataSink(DataSink dsNew)
{
    DEBUG_ENTER((DBG_TRANSDAT,
                Pointer,
                "CTransData::SwitchDataSink",
                "this=%#x, %#x",
                this, dsNew
                ));
                
    PerfDbgLog2(tagCTransData, this, "+CTransData::SwitchDataSink (_ds:%lx, dsNew:%lx)", _ds, dsNew);

    TransAssert((_ds != DataSink_Unknown));
    TransAssert((_formatetc.tymed != TYMED_NULL));
    HRESULT hr = NOERROR;

    switch (_ds)
    {
    case DataSink_File:
    {
        TransAssert((_formatetc.tymed == TYMED_FILE));
    }
    break;
    case DataSink_StreamOnFile:
    {
         TransAssert((_wzFileName[0] != 0));
         _formatetc.tymed = TYMED_ISTREAM;
    }
    break;

    case DataSink_GenericStream:
    {
        TransAssert((_formatetc.tymed == TYMED_ISTREAM));
    }
    break;

    case DataSink_StreamNoCopyData:
        TransAssert((_formatetc.tymed == TYMED_ISTREAM));
        if (   dsNew == DataSink_StreamOnFile
            || dsNew == DataSink_GenericStream
            || dsNew == DataSink_StreamBindToObject)
        {
            _ds = dsNew;
            DWORD dwNew = 0;
            hr = OnDataReceived(_grfBSC, 0, 0, &dwNew);
            if( hr == S_FALSE)
            {
                _fEOFOnSwitchSink = TRUE;
            }
        }

    break;

    case DataSink_StreamBindToObject:
    {
        TransAssert((_formatetc.tymed == TYMED_ISTREAM));
        TransAssert((_fBindToObject == TRUE));
        _ds = dsNew;
        if (_ds == DataSink_File)
        {
            _formatetc.tymed = TYMED_FILE;
            DWORD dwNew = 0;
            hr = OnDataReceived(_grfBSC, 0, 0, &dwNew);
            if( hr == S_FALSE)
            {
                _fEOFOnSwitchSink = TRUE;
            }
        }

    }
    break;

    case DataSink_Storage:
    {
        TransAssert((_formatetc.tymed == TYMED_ISTORAGE));
    }
    break;

    default:
        TransAssert((FALSE && "CTransData::SwitchDataSink -- Invalid data location"));
    break;
    }

    PerfDbgLog2(tagCTransData, this, "-CTransData::SwitchDataSink (_ds:%lx, dsNew:%lx)", _ds, dsNew);

    DEBUG_LEAVE(_ds);
    return _ds;
}

//+---------------------------------------------------------------------------
//
//  Method:     CTransData::IsFileRequired()
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    2-22-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL CTransData::IsFileRequired()
{
    DEBUG_ENTER((DBG_TRANSDAT,
                Bool,
                "CTransData::IsFileRequired",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCTransData, this, "+CTransData::IsFileRequired()");
    BOOL fRet = FALSE;
    TransAssert((_ds != DataSink_Unknown));

    switch (_ds)
    {
    case DataSink_File:
    case DataSink_StreamOnFile:
        fRet = TRUE;
    }

    PerfDbgLog1(tagCTransData, this, "-CTransData::IsFileRequired() (fRet:%d)", fRet);

    DEBUG_LEAVE(fRet);
    return fRet;
}

//+---------------------------------------------------------------------------
//
//  Method:     CTransData::GetData
//
//  Synopsis:
//
//  Arguments:  [ppformatetc] --
//              [ppStgMed] --
//              [grfBSCF] --
//
//  Returns:
//
//  History:    1-27-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CTransData::GetData(FORMATETC **ppformatetc, STGMEDIUM **ppStgMed, DWORD grfBSCF)
{
    DEBUG_ENTER((DBG_TRANSDAT,
                Hresult,
                "CTransData::GetData",
                "this=%#x, %#x, %#x, %#x",
                this, ppformatetc, ppStgMed, grfBSCF
                ));
                
    PerfDbgLog1(tagCTransData, this, "+CTransData::GetData (_ds:%ld)", _ds);
    HRESULT hr = INET_E_DATA_NOT_AVAILABLE;
    BOOL fNewStgMed = FALSE;
    DataSink ds;

    *ppStgMed = 0;
    *ppformatetc = 0;


    if (_pStgMed == NULL)
    {
        // first find the formatETC based on
        // clipformat and the EnumFormatETC
        FindFormatETC();

        _pStgMed = new STGMEDIUM;
        if (_pStgMed == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto End;
        }

        *ppformatetc = &_formatetc;

        _pStgMed->tymed = TYMED_NULL;
        _pStgMed->hGlobal = NULL;
        _pStgMed->pUnkForRelease = 0;
        _pStgMed->pstm = NULL;
        fNewStgMed = TRUE;

    }

    ds = _ds;
    if( _fFileAsStmOnFile && _ds == DataSink_File )
    {
        ds = DataSink_StreamOnFile;
    } 
    
    switch (ds)
    {
    case DataSink_File:
    {
        //TransAssert((   (grfBSCF & ~BSCF_LASTDATANOTIFICATION)
        //             || ((grfBSCF & BSCF_LASTDATANOTIFICATION) && (_formatetc.tymed == TYMED_FILE)) ));

        if (_wzFileName[0] != 0)
        {
            TransAssert((_wzFileName[0] != 0));
            if (_pStgMed->tymed == TYMED_FILE)
            {
                if (_pStgMed->lpszFileName == NULL)
                {
                    _pStgMed->lpszFileName = (LPWSTR) new WCHAR [wcslen(_wzFileName)+2];
                    if (_pStgMed->lpszFileName)
                    {
                        wcscpy(_pStgMed->lpszFileName, _wzFileName);
                    }
                    else
                    {
                        hr = E_OUTOFMEMORY;
                        goto End;
                    }
                }
            }
            else
            {
                ASSERT(_pStgMed->tymed == TYMED_NULL);
                
                _pStgMed->tymed = TYMED_FILE;
                _pStgMed->lpszFileName = (LPWSTR) new WCHAR [wcslen(_wzFileName)+2];
                if (_pStgMed->lpszFileName)
                {
                    wcscpy(_pStgMed->lpszFileName, _wzFileName);
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                    goto End;
                }
                
            }

            if (_pStgMed->pUnkForRelease == NULL)
            {
                _pStgMed->pUnkForRelease = this;
            }

            hr = NOERROR;
            DbgLog1(tagCTransData, this, "+CTransData::GetData -> TYMED_FILE: %ws", _wzFileName);
        }
        else
        {
            // filename is not available yet
            hr = INET_E_DATA_NOT_AVAILABLE;
        }
    }
    break;

    case DataSink_GenericStream:
    case DataSink_StreamBindToObject:
    case DataSink_StreamNoCopyData:
    {
        DbgLog1(tagCTransData, this, "=== CTransData::GetData (_ds:%lx)", _ds);
        TransAssert((_formatetc.tymed == TYMED_ISTREAM));

        if (_pStgMed->tymed == TYMED_NULL)
        {
            CReadOnlyStreamDirect *pCRoStm = new CReadOnlyStreamDirect( this, _grfBindF);

            if (pCRoStm)
            {
                _pStgMed->tymed = TYMED_ISTREAM;
                _pStgMed->pstm = pCRoStm;
                _pStgMed->pUnkForRelease = this;
                hr = NOERROR;
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }

            DbgLog1(tagCTransData, this, "+CTransData::GetData -> TYMED_ISTREAM: %lx", pCRoStm);
        }
        else
        {
            hr = NOERROR;
        }

        DbgLog2(tagCTransData, this, "=== CTransData::GetData (_ds:%lx,pstm:%lx)", _ds,_pStgMed->pstm);
        DbgLog2(tagCTransData, this, "=== (_cbBufferFilled:%ld, _cbBufferSize:%ld)", _cbBufferFilled,_cbBufferSize);

    }
    break;

    case DataSink_StreamOnFile:
    {
        DbgLog1(tagCTransData, this, "=== CTransData::GetData (_ds:%lx)", _ds);
        TransAssert((_formatetc.tymed == TYMED_ISTREAM));

        if (_wzFileName[0] != 0)
        {
            if (_pStgMed->tymed == TYMED_NULL)
            {
                if( _pStgMed->pstm )
                {
                    //BUG-BUG : relying on undocumented behavior of ReleaseStgMedium..
                    // may or may not zero this out in future.
                    _pStgMed->tymed = TYMED_ISTREAM;
                    _pStgMed->pUnkForRelease = this;

                    // When pStm gets created, the ctor set the ref count
                    // to 1, so no need any additional AddRef.
                    //
                    // Here we are not create a new pStm, we need to do an
                    // AddRef on the pStm because 
                    // CBinding::OnDataNotification (the only caller of this)
                    // will call ReleaseStgMedia() which will call 
                    // _pStgMeg->pstm->Release()

                    _pStgMed->pstm->AddRef();

                    hr = NOERROR;
                }
                else
                {
                    char szTempFile[MAX_PATH];
                    CReadOnlyStreamFile *pCRoStm = NULL;
                    W2A(_wzFileName, szTempFile, MAX_PATH);

                    hr = CReadOnlyStreamFile::Create(szTempFile, &pCRoStm);

                    if (pCRoStm)
                    {
                        _pStgMed->tymed = TYMED_ISTREAM;
                        _pStgMed->pstm = pCRoStm;
                        _pStgMed->pUnkForRelease = this;
                        hr = NOERROR;
                    }
                    else
                    {
                        // filename is not available yet
                        hr = INET_E_DATA_NOT_AVAILABLE;
                    }

                    DbgLog2(tagCTransData, this, "+CTransData::GetData -> TYMED_ISTREAM: %lx (hr:%lx)", pCRoStm,hr);
                }

            }
            else
            {
                TransAssert((_pStgMed->tymed == TYMED_ISTREAM));
                hr = NOERROR;
            }
        }
        else
        {
            DbgLog(tagCTransDataErr, this, "+CTransData::GetData ->StreamOnFile: no filename!");

            // filename is not available yet
            hr = INET_E_DATA_NOT_AVAILABLE;
        }

    }
    break;

    case DataSink_Storage:
    {
        DbgLog2(tagCTransData, this, "=== CTransData::GetData (_ds:%lx, _wzFileName:%ws)", _ds, _wzFileName);
        TransAssert((_formatetc.tymed == TYMED_ISTORAGE));

        TransAssert((_wzFileName != NULL));

        if (_wzFileName[0] != 0)
        {
            if (_pStgMed->tymed == TYMED_NULL)
            {
                IStorage *pStg = NULL;

                hr = StgOpenStorage(_wzFileName, NULL, STGM_READ | STGM_SHARE_DENY_WRITE, NULL, 0, &pStg );
                DbgLog1(tagCTransData, this, "+CTransData::GetData -> TYMED_ISTORAGE: %ws", _wzFileName);

                if (pStg)
                {
                    _pStgMed->tymed = TYMED_ISTORAGE;
                    _pStgMed->pstg = pStg;
                    _pStgMed->pUnkForRelease = this;
                    hr = NOERROR;
                }

                DbgLog2(tagCTransData, this, "+CTransData::GetData -> TYMED_ISTORAGE: %lx (hr:%lx)", pStg,hr);
            }
            else
            {
                TransAssert((_pStgMed->tymed == TYMED_ISTORAGE));
                hr = NOERROR;
            }
        }
        // else return default error
    }
    break;

    default:
        // this needs to be implemented
        TransAssert((FALSE && "CTransData::GetData -- Invalid data location"));
    break;
    }

    if (SUCCEEDED(hr) && _pStgMed)
    {
        // this object was addref on punkforrelease
        *ppStgMed = _pStgMed;
        *ppformatetc = &_formatetc;

        // Use ourselves as the unknown for release, so that the temp file
        // doesn't get removed when ReleaseStgMedium() is called.  We need
        // to AddRef ourselves to balance the Release that will occur.

        if (_pStgMed->pUnkForRelease)
        {
            AddRef();
            if (   _pProt 
                && fNewStgMed
                && SUCCEEDED(_pProt->LockRequest(0)) )
            {
                    _fLocked = TRUE;
            }
        }

        hr = NOERROR;

        TransAssert((_pStgMed->pUnkForRelease != NULL));
    }

End:
    PerfDbgLog1(tagCTransData, this, "-CTransData::GetData (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CTransData::ReadHere
//
//  Synopsis:
//
//  Arguments:  [pBuffer] --
//              [cbBuffer] --
//              [pdwRead] --
//
//  Returns:
//
//  History:    1-27-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CTransData::ReadHere(LPBYTE pBuffer, DWORD cbBuffer, DWORD *pdwRead)
{
    DEBUG_ENTER((DBG_TRANSDAT,
                Hresult,
                "CTransData::ReadHere",
                "this=%#x, %#x, %#x, %#x",
                this, pBuffer, cbBuffer, pdwRead
                ));
                
    PerfDbgLog2(tagCTransData, this, "+CTransData::ReadHere (_ds:%lx,cbBuffer:%ld)", _ds,cbBuffer);
    HRESULT hr = NOERROR;

    switch (_ds)
    {
    case DataSink_StreamNoCopyData:
    case DataSink_StreamBindToObject:
    {
        TransAssert((_formatetc.tymed == TYMED_ISTREAM));
        BOOL fRead = TRUE;
        DWORD dwCopy = 0;
        DWORD dwCopyNew = 0;

        if (_cbBufferFilled)
        {
            fRead = FALSE;

            // copy data form the local buffer to the provide buffer
            if (cbBuffer < _cbBufferFilled)
            {
                dwCopy = cbBuffer;
                memcpy(pBuffer, _lpBuffer, cbBuffer);
                // move the memory to the front
                memcpy(_lpBuffer, _lpBuffer + cbBuffer, _cbBufferFilled - cbBuffer);
                _cbBufferFilled -= cbBuffer;
                hr = S_OK;
            }
            else if (cbBuffer == _cbBufferFilled)
            {
                dwCopy = _cbBufferFilled;
                memcpy(pBuffer, _lpBuffer, _cbBufferFilled);
                _cbBufferFilled = 0;
                hr = S_OK;
            }
            else
            {
                //
                // user buffer is greater than what is available in
                //
                dwCopy = _cbBufferFilled;
                memcpy(pBuffer, _lpBuffer, _cbBufferFilled);
                _cbBufferFilled = 0;
                fRead = TRUE;
                hr = E_PENDING;
            }
        }

        // now read from the wire
        if ((_cbBufferFilled == 0) && (fRead == TRUE))
        {
            // read data from our buffer
            if (_TransDataState == TransData_ProtoTerminated)
            {
                // download completed
                hr = (dwCopy) ? S_OK : S_FALSE;
            }
            else if (pBuffer && cbBuffer)
            {
                hr = _pProt->Read(pBuffer + dwCopy, cbBuffer - dwCopy, &dwCopyNew);
                _cbTotalBytesRead += dwCopyNew;
            }
            else
            {
                hr = E_INVALIDARG;
            }
        }

        if (pdwRead)
        {
            *pdwRead = dwCopy + dwCopyNew;

            if (*pdwRead && (hr != E_PENDING))
            // some data in buffer
            {
                hr = S_OK;
            }
        }
    }
    break;

    case DataSink_StreamOnFile:
    {
        DbgLog(tagCTransData, this, "=== CTransData::ReadHere (_ds:DataSink_StreamNoCopyData)");
        TransAssert((_formatetc.tymed == TYMED_ISTREAM));
        TransAssert((pdwRead != NULL));

        // read data from our buffer
        if (_TransDataState == TransData_ProtoTerminated)
        {
            // download completed
            hr = S_FALSE;
        }
        else if (pBuffer && cbBuffer)
        {
            hr = _pProt->Read(pBuffer, cbBuffer, pdwRead);
        }
        else
        {
            hr = E_INVALIDARG;
        }
    }
    break;

    case DataSink_File:
    {
        TransAssert((_formatetc.tymed == TYMED_FILE));

    }
    break;

    default:
        // this needs to be implemented
        hr = E_FAIL;
        TransAssert((FALSE && "CTransData::ReadHere -- Invalid data location"));
    break;
    }

    TransAssert((   (   (hr == S_FALSE && *pdwRead == 0)
                     || (hr == S_OK && *pdwRead != 0)
                     || (hr == E_PENDING)
                     || (hr == E_INVALIDARG)
                     || (hr == INET_E_DATA_NOT_AVAILABLE)
                     || (hr == INET_E_DOWNLOAD_FAILURE)
                    )
                 && "CTransData::ReadHere -- Invalid return code"));


    PerfDbgLog3(tagCTransData, this, "-CTransData::ReadHere (hr:%lx,cbBuffer:%ld,pdwRead:%ld)", hr,cbBuffer,*pdwRead);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CTransData::Seek
//
//  Synopsis:
//
//  Arguments:  [DWORD] --
//              [ULARGE_INTEGER] --
//              [plibNewPosition] --
//
//  Returns:
//
//  History:    10-30-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CTransData::Seek(LARGE_INTEGER dlibMove,DWORD dwOrigin,ULARGE_INTEGER *plibNewPosition)
{
    DEBUG_ENTER((DBG_TRANSDAT,
                Hresult,
                "CTransData::Seek",
                "this=%#x, %#x, %#x, %#x",
                this, dlibMove, dwOrigin, plibNewPosition
                ));
                
    PerfDbgLog(tagCTransData, this, "+CTransData::Seek");
    HRESULT hr;

    hr = _pProt->Seek(dlibMove, dwOrigin,plibNewPosition);

    PerfDbgLog1(tagCTransData, this, "-CTransData::Seek (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CTransData::GetReadBuffer
//
//  Synopsis:
//
//  Arguments:  [ppBuffer] --
//              [pcbBytes] --
//
//  Returns:
//
//  History:    1-27-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CTransData::GetReadBuffer(BYTE **ppBuffer, DWORD *pcbBytes)
{
    DEBUG_ENTER((DBG_TRANSDAT,
                Hresult,
                "CTransData::GetReadBuffer",
                "this=%#x, %#x, %#x",
                this, ppBuffer, pcbBytes
                ));
                
    PerfDbgLog(tagCTransData, this, "+CTransData::GetReadBuffer");
    HRESULT hr;

    TransAssert((_cbBufferSize >= _cbBufferFilled));

    *ppBuffer = _lpBuffer + _cbBufferFilled;
    *pcbBytes = _cbBufferSize - _cbBufferFilled;

    hr = ((_cbBufferSize - _cbBufferFilled) > 0) ? NOERROR : E_FAIL;

    PerfDbgLog3(tagCTransData, this, "-CTransData::GetReadBuffer (pBuffer:%lx,size:%ld,hr:%lx)",
        *ppBuffer, *pcbBytes, hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CTransData::OnDataInBuffer
//
//  Synopsis:
//
//  Arguments:  [pBuffer] --
//              [cbBytesAvailable] --
//              [dwBytesTotal] --
//
//  Returns:
//
//  History:    1-27-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CTransData::OnDataInBuffer(BYTE *pBuffer, DWORD cbBytesRead, DWORD dwBytesTotal)
{
    DEBUG_ENTER((DBG_TRANSDAT,
                Hresult,
                "CTransData::OnDataInBuffer",
                "this=%#x, %#x, %#x, %#x",
                this, pBuffer, cbBytesRead, dwBytesTotal
                ));
                
    PerfDbgLog(tagCTransData, this, "+CTransData::OnDataInBuffer");
    HRESULT hr = NOERROR;

    _cbTotalBytesRead += cbBytesRead;
    _cbBufferFilled += cbBytesRead;

    PerfDbgLog1(tagCTransData, this, "-CTransData::OnDataInBuffer (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CTransData::OnDataReceived
//
//  Synopsis:
//
//  Arguments:  [cbBytesAvailable] --
//              [dwBytesTotalRead] --
//              [dwTotalSize] --
//
//  Returns:
//
//  History:    2-23-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CTransData::OnDataReceived(DWORD grfBSC, DWORD cbBytesAvailable, DWORD dwTotalSize, DWORD *pcbNewAvailable)
{
    DEBUG_ENTER((DBG_TRANSDAT,
                Hresult,
                "CTransData::OnDataReceived",
                "this=%#x, %#x, %#x, %#x, %#x",
                this, grfBSC, cbBytesAvailable, dwTotalSize, pcbNewAvailable
                ));
                
    PerfDbgLog4(tagCTransData, this, "+CTransData::OnDataReceived (_ds:%s, grfBSC:%lx,  cbBytesAvailable:%ld, _cbTotalBytesRead:%ld)",
        GetDataSinkName(_ds), grfBSC, cbBytesAvailable, _cbTotalBytesRead);
    HRESULT hr = NOERROR;

    *pcbNewAvailable = cbBytesAvailable;
    _grfBSC |= grfBSC;

    switch (_ds)
    {
    case DataSink_StreamNoCopyData:
        TransAssert((_formatetc.tymed == TYMED_ISTREAM));

    case DataSink_StreamBindToObject:
    {
        DWORD dwNewData = 0;
        TransAssert((_pProt && _cbDataSniffMin));

        // _cbTotalBytesRead = # of bytes read so far
        if (_cbTotalBytesRead < _cbDataSniffMin)
        {
            // no bytes read so far
            TransAssert((_cbTotalBytesRead < _cbDataSniffMin));
            // read data into buffer and report progess
            hr = _pProt->Read(_lpBuffer + _cbBufferFilled, _cbBufferSize - _cbBufferFilled, &dwNewData);
            _cbTotalBytesRead += dwNewData;
            _cbBufferFilled += dwNewData;

            // now check if this is docfile
            // if so download at least 2k
            if (!_fDocFile && _cbBufferFilled && (IsDocFile(_lpBuffer, _cbBufferFilled) == S_OK))
            {
                _fDocFile = TRUE;
                _cbDataSniffMin =  (dwTotalSize && dwTotalSize < DATASNIFSIZEDOCFILE_MIN) ? dwTotalSize : DATASNIFSIZEDOCFILE_MIN;
            }

            if ((hr == E_PENDING) && (_cbTotalBytesRead < _cbDataSniffMin))
            {
                // do not report anything - wait until we get more data
                // a request is pending at this time
                // need more data to sniff properly
                hr  = S_NEEDMOREDATA;
            }
            else if (hr == NOERROR || hr == E_PENDING)
            {
                TransAssert((_cbTotalBytesRead != 0));

                // report the data we have in the buffer or
                // the available #
                DWORD cbBytesReport =  (cbBytesAvailable > _cbTotalBytesRead) ? cbBytesAvailable : _cbTotalBytesRead + 1;

                if (dwTotalSize && ((cbBytesReport > dwTotalSize)))
                {
                    cbBytesReport =  dwTotalSize;
                }

               *pcbNewAvailable = cbBytesReport;
            }
        }
    }

    break;


    case DataSink_File:
    case DataSink_Storage:
    case DataSink_StreamOnFile:
    {
        DWORD dwNewData = 0;

        TransAssert((_pProt));

        if (_cbTotalBytesRead < _cbDataSniffMin)
        {
            _cbDataSniffMin =  (dwTotalSize && dwTotalSize < DATASNIFSIZEDOCFILE_MIN) ? dwTotalSize : DATASNIFSIZEDOCFILE_MIN;

            // read data into buffer and report progess
            hr = _pProt->Read(_lpBuffer + _cbBufferFilled, _cbBufferSize - _cbBufferFilled, &dwNewData);

            _cbTotalBytesRead += dwNewData;
            _cbBufferFilled += dwNewData;

            if ((hr == E_PENDING) && (_cbTotalBytesRead < _cbDataSniffMin))
            {
                // do not report anything - wait until we get more data
                // a request is pending at this time
                // need more data to sniff properly
                hr  = S_NEEDMOREDATA;
            }
            else if (hr == NOERROR || hr == E_PENDING)
            {
                TransAssert((_cbTotalBytesRead != 0));
            }
            *pcbNewAvailable = _cbTotalBytesRead;
        }

        // Note: read until pending or eof and report progress
        //       this is important to keep the download going
        if (hr == NOERROR)
        {
            // reset the buffer - don't overwrite sniffing data
            _cbBufferFilled = (_fMimeTypeVerified) ? 0 : _cbDataSniffMin;
            
            // bugbug: need special flag which indicates not to read if fully available
            //if (!(grfBSC & BSCF_DATAFULLYAVAILABLE))
            
            if (1)
            {
                //read as much data until S_OK or E_PENDING or error
                do
                {
                    hr = _pProt->Read(_lpBuffer + _cbBufferFilled, _cbBufferSize - _cbBufferFilled, &dwNewData);
                    _cbTotalBytesRead += dwNewData;

                } while (hr == NOERROR);

                // report available data
                if (hr == NOERROR || hr == E_PENDING)
                {
                    TransAssert((_cbTotalBytesRead != 0));
                }
                *pcbNewAvailable = (cbBytesAvailable > _cbTotalBytesRead) ? _cbTotalBytesRead : _cbTotalBytesRead;
            }
            else
            {
                TransAssert((dwTotalSize == cbBytesAvailable));
                *pcbNewAvailable = dwTotalSize;
            }

        }
    }
    break;

    default:
        TransAssert((FALSE && "CTransData::OnDataReceived -- Invalid data location"));
    break;
    }

    // cbBytesAvailable might be off be 1
    //TransAssert((cbBytesAvailable <= *pcbNewAvailable));

    PerfDbgLog1(tagCTransData, this, "-CTransData::OnDataReceived (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CTransData::OnStart
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    2-23-96   JohannP (Johann Posch)   Created
//
//  Notes:      TransData does not keep CINet alive
//              and will NOT call delete on it!
//
//----------------------------------------------------------------------------
STDMETHODIMP CTransData::OnStart(IOInetProtocol *pCINet)
{
    DEBUG_ENTER((DBG_TRANSDAT,
                Hresult,
                "CTransData::OnStart",
                "this=%#x, %#x",
                this, pCINet
                ));
                
    HRESULT hr = NOERROR;
    PerfDbgLog(tagCTransData, this, "+CTransData::OnStart");
    TransAssert((pCINet != NULL));

    if (_pProt)
    {
        _pProt->Release();
        _pProt = NULL;
    }

    switch (_ds)
    {
    case DataSink_StreamBindToObject:
    case DataSink_StreamNoCopyData:
    case DataSink_StreamOnFile:
    case DataSink_GenericStream:
    {
        TransAssert((_formatetc.tymed == TYMED_ISTREAM));
        // this point is not addref by CTransData
        TransAssert((_pProt == NULL));
        _pProt = pCINet;
    }
    break;

    case DataSink_Storage:
    {
        TransAssert((_formatetc.tymed == TYMED_ISTORAGE));
        // this point is not addref by CTransData
        TransAssert((_pProt == NULL));
        _pProt = pCINet;
    }
    break;


    case DataSink_File:
    {
        TransAssert((_formatetc.tymed == TYMED_FILE));
        // this point is not addref by CTransData
        TransAssert((_pProt == NULL));
        _pProt = pCINet;
    }
    break;

    default:
        TransAssert((FALSE && "Invalid data location"));
    break;
    }

    if (_pProt)
    {
        _pProt->AddRef();
    }
    else
    {
        TransAssert((FALSE));
    }

    PerfDbgLog1(tagCTransData, this, "-CTransData::OnStart (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CTransData::OnTerminate
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    1-27-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CTransData::OnTerminate()
{
    DEBUG_ENTER((DBG_TRANSDAT,
                Hresult,
                "CTransData::OnTerminate",
                "this=%#x",
                this
                ));
                
    HRESULT hr = NOERROR;
    PerfDbgLog(tagCTransData, this, "+CTransData::OnTerminate");

    TransAssert((_TransDataState < TransData_ProtoTerminated));

    switch (_ds)
    {

    case DataSink_Storage:
    case DataSink_File:
    {
        TransAssert((_formatetc.tymed == TYMED_FILE) || (_formatetc.tymed == TYMED_ISTORAGE));
        DbgLog2(tagCTransData, this, ">>> CTransData::OnTerminate (hr:%lx, _wzTempFile:%ws)", hr, _wzFileName);
    }
    break;

    case DataSink_StreamBindToObject:
    case DataSink_StreamNoCopyData:
    case DataSink_StreamOnFile:
    case DataSink_GenericStream:
    {
        TransAssert((_formatetc.tymed == TYMED_ISTREAM));
        TransAssert((_pProt != NULL));
    }
    break;
    default:
        TransAssert((FALSE && "Invalid data location"));
    break;
    }

    if (_pBndCtx)
    {
        _pBndCtx->Release();
        _pBndCtx = NULL;
    }

    PerfDbgLog1(tagCTransData, this, "-CTransData::OnTerminate (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CTransData::FindFormatETC
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    1-27-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CTransData::FindFormatETC()
{
    DEBUG_ENTER((DBG_TRANSDAT,
                Hresult,
                "CTransData::FindFormatETC",
                "this=%#x",
                this
                ));
                
    HRESULT hr = NOERROR;
    PerfDbgLog1(tagCTransData, this, "+CTransData::FindFormatETC (_cbBufferFilled:%ld)", _cbBufferFilled);

    _formatetc.ptd = NULL;
    _formatetc.dwAspect = DVASPECT_CONTENT;
    _formatetc.lindex = -1;

    _formatetc.cfFormat = 0;
    TransAssert((   _formatetc.tymed == TYMED_ISTREAM
                 || _formatetc.tymed == TYMED_FILE
                 || _formatetc.tymed == TYMED_ISTORAGE ));

    LPCWSTR pwzStrOrg = GetMimeType();
    LPCWSTR pwzStr = pwzStrOrg;

    // If not already done so, attempt to
    // verify mime type by examining data.
    if (!_fMimeTypeVerified)
    {
        DWORD dwFlags = 0;
        DWORD dwSniffFlags = 0;
        DWORD cbLen = sizeof(dwFlags);
        LPWSTR pwzFileName = GetFileName();
        LPWSTR pwzStrOut = 0;



        // the buffer should contain data if the no mime
        TransAssert((    (_cbBufferFilled == 0 && (pwzStr || pwzFileName))
                     ||  ( _cbBufferFilled != 0) ));

        FindMimeFromData(NULL, pwzFileName,_lpBuffer, _cbBufferFilled, pwzStrOrg, dwSniffFlags,  &pwzStrOut, 0);

        if (pwzStrOut)
        {
            SetMimeType(pwzStrOut);
            pwzStr = GetMimeType();
        }
        
        delete [] pwzStrOut;
        _fMimeTypeVerified = TRUE;
    }

    // the new mime should never be NULL if we had a proposed mime
    TransAssert((   (pwzStrOrg && pwzStr)
                 || (pwzStrOrg == NULL)     ));

    if (pwzStr)
    {
        char szMime[SZMIMESIZE_MAX];
        W2A(pwzStr, szMime, SZMIMESIZE_MAX);

        CLIPFORMAT cfType;
        if (FindMediaTypeW(pwzStr,&cfType) != NOERROR)
        {
            _formatetc.cfFormat = (CLIPFORMAT) RegisterClipboardFormat(szMime);
        }
        else
        {
            _formatetc.cfFormat = cfType;
        }
    }
    else
    {
        _formatetc.cfFormat = CF_NULL;
    }

    // Check if the format that we got is one of the format that
    // is requested, and if so, use it
#ifdef UNUSED
    if (_pEnumFE)
    {
        FORMATETC FmtetcT;
        BOOL fDone = FALSE;

        _pEnumFE->Reset();

        while (!fDone && ((hr = _pEnumFE->Next(1, &FmtetcT,NULL)) == NOERROR))
        {
            TransAssert((SUCCEEDED(hr)));

            if (FmtetcT.cfFormat == _cfFormat)
            {
                _formatetc.cfFormat = _cfFormat;
            }
        }
    }
#endif //UNUSED

    PerfDbgLog3(tagCTransData, this, "-CTransData::FindFormatETC (hr:%lx, szStr:%ws, _formatetc.cfFormat:%lx)", hr, pwzStr?pwzStr:L"", _formatetc.cfFormat);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CTransData::GetAcceptStr
//
//  Synopsis:
//
//  Arguments:  [ppwzStr] --
//              [pcElements] --
//
//  Returns:
//
//  History:    3-29-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CTransData::GetAcceptStr(LPWSTR *ppwzStr, ULONG *pcElements)
{
    DEBUG_ENTER((DBG_TRANSDAT,
                Hresult,
                "CTransData::GetAcceptStr",
                "this=%#x, %#x, %#x",
                this, ppwzStr, pcElements
                ));
                
    HRESULT hr = NOERROR;
    PerfDbgLog(tagCTransData, this, "+CTransData::GetAcceptStr");
    IEnumFORMATETC *pIEnumFE = NULL;

    TransAssert((ppwzStr));
    TransAssert((*pcElements > 0));

    CHAR pszUnknownName[MAX_PATH];
    ULONG cMimes = 0;
    
    *ppwzStr = 0;
    hr = GetObjectParam(_pBndCtx, REG_ENUMFORMATETC, IID_IEnumFORMATETC, (IUnknown**)&pIEnumFE);

    if (hr == NOERROR)
    {
        BOOL fCF_NULL = FALSE;
        #define ELEMENTS 10
        ULONG cElementsIn = ELEMENTS;
        ULONG cElements = 0;
        FORMATETC rgFormatEtc[ELEMENTS];


        pIEnumFE->Reset();
        // find # of elements
        do
        {
            ULONG cEl = 0;
            hr = pIEnumFE->Next(cElementsIn, rgFormatEtc ,&cEl);
            cElements += cEl;
        } while (hr == S_OK);

        UrlMkAssert((cElements > 0));

        if  (   (cElements > 0)
             && (hr == S_OK || hr == S_FALSE))
        {

            {
                ULONG cElementsOut = 0;
                pIEnumFE->Reset();
                do
                {
                    ULONG cEl = 0;
                    FORMATETC *pFmtEtc = rgFormatEtc;

                    hr = pIEnumFE->Next(cElementsIn, rgFormatEtc ,&cEl);                    
                    cElementsOut += cEl;
                    // (hr==S_FALSE) => (cElementsOut==cEl)
                    UrlMkAssert((!(hr==S_FALSE) || (cElementsOut == cElements)));

                    // On the last call to ->Next() enumerator, we get back an S_FALSE
                    // if the # of elements received (cEl) < asked for (cElementsIn)
                    if ((cElementsOut == cElements) && (hr == S_FALSE))
                        hr = S_OK;

                    for (ULONG i = 0; i < cEl; i++)
                    {
                        if( cMimes >=  (*pcElements - 1)  )
                        {
                            // exceeding the income array size, stop
                            break;
                        }


                        LPSTR szFormat = NULL;
                        CLIPFORMAT  cfFormat = (pFmtEtc + i)->cfFormat;
                        if (cfFormat == CF_NULL)
                        {
                            fCF_NULL = TRUE;
                        }
                        else
                        {
                            hr = FindMediaString(cfFormat, &szFormat);
                            if (hr != NOERROR || !szFormat)
                            {
                                // unknown cfFormat
                                if( GetClipboardFormatName(cfFormat, pszUnknownName, MAX_PATH))
                                {
                                    hr = NOERROR;
                                    szFormat = pszUnknownName;
                                } 
                                else
                                {
                                    // word97 will send out cfFormat=1
                                    // which associated to "" string
                                    hr = NOERROR;
                                }
                            }
                            if( szFormat )
                            {

                                *(ppwzStr + cMimes)= NULL; 
                                *(ppwzStr + cMimes) = DupA2W(szFormat);
                                if( *(ppwzStr + cMimes) )
                                {
                                    cMimes++;
                                } 
                                else
                                {
                                    hr = E_OUTOFMEMORY;
                                    break;
                                }
                            }
                        }
                    }

                } while ( (cElementsOut < cElements) && (hr == NOERROR) );

                // append the cf_null (*/*)
                if( hr == NOERROR && (fCF_NULL || (cMimes == 0)) )
                {
                    *(ppwzStr + cMimes) = DupA2W(g_szCF_NULL);
                    if( !*(ppwzStr + cMimes) )
                    {
                        hr = E_OUTOFMEMORY;
                    } 
                    else
                    { 
                        cMimes++;
                        hr = NOERROR;
                    }
                }

                if( hr == NOERROR )
                {
                    *(ppwzStr + cMimes) = NULL;
                }
            }
        }

        pIEnumFE->Release();
    }
    else
    {
        {
            *ppwzStr = DupA2W(g_szCF_NULL);
            if( *ppwzStr )
            {
                cMimes = 1;
                *(ppwzStr + 1) = NULL;
                hr = NOERROR;
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }

    if( hr == NOERROR )
    {
        *pcElements = cMimes;
    }
    else
    {
        *pcElements = 0;
        if( cMimes >= 1 )
        {
            for( ULONG i = 0; i < cMimes; i ++)
            {
                delete [] *(ppwzStr + i);
            }
        }
        *ppwzStr = NULL;
    }

    PerfDbgLog1(tagCTransData, this, "-CTransData::GetAcceptStr (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CTransData::GetAcceptMimes
//
//  Synopsis:
//
//  Arguments:  [ppStr] --
//
//  Returns:
//
//  History:    3-29-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CTransData::GetAcceptMimes(LPWSTR *ppwzStr, ULONG cel, ULONG *pcElements)
{
    DEBUG_ENTER((DBG_TRANSDAT,
                Hresult,
                "CTransData::GetAcceptMimes",
                "this=%#x, %#x, %#x, %#x",
                this, ppwzStr, cel, pcElements
                ));
                
    HRESULT hr = NOERROR;
    PerfDbgLog(tagCTransData, this, "+CTransData::GetAcceptMimes");

    TransAssert((ppwzStr && pcElements && *pcElements));

    if (ppwzStr && pcElements)
    {
        if( *pcElements > 1 )
        {
            hr = GetAcceptStr( ppwzStr, pcElements );
        }
        else if( *pcElements == 1)
        {
            // zero terminated 
            *ppwzStr = NULL;
        }
        else
        {
            hr =  E_INVALIDARG;
        }
    }
    else
    {
        hr =  E_INVALIDARG;
    }
    PerfDbgLog1(tagCTransData, this, "-CTransData::GetAcceptMimes (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CTransData::SetClipFormat
//
//  Synopsis:
//
//  Arguments:  [cfFormat] --
//
//  Returns:
//
//  History:    1-27-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CTransData::SetClipFormat(CLIPFORMAT  cfFormat)
{
    DEBUG_ENTER((DBG_TRANSDAT,
                Hresult,
                "CTransData::SetClipFormat",
                "this=%#x, %#x",
                this, cfFormat
                ));
                
    HRESULT hr = NOERROR;
    PerfDbgLog(tagCTransData, this, "+CTransData::SetClipFormat");

    _cfFormat = cfFormat;

    PerfDbgLog1(tagCTransData, this, "-CTransData::SetClipFormat (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CTransData::IsObjectReady
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    1-27-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CTransData::IsObjectReady(  )
{
    DEBUG_ENTER((DBG_TRANSDAT,
                Hresult,
                "CTransData::IsObjectReady",
                "this=%#x",
                this
                ));
                
    HRESULT hr = E_FAIL;
    PerfDbgLog(tagCTransData, this, "+CTransData::IsObjectReady");

    // check size and
    if ((_cbDataSize != 0) && (_cbDataSize == _cbTotalBytesRead))
    {
        hr = NOERROR;
    }

    PerfDbgLog3(tagCTransData, this, "-CTransData::IsObjectReady (hr:%lx, _cbDataSize:%ld, _cbTotalBytesRead:%ld)", hr, _cbDataSize, _cbTotalBytesRead);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CTransData::InProgress
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    1-27-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CTransData::InProgress()
{
    DEBUG_ENTER((DBG_TRANSDAT,
                Hresult,
                "CTransData::InProgress",
                "this=%#x",
                this
                ));
                
    HRESULT hr = S_FALSE;
    PerfDbgLog(tagCTransData, this, "+CTransData::InProgress");

    if (_grfBSC & (BSCF_LASTDATANOTIFICATION | BSCF_FIRSTDATANOTIFICATION))
    {
        hr = S_FALSE;
    }
    else if (_cbTotalBytesRead == 0)
    {
        // check if some bits already in the buffer

        hr = S_OK;
    }

    PerfDbgLog1(tagCTransData, this, "-CTransData::InProgress (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CTransData::GetFileName
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    1-27-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
LPWSTR CTransData::GetFileName()
{
    DEBUG_ENTER((DBG_TRANSDAT,
                Pointer,
                "CTransData::GetFileName",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCTransData, this, "+CTransData::GetFileName");
    LPWSTR pwzFileName = NULL;

    //TransAssert((_wzFileName[0] != 0));

    if (_wzFileName[0] != 0)
    {
        pwzFileName = _wzFileName;
    }

    PerfDbgLog1(tagCTransData, this, "-CTransData::GetFileName (szFile:%ws)", pwzFileName?pwzFileName:L"");

    DEBUG_LEAVE(pwzFileName);
    return pwzFileName;
}

//+---------------------------------------------------------------------------
//
//  Method:     CTransData::GetClassID
//
//  Synopsis:
//
//  Arguments:  [pclsid] --
//              [fReOpen] --
//
//  Returns:
//
//  History:    1-27-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CTransData::GetClassID(CLSID clsidIn, CLSID *pclsid)
{
    DEBUG_ENTER((DBG_TRANSDAT,
                Hresult,
                "CTransData::GetClassID",
                "this=%#x, %#x, %#x",
                this, clsidIn, pclsid
                ));
                
    PerfDbgLog(tagCTransData, this, "+CTransData::GetClassID");
    WCHAR wzMime[SZMIMESIZE_MAX];
    HRESULT hr;
    LPWSTR pwzTempFile = NULL;

    DWORD fIgnoreMimeClsid = GetBindFlags() & BINDF_IGNOREMIMECLSID;
    LPCWSTR pwzMime = GetMimeType();

    pwzTempFile = GetFileName();

    if (   (_cbBufferFilled != 0)
             && (_cbTotalBytesRead <= _cbBufferSize)
             && (IsDocFile(_lpBuffer, _cbBufferFilled) == S_OK))
    {
        _fDocFile = TRUE;
        _fMimeTypeVerified = TRUE;

        // Storage file (docfile) case
        // GetClassFileOrMime takes care of class mapping
        hr = GetClassFileOrMime2(_pBndCtx, pwzTempFile, _lpBuffer, _cbBufferFilled, pwzMime, 0, pclsid, fIgnoreMimeClsid);
        if (hr != NOERROR)
        {
            // S_FALSE means keep downloading
            hr = S_FALSE;
        }
    }
    else
    {
        if (!_fMimeTypeVerified)
        {
            DWORD dwFlags = 0;
            DWORD dwSniffFlags = 0;
            DWORD cbLen = sizeof(dwFlags);

            LPWSTR  pwzStr = 0;
            FindMimeFromData(NULL, pwzTempFile, _lpBuffer, _cbBufferFilled, pwzMime, dwSniffFlags,  &pwzStr, 0);
            if (pwzStr)
            {
                SetMimeType(pwzStr);
            }
            _fMimeTypeVerified = TRUE;
            delete [] pwzStr;
        }

        hr = GetClassFileOrMime2(_pBndCtx, pwzTempFile, NULL, 0, pwzMime, 0, pclsid, fIgnoreMimeClsid);
    }

    #if DBG==1
    if (hr == NOERROR)
    {
        LPOLESTR pszStr;
        StringFromCLSID(*pclsid, &pszStr);
        DbgLog2(tagCTransData, this, "CTransData::GetClassID (file:%ws)(class:%ws)",
            pwzTempFile, pszStr);
        delete pszStr;
    }
    #endif

    PerfDbgLog1(tagCTransData, this, "-CTransData::GetClassID (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CTransData::SetMimeType
//
//  Synopsis:
//
//  Arguments:  [pszMime] --
//
//  Returns:
//
//  History:    2-07-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CTransData::SetMimeType(LPCWSTR pwzMime)
{
    DEBUG_ENTER((DBG_TRANSDAT,
                Hresult,
                "CTransData::SetMimeType",
                "this=%#x, %.80wq",
                this, pwzMime
                ));
                
    PerfDbgLog2(tagCTransData, this, "+CTransData::SetMimeType (OldMime:%ws; MimeStr:%ws)", _wzMime?_wzMime:L"", pwzMime?pwzMime:L"");
    HRESULT hr = NOERROR;

    if (pwzMime)
    {

        #if DBG_XXX
        if (pwzMime)
        {
            if (   !wcscmp(_wzMime, CFWSTR_MIME_HTML)
                || !wcscmp(_wzMime, CFWSTR_MIME_TEXT))
            {
                if (   !wcscmp(pwzMime, CFWSTR_MIME_RAWDATA)
                    || !wcscmp(pwzMime,L"application/octet-stream"))
                {
                    DbgLog2(tagCTransDataErr, "=== SetMimeType: OldMime:%ws, NewMime:%ws",
                        _wzMime, pwzMime);
                    //TransAssert((FALSE));
                }
            }
        }

        if (_wzMime[0] != 0 && strcmp(_wzMime,pwzMime))
        {
            DbgLog2(tagTransDataErr, "=== SetMimeType: OldMime:%s, NewMime:%s",
                _wzMime, pwzMime);
        }

        #endif //DBG


        DWORD cLen = wcslen((LPWSTR)pwzMime);

        if (cLen >= SZMIMESIZE_MAX)
        {
            cLen = SZMIMESIZE_MAX - 1;
            wcsncpy(_wzMime, (LPWSTR)pwzMime, cLen);
            _wzMime[cLen] = 0;
        }
        else
        {
            wcscpy(_wzMime, (LPWSTR)pwzMime);
        }
    }
    else
    {
        DbgLog(tagCTransDataErr, this, "CTransData::SetMimeType ->invalid mime");
    }

    PerfDbgLog2(tagCTransData, this, "-CTransData::SetMimeType (hr:%lx, Mime:%ws)", hr,_wzMime?_wzMime:L"");

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CTransData::SetFileName
//
//  Synopsis:
//
//  Arguments:  [szFile] --
//
//  Returns:
//
//  History:    1-27-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CTransData::SetFileName(LPWSTR pwzFile)
{
    DEBUG_ENTER((DBG_TRANSDAT,
                Hresult,
                "CTransData::SetFileName",
                "this=%#x, %.80wq",
                this, pwzFile
                ));
                
    PerfDbgLog(tagCTransData, this, "+CTransData::SetFileName");

    TransAssert((pwzFile));
    if(pwzFile)
    {
        wcscpy(_wzFileName, pwzFile);
    }

    PerfDbgLog2(tagCTransData, this, "-CTransData::SetFileName (_wzFileName:%ws, hr:%lx)", _wzFileName?_wzFileName:L"", NOERROR);

    DEBUG_LEAVE(NOERROR);
    return NOERROR;
}

//+---------------------------------------------------------------------------
//
//  Method:     CTransData::GetMimeType
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    4-24-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
LPCWSTR CTransData::GetMimeType()
{
    DEBUG_ENTER((DBG_TRANSDAT,
                Pointer,
                "CTransData::GetMimeType",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCTransData, this, "+CTransData::GetMimeType");
    LPWSTR pwzStr = NULL;

    if (_wzMime[0] != 0)
    {
        pwzStr = _wzMime;
    }

    PerfDbgLog1(tagCTransData, this, "-CTransData::GetMimeType (pStr:%ws)", pwzStr?pwzStr:L"");

    DEBUG_LEAVE(pwzStr);
    return pwzStr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CTransData::OnEndofData()
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    7-30-97   DanpoZ(Danpo Zhang)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
void CTransData::OnEndofData()
{
    DEBUG_ENTER((DBG_TRANSDAT,
                None,
                "CTransData::OnEndofData",
                "this=%#x",
                this
                ));
                
    PerfDbgLog1(tagCTransData, this, "+CTransData::OnEndofData(_ds:%ld)", _ds);
    BOOL fNewStgMed = FALSE;

    if (_pStgMed  && _ds == DataSink_StreamOnFile && _pStgMed->pstm )
    {
        ((CReadOnlyStreamFile*)(_pStgMed->pstm))->SetDataFullyAvailable();
    }

    PerfDbgLog(tagCTransData, this, "-CTransData::OnEndofData");

    DEBUG_LEAVE(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\trans\transapi.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       transapi.cxx
//
//  Contents:   API's for internal use
//
//  Classes:
//
//  Functions:
//
//  History:    4-26-96   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------
#include <trans.h>
#include "oinet.hxx"
#include <shlwapi.h>
#include <shlwapip.h>
#include <winineti.h>
#include "datasnif.hxx"
#include <winver.h> 
#include <mshtml.h>

PerfDbgTag(tagTransApi, "Urlmon", "Log Trans API", DEB_DATA);

static char szMimeKey[]     = "MIME\\Database\\Content Type\\";
const ULONG ulMimeKeyLen    = ((sizeof(szMimeKey)/sizeof(char))-1);
LPCSTR pszDocObject         = "DocObject";
LPCSTR pszInprocServer      = "InprocServer32";
LPCSTR pszLocalServer       = "LocalServer32";

#define INTERNET_SETTING_KEY    "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Internet Settings"

extern LPSTR        g_pszUserAgentString;
extern BYTE         g_bShortcircuitKnownProtocols;
HMODULE             g_hLibPluginOcx = NULL;

HRESULT GetClassDocFileBuffer(LPVOID pbuffer, DWORD dwSize, CLSID *pclsid);

// borrow from urlmon\download to check if Doc Object handler is installed
// need CLocalComponentInfo & IsControlLocallyInstalled
#ifndef unix
#include "..\download\cdl.h"
#else
#include "../download/cdl.h"
#endif /* unix */

// DocFile properties and constants for extracting CodeBase property
#define DOCFILE_NUMPROPERTIES 3
#define DOCFILE_PROPID_CODEBASE 3
#define DOCFILE_PROPID_MAJORVERSION 4
#define DOCFILE_PROPID_MINORVERSION 5

//
// this new apis should be made public
//
STDAPI URLDownloadW(IUnknown *pUnk, LPCWSTR pwzURL, DWORD pBindInfo, IBindStatusCallback *pBSCB, DWORD dwReserved);
STDAPI URLDownloadA(IUnknown *pUnk, LPCSTR  pszURL, DWORD pBindInfo, IBindStatusCallback *pBSCB, DWORD dwReserved);

#define CF_INGNORE_SLASH 0x00000001     //ignore slash when comparing urls

typedef enum tagCLSCTXEX
{
/*
    // ole default class context values
    CLSCTX_INPROC_SERVER            = 0x0001,
    CLSCTX_INPROC_HANDLER           = 0x0002,
    CLSCTX_LOCAL_SERVER             = 0x0004,
    CLSCTX_INPROC_SERVER16          = 0x0008,
    CLSCTX_REMOTE_SERVER            = 0x0010,
    CLSCTX_INPROC_HANDLER16         = 0x0020,
    CLSCTX_INPROC_SERVERX86         = 0x0040,
    CLSCTX_INPROC_HANDLERX86        = 0x0080
*/
    // new class context values used in GetClassFileOrMime
    CLSCTX_INPROC_DOCOBJECT         = 0x0100,
    CLSCTX_LOCAL_DOCOBJECT          = 0x0200,
    CLSCTX_INPROC_CONTROL           = 0x0400,
    CLSCTX_INPROC_X_CONTROL         = 0x0800,
    CLSCTX_INPROC_PLUGIN            = 0x1000
}   CLSCTXEX;

#define CLSCTX_DOCOBJECT (CLSCTX_INPROC_DOCOBJECT|CLSCTX_LOCAL_DOCOBJECT)

const GUID CLSID_PluginHost =
{
    0x25336921, 0x03F9, 0x11cf, {0x8F, 0xD0, 0x00, 0xAA, 0x00, 0x68, 0x6F, 0x13}
};
const GUID CLSID_MsHtml =
{
    0x25336920, 0x03F9, 0x11cf, {0x8F, 0xD0, 0x00, 0xAA, 0x00, 0x68, 0x6F, 0x13}
};

const GUID FMTID_CodeBase =
{
    0xfe2d9191, 0x7fba, 0x11d0, {0xb3, 0xc2, 0x00, 0xa0, 0xc9, 0x0a, 0xea, 0x82}
};


//+---------------------------------------------------------------------------
//
//  Function:   GetClsIDInfo
//
//  Synopsis:
//
//  Arguments:  [pclsid] --     class id
//              [ClsCtxIn] --   unused
//              [pClsCtx] --    class context of class passed in
//
//  Returns:    S_OK on success
//              E_OUTOFMEMORY
//              E_FAIL
//
//  History:    7-20-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT GetClsIDInfo(CLSID *pclsid, DWORD ClsCtxIn, DWORD *pClsCtx)
{
    DEBUG_ENTER((DBG_TRANSDAT,
                Hresult,
                "GetClsIDInfo",
                "%#x, %#x, %#x",
                pclsid, ClsCtxIn, pClsCtx
                ));
                
    PerfDbgLog(tagTransApi, NULL, "+GetClsIDInfo");
    HRESULT hr = E_FAIL;

    TransAssert(( pClsCtx && pclsid && !IsEqualGUID(*pclsid, CLSID_NULL) ));

    LPSTR pszCls = StringAFromCLSID(pclsid);

    if (!pszCls)
    {
        hr = E_OUTOFMEMORY;
        *pClsCtx = 0;
    }
    else
    {
        CHAR  szCLSID[CLSIDSTR_MAX + 8];
        HKEY  hClsRegEntry;
        CHAR  szValue[64];
        long  lSize;
        DWORD dwClsCtx = 0;

        strcpy(szCLSID, "CLSID\\");
        strcat(szCLSID, pszCls);

        if (RegOpenKey(HKEY_CLASSES_ROOT, szCLSID, &hClsRegEntry) == ERROR_SUCCESS)
        {
            lSize = 64;
            HKEY hkeySrv32;
            if( RegOpenKey(hClsRegEntry, pszInprocServer, &hkeySrv32) 
                == ERROR_SUCCESS)
            {
                dwClsCtx |= CLSCTX_INPROC;
                RegCloseKey(hkeySrv32);
            }

            lSize = 64;
            if (RegQueryValue(hClsRegEntry, pszLocalServer, szValue, &lSize) == ERROR_SUCCESS)
            {
                dwClsCtx |= CLSCTX_LOCAL_SERVER;
            }
            lSize = 64;
            if (RegQueryValue(hClsRegEntry, pszDocObject, szValue, &lSize) == ERROR_SUCCESS)
            {
                dwClsCtx |= CLSCTX_INPROC_DOCOBJECT;
            }

            RegCloseKey(hClsRegEntry);
        }

        if (dwClsCtx)
        {
            hr = S_OK;
            *pClsCtx = dwClsCtx;
        }

        delete pszCls;
    }

    PerfDbgLog1(tagTransApi, NULL, "-GetClsIDInfo (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   FindFileExtension
//
//  Synopsis:
//
//  Arguments:  [pszFileName] --
//
//  Returns:
//
//  History:    2-09-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
LPSTR FindFileExtension(LPSTR pszFileName)
{
    DEBUG_ENTER((DBG_TRANSDAT,
                String,
                "FindFileExtension",
                "%.80q",
                pszFileName
                ));
            
    PerfDbgLog1(tagTransApi, NULL, "+FindFileExtension (szFileName:%s)", pszFileName);
    LPSTR pStr = NULL;

    if (pszFileName)
    {
        LPSTR lpF = pszFileName + strlen(pszFileName);

        if (lpF)
        {
            while (lpF >= pszFileName)
            {
                if (*lpF=='.')
                {
                    pStr = lpF;
                    break;
                }
                if (*lpF=='/')
                {
                    break;
                }
                lpF--;
            }
        }
    }

    PerfDbgLog1(tagTransApi, NULL, "-FindFileExtension (pStr:%s)", pStr);

    DEBUG_LEAVE(pStr);
    return pStr;
}

//+---------------------------------------------------------------------------
//
//  Function:   IsDocFile
//
//  Synopsis:
//
//  Arguments:  [pBuffer] --
//
//  Returns:    S_OK            buffer is begin of docfile
//              S_FALSE         not begin of docfile
//              E_INVALIDARG    arguments incorrect
//
//  History:    2-09-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT IsDocFile(LPVOID pBuffer, DWORD cbSize)
{
    DEBUG_ENTER((DBG_TRANSDAT,
                Hresult,
                "IsDocFile",
                "%#x, %#x",
                pBuffer, cbSize
                ));
                
    PerfDbgLog(tagTransApi, NULL, "+IsDocFile");
    HRESULT hr;

    // The byte combination that identifies that a file is a storage of
    // some kind
    BYTE SIGSTG[] = {0xd0, 0xcf, 0x11, 0xe0, 0xa1, 0xb1, 0x1a, 0xe1};
    BYTE CBSIGSTG = sizeof(SIGSTG);

    TransAssert(((pBuffer != NULL) &&  (cbSize != 0) ));

    if (!pBuffer  || (cbSize == 0))
    {
        hr = E_INVALIDARG;
    }
    else
    {
        hr = (!memcmp(pBuffer, SIGSTG, CBSIGSTG)) ? S_OK : S_FALSE;
    }

    PerfDbgLog1(tagTransApi, NULL, "-IsDocFile (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   GetMimeFromExt
//
//  Synopsis:
//
//  Arguments:  [pszExt] --
//              [pszMime] --
//              [cbMime] --
//
//  Returns:
//
//  History:    4-23-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT GetMimeFromExt(LPSTR pszExt, LPSTR pszMime, DWORD *pcbMime)
{
    DEBUG_ENTER((DBG_TRANSDAT,
                Hresult,
                "GetMimeFromExt",
                "%.80q, %.80q, %#x",
                pszExt, pszMime, pcbMime
                ));
                
    PerfDbgLog1(tagTransApi, NULL, "+GetMimeFromExt (szExt:%s)", pszExt);
    HRESULT hr = E_FAIL;

    *pszMime = '\0';
    TransAssert((pszExt[0] == '.'));

    // the entry begins with '.' so it may be a file extension
    // query the value (which is the ProgID)

    HKEY hMimeKey = NULL;

    if (RegOpenKeyEx(HKEY_CLASSES_ROOT, pszExt, 0, KEY_QUERY_VALUE, &hMimeKey) == ERROR_SUCCESS)
    {
        DWORD dwType = 1;
        if (RegQueryValueEx(hMimeKey, szContent, NULL, &dwType, (LPBYTE)pszMime, pcbMime) == ERROR_SUCCESS)
        {
            hr = NOERROR;
        }
        RegCloseKey(hMimeKey);
    }

    PerfDbgLog2(tagTransApi, NULL, "-GetMimeFromExt (pszMime:%s, hr:%lx)", pszMime, hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   GetMimeFileExtension
//
//  Synopsis:
//
//  Arguments:  [pszMime] --
//              [pclsid] --
//
//  Returns:
//
//  History:    2-22-96   JohannP (Johann Posch)   Created
//
//  Notes:      BUGBUG: needs to be optimized!
//
//----------------------------------------------------------------------------
HRESULT GetMimeFileExtension(LPSTR pszMime, LPSTR pszExt, DWORD cbSize)
{
    DEBUG_ENTER((DBG_TRANSDAT,
                Hresult,
                "GetMimeFileExtension",
                "%.80q, %.80q, %#x",
                pszMime, pszExt, cbSize
                ));
                
    PerfDbgLog1(tagTransApi, NULL, "+GetMimeFileExtension (MimeStr:%s)", pszMime);
    HRESULT hr = REGDB_E_CLASSNOTREG;

    HKEY hMimeKey = NULL;
    DWORD dwError;
    DWORD dwType;
    char szValue[256];
    DWORD dwValueLen = 256;
    char szKey[SZMIMESIZE_MAX + ulMimeKeyLen];

    if ((pszMime == 0) || (pszExt == 0))
    {
        hr = E_INVALIDARG;
    }
    else
    {
        *pszExt = 0;

        strcpy(szKey, szMimeKey);
        strncat(szKey,pszMime, SZMIMESIZE_MAX);

        switch (RegOpenKeyEx(HKEY_CLASSES_ROOT, szKey, 0, KEY_QUERY_VALUE, &hMimeKey))
        {
            case ERROR_SUCCESS:
                hr = NOERROR;
            break;
            // win32 will return file not found instead of bad key
            case ERROR_FILE_NOT_FOUND:
            case ERROR_BADKEY:
                hr = REGDB_E_CLASSNOTREG;
            break;
            default:
                hr = REGDB_E_READREGDB;
            break;
        }
        if (hr == NOERROR)
        {
            dwValueLen = 256;
            dwError = RegQueryValueEx(hMimeKey
                                        , szExtension
                                        , NULL
                                        , &dwType
                                        , (LPBYTE)szValue
                                        , &dwValueLen);

            if (  (dwError == ERROR_SUCCESS)
                && pszExt
                && dwValueLen
                && (dwValueLen <= cbSize) )
            {
                StrNCpy(pszExt, szValue, dwValueLen);
            }
        }
    }

    if (hMimeKey)
    {
        RegCloseKey(hMimeKey);
    }

    PerfDbgLog2(tagTransApi, NULL, "-GetMimeFileExtension (hr:%lx, szExt:%s)", hr, pszExt);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   GetClassMime
//
//  Synopsis:
//
//  Arguments:  [pszMime] --
//              [pclsid] --
//              [fIgnoreMimeClsid] --
//
//  Returns:
//
//  History:    2-07-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT GetClassMime(LPSTR pszMime, CLSID *pclsid, BOOL fIgnoreMimeClsid)
{
    DEBUG_ENTER((DBG_TRANSDAT,
                Hresult,
                "GetClassMime",
                "%.80q, %#x, %B",
                pszMime, pclsid, fIgnoreMimeClsid
                ));
                
    PerfDbgLog1(tagTransApi, NULL, "+GetClassMime (MimeStr:%s)", pszMime);
    HRESULT hr = REGDB_E_CLASSNOTREG;
    DWORD dwFlags = (fIgnoreMimeClsid) ? MIMEFLAGS_IGNOREMIME_CLASSID: 0;
    HKEY hMimeKey = NULL;
    DWORD dwClsCtx;

    DWORD dwError;
    DWORD dwType;
    char szValue[256];
    DWORD dwValueLen = 256;
    char szKey[SZMIMESIZE_MAX + ulMimeKeyLen];

    if ((pszMime == 0) || (*pszMime == 0))
    {
        hr = E_INVALIDARG;
    }
    else
    {
        strcpy(szKey, szMimeKey);
        strcat(szKey, pszMime);

        switch (RegOpenKeyEx(HKEY_CLASSES_ROOT, szKey, 0, KEY_QUERY_VALUE, &hMimeKey))
        {
            case ERROR_SUCCESS:
                hr = NOERROR;
            break;
            // win32 will return file not found instead of bad key
            case ERROR_FILE_NOT_FOUND:
            case ERROR_BADKEY:
                hr = REGDB_E_CLASSNOTREG;
            break;
            default:
                hr = REGDB_E_READREGDB;
            break;
        }
        if (hr == NOERROR)
        {
            // if fIgnoreMimeClsid is set, ignore the CLSID entry
            // in the HKCR\MIME tree.
            if (!fIgnoreMimeClsid)
            {
                dwError = RegQueryValueEx(hMimeKey, szClassID, NULL
                                        , &dwType, (LPBYTE)szValue, &dwValueLen);

                hr = REGDB_E_CLASSNOTREG;


                if (dwError == ERROR_SUCCESS)
                {
                    WCHAR sz[256];
                    A2W(szValue,sz,256);
                    hr = CLSIDFromString(sz, pclsid);
                }

                if (hr == NOERROR)
                {
                    goto End;
                }
            }

            hr = REGDB_E_CLASSNOTREG;

            dwValueLen = 256;
            dwError = RegQueryValueEx(hMimeKey
                                        , szExtension
                                        , NULL
                                        , &dwType
                                        , (LPBYTE)szValue
                                        , &dwValueLen);

            if (dwError == ERROR_SUCCESS)
            {

                hr = GetClassFromExt(szValue,pclsid);
                //class still not known
                // try extension
            }
        }
    }

End:
    if (hMimeKey)
    {
        RegCloseKey(hMimeKey);
    }

    PerfDbgLog1(tagTransApi, NULL, "-GetClassMime (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   GetMimeFlags
//
//  Synopsis:
//
//  Arguments:  [pszMime] --
//              [pdwFlags] --
//
//  Returns:
//
//  History:    2-07-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT GetMimeFlags(LPCWSTR pwzMime, DWORD *pdwFlags)
{
    DEBUG_ENTER((DBG_TRANSDAT,
                Hresult,
                "GetMimeFlags",
                "%.80wq, %#x",
                pwzMime, pdwFlags
                ));
                
    TransDebugOut((DEB_DATA, "API _IN GetMimeFlags (MimeStr:%ws)\n", pwzMime));
    HRESULT hr = E_FAIL;

    HKEY hMimeKey = NULL;
    DWORD dwError;
    DWORD dwType;
    DWORD dwFlags = 0;
    char szValue[256];
    DWORD dwValueLen = 256;
    char szKey[SZMIMESIZE_MAX + ulMimeKeyLen];

    if ((pwzMime == 0) || (*pwzMime == 0) || !pdwFlags)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        strcpy(szKey, szMimeKey);
        W2A(pwzMime, szKey + ulMimeKeyLen, SZMIMESIZE_MAX);

        *pdwFlags = 0;

        switch (RegOpenKeyEx(HKEY_CLASSES_ROOT, szKey, 0, KEY_QUERY_VALUE, &hMimeKey))
        {
            case ERROR_SUCCESS:
                hr = NOERROR;
            break;
            // win32 will return file not found instead of bad key
            case ERROR_FILE_NOT_FOUND:
            case ERROR_BADKEY:
                hr = REGDB_E_CLASSNOTREG;
            break;
            default:
                hr = REGDB_E_READREGDB;
            break;
        }
        if (hr == NOERROR)
        {
            dwValueLen = sizeof(DWORD);
            dwError = RegQueryValueEx(hMimeKey, szFlags, NULL
                                    , &dwType, (LPBYTE)&dwFlags, &dwValueLen);

            hr = E_FAIL;

            if (dwError == ERROR_SUCCESS)
            {
                *pdwFlags = dwFlags;
                hr = NOERROR;
            }
        }
    }

    if (hMimeKey)
    {
        RegCloseKey(hMimeKey);
    }

    TransDebugOut((DEB_DATA, "API OUT GetMimeFlags (DWFLAGS:%lx, hr:%lx)\n", dwFlags, hr));

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   GetMimeInfo
//
//  Synopsis:
//
//  Arguments:  [pszMime] --
//              [pclsid] --
//              [pdwFlags] --
//              [pdwMimeFlags] --
//
//  Returns:
//
//  History:    2-07-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT GetMimeInfo(LPSTR pszMime, CLSID *pclsid, DWORD dwFlags, DWORD *pdwMimeFlags)
{
    DEBUG_ENTER((DBG_TRANSDAT,
                Hresult,
                "GetMimeInfo",
                "%.80q, %#x, %#x, %#x",
                pszMime, pclsid, dwFlags, pdwMimeFlags
                ));
                
    PerfDbgLog1(tagTransApi, NULL, "+GetMimeInfo (MimeStr:%s)", pszMime);
    HRESULT hr = REGDB_E_CLASSNOTREG;

    BOOL fIgnoreMimeClsid = (dwFlags & MIMEFLAGS_IGNOREMIME_CLASSID);

    HKEY hMimeKey = NULL;
    DWORD dwError;
    DWORD dwType;
    char szValue[256];
    DWORD dwValueLen = 256;
    char szKey[SZMIMESIZE_MAX + ulMimeKeyLen];

    if ((pszMime == 0) || (*pszMime == 0))
    {
        hr = E_INVALIDARG;
    }
    else
    {
        strcpy(szKey, szMimeKey);
        strcat(szKey, pszMime);

        switch (RegOpenKeyEx(HKEY_CLASSES_ROOT, szKey, 0, KEY_QUERY_VALUE, &hMimeKey))
        {
            case ERROR_SUCCESS:
                hr = NOERROR;
            break;
            // win32 will return file not found instead of bad key
            case ERROR_FILE_NOT_FOUND:
            case ERROR_BADKEY:
                hr = REGDB_E_CLASSNOTREG;
            break;
            default:
                hr = REGDB_E_READREGDB;
            break;
        }
        if (hr == NOERROR)
        {
            // if fIgnoreMimeClsid is set, ignore the CLSID entry
            // in the HKCR\MIME tree.
            if (!fIgnoreMimeClsid)
            {
                dwError = RegQueryValueEx(hMimeKey, szClassID, NULL
                                        , &dwType, (LPBYTE)szValue, &dwValueLen);

                hr = REGDB_E_CLASSNOTREG;


                if (dwError == ERROR_SUCCESS)
                {
                    WCHAR sz[256];
                    A2W(szValue,sz,256);
                    hr = CLSIDFromString(sz, pclsid);
                }

                if (hr == NOERROR)
                {
                    goto End;
                }
            }

            hr = REGDB_E_CLASSNOTREG;

            dwValueLen = 256;
            dwError = RegQueryValueEx(hMimeKey
                                        , szExtension
                                        , NULL
                                        , &dwType
                                        , (LPBYTE)szValue
                                        , &dwValueLen);

            if (dwError == ERROR_SUCCESS)
            {

                hr = GetClassFromExt(szValue,pclsid);
            }

            if (pdwMimeFlags)
            {
                DWORD dwFlags = 0;
                *pdwMimeFlags = 0;
                dwValueLen = sizeof(DWORD);
                dwError = RegQueryValueEx(hMimeKey, szFlags, NULL
                                        , &dwType, (LPBYTE)&dwFlags, &dwValueLen);
                if (dwError == ERROR_SUCCESS)
                {
                    *pdwMimeFlags = dwFlags;
                }
            }
        }
    }

End:
    if (hMimeKey)
    {
        RegCloseKey(hMimeKey);
    }

    PerfDbgLog1(tagTransApi, NULL, "-GetMimeInfo (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}



//+---------------------------------------------------------------------------
//
//  Method:     GetClassFromExt
//
//  Synopsis:
//
//  Arguments:  [pszExt] --
//              [pclsid] --
//
//  Returns:
//
//  History:    2-07-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT GetClassFromExt(LPSTR pszExt, CLSID *pclsid)
{
    DEBUG_ENTER((DBG_TRANSDAT,
                Hresult,
                "GetClassFromExt",
                "%.80q, %#x",
                pszExt, pclsid
                ));
                
    PerfDbgLog1(tagTransApi, NULL, "+GetClassFromExt (szExt:%s)", pszExt);
    HRESULT hr = REGDB_E_CLASSNOTREG;

    HKEY        hkRoot = HKEY_CLASSES_ROOT;
    char        szFileExt[MAX_PATH];
    DWORD       cbFileExt = sizeof(szFileExt);

    *pclsid = CLSID_NULL;
    char szProgID[MAX_PATH];
    LONG  cbProgID = sizeof(szProgID);

    if (pszExt[0] == '\0')
    {
        goto End;
    }

    strcpy(szFileExt,pszExt);

    TransAssert((szFileExt[0] == '.'));

    // the entry begins with '.' so it may be a file extension
    // query the value (which is the ProgID)

    if (RegQueryValue(hkRoot, szFileExt, szProgID, &cbProgID) == ERROR_SUCCESS)
    {
        // we got the value (ProgID), now query for the CLSID
        // string and convert it to a CLSID

        char szClsid[40];
        LONG  cbClsid = sizeof(szClsid);
        strcat(szProgID, "\\Clsid");

        if (RegQueryValue(HKEY_CLASSES_ROOT, szProgID, szClsid,&cbClsid) == ERROR_SUCCESS)
        {
            // make sure the clsid is valid
            cbProgID = sizeof(szProgID);
            char szClsidEntry[80];
            strcpy(szClsidEntry, "Clsid\\");
            strcat(szClsidEntry, szClsid);

            if (RegQueryValue(HKEY_CLASSES_ROOT, szClsidEntry,szProgID, &cbProgID) == ERROR_SUCCESS)
            {
                CLSID clsid;
                WCHAR sz[256];
                A2W(szClsid,sz,256);
                hr = CLSIDFromString(sz, pclsid);

                if (hr != NOERROR)
                {
                    *pclsid = CLSID_NULL;
                    hr = REGDB_E_CLASSNOTREG;
                }
            }
        }
    }
End:

    PerfDbgLog1(tagTransApi, NULL, "-GetClassFromExt (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   IsValidURL
//
//  Synopsis:
//
//  Arguments:  [pBC] --
//              [szURL] --
//              [dwReserved] --
//
//  Returns:
//
//  History:    4-16-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI IsValidURL(LPBC pBC, LPCWSTR szURL, DWORD dwReserved)
{
    DEBUG_ENTER_API((DBG_API,
                    Hresult,
                    "IsValidURL",
                    "%#x, %.80wq, %#x",
                    pBC, szURL, dwReserved
                    ));
                
    HRESULT hr;
    PerfDbgLog2(tagTransApi, NULL, "+IsValidURL(pBC:%lx, szURL:%ws)",pBC,szURL);
    WCHAR   wzUrlStr[MAX_URL_SIZE + 1];

    if (szURL == NULL)
    {
        hr = E_INVALIDARG;
    }
    else if (   (ConstructURL(pBC, NULL, NULL, (LPWSTR)szURL, wzUrlStr, sizeof(wzUrlStr), CU_CANONICALIZE) == NOERROR)
             && IsOInetProtocol(pBC, wzUrlStr))
    {
        hr = NOERROR;
    }
    else
    {
        hr = S_FALSE;
    }

    PerfDbgLog3(tagTransApi, NULL, "-IsValidURL(pBC:%lx, szURL:%ws, hr:%lx)",pBC,szURL,hr);

    DEBUG_LEAVE_API(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   GetUrlScheme
//
//  Synopsis:
//
//  Arguments:  pcwsz -- the URL
//              [szURL] --
//              [dwReserved] --
//
//  Returns:    URL_SCHEME_*
//
//----------------------------------------------------------------------------

DWORD
GetUrlScheme(LPCWSTR pcwzUrl)
{
    DEBUG_ENTER((DBG_TRANSDAT,
                Hresult,
                "GetUrlScheme",
                "%.80wq",
                pcwzUrl
                ));
                
    if(pcwzUrl)
    {
        PARSEDURLW puW;
        puW.cbSize = sizeof(puW);
        if(SUCCEEDED(ParseURLW(pcwzUrl, &puW)))
        {
            DEBUG_LEAVE(puW.nScheme);
            return puW.nScheme;
        }
    }

    DEBUG_LEAVE(URL_SCHEME_INVALID);
    return URL_SCHEME_INVALID;
}

//+---------------------------------------------------------------------------
//
//  Function:   GetClassFileOrMime2
//
//  Synopsis:
//
//  Arguments:  [pBC] --
//              [wzFilename] --
//              [pBuffer] --
//              [cbSize] --
//              [pwzMime] --
//              [dwReserved] --
//              [pclsid] --
//              [fIgnoreMimeClsid] --
//
//  Returns:
//
//  History:    4-16-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI GetClassFileOrMime2(LPBC pBC, LPCWSTR pwzFilename, LPVOID pBuffer, DWORD cbSize,
                          LPCWSTR pwzMimeIn, DWORD dwReserved, CLSID *pclsid, BOOL fIgnoreMimeClsid)
{
    DEBUG_ENTER_API((DBG_API,
                    Hresult,
                    "GetClassFileOrMime2",
                    "%#x, %.80wq, %#x, %#x, %.80wq, %#x, %#x, %B",
                    pBC, pwzFilename, pBuffer, cbSize, pwzMimeIn, dwReserved, pclsid, fIgnoreMimeClsid
                    ));
                
    PerfDbgLog1(tagTransApi, NULL, "+GetClassFileOrMime(%lx)",pBC);
    HRESULT hr = REGDB_E_CLASSNOTREG;
    HRESULT hrPlugin = REGDB_E_CLASSNOTREG;
    HRESULT hrClass = REGDB_E_CLASSNOTREG;
    char szMime[SZMIMESIZE_MAX];
    char szFilename[MAX_PATH];
    LPSTR pszMime = NULL;
    LPSTR pszFilename = NULL;
    LPSTR pszExt = NULL;
    LPWSTR pwzMime = (LPWSTR)pwzMimeIn;
    DWORD cbMime = SZMIMESIZE_MAX;
    CLSID clsidPlugin = CLSID_NULL;
    BOOL  fDocFile = FALSE;
    DWORD dwClsCtx = 0;
    DWORD dwFlags = (fIgnoreMimeClsid) ? MIMEFLAGS_IGNOREMIME_CLASSID : 0;


    if (   pclsid == NULL
        || (!pwzFilename && (!pBuffer || !cbSize) && !pwzMimeIn))
    {
        hr = E_INVALIDARG;
        goto errRet;
    }
    *pclsid = CLSID_NULL;

    //sniff data here or when setting the mime
    if (pBuffer && cbSize)
    {
        fDocFile = (IsDocFile(pBuffer,cbSize) == S_OK);
        if (fDocFile)
        {
            // do not pass the buffer - no need to sniff data
            hr = FindMimeFromData(pBC, pwzFilename, NULL, 0, pwzMimeIn, 0, &pwzMime, 0);
        }
        else
        {
            hr = FindMimeFromData(pBC, pwzFilename, pBuffer, cbSize, pwzMimeIn, 0, &pwzMime, 0);
        }
    }

    if (pwzMime)
    {
        // convert the mime
        W2A(pwzMime, szMime, SZMIMESIZE_MAX);
        pszMime = szMime;
    }

    if (pwzFilename)
    {
        W2A(pwzFilename, szFilename, MAX_PATH);
        pszFilename = szFilename;
    }

    // 1. find the class based on the mime
    if (pszMime)
    {
        if (pBC)
        {
            hr = FindMediaTypeClass(pBC, szMime, pclsid, 0);
        }

        if (hr != NOERROR)
        {
            // get the class from the mime string
            hr = FindMediaTypeClassInfo(pszMime, pszFilename, pclsid, &dwClsCtx, dwFlags);
        }
    }

    // 2. find class of docfile
    if ((hr != NOERROR || IsEqualGUID(*pclsid, CLSID_NULL)) && cbSize && fDocFile)
    {
        // get class from docfile
        hr = GetClassDocFileBuffer(pBuffer, cbSize, pclsid);
    }

    // 3. use the file to find the class
    if (   (hr != NOERROR)
        && pszFilename)
    {
        pszExt = FindFileExtension(pszFilename);

        // use extension and use class mapping
        if (pszExt != NULL)
        {
            char szMimeExt[SZMIMESIZE_MAX];
            DWORD cbMimeExt = SZMIMESIZE_MAX;

            // get the mime for the file
            hr = GetMimeFromExt(pszExt,szMimeExt, &cbMimeExt);

            if (   (hr == NOERROR)
                && (   (pszMime && strcmp(pszMime, szMimeExt))
                    || !pszMime)
               )
            {
                hr = REGDB_E_CLASSNOTREG;
                if (pBC)
                {
                    // check for class mapping
                    hr = FindMediaTypeClass(pBC, szMimeExt, pclsid, 0);
                }

                if (hr != NOERROR)
                {
                    // get the class from the mime string
                    hr = FindMediaTypeClassInfo(szMimeExt, pszFilename, pclsid, &dwClsCtx, dwFlags);
                }
            }
        }

        // last call GetClassFile
        if ( hr != NOERROR && pwzFilename && (!pwzMime || fDocFile) )
        {
            hr = GetClassFile(pwzFilename, pclsid);
        }

        // should never need to use file to locate CLSID_HTMLDocument
        if (IsEqualGUID(*pclsid, CLSID_HTMLDocument))
        {
            *pclsid = CLSID_NULL;
            hrClass = REGDB_E_CLASSNOTREG;
        }
    }

    // 4. if available check the class id and
    //    trigger check for plugin class id if needed
    if (   (hr == NOERROR)
        && !IsEqualGUID(*pclsid, CLSID_NULL))
    {

        hrClass = NOERROR;
        if (dwClsCtx == 0)
        {
            hr = GetClsIDInfo(pclsid, 0, &dwClsCtx);
        }

        if (hr == NOERROR)
        {
            if (dwClsCtx  & CLSCTX_DOCOBJECT)
            {
                // server of class is a docobject
                hrPlugin = NOERROR;
            }
            else if (dwClsCtx  & CLSCTX_INPROC)
            {
                // server of class is inproc

                // check if the class is mshtml tread it as docobject and stop
                // looking for plugin
                if (IsEqualGUID(*pclsid, CLSID_MsHtml))
                {
                    hrPlugin = NOERROR;
                }
            }
            else if (dwClsCtx  & CLSCTX_LOCAL_SERVER)
            {
                // server of class is local
            }
        }
        // else
        // class is not properly registered
        //
    }

    // 5. check if the download is for a plugin
    //    if yes get the plugin host class id
    if (hrPlugin != NOERROR)
    {
        if (pszExt == NULL && pszFilename)
        {
            pszExt = FindFileExtension(pszFilename);
        }

        // if we have a mime and/or an extension mime check if
        // this is a plugin or an ocx
        if (pszExt || pszMime)
        {
            hrPlugin = GetPlugInClsID(pszExt, NULL, pszMime, &clsidPlugin);
        }

    }
    else
    {
        hrPlugin = E_FAIL;
    }

    // 6. the plugin class use it
    if ( (hrPlugin == NOERROR) && !(dwReserved & GETCLASSFILEORMIME_IGNOREPLUGIN))
    {
        *pclsid = clsidPlugin;
        hr = hrPlugin;
    }
    // used the class found
    else
    {
        hr = hrClass;
    }

    if (pwzMime != pwzMimeIn)
    {
        delete [] pwzMime;
    }

    TransAssert((   (hr != NOERROR && IsEqualGUID(*pclsid, CLSID_NULL))
                 || (hr == NOERROR && !IsEqualGUID(*pclsid, CLSID_NULL)) ));

errRet:
    TransAssert((hr == NOERROR  || hr == REGDB_E_CLASSNOTREG  || hr == E_INVALIDARG));
    PerfDbgLog1(tagTransApi, NULL, "-GetClassFileOrMime (hr:%lx)",hr);

    DEBUG_LEAVE_API(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   GetClassFileOrMime
//
//  Synopsis:
//
//  Arguments:  [pBC] --
//              [wzFilename] --
//              [pBuffer] --
//              [cbSize] --
//              [pwzMime] --
//              [dwReserved] --
//              [pclsid] --
//
//  Returns:
//
//  History:    4-16-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI GetClassFileOrMime(LPBC pBC, LPCWSTR pwzFilename, LPVOID pBuffer, DWORD cbSize,
                          LPCWSTR pwzMimeIn, DWORD dwReserved, CLSID *pclsid)
{
    DEBUG_ENTER_API((DBG_API,
                    Hresult,
                    "GetClassFileOrMime",
                    "%#x, %.80wq, %#x, %#x, %.80wq, %#x, %#x",
                    pBC, pwzFilename, pBuffer, cbSize, pwzMimeIn, dwReserved, pclsid
                    ));
                    
    HRESULT hr = GetClassFileOrMime2(pBC, pwzFilename, pBuffer, cbSize, pwzMimeIn,
        dwReserved, pclsid, FALSE);

    DEBUG_LEAVE_API(hr);
    return hr;
}



//+---------------------------------------------------------------------------
//
//  Function:   GetClassDocFileBuffer
//
//  Synopsis:
//
//  Arguments:  [pbuffer] --
//              [dwSize] --
//              [pclsid] --
//
//  Returns:
//
//  History:    2-28-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT GetClassDocFileBuffer(LPVOID pbuffer, DWORD dwSize, CLSID *pclsid)
{
    DEBUG_ENTER((DBG_TRANSDAT,
                Hresult,
                "GetClassDocFileBuffer",
                "%#x, %#x, %#x",
                pbuffer, dwSize, pclsid
                ));
                
    PerfDbgLog(tagTransApi, NULL, "+GetClassDocFileBuffer");
    HRESULT hr = E_FAIL;

    ILockBytes *pilb;
    IStorage *pstg;
    STATSTG stat;

    HGLOBAL hGlobal = 0;
    hGlobal = GlobalAlloc(GMEM_FIXED | GMEM_NODISCARD, dwSize);
    if (hGlobal)
    {
        memcpy(hGlobal, pbuffer, dwSize);

        hr = CreateILockBytesOnHGlobal(hGlobal,FALSE,&pilb);
        if (hr == NOERROR)
        {
            hr = StgOpenStorageOnILockBytes(pilb,NULL,STGM_DIRECT | STGM_READ | STGM_SHARE_EXCLUSIVE,
                        NULL,0,&pstg);

            if (hr == NOERROR)
            {
                pstg->Stat(&stat, STATFLAG_NONAME);
                pstg->Release();
                *pclsid = stat.clsid;
            }
            else
            {
                hr = E_FAIL;
            }
        }
        GlobalFree(hGlobal);
    }

    PerfDbgLog1(tagTransApi, NULL, "-GetClassDocFileBuffer (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

HRESULT GetCodeBaseFromDocFile(LPBYTE pBuffer, ULONG ulSize, LPWSTR *pwzClassStr, 
                               LPWSTR pwzBaseUrl, DWORD *lpdwVersionMS, DWORD *lpdwVersionLS);

//+---------------------------------------------------------------------------
//
//  Method:     IsHandlerAvailable
//
//  Synopsis:
//
//  Arguments:  [pClsid] --
//              [pMime] --
//
//  Returns:
//
//  History:    11-07-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT IsHandlerAvailable(LPWSTR pwzUrl, LPWSTR pwzMime, CLSID *pclsid, LPBYTE pBuffer, ULONG cbSize)
{
    DEBUG_ENTER((DBG_TRANSDAT,
                Hresult,
                "IsHandlerAvailable",
                "%.80wq, %.80wq, %#x, %#x, %#x",
                pwzUrl, pwzMime, pclsid, pBuffer, cbSize
                ));
                
    PerfDbgLog(tagTransApi, NULL, "+GetCodeBaseFromDocFile");
    HRESULT hr = E_FAIL, hr1;
    LPWSTR szDistUnit = 0;
    BOOL fIgnoreMimeClsid = FALSE, fHasHandler = FALSE, fDocFile = FALSE;
    CLocalComponentInfo lci;
    CHAR szKey[SZMIMESIZE_MAX + ulMimeKeyLen];
    CHAR szMime[SZMIMESIZE_MAX];
    LPSTR pszUrl = 0;

    W2A(pwzMime, szMime, SZMIMESIZE_MAX);
    pszUrl = DupW2A(pwzUrl);        // can potentially be very long

    if ((pwzMime == 0) || (*pwzMime == 0))
    {
        hr = E_INVALIDARG;
    }
    else
    {
        HKEY hMimeKey = 0;
     
        *pclsid = CLSID_NULL;

        strcpy(szKey, szMimeKey);
        strcat(szKey, szMime);

        // NOTE: different handlers may be implemented in different ways, for example.
        // the abscence of a CLSID does not imply the handler is bad or missing.

        // check if mime type exists in "Content Type" branch
        if (RegOpenKeyEx(HKEY_CLASSES_ROOT, szKey, 0, KEY_QUERY_VALUE, &hMimeKey) == ERROR_SUCCESS)
        {
            fHasHandler = TRUE;
            RegCloseKey(hMimeKey);
            hMimeKey = 0;
        }
        
        // if not check if extension type has handler
        if (!fHasHandler)
        {
            LPSTR pszExt = FindFileExtension(pszUrl);

            // try for handler of extension
            if (pszExt && *pszExt == '.')
            {
                hMimeKey = 0;

                // there may be a handler for this extension already
                if (RegOpenKeyEx(HKEY_CLASSES_ROOT, pszExt, 0, KEY_QUERY_VALUE, &hMimeKey) == ERROR_SUCCESS)
                {
                    fHasHandler = TRUE;
                    RegCloseKey(hMimeKey);
                }
            }
        }

        // we haven't found a handler yet, in case of DocFile, check if CLSID associated
        // with it exists.  
        if (!fHasHandler && SUCCEEDED(IsDocFile(pBuffer,cbSize)))
        {
            DWORD dwVersionMS = 0, dwVersionLS = 0;
            LPWSTR pwzCodeBase = 0;

            hr1 = GetCodeBaseFromDocFile(pBuffer, cbSize, &pwzCodeBase, NULL, &dwVersionMS, &dwVersionLS);
            if (pwzCodeBase) {

                delete pwzCodeBase;
            }

            hr1 = GetClassDocFileBuffer(pBuffer, cbSize, pclsid);

            if (SUCCEEDED(hr1) && !IsEqualCLSID(*pclsid, CLSID_NULL))
            {
                StringFromCLSID(*pclsid, &szDistUnit);

                hr1 = IsControlLocallyInstalled(NULL, pclsid, szDistUnit, dwVersionMS, dwVersionLS, &lci, NULL);

                if (hr1 == S_OK)
                {
                    fHasHandler = TRUE;
                }

                if (szDistUnit)
                {
                    delete szDistUnit;
                }
            }
        }
    }

    if (pszUrl)
    {
        delete [] pszUrl;
    }

    if (fHasHandler)
    {
        hr = S_OK;
    }    
    else
    {
        hr = S_FALSE;
    }

    DEBUG_LEAVE(hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     GetCodeBaseFromDocFile
//
//  Synopsis:
//
//  Arguments:  [pBuffer] --
//              [ulSize] --
//              [pwzClassStr] --
//
//  Returns:
//
//  History:    11-07-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT GetCodeBaseFromDocFile(LPBYTE pBuffer, ULONG ulSize, LPWSTR *pwzClassStr, 
                               LPWSTR pwzBaseUrl, DWORD *lpdwVersionMS, DWORD *lpdwVersionLS)
{
    DEBUG_ENTER((DBG_TRANSDAT,
                Hresult,
                "GetCodeBaseFromDocFile",
                "%#x, %#x, %#x, %.80wq, %#x, %#x",
                pBuffer, ulSize, pwzClassStr, pwzBaseUrl, lpdwVersionMS, lpdwVersionLS
                ));
                
    PerfDbgLog(tagTransApi, NULL, "+GetCodeBaseFromDocFile");
    HRESULT hr = E_FAIL;

    ILockBytes *pilb;
    IStorage *pstg;
    STATSTG stat;

    static ULONG cpSpec = DOCFILE_NUMPROPERTIES;
    static PROPSPEC rgpSpec[DOCFILE_NUMPROPERTIES] = { 
                                { PRSPEC_PROPID, DOCFILE_PROPID_CODEBASE },
                                { PRSPEC_PROPID, DOCFILE_PROPID_MAJORVERSION },
                                { PRSPEC_PROPID, DOCFILE_PROPID_MINORVERSION } };
            
    PROPVARIANT rgVarDisplay[DOCFILE_NUMPROPERTIES];
    
    if (!pwzClassStr || !lpdwVersionMS || !lpdwVersionLS)
    {
        hr = E_INVALIDARG;
    }
    else 
    {   
        HGLOBAL hGlobal = 0;
        hGlobal = GlobalAlloc(GMEM_FIXED | GMEM_NODISCARD, ulSize);

        *pwzClassStr = 0;

        if (hGlobal)
        {
            memcpy(hGlobal, pBuffer, ulSize);

            hr = CreateILockBytesOnHGlobal(hGlobal,FALSE,&pilb);
            if (hr == NOERROR)
            {
                hr = StgOpenStorageOnILockBytes(pilb,NULL,STGM_DIRECT | STGM_READ | STGM_SHARE_EXCLUSIVE,
                            NULL,0,&pstg);
                if (hr == NOERROR)
                {
                    IPropertySetStorage *ppss = 0;
                    
                    hr = pstg->QueryInterface(IID_IPropertySetStorage, (void **)&ppss);
                    if (SUCCEEDED(hr)) 
                    {
                        IPropertyStorage *pps = 0;

                        //BUGBUG: there is potential for error here if data structure of
                        // PropertyStorage is not fully loaded.  since we have read only access
                        // we should be ok.

                        hr = ppss->Open(FMTID_CodeBase, STGM_DIRECT | STGM_READ | STGM_SHARE_EXCLUSIVE, (IPropertyStorage **)&pps);
                        if (SUCCEEDED(hr))
                        {
                            hr = pps->ReadMultiple(cpSpec, rgpSpec, rgVarDisplay);
                            if (SUCCEEDED(hr)) 
                            {
                                *pwzClassStr = rgVarDisplay[0].pwszVal;
                                *lpdwVersionMS = rgVarDisplay[1].ulVal;
                                *lpdwVersionLS = rgVarDisplay[2].ulVal;
                            }
                            pps->Release();
                        }
                        ppss->Release();
                    }
                    pstg->Release();
                }
                else
                {
                    hr = E_FAIL;
                }
            }
            GlobalFree(hGlobal);
        }
    }

    if (SUCCEEDED(hr) && pwzBaseUrl)
    {
        LPWSTR pwzNewClassStr = 0;
        DWORD dwLen, dwNewLen;
        HRESULT hr1;

        // we do not know what the combined maximum Url length is, so as
        // an upper bound we take twice the combined url's plus 10.
        dwLen = 2*(lstrlenW(pwzBaseUrl) + lstrlenW(*pwzClassStr)) + 10;

        pwzNewClassStr = new WCHAR[dwLen];

        if (pwzNewClassStr)
        {
            hr1 = CoInternetCombineUrl(pwzBaseUrl, *pwzClassStr, ICU_NO_ENCODE, pwzNewClassStr, dwLen, &dwNewLen, 0);
            
            if (SUCCEEDED(hr1) && dwNewLen)
            {
                delete [] *pwzClassStr;
                *pwzClassStr = pwzNewClassStr;
            }
            else
            {
                delete [] pwzNewClassStr;
            }
        }
    }

    PerfDbgLog1(tagTransApi, NULL, "-GetCodeBaseFromDocFile (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   UrlMkSetSessionOption
//
//  Synopsis:
//
//  Arguments:  [dwOption] --
//              [pBuffer] --
//              [dwBufferLength] --
//              [dwReserved] --
//
//  Returns:
//
//  History:    5-06-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI UrlMkSetSessionOption(DWORD dwOption, LPVOID pBuffer, DWORD dwBufferLength, DWORD dwReserved)
{
    DEBUG_ENTER_API((DBG_API,
                    Hresult,
                    "UrlMkSetSessionOption",
                    "%#x, %#x, %#x, %#x",
                    dwOption, pBuffer, dwBufferLength, dwReserved
                    ));
    // BUGBUG - Function not threadsafe.
    
    PerfDbgLog(tagTransApi, NULL, "+UrlMkSetSessionOption");

    HRESULT hr;

    switch(dwOption)
    {
        // Change the User Agent string for this process.
        case URLMON_OPTION_USERAGENT:
        {
            // Validate buffer, allocate new user agent string,
            // delete old if necessary, copy and reference with
            // g_pszUserAgentString.

            if (!(pBuffer && dwBufferLength))
            {
                hr = E_INVALIDARG;
                break;
            }

            LPSTR pszTemp = new CHAR[dwBufferLength + 1];
            if (!pszTemp)
            {
                TransAssert(pszTemp && "Allocating memory for User-Agent header failed");
                hr = E_OUTOFMEMORY;
                break;
            }

            memcpy(pszTemp, pBuffer, dwBufferLength);
            pszTemp[dwBufferLength] = '\0';
            
            if (g_pszUserAgentString)
            {
                delete [] g_pszUserAgentString;
            }

            g_pszUserAgentString = pszTemp;
            hr = S_OK;
            break;
        }

        // Refresh user agent string from registry for this process.
        case URLMON_OPTION_USERAGENT_REFRESH:
        {
            // Refresh, delete old user agent string if necessary.
            // g_pszUserAgentString references refreshed string.

            LPSTR pszTemp = g_pszUserAgentString;            

            // NULL forces GetUserAgentString to refresh from registry.
            g_pszUserAgentString = NULL;
            g_pszUserAgentString = (LPSTR) GetUserAgentString();

            if (!g_pszUserAgentString)
            {
                g_pszUserAgentString = pszTemp;
                hr = S_FALSE;
                break;
            }
            
            // Need to set this on the session handle also.
            if (g_hSession)
                InternetSetOption(g_hSession, INTERNET_OPTION_USER_AGENT,
                    g_pszUserAgentString, strlen(g_pszUserAgentString));


            delete [] pszTemp;
            hr = S_OK;
            break;
        }
        
        // Set or reload proxy info from registry.
        case INTERNET_OPTION_PROXY:
        case INTERNET_OPTION_REFRESH:
        {
            // InternetSetOption does its own buffer validation.
            if (InternetSetOption(NULL, dwOption, pBuffer, dwBufferLength))
            {
                hr = S_OK;
                break;
            }

            hr = S_FALSE;
            break;
        }
                
        default:
        {
            hr = E_INVALIDARG;
            break;
        }
    }
                        
    PerfDbgLog1(tagTransApi, NULL, "-UrlMkSetSessionOption (hr:%lx)", hr);

    DEBUG_LEAVE_API(hr);
    return hr;
}
            
            
//+---------------------------------------------------------------------------
//
//  Function:   UrlMkGetSessionOption
//
//  Synopsis:
//
//  Arguments:  [dwOption] --
//              [pBuffer] --
//              [dwBufferLength] --
//              [dwReserved] --
//
//  Returns:
//
//  History:    5-06-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI UrlMkGetSessionOption(DWORD dwOption, LPVOID pBuffer, DWORD dwBufferLength, DWORD *pdwBufferLengthOut, DWORD dwReserved)
{
    DEBUG_ENTER_API((DBG_API,
                    Hresult,
                    "UrlMkSetSessionOption",
                    "%#x, %#x, %#x, %#x",
                    dwOption, pBuffer, dwBufferLength, dwReserved
                    ));
                    
    PerfDbgLog(tagTransApi, NULL, "+UrlMkGetSessionOption");
    HRESULT hr = E_FAIL;

    if( !pdwBufferLengthOut )
    {
        DEBUG_LEAVE_API(E_INVALIDARG);
        return E_INVALIDARG;
    }

    if (dwOption == URLMON_OPTION_USERAGENT)
    {
        // get the default user agent string
        LPCSTR pszStr = GetUserAgentString();

        DWORD cLen = strlen(pszStr);
        *pdwBufferLengthOut = cLen + 1;

        hr = E_OUTOFMEMORY;

        if (cLen < dwBufferLength )
        {
            if( pBuffer )
            {
                strcpy((LPSTR)pBuffer, pszStr);
// AOL BUG 66102 - we always return E_FAIL
//                 hr = NOERROR;
            }
            else
            {
                hr = E_INVALIDARG;
            }
        }
    }
    else if (dwOption == URLMON_OPTION_URL_ENCODING)
    {
        if( !pBuffer || dwBufferLength < sizeof(DWORD) )
        {
            hr = E_INVALIDARG;
        }
        else
        {
            DWORD dwEncoding = URL_ENCODING_NONE;
            BOOL fDefault = FALSE;
            DWORD dwUrlEncodingDisableUTF8;
            DWORD dwSize = sizeof(DWORD);
            
            if( ERROR_SUCCESS == SHRegGetUSValue(
                    INTERNET_SETTING_KEY,
                    "UrlEncoding", 
                    NULL, 
                    (LPBYTE) &dwUrlEncodingDisableUTF8, 
                    &dwSize, 
                    FALSE, 
                    (LPVOID) &fDefault, 
                    sizeof(fDefault) )  )
            {
                if( dwUrlEncodingDisableUTF8)
                    dwEncoding = URL_ENCODING_DISABLE_UTF8;
                else
                    dwEncoding = URL_ENCODING_ENABLE_UTF8;
            }

            hr = NOERROR;
            *pdwBufferLengthOut = sizeof(DWORD);
            memcpy(pBuffer, (LPVOID)(&dwEncoding), sizeof(DWORD));
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

    PerfDbgLog1(tagTransApi, NULL, "-UrlMkGetSessionOption (hr:%lx)", hr);

    DEBUG_LEAVE_API(hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   GetPlugInClsID
//
//  Synopsis:   load the plugin ocx; get the FindPluginByExtA address
//              call the FindPluginByExtA api
//
//  Arguments:  [pszExt] --
//              [szMime] --
//              [pclsid] --
//
//  Returns:    NOERROR and plugin class id if file is handled by plugin
//              REGDB_E_CLASSNOTREG otherwise
//
//  History:    7-16-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT GetPlugInClsID(LPSTR pszExt, LPSTR pszName, LPSTR pszMime, CLSID *pclsid)
{
    DEBUG_ENTER((DBG_TRANSDAT,
                Hresult,
                "GetPlugInClsID",
                "%.80q, %.80q, %.80q, %#x",
                pszExt, pszName, pszMime, pclsid
                ));
                
    HRESULT hr = REGDB_E_CLASSNOTREG;
    PerfDbgLog3(tagTransApi, NULL, "+GetPlugInClsID (pszExt:%s, pszName:%s, pszMime:%s)", pszExt, pszName, pszMime);

    typedef BOOL (WINAPI * pfnFINDPLUGINBYEXT)(char *szExt, char *szName, char *szMime);

    static pfnFINDPLUGINBYEXT pfnFindPlugin = NULL;
    static BOOL fPluginLoaded = FALSE;
    static BOOL fGotProcAddr = FALSE;

    if (!fPluginLoaded)
    {
        g_hLibPluginOcx = LoadLibraryA("plugin.ocx");
        fPluginLoaded = TRUE;
    }

    if (g_hLibPluginOcx != NULL)
    {
        if (!fGotProcAddr)
        {
            pfnFindPlugin = (pfnFINDPLUGINBYEXT)GetProcAddress(g_hLibPluginOcx, "FindPluginByExtA");
            fGotProcAddr = TRUE;
            if (pfnFindPlugin == NULL)
            {
                DbgLog(tagTransApi, NULL, "Failed to find entry point FindPluginByExt in  plugin.ocx");
            }
        }

        if (pfnFindPlugin && pfnFindPlugin(pszExt, pszName, pszMime))
        {
            hr = S_OK;
        }
    }
    else
    {
        DbgLog(tagTransApi, NULL, "Failed to find plugin.ocx");
    }

    if (hr == S_OK)
    {
        *pclsid = CLSID_PluginHost;
    }

    PerfDbgLog1(tagTransApi, NULL, "-GetPlugInClsID (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   StringAFromCLSID
//
//  Synopsis:   returns an ansi string of given class id
//
//  Arguments:  [pclsid] -- the class id
//
//  Returns:    pointer to class id string or
//              NULL if out of memory
//
//  History:    7-20-96   JohannP (Johann Posch)   Created
//
//  Notes:      string pointer has to be deleted with delete (operator)
//
//----------------------------------------------------------------------------
LPSTR StringAFromCLSID(CLSID *pclsid)
{
    DEBUG_ENTER((DBG_TRANSDAT,
                Hresult,
                "StringAFromCLSID",
                "%#x",
                pclsid
                ));
                
    LPOLESTR pwzStr;
    LPSTR    pszStr = NULL;

    TransAssert((pclsid));

    StringFromCLSID(*pclsid, &pwzStr);

    if (pwzStr)
    {
        pszStr =  SzDupWzToSz(pwzStr, TRUE);
        delete pwzStr;
    }

    DEBUG_LEAVE(pszStr);
    return pszStr;
}

//+---------------------------------------------------------------------------
//
//  Function:   CLSIDFromStringA
//
//  Synopsis:
//
//  Arguments:  [pszClsid] --
//              [pclsid] --
//
//  Returns:
//
//  History:    11-20-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CLSIDFromStringA(LPSTR pszClsid, CLSID *pclsid)
{
    DEBUG_ENTER((DBG_TRANSDAT,
                Hresult,
                "CLSIDFromStringA",
                "%.80q, %#x",
                pszClsid, pclsid
                ));
                
    WCHAR sz[CLSIDSTR_MAX];
    A2W(pszClsid,sz,CLSIDSTR_MAX);
    HRESULT hr = CLSIDFromString(sz, pclsid);

    DEBUG_LEAVE(hr);
    return hr;
}


#include "ocidl.h"
#ifndef unix
#include "..\urlhlink\urlhlink.h"
#else
#include "../urlhlink/urlhlink.h"
#endif /* unix */
#define IS_E_PENDING(hr) (hr == E_PENDING)

//+---------------------------------------------------------------------------
//
//  Function:   URLDownloadA
//
//  Synopsis:
//
//  Arguments:  [pUnk] --
//              [szURL] --
//              [pBindInfo] --
//              [pBSCB] --
//              [dwReserved] --
//
//  Returns:
//
//  History:    7-27-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI URLDownloadA(IUnknown *pUnk, LPCSTR pszURL, DWORD pBindInfo, IBindStatusCallback *pBSCB, DWORD dwReserved)
{
    DEBUG_ENTER_API((DBG_API,
                    Hresult,
                    "URLDownloadA",
                    "%#x, %.80q, %#x, %#x, %#x",
                    pUnk, pszURL, pBindInfo, pBSCB, dwReserved
                    ));
                    
    PerfDbgLog1(tagTransApi, NULL, "+URLDownloadA (pszUrl:%s)", pszURL);
    HRESULT hr = NOERROR;
    LPCWSTR pwzUrl = DupA2W((LPSTR) pszURL);

    if (pwzUrl)
    {
        hr = URLDownloadW(pUnk,pwzUrl,pBindInfo,pBSCB, 0);
    }

    PerfDbgLog1(tagTransApi, NULL, "-URLDownloadA (hr:%lx)", hr);

    DEBUG_LEAVE_API(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   URLDownloadW
//
//  Synopsis:
//
//  Arguments:  [pUnk] --
//              [pwzURL] --
//              [pBindInfo] --
//              [pBSCB] --
//              [dwReserved] --
//
//  Returns:
//
//  History:    7-27-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI URLDownloadW(IUnknown *pUnk, LPCWSTR pwzURL, DWORD pBindInfo, IBindStatusCallback *pBSCB, DWORD dwReserved)
{
    DEBUG_ENTER_API((DBG_API,
                    Hresult,
                    "URLDownloadW",
                    "%#x, %.80wq, %#x, %#x, %#x",
                    pUnk, pwzURL, pBindInfo, pBSCB, dwReserved
                    ));
                    
    PerfDbgLog1(tagTransApi, NULL, "+URLDownloadW (pwzUrl:%ws)", pwzURL);
    HRESULT             hr;
    IOleObject *        pOleObject = 0;
    IServiceProvider *  pServiceProvider = 0;
    IMoniker *          pmkr = 0;
    IBindCtx *          pBndCtx = 0;
    IBindHost *         pBindHost = 0;

    IStream * pstrm = 0;

    // Don't bother if we don't have a caller...

    if( pUnk )
    {
        // By convention the we give the caller first crack at service
        // provider. The assumption here is that if they implement it
        // they have the decency to forward QS's to their container.

        hr = pUnk->QueryInterface( IID_IServiceProvider,
                                        (void**)&pServiceProvider );

        if( FAILED(hr) )
        {
            // Ok, now try the 'slow way' : maybe the object is an 'OLE' object
            // that knows about it's client site:

            hr = pUnk->QueryInterface( IID_IOleObject, (void**)&pOleObject );

            if( SUCCEEDED(hr) )
            {
                IOleClientSite * pClientSite = 0;

                hr = pOleObject->GetClientSite(&pClientSite);

                if( SUCCEEDED(hr) )
                {
                    // Now see if we have a service provider at that site
                    hr = pClientSite->QueryInterface
                                            ( IID_IServiceProvider,
                                            (void**)&pServiceProvider );
                }

                if( pClientSite )
                    pClientSite->Release();
            }
            else
            {
                // Ok, it's not an OLE object, maybe it's one of these
                // new fangled 'ObjectWithSites':

                IObjectWithSite * pObjWithSite = 0;

                hr = pUnk->QueryInterface( IID_IObjectWithSite,
                                                    (void**)&pObjWithSite );

                if( SUCCEEDED(hr) )
                {
                    // Now see if we have a service provider at that site

                    hr = pObjWithSite->GetSite(IID_IServiceProvider,
                                                (void**)&pServiceProvider);
                }

                if( pObjWithSite )
                    pObjWithSite->Release();

            }
            if( pOleObject )
                pOleObject->Release();

        }

        // BUGBUG: In the code above we stop looking at one level up --
        //  this may be too harsh and we should loop on client sites
        // until we get to the top...

        if( !pServiceProvider )
            hr = E_UNEXPECTED;

        // Ok, we have a service provider, let's see if BindHost is
        // available. (Here there is some upward delegation going on
        // via service provider).

        if( SUCCEEDED(hr) )
            hr = pServiceProvider->QueryService( SID_SBindHost, IID_IBindHost,
                                                        (void**)&pBindHost );

        if( pServiceProvider )
            pServiceProvider->Release();

        pmkr = 0;
    }

    if (pBindHost)
    {
        // This allows the container to actually drive the download
        // by creating it's own moniker.

        hr = pBindHost->CreateMoniker( LPOLESTR(pwzURL),NULL, &pmkr,0 );



        if( SUCCEEDED(hr) )
        {
            // This allows containers to hook the download for
            // doing progress and aborting

            hr = pBindHost->MonikerBindToStorage(pmkr, NULL, pBSCB, IID_IStream,(void**)&pstrm);
        }

        pBindHost->Release();
    }
    else
    {
        // If you are here, then either the caller didn't pass
        // a 'caller' pointer or the caller is not in a BindHost
        // friendly environment.

        hr = CreateURLMoniker( 0, pwzURL, &pmkr );

        if( SUCCEEDED(hr) )
        {
            hr = CreateAsyncBindCtx( 0,pBSCB,0, &pBndCtx );
        }

        if (SUCCEEDED(hr))
        {
            hr = pmkr->BindToStorage( pBndCtx, NULL, IID_IStream, (void**)&pstrm );
        }

    }

    if( pstrm )
        pstrm->Release();

    if( pmkr )
        pmkr->Release();

    if( pBndCtx )
        pBndCtx->Release();

    PerfDbgLog1(tagTransApi, NULL, "-URLDownloadW (hr:%lx)", hr);

    DEBUG_LEAVE_API(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   FindMimeFromData
//
//  Synopsis:
//
//  Arguments:  [pBC] --
//              [pwzURL] --
//              [pBuffer] --
//              [cbSize] --
//              [dwReserved] --
//
//  Returns:
//
//  History:    3-28-97   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI FindMimeFromData(
                        LPBC pBC,                               // bind context - can be NULL
                        LPCWSTR pwzUrl,                     // url - can be null
                        LPVOID pBuffer,                     // buffer with data to sniff - can be null (pwzUrl must be valid)
                        DWORD cbSize,                   // size of buffer
                        LPCWSTR pwzMimeProposed,    // proposed mime if - can be null
                        DWORD dwMimeFlags,                  // will be determined
                        LPWSTR *ppwzMimeOut,        // the suggested mime
                        DWORD dwReserved)                   // must be 0
{
    DEBUG_ENTER_API((DBG_API,
                    Hresult,
                    "FindMimeFromData",
                    "%#x, %.80wq, %#x, %#x, %.80wq, %#x, %.80wq, %#x",
                    pBC, pwzUrl, pBuffer, cbSize, pwzMimeProposed, dwMimeFlags, ppwzMimeOut, dwReserved
                    ));
                    
    LPCWSTR wzMimeFromData = 0;
    HRESULT hr = E_FAIL;

    PerfDbgLog1(tagTransApi, NULL, "+FindMimeFromData (sugg: %ws)", pwzMimeProposed ? pwzMimeProposed : L"NULL");
    if (   !ppwzMimeOut
        || (!pwzUrl && !pBuffer))
    {
        hr = E_INVALIDARG;
    }
    else if( pBuffer || pwzMimeProposed )
    {
        CContentAnalyzer ca;
        wzMimeFromData = ca.FindMimeFromData(pwzUrl,(char*) pBuffer, cbSize, pwzMimeProposed, dwMimeFlags);

        if (wzMimeFromData)
        {
            *ppwzMimeOut = OLESTRDuplicate(wzMimeFromData);
            if (*ppwzMimeOut)
            {
                hr = NOERROR;
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }

        }
    }
    else
    {
        // file extension is the only solution
        LPSTR pszExt = NULL;
        CHAR  szUrl[MAX_PATH]; 
        CHAR  szMime[MAX_PATH];
        DWORD cbMime = MAX_PATH;
        
        W2A(pwzUrl, szUrl, MAX_PATH);
        pszExt = FindFileExtension(szUrl);

        if( pszExt )
        {
            hr = GetMimeFromExt(pszExt, szMime, &cbMime);
        }
        else
        {
            hr = E_FAIL;
        }

        if( SUCCEEDED(hr) )
        {
            *ppwzMimeOut = DupA2W(szMime);    
            if (*ppwzMimeOut)
            {
                hr = NOERROR;
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }

    PerfDbgLog1(tagTransApi, NULL, "-FindMimeFromData (actual: %ws)", wzMimeFromData ? wzMimeFromData : L"NULL" );

    DEBUG_LEAVE_API(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   CoInternetParseUrl
//
//  Synopsis:
//
//  Arguments:  [pwzUrl] --
//              [ParseAction] --
//              [dwFlags] --
//              [pszResult] --
//              [cchResult] --
//              [dwReserved] --
//
//  Returns:
//
//  History:    4-13-1997   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI CoInternetParseUrl(
    LPCWSTR     pwzUrl,
    PARSEACTION ParseAction,
    DWORD       dwFlags,
    LPWSTR      pszResult,
    DWORD       cchResult,
    DWORD      *pcchResult,
    DWORD       dwReserved
    )
{
    DEBUG_ENTER_API((DBG_API,
                    Hresult,
                    "CoInternetParseUrl",
                    "%.80wq, %#x, %#x, %#x, %#x, %#x, %#x",
                    pwzUrl, ParseAction, dwFlags, pszResult, cchResult, pcchResult, dwReserved
                    ));
                    
    PerfDbgLog(tagTransApi, NULL, "+CoInternetParseUrl");
    COInetSession *pOInetSession = 0;
    HRESULT hr = INET_E_DEFAULT_ACTION;

    if (!g_bShortcircuitKnownProtocols || !IsKnownProtocol(pwzUrl)) 
    {
        hr = GetCOInetSession(0, &pOInetSession,0);

        if (hr == NOERROR)
        {
            hr = pOInetSession->ParseUrl(pwzUrl, ParseAction, dwFlags,  pszResult, cchResult, pcchResult, dwReserved);
            pOInetSession->Release();
        }
    }
    
    if (hr == INET_E_DEFAULT_ACTION)
    {
        hr = E_FAIL;

        switch (ParseAction)
        {
        case PARSE_CANONICALIZE      :
            *pcchResult = cchResult;
            hr = UrlCanonicalizeW(pwzUrl, pszResult, pcchResult, dwFlags);
        break;
        case PARSE_SCHEMA            :
            *pcchResult = cchResult;
            hr = UrlGetPartW(pwzUrl, pszResult, pcchResult, URL_PART_SCHEME, 0);   
            break;

        break;
        case PARSE_SITE              :
        break;
        case PARSE_DOMAIN            :
            *pcchResult = cchResult;
            hr = UrlGetPartW(pwzUrl, pszResult, pcchResult, URL_PART_HOSTNAME, 0);   
            TransAssert(hr != E_POINTER);
            break;

        break;
        case PARSE_FRIENDLY          :
        break;
        case PARSE_SECURITY_URL   :
        // should return "schema:host"  for all protocols
        break;
        case PARSE_ROOTDOCUMENT      :
        {
            PARSEDURLW puW;
            puW.cbSize = sizeof(PARSEDURLW);
            if (SUCCEEDED(ParseURLW(pwzUrl, &puW)) && IsHierarchicalScheme(puW.nScheme))
            {
                DWORD cchRequired = 1;
                // The first URLGetPartW call is just to get the number of chars required for the hostname.
                // This is not as efficient but keeps the code simpler.
                if ((UrlGetPartW(pwzUrl, pszResult, &cchRequired, URL_PART_HOSTNAME, 0)) == E_POINTER)
                {
                    cchRequired += (puW.cchProtocol + 3);
                    if (cchResult >= cchRequired)
                    {
                        LPWSTR pszCopyTo = pszResult;

                        *pcchResult = cchRequired - 1;    // don't include terminating NULL char.
                        memcpy(pszCopyTo, puW.pszProtocol, puW.cchProtocol * sizeof(WCHAR));
                        pszCopyTo += puW.cchProtocol;
                        memcpy(pszCopyTo, L"://", 3 * sizeof(WCHAR));
                        pszCopyTo += 3;

                        DWORD cchHost = (DWORD) (cchResult - (pszCopyTo - pszResult));
                        hr = UrlGetPartW(pwzUrl, pszCopyTo, &cchHost, URL_PART_HOSTNAME, 0);
                    }
                    else 
                    {
                        *pcchResult = cchRequired;
                        hr = E_OUTOFMEMORY;
                    }
                }
            }
        }
        break;

        case PARSE_DOCUMENT          :
        break;
        case PARSE_ANCHOR            :
        break;
        case PARSE_ENCODE            :
        case PARSE_UNESCAPE          :
            *pcchResult = cchResult;
            hr = UrlUnescapeW((LPWSTR)pwzUrl, pszResult, pcchResult, dwFlags);
        break;
        case PARSE_ESCAPE            :
        case PARSE_DECODE            :
            *pcchResult = cchResult;
            hr = UrlEscapeW(pwzUrl, pszResult, pcchResult, dwFlags);
        break;
        case PARSE_PATH_FROM_URL     :
            *pcchResult = cchResult;
            hr = PathCreateFromUrlW(pwzUrl, pszResult, pcchResult, dwFlags);
        break;
        case PARSE_URL_FROM_PATH     :
            *pcchResult = cchResult;
            hr = UrlCreateFromPathW(pwzUrl, pszResult, pcchResult, dwFlags);
        break;
        case PARSE_LOCATION          :
        {
            hr = E_FAIL;
            *pcchResult = 0;
            LPCWSTR pwzStr = UrlGetLocationW(pwzUrl); //, pszResult, pcchResult, dwFlags);
            if (pwzStr)
            {
                DWORD dwlen = wcslen(pwzStr);
                if (dwlen < cchResult)
                {
                    wcscpy(pszResult, pwzStr);
                    *pcchResult = dwlen;
                    hr = NOERROR;
                }
                else
                {
                    // buffer too small
                }
            }
        }
        break;
        case PARSE_MIME              :
        default:
            hr = E_FAIL;
        }
    }

    PerfDbgLog1(tagTransApi, NULL, "-CoInternetParseUrl (hr:%lx)", hr);

    DEBUG_LEAVE_API(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     IsHierarchicalScheme
//
//  Synopsis:
//
//  Arguments:  [dwScheme] --
//
//  Returns:
//
//  History:    6-16-1997   Sanjays (Sanjay Shenoy)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

BOOL IsHierarchicalScheme(DWORD dwScheme)
{
    DEBUG_ENTER((DBG_TRANSDAT,
                Bool,
                "IsHierarchicalScheme",
                "%#x",
                dwScheme
                ));
                
    BOOL bReturn;

    switch ( dwScheme )
    {
        case URL_SCHEME_HTTP:
        case URL_SCHEME_FTP:
        case URL_SCHEME_HTTPS:
        case URL_SCHEME_NEWS:
        case URL_SCHEME_GOPHER:
        case URL_SCHEME_NNTP:
        case URL_SCHEME_TELNET:
        case URL_SCHEME_SNEWS:
            bReturn = TRUE;
            break;
        default:
            bReturn = FALSE;
            break;
    }

    DEBUG_LEAVE(bReturn);
    return bReturn;
}  

//+---------------------------------------------------------------------------
//
//  Method:     IsHierarchicalUrl
//
//  Synopsis:
//
//  Arguments:  [pwszUrl] --
//
//  Returns:
//
//  History:    6-16-1997   Sanjays (Sanjay Shenoy)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

BOOL IsHierarchicalUrl(LPCWSTR pwszUrl)
{
    DEBUG_ENTER((DBG_TRANSDAT,
                Bool,
                "IsHierarchicalUrl",
                "%.80wq",
                pwszUrl
                ));
                
    DWORD dwScheme = URL_SCHEME_INVALID;

    if(pwszUrl)
    {
        PARSEDURLW pu;
        pu.cbSize = sizeof(pu);
        if(SUCCEEDED(ParseURLW(pwszUrl, &pu)))
            dwScheme = pu.nScheme;
    }
  
    BOOL fRet = IsHierarchicalScheme(dwScheme);

    DEBUG_LEAVE(fRet);
    return fRet;
}

//+---------------------------------------------------------------------------
//
//  Method:     CoInternetGetSecurityUrl
//
//  Synopsis:
//
//  Arguments:  [pwszUrl] --
//              [ppszSecUrl] --
//              [psuAction]
//              [dwReserved]
//  Returns:
//
//  History:    4-28-1997   Sanjays (Sanjay Shenoy)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

STDAPI CoInternetGetSecurityUrl(
    LPCWSTR pwszUrl,
    LPWSTR *ppwszSecUrl,    // out argument.
    PSUACTION   psuAction,
    DWORD dwReserved
    )
{
    DEBUG_ENTER_API((DBG_API,
                    Hresult,
                    "CoInternetGetSecurityUrl",
                    "%.80wq, %#x, %#x, %#x",
                    pwszUrl, ppwszSecUrl, psuAction, dwReserved
                    ));
                    
    PerfDbgLog(tagTransApi, NULL, "+CoInternetGetSecurityUrl");
    COInetSession *pOInetSession = NULL;

    if (pwszUrl == NULL || ppwszSecUrl == NULL)
    {
        DEBUG_LEAVE_API(E_INVALIDARG);
        return E_INVALIDARG;
    }
    
    if (psuAction != PSU_DEFAULT && psuAction != PSU_SECURITY_URL_ONLY)
    {
        DEBUG_LEAVE_API(E_NOTIMPL);
        return E_NOTIMPL;
    }

    LPWSTR pwszSecUrl = (LPWSTR) pwszUrl;
    *ppwszSecUrl = NULL;
    BOOL bAllocSecUrl = FALSE; // Should we free pwszSecUrl?

    HRESULT hr = S_OK;

    // Step 1    
    // If this is a custom protocol, give it a chance to return back the 
    // security URL first. 

    hr = GetCOInetSession(0, &pOInetSession, 0);

    if (hr == NOERROR)
    {
        DWORD dwId;
        // It is important to loop here. The URL returned by a pluggable protocol by calling
        // PARSE_SECURITY_URL might be another pluggable protocol. 
        while ( !g_bShortcircuitKnownProtocols || ((dwId = IsKnownProtocol(pwszSecUrl)) == DLD_PROTOCOL_NONE) 
                || (dwId == DLD_PROTOCOL_STREAM)) // Special case mk: hack since there could be a 
                                                  // namespace handler defined for it. 
        {
        
            // Allocate as much memory as the url. This should be a good upper limit in most all cases.
            DWORD cchIn = lstrlenW(pwszSecUrl) + 1;
            DWORD cchOut = 0;

            LPWSTR pwszTmp = new WCHAR[cchIn];

            if (pwszTmp != NULL)
                hr = pOInetSession->ParseUrl(pwszSecUrl, PARSE_SECURITY_URL, 0, pwszTmp, cchIn, &cchOut, 0);
            else 
                hr = E_OUTOFMEMORY;


            // Not enough memory.
            if (hr == S_FALSE)
            {
                // Plug prot claims it needs more memory but asks us for a buffer of a 
                // smaller size.
                TransAssert(cchIn < cchOut);
                if (cchIn >= cchOut)
                {
                    hr = E_UNEXPECTED;
                }
                else
                {
                    cchIn = cchOut;
                    delete [] pwszTmp;
                    pwszTmp = new WCHAR[cchIn];

                    if ( pwszTmp != NULL ) 
                    {                  
                        hr = pOInetSession->ParseUrl(pwszSecUrl, PARSE_SECURITY_URL, 0, pwszTmp, cchIn, &cchOut, 0);
                        TransAssert(hr != S_FALSE);
                    }                
                    else
                    {
                        hr = E_OUTOFMEMORY;
                    }
                }
            }

            if (SUCCEEDED(hr))
            {
                // If for some reason the pluggable protocol just returned back
                // the original string, don't go into an infinite loop.
                if (0 == StrCmpW(pwszSecUrl, pwszTmp))
                {
                    delete [] pwszTmp;
                    break;
                }

                if (bAllocSecUrl)
                    delete [] pwszSecUrl;

                pwszSecUrl = pwszTmp;
                bAllocSecUrl = TRUE;
            }
            else 
            {
                if (hr == INET_E_DEFAULT_ACTION || hr == E_NOTIMPL)
                {
                    // This implies the pluggable protocol just wants us to use the 
                    // base url as the security url. 
                    hr = S_OK;
                }

                delete [] pwszTmp;
                break;
            }
        }
    }
    else 
    {
        // Some protocols don't support the IInternetProtocolInfo interface.
        // We will do the best we can. 
        hr = S_OK;
    }

    // End of Step 1.                                                          
    // At this point we have the security URL. We are done if the PSUACTION 
    // indicated we should only be getting the security URL.
    
    if (psuAction == PSU_SECURITY_URL_ONLY)
    {
        if (SUCCEEDED(hr))
        {
            // If we didn't allocate memory for pwszSecUrl i.e. it is the same as the 
            // input string, we have to do that before returning it back. 
            if (!bAllocSecUrl)    
            {
                *ppwszSecUrl = new WCHAR [(lstrlenW(pwszSecUrl) + 1)];
                if (*ppwszSecUrl != NULL)
                    StrCpyW(*ppwszSecUrl, pwszSecUrl);
                else
                    hr = E_OUTOFMEMORY;
            }
            else
            {
                *ppwszSecUrl = pwszSecUrl;
            }
        }
    }
    else
    {
        TransAssert(psuAction == PSU_DEFAULT);                                 
        // Step 2.
        // If URL after Step 1 is still not well known ask the protocol handler to simplify
        // it it is well known call UrlGetPart in shlwapi.

        LPWSTR pwszRet = NULL;

        if (SUCCEEDED(hr))
        {
            if (pwszSecUrl == NULL)
            {
                TransAssert(FALSE); // This has to be due to a bug in Step 1.
                pwszSecUrl = (LPWSTR) pwszUrl;   // recover as best as we can.
            }


            // Since Step 2 is just supposed to strip off parts we can safely assume that 
            // the out string will be smaller than the input string. 

            DWORD cchIn = lstrlenW(pwszSecUrl) + 1;
            DWORD cchOut = 0;
            pwszRet = new WCHAR[cchIn];

            if (pwszRet == NULL)
            {
                hr = E_OUTOFMEMORY;
            }
            else if (!g_bShortcircuitKnownProtocols || !IsKnownProtocol(pwszSecUrl))
            {
                TransAssert(pOInetSession);

                if (pOInetSession)
                    hr = pOInetSession->ParseUrl(pwszSecUrl, PARSE_SECURITY_DOMAIN, 0, pwszRet, cchIn, &cchOut, 0);
                else
                    hr = INET_E_DEFAULT_ACTION ; // no protocol info ==> use default

                TransAssert(hr != S_FALSE);   // Should never require more memory
                if (hr == INET_E_DEFAULT_ACTION || hr == E_NOTIMPL)
                {
                    StrCpyW(pwszRet, pwszSecUrl);
                    hr = S_OK;
                }
            }
            else  // Known protocol call shlwapi.
            {
                if (IsHierarchicalUrl(pwszSecUrl))
                {
                    hr = UrlGetPartW(pwszSecUrl, pwszRet, &cchIn, URL_PART_HOSTNAME, URL_PARTFLAG_KEEPSCHEME);   
                    TransAssert(hr != E_POINTER);
                }
                else
                {
                    // Just copy the string from step 1, we can't do any meaningful processing.
                    hr = INET_E_DEFAULT_ACTION;
                }


                // If UrlGetPart didn't process it, just pass the original string back.
                if (!SUCCEEDED(hr))
                {
                    hr = S_OK;
                    StrCpyW(pwszRet, pwszSecUrl);
                }
            }
        }

        // End of Step 2. 
    

        if (bAllocSecUrl)
            delete [] pwszSecUrl;

        if (SUCCEEDED(hr))
        {
            TransAssert(pwszRet != NULL);
            *ppwszSecUrl = pwszRet;
        }
    }

    PerfDbgLog1(tagTransApi, NULL, "-CoInternetGetSecurityUrl (hr:%lx)", hr);

    DEBUG_LEAVE_API(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   CoInternetCombineUrl
//
//  Synopsis:
//
//  Arguments:  [pwzBaseUrl] --
//              [pwzRelativeUrl] --
//              [dwFlags] --
//              [pszResult] --
//              [cchResult] --
//              [dwReserved] --
//
//  Returns:
//
//  History:    4-13-1997   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI CoInternetCombineUrl(
    LPCWSTR     pwzBaseUrl,
    LPCWSTR     pwzRelativeUrl,
    DWORD       dwFlags,
    LPWSTR      pszResult,
    DWORD       cchResult,
    DWORD      *pcchResult,
    DWORD       dwReserved
    )
{
    DEBUG_ENTER_API((DBG_API,
                    Hresult,
                    "CoInternetCombineUrl",
                    "%.80wq, %.80wq, %#x, %#x, %#x, %#x, %#x",
                    pwzBaseUrl, pwzRelativeUrl, dwFlags, pszResult, cchResult, pcchResult, dwReserved
                    ));
                    
    PerfDbgLog(tagTransApi, NULL, "+CoInternetCombineUrl");
    COInetSession *pOInetSession = 0;

    HRESULT hr = INET_E_DEFAULT_ACTION;

    if (!g_bShortcircuitKnownProtocols || !IsKnownProtocol(pwzBaseUrl))
    {
        hr = GetCOInetSession(0, &pOInetSession,0);

        if (hr == NOERROR)
        {
            hr = pOInetSession->CombineUrl(pwzBaseUrl, pwzRelativeUrl, dwFlags, pszResult, cchResult, pcchResult, dwReserved);
            pOInetSession->Release();
        }
    }
    if (hr == INET_E_DEFAULT_ACTION)
    {
        DWORD   dwRes = cchResult;

        hr = UrlCombineW(pwzBaseUrl, pwzRelativeUrl, pszResult, &dwRes, dwFlags);
        *pcchResult = dwRes;
    }

    PerfDbgLog1(tagTransApi, NULL, "-CoInternetCombineUrl (hr:%lx)", hr);

    DEBUG_LEAVE_API(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   CoInternetCompareUrl
//
//  Synopsis:
//
//  Arguments:  [pwzUrl1] --
//              [pwzUrl2] --
//              [dwFlags] --
//
//  Returns:
//
//  History:    4-13-1997   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI CoInternetCompareUrl(
    LPCWSTR pwzUrl1,
    LPCWSTR pwzUrl2,
    DWORD dwFlags
    )
{
    DEBUG_ENTER_API((DBG_API,
                    Hresult,
                    "CoInternetCompareUrl",
                    "%.80wq, %.80wq, %#x",
                    pwzUrl1, pwzUrl2, dwFlags
                    ));
                    
    PerfDbgLog(tagTransApi, NULL, "+CoInternetCompareUrl");
    COInetSession *pOInetSession = 0;
    HRESULT hr = INET_E_DEFAULT_ACTION;

    if (!g_bShortcircuitKnownProtocols || !IsKnownProtocol(pwzUrl1)) 
    {
        hr = GetCOInetSession(0, &pOInetSession,0);

        if (hr == NOERROR)
        {
            hr = pOInetSession->CompareUrl(pwzUrl1, pwzUrl2, dwFlags);
            pOInetSession->Release();
        }
    }
    if (hr == INET_E_DEFAULT_ACTION)
    {
        int iRes = UrlCompareW(pwzUrl1, pwzUrl2, dwFlags & CF_INGNORE_SLASH);
        if (iRes == 0)
        {
            hr = S_OK;
        }
        else
        {
            hr = S_FALSE;
        }
    }

    PerfDbgLog1(tagTransApi, NULL, "-CoInternetCompareUrl (hr:%lx)", hr);

    DEBUG_LEAVE_API(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   CoInternetQueryInfo
//
//  Synopsis:
//
//  Arguments:  [pwzUrl] --
//              [dwOptions] --
//              [pvBuffer] --
//              [cbBuffer] --
//              [pcbBuffer] --
//              [dwReserved] --
//
//  Returns:
//
//  History:    4-14-1997   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI CoInternetQueryInfo(
    LPCWSTR     pwzUrl,
    QUERYOPTION QueryOption,
    DWORD       dwQueryFlags,
    LPVOID      pvBuffer,
    DWORD       cbBuffer,
    DWORD      *pcbBuffer,
    DWORD       dwReserved
    )
{
    DEBUG_ENTER_API((DBG_API,
                    Hresult,
                    "CoInternetQueryInfo",
                    "%.80wq, %#x, %#x, %#x, %#x, %#x, %#x",
                    pwzUrl, QueryOption, dwQueryFlags, pvBuffer, cbBuffer, pcbBuffer, dwReserved
                    ));
                    
    PerfDbgLog(tagTransApi, NULL, "+CoInternetQueryInfo");
    COInetSession *pOInetSession = 0;

    HRESULT hr = INET_E_DEFAULT_ACTION;

    if (!g_bShortcircuitKnownProtocols || !IsKnownProtocol(pwzUrl))
    {
        hr = GetCOInetSession(0, &pOInetSession,0);

        if (hr == NOERROR)
        {
            hr = pOInetSession->QueryInfo(pwzUrl, QueryOption, dwQueryFlags, pvBuffer, cbBuffer, pcbBuffer, dwReserved);
            pOInetSession->Release();
        }
    }
  
    if (hr == INET_E_DEFAULT_ACTION)
    {
        switch (QueryOption)
        {
        case QUERY_USES_NETWORK:
        case QUERY_USES_CACHE:
            {
                if (!pvBuffer || cbBuffer < sizeof(DWORD))
                {
                    DEBUG_LEAVE_API(E_FAIL);
                    return E_FAIL;
                }

                if (pcbBuffer)
                {
                    *pcbBuffer = sizeof(DWORD);
                }

                switch (GetUrlScheme(pwzUrl)) 
                {
                    case URL_SCHEME_FILE:
                    case URL_SCHEME_NEWS:
                    case URL_SCHEME_NNTP:
                    case URL_SCHEME_MK:
                    case URL_SCHEME_SHELL:
                    case URL_SCHEME_SNEWS:
                    case URL_SCHEME_LOCAL:
                        *((DWORD *)pvBuffer) = FALSE;
                        
                        DEBUG_LEAVE_API(S_OK);
                        return S_OK;

                    case URL_SCHEME_FTP:
                    case URL_SCHEME_HTTP:
                    case URL_SCHEME_GOPHER:
                    case URL_SCHEME_TELNET:
                    case URL_SCHEME_WAIS:
                    case URL_SCHEME_HTTPS:
                        *((DWORD *)pvBuffer) = TRUE;
                        
                        DEBUG_LEAVE_API(S_OK);
                        return S_OK;

                    default:
                    
                        DEBUG_LEAVE_API(E_FAIL);
                        return E_FAIL;
                }
            }
            break;

         case QUERY_IS_CACHED:
         case QUERY_IS_INSTALLEDENTRY:
         case QUERY_IS_CACHED_OR_MAPPED:
            {
                char szUrl[MAX_URL_SIZE];
                DWORD dwFlags = 0;

                if(QueryOption == QUERY_IS_INSTALLEDENTRY)
                {
                    dwFlags = INTERNET_CACHE_FLAG_INSTALLED_ENTRY;
                }
                else if(QueryOption == QUERY_IS_CACHED_OR_MAPPED)
                {
                    dwFlags = INTERNET_CACHE_FLAG_ENTRY_OR_MAPPING;
                }
                // Otherwise let the flags remain as 0
                
                if (!pvBuffer || cbBuffer < sizeof(DWORD))
                {
                    DEBUG_LEAVE_API(E_FAIL);
                    return E_FAIL;
                }
                
                if (pcbBuffer)
                {
                    *pcbBuffer = sizeof(DWORD);
                }

                W2A(pwzUrl, szUrl, MAX_URL_SIZE);

                char *pchLoc = StrChr(szUrl, TEXT('#'));
                if (pchLoc)
                    *pchLoc = TEXT('\0');
        
                *((DWORD *)pvBuffer) = GetUrlCacheEntryInfoEx(szUrl, NULL, NULL, NULL, NULL, NULL, dwFlags);

                DEBUG_LEAVE_API(S_OK);
                return S_OK;
            }
            break;

        case QUERY_CAN_NAVIGATE:
            {
                //Bug#107130 - If we couldn't find the NEWS protocol, or it refused to answer this query,
                // trident assumes that it CAN navigate, and leads to above bug.
                // If we couldn't load this protocol, or it delegated to us, we now give Trident what they want.
                if (URL_SCHEME_NEWS == GetUrlScheme(pwzUrl))
                {
                    if (!pvBuffer || cbBuffer < sizeof(DWORD))
                    {
                        DEBUG_LEAVE_API(E_FAIL);
                        return E_FAIL;
                    }
                    
                    if (pcbBuffer)
                    {
                        *pcbBuffer = sizeof(DWORD);
                    }

                    *((DWORD *)pvBuffer) = FALSE;
                    
                    DEBUG_LEAVE_API(S_OK);
                    return S_OK;
                }
            }
            break;
             
        default:
            // do not know what do to
            hr = E_FAIL;
        }
    }

    PerfDbgLog1(tagTransApi, NULL, "-CoInternetQueryInfo (hr:%lx)", hr);

    DEBUG_LEAVE_API(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   CoInternetGetProtocolFlags
//
//  Synopsis:
//
//  Arguments:  [pwzUrl] --
//              [pdwFlags] --
//              [dwReserved] --
//
//  Returns:
//
//  History:    4-14-1997   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI CoInternetGetProtocolFlags(
    LPCWSTR     pwzUrl,
    DWORD      *pdwFlags,
    DWORD       dwReserved
    )
{
    DEBUG_ENTER_API((DBG_API,
                    Hresult,
                    "CoInternetGetProtocolFlags",
                    "%.80wq, %#x, %#x",
                    pwzUrl, pdwFlags, dwReserved
                    ));
                    
    PerfDbgLog(tagTransApi, NULL, "+CoInternetGetProtocolFlags");
    COInetSession *pOInetSession = 0;

    HRESULT hr = E_NOTIMPL;

    PerfDbgLog1(tagTransApi, NULL, "-CoInternetGetProtocolFlags (hr:%lx)", hr);

    DEBUG_LEAVE_API(hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   CoInternetCreateSecurityManager
//
//  Synopsis:
//
//  Arguments:  [pSP] --
//              [pSM] --
//              [dwReserved] --
//
//  Returns:
//
//  History:    4-28-1997   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI CoInternetCreateSecurityManager(IServiceProvider *pSP, IInternetSecurityManager **ppSM, DWORD dwReserved)
{
    DEBUG_ENTER_API((DBG_API,
                    Hresult,
                    "CoInternetCreateSecurityManager",
                    "%#x, %#x, %#x",
                    pSP, ppSM, dwReserved
                    ));
                    
    PerfDbgLog(tagTransApi, NULL, "+CoInternetCreateUrlSecurityManager");
    HRESULT hr = NOERROR;

    hr = InternetCreateSecurityManager(0, IID_IInternetSecurityManager, (void **)ppSM, dwReserved);

    PerfDbgLog1(tagTransApi, NULL, "-CoInternetCreateUrlSecurityManager (hr:%lx)", hr);

    DEBUG_LEAVE_API(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   CoInternetCreateZoneManager
//
//  Synopsis:
//
//  Arguments:  [pSP] --
//              [ppZM] --
//              [dwReserved] --
//
//  Returns:
//
//  History:    4-28-1997   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI CoInternetCreateZoneManager(IServiceProvider *pSP, IInternetZoneManager **ppZM, DWORD dwReserved)
{
    DEBUG_ENTER_API((DBG_API,
                    Hresult,
                    "CoInternetCreateZoneManager",
                    "%#x, %#x, %#x",
                    pSP, ppZM, dwReserved
                    ));
                    
    PerfDbgLog(tagTransApi, NULL, "+CoInternetCreateUrlZoneManager");
    HRESULT hr;

    hr = InternetCreateZoneManager(0, IID_IInternetZoneManager, (void **) ppZM, dwReserved);

    PerfDbgLog1(tagTransApi, NULL, "-CoInternetCreateUrlZoneManager (hr:%lx)", hr);

    DEBUG_LEAVE_API(hr);
    return hr;
}


BOOL PDFNeedProgressiveDownload()
{
    DEBUG_ENTER((DBG_TRANSDAT,
                Bool,
                "PDFNeedProgressiveDownload",
                NULL
                ));
                
    HKEY    hClsRegEntry;
    CHAR    szInProc[CLSIDSTR_MAX + 64];
    CHAR    szPath[MAX_PATH];
    long    lSize;
    BOOL    fRet = TRUE;
    BYTE*   pVerBuffer = NULL;
    DWORD   cbFileVersionBufSize;
    DWORD   dwTemp;
    unsigned uiLength = 0;
    VS_FIXEDFILEINFO *lpVSFixedFileInfo;

    strcpy(szInProc, 
           "CLSID\\{CA8A9780-280D-11CF-A24D-444553540000}\\InProcServer32");

    if( ERROR_SUCCESS != RegOpenKey(
                    HKEY_CLASSES_ROOT, szInProc, &hClsRegEntry) )
    {
        goto Exit;
    }

    // now we are at HKCR\CLSID\xxx-yyyy\InProcServer32
    // we need to get the path to the ocx
    lSize = MAX_PATH;
    if( ERROR_SUCCESS != RegQueryValue(
                    hClsRegEntry, NULL, szPath, &lSize) )
    {
        RegCloseKey(hClsRegEntry);
        goto Exit;
    }

    // done with key
    RegCloseKey(hClsRegEntry);
    
    // we have the path now
    if((cbFileVersionBufSize = GetFileVersionInfoSize( szPath, &dwTemp)) == 0 )
    {
        goto Exit;
    }

    pVerBuffer = new BYTE[cbFileVersionBufSize];
    if( !pVerBuffer )
    {
        goto Exit;
    }

    if( !GetFileVersionInfo(szPath, 0, cbFileVersionBufSize, pVerBuffer) )
    {
        goto Exit;
    }

    if( !VerQueryValue( 
            pVerBuffer, TEXT("\\"),(LPVOID*)&lpVSFixedFileInfo, &uiLength) ) 
    {
        goto Exit;
    }

    if( lpVSFixedFileInfo->dwFileVersionMS == 0x00010003 &&
        lpVSFixedFileInfo->dwFileVersionLS < 170 )
    {
        // this is 3.0 or 3.01, we should disable progressive download
        fRet = FALSE;
    }


Exit:
    if( pVerBuffer != NULL)
        delete [] pVerBuffer;

    DEBUG_LEAVE(fRet);
    return fRet;    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\urlhlink\sources.inc ===
SYNCHRONIZE_DRAIN=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\trans\urlmarsh.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       urlmarsh.cxx
//
//  Contents:   CUrlMarshal methods implementations
//              to support custom marshaling
//
//  Classes:
//
//  Functions:
//
//  History:    1-19-96   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------
#include <trans.h>
#include "urlmk.hxx"

PerfDbgTag(tagCUrlMarsh, "Urlmon", "Log CUrlMon Marshalling", DEB_URLMON);

//+---------------------------------------------------------------------------
//
//  Method:     CUrlMon::CanMarshalIID
//
//  Synopsis:   Checks whether this object supports marshalling this IID.
//
//  Arguments:  [riid] --
//
//  Returns:
//
//  History:    1-19-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
inline BOOL CUrlMon::CanMarshalIID(REFIID riid)
{
    DEBUG_ENTER((DBG_MONIKER,
                Bool,
                "CUrlMon::CanMarshalIID",
                "this=%#x, %#x",
                this, &riid
                ));
                
    // keep this in sync with the QueryInterface
    BOOL fRet = (BOOL) (riid == IID_IMoniker);

    DEBUG_LEAVE(fRet);
    return fRet;
}

//+---------------------------------------------------------------------------
//
//  Method:     CUrlMon::ValidateMarshalParams
//
//  Synopsis:   Validates the standard set parameters that are passed into most
//              of the IMarshal methods
//
//  Arguments:  [riid] --
//              [pvInterface] --
//              [dwDestContext] --
//              [pvDestContext] --
//              [mshlflags] --
//
//  Returns:
//
//  History:    1-19-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CUrlMon::ValidateMarshalParams(REFIID riid,void *pvInterface,
                    DWORD dwDestContext,void *pvDestContext,DWORD mshlflags)
{
    DEBUG_ENTER((DBG_MONIKER,
                Hresult,
                "CUrlMon::ValidateMarshalParams",
                "this=%#x, %#x, %#x, %#x, %#x, %#x",
                this, &riid, pvInterface, dwDestContext, pvDestContext, mshlflags
                ));

    PerfDbgLog(tagCUrlMarsh, this, "+CUrlMon::ValidateMarshalParams");
    HRESULT hr = NOERROR;
 
    if (CanMarshalIID(riid))
    {
        UrlMkAssert((dwDestContext == MSHCTX_INPROC || dwDestContext == MSHCTX_LOCAL || dwDestContext == MSHCTX_NOSHAREDMEM));
        UrlMkAssert((mshlflags == MSHLFLAGS_NORMAL || mshlflags == MSHLFLAGS_TABLESTRONG));

        if (   (dwDestContext != MSHCTX_INPROC && dwDestContext != MSHCTX_LOCAL && dwDestContext != MSHCTX_NOSHAREDMEM)
            || (mshlflags != MSHLFLAGS_NORMAL && mshlflags != MSHLFLAGS_TABLESTRONG))
        {
            hr = E_INVALIDARG;
        }
    }
    else
    {
        hr = E_NOINTERFACE;
    }

    PerfDbgLog1(tagCUrlMarsh, this, "-CUrlMon::ValidateMarshalParams (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
// IMarshal methods
//
//+---------------------------------------------------------------------------
//
//  Method:     CUrlMon::GetUnmarshalClass
//
//  Synopsis:
//
//  Arguments:  [riid] --
//              [pvInterface] --
//              [dwDestContext] --
//              [pvDestContext] --
//              [mshlflags] --
//              [pCid] --
//
//  Returns:
//
//  History:    1-19-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CUrlMon::GetUnmarshalClass(REFIID riid,void *pvInterface,
        DWORD dwDestContext,void *pvDestContext,DWORD mshlflags,CLSID *pCid)
{
    DEBUG_ENTER((DBG_MONIKER,
                Hresult,
                "CUrlMon::IMarshal::GetUnmarshalClass",
                "this=%#x, %#x, %#x, %#x, %#x, %#x, %#x",
                this, &riid, pvInterface, dwDestContext, pvDestContext, mshlflags, pCid
                ));
                
    HRESULT hr;
    PerfDbgLog(tagCUrlMarsh, this, "+CUrlMon::GetUnmarshalClass");

    hr = ValidateMarshalParams(riid, pvInterface, dwDestContext,pvDestContext, mshlflags);
    if (hr == NOERROR)
    {
        *pCid = (CLSID) CLSID_StdURLMoniker;
    }

    PerfDbgLog1(tagCUrlMarsh, this, "-CUrlMon::GetUnmarshalClass (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CUrlMon::GetMarshalSizeMax
//
//  Synopsis:
//
//  Arguments:  [void] --
//              [pvInterface] --
//              [dwDestContext] --
//              [pvDestContext] --
//              [mshlflags] --
//              [pSize] --
//
//  Returns:
//
//  History:    1-19-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CUrlMon::GetMarshalSizeMax(REFIID riid,void *pvInterface,
        DWORD dwDestContext,void *pvDestContext,DWORD mshlflags,DWORD *pSize)
{
    DEBUG_ENTER((DBG_MONIKER,
                Hresult,
                "CUrlMon::IMarshal::GetMarshalSizeMax",
                "this=%#x, %#x, %#x, %#x, %#x, %#x, %#x",
                this, &riid, pvInterface, dwDestContext, pvDestContext, mshlflags, pSize
                ));
                
    HRESULT hr;
    PerfDbgLog(tagCUrlMarsh, this, "+CUrlMon::GetMarshalSizeMax");

    if (pSize == NULL)
    {
        hr = E_INVALIDARG;

    }
    else
    {

        hr = ValidateMarshalParams(riid, pvInterface, dwDestContext,pvDestContext, mshlflags);
        if (hr == NOERROR)
        {

            // size of url + extra info
            *pSize = (wcslen(_pwzUrl) + 1) * sizeof(WCHAR) + sizeof(ULONG);
            // Note: add state info

        }
    }

    PerfDbgLog1(tagCUrlMarsh, this, "-CUrlMon::GetMarshalSizeMax (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CUrlMon::MarshalInterface
//
//  Synopsis:
//
//  Arguments:  [REFIID] --
//              [riid] --
//              [DWORD] --
//              [void] --
//              [DWORD] --
//              [mshlflags] --
//
//  Returns:
//
//  History:    1-19-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CUrlMon::MarshalInterface(IStream *pistm,REFIID riid,
                                void *pvInterface,DWORD dwDestContext,
                                void *pvDestContext,DWORD mshlflags)
{
    DEBUG_ENTER((DBG_MONIKER,
                Hresult,
                "CUrlMon::IMarshal::MarshalInterface",
                "this=%#x, %#x, %#x, %#x, %#x, %#x, %#x",
                this, pistm, &riid, pvInterface, dwDestContext, pvDestContext, mshlflags
                ));
                
    HRESULT hr;
    PerfDbgLog(tagCUrlMarsh, this, "+CUrlMon::MarshalInterface");

    hr = ValidateMarshalParams(riid, pvInterface, dwDestContext,pvDestContext, mshlflags);
    if (hr == NOERROR)
    {
        hr = Save(pistm, FALSE);
    }

    PerfDbgLog1(tagCUrlMarsh, this, "-CUrlMon::MarshalInterface (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CUrlMon::UnmarshalInterface
//
//  Synopsis:   Unmarshals an Urlmon interface out of a stream
//
//  Arguments:  [REFIID] --
//              [void] --
//              [ppvObj] --
//
//  Returns:
//
//  History:    1-19-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CUrlMon::UnmarshalInterface(IStream *pistm,REFIID riid,void ** ppvObj)
{
    DEBUG_ENTER((DBG_MONIKER,
                Hresult,
                "CUrlMon::IMarshal::UnmarshalInterface",
                "this=%#x, %#x, %#x, %#x",
                this, pistm, &riid, ppvObj
                ));
                
    HRESULT hr = NOERROR;
    PerfDbgLog(tagCUrlMarsh, this, "+CUrlMon::UnmarshalInterface");

    if (ppvObj == NULL)
    {
        hr = E_INVALIDARG;
    }
    else if (! CanMarshalIID(riid))
    {
        *ppvObj = NULL;
        hr = E_NOINTERFACE;
    }
    else
    {
        *ppvObj = NULL;

        hr = Load(pistm);

        // call QI to get the requested interface
        if (hr == NOERROR)
        {
            hr = QueryInterface(riid, ppvObj);
        }
    }

    PerfDbgLog1(tagCUrlMarsh, this, "-CUrlMon::UnmarshalInterface (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

STDMETHODIMP CUrlMon::ReleaseMarshalData(IStream *pStm)
{
    DEBUG_ENTER((DBG_MONIKER,
                Hresult,
                "CUrlMon::IMarshal::ReleaseMarshalData",
                "this=%#x, %#x",
                this, pStm
                ));
                
    PerfDbgLog(tagCUrlMarsh, this, "+CUrlMon::ReleaseMarshalData");
    PerfDbgLog1(tagCUrlMarsh, this, "-CUrlMon::ReleaseMarshalData (hr:%lx)", NOERROR);

    DEBUG_LEAVE(NOERROR);
    return NOERROR;
}

STDMETHODIMP CUrlMon::DisconnectObject(DWORD dwReserved)
{
    DEBUG_ENTER((DBG_MONIKER,
                Hresult,
                "CUrlMon::IMarshal::DisconnectObject",
                "this=%#x, %#x",
                this, dwReserved
                ));
                
    PerfDbgLog(tagCUrlMarsh, this, "+CUrlMon::DisconnectObject");
    PerfDbgLog1(tagCUrlMarsh, this, "-CUrlMon::DisconnectObject (hr:%lx)", NOERROR);

    DEBUG_LEAVE(NOERROR);
    return NOERROR;
}

//+---------------------------------------------------------------------------
//
//  Method:     CUrlMon::GetComparisonData
//
//  Synopsis:
//
//  Arguments:  [pbData] --
//              [cbMax] --
//              [pcbData] --
//
//  Returns:
//
//  History:    1-22-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CUrlMon::GetComparisonData(byte *pbData, ULONG cbMax, ULONG *pcbData)
{
    DEBUG_ENTER((DBG_MONIKER,
                Hresult,
                "CUrlMon::IROTData::GetComparisonData",
                "this=%#x, %#x, %#x, %#x",
                this, pbData, cbMax, pcbData
                ));
                
    PerfDbgLog(tagCUrlMarsh, this, "+CUrlMon::GetComparisonData");
    HRESULT hr = NOERROR;

    if (pbData == NULL || pcbData == NULL)
    {
        hr = E_INVALIDARG;
    }
    else
    {

        UrlMkAssert((_pwzUrl != NULL));

        *pcbData = (wcslen(_pwzUrl) + 1)  * sizeof(WCHAR);
        if (*pcbData > cbMax)
        {
            hr = E_FAIL;
        }
        else
        {
            wcscpy((WCHAR*)pbData,_pwzUrl);
        }
    }

    PerfDbgLog1(tagCUrlMarsh, this, "-CUrlMon::GetComparisonData (hr:%lx)", hr);

    DEBUG_LEAVE(NOERROR);
    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\trans\transmgr.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       transmgr.cxx
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    12-02-95   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------
#include <trans.h>

PerfDbgTag(tagCTransMgr, "Urlmon", "Log CTransactionMgr", DEB_TRANSMGR);
DbgTag(tagCTransMgrErr,  "Urlmon", "Log CTransMgr Errors", DEB_TRANSMGR|DEB_ERROR);

extern HINSTANCE g_hInst;
LRESULT CALLBACK TransactionWndProc(HWND hWnd, UINT msg,WPARAM wParam, LPARAM lParam);

#define szURLMonClassName "URL Moniker Notification Window"
static BOOL g_fWndClassRegistered = FALSE;
CMutexSem g_mxsTransMgr;

URLMON_TS* GetTS(DWORD);
HRESULT    AddTSToList(URLMON_TS*);

//+---------------------------------------------------------------------------
//
//  Function:   GetThreadTransactionMgr
//
//  Synopsis:
//
//  Arguments:  [fCreate] --
//
//  Returns:
//
//  History:    1-14-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
CTransactionMgr * GetThreadTransactionMgr(BOOL fCreate)
{
    DEBUG_ENTER((DBG_TRANSMGR,
                Pointer,
                "GetThreadTransactionMgr",
                "%B",
                fCreate
                ));
                
    PerfDbgLog(tagCTransMgr, NULL, "+GetThreadTransactionMgr");
    // only one thread should be here
    CLock lck(g_mxsMedia);

    HRESULT hr = NOERROR;
    CTransactionMgr *pCTMgr = NULL;

    CUrlMkTls tls(hr);
    if (hr == NOERROR)
    {
        pCTMgr = tls->pCTransMgr;

        if ((pCTMgr == NULL) && fCreate)
        {
            // the transaction mgr has an refcount of 1
            tls->pCTransMgr = pCTMgr = new CTransactionMgr;
        }
    }

    PerfDbgLog1(tagCTransMgr, NULL, "-GetThreadTransactionMgr (pCTMgr:%lx)", pCTMgr);

    DEBUG_LEAVE(pCTMgr);
    return pCTMgr;
}

//+---------------------------------------------------------------------------
//
//  Function:   GetTransactionMgr
//
//  Synopsis:
//
//  Arguments:  [fCreate] --
//
//  Returns:
//
//  History:    12-06-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
CTransactionMgr * GetTransactionMgr(BOOL fCreate)
{
    DEBUG_ENTER((DBG_TRANSMGR,
                Pointer,
                "GetTransactionMgr",
                "%B",
                fCreate
                ));
                
    CTransactionMgr* pCTransMgr = GetThreadTransactionMgr(fCreate);

    DEBUG_LEAVE(pCTransMgr);
    return pCTransMgr;
}

//+---------------------------------------------------------------------------
//
//  Function:   RegisterUrlMkWndClass
//
//  Synopsis:   register the Url Moniker window class on demand
//
//  Arguments:  (none)
//
//  Returns:    return FALSE if class could not be registered
//
//  History:    12-02-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL RegisterUrlMkWndClass()
{
    DEBUG_ENTER((DBG_TRANSMGR,
                Bool,
                "RegisterUrlMkWndClass",
                NULL
                ));
                
    // only one thread should be here
    CLock lck(g_mxsMedia);

    if (g_fWndClassRegistered == FALSE)
    {
        // else register the window class
        WNDCLASS    wndclass;

        wndclass.style          = 0;
        wndclass.lpfnWndProc    = &TransactionWndProc;
        wndclass.cbClsExtra     = 0;
        wndclass.cbWndExtra     = 0;
        wndclass.hInstance      = g_hInst;
        wndclass.hIcon          = NULL;
        wndclass.hCursor        = NULL;;
        wndclass.hbrBackground  = (HBRUSH)NULL;
        wndclass.lpszMenuName   = NULL;
        wndclass.lpszClassName  = szURLMonClassName;

        // Register the window class
        if (!RegisterClass(&wndclass))
        {
            DWORD dwLastError = GetLastError();

            if(dwLastError == ERROR_CLASS_ALREADY_EXISTS)
            {
                g_fWndClassRegistered = TRUE;
            }
            else
            {
                DEBUG_PRINT(TRANSMGR, ERROR, ("RegisterUrlMkWndClass(): RegisterClass failed, GetLastError: %ld\n", dwLastError));
                TransAssert(FALSE);
            }
        }
        else
        {
            g_fWndClassRegistered = TRUE;
        }
    }

    DEBUG_LEAVE(g_fWndClassRegistered);
    return g_fWndClassRegistered;
}


//+---------------------------------------------------------------------------
//
//  Function:   UnregisterUrlMkWndClass
//
//  Synopsis:   unregisters the hidden windows class
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    10-16-1996   JohannP (Johann Posch)   Created
//
//  Notes:      called during process detach
//
//----------------------------------------------------------------------------
BOOL UnregisterUrlMkWndClass()
{
    DEBUG_ENTER((DBG_TRANSMGR,
                Bool,
                "UnregisterUrlMkWndClass",
                NULL
                ));
                
    if (g_fWndClassRegistered == TRUE)
    {
        // Register the window class
        if (UnregisterClass(szURLMonClassName,g_hInst))
        {
            g_fWndClassRegistered = FALSE;
        }
        else
        {
            DEBUG_PRINT(TRANSMGR, ERROR, ("UnregisterUrlMkWndClass(): UnregisterClass failed, GetLastError: %ld\n", GetLastError()));
        }
    }

    DEBUG_LEAVE(g_fWndClassRegistered);
    return g_fWndClassRegistered;
}


//+---------------------------------------------------------------------------
//
//  Function:   GetThreadNotificationWnd
//
//  Synopsis:   return the notification for the current
//              the window is created if
//
//  Arguments:  [fCreate] --    TRUE if the window should be created
//
//  Returns:
//
//  History:    12-02-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
#ifndef HWND_MESSAGE
#define HWND_MESSAGE     ((HWND)-3)
#endif

extern BOOL  g_bNT5OrGreater;

HWND GetThreadNotificationWnd(BOOL fCreate)
{
    DEBUG_ENTER((DBG_TRANSMGR,
                Dword,
                "GetThreadNotificationWnd",
                "%B",
                fCreate
                ));
                
    HRESULT hr = NOERROR;
    HWND hwnd = NULL;

    DWORD tid = GetCurrentThreadId();
    URLMON_TS*  ts = NULL;

    ts = GetTS(tid);
    if( ts )
    {
        hwnd = ts->_hwndNotify;
        TransAssert((hwnd != NULL && "TS Corrupted!"));
    }   
    else
    {
        ts = new URLMON_TS;
        
        if( ts )
        { 
            if (   fCreate
                && (hwnd == NULL)
                && RegisterUrlMkWndClass() )
            {
                hwnd = CreateWindowEx(0, szURLMonClassName, NULL,
                                    0, 0, 0, 0, 0, 
                                    g_bNT5OrGreater ? HWND_MESSAGE : NULL, 
                                    NULL, g_hInst, NULL);

                TransAssert((hwnd != NULL && "can't create Notify window"));
                if (hwnd)
                {
                    ts->_dwTID = tid;
                    ts->_hwndNotify = hwnd;

                    AddTSToList(ts);
                }
            }
            else
            {
                delete ts;
            }
        }

    }
/**************************************************************************
    CUrlMkTls tls(hr);

    if (hr == NOERROR)
    {
        hwnd = tls->hwndUrlMkNotify;

        if (   fCreate
            && (hwnd == NULL)
            && RegisterUrlMkWndClass() )
        {
            hwnd = CreateWindowEx(0, szURLMonClassName, NULL,
                                    0, 0, 0, 0, 0, NULL, NULL, g_hInst, NULL);

            TransAssert((hwnd != NULL && "GetNotificationWnd: could not create window"));
            if (hwnd)
            {
                tls->hwndUrlMkNotify = hwnd;
                char achProgname[256];
                achProgname[0] = '\0';
                GetModuleFileNameA(NULL, achProgname, sizeof(achProgname));
            }
        }
    }
***************************************************************************/

    DEBUG_LEAVE(hwnd);
    return hwnd;
}

//+---------------------------------------------------------------------------
//
//  Method:     CTransactionMgr::CTransactionMgr
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    1-14-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
CTransactionMgr::CTransactionMgr() : CLifePtr()
{
    DEBUG_ENTER((DBG_TRANSMGR,
                None,
                "CTransactionMgr::CTransactionMgr",
                "this=%#x",
                this
                ));
                
    _pCTransFirst = NULL;
    _pCTransLast = NULL;

    DEBUG_LEAVE(0);
}


//+---------------------------------------------------------------------------
//
//  Method:     CTransactionMgr::~CTransactionMgr
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    1-14-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
CTransactionMgr::~CTransactionMgr()
{
    DEBUG_ENTER((DBG_TRANSMGR,
                None,
                "CTransactionMgr::~CTransactionMgr",
                "this=%#x",
                this
                ));
                
    // The list should be empty by the time it gets destroyed
    if (_pCTransFirst)
    {
        DbgLog1(tagCTransMgr, this, "CTransactionMgr::~CTransactionMgr (list not empty:%lx)", _pCTransFirst);
    }

    //TransAssert(( _pCTransFirst == NULL ));

    DEBUG_LEAVE(0);
}

//+---------------------------------------------------------------------------
//
//  Method:     CTransactionMgr::AddTransaction
//
//  Synopsis:   Add an internet transaction to the linked list.
//
//  Arguments:  [pCTrans] --
//
//  Returns:
//
//  History:    12-12-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CTransactionMgr::AddTransaction(CTransaction *pCTrans)
{
    DEBUG_ENTER((DBG_TRANSMGR,
                Hresult,
                "CTransactionMgr::AddTransaction",
                "this=%#x, %#x",
                this, pCTrans
                ));
                
    PerfDbgLog(tagCTransMgr, this, "+CTransMgr::AddTransaction");
    TransAssert((pCTrans != NULL));
    

    TransAssert((pCTrans->GetNextTransaction() == NULL));

    pCTrans->SetNextTransaction(_pCTransFirst);
    _pCTransFirst = pCTrans;
    AddRef();

    PerfDbgLog1(tagCTransMgr, this, "-CTransMgr::AddTransaction(hr:%lx)", NOERROR);

    DEBUG_LEAVE(NOERROR);
    return NOERROR;
}

//+---------------------------------------------------------------------------
//
//  Method:     CTransactionMgr::RemoveTransaction
//
//  Synopsis:   Removes a transaction from the linked list.  If the transaction
//              cannot be found, E_FAIL is returned.
//
//  Arguments:  [pCTrans] --
//
//  Returns:
//
//  History:    12-12-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CTransactionMgr::RemoveTransaction(CTransaction *pCTrans)
{
    DEBUG_ENTER((DBG_TRANSMGR,
                Hresult,
                "CTransactionMgr::RemoveTransaction",
                "this=%#x, %#x",
                this, pCTrans
                ));
                
    PerfDbgLog(tagCTransMgr, this, "+CTransMgr::RemoveTransaction");
    CLock lck(g_mxsTransMgr);
    CTransaction *pCTransPrev = NULL;
    CTransaction *pCTransTmp;
    HRESULT hr = E_FAIL;

    TransAssert((pCTrans != NULL));


    pCTransTmp = _pCTransFirst;

    TransAssert((pCTransTmp != NULL));

    // Search all the nodes in the linked list
    if (_pCTransFirst == pCTrans)
    {
        _pCTransFirst = _pCTransFirst->GetNextTransaction();
        hr = NOERROR;
        Release();
    }
    else while (pCTransTmp != NULL)
    {
        // If a match is found
        if (pCTransTmp == pCTrans)
        {
            // Remove it from the linked list
            if (pCTransPrev == NULL)
            {
                _pCTransFirst = pCTrans->GetNextTransaction();
            }
            else
            {
                pCTransPrev->SetNextTransaction(pCTrans->GetNextTransaction());
            }

            hr = NOERROR;
            Release();
        }

        pCTransPrev = pCTransTmp;
        pCTransTmp = pCTransTmp->GetNextTransaction();
    }

    TransAssert((hr == NOERROR));

    PerfDbgLog1(tagCTransMgr, this, "-CTransMgr::RemoveTransaction (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   GetTransactionObjects
//
//  Synopsis:
//
//  Arguments:  [pBndCtx] --
//              [wzUrl] --
//              [pUnkOuter] --
//              [ppUnk] --
//              [ppCTrans] --
//              [dwOption] --
//              [ppCTranSData] --
//
//  Returns:
//
//  History:    4-12-1997   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT GetTransactionObjects(LPBC pBndCtx, LPCWSTR wzUrl, IUnknown *pUnkOuter, IUnknown **ppUnk, 
                              IOInetProtocol **ppCTrans, DWORD dwOption, CTransData **ppCTransData)
{
    DEBUG_ENTER((DBG_TRANSMGR,
                Hresult,
                "GetTransactionObjects",
                "%#x, %.80wq, %#x, %#x, %#x, %#x, %#x",
                pBndCtx, wzUrl, pUnkOuter, ppUnk, ppCTrans, dwOption, ppCTransData
                ));
                
    HRESULT hr = S_OK;
    PerfDbgLog(tagCTransMgr, NULL, "+GetTransactionObjects");
    TransAssert((ppCTrans != NULL));
    CTransaction *pCTransTmp = NULL;

    BOOL fFound = FALSE;
    CLock lck(g_mxsTransMgr);

    CBindCtx *pCBndCtx = NULL;

    if (pBndCtx)
    {
        hr = pBndCtx->QueryInterface(IID_IAsyncBindCtx, (void **) &pCBndCtx);

        if (hr == NOERROR)
        {
            TransAssert((pCBndCtx));
            hr = pCBndCtx->GetTransactionObjects(&pCTransTmp, ppCTransData);
            if (hr == NOERROR)
            {
                TransAssert((pCTransTmp));

                if (!pCTransTmp->IsApartmentThread())
                {
                    pCBndCtx->SetTransactionObject(NULL);
                }

                fFound = TRUE;
                hr = S_FALSE;
            }
        }

        if (hr != S_FALSE && hr != NOERROR)
        {
            CBinding *pCBdgBindToObject = NULL;
            hr = pBndCtx->GetObjectParam(SZ_BINDING, (IUnknown **)&pCBdgBindToObject);

            if (pCBdgBindToObject)
            {
                pCTransTmp = (CTransaction *) pCBdgBindToObject->GetOInetBinding();
                fFound =  pCTransTmp ? true : false;
                pCTransTmp->AddRef();
                pCBdgBindToObject->Release();
                DbgLog1(tagCTransMgr, NULL, "=== CTransMgr::GetTransaction Found Transaction:%lx", pCTransTmp);
            }
        }

    }

    if (!fFound)
    {
        CTransactionMgr *pCTransMgr = GetThreadTransactionMgr();

        if (!pCTransMgr)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            // create a new transaction add it to the list
            hr = CTransaction::Create(pCBndCtx, dwOption, 0, 0, &pCTransTmp);
            if (hr == NOERROR)
            {
                hr = pCTransTmp->QueryInterface(IID_IOInetProtocol, (void **) ppCTrans);

                if (hr == NOERROR)
                {
                    pCTransTmp->Release();
                    pCTransMgr->AddTransaction(pCTransTmp);
                }
                
                if (!pCBndCtx && pBndCtx)
                {
                    pBndCtx->QueryInterface(IID_IAsyncBindCtx, (void **) &pCBndCtx);
                }
                if (pCBndCtx)
                {
                    pCBndCtx->SetTransactionObject(pCTransTmp);
                }
            }
        }
    }
    else if (pCTransTmp)
    {
        DbgLog1(tagCTransMgr, NULL, "GetTransactionObjects Found existing transaction(%lx)", pCTransTmp);
        // return false to indicate found existing transaction
        hr = S_FALSE;
    }

    if (pCBndCtx)
    {
        pCBndCtx->Release();
    }

    *ppCTrans = pCTransTmp;

    if (*ppCTrans && ppCTransData && *ppCTransData)
    {
        hr = S_FALSE;
    }

    if( hr == S_FALSE && ppCTransData && !*ppCTransData )
    {
        hr = S_OK;
    }

    PerfDbgLog2(tagCTransMgr, NULL, "-API GetTransactionObjects (pCTrans:%lx; hr:%lx)", pCTransTmp, hr);

    DEBUG_LEAVE(hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\urlhlink\idispids.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright 1995 - 1996 Microsoft Corporation. All Rights Reserved.
//
//  File: idispids.h
//
//--------------------------------------------------------------------------

#define DISPID_READYSTATE               (-525)
#define DISPID_READYSTATECHANGE         (-609)
#define DISPID_AMBIENT_TRANSFERPRIORITY (-728)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\urlmon\trans\urlmon.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       urlmon.cxx
//
//  Contents:   contains URL moniker implementation
//
//  Classes:
//
//  Functions:
//
//  History:    12-11-95   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------
#include <trans.h>
#ifndef unix
#include "..\iapp\curl.hxx"
#else
#include "../iapp/curl.hxx"
#endif /* unix */
#include "urlmk.hxx"

PerfDbgTag(tagCUrlMon, "Urlmon", "Log CUrlMon", DEB_URLMON);

BOOL IsOInetProtocol(IBindCtx *pbc, LPCWSTR wzProtocol);

// prototypes of helper functions (used by RelativePathTo)
CUrlMon *CreateEmptyPathUrlMon();
HRESULT HrCreateCUrlFromUrlStr(LPCWSTR pwzUrl, BOOL fParseUrl, CUrl **ppUrl);
HRESULT HrCreateCUrlFromUrlMon(LPMONIKER pmkUrl, BOOL fParseUrl, CUrl **ppUrl);
HRESULT HrGetRelativePath(LPSTR lpszBase, LPSTR lpszOther, DWORD dwProto, LPSTR lpszHost,LPSTR lpszRelPath);

// #define URLMON_RELPATHTO_PARSE_QUERY_PARAMS
#ifdef URLMON_RELPATHTO_PARSE_QUERY_PARAMS
// These are helper routines used by RelativePathTo to deal with the Query
// and Params sub-strings of a URL, according to rfc 1808.
// These routines are not enabled because ComposeWith does not deal with
// these sub-strings in any special way, and we want RelativePathTo to be
// compatible with ComposeWith.
void ParseUrlQuery(LPSTR pszURL, LPSTR *ppszQuery);
void ParseUrlParams(LPSTR pszURL, LPSTR *ppszParams);
void AddParamsAndQueryToRelPath(LPSTR szRelPath,
    LPSTR pszParamsBase, LPSTR pszParamsOther,
    LPSTR pszQueryBase, LPSTR pszQueryOther);
#endif // URLMON_RELPATHTO_PARSE_QUERY_PARAMS


// Macros for Double-Byte Character Support (DBCS)
#if 1
    // Beware of double evaluation
    #define IncLpch(sz)          ((sz)=CharNext((sz)))
    #define DecLpch(szStart, sz) ((sz)=CharPrev ((szStart),(sz)))
#else
    #define IncLpch(sz)         (++(sz))
    #define DecLpch(szStart,sz) (--(sz))
#endif


CUrlMon::CUrlMon(LPWSTR pszUrl) : _CRefs()
{
    DEBUG_ENTER((DBG_MONIKER,
                None,
                "CUrlMon::CUrlMon",
                "this=%#x",
                this
                ));
                
    _pwzUrl = pszUrl;
    DllAddRef();

    DEBUG_LEAVE(0);
}

CUrlMon::~CUrlMon()
{
    DEBUG_ENTER((DBG_MONIKER,
                None,
                "CUrlMon::~CUrlMon",
                "this=%#x",
                this
                ));

    if (_pwzUrl)
    {
        delete [] _pwzUrl;
    }
    DllRelease();

    DEBUG_LEAVE(0);
}

//+---------------------------------------------------------------------------
//
//  Method:     CUrlMon::QueryInterface
//
//  Synopsis:
//
//  Arguments:  [riid] --
//              [ppvObj] --
//
//  Returns:
//
//  History:    1-19-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CUrlMon::QueryInterface(REFIID riid, void **ppvObj)
{
    DEBUG_ENTER((DBG_MONIKER,
                Hresult,
                "CUrlMon::IUnknown::QueryInterface",
                "this=%#x, %#x, %#x",
                this, &riid, ppvObj
                ));
                
    VDATEPTROUT(ppvObj, void *);
    HRESULT hr = NOERROR;
    PerfDbgLog(tagCUrlMon, this, "+CUrlMon::QueryInterface");

    if (   riid == IID_IUnknown
        || riid == IID_IMoniker
        || riid == IID_IAsyncMoniker
        || riid == IID_IPersist
        || riid == IID_IPersistStream)
    {
        *ppvObj = this;
    }
    else if (riid == IID_IROTData)
    {
        *ppvObj = (void*)(IROTData *) this;
    }
    else if (riid == IID_IMarshal)
    {
        *ppvObj = (void*) (IMarshal *) this;
    }
    else
    {
        *ppvObj = NULL;
        hr = E_NOINTERFACE;
    }
    if (hr == NOERROR)
    {
        AddRef();
    }

    PerfDbgLog1(tagCUrlMon, this, "-CUrlMon::QueryInterface (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   CUrlMon::AddRef
//
//  Synopsis:
//
//  Arguments:  [ULONG] --
//
//  Returns:
//
//  History:    1-19-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CUrlMon::AddRef(void)
{
    DEBUG_ENTER((DBG_MONIKER,
                Dword,
                "CUrlMon::IUnknown::AddRef",
                "this=%#x",
                this
                ));
                
    LONG lRet = ++_CRefs;

    PerfDbgLog1(tagCUrlMon, this, "CUrlMon::AddRef (cRefs:%ld)", lRet);

    DEBUG_LEAVE(lRet);
    return lRet;
}

//+---------------------------------------------------------------------------
//
//  Function:   CUrlMon::Release
//
//  Synopsis:
//
//  Arguments:  [ULONG] --
//
//  Returns:
//
//  History:    1-19-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CUrlMon::Release(void)
{
    DEBUG_ENTER((DBG_MONIKER,
                Dword,
                "CUrlMon::IUnknown::Release",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCUrlMon, this, "+CUrlMon::Release");

    LONG lRet = --_CRefs;

    if (_CRefs == 0)
    {
        delete this;
    }

    PerfDbgLog1(tagCUrlMon, this, "-CUrlMon::Release (cRefs:%ld)", lRet);

    DEBUG_LEAVE(lRet);
    return lRet;
}

//+---------------------------------------------------------------------------
//
//  Method:     CUrlMon::GetClassID
//
//  Synopsis:
//
//  Arguments:  [pClassID] --
//
//  Returns:
//
//  History:    1-19-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CUrlMon::GetClassID(CLSID *pClassID)
{
    DEBUG_ENTER((DBG_MONIKER,
                Hresult,
                "CUrlMon::IPersist::GetClassID",
                "this=%#x, %#x",
                this, pClassID
                ));
                
    VDATEPTRIN(pClassID, CLSID);
    PerfDbgLog(tagCUrlMon, this, "+CUrlMon::GetClassID");

    *pClassID = CLSID_StdURLMoniker;
    PerfDbgLog1(tagCUrlMon, this, "-CUrlMon::GetClassID (hr:%lx)", NOERROR);

    DEBUG_LEAVE(NOERROR);
    return NOERROR;
}

//+---------------------------------------------------------------------------
//
//  Method:     CUrlMon::IsDirty
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    1-19-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CUrlMon::IsDirty()
{
    DEBUG_ENTER((DBG_MONIKER,
                Hresult,
                "CUrlMon::IPersistStream::IsDirty",
                "this=%#x",
                this
                ));
                

    DEBUG_LEAVE(NOERROR);
    return NOERROR;
}

//+---------------------------------------------------------------------------
//
//  Method:     CUrlMon::Load
//
//  Synopsis:
//
//  Arguments:  [pistm] --
//
//  Returns:
//
//  History:    1-19-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CUrlMon::Load(IStream *pistm)
{
    DEBUG_ENTER((DBG_MONIKER,
                Hresult,
                "CUrlMon::IPersistStream::Load",
                "this=%#x, %#x",
                this, pistm
                ));
                
    VDATEIFACE(pistm);
    PerfDbgLog(tagCUrlMon, this, "+CUrlMon::Load");
    HRESULT hr = NOERROR;
    ULONG cbLen = 0;

    // Read in the new URL from the stream
    hr = pistm->Read(&cbLen, sizeof(ULONG), NULL);

    if ((hr == NOERROR) && (cbLen > 0))
    {
        LPWSTR wszUrlLocal = new WCHAR [cbLen / sizeof(WCHAR)];
        DbgLog2(tagCUrlMon, this, "=== CUrlMon::Load (cbBytes:%ld, cbLen:%ld)", cbLen,  cbLen / sizeof(WCHAR));

        if (wszUrlLocal)
        {
            hr = pistm->Read(wszUrlLocal, cbLen, NULL);
            DbgLog2(tagCUrlMon, this, "=== CUrlMon::Load (cbLen:%ld, hr:%lx)", cbLen, hr);

            if (hr == NOERROR)
            {
                // If we already had a URL, delete it
                if (_pwzUrl)
                {
                    delete [] _pwzUrl;
                }

                _pwzUrl = wszUrlLocal;
            }
            else
            {
                delete [] wszUrlLocal;
            }
        }
    }

    PerfDbgLog2(tagCUrlMon, this, "-CUrlMon::Load (hr:%lx, szUrl:%ws)", hr, _pwzUrl?_pwzUrl:L"");

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CUrlMon::Save
//
//  Synopsis:
//
//  Arguments:  [pistm] --
//              [fClearDirty] --
//
//  Returns:
//
//  History:    1-19-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CUrlMon::Save(IStream *pistm, BOOL fClearDirty)
{
    DEBUG_ENTER((DBG_MONIKER,
                Hresult,
                "CUrlMon::IPersistStream::Save",
                "this=%#x, %#x, %B",
                this, pistm, fClearDirty
                ));
                
    VDATEIFACE(pistm);
    PerfDbgLog(tagCUrlMon, this, "+CUrlMon::Save");
    UrlMkAssert((_pwzUrl));
    HRESULT hr = E_FAIL;

    if (_pwzUrl)
    {
        ULONG cbLen = (wcslen(_pwzUrl) + 1) * sizeof(WCHAR);
        DbgLog2(tagCUrlMon, this, "=== CUrlMon::Save (cbLen:%ld, cbLen:%ld)", cbLen, cbLen / sizeof(WCHAR));

        // Write the URL to the stream
        hr = pistm->Write(&cbLen, sizeof(ULONG), NULL);
        if (hr == NOERROR)
        {
            hr = pistm->Write(_pwzUrl, cbLen, NULL);
        }
    }

    PerfDbgLog1(tagCUrlMon, this, "-CUrlMon::Save (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CUrlMon::GetSizeMax
//
//  Synopsis:
//
//  Arguments:  [pcbSize] --
//
//  Returns:
//
//  History:    1-19-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CUrlMon::GetSizeMax(ULARGE_INTEGER *pcbSize)
{
    DEBUG_ENTER((DBG_MONIKER,
                Hresult,
                "CUrlMon::IPersistStream::GetSizeMax",
                "this=%#x, %#x",
                this, pcbSize
                ));
                
    VDATEPTROUT (pcbSize, ULONG);
    PerfDbgLog(tagCUrlMon, this, "+CUrlMon::GetSizeMax");

    UrlMkAssert((_pwzUrl));
    UrlMkAssert((pcbSize));

    // length of url
    ULISet32(*pcbSize, ((wcslen(_pwzUrl) + 1) * sizeof(WCHAR)) + sizeof(ULONG));

    PerfDbgLog1(tagCUrlMon, this, "-CUrlMon::GetSizeMax (hr:%lx)", NOERROR);

    DEBUG_LEAVE(NOERROR);
    return NOERROR;
}

//+---------------------------------------------------------------------------
//
//  Method:     CUrlMon::BindToObject
//
//  Synopsis:
//
//  Arguments:  [pbc] --
//              [pmkToLeft] --
//              [riidRes] --
//              [ppvRes] --
//
//  Returns:
//
//  History:    1-19-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CUrlMon::BindToObject(IBindCtx *pbc, IMoniker *pmkToLeft,  REFIID riidRes, void **ppvRes)
{
    DEBUG_ENTER((DBG_MONIKER,
                Hresult,
                "CUrlMon::IMoniker::BindToObject",
                "this=%#x, %#x, %#x, %#x, %#x",
                this, pbc, pmkToLeft, &riidRes, ppvRes
                ));
                
    VDATEPTROUT(ppvRes, LPVOID);
    VDATEIFACE(pbc);
    PerfDbgLog2(tagCUrlMon, this, "+CUrlMon::BindToObject (IBindCtx:%lx, pmkToLeft:%lx)", pbc, pmkToLeft);

    *ppvRes = NULL;
    if (pmkToLeft)
    {
        VDATEIFACE(pmkToLeft);
    }

    HRESULT     hr;
    CLSID       clsid;
    BIND_OPTS   bindopts;
    CBinding    *pCBdg = NULL;
    CBSC        *pBSC = NULL;
    WCHAR       wzURL[MAX_URL_SIZE + 1];

    *ppvRes = NULL;

    // Step 1:  check if the object is runining
    //          if so QI for the requested interface
    //
    {
        IRunningObjectTable     *pROT = NULL;
        // check if the object is already running
        hr = IsRunningROT(pbc, pmkToLeft, &pROT);
        if (hr == NOERROR)
        {
            // object is running
            IUnknown *pUnk = NULL;

            // object is running
            // get the object and Qi for the requested interface
            hr = pROT->GetObject(this, &pUnk);
            if (SUCCEEDED(hr))
            {
                hr = pUnk->QueryInterface(riidRes, ppvRes);
                pUnk->Release();
            }

            pROT->Release();
            goto End;
        }
        else
        {
            if (pROT)
            {
                pROT->Release();
            }

            if (FAILED(hr))
            {
                // did not get ROT!!
                goto End;
            }
        }
    }

    // Step 2: get the bind options from the bind context
    bindopts.cbStruct = sizeof(BIND_OPTS);
    hr = pbc->GetBindOptions(&bindopts);
    if (FAILED(hr))
    {
        goto End;
    }

    // Step 3:  create a CBinding and releated objects and
    //          start a transaction


    hr = StartBinding(TRUE, pbc, pmkToLeft, riidRes, ppvRes);

End:

    PerfDbgLog2(tagCUrlMon, this, "-CUrlMon::BindToObject (hr:%lx, ppvobj:%lx)",
                    hr, (hr == S_OK) ? *ppvRes : NULL);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CUrlMon::BindToStorage
//
//  Synopsis:
//
//  Arguments:  [pbc] --
//              [pmkToLeft] --
//              [riid] --
//              [ppvObj] --
//
//  Returns:
//
//  History:    1-19-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CUrlMon::BindToStorage(IBindCtx *pbc, IMoniker *pmkToLeft, REFIID riid, void **ppvObj)
{
    DEBUG_ENTER((DBG_MONIKER,
                Hresult,
                "CUrlMon::IMoniker::BindToStorage",
                "this=%#x, %#x, %#x, %#x, %#x",
                this, pbc, pmkToLeft, &riid, ppvObj
                ));
                
    VDATEPTROUT(ppvObj, LPVOID);
    VDATEIFACE(pbc);
    PerfDbgLog2(tagCUrlMon, this, "+CUrlMon::BindToStorage (IBindCtx:%lx, pmkToLeft:%lx)", pbc, pmkToLeft);

    if (pmkToLeft)
    {
        VDATEIFACE(pmkToLeft);
    }
    CBSC *pBSC = NULL;
    HRESULT       hr;
    BIND_OPTS     bindopts;
    CBinding      *pCBdg = NULL;
    FORMATETC     fetc;
    WCHAR         wzURL[MAX_URL_SIZE + 1];

    IID iidLocal = riid;

    *ppvObj = NULL;

    #if DBG==1
    {
        LPOLESTR pszStr;
        StringFromCLSID(riid, &pszStr);
        DbgLog2(tagCUrlMon, this, "CUrlMon::BindToStorage (szUrl:%ws)(iid:%ws)",
                GetUrl(), pszStr);
        delete pszStr;
    }
    #endif

    hr = StartBinding(FALSE, pbc, pmkToLeft, riid, ppvObj);

    PerfDbgLog2(tagCUrlMon, this, "-CUrlMon::BindToStorage (hr:%lx, ppvobj:%lx)",
        hr, (hr == S_OK) ? *ppvObj : NULL);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CUrlMon::StartBinding
//
//  Synopsis:   sets up the cbinding and starts the transaction
//
//  Arguments:  [fBindToObject] --
//              [pbc] --
//              [pmkToLeft] --
//              [riid] --
//              [ppvObj] --
//
//  Returns:
//
//  History:    8-20-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CUrlMon::StartBinding(BOOL fBindToObject, IBindCtx *pbc, IMoniker *pmkToLeft, REFIID riid, void **ppvObj)
{
    DEBUG_ENTER((DBG_MONIKER,
                Hresult,
                "CUrlMon::StartBinding",
                "this=%#x, %B, %#x, %#x, %#x, %#x",
                this, fBindToObject, pbc, pmkToLeft, &riid, ppvObj
                ));
                
    PerfDbgLog(tagCUrlMon, this, "+CUrlMon::StartBinding");

    HRESULT     hr = NOERROR;
    WCHAR       wzURL[MAX_URL_SIZE + 1];
    CBSC        *pBSC = NULL;
    CBinding    *pCBdg = NULL;
    BOOL        fUnknown = FALSE;

    do 
    {
        // No need to canonicalize URL here.  This should have already been done
        // by CreateURLMoniker.

        hr = ConstructURL(pbc, NULL, pmkToLeft, GetUrl(), wzURL, sizeof(wzURL),CU_NO_CANONICALIZE);

        if (hr != NOERROR)
        {
            break;
        }

        // moved to CBinding::StartBinding
        // BUG-WORK
        //if (!IsOInetProtocol(pbc, wzURL))
        //{
        //    hr = INET_E_UNKNOWN_PROTOCOL;
        //    break;
        //}

        // check if a BSC is registerted if not register our own one - for Office!
        IUnknown *pUnk = NULL;
        hr = GetObjectParam(pbc, REG_BSCB_HOLDER, IID_IBindStatusCallback, (IUnknown**)&pUnk);
        if ((hr == NOERROR) && pUnk)
        {
            // release - nothing to do
            pUnk->Release();
        }
        else
        {
            hr = NOERROR;
            if (fBindToObject)
            {
                pBSC = new CBSC(Medium_Unknown);
            }
            else
            {
                Medium medium = (riid == IID_IStorage) ? Medium_Storage : Medium_Stream;
                pBSC = new CBSC(medium);
                if (medium == Medium_Storage)
                {
                    fUnknown = TRUE;
                }

            }

            // no IBSC - create our own one and register 
            if (pBSC)
            {
                hr = RegisterBindStatusCallback(pbc, pBSC, 0, 0);
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
            
        }
        
        if (hr != NOERROR)
        {
            break;
        }
        // Create a CBinding object
        hr = CBinding::Create(NULL, wzURL, pbc, (fUnknown) ? IID_IUnknown : riid, fBindToObject, &pCBdg);

        if (hr != NOERROR)
        {
            break;
        }
        
        UrlMkAssert((pCBdg != NULL));

        if (fBindToObject)
        {
            pCBdg->SetMoniker(this);
        }

        {
            LPWSTR pwzExtra = NULL;
            // start the transaction now
            hr = pCBdg->StartBinding(wzURL, pbc, (fUnknown) ? IID_IUnknown : riid, fBindToObject, &pwzExtra, ppvObj);

            if (pwzExtra)
            {
                SetUrl(GetUrl(), pwzExtra);
            }
        }

        if( hr == INET_E_USE_EXTEND_BINDING )
        {
            // rosebud
            hr = NOERROR;

            // there is no need to return IBinding to client, se should
            // free it here.
            pCBdg->Release();
            break;
        }

        if (SUCCEEDED(hr))
        {
            if (pCBdg->IsAsyncTransaction() == FALSE)
            {
                hr = pCBdg->CompleteTransaction();
                if (SUCCEEDED(hr))
                {
                    // retrieve the requested object
                    if (pBSC)
                    {
                        hr = pBSC->GetRequestedObject(pbc, ppvObj);
                    }
                    else
                    {
                        hr = pCBdg->GetRequestedObject(pbc, (IUnknown **)ppvObj);
                    }
                }
            }
            else 
            {
                hr = pCBdg->GetRequestedObject(pbc, (IUnknown **)ppvObj);
            }
        }

        // in case the transaction could not be started,
        // the following release we terminate all releated objects
        pCBdg->Release();
    
        break;
    } while (TRUE);

    if (pBSC)
    {
        RevokeBindStatusCallback(pbc, pBSC);
        pBSC->Release();
    }

    PerfDbgLog1(tagCUrlMon, this, "-CUrlMon::StartBinding (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CUrlMon::Reduce
//
//  Synopsis:
//
//  Arguments:  [pbc] --
//              [dwReduceHowFar] --
//              [IMoniker] --
//              [ppmkReduced] --
//
//  Returns:
//
//  History:    1-19-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CUrlMon::Reduce(IBindCtx *pbc, DWORD dwReduceHowFar,
                            IMoniker **ppmkToLeft,IMoniker **ppmkReduced)
{
    DEBUG_ENTER((DBG_MONIKER,
                Hresult,
                "CUrlMon::IMoniker::Reduce",
                "this=%#x, %#x, %#x, %#x, %#x",
                this, pbc, dwReduceHowFar, ppmkToLeft, ppmkReduced
                ));
                
    PerfDbgLog(tagCUrlMon, this, "+CUrlMon::Reduce");

    // There is nothing we can do to reduce our moniker
    *ppmkReduced = this;
    AddRef();

    PerfDbgLog1(tagCUrlMon, this, "-CUrlMon::Reduce (hr:%lx)", MK_S_REDUCED_TO_SELF);

    DEBUG_LEAVE(MK_S_REDUCED_TO_SELF);
    return MK_S_REDUCED_TO_SELF;
}

//+---------------------------------------------------------------------------
//
//  Method:     CUrlMon::ComposeWith
//
//  Synopsis:
//
//  Arguments:  [pmkRight] --
//              [fOnlyIfNotGeneric] --
//              [ppmkComposite] --
//
//  Returns:
//
//  History:    1-19-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CUrlMon::ComposeWith(IMoniker *pmkRight, BOOL fOnlyIfNotGeneric, IMoniker **ppmkComposite)
{
    DEBUG_ENTER((DBG_MONIKER,
                Hresult,
                "CUrlMon::IMoniker::ComposeWith",
                "this=%#x, %#x, %B, %#x",
                this, pmkRight, fOnlyIfNotGeneric, ppmkComposite
                ));
                
    PerfDbgLog(tagCUrlMon, this, "+CUrlMon::ComposeWith");
    VDATEIFACE(pmkRight);
    VDATEPTROUT(ppmkComposite, LPMONIKER);
    HRESULT hr = NOERROR;
    DWORD   dwMnk = 0;
    LPWSTR  wzURLRelative = NULL;

    *ppmkComposite = NULL;

    pmkRight->IsSystemMoniker(&dwMnk);
    if (dwMnk == MKSYS_URLMONIKER)
    {
        hr = pmkRight->GetDisplayName(NULL, NULL, &wzURLRelative);
        if (hr == NOERROR)
        {
            hr = CreateURLMoniker(this, wzURLRelative, ppmkComposite);
        }
    }
    else if (fOnlyIfNotGeneric)
    {
        hr = MK_E_NEEDGENERIC;
    }
    else
    {
        hr = CreateGenericComposite(this, pmkRight, ppmkComposite);
    }
    if (wzURLRelative)
    {
        delete wzURLRelative;
    }

    PerfDbgLog(tagCUrlMon, this, "-CUrlMon::ComposeWith");

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CUrlMon::Enum
//
//  Synopsis:
//
//  Arguments:  [fForward] --
//              [ppenumMoniker] --
//
//  Returns:
//
//  History:    1-19-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CUrlMon::Enum(BOOL fForward, IEnumMoniker **ppenumMoniker)
{
    DEBUG_ENTER((DBG_MONIKER,
                Hresult,
                "CUrlMon::IMoniker::Enum",
                "this=%#x, %B, %#x",
                this, fForward, ppenumMoniker
                ));
                
    PerfDbgLog(tagCUrlMon, this, "+CUrlMon::Enum");
    VDATEPTROUT(ppenumMoniker, LPENUMMONIKER);
    *ppenumMoniker = NULL;

    PerfDbgLog(tagCUrlMon, this, "-CUrlMon::Enum (hr:0)");

    DEBUG_LEAVE(NOERROR);
    return NOERROR;
}

//+---------------------------------------------------------------------------
//
//  Method:     CUrlMon::IsEqual
//
//  Synopsis:
//
//  Arguments:  [pMnkOther] --
//
//  Returns:
//
//  History:    1-19-96   JohannP (Johann Posch)   Created
//
//  Notes:
//          REVIEW: this code will not work cross process.  What is the
//          correct implementation?
//
//----------------------------------------------------------------------------
STDMETHODIMP CUrlMon::IsEqual(IMoniker *pMnkOther)
{
    DEBUG_ENTER((DBG_MONIKER,
                Hresult,
                "CUrlMon::IMoniker::IsEqual",
                "this=%#x, %#x",
                this, pMnkOther
                ));
                
    PerfDbgLog(tagCUrlMon, this, "+CUrlMon::IsEqual");
    HRESULT hr = S_FALSE;
    VDATEIFACE(pMnkOther);

    // We only worry about URL monikers
    if (this == pMnkOther)
    {
        // same object
        hr = NOERROR;
    }
    else if (IsUrlMoniker(pMnkOther))
    {
        LPWSTR szDispName = NULL;
        // The other moniker is a URL moniker.
        // get and compare the display names
        hr = pMnkOther->GetDisplayName(NULL, NULL, &szDispName);
        // Compare the URL's
        if (hr == NOERROR)
        {
            UrlMkAssert((_pwzUrl));
            UrlMkAssert((szDispName));

            hr = wcscmp(_pwzUrl, szDispName) ? S_FALSE : NOERROR;
        }

        if (szDispName)
        {
            delete szDispName;
        }
    }

    PerfDbgLog1(tagCUrlMon, this, "-CUrlMon::IsEqual (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CUrlMon::Hash
//
//  Synopsis:
//
//  Arguments:  [pdwHash] --
//
//  Returns:
//
//  History:    1-19-96   JohannP (Johann Posch)   Created
//
//              9-02-95   AdriaanC (Adriaan Canter)
//                        Modified to use Pearson's Method
//
//  Notes:
//  32 bit hashing operator for IMoniker::Hash(DWORD*)
//
//  Method based upon "Fast Hashing of Variable Length Text Strings" ,
//  by Peter K. Pearson, Communications of the ACM,
//  June 1990 Vol. 33, Number 6. pp 677-680.
//
//----------------------------------------------------------------------------
STDMETHODIMP CUrlMon::Hash(DWORD* pdwHash)
{
    DEBUG_ENTER((DBG_MONIKER,
                Hresult,
                "CUrlMon::IMoniker::Hash",
                "this=%#x, %#x",
                this, pdwHash
                ));
                
    PerfDbgLog(tagCUrlMon, this, "+CUrlMon::Hash");
    UrlMkAssert((_pwzUrl != NULL));

    HRESULT hr = NOERROR;

    UCHAR c0, c1, c2, c3;
    UCHAR* idx = (UCHAR*) _pwzUrl;

    static UCHAR T[256] =
    {
      1, 14,110, 25, 97,174,132,119,138,170,125,118, 27,233,140, 51,
      87,197,177,107,234,169, 56, 68, 30,  7,173, 73,188, 40, 36, 65,
      49,213,104,190, 57,211,148,223, 48,115, 15,  2, 67,186,210, 28,
      12,181,103, 70, 22, 58, 75, 78,183,167,238,157,124,147,172,144,
      176,161,141, 86, 60, 66,128, 83,156,241, 79, 46,168,198, 41,254,
      178, 85,253,237,250,154,133, 88, 35,206, 95,116,252,192, 54,221,
      102,218,255,240, 82,106,158,201, 61,  3, 89,  9, 42,155,159, 93,
      166, 80, 50, 34,175,195,100, 99, 26,150, 16,145,  4, 33,  8,189,
      121, 64, 77, 72,208,245,130,122,143, 55,105,134, 29,164,185,194,
      193,239,101,242,  5,171,126, 11, 74, 59,137,228,108,191,232,139,
      6, 24, 81, 20,127, 17, 91, 92,251,151,225,207, 21, 98,113,112,
      84,226, 18,214,199,187, 13, 32, 94,220,224,212,247,204,196, 43,
      249,236, 45,244,111,182,153,136,129, 90,217,202, 19,165,231, 71,
      230,142, 96,227, 62,179,246,114,162, 53,160,215,205,180, 47,109,
      44, 38, 31,149,135,  0,216, 52, 63, 23, 37, 69, 39,117,146,184,
      163,200,222,235,248,243,219, 10,152,131,123,229,203, 76,120,209
      };

    c0 = T[*idx];
    c1 = T[*idx+1 % 256];
    c2 = T[*idx+2 % 256];
    c3 = T[*idx+3 % 256];

#ifndef unix
    while ((WCHAR) *(WCHAR*) ++idx != L'\0')
#else
    // We are trying to cast a UCHAR as a WCHAR in the windows code. We will need
    // to handle alignments correctly here, as we cant randomly cast
    // a UCHAR * to a WCHAR *. 
    WCHAR wend = 0;
    while (memcmp(++idx,&wend,sizeof(WCHAR)))
#endif /* unix */
    {
      c0 = T[c0^*idx]; c1 = T[c1^*idx];
      c2 = T[c2^*idx]; c3 = T[c3^*idx];
    }

    *(((UCHAR*) pdwHash)+0) = c0;
    *(((UCHAR*) pdwHash)+1) = c1;
    *(((UCHAR*) pdwHash)+2) = c2;
    *(((UCHAR*) pdwHash)+3) = c3;

    PerfDbgLog1(tagCUrlMon, this, "-CUrlMon::Hash (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CUrlMon::IsRunning
//
//  Synopsis:
//
//  Arguments:  [pbc] --
//              [pmkToLeft] --
//              [pmkNewlyRunning] --
//
//  Returns:
//
//  History:    1-19-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CUrlMon::IsRunning(IBindCtx *pbc, IMoniker *pmkToLeft, IMoniker *pmkNewlyRunning)
{
    DEBUG_ENTER((DBG_MONIKER,
                Hresult,
                "CUrlMon::IMoniker::IsRunning",
                "this=%#x, %#x, %#x, %#x",
                this, pbc, pmkToLeft, pmkNewlyRunning
                ));
                
    PerfDbgLog(tagCUrlMon, this, "+CUrlMon::IsRunning");
    HRESULT hr = NOERROR;
    VDATEIFACE(pbc);

    if (pmkToLeft)
        VDATEIFACE(pmkToLeft);
    if (pmkNewlyRunning)
        VDATEIFACE(pmkNewlyRunning);

    // This implementation was shamelessly stolen from the OLE sources.

    if (pmkToLeft == NULL)
    {
        if (pmkNewlyRunning != NULL)
        {
            hr = pmkNewlyRunning->IsEqual(this);

        }
        else
        {
            hr = IsRunningROT(pbc, NULL, NULL);
        }
    }
    else
    {
        UrlMkAssert((FALSE));
        hr = S_FALSE;
    }

    PerfDbgLog1(tagCUrlMon, this, "-CUrlMon::IsRunning (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CUrlMon::GetTimeOfLastChange
//
//  Synopsis:
//
//  Arguments:  [pbc] --
//              [pmkToLeft] --
//              [pFileTime] --
//
//  Returns:
//
//  History:    1-19-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CUrlMon::GetTimeOfLastChange(IBindCtx *pbc, IMoniker *pmkToLeft, FILETIME *pFileTime)
{
    DEBUG_ENTER((DBG_MONIKER,
                Hresult,
                "CUrlMon::IMoniker::GetTimeOfLastChange",
                "this=%#x, %#x, %#x, %#x",
                this, pbc, pmkToLeft, pFileTime
                ));
                
    PerfDbgLog(tagCUrlMon, this, "+CUrlMon::GetTimeOfLastChange");
    VDATEIFACE(pbc);
    if (pmkToLeft)
    {
        VDATEIFACE(pmkToLeft);
    }
    VDATEPTROUT(pFileTime, FILETIME);

    HRESULT hr = MK_E_UNAVAILABLE;
    IRunningObjectTable *pROT;

    hr = pbc->GetRunningObjectTable(&pROT);

    if (SUCCEEDED(hr))
    {
        hr = pROT->GetTimeOfLastChange(this, pFileTime);
        pROT->Release();
    }
    else
    {
        hr = MK_E_UNAVAILABLE;
    }

    PerfDbgLog1(tagCUrlMon, this, "-CUrlMon::GetTimeOfLastChange (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CUrlMon::Inverse
//
//  Synopsis:
//
//  Arguments:  [ppmk] --
//
//  Returns:
//
//  History:    1-16-96   JohannP (Johann Posch)   Created
//
//  Notes:     urlmon does not have aninverse
//
//----------------------------------------------------------------------------
STDMETHODIMP CUrlMon::Inverse(IMoniker **ppmk)
{
    DEBUG_ENTER((DBG_MONIKER,
                Hresult,
                "CUrlMon::IMoniker::Inverse",
                "this=%#x, %#x",
                this, ppmk
                ));
                
    PerfDbgLog(tagCUrlMon, this, "+CUrlMon::Inverse");
    VDATEPTROUT(ppmk, LPMONIKER);

    PerfDbgLog1(tagCUrlMon, this, "-CUrlMon::Inverse (hr:%lx)", MK_E_NOINVERSE);

    DEBUG_LEAVE(MK_E_NOINVERSE);
    return MK_E_NOINVERSE;
}

//+---------------------------------------------------------------------------
//
//  Method:     CUrlMon::CommonPrefixWith
//
//  Synopsis:
//
//  Arguments:  [pmkOther] --
//              [ppmkPrefix] --
//
//  Returns:
//
//  History:    1-19-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CUrlMon::CommonPrefixWith(IMoniker *pmkOther, IMoniker **ppmkPrefix)
{
    DEBUG_ENTER((DBG_MONIKER,
                Hresult,
                "CUrlMon::IMoniker::CommonPrefixWith",
                "this=%#x, %#x, %#x",
                this, pmkOther, ppmkPrefix
                ));
                
    PerfDbgLog(tagCUrlMon, this, "+CUrlMon::CommonPrefixWith");
    HRESULT hr = E_NOTIMPL;
    VDATEPTROUT(ppmkPrefix, LPMONIKER);
    *ppmkPrefix = NULL;
    VDATEIFACE(pmkOther);

    PerfDbgLog1(tagCUrlMon, this, "-CUrlMon::CommonPrefixWith (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CUrlMon::RelativePathTo
//
//  Synopsis:
//
//  Arguments:  [pmkOther] --
//              [ppmkRelPath] --
//
//  Returns:
//
//  History:    1-16-96   JohannP (Johann Posch)   Created
//              8-20-96   ClarG   (Clarence Glasse) Implemented
//
//  Notes: Code is based on composition algorithm in rfc 1808 (this code does
//         the reverse of that).
//
//----------------------------------------------------------------------------
STDMETHODIMP CUrlMon::RelativePathTo(IMoniker *pmkOther, IMoniker **ppmkRelPath)
{
    DEBUG_ENTER((DBG_MONIKER,
                Hresult,
                "CUrlMon::IMoniker::RelativePathTo",
                "this=%#x, %#x, %#x",
                this, pmkOther, ppmkRelPath
                ));
                
    PerfDbgLog(tagCUrlMon, this, "+CUrlMon::RelativePathTo");
    HRESULT hr = NOERROR;
    VDATEPTROUT(ppmkRelPath, LPMONIKER);
    *ppmkRelPath = NULL;
    VDATEIFACE(pmkOther);

    CUrl *pUrlThis = NULL;
    CUrl *pUrlOther = NULL;
    LPSTR pch = NULL;
    LPSTR pszQueryThis = NULL;
    LPSTR pszQueryOther = NULL;
    LPSTR pszParamsThis = NULL;
    LPSTR pszParamsOther = NULL;

    char szRelPath[MAX_URL_SIZE + 1];

    if (!_pwzUrl)
    {
        hr = MK_E_NOTBINDABLE;
        goto End;
    }

    if (IsEqual(pmkOther) == S_OK)
    {
        // we are equal to pmkOther, so create an empty path URL moniker.
        if ((*ppmkRelPath = CreateEmptyPathUrlMon()) == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto End;
        }
        // CUrlmon has refcount of 1 now
    }
    else if (IsUrlMoniker(pmkOther))
    {
        if ((hr = HrCreateCUrlFromUrlMon(pmkOther, TRUE, &pUrlOther)) != NOERROR)
        {
            if (hr == MK_E_SYNTAX)
                hr = MK_E_NOTBINDABLE;
            goto End;
        }

        if ((hr = HrCreateCUrlFromUrlStr(_pwzUrl, TRUE, &pUrlThis)) != NOERROR)
        {
            if (hr == MK_E_SYNTAX)
                hr = MK_E_NOTBINDABLE;
            goto End;
        }

        // Each URL has been parsed into its separate components.
        // Now compute the relative path.
        if ((pUrlThis->_dwProto == DLD_PROTOCOL_NONE) ||
            (pUrlOther->_dwProto == DLD_PROTOCOL_NONE))
        {
            // Unrecognized protocol; return MK_S_HIM or MK_E_NOTBINDABLE
            if (pUrlThis->_pszProtocol[0] && pUrlOther->_pszProtocol[0])
            {
                *ppmkRelPath = pmkOther;
                pmkOther->AddRef();
                hr = MK_S_HIM;
            }
            else
            {
                hr = MK_E_NOTBINDABLE;
            }
            goto End;
        }

        // if the scheme and net_loc portion of the url are not equal,
        // return MK_S_HIM
        if ((pUrlThis->_dwProto != pUrlOther->_dwProto) ||
            (lstrcmpi(pUrlThis->_pszServerName, pUrlOther->_pszServerName) != 0) ||
            (pUrlThis->_ipPort != pUrlOther->_ipPort) ||
            (lstrcmpi(pUrlThis->_pszUserName, pUrlOther->_pszUserName) != 0) ||
            (lstrcmpi(pUrlThis->_pszPassword, pUrlOther->_pszPassword) != 0))
        {
            *ppmkRelPath = pmkOther;
            pmkOther->AddRef();
            hr = MK_S_HIM;
            goto End;
        }

#ifdef URLMON_RELPATHTO_PARSE_QUERY_PARAMS
        // parse the query and params info
        ParseUrlQuery(pUrlThis->_pszObject, &pszQueryThis);
        ParseUrlQuery(pUrlOther->_pszObject, &pszQueryOther);
        ParseUrlParams(pUrlThis->_pszObject, &pszParamsThis);
        ParseUrlParams(pUrlOther->_pszObject, &pszParamsOther);
#endif // URLMON_RELPATHTO_PARSE_QUERY_PARAMS

        // compute the relative path
        hr = HrGetRelativePath(
                pUrlThis->_pszObject, pUrlOther->_pszObject,
                pUrlThis->_dwProto, pUrlThis->_pszServerName, szRelPath);
        if (FAILED(hr))
            goto End;

#ifdef URLMON_RELPATHTO_PARSE_QUERY_PARAMS
        // append the appropriate query and params info
        AddParamsAndQueryToRelPath(
            szRelPath, pszParamsThis, pszParamsOther, pszQueryThis, pszQueryOther);
#endif // URLMON_RELPATHTO_PARSE_QUERY_PARAMS

        if (szRelPath[0])
        {
            HRESULT hr2 = NOERROR;
            WCHAR wzObjRel[MAX_URL_SIZE + 1];

            A2W(szRelPath, wzObjRel, MAX_URL_SIZE);
            hr2 = CreateURLMoniker(NULL, wzObjRel, ppmkRelPath);
            if (FAILED(hr2))
                hr = hr2;
        }
        else
        {
            *ppmkRelPath = CreateEmptyPathUrlMon();
            if (!(*ppmkRelPath))
                hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        hr = MonikerRelativePathTo(this, pmkOther, ppmkRelPath, TRUE);
    }

End:
    if (pUrlThis)
        delete pUrlThis;
    if (pUrlOther)
        delete pUrlOther;
    PerfDbgLog1(tagCUrlMon, this, "-CUrlMon::RelativePathTo (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CUrlMon::GetDisplayName
//
//  Synopsis:
//
//  Arguments:  [pbc] --
//              [pmkToLeft] --
//              [ppszDisplayName] --
//
//  Returns:
//
//  History:    1-19-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CUrlMon::GetDisplayName(IBindCtx *pbc, IMoniker *pmkToLeft, LPOLESTR *ppszDisplayName)
{
    DEBUG_ENTER((DBG_MONIKER,
                Hresult,
                "CUrlMon::IMoniker::GetDisplayName",
                "this=%#x, %#x, %#x, %#x",
                this, pbc, pmkToLeft, ppszDisplayName
                ));
                
    PerfDbgLog(tagCUrlMon, this, "+CUrlMon::GetDisplayName");
    HRESULT hr = NOERROR;
    VDATEPTROUT(ppszDisplayName, LPSTR);
    *ppszDisplayName = NULL;
    if (pbc)
    {
        VDATEIFACE(pbc);
    }
    if (pmkToLeft)
    {
        VDATEIFACE(pmkToLeft);
    }

    *ppszDisplayName = OLESTRDuplicate(_pwzUrl);

    if (*ppszDisplayName == NULL)
    {
        hr = E_OUTOFMEMORY;
    }

    PerfDbgLog2(tagCUrlMon, this, "-CUrlMon::GetDisplayName (hr:%lx) [%ws]", hr, *ppszDisplayName ? *ppszDisplayName : L"");

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CUrlMon::ParseDisplayName
//
//  Synopsis:
//
//  Arguments:  [IMoniker] --
//              [pmkToLeft] --
//              [ULONG] --
//              [IMoniker] --
//              [ppmkOut] --
//
//  Returns:
//
//  History:    1-19-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CUrlMon::ParseDisplayName(IBindCtx *pbc,IMoniker *pmkToLeft,
                LPOLESTR pozDisplayName,ULONG *pchEaten,IMoniker **ppmkOut)
{
    DEBUG_ENTER((DBG_MONIKER,
                Hresult,
                "CUrlMon::IMoniker::ParseDisplayName",
                "this=%#x, %#x, %#x, %#x, %#x, %#x",
                this, pbc, pmkToLeft, pozDisplayName, pchEaten, ppmkOut
                ));
                
    PerfDbgLog(tagCUrlMon, this, "+CUrlMon::ParseDisplayName");

    HRESULT hr;
    WCHAR wzURL[MAX_URL_SIZE + 1];
    VDATEPTROUT(ppmkOut, LPMONIKER);
    *ppmkOut = NULL;
    VDATEIFACE(pbc);
    if (pmkToLeft) VDATEIFACE(pmkToLeft);
    VDATEPTRIN(pozDisplayName, char);
    VDATEPTROUT(pchEaten, ULONG);

    hr = ConstructURL(pbc, this, pmkToLeft, pozDisplayName, wzURL,
            sizeof(wzURL), CU_CANONICALIZE);

    if (hr != NOERROR)
    {
        goto End;
    }

    if (!wcscmp(_pwzUrl, wzURL))
    {
        // Return ourselves if new URL is the same.

        *ppmkOut = this;
        AddRef();

        hr = NOERROR;
    }
    else
    {
        hr = CreateURLMoniker(NULL, wzURL, ppmkOut);
    }

    if (hr == NOERROR)
    {
        // We have eaten all the characters
        *pchEaten = wcslen(pozDisplayName);
    }

End:

    PerfDbgLog1(tagCUrlMon, this, "-CUrlMon::ParseDisplayName (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CUrlMon::IsSystemMoniker
//
//  Synopsis:
//
//  Arguments:  [pdwMksys] --
//
//  Returns:
//
//  History:    1-19-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CUrlMon::IsSystemMoniker(DWORD *pdwMksys)
{
    DEBUG_ENTER((DBG_MONIKER,
                Hresult,
                "CUrlMon::IMoniker::IsSystemMoniker",
                "this=%#x, %#x",
                this, pdwMksys
                ));
                
    PerfDbgLog(tagCUrlMon, this, "CUrlMon::IsSystemMoniker");
    VDATEPTROUT(pdwMksys, DWORD);
    *pdwMksys = MKSYS_URLMONIKER;

    DEBUG_LEAVE(NOERROR);
    return NOERROR;
}


// Delete the URL string if we have one
void CUrlMon::DeleteUrl()
{
    DEBUG_ENTER((DBG_MONIKER,
                None,
                "CUrlMon::DeleteUrl",
                "this=%#x",
                this
                ));
                
    if (_pwzUrl)
        delete [] _pwzUrl;

    _pwzUrl = NULL;

    DEBUG_LEAVE(0);
}

HRESULT CUrlMon::SetUrl(LPWSTR pwzUrl, LPWSTR pwzExtra)
{
    DEBUG_ENTER((DBG_MONIKER,
                Hresult,
                "CUrlMon::SetUrl",
                "this=%#x, %.80wq, %.80wq",
                this, pwzUrl, pwzExtra
                ));
                
    int clen;
    HRESULT hr = NOERROR;

    TransAssert((pwzUrl));

    clen  = wcslen(pwzUrl) + 1;
    if (pwzExtra)
    {
        clen  += wcslen(pwzExtra);
    }
    LPWSTR pwzStr = (LPWSTR) new WCHAR [clen];
    if (pwzStr)
    {
        wcscpy(pwzStr, pwzUrl);
        if (pwzExtra)
        {
            wcscat(pwzStr, pwzExtra);
        }
        if (_pwzUrl)
        {
            delete [] _pwzUrl;
        }
        _pwzUrl = pwzStr;
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    DEBUG_LEAVE(hr);
    return hr;
}


//    Helper function for IMoniker::IsRunning and BindToObject.
//    Return NOERROR if running, and S_FALSE if not.
//+---------------------------------------------------------------------------
//
//  Method:     CUrlMon::IsRunningROT
//
//  Synopsis:   Checks if the moniker is running
//
//  Arguments:  [pbc] --
//              [pmkToLeft] --
//              [ppROT] --
//
//  Returns:
//
//  History:    1-19-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CUrlMon::IsRunningROT(IBindCtx *pbc, IMoniker *pmkToLeft, IRunningObjectTable **ppROT)
{
    DEBUG_ENTER((DBG_MONIKER,
                Hresult,
                "CUrlMon::IsRunningROT",
                "this=%#x, %#x, %#x, %#x",
                this, pbc, pmkToLeft, ppROT
                ));
                
    HRESULT hr;
    PerfDbgLog(tagCUrlMon, this, "+CUrlMon::IsRunningROT");
    IRunningObjectTable *pROT;

    hr = pbc->GetRunningObjectTable(&pROT);
    if (SUCCEEDED(hr))
    {
        hr = pROT->IsRunning(this);

        if (ppROT != NULL && SUCCEEDED(hr))
        {
            *ppROT = pROT;
        }
        else
        {
            pROT->Release();
        }
    }

    PerfDbgLog1(tagCUrlMon, this, "-CUrlMon::IsRunningROT (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CUrlMon::IsUrlMoniker
//
//  Synopsis:   Checks if pMk is a URL moniker
//
//  Arguments:  [pMk] -- the moniker to be checked
//
//  Returns:    true if moniker is URL moniker
//
//  History:    1-19-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL CUrlMon::IsUrlMoniker(IMoniker *pMk)
{
    DEBUG_ENTER((DBG_MONIKER,
                Bool,
                "CUrlMon::IsUrlMoniker",
                "this=%#x, %#x",
                this, pMk
                ));
                
    PerfDbgLog(tagCUrlMon, this, "+CUrlMon::IsUrlMoniker");
    BOOL fRet = FALSE;

    if (pMk)
    {
        DWORD dwMnk = 0;
        pMk->IsSystemMoniker(&dwMnk);
        fRet = (dwMnk == MKSYS_URLMONIKER);
    }

    PerfDbgLog1(tagCUrlMon, this, "-CUrlMon::IsUrlMoniker (fRet:%d)", fRet);

    DEBUG_LEAVE(fRet);
    return fRet;
}


// ********** Helper Functions **********
// These functions are used by RelativePathTo

//+---------------------------------------------------------------------------
//
//  Function: CreateEmptyPathUrlMon
//
//  Synopsis: Create a UrlMon with empty path "", such that composing it onto
//            a base UrlMon via IMoniker::ComposeWith will yield a moniker
//            equal to the base UrlMon.
//            We don't call CreateUrlMoniker(""), to do this because that will
//            return a UrlMon with path "/".  Composing such a moniker onto
//            a base UrlMon out everything after the host name.
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:   8-16-96   ClarG  (Clarence Glasse)          Created
//
//  Notes:
//
//----------------------------------------------------------------------------
CUrlMon * CreateEmptyPathUrlMon()
{
    DEBUG_ENTER((DBG_MONIKER,
                Pointer,
                "CreateEmptyPathUrlMon",
                NULL
                ));
                
    PerfDbgLog(tagCUrlMon, NULL, "+CreateEmptyPathUrlMon");
    CUrlMon * pUMk = NULL;
    LPWSTR pwzUrlEmpty = NULL;

    // allocate empty string
    if ((pwzUrlEmpty = new WCHAR [1]) == NULL)
    {
        goto End;
    }
    pwzUrlEmpty[0] = 0;

    if ((pUMk = new CUrlMon(pwzUrlEmpty)) == NULL)
    {
        delete pwzUrlEmpty;
        goto End;
    }
    // pUMk has refcount of 1 now

End:
    PerfDbgLog1(tagCUrlMon, NULL, "-CreateEmptyPathUrlMon, pUMk:%lx", pUMk);

    DEBUG_LEAVE(pUMk);
    return pUMk;
}


//+---------------------------------------------------------------------------
//
//  Function: HrCreateCUrlFromUrlMon
//
//  Synopsis: Given a Url moniker pmkUrl, create a CUrl object.  Assumes that
//            pmkUrl is indeed a Url moniker.
//
//  Arguments:  [pmkUrl] -- Url moniker
//              [fParseUrl] -- if TRUE, parse the URL.
//              [ppUrl] -- returns created CUrl obj, which caller must delete
//                         when finished with it.
//
//  Returns: NOERROR is successful.
//
//  History:   8-16-96   ClarG  (Clarence Glasse)          Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT  HrCreateCUrlFromUrlMon(LPMONIKER pmkUrl, BOOL fParseUrl, CUrl **ppUrl)
{
    DEBUG_ENTER((DBG_MONIKER,
                Hresult,
                "HrCreateCUrlFromUrlMon",
                "%#x, %B, %#x",
                pmkUrl, fParseUrl, ppUrl
                ));
                
    PerfDbgLog(tagCUrlMon, NULL, "+HrCreateCUrlFromUrlMon");
    UrlMkAssert((pmkUrl));
    UrlMkAssert((ppUrl));
    HRESULT hr = NOERROR;
    LPBC pbc = NULL;
    LPWSTR pwzUrl = NULL;

    if ((*ppUrl = new CUrl) == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto End;
    }

    if( !(*ppUrl)->CUrlInitAll() )
    {
        hr = E_OUTOFMEMORY;
        goto End;
    }

    if ((hr = CreateBindCtx(0, &pbc)) != NOERROR)
    {
        goto End;
    }

    if ((hr = pmkUrl->GetDisplayName(pbc, NULL, &pwzUrl)) != NOERROR)
    {
        goto End;
    }


    W2A(pwzUrl, (*ppUrl)->_pszBaseURL, MAX_URL_SIZE);

    if (fParseUrl)
    {
        if (!(*ppUrl)->ParseUrl())
        {
            hr = MK_E_SYNTAX;
            goto End;
        }
    }

End:
    if (pbc)
        pbc->Release();
    if (pwzUrl)
        CoTaskMemFree(pwzUrl);

    if ((hr != NOERROR) && (*ppUrl != NULL))
    {
        delete *ppUrl;
        *ppUrl = NULL;
    }

    PerfDbgLog1(tagCUrlMon, NULL, "-HrCreateCUrlFromUrlMon (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function: HrCreateCUrlFromUrlStr
//
//  Synopsis: Given a Url string pwzUrl, create a CUrl object.
//
//  Arguments:  [pwzUrl] -- Url string
//              [fParseUrl] -- if TRUE, parse the URL.
//              [ppUrl] -- returns created CUrl obj, which caller must delete
//                         when finished with it.
//
//  Returns: NOERROR is successful.
//
//  History:   8-16-96   ClarG  (Clarence Glasse)          Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT  HrCreateCUrlFromUrlStr(LPCWSTR pwzUrl, BOOL fParseUrl, CUrl **ppUrl)
{
    DEBUG_ENTER((DBG_MONIKER,
                Hresult,
                "HrCreateCUrlFromUrlStr",
                "%.80wq, %B, %#x",
                pwzUrl, fParseUrl, ppUrl
                ));
                
    PerfDbgLog(tagCUrlMon, NULL, "+HrCreateCUrlFromUrlStr");
    UrlMkAssert((pwzUrl));
    UrlMkAssert((ppUrl));
    HRESULT hr = NOERROR;

    if ((*ppUrl = new CUrl) == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto End;
    }

    if( !(*ppUrl)->CUrlInitAll() )
    {
        hr = E_OUTOFMEMORY;
        goto End;
    }

    W2A(pwzUrl, (*ppUrl)->_pszBaseURL, MAX_URL_SIZE);

    if (fParseUrl)
    {
        if (!(*ppUrl)->ParseUrl())
        {
            hr = MK_E_SYNTAX;
            goto End;
        }
    }

End:
    if ((hr != NOERROR) && (*ppUrl != NULL))
    {
        delete *ppUrl;
        *ppUrl = NULL;
    }

    PerfDbgLog1(tagCUrlMon, NULL, "-HrCreateCUrlFromUrlStr (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function: IsSeparator
//
//  Synopsis: Return TRUE if ch is a file path or url path separator char.
//
//  Arguments:  [ch] -- the char in question
//                         when finished with it.
//
//  Returns: TRUE if ch is a separator char
//
//  History:   8-20-96   ClarG  (Clarence Glasse)          Created
//
//  Notes: This is taken from OLE2 file moniker code
//
//----------------------------------------------------------------------------
inline BOOL IsSeparator( char ch )
{
    DEBUG_ENTER((DBG_MONIKER,
                Bool,
                "IsSeparator",
                "%c",
                ch
                ));
                
    BOOL fRet = (ch == '\\' || ch == '/' || ch == ':');

    DEBUG_LEAVE(fRet);
    return fRet;
}


//+---------------------------------------------------------------------------
//
//  Function: CountSegments
//
//  Synopsis: Return the number of segments in file or url path pch.
//
//  Arguments:  [pch] -- the string in question.
//
//  Returns: number of segments in pch
//
//  History:   8-20-96   ClarG  (Claren