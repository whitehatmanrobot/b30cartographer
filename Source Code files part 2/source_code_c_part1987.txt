Id = Guid.NewGuid();
                string familyName = null;
                int serviceType = 1;
                int subscriptionType = 1;
                int tierId = 6;
                int servicePrivilegeSet = 102;

                SubscriptionFamilyInfo sf1 = SubscriptionFamilyHelper.CreateSubscriptionFamily(client, familyId, familyName, serviceType, subscriptionType, tierId, null, servicePrivilegeSet);
            }

        }

        [TestCase, Description("Verfiy passing invalid servicePrivilegeSet")]
        class N_SubscriptionFamilyConfigure_InvalidServicePrivilegeSet : WCFTestBase
        {
            public override void Run()
            {
                SubscriptionFamilyWCFClient client = new SubscriptionFamilyWCFClient();
                client.ExpectedHR = HResult.XONLINE_E_MIX_INVALID_SERVICE_PRIVILEGE_SET;

                Guid familyId = Guid.NewGuid();
                string familyName = "test";
                int serviceType = 1;
                int subscriptionType = 1;
                int tierId = 6;
                int servicePrivilegeSet = InvalidServicePrivilegeSet;

                SubscriptionFamilyInfo sf1 = SubscriptionFamilyHelper.CreateSubscriptionFamily(client, familyId, familyName, serviceType, subscriptionType, tierId, null, servicePrivilegeSet);
            }
        }

        [TestCase, Description("Verfiy passing 0 as tierId")]
        class P_SubscriptionFamilyConfigure_InvalidTierId_0 : WCFTestBase
        {
            public override void Run()
            {
                SubscriptionFamilyWCFClient client = new SubscriptionFamilyWCFClient();
                client.ExpectedHR = HResult.S_OK;

                Guid familyId = Guid.NewGuid();
                string familyName = "test";
                int serviceType = 1;
                int subscriptionType = 1;
                int tierId = 0;
                int servicePrivilegeSet = 102;

                SubscriptionFamilyInfo sf1 = SubscriptionFamilyHelper.CreateSubscriptionFamily(client, familyId, familyName, serviceType, subscriptionType, tierId, null, servicePrivilegeSet);
            }
        }

        [TestCase, Description("Verfiy pasisng none 0 invalid tierId")]
        class N_SubscriptionFamilyConfigure_InvalidTierId_NoneZero : WCFTestBase
        {
            public override void Run()
            {
                SubscriptionFamilyWCFClient client = new SubscriptionFamilyWCFClient();
                client.ExpectedHR = HResult.XONLINE_E_MIX_INVALID_TIER;

                Guid familyId = Guid.NewGuid();
                string familyName = "test";
                int serviceType = 1;
                int subscriptionType = 1;
                int tierId = 999;
                int servicePrivilegeSet = 102;

                SubscriptionFamilyInfo sf1 = SubscriptionFamilyHelper.CreateSubscriptionFamily(client, familyId, familyName, serviceType, subscriptionType, tierId, null, servicePrivilegeSet);
            }
        }

        [TestCase, Description("Verfiy passing invalid subscriptionType")]
        class N_SubscriptionFamilyConfigure_InvalidSubscriptionType : WCFTestBase
        {
            public override void Run()
            {
                SubscriptionFamilyWCFClient client = new SubscriptionFamilyWCFClient();
                client.ExpectedHR = HResult.XONLINE_E_MIX_INVALID_SUBSCRIPTION_TYPE;

                Guid familyId = Guid.NewGuid();
                string familyName = "test";
                int serviceType = 1;
                int subscriptionType = InvalidSubscriptionType;
                int tierId = 3;
                int servicePrivilegeSet = 102;

                SubscriptionFamilyInfo sf1 = SubscriptionFamilyHelper.CreateSubscriptionFamily(client, familyId, familyName, serviceType, subscriptionType, tierId, null, servicePrivilegeSet);
            }
        }

        public class SubscriptionFamilyHelper
        {

            public static SubscriptionFamilyInfo CreateSubscriptionFamily(SubscriptionFamilyWCFClient client,
                       Guid familyId, string familyName, int serviceType, int subscriptionType, int tierId, int[] titleIds, System.Nullable<int> servicePrivilegeSet)
            {
                SubscriptionFamilyInfo sf = new SubscriptionFamilyInfo();
                sf.FamilyId = familyId;
                sf.FamilyName = familyName;
                sf.ServiceType = serviceType;
                sf.SubscriptionType = subscriptionType;
                sf.TierId = tierId;
                sf.TitleIds = titleIds;
                sf.ServicePrivilegeSet = servicePrivilegeSet;

                client.SubscriptionFamilyConfigure(familyId, familyName, serviceType, subscriptionType, tierId, titleIds, servicePrivilegeSet);
                return sf;
            }

            public static bool Compare(SubscriptionFamilyInfo sf1, SubscriptionFamilyInfo sf2)
            {

                ValueCheck.Test("familyId", sf1.FamilyId, sf2.FamilyId);
                ValueCheck.Test("familyName", sf1.FamilyName, sf2.FamilyName);
                ValueCheck.Test("serviceType", sf1.ServiceType, sf2.ServiceType);
                ValueCheck.Test("subscriptionType", sf1.SubscriptionType, sf2.SubscriptionType);
                ValueCheck.Test("tierId", sf1.TierId, sf2.TierId);
                ValueCheck.Test("servicePrivilegeSet", sf1.ServicePrivilegeSet, sf2.ServicePrivilegeSet);
                if (sf1.TitleIds == null)
                {
                    if (sf2.TitleIds.Length == 0)
                    {
                        return true;
                    }
                }
                else
                {
                    ValueCheck.Test("titleIds Length", sf1.TitleIds.Length, sf2.TitleIds.Length);

                    for (int i = 0; i < sf1.TitleIds.Length; i++)
                    {
                        bool found = false;
                        for (int j = 0; j < sf1.TitleIds.Length; j++)
                        {
                            if (sf1.TitleIds[i] == sf1.TitleIds[j])
                            {
                                found = true;
                                break;
                            }
                        }
                        if (!found) throw new Exception(sf1.TitleIds[i].ToString("X") + " not match!");
                    }
                }
                return true;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Test\SubscriptionFamilyServiceTest\TestSuite.cs ===
using System;
using System.Xml;

using ServerTestFramework;

namespace SubscriptionFamilyServiceTest
{
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Test\SubscriptionFamilyServiceTest\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Test\SubscriptionFamilyServiceTest\stresstestcase.cs ===
ï»¿using System;
using System.Collections;
using System.Collections.Generic;
using System.ServiceModel;
using System.Text;
using System.Net;


using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService;

using xonline.common.config;
using xonline.mix.common;
using xonline.mix.subscriptionfamily.contracts.v1;
using MIXTesting;

namespace MixTest
{
    [StressTest]
    public class SubscriptionFamilyServiceStress : TestNode
    {


        [StressTest(TargetTPS = 1f, Priority = 2)]      
        public class ServiceTypeEnumerate_Stress : TestNode
        {

            public override void Run()
            {
                SubscriptionFamilyWCFClient client = new SubscriptionFamilyWCFClient();
                NameValue[] sets = client.ServiceTypeEnumerate();

            }
        }


        [StressTest(TargetTPS = 1f, Priority = 2)]    
        public class SubscriptionTypeEnumerate_Stress : TestNode
        {

            public override void Run()
            {
                SubscriptionFamilyWCFClient client = new SubscriptionFamilyWCFClient();
                NameValue[] sets = client.SubscriptionTypeEnumerate();


            }
        }

        [StressTest(TargetTPS = 1f, Priority = 2)]   
        public class ServicePrivilegeSetEnumerate_Stress : TestNode
        {

            public override void Run()
            {
                SubscriptionFamilyWCFClient client = new SubscriptionFamilyWCFClient();
                NameValue[] retSets = client.ServicePrivilegeSetEnumerate();
            }
        }




        [StressTest(TargetTPS = 1f, Priority = 2)]    
        class SubscriptionFamily_stress : TestNode
        {
            public override void Run()
            {
                SubscriptionFamilyWCFClient client = new SubscriptionFamilyWCFClient();

                SubscriptionFamilyInfo sf1 = new SubscriptionFamilyInfo();
                sf1.FamilyId = Guid.NewGuid();
                sf1.FamilyName = "stressfamilyName";
                sf1.ServiceType = 1;
                sf1.SubscriptionType = 1;
                sf1.TierId = 6;
               
                sf1.ServicePrivilegeSet = (System.Nullable<int>)101;
                uint title = 0xfffe07d1;
                int[] titleIds = new int[] { (int)title };
                sf1.TitleIds = titleIds;

                client.SubscriptionFamilyConfigure(sf1.FamilyId, sf1.FamilyName, sf1.ServiceType, sf1.SubscriptionType,
                                                   sf1.TierId, sf1.TitleIds, sf1.ServicePrivilegeSet);


                SubscriptionFamilyInfo sf2 = client.SubscriptionFamilyGet(sf1.FamilyId);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Test\SubscriptionFamilyServiceTest\SubscriptionTypeEnumerateV1.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.ServiceModel;
using System.Text;
using System.Net;


using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService;

using xonline.common.config;
using xonline.mix.common;
using xonline.mix.subscriptionfamily.contracts.v1;

using MIXTesting;

namespace MixTest
{
    public class SubscriptionTypes : NameValueList
    {
        public static NameValue[] List;

        public SubscriptionTypes()
        {
            Add("Base", 1);
            Add("Content", 2);
            Add("Game", 3);
        }
    }

    [TestGroup, Owner("LukeL"), TestCasePriority(1), TestFrequency("Regression"), Description("Mix ServicePrivilege Tests")]
    public class SubscriptionTypeEnumerateV1: TestNode
    {
        static protected SubscriptionTypes subscrptionTypes;

        public override void OneTimeSetup()
        {
            subscrptionTypes = new SubscriptionTypes();
        }

        [TestCase, Description("Verify Subscription Type returned")]
        class P_SubscriptionTypeEnumerate : WCFTestBase
        {
            public override void Run()
            {
                SubscriptionFamilyWCFClient client = new SubscriptionFamilyWCFClient();
                NameValue[] sets = client.SubscriptionTypeEnumerate();

                subscrptionTypes.Compare(sets);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Test\TitleManagementTest\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Test\TitleManagementTest\TestSuite.cs ===
using System;
using System.Xml;
using ServerTestFramework;
using MIXTesting;
using MIXTestingUtilsV2;

[assembly: RootNode(typeof(MixTest.TitleManagementSuite))]

namespace MixTest
{
    //Entry point of the tests. 
    [ReloadOnEnvironmentChange]
    public class TitleManagementSuite : TestNode
    {
        //Read configure file and do initialization.
        public override void PreRun()
        {
            Versions.Initialize();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Test\TitleManagementTest\SetTitleUpdatePackages.cs ===
using System.Collections.Generic;

using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.Utilities;
using ServerTestFramework.Database;

using MIXTesting;
using xonline.common.config;
using xonline.mix.titlemanagement.contracts.V2;
using MIXTestingUtilsV2;

namespace MixTest
{
    [TestGroup, Owner("ESebeni"), Description("Tests for the SetTitleUpdatePackages API")]
    public class SetTitleUpdatePackagesTests : TestNode
    {
        public override void OneTimeSetup()
        {
            base.OneTimeSetup();

            MIXTesting.Config.EnableAPIs(Interface.mixtitlemanagement, "Xonline.Mix.TitleManagement.Service", "MixTitleManagement.SetTitleUpdatePackages", "MixTitleManagement.ConfigureTitle", "MixTitleManagement.AddBaseVersion");
        }

        [TestCase, Description(""), TestCasePriority(1)]
        class Basic : MixTitleV2TestBase
        {
            public override void Run()
            {
                TitleUpdateUtils.PerformTest(TitleUpdateTests.Basic, titleClient);
            }
        }

        [TestCase, Description(""), TestCasePriority(2)]
        class ZeroTitleID : MixTitleV2TestBase
        {
            public override void Run()
            {
                TitleUpdateUtils.PerformTest(TitleUpdateTests.ZeroTitleID, titleClient);
            }
        }

        [TestCase, Description(""), TestCasePriority(2)]
        class UnproppedTitleID : MixTitleV2TestBase
        {
            public override void Run()
            {
                TitleUpdateUtils.PerformTest(TitleUpdateTests.UnproppedTitleID, titleClient);
            }
        }

        [TestCase, Description(""), TestCasePriority(3)]
        class ZeroUpgradeVersion : MixTitleV2TestBase
        {
            public override void Run()
            {
                TitleUpdateUtils.PerformTest(TitleUpdateTests.ZeroUpgradeVersion, titleClient);
            }
        }

        [TestCase, Description(""), TestCasePriority(3)]
        class UpgradedBelowBase : MixTitleV2TestBase
        {
            public override void Run()
            {
                TitleUpdateUtils.PerformTest(TitleUpdateTests.UpgradedBelowBase, titleClient);
            }
        }

        [TestCase, Description(""), TestCasePriority(3)]
        class NullPackage : MixTitleV2TestBase
        {
            public override void Run()
            {
                TitleUpdateUtils.PerformTest(TitleUpdateTests.NullPackage, titleClient);
            }
        }

        [TestCase, Description(""), TestCasePriority(3)]
        class NullSymKey : MixTitleV2TestBase
        {
            public override void Run()
            {
                TitleUpdateUtils.PerformTest(TitleUpdateTests.NullSymKey, titleClient);
            }
        }

        [TestCase, Description(""), TestCasePriority(3)]
        class ZeroLengthSymKey : MixTitleV2TestBase
        {
            public override void Run()
            {
                TitleUpdateUtils.PerformTest(TitleUpdateTests.ZeroLengthSymKey, titleClient);
            }
        }

        [TestCase, Description(""), TestCasePriority(3)]
        class NullPubKey : MixTitleV2TestBase
        {
            public override void Run()
            {
                TitleUpdateUtils.PerformTest(TitleUpdateTests.NullPubKey, titleClient);
            }
        }

        [TestCase, Description(""), TestCasePriority(3)]
        class ZeroLengthPubKey : MixTitleV2TestBase
        {
            public override void Run()
            {
                TitleUpdateUtils.PerformTest(TitleUpdateTests.ZeroLengthPubKey, titleClient);
            }
        }

        [TestCase, Description(""), TestCasePriority(3)]
        class ZeroInstallSize : MixTitleV2TestBase
        {
            public override void Run()
            {
                TitleUpdateUtils.PerformTest(TitleUpdateTests.ZeroInstallSize, titleClient);
            }
        }

        [TestCase, Description(""), TestCasePriority(2)]
        class ZeroPackageSize : MixTitleV2TestBase
        {
            public override void Run()
            {
                TitleUpdateUtils.PerformTest(TitleUpdateTests.ZeroPackageSize, titleClient);
            }
        }

        [TestCase, Description(""), TestCasePriority(2)]
        class NullContentID : MixTitleV2TestBase
        {
            public override void Run()
            {
                TitleUpdateUtils.PerformTest(TitleUpdateTests.NullContentID, titleClient);
            }
        }

        [TestCase, Description(""), TestCasePriority(3)]
        class ZeroLengthContentID : MixTitleV2TestBase
        {
            public override void Run()
            {
                TitleUpdateUtils.PerformTest(TitleUpdateTests.ZeroLengthContentID, titleClient);
            }
        }

        [TestCase, Description(""), TestCasePriority(2)]
        class NullLocations : MixTitleV2TestBase
        {
            public override void Run()
            {
                TitleUpdateUtils.PerformTest(TitleUpdateTests.NullLocations, titleClient);
            }
        }

        [TestCase, Description(""), TestCasePriority(3)]
        class ZeroLengthLocations : MixTitleV2TestBase
        {
            public override void Run()
            {
                TitleUpdateUtils.PerformTest(TitleUpdateTests.ZeroLengthLocations, titleClient);
            }
        }

        [TestCase, Description(""), TestCasePriority(1)]
        class DuplicateRank : MixTitleV2TestBase
        {
            public override void Run()
            {
                TitleUpdateUtils.PerformTest(TitleUpdateTests.DuplicateRank, titleClient);
            }
        }

        [TestCase, Description(""), TestCasePriority(2)]
        class NullXRL : MixTitleV2TestBase
        {
            public override void Run()
            {
                TitleUpdateUtils.PerformTest(TitleUpdateTests.NullXRL, titleClient);
            }
        }

        [TestCase, Description(""), TestCasePriority(3)]
        class EmptyXRL : MixTitleV2TestBase
        {
            public override void Run()
            {
                TitleUpdateUtils.PerformTest(TitleUpdateTests.EmptyXRL, titleClient);
            }
        }

        [TestCase, Description(""), TestCasePriority(3)]
        class NullLocation : MixTitleV2TestBase
        {
            public override void Run()
            {
                TitleUpdateUtils.PerformTest(TitleUpdateTests.NullLocation, titleClient);
            }
        }

        [TestCase, Description(""), TestCasePriority(2)]
        class DupeLocation : MixTitleV2TestBase
        {
            public override void Run()
            {
                TitleUpdateUtils.PerformTest(TitleUpdateTests.DupeLocation, titleClient);
            }
        }

        [TestCase, Description(""), TestCasePriority(2)]
        class MobileZeroPackages : MixTitleV2TestBase
        {
            public override void Run()
            {
                TitleUpdateUtils.PerformTest(TitleUpdateTests.MobileZeroPackages, titleClient);
            }
        }

        [TestCase, Description(""), TestCasePriority(2)]
        class MobileNullPackages : MixTitleV2TestBase
        {
            public override void Run()
            {
                TitleUpdateUtils.PerformTest(TitleUpdateTests.MobileNullPackages, titleClient);
            }
        }

        [TestCase, Description("Props multiple system update package locations to simulate many upgrades"), TestCasePriority(3)]
        class MultiPackage : MixTitleV2TestBase
        {
            public override void Run()
            {
                TitleUpdateTestInfo tInfo = TitleUpdateUtils.BuildTitleUpdateTest(TitleUpdateTests.Basic);

                TitleUpdateUtils.PerformTest(tInfo, titleClient, false);

                try
                {
                    tInfo.BaseVersion = tInfo.BaseVersion + 0x100;
                    tInfo.UpdateVersion = tInfo.UpdateVersion + 0x100;

                    TitleUpdateUtils.PerformTest(tInfo, titleClient, false);

                    tInfo.BaseVersion = tInfo.BaseVersion + 0x100;
                    tInfo.UpdateVersion = tInfo.UpdateVersion + 0x100;

                    TitleUpdateUtils.PerformTest(tInfo, titleClient, false);


                    tInfo.BaseVersion = tInfo.BaseVersion + 0x100;
                    tInfo.UpdateVersion = tInfo.UpdateVersion + 0x100;

                    TitleUpdateUtils.PerformTest(tInfo, titleClient, false);


                    tInfo.BaseVersion = tInfo.BaseVersion + 0x100;
                    tInfo.UpdateVersion = tInfo.UpdateVersion + 0x100;

                    TitleUpdateUtils.PerformTest(tInfo, titleClient, false);


                    tInfo.BaseVersion = tInfo.BaseVersion + 0x100;
                    tInfo.UpdateVersion = tInfo.UpdateVersion + 0x100;

                    TitleUpdateUtils.PerformTest(tInfo, titleClient, false);


                    tInfo.BaseVersion = tInfo.BaseVersion + 0x100;
                    tInfo.UpdateVersion = tInfo.UpdateVersion + 0x100;

                    TitleUpdateUtils.PerformTest(tInfo, titleClient, false);
                }
                finally
                {
                    titleClient.Cleanup(tInfo.TitleID);
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Test\TitleManagementTest\SetTitleFacebookAppIdTest.cs ===
using System.Collections.Generic;
using System;
using System.Data;
using System.Data.SqlClient;
using System.Data.Linq;
using System.Linq;

using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.Utilities;
using ServerTestFramework.Database;

using MIXTesting;
using xonline.common.config;
using xonline.mix.titlemanagement.contracts.V2;
using MIXTestingUtilsV2;
using Microsoft.Xbox.SocialConnect.DataAccess;

namespace MixTest
{
    [TestGroup, Owner("ESebeni"), Description("Tests for the SetTitleUpdatePackages API")]
    public class SetTitleFacebookAppIdTests : TestNode
    {
        public override void OneTimeSetup()
        {
            base.OneTimeSetup();

            MIXTesting.Config.EnableAPIs(Interface.mixtitlemanagement, "Xonline.Mix.TitleManagement.Service", "MixTitleManagement.SetTitleFacebookAppId", "MixTitleManagement.ConfigureTitle", "MixTitleManagement.AddBaseVersion");
        }

        uint TEST_TITLE_ID=0xFFEFD00B;

        [TestCase, Owner("savasg"), TestCasePriority(1), Description("Temporary simple unit test, to be deleted when real tests are written.")]
        public void ValidCallTest()
        {
            TitleManagementV2WCFClient client = new TitleManagementV2WCFClient();

            client.SetTitleFacebookAppId(TEST_TITLE_ID, "123123123", HResult.S_OK);
        }

        [TestCase, Owner("savasg"), TestCasePriority(1), Description("Test Invalid App ID")]
        public void InvalidTitleIdTest()
        {
            TitleManagementV2WCFClient client = new TitleManagementV2WCFClient();

            client.SetTitleFacebookAppId(0, "a123123123", HResult.XONLINE_E_MIX_INVALID_TITLE_ID);
        }


        [TestCase, Owner("savasg"), TestCasePriority(1), Description("Test Invalid App ID")]
        public void InvalidAppIdTest()
        {
            TitleManagementV2WCFClient client = new TitleManagementV2WCFClient();

            client.SetTitleFacebookAppId(TEST_TITLE_ID, "a123123123", HResult.XONLINE_E_MIX_INVALID_CONFIG);
        }

        [TestCase, Owner("savasg"), TestCasePriority(1), Description("Empty app Id test.")]
        public void EmptyAppIdTest()
        {
            TitleManagementV2WCFClient client = new TitleManagementV2WCFClient();

            client.SetTitleFacebookAppId(TEST_TITLE_ID, string.Empty, HResult.XONLINE_E_MIX_ARGUMENT_NULL); 
        }

        [TestCase, Owner("savasg"), TestCasePriority(1), Description("Too long app Id test.")]
        public void TooLongAppIdTest()
        {
            TitleManagementV2WCFClient client = new TitleManagementV2WCFClient();

            client.SetTitleFacebookAppId(TEST_TITLE_ID, "012345678901234567890123456789123", HResult.XONLINE_E_MIX_STRING_TOO_LONG);
        }

        [TestCase, Owner("savasg"), TestCasePriority(1), Description("Long but valid app Id test.")]
        public void LongAppIdTest()
        {
            TitleManagementV2WCFClient client = new TitleManagementV2WCFClient();

            client.SetTitleFacebookAppId(TEST_TITLE_ID, "01234567890123456789012345678912", HResult.S_OK);

            ValidateTitleFbApp(TEST_TITLE_ID, "01234567890123456789012345678912");
        }

        [TestCase, Owner("savasg"), TestCasePriority(1), Description("Short but valid app Id test.")]
        public void ShortAppIdTest()
        {
            TitleManagementV2WCFClient client = new TitleManagementV2WCFClient();

            client.SetTitleFacebookAppId(TEST_TITLE_ID, "0", HResult.S_OK);

            ValidateTitleFbApp(TEST_TITLE_ID, "0");
        }

        private static string GetConnectionStringForLiveConnect()
        {
            SqlConnectionStringBuilder sqlConnBldr = new SqlConnectionStringBuilder();
            sqlConnBldr.ConnectionString = "Data Source=blah;Initial Catalog=LiveConnect;Integrated Security=True"; // use this as a template, and change the server

            string connectionString = xonline.common.config.Config.GetSetting(Setting.mix_titlemgmt_liveconnectdbhost);

            if (!string.IsNullOrEmpty(connectionString))
            {
                sqlConnBldr["Data Source"] = connectionString;
            }

            return sqlConnBldr.ConnectionString;
        }

        private static void ValidateTitleFbApp(uint titleId, string appId)
        {
            string connectionString = GetConnectionStringForLiveConnect();
            LiveConnectDataAccessDataContext lcDataCtx = new LiveConnectDataAccessDataContext(connectionString);
            lcDataCtx.ObjectTrackingEnabled = false;

            int? spTitleId = (int)titleId;
            ISingleResult<spGetTitleMapResult> result = lcDataCtx.spGetTitleMap(spTitleId);

            if (result != null)
            {
                spGetTitleMapResult res = result.FirstOrDefault();
                if (res != null && !string.IsNullOrEmpty(res.vc_fbApp_id))
                {
                    if (string.Compare(res.vc_fbApp_id, appId, false) == 0)
                    {
                        return;
                    }
                }
            }

            throw new InvalidOperationException("Test Has Failed.");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Test\TitleManagementTest\NetworkSecurityList.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Net;
using System.Text;
using MixTest.SettingsManagement;
using MIXTesting;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using xonline.common.config;
using xonline.common.service;
using xonline.mix.titlemanagement.contracts.V3;

namespace MixTest.TitleManagement
{
    [TestGroup, Owner("BenRan"), Description("Tests for the SetNetworkSecurityList API")]
    public class SetNetworkSecurityList : TestNode
    {
        public override void PreRun()
        {
            MIXTesting.Config.EnableAPIs(Interface.mixtitlemanagement, "Xonline.Mix.TitleManagement.Service", "MixTitleManagement.SetBusinessPartnerTitleIDs");
            MIXTesting.Config.EnableAPIs(Interface.mixtitlemanagement, "Xonline.Mix.TitleManagement.Service", "MixTitleManagement.GetBusinessPartnerTitleIDs");
            MIXTesting.Config.EnableAPIs(Interface.mixtitlemanagement, "Xonline.Mix.TitleManagement.Service", "MixTitleManagement.SetNetworkSecurityList");
            MIXTesting.Config.EnableAPIs(Interface.mixtitlemanagement, "Xonline.Mix.TitleManagement.Service", "MixTitleManagement.GetNetworkSecurityList");

            MixSettingsHelperV3.Initialize();
        }

        [TestCase, TestCasePriority(1), Description("Ensures that SetNetworkSecurityList succeeds with valid input")]
        public class SetNetworkSecurityList_BVT : TestNode
        {
            TitleManagementHelperV3 helper;

            public override void PreRun()
            {
                helper = new TitleManagementHelperV3();
                helper.Initialize();
            }

            public override void Run()
            {
                helper.GenerateNetworkSecurityList(1);
            }

            public override void PostRun()
            {
                helper.Cleanup();
            }
        }

        [TestCase, TestCasePriority(1), Description("Ensures that GetNetworkSecurityList return the expected endpoints")]
        public class GetNetworkSecurityList_BVT : TestNode
        {
            TitleManagementHelperV3 helper;

            public override void PreRun()
            {
                helper = new TitleManagementHelperV3();
                helper.Initialize();
            }

            public override void Run()
            {
                // Generate a random network security list for the default title
                helper.GenerateNetworkSecurityList();

                TitleEndpointInfo[] endpoints = helper.GetNetworkSecurityList();
                helper.VerifyEndpoints(endpoints);
            }

            public override void PostRun()
            {
                helper.Cleanup();
            }
        }

        [TestCase, TestCasePriority(1), Description("Ensures that GetNetworkSecurityList return an empty list for a new title")]
        public class GetNetworkSecurityList_Empty : TestNode
        {
            TitleManagementHelperV3 helper;

            public override void PreRun()
            {
                helper = new TitleManagementHelperV3();
                helper.Initialize();
            }

            public override void Run()
            {
                Global.RO.Info("Getting empty Network Security List...");
                TitleEndpointInfo[] endpoints = helper.GetNetworkSecurityList();

                ValueCheck.Test("EndpointCount", 0, endpoints.Length);
                Global.RO.Success("Got empty list as expected!");
            }

            public override void PostRun()
            {
                helper.Cleanup();
            }
        }

        [TestCase, TestCasePriority(1), Description("Ensures that Get/SetNetworkSecurityList behaves correctly with various list sizes")]
        [CompoundCase("OneEndpoint(s)", 1)]
        [CompoundCase("TenEndpoint(s)", 10)]
        [CompoundCase("50Endpoint(s)", 50)]
        [CompoundCase("100Endpoint(s)", 100)]
        [CompoundCase("200Endpoint(s)", 200)]
        public class SetThenGetNacl : TestNode
        {
            TitleManagementHelperV3 helper;

            public override void PreRun()
            {
                helper = new TitleManagementHelperV3();
                helper.Initialize();
            }

            public override void Run()
            {
                Int32 endpointCount = (Int32)MyValues[0];

                Global.RO.Info("Generating network security list with {0} entry(s)...", endpointCount);
                helper.GenerateNetworkSecurityList(endpointCount);

                Global.RO.Info("Getting network security list...");
                TitleEndpointInfo[] endpoints = helper.GetNetworkSecurityList();

                helper.VerifyEndpoints(endpoints);

                Global.RO.Success("Validated Network Security List");
            }

            public override void PostRun()
            {
                helper.Cleanup();
            }
        }

        [TestCase, TestCasePriority(1), Description("Ensures that Get/SetNetworkSecurityList behaves correctly with various ips and ranges")]
        public class VariousIPAddresses : TestNode
        {
            TitleManagementHelperV3 helper;

            public override void PreRun()
            {
                helper = new TitleManagementHelperV3();
                helper.Initialize();
            }

            public override void Run()
            {
                Byte[] values = new Byte[] { 0, 1, 127, 128, 254, 255 };
                foreach (var a in values)
                {
                    if (a == 0) continue;

                    foreach (var b in values)
                    {
                        foreach (var c in values)
                        {
                            foreach (var d in values)
                            {
                                UInt32 ipValue = BitConverter.ToUInt32(new Byte[] { a, b, c, d }, 0);
                                IPAddress ipAddr = new IPAddress(ipValue);

                                Global.RO.Fatal("Checking IP {0}", ipAddr);

                                TitleEndpoint endpoint = new TitleEndpoint
                                {
                                    Protocol = "http",
                                    Hostname = "",
                                    FromIP = ipValue,
                                    ToIP = ipValue,
                                    Port = 80,
                                    Path = "/",
                                    AppliesToUri = helper.SettingsHelper.AppliesTos[0].AppliesToUri,
                                };

                                var endpointList = new List<TitleEndpoint> { endpoint };
                                helper.SetNetworkSecurityList(endpointList);
                                helper.TitleEndpoints[helper.TitleIds[0]] = endpointList;

                                Global.RO.Info("Getting network security list...");
                                TitleEndpointInfo[] endpoints = helper.GetNetworkSecurityList();

                                helper.VerifyEndpoints(endpoints);
                            }
                        }
                    }
                }

                Global.RO.Success("Validated Network Security List");
            }

            public override void PostRun()
            {
                helper.Cleanup();
            }
        }

        [TestCase, TestCasePriority(2), Description("Ensures that Get/SetNetworkSecurityList work with an empty appliesTo")]
        public class EmptyAppliesTo : TestNode
        {
            TitleManagementHelperV3 helper;

            public override void PreRun()
            {
                helper = new TitleManagementHelperV3();
                helper.Initialize();
            }

            public override void Run()
            {
                TitleEndpoint endpoint = helper.GenerateEndpoint();
                endpoint.AppliesToUri = null;

                var endpointList = new List<TitleEndpoint> { endpoint };
                helper.SetNetworkSecurityList(endpointList);
                helper.TitleEndpoints[helper.TitleIds[0]] = endpointList;

                TitleEndpointInfo[] endpoints = helper.GetNetworkSecurityList();

                helper.VerifyEndpoints(endpoints);
            }

            public override void PostRun()
            {
                helper.Cleanup();
            }
        }

        [TestCase, TestCasePriority(1), Description("Ensures that SetNetworkSecurityList fails with too many entries")]
        public class MoreThanMaxEndpoints : TestNode
        {
            TitleManagementHelperV3 helper;

            public override void PreRun()
            {
                helper = new TitleManagementHelperV3();
                helper.Initialize();
            }

            public override void Run()
            {
                Boolean failed = false;
                Global.RO.Info("Generating network security list with 300 entries");
                try
                {
                    helper.GenerateNetworkSecurityList(300);
                }
                catch (UnexpectedTestResultException)
                {
                    Global.RO.Success("SetNetworkSecurityList failed as expected with more than 200 entries");
                    failed = true;
                }

                if (!failed)
                {
                    throw new UnexpectedTestResultException("SetNetworkSecurityList did not fail as expected with more than 200 entries");
                }
            }

            public override void PostRun()
            {
                helper.Cleanup();
            }
        }

        [TestCase, TestCasePriority(1), Description("Ensures that Get/SetNetworkSecurityList fails when a duplicate endpoint is passed")]
        public class DuplicateEndpoints : TestNode
        {
            TitleManagementHelperV3 helper;

            public override void PreRun()
            {
                helper = new TitleManagementHelperV3();
                helper.Initialize();
            }

            public override void Run()
            {
                TitleEndpoint endpoint = helper.GenerateEndpoint();
                helper.TitleEndpoints[helper.TitleIds[0]] = new List<TitleEndpoint> { endpoint };

                TitleEndpoint[] endpoints = new TitleEndpoint[] { endpoint, endpoint };
                try
                {
                    helper.SetNetworkSecurityList(endpoints);
                }
                catch (UnexpectedTestResultException)
                {
                    Global.RO.Success("SetNetworkSecurityList failed as expected with duplicate endpoints");
                }

                //TitleEndpointInfo[] actualEndpoints = helper.GetNetworkSecurityList();
                //helper.VerifyEndpoints(actualEndpoints);
            }

            public override void PostRun()
            {
                helper.Cleanup();
            }
        }

        [TestCase, TestCasePriority(1), Description("Ensures that Get/SetNetworkSecurityList fails when a duplicate endpoint is passed")]
        public class OverwriteSecurityList : TestNode
        {
            TitleManagementHelperV3 helper;

            public override void PreRun()
            {
                helper = new TitleManagementHelperV3();
                helper.Initialize();
            }

            public override void Run()
            {
                // Overwrites the list a bunch of times
                for (int i = 0; i < 10; i++)
                {
                    // Generate a random list and verify that it's correct
                    helper.GenerateNetworkSecurityList();

                    // Then grab it,
                    var endpoints = helper.GetNetworkSecurityList();
                    // and verify that it's correct
                    helper.VerifyEndpoints(endpoints);
                }
            }

            public override void PostRun()
            {
                helper.Cleanup();
            }
        }

        [TestCase, TestCasePriority(1), Description("Ensures that Get/SetNetworkSecurityList work correctly with")]
        [CompoundCase("MissingHostAndIp", "http", "", 0, 0, 80, "/", "_")]
        [CompoundCase("InvalidIpRange", "http", "", 0x17847C0B, 0x17847C0A, 80, "/", "_")]
        [CompoundCase("InvalidHost", "http", "www.,/:(/,.com", 0, 0, 80, "/", "_")]
        [CompoundCase("MissingProtocol", "", "www.xbox.com", 0, 0, 80, "/", "_")]
        [CompoundCase("InvalidProtocol", "!!:(!!", "www.xbox.com", 0, 0, 80, "/", "_")]
        [CompoundCase("InvalidPortTooBig", "http", "www.xbox.com", 0, 0, 65535, "/", "_")]
        [CompoundCase("InvalidPortNegative", "http", "www.xbox.com", 0, 0, -10, "/", "_")]
        [CompoundCase("InvalidPortMaxValue", "http", "www.xbox.com", 0, 0, Int32.MaxValue, "/", "_")]
        [CompoundCase("InvalidPortMinValue", "http", "www.xbox.com", 0, 0, Int32.MinValue, "/", "_")]
        [CompoundCase("InvalidPath", "http", "www.xbox.com", 0, 0, 80, "/--:D---:(---:[---/", "_")]
        [CompoundCase("InvalidAppliesTo", "http", "www.xbox.com", 0, 0, 80, "/", "http://----HAROOOOOO!!!----/")]
        [CompoundCase("NonExistentAppliesTo", "http", "www.xbox.com", 0, 0, 80, "/", "http://www.example.com/notreal/")]
        public class InvalidEndpointInfo : TestNode
        {
            TitleManagementHelperV3 helper;

            public override void PreRun()
            {
                helper = new TitleManagementHelperV3();
                helper.Initialize();
            }

            public override void Run()
            {
                String appliesToUri = (String)MyValues[6];
                // If the applies to is equal to our sential value
                if (appliesToUri == "_")
                {
                    // Then just use the default
                    appliesToUri = helper.SettingsHelper.AppliesTos[0].AppliesToUri;
                }

                TitleEndpoint endpoint = new TitleEndpoint
                {
                    Protocol = (String)MyValues[0],
                    Hostname = (String)MyValues[1],
                    FromIP = Convert.ToUInt32(MyValues[2]),
                    ToIP = Convert.ToUInt32(MyValues[3]),
                    Port = (Int32)MyValues[4],
                    Path = (String)MyValues[5],
                    AppliesToUri = appliesToUri,
                };

                Boolean failed = false;
                try
                {
                    helper.SetNetworkSecurityList(new TitleEndpoint[] { endpoint });
                }
                catch (UnexpectedTestResultException)
                {
                    failed = true;
                    Global.RO.Success("SetNetworkSecurityList failed as expected with invalid endpoint");
                }

                if (!failed)
                {
                    throw new UnexpectedTestResultException("SetNetworkSecurityList did not fail as expected with invalid endpoint");
                }
            }

            public override void PostRun()
            {
                helper.Cleanup();
            }
        }

        [TestCase, TestCasePriority(1), Description("Ensures that Get/SetNetworkSecurityList work correctly with wildcard endpoints")]
        [CompoundCase("SimpleWildcard", "*.xbox.com", true)]
        [CompoundCase("TwoWildcard", "*.*.xbox.com", true)]
        [CompoundCase("*.*.*.*.Wildcard", "*.*.*.*.*.xbox.com", true)]
        [CompoundCase("ShortWildcard", "*.com", true)]
        [CompoundCase("InvalidWildcard", "test.*.xbox.com", false)]
        [CompoundCase("BackwardsWildcard", ".*xbox.com", false)]
        [CompoundCase("ExtraDotWildcard", ".*.xbox.com", false)]
        [CompoundCase("WildcardThenSpace", "*. xbox.com", false)]
        [CompoundCase("DoubleStar", "**.xbox.com", false)]
        [CompoundCase("DoubleDot", "*..xbox.com", false)]
        public class WildcardEndpointInfo : TestNode
        {
            TitleManagementHelperV3 helper;

            public override void PreRun()
            {
                helper = new TitleManagementHelperV3();
                helper.Initialize();
            }

            public override void Run()
            {
                String hostname = (String)MyValues[0];
                Boolean shouldSucceed = (Boolean)MyValues[1];

                TitleEndpoint endpoint = helper.GenerateEndpoint();
                endpoint.Hostname = hostname;

                Boolean failed = false;
                try
                {
                    helper.SetNetworkSecurityList(new TitleEndpoint[] { endpoint });
                }
                catch (UnexpectedTestResultException e)
                {
                    failed = true;
                    if (shouldSucceed)
                    {
                        throw new UnexpectedTestResultException("SetNetworkSecurityList failed with hostname " + hostname, e);
                    }
                    else
                    {
                        Global.RO.Success("SetNetworkSecurityList failed as expected with hostname " + hostname);
                    }
                }

                if (!failed)
                {
                    if (shouldSucceed)
                    {
                        Global.RO.Success("SetNetworkSecurityList succeeded as expected with hostname " + hostname);
                    }
                    else
                    {
                        throw new UnexpectedTestResultException("SetNetworkSecurityList did not fail as expected with hostname " + hostname);
                    }
                }
            }

            public override void PostRun()
            {
                helper.Cleanup();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Test\TitleManagementTest\BusinessPartnerTitleIDs.cs ===
ï»¿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using ServerTestFramework;
using xonline.common.config;
using MixTest.SettingsManagement;

namespace MixTest.TitleManagement
{
    [TestGroup, Owner("BenRan"), Description("Tests for the BusinessPartnerTitleID APIs")]
	public class BusinessPartnerTitleIDs : TestNode
	{
        public override void PreRun()
        {
            MIXTesting.Config.EnableAPIs(Interface.mixtitlemanagement, "Xonline.Mix.TitleManagement.Service", "MixTitleManagement.SetBusinessPartnerTitleIDs");
            MIXTesting.Config.EnableAPIs(Interface.mixtitlemanagement, "Xonline.Mix.TitleManagement.Service", "MixTitleManagement.GetBusinessPartnerTitleIDs");

            MixSettingsHelperV3.Initialize();
        }

        [TestCase, TestCasePriority(1), Description("Verifies that the SetBusinessPartnerTitleIDs API succeeds with valid input")]
        public class SetBusinessPartnerTitleIDs_Mainline : TestNode
        {
            TitleManagementHelperV3 helper;

            public override void PreRun()
            {
                helper = new TitleManagementHelperV3();
            }

            public override void Run()
            {
                helper.SetBusinessPartnerTitleIDs(2);
            }

            public override void PostRun()
            {
                helper.Cleanup();
            }
        }

        [TestCase, TestCasePriority(1), Description("Verifies that the GetBusinessPartnerTitleIDs API return the expected values")]
        public class GetBusinessPartnerTitleIDs_Mainline : TestNode
        {
            TitleManagementHelperV3 helper;

            public override void PreRun()
            {
                helper = new TitleManagementHelperV3();
                helper.Initialize();
            }

            public override void Run()
            {
                UInt32[] titleIds = helper.GetBusinessPartnerTitleIDs();
                helper.VerifyTitleIds(titleIds);
            }

            public override void PostRun()
            {
                helper.Cleanup();
            }
        }

        [TestCase, TestCasePriority(2), Description("Sets a list of titles ids then gets and verifies it")]
        [CompoundCase("NoEntries", 0, false)]
        [CompoundCase("OneEntry", 1, true)]
        [CompoundCase("TenEntries", 10, true)]
        [CompoundCase("50Entries", 50, true)]
        [CompoundCase("100Entries", 100, true)]
        [CompoundCase("1000Entries", 1000, true)]
        public class SetThenGet : TestNode
        {
            TitleManagementHelperV3 helper;

            public override void PreRun()
            {
                helper = new TitleManagementHelperV3();
            }

            public override void Run()
            {
                Int32 count = (Int32)MyValues[0];
                Boolean shouldSucceed = (Boolean)MyValues[1];

                Global.RO.Info("Setting BusinessPartner TitleIDs");
                helper.SetBusinessPartnerTitleIDs(count);

                Global.RO.Info("Retrieving BusinessPartner TitleIDs");
                var titleIds = helper.GetBusinessPartnerTitleIDs();

                helper.VerifyTitleIds(titleIds);

                Global.RO.Success("Recieved expected title id list");
            }

            public override void PostRun()
            {
                helper.Cleanup();
            }
        }

        [TestCase, TestCasePriority(3), Description("Ensures that SetBusinessPartnerTitleIds")]
        public class DuplicateEntries : TestNode
        {
            TitleManagementHelperV3 helper;

            public override void PreRun()
            {
                helper = new TitleManagementHelperV3();
            }

            public override void Run()
            {
                TitleManagementHelperV3 helper = new TitleManagementHelperV3();

                UInt32[] titleIds = new UInt32[] { 0xFFFE0000, 0xFFFE0001, 0xFFFE0001, 0xFFFE0002 };
                try
                {
                    helper.SetBusinessPartnerTitleIDs(titleIds);
                }
                catch (UnexpectedTestResultException)
                {
                    Global.RO.Success("SetBusinessPartnerTitleIDs failed as expected with duplicate TitleID entry");
                }
                //helper.TitleIds = titleIds.Distinct().ToArray();

                //UInt32[] actualTitleIds = helper.GetBusinessPartnerTitleIDs();
                //helper.VerifyTitleIds(actualTitleIds);
            }

            public override void PostRun()
            {
                helper.Cleanup();
            }
        }

        [TestCase, TestCasePriority(3), Description("Ensures that calling SetBusinessPratnerTitleIDs with a non existant BusinessPartner fails")]
        public void InvalidBusinessPartner()
        {
            TitleManagementHelperV3 helper = new TitleManagementHelperV3();

            try
            {
                helper.SetBusinessPartnerTitleIDs(Guid.NewGuid(), helper.GenerateTitleIds(1));
            }
            catch (UnexpectedTestResultException)
            {
                Global.RO.Success("SetBusinessPartnerTitleIDs failed as expected with a non-existant business partner");
            }
        }

        [TestCase, TestCasePriority(3), Description("Ensures that calling SetBusinessPratnerTitleIDs with a non existant BusinessPartner fails")]
        public void ReuseTitleId()
        {
            TitleManagementHelperV3 helper = new TitleManagementHelperV3();
            Global.RO.Info("Adding a random title id...");
            helper.SetBusinessPartnerTitleIDs(1);

            TitleManagementHelperV3 dupHelper = new TitleManagementHelperV3();
            // Use the same title ids
            try
            {
                dupHelper.SetBusinessPartnerTitleIDs(helper.TitleIds);
            }
            catch (UnexpectedTestResultException)
            {
                Global.RO.Success("SetBusinessPartnerTitleIDs failed as expected with already used TitleId");
            }
        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Test\TitleManagementTest\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Test\TokenManagementManualTest\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Test\TitleManagementTest\TitleManagementMobileWebTests.cs ===
ï»¿//Mobile TitleManagement Tests for the MIX Title Management API

using System;
using System.Collections;
using System.Collections.Generic;
using System.ServiceModel;
using System.Runtime.Serialization;
using System.IO;
using System.Threading;
using System.Xml;
using System.Xml.Serialization;
using System.Xml.XPath;
using System.Text;
using System.Text.RegularExpressions;
using System.Net;
using System.Security.Cryptography;
using ServerTestFramework;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.LiveService;
using ServerTestFramework.Utilities;
using System.Linq;
using System.Data.SqlClient;
using xonline.common.xlastutil;

using xonline.common.config;
using xonline.common.sql;
using xonline.mix.common;
using xonline.mix.titlemanagement.contract;
using xonline.mix.titlemanagement.contracts.V2;
using MIXTesting;
using MIXTestingUtilsV2;

using ServerTestFramework.Database;


namespace MixTest
{

    public class TestMobileTitle
    {
        private string _filePathTitle;
        private string _filePath_MobileStatsColumnsLocalizedXML;
        private string _beforeConversionXML;
        private string _afterConversionXML;
        private string _afterConversionXLAST_File;
        private XboxLiveSubmissionProject _beforeConversionXLSP;
        private XboxLiveSubmissionProject _afterConversionXLSP;
        private bool _isMobile;
        Dictionary<string, string> _colLocalizationData; 

        public bool IsMobile
        {
            get{ return _isMobile; }
        }

        public string MobileStatsColumnsLocalizedXML
        {
            get { return _filePath_MobileStatsColumnsLocalizedXML; }
        }

        public string BeforeConversionXML
        {
            get { return _beforeConversionXML; }
        }

        public string AfterConversionXML
        {
            get { return _afterConversionXML; }
        }

        public XboxLiveSubmissionProject BeforeConversion_XLSP_Object
        {
            get { return _beforeConversionXLSP; }
        }

        public XboxLiveSubmissionProject AfterConversion_XLSP_Object
        {
            get { return _afterConversionXLSP; }
        }

        public string GetConvertedXLAST_File
        {
            get { return _afterConversionXLAST_File; }
        }

        /// <summary>
        /// Constructor for TestMobileTitle for testing a mobile title
        /// </summary>
        /// <param name="TitlePath">Input Mobile XLAST file</param>
        /// <param name="LocXMLPath">MobileStatsColumnsLocalized.xml file path</param>
        public TestMobileTitle(string TitlePath, string LocXMLPath)
        {
            if (!File.Exists(TitlePath))
            {
                throw new Exception(String.Format("Title file - {0} NotFound!", TitlePath));
            }

            if (!File.Exists(LocXMLPath))
            {
                throw new Exception(String.Format("MobileStatsColumnsLocalized.xml file - {0} NotFound!", LocXMLPath));
            }

            _filePathTitle = TitlePath;
            using (StreamReader streamReader = new StreamReader(_filePathTitle))
            {
                _beforeConversionXML = streamReader.ReadToEnd();
            }
            
            //We initialize _beforeConversionXLSP and _afterConversionXLSP to same value 
            //Once ConvertFromMobileToGeneralFormat() is made _beforeConversionXLSP is not changed and only _afterConversionXLSP is changed.

            _beforeConversionXLSP = XlastUtil.GetXlastFromXml(_beforeConversionXML);
            _afterConversionXLSP = XlastUtil.GetXlastFromXml(_beforeConversionXML);
            _isMobile = MobileAndWebLeaderboardUtils.IsMobileTitle(_beforeConversionXLSP);

            _filePath_MobileStatsColumnsLocalizedXML = LocXMLPath;
            _colLocalizationData = MobileAndWebLeaderboardUtils.GetLocalizationDataDictionary(_filePath_MobileStatsColumnsLocalizedXML);

            if(!_isMobile)
            {
                throw new UnexpectedTestResultException(String.Format("Title do not have Mobile (FriendsStatsView) in it - {0}", TitlePath));
            }
        }

        /// <summary>
        /// Convert FriendsStatsView to StatsViewCount.
        /// _afterConversionXLSP and _afterConversionXML are populated with converted data.
        /// </summary>
        public void ConvertFromMobileToGeneralFormat()
        {
            if(!_isMobile)
            {
                throw new Exception("The title is not a MobileTitle");
            }

            MobileAndWebLeaderboardUtils.ConvertMobileLeaderboardsToGeneralFormat(_afterConversionXLSP, _colLocalizationData);

            XmlSerializer serializer = new XmlSerializer(_afterConversionXLSP.GetType());
            using (StringWriter writer = new StringWriter())
            {
                serializer.Serialize(writer, _afterConversionXLSP);
                _afterConversionXML = writer.ToString();
            }
        }

        public void SaveConvertedFile(string xmlFilePath)
        {
            if (null != _afterConversionXML)
            {
                // Create the XmlDocument.
                XmlDocument doc = new XmlDocument();
                doc.LoadXml(_afterConversionXML);

                if (File.Exists(xmlFilePath))
                {
                    File.Delete(xmlFilePath);
                }

                doc.Save(xmlFilePath);
                _afterConversionXLAST_File = xmlFilePath;
            }
            else
            {
                throw new Exception(" _afterConversionXML is null");
            }
        }


        /// <summary>
        /// Verify StatsViewCount after conversion       
        /// </summary>
        public void VerifyStatsViewCount()
        {
            InitializeVerification();

            FriendStatsViews friendStatsViews = _beforeConversionXLSP.GameConfigProject.FriendStatsViews;
            StatsViews statsViews = _afterConversionXLSP.GameConfigProject.StatsViews;

            int expected_StatsViewCount = (2 * friendStatsViews.FriendStatsView.Count());

            if (expected_StatsViewCount != statsViews.StatsView.Count())
            {
                throw new UnexpectedTestResultException(String.Format("StatsView Count do not match the expected value - {0}", expected_StatsViewCount));
            }
        }

        public static class ExpectedLocalizedString
        {
            public static LocalizedString GamerName = new LocalizedString() { clsid = null, id = 32515, friendlyName = "GamerName", idSpecified = true, Presence = null, Translation = null };
            public static LocalizedString Rating = new LocalizedString() { clsid = null, id = 32522, friendlyName = "Rating", idSpecified = true, Presence = null, Translation = null };
            public static LocalizedString Rank = new LocalizedString() { clsid = null, id = 32517, friendlyName = "Rank", idSpecified = true, Presence = null, Translation = null };
            public static LocalizedString BestScore = new LocalizedString() { clsid = null, id = 33001, friendlyName = "BestScore", idSpecified = true, Presence = null, Translation = null };
            public static LocalizedString BestTime = new LocalizedString() { clsid = null, id = 33002, friendlyName = "BestTime", idSpecified = true, Presence = null, Translation = null };
            public static LocalizedString GamesPlayed = new LocalizedString() { clsid = null, id = 33003, friendlyName = "GamesPlayed", idSpecified = true, Presence = null, Translation = null };
            public static LocalizedString LastPlayedDateTime = new LocalizedString() { clsid = null, id = 33004, friendlyName = "LastPlayedDateTime", idSpecified = true, Presence = null, Translation = null };
            public static LocalizedString Wins = new LocalizedString() { clsid = null, id = 33005, friendlyName = "Wins", idSpecified = true, Presence = null, Translation = null };
            public static LocalizedString CumulativeScore = new LocalizedString() { clsid = null, id = 33006, friendlyName = "CumulativeScore", idSpecified = true, Presence = null, Translation = null };
            public static LocalizedString CumulativeTime = new LocalizedString() { clsid = null, id = 33007, friendlyName = "CumulativeTime", idSpecified = true, Presence = null, Translation = null };
            public static LocalizedString Losses = new LocalizedString() { clsid = null, id = 33008, friendlyName = "Losses", idSpecified = true, Presence = null, Translation = null };
        }

        /// <summary>
        /// Verify LocalizedStrings data after conversion       
        /// </summary>
        public void VerifyLocalizedStrings()
        {
            VerifyStatsViewCount();

            SupportedLocale[] SupportedLocaleList = _beforeConversionXLSP.GameConfigProject.LocalizedStrings.SupportedLocale;
            
            LocalizedString[] ExpectedLocalizedStringList = new LocalizedString[] 
            {   ExpectedLocalizedString.GamerName, 
                ExpectedLocalizedString.Rating, 
                ExpectedLocalizedString.Rank, 
                ExpectedLocalizedString.BestScore, 
                ExpectedLocalizedString.BestTime, 
                ExpectedLocalizedString.GamesPlayed, 
                ExpectedLocalizedString.LastPlayedDateTime, 
                ExpectedLocalizedString.Wins, 
                ExpectedLocalizedString.CumulativeScore, 
                ExpectedLocalizedString.CumulativeTime,
                ExpectedLocalizedString.Losses
            };

            foreach (LocalizedString locStr in ExpectedLocalizedStringList)
            {
                locStr.Translation = new Translation[SupportedLocaleList.Count()];

                for(int i=0; i<SupportedLocaleList.Count(); i++)
                {
                    locStr.Translation[i] = new Translation();
                    locStr.Translation[i].locale = SupportedLocaleList[i].locale;

                    string key = String.Format("{0}:{1}", SupportedLocaleList[i].locale, locStr.friendlyName);

                    if (_colLocalizationData.ContainsKey(key))
                    {
                        locStr.Translation[i].Value = _colLocalizationData[key];
                    }
                    else
                    {
                        locStr.Translation[i].Value = locStr.friendlyName;
                    }
                }
            }

            foreach (LocalizedString item in ExpectedLocalizedStringList)
            {
                if (!IfLocExists(item))
                {
                    throw new Exception(String.Format("{0} value did not match the expected value", item.friendlyName));
                }
            }
        }

        /// <summary>
        /// Help function to check if the given LocalizedString item is present in the _afterConversionXLSP object under LocalizedStrings node
        /// It compares each member in LocalizedString object and returns true if they match
        /// </summary>
        /// <param name="locStr">input LocalizedString object to find</param>
        /// <returns>true if input LocalizedString object is found in the XLSP after conversion</returns>
        private bool IfLocExists(LocalizedString locStr)
        {
            LocalizedString[] list = _afterConversionXLSP.GameConfigProject.LocalizedStrings.LocalizedString;

            foreach (LocalizedString item in list)
            {
                //Check if LocalizedString <id> 
                if (item.id == locStr.id)
                {
                    //Check if <friendlyName>, <clisid>, <Presence> match
                    if ((item.clsid == locStr.clsid) &&
                       (item.friendlyName == locStr.friendlyName) &&
                       (item.Presence == locStr.Presence))
                    {
                        //Translation count gives number of locales the string can be translated to under GameConfigProject->LocalizedStrings->LocalizedString node
                        //The count after conversion should match to count that was present in LiveN Xlast file before conversion for each string id.
                        if (item.Translation.Count() == locStr.Translation.Count())
                        {
                            //We loop through each LocalizedString item and verify if the locate and Value data after conversion match to data that was in original LiveN Xlast file before conversion
                            for (int i = 0; i < item.Translation.Count(); i++)
                            {
                                if ((item.Translation[i].locale != locStr.Translation[i].locale) &&
                                   (item.Translation[i].Value != locStr.Translation[i].Value))
                                {
                                    //If it hits this place the match was not found and we return false
                                    return false;
                                }
                            }

                            //If it hits this place the match was successful and we return back true(found)
                            return true;
                        }
                    }                      
                }
            }
            //If it hits this place the match was not found and we return false
            return false;
        }

        /// <summary>
        /// Verifies if the _beforeConversionXLSP and _afterConversionXLSP objects are available and not null
        /// </summary>
        private void InitializeVerification()
        {
            if ((null == _beforeConversionXLSP) || (null == _beforeConversionXLSP.GameConfigProject) || (null == _beforeConversionXLSP.GameConfigProject.FriendStatsViews))
            {
                throw new ArgumentNullException("_beforeConversionXLSP object is NULL");
            }

            if ((null == _afterConversionXLSP) || (null == _afterConversionXLSP.GameConfigProject) || (null == _afterConversionXLSP.GameConfigProject.StatsViews))
            {
                throw new Exception(String.Format("_afterConversionXLSP object is NULL"));
            }
        }

        public static class ExpectedPropertiesProperty
        {
            public static XboxLiveSubmissionProjectGameConfigProjectPropertiesProperty GamerName = new XboxLiveSubmissionProjectGameConfigProjectPropertiesProperty() { dataSize = 0, id = "0x40008002", friendlyName = "GamerName", stringId = 32515 };
            public static XboxLiveSubmissionProjectGameConfigProjectPropertiesProperty Rating = new XboxLiveSubmissionProjectGameConfigProjectPropertiesProperty()
            { dataSize = 4, id = "0x50008104", friendlyName = "Rating",stringId = 32522,
              Format = new XboxLiveSubmissionProjectGameConfigProjectPropertiesPropertyFormat() { decimals = 2 }
            };
            public static XboxLiveSubmissionProjectGameConfigProjectPropertiesProperty Rank = new XboxLiveSubmissionProjectGameConfigProjectPropertiesProperty() { dataSize = 4, id = "0x10008001", friendlyName = "Rank", stringId = 32517 };
            public static XboxLiveSubmissionProjectGameConfigProjectPropertiesProperty BestScore = new XboxLiveSubmissionProjectGameConfigProjectPropertiesProperty() { dataSize = 8, id = "0x20000001", friendlyName = "BestScore", stringId = 33001 };
            public static XboxLiveSubmissionProjectGameConfigProjectPropertiesProperty BestTime = new XboxLiveSubmissionProjectGameConfigProjectPropertiesProperty() { dataSize = 8, id = "0x20000002", friendlyName = "BestTime", stringId = 33002 };
            public static XboxLiveSubmissionProjectGameConfigProjectPropertiesProperty GamesPlayed = new XboxLiveSubmissionProjectGameConfigProjectPropertiesProperty() { dataSize = 8, id = "0x20000003", friendlyName = "GamesPlayed", stringId = 33003 };
            public static XboxLiveSubmissionProjectGameConfigProjectPropertiesProperty LastPlayedDateTime = new XboxLiveSubmissionProjectGameConfigProjectPropertiesProperty() { dataSize = 8, id = "0x20000004", friendlyName = "LastPlayedDateTime", stringId = 33004 };
            public static XboxLiveSubmissionProjectGameConfigProjectPropertiesProperty Wins = new XboxLiveSubmissionProjectGameConfigProjectPropertiesProperty() { dataSize = 8, id = "0x20000005", friendlyName = "Wins", stringId = 33005 };
            public static XboxLiveSubmissionProjectGameConfigProjectPropertiesProperty CumulativeScore = new XboxLiveSubmissionProjectGameConfigProjectPropertiesProperty() { dataSize = 8, id = "0x20000006", friendlyName = "CumulativeScore", stringId = 33006 };
            public static XboxLiveSubmissionProjectGameConfigProjectPropertiesProperty CumulativeTime = new XboxLiveSubmissionProjectGameConfigProjectPropertiesProperty() { dataSize = 8, id = "0x20000007", friendlyName = "CumulativeTime", stringId = 33007 };
            public static XboxLiveSubmissionProjectGameConfigProjectPropertiesProperty Losses = new XboxLiveSubmissionProjectGameConfigProjectPropertiesProperty() { dataSize = 8, id = "0x20000008", friendlyName = "Losses", stringId = 33008 };
        }

        /// <summary>
        /// Verify Properties data after conversion       
        /// </summary>
        public void VerifyProperties()
        {
            InitializeVerification();

            XboxLiveSubmissionProjectGameConfigProjectPropertiesProperty[] actualProp = _afterConversionXLSP.GameConfigProject.Properties.Property;

            XboxLiveSubmissionProjectGameConfigProjectPropertiesProperty[] expectedPropList = new XboxLiveSubmissionProjectGameConfigProjectPropertiesProperty[]
            {
                 ExpectedPropertiesProperty.GamerName, 
                 ExpectedPropertiesProperty.Rating, 
                 ExpectedPropertiesProperty.Rank, 
                 ExpectedPropertiesProperty.BestScore, 
                 ExpectedPropertiesProperty.BestTime, 
                 ExpectedPropertiesProperty.GamesPlayed, 
                 ExpectedPropertiesProperty.LastPlayedDateTime,
                 ExpectedPropertiesProperty.Wins, 
                 ExpectedPropertiesProperty.CumulativeScore, 
                 ExpectedPropertiesProperty.CumulativeTime, 
                 ExpectedPropertiesProperty.Losses
            };

            if (expectedPropList.Count() != _afterConversionXLSP.GameConfigProject.Properties.Property.Count())
            {
                throw new Exception(String.Format("VerifyProperty - Property count did not match. Expected - {0}, Actual - {1}", expectedPropList.Count(), _afterConversionXLSP.GameConfigProject.Properties.Property.Count()));
            }

            foreach (XboxLiveSubmissionProjectGameConfigProjectPropertiesProperty item in expectedPropList)
            {
                if (!IfPropertyExist(item))
                {
                    throw new Exception(String.Format("Property ID - {0} data is not matching the expected value", item.id));
                }
            }
        }
        
        /// <summary>
        /// Help function to see if a given Property is present in the Propery list in XLSP after conversion
        /// </summary>
        /// <param name="expectedProp"></param>
        /// <returns>If the input property is found returns true else retrun false</returns>
        private bool IfPropertyExist(XboxLiveSubmissionProjectGameConfigProjectPropertiesProperty expectedProp)
        {
            XboxLiveSubmissionProjectGameConfigProjectPropertiesProperty[] actual = _afterConversionXLSP.GameConfigProject.Properties.Property;

            foreach (XboxLiveSubmissionProjectGameConfigProjectPropertiesProperty item in actual)
            {
                if (expectedProp.id == item.id)
                {                    
                    if (expectedProp.dataSize == item.dataSize)
                    {
                        if (expectedProp.stringId == item.stringId)
                        {
                            if (expectedProp.friendlyName == item.friendlyName)
                            {
                                if (expectedProp.friendlyName == "Rating")
                                {
                                    //Rating is special case where the Format is specific and we need to check if they match
                                    if (expectedProp.Format.decimals == item.Format.decimals)
                                    {
                                        //Found
                                        return true;
                                    }
                                    else
                                    {
                                        //Not found
                                        return false;
                                    }
                                }
                                else
                                {
                                    //Found
                                    return true;
                                }
                             }
                         }
                     }                    
                }
            }
            //If it hits this code the match is not found and return false
            return false;
        }

        /// <summary>
        /// Verify StatsView data after conversion       
        /// </summary>
        public void VerifyStatsView()
        {
            InitializeVerification();

            FriendStatsView[] friendStatsViews = _beforeConversionXLSP.GameConfigProject.FriendStatsViews.FriendStatsView;
            StatsView[] statsViews = _afterConversionXLSP.GameConfigProject.StatsViews.StatsView;

            foreach(FriendStatsView item in friendStatsViews)
            {
                List<StatsView> stats = GetStatsView(item);

                if(stats.Count!=2)
                {
                    throw new Exception(String.Format("FriendsStatsView - StringID: {0}, FriendlyName: {1} did not map exactly to 2 StatsView nodes after conversion", item.stringId.ToString(), item.friendlyName));
                }

                VerifyStatsViewData(item, stats);
            }

            //Verify there is no duplicate Leaderboard id
            List<ulong> ID_List = new List<ulong>();
            foreach (StatsView item in statsViews)
            {
                ID_List.Add(item.id);
            }

            if (ID_List.Distinct().Count() != ID_List.Count)
            {
                throw new Exception("Duplicate LeaderboardID found!");
            }
        }

        /// <summary>
        /// Help functions for VerifyStatsView 
        /// </summary>
        private List<StatsView> GetStatsView(FriendStatsView entry)
        {
            List<StatsView> return_value = new List<StatsView>();

            foreach(StatsView item in _afterConversionXLSP.GameConfigProject.StatsViews.StatsView)
            {
                if (item.stringId == entry.stringId)
                {
                    return_value.Add(item);
                }
            }
            return return_value;
        }

        /// <summary>
        /// Verifies if each FriendsStatsView is properly converted to a pair of StatsView data
        /// </summary>
        /// <param name="friendStats">FriendsStatView data from original Mobile XLAST before conversion</param>
        /// <param name="statsView">StatsView data from converted General format XLAST</param>
        private void VerifyStatsViewData(FriendStatsView friendStats, List<StatsView> statsView)
        {
            if(statsView.Count!=2)
            {
                throw new Exception("More than 2 StatsView found for a FriendsStatsView");
            }

            List<string> errorMessage = new List<string>();

            foreach (StatsView stat in statsView)
            {
                if (stat.stringId != friendStats.stringId)
                {
                    errorMessage.Add(String.Format("VerifyStatsViewData - StringID mismatch. Expected - {0}, Actual - {1}", friendStats.stringId, stat.stringId));
                }

                if (stat.friendlyName != friendStats.friendlyName)
                {
                    errorMessage.Add(String.Format("VerifyStatsViewData - FriendlyName mismatch. Expected - {0}, Actual - {1}", friendStats.friendlyName, stat.friendlyName));
                }

                if (stat.entryExpiration != 0)
                {
                    errorMessage.Add(String.Format("VerifyStatsViewData - entryExpiration mismatch. Expected - 0, Actual - {0}", stat.entryExpiration));
                }

                if (stat.topEntries != 4294967295)
                {
                    errorMessage.Add(String.Format("VerifyStatsViewData - topEntries mismatch. Expected - 4294967295, Actual - {0}", stat.topEntries));
                }

                if (stat.arbitrated != false)
                {
                    errorMessage.Add(String.Format("VerifyStatsViewData - arbitrated mismatch. Expected - false, Actual - {0}", stat.arbitrated));
                }

                if (stat.maxAttachments != 65535)
                {
                    errorMessage.Add(String.Format("VerifyStatsViewData - maxAttachments mismatch. Expected - maxAttachments, Actual - {0}", stat.maxAttachments));
                }

                if (stat.onlineOnly != false)
                {
                    errorMessage.Add(String.Format("VerifyStatsViewData - onlineOnly mismatch. Expected - false, Actual - {0}", stat.onlineOnly));
                }

                if (stat.viewType != "Leaderboard")
                {
                    errorMessage.Add(String.Format("VerifyStatsViewData - viewType mismatch. Expected - <Leaderboard>, Actual - {0}", stat.viewType));
                }

                if (stat.hidden != false)
                {
                    errorMessage.Add(String.Format("VerifyStatsViewData - <hidden> mismatch. Expected - true, Actual - {0}", stat.hidden));
                }
            }

            if(statsView[0].resetType!= ResetType.Never)
            {
                errorMessage.Add(String.Format("StatsViewData - resetType mismatch. Expected - <Never>, Actual - {0}", statsView[0].resetType));
            }

            if(statsView[1].resetType!= ResetType.Weekly)
            {
                errorMessage.Add(String.Format("StatsViewData - resetType mismatch. Expected - <Weekly>, Actual - {0}", statsView[0].resetType));
            }

            if(statsView[0].id == statsView[1].id)
            {
                errorMessage.Add(String.Format("StatsViewData - Leaderboard id duplicate found for id - {0}", statsView[0].id));
            }

            if (errorMessage.Count() > 0)
            {
                throw new Exception("StatsView data items did not match \n" + errorMessage);
            }

            //Verify the StatsView Columns data            
            foreach (StatsView stat in statsView)
            {
                int ColCount = stat.Columns.Count();

                if (ColCount == 0)
                {
                    throw new Exception("StatsView Column count is 0");
                }

                if (friendStats.bestOutcomeSortOrder == "Ascending")
                {
                    if (ColCount != 11)
                    {
                        throw new Exception(String.Format("StatsViewData - Column data - Column count not equal to 11 for Ascending sortorder. Actual count - {0}", ColCount));
                    }
                }

                if (friendStats.bestOutcomeSortOrder == "Descending")
                {
                    if (ColCount != 10)
                    {
                        throw new Exception(String.Format("StatsViewData - Column data - Column count not equal to 10 for Descending sortorder. Actual count - {0}", ColCount));
                    }
                }

                //Build the expected Fields. Note that we do not verify ordinal when we match using IfFieldExists() function and set it '0' when we build expected list.

                ViewFieldType GamerName = BuildField(65533, "Gamer Name", false, 32515, 0, PropertyFieldTypeAggregationType.Last, "0x40008002");
                ViewFieldType RatingColumn = null;
                ViewFieldType Rank = BuildField(65535, "Rank", false, 32517, 0, PropertyFieldTypeAggregationType.Last, "0x10008001");
                ViewFieldType Column1 = null;
                ViewFieldType Column2 = null;
                ViewFieldType Column5 = null;
                ViewFieldType GamesPlayed = BuildField(3, "GamesPlayed", false, 33003, 0, PropertyFieldTypeAggregationType.Sum, "0x20000003");
                ViewFieldType LastPlayedDateTime = BuildField(4, "LastPlayedDateTime", false, 33004, 0, PropertyFieldTypeAggregationType.Last, "0x20000004");
                ViewFieldType Wins = null; 
                ViewFieldType CumulativeScore = BuildField(6, "CumulativeScore", false, 33006, 0, PropertyFieldTypeAggregationType.Sum, "0x20000006");
                ViewFieldType CumulativeTime = BuildField(7, "CumulativeTime", false, 33006, 0, PropertyFieldTypeAggregationType.Sum, "0x20000007");
                ViewFieldType Losses = BuildField(8, "Losses", false, 33007, 0, PropertyFieldTypeAggregationType.Sum, "0x20000008");

                ViewFieldType[] fieldList = new ViewFieldType[]{ GamerName, Rank, GamesPlayed, LastPlayedDateTime, Wins, CumulativeScore, CumulativeTime, Losses};

                if (friendStats.bestOutcome == "BestTime")
                {
                    Wins = BuildField(5, "Wins", false, 33005, 0, PropertyFieldTypeAggregationType.Sum, "0x20000005");
                    VerifyField(stat, Wins);

                    if (friendStats.bestOutcomeSortOrder == "Descending")
                    {
                        RatingColumn = BuildField(65534, "BestTime", false, 33002, 0, PropertyFieldTypeAggregationType.Max, "0x20000002");
                        Column2 = BuildField(2, "BestScore", false, 33001, 0, PropertyFieldTypeAggregationType.Max, "0x20000001");

                        VerifyField(stat, RatingColumn);
                        VerifyField(stat, Column2);
                    }
                    else if (friendStats.bestOutcomeSortOrder == "Ascending")
                    {
                        RatingColumn = BuildField(65534, "BestTime", true, 33002, 0, PropertyFieldTypeAggregationType.Max, "0x20000002");
                        Column1 = BuildField(1, "BestScore", false, 33001, 0, PropertyFieldTypeAggregationType.Max, "0x20000001");
                        Column2 = BuildField(2, "BestTime", false, 33002, 0, PropertyFieldTypeAggregationType.Min, "0x20000002");

                        VerifyField(stat, RatingColumn);
                        VerifyField(stat, Column1);
                        VerifyField(stat, Column2);
                    }
                }

                if (friendStats.bestOutcome == "BestScore")
                {
                    Wins = BuildField(5, "Wins", false, 33005, 0, PropertyFieldTypeAggregationType.Sum, "0x20000005");
                    VerifyField(stat, Wins);

                    if (friendStats.bestOutcomeSortOrder == "Descending")
                    {
                        RatingColumn = BuildField(65534, "BestScore", false, 33001, 0, PropertyFieldTypeAggregationType.Max, "0x20000001");
                        Column2 = BuildField(2, "BestTime", false, 33002, 0, PropertyFieldTypeAggregationType.Max, "0x20000002");

                        VerifyField(stat, RatingColumn);
                        VerifyField(stat, Column2);
                    }
                    else if (friendStats.bestOutcomeSortOrder == "Ascending")
                    {
                        RatingColumn = BuildField(65534, "BestScore", true, 33001, 0, PropertyFieldTypeAggregationType.Max, "0x20000001");
                        Column2 = BuildField(2, "BestTime", false, 33002, 0, PropertyFieldTypeAggregationType.Max, "0x20000002");
                        Column1 = BuildField(1, "BestScore", false, 33001, 0, PropertyFieldTypeAggregationType.Min, "0x20000001");

                        VerifyField(stat, RatingColumn);
                        VerifyField(stat, Column1);
                        VerifyField(stat, Column2);

                    }
                }

                if (friendStats.bestOutcome == "MostWins")
                {

                    Column1 = BuildField(1, "BestScore", false, 33001, 0, PropertyFieldTypeAggregationType.Max, "0x20000001");
                    Column2 = BuildField(2, "BestTime", false, 33002, 0, PropertyFieldTypeAggregationType.Max, "0x20000002");

                    VerifyField(stat, Column1);
                    VerifyField(stat, Column2);

                    if (friendStats.bestOutcomeSortOrder == "Descending")
                    {
                        RatingColumn = BuildField(65534, "Wins", false, 33005, 0, PropertyFieldTypeAggregationType.Sum, "0x20000005");

                        VerifyField(stat, RatingColumn);
                    }
                    else if (friendStats.bestOutcomeSortOrder == "Ascending")
                    {
                        RatingColumn = BuildField(65534, "Wins", true, 33005, 0, PropertyFieldTypeAggregationType.Sum, "0x20000005");
                        Column5 = BuildField(5, "Wins", false, 33005, 0, PropertyFieldTypeAggregationType.Sum, "0x20000005");

                        VerifyField(stat, RatingColumn);
                        VerifyField(stat, Column5);
                    }
                }


                foreach (ViewFieldType item in fieldList)
                {
                    if (!IfFieldExists(stat, GamerName))
                    {
                        throw new Exception(String.Format("Field - AttributeID:<{0}> friendlyName:<{1}> data did not match", item.attributeId, item.friendlyName));
                    }
                }
            }
        }

        /// <summary>
        /// Verifies if the given ViewFieldType is present in given StatsView columns        
        /// </summary>
        /// <param name="_stat">StatsView column</param>
        /// <param name="_ExpectedField">Input Fiels to find in StatsView columns</param>
        /// <returns>return true if found else false</returns>
        private bool IfFieldExists(StatsView _stat, ViewFieldType _ExpectedField)
        {
            // Note that we do not verify ordinal number in this function
            foreach (ViewFieldType item in _stat.Columns)
            {
                if (_ExpectedField.attributeId == item.attributeId)
                {
                    if (_ExpectedField.friendlyName == item.friendlyName)
                    {
                        if (_ExpectedField.hidden == item.hidden)
                        {
                            if (_ExpectedField.stringId == item.stringId)
                            {
                                //Verify PropertyFieldType under each Field
                                PropertyFieldType propertyExpected = (PropertyFieldType)_ExpectedField.Item;
                                PropertyFieldType propertyActual = (PropertyFieldType)item.Item;

                                if (propertyExpected.Aggregation.type == propertyActual.Aggregation.type)
                                {
                                    if (propertyExpected.id == propertyActual.id)
                                    {
                                        return true;
                                    }
                                }
                            }
                        }
                    }
                }
            }

            return false;
        }

        //Helper function to verify each field
        private void VerifyField(StatsView _stat, ViewFieldType _ExpectedField)
        {
            if (!IfFieldExists(_stat, _ExpectedField))
            {
                throw new Exception(String.Format("Field - AttributeID:<{0}> friendlyName:<{1}> data did not match", _ExpectedField.attributeId, _ExpectedField.friendlyName));
            }
        }
        
        /// <summary>
        /// Help function to construct ViewFieldType object for verification.
        /// </summary>
        /// <param name="_attributeID">attributeID</param>
        /// <param name="_friendlyName">friendlyName</param>
        /// <param name="_hidden">hidden</param>
        /// <param name="_stringId">stringId</param>
        /// <param name="_ordinal">ordinal</param>
        /// <param name="_aggegrationType">aggegrationType</param>
        /// <param name="_propertyID">propertyID</param>
        /// <returns></returns>
        private ViewFieldType BuildField(ushort _attributeID, string _friendlyName, bool _hidden, ushort _stringId, ushort _ordinal, PropertyFieldTypeAggregationType _aggegrationType, string _propertyID)
        {
            ViewFieldType field = new ViewFieldType();
            field.attributeId = _attributeID;
            field.friendlyName = _friendlyName;
            field.hidden = _hidden;
            field.stringId = _stringId;
            field.ordinal = _ordinal;
            field.Item = new PropertyFieldType()
            {
                Aggregation = new PropertyFieldTypeAggregation() { type = _aggegrationType, typeSpecified = true },
                id = _propertyID
            };

            return field;
        }
    }
   
    /// <summary>
    /// Tests for MobileWeb gameconfig/XLAST title ingestion
    /// Tests are divided into three categories
    /// 1. Verification for Mobile format to General format, basically checking each FriendsStatsView is converted to a pair of StatsView data.
    /// 2. Verification of MixTitleManagement API and making sure the converted XLAST file can be successfully ingested. This includes both V1 and V2 version.
    /// 3. Verification of MixStats API to make sure a Mobile ingested title ( basically after above 2 steps) can be successfully configured for leaderboard data.
    /// </summary>
    /// 
    [TestGroup, Owner("srkalyan"), Description("MobileWeb Mix Title Management Tests")]
    public class TitleManagementTests_MobileWeb_Titles : TestNode
    {
        public override void OneTimeSetup()
        {
            base.OneTimeSetup();

            MIXTesting.Config.EnableAPIs(Interface.mixstats, "Xonline.Mix.Stats.Service", "MixStats.ConfigureLeaderboards", "MixStats.ResetLeaderboard");
            MIXTesting.Config.EnableAPIs(Interface.mixtitlemanagement, "Xonline.Mix.TitleManagement.Service", "MixTitleManagement.ConfigureTitle", "MixTitleManagement.AddBaseVersion");
        }

        const string BASE_DIR = "SuitesData\\MixTitleManagementTest\\Mobile\\mobile{0:X}.xlast";
        const string LOC_FILE = "SuitesData\\XlastUtils\\MobileStatsColumnsLocalized.xml";
        const string TEMP_FILE = "SuitesData\\MixTitleManagementTest\\Mobile\\xlastAfterConversion.xml";

        [TestCase, Description("Test XLAST conversion for BestScore-Descending, simple title (0x474607D6)")]
        class Convert_MobileWeb_Basic_Title_BestScore_Descending: MixTitleV2TestBase
        {
            public override void Run()
            {
                uint titleID = 0x474607D6;
                string TitlePath = String.Format(BASE_DIR, titleID);

                TestMobileTitle test1 = new TestMobileTitle(TitlePath, LOC_FILE);

                if(!test1.IsMobile)
                {
                    throw new UnexpectedTestResultException(String.Format("Title do not have Mobile (FriendsStatsView) in it - {0}", TitlePath));
                }

                test1.ConvertFromMobileToGeneralFormat();
                test1.VerifyStatsViewCount();
                test1.VerifyProperties();
                test1.VerifyLocalizedStrings();
                test1.VerifyStatsView();
            }
        }

        [TestCase, Description("Prop a simple MobileWeb title(0x474607D6) with FriendsStatsView BestScore_Descending")]
        class Prop_MobileWeb_Basic_Title_BestScore_Descending : MixTitleV2TestBase
        {
            public override void Run()
            {
                uint titleID = 0x474607D6;
                string TitlePath = String.Format(BASE_DIR, titleID);

                if (titleClient.propTitle((uint)titleID, TitlePath) != TEST_RESULTS.PASSED)
                {
                    throw new UnexpectedTestResultException("titleClient.propTitle failed");
                }
            }
        }

        [TestCase, Description("Test XLAST conversion for BestScore-Ascending, simple title (0x474607D6_Ascending)")]
        class Convert_MobileWeb_Basic_Title_BestScore_Ascending : MixTitleV2TestBase
        {
            public override void Run()
            {
                string TitlePath = String.Format(BASE_DIR, "474607D6_Ascending");

                TestMobileTitle test1 = new TestMobileTitle(TitlePath, LOC_FILE);

                if (!test1.IsMobile)
                {
                    throw new UnexpectedTestResultException(String.Format("Title do not have Mobile (FriendsStatsView) in it - {0}", TitlePath));
                }

                test1.ConvertFromMobileToGeneralFormat();
                test1.VerifyStatsViewCount();
                test1.VerifyProperties();
                test1.VerifyLocalizedStrings();
                test1.VerifyStatsView();
            }
        }

        [TestCase, Description("Prop a simple MobileWeb title(0x474607D6) with FriendsStatsView BestScore_Ascending")]
        class Prop_MobileWeb_Basic_Title_BestScore_Ascending : MixTitleV2TestBase
        {
            public override void Run()
            {
                uint titleID = 0x474607D6;
                string TitlePath = String.Format(BASE_DIR, "474607D6_Ascending");

                if (titleClient.propTitle((uint)titleID, TitlePath) != TEST_RESULTS.PASSED)
                {
                    throw new UnexpectedTestResultException("titleClient.propTitle failed");
                }
            }
        }

        [TestCase, Description("Test XLAST conversion having BestScore, BestTime and MostWins, simple title (474607D6_BS_BT_MW)")]
        class Convert_MobileWeb_Basic_Title_BestScore_BestTime_MostWins : MixTitleV2TestBase
        {
            public override void Run()
            {
                string TitlePath = String.Format(BASE_DIR, "474607D6_BS_BT_MW");

                TestMobileTitle test1 = new TestMobileTitle(TitlePath, LOC_FILE);

                if (!test1.IsMobile)
                {
                    throw new UnexpectedTestResultException(String.Format("Title do not have Mobile (FriendsStatsView) in it - {0}", TitlePath));
                }

                test1.ConvertFromMobileToGeneralFormat();
                test1.VerifyStatsViewCount();
                test1.VerifyProperties();
                test1.VerifyLocalizedStrings();
                test1.VerifyStatsView();
            }
        }

        [TestCase, Description("Prop a simple MobileWeb title(0x474607D6) with FriendsStatsView BestScore_BestTime_MostWins")]
        class Prop_MobileWeb_Basic_Title_BestScore_BestTime_MostWins : MixTitleV2TestBase
        {
            public override void Run()
            {
                string TitlePath = String.Format(BASE_DIR, "474607D6_BS_BT_MW");

                if (titleClient.propTitle((uint)0x474607D6, TitlePath) != TEST_RESULTS.PASSED)
                {
                    throw new UnexpectedTestResultException("titleClient.propTitle failed");
                }
            }
        }

        [TestCase, Description("Test XLAST conversion haing BestScore BestTime Ascending Descending, complex case (0x4541092D)")]
        class Convert_MobileWeb_Complex_Title_BestScore_BestTime_Ascending_Descending: MixTitleV2TestBase
        {
            public override void Run()
            {
                uint titleID = 0x4541092D;
                string TitlePath = String.Format(BASE_DIR, titleID);

                TestMobileTitle test1 = new TestMobileTitle(TitlePath, LOC_FILE);

                if (!test1.IsMobile)
                {
                    throw new UnexpectedTestResultException(String.Format("Title do not have Mobile (FriendsStatsView) in it - {0}", TitlePath));
                }

                test1.ConvertFromMobileToGeneralFormat();
                test1.VerifyStatsViewCount();
                test1.VerifyProperties();
                test1.VerifyLocalizedStrings();
                test1.VerifyStatsView();
            }
        }

        [TestCase, Description("Prop a complex MobileWeb title(0x4541092D) with FriendsStatsView BestScore BestTime Ascending Descending")]
        class Prop_MobileWeb_Complex_Title_BestScore_BestTime_Ascending_Descending : MixTitleV2TestBase
        {
            public override void Run()
            {
                uint titleID = 0x4541092D;
                string TitlePath = String.Format(BASE_DIR, titleID);


                if (titleClient.propTitle(titleID, TitlePath) != TEST_RESULTS.PASSED)
                {
                    throw new UnexpectedTestResultException("titleClient.propTitle failed");
                }
            }
        }

        [TestCase, Description("Test XLAST conversion from Mobile having BestScore BestTime MostWins, complex case (0x4541092D_MostWins)")]
        class Convert_MobileWeb_Complex_Title_BestScore_BestTime_MostWins : MixTitleV2TestBase
        {
            public override void Run()
            {                
                string TitlePath = String.Format(BASE_DIR, "4541092D_MostWins");

                TestMobileTitle test1 = new TestMobileTitle(TitlePath, LOC_FILE);

                if (!test1.IsMobile)
                {
                    throw new UnexpectedTestResultException(String.Format("Title do not have Mobile (FriendsStatsView) in it - {0}", TitlePath));
                }

                test1.ConvertFromMobileToGeneralFormat();
                test1.VerifyStatsViewCount();
                test1.VerifyProperties();
                test1.VerifyLocalizedStrings();
                test1.VerifyStatsView();
            }
        }

        [TestCase, Description("Prop a complex MobileWeb title(4541092D_MostWins) with FriendsStatsView BestScore BestTime MostWins")]
        class Prop_MobileWeb_Complex_Title_BestScore_BestTime_MostWins : MixTitleV2TestBase
        {
            public override void Run()
            {
                uint titleID = 0x4541092D;
                string TitlePath = String.Format(BASE_DIR, "4541092D_MostWins");


                if (titleClient.propTitle(titleID, TitlePath) != TEST_RESULTS.PASSED)
                {
                    throw new UnexpectedTestResultException("titleClient.propTitle failed");
                }
            }
        }

        [TestCase, Description("Test XLAST conversion from Mobile having invalid FriendsStatsView data (mobile474607D6_invalidOutcome.xlast)")]
        class Negative_Convert_MobileWeb_Complex_Title_Invalid_Outcome : MixTitleV2TestBase
        {
            public override void Run()
            {
                string TitlePath = String.Format(BASE_DIR, "474607D6_invalidOutcome");

                TestMobileTitle test1 = new TestMobileTitle(TitlePath, LOC_FILE);

                if (!test1.IsMobile)
                {
                    throw new UnexpectedTestResultException(String.Format("Title do not have Mobile (FriendsStatsView) in it - {0}", TitlePath));
                }

                try
                {
                    test1.ConvertFromMobileToGeneralFormat();
                }
                catch (Exception)
                {
                    return;
                }

                throw new Exception("The invalid <bestOutcome> in the XLAST did not throw any Exception");
            }
        }

        [TestCase, Description("Test XLAST conversion from Mobile having invalid ID (greater than 0x7FFFFFF) in FriendsStatsView data (mobile474607D6_invalidMaxID.xlast)")]
        class Negative_Convert_MobileWeb_Complex_Title_Invalid_id : MixTitleV2TestBase
        {
            public override void Run()
            {
                string TitlePath = String.Format(BASE_DIR, "474607D6_invalidMaxID");

                TestMobileTitle test1 = new TestMobileTitle(TitlePath, LOC_FILE);

                if (!test1.IsMobile)
                {
                    throw new UnexpectedTestResultException(String.Format("Title do not have Mobile (FriendsStatsView) in it - {0}", TitlePath));
                }

                try
                {
                    test1.ConvertFromMobileToGeneralFormat();
                }
                catch (Exception)
                {
                    return;
                }

                throw new Exception("The invalid <id> in the XLAST did not throw any Exception");
            }
        }

        [TestCase, Description("Test XLAST conversion from Mobile having duplicate id in FriendsStatsView data (mobile474607D6_duplicateID.xlast)")]
        class Negative_Convert_MobileWeb_Complex_Title_Duplicate_ID : MixTitleV2TestBase
        {
            public override void Run()
            {
                string TitlePath = String.Format(BASE_DIR, "474607D6_duplicateID");

                TestMobileTitle test1 = new TestMobileTitle(TitlePath, LOC_FILE);

                if (!test1.IsMobile)
                {
                    throw new UnexpectedTestResultException(String.Format("Title do not have Mobile (FriendsStatsView) in it - {0}", TitlePath));
                }

                try
                {
                    test1.ConvertFromMobileToGeneralFormat();
                }
                catch (Exception)
                {
                    return;
                }

                throw new Exception("Duplicate <id> in the XLAST did not throw any Exception");
            }
        }

        //Tests to prop using MIxTitleManagementAPI and ConfigureLeaderboard using MixStats API

        [TestCase, Description("V2 TitleManagement Prop and deploy a simple MobileWeb title(0x474607D6) with FriendsStatsView BestScore_Descending")]
        class V2_Prop_And_ConfigureLeaderboard_MobileWeb_Basic_Title_BestScore_Descending : MixTitleV2TestBase
        {
            public override void Run()
            {
                uint titleID = 0x474607D6;
                string TitlePath = String.Format(BASE_DIR, titleID);

                TestMobileTitle test1 = new TestMobileTitle(TitlePath, LOC_FILE);
                // Conver the Mobile XLAST to General format XLAST and save the converted XML it in TEMP_FILE.
                test1.ConvertFromMobileToGeneralFormat();
                test1.SaveConvertedFile(TEMP_FILE);

                //Prop and make sure the title is available to configure leaderboard data next
                if (titleClient.propTitle_WithoutCleaning((uint)titleID, TitlePath) != TEST_RESULTS.PASSED)
                {
                    throw new UnexpectedTestResultException("titleClient.propTitle failed");
                }

                // Clear db of any tables/sprocs from previous runs
                base.statsClient.ClearDB(titleID);

                // Deploy the title using MIX API
                base.statsClient.ConfigureLeaderboards(titleID);

                TEST_RESULTS tr = TEST_RESULTS.FAILED;

                tr = statsClient.VerifyXbox360StatsData(titleID, TEMP_FILE, true);

                base.statsClient.DeleteLeaderboards(titleID);

                if (tr != TEST_RESULTS.PASSED)
                {
                    throw new UnexpectedTestResultException("VerifyXbox360StatsData failed");
                }
            }
        }

        [TestCase, Description("V2 TitleManagement Prop and deploy simple MobileWeb title with BestScore BestTime MostWins(mobile474607D6_BS_BT_MW.xlast)")]
        class V2_Prop_And_ConfigureLeaderboard_MobileWeb_Basic_Title_BestScore_BestTime_MostWins : CnGWCFTestBase
        {
            public override void Run()
            {
                TitleManagementV2WCFClient titleClient = new TitleManagementV2WCFClient();
                uint titleID = 0x474607D6;
                string TitlePath = String.Format(BASE_DIR, "474607D6_BS_BT_MW");

                TestMobileTitle test1 = new TestMobileTitle(TitlePath, LOC_FILE);
                // Conver the Mobile XLAST to General format XLAST and save the converted XML it in TEMP_FILE.
                test1.ConvertFromMobileToGeneralFormat();
                test1.SaveConvertedFile(TEMP_FILE);

                if (titleClient.propTitle_WithoutCleaning((uint)titleID, TitlePath) != TEST_RESULTS.PASSED)
                {
                    throw new UnexpectedTestResultException("titleClient.propTitle failed");
                }

                // Clear db of any tables/sprocs from previous runs
                base.statsClient.ClearDB(titleID);
                // Deploy the title using MIX API
                base.statsClient.ConfigureLeaderboards(titleID);

                TEST_RESULTS tr = TEST_RESULTS.FAILED;

                tr = statsClient.VerifyXbox360StatsData(titleID, TEMP_FILE, true);

                base.statsClient.DeleteLeaderboards(titleID);

                if (tr != TEST_RESULTS.PASSED)
                {
                    throw new UnexpectedTestResultException("VerifyXbox360StatsData failed");
                }
            }
        }

        [TestCase, Description("V2 TitleManagement Prop and deploy complex MobileWeb title with BestScore BestTime MostWins(mobile4541092D_MostWins.xlast)")]
        class V2_Prop_And_ConfigureLeaderboard_MobileWeb_Complex_Title_BestScore_BestTime_MostWins : CnGWCFTestBase
        {
            public override void Run()
            {
                TitleManagementV2WCFClient titleClient = new TitleManagementV2WCFClient();
                uint titleID = 0x4541092D;
                string TitlePath = String.Format(BASE_DIR, "4541092D_MostWins");

                TestMobileTitle test1 = new TestMobileTitle(TitlePath, LOC_FILE);
                // Conver the Mobile XLAST to General format XLAST and save the converted XML it in TEMP_FILE.
                test1.ConvertFromMobileToGeneralFormat();
                test1.SaveConvertedFile(TEMP_FILE);

                if (titleClient.propTitle_WithoutCleaning((uint)titleID, TitlePath) != TEST_RESULTS.PASSED)
                {
                    throw new UnexpectedTestResultException("titleClient.propTitle failed");
                }

                // Clear db of any tables/sprocs from previous runs
                base.statsClient.ClearDB(titleID);
                // Deploy the title using MIX API
                base.statsClient.ConfigureLeaderboards(titleID);

                TEST_RESULTS tr = TEST_RESULTS.FAILED;

                tr = statsClient.VerifyXbox360StatsData(titleID, TEMP_FILE, true);

                base.statsClient.DeleteLeaderboards(titleID);

                if (tr != TEST_RESULTS.PASSED)
                {
                    throw new UnexpectedTestResultException("VerifyXbox360StatsData failed");
                }
            }
        }

        [TestCase, Description("V1 TitleManagement Prop and deploy a simple MobileWeb title(0x474607D6) with FriendsStatsView BestScore_Descending")]
        class V1_Prop_And_ConfigureLeaderboard_MobileWeb_Basic_Title_BestScore_Descending : CnGWCFTestBase
        {
            public override void Run()
            {
                TitleManagementWCFClient titleClient = new TitleManagementWCFClient();
                uint titleID = 0x474607D6;
                string TitlePath = String.Format(BASE_DIR, titleID);

                TestMobileTitle test1 = new TestMobileTitle(TitlePath, LOC_FILE);
                // Conver the Mobile XLAST to General format XLAST and save the converted XML it in TEMP_FILE.
                test1.ConvertFromMobileToGeneralFormat();
                test1.SaveConvertedFile(TEMP_FILE);

                //Prop the title using
                byte[] compressedXlast = titleClient.CompressXlast(titleClient.GetXlast(TEMP_FILE));
                titleClient.AddBaseVersion(titleID, 0, xonline.mix.titlemanagement.contracts.V1.PlatformType.Xenon);
                titleClient.ConfigureTitle(compressedXlast);

                // Clear db of any tables/sprocs from previous runs
                base.statsClient.ClearDB(titleID);

                // Deploy the title using MIX API
                base.statsClient.ConfigureLeaderboards(titleID);

                TEST_RESULTS tr = TEST_RESULTS.FAILED;

                tr = statsClient.VerifyXbox360StatsData(titleID, TEMP_FILE, true);

                base.statsClient.DeleteLeaderboards(titleID);

                if (tr != TEST_RESULTS.PASSED)
                {
                    throw new UnexpectedTestResultException("VerifyXbox360StatsData failed");
                }
            }
        }

        [TestCase, Description("V1 TitleManagement Prop and deploy complex MobileWeb title with BestScore BestTime MostWins(mobile4541092D_MostWins.xlast)")]
        class V1_Prop_And_ConfigureLeaderboard_MobileWeb_Complex_Title_BestScore_BestTime_MostWins : CnGWCFTestBase
        {
            public override void Run()
            {
                TitleManagementWCFClient titleClient = new TitleManagementWCFClient();

                uint titleID = 0x4541092D;
                string TitlePath = String.Format(BASE_DIR, "4541092D_MostWins");

                TestMobileTitle test1 = new TestMobileTitle(TitlePath, LOC_FILE);
                // Convert the Mobile XLAST to General format XLAST and save the converted XML it in TEMP_FILE.
                test1.ConvertFromMobileToGeneralFormat();
                test1.SaveConvertedFile(TEMP_FILE);

                //Prop the title using
                byte[] compressedXlast = titleClient.CompressXlast(titleClient.GetXlast(TEMP_FILE));
                titleClient.AddBaseVersion(titleID, 0, xonline.mix.titlemanagement.contracts.V1.PlatformType.Xenon);
                titleClient.ConfigureTitle(compressedXlast);

                // Clear db of any tables/sprocs from previous runs
                base.statsClient.ClearDB(titleID);
                // Deploy the title using MIX API
                base.statsClient.ConfigureLeaderboards(titleID);

                TEST_RESULTS tr = TEST_RESULTS.FAILED;

                tr = statsClient.VerifyXbox360StatsData(titleID, TEMP_FILE, true);

                base.statsClient.DeleteLeaderboards(titleID);

                if (tr != TEST_RESULTS.PASSED)
                {
                    throw new UnexpectedTestResultException("VerifyXbox360StatsData failed");
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Test\TokenManagementManualTest\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Test\TokenManagementManualTest\TestSuite.cs ===
using System;
using System.Xml;

using ServerTestFramework;

namespace TokenManagementManualTest
{
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Test\TokenManagementManualTest\GenerateTokensLargeTests.cs ===
ï»¿using System;
using System.Collections;
using System.Collections.Generic;
using System.ServiceModel;
using System.Runtime.Serialization;
using System.IO;
using System.Threading;
using System.Xml;
using System.Text;
using System.Text.RegularExpressions;
using System.Net;
using System.Security.Cryptography;

using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.LiveService;
using ServerTestFramework.Utilities;

using xonline.common.config;
using MIXTesting;
using xonline.mix.tokenmanagement.contracts.V1;
using xonline.mix.common;

namespace MixTest
{
    /// <summary>
    /// Call Mix GenerateTakens API with large number of tokens.
    /// The tests will run for a long time and should be run only manually.
    /// </summary>
    [TestGroup, Owner("yuanfeiw"), TestCasePriority(2), TestFrequency("Regression"), EnvRequirement("Manual"), Description("Mix TokenInfo Tests")]
    public class GenerateTokensLargeTests : TestNode
    {
        [Description("GenerateTokens - create 3 jobs 10 million tokens each and generate 30 million tokens total")]
        class P_GenerateTokens_30Million : WCFTestBase
        {
            public override void Run()
            {
                DateTime startTime = DateTime.UtcNow;
                Global.RO.Warn("Start the long running test");

                // first 10 million tokens for first TC
                Guid jobId1 = MixTokenHelper.GenerateTestTokens(MixTokenHelper.GlobalTC.TokenCategoryId, 10000000, MixTokenHelper.Key, true, false);

                // second 10 million tokens for second TC
                TokenCategory tc2 = MixTokenHelper.NewTokenCategory();
                TokenManagementWCFClient client = new TokenManagementWCFClient();
                client.ConfigureTokenCategory(tc2);
                Guid jobId2 = MixTokenHelper.GenerateTestTokens(tc2.TokenCategoryId, 10000000, MixTokenHelper.Key, false, false);

                // third 10 million tokens for first TC again
                Guid jobId3 = MixTokenHelper.GenerateTestTokens(MixTokenHelper.GlobalTC.TokenCategoryId, 10000000, MixTokenHelper.Key, false, false);

                // wait until all 3 jobs are done. Max wait time is 10000 * 5 = 50,000 seconds, 13.9 hours.
                MixTokenHelper.WaitOnTokenJobs(new Guid[] { jobId1, jobId2, jobId3 }, 10000);

                TimeSpan timeTook = DateTime.UtcNow - startTime;
                Global.RO.Warn("The long running test is done. Execution time = {0}", timeTook.ToString());
            }
        }

        [TestCase, Owner("shwetap"), TestCasePriority(2), TestFrequency("Regression"), EnvRequirement("XblobOnly")]
        [Description("GenerateTokens - Concurrent test: 30 pending token jobs(numTokens = 40)")]
        class P_Concurent_GenerateTokens_40_30PendingJobs : WCFTestBase
        {
            public override void Run()
            {
                Guid[] jobId = MixTokenHelper.GenerateTestTokens(MixTokenHelper.GlobalTC.TokenCategoryId, 40, MixTokenHelper.Key, true, 30, 0, 15000, false);
                for (int i = 0; i < jobId.Length; i++)
                {
                    Global.RO.Warn("=== Verify Job #{0}/{1} ===", i, jobId.Length);
                    TokenEntry[] tokens = MixTokenHelper.GetTokenEntries(jobId[i], MixTokenHelper.Key);
                    MixTokenHelper.VerifyTokens(40, tokens, MixTokenHelper.GlobalTC);
                }
            }
        }

        [TestCase, Owner("shwetap"), TestCasePriority(2), TestFrequency("Regression"), EnvRequirement("XblobOnly")]
        [Description("GenerateTokens - Concurrent tes: 15 pending and 15 stale token jobs(numTokens = 40)")]
        class P_Concurent_GenerateTokens_40_15PendingJobs_15StaleJobs : WCFTestBase
        {
            public override void Run()
            {
                Guid[] jobId = MixTokenHelper.GenerateTestTokens(MixTokenHelper.GlobalTC.TokenCategoryId, 40, MixTokenHelper.Key, true, 15, 15, 25000, false);
                for (int i = 0; i < jobId.Length; i++)
                {
                    Global.RO.Warn("=== Verify Job #{0}/{1} ===", i, jobId.Length);
                    TokenEntry[] tokens = MixTokenHelper.GetTokenEntries(jobId[i], MixTokenHelper.Key);
                    MixTokenHelper.VerifyTokens(40, tokens, MixTokenHelper.GlobalTC);
                }
            }
        }

        //This Test cannot be run in parallel with other test as it changes the number of Cron Jobs running concurrently
        [TestCase, Owner("shwetap"), TestCasePriority(2), TestFrequency("Regression"), EnvRequirement("XblobOnly")]
        [Description("GenerateTokens - Concurrent test: 15 pending and 15 stale token jobs(numTokens = 40 and numOfBuckets = 10)")]
        class P_Concurent_GenerateTokens_40_15PendingJobs_15StaleJobs_10Buckets : WCFTestBase
        {
            public override void Run()
            {
                try
                {
                    MixTokenHelper.IncreaseNumberOfBucket(10);
                    Guid[] jobId = MixTokenHelper.GenerateTestTokens(MixTokenHelper.GlobalTC.TokenCategoryId, 40, MixTokenHelper.Key, true, 15, 15, 15000, false);
                    for (int i = 0; i < jobId.Length; i++)
                    {
                        Global.RO.Warn("=== Verify Job #{0}/{1} ===", i, jobId.Length);
                        TokenEntry[] tokens = MixTokenHelper.GetTokenEntries(jobId[i], MixTokenHelper.Key);
                        MixTokenHelper.VerifyTokens(40, tokens, MixTokenHelper.GlobalTC);
                    }
                }
                finally
                {
                    MixTokenHelper.RevertBackNumberOfBucket();
                }
            }
        }

        /// <summary>
        /// For a Failed Job verify between each reprocessing there is an exponential delay which is done by comparing the next Processing date returned by
        /// GetTokenJobStatus API with the expected value for each retry.
        /// </summary>
        [TestCase, Owner( "shwetap" ), TestCasePriority( 1 ), TestFrequency( "Regression" ), EnvRequirement( "XblobOnly" )]
        [Description( "GetTokenJobStatus - validate exponential delay between each reprocessing of a failed job" )]
        class P_GetTokenJobStatus_Exponential_Delay : WCFTestBase
        {
            public override void Run()
            {
                try
                {
                    Guid jobId = MixTokenHelper.GenerateTestTokens( MixTokenHelper.GlobalTC.TokenCategoryId, 1, MixTokenHelper.Key, true, false );
                    StaticNpdb.ExecuteNonQuery( String.Format( @"UPDATE [dbo].[t_token_jobs] SET vc_output_path = 'q:\Invalid.txt' WHERE uid_job_id = '{0}'", jobId ) );

                    //Disable Cron
                    MixTokenHelper.DisableCron();

                    DateTime processingStartDate = DateTime.Now;
                    DateTime processingEndDate = processingStartDate.AddMinutes( 2 );
                    DateTime expectedNextProcessingDate;
                    double delayBaseNumber = Convert.ToDouble( Global.XEnv.GetSetting( Setting.tokenService_delayBaseNumber ) );
                    double delayExponentFactor = Convert.ToDouble( Global.XEnv.GetSetting( Setting.tokenService_delayExponentFactor ) );
                    string errorMsg = "Could not find a part of the path.";
                    int hresult = -2146090496;

                    TokenManagementWCFClient client;
                    TokenJobStatus tokenJobStatus;

                    for ( int retry = 1; retry <= 20; retry++ )
                    {
                        Guid jobHistoryId = Guid.NewGuid();
                        StaticNpdb.ExecuteNonQuery( String.Format( "INSERT INTO [dbo].[t_token_job_history] VALUES ('{0}','{1}',{2},'{3}','{4}','{5}')", jobHistoryId, jobId, hresult, errorMsg, processingStartDate, processingEndDate ) );
                        double delay = Math.Pow( delayBaseNumber, ( retry * delayExponentFactor ) );
                        expectedNextProcessingDate = processingEndDate.AddMinutes( Math.Truncate( delay ) );
                        client = new TokenManagementWCFClient();
                        tokenJobStatus = client.GetTokenJobStatus( jobId );

                        if ( expectedNextProcessingDate.ToString() != tokenJobStatus.NextProcessing.ToString() )
                        {
                            throw new UnexpectedTestResultException( String.Format( "Actual nextProcessing returned by GetTokenJobStatus: {0} is not equal to expected one: {1} for {2} retry", tokenJobStatus.NextProcessing, expectedNextProcessingDate, retry ) );
                        }

                        //Compute the next dates for next retry
                        processingStartDate = processingEndDate.AddMinutes( Math.Truncate( delay ) );
                        processingEndDate = processingStartDate.AddMinutes( 2 );
                    }
                }
                finally
                {
                    //Enable Cron
                    MixTokenHelper.EnableCron();
                }
            }
        }

        /// <summary>
        /// For a Failed job verify its abandon from future processing and moved to failed state within a defined threshold.
        /// Verify Number of failures returned by GetTokenJobStatus API is equal number of failures in t_token_job_history which is then equal to tokenService_maxFailureThreshold value
        /// </summary>
        [TestCase, Owner( "shwetap" ), TestCasePriority( 1 ), TestFrequency( "Regression" ), EnvRequirement( "XblobOnly" )]
        [Description( "GetTokenJobStatus - Max Threshold Validation,  Number of Fail Jobs = 1" )]
        class P_GetTokenJobStatus_Max_Threshold_Validation : WCFTestBase
        {
            public override void Run()
            {
                SettingState oldState = new SettingState();
                try
                {
                    uint newMaxThreshold = 2;

                    //override npdb setting tokenService_maxFailureThreshold = 2
                    oldState = Global.XEnv.OverrideSetting( Component.cron, "ALL", Setting.tokenService_maxFailureThreshold, newMaxThreshold.ToString(), -1 );
                    Global.XEnv.ExecuteXmgmtCommand( Interface.cron_int, "e :cron configcacherefresh" );
                    System.Threading.Thread.Sleep( 3000 );

                    Guid jobId = MixTokenHelper.GenerateTestTokens( MixTokenHelper.GlobalTC.TokenCategoryId, 1, MixTokenHelper.Key, true, false );

                    StaticNpdb.ExecuteNonQuery( String.Format( @"UPDATE [dbo].[t_token_jobs] SET vc_output_path = 'q:\Invalid.txt' WHERE uid_job_id = '{0}'", jobId ) );
                    uint[] numOfFailures = MixTokenHelper.WaitOnFailedTokenJob( new Guid[] { jobId }, 1000 );

                    TokenManagementWCFClient client = new TokenManagementWCFClient();
                    TokenJobStatus tokenJobStatus = client.GetTokenJobStatus( jobId );

                    MixTokenHelper.ThresholdValidation( numOfFailures, newMaxThreshold, new Guid[] { jobId } );
                }
                finally
                {
                    // make the npdb settings back to default values
                    if ( oldState.wasoverriden )
                    {
                        Global.XEnv.OverrideSetting( Component.cron, "ALL", Setting.tokenService_maxFailureThreshold, oldState.oldvalue, -1 );
                    }
                    else
                    {
                        Global.XEnv.DeleteOverrideSetting( Component.cron, "ALL", Setting.tokenService_maxFailureThreshold, -1 );
                    }
                    Global.XEnv.ExecuteXmgmtCommand( Interface.cron_int, "e :cron configcacherefresh" );
                }
            }
        }

        /// <summary>
        /// Submits 3 Failed job and 1 Passing Job
        /// Verify all the Failed Jobs are abandon from future processing and moved to failed state within a defined threshold.
        /// For all failed job verify Number of failures returned by GetTokenJobStatus API is equal number of failures in t_token_job_history which is then equal to tokenService_maxFailureThreshold value
        /// Passing job is delivered properly
        /// </summary>
        [TestCase, Owner( "shwetap" ), TestCasePriority( 2 ), TestFrequency( "Regression" ), EnvRequirement( "XblobOnly" )]
        [Description( "GetTokenJobStatus - Max Threshold Validation, Number of Fail Jobs = 3, Number of Passing Job = 1" )]
        class P_GetTokenJobStatus_MultiJob_Threshold_Validation : WCFTestBase
        {
            public override void Run()
            {
                SettingState oldState = new SettingState();
                try
                {
                    uint newMaxThreshold = 1;

                    //override npdb setting tokenService_maxFailureThreshold = 1
                    oldState = Global.XEnv.OverrideSetting( Component.cron, "ALL", Setting.tokenService_maxFailureThreshold, newMaxThreshold.ToString(), -1 );
                    Global.XEnv.ExecuteXmgmtCommand( Interface.cron_int, "e :cron configcacherefresh" );
                    System.Threading.Thread.Sleep( 3000 );

                    Guid[] failJobs = new Guid[3];

                    TokenCategory tc1 = MixTokenHelper.NewTokenCategory();
                    TokenManagementWCFClient client = new TokenManagementWCFClient();
                    client.ConfigureTokenCategory( tc1 );

                    for ( int i = 0; i < 3; i++ )
                    {
                        failJobs[i] = MixTokenHelper.GenerateTestTokens( tc1.TokenCategoryId, 1, MixTokenHelper.Key, true, false );
                        StaticNpdb.ExecuteNonQuery( String.Format( @"UPDATE [dbo].[t_token_jobs] SET vc_output_path = 'q:\Invalid.txt' WHERE uid_job_id = '{0}'", failJobs[i] ) );
                    }

                    uint[] numOfFailures = MixTokenHelper.WaitOnFailedTokenJob( tc1.TokenCategoryId, 5000 );

                    Guid passJob = MixTokenHelper.GenerateTestTokens( tc1.TokenCategoryId, 1, MixTokenHelper.Key, true, false );

                    TokenEntry[] tokens = MixTokenHelper.GetTokenEntries( passJob, MixTokenHelper.Key );
                    MixTokenHelper.VerifyTokens( 1, tokens, tc1 );

                    MixTokenHelper.ThresholdValidation( numOfFailures, newMaxThreshold, failJobs );
                }
                finally
                {
                    // make the npdb settings back to default values
                    if ( oldState.wasoverriden )
                    {
                        Global.XEnv.OverrideSetting( Component.cron, "ALL", Setting.tokenService_maxFailureThreshold, oldState.oldvalue, -1 );
                    }
                    else
                    {
                        Global.XEnv.DeleteOverrideSetting( Component.cron, "ALL", Setting.tokenService_maxFailureThreshold, -1 );
                    }
                    Global.XEnv.ExecuteXmgmtCommand( Interface.cron_int, "e :cron configcacherefresh" );
                }
            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Test\TokenManagementTest\TestSuite.cs ===
using System;
using System.Xml;

using ServerTestFramework;

namespace TokenManagementTest
{
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Test\TokenManagementTest\GetTokensTests.cs ===
ï»¿using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.ServiceModel;
using System.Runtime.Serialization;
using System.IO;
using System.IO.Compression;
using System.Net;
using System.Security.Cryptography;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;
using System.Xml;

using ServerTestFramework;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.LiveService;
using ServerTestFramework.Utilities;
using ServerTestFramework.Database;

using xonline.common.config;
using MIXTesting;
using xonline.mix.tokenmanagement.contracts.V1;
using xonline.mix.common;

namespace MixTest
{
    /// <summary>
    /// This test group covers GetTokens tests
    /// </summary>
    [TestGroup, Owner("yuanfeiw"), TestCasePriority(1), TestFrequency("Regression"), EnvRequirement(""), Description("Mix GetTokens API Tests")]
    public class GetTokensTests : TestNode
    {
        #region OneTime Setup
        public override void OneTimeSetup()
        {
            // lower cron job execution interval from 120 seconds to 50 seconds
            StaticNpdb.ExecuteNonQuery("update dbo.t_cron_jobs set i_exec_interval_secs = 50 where vc_assembly = 'TokenGeneratePlugIns.dll'");
        }
        #endregion

        #region Helper Functions

        #region Generate Tokens
        private static Guid GenerateTokens(int tokenNum, ref TokenEntry[] tokens)
        {
            Guid jobId = MixTokenHelper.GenerateTestTokens(MixTokenHelper.GlobalTC.TokenCategoryId, (uint)tokenNum, MixTokenHelper.Key, true, false);
            tokens = MixTokenHelper.GetTokenEntries(jobId, MixTokenHelper.Key);
            //MixTokenHelper.VerifyTokens(tokenNum, tokens, MixTokenHelper.GlobalTC);

            return jobId;
        }
        #endregion

        #region GetTokens
        private static void GetTokens(int count, int start, int total, int totalCalls)
        {
            TokenManagementWCFClient client = new TokenManagementWCFClient();
            Stopwatch stopWatch = new Stopwatch();
            uint expectedHResult = HResult.S_OK;
            bool expectedRetryable = false;

            TokenEntry[] preEncryptionTokens = new TokenEntry[total];
            //Xonline.Mix.TokenManagement.Contract.TokenEntry[] decryptedTokens;
            xonline.mix.tokenmanagement.contracts.V1.TokenEntry[] decryptedTokens;
            Guid jobId = GenerateTokens(total, ref preEncryptionTokens);

            int tokenCountRetrieved = 0;
            int currCall = 0;
            while ((currCall < totalCalls))
            {
                stopWatch.Reset();
                stopWatch.Start();
                decryptedTokens = client.GetTokens(jobId, MixTokenHelper.Key, start + (count * currCall), count, expectedHResult, expectedRetryable);
                stopWatch.Stop();

                GetHeuristics(total, count, start + (count * currCall), stopWatch.Elapsed);
                tokenCountRetrieved += count;

                CompareTokenArrays(preEncryptionTokens, decryptedTokens, start + (count * currCall), count);
                currCall++;
                // we have retrieved all the tokens requested, get out of here
                if (tokenCountRetrieved >= total)
                {
                    break;
                }
            }
        }
        #endregion

        #region Compare TokenArrays
        private static void CompareTokenArrays(TokenEntry[] preEncryptionTokens, xonline.mix.tokenmanagement.contracts.V1.TokenEntry[] decryptedTokens, int start, int count)
        {
            string msg = string.Empty;

            for (int i = 0; i < count; i++)
            {
                if ((preEncryptionTokens[(start + i) - 1].Pkpn != decryptedTokens[i].Pkpn) ||
                   (Convert.ToUInt32(preEncryptionTokens[(start + i) - 1].SequenceNumber) != decryptedTokens[i].SequenceNumber) ||
                   (preEncryptionTokens[(start + i) - 1].Token != decryptedTokens[i].Token))
                {
                    msg = string.Format("\r\nToken Mismatch Found\r\n   Pre-encrpted Token {0}:\r\n   Token: {1}\r\n   Pkpn: {2}\r\nSequence: {3}\r\n\r\n   Decrypted Token {4}:\r\n   Token: {5}\r\n   Pkpn: {6}\r\nSequence: {7}\r\n",
                                         i, preEncryptionTokens[(start + i) - 1].Token, preEncryptionTokens[(start + i) - 1].Pkpn, preEncryptionTokens[(start + i) - 1].SequenceNumber,
                                         i, decryptedTokens[i].Token, decryptedTokens[i].Pkpn, decryptedTokens[i].SequenceNumber);
                    throw new UnexpectedTestResultException(msg);
                };
            }
            msg = string.Format("\r\nTokens in pre-encrypted and decrypted arrays match");
            Global.RO.Warn(msg);
        }
        #endregion

        #region GetHeuristics
        private static void GetHeuristics(int totalTokens, int retrievedTokens, int startLocation, TimeSpan ts)
        {
            string msg = string.Format("\r\nTotal tokens in file: {0}\r\nTokens retrieved: {1}\r\nStart location: {2}", totalTokens, retrievedTokens, startLocation);

            Global.RO.Warn(msg);

            GetElapsedTime(ts, startLocation, retrievedTokens, totalTokens);
        }
        #endregion

        #region Get Elapsed Time
        private static void GetElapsedTime(TimeSpan ts, int start, int count, int total)
        {
            string elapsedTime = String.Format("{0:00}:{1:00}:{2:00}.{3:00}",
                ts.Hours, ts.Minutes, ts.Seconds,
                ts.Milliseconds / 10);

            string appPath = System.IO.Directory.GetCurrentDirectory();
            DirectoryInfo di = new DirectoryInfo(string.Format(@"{0}\FuncOutput\GetTokensTests", appPath));
            if (!di.Exists)
            {
                di.Create();
            }
            string outputPath = string.Format(@"{0}\benchmarks.txt", di.FullName);


            StreamWriter sw = new StreamWriter(outputPath, true);
            sw.WriteLine(string.Format("Get {0} Token(s) From {1} Token File, staring at {2}: {3}", count, total, start, elapsedTime));
            sw.Close();

            Global.RO.Warn(string.Format("Elapsed Time: {0}", elapsedTime));
        }
        #endregion

        #endregion

        #region Positive Tests

        #region Get 5 token(s) from token file containing 50 token(s), CallAmount 5
        [TestCase, Description("Posative: Get 5 token(s) from token file containing 50 token(s), CallAmount 5")]
        class Get5Tokens_From50TokenFile_CallAmount5 : WCFTestBase
        {
            public override void Run()
            {
                int count = 5;
                int start = 1;
                int total = 50;
                int callCount = 5;

                GetTokens(count, start, total, callCount);
            }
        }
        #endregion

        #region Get 1000 token(s) from token file containing 10000 token(s), CallAmount 5
        [TestCase, Description("Posative: Get 1000 token(s) from token file containing 10000 token(s), CallAmount 5")]
        class Get1000Tokens_From10000TokenFile_CallAmount5 : WCFTestBase
        {
            public override void Run()
            {
                int count = 1000;
                int start = 3000;
                int total = 10000;
                int callCount = 5;

                GetTokens(count, start, total, callCount);
            }
        }
        #endregion

        #region Get 1000 token(s) from token file containing 1000 token(s), CallAmount 1, Count 1
        [TestCase, Description("Positive: Get 1000 token(s) from token file containing 1000 token(s), CallAmount 1, Count 1")]
        class Get1000Tokens_From1000TokenFile_CallAmount1_Count1 : WCFTestBase
        {
            public override void Run()
            {
                int count = 1000;
                int start = 0001;
                int total = 1000;
                int callCount = 1;

                GetTokens(count, start, total, callCount);
            }
        }
        #endregion

        #region Get 1000 token(s) from token file containing 1000 token(s), CallAmount 10, Count 100
        [TestCase, Description("Positive: Get 1000 token(s) from token file containing 1000 token(s), CallAmount 10, Count 100")]
        class Get1000Tokens_From1000TokenFile_CallAmount10_Count100 : WCFTestBase
        {
            public override void Run()
            {
                int count = 100;
                int start = 0001;
                int total = 1000;
                int callCount = 10;

                GetTokens(count, start, total, callCount);
            }
        }
        #endregion

        #region Get 1000 token(s) from token file containing 1000 token(s) Boundary, CallAmount 10, Count 1000
        [TestCase, Description("Positive: Get 1000 token(s) from token file containing 1000 token(s) Boundary, CallAmount 10, Count 1000")]
        class Get1000Tokens_From1000TokenFile_CallAmount10_Count1000 : WCFTestBase
        {
            public override void Run()
            {
                int count = 1000;
                int start = 0001;
                int total = 1000;
                int callCount = 10;

                // The above CallCount of 10 will get all the 1000 tokens in first call
                // and the rest of the 9 calls are skipped.

                GetTokens(count, start, total, callCount);
            }
        }
        #endregion

        #region Get 15000 token(s) from token file containing 150000 token(s), CallAmount 1
        [TestCase, Description("Posative: Get 15000 token(s) from token file containing 150000 token(s), CallAmount 1")]
        class Get15000Tokens_From150000TokenFile_CallAmount1 : WCFTestBase
        {
            public override void Run()
            {
                int count = 15000;
                int start = 75000;
                int total = 150000;
                int callCount = 1;

                GetTokens(count, start, total, callCount);
            }
        }
        #endregion

        #region Get 15000 token(s) from token file containing 150000 token(s), CallAmount 10
        [TestCase, Description("Posative: Get 15000 token(s) from token file containing 150000 token(s), CallAmount 10")]
        class Get15000Tokens_From150000TokenFile_CallAmount10 : WCFTestBase
        {
            public override void Run()
            {
                int count = 15000;
                int start = 1;
                int total = 150000;
                int callCount = 10;

                GetTokens(count, start, total, callCount);
            }
        }
        #endregion

        #region Get 1 token from token file containing 1 token, CallAmount 1
        [TestCase, Description("Positive: Get 1 token from token file containing 1 token, CallAmount 1")]
        class P_Get1Token_From1TokenFile_CallAmount1 : WCFTestBase
        {
            public override void Run()
            {
                int count = 1;
                int start = 1;
                int total = 1;
                int callCount = 1;

                GetTokens(count, start, total, callCount);
            }
        }

        #endregion

        #endregion

        #region Negative Tests

        #region Get 5 token from token file containing 10 token, CallAmount 1 and start 11
        [TestCase, Description("Negative: Get 5 token from token file containing 10 token, CallAmount 1 and Start 11")]
        class N_Get5Token_From10TokenFile_CallAmount1_Start11 : WCFTestBase
        {
            public override void Run()
            {
                int count = 5;
                int start = 11;
                int total = 10;
               
                TokenManagementWCFClient client = new TokenManagementWCFClient();
                uint expectedHResult = HResult.XONLINE_E_TOKEN_EOF_REACHED_BEFORE_ALL_TOKENS_RETRIEVED;
                bool expectedRetryable = false;

                TokenEntry[] preEncryptionTokens = new TokenEntry[total];
                xonline.mix.tokenmanagement.contracts.V1.TokenEntry[] decryptedTokens;
                Guid jobId = GenerateTokens(total, ref preEncryptionTokens);                
                decryptedTokens = client.GetTokens(jobId, MixTokenHelper.Key, start, count, expectedHResult, expectedRetryable);
            }
        }

        #endregion

        #region Get 1 token from token file containing 1 token, CallAmount 1, Negative Start
        [TestCase, Description("Negative: Get 1 token from token file containing 1 token, CallAmount 1 and Negative start value")]
        class N_Get1Token_From1TokenFile_CallAmount1_NegativeStart : WCFTestBase
        {
            public override void Run()
            {
                int count = 1;
                int start = -1;
                int total = 1;

                TokenManagementWCFClient client = new TokenManagementWCFClient();
                uint expectedHResult = HResult.XONLINE_E_TOKEN_INVALID_START_PARAMETER;
                bool expectedRetryable = false;

                TokenEntry[] preEncryptionTokens = new TokenEntry[total];
                xonline.mix.tokenmanagement.contracts.V1.TokenEntry[] decryptedTokens;
                Guid jobId = GenerateTokens(total, ref preEncryptionTokens);
                decryptedTokens = client.GetTokens(jobId, MixTokenHelper.Key, start, count, expectedHResult, expectedRetryable);
            }
        }

        #endregion

        #region Get 1 token from token file containing 1 token, CallAmount 1, Negative count
        [TestCase, Description("Negative: Get 1 token from token file containing 1 token, CallAmount 1 and Negative count value")]
        class N_Get1Token_From1TokenFile_CallAmount1_NegativeCount : WCFTestBase
        {
            public override void Run()
            {
                int count = -1;
                int start = 1;
                int total = 1;

                TokenManagementWCFClient client = new TokenManagementWCFClient();
                uint expectedHResult = HResult.XONLINE_E_TOKEN_REQUESTED_TOKENS_EXCEEDS_MAXIMUM_ALLOWABLE;
                bool expectedRetryable = false;

                TokenEntry[] preEncryptionTokens = new TokenEntry[total];
                xonline.mix.tokenmanagement.contracts.V1.TokenEntry[] decryptedTokens;
                Guid jobId = GenerateTokens(total, ref preEncryptionTokens);
                decryptedTokens = client.GetTokens(jobId, MixTokenHelper.Key, start, count, expectedHResult, expectedRetryable);
            }
        }

        #endregion

        #region Get 1 token from token file containing 1 token, CallAmount 1, invalid jobid
        [TestCase, Description("Negative: Get 1 token from token file containing 1 token, CallAmount 1 and Invalid JobId value")]
        class N_Get1Token_From1TokenFile_CallAmount1_InvalidJobId : WCFTestBase
        {
            public override void Run()
            {
                int count = 1;
                int start = 1;
                int total = 1;

                TokenManagementWCFClient client = new TokenManagementWCFClient();
                Stopwatch stopWatch = new Stopwatch();
                uint expectedHResult = HResult.XONLINE_E_TOKEN_JOB_NOT_FOUND;
                bool expectedRetryable = false;

                TokenEntry[] preEncryptionTokens = new TokenEntry[total];
                xonline.mix.tokenmanagement.contracts.V1.TokenEntry[] decryptedTokens;

                Guid jobId = Guid.NewGuid();

                string path = MixTokenHelper.GetTokenFilePath(jobId);
                FileInfo fi = new FileInfo(path);
                if (fi.Exists)
                {
                    fi.Delete();
                }

                decryptedTokens = client.GetTokens(jobId, MixTokenHelper.Key, start, count, expectedHResult, expectedRetryable);
            }
        }
        #endregion

        #region Get 1 token from token file containing 1 token, CallAmount 1, invalid count
        [TestCase, Description("Negative: Get 1 token from token file containing 10 token, CallAmount 1 and Invalid count value")]
        class N_Get10Token_From10TokenFile_CallAmount1_InvalidCount : WCFTestBase
        {
            public override void Run()
            {
                int count = 100;
                int start = 1;
                int total = 10;

                TokenManagementWCFClient client = new TokenManagementWCFClient();
                uint expectedHResult = HResult.XONLINE_E_TOKEN_EOF_REACHED_BEFORE_ALL_TOKENS_RETRIEVED;
                bool expectedRetryable = false;

                TokenEntry[] preEncryptionTokens = new TokenEntry[total];
                xonline.mix.tokenmanagement.contracts.V1.TokenEntry[] decryptedTokens;
                Guid jobId = GenerateTokens(total, ref preEncryptionTokens);
                decryptedTokens = client.GetTokens(jobId, MixTokenHelper.Key, start, count, expectedHResult, expectedRetryable);
            }
        }
        #endregion

        #region Get 1 token from token file containing 1 token, CallAmount 1, invalid key
        [TestCase, Description("Negative: Get 1 token from token file containing 10 token, CallAmount 1 and Invalid Key value")]
        class N_Get1Token_From10TokenFile_CallAmount1_InvalidKey : WCFTestBase
        {
            public override void Run()
            {
                int count = 1;
                int start = 1;
                int total = 10;
                byte[] Key = new byte[] { 0x0, 0x1, 0x2, 0x3, 0x3, 0x3, 0x3, 0x0, 0x0, 0x0, 0xa, 0xb, 0xc, 0xd, 0xa, 0xa };

                TokenManagementWCFClient client = new TokenManagementWCFClient();
                Stopwatch stopWatch = new Stopwatch();
                uint expectedHResult = HResult.XONLINE_E_TOKEN_FILE_COULD_NOT_BE_DECRYPTED;
                bool expectedRetryable = false;

                TokenEntry[] preEncryptionTokens = new TokenEntry[total];
                xonline.mix.tokenmanagement.contracts.V1.TokenEntry[] decryptedTokens;

                Guid jobId = GenerateTokens(total, ref preEncryptionTokens);
                decryptedTokens = client.GetTokens(jobId, Key, start, count, expectedHResult, expectedRetryable);
            }
        }
        #endregion

        #region Get 1 token from token file containing 1 token, CallAmount 1, Unfinished jobs
        [TestCase, Description("Negative: Get 1 token from token file containing 10 token, CallAmount 1 and Accesing unfinished job")]
        class N_Get1Token_From10TokenFile_CallAmount1_NotDelivered : WCFTestBase
        {
            public override void Run()
            {
                int count = 1;
                int start = 1;
                int total = 10;

                TokenManagementWCFClient client = new TokenManagementWCFClient();
                Stopwatch stopWatch = new Stopwatch();
                uint expectedHResult = HResult.XONLINE_E_TOKEN_JOB_NOT_IN_REQUIRED_STATE;
                bool expectedRetryable = false;

                TokenEntry[] preEncryptionTokens = new TokenEntry[total];
                xonline.mix.tokenmanagement.contracts.V1.TokenEntry[] decryptedTokens;

                //Guid jobId = GenerateTokens(total, ref preEncryptionTokens);

                Guid jobId = MixTokenHelper.GenerateTestTokens(MixTokenHelper.GlobalTC.TokenCategoryId, (uint)total, MixTokenHelper.Key, true, false);

                decryptedTokens = client.GetTokens(jobId, MixTokenHelper.Key, start, count, expectedHResult, expectedRetryable);
            }
        }

        #endregion

        #region Attempt to access jobId that returns 'Delivered' but for which no .xtx file exists
        [TestCase, Description("Negative: Attempt to access jobId that returns 'Delivered' but for which no .xtx file exists")]
        class TokenJobInDeliveredStateNoTokenFileExists : WCFTestBase
        {
            public override void Run()
            {
                int count = 10;
                int start = 10;
                int total = 50;

                TokenManagementWCFClient client = new TokenManagementWCFClient();
                Stopwatch stopWatch = new Stopwatch();
                uint expectedHResult = HResult.XONLINE_E_TOKEN_FILE_NOT_FOUND;
                bool expectedRetryable = false;

                TokenEntry[] preEncryptionTokens = new TokenEntry[total];
                xonline.mix.tokenmanagement.contracts.V1.TokenEntry[] decryptedTokens;

                Guid jobId = GenerateTokens(total, ref preEncryptionTokens);

                string path = MixTokenHelper.GetTokenFilePath(jobId);
                FileInfo fi = new FileInfo(path);
                if (fi.Exists)
                {
                    fi.Delete();
                }

                try
                {
                    decryptedTokens = client.GetTokens(jobId, MixTokenHelper.Key, start, count, expectedHResult, expectedRetryable);
                }
                catch (Exception ex)
                {
                    Global.RO.Warn(ex.Message);
                }
            }
        }
        #endregion

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Test\TokenManagementTest\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Test\TokenManagementTest\GenerateTokensTests.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.ServiceModel;
using System.Runtime.Serialization;
using System.IO;
using System.IO.Compression;
using System.Net;
using System.Security.Cryptography;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;
using System.Xml;

using ServerTestFramework;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.LiveService;
using ServerTestFramework.Utilities;
using ServerTestFramework.Database;

using xonline.common.config;
using xonline.common.billing;
using MIXTesting;
using xonline.mix.tokenmanagement.contracts.V1;
using xonline.mix.common;

namespace MixTest
{
    /// <summary>
    /// This test group covers 2 TokenManagement APIs.
    /// GenerateTokens
    /// GetTokenJobStatus
    /// </summary>
    [TestGroup, Owner("yuanfeiw"), TestCasePriority(1), TestFrequency("Regression"), EnvRequirement("Catalog"), Description("Mix GenerateTokens/GetTokenJobsStatus API Tests")]
    public class GenerateTokensTests : TestNode
    {
        public override void OneTimeSetup()
        {
            // lower cron job execution interval from 120 seconds to 50 seconds
            StaticNpdb.ExecuteNonQuery("update dbo.t_cron_jobs set i_exec_interval_secs = 50 where vc_assembly = 'TokenGeneratePlugIns.dll'");
        }

        [TestCase, Description("GenerateTokens - generate one token for Arcade game Not In Csat (Xbox only token)")]
        class P_GenerateTokens_One_ArcadeGame_NotInCsat : WCFTestBase
        {
            private TokenCategory tc = null;
            private int numTokens = 1;

            public override void PreRun()
            {
                // create a new token category for an Arcade Game NOT in Csat
                // PKPN will not be added to CTP and LoaTokenInstance API is not called
                // Token Hash file should not be created
                tc = MixTokenHelper.NewTokenCategory();
                PrintObject(tc);
                TokenManagementWCFClient client = new TokenManagementWCFClient();
                client.ConfigureTokenCategory(tc);
            }

            public override void Run()
            {
                Guid jobId = MixTokenHelper.GenerateTestTokens(tc.TokenCategoryId, (uint)numTokens, MixTokenHelper.Key, true, true);

                // verify the token by calling Mix GetTokenInfo and GetTokens
                TokenEntry[] tokens = MixTokenHelper.GetTokenEntries(jobId, MixTokenHelper.Key);
                MixTokenHelper.VerifyTokens(numTokens, tokens, tc);

                // Token Hash file should not be created for game content and InCsat = false. Assume the job is completed.
                MixTokenHelper.VerifyTokenHashFileExist(jobId, false);

                // redeem the token
                // verify the token is consumed by calling Xbos VerifyToken
                // verify the token is consumed by calling Mix GetTokenInfo
            }
        }

        [TestCase, Description("GenerateTokens - generate one token for Arcade game In Csat (CIS token)")]
        class P_GenerateTokens_One_ArcadeGame_InCsat : WCFTestBase
        {
            private TokenCategory tc = null;
            private int numTokens = 1;

            public override void PreRun()
            {
                // create a new token category for an Arcade Game in Csat
                // PKPN will be added to CTP and LoaTokenInstance API is called
                // Token Hash file should not be created
                tc = MixTokenHelper.NewTokenCategoryInCsatArcadeGame();
                PrintObject(tc);
                TokenManagementWCFClient client = new TokenManagementWCFClient();
                client.ConfigureTokenCategory(tc);
            }

            public override void Run()
            {
                Guid jobId = MixTokenHelper.GenerateTestTokens(tc.TokenCategoryId, (uint)numTokens, MixTokenHelper.Key, true, true);

                // verify the token by calling Mix GetTokenInfo and GetTokens
                TokenEntry[] tokens = MixTokenHelper.GetTokenEntries(jobId, MixTokenHelper.Key);
                MixTokenHelper.VerifyTokens(numTokens, tokens, tc);

                // Token Hash file should not be created for game content even InCsat = true. Assume the job is completed.
                MixTokenHelper.VerifyTokenHashFileExist(jobId, false);
            }
        }

        [TestCase, Description( "GenerateTokens - generate 15010 token for Arcade game In Csat (CIS token)" )]
        class P_GenerateTokens_15010_ArcadeGame_InCsat : WCFTestBase
        {
            private TokenCategory tc = null;
            private int numTokens = 15010;

            public override void PreRun()
            {
                // create a new token category for an Arcade Game in Csat
                // PKPN will be added to CTP and LoaTokenInstance API is called
                // Token Hash file should not be created
                tc = MixTokenHelper.NewTokenCategoryInCsatArcadeGame();
                PrintObject(tc);
                TokenManagementWCFClient client = new TokenManagementWCFClient();
                client.ConfigureTokenCategory(tc);
            }

            public override void Run()
            {
                Guid jobId = MixTokenHelper.GenerateTestTokens(tc.TokenCategoryId, (uint)numTokens, MixTokenHelper.Key, true, true);

                // verify the token by calling Mix GetTokenInfo and GetTokens. May take a long time.
                // set the timeout to 1800 seconds ( 30 minutes )
                TokenEntry[] tokens = MixTokenHelper.GetTokenEntries(jobId, MixTokenHelper.Key, 1800);
                // it takes too long to verify all tokens, verify the first 10
                MixTokenHelper.VerifyTokens(numTokens, tokens, 10, tc);

                // Token Hash file should not be created for game content even InCsat = true. Assume the job is completed.
                MixTokenHelper.VerifyTokenHashFileExist(jobId, false);
            }
        }

        [TestCase, Description("GenerateTokens - use BIF to simulate non-retryable error from CTP LoadTokenInstance API")]
        class P_GenerateTokens_CTP_LoadTokenInstance_FirstBatch_Fail_NonRetryable : WCFTestBase
        {
            private TokenCategory tc = null;
            private int numTokens = 50001;
            private TokenManagementWCFClient client = new TokenManagementWCFClient();

            public override void PreRun()
            {
                // create a new token category for an Arcade Game in Csat
                tc = MixTokenHelper.NewTokenCategoryInCsatArcadeGame();
                client.ConfigureTokenCategory(tc);

                // custom http header for a non-retryable error
                string scsError = BehaviorInjection.AddScsFailure("LoadTokenInstance", "BDK_E_AUTHORIZATION_FAILED", false);
                scsError = scsError.Replace("BEHAVIOR_INJECTIONS:", "").Trim();
                CustomHttpHeader header = new CustomHttpHeader("BEHAVIOR_INJECTIONS", scsError);
                CustomHttpHeader[] headers = new CustomHttpHeader[] { header };
                PrintObject(headers);
                client = new TokenManagementWCFClient();
                client.CustomHttpHeaders = headers;
            }

            public override void Run()
            {
                // Run health check URL
                MixTokenHelper.RunCronHealthCheck();
                TokenJob tokenJob = client.GenerateTokens(tc.TokenCategoryId, (uint)numTokens, MixTokenHelper.Key, true);
                Global.RO.Info("Got Token Job");
                WCFTestBase.PrintObject(tokenJob);

                // Verify the first call to LoadTokenInstance fails with non-retryable error
                uint hr = (uint)MixTokenHelper.GetFailedTokenJobStatus(tokenJob.TokenJobId, 1, MixTokenHelper.WaitTimeout, TokenJobStatusEnum.Failed);
                Global.RO.Info("GenerateTokens failure HR: " + hr.ToString("X"));
                ValueCheck.TestHR("GenerateTokens failure HR", HResult.XONLINE_E_BILLING_AUTHORIZATION_FAILED, hr);

                // no token is created
            }
        }

        [TestCase, Description("GenerateTokens - use BIF to simulate retryable error from CTP LoadTokenInstance API")]
        class P_GenerateTokens_CTP_LoadTokenInstance_FirstBatch_Fail_Retryable : WCFTestBase
        {
            private TokenCategory tc = null;
            private int numTokens = 501;
            private TokenManagementWCFClient client = new TokenManagementWCFClient();

            public override void PreRun()
            {
                // create a new token category for an Arcade Game in Csat
                tc = MixTokenHelper.NewTokenCategoryInCsatArcadeGame();
                client.ConfigureTokenCategory(tc);

                // custom http header for a retryable error
                string scsError = BehaviorInjection.AddScsFailure("LoadTokenInstance", "BDK_E_UNKNOWN_SERVER_FAILURE", false);
                scsError = scsError.Replace("BEHAVIOR_INJECTIONS:", "").Trim();
                CustomHttpHeader header = new CustomHttpHeader("BEHAVIOR_INJECTIONS", scsError);
                CustomHttpHeader[] headers = new CustomHttpHeader[] { header };
                PrintObject(headers);
                client = new TokenManagementWCFClient();
                client.CustomHttpHeaders = headers;
            }

            public override void Run()
            {
                MixTokenHelper.RunCronHealthCheck();
                TokenJob tokenJob = client.GenerateTokens(tc.TokenCategoryId, (uint)numTokens, MixTokenHelper.Key, true);
                Global.RO.Info("Got Token Job");
                WCFTestBase.PrintObject(tokenJob);

                // Verify the first call to LoadTokenInstance fails with retryable error
                // by looking at token job history.
                uint hr = (uint)MixTokenHelper.GetFailedTokenJobStatus(tokenJob.TokenJobId, 1, MixTokenHelper.WaitTimeout);
                Global.RO.Info("GenerateTokens failure HR: " + hr.ToString("X"));
                ValueCheck.TestHR("GenerateTokens failure HR", HResult.XONLINE_E_BILLING_UNKNOWN_SERVER_FAILURE, hr);

                // Then clear the Behavior Injection field in t_token_jobs table to let
                // the next Cron job succeed.
                StaticNpdb.ExecuteNonQuery("update dbo.t_token_jobs set vc_behavior_injection = '' where uid_job_id = '" + tokenJob.TokenJobId.ToString() + "'");

                TokenEntry[] tokens = MixTokenHelper.GetTokenEntries(tokenJob.TokenJobId, MixTokenHelper.Key);
                // it takes too long to verify all tokens, verify the first 30
                MixTokenHelper.VerifyTokens(numTokens, tokens, 30, tc);
            }
        }

        // Comment out this test because we temporarily disable support of subscription and points bundle, see bug 169501.
        //[TestCase, Description("GenerateTokens - generate one token for Live Subscription In Csat")]
        class P_GenerateTokens_One_Subscription_InCsat : WCFTestBase
        {
            private TokenCategory tc = null;
            private int numTokens = 1;

            public override void PreRun()
            {
                // create a new token category for a live subcription offer
                // PKPN will not be added to CTP. And LoadTokenInstance API is not called
                // Token Hash file should be created.
                tc = MixTokenHelper.NewTokenCategoryInCsatLiveSubscription();
                PrintObject(tc);
                TokenManagementWCFClient client = new TokenManagementWCFClient();
                client.ConfigureTokenCategory(tc);
            }

            public override void Run()
            {
                Guid jobId = MixTokenHelper.GenerateTestTokens(tc.TokenCategoryId, (uint)numTokens, MixTokenHelper.Key, true, true);

                // verify the token by calling Mix GetTokenInfo and GetTokens
                TokenEntry[] tokens = MixTokenHelper.GetTokenEntries(jobId, MixTokenHelper.Key);
                MixTokenHelper.VerifyTokens(numTokens, tokens, tc);

                // Token Hash file should be created for Subscription. Assume the job is completed.
                MixTokenHelper.VerifyTokenHashFileExist(jobId, true);
            }
        }

        // Comment out this test because we temporarily disable support of subscription and points bundle, see bug 169501.
        //[TestCase, Description("GenerateTokens - generate one token for Points Bundle In Csat")]
        class P_GenerateTokens_One_PointsBundle_InCsat : WCFTestBase
        {
            private TokenCategory tc = null;
            private int numTokens = 1;

            public override void PreRun()
            {
                // create a new token category for a 1600 points bundle offer
                // PKPN will not be added to CTP. And LoadTokenInstance API is not called
                // Token Hash file should be created.
                tc = MixTokenHelper.NewTokenCategoryInCsatPointsBundle();
                PrintObject(tc);
                TokenManagementWCFClient client = new TokenManagementWCFClient();
                client.ConfigureTokenCategory(tc);
            }

            public override void Run()
            {
                Guid jobId = MixTokenHelper.GenerateTestTokens(tc.TokenCategoryId, (uint)numTokens, MixTokenHelper.Key, true, true);

                // verify the token by calling Mix GetTokenInfo and GetTokens
                TokenEntry[] tokens = MixTokenHelper.GetTokenEntries(jobId, MixTokenHelper.Key);
                MixTokenHelper.VerifyTokens(numTokens, tokens, tc);

                // Token Hash file should be created for Points Bundle. Assume the job is completed.
                MixTokenHelper.VerifyTokenHashFileExist(jobId, true);
            }
        }

        // Comment out this test because we temporarily disable support of subscription and points bundle, see bug 169501.
        //[TestCase, Description("GenerateTokens - generate half million token for Live Subscription In Csat")]
        class P_GenerateTokens_HalfMillion_Subscription_InCsat : WCFTestBase
        {
            private TokenCategory tc = null;
            private int numTokens = 500000;

            public override void PreRun()
            {
                // create a new token category for a live subcription offer
                // PKPN will not be added to CTP. And LoadTokenInstance API is not called
                // Token Hash file should be created.
                tc = MixTokenHelper.NewTokenCategoryInCsatLiveSubscription();
                PrintObject(tc);
                TokenManagementWCFClient client = new TokenManagementWCFClient();
                client.ConfigureTokenCategory(tc);
            }

            public override void Run()
            {
                Guid jobId = MixTokenHelper.GenerateTestTokens(tc.TokenCategoryId, (uint)numTokens, MixTokenHelper.Key, true, true);

                // verify the token by calling Mix GetTokenInfo and GetTokens
                TokenEntry[] tokens = MixTokenHelper.GetTokenEntries(jobId, MixTokenHelper.Key);
                // it takes too long to verify all tokens, verify the first 30
                MixTokenHelper.VerifyTokens(numTokens, tokens, 30, tc);

                // Token Hash file should be created for Subscription. Assume the job is completed.
                MixTokenHelper.VerifyTokenHashFileExist(jobId, true);
            }
        }

        // this test will fail until bug 154485 is fixed.
        [Description("GenerateTokens - use BIF to simulate npdb RecordJobDelivered failure")]
        class P_GenerateTokens_Npdb_SprocFailure_RecordJobDelivered : WCFTestBase
        {
            private TokenCategory tc = null;
            private int numTokens = 500;
            private TokenManagementWCFClient client = new TokenManagementWCFClient();

            public override void PreRun()
            {
                // create a new token category for a live subscription in Csat
                tc = MixTokenHelper.NewTokenCategoryInCsatLiveSubscription();
                client.ConfigureTokenCategory(tc);

                // custom http header to simulate npdb sproc RecordJobDelivered failure
                string npdbSprocFailure = "SprocFailure;sproc=dbo.p_token_job_record_delivered:exception=System.Exception;";
                CustomHttpHeader[] headers = new CustomHttpHeader[] { new CustomHttpHeader("BEHAVIOR_INJECTIONS", npdbSprocFailure) };
                PrintObject(headers);
                client = new TokenManagementWCFClient();
                client.CustomHttpHeaders = headers;
            }

            public override void Run()
            {
                MixTokenHelper.RunCronHealthCheck();
                TokenJob tokenJob = client.GenerateTokens(tc.TokenCategoryId, (uint)numTokens, MixTokenHelper.Key, true);
                WCFTestBase.PrintObject(tokenJob);

                // Verify the first try failed with npdb failure
                uint hr = (uint)MixTokenHelper.GetFailedTokenJobStatus(tokenJob.TokenJobId, 1, MixTokenHelper.WaitTimeout);
                ValueCheck.TestHR("GenerateTokens failure HR", HResult.XONLINE_E_DATABASE_EXECUTE_ERROR, hr);

                // no token is created, no encrypted token file, no token hash file
                ValueCheck.Test("Number of Tokens in TokenDB t_tokens_v2 table", 0, TokendbWS.GetNumTokensByTokenJobId(tokenJob.TokenJobId));
                MixTokenHelper.VerifyEncryptedTokenFileExist(tokenJob.TokenJobId, false);
                MixTokenHelper.VerifyTokenHashFileExist(tokenJob.TokenJobId, false);

                // clear the BIF field in t_token_jobs table to let the next Cron job succeed.
                MixTokenHelper.SetTokenJobBIFField(tokenJob.TokenJobId, string.Empty);

                TokenEntry[] tokens = MixTokenHelper.GetTokenEntries(tokenJob.TokenJobId, MixTokenHelper.Key);
                // it takes too long to verify all tokens, verify the first 30
                MixTokenHelper.VerifyTokens(numTokens, tokens, 30, tc);
            }
        }

        // this test will fail until bug 154485 is fixed.
        [Description("GenerateTokens - use BIF to simulate final file share access failure")]
        class P_GenerateTokens_FinalFileShare_AccessFailure : WCFTestBase
        {
            private TokenCategory tc = null;
            private int numTokens = 500;
            private TokenManagementWCFClient client = new TokenManagementWCFClient();

            public override void PreRun()
            {
                // create a new token category for a live subscription in Csat
                tc = MixTokenHelper.NewTokenCategoryInCsatLiveSubscription();
                client.ConfigureTokenCategory(tc);
            }

            public override void Run()
            {
                MixTokenHelper.RunCronHealthCheck();
                TokenJob tokenJob = client.GenerateTokens(tc.TokenCategoryId, (uint)numTokens, MixTokenHelper.Key, true);
                WCFTestBase.PrintObject(tokenJob);

                // add BIF by directly updating BIF field in t_token_jobs table
                string npdbOverride = BehaviorInjection.AddNpdbOverride("tokenService_finalOutputDirectory", @"\\invalid\path\TokenOutput", false);
                MixTokenHelper.SetTokenJobBIFField(tokenJob.TokenJobId, npdbOverride);

                // Verify the first try failed with file access failure
                uint hr = (uint)MixTokenHelper.GetFailedTokenJobStatus(tokenJob.TokenJobId, 1, MixTokenHelper.WaitTimeout);
                ValueCheck.TestHR("GenerateTokens failure HR", HResult.XONLINE_E_TOKEN_UNKNOWN_ERROR/*XONLINE_E_IO_ERROR*/, hr);

                // no token is created, no encrypted token file, no token hash file
                ValueCheck.Test("Number of Tokens in TokenDB t_tokens_v2 table", 0, TokendbWS.GetNumTokensByTokenJobId(tokenJob.TokenJobId));
                MixTokenHelper.VerifyEncryptedTokenFileExist(tokenJob.TokenJobId, false);
                MixTokenHelper.VerifyTokenHashFileExist(tokenJob.TokenJobId, false);

                // clear the BIF field in t_token_jobs table to let the next Cron job succeed.
                MixTokenHelper.SetTokenJobBIFField(tokenJob.TokenJobId, string.Empty);

                TokenEntry[] tokens = MixTokenHelper.GetTokenEntries(tokenJob.TokenJobId, MixTokenHelper.Key);
                // it takes too long to verify all tokens, verify the first 30
                MixTokenHelper.VerifyTokens(numTokens, tokens, 30, tc);
            }
        }

        // this test will fail until bug 154485 is fixed.
        [Description("GenerateTokens - use BIF to simulate temp file share access failure")]
        class P_GenerateTokens_TempFileShare_AccessFailure : WCFTestBase
        {
            private TokenCategory tc = null;
            private int numTokens = 500;
            private TokenManagementWCFClient client = new TokenManagementWCFClient();

            public override void PreRun()
            {
                // create a new token category for a live subscription in Csat
                tc = MixTokenHelper.NewTokenCategoryInCsatLiveSubscription();
                client.ConfigureTokenCategory(tc);
            }

            public override void Run()
            {
                MixTokenHelper.RunCronHealthCheck();
                TokenJob tokenJob = client.GenerateTokens(tc.TokenCategoryId, (uint)numTokens, MixTokenHelper.Key, true);
                WCFTestBase.PrintObject(tokenJob);

                // add BIF by directly updating BIF field in t_token_jobs table
                string npdbOverride = BehaviorInjection.AddNpdbOverride("tokenService_finalOutputDirectory", @"\\invalid\path\TokenOutput", false);
                MixTokenHelper.SetTokenJobBIFField(tokenJob.TokenJobId, npdbOverride);

                // Verify the first try failed with file access failure
                uint hr = (uint)MixTokenHelper.GetFailedTokenJobStatus(tokenJob.TokenJobId, 1, MixTokenHelper.WaitTimeout);
                ValueCheck.TestHR("GenerateTokens failure HR", HResult.XONLINE_E_TOKEN_UNKNOWN_ERROR/*XONLINE_E_IO_ERROR*/, hr);

                // no token is created, no encrypted token file, no token hash file
                ValueCheck.Test("Number of Tokens in TokenDB t_tokens_v2 table", 0, TokendbWS.GetNumTokensByTokenJobId(tokenJob.TokenJobId));
                MixTokenHelper.VerifyEncryptedTokenFileExist(tokenJob.TokenJobId, false);
                MixTokenHelper.VerifyTokenHashFileExist(tokenJob.TokenJobId, false);

                // clear the BIF field in t_token_jobs table to let the next Cron job succeed.
                MixTokenHelper.SetTokenJobBIFField(tokenJob.TokenJobId, string.Empty);

                TokenEntry[] tokens = MixTokenHelper.GetTokenEntries(tokenJob.TokenJobId, MixTokenHelper.Key);
                // it takes too long to verify all tokens, verify the first 30
                MixTokenHelper.VerifyTokens(numTokens, tokens, 30, tc);
            }
        }

        // update the npdb setting override, make tokenService_batchSize to 10
        [TestCase, Description("GenerateTokens - generate 101 token and the batch size is 10")]
        class P_GenerateTokens_TokenBatchSize_10BatchesPlus1 : WCFTestBase
        {
            public override void Run()
            {
                SettingState oldState = new SettingState();
                // start the cron
                MixTokenHelper.RunCronHealthCheck();

                try
                {
                    oldState = Global.XEnv.OverrideSetting(Component.cron, "ALL", Setting.tokenService_batchSize, "10", -1);
                    Global.XEnv.ExecuteXmgmtCommand(Interface.cron_int, "e :cron configcacherefresh");
                    System.Threading.Thread.Sleep(3000);

                    Guid jobId = MixTokenHelper.GenerateTestTokens(MixTokenHelper.GlobalTC.TokenCategoryId, 101, MixTokenHelper.Key, true, false);
                    TokenEntry[] tokens = MixTokenHelper.GetTokenEntries(jobId, MixTokenHelper.Key);
                    MixTokenHelper.VerifyTokens(101, tokens, MixTokenHelper.GlobalTC);
                }
                finally
                {
                    // make the npdb settings back to default values
                    if (oldState.wasoverriden)
                    {
                        Global.XEnv.OverrideSetting(Component.cron, "ALL", Setting.tokenService_batchSize, oldState.oldvalue, -1);
                    }
                    else
                    {
                        Global.XEnv.DeleteOverrideSetting(Component.cron, "ALL", Setting.tokenService_batchSize, -1);
                    }
                    Global.XEnv.ExecuteXmgmtCommand(Interface.cron_int, "e :cron configcacherefresh");
                }
            }
        }

        [TestCase, Owner("shwetap"), TestCasePriority(1), TestFrequency("Regression")]
        [Description("GenerateTokens - Concurrent test: 5 pending token jobs(numTokens = 7)")]
        class P_Concurent_GenerateTokens_7_5PendingJobs : WCFTestBase
        {
            public override void Run()
            {
                Guid[] jobId = MixTokenHelper.GenerateTestTokens(MixTokenHelper.GlobalTC.TokenCategoryId, 7, MixTokenHelper.Key, true, 5, 0, 5000, false);
                for (int i = 0; i < jobId.Length; i++)
                {
                    Global.RO.Warn("==== Verify Job #{0}/{1} ===", i, jobId.Length);
                    TokenEntry[] tokens = MixTokenHelper.GetTokenEntries(jobId[i], MixTokenHelper.Key);
                    MixTokenHelper.VerifyTokens(7, tokens, MixTokenHelper.GlobalTC);
                }
            }
        }

        [TestCase, Owner("shwetap"), TestCasePriority(1), TestFrequency("Regression")]
        [Description("GenerateTokens - Concurrent test: 5 pending and 5 stale token jobs(numTokens = 7)")]
        class P_Concurent_GenerateTokens_7_5PendingJobs_5StaleJobs : WCFTestBase
        {
            public override void Run()
            {
                Guid[] jobId = MixTokenHelper.GenerateTestTokens(MixTokenHelper.GlobalTC.TokenCategoryId, 7, MixTokenHelper.Key, true, 5, 5, 5000, false);
                for (int i = 0; i < jobId.Length; i++)
                {
                    Global.RO.Warn("=== Verify Job #{0}/{1} ===", i, jobId.Length);
                    TokenEntry[] tokens = MixTokenHelper.GetTokenEntries(jobId[i], MixTokenHelper.Key);
                    MixTokenHelper.VerifyTokens(7, tokens, MixTokenHelper.GlobalTC);
                }
            }
        }

        //This Test cannot be run in parallel with other test as it changes the number of Cron Jobs running concurrently
        [TestCase, Owner("shwetap"), TestCasePriority(2), TestFrequency("Regression")]
        [Description("GenerateTokens - Concurrent test: 5 pending and 5 stale token jobs(numTokens = 7 and numOfBuckets = 10)")]
        class P_Concurent_GenerateTokens_7_5PendingJobs_5StaleJobs_10Buckets : WCFTestBase
        {
            public override void Run()
            {
                try
                {
                    MixTokenHelper.IncreaseNumberOfBucket(10);
                    Guid[] jobId = MixTokenHelper.GenerateTestTokens(MixTokenHelper.GlobalTC.TokenCategoryId, 7, MixTokenHelper.Key, true, 5, 5, 5000, false);

                    for (int i = 0; i < jobId.Length; i++)
                    {
                        Global.RO.Warn("=== Verify Job #{0}/{1} ===", i, jobId.Length);
                        TokenEntry[] tokens = MixTokenHelper.GetTokenEntries(jobId[i], MixTokenHelper.Key);
                        MixTokenHelper.VerifyTokens(7, tokens, MixTokenHelper.GlobalTC);
                    }
                }
                finally
                {
                    MixTokenHelper.RevertBackNumberOfBucket();
                }
            }
        }

        [TestCase, Description("GenerateTokens - 3 token jobs for the same token category at roughly the same time")]
        class P_GenerateTokens_MultiJobs_SameTC : WCFTestBase
        {
            public override void Run()
            {
                // create 3 token categories from 3 different PKPN
                TokenCategory tc1 = MixTokenHelper.NewTokenCategory();
                string tcId = tc1.TokenCategoryId.ToString();
                tc1.Pkpn = tcId.Substring(0, 16);
                TokenManagementWCFClient client = new TokenManagementWCFClient();
                client.ConfigureTokenCategory(tc1);

                // create 3 token jobs for these 3 different token categories
                Guid jobId1 = MixTokenHelper.GenerateTestTokens(tc1.TokenCategoryId, 10, MixTokenHelper.Key, true, false);
                Guid jobId2 = MixTokenHelper.GenerateTestTokens(tc1.TokenCategoryId, 20, MixTokenHelper.Key, false, false);
                Guid jobId3 = MixTokenHelper.GenerateTestTokens(tc1.TokenCategoryId, 30, MixTokenHelper.Key, false, false);

                // wait for all 3 to finish
                MixTokenHelper.WaitOnTokenJobs(tc1.TokenCategoryId, 900);

                // verify all 3 jobs
                TokenEntry[] tokens = MixTokenHelper.GetTokenEntries(jobId1, MixTokenHelper.Key);
                MixTokenHelper.VerifyTokens(10, tokens, tc1);
                tokens = MixTokenHelper.GetTokenEntries(jobId2, MixTokenHelper.Key);
                MixTokenHelper.VerifyTokens(20, tokens, tc1);
                tokens = MixTokenHelper.GetTokenEntries(jobId3, MixTokenHelper.Key);
                MixTokenHelper.VerifyTokens(30, tokens, tc1);
            }
        }

        [TestCase, Description("GenerateTokens - 3 token jobs for different token categories from same PKPN at roughly the same time")]
        class P_GenerateTokens_MultiJobs_DiffTC_SamePKPN : WCFTestBase
        {
            public override void Run()
            {
                // create 3 token categories from 3 different PKPN
                TokenCategory tc1 = MixTokenHelper.NewTokenCategory();
                string tcId = tc1.TokenCategoryId.ToString();
                tc1.Pkpn = tcId.Substring(0, 16);
                TokenManagementWCFClient client = new TokenManagementWCFClient();
                client.ConfigureTokenCategory(tc1);

                TokenCategory tc2 = MixTokenHelper.NewTokenCategory();
                tc2.Pkpn = tc1.Pkpn;
                client.ConfigureTokenCategory(tc2);

                TokenCategory tc3 = MixTokenHelper.NewTokenCategory();
                tc3.Pkpn = tc1.Pkpn;
                client.ConfigureTokenCategory(tc3);

                // create 3 token jobs for these 3 different token categories
                Guid jobId1 = MixTokenHelper.GenerateTestTokens(tc1.TokenCategoryId, 10, MixTokenHelper.Key, true, false);
                Guid jobId2 = MixTokenHelper.GenerateTestTokens(tc2.TokenCategoryId, 20, MixTokenHelper.Key, false, false);
                Guid jobId3 = MixTokenHelper.GenerateTestTokens(tc3.TokenCategoryId, 30, MixTokenHelper.Key, false, false);

                // verify all 3 jobs
                TokenEntry[] tokens = MixTokenHelper.GetTokenEntries(jobId1, MixTokenHelper.Key);
                MixTokenHelper.VerifyTokens(10, tokens, tc1);
                tokens = MixTokenHelper.GetTokenEntries(jobId2, MixTokenHelper.Key);
                MixTokenHelper.VerifyTokens(20, tokens, tc2);
                tokens = MixTokenHelper.GetTokenEntries(jobId3, MixTokenHelper.Key);
                MixTokenHelper.VerifyTokens(30, tokens, tc3);
            }
        }

        // This test case is also to verify the key can be less than 16 bytes.
        [TestCase, Description("GenerateTokens - 3 token jobs for different token categories from different PKPN at roughly the same time")]
        class P_GenerateTokens_MultiJobs_DiffPKPN_DiffKey : WCFTestBase
        {
            public override void Run()
            {
                byte[] Key1 = new byte[] { 0x0, 0x0, 0x2, 0x3, 0x4 };
                byte[] Key2 = new byte[] { 0x0, 0x1, 0x0, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf };
                byte[] Key3 = new byte[] { 0x0, 0x1, 0x2, 0x0, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9 };

                // create 3 token categories from 3 different PKPN
                TokenCategory tc1 = MixTokenHelper.NewTokenCategory();
                string tcId = tc1.TokenCategoryId.ToString();
                tc1.Pkpn = tcId.Substring(0, 16);
                TokenManagementWCFClient client = new TokenManagementWCFClient();
                client.ConfigureTokenCategory(tc1);

                TokenCategory tc2 = MixTokenHelper.NewTokenCategory();
                tcId = tc2.TokenCategoryId.ToString();
                tc2.Pkpn = tcId.Substring(0, 16);
                client.ConfigureTokenCategory(tc2);

                TokenCategory tc3 = MixTokenHelper.NewTokenCategory();
                tcId = tc3.TokenCategoryId.ToString();
                tc3.Pkpn = tcId.Substring(0, 16);
                client.ConfigureTokenCategory(tc3);

                // create 3 token jobs for these 3 different token categories
                Guid jobId1 = MixTokenHelper.GenerateTestTokens(tc1.TokenCategoryId, 30, Key1, true, false);
                Guid jobId2 = MixTokenHelper.GenerateTestTokens(tc2.TokenCategoryId, 20, Key2, false, false);
                Guid jobId3 = MixTokenHelper.GenerateTestTokens(tc3.TokenCategoryId, 10, Key3, false, false);

                // verify all 3 jobs
                TokenEntry[] tokens = MixTokenHelper.GetTokenEntries(jobId1, Key1);
                MixTokenHelper.VerifyTokens(30, tokens, tc1);
                tokens = MixTokenHelper.GetTokenEntries(jobId2, Key2);
                MixTokenHelper.VerifyTokens(20, tokens, tc2);
                tokens = MixTokenHelper.GetTokenEntries(jobId3, Key3);
                MixTokenHelper.VerifyTokens(10, tokens, tc3);
            }
        }

        [TestCase, Description("GenerateTokens - sequence number index is below 10million for one PKPN")]
        class P_GenerateTokens_SeqNum_10Million_DiffPKPN : WCFTestBase
        {
            public override void Run()
            {
                // create a token category and PKPN each time
                TokenCategory tc = MixTokenHelper.NewTokenCategory();
                string tcId = tc.TokenCategoryId.ToString();
                tc.Pkpn = tcId.Substring(0, 16);
                TokenManagementWCFClient client = new TokenManagementWCFClient();
                client.ConfigureTokenCategory(tc);

                // update the t_token_pkpn_sequence_number table in npdb directly
                // to make next sequence number index, 9,999,990
                StaticNpdb.ExecuteNonQuery(string.Format("insert into dbo.t_token_pkpn_sequence_number values ('{0}', 9999990, '{1}')", tc.Pkpn, DateTime.UtcNow));

                // try to create another 100 tokens for a different PKPN. There is no error.
                Guid jobId = MixTokenHelper.GenerateTestTokens(MixTokenHelper.GlobalTC.TokenCategoryId, 100, MixTokenHelper.Key, true, false);
                TokenEntry[] tokens = MixTokenHelper.GetTokenEntries(jobId, MixTokenHelper.Key);
                MixTokenHelper.VerifyTokens(100, tokens, MixTokenHelper.GlobalTC);
            }
        }

        [TestCase, Description("GenerateTokens - sequence number index is over 10million for one PKPN")]
        class N_GenerateTokens_SeqNum_10Million_SamePKPN : WCFTestBase
        {
            public override void Run()
            {
                // create a token category and PKPN each time
                TokenCategory tc = MixTokenHelper.NewTokenCategory();
                string tcId = tc.TokenCategoryId.ToString();
                tc.Pkpn = tcId.Substring(0, 16);
                TokenManagementWCFClient client = new TokenManagementWCFClient();
                client.ConfigureTokenCategory(tc);

                // update the t_token_pkpn_sequence_number table in npdb directly
                // to make next sequence number index, 9,999,990
                StaticNpdb.ExecuteNonQuery(string.Format("insert into dbo.t_token_pkpn_sequence_number values ('{0}', 9999990, '{1}')", tc.Pkpn, DateTime.UtcNow));

                // try to create another 100 tokens for the same PKPN, will fail
                // with HResult.XONLINE_E_TOKEN_SEQUENCE_NUMBER_INVALID_INDEX
                client.GenerateTokens(tc.TokenCategoryId, 100, MixTokenHelper.Key, HResult.XONLINE_E_TOKEN_SEQUENCE_NUMBER_INVALID_INDEX, false, false);
            }
        }

        [TestCase, Description("GenerateTokens - Negative Test for an empty Guid (all zeros) token categroy")]
        class N_GenerateTokens_EmptyGuid_TC : WCFTestBase
        {
            public override void Run()
            {
                TokenManagementWCFClient client = new TokenManagementWCFClient();
                client.GenerateTokens(Guid.Empty, 10, MixTokenHelper.Key, HResult.E_INVALIDARG, false, false);
            }
        }

        [TestCase, Description("GenerateTokens - Negative Test for an invalid token categroy")]
        class N_GenerateTokens_Invalid_TC : WCFTestBase
        {
            public override void Run()
            {
                TokenManagementWCFClient client = new TokenManagementWCFClient();
                client.GenerateTokens(Guid.NewGuid(), 10, MixTokenHelper.Key, HResult.XONLINE_E_TOKEN_NO_CATEGORY_FOUND, false, false);
            }
        }

        [TestCase, Description("GenerateTokens - Negative Test for an expired token categroy")]
        class N_GenerateTokens_Expired_TC : WCFTestBase
        {
            public override void Run()
            {
                TokenCategory tc = MixTokenHelper.NewTokenCategory();
                tc.ExpirationDate = DateTime.UtcNow.AddDays(-2);
                PrintObject(tc);
                TokenManagementWCFClient client = new TokenManagementWCFClient();
                client.ConfigureTokenCategory(tc);

                client.GenerateTokens(tc.TokenCategoryId, 10, MixTokenHelper.Key, HResult.XONLINE_E_TOKEN_EXPIRED_TOKEN_CATEGORY, false, false);
            }
        }

        [TestCase, Description("GenerateTokens - Negative Test for zero NumTokens")]
        class N_GenerateTokens_NumTokens_Zero : WCFTestBase
        {
            public override void Run()
            {
                TokenManagementWCFClient client = new TokenManagementWCFClient();
                client.GenerateTokens(MixTokenHelper.GlobalTC.TokenCategoryId, 0, MixTokenHelper.Key, HResult.E_INVALIDARG, false, false);
            }
        }

        [TestCase, Description("GenerateTokens - Key larger than 16 bytes")]
        class N_GenerateTokens_InvalidKey_TooLarge : WCFTestBase
        {
            public override void Run()
            {
                RNGCryptoServiceProvider rng = new RNGCryptoServiceProvider();
                byte[] invalidKey = new byte[32];
                rng.GetBytes(invalidKey);

                TokenManagementWCFClient client = new TokenManagementWCFClient();
                client.GenerateTokens(MixTokenHelper.GlobalTC.TokenCategoryId, 10, invalidKey, HResult.E_INVALIDARG, false, false);
            }
        }

        [TestCase, Description("GetTokenJobStatus - Negative Test for an empty Guid (all zeros) JobId")]
        class N_GetTokenJobStatus_EmptyGuid_JobId : WCFTestBase
        {
            public override void Run()
            {
                TokenManagementWCFClient client = new TokenManagementWCFClient();
                client.GetTokenJobStatus(Guid.Empty, HResult.E_INVALIDARG, false);
            }
        }

        [TestCase, Description("GetTokenJobStatus - Negative Test for an invalid JobId")]
        class N_GetTokenJobStatus_Invalid_JobId : WCFTestBase
        {
            public override void Run()
            {
                TokenManagementWCFClient client = new TokenManagementWCFClient();
                client.GetTokenJobStatus(Guid.NewGuid(), HResult.XONLINE_E_TOKEN_JOB_NOT_FOUND, false);
            }
        }

        [TestCase, Description("GetTokenJobStatusByCategory - Negative Test for an empty Guid (all zeros) TokenCategoryId")]
        class N_GetTokenJobStatusByCategory_EmptyGuid_TokenCategoryId : WCFTestBase
        {
            public override void Run()
            {
                TokenManagementWCFClient client = new TokenManagementWCFClient();
                client.GetTokenJobStatusByCategory(Guid.Empty, HResult.E_INVALIDARG, false);
            }
        }

        [TestCase, Description("GetTokenJobStatusByCategory - Negative Test for a not found TokenCategoryId")]
        class N_GetTokenJobStatusByCategory_NotFound_TokenCategoryId : WCFTestBase
        {
            public override void Run()
            {
                TokenManagementWCFClient client = new TokenManagementWCFClient();
                TokenJobStatus[] tjs = client.GetTokenJobStatusByCategory(Guid.NewGuid());
                if(tjs == null)
                {
                    throw new UnexpectedTestResultException("GetTokenJobStatusByCategory unexpectedly returned null");
                }
                if(tjs.Length > 0)
                {
                    throw new UnexpectedTestResultException(string.Format("GetTokenJobStatusByCategory unexpectedly returned {0} results", tjs.Length));
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Test\TokenManagementTest\TokenCategoryTests.cs ===
using System;
using System.Collections;
using System.ServiceModel;
using System.Runtime.Serialization;
using System.IO;
using System.Xml;
using System.Text;

using ServerTestFramework;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.LiveService;
using ServerTestFramework.Utilities;

using MIXTesting;
using xonline.mix.tokenmanagement.contracts.V1;

namespace MixTest
{
    /// <summary>
    /// This test group covers 4 TokenManagement APIs:
    /// ConfigureTokenCategory
    /// GetTokenCategoryById
    /// GetTokenCategoryByName
    /// GetTokenCategoryByOffer
    /// </summary>
    [TestGroup, Owner("yuanfeiw"), TestCasePriority(1), TestFrequency("Daily"), Description("Mix Token Category Tests")]
    public class TokenCategoryTests : TestNode
    {
        [TestCase, Description("ConfigureTokenCategory - Create a new Token Category")]
        class P_ConfigureTC_New_One : WCFTestBase
        {
            public override void Run()
            {
                TokenCategory tc = MixTokenHelper.NewTokenCategory();
                TokenManagementWCFClient client = new TokenManagementWCFClient();
                client.ConfigureTokenCategory(tc);
                PrintObject(tc);
                MixTokenHelper.VerifyTokenCategory(tc);
            }
        }

        [TestCase, Description("ConfigureTokenCategory - Create three new Token Categories for the same OfferId")]
        class P_ConfigureTC_New_Three : WCFTestBase
        {
            public override void Run()
            {
                TokenCategory tc1 = MixTokenHelper.NewTokenCategory();
                TokenManagementWCFClient client = new TokenManagementWCFClient();
                client.ConfigureTokenCategory(tc1);
                TokenCategory tc2 = MixTokenHelper.NewTokenCategory();
                tc2.OfferId = tc1.OfferId;
                client = new TokenManagementWCFClient();
                client.ConfigureTokenCategory(tc2);
                TokenCategory tc3 = MixTokenHelper.NewTokenCategory();
                tc3.OfferId = tc1.OfferId;
                client = new TokenManagementWCFClient();
                client.ConfigureTokenCategory(tc3);

                PrintObject(tc1);
                PrintObject(tc2);
                PrintObject(tc3);
                MixTokenHelper.VerifyTokenCategory(new TokenCategory[] { tc1, tc2, tc3 });
            }
        }

        [TestCase, Description("ConfigureTokenCategory - Update an existing Token Category")]
        class P_ConfigureTC_Update : WCFTestBase
        {
            public override void Run()
            {
                // create a new Token Category first
                TokenCategory tcFirst = MixTokenHelper.NewTokenCategory();
                TokenManagementWCFClient client = new TokenManagementWCFClient();
                client.ConfigureTokenCategory(tcFirst);

                // update the already existing Token Category with new TokenCategoryName and ExpirationDate
                TokenCategory tc = MixTokenHelper.CreateTokenCategoryFrom(tcFirst);
                tc.TokenCategoryName = "Arcade Media Token Category update:" + Guid.NewGuid().ToString();
                RandomEx randomEx = new RandomEx();
                int year = randomEx.Next(1900, 3000);
                tc.ExpirationDate = new DateTime(year, 12, 31, 00, 00, 00);

                client = new TokenManagementWCFClient();
                client.ConfigureTokenCategory(tc);
                PrintObject(tc);
                MixTokenHelper.VerifyTokenCategory(tc);
            }
        }

        [TestCase, Description("ConfigureTokenCategory - use Behavior Injection Framework to simulate a database exception ")]
        class N_ConfigureTC_DatabaseException_BIF : WCFTestBase
        {
            public override void Run()
            {
                TokenCategory tc = MixTokenHelper.NewTokenCategory();
                CustomHttpHeader header = new CustomHttpHeader("BEHAVIOR_INJECTIONS", "SprocFailure;sproc=dbo.p_configure_token_category:exception=System.Exception;");
                CustomHttpHeader[] headers = new CustomHttpHeader[] { header };
                PrintObject(headers);

                TokenManagementWCFClient client = new TokenManagementWCFClient();
                client.CustomHttpHeaders = headers;

                // call all TokenManagement APIs
                client.ConfigureTokenCategory(tc, HResult.XONLINE_E_DATABASE_EXECUTE_ERROR, false);
            }
        }

        [TestCase, Description("Call all TokenManagement APIs with an invalid PartnerId in WebSG header")]
        class N_AllTokenAPIs_WebSGHeader_Invalid_PartnerId : WCFTestBase
        {
            public override void Run()
            {
                TokenCategory tc = MixTokenHelper.NewTokenCategory();
                CustomHttpHeader[] headers = MixTokenHelper.CreateNewWebSGHeaders();
                headers[0].value = "DebugPartner123"; // make the Subject Name ('DebugPartner123') an invalid PartnerId
                PrintObject(headers);

                TokenManagementWCFClient client = new TokenManagementWCFClient();
                client.CustomHttpHeaders = headers;

                // call all TokenManagement APIs
                client.ConfigureTokenCategory(tc, HResult.XONLINE_E_MIX_WEBSGVALIDATIONERROR, false);
                client.GetTokenCategoryById(tc.TokenCategoryId, HResult.XONLINE_E_MIX_WEBSGVALIDATIONERROR, false);
                client.GetTokenCategoryByName(tc.TokenCategoryName, HResult.XONLINE_E_MIX_WEBSGVALIDATIONERROR, false);
                client.GetTokenCategoryByOffer(tc.OfferId, HResult.XONLINE_E_MIX_WEBSGVALIDATIONERROR, false);
                client.GenerateTokens(tc.TokenCategoryId, 10, MixTokenHelper.Key, HResult.XONLINE_E_MIX_WEBSGVALIDATIONERROR, false, false);
                client.GetTokenJobStatus(new Guid(), HResult.XONLINE_E_MIX_WEBSGVALIDATIONERROR, false);
                client.GetTokenJobStatusByCategory(new Guid(), HResult.XONLINE_E_MIX_WEBSGVALIDATIONERROR, false);
                client.GetTokenInfoByHash(new byte[20], HResult.XONLINE_E_MIX_WEBSGVALIDATIONERROR, false);
                client.GetTokenInfoByToken("11111-11111-11111-11111-11111", HResult.XONLINE_E_MIX_WEBSGVALIDATIONERROR, false);
            }
        }

        [TestCase, Description("ConfigureTokenCategory - try to create new token category with an invalid PartnerId in WebSG header")]
        class N_ConfigureTC_WebSGHeader_Invalid_PartnerId : WCFTestBase
        {
            public override void Run()
            {
                TokenCategory tc = MixTokenHelper.NewTokenCategory();
                CustomHttpHeader[] headers = MixTokenHelper.CreateNewWebSGHeaders();
                headers[0].value = "DebugPartner123"; // make the Subject Name ('DebugPartner123') an invalid PartnerId
                PrintObject(headers);

                TokenManagementWCFClient client = new TokenManagementWCFClient();
                client.CustomHttpHeaders = headers;
                client.ConfigureTokenCategory(tc, HResult.XONLINE_E_MIX_WEBSGVALIDATIONERROR, false);
            }
        }

        [TestCase, Description("ConfigureTokenCategory - try to create new token category with an invalid ClientIp in WebSG header")]
        class N_ConfigureTC_WebSGHeader_Invalid_ClientIp : WCFTestBase
        {
            public override void Run()
            {
                TokenCategory tc = MixTokenHelper.NewTokenCategory();
                CustomHttpHeader[] headers = MixTokenHelper.CreateNewWebSGHeaders();
                headers[1].value = "1.1.1.2:1000"; // 1.1.1.2 is invalid client ip
                PrintObject(headers);

                TokenManagementWCFClient client = new TokenManagementWCFClient();
                client.CustomHttpHeaders = headers;
                client.ConfigureTokenCategory(tc, HResult.XONLINE_E_MIX_WEBSGVALIDATIONERROR, false);
            }
        }

        [TestCase, Description("ConfigureTokenCategory - try to create new token category with an invalid RequestId in WebSG header")]
        class N_ConfigureTC_WebSGHeader_Invalid_RequestId : WCFTestBase
        {
            public override void Run()
            {
                TokenCategory tc = MixTokenHelper.NewTokenCategory();
                CustomHttpHeader[] headers = MixTokenHelper.CreateNewWebSGHeaders();
                headers[2].value = "1!@6T6R66T6T6T6T6T6T6T6T6"; // an invalid request id
                PrintObject(headers);

                TokenManagementWCFClient client = new TokenManagementWCFClient();
                client.CustomHttpHeaders = headers;
                client.ConfigureTokenCategory(tc, HResult.XONLINE_E_MIX_WEBSGVALIDATIONERROR, false);
            }
        }

        [TestCase, Description("ConfigureTokenCategory - try to create new token category with null PartnerId in WebSG header")]
        class N_ConfigureTC_WebSGHeader_Null_PartnerId : WCFTestBase
        {
            public override void Run()
            {
                TokenCategory tc = MixTokenHelper.NewTokenCategory();
                CustomHttpHeader[] headers = MixTokenHelper.CreateNewWebSGHeaders();
                headers[0].value = null; // null PartnerId
                PrintObject(headers);

                TokenManagementWCFClient client = new TokenManagementWCFClient();
                client.CustomHttpHeaders = headers;
                client.ConfigureTokenCategory(tc, HResult.XONLINE_E_MIX_WEBSGVALIDATIONERROR, false);
            }
        }

        [TestCase, Description("ConfigureTokenCategory - try to create new token category with null ClientIp in WebSG header")]
        class N_ConfigureTC_WebSGHeader_Null_ClientIp : WCFTestBase
        {
            public override void Run()
            {
                TokenCategory tc = MixTokenHelper.NewTokenCategory();
                CustomHttpHeader[] headers = MixTokenHelper.CreateNewWebSGHeaders();
                headers[1].value = null; // null client ip
                PrintObject(headers);

                TokenManagementWCFClient client = new TokenManagementWCFClient();
                client.CustomHttpHeaders = headers;
                client.ConfigureTokenCategory(tc, HResult.XONLINE_E_MIX_WEBSGVALIDATIONERROR, false);
            }
        }

        [TestCase, Description("ConfigureTokenCategory - try to create new token category with null RequestId in WebSG header")]
        class N_ConfigureTC_WebSGHeader_Null_RequestId : WCFTestBase
        {
            public override void Run()
            {
                TokenCategory tc = MixTokenHelper.NewTokenCategory();
                CustomHttpHeader[] headers = MixTokenHelper.CreateNewWebSGHeaders();
                headers[2].value = null; // null request id
                PrintObject(headers);

                TokenManagementWCFClient client = new TokenManagementWCFClient();
                client.CustomHttpHeaders = headers;
                client.ConfigureTokenCategory(tc, HResult.XONLINE_E_MIX_WEBSGVALIDATIONERROR, false);
            }
        }

        [TestCase, Description("ConfigureTokenCategory - try to create new token category with empty Guid OfferId")]
        class N_ConfigureTC_New_OfferId_EmptyGuid : WCFTestBase
        {
            public override void Run()
            {
                TokenCategory tc = MixTokenHelper.NewTokenCategory();
                tc.OfferId = Guid.Empty;

                TokenManagementWCFClient client = new TokenManagementWCFClient();
                client.ConfigureTokenCategory(tc, HResult.E_INVALIDARG, false);
            }
        }

        [TestCase, Description("ConfigureTokenCategory - try to create new token category with ProductTypeId zero")]
        class N_ConfigureTC_New_ProductTypeId_Zero : WCFTestBase
        {
            public override void Run()
            {
                TokenCategory tc = MixTokenHelper.NewTokenCategory();
                tc.ProductTypeId = 0;

                TokenManagementWCFClient client = new TokenManagementWCFClient();
                client.ConfigureTokenCategory(tc, HResult.E_INVALIDARG, false);
            }
        }

        [TestCase, Description("ConfigureTokenCategory - try to create new token category with empty Guid TokenCategoryId")]
        class N_ConfigureTC_New_TokenCategoryId_EmptyGuid : WCFTestBase
        {
            public override void Run()
            {
                TokenCategory tc = MixTokenHelper.NewTokenCategory();
                tc.TokenCategoryId = Guid.Empty;

                TokenManagementWCFClient client = new TokenManagementWCFClient();
                client.ConfigureTokenCategory(tc, HResult.E_INVALIDARG, false);
            }
        }

        [TestCase, Description("ConfigureTokenCategory - try to create new token category with TokenCategoryName null")]
        class N_ConfigureTC_New_TokenCategoryName_Null : WCFTestBase
        {
            public override void Run()
            {
                TokenCategory tc = MixTokenHelper.NewTokenCategory();
                tc.TokenCategoryName = null;

                TokenManagementWCFClient client = new TokenManagementWCFClient();
                client.ConfigureTokenCategory(tc, HResult.E_INVALIDARG, false);
            }
        }

        [TestCase, Description("ConfigureTokenCategory - try to create new token category with TokenCategoryName empty")]
        class N_ConfigureTC_New_TokenCategoryName_Empty : WCFTestBase
        {
            public override void Run()
            {
                TokenCategory tc = MixTokenHelper.NewTokenCategory();
                tc.TokenCategoryName = "";

                TokenManagementWCFClient client = new TokenManagementWCFClient();
                client.ConfigureTokenCategory(tc, HResult.E_INVALIDARG, false);
            }
        }

        [TestCase, Description("ConfigureTokenCategory - try to create new token category with a long TokenCategoryName")]
        class N_ConfigureTC_New_TokenCategoryName_VeryLong : WCFTestBase
        {
            public override void Run()
            {
                TokenCategory tc = MixTokenHelper.NewTokenCategory();
                tc.TokenCategoryName = new string('A', 101);

                TokenManagementWCFClient client = new TokenManagementWCFClient();
                client.ConfigureTokenCategory(tc, HResult.E_INVALIDARG, false);
            }
        }

        [TestCase, Description("ConfigureTokenCategory - try to create new token category with null Pkpn")]
        class N_ConfigureTC_New_Pkpn_Null : WCFTestBase
        {
            public override void Run()
            {
                TokenCategory tc = MixTokenHelper.NewTokenCategory();
                tc.Pkpn = null;

                TokenManagementWCFClient client = new TokenManagementWCFClient();
                client.ConfigureTokenCategory(tc, HResult.E_INVALIDARG, false);
            }
        }

        [TestCase, Description("ConfigureTokenCategory - try to create new token category with empty Pkpn")]
        class N_ConfigureTC_New_Pkpn_Empty : WCFTestBase
        {
            public override void Run()
            {
                TokenCategory tc = MixTokenHelper.NewTokenCategory();
                tc.Pkpn = "";

                TokenManagementWCFClient client = new TokenManagementWCFClient();
                client.ConfigureTokenCategory(tc, HResult.E_INVALIDARG, false);
            }
        }

        [TestCase, Description("ConfigureTokenCategory - try to create new token category with a long Pkpn")]
        class N_ConfigureTC_New_Pkpn_VeryLong : WCFTestBase
        {
            public override void Run()
            {
                TokenCategory tc = MixTokenHelper.NewTokenCategory();
                tc.Pkpn = new string('A', 17);  // the upper limit is 16

                TokenManagementWCFClient client = new TokenManagementWCFClient();
                client.ConfigureTokenCategory(tc, HResult.E_INVALIDARG, false);
            }
        }

        [TestCase, Description("ConfigureTokenCategory - try to set read only property OfferId")]
        class N_ConfigureTC_Update_Readonly_OfferId : WCFTestBase
        {
            public override void Run()
            {
                TokenCategory tc = MixTokenHelper.CreateTokenCategoryFrom(MixTokenHelper.GlobalTC);
                tc.OfferId = Guid.NewGuid();

                TokenManagementWCFClient client = new TokenManagementWCFClient();
                client.ConfigureTokenCategory(tc, HResult.XONLINE_E_TOKEN_CATEGORY_READ_ONLY_PROPERTY_CHANGE, false);
            }
        }

        [TestCase, Description("ConfigureTokenCategory - try to set read only property PromotionId")]
        class N_ConfigureTC_Update_Readonly_PromotionId : WCFTestBase
        {
            public override void Run()
            {
                TokenCategory tc = MixTokenHelper.CreateTokenCategoryFrom(MixTokenHelper.GlobalTC);
                tc.PromotionId = Guid.NewGuid();

                TokenManagementWCFClient client = new TokenManagementWCFClient();
                client.ConfigureTokenCategory(tc, HResult.XONLINE_E_TOKEN_CATEGORY_READ_ONLY_PROPERTY_CHANGE, false);
            }
        }

        [TestCase, Description("ConfigureTokenCategory - try to set read only property ProductTypeId")]
        class N_ConfigureTC_Update_Readonly_ProductTypeId : WCFTestBase
        {
            public override void Run()
            {
                TokenCategory tc = MixTokenHelper.CreateTokenCategoryFrom(MixTokenHelper.GlobalTC);
                tc.ProductTypeId = tc.ProductTypeId + 1;

                TokenManagementWCFClient client = new TokenManagementWCFClient();
                client.ConfigureTokenCategory(tc, HResult.XONLINE_E_TOKEN_CATEGORY_READ_ONLY_PROPERTY_CHANGE, false);
            }
        }

        [TestCase, Description("ConfigureTokenCategory - try to set read only property InCsat")]
        class N_ConfigureTC_Update_Readonly_InCsat : WCFTestBase
        {
            public override void Run()
            {
                TokenCategory tc = MixTokenHelper.CreateTokenCategoryFrom(MixTokenHelper.GlobalTC);
                tc.InCsat = !(tc.InCsat);

                TokenManagementWCFClient client = new TokenManagementWCFClient();
                client.ConfigureTokenCategory(tc, HResult.XONLINE_E_TOKEN_CATEGORY_READ_ONLY_PROPERTY_CHANGE, false);
            }
        }

        [TestCase, Owner("shwetap"), TestFrequency("Daily"), TestCasePriority(2)]
        [Description("ConfigureTokenCategory - try to set read only property isRSM")]
        class N_ConfigureTC_Update_Readonly_isRSM : WCFTestBase
        {
            public override void Run()
            {
                TokenCategory tc = MixTokenHelper.CreateTokenCategoryFrom(MixTokenHelper.GlobalTC);
                tc.IsRsm = !(tc.IsRsm);

                TokenManagementWCFClient client = new TokenManagementWCFClient();
                client.ConfigureTokenCategory(tc, HResult.XONLINE_E_TOKEN_CATEGORY_READ_ONLY_PROPERTY_CHANGE, false);
            }
        }

        [TestCase, Owner("shwetap"), TestFrequency("Daily"), TestCasePriority(2)]
        [Description("ConfigureTokenCategory - try to set read only property PKPN")]
        class N_ConfigureTC_Update_Readonly_PKPN : WCFTestBase
        {
            public override void Run()
            {
                TokenCategory tc = MixTokenHelper.CreateTokenCategoryFrom(MixTokenHelper.GlobalTC);
                tc.Pkpn = "Updated PKPN";

                TokenManagementWCFClient client = new TokenManagementWCFClient();
                client.ConfigureTokenCategory(tc, HResult.XONLINE_E_TOKEN_CATEGORY_READ_ONLY_PROPERTY_CHANGE, false);
            }
        }

        [TestCase, Description("ConfigureTokenCategory - try to set read only property ChannelTypeId")]
        class N_ConfigureTC_Update_Readonly_ChannelTypeId : WCFTestBase
        {
            public override void Run()
            {
                TokenCategory tc = MixTokenHelper.CreateTokenCategoryFrom(MixTokenHelper.GlobalTC);
                tc.ChannelTypeId = tc.ChannelTypeId + 1;

                TokenManagementWCFClient client = new TokenManagementWCFClient();
                client.ConfigureTokenCategory(tc, HResult.XONLINE_E_TOKEN_CATEGORY_READ_ONLY_PROPERTY_CHANGE, false);
            }
        }

        [TestCase, Description("ConfigureTokenCategory - try to set read only property IsRevenueBearing")]
        class N_ConfigureTC_Update_Readonly_IsRevenueBearing : WCFTestBase
        {
            public override void Run()
            {
                TokenCategory tc = MixTokenHelper.CreateTokenCategoryFrom(MixTokenHelper.GlobalTC);
                tc.IsRevenueBearing = !(tc.IsRevenueBearing);

                TokenManagementWCFClient client = new TokenManagementWCFClient();
                client.ConfigureTokenCategory(tc, HResult.XONLINE_E_TOKEN_CATEGORY_READ_ONLY_PROPERTY_CHANGE, false);
            }
        }

        [TestCase, Description("ConfigureTokenCategory - try to set read only property IsRoyaltyBearing")]
        class N_ConfigureTC_Update_Readonly_IsRoyaltyBearing : WCFTestBase
        {
            public override void Run()
            {
                TokenCategory tc = MixTokenHelper.CreateTokenCategoryFrom(MixTokenHelper.GlobalTC);
                tc.IsRoyaltyBearing = !(tc.IsRoyaltyBearing);

                TokenManagementWCFClient client = new TokenManagementWCFClient();
                client.ConfigureTokenCategory(tc, HResult.XONLINE_E_TOKEN_CATEGORY_READ_ONLY_PROPERTY_CHANGE, false);
            }
        }

        [TestCase, Description("ConfigureTokenCategory - try to set IsRedeemable from false to true")]
        class P_ConfigureTC_Update_IsRedeemable : WCFTestBase
        {
            public override void Run()
            {
                TokenCategory firstTc = MixTokenHelper.NewTokenCategory();
                firstTc.IsRedeemable = false;
                TokenManagementWCFClient client = new TokenManagementWCFClient();
                client.ConfigureTokenCategory(firstTc);

                TokenCategory tc = MixTokenHelper.CreateTokenCategoryFrom(firstTc);
                // IsRedeemable is allowed to change from false to true
                tc.IsRedeemable = true;

                client.ConfigureTokenCategory(tc);
            }
        }

        [TestCase, Description("ConfigureTokenCategory - try to set IsRedeemable from true to false")]
        class N_ConfigureTC_Update_Readonly_IsRedeemable : WCFTestBase
        {
            public override void Run()
            {
                TokenCategory tc = MixTokenHelper.CreateTokenCategoryFrom(MixTokenHelper.GlobalTC);
                // in GlobalTC, IsRedeemable is true. Update to false will fail
                tc.IsRedeemable = false;

                TokenManagementWCFClient client = new TokenManagementWCFClient();
                client.ConfigureTokenCategory(tc, HResult.XONLINE_E_TOKEN_CATEGORY_READ_ONLY_PROPERTY_CHANGE, false);
            }
        }

        [TestCase, Description("ConfigureTokenCategory - Duplicate Token Category name succeeds")]
        class P_ConfigureTC_Update_Duplicate_TokenCategoryName : WCFTestBase
        {
            public override void Run()
            {
                TokenCategory tc = MixTokenHelper.NewTokenCategory();
                tc.TokenCategoryName = MixTokenHelper.GlobalTC.TokenCategoryName;   // make the token category name the same as an existing one

                TokenManagementWCFClient client = new TokenManagementWCFClient();
                client.ConfigureTokenCategory(tc);
            }
        }

        [TestCase, Description("ConfigureTokenCategory - try to configure new token category for subscription product")]
        class N_ConfigureTC_Subscription : WCFTestBase
        {
            public override void Run()
            {
                TokenCategory tc = MixTokenHelper.NewTokenCategoryInCsatLiveSubscription();

                TokenManagementWCFClient client = new TokenManagementWCFClient();
                client.ConfigureTokenCategory(tc, HResult.E_INVALIDARG, false);
            }
        }

        [TestCase, Description("ConfigureTokenCategory - try to configure new token category for points bundle product")]
        class N_ConfigureTC_PointsBundle : WCFTestBase
        {
            public override void Run()
            {
                TokenCategory tc = MixTokenHelper.NewTokenCategoryInCsatPointsBundle();

                TokenManagementWCFClient client = new TokenManagementWCFClient();
                client.ConfigureTokenCategory(tc, HResult.E_INVALIDARG, false);
            }
        }

        [TestCase, Description("GetTokenCategoryById - token category id is empty Guid")]
        class N_GetTokenCategoryById_EmptyGuid : WCFTestBase
        {
            public override void Run()
            {
                TokenManagementWCFClient client = new TokenManagementWCFClient();
                client.GetTokenCategoryById(Guid.Empty, HResult.XONLINE_E_TOKEN_NO_CATEGORY_FOUND, false);
            }
        }

        [TestCase, Description("GetTokenCategoryById - token category id is an invalid Guid")]
        class N_GetTokenCategoryById_InvalidGuid : WCFTestBase
        {
            public override void Run()
            {
                TokenManagementWCFClient client = new TokenManagementWCFClient();
                client.GetTokenCategoryById(Guid.NewGuid(), HResult.XONLINE_E_TOKEN_NO_CATEGORY_FOUND, false);
            }
        }

        [TestCase, Description("GetTokenCategoryByName - token category name is empty string")]
        class N_GetTokenCategoryByName_EmptyName : WCFTestBase
        {
            public override void Run()
            {
                TokenManagementWCFClient client = new TokenManagementWCFClient();
                client.GetTokenCategoryByName("", HResult.XONLINE_E_TOKEN_NO_CATEGORY_FOUND, false);
            }
        }

        [TestCase, Description("GetTokenCategoryByName - token category name is null")]
        class N_GetTokenCategoryByName_NullName : WCFTestBase
        {
            public override void Run()
            {
                TokenManagementWCFClient client = new TokenManagementWCFClient();
                client.GetTokenCategoryByName(null, HResult.XONLINE_E_TOKEN_NO_CATEGORY_FOUND, false);
            }
        }

        [TestCase, Description("GetTokenCategoryByName - token category name is invalid")]
        class N_GetTokenCategoryByName_InvalidName : WCFTestBase
        {
            public override void Run()
            {
                TokenManagementWCFClient client = new TokenManagementWCFClient();
                client.GetTokenCategoryByName(Guid.NewGuid().ToString(), HResult.XONLINE_E_TOKEN_NO_CATEGORY_FOUND, false);
            }
        }

        [TestCase, Description("GetTokenCategoryByName - token category name is very long")]
        class N_GetTokenCategoryByName_VeryLongName : WCFTestBase
        {
            public override void Run()
            {
                TokenManagementWCFClient client = new TokenManagementWCFClient();
                client.GetTokenCategoryByName(new string('A', 101), HResult.XONLINE_E_TOKEN_NO_CATEGORY_FOUND, false);
            }
        }

        [TestCase, Description("GetTokenCategoryByOffer - offer id is empty Guid")]
        class N_GetTokenCategoryByOffer_EmptyOfferGuid : WCFTestBase
        {
            public override void Run()
            {
                TokenManagementWCFClient client = new TokenManagementWCFClient();
                client.GetTokenCategoryByOffer(Guid.Empty, HResult.E_INVALIDARG, false);
            }
        }

        [TestCase, Description("GetTokenCategoryByOffer - offer id is a not found Guid")]
        class N_GetTokenCategoryByOffer_NotFoundOfferGuid : WCFTestBase
        {
            public override void Run()
            {
                TokenManagementWCFClient client = new TokenManagementWCFClient();
                TokenCategory[] tcs = client.GetTokenCategoryByOffer(Guid.NewGuid());
                if(tcs == null)
                {
                    throw new UnexpectedTestResultException("GetTokenCategoryByOffer unexpectedly returned null");
                }
                if(tcs.Length > 0)
                {
                    throw new UnexpectedTestResultException(string.Format("GetTokenCategoryByOffer unexpectedly returned {0} results", tcs.Length));
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Test\TitleManagementTest\TitleManagementTests.cs ===
ï»¿//TitleManagement Tests for the MIX Title Management API

using System;
using System.Collections;
using System.Collections.Generic;
using System.ServiceModel;
using System.Runtime.Serialization;
using System.IO;
using System.Threading;
using System.Xml;
using System.Text;
using System.Text.RegularExpressions;
using System.Net;
using System.Security.Cryptography;
using ServerTestFramework;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.LiveService;
using ServerTestFramework.Utilities;
using System.Linq;
using System.Data.SqlClient;
using xonline.common.xlastutil;

using xonline.common.config;
using xonline.common.sql;
using xonline.mix.common;
using xonline.mix.titlemanagement.contracts.V2;
using MIXTesting;
using MIXTestingUtilsV2;

using ServerTestFramework.Database;


namespace MixTest
{

    public abstract class MixTitleV2TestBase: WCFTestBase
    {
        public TitleManagementV2WCFClient titleClient;
        public MatchWCFClient matchClient;
        public StatsWCFClient statsClient;

        public override void PreRun()
        {
            titleClient = new TitleManagementV2WCFClient();
            matchClient = new MatchWCFClient();
            statsClient = new StatsWCFClient();
        }
    }

    /// <summary>
    /// This test group covers the title management submission API.
    /// </summary>
    /// 
    [TestGroup, Owner("esebeni"), Description("Mix Title Management Positive Tests")]
    public class TitleManagementTests_Positive : TestNode
    {
        public override void OneTimeSetup()
        {
            base.OneTimeSetup();

            MIXTesting.Config.EnableAPIs(Interface.mixtitlemanagement, "Xonline.Mix.TitleManagement.Service", "MixTitleManagement.ConfigureTitle", "MixTitleManagement.AddBaseVersion");
        }

        [TestCase, Description("BasicTest - Prop a basic, non-complex title.")]
        class P_BasicTest : MixTitleV2TestBase
        {
            public override void Run()
            {
                if (titleClient.propTitle((uint)TM_Titles.BASIC)!=TEST_RESULTS.PASSED)
                {
                    throw new UnexpectedTestResultException("titleClient.propTitle failed");
                }
            }
        }

        [TestCase, Description("ComplexTest - Prop a complex title with many strings, contexts, etc.  Using the Lips xlast.")]
        class P_ComplexTest : MixTitleV2TestBase
        {
            public override void Run()
            {
                if (titleClient.propTitle((uint)TM_Titles.LIPS)!=TEST_RESULTS.PASSED)
                {
                    throw new UnexpectedTestResultException("titleClient.propTitle failed");
                }
            }
        }

        [TestCase, Description("Exceptions - Prop a title with data that violates exceptions that aren't currently violated by production titles.")]
        class P_Exceptions : MixTitleV2TestBase
        {
            public override void Run()
            {
                if (titleClient.propTitle((uint)TM_Titles.EXCEPTIONS)!=TEST_RESULTS.PASSED)
                {
                    throw new UnexpectedTestResultException("titleClient.propTitle failed");
                }
            }
        }

        [TestCase, Description("Reprop - Re-Prop a title.")]
        class P_RepropTest : MixTitleV2TestBase
        {
            public override void Run()
            {
                // Prop the replacement file
                string xlast = titleClient.GetXlast((uint)TM_Titles.BASIC);
                byte[] compressedXLast = titleClient.CompressXlast(xlast);
                titleClient.AddBaseVersion((uint)TM_Titles.BASIC, 1, PlatformType.Xenon);
                titleClient.ConfigureTitle(compressedXLast);
                
                if (!titleClient.ValidateSuccessfulProp((uint)TM_Titles.BASIC, xlast))
                {
                    throw new UnexpectedTestResultException("ValidateSuccessfulProp failed");
                }

                // Re-prop the basic title, with some modifications
                xlast = titleClient.GetXlast((uint)TM_Titles.BASIC_REPROP);
                compressedXLast = titleClient.CompressXlast(xlast);

                // Set up the reload watcher
                string[] servers = xonline.common.config.Config.GetServerListByInterface(Interface.kdcsvc);
                ServerTestFramework.Utilities.Events change = new ServerTestFramework.Utilities.Events(servers);
                change.Source = "Xkdc";
                change.Init();
            
                // Re-prop
                titleClient.ConfigureTitle(compressedXLast);

                //validate that the xlast file for that titleID is now the new one
                bool success = titleClient.ValidateSuccessfulProp((uint)TM_Titles.BASIC, xlast);

                titleClient.Cleanup((uint)TM_Titles.BASIC);

                if (success)
                {
                    bool reset = change.TestForChange("Reinitialize: completed reinitialization.");
                    if (!reset)
                    {
                        throw new UnexpectedTestResultException("Did not find reset");
                    }
                }
                else
                {
                    throw new UnexpectedTestResultException("ValidateSuccessfulProp failed");
                }
            }
        }

        [TestCase, Description("NoReload - confirm that if we do not reload kdc if set to true")]
        class P_NoReloadTest : MixTitleV2TestBase
        {
            public override void Run()
            {
                // Get the byte array
                string xlast = titleClient.GetXlast((uint)TM_Titles.BASIC);
                byte[] compressedXLast = titleClient.CompressXlast(xlast);

                // Set up the reload watcher
                string[] servers = xonline.common.config.Config.GetServerListByInterface(Interface.kdcsvc);
                ServerTestFramework.Utilities.Events change = new ServerTestFramework.Utilities.Events(servers);
                change.Source = "Xkdc";
                change.Init();

                // Add a version
                titleClient.AddBaseVersion((uint)TM_Titles.BASIC, 1, PlatformType.Xenon);

                // Configure the title
                titleClient.ConfigureTitle(compressedXLast, true);

                // Validate and clean up.
                bool success = titleClient.ValidateSuccessfulProp((uint)TM_Titles.BASIC, xlast);
                titleClient.Cleanup((uint)TM_Titles.BASIC);

                if (success)
                {
                    bool reset = change.TestForChange("Reinitialize: completed reinitialization.");
                    if (reset)
                    {
                        throw new UnexpectedTestResultException("Unexpectedly found reset");
                    }
                }
                else
                {
                    throw new UnexpectedTestResultException("ValidateSuccessfulProp failed");
                }
            }
        }
    }

    [TestGroup, Owner("esebeni"), Description("Mix Title Management Negative Tests")]
    public class TitleManagementTests_Negative : TestNode
    {
        public override void OneTimeSetup()
        {
            base.OneTimeSetup();

            MIXTesting.Config.EnableAPIs(Interface.mixtitlemanagement, "Xonline.Mix.TitleManagement.Service", "MixTitleManagement.ConfigureTitle", "MixTitleManagement.AddBaseVersion");
        }

        [TestCase, Description("NullTitleID - Attempt to prop an xlast that has 0 as the TitleID.")]
        class P_NullTitleID : MixTitleV2TestBase
        {
            public override void Run()
            {
                string xlast = titleClient.GetXlast((uint)TM_Titles.NULL_TITLE_ID);
                byte[] compressedXLast = titleClient.CompressXlast(xlast);

                try
                {
                    titleClient.ConfigureTitle(compressedXLast);
                }
                catch(Exception)
                {
                    return;
                }

                throw new UnexpectedTestResultException("Unexpectedly succeeded");
            }
        }

        [TestCase, Description("Null Xlast - Attempt to send a null byte array to the title config API.")]
        class P_NullXlast : MixTitleV2TestBase
        {
            public override void Run()
            {
                try
                {
                    titleClient.ConfigureTitle(null);
                }
                catch (Exception)
                {
                    return;
                }

                throw new UnexpectedTestResultException("Unexpectedly succeeded");
            }
        }

        [TestCase, Description("Blank Xlast - Attempt to send a blank xlast to the title config API.")]
        class P_BlankXlast : MixTitleV2TestBase
        {
            public override void Run()
            {
                string xlast = "";
                byte[] compressedXLast = titleClient.CompressXlast(xlast);

                try
                {
                    titleClient.ConfigureTitle(compressedXLast);
                }
                catch (Exception)
                {
                    return;
                }

                throw new UnexpectedTestResultException("Unexpectedly succeeded");

            }
        }

        [TestCase, Description("CorruptCompression - Attempt to prop an xlast that's had its compression corrupted.")]
        class P_CorruptCompression : MixTitleV2TestBase
        {
            public override void Run()
            {
                string xlast = titleClient.GetXlast((uint)TM_Titles.BASIC);
                byte[] compressedXLast = titleClient.CompressXlast(xlast);
                compressedXLast[0] = (byte)((compressedXLast[0] + 1) % 16); // Mess up the compression

                try
                {
                    titleClient.ConfigureTitle(compressedXLast);
                }
                catch (Exception)
                {
                    return;
                }

                throw new UnexpectedTestResultException("Unexpectedly succeeded");
            }
        }
    }

    [TestGroup, EnvRequirement("Xblobonly"), Owner("esebeni"), Description("Mix Title Management Bulk Propping Tests")]
    public class TitleManagementTests_Bulk : TestNode
    {
        public override void OneTimeSetup()
        {
            base.OneTimeSetup();

            MIXTesting.Config.EnableAPIs(Interface.mixtitlemanagement, "Xonline.Mix.TitleManagement.Service", "MixTitleManagement.ConfigureTitle", "MixTitleManagement.AddBaseVersion");
            MIXTesting.Config.EnableAPIs(Interface.mixmatch, "Xonline.Mix.Match.Service", "MixMatch.ConfigureMatchmaking");
            MIXTesting.Config.EnableAPIs(Interface.mixstats, "Xonline.Mix.Stats.Service", "MixStats.ConfigureLeaderboards");
        }

        [TestCase, Description("BulkBasic - Prop a very large number of titles with varying structures.")]
        class P_BulkBasic : MixTitleV2TestBase
        {
            public override void Run()
            {
                List<string> failures = new List<string>();
                string[] titles = titleClient.GetBulkTitlesList();
                if ((null == titles) || (0 == titles.Length))
                {
                    throw new DidNotExecuteException(string.Format("Unable to retrieve list of titles to prop from {0}.  Test not run.", titleClient.BulkTitlePath));
                }

                for (int i = 0; i < titles.Length; i++)
                {
                    string s = titles[i];
                    try
                    {

                        Global.RO.Info("Attempting to prop {0}/{1}:  {2}", i, titles.Length, s);

                        if (!PropBulkTitle(s))
                        {
                            Global.RO.Warn("Failed to prop {0}", s);
                            failures.Add(s);
                        }
                        else
                        {
                            Global.RO.Success("Successfully propped {0}", s);
                        }
                    }
                    catch (UnexpectedTestResultException e)
                    {
                        if (e.InnerException != null)
                        {
                            if (e.InnerException.Message.Contains("The cached Webstore deployment configuration information has expired.")
                                || e.Message.Equals("The service operation timed out.")) // Needs to retry
                            {
                                // Sleep for a minute so the xblob can work through whatever issues it's having
                                Global.RO.Warn("Webstore deployment config cache has expired or there was an unexpected timeout.  Retrying in 60 seconds.");
                                Thread.Sleep(60000);
                                i--; // Decrement i so we don't actually increase in index next iteration
                                continue;
                            }
                        }
                        Global.RO.Warn("Failed to prop {0}", s);
                        Global.RO.Warn("Error:{0}\n{1}", e.Message, e.StackTrace);
                        failures.Add(s);
                    }
                    catch (System.TimeoutException)
                    {
                        // Sleep for a minute so the xblob can work through whatever issues it's having
                        Global.RO.Warn("Timed out when contacting server.  Retrying in 60 seconds.");
                        Thread.Sleep(60000);
                        i--; // Decrement i so we don't actually increase in index next iteration
                    }
                    catch (Exception e)
                    {
                        Global.RO.Warn("Failed to prop {0}", s);
                        Global.RO.Warn("Error:{0}\n{1}", e.Message, e.StackTrace);
                        failures.Add(s);
                    }
                }

                if (failures.Count != 0)
                {
                    Global.RO.Warn(failures.Count + " failures propping xlasts:\n");
                    foreach (string s in failures)
                    {
                        Global.RO.Warn("\t{0}", s);
                    }
                    int total = titles.Length;
                    int fails = failures.Count;
                    int successes = total - fails;
                    throw new UnexpectedTestResultException(string.Format("Results:  {0}/{1} titles passed, {2} failures.  Pass Rate: {3:0.##}%", successes, total, fails, ((double)successes) / total * 100));
                }
            }

            public bool PropBulkTitle(string s)
            {


                string xlast = titleClient.GetBulkXlast(s);
                XboxLiveSubmissionProject xlsp = XlastUtil.GetXlastFromXml(xlast);
                uint titleID = System.Convert.ToUInt32(xlsp.GameConfigProject.titleId, 16);

                // Assume success
                bool success = true;

                // Set up the version
                titleClient.AddBaseVersion(titleID, 1, PlatformType.Xenon);

                titleClient.ConfigureTitle(titleClient.CompressXlast(xlast));
                if (!titleClient.ValidateSuccessfulProp(titleID, xlast))
                {
                    success = false;
                    goto cleanup;
                }
                matchClient.ConfigureMatchmaking(titleID, false, false, false, true);
                if (!matchClient.Verify(titleID))
                {
                    success = false;
                    goto cleanup;
                }
                statsClient.ConfigureLeaderboards(titleID);
                if (TEST_RESULTS.PASSED != statsClient.VerifyXbox360StatsData(titleID, s, true))
                {
                    success = false;
                    goto cleanup;
                }

            cleanup:

                matchClient.ClearDB(titleID);
                statsClient.DeleteLeaderboards(titleID);
                titleClient.Cleanup(titleID);

                return success;
            }
        }

        static string dropDirectory = @"\\esebeni1\share\xlast\drop";
        [TestCase, Description(@"Prop xlast files located at \\esebeni1\share\xlast\drop.")]
        class P_PropDropTitles : MixTitleV2TestBase
        {
            public override void Run()
            {
                string[] titles = Directory.GetFiles(dropDirectory, "*.xlast", SearchOption.AllDirectories);
                if ((null == titles) || (0 == titles.Length))
                {
                    throw new DidNotExecuteException(string.Format("Unable to retrieve list of titles to prop from {0}.  Test not run.", dropDirectory));
                }

                for (int i = 0; i < titles.Length;  i++)
                {
                    string s = titles[i];
                    Global.RO.Info("Propping {0}/{1}:  {2}", i, titles.Length, s);
                    string xlast = titleClient.GetDropXlast(s);
                    byte[] bytes = titleClient.CompressXlast(xlast);
                    titleClient.ConfigureTitle(bytes);
                }
            }
        }

        [TestCase, Description("BulkBasic - Prop a very large number of titles with varying structures.")]
        class P_CleanDropTitles : MixTitleV2TestBase
        {
            public override void Run()
            {
                string[] titles = Directory.GetFiles(dropDirectory, "*.xlast", SearchOption.AllDirectories);
                if ((null == titles) || (0 == titles.Length))
                {
                    throw new DidNotExecuteException(string.Format("Unable to retrieve list of titles to prop from {0}.  Test not run.", dropDirectory));
                }

                for (int i = 0; i < titles.Length; i++)
                {
                    string s = titles[i];
                    Global.RO.Info("Cleaning up {0}/{1}:  {2}", i, titles.Length, s);
                    string xlast = titleClient.GetDropXlast(s);
                    XboxLiveSubmissionProject xlsp = XlastUtil.GetXlastFromXml(xlast);
                    titleClient.Cleanup(Convert.ToUInt32(xlsp.GameConfigProject.titleId, 16));
                }
            }
        }

        [TestCase, Description("BulkBasic - Prop a very large number of titles with varying structures.")]
        class P_TestDropTitles : MixTitleV2TestBase
        {
            public override void Run()
            {
                string[] titles = Directory.GetFiles(dropDirectory, "*.xlast", SearchOption.AllDirectories);
                if ((null == titles) || (0 == titles.Length))
                {
                    throw new DidNotExecuteException(string.Format("Unable to retrieve list of titles to prop from {0}.  Test not run.", dropDirectory));
                }

                for (int i = 0; i < titles.Length;  i++)
                {
                    string s = titles[i];
                    Global.RO.Info("Propping {0}/{1}:  {2}", i, titles.Length, s);
                    PropBulkTitle(s);
                }
            }

            public bool PropBulkTitle(string s)
            {
                string xlast = titleClient.GetDropXlast(s);
                XboxLiveSubmissionProject xlsp = XlastUtil.GetXlastFromXml(xlast);
                uint titleID = System.Convert.ToUInt32(xlsp.GameConfigProject.titleId, 16);

                // Assume success
                bool success = true;

                // Set up the version
                titleClient.AddBaseVersion(titleID, 1, PlatformType.Xenon);

                titleClient.ConfigureTitle(titleClient.CompressXlast(xlast));
                if (!titleClient.ValidateSuccessfulProp(titleID, xlast))
                {
                    success = false;
                    goto cleanup;
                }
                matchClient.ConfigureMatchmaking(titleID, false, false, false, true);
                if (!matchClient.Verify(titleID))
                {
                    success = false;
                    goto cleanup;
                }
                statsClient.ConfigureLeaderboards(titleID);
                if (TEST_RESULTS.PASSED != statsClient.VerifyXbox360StatsData(titleID, s, true))
                {
                    success = false;
                    goto cleanup;
                }

            cleanup:

                matchClient.ClearDB(titleID);
                statsClient.DeleteLeaderboards(titleID);
                titleClient.Cleanup(titleID);

                return success;
            }
        }
    }

    [TestGroup, Owner("esebeni"), Description("")]
    public class AddRemoveBaseVersionTests_Positive : TestNode
    {
        public override void OneTimeSetup()
        {
            base.OneTimeSetup();

            MIXTesting.Config.EnableAPIs(Interface.mixtitlemanagement, "Xonline.Mix.TitleManagement.Service", "MixTitleManagement.RemoveBaseVersion", "MixTitleManagement.AddBaseVersion", "MixTitleManagement.GetTitleVersions");
        }

        [TestCase, Description("")]
        class P_Basic : MixTitleV2TestBase
        {
            public override void Run()
            {

                if (!titleClient.AddAndVerifyVersions((uint) TM_Titles.BASIC, Versions.Basic))
                    throw new UnexpectedTestResultException("AddAndVerifyVersions failed");

                if (!titleClient.RemoveAndVerifyVersions((uint)TM_Titles.BASIC, Versions.Basic))
                    throw new UnexpectedTestResultException("RemoveAndVerifyVersions failed");
            }

            public override void PostRun()
            {
                titleClient.RemoveAllVersions((uint)TM_Titles.BASIC);
            }
        }

        [TestCase, Description("")]
        class P_ProppedTitle : MixTitleV2TestBase
        {
            public override void Run()
            {

                string xlast = titleClient.GetXlast((uint)TM_Titles.BASIC);
                byte[] compressedXLast = titleClient.CompressXlast(xlast);
                titleClient.AddBaseVersion((uint)TM_Titles.BASIC, 1, PlatformType.Xenon);
                titleClient.ConfigureTitle(compressedXLast);

                if (!titleClient.ValidateSuccessfulProp((uint)TM_Titles.BASIC, xlast))
                {
                    throw new UnexpectedTestResultException("ValidateSuccessfulProp failed");
                }

                if (!titleClient.AddAndVerifyVersions((uint)TM_Titles.BASIC, Versions.Basic))
                    throw new UnexpectedTestResultException("AddAndVerifyVersions failed");

                titleClient.Cleanup((uint)TM_Titles.BASIC);
            }

            public override void PostRun()
            {
                titleClient.RemoveAllVersions((uint)TM_Titles.BASIC);
            }
        }

        [TestCase, Description("")]
        class P_RemoveOnlyVersionFromProppedTitle : MixTitleV2TestBase
        {
            public override void Run()
            {

                string xlast = titleClient.GetXlast((uint)TM_Titles.BASIC);
                byte[] compressedXLast = titleClient.CompressXlast(xlast);
                titleClient.AddBaseVersion((uint)TM_Titles.BASIC, 1, PlatformType.Xenon);
                titleClient.ConfigureTitle(compressedXLast);

                if (!titleClient.ValidateSuccessfulProp((uint)TM_Titles.BASIC, xlast))
                {
                    throw new UnexpectedTestResultException("ValidateSuccessfulProp failed");
                }

                if (!titleClient.RemoveAndVerifyVersions((uint)TM_Titles.BASIC, Versions.Basic)) // The 'Basic' case is the version that is propped when the title is propped
                {
                    titleClient.Cleanup((uint)TM_Titles.BASIC);
                    throw new UnexpectedTestResultException("RemoveAndVerifyVersions failed");
                }

                titleClient.Cleanup((uint)TM_Titles.BASIC);
            }

            public override void PostRun()
            {
                titleClient.RemoveAllVersions((uint)TM_Titles.BASIC);
            }
        }

        [TestCase, Description("")]
        class P_MultiPlatform : MixTitleV2TestBase
        {
            public override void Run()
            {

                if (!titleClient.AddAndVerifyVersions((uint)TM_Titles.BASIC, Versions.MultiPlatform))
                    throw new UnexpectedTestResultException("AddAndVerifyVersions failed");

                if (!titleClient.RemoveAndVerifyVersions((uint)TM_Titles.BASIC, Versions.MultiPlatform))
                    throw new UnexpectedTestResultException("RemoveAndVerifyVersions failed");
            }

            public override void PostRun()
            {
                titleClient.RemoveAllVersions((uint)TM_Titles.BASIC);
            }
        }

        [TestCase, Description("")]
        class P_MultiVersion : MixTitleV2TestBase
        {
            public override void Run()
            {
                if (!titleClient.AddAndVerifyVersions((uint)TM_Titles.BASIC, Versions.MultiVersion))
                    throw new UnexpectedTestResultException("AddAndVerifyVersions failed");

                if (!titleClient.RemoveAndVerifyVersions((uint)TM_Titles.BASIC, Versions.MultiVersion))
                    throw new UnexpectedTestResultException("RemoveAndVerifyVersions failed");
            }

            public override void PostRun()
            {
                titleClient.RemoveAllVersions((uint)TM_Titles.BASIC);
            }
        }

        [TestCase, Description("")]
        class P_MultiTitle : MixTitleV2TestBase
        {
            public override void Run()
            {
                if (!titleClient.AddAndVerifyVersions((uint)TM_Titles.BASIC, Versions.Basic))
                    throw new UnexpectedTestResultException("AddAndVerifyVersions failed for Basic");
                if (!titleClient.AddAndVerifyVersions((uint)TM_Titles.LIPS, Versions.Lips))
                    throw new UnexpectedTestResultException("AddAndVerifyVersions failed for Lips");

                if (!titleClient.RemoveAndVerifyVersions((uint)TM_Titles.BASIC, Versions.Basic))
                    throw new UnexpectedTestResultException("RemoveAndVerifyVersions failed for Basic");
                if (!titleClient.RemoveAndVerifyVersions((uint)TM_Titles.LIPS, Versions.Lips))
                    throw new UnexpectedTestResultException("RemoveAndVerifyVersions failed for Lips");
            }

            public override void PostRun()
            {
                titleClient.RemoveAllVersions((uint)TM_Titles.BASIC);
                titleClient.RemoveAllVersions((uint)TM_Titles.LIPS);
            }
        }

        [TestCase, Description("")]
        class P_RemoveOneOfSeveralVersions : MixTitleV2TestBase
        {
            public override void Run()
            {
                if (!titleClient.AddAndVerifyVersions((uint)TM_Titles.BASIC, Versions.MultiVersion))
                    throw new UnexpectedTestResultException("AddAndVerifyVersions failed");

                if (!titleClient.RemoveAndVerifyVersions((uint)TM_Titles.BASIC, Versions.MultiVersion_SecondHalf))
                    throw new UnexpectedTestResultException("RemoveAndVerifyVersions failed");
            }

            public override void PostRun()
            {
                titleClient.RemoveAllVersions((uint)TM_Titles.BASIC);
            }
        }

        [TestCase, Description("")]
        class P_RemoveOneOfSeveralPlatforms : MixTitleV2TestBase
        {
            public override void Run()
            {
                if (!titleClient.AddAndVerifyVersions((uint)TM_Titles.BASIC, Versions.MultiPlatform))
                    throw new UnexpectedTestResultException("AddAndVerifyVersions failed");

                if (!titleClient.RemoveAndVerifyVersions((uint)TM_Titles.BASIC, Versions.MultiPlatform_SecondHalf))
                    throw new UnexpectedTestResultException("RemoveAndVerifyVersions failed");
            }

            public override void PostRun()
            {
                titleClient.RemoveAllVersions((uint)TM_Titles.BASIC);
            }
        }
    }

    [TestGroup, Owner("esebeni"), Description("")]
    public class AddRemoveBaseVersionTests_Negative : TestNode
    {
        public override void OneTimeSetup()
        {
            base.OneTimeSetup();

            MIXTesting.Config.EnableAPIs(Interface.mixtitlemanagement, "Xonline.Mix.TitleManagement.Service", "MixTitleManagement.RemoveBaseVersion", "MixTitleManagement.AddBaseVersion", "MixTitleManagement.GetTitleVersions");
        }

        [TestCase, Description("")]
        class P_InvalidPlatform : MixTitleV2TestBase
        {
            public override void Run()
            {
                bool succeeded=false;
                try
                {
                    if (titleClient.AddAndVerifyVersions((uint)TM_Titles.BASIC, Versions.InvalidPlatform))
                        succeeded=true;

                    if (titleClient.AddAndVerifyVersions((uint)TM_Titles.BASIC, Versions.Marketplace))
                        succeeded=true;
                }
                catch (UnexpectedTestResultException) //!NOTE: It is bad form to expect the unexpected...
                {
                }

                if (succeeded)
                    throw new UnexpectedTestResultException("Unexpectedly succeeded");
            }

            public override void PostRun()
            {
                titleClient.RemoveAllVersions((uint)TM_Titles.BASIC);
            }
        }

        [TestCase, Description("")]
        class P_InvalidTitleID : MixTitleV2TestBase
        {
            public override void Run()
            {
                bool succeeded=false;
                try
                {
                    if (titleClient.AddAndVerifyVersions((uint)TM_Titles.BASIC, Versions.InvalidTitle))
                        succeeded=true;
                }
                catch (UnexpectedTestResultException) //!NOTE: It is bad form to expect the unexpected...
                {
                }

                if (succeeded)
                    throw new UnexpectedTestResultException("Unexpectedly succeeded");
            }

            public override void PostRun()
            {
                titleClient.RemoveAllVersions((uint)TM_Titles.BASIC);
            }
        }

        [TestCase, Description("")]
        class P_RemoveInvalidPlatform : MixTitleV2TestBase
        {
            public override void Run()
            {
                bool succeeded=false;
                try
                {
                    if (titleClient.RemoveAndVerifyVersions((uint)TM_Titles.BASIC, Versions.InvalidPlatform))
                        succeeded=true;
                }
                catch (UnexpectedTestResultException) //!NOTE: It is bad form to expect the unexpected...
                {
                }

                if (succeeded)
                    throw new UnexpectedTestResultException("Unexpectedly succeeded");
            }

            public override void PostRun()
            {
                titleClient.RemoveAllVersions((uint)TM_Titles.BASIC);
            }
        }

        [TestCase, Description("")]
        class P_RemoveNonexistentPlatform : MixTitleV2TestBase
        {
            public override void Run()
            {
                bool succeeded=false;
                try
                {
                    if (titleClient.RemoveAndVerifyVersions((uint)TM_Titles.BASIC, Versions.Marketplace))
                        succeeded=true;
                }
                catch (UnexpectedTestResultException) //!NOTE: It is bad form to expect the unexpected...
                {
                }

                if (succeeded)
                    throw new UnexpectedTestResultException("Unexpectedly succeeded");
            }

            public override void PostRun()
            {
                titleClient.RemoveAllVersions((uint)TM_Titles.BASIC);
            }
        }

        [TestCase, Description("")]
        class P_RemoveInvalidTitleID : MixTitleV2TestBase
        {
            public override void Run()
            {
                bool succeeded=false;
                try
                {
                    if (titleClient.RemoveAndVerifyVersions((uint)TM_Titles.BASIC, Versions.InvalidTitle))
                        succeeded=true;
                }
                catch (UnexpectedTestResultException) //!NOTE: It is bad form to expect the unexpected...
                {
                }

                if (succeeded)
                    throw new UnexpectedTestResultException("Unexpectedly succeeded");
            }

            public override void PostRun()
            {
                titleClient.RemoveAllVersions((uint)TM_Titles.BASIC);
            }
        }
    }

    [TestGroup, Owner("esebeni"), Description("")]
    public class GetTitleVersionsTests_Positive : TestNode
    {
        public override void OneTimeSetup()
        {
            base.OneTimeSetup();

            MIXTesting.Config.EnableAPIs(Interface.mixtitlemanagement, "Xonline.Mix.TitleManagement.Service", "MixTitleManagement.GetTitleVersions");
        }

        [TestCase, Description("")]
        class GetVersionsTest : MixTitleV2TestBase
        {
            public override void Run()
            {
                titleClient.AddBaseVersion((uint)TM_Titles.BASIC, 47, PlatformType.Xenon);
                titleClient.AddBaseVersion((uint)TM_Titles.BASIC, 48, PlatformType.Xenon);

                xonline.mix.titlemanagement.contracts.V2.TitleVersions versions = titleClient.GetTitleVersions((uint)TM_Titles.BASIC);

                foreach (xonline.mix.titlemanagement.contracts.V2.TitleVersionInstance instance in versions.Versions)
                {
                    Global.RO.Info("title:" + instance.TitleId + " base:" + instance.BaseVersion + " update:" + instance.UpdateVersion + " platform:" + instance.PlatformType + " beta group:" + instance.BetaGroup.ToString());
                }

                if (versions.Versions.Length == 2)
                {
                    TitleVersionInstance v1 = versions.Versions[0];
                    TitleVersionInstance v2 = versions.Versions[1];

                    if (v1.TitleId == (uint)TM_Titles.BASIC && v1.BaseVersion == 47 && v1.UpdateVersion == 47 && v1.PlatformType == PlatformType.Xenon && v1.BetaGroup == Guid.Empty &&
                        v2.TitleId == (uint)TM_Titles.BASIC && v2.BaseVersion == 48 && v2.UpdateVersion == 48 && v2.PlatformType == PlatformType.Xenon && v2.BetaGroup == Guid.Empty)
                        return;
                }

                throw new UnexpectedTestResultException("Versions Length is not 2, or Versions are not the same.");
            }

            public override void PostRun()
            {
                titleClient.RemoveAllVersions((uint)TM_Titles.BASIC);
            }
        }
    }

    [TestGroup, Owner("esebeni"), Description("")]
    public class BetaGroupTests_Positive : TestNode
    {
        public override void OneTimeSetup()
        {
            base.OneTimeSetup();

            MIXTesting.Config.EnableAPIs(Interface.mixtitlemanagement, "Xonline.Mix.TitleManagement.Service", "MixTitleManagement.GetTitleVersions", "MixTitleManagement.RemoveBaseVersion", "MixTitleManagement.AddBaseVersion");
        }

        [TestCase, Description("")]
        class BasicAddRemoveGetVersionsTest : MixTitleV2TestBase
        {
            public override void Run()
            {
                TitleVersionInstance v1 = new TitleVersionInstance();
                v1.TitleId = (uint)TM_Titles.BASIC;
                v1.BaseVersion = 1;
                v1.UpdateVersion = 1;
                v1.PlatformType = PlatformType.Xenon;
                v1.BetaGroup = new Guid("F9168C5E-CEB2-4faa-B6BF-329BF39FA1E4");

                TitleVersionInstance v2 = new TitleVersionInstance();
                v2.TitleId = (uint)TM_Titles.BASIC;
                v2.BaseVersion = 1;
                v2.UpdateVersion = 1;
                v2.PlatformType = PlatformType.Xenon;
                v2.BetaGroup = new Guid("936DA01F-9ABD-4d9d-80C7-02AF85C822A8");

                titleClient.AddBaseVersion(v1);
                titleClient.AddBaseVersion(v2);

                xonline.mix.titlemanagement.contracts.V2.TitleVersions addVersions = titleClient.GetTitleVersions((uint)TM_Titles.BASIC);

                foreach (xonline.mix.titlemanagement.contracts.V2.TitleVersionInstance instance in addVersions.Versions)
                {
                    Global.RO.Info("title:" + instance.TitleId + " base:" + instance.BaseVersion + " update:" + instance.UpdateVersion + " platform:" + instance.PlatformType + " beta group:" + instance.BetaGroup.ToString());
                }

                if (addVersions.Versions.Length == 2)
                {
                    // TODO: This is stupid and prone to future failures, need to change.
                    TitleVersionInstance addVersionsv1 = addVersions.Versions[1];
                    TitleVersionInstance addVersionsv2 = addVersions.Versions[0];

                    if (addVersionsv1.TitleId != v1.TitleId || addVersionsv1.BaseVersion != v1.BaseVersion || addVersionsv1.UpdateVersion != v1.UpdateVersion || addVersionsv1.PlatformType != v1.PlatformType || addVersionsv1.BetaGroup != v1.BetaGroup ||
                        addVersionsv2.TitleId != v2.TitleId || addVersionsv2.BaseVersion != v2.BaseVersion || addVersionsv2.UpdateVersion != v2.UpdateVersion || addVersionsv2.PlatformType != v2.PlatformType || addVersionsv2.BetaGroup != v2.BetaGroup)
                        throw new UnexpectedTestResultException("Versions are not the same.");
                }

                titleClient.RemoveBaseVersion(v2);

                xonline.mix.titlemanagement.contracts.V2.TitleVersions removeVersions = titleClient.GetTitleVersions((uint)TM_Titles.BASIC);

                foreach (xonline.mix.titlemanagement.contracts.V2.TitleVersionInstance instance in removeVersions.Versions)
                {
                    Global.RO.Info("title:" + instance.TitleId + " base:" + instance.BaseVersion + " update:" + instance.UpdateVersion + " platform:" + instance.PlatformType + " beta group:" + instance.BetaGroup.ToString());
                }

                if (removeVersions.Versions.Length == 1)
                {
                    TitleVersionInstance addVersionsv1 = removeVersions.Versions[0];

                    if (addVersionsv1.TitleId == v1.TitleId && addVersionsv1.BaseVersion == v1.BaseVersion && addVersionsv1.UpdateVersion == v1.UpdateVersion && addVersionsv1.PlatformType == v1.PlatformType && addVersionsv1.BetaGroup == v1.BetaGroup)
                        return;
                }

                throw new UnexpectedTestResultException("Versions length is not 1, or versions are not the same.");
            }

            public override void PostRun()
            {
                titleClient.RemoveAllVersions((uint)TM_Titles.BASIC);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Test\TokenManagementTest\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Test\TokenManagementTest\TokenInfoTests.cs ===
ï»¿// GetTokenInfo MIX API Tests
// Positive Cases
// Test Case 1. Pass Token that is not existing in the TokenDB (by Token)
// Test Case 2. Pass Token the is existing in the TokenDB (By Token)
//
// Test Case 1. Pass Token Hash that is not existing in the TokenDB (by Hash)
// Test Case 2. Pass Token Hash the is existing in the TokenDB(By Hash)



using System;
using System.Collections;
using System.Collections.Generic;
using System.ServiceModel;
using System.Runtime.Serialization;
using System.IO;
using System.Threading;
using System.Xml;
using System.Text;
using System.Text.RegularExpressions;
using System.Net;
using System.Security.Cryptography;
using ServerTestFramework;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.LiveService;
using ServerTestFramework.Utilities;
using ServerTestFramework.Database;

using xonline.common.config;
using MIXTesting;
using xonline.mix.tokenmanagement.contracts.V1;
using xonline.mix.common;

namespace MixTest
{
    /// <summary>
    /// This test group covers 2 TokenManagement APIs.
    /// GetTokenInfoByToken
    /// GetTokenInfoByHash
    /// </summary>
    ///
    [TestGroup, Owner("yuanfeiw"), TestCasePriority(1), TestFrequency("Daily"), EnvRequirement("Catalog"), Description("Mix TokenInfo Tests")]
    public class TokenInfoTests : TestNode
    {
        private readonly static string NonExistingToken = "!@#blah-blah;yada-yada;~^*!"; // used for some negatvie tests
        private readonly static uint NumTestTokens = 10; // number of test tokens
        private readonly static uint MaxHashSize = 20; // Max Hash size

        public override void OneTimeSetup()
        {
            // lower cron job execution interval from 120 seconds to 50 seconds
            StaticNpdb.ExecuteNonQuery("update dbo.t_cron_jobs set i_exec_interval_secs = 50 where vc_assembly = 'TokenGeneratePlugIns.dll'");
        }

        [TestCase, Description("TokenInfo - Positive Test to test GetTokenInfoByToken & GetTokenInfoById")]
        class P_GetTokenInfo_ByTokenAndHash : WCFTestBase
        {
            public override void Run()
            {
                // Generate set of tokens for a Token Category
                Guid jobId = MixTokenHelper.GenerateTestTokens(MixTokenHelper.GlobalTC.TokenCategoryId, NumTestTokens, MixTokenHelper.Key, true, false);

                // Get the Tokens for the jobId
                TokenEntry[] tokens = MixTokenHelper.GetTokenEntries(jobId, MixTokenHelper.Key);

                // Verify Tokens
                MixTokenHelper.VerifyTokens((int)NumTestTokens, tokens, MixTokenHelper.GlobalTC);
            }
        }

        [TestCase, Description("TokenInfo - Negative Test to test GetTokenInfoByToken an empty token")]
        class N_GetTokenInfo_ByToken_EmptyToken : WCFTestBase
        {
            public override void Run()
            {
                TokenManagementWCFClient client = new TokenManagementWCFClient();
                client.GetTokenInfoByToken("", HResult.E_INVALIDARG, false);
            }
        }

        [TestCase, Description("TokenInfo - Negative Test to test GetTokenInfoByToken a null token")]
        class N_GetTokenInfo_ByToken_NullToken : WCFTestBase
        {
            public override void Run()
            {
                TokenManagementWCFClient client = new TokenManagementWCFClient();
                client.GetTokenInfoByToken(null, HResult.E_INVALIDARG, false);
            }
        }

        [TestCase, Description("TokenInfo - Negative Test to test GetTokenInfoByToken a long token")]
        class N_GetTokenInfo_ByToken_VeryLongToken : WCFTestBase
        {
            public override void Run()
            {
                TokenManagementWCFClient client = new TokenManagementWCFClient();
                client.GetTokenInfoByToken(new string('A', 101), HResult.XONLINE_E_ACCOUNTS_INVALID_VOUCHER, false);
            }
        }

        [TestCase, Description("TokenInfo - Negative Test to test GetTokenInfoByToken an invalid token")]
        class N_GetTokenInfo_ByToken_invalid : WCFTestBase
        {
            public override void Run()
            {
                TokenManagementWCFClient client = new TokenManagementWCFClient();
                client.GetTokenInfoByToken(MixTokenHelper.AllZeroToken, HResult.XONLINE_E_ACCOUNTS_INVALID_VOUCHER, false);
            }
        }

        [TestCase, Description("TokenInfo - Negative Test to test GetTokenInfoByToken non-existing token")]
        class N_GetTokenInfo_ByToken_NonExistingToken : WCFTestBase
        {
            public override void Run()
            {
                TokenManagementWCFClient client = new TokenManagementWCFClient();
                client.GetTokenInfoByToken(NonExistingToken, HResult.XONLINE_E_ACCOUNTS_INVALID_VOUCHER, false);
            }
        }

        [TestCase, Description("TokenInfo - Negative Test to test GetTokenInfoByHash an single byte hash")]
        class N_GetTokenInfo_ByHash_EmptyHash : WCFTestBase
        {
            public override void Run()
            {
                byte[] hash = new byte[0];

                TokenManagementWCFClient client = new TokenManagementWCFClient();
                client.GetTokenInfoByHash(hash, HResult.E_INVALIDARG, false);
            }
        }

        [TestCase, Description("TokenInfo - Negative Test to test GetTokenInfoByHash a zero initialized hash")]
        class N_GetTokenInfo_ByHash_HashWithZeros : WCFTestBase
        {
            public override void Run()
            {
                byte[] hash = new byte[MaxHashSize];
                for (int i = 0; i < MaxHashSize; i++)
                {
                    hash[i] = 0;
                }

                TokenManagementWCFClient client = new TokenManagementWCFClient();
                client.GetTokenInfoByHash(hash, HResult.XONLINE_E_ACCOUNTS_INVALID_VOUCHER, false);
            }
        }

        [TestCase, Description("TokenInfo - Negative Test to test GetTokenInfoByHash a long hash")]
        class N_GetTokenInfo_ByHash_VeryLongHash : WCFTestBase
        {
            public override void Run()
            {
                byte[] hash = new byte[100];
                for (int i = 0; i < 100; i++)
                {
                    hash[i] = 0;
                }

                TokenManagementWCFClient client = new TokenManagementWCFClient();
                client.GetTokenInfoByHash(hash, HResult.E_INVALIDARG, false);
            }
        }

        [TestCase, Description("TokenInfo - Negative Test to test GetTokenInfoByHash an invalid hash")]
        class N_GetTokenInfo_ByHash_InvalidHash : WCFTestBase
        {
            public override void Run()
            {
                byte[] hash = new byte[MaxHashSize];
                for (int i = 0; i < MaxHashSize; i++)
                {
                    hash[i] = (byte) i;
                }

                TokenManagementWCFClient client = new TokenManagementWCFClient();
                client.GetTokenInfoByHash(hash, HResult.XONLINE_E_ACCOUNTS_INVALID_VOUCHER, false);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Test\TokenManagementTest\TokenCategoryCTPTests.cs ===
using System;
using System.Collections;
using System.ServiceModel;
using System.Runtime.Serialization;
using System.IO;
using System.Xml;
using System.Text;

using ServerTestFramework;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.LiveService;
using ServerTestFramework.Utilities;

//using Microsoft.XBox.Live.Server.Emulators.Bdk;
//using XeXbos;

using MIXTesting;
using xonline.mix.tokenmanagement.contracts.V1;

namespace MixTest
{
    /// <summary>
    /// This test group covers 4 TokenManagement APIs:
    /// ConfigureTokenCategory
    /// GetTokenCategoryById
    /// GetTokenCategoryByName
    /// GetTokenCategoryByOffer
    /// </summary>
    [TestGroup, Owner("yuanfeiw"), TestCasePriority(1), TestFrequency("Daily"), Description("Mix Token Category Tests")]
    public class TokenCategoryCTPTests : TestNode
    {
        [TestCase, Description("ConfigureTokenCategory - Create a new Token Category with InCsat set to True and game")]
        class P_ConfigureTC_New_InCsat_True_ArcadeGame : WCFTestBase
        {
            private TokenCategory tc = null;

            public override void PreRun()
            {
                tc = MixTokenHelper.NewTokenCategoryInCsatArcadeGame();
                PrintObject(tc);
                PrintObject(tc.ChannelSKUArray);
            }

            public override void Run()
            {
                TokenManagementWCFClient client = new TokenManagementWCFClient();
                client.ConfigureTokenCategory(tc);
                MixTokenHelper.VerifyTokenCategory(tc);
            }
        }

        // Comment out this test because we temporarily disable support of subscription and points bundle, see bug 169501.
        //[TestCase, Description("ConfigureTokenCategory - Create a new Token Category with InCsat set to True and subscription")]
        class P_ConfigureTC_New_InCsat_True_Subscription : WCFTestBase
        {
            private TokenCategory tc = null;
            private TokenManagementWCFClient client = null;

            public override void PreRun()
            {
                // custom http header for a non-retryable error
                string scsError = BehaviorInjection.AddScsFailure("SetPartnerConfiguration", "BDK_E_AUTHORIZATION_FAILED", false);
                scsError = scsError.Replace("BEHAVIOR_INJECTIONS:", "").Trim();
                CustomHttpHeader header = new CustomHttpHeader("BEHAVIOR_INJECTIONS", scsError);
                CustomHttpHeader[] headers = new CustomHttpHeader[] { header };
                PrintObject(headers);

                // create client
                tc = MixTokenHelper.NewTokenCategoryInCsatLiveSubscription();
                client = new TokenManagementWCFClient();
                client.CustomHttpHeaders = headers;
                PrintObject(tc);
                PrintObject(tc.ChannelSKUArray);
            }

            public override void Run()
            {
                // use BIF to verify that Mix does not call CTP SetParnterConfiguration for Subscription
                client.ConfigureTokenCategory(tc);
                MixTokenHelper.VerifyTokenCategory(tc);
            }
        }

        [TestCase, Description("ConfigureTokenCategory - Create a new Token Category with InCsat set to True and null ChannelSKU")]
        class P_ConfigureTC_New_InCsat_True_ChannelSKU_Null_Then_Update : WCFTestBase
        {
            private TokenCategory tc = null;

            public override void PreRun()
            {
                // the first ConfigureTokenCategory has IsRedeemable set to false
                tc = MixTokenHelper.NewTokenCategoryInCsatArcadeGame();
                tc.IsRedeemable = false;
                tc.ChannelSKUArray = null;
                PrintObject(tc);
            }

            public override void Run()
            {
                TokenManagementWCFClient client = new TokenManagementWCFClient();
                client.ConfigureTokenCategory(tc);
                MixTokenHelper.VerifyTokenCategory(tc);

                // second ConfigureTokenCategory has IsRedeemable set to true and add two ChannelSKU
                tc.IsRedeemable = true;
                tc.ChannelSKUArray = new ChannelSKU[2];
                tc.ChannelSKUArray[0] = MixTokenHelper.NewChannelSKUObject(tc.Pkpn);
                tc.ChannelSKUArray[1] = MixTokenHelper.NewChannelSKUObject(tc.Pkpn);

                client.ConfigureTokenCategory(tc);
                MixTokenHelper.VerifyTokenCategory(tc);
            }
        }

        [TestCase, Description("ConfigureTokenCategory - Update an existing Token Category with InCsat set to True, same ChannelSKUs")]
        class P_ConfigureTC_Update_InCsat_True_SameChannelSKUs : WCFTestBase
        {
            private TokenCategory tc = null;
            private TokenManagementWCFClient client = null;

            public override void PreRun()
            {
                // create a new Token Category first which has two ChannelSKU for this PKPN
                TokenCategory tcFirst = MixTokenHelper.NewTokenCategoryInCsatArcadeGame();
                client = new TokenManagementWCFClient();
                client.ConfigureTokenCategory(tcFirst);

                // update the already existing Token Category with new TokenCategoryName and ExpirationDate
                // and a new ChannelSKU. So the total ChannelSKU for this PKNP is 3.
                tc = MixTokenHelper.CreateTokenCategoryFrom(tcFirst);
                tc.TokenCategoryName = "Arcade Media Token Category update:" + Guid.NewGuid().ToString();
                RandomEx randomEx = new RandomEx();
                int year = randomEx.Next(1900, 3000);
                tc.ExpirationDate = new DateTime(year, 12, 31, 00, 00, 00);
                PrintObject(tc);
                PrintObject(tc.ChannelSKUArray);
            }

            public override void Run()
            {
                client = new TokenManagementWCFClient();
                client.ConfigureTokenCategory(tc);
                MixTokenHelper.VerifyTokenCategory(tc);
            }
        }

        [TestCase, Description("ConfigureTokenCategory - Update an existing Token Category with InCsat set to True, new ChannelSKU during update")]
        class P_ConfigureTC_Update_InCsat_True_NewChannelSKU : WCFTestBase
        {
            private TokenCategory tc = null;
            private TokenManagementWCFClient client = null;

            public override void PreRun()
            {
                // create a new Token Category first which has two ChannelSKU for this PKPN
                TokenCategory tcFirst = MixTokenHelper.NewTokenCategoryInCsatArcadeGame();
                client = new TokenManagementWCFClient();
                client.ConfigureTokenCategory(tcFirst);

                // update the already existing Token Category with new TokenCategoryName and ExpirationDate
                // and a new ChannelSKU. So the total ChannelSKU for this PKNP is 3.
                tc = MixTokenHelper.CreateTokenCategoryFrom(tcFirst);
                tc.TokenCategoryName = "Arcade Media Token Category update:" + Guid.NewGuid().ToString();
                RandomEx randomEx = new RandomEx();
                int year = randomEx.Next(1900, 3000);
                tc.ExpirationDate = new DateTime(year, 12, 31, 00, 00, 00);
                tc.ChannelSKUArray = new ChannelSKU[1];
                tc.ChannelSKUArray[0] = MixTokenHelper.NewChannelSKUObject(tc.Pkpn);
                PrintObject(tc);
                PrintObject(tc.ChannelSKUArray);
            }

            public override void Run()
            {
                client = new TokenManagementWCFClient();
                client.ConfigureTokenCategory(tc);
                MixTokenHelper.VerifyTokenCategory(tc);
            }
        }

        [TestCase, Description("ConfigureTokenCategory - use BIF to simulate non-retryable error from CTP SetPartnerConfiguration API")]
        class N_ConfigureTC_CTP_SetPartnerConfigurationApi_PKPK_Fail_NonRetryable : WCFTestBase
        {
            private TokenCategory tc = null;
            private TokenManagementWCFClient client = null;

            public override void PreRun()
            {
                // custom http header for a non-retryable error
                string scsError = BehaviorInjection.AddScsFailure("SetPartnerConfiguration", "BDK_E_AUTHORIZATION_FAILED", false);
                scsError = scsError.Replace("BEHAVIOR_INJECTIONS:", "").Trim();
                CustomHttpHeader header = new CustomHttpHeader("BEHAVIOR_INJECTIONS", scsError);
                CustomHttpHeader[] headers = new CustomHttpHeader[] { header };
                PrintObject(headers);

                // create client
                tc = MixTokenHelper.NewTokenCategoryInCsatArcadeGame();
                client = new TokenManagementWCFClient();
                client.CustomHttpHeaders = headers;
            }
            
            public override void Run()
            {
                client.ConfigureTokenCategory(tc, HResult.XONLINE_E_BILLING_AUTHORIZATION_FAILED, false);
                MixTokenHelper.VerifyTokenCategoryNotExist(tc);
            }
        }

        [TestCase, Description("ConfigureTokenCategory - use BIF to simulate retryable error from CTP SetPartnerConfiguration API")]
        class N_ConfigureTC_CTP_SetPartnerConfigurationApi_PKPK_Fail_Retryable : WCFTestBase
        {
            private TokenCategory tc = null;
            private TokenManagementWCFClient client = null;

            public override void PreRun()
            {
                // custom http header for a retryable error
                string scsError = BehaviorInjection.AddScsFailure("SetPartnerConfiguration", "BDK_E_UNKNOWN_SERVER_FAILURE", false);
                scsError = scsError.Replace("BEHAVIOR_INJECTIONS:", "").Trim();
                CustomHttpHeader header = new CustomHttpHeader("BEHAVIOR_INJECTIONS", scsError);
                //CustomHttpHeader header = new CustomHttpHeader("BEHAVIOR_INJECTIONS", "AlternateBillingUrl;" + BdkEmu.GetUrl(IBdk));
                //CustomHttpHeader header2 = new CustomHttpHeader("AlternateBillingUrl", BdkEmu.GetUrl(IBdk));
                CustomHttpHeader[] headers = new CustomHttpHeader[] { header };
                PrintObject(headers);

                // create client
                tc = MixTokenHelper.NewTokenCategoryInCsatArcadeGame();
                client = new TokenManagementWCFClient();
                client.CustomHttpHeaders = headers;
            }

            public override void Run()
            {
                client.ConfigureTokenCategory(tc, HResult.XONLINE_E_BILLING_UNKNOWN_SERVER_FAILURE, true);
                MixTokenHelper.VerifyTokenCategoryNotExist(tc);
            }
        }

        [TestCase, Description("ConfigureTokenCategory - try to create new token category with null TokenType")]
        class N_ConfigureTC_New_TokenType_Null : WCFTestBase
        {
            private TokenCategory tc = null;

            public override void PreRun()
            {
                tc = MixTokenHelper.NewTokenCategoryInCsatArcadeGame();
                tc.TokenType = null;
            }

            public override void Run()
            {
                TokenManagementWCFClient client = new TokenManagementWCFClient();
                client.ConfigureTokenCategory(tc, HResult.E_INVALIDARG, false);
            }
        }

        [TestCase, Description("ConfigureTokenCategory - try to create new token category with empty TokenType")]
        class P_ConfigureTC_New_TokenType_Empty : WCFTestBase
        {
            private TokenCategory tc = null;

            public override void PreRun()
            {
                tc = MixTokenHelper.NewTokenCategoryInCsatArcadeGame();
                tc.TokenType = string.Empty;
            }

            public override void Run()
            {
                TokenManagementWCFClient client = new TokenManagementWCFClient();
                client.ConfigureTokenCategory(tc);
                MixTokenHelper.VerifyTokenCategory(tc);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Test\TokenManagementTest\TokenManagementStress.cs ===
ï»¿using System;
using System.Collections;
using System.Collections.Generic;
using System.ServiceModel;
using System.Runtime.Serialization;
using System.IO;
using System.IO.Compression;
using System.Net;
using System.Security.Cryptography;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;
using System.Xml;

using ServerTestFramework;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.LiveService;
using ServerTestFramework.Utilities;
using ServerTestFramework.Database;

using xonline.common.config;
using MIXTesting;
using xonline.mix.tokenmanagement.contracts.V1;
using xonline.mix.common;

namespace MixTest
{
    public class TokenManagementStressTestBase : TestNode
    {
        #region Constants

        internal const int GET_TOKEN_CHUNK_SIZE = 1000;
        internal const int MAX_TOKENS_TO_STORE_LOCALLY = 1000;
        private const string FAILED_TO_START_JOB = "Failed to successfully start generating tokens for the following reason:\r\n{0}";
        internal const string GET_TOKENS_NO_TOKENS_JOB_RUNNING = "No tokens are currently available, but a job should be running.";
        internal const string GET_TOKENS_COUNT_MISMATCH = "Retrieved token count does not equal the expected count of {0}!";
        private const string JOB_COMPLETE = "Job {0} has completed successfully.";
        private const string JOB_CREATED = "Job {0} has been successfully created.  Generating {1} tokens.";
        private const string JOB_FAILED = "Job {0} has failed!";
        private const string TOKEN_CATEGORY_CONFIGURED = "Configured the token category.";
        private const string TOKEN_CATEGORY_CREATED = "Creating new token category: {0}";
        internal const string TOKEN_JOB_STATUS_NO_KNOWN_JOB = "No known jobs available, kicking off a token job for 10 tokens.";

        #endregion

        #region Fields

        internal static float thousandsTPS = 0;
        internal static float hundredThousandsTPS = 0;
        internal static float millionsTPS = 0;
        internal static List<Guid> activeJobs = new List<Guid>();
        internal static Dictionary<Guid, uint> tokensToGenerate = new Dictionary<Guid, uint>();

        internal static int createdTokenCategoriesIndex = 0;
        internal static int completedTokenJobsIndex = 0;
        internal static int generatedTokensIndex = 0;
        internal static List<TokenCategory> createdTokenCategories = new List<TokenCategory>();
        internal static List<Guid> completedTokenJobs = new List<Guid>();
        internal static List<xonline.mix.tokenmanagement.contracts.V1.TokenEntry> generatedTokens = new List<xonline.mix.tokenmanagement.contracts.V1.TokenEntry>();
        
        internal ReaderWriterLock activeJobsLock = new ReaderWriterLock();
        private static bool isRunning = false; 
        private Thread jobMonitor = null;
        
        #endregion

        #region Stress Background Work

        /// <summary>
        /// One time setup prior to stress suite execution
        /// </summary>
        public override void OneTimeSetup()
        {
            if (!isRunning)
            {
                jobMonitor = new Thread(new ThreadStart(JobMonitorWorker));
                jobMonitor.Start();
                isRunning = true;

                base.OneTimeSetup();
            }
        }
        
        /// <summary>
        /// Wrap up the stress test execution
        /// </summary>
        public override void PostRun()
        {
            //stop the job monitor thread if it's running
            if (isRunning)
            {
                isRunning = false;
            }

            base.PostRun();
        }

        /// <summary>
        /// Monitor the token generation jobs to completion
        /// </summary>
        private void JobMonitorWorker()
        {
            uint tokenCount = 0;
            bool removeJob = false;
            Guid jobId = Guid.Empty;
            TokenManagementWCFClient client = new TokenManagementWCFClient();
            
            //Run until the stress suite is asked to stop
            while (isRunning)
            {
                try
                {
                    for (int i = 0; i < activeJobs.Count; i++)
                    {
                        activeJobsLock.AcquireReaderLock(5000);

                        try
                        {
                            jobId = activeJobs[i];

                            if (tokensToGenerate.ContainsKey(jobId))
                            {
                                tokenCount = tokensToGenerate[jobId];
                            }
                        }
                        finally
                        {
                            activeJobsLock.ReleaseReaderLock();
                        }

                        removeJob = false;

                        //If the token job completed successfully
                        if (TokenJobStatusEnum.Delivered == client.GetTokenJobStatus(jobId).Status)
                        {
                            completedTokenJobs.Add(jobId);

                            removeJob = true;

                            Global.RO.Success(JOB_COMPLETE, jobId);
                        }

                        //If the job failed for any reason, stop tracking it
                        else if (TokenJobStatusEnum.Failed == client.GetTokenJobStatus(jobId).Status)
                        {
                            removeJob = true;

                            Global.RO.Error(JOB_FAILED, jobId);
                        }

                        if (removeJob)
                        {
                            switch (tokenCount)
                            {
                                case 1000: thousandsTPS--; break;
                                case 100000: hundredThousandsTPS--; break;
                                case 1000000: millionsTPS--; break;
                                default: break;
                            }

                            activeJobsLock.AcquireWriterLock(5000);

                            try
                            {
                                activeJobs.RemoveAt(i--);
                            }
                            catch
                            {
                                Global.RO.Error("Index: {0}\r\nCount: {1}", i, activeJobs.Count);
                            }
                            finally
                            {
                                activeJobsLock.ReleaseWriterLock();
                            }
                        }
                    }
                }
                catch (Exception ex)
                {
                    Global.RO.Error("Tokens: {0}", tokensToGenerate.ContainsKey(jobId));
                    Global.RO.Error(ex.ToString());
                }

                Thread.Sleep(5000);
            }
        }

        #endregion

        #region Common Stress Work

        /// <summary>
        /// Generate a specified number of tokens
        /// </summary>
        /// <param name="tokenCount">The number of tokens to generate</param>
        /// <param name="inCTP">Whether or not to invoke the CTP LoadTokenInstance APIs</param>
        /// <returns>Whether or not the generation job could be successfully started or not</returns>
        public TEST_RESULTS GenerateTokens(uint tokenCount, bool inCTP)
        {
            Guid jobId = Guid.Empty;
            TokenCategory tokenCategory = null;
            TEST_RESULTS results = TEST_RESULTS.PASSED;            

            try
            {
                //Create a new token category for the batch of tokens
                tokenCategory = ConfigureTokenCategory(inCTP);                

                //Kick off a job to create a new batch of tokens
                jobId = MixTokenHelper.GenerateTestTokens(tokenCategory.TokenCategoryId, tokenCount, MixTokenHelper.Key, true, false);

                Global.RO.Success(JOB_CREATED, jobId, tokenCount);
            }
            catch (Exception ex)
            {
                Global.RO.Error(FAILED_TO_START_JOB, ex.ToString());
            }
            finally
            {
                if (activeJobsLock.IsWriterLockHeld)
                {
                    activeJobsLock.ReleaseWriterLock();
                }
            }

            //If a job was successfully created
            if (Guid.Empty != jobId)
            {
                //Guids should be unique, but just in case a duplicate is generated
                if (tokensToGenerate.ContainsKey(jobId))
                {
                    tokensToGenerate[jobId] = tokenCount;
                }
                else
                {
                    tokensToGenerate.Add(jobId, tokenCount);
                }

                createdTokenCategories.Add(tokenCategory);
                
                activeJobsLock.AcquireWriterLock(5000);

                activeJobs.Add(jobId);

                activeJobsLock.ReleaseWriterLock();
            }
            else
            {
                results = TEST_RESULTS.NOT_EXECUTED;
            }

            return results;
        }

        /// <summary>
        /// Configure a new token token category
        /// </summary>
        /// <returns>The new token category.</returns>
        public TokenCategory ConfigureTokenCategory(bool inCTP)
        {
            TokenCategory tokenCategory = null;

            if (inCTP)
            {
                tokenCategory = MixTokenHelper.NewTokenCategoryInCsatArcadeGame();
            }
            else
            {
                tokenCategory = MixTokenHelper.NewTokenCategory();
            }
            tokenCategory.OfferId = Guid.NewGuid();

            string tokenCategoryId = tokenCategory.TokenCategoryId.ToString();

            Global.RO.Debug(TOKEN_CATEGORY_CREATED, tokenCategoryId);

            TokenManagementWCFClient client = new TokenManagementWCFClient();
            
            client.ConfigureTokenCategory(tokenCategory);

            Global.RO.Debug(TOKEN_CATEGORY_CONFIGURED);

            createdTokenCategories.Add(tokenCategory);

            return tokenCategory;
        }

        /// <summary>
        /// Create a new token category object
        /// TokenCategoryId, TokenCategoryName, OfferId, PromotionId and PKPN are different each time
        /// </summary>
        /// <returns></returns>
        public static TokenCategory CreateNewTokenCategory()
        {
            TokenCategory tc = new TokenCategory();
            tc.TokenCategoryId = Guid.NewGuid();
            tc.TokenCategoryName = "Arcade Media Token Category:" + tc.TokenCategoryId.ToString();
            tc.ExpirationDate = new DateTime(2099, 12, 31, 00, 00, 00);
            tc.OfferId = Guid.NewGuid();
            tc.PromotionId = Guid.NewGuid();
            tc.ProductTypeId = 23;              // Arcade Game
            tc.InCsat = true;
            tc.IsRsm = true;
            RandomEx randomEx = new RandomEx();
            tc.Pkpn = "XXX-" + randomEx.GenerateNumberString(5);    // format of PKPN, XXX-01234
            tc.ChannelTypeId = 1;               // 0 - Etailer, 1 - retailer, 2 - POSA
            tc.IsRevenueBearing = false;        // PKPN and ChannelSKU are not needed on CTP
            tc.TokenType = "Fake Token Type";   // not used

            tc.ChannelSKUArray = new ChannelSKU[1];
            tc.ChannelSKUArray[0] = MixTokenHelper.NewChannelSKUObject(tc.Pkpn);

            //tc.ChannelSKUArray = null;
            tc.IsRoyaltyBearing = true;
            tc.IsRedeemable = true;             // set so that we can redeem these tokens by default

            return tc;
        }

        /// <summary>
        /// Get the tokens for the job specified.
        /// </summary>
        /// <param name="jobId">The ID of the job to retrieve the tokens for.</param>
        /// <param name="tokenCount">The total number of tokens generated for the job specified.</param>
        /// <returns>Whether or not the retrieval was a success.</returns>
        public xonline.mix.tokenmanagement.contracts.V1.TokenEntry[] GetTokens(Guid jobId, int tokenCount)
        {
            int tokenStart = 1;
            TokenManagementWCFClient client = new TokenManagementWCFClient();
            xonline.mix.tokenmanagement.contracts.V1.TokenEntry[] tokens = null;

            try
            {
                //loop in 1000 chunk blocks of tokens
                while (tokenStart < tokenCount)
                {
                    tokens = client.GetTokens(
                                jobId,
                                MixTokenHelper.Key,
                                tokenStart,
                                tokenStart + GET_TOKEN_CHUNK_SIZE <= tokenCount ? tokenStart + GET_TOKEN_CHUNK_SIZE : tokenCount,
                                0,
                                false);

                    tokenStart = tokenStart + GET_TOKEN_CHUNK_SIZE <= tokenCount ? tokenStart + GET_TOKEN_CHUNK_SIZE : tokenCount;

                    for (int i = 0; i < tokens.Length && generatedTokens.Count < MAX_TOKENS_TO_STORE_LOCALLY; i++)
                    {
                        generatedTokens.Add(tokens[i]);
                    }
                }
            }
            catch (Exception ex)
            {
                Global.RO.Error(ex.ToString());
            }

            return tokens;
        }

        #endregion

        /// <summary> This is a temporary workaround for fixing this test suite to compile now that TestNode no longer has a return value.  Ideally the way these stress tests would be changed to directly throw as appropriate, but that is a larger work item that I'll leave up to the owner of this test suite.  Unfortunately in this context we have no better information to use for the exception strings.  </summary>
        public static void ThrowResultException(TEST_RESULTS result)
        {
            if (result==TEST_RESULTS.FAILED)
            {
                throw new UnexpectedTestResultException("FAILED");
            }
            else if (result==TEST_RESULTS.NOT_EXECUTED)
            {
                throw new DidNotExecuteException("NOT_EXECUTED");
            }
        }
    }

    /// <summary>
    /// The TPS specified via STF does not cause GenerateTokens to be executed at that rate.  Instead
    /// the value specified indicates the total number of jobs of that size that are running at any given time.
    /// This test group covers 2 TokenManagement APIs:
    ///     GenerateTokens is used to actually generate the tokens requests.
    ///     GetTokenJobStatus is used to monitor the status of the token job.
    /// </summary>
    [StressTest(Priority = 1)]
    public class GenerateTokensThousands : TokenManagementStressTestBase
    {
        public override void Run()
        {
            TEST_RESULTS results = TEST_RESULTS.NOT_EXECUTED;

            if (thousandsTPS < Math.Ceiling(this.StressData.TargetTPS))
            {
                thousandsTPS++;
                results = GenerateTokens(1000, false);
            }

            ThrowResultException(results);
        }
    }

    /// <summary>
    /// The TPS specified via STF does not cause GenerateTokens to be executed at that rate.  Instead
    /// the value specified indicates the total number of jobs of that size that are running at any given time.
    /// This test group covers 2 TokenManagement APIs:
    ///     GenerateTokens is used to actually generate the tokens requests.
    ///     GetTokenJobStatus is used to monitor the status of the token job.
    /// </summary>
    [StressTest(Priority = 1)]
    public class GenerateTokensHundredThousands : TokenManagementStressTestBase
    {
        public override void Run()
        {
            TEST_RESULTS results = TEST_RESULTS.NOT_EXECUTED;

            if (hundredThousandsTPS < Math.Ceiling(this.StressData.TargetTPS))
            {
                hundredThousandsTPS++;
                results = GenerateTokens(100000, false);
            }

            ThrowResultException(results);
        }
    }

    /// <summary>
    /// The TPS specified via STF does not cause GenerateTokens to be executed at that rate.  Instead
    /// the value specified indicates the total number of jobs of that size that are running at any given time.
    /// This test group covers 2 TokenManagement APIs:
    ///     GenerateTokens is used to actually generate the tokens requests.
    ///     GetTokenJobStatus is used to monitor the status of the token job.
    /// </summary>
    [StressTest(Priority = 1)]
    public class GenerateTokensMillions : TokenManagementStressTestBase
    {
        public override void Run()
        {
            TEST_RESULTS results = TEST_RESULTS.NOT_EXECUTED;

            if (millionsTPS < Math.Ceiling(this.StressData.TargetTPS))
            {
                millionsTPS++;
                results = GenerateTokens(1000000, false);
            }

            ThrowResultException(results);
        }
    }

    /// <summary>
    /// The TPS specified via STF does not cause GenerateTokens to be executed at that rate.  Instead
    /// the value specified indicates the total number of jobs of that size that are running at any given time.
    /// This test group covers 2 TokenManagement APIs:
    ///     GenerateTokens is used to actually generate the tokens requests.
    ///     GetTokenJobStatus is used to monitor the status of the token job.
    /// </summary>
    [StressTest(Priority = 1)]
    public class GenerateTokensThousandsInCTP : TokenManagementStressTestBase
    {
        public override void Run()
        {
            TEST_RESULTS results = TEST_RESULTS.NOT_EXECUTED;

            if (thousandsTPS < Math.Ceiling(this.StressData.TargetTPS))
            {
                thousandsTPS++;
                results = GenerateTokens(1000, true);
            }

            ThrowResultException(results);
        }
    }

    /// <summary>
    /// The TPS specified via STF does not cause GenerateTokens to be executed at that rate.  Instead
    /// the value specified indicates the total number of jobs of that size that are running at any given time.
    /// This test group covers 2 TokenManagement APIs:
    ///     GenerateTokens is used to actually generate the tokens requests.
    ///     GetTokenJobStatus is used to monitor the status of the token job.
    /// </summary>
    [StressTest(Priority = 1)]
    public class GenerateTokensHundredThousandsInCTP : TokenManagementStressTestBase
    {
        public override void Run()
        {
            TEST_RESULTS results = TEST_RESULTS.NOT_EXECUTED;

            if (hundredThousandsTPS < Math.Ceiling(this.StressData.TargetTPS))
            {
                hundredThousandsTPS++;
                results = GenerateTokens(100000, true);
            }

            ThrowResultException(results);
        }
    }

    /// <summary>
    /// The TPS specified via STF does not cause GenerateTokens to be executed at that rate.  Instead
    /// the value specified indicates the total number of jobs of that size that are running at any given time.
    /// This test group covers 2 TokenManagement APIs:
    ///     GenerateTokens is used to actually generate the tokens requests.
    ///     GetTokenJobStatus is used to monitor the status of the token job.
    /// </summary>
    [StressTest(Priority = 1)]
    public class GenerateTokensMillionsInCTP : TokenManagementStressTestBase
    {
        public override void Run()
        {
            TEST_RESULTS results = TEST_RESULTS.NOT_EXECUTED;

            if (millionsTPS < Math.Ceiling(this.StressData.TargetTPS))
            {
                millionsTPS++;
                results = GenerateTokens(1000000, true);
            }

            ThrowResultException(results);
        }
    }

    /// <summary>
    /// Configures a new token category.
    /// </summary>
    [StressTest(Priority = 1)]
    public class ConfigureTokenCategory : TokenManagementStressTestBase
    {
        public override void Run()
        {
            TokenCategory tokenCategory = base.ConfigureTokenCategory(false);

            if (null == tokenCategory)
            {
                throw new UnexpectedTestResultException("tokenCategory is null");
            }
        }
    }

    /// <summary>
    /// Configures a new token category.
    /// </summary>
    [StressTest(Priority = 1)]
    public class ConfigureTokenCategoryInCTP : TokenManagementStressTestBase
    {
        public override void Run()
        {
            TokenCategory tokenCategory = base.ConfigureTokenCategory(true);

            if (null == tokenCategory)
            {
                throw new UnexpectedTestResultException("tokenCategory is null");
            }
        }
    }

    /// <summary>
    /// Calls GetTokenCategory for a TokenCategory that has previously been configured.
    /// If no TokenCategory is known for this stress instance, ConfigureToken is called
    /// to prime the system and unblock GetTokenCategory.  If other stress cases are 
    /// running that are creating TokenCategories, those will be available to this test
    /// case as well.
    /// </summary>
    [StressTest(Priority = 1)]
    public class GetTokenCategory : TokenManagementStressTestBase
    {
        public override void Run()
        {
            Random random = new Random();
            TokenCategory tokenCategory = null;
            TEST_RESULTS results = TEST_RESULTS.PASSED;
            TokenManagementWCFClient client = new TokenManagementWCFClient();

            lock (createdTokenCategories)
            {
                if (createdTokenCategories.Count > 0)
                {
                    tokenCategory = createdTokenCategories[createdTokenCategoriesIndex];

                    createdTokenCategoriesIndex = ++createdTokenCategoriesIndex % createdTokenCategories.Count;

                    createdTokenCategories.Add(tokenCategory);
                }
            }

            //if no token category is available for use, create a new one
            if(null == tokenCategory)
            {
                tokenCategory = base.ConfigureTokenCategory(false);
            }
            else
            {
                try
                {
                    //Alternate between the various ways to call GetTokenCategory
                    switch (random.Next(1, 4))
                    {
                        case 1: 
                            client.GetTokenCategoryById(tokenCategory.TokenCategoryId);
                            break;

                        case 2:
                            client.GetTokenCategoryByName(tokenCategory.TokenCategoryName);
                            break;

                        case 3:
                            client.GetTokenCategoryByOffer(tokenCategory.OfferId);
                            break;

                        default: break;
                    }
                }
                catch (Exception ex)
                {
                    results = TEST_RESULTS.FAILED;
                    Global.RO.Error(ex.ToString());
                }
            }

            ThrowResultException(results);
        }
    }


    /// <summary>
    /// Calls GetTokenJobStatus for a token job that has previously been kicked off.
    /// If no current job is known for this stress instance, a new token generation job is
    /// kicked off to prime the system and unblock GetTokenJobStatus.  If other stress cases are 
    /// running that are creating token jobs, those will be available to this test case as well.
    /// </summary>
    [StressTest(Priority = 1)]
    public class GetTokenJobStatus : TokenManagementStressTestBase
    {
        public override void Run()
        {
            Guid jobId = Guid.Empty;
            Random random = new Random(); 
            TokenManagementWCFClient client = new TokenManagementWCFClient();
            TEST_RESULTS results = TEST_RESULTS.PASSED;

            try
            {
                activeJobsLock.AcquireReaderLock(5000);

                if (activeJobs.Count > 0)
                {
                    jobId = activeJobs[random.Next(0, activeJobs.Count)];
                }

                activeJobsLock.ReleaseReaderLock();
            }
            finally
            {
                if (activeJobsLock.IsReaderLockHeld)
                {
                    activeJobsLock.ReleaseReaderLock();
                }
            }

            //If no job is known, kick off a new job
            if (Guid.Empty == jobId)
            {
                Global.RO.Info(TOKEN_JOB_STATUS_NO_KNOWN_JOB);

                this.GenerateTokens(10, false);

                results = TEST_RESULTS.NOT_EXECUTED;
            }

            //if a job available, get its status
            else
            {
                try
                {
                    client.GetTokenJobStatus(jobId);
                }
                catch (Exception ex)
                {
                    results = TEST_RESULTS.FAILED;

                    Global.RO.Error(ex.ToString());
                }
            }

            ThrowResultException(results);
        }
    }

    /// <summary>
    /// Calls GetTokens for a token job that has previously been delivered.
    /// If no completed job is known for this stress instance, GenerateTokens is called
    /// to prime the system and unblock GetTokens.  If other stress cases are 
    /// running that are creating tokens, those will be available to this test
    /// case as well.
    /// </summary>
    [StressTest(Priority = 1)]
    public class GetTokens : TokenManagementStressTestBase
    {
        public override void Run()
        {
            Guid jobId = Guid.Empty;
            TEST_RESULTS results = TEST_RESULTS.PASSED;

            try
            {
                activeJobsLock.AcquireReaderLock(5000);
                
                int activeJobsCount = activeJobs.Count;

                activeJobsLock.ReleaseReaderLock();

                //If at least one token job has completed, grab a job ID
                if (completedTokenJobs.Count > 0)
                {                    
                    jobId = completedTokenJobs[completedTokenJobsIndex];

                    completedTokenJobsIndex = ++completedTokenJobsIndex % completedTokenJobs.Count;
                }

                //If no token job is underway, kick one off
                else if (activeJobsCount == 0)
                {
                    Global.RO.Info(TOKEN_JOB_STATUS_NO_KNOWN_JOB);

                    this.GenerateTokens(10, false);

                    results = TEST_RESULTS.NOT_EXECUTED;
                }

                //A job is underway, but no tokens are available at the moment.
                else
                {
                    Global.RO.Info(GET_TOKENS_NO_TOKENS_JOB_RUNNING);

                    results = TEST_RESULTS.NOT_EXECUTED;
                }

            }
            finally
            {
                if (activeJobsLock.IsReaderLockHeld)
                {
                    activeJobsLock.ReleaseReaderLock();
                }
            }

            //If GetTokens can be executed, do it
            if(Guid.Empty != jobId)
            {
                int tokenCount = 0;
                try
                {
                    tokenCount = (int)tokensToGenerate[jobId];
                }
                catch
                {
                    bool stop = true;
                    if (stop)
                    {
                        stop = true;
                    }
                }

                xonline.mix.tokenmanagement.contracts.V1.TokenEntry[] tokens = base.GetTokens(jobId, tokenCount);

                //do quick validation that the number of tokens returned is the amount expected
                if (tokens.Length < tokenCount)
                {
                    results = TEST_RESULTS.FAILED;

                    Global.RO.Error(GET_TOKENS_COUNT_MISMATCH, tokenCount);
                }
            }

            ThrowResultException(results);
        }
    }

    /// <summary>
    /// Calls GetTokenInfo for a token that has previously been retrieved via GetTokens.
    /// If no tokens are known for this stress instance, GetTokens is called to prime the 
    /// system and unblock GetTokenInfo.  If other stress cases are running that are creating 
    /// tokens, those will be available to this test case as well.
    /// </summary>
    [StressTest(Priority = 1)]
    public class GetTokenInfo : TokenManagementStressTestBase
    {
        public override void Run()
        {
            TEST_RESULTS results = TEST_RESULTS.PASSED;
            TokenManagementWCFClient client = new TokenManagementWCFClient();

            //If tokens are known, take the next one available
            if (generatedTokens.Count > 0)
            {
                try
                {
                    xonline.mix.tokenmanagement.contracts.V1.TokenEntry token = generatedTokens[generatedTokensIndex];

                    generatedTokensIndex = ++generatedTokensIndex % generatedTokens.Count;

                    TokenInfo tokenInfo = client.GetTokenInfoByToken(token.Token);
                }
                catch (Exception ex)
                {
                    results = TEST_RESULTS.FAILED;
                    Global.RO.Error(ex.ToString());
                }
            }

            //if no tokens are known, generate new tokens for use
            else
            {
                GetTokens getTokens = new GetTokens();

                getTokens.Run();

                results = TEST_RESULTS.NOT_EXECUTED;
            }

            ThrowResultException(results);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\Test\TokenManagementTest\TokenIntegrationTests.cs ===
using System;
using System.Collections;
using System.ServiceModel;
using System.Runtime.Serialization;
using System.IO;
using System.Xml;
using System.Text;

using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Billing;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.Utilities;

using MIXTesting;
using xonline.mix.tokenmanagement.contracts.V1;
using xonline.common.billing;

namespace MixTest
{
    [TestGroup, Owner( "yuanfeiw" ), TestCasePriority( 1 ), TestFrequency( "Regression" ), Description( "Mix Token Integration Tests" )]
    public class TokenIntegrationTests : TestNode
    {
        /// <summary>
        /// Create a new token category object
        /// TokenCategoryId, TokenCategoryName, OfferId, PromotionId and PKPN are different each time
        /// </summary>
        /// <returns></returns>
        public static TokenCategory CreateArcadeTokenCategory()
        {
            TokenCategory tc = MixTokenHelper.NewTokenCategoryInCsatArcadeGame();
            WCFTestBase.PrintObject(tc);
            WCFTestBase.PrintObject(tc.ChannelSKUArray);
            TokenManagementWCFClient client = new TokenManagementWCFClient();
            client.ConfigureTokenCategory(tc);

            return tc;
        }

        /// <summary>
        /// Create a new token category object
        /// TokenCategoryId, TokenCategoryName, OfferId, PromotionId and PKPN are different each time
        /// </summary>
        /// <returns></returns>
        public static TokenCategory CreateSubscriptionTokenCategory()
        {
            TokenCategory tc = MixTokenHelper.NewTokenCategoryInCsatLiveSubscription();
            WCFTestBase.PrintObject(tc);
            WCFTestBase.PrintObject(tc.ChannelSKUArray);
            TokenManagementWCFClient client = new TokenManagementWCFClient();
            client.ConfigureTokenCategory(tc);

            return tc;
        }

        public override void PreRun()
        {
            // set a longer client timeout for billing related tests
            FDTransaction.sReceiveTimeOut = FDTransaction.BillingReceiveTimeout;

            /*Commmenting this out for now as this import job currently exists only in R2 
            //Run the ImportOffersFromUODB SQL job, if it hasn't been run already
            MixTokenHelper.EnsureImportPointsJobIsRun();
             */
        }

        #region Subscription Tests

        //Marking tests as hidden as we currently don't support subscription token generation from GG
        [Description( "Subscription - Redeem new subscription token using XeVerifyToken and XeOfferPurchase" ), EnvRequirement( "Billing" )]
        class P_Subscription_VerifyToken_XeOfferPurchase_MaxUsage1 : WCFTestBase
        {
            public override void Run()
            {
                uint hrExpected = HResult.S_OK;
                string tokenHash = TokendbWS.GetVoucherHash(MixTokenHelper.ThreeMonthLiveSubTokenOneTimeToken);

                try
                {
                    //Unuse Token
                    TokendbWS.UnuseToken(tokenHash);

                    // create a silver user
                    XeUser user = XbosUser.XenonSilverUser();

                    // call VerifyToken for the new token as an old client
                    {
                        XRLXeVerifyToken vtReq = new XRLXeVerifyToken();
                        vtReq.UserPuid = user.UserPuid;
                        vtReq.BillingToken = MixTokenHelper.ThreeMonthLiveSubTokenOneTimeToken;
                        ushort expectedOfferCatalogType = (ushort)OfferCatalogTypeEnum.Xbox;
                        XRLXeVerifyTokenResponse vtResp = new XRLXeVerifyTokenResponse();

                        if (vtReq.Execute(out vtResp))
                        {
                            if (vtResp.OfferCatalogType != expectedOfferCatalogType)
                            {
                                throw new UnexpectedTestResultException(string.Format("Expected OfferCatalogType of: {0}, received: {1}", expectedOfferCatalogType, vtResp.OfferCatalogType));
                            }
                        }

                        if (vtReq.XErr != hrExpected)
                        {
                            throw new UnexpectedTestResultException(String.Format("hrExpected {0:x} not Equal to hrReturned {1:x}", hrExpected, vtReq.XErr));
                        }

                        XRLXeOfferPurchase opReq = new XRLXeOfferPurchase();
                        opReq.UserPuid = user.UserPuid;
                        opReq.OfferID = vtResp.XboxOfferInfo.OfferId;
                        opReq.LanguageID = user.LanguageId;
                        opReq.CountryID = user.CountryId;
                        opReq.PaymentType = (uint)PaymentTypeEnum.Token;
                        opReq.BillingToken = MixTokenHelper.ThreeMonthLiveSubTokenOneTimeToken;

                        if (!opReq.Execute())
                        {
                            throw new UnexpectedTestResultException(String.Format("Purhcase of offer faled with: {0}", opReq.XErr));
                        }
                        if (opReq.XErr != hrExpected)
                        {
                            throw new UnexpectedTestResultException(String.Format("hrExpected {0:x} not Equal to hrReturned {1:x}", hrExpected, opReq.XErr));
                        }
                    }

                    //Same user trying to redeem the token twice
                    {
                        hrExpected = HResult.XONLINE_E_ACCOUNTS_VOUCHER_ALREADY_USED;

                        XRLXeVerifyToken vtReq = new XRLXeVerifyToken();
                        vtReq.UserPuid = user.UserPuid;
                        vtReq.BillingToken = MixTokenHelper.ThreeMonthLiveSubTokenOneTimeToken;
                        XRLXeVerifyTokenResponse vtResp = new XRLXeVerifyTokenResponse();
                        if (vtReq.Execute(out vtResp))
                        {
                            throw new UnexpectedTestResultException(String.Format("Call to XeVerifyToken Succeeded when it should have faled with: {0}", hrExpected));
                        }
                        if (vtReq.XErr != hrExpected)
                        {
                            throw new UnexpectedTestResultException(String.Format("hrExpected {0:x} not Equal to hrReturned {1:x}", hrExpected, vtReq.XErr));
                        }
                    }

                    //Different user trying to redeem the already used token
                    {
                        hrExpected = HResult.XONLINE_E_ACCOUNTS_VOUCHER_ALREADY_USED;

                        XRLXeVerifyToken vtReq = new XRLXeVerifyToken();
                        vtReq.UserPuid = user.UserPuid;
                        vtReq.BillingToken = MixTokenHelper.ThreeMonthLiveSubTokenOneTimeToken;
                        XRLXeVerifyTokenResponse vtResp = new XRLXeVerifyTokenResponse();
                        if (vtReq.Execute(out vtResp))
                        {
                            throw new UnexpectedTestResultException(String.Format("Call to XeVerifyToken Succeeded when it should have faled with: {0}", hrExpected));
                        }
                        if (vtReq.XErr != hrExpected)
                        {
                            throw new UnexpectedTestResultException(String.Format("hrExpected {0:x} not Equal to hrReturned {1:x}", hrExpected, vtReq.XErr));
                        }
                    }
                }
                finally
                {
                    //Unuse Token
                    TokendbWS.UnuseToken(tokenHash);                    
                }
            }
            
        }

        [Description( "Subscription - Redeem new subscription token using XeVerifyToken and XeOfferPurchase" ), EnvRequirement( "Billing" )]
        class P_Subscription_VerifyToken_XeOfferPurchase_Timeout : WCFTestBase
        {
            public override void Run()
            {
                uint hrExpected = HResult.S_OK;
                
                // create a silver user
                XeUser user = XbosUser.XenonSilverUser();

                // call VerifyToken for the new token as an old client
                {
                    XRLXeVerifyToken vtReq = new XRLXeVerifyToken();
                    vtReq.UserPuid = user.UserPuid;
                    vtReq.BillingToken = MixTokenHelper.ThreeMonthLiveSubToken;
                    ushort expectedOfferCatalogType = (ushort)OfferCatalogTypeEnum.Xbox;
                    XRLXeVerifyTokenResponse vtResp = new XRLXeVerifyTokenResponse();

                    if (vtReq.Execute(out vtResp))
                    {
                        if (vtResp.OfferCatalogType != expectedOfferCatalogType)
                        {
                            throw new UnexpectedTestResultException(string.Format("Expected OfferCatalogType of: {0}, received: {1}", expectedOfferCatalogType, vtResp.OfferCatalogType));
                        }
                    }

                    if (vtReq.XErr != hrExpected)
                    {
                        throw new UnexpectedTestResultException(String.Format("hrExpected {0:x} not Equal to hrReturned {1:x}", hrExpected, vtReq.XErr));
                    }

                    XRLXeOfferPurchase opReq = new XRLXeOfferPurchase();
                    opReq.UserPuid = user.UserPuid;
                    opReq.OfferID = vtResp.XboxOfferInfo.OfferId;
                    opReq.LanguageID = user.LanguageId;
                    opReq.CountryID = user.CountryId;
                    opReq.PaymentType = (uint)PaymentTypeEnum.Token;
                    opReq.BillingToken = MixTokenHelper.ThreeMonthLiveSubToken;
                    opReq.CustomHeader = BehaviorInjection.AddCTPPurchaseTimeout(true);

                    if (!opReq.Execute())
                    {
                        throw new UnexpectedTestResultException(String.Format("Purhcase of offer faled with: {0}", opReq.XErr));
                    }
                    if (opReq.XErr != hrExpected)
                    {
                        throw new UnexpectedTestResultException(String.Format("hrExpected {0:x} not Equal to hrReturned {1:x}", hrExpected, opReq.XErr));

                    }
                }
            }
        }

        [Description( "Subscription - Verify token redemption fails for non-redeemable token" ), EnvRequirement( "Billing" )]
        class N_Subscription_VerifyToken_NonReedemable : WCFTestBase
        {
            public override void PreRun()
            {
                //Update TC as non Reedemable
                TokendbWS.NonReedemableTC(MixTokenHelper.ThreeMonthLiveSubTC);
            }
            public override void Run()
            {
                try
                {
                    // create a silver user
                    XeUser user = XbosUser.XenonSilverUser();

                    uint hrExpected = live.common.HResult.XONLINE_E_TOKEN_NOT_YET_REDEEMABLE;

                    // call VerifyToken for the new token as an old client
                    {
                        XRLXeVerifyToken vtReq = new XRLXeVerifyToken();
                        vtReq.UserPuid = user.UserPuid; 
                        vtReq.BillingToken = MixTokenHelper.ThreeMonthLiveSubToken;
                        XRLXeVerifyTokenResponse vtResp = new XRLXeVerifyTokenResponse();

                        if (vtReq.Execute(out vtResp))
                        {
                            throw new UnexpectedTestResultException(string.Format("Call to XeVerifyToken Succeded when it should have failed with Exception: {0}", hrExpected));
                        }
                        if (vtReq.XErr != hrExpected)
                        {
                            throw new UnexpectedTestResultException(String.Format("hrExpected {0:x} not Equal to hrReturned {1:x}", hrExpected, vtReq.XErr));
                        }
                    }
                }
                finally
                {
                    TokendbWS.ReedemableTC(MixTokenHelper.ThreeMonthLiveSubTC);
                }
            }
        }

        [Description( "Subscription - Verify token redemption fails for Expired tokens" ), EnvRequirement( "Billing" )]
        class N_Subscription_VerifyToken_Expired_TC : WCFTestBase
        {
            public override void PreRun()
            {
                //Expire Token Category
                TokendbWS.ExipreTokenCategory(MixTokenHelper.ThreeMonthLiveSubTC);
            }
            public override void Run()
            {
                try
                {
                    // create a silver user
                    XeUser user = XbosUser.XenonSilverUser();

                    uint hrExpected = HResult.XOFF_E_OFFER_EXPIRED;

                    // call VerifyToken for the new token as an old client
                    {
                        XRLXeVerifyToken vtReq = new XRLXeVerifyToken();
                        vtReq.UserPuid = user.UserPuid;
                        vtReq.BillingToken = MixTokenHelper.ThreeMonthLiveSubToken;
                        XRLXeVerifyTokenResponse vtResp = new XRLXeVerifyTokenResponse();

                        if (vtReq.Execute(out vtResp))
                        {
                            throw new UnexpectedTestResultException(string.Format("Call to XeVerifyToken Succeded when it should have failed with Exception: {0}", hrExpected));
                        }
                        if (vtReq.XErr != hrExpected)
                        {
                            throw new UnexpectedTestResultException(String.Format("hrExpected {0:x} not Equal to hrReturned {1:x}", hrExpected, vtReq.XErr));
                        }
                    }
                }
                finally
                {
                    TokendbWS.UnExipreTokenCategory(MixTokenHelper.ThreeMonthLiveSubTC);
                }
            }
        }

        [Description( "Subscription - Verify token redemption fails for invalid token" ), EnvRequirement( "Billing" )]
        class N_Subscription_VerifyToken_Invalid_Token : WCFTestBase
        {
            public override void Run()
            {

                // create a silver user
                XeUser user = XbosUser.XenonSilverUser();

                uint hrExpected = HResult.XONLINE_E_ACCOUNTS_INVALID_VOUCHER;

                // call VerifyToken for the new token as an old client
                {
                    XRLXeVerifyToken vtReq = new XRLXeVerifyToken();
                    vtReq.UserPuid = user.UserPuid;
                    vtReq.BillingToken = MixTokenHelper.InvalidToken;
                    XRLXeVerifyTokenResponse vtResp = new XRLXeVerifyTokenResponse();

                    if (vtReq.Execute(out vtResp))
                    {
                        throw new UnexpectedTestResultException(string.Format("Call to XeVerifyToken Succeded when it should have failed with Exception: {0}", hrExpected));
                    }
                    if (vtReq.XErr != hrExpected)
                    {
                        throw new UnexpectedTestResultException(String.Format("hrExpected {0:x} not Equal to hrReturned {1:x}", hrExpected, vtReq.XErr));
                    }
                }
            }
        }

        [Description( "Subscription - Verify token redemption fails for Disable token" ), EnvRequirement( "Billing" )]
        class N_Subscription_VerifyToken_Disable_Token : WCFTestBase
        {
            string tokenHash;

            public override void PreRun()
            {
                tokenHash = TokendbWS.GetVoucherHash(MixTokenHelper.ThreeMonthLiveSubToken);

                //Disable Token
                TokendbWS.DisableTokenV2(tokenHash);
            }
            public override void Run()
            {
                try
                {
                    // create a silver user
                    XeUser user = XbosUser.XenonSilverUser();

                    uint hrExpected = HResult.XONLINE_E_ACCOUNTS_INVALID_VOUCHER;

                    // call VerifyToken for the new token as an old client
                    {
                        XRLXeVerifyToken vtReq = new XRLXeVerifyToken();
                        vtReq.UserPuid = user.UserPuid;
                        vtReq.BillingToken = MixTokenHelper.ThreeMonthLiveSubToken;
                        XRLXeVerifyTokenResponse vtResp = new XRLXeVerifyTokenResponse();

                        if (vtReq.Execute(out vtResp))
                        {
                            throw new UnexpectedTestResultException(string.Format("Call to XeVerifyToken Succeded when it should have failed with Exception: {0}", hrExpected));
                        }
                        if (vtReq.XErr != hrExpected)
                        {
                            throw new UnexpectedTestResultException(String.Format("hrExpected {0:x} not Equal to hrReturned {1:x}", hrExpected, vtReq.XErr));
                        }
                    }
                }
                finally
                {
                    //Re-Enable Token
                    TokendbWS.EnableTokenV2(tokenHash);
                }
            }
        }

        #endregion

        //Marking tests as hidden as we currently don't support points bundle token generation from GG
        #region Points Bundle Tests

        [Description( "PointsBundle - Redeem new PointsBundle token using XeVerifyToken and XeOfferPurchase" ), EnvRequirement( "Billing" )]
        class P_PointsBundle_VerifyToken_XeOfferPurchase_Success : WCFTestBase
        {
            public override void Run()
            {
                uint hrExpected = live.common.HResult.S_OK;
                UacsCommon2 uacs = new UacsCommon2();
             
                // create a silver user
                XeUser user = XbosUser.XenonSilverUser();
                uint pointsBalanceBefore = uacs.GetPointsBalance(user.UserPuid);
                uint expectedPointsBalance = pointsBalanceBefore + 1600; 

                Global.RO.Info("Points Balance is: " + pointsBalanceBefore);

                // call VerifyToken for the new token as an old client
                {
                    
                    XRLXeVerifyToken vtReq = new XRLXeVerifyToken();
                    vtReq.UserPuid = user.UserPuid;
                    vtReq.BillingToken = MixTokenHelper.PointsBundle1600LiveToken;
                    ushort expectedOfferCatalogType = (ushort)OfferCatalogTypeEnum.Xbox;
                    XRLXeVerifyTokenResponse vtResp = new XRLXeVerifyTokenResponse();

                    if (vtReq.Execute(out vtResp))
                    {
                        if (vtResp.OfferCatalogType != expectedOfferCatalogType)
                        {
                            throw new UnexpectedTestResultException(string.Format("Expected OfferCatalogType of: {0}, received: {1}", expectedOfferCatalogType, vtResp.OfferCatalogType));
                        }
                    }

                    if (vtReq.XErr != hrExpected)
                    {
                        throw new UnexpectedTestResultException(String.Format("hrExpected {0:x} not Equal to hrReturned {1:x}", hrExpected, vtReq.XErr));
                    }

                    XRLXeOfferPurchase opReq = new XRLXeOfferPurchase();
                    opReq.UserPuid = user.UserPuid;
                    opReq.OfferID = vtResp.XboxOfferInfo.OfferId;
                    opReq.LanguageID = user.LanguageId;
                    opReq.CountryID = user.CountryId;
                    opReq.PaymentType = (uint)PaymentTypeEnum.Token;
                    opReq.BillingToken = MixTokenHelper.PointsBundle1600LiveToken;

                    if (!opReq.Execute())
                    {
                        throw new UnexpectedTestResultException(String.Format("Purhcase of offer faled with: {0}", opReq.XErr));
                    }
                    if (opReq.XErr != hrExpected)
                    {
                        throw new UnexpectedTestResultException(String.Format("hrExpected {0:x} not Equal to hrReturned {1:x}", hrExpected, opReq.XErr));
                    }
                    uint pointsBalanceAfter = uacs.GetPointsBalance(user.UserPuid);

                    if (expectedPointsBalance != pointsBalanceAfter)
                    {
                        throw new UnexpectedTestResultException(String.Format("Expected points balance: {0} not equal to actual value: {1}", expectedPointsBalance, pointsBalanceAfter));
                    }
                }

                //Same user trying to redeem the token twice
                {
                    hrExpected = live.common.HResult.XONLINE_E_ACCOUNTS_VOUCHER_ALREADY_USED;

                    XRLXeVerifyToken vtReq = new XRLXeVerifyToken();
                    vtReq.UserPuid = user.UserPuid;
                    vtReq.BillingToken = MixTokenHelper.PointsBundle1600LiveToken;
                    XRLXeVerifyTokenResponse vtResp = new XRLXeVerifyTokenResponse();
                    if (!vtReq.Execute(out vtResp))
                    {
                        throw new UnexpectedTestResultException(String.Format("Call to XeVerifyToken Failed with: {0}", hrExpected));
                    }

                    XRLXeOfferPurchase opReq = new XRLXeOfferPurchase();
                    opReq.UserPuid = user.UserPuid;
                    opReq.OfferID = vtResp.XboxOfferInfo.OfferId;
                    opReq.LanguageID = user.LanguageId;
                    opReq.CountryID = user.CountryId;
                    opReq.PaymentType = (uint)PaymentTypeEnum.Token;
                    opReq.BillingToken = MixTokenHelper.PointsBundle1600LiveToken;

                    if (opReq.Execute())
                    {
                        throw new UnexpectedTestResultException(String.Format("Purhcase of Succeeded when it should have faled with: {0}", hrExpected));
                    }
                    if (opReq.XErr != hrExpected)
                    {
                        throw new UnexpectedTestResultException(String.Format("hrExpected {0:x} not Equal to hrReturned {1:x}", hrExpected, opReq.XErr));
                    }
                    uint pointsBalanceAfter = uacs.GetPointsBalance(user.UserPuid);

                    //After purhcase failure points balance should be same as before failure
                    if (expectedPointsBalance != pointsBalanceAfter)
                    {
                        throw new UnexpectedTestResultException(String.Format("Expected points balance: {0} not equal to actual value: {1}", expectedPointsBalance, pointsBalanceAfter));
                    }

                }
            }
        }

        [Description( "PointsBundle - Redeem new PointsBundle token using XeVerifyToken and XeOfferPurchase" ), EnvRequirement( "Billing" )]
        class P_PointsBundle_VerifyToken_XeOfferPurchase_MaxUsage1 : WCFTestBase
        {
            public override void Run()
            {
                uint hrExpected = HResult.S_OK;
                string tokenHash = TokendbWS.GetVoucherHash(MixTokenHelper.PointsBundle1600LiveTokenOneTimeToken);

                try
                {
                    //Unuse Token
                    TokendbWS.UnuseToken(tokenHash);

                    // create a silver user
                    XeUser user = XbosUser.XenonSilverUser();

                    // call VerifyToken for the new token as an old client
                    {
                        XRLXeVerifyToken vtReq = new XRLXeVerifyToken();
                        vtReq.UserPuid = user.UserPuid;
                        vtReq.BillingToken = MixTokenHelper.PointsBundle1600LiveTokenOneTimeToken;
                        ushort expectedOfferCatalogType = (ushort)OfferCatalogTypeEnum.Xbox;
                        XRLXeVerifyTokenResponse vtResp = new XRLXeVerifyTokenResponse();

                        if (vtReq.Execute(out vtResp))
                        {
                            if (vtResp.OfferCatalogType != expectedOfferCatalogType)
                            {
                                throw new UnexpectedTestResultException(string.Format("Expected OfferCatalogType of: {0}, received: {1}", expectedOfferCatalogType, vtResp.OfferCatalogType));
                            }
                        }

                        if (vtReq.XErr != hrExpected)
                        {
                            throw new UnexpectedTestResultException(String.Format("hrExpected {0:x} not Equal to hrReturned {1:x}", hrExpected, vtReq.XErr));
                        }

                        XRLXeOfferPurchase opReq = new XRLXeOfferPurchase();
                        opReq.UserPuid = user.UserPuid;
                        opReq.OfferID = vtResp.XboxOfferInfo.OfferId;
                        opReq.LanguageID = user.LanguageId;
                        opReq.CountryID = user.CountryId;
                        opReq.PaymentType = (uint)PaymentTypeEnum.Token;
                        opReq.BillingToken = MixTokenHelper.PointsBundle1600LiveTokenOneTimeToken;

                        if (!opReq.Execute())
                        {
                            throw new UnexpectedTestResultException(String.Format("Purhcase of offer faled with: {0}", opReq.XErr));
                        }
                        if (opReq.XErr != hrExpected)
                        {
                            throw new UnexpectedTestResultException(String.Format("hrExpected {0:x} not Equal to hrReturned {1:x}", hrExpected, opReq.XErr));

                        }

                    }

                    //Same user trying to redeem the token twice
                    {
                        hrExpected = live.common.HResult.XOFF_E_ALREADY_OWN_MAX;

                        XRLXeVerifyToken vtReq = new XRLXeVerifyToken();
                        vtReq.UserPuid = user.UserPuid;
                        vtReq.BillingToken = MixTokenHelper.PointsBundle1600LiveTokenOneTimeToken;
                        XRLXeVerifyTokenResponse vtResp = new XRLXeVerifyTokenResponse();
                        if (vtReq.Execute(out vtResp))
                        {
                            throw new UnexpectedTestResultException(String.Format("Call to XeVerifyToken Succeeded when it should have faled with: {0}", hrExpected));
                        }
                    }

                    //Different user trying to redeem the already used token
                    {
                        hrExpected = live.common.HResult.XOFF_E_ALREADY_OWN_MAX;

                        XRLXeVerifyToken vtReq = new XRLXeVerifyToken();
                        vtReq.UserPuid = user.UserPuid;
                        vtReq.BillingToken = MixTokenHelper.PointsBundle1600LiveTokenOneTimeToken;
                        XRLXeVerifyTokenResponse vtResp = new XRLXeVerifyTokenResponse();
                        if (vtReq.Execute(out vtResp))
                        {
                            throw new UnexpectedTestResultException(String.Format("Call to XeVerifyToken Succeeded when it should have faled with: {0}", hrExpected));
                        }
                    }
                }
                finally
                {
                    //Unuse Token
                    TokendbWS.UnuseToken(tokenHash);
                }
            }
        }

        [Description( "PointsBundle - Redeem new PointsBundle token using XeVerifyToken and XeOfferPurchase" ), EnvRequirement( "Billing" )]
        class P_PointsBundle_VerifyToken_XeOfferPurchase_Timeout : WCFTestBase
        {
            public override void Run()
            {
                uint hrExpected = HResult.S_OK;
               
                // create a silver user
                XeUser user = XbosUser.XenonSilverUser();

                // call VerifyToken for the new token as an old client
                {
                    XRLXeVerifyToken vtReq = new XRLXeVerifyToken();
                    vtReq.UserPuid = user.UserPuid;
                    vtReq.BillingToken = MixTokenHelper.PointsBundle1600LiveToken;
                    ushort expectedOfferCatalogType = (ushort)OfferCatalogTypeEnum.Xbox;
                    XRLXeVerifyTokenResponse vtResp = new XRLXeVerifyTokenResponse();

                    if (vtReq.Execute(out vtResp))
                    {
                        if (vtResp.OfferCatalogType != expectedOfferCatalogType)
                        {
                            throw new UnexpectedTestResultException(string.Format("Expected OfferCatalogType of: {0}, received: {1}", expectedOfferCatalogType, vtResp.OfferCatalogType));
                        }
                    }

                    if (vtReq.XErr != hrExpected)
                    {
                        throw new UnexpectedTestResultException(String.Format("hrExpected {0:x} not Equal to hrReturned {1:x}", hrExpected, vtReq.XErr));
                    }

                    XRLXeOfferPurchase opReq = new XRLXeOfferPurchase();
                    opReq.UserPuid = user.UserPuid;
                    opReq.OfferID = vtResp.XboxOfferInfo.OfferId;
                    opReq.LanguageID = user.LanguageId;
                    opReq.CountryID = user.CountryId;
                    opReq.PaymentType = (uint)PaymentTypeEnum.Token;
                    opReq.BillingToken = MixTokenHelper.PointsBundle1600LiveToken;
                    opReq.CustomHeader = BehaviorInjection.AddCTPPurchaseTimeout(true);

                    if (!opReq.Execute())
                    {
                        throw new UnexpectedTestResultException(String.Format("Purhcase of offer faled with: {0}", opReq.XErr));
                    }
                    if (opReq.XErr != hrExpected)
                    {
                        throw new UnexpectedTestResultException(String.Format("hrExpected {0:x} not Equal to hrReturned {1:x}", hrExpected, opReq.XErr));

                    }
                }
            }
        }

        [Description( "PointsBundle - Verify token redemption fails for non-redeemable token" ), EnvRequirement( "Billing" )]
        class N_PointsBundle_VerifyToken_NonReedemable : WCFTestBase
        {
            public override void PreRun()
            {
                //Update TC as non Reedemable
                TokendbWS.NonReedemableTC(MixTokenHelper.PointsBundle1600LiveTC);
            }
            public override void Run()
            {
                try
                {
                    // create a silver user
                    XeUser user = XbosUser.XenonSilverUser();

                    uint hrExpected = live.common.HResult.XONLINE_E_TOKEN_NOT_YET_REDEEMABLE;

                    // call VerifyToken for the new token as an old client
                    {
                        XRLXeVerifyToken vtReq = new XRLXeVerifyToken();
                        vtReq.UserPuid = user.UserPuid;
                        vtReq.BillingToken = MixTokenHelper.PointsBundle1600LiveToken;
                        XRLXeVerifyTokenResponse vtResp = new XRLXeVerifyTokenResponse();

                        if (vtReq.Execute(out vtResp))
                        {
                            throw new UnexpectedTestResultException(string.Format("Call to XeVerifyToken Succeded when it should have failed with Exception: {0}", hrExpected));
                        }
                        if (vtReq.XErr != hrExpected)
                        {
                            throw new UnexpectedTestResultException(String.Format("hrExpected {0:x} not Equal to hrReturned {1:x}", hrExpected, vtReq.XErr));
                        }
                    }
                }
                finally
                {
                    TokendbWS.ReedemableTC(MixTokenHelper.PointsBundle1600LiveTC);
                }
            }
        }

        [Description( "PointsBundle - Verify token redemption fails for Expired token" ), EnvRequirement( "Billing" )]
        class N_PointsBundle_VerifyToken_Expired_TC : WCFTestBase
        {
            public override void PreRun()
            {
                //Expire Token Category
                TokendbWS.ExipreTokenCategory(MixTokenHelper.PointsBundle1600LiveTC);
            }
            public override void Run()
            {
                try
                {
                    // create a silver user
                    XeUser user = XbosUser.XenonSilverUser();

                    uint hrExpected = HResult.XOFF_E_OFFER_EXPIRED;

                    // call VerifyToken for the new token as an old client
                    {
                        XRLXeVerifyToken vtReq = new XRLXeVerifyToken();
                        vtReq.UserPuid = user.UserPuid;
                        vtReq.BillingToken = MixTokenHelper.PointsBundle1600LiveToken;
                        XRLXeVerifyTokenResponse vtResp = new XRLXeVerifyTokenResponse();

                        if (vtReq.Execute(out vtResp))
                        {
                            throw new UnexpectedTestResultException(string.Format("Call to XeVerifyToken Succeded when it should have failed with Exception: {0}", hrExpected));
                        }
                        if (vtReq.XErr != hrExpected)
                        {
                            throw new UnexpectedTestResultException(String.Format("hrExpected {0:x} not Equal to hrReturned {1:x}", hrExpected, vtReq.XErr));
                        }
                    }
                }
                finally
                {
                    TokendbWS.UnExipreTokenCategory(MixTokenHelper.PointsBundle1600LiveTC);
                }
            }
        }

        [Description( "PointsBundle - Verify token redemption fails for invalid token" ), EnvRequirement( "Billing" )]
        class N_PointsBundle_VerifyToken_Invalid_Token : WCFTestBase
        {
            public override void Run()
            {

                // create a silver user
                XeUser user = XbosUser.XenonSilverUser();

                uint hrExpected = HResult.XONLINE_E_ACCOUNTS_INVALID_VOUCHER;

                // call VerifyToken for the new token as an old client
                {
                    XRLXeVerifyToken vtReq = new XRLXeVerifyToken();
                    vtReq.UserPuid = user.UserPuid;
                    vtReq.BillingToken = MixTokenHelper.InvalidToken;
                    XRLXeVerifyTokenResponse vtResp = new XRLXeVerifyTokenResponse();

                    if (vtReq.Execute(out vtResp))
                    {
                        throw new UnexpectedTestResultException(string.Format("Call to XeVerifyToken Succeded when it should have failed with Exception: {0}", hrExpected));
                    }
                    if (vtReq.XErr != hrExpected)
                    {
                        throw new UnexpectedTestResultException(String.Format("hrExpected {0:x} not Equal to hrReturned {1:x}", hrExpected, vtReq.XErr));
                    }
                }
            }
        }

        [Description( "PointsBundle - Verify token redemption fails for Disable token" ), EnvRequirement( "Billing" )]
        class N_PointsBundle_VerifyToken_Disable_Token : WCFTestBase
        {
            public override void Run()
            {
                string tokenHash = TokendbWS.GetVoucherHash(MixTokenHelper.PointsBundle1600LiveToken);

                try
                {
                    // create a silver user
                    XeUser user = XbosUser.XenonSilverUser();

                    //Disable Token
                    TokendbWS.DisableTokenV2(tokenHash);

                    uint hrExpected = HResult.XONLINE_E_ACCOUNTS_INVALID_VOUCHER;

                    // call VerifyToken for the new token as an old client
                    {
                        XRLXeVerifyToken vtReq = new XRLXeVerifyToken();
                        vtReq.UserPuid = user.UserPuid;
                        vtReq.BillingToken = MixTokenHelper.PointsBundle1600LiveToken;
                        XRLXeVerifyTokenResponse vtResp = new XRLXeVerifyTokenResponse();

                        if (vtReq.Execute(out vtResp))
                        {
                            throw new UnexpectedTestResultException(string.Format("Call to XeVerifyToken Succeded when it should have failed with Exception: {0}", hrExpected));
                        }
                        if (vtReq.XErr != hrExpected)
                        {
                            throw new UnexpectedTestResultException(String.Format("hrExpected {0:x} not Equal to hrReturned {1:x}", hrExpected, vtReq.XErr));
                        }
                    }
                }
                finally
                {
                    //Re-Enable Token
                    TokendbWS.EnableTokenV2(tokenHash);
                }
            }
        }

        #endregion

        #region Financial Game Content

        [TestCase, Description("Arcade - Generate one token for financial game content and verify token redemption works fine")]
        class P_Arcade_Financial_VerifyToken_PurchaseMediaOffers_MaxUsage1 : WCFTestBase
        {
            private static TokenCategory tc = null;

            public override void PreRun()
            {
                if (tc == null)
                {
                    tc = CreateArcadeTokenCategory();
                }
            }

            public override void Run()
            {
                //Generate a token for the new token category
                Guid jobId = MixTokenHelper.GenerateTestTokens(tc.TokenCategoryId, 1, MixTokenHelper.Key, true, false);
                TokenEntry[] tokens = MixTokenHelper.GetTokenEntries(jobId, MixTokenHelper.Key);
                MixTokenHelper.VerifyTokens(1, tokens, tc);
                uint hrExpected = live.common.HResult.S_OK;

                //Fetch the Token
                string arcadeToken = tokens[0].Token;

                // create a silver user
                XeUser user = XbosUser.XenonSilverUser();


                // call VerifyToken for the new token as an old client
                {
                    XRLXeVerifyToken vtReq = new XRLXeVerifyToken();
                    vtReq.UserPuid = user.UserPuid;
                    vtReq.BillingToken = arcadeToken;
                    ushort expectedOfferCatalogType = (ushort)OfferCatalogTypeEnum.Ems;
                    XRLXeVerifyTokenResponse vtResp = new XRLXeVerifyTokenResponse();

                    if (vtReq.Execute(out vtResp))
                    {
                        if (vtResp.OfferCatalogType != expectedOfferCatalogType)
                        {
                            throw new UnexpectedTestResultException(string.Format("Expected OfferCatalogType of: {0}, received: {1}", expectedOfferCatalogType, vtResp.OfferCatalogType));
                        }
                    }

                    if (vtReq.XErr != hrExpected)
                    {
                        throw new UnexpectedTestResultException(String.Format("hrExpected {0:x} not Equal to hrReturned {1:x}", hrExpected, vtReq.XErr));
                    }


                    OfferMediaTypeExpectedPrice omtep = new OfferMediaTypeExpectedPrice();
                    omtep.ExpectedPriceWhole = 800; // this seems wrong
                    omtep.ExpectedPriceFractional = 0;
                    omtep.MediaTypeId = (int)tc.ProductTypeId;
                    omtep.OfferId = tc.OfferId;
                    OfferMediaTypeExpectedPrice[] offers = new OfferMediaTypeExpectedPrice[] { omtep };

                    XRLPurchaseMediaOffers pmoReq = new XRLPurchaseMediaOffers();
                    pmoReq.UserPuid = user.UserPuid;
                    pmoReq.PaymentType = (uint)PaymentTypeEnum.Token;
                    pmoReq.Offers = offers;
                    pmoReq.BillingToken = arcadeToken;
                    pmoReq.StoreId = 1;

                    if (!pmoReq.Execute())
                    {
                        throw new UnexpectedTestResultException(String.Format("Purhcase of offer faled with: {0}", pmoReq.XErr));
                    }
                    if (pmoReq.XErr != hrExpected)
                    {
                        throw new UnexpectedTestResultException(String.Format("hrExpected {0:x} not Equal to hrReturned {1:x}", hrExpected, pmoReq.XErr));
                    }
                }

                //Same user trying to redeem the token twice
                {
                    hrExpected = live.common.HResult.XOFF_E_ALREADY_OWN_MAX;

                    OfferMediaTypeExpectedPrice omtep = new OfferMediaTypeExpectedPrice();
                    omtep.ExpectedPriceWhole = 800; // this seems wrong
                    omtep.ExpectedPriceFractional = 0;
                    omtep.MediaTypeId = (int)tc.ProductTypeId;
                    omtep.OfferId = tc.OfferId;
                    OfferMediaTypeExpectedPrice[] offers = new OfferMediaTypeExpectedPrice[] { omtep };

                    XRLPurchaseMediaOffers pmoReq = new XRLPurchaseMediaOffers();
                    pmoReq.UserPuid = user.UserPuid;
                    pmoReq.PaymentType = (uint)PaymentTypeEnum.Token;
                    pmoReq.Offers = offers;
                    pmoReq.BillingToken = arcadeToken;
                    pmoReq.StoreId = 1;

                    if (pmoReq.Execute())
                    {
                        throw new UnexpectedTestResultException(String.Format("Purhcase of offer Succeeded when it should have faled with: {0}", hrExpected));
                    }
                    if (pmoReq.XErr != hrExpected)
                    {
                        throw new UnexpectedTestResultException(String.Format("hrExpected {0:x} not Equal to hrReturned {1:x}", hrExpected, pmoReq.XErr));

                    }
                }

                //Different user trying to redeem the already used token
                {
                    hrExpected = live.common.HResult.XONLINE_E_ACCOUNTS_VOUCHER_ALREADY_USED;

                    XeUser newUser = XbosUser.XenonSilverUser();

                    OfferMediaTypeExpectedPrice omtep = new OfferMediaTypeExpectedPrice();
                    omtep.ExpectedPriceWhole = 800; // this seems wrong
                    omtep.ExpectedPriceFractional = 0;
                    omtep.MediaTypeId = (int)tc.ProductTypeId;
                    omtep.OfferId = tc.OfferId;
                    OfferMediaTypeExpectedPrice[] offers = new OfferMediaTypeExpectedPrice[] { omtep };

                    XRLPurchaseMediaOffers pmoReq = new XRLPurchaseMediaOffers();
                    pmoReq.UserPuid = newUser.UserPuid;
                    pmoReq.PaymentType = (uint)PaymentTypeEnum.Token;
                    pmoReq.Offers = offers;
                    pmoReq.BillingToken = arcadeToken;
                    pmoReq.StoreId = 1;

                    if (pmoReq.Execute())
                    {
                        throw new UnexpectedTestResultException(String.Format("Purhcase of offer Succeeded when it should have faled with: {0}", hrExpected));
                    }
                    if (pmoReq.XErr != hrExpected)
                    {
                        throw new UnexpectedTestResultException(String.Format("hrExpected {0:x} not Equal to hrReturned {1:x}", hrExpected, pmoReq.XErr));

                    }
                }
            }
        }

        [TestCase, Description("Arcade - generate and redeem new arcade token using XeVerifyToken and PurchaseMediaOffers")]
        class P_Arcade_Financial_VerifyToken_PurchaseMediaOffers_Timeout : WCFTestBase
        {
            private static TokenCategory tc = null;

            public override void PreRun()
            {
                if (tc == null)
                {
                    tc = CreateArcadeTokenCategory();
                }
            }

            public override void Run()
            {
                // generate a token for the new token category
                Guid jobId = MixTokenHelper.GenerateTestTokens(tc.TokenCategoryId, 1, MixTokenHelper.Key, true, false);
                TokenEntry[] tokens = MixTokenHelper.GetTokenEntries(jobId, MixTokenHelper.Key);
                MixTokenHelper.VerifyTokens(1, tokens, tc);

                string arcadeToken = tokens[0].Token;

                // create a silver user
                XeUser user = XbosUser.XenonSilverUser();

                // call VerifyToken for the new token as an old client
                {
                    XRLXeVerifyToken vtReq = new XRLXeVerifyToken();
                    vtReq.UserPuid = user.UserPuid;
                    vtReq.BillingToken = arcadeToken;
                    ushort expectedOfferCatalogType = (ushort)OfferCatalogTypeEnum.Ems;
                    XRLXeVerifyTokenResponse vtResp = new XRLXeVerifyTokenResponse();
                    if (vtReq.Execute(out vtResp))
                    {
                        if (vtResp.OfferCatalogType != expectedOfferCatalogType)
                        {
                            throw new UnexpectedTestResultException(string.Format("Expected OfferCatalogType of: {0}, received: {1}", expectedOfferCatalogType, vtResp.OfferCatalogType));
                        }
                    }

                    OfferMediaTypeExpectedPrice omtep = new OfferMediaTypeExpectedPrice();
                    omtep.ExpectedPriceWhole = 800; // this seems wrong
                    omtep.ExpectedPriceFractional = 0;
                    omtep.MediaTypeId = (int)tc.ProductTypeId;
                    omtep.OfferId = tc.OfferId;
                    OfferMediaTypeExpectedPrice[] offers = new OfferMediaTypeExpectedPrice[] { omtep };

                    XRLPurchaseMediaOffers pmoReq = new XRLPurchaseMediaOffers();
                    pmoReq.UserPuid = user.UserPuid;
                    pmoReq.PaymentType = (uint)PaymentTypeEnum.Token;
                    pmoReq.Offers = offers;
                    pmoReq.BillingToken = arcadeToken;
                    pmoReq.StoreId = 1;
                    pmoReq.CustomHeader = BehaviorInjection.AddCTPPurchaseTimeout(true);

                    if (pmoReq.Execute())
                    {
                        return;
                    }

                    throw new UnexpectedTestResultException("pmoReq.Execute failed");
                }
            }
        }

        [TestCase, Description("Arcade - Generate one token for royalty bearing game content token and verify token redemption works fine")]
        class P_Arcade_Financial_VerifyToken_PurchaseMediaOffers_RoyaltyBearing : WCFTestBase
        {
            private static TokenCategory tc = null;

            public override void PreRun()
            {
                if (tc == null)
                {
                    tc = MixTokenHelper.NewTokenCategoryInCsatArcadeGame();
                    tc.InCsat = false;
                    tc.IsRevenueBearing = false;
                    WCFTestBase.PrintObject(tc);
                    WCFTestBase.PrintObject(tc.ChannelSKUArray);
                    TokenManagementWCFClient client = new TokenManagementWCFClient();
                    client.ConfigureTokenCategory(tc);
                }
            }

            public override void Run()
            {
                //Generate a token for the new token category
                Guid jobId = MixTokenHelper.GenerateTestTokens(tc.TokenCategoryId, 1, MixTokenHelper.Key, true, false);
                TokenEntry[] tokens = MixTokenHelper.GetTokenEntries(jobId, MixTokenHelper.Key);
                MixTokenHelper.VerifyTokens(1, tokens, tc);
                uint hrExpected = live.common.HResult.S_OK;

                //Fetch the Token
                string arcadeToken = tokens[0].Token;

                // create a silver user
                XeUser user = XbosUser.XenonSilverUser();


                // call VerifyToken for the new token as an old client
                {
                    XRLXeVerifyToken vtReq = new XRLXeVerifyToken();
                    vtReq.UserPuid = user.UserPuid;
                    vtReq.BillingToken = arcadeToken;
                    ushort expectedOfferCatalogType = (ushort)OfferCatalogTypeEnum.Ems;
                    XRLXeVerifyTokenResponse vtResp = new XRLXeVerifyTokenResponse();
                    if (vtReq.Execute(out vtResp))
                    {
                        if (vtResp.OfferCatalogType != expectedOfferCatalogType)
                        {
                            throw new UnexpectedTestResultException(string.Format("Expected OfferCatalogType of: {0}, received: {1}", expectedOfferCatalogType, vtResp.OfferCatalogType));
                        }
                    }

                    if (vtReq.XErr != hrExpected)
                    {
                        throw new UnexpectedTestResultException(String.Format("hrExpected {0:x} not Equal to hrReturned {1:x}", hrExpected, vtReq.XErr));
                    }

                    OfferMediaTypeExpectedPrice omtep = new OfferMediaTypeExpectedPrice();
                    omtep.ExpectedPriceWhole = 800; // this seems wrong
                    omtep.ExpectedPriceFractional = 0;
                    omtep.MediaTypeId = (int)tc.ProductTypeId;
                    omtep.OfferId = tc.OfferId;
                    OfferMediaTypeExpectedPrice[] offers = new OfferMediaTypeExpectedPrice[] { omtep };

                    XRLPurchaseMediaOffers pmoReq = new XRLPurchaseMediaOffers();
                    pmoReq.UserPuid = user.UserPuid;
                    pmoReq.PaymentType = (uint)PaymentTypeEnum.Token;
                    pmoReq.Offers = offers;
                    pmoReq.BillingToken = arcadeToken;
                    pmoReq.StoreId = 1;

                    if (!pmoReq.Execute())
                    {
                        throw new UnexpectedTestResultException(String.Format("Purhcase of offer faled with: {0}", pmoReq.XErr));
                    }
                    if (pmoReq.XErr != hrExpected)
                    {
                        throw new UnexpectedTestResultException(String.Format("hrExpected {0:x} not Equal to hrReturned {1:x}", hrExpected, pmoReq.XErr));

                    }
                }
            }
        }

        [TestCase, Description("Arcade - Generate one token for revenue bearing game content and verify token redemption works fine")]
        class P_Arcade_Financial_VerifyToken_PurchaseMediaOffers_RevenuBearing : WCFTestBase
        {
            private static TokenCategory tc = null;

            public override void PreRun()
            {
                if (tc == null)
                {
                    tc = MixTokenHelper.NewTokenCategoryInCsatArcadeGame();
                    tc.InCsat = false;
                    tc.IsRoyaltyBearing = false;
                    WCFTestBase.PrintObject(tc);
                    WCFTestBase.PrintObject(tc.ChannelSKUArray);
                    TokenManagementWCFClient client = new TokenManagementWCFClient();
                    client.ConfigureTokenCategory(tc);
                }
            }

            public override void Run()
            {
                //Generate a token for the new token category
                Guid jobId = MixTokenHelper.GenerateTestTokens(tc.TokenCategoryId, 1, MixTokenHelper.Key, true, false);
                TokenEntry[] tokens = MixTokenHelper.GetTokenEntries(jobId, MixTokenHelper.Key);
                MixTokenHelper.VerifyTokens(1, tokens, tc);
                uint hrExpected = live.common.HResult.S_OK;

                //Fetch the Token
                string arcadeToken = tokens[0].Token;

                // create a silver user
                XeUser user = XbosUser.XenonSilverUser();


                // call VerifyToken for the new token as an old client
                {
                    XRLXeVerifyToken vtReq = new XRLXeVerifyToken();
                    vtReq.UserPuid = user.UserPuid;
                    vtReq.BillingToken = arcadeToken;
                    ushort expectedOfferCatalogType = (ushort)OfferCatalogTypeEnum.Ems;
                    XRLXeVerifyTokenResponse vtResp = new XRLXeVerifyTokenResponse();
                    if (vtReq.Execute(out vtResp))
                    {
                        if (vtResp.OfferCatalogType != expectedOfferCatalogType)
                        {
                            throw new UnexpectedTestResultException(string.Format("Expected OfferCatalogType of: {0}, received: {1}", expectedOfferCatalogType, vtResp.OfferCatalogType));
                        }
                    }
                    if (vtReq.XErr != hrExpected)
                    {
                        throw new UnexpectedTestResultException(String.Format("hrExpected {0:x} not Equal to hrReturned {1:x}", hrExpected, vtReq.XErr));
                    }

                    OfferMediaTypeExpectedPrice omtep = new OfferMediaTypeExpectedPrice();
                    omtep.ExpectedPriceWhole = 800; // this seems wrong
                    omtep.ExpectedPriceFractional = 0;
                    omtep.MediaTypeId = (int)tc.ProductTypeId;
                    omtep.OfferId = tc.OfferId;
                    OfferMediaTypeExpectedPrice[] offers = new OfferMediaTypeExpectedPrice[] { omtep };

                    XRLPurchaseMediaOffers pmoReq = new XRLPurchaseMediaOffers();
                    pmoReq.UserPuid = user.UserPuid;
                    pmoReq.PaymentType = (uint)PaymentTypeEnum.Token;
                    pmoReq.Offers = offers;
                    pmoReq.BillingToken = arcadeToken;
                    pmoReq.StoreId = 1;

                    if (!pmoReq.Execute())
                    {
                        throw new UnexpectedTestResultException(String.Format("Purhcase of offer faled with: {0}", pmoReq.XErr));
                    }
                    if (pmoReq.XErr != hrExpected)
                    {
                        throw new UnexpectedTestResultException(String.Format("hrExpected {0:x} not Equal to hrReturned {1:x}", hrExpected, pmoReq.XErr));
                    }
                }
            }
        }

        [TestCase, Description("Arcade - generate and redeem new arcade token using XeVerifyToken and PurchaseMediaOffers")]
        class N_Arcade_Financial_VerifyToken_PurchaseMediaOffers_Failure : WCFTestBase
        {
            private static TokenCategory tc = null;

            public override void PreRun()
            {
                if (tc == null)
                {
                    tc = CreateArcadeTokenCategory();
                }
            }

            public override void Run()
            {
                // generate a token for the new token category
                Guid jobId = MixTokenHelper.GenerateTestTokens(tc.TokenCategoryId, 1, MixTokenHelper.Key, true, false);
                TokenEntry[] tokens = MixTokenHelper.GetTokenEntries(jobId, MixTokenHelper.Key);
                MixTokenHelper.VerifyTokens(1, tokens, tc);

                string arcadeToken = tokens[0].Token;

                // create a silver user
                XeUser user = XbosUser.XenonSilverUser();

                // call VerifyToken for the new token as an old client
                {
                    XRLXeVerifyToken vtReq = new XRLXeVerifyToken();
                    vtReq.UserPuid = user.UserPuid;
                    vtReq.BillingToken = arcadeToken;
                    ushort expectedOfferCatalogType = (ushort)OfferCatalogTypeEnum.Ems;
                    XRLXeVerifyTokenResponse vtResp = new XRLXeVerifyTokenResponse();
                    if (vtReq.Execute(out vtResp))
                    {
                        if (vtResp.OfferCatalogType != expectedOfferCatalogType)
                        {
                            throw new UnexpectedTestResultException(string.Format("Expected OfferCatalogType of: {0}, received: {1}", expectedOfferCatalogType, vtResp.OfferCatalogType));
                        }
                    }

                    OfferMediaTypeExpectedPrice omtep = new OfferMediaTypeExpectedPrice();
                    omtep.ExpectedPriceWhole = 800; // this seems wrong
                    omtep.ExpectedPriceFractional = 0;
                    omtep.MediaTypeId = (int)tc.ProductTypeId;
                    omtep.OfferId = tc.OfferId;
                    OfferMediaTypeExpectedPrice[] offers = new OfferMediaTypeExpectedPrice[] { omtep };

                    XRLPurchaseMediaOffers pmoReq = new XRLPurchaseMediaOffers();
                    pmoReq.UserPuid = user.UserPuid;
                    pmoReq.PaymentType = (uint)PaymentTypeEnum.Token;
                    pmoReq.Offers = offers;
                    pmoReq.BillingToken = arcadeToken;
                    pmoReq.StoreId = 1;
                    pmoReq.CustomHeader = BehaviorInjection.AddCTPPurchaseFailure("BDK_E_TOKEN_RANGE_NOT_ACTIVE", true);

                    if (!pmoReq.Execute() && pmoReq.XErr == 0x80190536 /* BDK_E_TOKEN_RANGE_NOT_ACTIVE */)
                    {
                        return;
                    }

                    throw new UnexpectedTestResultException("pmoReq.Execute either unexpectedly succeeded or failed wrongly");
                }
            }
        }

        [TestCase, Description("Arcade - Generate one non redeemable token and Verify token redemption fails")]
        class N_Arcade_Financial_VerifyToken_PurchaseMediaOffers_NonReedemable : WCFTestBase
        {
            private static TokenCategory tc = null;

            public override void PreRun()
            {
                if (tc == null)
                {
                    tc = MixTokenHelper.NewTokenCategoryInCsatArcadeGame();
                    tc.IsRedeemable = false;
                    WCFTestBase.PrintObject(tc);
                    WCFTestBase.PrintObject(tc.ChannelSKUArray);
                    TokenManagementWCFClient client = new TokenManagementWCFClient();
                    client.ConfigureTokenCategory(tc);
                }
            }

            public override void Run()
            {
                //Generate a token for the new token category
                Guid jobId = MixTokenHelper.GenerateTestTokens(tc.TokenCategoryId, 1, MixTokenHelper.Key, true, false);
                TokenEntry[] tokens = MixTokenHelper.GetTokenEntries(jobId, MixTokenHelper.Key);
                MixTokenHelper.VerifyTokens(1, tokens, tc);
                uint hrExpected = live.common.HResult.XONLINE_E_TOKEN_NOT_YET_REDEEMABLE;


                //Fetch the Token
                string arcadeToken = tokens[0].Token;

                // create a silver user
                XeUser user = XbosUser.XenonSilverUser();


                // call VerifyToken for the new token as an old client
                {
                    XRLXeVerifyToken vtReq = new XRLXeVerifyToken();
                    vtReq.UserPuid = user.UserPuid;
                    vtReq.BillingToken = arcadeToken;
                    XRLXeVerifyTokenResponse vtResp = new XRLXeVerifyTokenResponse();

                    if (vtReq.Execute(out vtResp))
                    {
                        throw new UnexpectedTestResultException(string.Format("Call to XeVerifyToken Succeded when it should have failed with Exception: {0}", hrExpected));
                    }
                    if (vtReq.XErr != hrExpected)
                    {
                        throw new UnexpectedTestResultException(String.Format("hrExpected {0:x} not Equal to hrReturned {1:x}", hrExpected, vtReq.XErr));
                    }

                    OfferMediaTypeExpectedPrice omtep = new OfferMediaTypeExpectedPrice();
                    omtep.ExpectedPriceWhole = 800; // this seems wrong
                    omtep.ExpectedPriceFractional = 0;
                    omtep.MediaTypeId = (int)tc.ProductTypeId;
                    omtep.OfferId = tc.OfferId;
                    OfferMediaTypeExpectedPrice[] offers = new OfferMediaTypeExpectedPrice[] { omtep };

                    XRLPurchaseMediaOffers pmoReq = new XRLPurchaseMediaOffers();
                    pmoReq.UserPuid = user.UserPuid;
                    pmoReq.PaymentType = (uint)PaymentTypeEnum.Token;
                    pmoReq.Offers = offers;
                    pmoReq.BillingToken = arcadeToken;
                    pmoReq.StoreId = 1;

                    if (pmoReq.Execute())
                    {
                        throw new UnexpectedTestResultException(String.Format("Purhcase of offer Passed when it should have failed with error: {0}", hrExpected));
                    }
                    if (pmoReq.XErr != hrExpected)
                    {
                        throw new UnexpectedTestResultException(String.Format("hrExpected {0:x} not Equal to hrReturned {1:x}", hrExpected, pmoReq.XErr));

                    }
                }
            }
        }

        [TestCase, Description("Arcade - generate one expired token for FINANCIAL game content and verify token redemption fails")]
        class N_Arcade_Financial_VerifyToken_PurchaseMediaOffers_Expired_TC : WCFTestBase
        {
            private static TokenCategory tc = null;

            public override void PreRun()
            {
                tc = CreateArcadeTokenCategory();
            }

            public override void Run()
            {
                //Generate a token for the new token category
                Guid jobId = MixTokenHelper.GenerateTestTokens(tc.TokenCategoryId, 1, MixTokenHelper.Key, true, false);
                TokenEntry[] tokens = MixTokenHelper.GetTokenEntries(jobId, MixTokenHelper.Key);
                MixTokenHelper.VerifyTokens(1, tokens, tc);
                uint hrExpected = HResult.XOFF_E_OFFER_EXPIRED;

                //Fetch the Token
                string arcadeToken = tokens[0].Token;

                // create a silver user
                XeUser user = XbosUser.XenonSilverUser();

                //Expire Token Category
                TokendbWS.ExipreTokenCategory(tc.TokenCategoryId);

                // call VerifyToken for the new token as an old client
                {
                    XRLXeVerifyToken vtReq = new XRLXeVerifyToken();
                    vtReq.UserPuid = user.UserPuid;
                    vtReq.BillingToken = arcadeToken;
                    XRLXeVerifyTokenResponse vtResp = new XRLXeVerifyTokenResponse();

                    if (vtReq.Execute(out vtResp))
                    {
                        throw new UnexpectedTestResultException(string.Format("Call to XeVerifyToken Succeded when it should have failed with Exception: {0}", hrExpected));
                    }
                    if (vtReq.XErr != hrExpected)
                    {
                        throw new UnexpectedTestResultException(String.Format("hrExpected {0:x} not Equal to hrReturned {1:x}", hrExpected, vtReq.XErr));
                    }

                    OfferMediaTypeExpectedPrice omtep = new OfferMediaTypeExpectedPrice();
                    omtep.ExpectedPriceWhole = 800; // this seems wrong
                    omtep.ExpectedPriceFractional = 0;
                    omtep.MediaTypeId = (int)tc.ProductTypeId;
                    omtep.OfferId = tc.OfferId;
                    OfferMediaTypeExpectedPrice[] offers = new OfferMediaTypeExpectedPrice[] { omtep };

                    XRLPurchaseMediaOffers pmoReq = new XRLPurchaseMediaOffers();
                    pmoReq.UserPuid = user.UserPuid;
                    pmoReq.PaymentType = (uint)PaymentTypeEnum.Token;
                    pmoReq.Offers = offers;
                    pmoReq.BillingToken = arcadeToken;
                    pmoReq.StoreId = 1;

                    if (pmoReq.Execute())
                    {
                        throw new UnexpectedTestResultException(String.Format("Purhcase of offer Passed when it should have failed with error: {0}", hrExpected));
                    }
                    if (pmoReq.XErr != hrExpected)
                    {
                        throw new UnexpectedTestResultException(String.Format("hrExpected {0:x} not Equal to hrReturned {1:x}", hrExpected, pmoReq.XErr));

                    }
                }
            }
        }

        [TestCase, Description("Arcade - Verify token redemption fails for invalid token")]
        class N_Arcade_VerifyToken_PurchaseMediaOffers_Invalid_Token : WCFTestBase
        {
            public override void Run()
            {
                // create a silver user
                XeUser user = XbosUser.XenonSilverUser();
                uint hrExpected = live.common.HResult.XONLINE_E_ACCOUNTS_INVALID_VOUCHER;

                // call VerifyToken for the new token as an old client
                {
                    XRLXeVerifyToken vtReq = new XRLXeVerifyToken();
                    vtReq.UserPuid = user.UserPuid;
                    vtReq.BillingToken = MixTokenHelper.InvalidToken;
                    XRLXeVerifyTokenResponse vtResp = new XRLXeVerifyTokenResponse();

                    if (vtReq.Execute(out vtResp))
                    {
                        throw new UnexpectedTestResultException(string.Format("Call to XeVerifyToken Succeded when it should have failed with Exception: {0}", hrExpected));
                    }
                    if (vtReq.XErr != hrExpected)
                    {
                        throw new UnexpectedTestResultException(String.Format("hrExpected {0:x} not Equal to hrReturned {1:x}", hrExpected, vtReq.XErr));
                    }

                    OfferMediaTypeExpectedPrice omtep = new OfferMediaTypeExpectedPrice();
                    omtep.ExpectedPriceWhole = 800; // this seems wrong
                    omtep.ExpectedPriceFractional = 0;
                    omtep.MediaTypeId = MediaTypeInfo.ArcadeGame;
                    omtep.OfferId = MixTokenHelper.TexasHoldemArcadeOfferId;
                    OfferMediaTypeExpectedPrice[] offers = new OfferMediaTypeExpectedPrice[] { omtep };

                    XRLPurchaseMediaOffers pmoReq = new XRLPurchaseMediaOffers();
                    pmoReq.UserPuid = user.UserPuid;
                    pmoReq.PaymentType = (uint)PaymentTypeEnum.Token;
                    pmoReq.Offers = offers;
                    pmoReq.BillingToken = MixTokenHelper.InvalidToken;
                    pmoReq.StoreId = 1;

                    if (pmoReq.Execute())
                    {
                        throw new UnexpectedTestResultException(String.Format("Purhcase of offer Passed when it should have failed with error: {0}", hrExpected));
                    }
                    if (pmoReq.XErr != hrExpected)
                    {
                        throw new UnexpectedTestResultException(String.Format("hrExpected {0:x} not Equal to hrReturned {1:x}", hrExpected, pmoReq.XErr));

                    }
                }
            }
        }

        [TestCase, Description("Arcade - Disable token for FINANCIAL game content and verify token redemption fails")]
        class N_Arcade_Financial_VerifyToken_PurchaseMediaOffers_Disable_Token : WCFTestBase
        {
            private static TokenCategory tc = null;

            public override void PreRun()
            {
                if (tc == null)
                {
                    tc = CreateArcadeTokenCategory();
                }
            }

            public override void Run()
            {
                //Generate a token for the new token category
                Guid jobId = MixTokenHelper.GenerateTestTokens(tc.TokenCategoryId, 1, MixTokenHelper.Key, true, false);
                TokenEntry[] tokens = MixTokenHelper.GetTokenEntries(jobId, MixTokenHelper.Key);
                MixTokenHelper.VerifyTokens(1, tokens, tc);
                uint hrExpected = HResult.XONLINE_E_ACCOUNTS_INVALID_VOUCHER;

                //Fetch the Token
                string arcadeToken = tokens[0].Token;

                // create a silver user
                XeUser user = XbosUser.XenonSilverUser();

                string tokenHash = TokendbWS.GetVoucherHash(arcadeToken);

                //Disable Token
                TokendbWS.DisableTokenV2(tokenHash);

                // call VerifyToken for the new token as an old client
                {
                    XRLXeVerifyToken vtReq = new XRLXeVerifyToken();
                    vtReq.UserPuid = user.UserPuid;
                    vtReq.BillingToken = arcadeToken;
                    XRLXeVerifyTokenResponse vtResp = new XRLXeVerifyTokenResponse();

                    if (vtReq.Execute(out vtResp))
                    {
                        throw new UnexpectedTestResultException(string.Format("Call to XeVerifyToken Succeded when it should have failed with Exception: {0}", hrExpected));
                    }
                    if (vtReq.XErr != hrExpected)
                    {
                        throw new UnexpectedTestResultException(String.Format("hrExpected {0:x} not Equal to hrReturned {1:x}", hrExpected, vtReq.XErr));
                    }

                    OfferMediaTypeExpectedPrice omtep = new OfferMediaTypeExpectedPrice();
                    omtep.ExpectedPriceWhole = 800; // this seems wrong
                    omtep.ExpectedPriceFractional = 0;
                    omtep.MediaTypeId = (int)tc.ProductTypeId;
                    omtep.OfferId = tc.OfferId;
                    OfferMediaTypeExpectedPrice[] offers = new OfferMediaTypeExpectedPrice[] { omtep };

                    XRLPurchaseMediaOffers pmoReq = new XRLPurchaseMediaOffers();
                    pmoReq.UserPuid = user.UserPuid;
                    pmoReq.PaymentType = (uint)PaymentTypeEnum.Token;
                    pmoReq.Offers = offers;
                    pmoReq.BillingToken = arcadeToken;
                    pmoReq.StoreId = 1;

                    if (pmoReq.Execute())
                    {
                        throw new UnexpectedTestResultException(String.Format("Purhcase of offer Passed when it should have failed with error: {0}", hrExpected));
                    }
                    if (pmoReq.XErr != hrExpected)
                    {
                        throw new UnexpectedTestResultException(String.Format("hrExpected {0:x} not Equal to hrReturned {1:x}", hrExpected, pmoReq.XErr));

                    }
                }

                //Re-Enable Token
                TokendbWS.EnableTokenV2(tokenHash);
                hrExpected = HResult.S_OK;

                //Verify Token Redemption works 
                {
                    XRLXeVerifyToken vtReq = new XRLXeVerifyToken();
                    vtReq.UserPuid = user.UserPuid;
                    vtReq.BillingToken = arcadeToken;
                    XRLXeVerifyTokenResponse vtResp = new XRLXeVerifyTokenResponse();

                    if (!vtReq.Execute(out vtResp))
                    {
                        throw new UnexpectedTestResultException(string.Format("Call to XeVerifyToken Failed with Exception: {0}", hrExpected));
                    }
                    if (vtReq.XErr != hrExpected)
                    {
                        throw new UnexpectedTestResultException(String.Format("hrExpected {0:x} not Equal to hrReturned {1:x}", hrExpected, vtReq.XErr));
                    }

                    OfferMediaTypeExpectedPrice omtep = new OfferMediaTypeExpectedPrice();
                    omtep.ExpectedPriceWhole = 800; // this seems wrong
                    omtep.ExpectedPriceFractional = 0;
                    omtep.MediaTypeId = (int)tc.ProductTypeId;
                    omtep.OfferId = tc.OfferId;
                    OfferMediaTypeExpectedPrice[] offers = new OfferMediaTypeExpectedPrice[] { omtep };

                    XRLPurchaseMediaOffers pmoReq = new XRLPurchaseMediaOffers();
                    pmoReq.UserPuid = user.UserPuid;
                    pmoReq.PaymentType = (uint)PaymentTypeEnum.Token;
                    pmoReq.Offers = offers;
                    pmoReq.BillingToken = arcadeToken;
                    pmoReq.StoreId = 1;

                    if (!pmoReq.Execute())
                    {
                        throw new UnexpectedTestResultException(String.Format("Purhcase of offer Failed with error: {0}", hrExpected));
                    }
                    if (pmoReq.XErr != hrExpected)
                    {
                        throw new UnexpectedTestResultException(String.Format("hrExpected {0:x} not Equal to hrReturned {1:x}", hrExpected, pmoReq.XErr));

                    }
                }
            }
        }

        #endregion

        #region Non-Financial Game Content

        [TestCase, Description("Arcade - Generate one token for NON-FINANCIAL game content and verify token redemption works fine")]
        class P_Arcade_NonFinancial_VerifyToken_PurchaseMediaOffers_MaxUsage1 : WCFTestBase
        {
            private static TokenCategory tc = null;

            public override void PreRun()
            {
                if (tc == null)
                {
                    tc = MixTokenHelper.NewTokenCategory();
                    PrintObject(tc);
                    TokenManagementWCFClient client = new TokenManagementWCFClient();
                    client.ConfigureTokenCategory(tc);
                }
            }

            public override void Run()
            {
                //Generate a token for the new token category
                Guid jobId = MixTokenHelper.GenerateTestTokens(tc.TokenCategoryId, 1, MixTokenHelper.Key, true, false);
                TokenEntry[] tokens = MixTokenHelper.GetTokenEntries(jobId, MixTokenHelper.Key);
                MixTokenHelper.VerifyTokens(1, tokens, tc);
                uint hrExpected = live.common.HResult.S_OK;

                //Fetch the Token
                string arcadeToken = tokens[0].Token;

                // create a silver user
                XeUser user = XbosUser.XenonSilverUser();


                // call VerifyToken for the new token as an old client
                {
                    XRLXeVerifyToken vtReq = new XRLXeVerifyToken();
                    vtReq.UserPuid = user.UserPuid;
                    vtReq.BillingToken = arcadeToken;
                    ushort expectedOfferCatalogType = (ushort)OfferCatalogTypeEnum.Ems;
                    XRLXeVerifyTokenResponse vtResp = new XRLXeVerifyTokenResponse();

                    if (vtReq.Execute(out vtResp))
                    {
                        if (vtResp.OfferCatalogType != expectedOfferCatalogType)
                        {
                            throw new UnexpectedTestResultException(string.Format("Expected OfferCatalogType of: {0}, received: {1}", expectedOfferCatalogType, vtResp.OfferCatalogType));
                        }
                    }
                    if (vtReq.XErr != hrExpected)
                    {
                        throw new UnexpectedTestResultException(String.Format("hrExpected {0:x} not Equal to hrReturned {1:x}", hrExpected, vtReq.XErr));
                    }

                    OfferMediaTypeExpectedPrice omtep = new OfferMediaTypeExpectedPrice();
                    omtep.ExpectedPriceWhole = 800; // this seems wrong
                    omtep.ExpectedPriceFractional = 0;
                    omtep.MediaTypeId = (int)tc.ProductTypeId;
                    omtep.OfferId = tc.OfferId;
                    OfferMediaTypeExpectedPrice[] offers = new OfferMediaTypeExpectedPrice[] { omtep };

                    XRLPurchaseMediaOffers pmoReq = new XRLPurchaseMediaOffers();
                    pmoReq.UserPuid = user.UserPuid;
                    pmoReq.PaymentType = (uint)PaymentTypeEnum.Token;
                    pmoReq.Offers = offers;
                    pmoReq.BillingToken = arcadeToken;
                    pmoReq.StoreId = 1;

                    if (!pmoReq.Execute())
                    {
                        throw new UnexpectedTestResultException(String.Format("Purhcase of offer faled with: {0}", pmoReq.XErr));
                    }
                    if (pmoReq.XErr != hrExpected)
                    {
                        throw new UnexpectedTestResultException(String.Format("hrExpected {0:x} not Equal to hrReturned {1:x}", hrExpected, pmoReq.XErr));

                    }
                }

                //Same user trying to redeem the token twice
                {
                    hrExpected = live.common.HResult.XOFF_E_ALREADY_OWN_MAX;

                    OfferMediaTypeExpectedPrice omtep = new OfferMediaTypeExpectedPrice();
                    omtep.ExpectedPriceWhole = 800; // this seems wrong
                    omtep.ExpectedPriceFractional = 0;
                    omtep.MediaTypeId = (int)tc.ProductTypeId;
                    omtep.OfferId = tc.OfferId;
                    OfferMediaTypeExpectedPrice[] offers = new OfferMediaTypeExpectedPrice[] { omtep };

                    XRLPurchaseMediaOffers pmoReq = new XRLPurchaseMediaOffers();
                    pmoReq.UserPuid = user.UserPuid;
                    pmoReq.PaymentType = (uint)PaymentTypeEnum.Token;
                    pmoReq.Offers = offers;
                    pmoReq.BillingToken = arcadeToken;
                    pmoReq.StoreId = 1;

                    if (pmoReq.Execute())
                    {
                        throw new UnexpectedTestResultException(String.Format("Purhcase of offer Succeeded when it should have faled with: {0}", hrExpected));
                    }
                    if (pmoReq.XErr != hrExpected)
                    {
                        throw new UnexpectedTestResultException(String.Format("hrExpected {0:x} not Equal to hrReturned {1:x}", hrExpected, pmoReq.XErr));

                    }
                }

                //Different user trying to redeem the already used token
                {
                    hrExpected = live.common.HResult.XONLINE_E_ACCOUNTS_VOUCHER_ALREADY_USED;

                    XeUser newUser = XbosUser.XenonSilverUser();

                    OfferMediaTypeExpectedPrice omtep = new OfferMediaTypeExpectedPrice();
                    omtep.ExpectedPriceWhole = 800; // this seems wrong
                    omtep.ExpectedPriceFractional = 0;
                    omtep.MediaTypeId = (int)tc.ProductTypeId;
                    omtep.OfferId = tc.OfferId;
                    OfferMediaTypeExpectedPrice[] offers = new OfferMediaTypeExpectedPrice[] { omtep };

                    XRLPurchaseMediaOffers pmoReq = new XRLPurchaseMediaOffers();
                    pmoReq.UserPuid = newUser.UserPuid;
                    pmoReq.PaymentType = (uint)PaymentTypeEnum.Token;
                    pmoReq.Offers = offers;
                    pmoReq.BillingToken = arcadeToken;
                    pmoReq.StoreId = 1;

                    if (pmoReq.Execute())
                    {
                        throw new UnexpectedTestResultException(String.Format("Purhcase of offer Succeeded when it should have faled with: {0}", hrExpected));
                    }
                    if (pmoReq.XErr != hrExpected)
                    {
                        throw new UnexpectedTestResultException(String.Format("hrExpected {0:x} not Equal to hrReturned {1:x}", hrExpected, pmoReq.XErr));

                    }
                }
            }
        }

        [TestCase, Description("Arcade - Generate one non-redeemable token for NON-FINANCIAL game content and verify token redemption fails")]
        class N_Arcade_NonFinancial_VerifyToken_PurchaseMediaOffers_NonReedemable : WCFTestBase
        {
            private static TokenCategory tc = null;

            public override void PreRun()
            {
                if (tc == null)
                {
                    tc = MixTokenHelper.NewTokenCategory();
                    tc.IsRedeemable = false;
                    PrintObject(tc);
                    TokenManagementWCFClient client = new TokenManagementWCFClient();
                    client.ConfigureTokenCategory(tc);
                }
            }

            public override void Run()
            {
                //Generate a token for the new token category
                Guid jobId = MixTokenHelper.GenerateTestTokens(tc.TokenCategoryId, 1, MixTokenHelper.Key, true, false);
                TokenEntry[] tokens = MixTokenHelper.GetTokenEntries(jobId, MixTokenHelper.Key);
                MixTokenHelper.VerifyTokens(1, tokens, tc);
                uint hrExpected = live.common.HResult.XONLINE_E_TOKEN_NOT_YET_REDEEMABLE;


                //Fetch the Token
                string arcadeToken = tokens[0].Token;

                // create a silver user
                XeUser user = XbosUser.XenonSilverUser();


                // call VerifyToken for the new token as an old client
                {
                    XRLXeVerifyToken vtReq = new XRLXeVerifyToken();
                    vtReq.UserPuid = user.UserPuid;
                    vtReq.BillingToken = arcadeToken;
                    XRLXeVerifyTokenResponse vtResp = new XRLXeVerifyTokenResponse();

                    if (vtReq.Execute(out vtResp))
                    {
                        throw new UnexpectedTestResultException(string.Format("Call to XeVerifyToken Succeded when it should have failed with Exception: {0}", hrExpected));
                    }
                    if (vtReq.XErr != hrExpected)
                    {
                        throw new UnexpectedTestResultException(String.Format("hrExpected {0:x} not Equal to hrReturned {1:x}", hrExpected, vtReq.XErr));
                    }

                    OfferMediaTypeExpectedPrice omtep = new OfferMediaTypeExpectedPrice();
                    omtep.ExpectedPriceWhole = 800; // this seems wrong
                    omtep.ExpectedPriceFractional = 0;
                    omtep.MediaTypeId = (int)tc.ProductTypeId;
                    omtep.OfferId = tc.OfferId;
                    OfferMediaTypeExpectedPrice[] offers = new OfferMediaTypeExpectedPrice[] { omtep };

                    XRLPurchaseMediaOffers pmoReq = new XRLPurchaseMediaOffers();
                    pmoReq.UserPuid = user.UserPuid;
                    pmoReq.PaymentType = (uint)PaymentTypeEnum.Token;
                    pmoReq.Offers = offers;
                    pmoReq.BillingToken = arcadeToken;
                    pmoReq.StoreId = 1;

                    if (pmoReq.Execute())
                    {
                        throw new UnexpectedTestResultException(String.Format("Purhcase of offer Passed when it should have failed with error: {0}", hrExpected));
                    }
                    if (pmoReq.XErr != hrExpected)
                    {
                        throw new UnexpectedTestResultException(String.Format("hrExpected {0:x} not Equal to hrReturned {1:x}", hrExpected, pmoReq.XErr));

                    }
                }
            }
        }

        [TestCase, Description("Arcade - generate one expired token for NON-FINANCIAL game content and verify token redemption fails")]
        class N_Arcade_NonFinancial_VerifyToken_PurchaseMediaOffers_Expired_TC : WCFTestBase
        {
            private static TokenCategory tc = null;

            public override void PreRun()
            {
                tc = MixTokenHelper.NewTokenCategory();
                WCFTestBase.PrintObject(tc);
                TokenManagementWCFClient client = new TokenManagementWCFClient();
                client.ConfigureTokenCategory(tc);
            }

            public override void Run()
            {
                //Generate a token for the new token category
                Guid jobId = MixTokenHelper.GenerateTestTokens(tc.TokenCategoryId, 1, MixTokenHelper.Key, true, false);
                TokenEntry[] tokens = MixTokenHelper.GetTokenEntries(jobId, MixTokenHelper.Key);
                MixTokenHelper.VerifyTokens(1, tokens, tc);
                uint hrExpected = HResult.XOFF_E_OFFER_EXPIRED;

                //Fetch the Token
                string arcadeToken = tokens[0].Token;

                //Expire Token Category
                TokendbWS.ExipreTokenCategory(tc.TokenCategoryId);

                // create a silver user
                XeUser user = XbosUser.XenonSilverUser();


                // call VerifyToken for the new token as an old client
                {
                    XRLXeVerifyToken vtReq = new XRLXeVerifyToken();
                    vtReq.UserPuid = user.UserPuid;
                    vtReq.BillingToken = arcadeToken;
                    XRLXeVerifyTokenResponse vtResp = new XRLXeVerifyTokenResponse();

                    if (vtReq.Execute(out vtResp))
                    {
                        throw new UnexpectedTestResultException(string.Format("Call to XeVerifyToken Succeded when it should have failed with Exception: {0}", hrExpected));
                    }
                    if (vtReq.XErr != hrExpected)
                    {
                        throw new UnexpectedTestResultException(String.Format("hrExpected {0:x} not Equal to hrReturned {1:x}", hrExpected, vtReq.XErr));
                    }

                    OfferMediaTypeExpectedPrice omtep = new OfferMediaTypeExpectedPrice();
                    omtep.ExpectedPriceWhole = 800; // this seems wrong
                    omtep.ExpectedPriceFractional = 0;
                    omtep.MediaTypeId = (int)tc.ProductTypeId;
                    omtep.OfferId = tc.OfferId;
                    OfferMediaTypeExpectedPrice[] offers = new OfferMediaTypeExpectedPrice[] { omtep };

                    XRLPurchaseMediaOffers pmoReq = new XRLPurchaseMediaOffers();
                    pmoReq.UserPuid = user.UserPuid;
                    pmoReq.PaymentType = (uint)PaymentTypeEnum.Token;
                    pmoReq.Offers = offers;
                    pmoReq.BillingToken = arcadeToken;
                    pmoReq.StoreId = 1;

                    if (pmoReq.Execute())
                    {
                        throw new UnexpectedTestResultException(String.Format("Purhcase of offer Passed when it should have failed with error: {0}", hrExpected));
                    }
                    if (pmoReq.XErr != hrExpected)
                    {
                        throw new UnexpectedTestResultException(String.Format("hrExpected {0:x} not Equal to hrReturned {1:x}", hrExpected, pmoReq.XErr));

                    }
                }
            }
        }

        [TestCase, Description("Arcade - Disable token for NON FINANCIAL game content and verify token redemption fails")]
        class N_Arcade_NonFinancial_VerifyToken_PurchaseMediaOffers_Disable_Token : WCFTestBase
        {
            private static TokenCategory tc = null;

            public override void PreRun()
            {
                if (tc == null)
                {
                    tc = MixTokenHelper.NewTokenCategory();
                    WCFTestBase.PrintObject(tc);
                    TokenManagementWCFClient client = new TokenManagementWCFClient();
                    client.ConfigureTokenCategory(tc);
                }
            }

            public override void Run()
            {
                //Generate a token for the new token category
                Guid jobId = MixTokenHelper.GenerateTestTokens(tc.TokenCategoryId, 1, MixTokenHelper.Key, true, false);
                TokenEntry[] tokens = MixTokenHelper.GetTokenEntries(jobId, MixTokenHelper.Key);
                MixTokenHelper.VerifyTokens(1, tokens, tc);
                uint hrExpected = HResult.XONLINE_E_ACCOUNTS_INVALID_VOUCHER;

                //Fetch the Token
                string arcadeToken = tokens[0].Token;

                // create a silver user
                XeUser user = XbosUser.XenonSilverUser();

                string tokenHash = TokendbWS.GetVoucherHash(arcadeToken);

                //Disable Token
                TokendbWS.DisableTokenV2(tokenHash);

                // call VerifyToken for the new token as an old client
                {
                    XRLXeVerifyToken vtReq = new XRLXeVerifyToken();
                    vtReq.UserPuid = user.UserPuid;
                    vtReq.BillingToken = arcadeToken;
                    XRLXeVerifyTokenResponse vtResp = new XRLXeVerifyTokenResponse();

                    if (vtReq.Execute(out vtResp))
                    {
                        throw new UnexpectedTestResultException(string.Format("Call to XeVerifyToken Succeded when it should have failed with Exception: {0}", hrExpected));
                    }
                    if (vtReq.XErr != hrExpected)
                    {
                        throw new UnexpectedTestResultException(String.Format("hrExpected {0:x} not Equal to hrReturned {1:x}", hrExpected, vtReq.XErr));
                    }

                    OfferMediaTypeExpectedPrice omtep = new OfferMediaTypeExpectedPrice();
                    omtep.ExpectedPriceWhole = 800; // this seems wrong
                    omtep.ExpectedPriceFractional = 0;
                    omtep.MediaTypeId = (int)tc.ProductTypeId;
                    omtep.OfferId = tc.OfferId;
                    OfferMediaTypeExpectedPrice[] offers = new OfferMediaTypeExpectedPrice[] { omtep };

                    XRLPurchaseMediaOffers pmoReq = new XRLPurchaseMediaOffers();
                    pmoReq.UserPuid = user.UserPuid;
                    pmoReq.PaymentType = (uint)PaymentTypeEnum.Token;
                    pmoReq.Offers = offers;
                    pmoReq.BillingToken = arcadeToken;
                    pmoReq.StoreId = 1;

                    if (pmoReq.Execute())
                    {
                        throw new UnexpectedTestResultException(String.Format("Purhcase of offer Passed when it should have failed with error: {0}", hrExpected));
                    }
                    if (pmoReq.XErr != hrExpected)
                    {
                        throw new UnexpectedTestResultException(String.Format("hrExpected {0:x} not Equal to hrReturned {1:x}", hrExpected, pmoReq.XErr));

                    }
                }

                //Re-Enable Token
                TokendbWS.EnableTokenV2(tokenHash);
                hrExpected = HResult.S_OK;

                //Verify Token Redemption works 
                {
                    XRLXeVerifyToken vtReq = new XRLXeVerifyToken();
                    vtReq.UserPuid = user.UserPuid;
                    vtReq.BillingToken = arcadeToken;
                    XRLXeVerifyTokenResponse vtResp = new XRLXeVerifyTokenResponse();

                    if (!vtReq.Execute(out vtResp))
                    {
                        throw new UnexpectedTestResultException(string.Format("Call to XeVerifyToken Failed with Exception: {0}", hrExpected));
                    }
                    if (vtReq.XErr != hrExpected)
                    {
                        throw new UnexpectedTestResultException(String.Format("hrExpected {0:x} not Equal to hrReturned {1:x}", hrExpected, vtReq.XErr));
                    }

                    OfferMediaTypeExpectedPrice omtep = new OfferMediaTypeExpectedPrice();
                    omtep.ExpectedPriceWhole = 800; // this seems wrong
                    omtep.ExpectedPriceFractional = 0;
                    omtep.MediaTypeId = (int)tc.ProductTypeId;
                    omtep.OfferId = tc.OfferId;
                    OfferMediaTypeExpectedPrice[] offers = new OfferMediaTypeExpectedPrice[] { omtep };

                    XRLPurchaseMediaOffers pmoReq = new XRLPurchaseMediaOffers();
                    pmoReq.UserPuid = user.UserPuid;
                    pmoReq.PaymentType = (uint)PaymentTypeEnum.Token;
                    pmoReq.Offers = offers;
                    pmoReq.BillingToken = arcadeToken;
                    pmoReq.StoreId = 1;

                    if (!pmoReq.Execute())
                    {
                        throw new UnexpectedTestResultException(String.Format("Purhcase of offer Failed with error: {0}", hrExpected));
                    }
                    if (pmoReq.XErr != hrExpected)
                    {
                        throw new UnexpectedTestResultException(String.Format("hrExpected {0:x} not Equal to hrReturned {1:x}", hrExpected, pmoReq.XErr));

                    }
                }
            }
        }

        #endregion 
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\TitleManagement\Contracts\DataContractV2.cs ===
using System;
using System.Runtime.Serialization;
using Microsoft.Practices.EnterpriseLibrary.Validation.Validators;
using xonline.mix.common;

namespace xonline.mix.titlemanagement.contract.v2
{
    // Duplication of ConsoleTypeEnum enum from common\config\config\titleconfig.cs  (matches UODB's t_console_types).
    [DataContract(Name = "PlatformType", Namespace = "http://xonline.mix.titlemanagement.contracts/V2")]
    public enum PlatformTypeV2: byte
    {
        [EnumMember]
        Xbox1 = 0,
        [EnumMember]
        XboxCom = 1,
        [EnumMember]
        Xenon = 2,
        [EnumMember]
        Marketplace = 3,
        [EnumMember]
        PC = 4,
        [EnumMember]
        Mobile = 5,
        [EnumMember]
        WebGames = 6,
    }

    [DataContract(Name = "TitleVersions", Namespace = "http://xonline.mix.titlemanagement.contracts/V2")]
    public class TitleVersionsV2
    {
        [DataMember(Name = "Versions", IsRequired = true)]
        [NotNullValidator(MessageTemplate = MixConstants.TemplateMessages.NullObjectString/*, Tag = MixConstants.Tags.OfferTag*/)]
        [ObjectCollectionValidator(typeof(TitleVersionInstanceV2))]
        public TitleVersionInstanceV2[] Versions { get; set; }
    }

    [DataContract(Name = "TitleVersionInstance", Namespace = "http://xonline.mix.titlemanagement.contracts/V2")]
    public class TitleVersionInstanceV2
    {
        [DataMember(Name = "TitleId", IsRequired = true)]
        public uint TitleId { get; set; }

        [DataMember(Name = "BaseVersion", IsRequired = true)]
        public int BaseVersion { get; set; }

        [DataMember(Name = "UpdateVersion", IsRequired = true)]
        public int UpdateVersion { get; set; }

        [DataMember(Name = "PlatformType", IsRequired = true)]
        public PlatformTypeV2 PlatformType { get; set; }

        [DataMember(Name = "BetaGroup", IsRequired = true)]
        public Guid BetaGroup { get; set; }

        public TitleVersionInstanceV2()
        {
        }

        public TitleVersionInstanceV2(uint titleId, int baseVersion, PlatformTypeV2 platformType)
        {
            TitleId = titleId;
            BaseVersion = baseVersion;
            UpdateVersion = baseVersion;
            PlatformType = platformType;
            BetaGroup = Guid.Empty;
        }

        public TitleVersionInstanceV2(uint titleId, int baseVersion, int updateVersion, PlatformTypeV2 platformType, Guid betaGroup)
        {
            TitleId = titleId;
            BaseVersion = baseVersion;
            UpdateVersion = updateVersion;
            PlatformType = platformType;
            BetaGroup = betaGroup;
        }
    }

    [DataContract(Name = "TitleUpdatePackageLocation", Namespace = "http://xonline.mix.titlemanagement.contracts/V2")]
    public class TitleUpdatePackageLocationV2
    {
        [DataMember(Name = "Rank", IsRequired = true)]
        public int    Rank { get; set; }

        [DataMember(Name = "Xrl", IsRequired = true)]
        public string Xrl { get; set; }
    }

    [DataContract(Name = "TitleUpdatePackageInformation", Namespace = "http://xonline.mix.titlemanagement.contracts/V2")]
    public class TitleUpdatePackageInformationV2
    {
        [DataMember(Name = "UpdateSymmetricKey", IsRequired = true)]
        public byte []UpdateSymmetricKey { get; set; }

        [DataMember(Name = "PublicKey", IsRequired = true)]
        public byte []PublicKey { get; set; }

        [DataMember(Name = "InstallSize", IsRequired = true)]
        public int    InstallSize { get; set; }

        [DataMember(Name = "PackageSize", IsRequired = true)]
        public int    PackageSize { get; set; }

        [DataMember(Name = "ContentId", IsRequired = true)]
        public byte []ContentId { get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\TitleManagement\Contracts\DataContractV3.cs ===
using System;
using System.Runtime.Serialization;
using Microsoft.Practices.EnterpriseLibrary.Validation.Validators;
using xonline.mix.common;

namespace xonline.mix.titlemanagement.contract.V3
{
    // Duplication of ConsoleTypeEnum enum from common\config\config\titleconfig.cs  (matches UODB's t_console_types).
    [DataContract(Name = "PlatformType", Namespace = "http://xonline.mix.titlemanagement.contracts/V3")]
    public enum PlatformTypeV3: byte
    {
        [EnumMember]
        Xbox1 = 0,
        [EnumMember]
        XboxCom = 1,
        [EnumMember]
        Xenon = 2,
        [EnumMember]
        Marketplace = 3,
        [EnumMember]
        PC = 4,
        [EnumMember]
        Mobile = 5,
        [EnumMember]
        WebGames = 6,
    }

    [DataContract(Name = "TitleVersions", Namespace = "http://xonline.mix.titlemanagement.contracts/V3")]
    public class TitleVersionsV3
    {
        [DataMember(Name = "Versions", IsRequired = true)]
        [NotNullValidator(MessageTemplate = MixConstants.TemplateMessages.NullObjectString/*, Tag = MixConstants.Tags.OfferTag*/)]
        [ObjectCollectionValidator(typeof(TitleVersionInstanceV3))]
        public TitleVersionInstanceV3[] Versions { get; set; }
    }

    [DataContract(Name = "TitleVersionInstance", Namespace = "http://xonline.mix.titlemanagement.contracts/V3")]
    public class TitleVersionInstanceV3
    {
        [DataMember(Name = "TitleId", IsRequired = true)]
        public uint TitleId { get; set; }

        [DataMember(Name = "BaseVersion", IsRequired = true)]
        public int BaseVersion { get; set; }

        [DataMember(Name = "UpdateVersion", IsRequired = true)]
        public int UpdateVersion { get; set; }

        [DataMember(Name = "PlatformType", IsRequired = true)]
        public PlatformTypeV3 PlatformType { get; set; }

        [DataMember(Name = "BetaGroup", IsRequired = true)]
        public Guid BetaGroup { get; set; }

        public TitleVersionInstanceV3()
        {
        }

        public TitleVersionInstanceV3(uint titleId, int baseVersion, PlatformTypeV3 platformType)
        {
            TitleId = titleId;
            BaseVersion = baseVersion;
            UpdateVersion = baseVersion;
            PlatformType = platformType;
            BetaGroup = Guid.Empty;
        }

        public TitleVersionInstanceV3(uint titleId, int baseVersion, int updateVersion, PlatformTypeV3 platformType, Guid betaGroup)
        {
            TitleId = titleId;
            BaseVersion = baseVersion;
            UpdateVersion = updateVersion;
            PlatformType = platformType;
            BetaGroup = betaGroup;
        }
    }

    [DataContract(Name = "TitleUpdatePackageLocation", Namespace = "http://xonline.mix.titlemanagement.contracts/V3")]
    public class TitleUpdatePackageLocationV3
    {
        [DataMember(Name = "Rank", IsRequired = true)]
        public int    Rank { get; set; }

        [DataMember(Name = "Xrl", IsRequired = true)]
        public string Xrl { get; set; }
    }

    [DataContract(Name = "TitleUpdatePackageInformation", Namespace = "http://xonline.mix.titlemanagement.contracts/V3")]
    public class TitleUpdatePackageInformationV3
    {
        [DataMember(Name = "UpdateSymmetricKey", IsRequired = true)]
        public byte []UpdateSymmetricKey { get; set; }

        [DataMember(Name = "PublicKey", IsRequired = true)]
        public byte []PublicKey { get; set; }

        [DataMember(Name = "InstallSize", IsRequired = true)]
        public int    InstallSize { get; set; }

        [DataMember(Name = "PackageSize", IsRequired = true)]
        public int    PackageSize { get; set; }

        [DataMember(Name = "ContentId", IsRequired = true)]
        public byte []ContentId { get; set; }
    }

    [DataContract(Name = "TitleEndpoint", Namespace = "http://xonline.mix.titlemanagement.contracts/V3")]
    public class TitleEndpointV3
    {
        [DataMember(Name = "Protocol", IsRequired = true)]
        public string Protocol { get; set; }

        [DataMember(Name = "Hostname", IsRequired = false)]
        public string Hostname { get; set; }

        [DataMember(Name = "FromIP", IsRequired = false)]
        public uint FromIP { get; set; }

        [DataMember(Name = "ToIP", IsRequired = false)]
        public uint ToIP { get; set; }

        [DataMember(Name = "Path", IsRequired = false)]
        public string Path { get; set; }

        [DataMember(Name = "Port", IsRequired = false)]
        public int Port { get; set; }

        [DataMember(Name = "AppliesToUri", IsRequired = false)]
        public string AppliesToUri { get; set; }
    }

    [DataContract(Name = "TitleEndpointInfo", Namespace = "http://xonline.mix.titlemanagement.contracts/V3")]
    public class TitleEndpointInfoV3
    {
        [DataMember(Name = "TitleID", IsRequired = true)]
        public uint TitleID { get; set; }

        [DataMember(Name = "EndpointInfo", IsRequired = true)]
        public TitleEndpointV3 EndpointInfo { get; set; }

        [DataMember(Name = "Start", IsRequired = true)]
        public DateTime Start { get; set; }

        [DataMember(Name = "End", IsRequired = true)]
        public DateTime End { get; set; }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\TitleManagement\Contracts\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\TitleManagement\Contracts\ServiceContractV1.cs ===
ï»¿using System;
using System.ServiceModel;
using xonline.mix.common;
using Microsoft.Practices.EnterpriseLibrary.Validation.Integration.WCF;

namespace xonline.mix.titlemanagement.contract
{
    // NOTE: If you change the interface name "IMixOfferManagementV1" here, you must also update the reference to "IMixOfferManagementV1" in Web.config.
    [ServiceContract(Name = "MixTitleManagement", Namespace = "http://xonline.mix.titlemanagement.contracts/V1")]
    public interface IMixTitleManagementV1
    {
        [OperationContract(Name = "ConfigureTitle")]
        [FaultContract(typeof(MixClientFault))]
        [FaultContract(typeof(ValidationFault), Name = "ValidationFault", Namespace = "http://xonline.mix.common.contracts")]
        void ConfigureTitle(byte[] compressedXlast, bool noReload);

        [OperationContract(Name = "AddBaseVersion")]
        [FaultContract(typeof(MixClientFault))]
        [FaultContract(typeof(ValidationFault), Name = "ValidationFault", Namespace = "http://xonline.mix.common.contracts")]
        void AddBaseVersion(uint titleId, int version, PlatformType platformType, Guid betaGroup);

        [OperationContract(Name = "RemoveBaseVersion")]
        [FaultContract(typeof(MixClientFault))]
        [FaultContract(typeof(ValidationFault), Name = "ValidationFault", Namespace = "http://xonline.mix.common.contracts")]
        void RemoveBaseVersion(uint titleId, int version, PlatformType platformType, Guid betaGroup);

        [OperationContract(Name = "GetTitleVersions")]
        [FaultContract(typeof(MixClientFault))]
        [FaultContract(typeof(ValidationFault), Name = "ValidationFault", Namespace = "http://xonline.mix.common.contracts")]
        TitleVersionsV1 GetTitleVersions(uint titleId);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\TitleManagement\Contracts\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\TitleManagement\Contracts\ServiceContractV3.cs ===
ï»¿using System;
using System.ServiceModel;
using xonline.mix.common;
using Microsoft.Practices.EnterpriseLibrary.Validation.Integration.WCF;

namespace xonline.mix.titlemanagement.contract.V3
{
    // NOTE: If you change the interface name "IMixOfferManagementV3" here, you must also update the reference to "IMixOfferManagementV3" in Web.config.
    [ServiceContract(Name = "MixTitleManagementV3", Namespace = "http://xonline.mix.titlemanagement.contracts/V3")]
    public interface IMixTitleManagementV3
    {
        [OperationContract(Name = "ConfigureTitle")]
        [FaultContract(typeof(MixClientFault))]
        [FaultContract(typeof(ValidationFault), Name = "ValidationFault", Namespace = "http://xonline.mix.common.contracts")]
        void ConfigureTitle(byte[] compressedXlast, bool noReload);

        [OperationContract(Name = "AddBaseVersion")]
        [FaultContract(typeof(MixClientFault))]
        [FaultContract(typeof(ValidationFault), Name = "ValidationFault", Namespace = "http://xonline.mix.common.contracts")]
        void AddBaseVersion(uint titleId, int version, PlatformTypeV3 platformType, Guid betaGroup);

        [OperationContract(Name = "RemoveBaseVersion")]
        [FaultContract(typeof(MixClientFault))]
        [FaultContract(typeof(ValidationFault), Name = "ValidationFault", Namespace = "http://xonline.mix.common.contracts")]
        void RemoveBaseVersion(uint titleId, int version, PlatformTypeV3 platformType, Guid betaGroup);

        [OperationContract(Name = "GetTitleVersions")]
        [FaultContract(typeof(MixClientFault))]
        [FaultContract(typeof(ValidationFault), Name = "ValidationFault", Namespace = "http://xonline.mix.common.contracts")]
        TitleVersionsV3 GetTitleVersions(uint titleId);

        [OperationContract(Name = "SetTitleUpdatePackages")]
        [FaultContract(typeof(MixClientFault))]
        [FaultContract(typeof(ValidationFault), Name = "ValidationFault", Namespace = "http://xonline.mix.common.contracts")]
        void SetTitleUpdatePackages(uint titleId, int baseVersion, int updateVersion, PlatformTypeV3 consoleType, TitleUpdatePackageInformationV3 packageInformation, TitleUpdatePackageLocationV3 []updateLocations);

        [OperationContract(Name = "GetBusinessPartnerTitleIDs")]
        [FaultContract(typeof(MixClientFault))]
        [FaultContract(typeof(ValidationFault), Name = "ValidationFault", Namespace = "http://xonline.mix.common.contracts")]
        uint[] GetBusinessPartnerTitleIDs(Guid businessPartnerID);

        [OperationContract(Name = "SetBusinessPartnerTitleIDs")]
        [FaultContract(typeof(MixClientFault))]
        [FaultContract(typeof(ValidationFault), Name = "ValidationFault", Namespace = "http://xonline.mix.common.contracts")]
        void SetBusinessPartnerTitleIDs(Guid businessPartnerID, uint[] titleIDs);

        [OperationContract(Name = "SetNetworkSecurityList")]
        [FaultContract(typeof(MixClientFault))]
        [FaultContract(typeof(ValidationFault), Name = "ValidationFault", Namespace = "http://xonline.mix.common.contracts")]
        void SetNetworkSecurityList(uint titleID, TitleEndpointV3[] allowedEndpoints);

        [OperationContract(Name = "GetNetworkSecurityList")]
        [FaultContract(typeof(MixClientFault))]
        [FaultContract(typeof(ValidationFault), Name = "ValidationFault", Namespace = "http://xonline.mix.common.contracts")]
        TitleEndpointInfoV3[] GetNetworkSecurityList(uint titleID, bool bFullHistory);

        [OperationContract(Name = "GetNetworkSecurityListByAppliesTo")]
        [FaultContract(typeof(MixClientFault))]
        [FaultContract(typeof(ValidationFault), Name = "ValidationFault", Namespace = "http://xonline.mix.common.contracts")]
        TitleEndpointInfoV3[] GetNetworkSecurityListByAppliesTo(string appliesTo, bool bFullHistory);
     }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\TitleManagement\Contracts\DataContractV1.cs ===
ï»¿using System;
using System.Runtime.Serialization;
using Microsoft.Practices.EnterpriseLibrary.Validation.Validators;
using xonline.mix.common;

namespace xonline.mix.titlemanagement.contract
{
    // Duplication of ConsoleTypeEnum enum from common\config\config\titleconfig.cs
    [DataContract(Name = "PlatformType", Namespace = "http://xonline.mix.titlemanagement.contracts/V1")]
    public enum PlatformType
    {
        [EnumMember]
        Xbox1 = 0,
        [EnumMember]
        XboxCom = 1,
        [EnumMember]
        Xenon = 2,
        [EnumMember]
        Marketplace = 3,
        [EnumMember]
        PC = 4,
        [EnumMember]
        Mobile = 5,
        [EnumMember]
        WebGames = 6,
    }

    [DataContract(Name = "TitleVersions", Namespace = "http://xonline.mix.titlemanagement.contracts/V1")]
    public class TitleVersionsV1
    {
        [DataMember(Name = "Versions", IsRequired = true)]
        [NotNullValidator(MessageTemplate = MixConstants.TemplateMessages.NullObjectString/*, Tag = MixConstants.Tags.OfferTag*/)]
        [ObjectCollectionValidator(typeof(TitleVersionInstanceV1))]
        public TitleVersionInstanceV1[] Versions { get; set; }
    }

    [DataContract(Name = "TitleVersionInstance", Namespace = "http://xonline.mix.titlemanagement.contracts/V1")]
    public class TitleVersionInstanceV1
    {
        [DataMember(Name = "TitleId", IsRequired = true)]
        public uint TitleId { get; set; }

        [DataMember(Name = "BaseVersion", IsRequired = true)]
        public int BaseVersion { get; set; }

        [DataMember(Name = "UpdateVersion", IsRequired = true)]
        public int UpdateVersion { get; set; }

        [DataMember(Name = "PlatformType", IsRequired = true)]
        public PlatformType PlatformType { get; set; }

        [DataMember(Name = "BetaGroup", IsRequired = true)]
        public Guid BetaGroup { get; set; }

        public TitleVersionInstanceV1()
        {
        }

        public TitleVersionInstanceV1(uint titleId, int baseVersion, PlatformType platformType)
        {
            TitleId = titleId;
            BaseVersion = baseVersion;
            UpdateVersion = baseVersion;
            PlatformType = platformType;
            BetaGroup = Guid.Empty;
        }

        public TitleVersionInstanceV1(uint titleId, int baseVersion, int updateVersion, PlatformType platformType, Guid betaGroup)
        {
            TitleId = titleId;
            BaseVersion = baseVersion;
            UpdateVersion = updateVersion;
            PlatformType = platformType;
            BetaGroup = betaGroup;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\TitleManagement\Contracts\obj\i386\MixTitleManagementProxy.cs ===
ï»¿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.4971
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

[assembly: System.Runtime.Serialization.ContractNamespaceAttribute("http://xonline.mix.titlemanagement.contracts/V1", ClrNamespace="xonline.mix.titlemanagement.contracts.V1")]
[assembly: System.Runtime.Serialization.ContractNamespaceAttribute("http://xonline.mix.titlemanagement.contracts/V2", ClrNamespace="xonline.mix.titlemanagement.contracts.V2")]
[assembly: System.Runtime.Serialization.ContractNamespaceAttribute("http://xonline.mix.titlemanagement.contracts/V3", ClrNamespace="xonline.mix.titlemanagement.contracts.V3")]

namespace xonline.mix.titlemanagement.contracts.V1
{
    using System.Runtime.Serialization;
    
    
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="PlatformType", Namespace="http://xonline.mix.titlemanagement.contracts/V1")]
    public enum PlatformType : int
    {
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        Xbox1 = 0,
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        XboxCom = 1,
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        Xenon = 2,
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        Marketplace = 3,
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        PC = 4,
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        Mobile = 5,
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        WebGames = 6,
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="TitleVersions", Namespace="http://xonline.mix.titlemanagement.contracts/V1")]
    public partial class TitleVersions : object, System.Runtime.Serialization.IExtensibleDataObject
    {
        
        private System.Runtime.Serialization.ExtensionDataObject extensionDataField;
        
        private xonline.mix.titlemanagement.contracts.V1.TitleVersionInstance[] VersionsField;
        
        public System.Runtime.Serialization.ExtensionDataObject ExtensionData
        {
            get
            {
                return this.extensionDataField;
            }
            set
            {
                this.extensionDataField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute(IsRequired=true)]
        public xonline.mix.titlemanagement.contracts.V1.TitleVersionInstance[] Versions
        {
            get
            {
                return this.VersionsField;
            }
            set
            {
                this.VersionsField = value;
            }
        }
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="TitleVersionInstance", Namespace="http://xonline.mix.titlemanagement.contracts/V1")]
    public partial class TitleVersionInstance : object, System.Runtime.Serialization.IExtensibleDataObject
    {
        
        private System.Runtime.Serialization.ExtensionDataObject extensionDataField;
        
        private int BaseVersionField;
        
        private System.Guid BetaGroupField;
        
        private xonline.mix.titlemanagement.contracts.V1.PlatformType PlatformTypeField;
        
        private uint TitleIdField;
        
        private int UpdateVersionField;
        
        public System.Runtime.Serialization.ExtensionDataObject ExtensionData
        {
            get
            {
                return this.extensionDataField;
            }
            set
            {
                this.extensionDataField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute(IsRequired=true)]
        public int BaseVersion
        {
            get
            {
                return this.BaseVersionField;
            }
            set
            {
                this.BaseVersionField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute(IsRequired=true)]
        public System.Guid BetaGroup
        {
            get
            {
                return this.BetaGroupField;
            }
            set
            {
                this.BetaGroupField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute(IsRequired=true)]
        public xonline.mix.titlemanagement.contracts.V1.PlatformType PlatformType
        {
            get
            {
                return this.PlatformTypeField;
            }
            set
            {
                this.PlatformTypeField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute(IsRequired=true)]
        public uint TitleId
        {
            get
            {
                return this.TitleIdField;
            }
            set
            {
                this.TitleIdField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute(IsRequired=true)]
        public int UpdateVersion
        {
            get
            {
                return this.UpdateVersionField;
            }
            set
            {
                this.UpdateVersionField = value;
            }
        }
    }
}


[System.CodeDom.Compiler.GeneratedCodeAttribute("System.ServiceModel", "3.0.0.0")]
[System.ServiceModel.ServiceContractAttribute(Namespace="http://xonline.mix.titlemanagement.contracts/V1", ConfigurationName="MixTitleManagement")]
public interface MixTitleManagement
{
    
    [System.ServiceModel.OperationContractAttribute(Action="http://xonline.mix.titlemanagement.contracts/V1/MixTitleManagement/ConfigureTitle" +
        "", ReplyAction="http://xonline.mix.titlemanagement.contracts/V1/MixTitleManagement/ConfigureTitle" +
        "Response")]
    [System.ServiceModel.FaultContractAttribute(typeof(xonline.mix.common.MixClientFault), Action="http://xonline.mix.titlemanagement.contracts/V1/MixTitleManagement/ConfigureTitle" +
        "MixClientFaultFault", Name="MixClientFault", Namespace="http://xonline.mix.common.contracts")]
    [System.ServiceModel.FaultContractAttribute(typeof(Microsoft.Practices.EnterpriseLibrary.Validation.Integration.WCF.ValidationFault), Action="http://xonline.mix.titlemanagement.contracts/V1/MixTitleManagement/ConfigureTitle" +
        "ValidationFault", Name="ValidationFault", Namespace="http://xonline.mix.common.contracts")]
    void ConfigureTitle(byte[] compressedXlast, bool noReload);
    
    [System.ServiceModel.OperationContractAttribute(Action="http://xonline.mix.titlemanagement.contracts/V1/MixTitleManagement/AddBaseVersion" +
        "", ReplyAction="http://xonline.mix.titlemanagement.contracts/V1/MixTitleManagement/AddBaseVersion" +
        "Response")]
    [System.ServiceModel.FaultContractAttribute(typeof(Microsoft.Practices.EnterpriseLibrary.Validation.Integration.WCF.ValidationFault), Action="http://xonline.mix.titlemanagement.contracts/V1/MixTitleManagement/AddBaseVersion" +
        "ValidationFault", Name="ValidationFault", Namespace="http://xonline.mix.common.contracts")]
    [System.ServiceModel.FaultContractAttribute(typeof(xonline.mix.common.MixClientFault), Action="http://xonline.mix.titlemanagement.contracts/V1/MixTitleManagement/AddBaseVersion" +
        "MixClientFaultFault", Name="MixClientFault", Namespace="http://xonline.mix.common.contracts")]
    void AddBaseVersion(uint titleId, int version, xonline.mix.titlemanagement.contracts.V1.PlatformType platformType, System.Guid betaGroup);
    
    [System.ServiceModel.OperationContractAttribute(Action="http://xonline.mix.titlemanagement.contracts/V1/MixTitleManagement/RemoveBaseVers" +
        "ion", ReplyAction="http://xonline.mix.titlemanagement.contracts/V1/MixTitleManagement/RemoveBaseVers" +
        "ionResponse")]
    [System.ServiceModel.FaultContractAttribute(typeof(xonline.mix.common.MixClientFault), Action="http://xonline.mix.titlemanagement.contracts/V1/MixTitleManagement/RemoveBaseVers" +
        "ionMixClientFaultFault", Name="MixClientFault", Namespace="http://xonline.mix.common.contracts")]
    [System.ServiceModel.FaultContractAttribute(typeof(Microsoft.Practices.EnterpriseLibrary.Validation.Integration.WCF.ValidationFault), Action="http://xonline.mix.titlemanagement.contracts/V1/MixTitleManagement/RemoveBaseVers" +
        "ionValidationFault", Name="ValidationFault", Namespace="http://xonline.mix.common.contracts")]
    void RemoveBaseVersion(uint titleId, int version, xonline.mix.titlemanagement.contracts.V1.PlatformType platformType, System.Guid betaGroup);
    
    [System.ServiceModel.OperationContractAttribute(Action="http://xonline.mix.titlemanagement.contracts/V1/MixTitleManagement/GetTitleVersio" +
        "ns", ReplyAction="http://xonline.mix.titlemanagement.contracts/V1/MixTitleManagement/GetTitleVersio" +
        "nsResponse")]
    [System.ServiceModel.FaultContractAttribute(typeof(Microsoft.Practices.EnterpriseLibrary.Validation.Integration.WCF.ValidationFault), Action="http://xonline.mix.titlemanagement.contracts/V1/MixTitleManagement/GetTitleVersio" +
        "nsValidationFault", Name="ValidationFault", Namespace="http://xonline.mix.common.contracts")]
    [System.ServiceModel.FaultContractAttribute(typeof(xonline.mix.common.MixClientFault), Action="http://xonline.mix.titlemanagement.contracts/V1/MixTitleManagement/GetTitleVersio" +
        "nsMixClientFaultFault", Name="MixClientFault", Namespace="http://xonline.mix.common.contracts")]
    xonline.mix.titlemanagement.contracts.V1.TitleVersions GetTitleVersions(uint titleId);
}

[System.CodeDom.Compiler.GeneratedCodeAttribute("System.ServiceModel", "3.0.0.0")]
public interface MixTitleManagementChannel : MixTitleManagement, System.ServiceModel.IClientChannel
{
}

[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.CodeDom.Compiler.GeneratedCodeAttribute("System.ServiceModel", "3.0.0.0")]
public partial class MixTitleManagementClient : System.ServiceModel.ClientBase<MixTitleManagement>, MixTitleManagement
{
    
    public MixTitleManagementClient()
    {
    }
    
    public MixTitleManagementClient(string endpointConfigurationName) : 
            base(endpointConfigurationName)
    {
    }
    
    public MixTitleManagementClient(string endpointConfigurationName, string remoteAddress) : 
            base(endpointConfigurationName, remoteAddress)
    {
    }
    
    public MixTitleManagementClient(string endpointConfigurationName, System.ServiceModel.EndpointAddress remoteAddress) : 
            base(endpointConfigurationName, remoteAddress)
    {
    }
    
    public MixTitleManagementClient(System.ServiceModel.Channels.Binding binding, System.ServiceModel.EndpointAddress remoteAddress) : 
            base(binding, remoteAddress)
    {
    }
    
    public void ConfigureTitle(byte[] compressedXlast, bool noReload)
    {
        base.Channel.ConfigureTitle(compressedXlast, noReload);
    }
    
    public void AddBaseVersion(uint titleId, int version, xonline.mix.titlemanagement.contracts.V1.PlatformType platformType, System.Guid betaGroup)
    {
        base.Channel.AddBaseVersion(titleId, version, platformType, betaGroup);
    }
    
    public void RemoveBaseVersion(uint titleId, int version, xonline.mix.titlemanagement.contracts.V1.PlatformType platformType, System.Guid betaGroup)
    {
        base.Channel.RemoveBaseVersion(titleId, version, platformType, betaGroup);
    }
    
    public xonline.mix.titlemanagement.contracts.V1.TitleVersions GetTitleVersions(uint titleId)
    {
        return base.Channel.GetTitleVersions(titleId);
    }
}

[System.CodeDom.Compiler.GeneratedCodeAttribute("System.ServiceModel", "3.0.0.0")]
[System.ServiceModel.ServiceContractAttribute(Namespace="http://xonline.mix.titlemanagement.contracts/V2", ConfigurationName="MixTitleManagementV2")]
public interface MixTitleManagementV2
{
    
    [System.ServiceModel.OperationContractAttribute(Action="http://xonline.mix.titlemanagement.contracts/V2/MixTitleManagementV2/ConfigureTit" +
        "le", ReplyAction="http://xonline.mix.titlemanagement.contracts/V2/MixTitleManagementV2/ConfigureTit" +
        "leResponse")]
    [System.ServiceModel.FaultContractAttribute(typeof(Microsoft.Practices.EnterpriseLibrary.Validation.Integration.WCF.ValidationFault), Action="http://xonline.mix.titlemanagement.contracts/V2/MixTitleManagementV2/ConfigureTit" +
        "leValidationFault", Name="ValidationFault", Namespace="http://xonline.mix.common.contracts")]
    [System.ServiceModel.FaultContractAttribute(typeof(xonline.mix.common.MixClientFault), Action="http://xonline.mix.titlemanagement.contracts/V2/MixTitleManagementV2/ConfigureTit" +
        "leMixClientFaultFault", Name="MixClientFault", Namespace="http://xonline.mix.common.contracts")]
    void ConfigureTitle(byte[] compressedXlast, bool noReload);
    
    [System.ServiceModel.OperationContractAttribute(Action="http://xonline.mix.titlemanagement.contracts/V2/MixTitleManagementV2/AddBaseVersi" +
        "on", ReplyAction="http://xonline.mix.titlemanagement.contracts/V2/MixTitleManagementV2/AddBaseVersi" +
        "onResponse")]
    [System.ServiceModel.FaultContractAttribute(typeof(Microsoft.Practices.EnterpriseLibrary.Validation.Integration.WCF.ValidationFault), Action="http://xonline.mix.titlemanagement.contracts/V2/MixTitleManagementV2/AddBaseVersi" +
        "onValidationFault", Name="ValidationFault", Namespace="http://xonline.mix.common.contracts")]
    [System.ServiceModel.FaultContractAttribute(typeof(xonline.mix.common.MixClientFault), Action="http://xonline.mix.titlemanagement.contracts/V2/MixTitleManagementV2/AddBaseVersi" +
        "onMixClientFaultFault", Name="MixClientFault", Namespace="http://xonline.mix.common.contracts")]
    void AddBaseVersion(uint titleId, int version, xonline.mix.titlemanagement.contracts.V2.PlatformType platformType, System.Guid betaGroup);
    
    [System.ServiceModel.OperationContractAttribute(Action="http://xonline.mix.titlemanagement.contracts/V2/MixTitleManagementV2/RemoveBaseVe" +
        "rsion", ReplyAction="http://xonline.mix.titlemanagement.contracts/V2/MixTitleManagementV2/RemoveBaseVe" +
        "rsionResponse")]
    [System.ServiceModel.FaultContractAttribute(typeof(xonline.mix.common.MixClientFault), Action="http://xonline.mix.titlemanagement.contracts/V2/MixTitleManagementV2/RemoveBaseVe" +
        "rsionMixClientFaultFault", Name="MixClientFault", Namespace="http://xonline.mix.common.contracts")]
    [System.ServiceModel.FaultContractAttribute(typeof(Microsoft.Practices.EnterpriseLibrary.Validation.Integration.WCF.ValidationFault), Action="http://xonline.mix.titlemanagement.contracts/V2/MixTitleManagementV2/RemoveBaseVe" +
        "rsionValidationFault", Name="ValidationFault", Namespace="http://xonline.mix.common.contracts")]
    void RemoveBaseVersion(uint titleId, int version, xonline.mix.titlemanagement.contracts.V2.PlatformType platformType, System.Guid betaGroup);
    
    [System.ServiceModel.OperationContractAttribute(Action="http://xonline.mix.titlemanagement.contracts/V2/MixTitleManagementV2/GetTitleVers" +
        "ions", ReplyAction="http://xonline.mix.titlemanagement.contracts/V2/MixTitleManagementV2/GetTitleVers" +
        "ionsResponse")]
    [System.ServiceModel.FaultContractAttribute(typeof(xonline.mix.common.MixClientFault), Action="http://xonline.mix.titlemanagement.contracts/V2/MixTitleManagementV2/GetTitleVers" +
        "ionsMixClientFaultFault", Name="MixClientFault", Namespace="http://xonline.mix.common.contracts")]
    [System.ServiceModel.FaultContractAttribute(typeof(Microsoft.Practices.EnterpriseLibrary.Validation.Integration.WCF.ValidationFault), Action="http://xonline.mix.titlemanagement.contracts/V2/MixTitleManagementV2/GetTitleVers" +
        "ionsValidationFault", Name="ValidationFault", Namespace="http://xonline.mix.common.contracts")]
    xonline.mix.titlemanagement.contracts.V2.TitleVersions GetTitleVersions(uint titleId);
    
    [System.ServiceModel.OperationContractAttribute(Action="http://xonline.mix.titlemanagement.contracts/V2/MixTitleManagementV2/SetTitleUpda" +
        "tePackages", ReplyAction="http://xonline.mix.titlemanagement.contracts/V2/MixTitleManagementV2/SetTitleUpda" +
        "tePackagesResponse")]
    [System.ServiceModel.FaultContractAttribute(typeof(Microsoft.Practices.EnterpriseLibrary.Validation.Integration.WCF.ValidationFault), Action="http://xonline.mix.titlemanagement.contracts/V2/MixTitleManagementV2/SetTitleUpda" +
        "tePackagesValidationFault", Name="ValidationFault", Namespace="http://xonline.mix.common.contracts")]
    [System.ServiceModel.FaultContractAttribute(typeof(xonline.mix.common.MixClientFault), Action="http://xonline.mix.titlemanagement.contracts/V2/MixTitleManagementV2/SetTitleUpda" +
        "tePackagesMixClientFaultFault", Name="MixClientFault", Namespace="http://xonline.mix.common.contracts")]
    void SetTitleUpdatePackages(uint titleId, int baseVersion, int updateVersion, xonline.mix.titlemanagement.contracts.V2.PlatformType consoleType, xonline.mix.titlemanagement.contracts.V2.TitleUpdatePackageInformation packageInformation, xonline.mix.titlemanagement.contracts.V2.TitleUpdatePackageLocation[] updateLocations);
    
    [System.ServiceModel.OperationContractAttribute(Action="http://xonline.mix.titlemanagement.contracts/V2/MixTitleManagementV2/SetTitleFace" +
        "bookAppId", ReplyAction="http://xonline.mix.titlemanagement.contracts/V2/MixTitleManagementV2/SetTitleFace" +
        "bookAppIdResponse")]
    [System.ServiceModel.FaultContractAttribute(typeof(Microsoft.Practices.EnterpriseLibrary.Validation.Integration.WCF.ValidationFault), Action="http://xonline.mix.titlemanagement.contracts/V2/MixTitleManagementV2/SetTitleFace" +
        "bookAppIdValidationFault", Name="ValidationFault", Namespace="http://xonline.mix.common.contracts")]
    [System.ServiceModel.FaultContractAttribute(typeof(xonline.mix.common.MixClientFault), Action="http://xonline.mix.titlemanagement.contracts/V2/MixTitleManagementV2/SetTitleFace" +
        "bookAppIdMixClientFaultFault", Name="MixClientFault", Namespace="http://xonline.mix.common.contracts")]
    void SetTitleFacebookAppId(uint titleId, string appId);
}

[System.CodeDom.Compiler.GeneratedCodeAttribute("System.ServiceModel", "3.0.0.0")]
public interface MixTitleManagementV2Channel : MixTitleManagementV2, System.ServiceModel.IClientChannel
{
}

[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.CodeDom.Compiler.GeneratedCodeAttribute("System.ServiceModel", "3.0.0.0")]
public partial class MixTitleManagementV2Client : System.ServiceModel.ClientBase<MixTitleManagementV2>, MixTitleManagementV2
{
    
    public MixTitleManagementV2Client()
    {
    }
    
    public MixTitleManagementV2Client(string endpointConfigurationName) : 
            base(endpointConfigurationName)
    {
    }
    
    public MixTitleManagementV2Client(string endpointConfigurationName, string remoteAddress) : 
            base(endpointConfigurationName, remoteAddress)
    {
    }
    
    public MixTitleManagementV2Client(string endpointConfigurationName, System.ServiceModel.EndpointAddress remoteAddress) : 
            base(endpointConfigurationName, remoteAddress)
    {
    }
    
    public MixTitleManagementV2Client(System.ServiceModel.Channels.Binding binding, System.ServiceModel.EndpointAddress remoteAddress) : 
            base(binding, remoteAddress)
    {
    }
    
    public void ConfigureTitle(byte[] compressedXlast, bool noReload)
    {
        base.Channel.ConfigureTitle(compressedXlast, noReload);
    }
    
    public void AddBaseVersion(uint titleId, int version, xonline.mix.titlemanagement.contracts.V2.PlatformType platformType, System.Guid betaGroup)
    {
        base.Channel.AddBaseVersion(titleId, version, platformType, betaGroup);
    }
    
    public void RemoveBaseVersion(uint titleId, int version, xonline.mix.titlemanagement.contracts.V2.PlatformType platformType, System.Guid betaGroup)
    {
        base.Channel.RemoveBaseVersion(titleId, version, platformType, betaGroup);
    }
    
    public xonline.mix.titlemanagement.contracts.V2.TitleVersions GetTitleVersions(uint titleId)
    {
        return base.Channel.GetTitleVersions(titleId);
    }
    
    public void SetTitleUpdatePackages(uint titleId, int baseVersion, int updateVersion, xonline.mix.titlemanagement.contracts.V2.PlatformType consoleType, xonline.mix.titlemanagement.contracts.V2.TitleUpdatePackageInformation packageInformation, xonline.mix.titlemanagement.contracts.V2.TitleUpdatePackageLocation[] updateLocations)
    {
        base.Channel.SetTitleUpdatePackages(titleId, baseVersion, updateVersion, consoleType, packageInformation, updateLocations);
    }
    
    public void SetTitleFacebookAppId(uint titleId, string appId)
    {
        base.Channel.SetTitleFacebookAppId(titleId, appId);
    }
}

[System.CodeDom.Compiler.GeneratedCodeAttribute("System.ServiceModel", "3.0.0.0")]
[System.ServiceModel.ServiceContractAttribute(Namespace="http://xonline.mix.titlemanagement.contracts/V3", ConfigurationName="MixTitleManagementV3")]
public interface MixTitleManagementV3
{
    
    [System.ServiceModel.OperationContractAttribute(Action="http://xonline.mix.titlemanagement.contracts/V3/MixTitleManagementV3/ConfigureTit" +
        "le", ReplyAction="http://xonline.mix.titlemanagement.contracts/V3/MixTitleManagementV3/ConfigureTit" +
        "leResponse")]
    [System.ServiceModel.FaultContractAttribute(typeof(xonline.mix.common.MixClientFault), Action="http://xonline.mix.titlemanagement.contracts/V3/MixTitleManagementV3/ConfigureTit" +
        "leMixClientFaultFault", Name="MixClientFault", Namespace="http://xonline.mix.common.contracts")]
    [System.ServiceModel.FaultContractAttribute(typeof(Microsoft.Practices.EnterpriseLibrary.Validation.Integration.WCF.ValidationFault), Action="http://xonline.mix.titlemanagement.contracts/V3/MixTitleManagementV3/ConfigureTit" +
        "leValidationFault", Name="ValidationFault", Namespace="http://xonline.mix.common.contracts")]
    void ConfigureTitle(byte[] compressedXlast, bool noReload);
    
    [System.ServiceModel.OperationContractAttribute(Action="http://xonline.mix.titlemanagement.contracts/V3/MixTitleManagementV3/AddBaseVersi" +
        "on", ReplyAction="http://xonline.mix.titlemanagement.contracts/V3/MixTitleManagementV3/AddBaseVersi" +
        "onResponse")]
    [System.ServiceModel.FaultContractAttribute(typeof(xonline.mix.common.MixClientFault), Action="http://xonline.mix.titlemanagement.contracts/V3/MixTitleManagementV3/AddBaseVersi" +
        "onMixClientFaultFault", Name="MixClientFault", Namespace="http://xonline.mix.common.contracts")]
    [System.ServiceModel.FaultContractAttribute(typeof(Microsoft.Practices.EnterpriseLibrary.Validation.Integration.WCF.ValidationFault), Action="http://xonline.mix.titlemanagement.contracts/V3/MixTitleManagementV3/AddBaseVersi" +
        "onValidationFault", Name="ValidationFault", Namespace="http://xonline.mix.common.contracts")]
    void AddBaseVersion(uint titleId, int version, xonline.mix.titlemanagement.contracts.V3.PlatformType platformType, System.Guid betaGroup);
    
    [System.ServiceModel.OperationContractAttribute(Action="http://xonline.mix.titlemanagement.contracts/V3/MixTitleManagementV3/RemoveBaseVe" +
        "rsion", ReplyAction="http://xonline.mix.titlemanagement.contracts/V3/MixTitleManagementV3/RemoveBaseVe" +
        "rsionResponse")]
    [System.ServiceModel.FaultContractAttribute(typeof(xonline.mix.common.MixClientFault), Action="http://xonline.mix.titlemanagement.contracts/V3/MixTitleManagementV3/RemoveBaseVe" +
        "rsionMixClientFaultFault", Name="MixClientFault", Namespace="http://xonline.mix.common.contracts")]
    [System.ServiceModel.FaultContractAttribute(typeof(Microsoft.Practices.EnterpriseLibrary.Validation.Integration.WCF.ValidationFault), Action="http://xonline.mix.titlemanagement.contracts/V3/MixTitleManagementV3/RemoveBaseVe" +
        "rsionValidationFault", Name="ValidationFault", Namespace="http://xonline.mix.common.contracts")]
    void RemoveBaseVersion(uint titleId, int version, xonline.mix.titlemanagement.contracts.V3.PlatformType platformType, System.Guid betaGroup);
    
    [System.ServiceModel.OperationContractAttribute(Action="http://xonline.mix.titlemanagement.contracts/V3/MixTitleManagementV3/GetTitleVers" +
        "ions", ReplyAction="http://xonline.mix.titlemanagement.contracts/V3/MixTitleManagementV3/GetTitleVers" +
        "ionsResponse")]
    [System.ServiceModel.FaultContractAttribute(typeof(xonline.mix.common.MixClientFault), Action="http://xonline.mix.titlemanagement.contracts/V3/MixTitleManagementV3/GetTitleVers" +
        "ionsMixClientFaultFault", Name="MixClientFault", Namespace="http://xonline.mix.common.contracts")]
    [System.ServiceModel.FaultContractAttribute(typeof(Microsoft.Practices.EnterpriseLibrary.Validation.Integration.WCF.ValidationFault), Action="http://xonline.mix.titlemanagement.contracts/V3/MixTitleManagementV3/GetTitleVers" +
        "ionsValidationFault", Name="ValidationFault", Namespace="http://xonline.mix.common.contracts")]
    xonline.mix.titlemanagement.contracts.V3.TitleVersions GetTitleVersions(uint titleId);
    
    [System.ServiceModel.OperationContractAttribute(Action="http://xonline.mix.titlemanagement.contracts/V3/MixTitleManagementV3/SetTitleUpda" +
        "tePackages", ReplyAction="http://xonline.mix.titlemanagement.contracts/V3/MixTitleManagementV3/SetTitleUpda" +
        "tePackagesResponse")]
    [System.ServiceModel.FaultContractAttribute(typeof(Microsoft.Practices.EnterpriseLibrary.Validation.Integration.WCF.ValidationFault), Action="http://xonline.mix.titlemanagement.contracts/V3/MixTitleManagementV3/SetTitleUpda" +
        "tePackagesValidationFault", Name="ValidationFault", Namespace="http://xonline.mix.common.contracts")]
    [System.ServiceModel.FaultContractAttribute(typeof(xonline.mix.common.MixClientFault), Action="http://xonline.mix.titlemanagement.contracts/V3/MixTitleManagementV3/SetTitleUpda" +
        "tePackagesMixClientFaultFault", Name="MixClientFault", Namespace="http://xonline.mix.common.contracts")]
    void SetTitleUpdatePackages(uint titleId, int baseVersion, int updateVersion, xonline.mix.titlemanagement.contracts.V3.PlatformType consoleType, xonline.mix.titlemanagement.contracts.V3.TitleUpdatePackageInformation packageInformation, xonline.mix.titlemanagement.contracts.V3.TitleUpdatePackageLocation[] updateLocations);
    
    [System.ServiceModel.OperationContractAttribute(Action="http://xonline.mix.titlemanagement.contracts/V3/MixTitleManagementV3/GetBusinessP" +
        "artnerTitleIDs", ReplyAction="http://xonline.mix.titlemanagement.contracts/V3/MixTitleManagementV3/GetBusinessP" +
        "artnerTitleIDsResponse")]
    [System.ServiceModel.FaultContractAttribute(typeof(Microsoft.Practices.EnterpriseLibrary.Validation.Integration.WCF.ValidationFault), Action="http://xonline.mix.titlemanagement.contracts/V3/MixTitleManagementV3/GetBusinessP" +
        "artnerTitleIDsValidationFault", Name="ValidationFault", Namespace="http://xonline.mix.common.contracts")]
    [System.ServiceModel.FaultContractAttribute(typeof(xonline.mix.common.MixClientFault), Action="http://xonline.mix.titlemanagement.contracts/V3/MixTitleManagementV3/GetBusinessP" +
        "artnerTitleIDsMixClientFaultFault", Name="MixClientFault", Namespace="http://xonline.mix.common.contracts")]
    uint[] GetBusinessPartnerTitleIDs(System.Guid businessPartnerID);
    
    [System.ServiceModel.OperationContractAttribute(Action="http://xonline.mix.titlemanagement.contracts/V3/MixTitleManagementV3/SetBusinessP" +
        "artnerTitleIDs", ReplyAction="http://xonline.mix.titlemanagement.contracts/V3/MixTitleManagementV3/SetBusinessP" +
        "artnerTitleIDsResponse")]
    [System.ServiceModel.FaultContractAttribute(typeof(Microsoft.Practices.EnterpriseLibrary.Validation.Integration.WCF.ValidationFault), Action="http://xonline.mix.titlemanagement.contracts/V3/MixTitleManagementV3/SetBusinessP" +
        "artnerTitleIDsValidationFault", Name="ValidationFault", Namespace="http://xonline.mix.common.contracts")]
    [System.ServiceModel.FaultContractAttribute(typeof(xonline.mix.common.MixClientFault), Action="http://xonline.mix.titlemanagement.contracts/V3/MixTitleManagementV3/SetBusinessP" +
        "artnerTitleIDsMixClientFaultFault", Name="MixClientFault", Namespace="http://xonline.mix.common.contracts")]
    void SetBusinessPartnerTitleIDs(System.Guid businessPartnerID, uint[] titleIDs);
    
    [System.ServiceModel.OperationContractAttribute(Action="http://xonline.mix.titlemanagement.contracts/V3/MixTitleManagementV3/SetNetworkSe" +
        "curityList", ReplyAction="http://xonline.mix.titlemanagement.contracts/V3/MixTitleManagementV3/SetNetworkSe" +
        "curityListResponse")]
    [System.ServiceModel.FaultContractAttribute(typeof(xonline.mix.common.MixClientFault), Action="http://xonline.mix.titlemanagement.contracts/V3/MixTitleManagementV3/SetNetworkSe" +
        "curityListMixClientFaultFault", Name="MixClientFault", Namespace="http://xonline.mix.common.contracts")]
    [System.ServiceModel.FaultContractAttribute(typeof(Microsoft.Practices.EnterpriseLibrary.Validation.Integration.WCF.ValidationFault), Action="http://xonline.mix.titlemanagement.contracts/V3/MixTitleManagementV3/SetNetworkSe" +
        "curityListValidationFault", Name="ValidationFault", Namespace="http://xonline.mix.common.contracts")]
    void SetNetworkSecurityList(uint titleID, xonline.mix.titlemanagement.contracts.V3.TitleEndpoint[] allowedEndpoints);
    
    [System.ServiceModel.OperationContractAttribute(Action="http://xonline.mix.titlemanagement.contracts/V3/MixTitleManagementV3/GetNetworkSe" +
        "curityList", ReplyAction="http://xonline.mix.titlemanagement.contracts/V3/MixTitleManagementV3/GetNetworkSe" +
        "curityListResponse")]
    [System.ServiceModel.FaultContractAttribute(typeof(xonline.mix.common.MixClientFault), Action="http://xonline.mix.titlemanagement.contracts/V3/MixTitleManagementV3/GetNetworkSe" +
        "curityListMixClientFaultFault", Name="MixClientFault", Namespace="http://xonline.mix.common.contracts")]
    [System.ServiceModel.FaultContractAttribute(typeof(Microsoft.Practices.EnterpriseLibrary.Validation.Integration.WCF.ValidationFault), Action="http://xonline.mix.titlemanagement.contracts/V3/MixTitleManagementV3/GetNetworkSe" +
        "curityListValidationFault", Name="ValidationFault", Namespace="http://xonline.mix.common.contracts")]
    xonline.mix.titlemanagement.contracts.V3.TitleEndpointInfo[] GetNetworkSecurityList(uint titleID, bool bFullHistory);
    
    [System.ServiceModel.OperationContractAttribute(Action="http://xonline.mix.titlemanagement.contracts/V3/MixTitleManagementV3/GetNetworkSe" +
        "curityListByAppliesTo", ReplyAction="http://xonline.mix.titlemanagement.contracts/V3/MixTitleManagementV3/GetNetworkSe" +
        "curityListByAppliesToResponse")]
    [System.ServiceModel.FaultContractAttribute(typeof(xonline.mix.common.MixClientFault), Action="http://xonline.mix.titlemanagement.contracts/V3/MixTitleManagementV3/GetNetworkSe" +
        "curityListByAppliesToMixClientFaultFault", Name="MixClientFault", Namespace="http://xonline.mix.common.contracts")]
    [System.ServiceModel.FaultContractAttribute(typeof(Microsoft.Practices.EnterpriseLibrary.Validation.Integration.WCF.ValidationFault), Action="http://xonline.mix.titlemanagement.contracts/V3/MixTitleManagementV3/GetNetworkSe" +
        "curityListByAppliesToValidationFault", Name="ValidationFault", Namespace="http://xonline.mix.common.contracts")]
    xonline.mix.titlemanagement.contracts.V3.TitleEndpointInfo[] GetNetworkSecurityListByAppliesTo(string appliesTo, bool bFullHistory);
}

[System.CodeDom.Compiler.GeneratedCodeAttribute("System.ServiceModel", "3.0.0.0")]
public interface MixTitleManagementV3Channel : MixTitleManagementV3, System.ServiceModel.IClientChannel
{
}

[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.CodeDom.Compiler.GeneratedCodeAttribute("System.ServiceModel", "3.0.0.0")]
public partial class MixTitleManagementV3Client : System.ServiceModel.ClientBase<MixTitleManagementV3>, MixTitleManagementV3
{
    
    public MixTitleManagementV3Client()
    {
    }
    
    public MixTitleManagementV3Client(string endpointConfigurationName) : 
            base(endpointConfigurationName)
    {
    }
    
    public MixTitleManagementV3Client(string endpointConfigurationName, string remoteAddress) : 
            base(endpointConfigurationName, remoteAddress)
    {
    }
    
    public MixTitleManagementV3Client(string endpointConfigurationName, System.ServiceModel.EndpointAddress remoteAddress) : 
            base(endpointConfigurationName, remoteAddress)
    {
    }
    
    public MixTitleManagementV3Client(System.ServiceModel.Channels.Binding binding, System.ServiceModel.EndpointAddress remoteAddress) : 
            base(binding, remoteAddress)
    {
    }
    
    public void ConfigureTitle(byte[] compressedXlast, bool noReload)
    {
        base.Channel.ConfigureTitle(compressedXlast, noReload);
    }
    
    public void AddBaseVersion(uint titleId, int version, xonline.mix.titlemanagement.contracts.V3.PlatformType platformType, System.Guid betaGroup)
    {
        base.Channel.AddBaseVersion(titleId, version, platformType, betaGroup);
    }
    
    public void RemoveBaseVersion(uint titleId, int version, xonline.mix.titlemanagement.contracts.V3.PlatformType platformType, System.Guid betaGroup)
    {
        base.Channel.RemoveBaseVersion(titleId, version, platformType, betaGroup);
    }
    
    public xonline.mix.titlemanagement.contracts.V3.TitleVersions GetTitleVersions(uint titleId)
    {
        return base.Channel.GetTitleVersions(titleId);
    }
    
    public void SetTitleUpdatePackages(uint titleId, int baseVersion, int updateVersion, xonline.mix.titlemanagement.contracts.V3.PlatformType consoleType, xonline.mix.titlemanagement.contracts.V3.TitleUpdatePackageInformation packageInformation, xonline.mix.titlemanagement.contracts.V3.TitleUpdatePackageLocation[] updateLocations)
    {
        base.Channel.SetTitleUpdatePackages(titleId, baseVersion, updateVersion, consoleType, packageInformation, updateLocations);
    }
    
    public uint[] GetBusinessPartnerTitleIDs(System.Guid businessPartnerID)
    {
        return base.Channel.GetBusinessPartnerTitleIDs(businessPartnerID);
    }
    
    public void SetBusinessPartnerTitleIDs(System.Guid businessPartnerID, uint[] titleIDs)
    {
        base.Channel.SetBusinessPartnerTitleIDs(businessPartnerID, titleIDs);
    }
    
    public void SetNetworkSecurityList(uint titleID, xonline.mix.titlemanagement.contracts.V3.TitleEndpoint[] allowedEndpoints)
    {
        base.Channel.SetNetworkSecurityList(titleID, allowedEndpoints);
    }
    
    public xonline.mix.titlemanagement.contracts.V3.TitleEndpointInfo[] GetNetworkSecurityList(uint titleID, bool bFullHistory)
    {
        return base.Channel.GetNetworkSecurityList(titleID, bFullHistory);
    }
    
    public xonline.mix.titlemanagement.contracts.V3.TitleEndpointInfo[] GetNetworkSecurityListByAppliesTo(string appliesTo, bool bFullHistory)
    {
        return base.Channel.GetNetworkSecurityListByAppliesTo(appliesTo, bFullHistory);
    }
}
namespace xonline.mix.titlemanagement.contracts.V2
{
    using System.Runtime.Serialization;
    
    
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="PlatformType", Namespace="http://xonline.mix.titlemanagement.contracts/V2")]
    public enum PlatformType : byte
    {
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        Xbox1 = 0,
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        XboxCom = 1,
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        Xenon = 2,
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        Marketplace = 3,
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        PC = 4,
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        Mobile = 5,
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        WebGames = 6,
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="TitleVersions", Namespace="http://xonline.mix.titlemanagement.contracts/V2")]
    public partial class TitleVersions : object, System.Runtime.Serialization.IExtensibleDataObject
    {
        
        private System.Runtime.Serialization.ExtensionDataObject extensionDataField;
        
        private xonline.mix.titlemanagement.contracts.V2.TitleVersionInstance[] VersionsField;
        
        public System.Runtime.Serialization.ExtensionDataObject ExtensionData
        {
            get
            {
                return this.extensionDataField;
            }
            set
            {
                this.extensionDataField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute(IsRequired=true)]
        public xonline.mix.titlemanagement.contracts.V2.TitleVersionInstance[] Versions
        {
            get
            {
                return this.VersionsField;
            }
            set
            {
                this.VersionsField = value;
            }
        }
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="TitleVersionInstance", Namespace="http://xonline.mix.titlemanagement.contracts/V2")]
    public partial class TitleVersionInstance : object, System.Runtime.Serialization.IExtensibleDataObject
    {
        
        private System.Runtime.Serialization.ExtensionDataObject extensionDataField;
        
        private int BaseVersionField;
        
        private System.Guid BetaGroupField;
        
        private xonline.mix.titlemanagement.contracts.V2.PlatformType PlatformTypeField;
        
        private uint TitleIdField;
        
        private int UpdateVersionField;
        
        public System.Runtime.Serialization.ExtensionDataObject ExtensionData
        {
            get
            {
                return this.extensionDataField;
            }
            set
            {
                this.extensionDataField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute(IsRequired=true)]
        public int BaseVersion
        {
            get
            {
                return this.BaseVersionField;
            }
            set
            {
                this.BaseVersionField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute(IsRequired=true)]
        public System.Guid BetaGroup
        {
            get
            {
                return this.BetaGroupField;
            }
            set
            {
                this.BetaGroupField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute(IsRequired=true)]
        public xonline.mix.titlemanagement.contracts.V2.PlatformType PlatformType
        {
            get
            {
                return this.PlatformTypeField;
            }
            set
            {
                this.PlatformTypeField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute(IsRequired=true)]
        public uint TitleId
        {
            get
            {
                return this.TitleIdField;
            }
            set
            {
                this.TitleIdField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute(IsRequired=true)]
        public int UpdateVersion
        {
            get
            {
                return this.UpdateVersionField;
            }
            set
            {
                this.UpdateVersionField = value;
            }
        }
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="TitleUpdatePackageInformation", Namespace="http://xonline.mix.titlemanagement.contracts/V2")]
    public partial class TitleUpdatePackageInformation : object, System.Runtime.Serialization.IExtensibleDataObject
    {
        
        private System.Runtime.Serialization.ExtensionDataObject extensionDataField;
        
        private byte[] ContentIdField;
        
        private int InstallSizeField;
        
        private int PackageSizeField;
        
        private byte[] PublicKeyField;
        
        private byte[] UpdateSymmetricKeyField;
        
        public System.Runtime.Serialization.ExtensionDataObject ExtensionData
        {
            get
            {
                return this.extensionDataField;
            }
            set
            {
                this.extensionDataField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute(IsRequired=true)]
        public byte[] ContentId
        {
            get
            {
                return this.ContentIdField;
            }
            set
            {
                this.ContentIdField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute(IsRequired=true)]
        public int InstallSize
        {
            get
            {
                return this.InstallSizeField;
            }
            set
            {
                this.InstallSizeField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute(IsRequired=true)]
        public int PackageSize
        {
            get
            {
                return this.PackageSizeField;
            }
            set
            {
                this.PackageSizeField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute(IsRequired=true)]
        public byte[] PublicKey
        {
            get
            {
                return this.PublicKeyField;
            }
            set
            {
                this.PublicKeyField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute(IsRequired=true)]
        public byte[] UpdateSymmetricKey
        {
            get
            {
                return this.UpdateSymmetricKeyField;
            }
            set
            {
                this.UpdateSymmetricKeyField = value;
            }
        }
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="TitleUpdatePackageLocation", Namespace="http://xonline.mix.titlemanagement.contracts/V2")]
    public partial class TitleUpdatePackageLocation : object, System.Runtime.Serialization.IExtensibleDataObject
    {
        
        private System.Runtime.Serialization.ExtensionDataObject extensionDataField;
        
        private int RankField;
        
        private string XrlField;
        
        public System.Runtime.Serialization.ExtensionDataObject ExtensionData
        {
            get
            {
                return this.extensionDataField;
            }
            set
            {
                this.extensionDataField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute(IsRequired=true)]
        public int Rank
        {
            get
            {
                return this.RankField;
            }
            set
            {
                this.RankField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute(IsRequired=true)]
        public string Xrl
        {
            get
            {
                return this.XrlField;
            }
            set
            {
                this.XrlField = value;
            }
        }
    }
}
namespace xonline.mix.titlemanagement.contracts.V3
{
    using System.Runtime.Serialization;
    
    
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="PlatformType", Namespace="http://xonline.mix.titlemanagement.contracts/V3")]
    public enum PlatformType : byte
    {
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        Xbox1 = 0,
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        XboxCom = 1,
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        Xenon = 2,
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        Marketplace = 3,
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        PC = 4,
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        Mobile = 5,
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        WebGames = 6,
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="TitleVersions", Namespace="http://xonline.mix.titlemanagement.contracts/V3")]
    public partial class TitleVersions : object, System.Runtime.Serialization.IExtensibleDataObject
    {
        
        private System.Runtime.Serialization.ExtensionDataObject extensionDataField;
        
        private xonline.mix.titlemanagement.contracts.V3.TitleVersionInstance[] VersionsField;
        
        public System.Runtime.Serialization.ExtensionDataObject ExtensionData
        {
            get
            {
                return this.extensionDataField;
            }
            set
            {
                this.extensionDataField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute(IsRequired=true)]
        public xonline.mix.titlemanagement.contracts.V3.TitleVersionInstance[] Versions
        {
            get
            {
                return this.VersionsField;
            }
            set
            {
                this.VersionsField = value;
            }
        }
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="TitleVersionInstance", Namespace="http://xonline.mix.titlemanagement.contracts/V3")]
    public partial class TitleVersionInstance : object, System.Runtime.Serialization.IExtensibleDataObject
    {
        
        private System.Runtime.Serialization.ExtensionDataObject extensionDataField;
        
        private int BaseVersionField;
        
        private System.Guid BetaGroupField;
        
        private xonline.mix.titlemanagement.contracts.V3.PlatformType PlatformTypeField;
        
        private uint TitleIdField;
        
        private int UpdateVersionField;
        
        public System.Runtime.Serialization.ExtensionDataObject ExtensionData
        {
            get
            {
                return this.extensionDataField;
            }
            set
            {
                this.extensionDataField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute(IsRequired=true)]
        public int BaseVersion
        {
            get
            {
                return this.BaseVersionField;
            }
            set
            {
                this.BaseVersionField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute(IsRequired=true)]
        public System.Guid BetaGroup
        {
            get
            {
                return this.BetaGroupField;
            }
            set
            {
                this.BetaGroupField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute(IsRequired=true)]
        public xonline.mix.titlemanagement.contracts.V3.PlatformType PlatformType
        {
            get
            {
                return this.PlatformTypeField;
            }
            set
            {
                this.PlatformTypeField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute(IsRequired=true)]
        public uint TitleId
        {
            get
            {
                return this.TitleIdField;
            }
            set
            {
                this.TitleIdField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute(IsRequired=true)]
        public int UpdateVersion
        {
            get
            {
                return this.UpdateVersionField;
            }
            set
            {
                this.UpdateVersionField = value;
            }
        }
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="TitleUpdatePackageInformation", Namespace="http://xonline.mix.titlemanagement.contracts/V3")]
    public partial class TitleUpdatePackageInformation : object, System.Runtime.Serialization.IExtensibleDataObject
    {
        
        private System.Runtime.Serialization.ExtensionDataObject extensionDataField;
        
        private byte[] ContentIdField;
        
        private int InstallSizeField;
        
        private int PackageSizeField;
        
        private byte[] PublicKeyField;
        
        private byte[] UpdateSymmetricKeyField;
        
        public System.Runtime.Serialization.ExtensionDataObject ExtensionData
        {
            get
            {
                return this.extensionDataField;
            }
            set
            {
                this.extensionDataField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute(IsRequired=true)]
        public byte[] ContentId
        {
            get
            {
                return this.ContentIdField;
            }
            set
            {
                this.ContentIdField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute(IsRequired=true)]
        public int InstallSize
        {
            get
            {
                return this.InstallSizeField;
            }
            set
            {
                this.InstallSizeField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute(IsRequired=true)]
        public int PackageSize
        {
            get
            {
                return this.PackageSizeField;
            }
            set
            {
                this.PackageSizeField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute(IsRequired=true)]
        public byte[] PublicKey
        {
            get
            {
                return this.PublicKeyField;
            }
            set
            {
                this.PublicKeyField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute(IsRequired=true)]
        public byte[] UpdateSymmetricKey
        {
            get
            {
                return this.UpdateSymmetricKeyField;
            }
            set
            {
                this.UpdateSymmetricKeyField = value;
            }
        }
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="TitleUpdatePackageLocation", Namespace="http://xonline.mix.titlemanagement.contracts/V3")]
    public partial class TitleUpdatePackageLocation : object, System.Runtime.Serialization.IExtensibleDataObject
    {
        
        private System.Runtime.Serialization.ExtensionDataObject extensionDataField;
        
        private int RankField;
        
        private string XrlField;
        
        public System.Runtime.Serialization.ExtensionDataObject ExtensionData
        {
            get
            {
                return this.extensionDataField;
            }
            set
            {
                this.extensionDataField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute(IsRequired=true)]
        public int Rank
        {
            get
            {
                return this.RankField;
            }
            set
            {
                this.RankField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute(IsRequired=true)]
        public string Xrl
        {
            get
            {
                return this.XrlField;
            }
            set
            {
                this.XrlField = value;
            }
        }
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="TitleEndpoint", Namespace="http://xonline.mix.titlemanagement.contracts/V3")]
    public partial class TitleEndpoint : object, System.Runtime.Serialization.IExtensibleDataObject
    {
        
        private System.Runtime.Serialization.ExtensionDataObject extensionDataField;
        
        private string AppliesToUriField;
        
        private uint FromIPField;
        
        private string HostnameField;
        
        private string PathField;
        
        private int PortField;
        
        private string ProtocolField;
        
        private uint ToIPField;
        
        public System.Runtime.Serialization.ExtensionDataObject ExtensionData
        {
            get
            {
                return this.extensionDataField;
            }
            set
            {
                this.extensionDataField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string AppliesToUri
        {
            get
            {
                return this.AppliesToUriField;
            }
            set
            {
                this.AppliesToUriField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public uint FromIP
        {
            get
            {
                return this.FromIPField;
            }
            set
            {
                this.FromIPField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string Hostname
        {
            get
            {
                return this.HostnameField;
            }
            set
            {
                this.HostnameField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string Path
        {
            get
            {
                return this.PathField;
            }
            set
            {
                this.PathField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public int Port
        {
            get
            {
                return this.PortField;
            }
            set
            {
                this.PortField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute(IsRequired=true)]
        public string Protocol
        {
            get
            {
                return this.ProtocolField;
            }
            set
            {
                this.ProtocolField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public uint ToIP
        {
            get
            {
                return this.ToIPField;
            }
            set
            {
                this.ToIPField = value;
            }
        }
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="TitleEndpointInfo", Namespace="http://xonline.mix.titlemanagement.contracts/V3")]
    public partial class TitleEndpointInfo : object, System.Runtime.Serialization.IExtensibleDataObject
    {
        
        private System.Runtime.Serialization.ExtensionDataObject extensionDataField;
        
        private System.DateTime EndField;
        
        private xonline.mix.titlemanagement.contracts.V3.TitleEndpoint EndpointInfoField;
        
        private System.DateTime StartField;
        
        private uint TitleIDField;
        
        public System.Runtime.Serialization.ExtensionDataObject ExtensionData
        {
            get
            {
                return this.extensionDataField;
            }
            set
            {
                this.extensionDataField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute(IsRequired=true)]
        public System.DateTime End
        {
            get
            {
                return this.EndField;
            }
            set
            {
                this.EndField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute(IsRequired=true)]
        public xonline.mix.titlemanagement.contracts.V3.TitleEndpoint EndpointInfo
        {
            get
            {
                return this.EndpointInfoField;
            }
            set
            {
                this.EndpointInfoField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute(IsRequired=true)]
        public System.DateTime Start
        {
            get
            {
                return this.StartField;
            }
            set
            {
                this.StartField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute(IsRequired=true)]
        public uint TitleID
        {
            get
            {
                return this.TitleIDField;
            }
            set
            {
                this.TitleIDField = value;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\TitleManagement\Contracts\ServiceContractV2.cs ===
ï»¿using System;
using System.ServiceModel;
using xonline.mix.common;
using Microsoft.Practices.EnterpriseLibrary.Validation.Integration.WCF;

namespace xonline.mix.titlemanagement.contract.v2
{
    // NOTE: If you change the interface name "IMixOfferManagementV2" here, you must also update the reference to "IMixOfferManagementV2" in Web.config.
    [ServiceContract(Name = "MixTitleManagementV2", Namespace = "http://xonline.mix.titlemanagement.contracts/V2")]
    public interface IMixTitleManagementV2
    {
        [OperationContract(Name = "ConfigureTitle")]
        [FaultContract(typeof(MixClientFault))]
        [FaultContract(typeof(ValidationFault), Name = "ValidationFault", Namespace = "http://xonline.mix.common.contracts")]
        void ConfigureTitle(byte[] compressedXlast, bool noReload);

        [OperationContract(Name = "AddBaseVersion")]
        [FaultContract(typeof(MixClientFault))]
        [FaultContract(typeof(ValidationFault), Name = "ValidationFault", Namespace = "http://xonline.mix.common.contracts")]
        void AddBaseVersion(uint titleId, int version, PlatformTypeV2 platformType, Guid betaGroup);

        [OperationContract(Name = "RemoveBaseVersion")]
        [FaultContract(typeof(MixClientFault))]
        [FaultContract(typeof(ValidationFault), Name = "ValidationFault", Namespace = "http://xonline.mix.common.contracts")]
        void RemoveBaseVersion(uint titleId, int version, PlatformTypeV2 platformType, Guid betaGroup);

        [OperationContract(Name = "GetTitleVersions")]
        [FaultContract(typeof(MixClientFault))]
        [FaultContract(typeof(ValidationFault), Name = "ValidationFault", Namespace = "http://xonline.mix.common.contracts")]
        TitleVersionsV2 GetTitleVersions(uint titleId);

        [OperationContract(Name = "SetTitleUpdatePackages")]
        [FaultContract(typeof(MixClientFault))]
        [FaultContract(typeof(ValidationFault), Name = "ValidationFault", Namespace = "http://xonline.mix.common.contracts")]
        void SetTitleUpdatePackages(uint titleId, int baseVersion, int updateVersion, PlatformTypeV2 consoleType, TitleUpdatePackageInformationV2 packageInformation, TitleUpdatePackageLocationV2 []updateLocations);

        [OperationContract(Name = "SetTitleFacebookAppId")]
        [FaultContract(typeof(MixClientFault))]
        [FaultContract(typeof(ValidationFault), Name = "ValidationFault", Namespace = "http://xonline.mix.common.contracts")]
        void SetTitleFacebookAppId(uint titleId, string appId);
     }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\TitleManagement\Service\MixTitleManagement.cs ===
using xonline.common.config;
using xonline.common.content;
using xonline.common.installer;
using xonline.common.mgmt;

[assembly: XomIisInstallerAttribute(Interface.mixtitlemanagement)]
[assembly: ConfigAttribute(Component.mixtitlemanagement)]
[assembly: XomAreaDefinition(XomAreaName.log)]

namespace xonline.mix.titlemanagement.service
{
    public class MixTitleManagement
    {
        public static readonly string ConfigureTitleApiName = "MixTitleManagement.ConfigureTitle";
        public static readonly string AddBaseVersionApiName = "MixTitleManagement.AddBaseVersion";
        public static readonly string RemoveBaseVersionApiName = "MixTitleManagement.RemoveBaseVersion";
        public static readonly string GetTitleVersionsApiName = "MixTitleManagement.GetTitleVersions";
        public static readonly string SetTitleUpdatePackagesApiName = "MixTitleManagement.SetTitleUpdatePackages";
        public static readonly string SetTitleFacebookAppId = "MixTitleManagement.SetTitleFacebookAppId";
        public static readonly string GetBusinessPartnerTitleIDsApiName = "MixTitleManagement.GetBusinessPartnerTitleIDs";
        public static readonly string SetBusinessPartnerTitleIDsApiName = "MixTitleManagement.SetBusinessPartnerTitleIDs";
        public static readonly string SetNetworkSecurityListApiName = "MixTitleManagement.SetNetworkSecurityList";
        public static readonly string GetNetworkSecurityList = "MixTitleManagement.GetNetworkSecurityList";
        public static readonly string GetNetworkSecurityListByAppliesTo = "MixTitleManagement.GetNetworkSecurityListByAppliesTo";
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\TitleManagement\Contracts\objd\i386\MixTitleManagementProxy.cs ===
ï»¿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.4971
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

[assembly: System.Runtime.Serialization.ContractNamespaceAttribute("http://xonline.mix.titlemanagement.contracts/V1", ClrNamespace="xonline.mix.titlemanagement.contracts.V1")]
[assembly: System.Runtime.Serialization.ContractNamespaceAttribute("http://xonline.mix.titlemanagement.contracts/V2", ClrNamespace="xonline.mix.titlemanagement.contracts.V2")]
[assembly: System.Runtime.Serialization.ContractNamespaceAttribute("http://xonline.mix.titlemanagement.contracts/V3", ClrNamespace="xonline.mix.titlemanagement.contracts.V3")]

namespace xonline.mix.titlemanagement.contracts.V1
{
    using System.Runtime.Serialization;
    
    
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="PlatformType", Namespace="http://xonline.mix.titlemanagement.contracts/V1")]
    public enum PlatformType : int
    {
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        Xbox1 = 0,
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        XboxCom = 1,
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        Xenon = 2,
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        Marketplace = 3,
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        PC = 4,
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        Mobile = 5,
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        WebGames = 6,
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="TitleVersions", Namespace="http://xonline.mix.titlemanagement.contracts/V1")]
    public partial class TitleVersions : object, System.Runtime.Serialization.IExtensibleDataObject
    {
        
        private System.Runtime.Serialization.ExtensionDataObject extensionDataField;
        
        private xonline.mix.titlemanagement.contracts.V1.TitleVersionInstance[] VersionsField;
        
        public System.Runtime.Serialization.ExtensionDataObject ExtensionData
        {
            get
            {
                return this.extensionDataField;
            }
            set
            {
                this.extensionDataField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute(IsRequired=true)]
        public xonline.mix.titlemanagement.contracts.V1.TitleVersionInstance[] Versions
        {
            get
            {
                return this.VersionsField;
            }
            set
            {
                this.VersionsField = value;
            }
        }
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="TitleVersionInstance", Namespace="http://xonline.mix.titlemanagement.contracts/V1")]
    public partial class TitleVersionInstance : object, System.Runtime.Serialization.IExtensibleDataObject
    {
        
        private System.Runtime.Serialization.ExtensionDataObject extensionDataField;
        
        private int BaseVersionField;
        
        private System.Guid BetaGroupField;
        
        private xonline.mix.titlemanagement.contracts.V1.PlatformType PlatformTypeField;
        
        private uint TitleIdField;
        
        private int UpdateVersionField;
        
        public System.Runtime.Serialization.ExtensionDataObject ExtensionData
        {
            get
            {
                return this.extensionDataField;
            }
            set
            {
                this.extensionDataField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute(IsRequired=true)]
        public int BaseVersion
        {
            get
            {
                return this.BaseVersionField;
            }
            set
            {
                this.BaseVersionField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute(IsRequired=true)]
        public System.Guid BetaGroup
        {
            get
            {
                return this.BetaGroupField;
            }
            set
            {
                this.BetaGroupField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute(IsRequired=true)]
        public xonline.mix.titlemanagement.contracts.V1.PlatformType PlatformType
        {
            get
            {
                return this.PlatformTypeField;
            }
            set
            {
                this.PlatformTypeField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute(IsRequired=true)]
        public uint TitleId
        {
            get
            {
                return this.TitleIdField;
            }
            set
            {
                this.TitleIdField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute(IsRequired=true)]
        public int UpdateVersion
        {
            get
            {
                return this.UpdateVersionField;
            }
            set
            {
                this.UpdateVersionField = value;
            }
        }
    }
}


[System.CodeDom.Compiler.GeneratedCodeAttribute("System.ServiceModel", "3.0.0.0")]
[System.ServiceModel.ServiceContractAttribute(Namespace="http://xonline.mix.titlemanagement.contracts/V1", ConfigurationName="MixTitleManagement")]
public interface MixTitleManagement
{
    
    [System.ServiceModel.OperationContractAttribute(Action="http://xonline.mix.titlemanagement.contracts/V1/MixTitleManagement/ConfigureTitle" +
        "", ReplyAction="http://xonline.mix.titlemanagement.contracts/V1/MixTitleManagement/ConfigureTitle" +
        "Response")]
    [System.ServiceModel.FaultContractAttribute(typeof(Microsoft.Practices.EnterpriseLibrary.Validation.Integration.WCF.ValidationFault), Action="http://xonline.mix.titlemanagement.contracts/V1/MixTitleManagement/ConfigureTitle" +
        "ValidationFault", Name="ValidationFault", Namespace="http://xonline.mix.common.contracts")]
    [System.ServiceModel.FaultContractAttribute(typeof(xonline.mix.common.MixClientFault), Action="http://xonline.mix.titlemanagement.contracts/V1/MixTitleManagement/ConfigureTitle" +
        "MixClientFaultFault", Name="MixClientFault", Namespace="http://xonline.mix.common.contracts")]
    void ConfigureTitle(byte[] compressedXlast, bool noReload);
    
    [System.ServiceModel.OperationContractAttribute(Action="http://xonline.mix.titlemanagement.contracts/V1/MixTitleManagement/AddBaseVersion" +
        "", ReplyAction="http://xonline.mix.titlemanagement.contracts/V1/MixTitleManagement/AddBaseVersion" +
        "Response")]
    [System.ServiceModel.FaultContractAttribute(typeof(Microsoft.Practices.EnterpriseLibrary.Validation.Integration.WCF.ValidationFault), Action="http://xonline.mix.titlemanagement.contracts/V1/MixTitleManagement/AddBaseVersion" +
        "ValidationFault", Name="ValidationFault", Namespace="http://xonline.mix.common.contracts")]
    [System.ServiceModel.FaultContractAttribute(typeof(xonline.mix.common.MixClientFault), Action="http://xonline.mix.titlemanagement.contracts/V1/MixTitleManagement/AddBaseVersion" +
        "MixClientFaultFault", Name="MixClientFault", Namespace="http://xonline.mix.common.contracts")]
    void AddBaseVersion(uint titleId, int version, xonline.mix.titlemanagement.contracts.V1.PlatformType platformType, System.Guid betaGroup);
    
    [System.ServiceModel.OperationContractAttribute(Action="http://xonline.mix.titlemanagement.contracts/V1/MixTitleManagement/RemoveBaseVers" +
        "ion", ReplyAction="http://xonline.mix.titlemanagement.contracts/V1/MixTitleManagement/RemoveBaseVers" +
        "ionResponse")]
    [System.ServiceModel.FaultContractAttribute(typeof(Microsoft.Practices.EnterpriseLibrary.Validation.Integration.WCF.ValidationFault), Action="http://xonline.mix.titlemanagement.contracts/V1/MixTitleManagement/RemoveBaseVers" +
        "ionValidationFault", Name="ValidationFault", Namespace="http://xonline.mix.common.contracts")]
    [System.ServiceModel.FaultContractAttribute(typeof(xonline.mix.common.MixClientFault), Action="http://xonline.mix.titlemanagement.contracts/V1/MixTitleManagement/RemoveBaseVers" +
        "ionMixClientFaultFault", Name="MixClientFault", Namespace="http://xonline.mix.common.contracts")]
    void RemoveBaseVersion(uint titleId, int version, xonline.mix.titlemanagement.contracts.V1.PlatformType platformType, System.Guid betaGroup);
    
    [System.ServiceModel.OperationContractAttribute(Action="http://xonline.mix.titlemanagement.contracts/V1/MixTitleManagement/GetTitleVersio" +
        "ns", ReplyAction="http://xonline.mix.titlemanagement.contracts/V1/MixTitleManagement/GetTitleVersio" +
        "nsResponse")]
    [System.ServiceModel.FaultContractAttribute(typeof(xonline.mix.common.MixClientFault), Action="http://xonline.mix.titlemanagement.contracts/V1/MixTitleManagement/GetTitleVersio" +
        "nsMixClientFaultFault", Name="MixClientFault", Namespace="http://xonline.mix.common.contracts")]
    [System.ServiceModel.FaultContractAttribute(typeof(Microsoft.Practices.EnterpriseLibrary.Validation.Integration.WCF.ValidationFault), Action="http://xonline.mix.titlemanagement.contracts/V1/MixTitleManagement/GetTitleVersio" +
        "nsValidationFault", Name="ValidationFault", Namespace="http://xonline.mix.common.contracts")]
    xonline.mix.titlemanagement.contracts.V1.TitleVersions GetTitleVersions(uint titleId);
}

[System.CodeDom.Compiler.GeneratedCodeAttribute("System.ServiceModel", "3.0.0.0")]
public interface MixTitleManagementChannel : MixTitleManagement, System.ServiceModel.IClientChannel
{
}

[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.CodeDom.Compiler.GeneratedCodeAttribute("System.ServiceModel", "3.0.0.0")]
public partial class MixTitleManagementClient : System.ServiceModel.ClientBase<MixTitleManagement>, MixTitleManagement
{
    
    public MixTitleManagementClient()
    {
    }
    
    public MixTitleManagementClient(string endpointConfigurationName) : 
            base(endpointConfigurationName)
    {
    }
    
    public MixTitleManagementClient(string endpointConfigurationName, string remoteAddress) : 
            base(endpointConfigurationName, remoteAddress)
    {
    }
    
    public MixTitleManagementClient(string endpointConfigurationName, System.ServiceModel.EndpointAddress remoteAddress) : 
            base(endpointConfigurationName, remoteAddress)
    {
    }
    
    public MixTitleManagementClient(System.ServiceModel.Channels.Binding binding, System.ServiceModel.EndpointAddress remoteAddress) : 
            base(binding, remoteAddress)
    {
    }
    
    public void ConfigureTitle(byte[] compressedXlast, bool noReload)
    {
        base.Channel.ConfigureTitle(compressedXlast, noReload);
    }
    
    public void AddBaseVersion(uint titleId, int version, xonline.mix.titlemanagement.contracts.V1.PlatformType platformType, System.Guid betaGroup)
    {
        base.Channel.AddBaseVersion(titleId, version, platformType, betaGroup);
    }
    
    public void RemoveBaseVersion(uint titleId, int version, xonline.mix.titlemanagement.contracts.V1.PlatformType platformType, System.Guid betaGroup)
    {
        base.Channel.RemoveBaseVersion(titleId, version, platformType, betaGroup);
    }
    
    public xonline.mix.titlemanagement.contracts.V1.TitleVersions GetTitleVersions(uint titleId)
    {
        return base.Channel.GetTitleVersions(titleId);
    }
}

[System.CodeDom.Compiler.GeneratedCodeAttribute("System.ServiceModel", "3.0.0.0")]
[System.ServiceModel.ServiceContractAttribute(Namespace="http://xonline.mix.titlemanagement.contracts/V2", ConfigurationName="MixTitleManagementV2")]
public interface MixTitleManagementV2
{
    
    [System.ServiceModel.OperationContractAttribute(Action="http://xonline.mix.titlemanagement.contracts/V2/MixTitleManagementV2/ConfigureTit" +
        "le", ReplyAction="http://xonline.mix.titlemanagement.contracts/V2/MixTitleManagementV2/ConfigureTit" +
        "leResponse")]
    [System.ServiceModel.FaultContractAttribute(typeof(Microsoft.Practices.EnterpriseLibrary.Validation.Integration.WCF.ValidationFault), Action="http://xonline.mix.titlemanagement.contracts/V2/MixTitleManagementV2/ConfigureTit" +
        "leValidationFault", Name="ValidationFault", Namespace="http://xonline.mix.common.contracts")]
    [System.ServiceModel.FaultContractAttribute(typeof(xonline.mix.common.MixClientFault), Action="http://xonline.mix.titlemanagement.contracts/V2/MixTitleManagementV2/ConfigureTit" +
        "leMixClientFaultFault", Name="MixClientFault", Namespace="http://xonline.mix.common.contracts")]
    void ConfigureTitle(byte[] compressedXlast, bool noReload);
    
    [System.ServiceModel.OperationContractAttribute(Action="http://xonline.mix.titlemanagement.contracts/V2/MixTitleManagementV2/AddBaseVersi" +
        "on", ReplyAction="http://xonline.mix.titlemanagement.contracts/V2/MixTitleManagementV2/AddBaseVersi" +
        "onResponse")]
    [System.ServiceModel.FaultContractAttribute(typeof(Microsoft.Practices.EnterpriseLibrary.Validation.Integration.WCF.ValidationFault), Action="http://xonline.mix.titlemanagement.contracts/V2/MixTitleManagementV2/AddBaseVersi" +
        "onValidationFault", Name="ValidationFault", Namespace="http://xonline.mix.common.contracts")]
    [System.ServiceModel.FaultContractAttribute(typeof(xonline.mix.common.MixClientFault), Action="http://xonline.mix.titlemanagement.contracts/V2/MixTitleManagementV2/AddBaseVersi" +
        "onMixClientFaultFault", Name="MixClientFault", Namespace="http://xonline.mix.common.contracts")]
    void AddBaseVersion(uint titleId, int version, xonline.mix.titlemanagement.contracts.V2.PlatformType platformType, System.Guid betaGroup);
    
    [System.ServiceModel.OperationContractAttribute(Action="http://xonline.mix.titlemanagement.contracts/V2/MixTitleManagementV2/RemoveBaseVe" +
        "rsion", ReplyAction="http://xonline.mix.titlemanagement.contracts/V2/MixTitleManagementV2/RemoveBaseVe" +
        "rsionResponse")]
    [System.ServiceModel.FaultContractAttribute(typeof(Microsoft.Practices.EnterpriseLibrary.Validation.Integration.WCF.ValidationFault), Action="http://xonline.mix.titlemanagement.contracts/V2/MixTitleManagementV2/RemoveBaseVe" +
        "rsionValidationFault", Name="ValidationFault", Namespace="http://xonline.mix.common.contracts")]
    [System.ServiceModel.FaultContractAttribute(typeof(xonline.mix.common.MixClientFault), Action="http://xonline.mix.titlemanagement.contracts/V2/MixTitleManagementV2/RemoveBaseVe" +
        "rsionMixClientFaultFault", Name="MixClientFault", Namespace="http://xonline.mix.common.contracts")]
    void RemoveBaseVersion(uint titleId, int version, xonline.mix.titlemanagement.contracts.V2.PlatformType platformType, System.Guid betaGroup);
    
    [System.ServiceModel.OperationContractAttribute(Action="http://xonline.mix.titlemanagement.contracts/V2/MixTitleManagementV2/GetTitleVers" +
        "ions", ReplyAction="http://xonline.mix.titlemanagement.contracts/V2/MixTitleManagementV2/GetTitleVers" +
        "ionsResponse")]
    [System.ServiceModel.FaultContractAttribute(typeof(xonline.mix.common.MixClientFault), Action="http://xonline.mix.titlemanagement.contracts/V2/MixTitleManagementV2/GetTitleVers" +
        "ionsMixClientFaultFault", Name="MixClientFault", Namespace="http://xonline.mix.common.contracts")]
    [System.ServiceModel.FaultContractAttribute(typeof(Microsoft.Practices.EnterpriseLibrary.Validation.Integration.WCF.ValidationFault), Action="http://xonline.mix.titlemanagement.contracts/V2/MixTitleManagementV2/GetTitleVers" +
        "ionsValidationFault", Name="ValidationFault", Namespace="http://xonline.mix.common.contracts")]
    xonline.mix.titlemanagement.contracts.V2.TitleVersions GetTitleVersions(uint titleId);
    
    [System.ServiceModel.OperationContractAttribute(Action="http://xonline.mix.titlemanagement.contracts/V2/MixTitleManagementV2/SetTitleUpda" +
        "tePackages", ReplyAction="http://xonline.mix.titlemanagement.contracts/V2/MixTitleManagementV2/SetTitleUpda" +
        "tePackagesResponse")]
    [System.ServiceModel.FaultContractAttribute(typeof(xonline.mix.common.MixClientFault), Action="http://xonline.mix.titlemanagement.contracts/V2/MixTitleManagementV2/SetTitleUpda" +
        "tePackagesMixClientFaultFault", Name="MixClientFault", Namespace="http://xonline.mix.common.contracts")]
    [System.ServiceModel.FaultContractAttribute(typeof(Microsoft.Practices.EnterpriseLibrary.Validation.Integration.WCF.ValidationFault), Action="http://xonline.mix.titlemanagement.contracts/V2/MixTitleManagementV2/SetTitleUpda" +
        "tePackagesValidationFault", Name="ValidationFault", Namespace="http://xonline.mix.common.contracts")]
    void SetTitleUpdatePackages(uint titleId, int baseVersion, int updateVersion, xonline.mix.titlemanagement.contracts.V2.PlatformType consoleType, xonline.mix.titlemanagement.contracts.V2.TitleUpdatePackageInformation packageInformation, xonline.mix.titlemanagement.contracts.V2.TitleUpdatePackageLocation[] updateLocations);
    
    [System.ServiceModel.OperationContractAttribute(Action="http://xonline.mix.titlemanagement.contracts/V2/MixTitleManagementV2/SetTitleFace" +
        "bookAppId", ReplyAction="http://xonline.mix.titlemanagement.contracts/V2/MixTitleManagementV2/SetTitleFace" +
        "bookAppIdResponse")]
    [System.ServiceModel.FaultContractAttribute(typeof(xonline.mix.common.MixClientFault), Action="http://xonline.mix.titlemanagement.contracts/V2/MixTitleManagementV2/SetTitleFace" +
        "bookAppIdMixClientFaultFault", Name="MixClientFault", Namespace="http://xonline.mix.common.contracts")]
    [System.ServiceModel.FaultContractAttribute(typeof(Microsoft.Practices.EnterpriseLibrary.Validation.Integration.WCF.ValidationFault), Action="http://xonline.mix.titlemanagement.contracts/V2/MixTitleManagementV2/SetTitleFace" +
        "bookAppIdValidationFault", Name="ValidationFault", Namespace="http://xonline.mix.common.contracts")]
    void SetTitleFacebookAppId(uint titleId, string appId);
}

[System.CodeDom.Compiler.GeneratedCodeAttribute("System.ServiceModel", "3.0.0.0")]
public interface MixTitleManagementV2Channel : MixTitleManagementV2, System.ServiceModel.IClientChannel
{
}

[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.CodeDom.Compiler.GeneratedCodeAttribute("System.ServiceModel", "3.0.0.0")]
public partial class MixTitleManagementV2Client : System.ServiceModel.ClientBase<MixTitleManagementV2>, MixTitleManagementV2
{
    
    public MixTitleManagementV2Client()
    {
    }
    
    public MixTitleManagementV2Client(string endpointConfigurationName) : 
            base(endpointConfigurationName)
    {
    }
    
    public MixTitleManagementV2Client(string endpointConfigurationName, string remoteAddress) : 
            base(endpointConfigurationName, remoteAddress)
    {
    }
    
    public MixTitleManagementV2Client(string endpointConfigurationName, System.ServiceModel.EndpointAddress remoteAddress) : 
            base(endpointConfigurationName, remoteAddress)
    {
    }
    
    public MixTitleManagementV2Client(System.ServiceModel.Channels.Binding binding, System.ServiceModel.EndpointAddress remoteAddress) : 
            base(binding, remoteAddress)
    {
    }
    
    public void ConfigureTitle(byte[] compressedXlast, bool noReload)
    {
        base.Channel.ConfigureTitle(compressedXlast, noReload);
    }
    
    public void AddBaseVersion(uint titleId, int version, xonline.mix.titlemanagement.contracts.V2.PlatformType platformType, System.Guid betaGroup)
    {
        base.Channel.AddBaseVersion(titleId, version, platformType, betaGroup);
    }
    
    public void RemoveBaseVersion(uint titleId, int version, xonline.mix.titlemanagement.contracts.V2.PlatformType platformType, System.Guid betaGroup)
    {
        base.Channel.RemoveBaseVersion(titleId, version, platformType, betaGroup);
    }
    
    public xonline.mix.titlemanagement.contracts.V2.TitleVersions GetTitleVersions(uint titleId)
    {
        return base.Channel.GetTitleVersions(titleId);
    }
    
    public void SetTitleUpdatePackages(uint titleId, int baseVersion, int updateVersion, xonline.mix.titlemanagement.contracts.V2.PlatformType consoleType, xonline.mix.titlemanagement.contracts.V2.TitleUpdatePackageInformation packageInformation, xonline.mix.titlemanagement.contracts.V2.TitleUpdatePackageLocation[] updateLocations)
    {
        base.Channel.SetTitleUpdatePackages(titleId, baseVersion, updateVersion, consoleType, packageInformation, updateLocations);
    }
    
    public void SetTitleFacebookAppId(uint titleId, string appId)
    {
        base.Channel.SetTitleFacebookAppId(titleId, appId);
    }
}

[System.CodeDom.Compiler.GeneratedCodeAttribute("System.ServiceModel", "3.0.0.0")]
[System.ServiceModel.ServiceContractAttribute(Namespace="http://xonline.mix.titlemanagement.contracts/V3", ConfigurationName="MixTitleManagementV3")]
public interface MixTitleManagementV3
{
    
    [System.ServiceModel.OperationContractAttribute(Action="http://xonline.mix.titlemanagement.contracts/V3/MixTitleManagementV3/ConfigureTit" +
        "le", ReplyAction="http://xonline.mix.titlemanagement.contracts/V3/MixTitleManagementV3/ConfigureTit" +
        "leResponse")]
    [System.ServiceModel.FaultContractAttribute(typeof(Microsoft.Practices.EnterpriseLibrary.Validation.Integration.WCF.ValidationFault), Action="http://xonline.mix.titlemanagement.contracts/V3/MixTitleManagementV3/ConfigureTit" +
        "leValidationFault", Name="ValidationFault", Namespace="http://xonline.mix.common.contracts")]
    [System.ServiceModel.FaultContractAttribute(typeof(xonline.mix.common.MixClientFault), Action="http://xonline.mix.titlemanagement.contracts/V3/MixTitleManagementV3/ConfigureTit" +
        "leMixClientFaultFault", Name="MixClientFault", Namespace="http://xonline.mix.common.contracts")]
    void ConfigureTitle(byte[] compressedXlast, bool noReload);
    
    [System.ServiceModel.OperationContractAttribute(Action="http://xonline.mix.titlemanagement.contracts/V3/MixTitleManagementV3/AddBaseVersi" +
        "on", ReplyAction="http://xonline.mix.titlemanagement.contracts/V3/MixTitleManagementV3/AddBaseVersi" +
        "onResponse")]
    [System.ServiceModel.FaultContractAttribute(typeof(xonline.mix.common.MixClientFault), Action="http://xonline.mix.titlemanagement.contracts/V3/MixTitleManagementV3/AddBaseVersi" +
        "onMixClientFaultFault", Name="MixClientFault", Namespace="http://xonline.mix.common.contracts")]
    [System.ServiceModel.FaultContractAttribute(typeof(Microsoft.Practices.EnterpriseLibrary.Validation.Integration.WCF.ValidationFault), Action="http://xonline.mix.titlemanagement.contracts/V3/MixTitleManagementV3/AddBaseVersi" +
        "onValidationFault", Name="ValidationFault", Namespace="http://xonline.mix.common.contracts")]
    void AddBaseVersion(uint titleId, int version, xonline.mix.titlemanagement.contracts.V3.PlatformType platformType, System.Guid betaGroup);
    
    [System.ServiceModel.OperationContractAttribute(Action="http://xonline.mix.titlemanagement.contracts/V3/MixTitleManagementV3/RemoveBaseVe" +
        "rsion", ReplyAction="http://xonline.mix.titlemanagement.contracts/V3/MixTitleManagementV3/RemoveBaseVe" +
        "rsionResponse")]
    [System.ServiceModel.FaultContractAttribute(typeof(Microsoft.Practices.EnterpriseLibrary.Validation.Integration.WCF.ValidationFault), Action="http://xonline.mix.titlemanagement.contracts/V3/MixTitleManagementV3/RemoveBaseVe" +
        "rsionValidationFault", Name="ValidationFault", Namespace="http://xonline.mix.common.contracts")]
    [System.ServiceModel.FaultContractAttribute(typeof(xonline.mix.common.MixClientFault), Action="http://xonline.mix.titlemanagement.contracts/V3/MixTitleManagementV3/RemoveBaseVe" +
        "rsionMixClientFaultFault", Name="MixClientFault", Namespace="http://xonline.mix.common.contracts")]
    void RemoveBaseVersion(uint titleId, int version, xonline.mix.titlemanagement.contracts.V3.PlatformType platformType, System.Guid betaGroup);
    
    [System.ServiceModel.OperationContractAttribute(Action="http://xonline.mix.titlemanagement.contracts/V3/MixTitleManagementV3/GetTitleVers" +
        "ions", ReplyAction="http://xonline.mix.titlemanagement.contracts/V3/MixTitleManagementV3/GetTitleVers" +
        "ionsResponse")]
    [System.ServiceModel.FaultContractAttribute(typeof(Microsoft.Practices.EnterpriseLibrary.Validation.Integration.WCF.ValidationFault), Action="http://xonline.mix.titlemanagement.contracts/V3/MixTitleManagementV3/GetTitleVers" +
        "ionsValidationFault", Name="ValidationFault", Namespace="http://xonline.mix.common.contracts")]
    [System.ServiceModel.FaultContractAttribute(typeof(xonline.mix.common.MixClientFault), Action="http://xonline.mix.titlemanagement.contracts/V3/MixTitleManagementV3/GetTitleVers" +
        "ionsMixClientFaultFault", Name="MixClientFault", Namespace="http://xonline.mix.common.contracts")]
    xonline.mix.titlemanagement.contracts.V3.TitleVersions GetTitleVersions(uint titleId);
    
    [System.ServiceModel.OperationContractAttribute(Action="http://xonline.mix.titlemanagement.contracts/V3/MixTitleManagementV3/SetTitleUpda" +
        "tePackages", ReplyAction="http://xonline.mix.titlemanagement.contracts/V3/MixTitleManagementV3/SetTitleUpda" +
        "tePackagesResponse")]
    [System.ServiceModel.FaultContractAttribute(typeof(Microsoft.Practices.EnterpriseLibrary.Validation.Integration.WCF.ValidationFault), Action="http://xonline.mix.titlemanagement.contracts/V3/MixTitleManagementV3/SetTitleUpda" +
        "tePackagesValidationFault", Name="ValidationFault", Namespace="http://xonline.mix.common.contracts")]
    [System.ServiceModel.FaultContractAttribute(typeof(xonline.mix.common.MixClientFault), Action="http://xonline.mix.titlemanagement.contracts/V3/MixTitleManagementV3/SetTitleUpda" +
        "tePackagesMixClientFaultFault", Name="MixClientFault", Namespace="http://xonline.mix.common.contracts")]
    void SetTitleUpdatePackages(uint titleId, int baseVersion, int updateVersion, xonline.mix.titlemanagement.contracts.V3.PlatformType consoleType, xonline.mix.titlemanagement.contracts.V3.TitleUpdatePackageInformation packageInformation, xonline.mix.titlemanagement.contracts.V3.TitleUpdatePackageLocation[] updateLocations);
    
    [System.ServiceModel.OperationContractAttribute(Action="http://xonline.mix.titlemanagement.contracts/V3/MixTitleManagementV3/GetBusinessP" +
        "artnerTitleIDs", ReplyAction="http://xonline.mix.titlemanagement.contracts/V3/MixTitleManagementV3/GetBusinessP" +
        "artnerTitleIDsResponse")]
    [System.ServiceModel.FaultContractAttribute(typeof(xonline.mix.common.MixClientFault), Action="http://xonline.mix.titlemanagement.contracts/V3/MixTitleManagementV3/GetBusinessP" +
        "artnerTitleIDsMixClientFaultFault", Name="MixClientFault", Namespace="http://xonline.mix.common.contracts")]
    [System.ServiceModel.FaultContractAttribute(typeof(Microsoft.Practices.EnterpriseLibrary.Validation.Integration.WCF.ValidationFault), Action="http://xonline.mix.titlemanagement.contracts/V3/MixTitleManagementV3/GetBusinessP" +
        "artnerTitleIDsValidationFault", Name="ValidationFault", Namespace="http://xonline.mix.common.contracts")]
    uint[] GetBusinessPartnerTitleIDs(System.Guid businessPartnerID);
    
    [System.ServiceModel.OperationContractAttribute(Action="http://xonline.mix.titlemanagement.contracts/V3/MixTitleManagementV3/SetBusinessP" +
        "artnerTitleIDs", ReplyAction="http://xonline.mix.titlemanagement.contracts/V3/MixTitleManagementV3/SetBusinessP" +
        "artnerTitleIDsResponse")]
    [System.ServiceModel.FaultContractAttribute(typeof(Microsoft.Practices.EnterpriseLibrary.Validation.Integration.WCF.ValidationFault), Action="http://xonline.mix.titlemanagement.contracts/V3/MixTitleManagementV3/SetBusinessP" +
        "artnerTitleIDsValidationFault", Name="ValidationFault", Namespace="http://xonline.mix.common.contracts")]
    [System.ServiceModel.FaultContractAttribute(typeof(xonline.mix.common.MixClientFault), Action="http://xonline.mix.titlemanagement.contracts/V3/MixTitleManagementV3/SetBusinessP" +
        "artnerTitleIDsMixClientFaultFault", Name="MixClientFault", Namespace="http://xonline.mix.common.contracts")]
    void SetBusinessPartnerTitleIDs(System.Guid businessPartnerID, uint[] titleIDs);
    
    [System.ServiceModel.OperationContractAttribute(Action="http://xonline.mix.titlemanagement.contracts/V3/MixTitleManagementV3/SetNetworkSe" +
        "curityList", ReplyAction="http://xonline.mix.titlemanagement.contracts/V3/MixTitleManagementV3/SetNetworkSe" +
        "curityListResponse")]
    [System.ServiceModel.FaultContractAttribute(typeof(xonline.mix.common.MixClientFault), Action="http://xonline.mix.titlemanagement.contracts/V3/MixTitleManagementV3/SetNetworkSe" +
        "curityListMixClientFaultFault", Name="MixClientFault", Namespace="http://xonline.mix.common.contracts")]
    [System.ServiceModel.FaultContractAttribute(typeof(Microsoft.Practices.EnterpriseLibrary.Validation.Integration.WCF.ValidationFault), Action="http://xonline.mix.titlemanagement.contracts/V3/MixTitleManagementV3/SetNetworkSe" +
        "curityListValidationFault", Name="ValidationFault", Namespace="http://xonline.mix.common.contracts")]
    void SetNetworkSecurityList(uint titleID, xonline.mix.titlemanagement.contracts.V3.TitleEndpoint[] allowedEndpoints);
    
    [System.ServiceModel.OperationContractAttribute(Action="http://xonline.mix.titlemanagement.contracts/V3/MixTitleManagementV3/GetNetworkSe" +
        "curityList", ReplyAction="http://xonline.mix.titlemanagement.contracts/V3/MixTitleManagementV3/GetNetworkSe" +
        "curityListResponse")]
    [System.ServiceModel.FaultContractAttribute(typeof(Microsoft.Practices.EnterpriseLibrary.Validation.Integration.WCF.ValidationFault), Action="http://xonline.mix.titlemanagement.contracts/V3/MixTitleManagementV3/GetNetworkSe" +
        "curityListValidationFault", Name="ValidationFault", Namespace="http://xonline.mix.common.contracts")]
    [System.ServiceModel.FaultContractAttribute(typeof(xonline.mix.common.MixClientFault), Action="http://xonline.mix.titlemanagement.contracts/V3/MixTitleManagementV3/GetNetworkSe" +
        "curityListMixClientFaultFault", Name="MixClientFault", Namespace="http://xonline.mix.common.contracts")]
    xonline.mix.titlemanagement.contracts.V3.TitleEndpointInfo[] GetNetworkSecurityList(uint titleID, bool bFullHistory);
    
    [System.ServiceModel.OperationContractAttribute(Action="http://xonline.mix.titlemanagement.contracts/V3/MixTitleManagementV3/GetNetworkSe" +
        "curityListByAppliesTo", ReplyAction="http://xonline.mix.titlemanagement.contracts/V3/MixTitleManagementV3/GetNetworkSe" +
        "curityListByAppliesToResponse")]
    [System.ServiceModel.FaultContractAttribute(typeof(Microsoft.Practices.EnterpriseLibrary.Validation.Integration.WCF.ValidationFault), Action="http://xonline.mix.titlemanagement.contracts/V3/MixTitleManagementV3/GetNetworkSe" +
        "curityListByAppliesToValidationFault", Name="ValidationFault", Namespace="http://xonline.mix.common.contracts")]
    [System.ServiceModel.FaultContractAttribute(typeof(xonline.mix.common.MixClientFault), Action="http://xonline.mix.titlemanagement.contracts/V3/MixTitleManagementV3/GetNetworkSe" +
        "curityListByAppliesToMixClientFaultFault", Name="MixClientFault", Namespace="http://xonline.mix.common.contracts")]
    xonline.mix.titlemanagement.contracts.V3.TitleEndpointInfo[] GetNetworkSecurityListByAppliesTo(string appliesTo, bool bFullHistory);
}

[System.CodeDom.Compiler.GeneratedCodeAttribute("System.ServiceModel", "3.0.0.0")]
public interface MixTitleManagementV3Channel : MixTitleManagementV3, System.ServiceModel.IClientChannel
{
}

[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.CodeDom.Compiler.GeneratedCodeAttribute("System.ServiceModel", "3.0.0.0")]
public partial class MixTitleManagementV3Client : System.ServiceModel.ClientBase<MixTitleManagementV3>, MixTitleManagementV3
{
    
    public MixTitleManagementV3Client()
    {
    }
    
    public MixTitleManagementV3Client(string endpointConfigurationName) : 
            base(endpointConfigurationName)
    {
    }
    
    public MixTitleManagementV3Client(string endpointConfigurationName, string remoteAddress) : 
            base(endpointConfigurationName, remoteAddress)
    {
    }
    
    public MixTitleManagementV3Client(string endpointConfigurationName, System.ServiceModel.EndpointAddress remoteAddress) : 
            base(endpointConfigurationName, remoteAddress)
    {
    }
    
    public MixTitleManagementV3Client(System.ServiceModel.Channels.Binding binding, System.ServiceModel.EndpointAddress remoteAddress) : 
            base(binding, remoteAddress)
    {
    }
    
    public void ConfigureTitle(byte[] compressedXlast, bool noReload)
    {
        base.Channel.ConfigureTitle(compressedXlast, noReload);
    }
    
    public void AddBaseVersion(uint titleId, int version, xonline.mix.titlemanagement.contracts.V3.PlatformType platformType, System.Guid betaGroup)
    {
        base.Channel.AddBaseVersion(titleId, version, platformType, betaGroup);
    }
    
    public void RemoveBaseVersion(uint titleId, int version, xonline.mix.titlemanagement.contracts.V3.PlatformType platformType, System.Guid betaGroup)
    {
        base.Channel.RemoveBaseVersion(titleId, version, platformType, betaGroup);
    }
    
    public xonline.mix.titlemanagement.contracts.V3.TitleVersions GetTitleVersions(uint titleId)
    {
        return base.Channel.GetTitleVersions(titleId);
    }
    
    public void SetTitleUpdatePackages(uint titleId, int baseVersion, int updateVersion, xonline.mix.titlemanagement.contracts.V3.PlatformType consoleType, xonline.mix.titlemanagement.contracts.V3.TitleUpdatePackageInformation packageInformation, xonline.mix.titlemanagement.contracts.V3.TitleUpdatePackageLocation[] updateLocations)
    {
        base.Channel.SetTitleUpdatePackages(titleId, baseVersion, updateVersion, consoleType, packageInformation, updateLocations);
    }
    
    public uint[] GetBusinessPartnerTitleIDs(System.Guid businessPartnerID)
    {
        return base.Channel.GetBusinessPartnerTitleIDs(businessPartnerID);
    }
    
    public void SetBusinessPartnerTitleIDs(System.Guid businessPartnerID, uint[] titleIDs)
    {
        base.Channel.SetBusinessPartnerTitleIDs(businessPartnerID, titleIDs);
    }
    
    public void SetNetworkSecurityList(uint titleID, xonline.mix.titlemanagement.contracts.V3.TitleEndpoint[] allowedEndpoints)
    {
        base.Channel.SetNetworkSecurityList(titleID, allowedEndpoints);
    }
    
    public xonline.mix.titlemanagement.contracts.V3.TitleEndpointInfo[] GetNetworkSecurityList(uint titleID, bool bFullHistory)
    {
        return base.Channel.GetNetworkSecurityList(titleID, bFullHistory);
    }
    
    public xonline.mix.titlemanagement.contracts.V3.TitleEndpointInfo[] GetNetworkSecurityListByAppliesTo(string appliesTo, bool bFullHistory)
    {
        return base.Channel.GetNetworkSecurityListByAppliesTo(appliesTo, bFullHistory);
    }
}
namespace xonline.mix.titlemanagement.contracts.V2
{
    using System.Runtime.Serialization;
    
    
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="PlatformType", Namespace="http://xonline.mix.titlemanagement.contracts/V2")]
    public enum PlatformType : byte
    {
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        Xbox1 = 0,
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        XboxCom = 1,
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        Xenon = 2,
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        Marketplace = 3,
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        PC = 4,
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        Mobile = 5,
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        WebGames = 6,
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="TitleVersions", Namespace="http://xonline.mix.titlemanagement.contracts/V2")]
    public partial class TitleVersions : object, System.Runtime.Serialization.IExtensibleDataObject
    {
        
        private System.Runtime.Serialization.ExtensionDataObject extensionDataField;
        
        private xonline.mix.titlemanagement.contracts.V2.TitleVersionInstance[] VersionsField;
        
        public System.Runtime.Serialization.ExtensionDataObject ExtensionData
        {
            get
            {
                return this.extensionDataField;
            }
            set
            {
                this.extensionDataField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute(IsRequired=true)]
        public xonline.mix.titlemanagement.contracts.V2.TitleVersionInstance[] Versions
        {
            get
            {
                return this.VersionsField;
            }
            set
            {
                this.VersionsField = value;
            }
        }
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="TitleVersionInstance", Namespace="http://xonline.mix.titlemanagement.contracts/V2")]
    public partial class TitleVersionInstance : object, System.Runtime.Serialization.IExtensibleDataObject
    {
        
        private System.Runtime.Serialization.ExtensionDataObject extensionDataField;
        
        private int BaseVersionField;
        
        private System.Guid BetaGroupField;
        
        private xonline.mix.titlemanagement.contracts.V2.PlatformType PlatformTypeField;
        
        private uint TitleIdField;
        
        private int UpdateVersionField;
        
        public System.Runtime.Serialization.ExtensionDataObject ExtensionData
        {
            get
            {
                return this.extensionDataField;
            }
            set
            {
                this.extensionDataField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute(IsRequired=true)]
        public int BaseVersion
        {
            get
            {
                return this.BaseVersionField;
            }
            set
            {
                this.BaseVersionField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute(IsRequired=true)]
        public System.Guid BetaGroup
        {
            get
            {
                return this.BetaGroupField;
            }
            set
            {
                this.BetaGroupField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute(IsRequired=true)]
        public xonline.mix.titlemanagement.contracts.V2.PlatformType PlatformType
        {
            get
            {
                return this.PlatformTypeField;
            }
            set
            {
                this.PlatformTypeField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute(IsRequired=true)]
        public uint TitleId
        {
            get
            {
                return this.TitleIdField;
            }
            set
            {
                this.TitleIdField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute(IsRequired=true)]
        public int UpdateVersion
        {
            get
            {
                return this.UpdateVersionField;
            }
            set
            {
                this.UpdateVersionField = value;
            }
        }
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="TitleUpdatePackageInformation", Namespace="http://xonline.mix.titlemanagement.contracts/V2")]
    public partial class TitleUpdatePackageInformation : object, System.Runtime.Serialization.IExtensibleDataObject
    {
        
        private System.Runtime.Serialization.ExtensionDataObject extensionDataField;
        
        private byte[] ContentIdField;
        
        private int InstallSizeField;
        
        private int PackageSizeField;
        
        private byte[] PublicKeyField;
        
        private byte[] UpdateSymmetricKeyField;
        
        public System.Runtime.Serialization.ExtensionDataObject ExtensionData
        {
            get
            {
                return this.extensionDataField;
            }
            set
            {
                this.extensionDataField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute(IsRequired=true)]
        public byte[] ContentId
        {
            get
            {
                return this.ContentIdField;
            }
            set
            {
                this.ContentIdField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute(IsRequired=true)]
        public int InstallSize
        {
            get
            {
                return this.InstallSizeField;
            }
            set
            {
                this.InstallSizeField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute(IsRequired=true)]
        public int PackageSize
        {
            get
            {
                return this.PackageSizeField;
            }
            set
            {
                this.PackageSizeField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute(IsRequired=true)]
        public byte[] PublicKey
        {
            get
            {
                return this.PublicKeyField;
            }
            set
            {
                this.PublicKeyField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute(IsRequired=true)]
        public byte[] UpdateSymmetricKey
        {
            get
            {
                return this.UpdateSymmetricKeyField;
            }
            set
            {
                this.UpdateSymmetricKeyField = value;
            }
        }
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="TitleUpdatePackageLocation", Namespace="http://xonline.mix.titlemanagement.contracts/V2")]
    public partial class TitleUpdatePackageLocation : object, System.Runtime.Serialization.IExtensibleDataObject
    {
        
        private System.Runtime.Serialization.ExtensionDataObject extensionDataField;
        
        private int RankField;
        
        private string XrlField;
        
        public System.Runtime.Serialization.ExtensionDataObject ExtensionData
        {
            get
            {
                return this.extensionDataField;
            }
            set
            {
                this.extensionDataField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute(IsRequired=true)]
        public int Rank
        {
            get
            {
                return this.RankField;
            }
            set
            {
                this.RankField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute(IsRequired=true)]
        public string Xrl
        {
            get
            {
                return this.XrlField;
            }
            set
            {
                this.XrlField = value;
            }
        }
    }
}
namespace xonline.mix.titlemanagement.contracts.V3
{
    using System.Runtime.Serialization;
    
    
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="PlatformType", Namespace="http://xonline.mix.titlemanagement.contracts/V3")]
    public enum PlatformType : byte
    {
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        Xbox1 = 0,
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        XboxCom = 1,
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        Xenon = 2,
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        Marketplace = 3,
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        PC = 4,
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        Mobile = 5,
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        WebGames = 6,
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="TitleVersions", Namespace="http://xonline.mix.titlemanagement.contracts/V3")]
    public partial class TitleVersions : object, System.Runtime.Serialization.IExtensibleDataObject
    {
        
        private System.Runtime.Serialization.ExtensionDataObject extensionDataField;
        
        private xonline.mix.titlemanagement.contracts.V3.TitleVersionInstance[] VersionsField;
        
        public System.Runtime.Serialization.ExtensionDataObject ExtensionData
        {
            get
            {
                return this.extensionDataField;
            }
            set
            {
                this.extensionDataField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute(IsRequired=true)]
        public xonline.mix.titlemanagement.contracts.V3.TitleVersionInstance[] Versions
        {
            get
            {
                return this.VersionsField;
            }
            set
            {
                this.VersionsField = value;
            }
        }
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="TitleVersionInstance", Namespace="http://xonline.mix.titlemanagement.contracts/V3")]
    public partial class TitleVersionInstance : object, System.Runtime.Serialization.IExtensibleDataObject
    {
        
        private System.Runtime.Serialization.ExtensionDataObject extensionDataField;
        
        private int BaseVersionField;
        
        private System.Guid BetaGroupField;
        
        private xonline.mix.titlemanagement.contracts.V3.PlatformType PlatformTypeField;
        
        private uint TitleIdField;
        
        private int UpdateVersionField;
        
        public System.Runtime.Serialization.ExtensionDataObject ExtensionData
        {
            get
            {
                return this.extensionDataField;
            }
            set
            {
                this.extensionDataField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute(IsRequired=true)]
        public int BaseVersion
        {
            get
            {
                return this.BaseVersionField;
            }
            set
            {
                this.BaseVersionField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute(IsRequired=true)]
        public System.Guid BetaGroup
        {
            get
            {
                return this.BetaGroupField;
            }
            set
            {
                this.BetaGroupField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute(IsRequired=true)]
        public xonline.mix.titlemanagement.contracts.V3.PlatformType PlatformType
        {
            get
            {
                return this.PlatformTypeField;
            }
            set
            {
                this.PlatformTypeField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute(IsRequired=true)]
        public uint TitleId
        {
            get
            {
                return this.TitleIdField;
            }
            set
            {
                this.TitleIdField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute(IsRequired=true)]
        public int UpdateVersion
        {
            get
            {
                return this.UpdateVersionField;
            }
            set
            {
                this.UpdateVersionField = value;
            }
        }
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="TitleUpdatePackageInformation", Namespace="http://xonline.mix.titlemanagement.contracts/V3")]
    public partial class TitleUpdatePackageInformation : object, System.Runtime.Serialization.IExtensibleDataObject
    {
        
        private System.Runtime.Serialization.ExtensionDataObject extensionDataField;
        
        private byte[] ContentIdField;
        
        private int InstallSizeField;
        
        private int PackageSizeField;
        
        private byte[] PublicKeyField;
        
        private byte[] UpdateSymmetricKeyField;
        
        public System.Runtime.Serialization.ExtensionDataObject ExtensionData
        {
            get
            {
                return this.extensionDataField;
            }
            set
            {
                this.extensionDataField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute(IsRequired=true)]
        public byte[] ContentId
        {
            get
            {
                return this.ContentIdField;
            }
            set
            {
                this.ContentIdField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute(IsRequired=true)]
        public int InstallSize
        {
            get
            {
                return this.InstallSizeField;
            }
            set
            {
                this.InstallSizeField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute(IsRequired=true)]
        public int PackageSize
        {
            get
            {
                return this.PackageSizeField;
            }
            set
            {
                this.PackageSizeField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute(IsRequired=true)]
        public byte[] PublicKey
        {
            get
            {
                return this.PublicKeyField;
            }
            set
            {
                this.PublicKeyField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute(IsRequired=true)]
        public byte[] UpdateSymmetricKey
        {
            get
            {
                return this.UpdateSymmetricKeyField;
            }
            set
            {
                this.UpdateSymmetricKeyField = value;
            }
        }
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="TitleUpdatePackageLocation", Namespace="http://xonline.mix.titlemanagement.contracts/V3")]
    public partial class TitleUpdatePackageLocation : object, System.Runtime.Serialization.IExtensibleDataObject
    {
        
        private System.Runtime.Serialization.ExtensionDataObject extensionDataField;
        
        private int RankField;
        
        private string XrlField;
        
        public System.Runtime.Serialization.ExtensionDataObject ExtensionData
        {
            get
            {
                return this.extensionDataField;
            }
            set
            {
                this.extensionDataField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute(IsRequired=true)]
        public int Rank
        {
            get
            {
                return this.RankField;
            }
            set
            {
                this.RankField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute(IsRequired=true)]
        public string Xrl
        {
            get
            {
                return this.XrlField;
            }
            set
            {
                this.XrlField = value;
            }
        }
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="TitleEndpoint", Namespace="http://xonline.mix.titlemanagement.contracts/V3")]
    public partial class TitleEndpoint : object, System.Runtime.Serialization.IExtensibleDataObject
    {
        
        private System.Runtime.Serialization.ExtensionDataObject extensionDataField;
        
        private string AppliesToUriField;
        
        private uint FromIPField;
        
        private string HostnameField;
        
        private string PathField;
        
        private int PortField;
        
        private string ProtocolField;
        
        private uint ToIPField;
        
        public System.Runtime.Serialization.ExtensionDataObject ExtensionData
        {
            get
            {
                return this.extensionDataField;
            }
            set
            {
                this.extensionDataField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string AppliesToUri
        {
            get
            {
                return this.AppliesToUriField;
            }
            set
            {
                this.AppliesToUriField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public uint FromIP
        {
            get
            {
                return this.FromIPField;
            }
            set
            {
                this.FromIPField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string Hostname
        {
            get
            {
                return this.HostnameField;
            }
            set
            {
                this.HostnameField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string Path
        {
            get
            {
                return this.PathField;
            }
            set
            {
                this.PathField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public int Port
        {
            get
            {
                return this.PortField;
            }
            set
            {
                this.PortField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute(IsRequired=true)]
        public string Protocol
        {
            get
            {
                return this.ProtocolField;
            }
            set
            {
                this.ProtocolField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public uint ToIP
        {
            get
            {
                return this.ToIPField;
            }
            set
            {
                this.ToIPField = value;
            }
        }
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="TitleEndpointInfo", Namespace="http://xonline.mix.titlemanagement.contracts/V3")]
    public partial class TitleEndpointInfo : object, System.Runtime.Serialization.IExtensibleDataObject
    {
        
        private System.Runtime.Serialization.ExtensionDataObject extensionDataField;
        
        private System.DateTime EndField;
        
        private xonline.mix.titlemanagement.contracts.V3.TitleEndpoint EndpointInfoField;
        
        private System.DateTime StartField;
        
        private uint TitleIDField;
        
        public System.Runtime.Serialization.ExtensionDataObject ExtensionData
        {
            get
            {
                return this.extensionDataField;
            }
            set
            {
                this.extensionDataField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute(IsRequired=true)]
        public System.DateTime End
        {
            get
            {
                return this.EndField;
            }
            set
            {
                this.EndField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute(IsRequired=true)]
        public xonline.mix.titlemanagement.contracts.V3.TitleEndpoint EndpointInfo
        {
            get
            {
                return this.EndpointInfoField;
            }
            set
            {
                this.EndpointInfoField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute(IsRequired=true)]
        public System.DateTime Start
        {
            get
            {
                return this.StartField;
            }
            set
            {
                this.StartField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute(IsRequired=true)]
        public uint TitleID
        {
            get
            {
                return this.TitleIDField;
            }
            set
            {
                this.TitleIDField = value;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\TitleManagement\Service\global.asax.cs ===
using System;
using System.Collections.Generic;
using xonline.common.service;
using xonline.common.mgmt;
using xonline.common.xlastutil;
using xonline.server.mgmt.soap;
using xonline.mix.common;

namespace xonline.mix.titlemanagement.service
{
    public class MixTitleManagementApp : SoapFrontEndApp
    {
        internal static Dictionary<string, string> MobileColumnLocalizationData;

        /// <summary>
        /// Default constructor
        /// </summary>
        public MixTitleManagementApp()
            : base()
        {

        }

        public override void Application_Start(object sender, EventArgs eventArgs)
        {

            //Call the base 
            base.Application_Start(sender, eventArgs);
            
            EventBuilder.ShowSGInfo = false;
            // Custom start code
            XomControl.ControlRequestEvent += new XomControl.ControlRequestEventHandler(OnXomControlRequest);

            // Initialize the mobile title column localization data.
            MobileColumnLocalizationData = MobileAndWebLeaderboardUtils.GetLocalizationDataDictionary(
                AppDomain.CurrentDomain.BaseDirectory + MobileAndWebLeaderboardUtils.ColLocalizationDataFile);
        }
        /// <summary>
        /// Event handler for the Xmgmt control request event
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="args"></param>
        public void OnXomControlRequest(object sender, ControlRequestEventArgs args)
        {
            //TODO add xmgmt control command parsing logic and code
            //Is there any thing to reload, cancel? 
        }
        /// <summary>
        /// Error handling for Mix will happen using MixError handler
        /// On Error is not capable of catching FaultExceptions
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="ea"></param>
        public override void Application_OnError(object sender, EventArgs ea)
        {
            //We handle errors in the MixErrorHandler
        }

        public override void Application_EndRequest(object sender, EventArgs ea)
        {
            //We dont need to reformat any response
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\TitleManagement\Service\MixTitleManagementV1.svc.cs ===
using System;
using System.Collections.Generic;
using System.ServiceModel;
using System.ServiceModel.Activation;

using xonline.common.service;
using xonline.common.config;
using xonline.common.installer;
using xonline.common.mgmt;
using xonline.server.webcache.common;
using xonline.mix.titlemanagement.contract;
using PlatformTypeV1=xonline.mix.titlemanagement.contract.PlatformType;
using PlatformType=xonline.mix.titlemanagement.service.PlatformType;

namespace xonline.mix.titlemanagement.service
{
    public class TitleMgmtHostFactory : ServiceHostFactory
    {
        protected override ServiceHost CreateServiceHost(Type serviceType, Uri[] baseAddresses)
        {
            ServiceHost host = new ServiceHost(serviceType, baseAddresses);

            foreach (Uri address in baseAddresses)
            {
                BasicHttpBinding binding = new BasicHttpBinding(BasicHttpSecurityMode.None);
                binding.Name = serviceType.Name;
                binding.CloseTimeout = new TimeSpan(0, 1, 0);
                binding.OpenTimeout = new TimeSpan(0, 1, 0);
                binding.ReceiveTimeout = new TimeSpan(0, 10, 0);
                binding.SendTimeout = new TimeSpan(0, 1, 0);
                binding.MaxReceivedMessageSize = Convert.ToInt64(Config.GetSetting("mix_wcfMaxReceivedMsgSize"));
                binding.ReaderQuotas.MaxArrayLength = Convert.ToInt32(Config.GetSetting("mix_wcfMaxReceivedMsgSize"));
            
                host.AddServiceEndpoint(serviceType.GetInterfaces()[0], binding, address);
            }
            
            return host;
        }
    }

    // NOTE: If you change the class name "MixOfferManagement" here, you must also update the reference to "MixOfferManagement" in Web.config and in the associated .svc file.
    //Set the compat mode to allow the WCF application mimic the ASPNET lifecycle. This will ensure that the current components like FEAPP will continue to work with our service
    [AspNetCompatibilityRequirements(RequirementsMode = AspNetCompatibilityRequirementsMode.Required)]
    public class MixTitleManagementV1 : IMixTitleManagementV1
    {
        public void ConfigureTitle(byte[] compressedXlast, bool noReload)
        {
            try
            {
                try
                {
                    Utilities.Instance.CheckAPI(MixTitleManagement.ConfigureTitleApiName);
                }
                catch (XboxWebInternalException ex)
                {
                    throw new XRLException(HResult.XONLINE_E_MIX_WEBSGVALIDATIONERROR, XEvent.Id.MIX_WEBSGVALIDATION_HEADERINVALID, string.Format("Partner Validation did not pass, WebSG header information missing {0}", ex.Message), false);
                }
                catch (XboxWebException ex)
                {
                    //catches incorrect IP information
                    throw new XRLException(HResult.XONLINE_E_MIX_WEBSGVALIDATIONERROR, XEvent.Id.MIX_WEBSGVALIDATION_HEADERINVALID, string.Format("Partner Validation did not pass, WebSG header information missing {0}", ex.Message), false);
                }
                catch (KeyNotFoundException ex)
                {
                    throw new XRLException(HResult.XONLINE_E_MIX_WEBSGVALIDATIONERROR, XEvent.Id.MIX_WEBSGVALIDATION_HEADERMISSING, string.Format("Partner Validation did not pass, WebSG header information invalid {0}", ex.Message), false);
                }

                TitleManager.ConfigureTitle(compressedXlast, noReload);
            }
            finally
            {
                // Logging API name and input parameters
                string appLog = string.Join(xonline.mix.common.MixConstants.AppLogSeparator, new string[]
                {
                    // API name
                    MixTitleManagement.ConfigureTitleApiName,
                    // Input params
                    compressedXlast.Length.ToString(),
                    noReload.ToString()
                });

                Xom.Log(XomAreaName.log, appLog);
            }
        }

        public void AddBaseVersion(uint titleId, int version, PlatformTypeV1 platformType, Guid betaGroup)
        {
            try
            {
                try
                {
                    Utilities.Instance.CheckAPI(MixTitleManagement.AddBaseVersionApiName);
                }
                catch (XboxWebInternalException ex)
                {
                    throw new XRLException(HResult.XONLINE_E_MIX_WEBSGVALIDATIONERROR, XEvent.Id.MIX_WEBSGVALIDATION_HEADERINVALID, string.Format("Partner Validation did not pass, WebSG header information missing {0}", ex.Message), false);
                }
                catch (XboxWebException ex)
                {
                    //catches incorrect IP information
                    throw new XRLException(HResult.XONLINE_E_MIX_WEBSGVALIDATIONERROR, XEvent.Id.MIX_WEBSGVALIDATION_HEADERINVALID, string.Format("Partner Validation did not pass, WebSG header information missing {0}", ex.Message), false);
                }
                catch (KeyNotFoundException ex)
                {
                    throw new XRLException(HResult.XONLINE_E_MIX_WEBSGVALIDATIONERROR, XEvent.Id.MIX_WEBSGVALIDATION_HEADERMISSING, string.Format("Partner Validation did not pass, WebSG header information invalid {0}", ex.Message), false);
                }

                TitleManager.AddBaseVersion(titleId, version, (PlatformType)platformType, betaGroup);
            }
            finally
            {
                // Logging API name and input parameters
                string appLog = string.Join(xonline.mix.common.MixConstants.AppLogSeparator, new string[]
                {
                    // API name
                    MixTitleManagement.AddBaseVersionApiName,
                    // Input params
                    titleId.ToString(),
                    version.ToString(),
                    platformType.ToString(),
                    betaGroup.ToString()
                });

                Xom.Log(XomAreaName.log, appLog);
            }
        }

        public void RemoveBaseVersion(uint titleId, int version, PlatformTypeV1 platformType, Guid betaGroup)
        {
            try
            {
                try
                {
                    Utilities.Instance.CheckAPI(MixTitleManagement.RemoveBaseVersionApiName);
                }
                catch (XboxWebInternalException ex)
                {
                    throw new XRLException(HResult.XONLINE_E_MIX_WEBSGVALIDATIONERROR, XEvent.Id.MIX_WEBSGVALIDATION_HEADERINVALID, string.Format("Partner Validation did not pass, WebSG header information missing {0}", ex.Message), false);
                }
                catch (XboxWebException ex)
                {
                    //catches incorrect IP information
                    throw new XRLException(HResult.XONLINE_E_MIX_WEBSGVALIDATIONERROR, XEvent.Id.MIX_WEBSGVALIDATION_HEADERINVALID, string.Format("Partner Validation did not pass, WebSG header information missing {0}", ex.Message), false);
                }
                catch (KeyNotFoundException ex)
                {
                    throw new XRLException(HResult.XONLINE_E_MIX_WEBSGVALIDATIONERROR, XEvent.Id.MIX_WEBSGVALIDATION_HEADERMISSING, string.Format("Partner Validation did not pass, WebSG header information invalid {0}", ex.Message), false);
                }

                TitleManager.RemoveBaseVersion(titleId, version, (PlatformType)platformType, betaGroup);
            }
            finally
            {
                // Logging API name and input parameters
                string appLog = string.Join(xonline.mix.common.MixConstants.AppLogSeparator, new string[]
                {
                    // API name
                    MixTitleManagement.RemoveBaseVersionApiName,
                    // Input params
                    titleId.ToString(),
                    version.ToString(),
                    platformType.ToString(),
                    betaGroup.ToString()
                });

                Xom.Log(XomAreaName.log, appLog);
            }
        }

        public TitleVersionsV1 GetTitleVersions(uint titleId)
        {
            TitleVersionsV1 versions = null;

            try
            {
                try
                {
                    Utilities.Instance.CheckAPI(MixTitleManagement.GetTitleVersionsApiName);
                }
                catch (XboxWebInternalException ex)
                {
                    throw new XRLException(HResult.XONLINE_E_MIX_WEBSGVALIDATIONERROR, XEvent.Id.MIX_WEBSGVALIDATION_HEADERINVALID, string.Format("Partner Validation did not pass, WebSG header information missing {0}", ex.Message), false);
                }
                catch (XboxWebException ex)
                {
                    //catches incorrect IP information
                    throw new XRLException(HResult.XONLINE_E_MIX_WEBSGVALIDATIONERROR, XEvent.Id.MIX_WEBSGVALIDATION_HEADERINVALID, string.Format("Partner Validation did not pass, WebSG header information missing {0}", ex.Message), false);
                }
                catch (KeyNotFoundException ex)
                {
                    throw new XRLException(HResult.XONLINE_E_MIX_WEBSGVALIDATIONERROR, XEvent.Id.MIX_WEBSGVALIDATION_HEADERMISSING, string.Format("Partner Validation did not pass, WebSG header information invalid {0}", ex.Message), false);
                }

                versions = TitleManager.GetTitleVersions(titleId);
            }
            finally
            {
                // Logging API name and input parameters
                string appLog = string.Join(xonline.mix.common.MixConstants.AppLogSeparator, new string[]
                {
                    // API name
                    MixTitleManagement.GetTitleVersionsApiName,
                    // Input params
                    titleId.ToString()
                });

                Xom.Log(XomAreaName.log, appLog);
            }

            return versions;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\TitleManagement\Service\MixTitleManagementV3.svc.cs ===
using System;
using System.Collections.Generic;
using System.ServiceModel;
using System.ServiceModel.Activation;

using xonline.common.service;
using xonline.common.config;
using xonline.common.installer;
using xonline.common.mgmt;
using xonline.server.webcache.common;
using xonline.mix.common;
using xonline.mix.titlemanagement.contract.V3;

namespace xonline.mix.titlemanagement.service.V3
{
    public class TitleMgmtHostFactory : ServiceHostFactory
    {
        protected override ServiceHost CreateServiceHost(Type serviceType, Uri[] baseAddresses)
        {
            ServiceHost host = new ServiceHost(serviceType, baseAddresses);

            foreach (Uri address in baseAddresses)
            {
                BasicHttpBinding binding = new BasicHttpBinding(BasicHttpSecurityMode.None);
                binding.Name = serviceType.Name;
                binding.CloseTimeout = new TimeSpan(0, 1, 0);
                binding.OpenTimeout = new TimeSpan(0, 1, 0);
                binding.ReceiveTimeout = new TimeSpan(0, 10, 0);
                binding.SendTimeout = new TimeSpan(0, 1, 0);
                binding.MaxReceivedMessageSize = Config.GetLongSetting(Setting.mix_wcfMaxReceivedMsgSize);
                binding.ReaderQuotas.MaxArrayLength = Config.GetIntSetting(Setting.mix_wcfMaxReceivedMsgSize);

                host.AddServiceEndpoint(serviceType.GetInterfaces()[0], binding, address);
            }

            return host;
        }
    }

    // NOTE: If you change the class name "MixOfferManagement" here, you must also update the reference to "MixOfferManagement" in Web.config and in the associated .svc file.
    //Set the compat mode to allow the WCF application mimic the ASPNET lifecycle. This will ensure that the current components like FEAPP will continue to work with our service
    [AspNetCompatibilityRequirements(RequirementsMode = AspNetCompatibilityRequirementsMode.Required)]
    public class MixTitleManagementV3 : IMixTitleManagementV3
    {
        public void ConfigureTitle(byte[] compressedXlast, bool noReload)
        {
            try
            {
                try
                {
                    Utilities.Instance.CheckAPI(MixTitleManagement.ConfigureTitleApiName);
                }
                catch (XboxWebInternalException ex)
                {
                    throw new XRLException(HResult.XONLINE_E_MIX_WEBSGVALIDATIONERROR, XEvent.Id.MIX_WEBSGVALIDATION_HEADERINVALID, string.Format("Partner Validation did not pass, WebSG header information missing {0}", ex.Message), false);
                }
                catch (XboxWebException ex)
                {
                    //catches incorrect IP information
                    throw new XRLException(HResult.XONLINE_E_MIX_WEBSGVALIDATIONERROR, XEvent.Id.MIX_WEBSGVALIDATION_HEADERINVALID, string.Format("Partner Validation did not pass, WebSG header information missing {0}", ex.Message), false);
                }
                catch (KeyNotFoundException ex)
                {
                    throw new XRLException(HResult.XONLINE_E_MIX_WEBSGVALIDATIONERROR, XEvent.Id.MIX_WEBSGVALIDATION_HEADERMISSING, string.Format("Partner Validation did not pass, WebSG header information invalid {0}", ex.Message), false);
                }

                TitleManager.ConfigureTitle(compressedXlast, noReload);
            }
            finally
            {
                // Logging API name and input parameters
                string appLog = string.Join(xonline.mix.common.MixConstants.AppLogSeparator, new string[]
                {
                    // API name
                    MixTitleManagement.ConfigureTitleApiName,
                    // Input params
                    compressedXlast.Length.ToString(),
                    noReload.ToString()
                });

                Xom.Log(XomAreaName.log, appLog);
            }
        }

        public void AddBaseVersion(uint titleId, int version, PlatformTypeV3 platformType, Guid betaGroup)
        {
            try
            {
                try
                {
                    Utilities.Instance.CheckAPI(MixTitleManagement.AddBaseVersionApiName);
                }
                catch (XboxWebInternalException ex)
                {
                    throw new XRLException(HResult.XONLINE_E_MIX_WEBSGVALIDATIONERROR, XEvent.Id.MIX_WEBSGVALIDATION_HEADERINVALID, string.Format("Partner Validation did not pass, WebSG header information missing {0}", ex.Message), false);
                }
                catch (XboxWebException ex)
                {
                    //catches incorrect IP information
                    throw new XRLException(HResult.XONLINE_E_MIX_WEBSGVALIDATIONERROR, XEvent.Id.MIX_WEBSGVALIDATION_HEADERINVALID, string.Format("Partner Validation did not pass, WebSG header information missing {0}", ex.Message), false);
                }
                catch (KeyNotFoundException ex)
                {
                    throw new XRLException(HResult.XONLINE_E_MIX_WEBSGVALIDATIONERROR, XEvent.Id.MIX_WEBSGVALIDATION_HEADERMISSING, string.Format("Partner Validation did not pass, WebSG header information invalid {0}", ex.Message), false);
                }

                TitleManager.AddBaseVersion(titleId, version, (PlatformType)platformType, betaGroup);
            }
            finally
            {
                // Logging API name and input parameters
                string appLog = string.Join(xonline.mix.common.MixConstants.AppLogSeparator, new string[]
                {
                    // API name
                    MixTitleManagement.AddBaseVersionApiName,
                    // Input params
                    titleId.ToString(),
                    version.ToString(),
                    platformType.ToString(),
                    betaGroup.ToString()
                });

                Xom.Log(XomAreaName.log, appLog);
            }
        }

        public void RemoveBaseVersion(uint titleId, int version, PlatformTypeV3 platformType, Guid betaGroup)
        {
            try
            {
                try
                {
                    Utilities.Instance.CheckAPI(MixTitleManagement.RemoveBaseVersionApiName);
                }
                catch (XboxWebInternalException ex)
                {
                    throw new XRLException(HResult.XONLINE_E_MIX_WEBSGVALIDATIONERROR, XEvent.Id.MIX_WEBSGVALIDATION_HEADERINVALID, string.Format("Partner Validation did not pass, WebSG header information missing {0}", ex.Message), false);
                }
                catch (XboxWebException ex)
                {
                    //catches incorrect IP information
                    throw new XRLException(HResult.XONLINE_E_MIX_WEBSGVALIDATIONERROR, XEvent.Id.MIX_WEBSGVALIDATION_HEADERINVALID, string.Format("Partner Validation did not pass, WebSG header information missing {0}", ex.Message), false);
                }
                catch (KeyNotFoundException ex)
                {
                    throw new XRLException(HResult.XONLINE_E_MIX_WEBSGVALIDATIONERROR, XEvent.Id.MIX_WEBSGVALIDATION_HEADERMISSING, string.Format("Partner Validation did not pass, WebSG header information invalid {0}", ex.Message), false);
                }

                TitleManager.RemoveBaseVersion(titleId, version, (PlatformType)platformType, betaGroup);
            }
            finally
            {
                // Logging API name and input parameters
                string appLog = string.Join(xonline.mix.common.MixConstants.AppLogSeparator, new string[]
                {
                    // API name
                    MixTitleManagement.RemoveBaseVersionApiName,
                    // Input params
                    titleId.ToString(),
                    version.ToString(),
                    platformType.ToString(),
                    betaGroup.ToString()
                });

                Xom.Log(XomAreaName.log, appLog);
            }
        }

        public TitleVersionsV3 GetTitleVersions(uint titleId)
        {
            TitleVersionsV3 versions = null;

            try
            {
                try
                {
                    Utilities.Instance.CheckAPI(MixTitleManagement.GetTitleVersionsApiName);
                }
                catch (XboxWebInternalException ex)
                {
                    throw new XRLException(HResult.XONLINE_E_MIX_WEBSGVALIDATIONERROR, XEvent.Id.MIX_WEBSGVALIDATION_HEADERINVALID, string.Format("Partner Validation did not pass, WebSG header information missing {0}", ex.Message), false);
                }
                catch (XboxWebException ex)
                {
                    //catches incorrect IP information
                    throw new XRLException(HResult.XONLINE_E_MIX_WEBSGVALIDATIONERROR, XEvent.Id.MIX_WEBSGVALIDATION_HEADERINVALID, string.Format("Partner Validation did not pass, WebSG header information missing {0}", ex.Message), false);
                }
                catch (KeyNotFoundException ex)
                {
                    throw new XRLException(HResult.XONLINE_E_MIX_WEBSGVALIDATIONERROR, XEvent.Id.MIX_WEBSGVALIDATION_HEADERMISSING, string.Format("Partner Validation did not pass, WebSG header information invalid {0}", ex.Message), false);
                }

                versions = TitleManager.GetTitleVersions(titleId);
            }
            finally
            {
                // Logging API name and input parameters
                string appLog = string.Join(xonline.mix.common.MixConstants.AppLogSeparator, new string[]
                {
                    // API name
                    MixTitleManagement.GetTitleVersionsApiName,
                    // Input params
                    titleId.ToString()
                });

                Xom.Log(XomAreaName.log, appLog);
            }

            return versions;
        }

        public void SetTitleUpdatePackages(uint titleId, int baseVersion, int updateVersion, PlatformTypeV3 consoleType, TitleUpdatePackageInformationV3 packageInformation, TitleUpdatePackageLocationV3 []updateLocations)
        {
            bool success=false;

            try
            {
                Utilities.Instance.CheckAPI(MixTitleManagement.SetTitleUpdatePackagesApiName);

                TitleManager.SetTitleUpdatePackages(titleId, baseVersion, updateVersion, (PlatformType)consoleType, packageInformation, TitleUpdatePackageLocation.ConvertAll(updateLocations));
                success=true;
            }
            finally
            {
                string appLog = string.Join(MixConstants.AppLogSeparator, new string[]
                {
                    // API name and version
                    MixTitleManagement.SetTitleUpdatePackagesApiName,
                    "V3",
                    // Execution success
                    success ? "1" : "0",
                    // Input params
                    titleId.ToString(),
                    baseVersion.ToString(),
                    updateVersion.ToString(),
                    ((byte)consoleType).ToString(),
                    (packageInformation!=null && packageInformation.ContentId!=null) ? string.Format("0x{0:X}", packageInformation.ContentId) : "",
                    (updateLocations!=null) ? updateLocations.Length.ToString() : ""
                });
                Xom.Log(XomAreaName.log, appLog);
            }
        }

        public uint[] GetBusinessPartnerTitleIDs(Guid businessPartnerID)
        {
            uint[] results = new uint[0];

            try
            {
                Utilities.Instance.CheckAPI(MixTitleManagement.GetBusinessPartnerTitleIDsApiName);

                results = TitleManager.GetBusinessPartnerTitleIDs(businessPartnerID);
            }
            finally
            {
                string appLog = string.Join(MixConstants.AppLogSeparator, new string[]
                {
                    // API name and version
                    MixTitleManagement.GetBusinessPartnerTitleIDsApiName,
                    "V3",
                    // Input params
                    businessPartnerID.ToString(),
                    // Output (how many returned)
                    results.Length.ToString()
                });
                Xom.Log(XomAreaName.log, appLog);
            }

            return results;
        }

        public void SetBusinessPartnerTitleIDs(Guid businessPartnerID, uint[] titleIDs)
        {
            bool success = false;

            try
            {
                Utilities.Instance.CheckAPI(MixTitleManagement.SetBusinessPartnerTitleIDsApiName);

                TitleManager.SetBusinessPartnerTitleIDs(businessPartnerID, titleIDs);
                success = true;
            }
            finally
            {
                string appLog = string.Join(MixConstants.AppLogSeparator, new string[]
                {
                    // API name and version
                    MixTitleManagement.SetBusinessPartnerTitleIDsApiName,
                    "V3",
                    success ? "1" : "0",
                    // Input params
                    businessPartnerID.ToString(),
                    titleIDs.Length.ToString(),
                });
                Xom.Log(XomAreaName.log, appLog);
            }
        }

        public void SetNetworkSecurityList(uint titleID, TitleEndpointV3[] allowedEndpoints)
        {
            bool success = false;

            try
            {
                Utilities.Instance.CheckAPI(MixTitleManagement.SetNetworkSecurityListApiName);
                TitleManager.SetNetworkSecurityList(titleID, TitleEndpoint.ConvertAll(allowedEndpoints));
                success = true;
            }
            finally
            {
                string appLog = string.Join(MixConstants.AppLogSeparator, new string[]
                {
                    // API name and version
                    MixTitleManagement.SetNetworkSecurityListApiName,
                    "V3",
                    success ? "1" : "0",
                    // Input params
                    titleID.ToString(),
                    allowedEndpoints.Length.ToString(),
                });
                Xom.Log(XomAreaName.log, appLog);
            }
        }

        public TitleEndpointInfoV3[] GetNetworkSecurityList(uint titleID, bool bFullHistory)
        {
            TitleEndpointInfoV3[] infos = new TitleEndpointInfoV3[0];

            try
            {
                Utilities.Instance.CheckAPI(MixTitleManagement.GetNetworkSecurityList);
                infos = TitleEndpointInfo.ConvertAll(TitleManager.GetNetworkSecurityList(titleID, bFullHistory));
            }
            finally
            {
                string appLog = string.Join(MixConstants.AppLogSeparator, new string[]
                {
                    // API name and version
                    MixTitleManagement.GetNetworkSecurityList,
                    "V3",
                    // Input params
                    titleID.ToString(),
                    bFullHistory.ToString(),
                    // How many returned
                    infos.Length.ToString()
                });
                Xom.Log(XomAreaName.log, appLog);
            }

            return infos;
        }

        public TitleEndpointInfoV3[] GetNetworkSecurityListByAppliesTo(string appliesTo, bool bFullHistory)
        {
            TitleEndpointInfoV3[] infos = new TitleEndpointInfoV3[0];

            try
            {
                Utilities.Instance.CheckAPI(MixTitleManagement.GetNetworkSecurityListByAppliesTo);
                infos = TitleEndpointInfo.ConvertAll(TitleManager.GetNetworkSecurityListByAppliesTo(appliesTo, bFullHistory));
            }
            finally
            {
                string appLog = string.Join(MixConstants.AppLogSeparator, new string[]
                {
                    // API name and version
                    MixTitleManagement.GetNetworkSecurityList,
                    "V3",
                    // Input params
                    appliesTo,
                    bFullHistory.ToString(),
                    // How many returned
                    infos.Length.ToString()
                });
                Xom.Log(XomAreaName.log, appLog);
            }

            return infos;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\TitleManagement\Service\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\TitleManagement\Service\MixTitleManagementV2.svc.cs ===
using System;
using System.Collections.Generic;
using System.ServiceModel;
using System.ServiceModel.Activation;

using xonline.common.service;
using xonline.common.config;
using xonline.common.installer;
using xonline.common.mgmt;
using xonline.server.webcache.common;
using xonline.mix.common;
using xonline.mix.titlemanagement.contract.v2;

namespace xonline.mix.titlemanagement.service.v2
{
    public class TitleMgmtHostFactory : ServiceHostFactory
    {
        protected override ServiceHost CreateServiceHost(Type serviceType, Uri[] baseAddresses)
        {
            ServiceHost host = new ServiceHost(serviceType, baseAddresses);

            foreach (Uri address in baseAddresses)
            {
                BasicHttpBinding binding = new BasicHttpBinding(BasicHttpSecurityMode.None);
                binding.Name = serviceType.Name;
                binding.CloseTimeout = new TimeSpan(0, 1, 0);
                binding.OpenTimeout = new TimeSpan(0, 1, 0);
                binding.ReceiveTimeout = new TimeSpan(0, 10, 0);
                binding.SendTimeout = new TimeSpan(0, 1, 0);
                binding.MaxReceivedMessageSize = Config.GetLongSetting(Setting.mix_wcfMaxReceivedMsgSize);
                binding.ReaderQuotas.MaxArrayLength = Config.GetIntSetting(Setting.mix_wcfMaxReceivedMsgSize);

                host.AddServiceEndpoint(serviceType.GetInterfaces()[0], binding, address);
            }

            return host;
        }
    }

    // NOTE: If you change the class name "MixOfferManagement" here, you must also update the reference to "MixOfferManagement" in Web.config and in the associated .svc file.
    //Set the compat mode to allow the WCF application mimic the ASPNET lifecycle. This will ensure that the current components like FEAPP will continue to work with our service
    [AspNetCompatibilityRequirements(RequirementsMode = AspNetCompatibilityRequirementsMode.Required)]
    public class MixTitleManagementV2 : IMixTitleManagementV2
    {
        public void ConfigureTitle(byte[] compressedXlast, bool noReload)
        {
            try
            {
                try
                {
                    Utilities.Instance.CheckAPI(MixTitleManagement.ConfigureTitleApiName);
                }
                catch (XboxWebInternalException ex)
                {
                    throw new XRLException(HResult.XONLINE_E_MIX_WEBSGVALIDATIONERROR, XEvent.Id.MIX_WEBSGVALIDATION_HEADERINVALID, string.Format("Partner Validation did not pass, WebSG header information missing {0}", ex.Message), false);
                }
                catch (XboxWebException ex)
                {
                    //catches incorrect IP information
                    throw new XRLException(HResult.XONLINE_E_MIX_WEBSGVALIDATIONERROR, XEvent.Id.MIX_WEBSGVALIDATION_HEADERINVALID, string.Format("Partner Validation did not pass, WebSG header information missing {0}", ex.Message), false);
                }
                catch (KeyNotFoundException ex)
                {
                    throw new XRLException(HResult.XONLINE_E_MIX_WEBSGVALIDATIONERROR, XEvent.Id.MIX_WEBSGVALIDATION_HEADERMISSING, string.Format("Partner Validation did not pass, WebSG header information invalid {0}", ex.Message), false);
                }

                TitleManager.ConfigureTitle(compressedXlast, noReload);
            }
            finally
            {
                // Logging API name and input parameters
                string appLog = string.Join(xonline.mix.common.MixConstants.AppLogSeparator, new string[]
                {
                    // API name
                    MixTitleManagement.ConfigureTitleApiName,
                    // Input params
                    compressedXlast.Length.ToString(),
                    noReload.ToString()
                });

                Xom.Log(XomAreaName.log, appLog);
            }
        }

        public void AddBaseVersion(uint titleId, int version, PlatformTypeV2 platformType, Guid betaGroup)
        {
            try
            {
                try
                {
                    Utilities.Instance.CheckAPI(MixTitleManagement.AddBaseVersionApiName);
                }
                catch (XboxWebInternalException ex)
                {
                    throw new XRLException(HResult.XONLINE_E_MIX_WEBSGVALIDATIONERROR, XEvent.Id.MIX_WEBSGVALIDATION_HEADERINVALID, string.Format("Partner Validation did not pass, WebSG header information missing {0}", ex.Message), false);
                }
                catch (XboxWebException ex)
                {
                    //catches incorrect IP information
                    throw new XRLException(HResult.XONLINE_E_MIX_WEBSGVALIDATIONERROR, XEvent.Id.MIX_WEBSGVALIDATION_HEADERINVALID, string.Format("Partner Validation did not pass, WebSG header information missing {0}", ex.Message), false);
                }
                catch (KeyNotFoundException ex)
                {
                    throw new XRLException(HResult.XONLINE_E_MIX_WEBSGVALIDATIONERROR, XEvent.Id.MIX_WEBSGVALIDATION_HEADERMISSING, string.Format("Partner Validation did not pass, WebSG header information invalid {0}", ex.Message), false);
                }

                TitleManager.AddBaseVersion(titleId, version, (PlatformType)platformType, betaGroup);
            }
            finally
            {
                // Logging API name and input parameters
                string appLog = string.Join(xonline.mix.common.MixConstants.AppLogSeparator, new string[]
                {
                    // API name
                    MixTitleManagement.AddBaseVersionApiName,
                    // Input params
                    titleId.ToString(),
                    version.ToString(),
                    platformType.ToString(),
                    betaGroup.ToString()
                });

                Xom.Log(XomAreaName.log, appLog);
            }
        }

        public void RemoveBaseVersion(uint titleId, int version, PlatformTypeV2 platformType, Guid betaGroup)
        {
            try
            {
                try
                {
                    Utilities.Instance.CheckAPI(MixTitleManagement.RemoveBaseVersionApiName);
                }
                catch (XboxWebInternalException ex)
                {
                    throw new XRLException(HResult.XONLINE_E_MIX_WEBSGVALIDATIONERROR, XEvent.Id.MIX_WEBSGVALIDATION_HEADERINVALID, string.Format("Partner Validation did not pass, WebSG header information missing {0}", ex.Message), false);
                }
                catch (XboxWebException ex)
                {
                    //catches incorrect IP information
                    throw new XRLException(HResult.XONLINE_E_MIX_WEBSGVALIDATIONERROR, XEvent.Id.MIX_WEBSGVALIDATION_HEADERINVALID, string.Format("Partner Validation did not pass, WebSG header information missing {0}", ex.Message), false);
                }
                catch (KeyNotFoundException ex)
                {
                    throw new XRLException(HResult.XONLINE_E_MIX_WEBSGVALIDATIONERROR, XEvent.Id.MIX_WEBSGVALIDATION_HEADERMISSING, string.Format("Partner Validation did not pass, WebSG header information invalid {0}", ex.Message), false);
                }

                TitleManager.RemoveBaseVersion(titleId, version, (PlatformType)platformType, betaGroup);
            }
            finally
            {
                // Logging API name and input parameters
                string appLog = string.Join(xonline.mix.common.MixConstants.AppLogSeparator, new string[]
                {
                    // API name
                    MixTitleManagement.RemoveBaseVersionApiName,
                    // Input params
                    titleId.ToString(),
                    version.ToString(),
                    platformType.ToString(),
                    betaGroup.ToString()
                });

                Xom.Log(XomAreaName.log, appLog);
            }
        }

        public TitleVersionsV2 GetTitleVersions(uint titleId)
        {
            TitleVersionsV2 versions = null;

            try
            {
                try
                {
                    Utilities.Instance.CheckAPI(MixTitleManagement.GetTitleVersionsApiName);
                }
                catch (XboxWebInternalException ex)
                {
                    throw new XRLException(HResult.XONLINE_E_MIX_WEBSGVALIDATIONERROR, XEvent.Id.MIX_WEBSGVALIDATION_HEADERINVALID, string.Format("Partner Validation did not pass, WebSG header information missing {0}", ex.Message), false);
                }
                catch (XboxWebException ex)
                {
                    //catches incorrect IP information
                    throw new XRLException(HResult.XONLINE_E_MIX_WEBSGVALIDATIONERROR, XEvent.Id.MIX_WEBSGVALIDATION_HEADERINVALID, string.Format("Partner Validation did not pass, WebSG header information missing {0}", ex.Message), false);
                }
                catch (KeyNotFoundException ex)
                {
                    throw new XRLException(HResult.XONLINE_E_MIX_WEBSGVALIDATIONERROR, XEvent.Id.MIX_WEBSGVALIDATION_HEADERMISSING, string.Format("Partner Validation did not pass, WebSG header information invalid {0}", ex.Message), false);
                }

                versions = TitleManager.GetTitleVersions(titleId);
            }
            finally
            {
                // Logging API name and input parameters
                string appLog = string.Join(xonline.mix.common.MixConstants.AppLogSeparator, new string[]
                {
                    // API name
                    MixTitleManagement.GetTitleVersionsApiName,
                    // Input params
                    titleId.ToString()
                });

                Xom.Log(XomAreaName.log, appLog);
            }

            return versions;
        }

        public void SetTitleUpdatePackages(uint titleId, int baseVersion, int updateVersion, PlatformTypeV2 consoleType, TitleUpdatePackageInformationV2 packageInformation, TitleUpdatePackageLocationV2 []updateLocations)
        {
            bool success=false;

            try
            {
                Utilities.Instance.CheckAPI(MixTitleManagement.SetTitleUpdatePackagesApiName);

                TitleManager.SetTitleUpdatePackages(titleId, baseVersion, updateVersion, (PlatformType)consoleType, packageInformation, TitleUpdatePackageLocation.ConvertAll(updateLocations));
                success=true;
            }
            finally
            {
                string appLog = string.Join(MixConstants.AppLogSeparator, new string[]
                {
                    // API name and version
                    MixTitleManagement.SetTitleUpdatePackagesApiName,
                    "V2",
                    // Execution success
                    success ? "1" : "0",
                    // Input params
                    titleId.ToString(),
                    baseVersion.ToString(),
                    updateVersion.ToString(),
                    ((byte)consoleType).ToString(),
                    (packageInformation!=null && packageInformation.ContentId!=null) ? string.Format("0x{0:X}", packageInformation.ContentId) : "",
                    (updateLocations!=null) ? updateLocations.Length.ToString() : ""
                });
                Xom.Log(XomAreaName.log, appLog);
            }
        }

        public void SetTitleFacebookAppId(uint titleId, string appId)
        {
            bool success = false;

            try
            {
                Utilities.Instance.CheckAPI(MixTitleManagement.SetTitleFacebookAppId);
                TitleManager.SetTitleFacebookAppId(titleId, appId);
                success = true;
            }
            finally
            {
                string appLog = string.Join(MixConstants.AppLogSeparator, new string[]
                    {
                        MixTitleManagement.SetTitleFacebookAppId,
                        "V2",
                        // Execution success
                        success ? "1" : "0",
                        // Input params
                        titleId.ToString(),
                        appId.ToString()
                    }
                    );
                Xom.Log(XomAreaName.log, appLog);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\TitleManagement\Service\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\TitleManagement\Service\TitleManagementHelpers.cs ===
using System;
using System.Text;
using System.Reflection;
using System.Collections;
using System.Globalization;

using xonline.common.livetitleconfig;
using xonline.common.xlastutil;
using xonline.common.config;
using xonline.common.title;
using xonline.common.service;
using xonline.mix.titlemanagement.contract;
using xonline.tools.framework;

namespace xonline.mix.titlemanagement.service
{
    /// <summary>
    /// This is a local copy of XLast helper which has functionality related to C&G. 
    /// private\common\ingestionutils\xlastutil\xlastchecker.cs
    /// </summary>
    public class CGXLastHelper
    {
        /// <summary>
        /// This function checks the given xlast xml, parse it for the required nodes, and does the basic verification.
        /// This is mostly the list of checks, and actual checks are performed in XLastChecker.
        /// XLastChecker is at private\common\ingestionutils\xlastutil\xlastchecker.cs
        /// </summary>
        /// <param name="xlsp">XboxLiveSubmissionProject</param>
        /// <param name="ltc">LiveTitleConfig</param>
        /// <param name="validationInfo">validationInfo. Feel free to ignore this. it is a list of string outputs over the whole processing. I have kept it since it might be helpful in knowing what went wrong.</param>
        /// <returns>true/false based on success. If failed at some point, it will still try to continue checking other stuff so that we can get all the failures in one pass.</returns>
        /// <remarks>This function is checking bunch of stuff against LTC file. However LTC file is generated by this API from the same xlast, so essentially we are not doing anything new here.
        /// It is possible that there might be some default info in generated ltc, in which case we have to remove the check. e.g. we removed Achievements Check.
        /// </remarks>
        public static bool CheckXlast(XboxLiveSubmissionProject xlsp, LiveTitleConfig ltc, ref StringBuilder validationInfo)
        {
            bool validXlast = true;
            validationInfo.Append("Starting Validation\n");

            // Make sure we have valid parameters
            if ((xlsp == null) || (ltc == null) || (validationInfo == null))
            {
                validationInfo.Append("Invalid (null) Parameters passed.\n");
                return false;
            }

            if (xlsp.GameConfigProject == null)
            {
                validationInfo.Append("GameConfigProject passed is null\n");
                return false;
            }

            return validXlast;
        }

        /// <summary>
        /// Generates a LTC file from the given xml xlast.
        /// </summary>
        /// <param name="xlast">xlast file in xml form.</param>
        /// <param name="titleId">Title id</param>
        /// <returns>LiveTitleConfig object. We are not persisting this on disk as livetitle.exe used to do.</returns>
        public static LiveTitleConfig GenerateLiveTitleConfigFromXlast(string xlast, CTitleId titleId)
        {
            LiveTitleConfig ltc = null;

            //extract from npdb, deserialize, returns null if not present
            LiveTitleConfig existingLTC = LiveTitleConfig.Get(titleId.uiTitleId);
            string leaderboardServer = Config.GetSetting(Setting.mix_default_LeaderBoardServer);
            string matchServer = Config.GetSetting(Setting.mix_default_MatchServer);


            // TODO QUESTION
            // If we create newLTC with new lb/match servers will bad things happen??? What about the old ones???

            if (existingLTC != null)
            {
                //update the leaderboardconfigs in the TLC to synchronize with the new xlast
                ltc = existingLTC;

                LiveTitleConfig newLTC = LiveTitleConfig.GetLiveTitleConfigFromXlast(xlast, leaderboardServer, matchServer);

                ltc = LiveTitleConfig.UpdateLiveTitleConfigFromExisting(newLTC, ltc, leaderboardServer);

                ltc.AllowCrossPlatformPlay = newLTC.AllowCrossPlatformPlay;

                if (ltc == null)
                {
                    throw new Exception();
                }
            }
            else
            {
                ltc = LiveTitleConfig.GetLiveTitleConfigFromXlast(xlast, leaderboardServer, matchServer);
            }

            return ltc;
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\TitleManagement\Service\DataLayer.cs ===
/*--------------------------------------------------------------------------------------------------
 * Generally speaking, this file should contain the data layer for title group management MIX apis,
 * and not the business logic layer.
 * 
 * That said, it's sometimes hard to really seperate those because we have a lot of business
 * logic directly in the database. This is a best effort and nothing more.
 *------------------------------------------------------------------------------------------------*/

using System;
using System.Collections.Generic;
using System.Text;
using System.Reflection;
using System.Collections;
using System.Globalization;
using System.Data;
using System.Data.SqlClient;

using Microsoft.Webstore.WstClient;

using xonline.common.sql.webstore;
using xonline.common.config;
using xonline.common.service;
using xonline.common.sql.sqlclient;
using xonline.common.livetitleconfig;
using xonline.common.xlastutil;
using xonline.common.title;
using xonline.tools.framework;
using xonline.mix.titlemanagement.contract;

namespace xonline.mix.titlemanagement.service
{
    public class UodbTitleManagementDatabase
    {
        public static bool DoesTitleExist(uint titleId)
        {
            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.Partition = WstCommand.AnyPartition;
                ws.StoredProc = "dbo.p_svc_title_exists";

                ws.AddParameter(ParamType.INPUT, "@i_title_id", (int)titleId);
                ws.AddParameter(ParamType.RETVAL, "@RETVAL", 0);

                ws.ExecuteNonQuery();

                int retval = ws.GetIntParameter("@RETVAL");
                return (retval != 0);
            }
        }

        public static TitleVersions GetTitleVersions(uint titleId)
        {
            List<TitleVersionInstance> versions = new List<TitleVersionInstance>();

            IVirtualInterfaceInfo viInfo = xonline.common.config.Config.GetVirtualInterface(VirtualInterface.uodb, Site.main);
            string webstoreApplicationName = viInfo.WebstoreApp;

            using (WstConnection conn = new WstConnection(webstoreApplicationName))
            {
                conn.Open();

                //  Set up the command
                WstCommand cmd = new WstCommand(
                    "dbo.p_svc_get_title_versions",   //name of the stored procedure
                    conn,                             //connection
                    0,                                //there's always a partition 0
                    WstFailoverMode.PrimaryOnly
                    );

                cmd.CommandType = CommandType.StoredProcedure;
                cmd.PartitionType = WstPartitionType.Physical;
                cmd.Transaction = conn.BeginTransaction();

                cmd.Parameters.Add("@i_title_id", SqlDbType.Int).Value = (int)titleId;
                cmd.Parameters["@i_title_id"].Direction = ParameterDirection.Input;

                cmd.Parameters.Add("@i_base_version", SqlDbType.Int).Value = -1; //retrieve all versions
                cmd.Parameters["@i_base_version"].Direction = ParameterDirection.Input;

                cmd.Parameters.Add("@b_all_groups", SqlDbType.Bit).Value = 1; //retrieve all beta groups
                cmd.Parameters["@b_all_groups"].Direction = ParameterDirection.Input;

                WstDataReader verReader = cmd.ExecuteReader();

                //task: retrieve data
                //loop through result set
                int baseCol = verReader.GetOrdinal("i_base_version");
                int updateCol = verReader.GetOrdinal("i_update_version");
                int consoleTypeCol = verReader.GetOrdinal("ti_console_type_id");
                int betaGroupCol = verReader.GetOrdinal("uid_beta_group_id");

                while (verReader.Read())
                {
                    TitleVersionInstance version = new TitleVersionInstance(
                        titleId,
                        verReader.GetInt32(baseCol),
                        verReader.GetInt32(updateCol),
                        (PlatformType)verReader.GetByte(consoleTypeCol),
                        verReader.GetGuid(betaGroupCol));

                    versions.Add(version);
                }

                TitleVersions titleVersions = new TitleVersions();
                titleVersions.Versions = versions.ToArray();
                return titleVersions;
            }
        }

        //In addition to just inserting your row, this does a bunch of other crazy updates and may add additional rows.  See the sproc for details.
        public static void UpdateAndOrInsertTitleUpdatePackageInformation(uint titleId, int baseVersion, int updateVersion, PlatformType consoleType, TitleUpdatePackageInformation packageInformation)
        {
            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                for (int partition=0; partition<ws.PhysicalPartitions; ++partition)
                {
                    ws.ClearParameters();
                    ws.PhysicalPartition = partition;
                    ws.StoredProc = "dbo.p_svc_insert_title_update_packages";

                    ws.AddParameter(ParamType.INPUT, "@i_title_id", (int)titleId);
                    ws.AddParameter(ParamType.INPUT, "@i_title_base_version", baseVersion);
                    ws.AddParameter(ParamType.INPUT, "@i_title_update_version", updateVersion);
                    ws.AddParameter(ParamType.INPUT, "@ti_console_type_id", (byte)consoleType);
                    ws.AddParameter(ParamType.INPUT, "@i_package_size", packageInformation.PackageSize);
                    ws.AddParameter(ParamType.INPUT, "@i_install_size", packageInformation.InstallSize);
                    ws.AddParameter(ParamType.INPUT, "@vb_update_sym_key", packageInformation.UpdateSymmetricKey, packageInformation.UpdateSymmetricKey.Length);
                    ws.AddParameter(ParamType.INPUT, "@vb_public_key", packageInformation.PublicKey, packageInformation.PublicKey.Length);
                    if (packageInformation.ContentId!=null)
                    {
                        ws.AddParameter(ParamType.INPUT, "@b_content_id", packageInformation.ContentId, packageInformation.ContentId.Length);
                    }
                    else
                    {
                        //This should work but it does not.  Since the sproc has null as the default value for the parameter, we will instead simply not specify it.
                        //ws.AddParameterObject(ParamType.INPUT, "@b_content_id", System.DBNull.Value);
                    }
                    ws.AddParameter(ParamType.RETVAL, "@RETVAL", 0);

                    ws.ExecuteNonQuery();

                    uint hr = (uint)ws.GetIntParameter("@RETVAL");
                    if (hr!=0)
                    {
                        throw new XRLException(hr, XEvent.Id.MIX_TITLEMANAGEMENT_DATABASE_RETURN_ERROR, string.Format("p_svc_insert_title_update_packages returned HR=0x{0:X}", hr));
                    }
                }
            }
        }

        //This adds a row to t_title_versions for the magic livecontent hack group.
        public static void AddLiveContentTitleVersionHack(uint titleId, int baseVersion, int updateVersion, PlatformType consoleType)
        {
            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                for (int partition=0; partition<ws.PhysicalPartitions; ++partition)
                {
                    ws.ClearParameters();
                    ws.PhysicalPartition = partition;
                    ws.StoredProc = "dbo.p_svc_insert_title_versions";

                    ws.AddParameter(ParamType.INPUT, "@i_title_id", (int)titleId);
                    ws.AddParameter(ParamType.INPUT, "@i_base_version", baseVersion);
                    ws.AddParameter(ParamType.INPUT, "@i_new_version", updateVersion);
                    ws.AddParameter(ParamType.INPUT, "@ti_console_type_id", (byte)consoleType);
                    ws.AddParameter(ParamType.INPUT, "@i_version_flag", 1);
                    ws.AddParameter(ParamType.RETVAL, "@RETVAL", 0);

                    ws.ExecuteNonQuery();

                    uint retval = (uint)ws.GetIntParameter("@RETVAL");
                    if (retval!=0)
                    {
                        throw new XRLException(HResult.XONLINE_E_DATABASE_RESULT_ERROR, XEvent.Id.MIX_TITLEMANAGEMENT_DATABASE_RETURN_ERROR, string.Format("p_svc_insert_title_versions returned unexpected value: {0}", retval));
                    }
                }
            }
        }

        //In addition to just inserting your row, this does a bunch of other crazy updates and may add additional rows.  See the sproc for details.
        public static void UpdateAndOrInsertTitleUpdatePackageLocation(uint titleId, int baseVersion, int updateVersion, PlatformType consoleType, TitleUpdatePackageLocation packageLocation)
        {
            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                for (int partition=0; partition<ws.PhysicalPartitions; ++partition)
                {
                    ws.ClearParameters();
                    ws.PhysicalPartition = partition;
                    ws.StoredProc = "dbo.p_svc_insert_title_update_locations";

                    ws.AddParameter(ParamType.INPUT, "@i_title_id", (int)titleId);
                    ws.AddParameter(ParamType.INPUT, "@i_title_base_version", baseVersion);
                    ws.AddParameter(ParamType.INPUT, "@i_title_update_version", updateVersion);
                    ws.AddParameter(ParamType.INPUT, "@ti_console_type_id", (byte)consoleType);
                    ws.AddParameter(ParamType.INPUT, "@i_location_rank", packageLocation.Rank);
                    ws.AddParameter(ParamType.INPUT, "@vc_XRL", packageLocation.Xrl);
                    ws.AddParameter(ParamType.RETVAL, "@RETVAL", 0);

                    ws.ExecuteNonQuery();

                    uint hr = (uint)ws.GetIntParameter("@RETVAL");
                    if (hr!=0)
                    {
                        throw new XRLException(hr, XEvent.Id.MIX_TITLEMANAGEMENT_DATABASE_RETURN_ERROR, string.Format("p_svc_insert_title_update_locations returned HR=0x{0:X}", hr));
                    }
                }
            }
        }

        //returns a list of location ranks for a specfic update package
        public static int[] GetTitleUpdatePackageLocationRanks(uint titleId, int baseVersion, int updateVersion, PlatformType consoleType)
        {
            System.Collections.Generic.List<int> ranks = new System.Collections.Generic.List<int>();

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.Partition = WstCommand.AnyPartition;
                ws.StoredProc = "dbo.p_svc_get_title_update_location_ranks";

                ws.AddParameter(ParamType.INPUT, "@i_title_id", (int)titleId);
                ws.AddParameter(ParamType.INPUT, "@i_title_base_version", baseVersion);
                ws.AddParameter(ParamType.INPUT, "@i_title_update_version", updateVersion);
                ws.AddParameter(ParamType.INPUT, "@ti_console_type_id", (byte)consoleType);

                using (WstDataReader reader = ws.Execute())
                {
                    while(reader.Read())
                    {
                        ranks.Add((int)reader[0]);
                    }
                }
            }

            return ranks.ToArray();
        }

        //removes a specific update location
        public static void RemoveTitleUpdatePackageLocationRank(uint titleId, int baseVersion, int updateVersion, PlatformType consoleType, int rank)
        {
            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                for (int partition=0; partition<ws.PhysicalPartitions; ++partition)
                {
                    ws.ClearParameters();
                    ws.PhysicalPartition = partition;
                    ws.StoredProc = "dbo.p_svc_remove_title_update_location_rank";

                    ws.AddParameter(ParamType.INPUT, "@i_title_id", (int)titleId);
                    ws.AddParameter(ParamType.INPUT, "@i_title_base_version", baseVersion);
                    ws.AddParameter(ParamType.INPUT, "@i_title_update_version", updateVersion);
                    ws.AddParameter(ParamType.INPUT, "@ti_console_type_id", (byte)consoleType);
                    ws.AddParameter(ParamType.INPUT, "@i_location_rank", rank);

                    ws.ExecuteNonQuery();
                }
            }
        }
    };

    /// <summary>
    /// A local wrapper for CG. Can't use the stuff for title.cs since it gets compild in to livetitle.exe, so we have to copy the stuff here.
    /// </summary>
    public class CGTitleHelper
    {

        /// <summary>
        /// Todo: Should we use this by default?
        /// </summary>
        public static bool useTransactions = false;

        /// <summary>
        /// Adds a title specific feature data / product information to uodb.
        /// </summary>
        /// <param name="titleID"></param>
        /// <param name="titleName"></param>
        /// <param name="pi"></param>
        /// <param name="strLib"></param>
        /// <param name="procInfo"></param>
        public static void AddTitleFeatureData(uint titleID, string titleName, ProductInformation pi, StringLibrary strLib, ref StringBuilder procInfo)
        {
            if (pi == null)
                return;

            Hashtable bitflags = new Hashtable(30);

            bitflags.Add("camera", false);  //  <param required="yes" description="support camera?"/>
            bitflags.Add("coOp", false);  //  <param required="yes" description="support coop?"/>
            bitflags.Add("customSoundtrack", false);  //  <param required="yes" description="support custom soundtracks?"/>
            bitflags.Add("dolby51", false);  //  <param required="yes" description="support dolby 5.1?"/>
            bitflags.Add("hardDriveEnhanced", false);  //  <param required="yes" description="hard drive enhanced?"/>
            bitflags.Add("hardDriveRequired", false);  //  <param required="yes" description="hard drive required?"/>
            bitflags.Add("liveAware", false);  //  <param required="yes" description="support xbox live?"/>
            bitflags.Add("liveCoOp", false);  //  <param required="yes" description="support xbox live coop play?"/>
            bitflags.Add("liveClans", false);  //  <param required="yes" description="support xbox live clans?"/>
            bitflags.Add("liveDownloads", false);  //  <param required="yes" description="has live downloads?"/>
            bitflags.Add("liveFriends", false);  //  <param required="yes" description="support live friends?"/>
            bitflags.Add("liveMessaging", false);  //  <param required="yes" description="support live messaging?"/>
            bitflags.Add("liveMultiplayer", false);  //  <param required="yes" description="support live multiplayer?"/>
            bitflags.Add("liveScoreboard", false);  //  <param required="yes" description="support live scoreboard?"/>
            bitflags.Add("liveServiceProxy", false);  //  <param required="yes" description="uses a live service proxy?"/>
            bitflags.Add("liveStats", false);  //  <param required="yes" description="support live stats?"/>
            bitflags.Add("liveTournaments", false);  //  <param required="yes" description="support live tournaments?"/>
            bitflags.Add("liveVoice", false);  //  <param required="yes" description="support live voice?"/>
            bitflags.Add("liveVoiceMessaging", false);  //  <param required="yes" description="support live voice messaging?"/>
            bitflags.Add("memoryUnit", false);  //  <param required="yes" description="support memory unit?"/>
            bitflags.Add("multiplayerVersus", false);  //  <param required="yes" description="support multiplayer versus?"/>
            bitflags.Add("peripherals", false);  //  <param required="yes" description="support special peripherals?"/>
            bitflags.Add("systemLink", false);  //  <param required="yes" description="support systemlink?"/>
            bitflags.Add("premiumOffers", false);  //  <param required="yes" description="has premium offers?"/>
            bitflags.Add("userCreatableContent", false);  //  <param required="yes" description="support user creatable content?"/>
            bitflags.Add("xboxSupport", false);  //  <param required="yes" description="support xbox?"/>
            bitflags.Add("xbox2Support", false);  //  <param required="yes" description="support xbox 2?"/>


            if (pi.Feature != null)
            {
                foreach (Feature x in pi.Feature)
                {
                    if (bitflags[x.name] != null)
                    {
                        bitflags[x.name] = true;
                    }
                    else
                    {
                        // Hmmm, not good, the feature name doesn't match anything we know
                    }
                }
            }


            // insert title
            IVirtualInterfaceInfo viInfo = Config.GetVirtualInterface(VirtualInterface.uodb, Site.main);
            string webstoreApplicationName = viInfo.WebstoreApp;

            ArrayList paramlist = new ArrayList();
            SqlParameter sp = null;

            //for the UODB call
            sp = new SqlParameter("@i_title_id", SqlDbType.Int);
            sp.Value = (int)titleID;
            paramlist.Add(sp);

            sp = new SqlParameter("@vc_name", SqlDbType.NVarChar, 255);
            sp.Value = (string)titleName;
            paramlist.Add(sp);

            sp = new SqlParameter("@playersOffline", SqlDbType.Int);
            sp.Value = (int)pi.offlinePlayersMax;
            paramlist.Add(sp);

            sp = new SqlParameter("@playersSystemLink", SqlDbType.Int);
            sp.Value = (int)pi.systemLinkPlayersMax;
            paramlist.Add(sp);

            sp = new SqlParameter("@playersLive", SqlDbType.Int);
            sp.Value = (int)pi.livePlayersMax;
            paramlist.Add(sp);

            foreach (DictionaryEntry x in bitflags)
            {
                sp = new SqlParameter("@" + x.Key, SqlDbType.Bit);
                sp.Value = (bool)x.Value;
                paramlist.Add(sp);
            }

            ExecuteWebstoreNonQuery(webstoreApplicationName, paramlist, "dbo.p_svc_insert_title_features", ref procInfo);
        } // AddTitleFeatureData

        /// <summary>
        /// add title specific culture details to UODB from pi.
        /// </summary>
        /// <param name="titleID"></param>
        /// <param name="pi"></param>
        /// <param name="strLib"></param>
        /// <param name="procInfo"></param>
        public static void AddTitleCultureDetails(uint titleID, ProductInformation pi, StringLibrary strLib, ref StringBuilder procInfo)
        {
            if (pi == null)
                return;


            System.UInt16 titleNameId = 32768;

            IVirtualInterfaceInfo viInfo = Config.GetVirtualInterface(VirtualInterface.uodb, Site.main);
            string webstoreApplicationName = viInfo.WebstoreApp;

            //-----------------------------------------------------------------
            // This is fairly elaborate: the cultures member of StringLibrary has
            // been constructed as HashTable of ArrayLists  The top level HashTable
            // is keyed by language ID and the corresponding value is an ArrayList.
            // These ArrayLists contain the culture IDs that use the language
            // designated by the key value.
            //
            // The loop below uses this to first pull the translated text for a
            // particular language (outer loop) and then create a
            // t_title_culture_details record for each culture that uses that
            // language (inner loop).
            //
            foreach (DictionaryEntry x in strLib.cultures)
            {
                int languageID = (int)x.Key;

                string titleName = "";
                string sellText = "";
                string publisher = "";
                string developer = "";
                string genre = "";

                if (strLib.Exists(titleNameId, languageID))
                    titleName = strLib.GetString(titleNameId, languageID);
                if (strLib.Exists(pi.sellTextStringId, languageID))
                    sellText = strLib.GetString(pi.sellTextStringId, languageID);
                if (strLib.Exists(pi.publisherStringId, languageID))
                    publisher = strLib.GetString(pi.publisherStringId, languageID);
                if (strLib.Exists(pi.developerStringId, languageID))
                    developer = strLib.GetString(pi.developerStringId, languageID);
                if (strLib.Exists(pi.genreTextStringId, languageID))
                    genre = strLib.GetString(pi.genreTextStringId, languageID);

                ArrayList y = (ArrayList)x.Value;

                foreach (int cultureID in y)
                {
                    ArrayList paramlist = new ArrayList();
                    SqlParameter sp = null;

                    // write to UODB
                    sp = new SqlParameter("@i_title_id", SqlDbType.Int);
                    sp.Value = (int)titleID;
                    paramlist.Add(sp);

                    sp = new SqlParameter("@i_culture_id", SqlDbType.Int);
                    sp.Value = (int)cultureID;
                    paramlist.Add(sp);

                    sp = new SqlParameter("@vc_name", SqlDbType.NVarChar, 100);
                    sp.Value = titleName;
                    paramlist.Add(sp);

                    sp = new SqlParameter("@vc_sell_text", SqlDbType.NVarChar, 1000);
                    sp.Value = sellText;
                    paramlist.Add(sp);

                    sp = new SqlParameter("@vc_publisher", SqlDbType.NVarChar, 60);
                    sp.Value = publisher;
                    paramlist.Add(sp);

                    sp = new SqlParameter("@vc_developer", SqlDbType.NVarChar, 60);
                    sp.Value = developer;
                    paramlist.Add(sp);

                    sp = new SqlParameter("@vc_genre", SqlDbType.NVarChar, 60);
                    sp.Value = (string)genre;
                    paramlist.Add(sp);

                    ExecuteWebstoreNonQuery(webstoreApplicationName, paramlist, "dbo.p_svc_insert_title_culture_details", ref procInfo);
                }
            }
        } // AddTitleCultureDetails

        /// <summary>
        /// Add htdv data for a title in to UODB.
        /// </summary>
        /// <param name="titleID"></param>
        /// <param name="pi"></param>
        /// <param name="procInfo"></param>
        public static void AddTitleHdtvData(uint titleID, ProductInformation pi, ref StringBuilder procInfo)
        {
            if (pi == null || pi.HdtvMode == null)
                return;

            foreach (HdtvMode x in pi.HdtvMode)
            {
                // write to UODB
                IVirtualInterfaceInfo viInfo = Config.GetVirtualInterface(VirtualInterface.uodb, Site.main);
                string webstoreApplicationName = viInfo.WebstoreApp;

                ArrayList paramlist = new ArrayList();
                SqlParameter sp = null;

                //for the UODB call
                sp = new SqlParameter("@i_title_id", SqlDbType.Int);
                sp.Value = (int)titleID;
                paramlist.Add(sp);

                sp = new SqlParameter("@i_HDTVsystem_id", SqlDbType.Int);
                sp.Value = (int)x.hdtvSystemId;
                paramlist.Add(sp);

                sp = new SqlParameter("@i_HDTVmode_id", SqlDbType.Int);
                sp.Value = (int)x.hdtvId;
                paramlist.Add(sp);

                ExecuteWebstoreNonQuery(webstoreApplicationName, paramlist, "dbo.p_svc_insert_title_hdtv_mode", ref procInfo);
            }

        } // AddTitleHdtvData

        /// <summary>
        /// Add rating data for a title in to UODB.
        /// </summary>
        /// <param name="titleID"></param>
        /// <param name="pi"></param>
        /// <param name="procInfo"></param>
        public static void AddTitleRatingData(uint titleID, ProductInformation pi, ref StringBuilder procInfo)
        {
            if (pi == null)
            {
                pi = new ProductInformation();
            }

            if (pi.Rating != null)
            {
                foreach (Rating x in pi.Rating)
                {
                    // write to UODB
                    IVirtualInterfaceInfo viInfo = Config.GetVirtualInterface(VirtualInterface.uodb, Site.main);
                    string webstoreApplicationName = viInfo.WebstoreApp;

                    ArrayList paramlist = new ArrayList();
                    SqlParameter sp = null;

                    //for the UODB call
                    sp = new SqlParameter("@i_title_id", SqlDbType.Int);
                    sp.Value = (int)titleID;
                    paramlist.Add(sp);

                    sp = new SqlParameter("@i_rating_system_id", SqlDbType.Int);
                    sp.Value = (int)x.ratingSystemId;
                    paramlist.Add(sp);

                    sp = new SqlParameter("@i_rating_id", SqlDbType.Int);
                    sp.Value = (int)x.ratingId;
                    paramlist.Add(sp);

                    ExecuteWebstoreNonQuery(webstoreApplicationName, paramlist, "dbo.p_svc_insert_title_rating", ref procInfo);
                }
            }
        } // AddTitleRatingData

        /// <summary>
        /// Add a genere data for a title in to UODB.
        /// </summary>
        /// <param name="titleID"></param>
        /// <param name="pi"></param>
        /// <param name="procInfo"></param>
        public static void AddTitleGenreData(uint titleID, ProductInformation pi, ref StringBuilder procInfo)
        {
            ArrayList paramlist = null;
            SqlParameter sp = null;

            if (pi == null)  // $REVIEW (michion): Without a ProductInformation node, there's really nothing
                return;      // we can do... so should we remove call p_svc_clear_title_genres?  Or is it
            // really an invalid case when pi is null?

            // N.B.
            // Unlike other p_svc_insert_title_* sprocs, p_svc_insert_title_genre does not UPDATE existing
            // records in t_title_genres if they exist for the title ID.  This is because the records in
            // this table are chained together by a parent-child relationship established by the genre ID
            // (which makes it impractical to try to update a chain when a genre ID changes because the
            // chain for the new genre will likely be different than the original one).  Accordingly, it
            // is necessary to use a separate sproc (p_svc_cleare_title_genres) to remove all records based
            // on their title ID before insert new/updated ones.


            // Get UODB connection info
            IVirtualInterfaceInfo viInfo = Config.GetVirtualInterface(VirtualInterface.uodb, Site.main);
            string webstoreApplicationName = viInfo.WebstoreApp;

            // Wipe existing title genre info in the UODB and PCDB
            paramlist = new ArrayList();
            sp = new SqlParameter("@i_title_id", SqlDbType.Int);
            sp.Value = (int)titleID;
            paramlist.Add(sp);
            ExecuteWebstoreNonQuery(webstoreApplicationName, paramlist, "dbo.p_svc_clear_title_genres", ref procInfo);

            //---------------------------------------------------------------------
            // Now create record(s) for the genre's found in the ProductInformation
            // NOTE: There's a corner case where NO genre's are specified, in which
            // case the pi.Genre collection won't exist (will be null instead of
            // being empty) so we must protect the loop below.
            //
            if (pi.Genre != null)
            {
                foreach (Genre x in pi.Genre)
                {
                    paramlist = new ArrayList();

                    //for the UODB call
                    sp = new SqlParameter("@i_title_id", SqlDbType.Int);
                    sp.Value = (int)titleID;
                    paramlist.Add(sp);

                    sp = new SqlParameter("@i_genre_id", SqlDbType.Int);
                    sp.Value = (int)x.genreId;
                    paramlist.Add(sp);
                    ExecuteWebstoreNonQuery(webstoreApplicationName, paramlist, "dbo.p_svc_insert_title_genre", ref procInfo);
                }
            }
        } // AddTitleGenreData

        #region Title Creating Methods

        //task: add stringbuilder to get detailed log info...
        /// <summary>
        /// C&G specific implementation of Create title. Original version is in title.cs under livetitle.exe.
        /// </summary>
        /// <param name="xlsp">XboxLiveSubmissionProject</param>
        /// <param name="ltc">LiveTitleConfig</param>
        /// <param name="baseVersion">base version to be used for the first time.</param>
        /// <param name="processingInfo">string builder to store more info.</param>
        public static void CreateNew(
            XboxLiveSubmissionProject xlsp,
            LiveTitleConfig ltc,
            ref StringBuilder processingInfo)
        {
            LocalizedStrings strings = null;
            string titleName = string.Empty;
            uint titleID = 0;

            if (xlsp == null)
                throw new ArgumentException("XboxLiveSubmissionProject passed to Title.CreateNew() was null");

            if (xlsp.GameConfigProject == null && xlsp.MarketplaceConfigProject == null)
                throw new ArgumentException("XboxLiveSubmissionProject passed to Title.CreateNew() has null GameConfigProject And MarketplaceConfigProject");

            // Are we creating a game title or a marketplace only title?
            if (xlsp.GameConfigProject != null)
            {
                strings = xlsp.GameConfigProject.LocalizedStrings;
                titleName = xlsp.GameConfigProject.titleName;
                titleID = UInt32.Parse(xlsp.GameConfigProject.titleId.Substring(2), NumberStyles.HexNumber);
            }
            
            if (titleName == "")
            {
                throw new ArgumentException("Title name must be valid.");
            }

            if (strings == null)
            {
                throw new ArgumentException("LocalizedStrings element not found in the Title configuration passed to Title.CreateNew()");
            }

            if (!CreateNewTitleUODBandPCDB(titleID, xlsp, ltc, ref processingInfo))
            {
                throw new Exception("CreateNewTitleUODBandPCDB failed: " + processingInfo.ToString());
            }

            processingInfo.Length = 0;
            processingInfo.Append("Begin NPDB Deploy.");

            if (!NPDBCreateTitleStrings(titleID, strings, ref processingInfo))
            {
                throw new Exception("NPDBCreateTitleStrings failed: " + processingInfo.ToString());
            }

            processingInfo.Length = 0;
            processingInfo.Append("Begin WebDB deploy.");

            if (!CreateNewTitleWebDB(titleID, strings, ref processingInfo))
            {
                throw new Exception("CreateNewTitleWebDB failed: " + processingInfo.ToString());
            }
        } // CreateNew


        /// <summary>
        /// Insert the titile information in UODB. //TODO: Should we change the method name to InsertTitleInfoToUODB, since there is no more PCDB?
        /// </summary>
        /// <param name="titleID"></param>
        /// <param name="xlsp"></param>
        /// <param name="ltc"></param>
        /// <param name="baseVersion"></param>
        /// <param name="procInfo"></param>
        /// <returns></returns>
        public static bool CreateNewTitleUODBandPCDB(
            uint titleID,
            XboxLiveSubmissionProject xlsp,
            LiveTitleConfig ltc,
            ref StringBuilder procInfo)
        {

            bool returnValue = true;
            ConsoleTypeEnum[] consoleTypes = null;

            LocalizedStrings strings = null;
            Privilege[] privileges = null;
            ProductInformation pi = null;
            Achievements achievements = null;
            string titleName = string.Empty;
            ulong titleType = 0;

            if (xlsp == null)
            {
                throw new ArgumentException("XboxLiveSubmissionProject passed to Title.CreateNewTitleUODBandPCDB() was null");
            }

            // Are we creating a game title or a marketplace only title?
            if (xlsp.GameConfigProject != null)
            {
                strings = xlsp.GameConfigProject.LocalizedStrings;
                privileges = xlsp.GameConfigProject.Privileges;
                pi = xlsp.GameConfigProject.ProductInformation;
                achievements = xlsp.GameConfigProject.Achievements;
                titleName = xlsp.GameConfigProject.titleName;
                titleType = xlsp.GameConfigProject.titleType;

                if (pi.Platform != null && pi.Platform.Length != 0)
                {
                    consoleTypes = new ConsoleTypeEnum[pi.Platform.Length];
                    for (int i = 0; i < pi.Platform.Length; ++i)
                    {
                        consoleTypes[i] = (ConsoleTypeEnum)(pi.Platform[i].id);
                    }
                }
                else
                {
                    consoleTypes = new ConsoleTypeEnum[1] { ConsoleTypeEnum.Xenon };
                }
            }

            try
            {
                #region Add Game Title to UODB

                procInfo.Append("Add Title to UODB - Starting");

                ArrayList versions = GetTitleVersions(titleID, ref procInfo);

                bool AllowCrossPlatformPlay = ltc == null ? false : ltc.AllowCrossPlatformPlay;

                // No longer is this optional, due to new per-title 5x5 work.
                // t_title_info
                // Row Missing               Legacy
                // f_requires_activation=0   Per-title 5x5
                // f_requires_activation=1   SSA
                // 
                bool PcServerSideActivation = false;
                if (pi.Feature != null)
                {
                    foreach (Feature x in pi.Feature)
                    {
                        if (x.name == "pcServerSideActivation")
                        {
                            PcServerSideActivation = x.enabled;
                        }
                    }
                }
                if (PcServerSideActivation == true)
                {
                    procInfo.Append("Title requires server-side activation");
                }

                //the sp that adds titles will add version 0 if it's not there
                // so we only want to call this function with 0 if the title completely new
                if (versions.Count == 0)
                {
                    //throw new Exception("No version found for this title. User AddBaseVersion API to add the version before calling this.");
                    ////add the title - always starts with version 0
                    AddTitleID(titleID, 0, consoleTypes, AllowCrossPlatformPlay, PcServerSideActivation, ref procInfo);
                    //procInfo.Append("Added New Xenon Title to UODB - Title");
                }
                else
                {
                    //add the title - one of the base versions
                    AddTitleID(titleID, ((CGTitleVersion)versions[0]).Base, consoleTypes, AllowCrossPlatformPlay, PcServerSideActivation, ref procInfo);
                    procInfo.Append("Added Existing Xenon Title to UODB - Title");
                }

                StringLibrary strLib = new StringLibrary(strings);
                if (strLib.ErrorsDetected())
                {
                    throw new Exception("String data could not be loaded: " + strLib.ErrorText());
                }

                ReferenceData refData = new ReferenceData(pi);
                if (refData.ErrorsDetected())
                {
                    throw new Exception("Reference data could not be loaded: " + refData.ErrorText());
                }

                /*===================================
                 * Please note: This might need to be deleted. We may not get the data from golden gate.
                 * Commented out the sections which we are not going to receive. Refer to mail from James jacoby.
                 ==================================*/
                AddTitleCultureDetails(titleID, pi, strLib, ref procInfo);
                //AddTitleFeatureData(titleID, titleName, pi, strLib, ref procInfo);
                AddTitleHdtvData(titleID, pi, ref procInfo);
                //AddTitleRatingData(titleID, pi, ref procInfo);
                //AddTitleGenreData(titleID, pi, ref procInfo);

                if (ltc != null)
                {
                    //alternate title ids
                    AddAltTitleInfo(ltc, ref procInfo);
                    procInfo.Append("Added Title to UODB - AltTitleID");

                    //add bounty
                    //task: can we "unbounty" a title?
                    if (ltc.BountyExempt)
                    {
                        UODBAddBountyTitle(titleID, ref procInfo);
                        procInfo.Append("Added Title to UODB - Bounty Exempt");
                    }
                }

                #endregion

                #region Add Title Privileges

                if ((privileges != null) && (privileges.Length > 0))
                {
                    procInfo.Append("Add Title to UODB - Privileges");

                    foreach (Privilege privilege in privileges)
                    {
                        AddPrivilege(titleID, privilege.name, ref procInfo);
                    }
                }

                #endregion

                procInfo.Append("Add Title to UODB - Completed");
            }
            catch (Exception e)
            {
                returnValue = false;
                procInfo.Append("Error occurred in creating title: " + e.Message + "  STACK: " + e.StackTrace);
            }

            return returnValue;
        }

        /// <summary>
        /// Add Privilege info in to UODB. Overload for Privilege Name.
        /// </summary>
        /// <param name="titleID"></param>
        /// <param name="privilegeName"></param>
        /// <param name="procInfo"></param>
        public static void AddPrivilege(uint titleID, string privilegeName, ref StringBuilder procInfo)
        {
            FieldInfo fieldInfo = typeof(XOn).GetField(privilegeName);

            if (fieldInfo == null)
                throw new Exception("No such privilege '" + privilegeName + "'");
            else
            {
                byte privilegeId = (byte)fieldInfo.GetRawConstantValue();
                AddPrivilege(titleID, privilegeId, ref procInfo);
            }
        }

        /// <summary>
        /// Add privilege info to UODB. Overload for privilege ID.
        /// </summary>
        /// <param name="titleID"></param>
        /// <param name="privilegeId"></param>
        /// <param name="procInfo"></param>
        public static void AddPrivilege(uint titleID, byte privilegeId, ref StringBuilder procInfo)
        {
            IVirtualInterfaceInfo viInfo = Config.GetVirtualInterface(VirtualInterface.uodb, Site.main);
            string webstoreApplicationName = viInfo.WebstoreApp;

            string sproc = "dbo.p_svc_set_title_privilege";
            ArrayList paramlist = new ArrayList();
            SqlParameter sp = null;

            sp = new SqlParameter("@i_title_id", SqlDbType.Int);
            sp.Value = (int)titleID;
            paramlist.Add(sp);

            // privilege
            sp = new SqlParameter("@ti_privilege_id", SqlDbType.TinyInt);
            sp.Value = privilegeId;
            paramlist.Add(sp);

            ExecuteWebstoreNonQuery(webstoreApplicationName, paramlist, sproc, ref procInfo);
        }

        /// <summary>
        /// Remove privilege info to UODB. Overload for privilege ID.
        /// </summary>
        /// <param name="titleID"></param>
        /// <param name="privilegeId"></param>
        /// <param name="procInfo"></param>
        public static void RemovePrivilege(uint titleID, byte privilegeId, ref StringBuilder procInfo)
        {
            IVirtualInterfaceInfo viInfo = Config.GetVirtualInterface(VirtualInterface.uodb, Site.main);
            string webstoreApplicationName = viInfo.WebstoreApp;

            string sproc = "dbo.p_svc_remove_title_privilege";
            ArrayList paramlist = new ArrayList();
            SqlParameter sp = null;

            sp = new SqlParameter("@i_title_id", SqlDbType.Int);
            sp.Value = (int)titleID;
            paramlist.Add(sp);

            // privilege
            sp = new SqlParameter("@ti_privilege_id", SqlDbType.TinyInt);
            sp.Value = privilegeId;
            paramlist.Add(sp);

            ExecuteWebstoreNonQuery(webstoreApplicationName, paramlist, sproc, ref procInfo);
        }

        //task: REVIEW whether this works for multiple partition UODB config...
        /// <summary>
        /// Add Title Id to UODB. This also handles the addbaseversion call.
        /// </summary>
        /// <param name="titleID"></param>
        /// <param name="initialVer"></param>
        /// <param name="consoleTypes"></param>
        /// <param name="allowCrossPlatformPlay"></param>
        /// <param name="pcServerSideActivation"></param>
        /// <param name="procInfo"></param>
        public static void AddTitleID(uint titleID, int initialVer, ConsoleTypeEnum[] consoleTypes, bool allowCrossPlatformPlay, bool? pcServerSideActivation, ref StringBuilder procInfo)
        {
            // insert title
            //it's weird, but we're supposed to get the app name from the config...
            //how often are we going to change the appname?
            IVirtualInterfaceInfo viInfo = Config.GetVirtualInterface(VirtualInterface.uodb, Site.main);
            string webstoreApplicationName = viInfo.WebstoreApp;

            foreach (ConsoleTypeEnum consoleType in consoleTypes)
            {
                ArrayList paramlist = new ArrayList();
                SqlParameter sp = null;

                //for the UODB call
                sp = new SqlParameter("@i_title_id", SqlDbType.Int);
                sp.Value = (int)titleID;
                paramlist.Add(sp);

                sp = new SqlParameter("@i_initial_version", SqlDbType.Int);
                sp.Value = initialVer;
                paramlist.Add(sp);

                sp = new SqlParameter("@ti_console_type_id", SqlDbType.TinyInt);
                sp.Value = (byte)consoleType;
                paramlist.Add(sp);

                // @@@kgoodier: Hack for PC titles only; this should be refactored if we 
                // extend title activation to other platforms
                if (consoleType == ConsoleTypeEnum.PC &&
                    pcServerSideActivation != null)
                {
                    sp = new SqlParameter("@f_requires_activation", SqlDbType.Bit);
                    sp.Value = pcServerSideActivation;
                    paramlist.Add(sp);
                }

                //t_titles, t_title_versions, t_title_info, t_trust_constants
                ExecuteWebstoreNonQuery(webstoreApplicationName, paramlist, "dbo.p_svc_insert_titles", ref procInfo);
            }

            //
            //  If more than one console type is indicated, set the XPRIVILEGE_CROSS_PLATFORM_MULTIPLAYER
            //  privilege.
            //

            if (true)
            {
                ArrayList paramlist = new ArrayList();
                SqlParameter sp = null;

                string sproc = (consoleTypes.Length > 1 && allowCrossPlatformPlay ? "dbo.p_svc_set_title_privilege" : "dbo.p_svc_remove_title_privilege");

                //
                //  UODB
                //

                // title id
                sp = new SqlParameter("@i_title_id", SqlDbType.Int);
                sp.Value = (int)titleID;
                paramlist.Add(sp);

                // privilege
                sp = new SqlParameter("@ti_privilege_id", SqlDbType.TinyInt);
                sp.Value = XOn.XPRIVILEGE_CROSS_PLATFORM_MULTIPLAYER;
                paramlist.Add(sp);

                ExecuteWebstoreNonQuery(webstoreApplicationName, paramlist, sproc, ref procInfo);
            }

        } //add title id

        /// <summary>
        /// 
        /// </summary>
        /// <param name="titleID"></param>
        /// <param name="version"></param>
        /// <param name="consoleType"></param>
        public static void AddTitleVersion(uint titleId, int version, PlatformType platformType, Guid betaGroup)
        {
            IVirtualInterfaceInfo viInfo = Config.GetVirtualInterface(VirtualInterface.uodb, Site.main);
            string webstoreApplicationName = viInfo.WebstoreApp;

            ArrayList paramlist = new ArrayList();
            SqlParameter sp = null;

            //for the UODB call
            sp = new SqlParameter("@i_title_id", SqlDbType.Int);
            sp.Value = (int)titleId;
            paramlist.Add(sp);

            sp = new SqlParameter("@i_initial_version", SqlDbType.Int);
            sp.Value = version;
            paramlist.Add(sp);

            sp = new SqlParameter("@ti_console_type_id", SqlDbType.TinyInt);
            sp.Value = (byte)platformType;
            paramlist.Add(sp);

            sp = new SqlParameter("@uid_beta_group_id", SqlDbType.UniqueIdentifier);
            sp.Value = betaGroup;
            paramlist.Add(sp);

            StringBuilder bld = new StringBuilder();
            ExecuteWebstoreNonQuery(webstoreApplicationName, paramlist, "dbo.p_svc_insert_titles", ref bld);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="titleId"></param>
        /// <param name="version"></param>
        /// <param name="consoleType"></param>
        public static void RemoveTitleVersion(uint titleId, int version, PlatformType platformType, Guid betaGroup)
        {
            IVirtualInterfaceInfo viInfo = Config.GetVirtualInterface(VirtualInterface.uodb, Site.main);
            string webstoreApplicationName = viInfo.WebstoreApp;

            ArrayList paramlist = new ArrayList();
            SqlParameter sp = null;

            //for the UODB call
            sp = new SqlParameter("@i_title_id", SqlDbType.Int);
            sp.Value = (int)titleId;
            paramlist.Add(sp);

            sp = new SqlParameter("@i_base_version", SqlDbType.Int);
            sp.Value = version;
            paramlist.Add(sp);

            sp = new SqlParameter("@ti_console_type_id", SqlDbType.TinyInt);
            sp.Value = (byte)platformType;
            paramlist.Add(sp);

            sp = new SqlParameter("@uid_beta_group_id", SqlDbType.UniqueIdentifier);
            sp.Value = betaGroup;
            paramlist.Add(sp);

            StringBuilder bld = new StringBuilder();
            ExecuteWebstoreNonQuery(webstoreApplicationName, paramlist, "dbo.p_svc_delete_title_version", ref bld);
        }

        /// <summary>
        /// Excempt the title. Todo: Make sure that this is really needs to be called.
        /// </summary>
        /// <param name="titleID"></param>
        /// <param name="procInfo"></param>
        public static void UODBAddBountyTitle(uint titleID, ref StringBuilder procInfo)
        {
            //it's weird, but we're supposed to get the app name from the config...
            //how often are we going to change the appname?
            IVirtualInterfaceInfo viInfo = Config.GetVirtualInterface(VirtualInterface.uodb, Site.main);
            string webstoreApplicationName = viInfo.WebstoreApp;

            ArrayList parameters = new ArrayList();
            SqlParameter sp = null;

            //for the UODB call
            sp = new SqlParameter("@i_title_id", SqlDbType.Int);
            sp.Value = (int)titleID;
            parameters.Add(sp);

            //proc already checks if title is there and won't retry the insert
            // p_xprof_insert_exempt_title   int titleid
            ExecuteWebstoreNonQuery(webstoreApplicationName, parameters, "dbo.p_xprof_insert_exempt_title", ref procInfo);
        } //bounty

        /// <summary>
        /// Add alternate title info to UODB.
        /// </summary>
        /// <param name="ltc"></param>
        /// <param name="procInfo"></param>
        /// <returns></returns>
        public static bool AddAltTitleInfo(LiveTitleConfig ltc, ref StringBuilder procInfo)
        {
            ArrayList paramlist = new ArrayList();
            SqlParameter sp = null;

            //for the UODB call
            sp = new SqlParameter("@i_title_id", SqlDbType.Int);
            sp.Value = (int)ltc.TitleID;
            paramlist.Add(sp);

            //these will almost always be 0, but reduce code churn here,
            //these will get set to the value from the LTC.
            sp = new SqlParameter("@i_title_region", SqlDbType.Int);
            sp.Value = ltc.TitleRegion;
            paramlist.Add(sp);

            sp = new SqlParameter("@i_media_id", SqlDbType.Int);
            sp.Value = (int)ltc.DiscMediaID;
            paramlist.Add(sp);

            sp = new SqlParameter("@i_live_title_id", SqlDbType.Int);
            sp.Value = (int)ltc.LiveTitleID;
            paramlist.Add(sp);

            sp = new SqlParameter("@i_alternate_id1", SqlDbType.Int);
            sp.Value = (int)ltc.AlternateTitleID1;
            paramlist.Add(sp);

            sp = new SqlParameter("@i_alternate_id2", SqlDbType.Int);
            sp.Value = (int)ltc.AlternateTitleID2;
            paramlist.Add(sp);

            sp = new SqlParameter("@i_alternate_id3", SqlDbType.Int);
            sp.Value = (int)ltc.AlternateTitleID3;
            paramlist.Add(sp);

            sp = new SqlParameter("@i_alternate_id4", SqlDbType.Int);
            sp.Value = (int)ltc.AlternateTitleID4;
            paramlist.Add(sp);

            sp = new SqlParameter("@i_service1", SqlDbType.Int);
            sp.Value = ltc.Service1;
            paramlist.Add(sp);

            sp = new SqlParameter("@i_service1_alt_id", SqlDbType.Int);
            sp.Value = ltc.Service1AltID;
            paramlist.Add(sp);

            sp = new SqlParameter("@i_service2", SqlDbType.Int);
            sp.Value = ltc.Service2;
            paramlist.Add(sp);

            sp = new SqlParameter("@i_service2_alt_id", SqlDbType.Int);
            sp.Value = ltc.Service2AltID;
            paramlist.Add(sp);

            sp = new SqlParameter("@i_service3", SqlDbType.Int);
            sp.Value = ltc.Service3;
            paramlist.Add(sp);

            sp = new SqlParameter("@i_service3_alt_id", SqlDbType.Int);
            sp.Value = ltc.Service3AltID;
            paramlist.Add(sp);

            sp = new SqlParameter("@i_service4", SqlDbType.Int);
            sp.Value = ltc.Service4;
            paramlist.Add(sp);

            sp = new SqlParameter("@i_service4_alt_id", SqlDbType.Int);
            sp.Value = ltc.Service4AltID;
            paramlist.Add(sp);

            //add it to UODB
            bool flag = true;
            ExecuteWebstoreNonQuery(
                ConfigUtil.UodbWebstoreApp,
                paramlist,
                "p_svc_set_alternate_titleids",
                ref procInfo
                );

            return flag;
        }  //alt title id

        /// <summary>
        /// Add title information to WebDB
        /// </summary>
        /// <param name="titleID"></param>
        /// <param name="strings"></param>
        /// <param name="procInfo"></param>
        /// <returns></returns>
        public static bool CreateNewTitleWebDB(uint titleID, LocalizedStrings strings, ref StringBuilder procInfo)
        {
            string defaultLocale = "";
            int clusterID = 1;
            int esrb = 7;

            if (strings == null || strings.defaultLocale == null)
            {
                procInfo.Append("XLAST did not specify a defaultLocale for LocalizedStrings!");
                return false;
            }

            defaultLocale = strings.defaultLocale;

            string connection = ConfigUtil.WebdbConnectionString;

            ArrayList paramlist = new ArrayList();
            SqlParameter sp = null;

            sp = new SqlParameter("@i_title_id", SqlDbType.Int);
            sp.Value = (int)titleID;
            paramlist.Add(sp);

            sp = new SqlParameter("@ti_esrb_rating", SqlDbType.TinyInt);
            sp.Value = esrb;
            paramlist.Add(sp);

            sp = new SqlParameter("@i_cluster_id", SqlDbType.Int);
            sp.Value = clusterID;
            paramlist.Add(sp);

            sp = new SqlParameter("@vc_default_locale", SqlDbType.NVarChar, 8);
            sp.Value = defaultLocale;
            paramlist.Add(sp);

            //add it to WebDB
            bool flag = ExecuteNonQuery(
                connection,
                paramlist,
                "dbo.p_webdb_tmr_insert_title_info",
                ref procInfo
                );

            // $REVIEW (michion): this code loops through all the localized versions of the
            // game title. This is consistent with the XBOX1 treatment, but in other databases
            // eg UODB.t_title_culture_details, we use the StringLibrary to add all languages
            // (using defaulting logic with default locale)
            //
            LocalizedString ls = XlastUtil.GetTitleNameLocalizeString(strings);

            if ((null != ls) && (null != ls.Translation) && (ls.Translation.Length > 0))
            {
                foreach (Translation t in ls.Translation)
                {
                    paramlist = new ArrayList();

                    sp = new SqlParameter("@i_title_id", SqlDbType.Int);
                    sp.Value = (int)titleID;
                    paramlist.Add(sp);

                    sp = new SqlParameter("@vc_locale_id", SqlDbType.NVarChar, 8);
                    sp.Value = t.locale;
                    paramlist.Add(sp);

                    sp = new SqlParameter("@vc_display_name", SqlDbType.NVarChar, 128);
                    sp.Value = t.Value;
                    paramlist.Add(sp);

                    flag = flag && ExecuteNonQuery(
                        connection,
                        paramlist,
                        "dbo.p_webdb_tmr_insert_title_name_info",
                        ref procInfo
                        );
                }
            }

            return flag;
        }

        /// <summary>
        /// Add title specific localized strings to NPDB.
        /// </summary>
        /// <param name="titleID"></param>
        /// <param name="strings"></param>
        /// <param name="procInfo"></param>
        /// <returns></returns>
        public static bool NPDBCreateTitleStrings(uint titleID, LocalizedStrings strings, ref StringBuilder procInfo)
        {
            LocalizedString ls = XlastUtil.GetTitleNameLocalizeString(strings);

            if ((null != ls) && (null != ls.Translation) && (ls.Translation.Length > 0))
            {
                foreach (Translation t in ls.Translation)
                {
                    // We set the StringId to 0 because 0 is required for StringSvr to create the correct key for a title string
                    NPDBCreateTitleString(titleID, 0, t.locale, t.Value, ref procInfo);

                    //xlast/spac verifies that there is a translation for the default locale
                    if (t.locale == strings.defaultLocale)
                    {
                        NPDBCreateTitleString(titleID, 0, "default", t.Value, ref procInfo);
                    }
                }
            }

            return true;
        }

        /// <summary>
        /// Add title specific localized strings to NPDB.
        /// </summary>
        /// <param name="titleID"></param>
        /// <param name="stringID"></param>
        /// <param name="locale"></param>
        /// <param name="stringText"></param>
        /// <param name="procInfo"></param>
        /// <returns></returns>
        public static bool NPDBCreateTitleString(uint titleID, int stringID, string locale, string stringText, ref StringBuilder procInfo)
        {
            ArrayList paramlist = new ArrayList();
            SqlParameter sp = null;
            IInterfaceInfo npdbInterfaceInfo = Config.GetSingleInterface(Interface.npdb);
            string connection = npdbInterfaceInfo.SqlConnectionString;

            sp = new SqlParameter("@i_title_id", SqlDbType.Int);
            sp.Value = (int)titleID;
            paramlist.Add(sp);

            sp = new SqlParameter("@i_string_id", SqlDbType.Int);
            sp.Value = stringID;
            paramlist.Add(sp);

            sp = new SqlParameter("@vc_locale", SqlDbType.VarChar, 10);
            sp.Value = locale;
            paramlist.Add(sp);

            //titlemgr convention to have strings expire in 100 years
            sp = new SqlParameter("@dt_expire", SqlDbType.DateTime);
            sp.Value = System.DateTime.Now.AddYears(100);
            paramlist.Add(sp);

            sp = new SqlParameter("@nvc_text", SqlDbType.NVarChar, 512);
            if (stringText.Length > 512)
            {
                sp.Value = stringText.Substring(0, 512);
            }
            else
            {
                sp.Value = stringText;
            }
            paramlist.Add(sp);

            bool flag = ExecuteNonQuery(
                connection,
                paramlist,
                "dbo.p_stringsvr_string_add_by_id",
                ref procInfo
                );

            return flag;
        }

        #endregion Title Creating Methods

        #region Title Configuration Report Methods

        /// <summary>
        /// Get the title versions from UODB
        /// </summary>
        /// <param name="titleID"></param>
        /// <param name="procInfo"></param>
        /// <returns></returns>
        public static ArrayList GetTitleVersions(uint titleID, ref StringBuilder procInfo)
        {
            // there's always a partition 0
            return GetTitleVersions(titleID, 0, ref procInfo);
        }

        
        /// <summary>
        /// Get the title versions from UODB.
        /// </summary>
        /// <param name="titleID"></param>
        /// <param name="partition"></param>
        /// <param name="procInfo"></param>
        /// <returns></returns>
        public static ArrayList GetTitleVersions(uint titleID, int partition, ref StringBuilder procInfo)
        {
            //this will be used later to audit title configuration, to make sure all partitions are the same
            ArrayList versions = new ArrayList();

            IVirtualInterfaceInfo viInfo = Config.GetVirtualInterface(VirtualInterface.uodb, Site.main);
            string webstoreApplicationName = viInfo.WebstoreApp;

            using (WstConnection conn = new WstConnection(webstoreApplicationName))
            {
                conn.Open();

                //  Set up the command
                WstCommand cmd = new WstCommand(
                    "dbo.p_svc_get_title_versions",   //name of the stored procedure
                    conn,                             //connection
                    partition,
                    WstFailoverMode.PrimaryOnly
                    );

                cmd.CommandType = CommandType.StoredProcedure;
                cmd.PartitionType = WstPartitionType.Physical;
                cmd.Transaction = conn.BeginTransaction();

                cmd.Parameters.Add("@i_title_id", SqlDbType.Int).Value = (int)titleID;
                cmd.Parameters["@i_title_id"].Direction = ParameterDirection.Input;

                cmd.Parameters.Add("@i_base_version", SqlDbType.Int).Value = -1; //retrieve all versions
                cmd.Parameters["@i_base_version"].Direction = ParameterDirection.Input;

                try
                {
                    WstDataReader verReader = cmd.ExecuteReader();

                    //task: retrieve data
                    //loop through result set
                    int baseCol = verReader.GetOrdinal("i_base_version");
                    int updateCol = verReader.GetOrdinal("i_update_version");
                    int betaCol = verReader.GetOrdinal("i_beta_version");
                    int consoleTypeCol = verReader.GetOrdinal("ti_console_type_id");

                    while (verReader.Read())
                    {
                        CGTitleVersion version = new CGTitleVersion(
                            titleID,
                            verReader.GetInt32(baseCol),
                            verReader.GetInt32(updateCol),
                            verReader.GetInt32(betaCol),
                            (ConsoleTypeEnum)verReader.GetByte(consoleTypeCol)
                            );
                        versions.Add(version);
                    }

                }
                catch (Exception e)
                {
                    string errString = "\n\rError Calling p_svc_get_title_versions on ptn " + partition + ": " + e.Message + "\n\r Stack: " + e.StackTrace;
                    procInfo.Append(errString);

                    throw;
                }
            }

            return versions;
        }

        #endregion

        #region SQL Methods

        //NOTE:
        //  all calls must be for Webstore DB's
        //  all calls must be NonQuery
        //  all procedures called must have "set" semantic not additive
        //  (i.e. repeated calls with same params will not change configuration )
        public static void ExecuteWebstoreNonQuery(string applicationName, ArrayList paramList, string procName, ref StringBuilder procInfo)
        {
            int partitionCount;
            //get partition count
            using (WstConnection conn = new WstConnection(applicationName))
            {
                conn.Open();
                partitionCount = conn.SqlPartitions.Count;
            }

            ArrayList connectionList = new ArrayList();
            ArrayList commandList = new ArrayList();

            try
            {
                //open a connection for each partition
                for (int physicalPartition = 0; physicalPartition < partitionCount; physicalPartition++)
                {

                    WstConnection conn = new WstConnection(applicationName);
                    conn.Open();

                    //Hold on to this connection for later
                    connectionList.Add(conn);

                    //  Set up the command
                    WstCommand cmd = new WstCommand(
                        procName,                   //name of the stored procedure
                        conn,                       //connection
                        physicalPartition,
                        WstFailoverMode.PrimaryOnly
                        );

                    //Hold on to this command for later
                    commandList.Add(cmd);

                    cmd.CommandType = CommandType.StoredProcedure;
                    cmd.PartitionType = WstPartitionType.Physical;
                    if (useTransactions)
                    {
                        cmd.Transaction = conn.BeginTransaction();
                    }

                    //this should prevent changes to the original parameter set
                    foreach (SqlParameter sp in paramList)
                    {
                        SqlParameter paramCopy = new SqlParameter(
                            sp.ParameterName,
                            sp.SqlDbType,
                            sp.Size,
                            sp.Direction,
                            sp.IsNullable,
                            sp.Precision,
                            sp.Scale,
                            sp.SourceColumn,
                            sp.SourceVersion,
                            sp.Value
                            );
                        cmd.Parameters.Add(paramCopy);
                    } // copy params

                    try
                    {
                        cmd.ExecuteNonQuery();
                    }
                    catch (Exception e)
                    {
                        string errString = "\n\rError Calling " + procName + " on ptn " + physicalPartition + ": " + e.Message + "\n\r Stack: " + e.StackTrace;
                        procInfo.Append(errString);

                        throw;
                    }
                }// for each partition

                //if all commands execute ok, commit all transactions
                foreach (WstCommand cmd in commandList)
                {
                    if (useTransactions)
                    {
                        cmd.Transaction.Commit();
                    }
                    cmd.Parameters.Clear();
                }

            }
            catch
            {
                //rollback all transactions on commands
                foreach (WstCommand cmd in commandList)
                {
                    if (useTransactions)
                    {
                        cmd.Transaction.Rollback();
                    }
                }

                //preserve the original exception
                throw;
            }
            finally
            {
                //task: assumes auto-rollback on close  is this the case??
                foreach (WstConnection conn in connectionList)
                {
                    conn.Close();
                }
            }
        }

        public static bool ExecuteNonQuery(string connectionString, ArrayList paramList, string procName, ref StringBuilder procInfo)
        {
            bool flag = true;

            try
            {
                //open connection
                using (SqlConnection execConn = new SqlConnection(connectionString))
                {
                    //create command
                    execConn.Open();
                    SqlCommand execCmd = execConn.CreateCommand();
                    execCmd.CommandType = CommandType.StoredProcedure;
                    execCmd.CommandText = procName;

                    //this should prevent changes to the original parameter set
                    ArrayList parameters = (ArrayList)paramList.Clone();

                    //add parameters
                    foreach (object param in parameters)
                    {
                        execCmd.Parameters.Add((SqlParameter)param);
                    }

                    //execute non-query
                    try
                    {
                        execCmd.ExecuteNonQuery();
                    }
                    catch (Exception e)
                    {
                        string errString = "\n\rError Calling " + procName + " on ||" + connectionString + "|| Error was: " + e.Message + "\n\r Stack: " + e.StackTrace;
                        procInfo.Append(errString);

                        throw;
                    }
                }
            }
            catch
            {
                //no rollback here, since we only have 1 partition... it will fail or succeed.
                //don't need finally either, since Using will close the connection
                //preserve the original exception
                throw;
            }
            return flag;
        }

        #endregion
    } //class

    public class CGTitleVersion
    {
        public uint TitleID;
        public int Base;
        public int Update;
        public int Beta;
        public ConsoleTypeEnum ConsoleType;

        public CGTitleVersion()
        {
        }

        public CGTitleVersion( uint titleID, int baseVersion, int updateVersion, int betaVersion, ConsoleTypeEnum consoleType )
        {
            TitleID = titleID;
            Base = baseVersion;
            Update = updateVersion;
            Beta = betaVersion;
            ConsoleType = consoleType;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\TitleManagement\Service\VersionNeutralDataContract.cs ===
/*--------------------------------------------------------------------------
    This file provides a version neutral data contract for the mix
    title management APIs. This any versioned data contracts should have
    a corresponding entry here. The point is this is so that our
    implementations don't rely on a specific data contract--they
    can all share a common implementation and then convert them
    only at the very end of the call.

    NOTE: There is an obvious potential performance issue here. We
    will need to monitor and measure that.
--------------------------------------------------------------------------*/

using System;
using System.Collections.Generic;

using xonline.common.service;
using xonline.mix.titlemanagement.contract;
using PlatformTypeV1=xonline.mix.titlemanagement.contract.PlatformType;
using PlatformType=xonline.mix.titlemanagement.service.PlatformType;
using xonline.mix.titlemanagement.contract.v2;
using xonline.mix.titlemanagement.contract.V3;

namespace xonline.mix.titlemanagement.service
{
    public enum PlatformType
    {
        Xbox1 = 0,
        XboxCom = 1,
        Xenon = 2,
        Marketplace = 3,
        PC = 4,
        Mobile = 5,
        WebGames = 6,
    }

    public class TitleVersions
    {
        public TitleVersionInstance[] Versions { get; set; }

        //conversions
        public static implicit operator TitleVersionsV1(TitleVersions source)
        {
            TitleVersionsV1 v1=new TitleVersionsV1();
            v1.Versions=TitleVersionInstance.ConvertAllV1(source.Versions);
            return v1;
        }

        public static implicit operator TitleVersionsV2(TitleVersions source)
        {
            TitleVersionsV2 v2=new TitleVersionsV2();
            v2.Versions=TitleVersionInstance.ConvertAllV2(source.Versions);
            return v2;
        }

        public static implicit operator TitleVersionsV3(TitleVersions source)
        {
            TitleVersionsV3 v3=new TitleVersionsV3();
            v3.Versions=TitleVersionInstance.ConvertAllV3(source.Versions);
            return v3;
        }
    }

    public class TitleVersionInstance
    {
        public uint TitleId { get; set; }
        public int BaseVersion { get; set; }
        public int UpdateVersion { get; set; }
        public PlatformType PlatformType { get; set; }
        public Guid BetaGroup { get; set; }

        public TitleVersionInstance()
        {
        }

        public TitleVersionInstance(uint titleId, int baseVersion, PlatformType platformType)
        {
            TitleId = titleId;
            BaseVersion = baseVersion;
            UpdateVersion = baseVersion;
            PlatformType = platformType;
            BetaGroup = Guid.Empty;
        }

        public TitleVersionInstance(uint titleId, int baseVersion, int updateVersion, PlatformType platformType, Guid betaGroup)
        {
            TitleId = titleId;
            BaseVersion = baseVersion;
            UpdateVersion = updateVersion;
            PlatformType = platformType;
            BetaGroup = betaGroup;
        }

        //conversions
        public static implicit operator TitleVersionInstanceV1(TitleVersionInstance source)
        {
            TitleVersionInstanceV1 v1=new TitleVersionInstanceV1();
            v1.TitleId=source.TitleId;
            v1.BaseVersion=source.BaseVersion;
            v1.UpdateVersion=source.UpdateVersion;
            v1.PlatformType=(PlatformTypeV1)source.PlatformType;
            v1.BetaGroup=source.BetaGroup;
            return v1;
        }

        public static implicit operator TitleVersionInstanceV2(TitleVersionInstance source)
        {
            TitleVersionInstanceV2 v2=new TitleVersionInstanceV2();
            v2.TitleId=source.TitleId;
            v2.BaseVersion=source.BaseVersion;
            v2.UpdateVersion=source.UpdateVersion;
            v2.PlatformType=(PlatformTypeV2)source.PlatformType;
            v2.BetaGroup=source.BetaGroup;
            return v2;
        }

        public static implicit operator TitleVersionInstanceV3(TitleVersionInstance source)
        {
            TitleVersionInstanceV3 v3=new TitleVersionInstanceV3();
            v3.TitleId=source.TitleId;
            v3.BaseVersion=source.BaseVersion;
            v3.UpdateVersion=source.UpdateVersion;
            v3.PlatformType=(PlatformTypeV3)source.PlatformType;
            v3.BetaGroup=source.BetaGroup;
            return v3;
        }

        public static TitleVersionInstanceV1[] ConvertAllV1(TitleVersionInstance []source)
        {
            TitleVersionInstanceV1 []dest=new TitleVersionInstanceV1[source.Length];
            for (int i=0; i<source.Length; ++i)
            {
                dest[i]=source[i];
            }

            return dest;
        }

        public static TitleVersionInstanceV2[] ConvertAllV2(TitleVersionInstance []source)
        {
            TitleVersionInstanceV2 []dest=new TitleVersionInstanceV2[source.Length];
            for (int i=0; i<source.Length; ++i)
            {
                dest[i]=source[i];
            }

            return dest;
        }

        public static TitleVersionInstanceV3[] ConvertAllV3(TitleVersionInstance []source)
        {
            TitleVersionInstanceV3 []dest=new TitleVersionInstanceV3[source.Length];
            for (int i=0; i<source.Length; ++i)
            {
                dest[i]=source[i];
            }

            return dest;
        }
    }

    public class TitleUpdatePackageLocation
    {
        public int    Rank { get; set; }
        public string Xrl { get; set; }

        public static implicit operator TitleUpdatePackageLocation(TitleUpdatePackageLocationV2 source)
        {
            if (source==null)
            {
                return null;
            }

            TitleUpdatePackageLocation vn=new TitleUpdatePackageLocation();
            vn.Rank=source.Rank;
            vn.Xrl=source.Xrl;
            return vn;
        }

        public static implicit operator TitleUpdatePackageLocation(TitleUpdatePackageLocationV3 source)
        {
            if (source==null)
            {
                return null;
            }

            TitleUpdatePackageLocation vn=new TitleUpdatePackageLocation();
            vn.Rank=source.Rank;
            vn.Xrl=source.Xrl;
            return vn;
        }

        public static TitleUpdatePackageLocation[] ConvertAll(TitleUpdatePackageLocationV2 []source)
        {
            if (source==null)
            {
                return null;
            }

            TitleUpdatePackageLocation []dest=new TitleUpdatePackageLocation[source.Length];
            for (int i=0; i<source.Length; ++i)
            {
                dest[i]=source[i];
            }

            return dest;
        }

        public static TitleUpdatePackageLocation[] ConvertAll(TitleUpdatePackageLocationV3 []source)
        {
            if (source==null)
            {
                return null;
            }

            TitleUpdatePackageLocation []dest=new TitleUpdatePackageLocation[source.Length];
            for (int i=0; i<source.Length; ++i)
            {
                dest[i]=source[i];
            }

            return dest;
        }
    }

    public class TitleUpdatePackageInformation
    {
        public byte []UpdateSymmetricKey { get; set; }
        public byte []PublicKey { get; set; }
        public int    InstallSize { get; set; }
        public int    PackageSize { get; set; }
        public byte []ContentId { get; set; }

        public static implicit operator TitleUpdatePackageInformation(TitleUpdatePackageInformationV2 source)
        {
            if (source==null)
            {
                return null;
            }

            TitleUpdatePackageInformation vn=new TitleUpdatePackageInformation();
            vn.UpdateSymmetricKey=source.UpdateSymmetricKey;
            vn.PublicKey=source.PublicKey;
            vn.InstallSize=source.InstallSize;
            vn.PackageSize=source.PackageSize;
            vn.ContentId=source.ContentId;
            return vn;
        }

        public static implicit operator TitleUpdatePackageInformation(TitleUpdatePackageInformationV3 source)
        {
            if (source==null)
            {
                return null;
            }

            TitleUpdatePackageInformation vn=new TitleUpdatePackageInformation();
            vn.UpdateSymmetricKey=source.UpdateSymmetricKey;
            vn.PublicKey=source.PublicKey;
            vn.InstallSize=source.InstallSize;
            vn.PackageSize=source.PackageSize;
            vn.ContentId=source.ContentId;
            return vn;
        }
    }

    public class TitleEndpoint
    {
        public string Protocol { get; set; }
        public string Hostname { get; set; }
        public uint FromIP { get; set; }
        public uint ToIP { get; set; }
        public string Path { get; set; }
        public int Port { get; set; }
        public string AppliesToUrl { get; set; }

        public void Validate()
        {
            if(Protocol.Length > 10)
            {
                throw new XRLException(HResult.XONLINE_E_MIX_STRING_TOO_LONG, XEvent.Id.MIX_TITLEMANAGEMENT_INVALID_ARGUMENT, "Protocol string too long.");
            }

            if(Hostname.Length > 200)
            {
                throw new XRLException(HResult.XONLINE_E_MIX_STRING_TOO_LONG, XEvent.Id.MIX_TITLEMANAGEMENT_INVALID_ARGUMENT, "Hostname too long.");
            }

            if(Path.Length > 200)
            {
                throw new XRLException(HResult.XONLINE_E_MIX_STRING_TOO_LONG, XEvent.Id.MIX_TITLEMANAGEMENT_INVALID_ARGUMENT, "Path too long.");
            }
        }

        public static implicit operator TitleEndpoint(TitleEndpointV3 source)
        {
            if(source == null)
            {
                return null;
            }

            TitleEndpoint e = new TitleEndpoint();
            e.Protocol = source.Protocol;
            e.Hostname = source.Hostname;
            e.FromIP = source.FromIP;
            e.ToIP = source.ToIP;
            e.Path = source.Path;
            e.Port = source.Port;
            e.AppliesToUrl = source.AppliesToUri;

            return e;
        }

        public static implicit operator TitleEndpointV3(TitleEndpoint source)
        {
            if(source == null)
            {
                return null;
            }

            TitleEndpointV3 e = new TitleEndpointV3();
            e.Protocol = source.Protocol;
            e.Hostname = source.Hostname;
            e.FromIP = source.FromIP;
            e.ToIP = source.ToIP;
            e.Path = source.Path;
            e.Port = source.Port;
            e.AppliesToUri = source.AppliesToUrl;

            return e;
        }

        public static TitleEndpoint[] ConvertAll(TitleEndpointV3 []source)
        {
            if (source==null)
            {
                return null;
            }

            TitleEndpoint []dest=new TitleEndpoint[source.Length];
            for (int i=0; i<source.Length; ++i)
            {
                dest[i]=source[i];
            }

            return dest;
        }
    }

    public class TitleEndpointInfo
    {
        public TitleEndpointInfo()
        {
            EndpointInfo = new TitleEndpoint();
        }

        public uint TitleID;
        public TitleEndpoint EndpointInfo;
        public DateTime Start;
        public DateTime End;

        public static implicit operator TitleEndpointInfoV3(TitleEndpointInfo source)
        {
            if(source == null)
            {
                return null;
            }

            TitleEndpointInfoV3 teiV3 = new TitleEndpointInfoV3();
            teiV3.TitleID = source.TitleID;
            teiV3.Start = source.Start;
            teiV3.End = source.End;
            teiV3.EndpointInfo = source.EndpointInfo;

            return teiV3;
        }

        public static TitleEndpointInfoV3[] ConvertAll(TitleEndpointInfo[] source)
        {
            if (source==null)
            {
                return null;
            }

            TitleEndpointInfoV3 []dest=new TitleEndpointInfoV3[source.Length];
            for (int i=0; i<source.Length; ++i)
            {
                dest[i]=source[i];
            }

            return dest;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\TitleManagement\Service\TitleManager.cs ===
using System;
using System.IO;
using System.Net;
using System.Text;
using System.Xml;
using System.Linq;
using System.Collections.Generic;
using System.Data;
using System.Data.SqlClient;
using System.Text.RegularExpressions;

using xonline.common.config;
using xonline.common.livetitleconfig;
using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.xlastutil;
using xonline.tools.framework;
using xonline.mix.titlemanagement.contract;
using xonline.mix.common;

using xonline.config.sts.interfaces;
using xonline.config.sts.databaseconfig;

using Microsoft.Webstore.WstClient;
using Microsoft.Xbox.SocialConnect.DataAccess;

namespace xonline.mix.titlemanagement.service
{
    public class TitleManager
    {
        static public void ConfigureTitle(byte[] compressedXlast, bool noReload)
        {
            //Decompress input byte array to valid xml.

            if (compressedXlast == null || compressedXlast.Length == 0)
                throw new XRLException(HResult.XONLINE_E_MIX_DECOMPRESSION_ERROR, XEvent.Id.MIX_TITLEMANAGEMENT_DECOMPRESSION_ERROR, "Please provide a valid compressed xlast file.");

            string xlastXml = string.Empty;
            try
            {
                xlastXml = xonline.mix.common.Gzip.Decompress(compressedXlast);
            }
            catch (Exception) //Todo: be specific here.
            {
                throw new XRLException(HResult.XONLINE_E_MIX_DECOMPRESSION_ERROR, XEvent.Id.MIX_TITLEMANAGEMENT_DECOMPRESSION_ERROR, "Error decompressing input xlast byte array.");
            }

            //Verify Xlast is a valid xml by loading it in to xmldocument.
            XmlDocument XlastXmlDocument = new XmlDocument();
            try
            {
                XlastXmlDocument.LoadXml(xlastXml);
            }
            catch (XmlException)
            {
                throw new XRLException(HResult.XONLINE_E_MIX_INVALID_XLAST, XEvent.Id.MIX_TITLEMANAGEMENT_INVALID_XLAST, "Please provide a valid xlast xml file.");
            }
            catch (Exception)
            {
                throw new XRLException(HResult.XONLINE_E_MIX_INVALID_XLAST, XEvent.Id.MIX_TITLEMANAGEMENT_INVALID_XLAST, "Error parsing input xlast xml.");
            }

            //verify xlast version exists in xml
            string xlastVersion;
            try
            {
                xlastVersion = XlastUtil.GetXlastVersion(xlastXml);
            }
            catch (Exception)
            {
                throw new XRLException(HResult.XONLINE_E_MIX_INVALID_XLAST, XEvent.Id.MIX_TITLEMANAGEMENT_INVALID_XLAST, "Xlast file does not seem to have a valid xlast version.");
            }

            //Get required objects from xlast, which we can use later.
            XboxLiveSubmissionProject xlsp = XlastUtil.GetXlastFromXml(xlastXml);

            // For Mobile/Web titles, convert the xlsp to the console version.
            bool isMobileTitle = MobileAndWebLeaderboardUtils.IsMobileTitle(xlsp);
            if (isMobileTitle)
            {
                MobileAndWebLeaderboardUtils.ConvertMobileLeaderboardsToGeneralFormat(xlsp, MixTitleManagementApp.MobileColumnLocalizationData);
                xlastXml = XlastUtil.ToXml(xlsp);
            }

            GameConfigProject gcp = xlsp.GameConfigProject;

            //Verify valid title id in xlast.
            CTitleId titleId = null;
            try
            {
                titleId = new CTitleId(gcp.titleId);
            }
            catch (Exception)
            {
                throw new XRLException(HResult.XONLINE_E_MIX_INVALID_XLAST, XEvent.Id.MIX_TITLEMANAGEMENT_INVALID_XLAST, "Xlast file does not seem to have a valid titleId.");
            }

            //verify titleid is not 0
            if (titleId.uiTitleId == 0) //Todo: What other checks are needed?
            {
                throw new XRLException(HResult.XONLINE_E_MIX_INVALID_XLAST, XEvent.Id.MIX_TITLEMANAGEMENT_INVALID_XLAST, "Xlast file does not seem to have a valid titleId.");
            }

            //Generate LTC from xlast
            LiveTitleConfig ltc = null;
            try
            {
                ltc = CGXLastHelper.GenerateLiveTitleConfigFromXlast(xlastXml, titleId);
            }
            catch (SqlException)
            {
                throw;
            }
            catch (Exception)
            {
                throw new XRLException(HResult.XONLINE_E_MIX_INVALID_XLAST, XEvent.Id.MIX_TITLEMANAGEMENT_INVALID_XLAST, "An error occurred while generating ltc from the given xlast.");
            }

            //Verify xlast for integrity
            StringBuilder validationInformation = new StringBuilder();
            if (!CGXLastHelper.CheckXlast(xlsp, ltc, ref validationInformation)) 
            {
                throw new XRLException(HResult.XONLINE_E_MIX_INVALID_XLAST, XEvent.Id.MIX_TITLEMANAGEMENT_INVALID_XLAST, "LiveTitle: One or more server-side XLAST / LTC consistency checks failed." + Environment.NewLine + validationInformation.ToString());
            }

            //load files to npdb
            XlastUtil.PutXlast(titleId.uiTitleId, xlastXml);
            ltc.Save();

            //this allows us to get detailed information back to the caller...
            StringBuilder processingInfo = new StringBuilder();

            //Todo: What do we want to do with processingInfo ? It isn't needed, but could be used...
            CGTitleHelper.CreateNew(xlsp, ltc, ref processingInfo);

            if (!noReload)
            {
                MixUtilities.ResetFrontDoor(Interface.kdcsvc, "", "xkdc", "reload", Config.GetIntSetting(Setting.mix_titleMgmt_kdcReloadTimeout), /*waitForCompletion*/ false);
            }
        }

        /// <summary>
        /// Add a title version
        /// </summary>
        /// <param name="titleId"></param>
        /// <param name="version"></param>
        /// <param name="consoleType"></param>
        static public void AddBaseVersion(uint titleId, int version, PlatformType platformType, Guid betaGroup)
        {
            // Verify titleid is not 0
            if (titleId == 0)
            {
                throw new XRLException(HResult.XONLINE_E_MIX_INVALID_TITLE_ID, XEvent.Id.MIX_TITLEMANAGEMENT_INVALID_TITLE_ID, "TitleId of 0 is not supported.");
            }

            // Check if we are in a production environment
            if (String.Compare(Config.EnvironmentType, "production", true) == 0)
            {
                if (version == 0)
                {
                    throw new XRLException(HResult.XONLINE_E_MIX_INVALID_VERSION, XEvent.Id.MIX_TITLEMANAGEMENT_INVALID_VERSION, "Version of 0 is not allowed in a production environment.");
                }
            }

            // Verify a valid console type is being used
            if (platformType != PlatformType.PC &&
                platformType != PlatformType.Xenon &&
                platformType != PlatformType.Xbox1 &&
                platformType != PlatformType.Mobile &&
                platformType != PlatformType.WebGames)
            {
                throw new XRLException(HResult.XONLINE_E_MIX_INVALID_PLATFORM, XEvent.Id.MIX_TITLEMANAGEMENT_INVALID_PLATFORM, "Unsupported consoleType provided.");
            }

            CGTitleHelper.AddTitleVersion(titleId, version, platformType, betaGroup);
            Xom.NtEvent(XEvent.Id.MIX_TITLEMANAGEMENT_SUCCESS, "Version {0} successfully added for title 0x{1:X}.", version, titleId);
        }

        /// <summary>
        /// Remove a title version
        /// </summary>
        /// <param name="titleId"></param>
        /// <param name="version"></param>
        /// <param name="consoleType"></param>
        static public void RemoveBaseVersion(uint titleId, int version, PlatformType platformType, Guid betaGroup)
        {
            // Verify titleid is not 0
            if (titleId == 0)
            {
                throw new XRLException(HResult.XONLINE_E_MIX_INVALID_TITLE_ID, XEvent.Id.MIX_TITLEMANAGEMENT_INVALID_TITLE_ID, "TitleId of 0 is not supported.");
            }

            // Check if we are in a production environment
            if (String.Compare(Config.EnvironmentType, "production", true) == 0)
            {
                if (version == 0)
                {
                    throw new XRLException(HResult.XONLINE_E_MIX_INVALID_VERSION, XEvent.Id.MIX_TITLEMANAGEMENT_INVALID_VERSION, "Version of 0 is not allowed in a production environment.");
                }
            }

            // Verify a valid console type is being used
            if (platformType != PlatformType.PC &&
                platformType != PlatformType.Xenon &&
                platformType != PlatformType.Xbox1 &&
                platformType != PlatformType.Mobile &&
                platformType != PlatformType.WebGames)
            {
                throw new XRLException(HResult.XONLINE_E_MIX_INVALID_PLATFORM, XEvent.Id.MIX_TITLEMANAGEMENT_INVALID_PLATFORM, "Unsupported consoleType provided.");
            }

            CGTitleHelper.RemoveTitleVersion(titleId, version, platformType, betaGroup);
            Xom.NtEvent(XEvent.Id.MIX_TITLEMANAGEMENT_SUCCESS, "Version {0} successfully removed for title 0x{1:X}.", version, titleId);
        }

        /// <summary>
        /// Returns a list of all title versions
        /// </summary>
        /// <param name="titleId"></param>
        /// <returns></returns>
        static public TitleVersions GetTitleVersions(uint titleId)
        {
            // Verify titleid is not 0
            if (titleId == 0)
            {
                throw new XRLException(HResult.XONLINE_E_MIX_INVALID_TITLE_ID, XEvent.Id.MIX_TITLEMANAGEMENT_INVALID_TITLE_ID, "TitleId of 0 is not supported.");
            }

            return UodbTitleManagementDatabase.GetTitleVersions(titleId);
        }

        /// <summary> Adds or replaces a title update package information and locations. </summary>
        public static void SetTitleUpdatePackages(uint titleId, int baseVersion, int updateVersion, PlatformType consoleType, TitleUpdatePackageInformation packageInformation, TitleUpdatePackageLocation []updateLocations)
        {
            //validate parameters
            if (titleId==0)
            {
                throw new XRLException(HResult.XONLINE_E_MIX_INVALID_TITLE_ID, XEvent.Id.MIX_TITLEMANAGEMENT_INVALID_TITLE_ID, "TitleId 0 is not allowed.");
            }

            if (baseVersion==0 || updateVersion==0)
            {
                throw new XRLException(HResult.XONLINE_E_MIX_INVALID_VERSION, XEvent.Id.MIX_TITLEMANAGEMENT_INVALID_VERSION, "It is not valid to update to or from version 0.");
            }

            if (baseVersion==updateVersion)
            {
                throw new XRLException(HResult.XONLINE_E_MIX_INVALID_VERSION, XEvent.Id.MIX_TITLEMANAGEMENT_INVALID_VERSION, "For title update packages, baseVersion and updateVersion must be different.");
            }

            if (consoleType!=PlatformType.Xbox1 &&
                consoleType!=PlatformType.Xenon &&
                consoleType!=PlatformType.PC &&
                consoleType!=PlatformType.Mobile &&
                consoleType!=PlatformType.WebGames)
            {
                throw new XRLException(HResult.XONLINE_E_MIX_INVALID_PLATFORM, XEvent.Id.MIX_TITLEMANAGEMENT_INVALID_PLATFORM, "Unsupported consoleType provided.");
            }

            VerifyParameterNotNull(packageInformation, "packageInformation");
            VerifyParameterNotNull(packageInformation.UpdateSymmetricKey, "packageInformation.UpdateSymmetricKey");
            VerifyParameterArrayNotEmpty(packageInformation.UpdateSymmetricKey, "packageInformation.UpdateSymmetricKey");
            VerifyParameterArrayMaxSize(packageInformation.UpdateSymmetricKey, 16, "packageInformation.UpdateSymmetricKey");
            VerifyParameterNotNull(packageInformation.PublicKey, "packageInformation.PublicKey");
            VerifyParameterArrayNotEmpty(packageInformation.PublicKey, "packageInformation.PublicKey");
            VerifyParameterArrayMaxSize(packageInformation.PublicKey, 284, "packageInformation.PublicKey");

            if (packageInformation.ContentId!=null)
            {
                VerifyParameterArrayMaxSize(packageInformation.ContentId, 20, "packageInformation.ContentId");
                VerifyParameterArrayNotEmpty(packageInformation.ContentId, "packageInformation.ContentId");
            }

            System.Collections.Generic.HashSet<int> ranksToAdd = new System.Collections.Generic.HashSet<int>();
            System.Collections.Generic.HashSet<string> xrlsToAdd = new System.Collections.Generic.HashSet<string>();

            // We don't care about updateLocations for mobile titles
            if (consoleType != PlatformType.Mobile)
            {
                VerifyParameterNotNull(updateLocations, "updateLocations");

                if (updateLocations.Length == 0)
                {
                    throw new XRLException(HResult.XONLINE_E_MIX_ARGUMENT_EMPTY, XEvent.Id.MIX_TITLEMANAGEMENT_INVALID_ARGUMENT, "Parameter updateLocations may not be empty.");
                }
            }

            if (updateLocations != null)
            {
                //verify that there are no duplicates in the update locations and that the xrls are all valid
                foreach (TitleUpdatePackageLocation tupl in updateLocations)
                {
                    if (tupl == null)
                    {
                        throw new XRLException(HResult.XONLINE_E_MIX_ARGUMENT_NULL, XEvent.Id.MIX_TITLEMANAGEMENT_NULL_ARGUMENT, "A title update location may not be null.");
                    }

                    if (ranksToAdd.Contains(tupl.Rank))
                    {
                        throw new XRLException(HResult.XONLINE_E_MIX_DUPLICATE_RANK_NOT_ALLOWED, XEvent.Id.MIX_TITLEMANAGEMENT_DUPLICATE_UPDATE_RANK_LOCATION, "Ranks within the TitleUpdatePackageLocation must be unique.");
                    }

                    ranksToAdd.Add(tupl.Rank);

                    if (tupl.Xrl == null)
                    {
                        throw new XRLException(HResult.XONLINE_E_MIX_ARGUMENT_NULL, XEvent.Id.MIX_TITLEMANAGEMENT_NULL_ARGUMENT, "A title update location xrl may not be null.");
                    }

                    if (tupl.Xrl.Length > 4000)
                    {
                        throw new XRLException(HResult.XONLINE_E_MIX_ARRAY_TOO_LONG, XEvent.Id.MIX_TITLEMANAGEMENT_ARGUMENT_TOO_LARGE, "Paramater TitleUpdatePackageLocation.Xrl is too large.");
                    }

                    if (xrlsToAdd.Contains(tupl.Xrl))
                    {
                        throw new XRLException(HResult.XONLINE_E_MIX_DUPLICATE_XRL_NOT_ALLOWED, XEvent.Id.MIX_TITLEMANAGEMENT_DUPLICATE_UPDATE_XRL_LOCATION, "XRLs within the TitleUpdatePackageLocation must be unique.");
                    }

                    xrlsToAdd.Add(tupl.Xrl);
                }
            }

            //verify that the title exists, since only a subset of the sprocs we'll be calling do that
            if (!UodbTitleManagementDatabase.DoesTitleExist(titleId))
            {
                throw new XRLException(HResult.XONLINE_E_MIX_INVALID_TITLE_ID, XEvent.Id.MIX_TITLEMANAGEMENT_INVALID_TITLE_ID, string.Format("TitleId 0x{0:8X} does not exist.", titleId));
            }

            //add to t_title_versions for the magical livecontent hack group to satisfy assumptions made by the sprocs that adds package information and locations and so livecontent doesn't break
            UodbTitleManagementDatabase.AddLiveContentTitleVersionHack(titleId, baseVersion, updateVersion, consoleType);

            //add or update the update package information
            UodbTitleManagementDatabase.UpdateAndOrInsertTitleUpdatePackageInformation(titleId, baseVersion, updateVersion, consoleType, packageInformation);

            if (updateLocations != null)
            {
                //add or update the title update locations
                foreach (TitleUpdatePackageLocation tupl in updateLocations)
                {
                    UodbTitleManagementDatabase.UpdateAndOrInsertTitleUpdatePackageLocation(titleId, baseVersion, updateVersion, consoleType, tupl);
                }
            }

            //remove the update location ranks that exist in the DB but are not in our list
            int []ranksInDb=UodbTitleManagementDatabase.GetTitleUpdatePackageLocationRanks(titleId, baseVersion, updateVersion, consoleType);
            System.Collections.Generic.List<int> ranksToRemove=new System.Collections.Generic.List<int>();

            foreach (int rdb in ranksInDb)
            {
                if (!ranksToAdd.Contains(rdb))
                {
                    ranksToRemove.Add(rdb);
                }
            }

            foreach (int rr in ranksToRemove)
            {
                UodbTitleManagementDatabase.RemoveTitleUpdatePackageLocationRank(titleId, baseVersion, updateVersion, consoleType, rr);
            }

            //flush xbos caches
            try
            {
                MixUtilities.ResetFrontDoor(Interface.xbos_autoupdate, "", "xbos", "cacheflush", Config.GetIntSetting(Setting.mix_titleMgmt_kdcReloadTimeout), /*waitForCompletion*/ false);
            }
            catch (System.Exception e)
            {
                Xom.NtEvent(XEvent.Id.MIX_TITLEMANAGEMENT_XBOS_RELOAD_FAILED, e, "Xbos cacheflush failed after updating title update packages.  Consoles may receive stale update package information until this is corrected.");
            }
        }

        public static void SetTitleFacebookAppId(uint titleId, string appId)
        {
            //validate parameters
            if (titleId == 0)
            {
                throw new XRLException(HResult.XONLINE_E_MIX_INVALID_TITLE_ID, XEvent.Id.MIX_TITLEMANAGEMENT_INVALID_TITLE_ID, "TitleId 0 is not allowed.");
            }

            // A Facebook Application Id is, for the time being around BIGINT(20), we shall just enforce a VARCHAR(32) of decimal digits for future proofness.
            if (string.IsNullOrEmpty(appId))
            {
                throw new XRLException(HResult.XONLINE_E_MIX_ARGUMENT_NULL, XEvent.Id.MIX_TITLEMANAGEMENT_NULL_ARGUMENT, "A facebook application id may not be null or empty.");
            }

            if (appId.Length > 32)
            {
                throw new XRLException(HResult.XONLINE_E_MIX_STRING_TOO_LONG, XEvent.Id.MIX_TITLEMANAGEMENT_ARGUMENT_TOO_LARGE, "A facebook application id is too long.");
            }

            // any string that is not purely made of 0-9 digits should fail.
            Regex objNotWholePattern = new Regex("[^0-9]");
            if (objNotWholePattern.IsMatch(appId))
            {
                throw new XRLException(HResult.XONLINE_E_MIX_INVALID_CONFIG, XEvent.Id.MIX_TITLEMANAGEMENT_INVALID_ARGUMENT, "Facebook application id is not numerical.");
            }

            InternalSetTitleFacebookAppId(titleId, appId);

            Xom.NtEvent(XEvent.Id.MIX_TITLEMANAGEMENT_SUCCESS, "AppId {0} successfully added for title 0x{1:X}.", appId, titleId);
        }

        static public uint[] GetBusinessPartnerTitleIDs(Guid businessPartnerID)
        {
            IEBBusinessPartner p;

            GetConfigObjects(out p, businessPartnerID);

            return p.Titles.Keys.ToArray();
        }

        static public void SetBusinessPartnerTitleIDs(Guid businessPartnerID, uint[] titleIDs)
        {
            List<uint> titleIDList = new List<uint>(titleIDs);
            IEBBusinessPartner p;

            GetConfigObjects(out p, businessPartnerID);

            foreach(uint titleID in new List<uint>(p.Titles.Keys))
            {
                if(!titleIDList.Contains(titleID))
                {
                    p.Titles.Remove(titleID);
                }
            }

            // Make the ones that don't exist in the list
            foreach(uint titleID in titleIDs)
            {
                if(!p.Titles.ContainsKey(titleID))
                {
                    Title t = new Title(titleID, p);
                    p.Titles.Add(titleID, t);
                }
            }

            try
            {
                DatabaseWriter.SetBusinessPartnerTitles(p);
            }
            catch(Exception e)
            {
                throw new XRLException(HResult.XONLINE_E_MIX_UNKNOWNERROR,
                        XEvent.Id.MIX_STS_CONFIGURATION_DATABASE_WRITE_ERROR,
                        e,
                        "Error writing the information out to the database.  See inner exception for more details.");
            }

            ForceSTSConfigurationReload();
        }

        static public void SetNetworkSecurityList(uint titleID, TitleEndpoint[] allowedEndpoints)
        {
            STSConfiguration stsconf = null;
            StringBuilder output = new StringBuilder();
            Title t = null;

            GetConfigObjects(out stsconf, out t, titleID);

            if(allowedEndpoints.Length > 200)
            {
                throw new XRLException(HResult.XONLINE_E_MIX_TITLE_TOO_MANY_ENDPOINTS,
                        XEvent.Id.MIX_TITLEMANAGEMENT_INVALID_ARGUMENT,
                        "Too many endpoints for this title.  There is a maximum of 200 endpionts.");
            }

            // If there's some endpoints, we set the privilege.  Otherwise we unset it.
            try
            {
                if(allowedEndpoints.Length == 0)
                {
                    CGTitleHelper.RemovePrivilege(titleID, XOn.MPRIVILEGE_NETWORK_AUTH_LIST, ref output);
                }
                else
                {
                    CGTitleHelper.AddPrivilege(titleID, XOn.MPRIVILEGE_NETWORK_AUTH_LIST, ref output);
                }
            }
            catch(Exception e)
            {
                throw new XRLException(HResult.XONLINE_E_MIX_UNKNOWNERROR,
                        XEvent.Id.MIX_TITLE_MANAGEMENT_ERROR_SETTING_NACL_PRIVILEGE,
                        e,
                        "Error setting NACL privilege on the title.  See inner exception for more details.");
            }

            t.Endpoints.Clear();

            foreach(TitleEndpoint te in allowedEndpoints)
            {
                te.Validate();
                Endpoint e = new Endpoint(t);

                if(!ProtocolLookupTable.GetInstance().ContainsKey(te.Protocol))
                {
                    string exString = string.Format(
                            "Endpoint protocol {0} is not supported.",
                            te.Protocol);

                    throw new XRLException(HResult.XONLINE_E_MIX_UNSUPPORTED_ENDPOINT_PROTOCOL,
                            XEvent.Id.MIX_STS_CONFIGURATION_UNSUPPORTED_ENDPOINT_PROTOCOL,
                            exString);
                }

                HResult hr = HResult.S_OK;

                // if hostname is empty, then ip addresses are  required
                // if ip addresses are provided  they  must  be  ordered

                if (string.IsNullOrEmpty(te.Hostname)) {
                    if ((te.FromIP == 0) || (te.ToIP == 0))
                        hr = HResult.XONLINE_E_MIX_HOSTNAME_IP_EXCLUSION;
                    else if (IPAddress.NetworkToHostOrder(te.FromIP) > IPAddress.NetworkToHostOrder(te.ToIP)) {
                        hr = HResult.XONLINE_E_MIX_INVALID_IP_RANGE;
                    }
                }

                // if hostname is non-empty, then ip addresses must be 0
                // and the hostname must check out as a valid  DNS  name

                else {
                    if ((te.FromIP != 0) || (te.ToIP != 0))
                        hr = HResult.XONLINE_E_MIX_HOSTNAME_IP_EXCLUSION;
                    else {
			string hostname = te.Hostname;

			while (hostname.StartsWith("*.")) {
                            hostname = hostname.Substring(2);
                        }

			if (Uri.CheckHostName(hostname) != UriHostNameType.Dns) {
                            hr = HResult.XONLINE_E_MIX_INVALID_HOSTNAME;
	                }
                    }
                }


                if (hr.IsFailure()) {
                    throw new XRLException(hr, XEvent.Id.MIX_TITLEMANAGEMENT_INVALID_ARGUMENT, "Endpoint hostname or to/from IP is invalid");
                }

                // negative ports are not allowed.  65535 is a  special
                // value, anything higher is outside the  16-bit  range

                if (te.Port < 0 || te.Port > 65534) {
                    throw new XRLException(HResult.XONLINE_E_MIX_INVALID_PORT, XEvent.Id.MIX_TITLEMANAGEMENT_INVALID_ARGUMENT, "Endpoint port number must be in range 0-65534 inclusive");
                }

                e.Protocol = te.Protocol;
                e.Hostname = te.Hostname;
                e.FromIP = te.FromIP;
                e.ToIP = te.ToIP;
                e.Port = te.Port;
                e.Path = te.Path;

                if(!String.IsNullOrEmpty(te.AppliesToUrl))
                {
                    Uri atUrl = new Uri(te.AppliesToUrl);
                    if(!stsconf.AppliesToes.Keys.Contains(atUrl))
                    {
                        string exceptionString = string.Format("AppliesTo {0} doesn't exist.", te.AppliesToUrl);

                        throw new XRLException(HResult.XONLINE_E_MIX_APPLIES_TO_DOES_NOT_EXIST,
                                XEvent.Id.MIX_STS_CONFIGURATION_APPLIES_TO_DOES_NOT_EXIST,
                                exceptionString);
                    }

                    e.AppliesTo = stsconf.AppliesToes[atUrl];
                }
                else
                {
                    e.AppliesTo = null;
                }

                t.Endpoints.Add(e);
            }

            try
            {
                DatabaseWriter.SetTitleEndpoints(t);
            }
            catch(Exception e)
            {
                throw new XRLException(HResult.XONLINE_E_MIX_UNKNOWNERROR,
                        XEvent.Id.MIX_STS_CONFIGURATION_DATABASE_WRITE_ERROR,
                        e,
                        "Encountered an unknown exception writing the endpoints to the database.  See inner exception for more details.");
            }

            ForceSTSConfigurationReload();
        }

        static public TitleEndpointInfo[] GetNetworkSecurityList(uint titleID, bool fullHistory)
        {
            try
            {
                List<TitleEndpointInfo> returnList = new List<TitleEndpointInfo>();
                foreach(TitleEndpointHistory teh in DatabaseObjectFactory.GetTitleEndpointHistoryByTitleID(titleID, fullHistory))
                {
                    TitleEndpointInfo tei = new TitleEndpointInfo();
                    tei.TitleID = teh.EndpointInfo.TitleID;
                    tei.Start = teh.Start;
                    tei.End = teh.End;
                    tei.EndpointInfo.Protocol = teh.EndpointInfo.Protocol;
                    tei.EndpointInfo.Hostname = teh.EndpointInfo.Hostname;
                    tei.EndpointInfo.FromIP = teh.EndpointInfo.FromIP;
                    tei.EndpointInfo.ToIP = teh.EndpointInfo.ToIP;
                    tei.EndpointInfo.Path = teh.EndpointInfo.Path;
                    tei.EndpointInfo.Port = teh.EndpointInfo.Port;
                    tei.EndpointInfo.AppliesToUrl = teh.EndpointInfo.AppliesToUrl;

                    returnList.Add(tei);
                }

                return returnList.ToArray();
            }
            catch(Exception e)
            {
                throw new XRLException(HResult.XONLINE_E_MIX_UNKNOWNERROR,
                        XEvent.Id.MIX_STS_CONFIGURATION_DATABASE_LOAD_FAILED,
                        "Error accessing the database to retrieve the network security history.  See internal exception for more details.",
                        e);
            }
        }

        static public TitleEndpointInfo[] GetNetworkSecurityListByAppliesTo(string appliesTo, bool fullHistory)
        {
            try
            {
                List<TitleEndpointInfo> returnList = new List<TitleEndpointInfo>();

                foreach(TitleEndpointHistory teh in DatabaseObjectFactory.GetTitleEndpointHistoryByAppliesTo(appliesTo, fullHistory))
                {
                    TitleEndpointInfo tei = new TitleEndpointInfo();
                    tei.TitleID = teh.EndpointInfo.TitleID;
                    tei.Start = teh.Start;
                    tei.End = teh.End;
                    tei.EndpointInfo.Protocol = teh.EndpointInfo.Protocol;
                    tei.EndpointInfo.Hostname = teh.EndpointInfo.Hostname;
                    tei.EndpointInfo.FromIP = teh.EndpointInfo.FromIP;
                    tei.EndpointInfo.ToIP = teh.EndpointInfo.ToIP;
                    tei.EndpointInfo.Path = teh.EndpointInfo.Path;
                    tei.EndpointInfo.Port = teh.EndpointInfo.Port;
                    tei.EndpointInfo.AppliesToUrl = teh.EndpointInfo.AppliesToUrl;

                    returnList.Add(tei);
                }

                return returnList.ToArray();
            }
            catch(Exception e)
            {
                throw new XRLException(HResult.XONLINE_E_MIX_UNKNOWNERROR,
                        XEvent.Id.MIX_STS_CONFIGURATION_DATABASE_LOAD_FAILED,
                        e,
                        "Error accessing the database to retrieve the network security history.  See internal exception for more details.");
            }
        }

        private static void GetConfigObjects(out IEBBusinessPartner partner, Guid partnerId)
        {
            DatabaseConfigurationProvider dcp = new DatabaseConfigurationProvider();
            partner = null;

            try
            {
                dcp.Load();
            }
            catch(Exception e)
            {
                throw new XRLException(HResult.XONLINE_E_MIX_UNKNOWNERROR,
                        XEvent.Id.MIX_STS_CONFIGURATION_DATABASE_LOAD_FAILED,
                        "STS database configuration failed to load.  See inner exception for more details.",
                        e);
            }

            foreach(IIEBBusinessPartner ip in dcp.IEBBusinessPartners.Values)
            {
                IEBBusinessPartner p = ip as IEBBusinessPartner;
                if(p.Id == partnerId)
                {
                    partner = p;
                }
            }

            if(partner == null)
            {
                throw new XRLException(HResult.XONLINE_E_MIX_BUSINESS_PARTNER_DOES_NOT_EXIST,
                        XEvent.Id.MIX_STS_CONFIGURATION_PARTNER_DOES_NOT_EXIST,
                        "The requested business partner doesn't exist.");
            }
        }

        private static void GetConfigObjects(out STSConfiguration stsconf, out Title t, uint titleID)
        {
            t = null;
            stsconf = null;
            DatabaseConfigurationProvider dcp = new DatabaseConfigurationProvider();

            try
            {
                dcp.Load();
                stsconf = dcp.STSConfiguration as STSConfiguration;
            }
            catch(Exception e)
            {
                throw new XRLException(HResult.XONLINE_E_MIX_UNKNOWNERROR,
                        XEvent.Id.MIX_STS_CONFIGURATION_DATABASE_LOAD_FAILED,
                        "STS database configuration failed to load.  See inner exception for more details.",
                        e);
            }

            foreach(IIEBBusinessPartner ip in dcp.IEBBusinessPartners.Values)
            {
                IEBBusinessPartner p = ip as IEBBusinessPartner;
                if(p.Titles.ContainsKey(titleID))
                {
                    t = p.Titles[titleID] as Title;
                }
            }

            if(t == null)
            {
                throw new XRLException(HResult.XONLINE_E_MIX_TITLE_HAS_NO_BUSINESS_PARTNER,
                        XEvent.Id.MIX_STS_CONFIGURATION_TITLE_NOT_ASSOCIATED,
                    "This title has no associated business partner.  Call MixSettings.SetBusinessPartnerTitles.");
            }
        }

        private static void ForceSTSConfigurationReload()
        {
            try
            {
                MixUtilities.ResetFrontDoor(Interface.liveinfo, "", "liveinfo", "reloadnacl", 200);
            }
            catch (System.Exception e)
            {
                Xom.NtEvent(XEvent.Id.MIX_STS_CONFIGURATION_RELOAD_FAILED, e, "STS Configuration reload failed.  Some servers may have stale configuration data.");
            }
        }

        private static void VerifyParameterNotNull(object p, string name)
        {
            if (p==null)
            {
                throw new XRLException(HResult.XONLINE_E_MIX_ARGUMENT_NULL, XEvent.Id.MIX_TITLEMANAGEMENT_NULL_ARGUMENT, "Paramater "+name+" may not be null.");
            }
        }

        private static void VerifyParameterArrayMaxSize(System.Array arr, int maxLength, string name)
        {
            if (arr.Length>maxLength)
            {
                throw new XRLException(HResult.XONLINE_E_MIX_ARRAY_TOO_LONG, XEvent.Id.MIX_TITLEMANAGEMENT_ARGUMENT_TOO_LARGE, "Paramater "+name+" is too large.");
            }
        }

        private static void VerifyParameterArrayNotEmpty(System.Array arr, string name)
        {
            if (arr.Length==0)
            {
                throw new XRLException(HResult.XONLINE_E_MIX_ARGUMENT_EMPTY, XEvent.Id.MIX_TITLEMANAGEMENT_INVALID_ARGUMENT, "Paramater "+name+" must contain at least one element.");
            }
        }

        private static void InternalSetTitleFacebookAppId(uint titleId, string appId)
        {
            try
            {
                string connectionString = GetConnectionStringForLiveConnect();
                using (LiveConnectDataAccessDataContext lcDataCtx = new LiveConnectDataAccessDataContext(connectionString))
                {
                    lcDataCtx.ObjectTrackingEnabled = false;
                    lcDataCtx.spUpdateTitleMap((int)titleId, appId, null, false, false);
                }
            }
            catch (XRLException)
            {
                throw;
            }
            catch (Exception ex)
            {
                throw new XRLException(HResult.XONLINE_E_MIX_ENTITYFRAMEWORK_CONNECTION_ERROR, XEvent.Id.MIX_TITLEMANAGEMENT_DATABASE_RETURN_ERROR, string.Format("Operation Failed: {0}", ex.ToString()));
            }
        }

        private static string GetConnectionStringForLiveConnect()
        {
            SqlConnectionStringBuilder sqlConnBldr = new SqlConnectionStringBuilder();
            sqlConnBldr.ConnectionString = "Data Source=slsnetlc101;Initial Catalog=LiveConnect;Integrated Security=True"; // use this as a template, and change the server

            string connectionString = Config.GetSetting(Setting.mix_titlemgmt_liveconnectdbhost);

            if (!string.IsNullOrEmpty(connectionString))
            {
                sqlConnBldr["Data Source"] = connectionString;
            }
            
            return sqlConnBldr.ConnectionString;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\TokenManagement\Contracts\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\TokenManagement\Contracts\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\TitleManagement\Service\SocialConnectDataLayer\Settings.Designer.cs ===
ï»¿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.225
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace Microsoft.Xbox.SocialConnect.DataAccess.Properties {
    
    
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.Editors.SettingsDesigner.SettingsSingleFileGenerator", "10.0.0.0")]
    internal sealed partial class Settings : global::System.Configuration.ApplicationSettingsBase {
        
        private static Settings defaultInstance = ((Settings)(global::System.Configuration.ApplicationSettingsBase.Synchronized(new Settings())));
        
        public static Settings Default {
            get {
                return defaultInstance;
            }
        }
        
        [global::System.Configuration.ApplicationScopedSettingAttribute()]
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.Configuration.SpecialSettingAttribute(global::System.Configuration.SpecialSetting.ConnectionString)]
        [global::System.Configuration.DefaultSettingValueAttribute("Data Source=slsnetlc101;Initial Catalog=LiveConnect;Integrated Security=True")]
        public string LiveConnectConnectionString {
            get {
                return ((string)(this["LiveConnectConnectionString"]));
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\TitleManagement\Service\SocialConnectDataLayer\LiveConnectDataAccess.designer.cs ===
ï»¿#pragma warning disable 1591
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.225
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace Microsoft.Xbox.SocialConnect.DataAccess
{
	using System.Data.Linq;
	using System.Data.Linq.Mapping;
	using System.Data;
	using System.Collections.Generic;
	using System.Reflection;
	using System.Linq;
	using System.Linq.Expressions;
	using System.ComponentModel;
	using System;
	
	
	[global::System.Data.Linq.Mapping.DatabaseAttribute(Name="LiveConnect")]
	public partial class LiveConnectDataAccessDataContext : System.Data.Linq.DataContext
	{
		
		private static System.Data.Linq.Mapping.MappingSource mappingSource = new AttributeMappingSource();
		
    #region Extensibility Method Definitions
    partial void OnCreated();
    partial void InsertTitleMap(TitleMap instance);
    partial void UpdateTitleMap(TitleMap instance);
    partial void DeleteTitleMap(TitleMap instance);
    partial void InsertDirectory(Directory instance);
    partial void UpdateDirectory(Directory instance);
    partial void DeleteDirectory(Directory instance);
    #endregion
		
		public LiveConnectDataAccessDataContext() : 
				base(global::Microsoft.Xbox.SocialConnect.DataAccess.Properties.Settings.Default.LiveConnectConnectionString, mappingSource)
		{
			OnCreated();
		}
		
		public LiveConnectDataAccessDataContext(string connection) : 
				base(connection, mappingSource)
		{
			OnCreated();
		}
		
		public LiveConnectDataAccessDataContext(System.Data.IDbConnection connection) : 
				base(connection, mappingSource)
		{
			OnCreated();
		}
		
		public LiveConnectDataAccessDataContext(string connection, System.Data.Linq.Mapping.MappingSource mappingSource) : 
				base(connection, mappingSource)
		{
			OnCreated();
		}
		
		public LiveConnectDataAccessDataContext(System.Data.IDbConnection connection, System.Data.Linq.Mapping.MappingSource mappingSource) : 
				base(connection, mappingSource)
		{
			OnCreated();
		}
		
		public System.Data.Linq.Table<TitleMap> TitleMaps
		{
			get
			{
				return this.GetTable<TitleMap>();
			}
		}
		
		public System.Data.Linq.Table<Directory> Directories
		{
			get
			{
				return this.GetTable<Directory>();
			}
		}
		
		[global::System.Data.Linq.Mapping.FunctionAttribute(Name="dbo.spGetTitleMap")]
		public ISingleResult<spGetTitleMapResult> spGetTitleMap([global::System.Data.Linq.Mapping.ParameterAttribute(DbType="Int")] System.Nullable<int> title_id)
		{
			IExecuteResult result = this.ExecuteMethodCall(this, ((MethodInfo)(MethodInfo.GetCurrentMethod())), title_id);
			return ((ISingleResult<spGetTitleMapResult>)(result.ReturnValue));
		}
		
		[global::System.Data.Linq.Mapping.FunctionAttribute(Name="dbo.spGetTitleMapBlacklist")]
		public ISingleResult<spGetTitleMapBlacklistResult> spGetTitleMapBlacklist()
		{
			IExecuteResult result = this.ExecuteMethodCall(this, ((MethodInfo)(MethodInfo.GetCurrentMethod())));
			return ((ISingleResult<spGetTitleMapBlacklistResult>)(result.ReturnValue));
		}
		
		[global::System.Data.Linq.Mapping.FunctionAttribute(Name="dbo.spGetTitleMapFull")]
		public ISingleResult<spGetTitleMapFullResult> spGetTitleMapFull()
		{
			IExecuteResult result = this.ExecuteMethodCall(this, ((MethodInfo)(MethodInfo.GetCurrentMethod())));
			return ((ISingleResult<spGetTitleMapFullResult>)(result.ReturnValue));
		}
		
		[global::System.Data.Linq.Mapping.FunctionAttribute(Name="dbo.spGetTitleMapWhitelist")]
		public ISingleResult<spGetTitleMapWhitelistResult> spGetTitleMapWhitelist()
		{
			IExecuteResult result = this.ExecuteMethodCall(this, ((MethodInfo)(MethodInfo.GetCurrentMethod())));
			return ((ISingleResult<spGetTitleMapWhitelistResult>)(result.ReturnValue));
		}
		
		[global::System.Data.Linq.Mapping.FunctionAttribute(Name="dbo.spGetXUIDS")]
		public ISingleResult<spGetXUIDSResult> spGetXUIDS([global::System.Data.Linq.Mapping.ParameterAttribute(DbType="Int")] System.Nullable<int> sNetworkId, [global::System.Data.Linq.Mapping.ParameterAttribute(DbType="NVarChar(4000)")] string userList)
		{
			IExecuteResult result = this.ExecuteMethodCall(this, ((MethodInfo)(MethodInfo.GetCurrentMethod())), sNetworkId, userList);
			return ((ISingleResult<spGetXUIDSResult>)(result.ReturnValue));
		}
		
		[global::System.Data.Linq.Mapping.FunctionAttribute(Name="dbo.spGetXUIDSEx")]
		public ISingleResult<spGetXUIDSExResult> spGetXUIDSEx([global::System.Data.Linq.Mapping.ParameterAttribute(DbType="Int")] System.Nullable<int> sNetworkId, [global::System.Data.Linq.Mapping.ParameterAttribute(DbType="Xml")] System.Xml.Linq.XElement userList)
		{
			IExecuteResult result = this.ExecuteMethodCall(this, ((MethodInfo)(MethodInfo.GetCurrentMethod())), sNetworkId, userList);
			return ((ISingleResult<spGetXUIDSExResult>)(result.ReturnValue));
		}
		
		[global::System.Data.Linq.Mapping.FunctionAttribute(Name="dbo.spRemoveSNAuthInfo")]
		public int spRemoveSNAuthInfo([global::System.Data.Linq.Mapping.ParameterAttribute(DbType="SmallInt")] System.Nullable<short> sNetworkId, [global::System.Data.Linq.Mapping.ParameterAttribute(DbType="BigInt")] System.Nullable<long> xuid)
		{
			IExecuteResult result = this.ExecuteMethodCall(this, ((MethodInfo)(MethodInfo.GetCurrentMethod())), sNetworkId, xuid);
			return ((int)(result.ReturnValue));
		}
		
		[global::System.Data.Linq.Mapping.FunctionAttribute(Name="dbo.spRemoveUserInfo")]
		public int spRemoveUserInfo([global::System.Data.Linq.Mapping.ParameterAttribute(DbType="SmallInt")] System.Nullable<short> sNetworkId, [global::System.Data.Linq.Mapping.ParameterAttribute(DbType="BigInt")] System.Nullable<long> xuid)
		{
			IExecuteResult result = this.ExecuteMethodCall(this, ((MethodInfo)(MethodInfo.GetCurrentMethod())), sNetworkId, xuid);
			return ((int)(result.ReturnValue));
		}
		
		[global::System.Data.Linq.Mapping.FunctionAttribute(Name="dbo.spSetAuthAndUserInfo")]
		public int spSetAuthAndUserInfo([global::System.Data.Linq.Mapping.ParameterAttribute(DbType="SmallInt")] System.Nullable<short> sNetworkId, [global::System.Data.Linq.Mapping.ParameterAttribute(DbType="BigInt")] System.Nullable<long> xuid, [global::System.Data.Linq.Mapping.ParameterAttribute(DbType="NVarChar(128)")] string snUserId, [global::System.Data.Linq.Mapping.ParameterAttribute(DbType="VarChar(16)")] string gamerTag, [global::System.Data.Linq.Mapping.ParameterAttribute(DbType="VarChar(4096)")] string token, [global::System.Data.Linq.Mapping.ParameterAttribute(DbType="VarChar(32)")] string deviceId, [global::System.Data.Linq.Mapping.ParameterAttribute(DbType="Int")] System.Nullable<int> flags, [global::System.Data.Linq.Mapping.ParameterAttribute(DbType="SmallInt")] System.Nullable<short> preserveToken)
		{
			IExecuteResult result = this.ExecuteMethodCall(this, ((MethodInfo)(MethodInfo.GetCurrentMethod())), sNetworkId, xuid, snUserId, gamerTag, token, deviceId, flags, preserveToken);
			return ((int)(result.ReturnValue));
		}
		
		[global::System.Data.Linq.Mapping.FunctionAttribute(Name="dbo.spSetSNAuthInfo")]
		public int spSetSNAuthInfo([global::System.Data.Linq.Mapping.ParameterAttribute(DbType="SmallInt")] System.Nullable<short> sNetworkId, [global::System.Data.Linq.Mapping.ParameterAttribute(DbType="BigInt")] System.Nullable<long> xuid, [global::System.Data.Linq.Mapping.ParameterAttribute(DbType="NVarChar(128)")] string snUserId, [global::System.Data.Linq.Mapping.ParameterAttribute(DbType="VarChar(4096)")] string token, [global::System.Data.Linq.Mapping.ParameterAttribute(DbType="VarChar(32)")] string deviceId, [global::System.Data.Linq.Mapping.ParameterAttribute(DbType="SmallInt")] System.Nullable<short> preserveToken)
		{
			IExecuteResult result = this.ExecuteMethodCall(this, ((MethodInfo)(MethodInfo.GetCurrentMethod())), sNetworkId, xuid, snUserId, token, deviceId, preserveToken);
			return ((int)(result.ReturnValue));
		}
		
		[global::System.Data.Linq.Mapping.FunctionAttribute(Name="dbo.spSetSNUserInfo")]
		public int spSetSNUserInfo([global::System.Data.Linq.Mapping.ParameterAttribute(DbType="SmallInt")] System.Nullable<short> sNetworkId, [global::System.Data.Linq.Mapping.ParameterAttribute(DbType="BigInt")] System.Nullable<long> xuid, [global::System.Data.Linq.Mapping.ParameterAttribute(DbType="NVarChar(128)")] string snUserId, [global::System.Data.Linq.Mapping.ParameterAttribute(DbType="VarChar(16)")] string gamerTag, [global::System.Data.Linq.Mapping.ParameterAttribute(DbType="Int")] System.Nullable<int> flags)
		{
			IExecuteResult result = this.ExecuteMethodCall(this, ((MethodInfo)(MethodInfo.GetCurrentMethod())), sNetworkId, xuid, snUserId, gamerTag, flags);
			return ((int)(result.ReturnValue));
		}
		
		[global::System.Data.Linq.Mapping.FunctionAttribute(Name="dbo.spUpdateTitleMap")]
		public int spUpdateTitleMap([global::System.Data.Linq.Mapping.ParameterAttribute(DbType="Int")] System.Nullable<int> i_title_id, [global::System.Data.Linq.Mapping.ParameterAttribute(DbType="NVarChar(MAX)")] string vc_fbApp_id, [global::System.Data.Linq.Mapping.ParameterAttribute(DbType="NVarChar(64)")] string vc_name, [global::System.Data.Linq.Mapping.ParameterAttribute(DbType="Bit")] System.Nullable<bool> b_blacklisted, [global::System.Data.Linq.Mapping.ParameterAttribute(DbType="Bit")] System.Nullable<bool> b_whitelisted)
		{
			IExecuteResult result = this.ExecuteMethodCall(this, ((MethodInfo)(MethodInfo.GetCurrentMethod())), i_title_id, vc_fbApp_id, vc_name, b_blacklisted, b_whitelisted);
			return ((int)(result.ReturnValue));
		}
	}
	
	[global::System.Data.Linq.Mapping.TableAttribute(Name="dbo.TitleMap")]
	public partial class TitleMap : INotifyPropertyChanging, INotifyPropertyChanged
	{
		
		private static PropertyChangingEventArgs emptyChangingEventArgs = new PropertyChangingEventArgs(String.Empty);
		
		private int _i_title_id;
		
		private string _vc_fbApp_id;
		
		private string _vc_name;
		
		private bool _b_blacklisted;
		
		private bool _b_whitelisted;
		
		private System.DateTime _dt_LastUpdatedTime;
		
    #region Extensibility Method Definitions
    partial void OnLoaded();
    partial void OnValidate(System.Data.Linq.ChangeAction action);
    partial void OnCreated();
    partial void Oni_title_idChanging(int value);
    partial void Oni_title_idChanged();
    partial void Onvc_fbApp_idChanging(string value);
    partial void Onvc_fbApp_idChanged();
    partial void Onvc_nameChanging(string value);
    partial void Onvc_nameChanged();
    partial void Onb_blacklistedChanging(bool value);
    partial void Onb_blacklistedChanged();
    partial void Onb_whitelistedChanging(bool value);
    partial void Onb_whitelistedChanged();
    partial void Ondt_LastUpdatedTimeChanging(System.DateTime value);
    partial void Ondt_LastUpdatedTimeChanged();
    #endregion
		
		public TitleMap()
		{
			OnCreated();
		}
		
		[global::System.Data.Linq.Mapping.ColumnAttribute(Storage="_i_title_id", DbType="Int NOT NULL", IsPrimaryKey=true)]
		public int i_title_id
		{
			get
			{
				return this._i_title_id;
			}
			set
			{
				if ((this._i_title_id != value))
				{
					this.Oni_title_idChanging(value);
					this.SendPropertyChanging();
					this._i_title_id = value;
					this.SendPropertyChanged("i_title_id");
					this.Oni_title_idChanged();
				}
			}
		}
		
		[global::System.Data.Linq.Mapping.ColumnAttribute(Storage="_vc_fbApp_id", DbType="NVarChar(MAX) NOT NULL", CanBeNull=false)]
		public string vc_fbApp_id
		{
			get
			{
				return this._vc_fbApp_id;
			}
			set
			{
				if ((this._vc_fbApp_id != value))
				{
					this.Onvc_fbApp_idChanging(value);
					this.SendPropertyChanging();
					this._vc_fbApp_id = value;
					this.SendPropertyChanged("vc_fbApp_id");
					this.Onvc_fbApp_idChanged();
				}
			}
		}
		
		[global::System.Data.Linq.Mapping.ColumnAttribute(Storage="_vc_name", DbType="NVarChar(64)")]
		public string vc_name
		{
			get
			{
				return this._vc_name;
			}
			set
			{
				if ((this._vc_name != value))
				{
					this.Onvc_nameChanging(value);
					this.SendPropertyChanging();
					this._vc_name = value;
					this.SendPropertyChanged("vc_name");
					this.Onvc_nameChanged();
				}
			}
		}
		
		[global::System.Data.Linq.Mapping.ColumnAttribute(Storage="_b_blacklisted", DbType="Bit NOT NULL")]
		public bool b_blacklisted
		{
			get
			{
				return this._b_blacklisted;
			}
			set
			{
				if ((this._b_blacklisted != value))
				{
					this.Onb_blacklistedChanging(value);
					this.SendPropertyChanging();
					this._b_blacklisted = value;
					this.SendPropertyChanged("b_blacklisted");
					this.Onb_blacklistedChanged();
				}
			}
		}
		
		[global::System.Data.Linq.Mapping.ColumnAttribute(Storage="_b_whitelisted", DbType="Bit NOT NULL")]
		public bool b_whitelisted
		{
			get
			{
				return this._b_whitelisted;
			}
			set
			{
				if ((this._b_whitelisted != value))
				{
					this.Onb_whitelistedChanging(value);
					this.SendPropertyChanging();
					this._b_whitelisted = value;
					this.SendPropertyChanged("b_whitelisted");
					this.Onb_whitelistedChanged();
				}
			}
		}
		
		[global::System.Data.Linq.Mapping.ColumnAttribute(Storage="_dt_LastUpdatedTime", DbType="DateTime2 NOT NULL")]
		public System.DateTime dt_LastUpdatedTime
		{
			get
			{
				return this._dt_LastUpdatedTime;
			}
			set
			{
				if ((this._dt_LastUpdatedTime != value))
				{
					this.Ondt_LastUpdatedTimeChanging(value);
					this.SendPropertyChanging();
					this._dt_LastUpdatedTime = value;
					this.SendPropertyChanged("dt_LastUpdatedTime");
					this.Ondt_LastUpdatedTimeChanged();
				}
			}
		}
		
		public event PropertyChangingEventHandler PropertyChanging;
		
		public event PropertyChangedEventHandler PropertyChanged;
		
		protected virtual void SendPropertyChanging()
		{
			if ((this.PropertyChanging != null))
			{
				this.PropertyChanging(this, emptyChangingEventArgs);
			}
		}
		
		protected virtual void SendPropertyChanged(String propertyName)
		{
			if ((this.PropertyChanged != null))
			{
				this.PropertyChanged(this, new PropertyChangedEventArgs(propertyName));
			}
		}
	}
	
	[global::System.Data.Linq.Mapping.TableAttribute(Name="dbo.Directory")]
	public partial class Directory : INotifyPropertyChanging, INotifyPropertyChanged
	{
		
		private static PropertyChangingEventArgs emptyChangingEventArgs = new PropertyChangingEventArgs(String.Empty);
		
		private short _SNetworkId;
		
		private long _XUID;
		
		private string _SNUserId;
		
		private string _GamerTag;
		
		private int _Flags;
		
		private System.DateTime _LastAccessedTime;
		
    #region Extensibility Method Definitions
    partial void OnLoaded();
    partial void OnValidate(System.Data.Linq.ChangeAction action);
    partial void OnCreated();
    partial void OnSNetworkIdChanging(short value);
    partial void OnSNetworkIdChanged();
    partial void OnXUIDChanging(long value);
    partial void OnXUIDChanged();
    partial void OnSNUserIdChanging(string value);
    partial void OnSNUserIdChanged();
    partial void OnGamerTagChanging(string value);
    partial void OnGamerTagChanged();
    partial void OnFlagsChanging(int value);
    partial void OnFlagsChanged();
    partial void OnLastAccessedTimeChanging(System.DateTime value);
    partial void OnLastAccessedTimeChanged();
    #endregion
		
		public Directory()
		{
			OnCreated();
		}
		
		[global::System.Data.Linq.Mapping.ColumnAttribute(Storage="_SNetworkId", DbType="SmallInt NOT NULL", IsPrimaryKey=true)]
		public short SNetworkId
		{
			get
			{
				return this._SNetworkId;
			}
			set
			{
				if ((this._SNetworkId != value))
				{
					this.OnSNetworkIdChanging(value);
					this.SendPropertyChanging();
					this._SNetworkId = value;
					this.SendPropertyChanged("SNetworkId");
					this.OnSNetworkIdChanged();
				}
			}
		}
		
		[global::System.Data.Linq.Mapping.ColumnAttribute(Storage="_XUID", DbType="BigInt NOT NULL", IsPrimaryKey=true)]
		public long XUID
		{
			get
			{
				return this._XUID;
			}
			set
			{
				if ((this._XUID != value))
				{
					this.OnXUIDChanging(value);
					this.SendPropertyChanging();
					this._XUID = value;
					this.SendPropertyChanged("XUID");
					this.OnXUIDChanged();
				}
			}
		}
		
		[global::System.Data.Linq.Mapping.ColumnAttribute(Storage="_SNUserId", DbType="NVarChar(128) NOT NULL", CanBeNull=false)]
		public string SNUserId
		{
			get
			{
				return this._SNUserId;
			}
			set
			{
				if ((this._SNUserId != value))
				{
					this.OnSNUserIdChanging(value);
					this.SendPropertyChanging();
					this._SNUserId = value;
					this.SendPropertyChanged("SNUserId");
					this.OnSNUserIdChanged();
				}
			}
		}
		
		[global::System.Data.Linq.Mapping.ColumnAttribute(Storage="_GamerTag", DbType="VarChar(16) NOT NULL", CanBeNull=false)]
		public string GamerTag
		{
			get
			{
				return this._GamerTag;
			}
			set
			{
				if ((this._GamerTag != value))
				{
					this.OnGamerTagChanging(value);
					this.SendPropertyChanging();
					this._GamerTag = value;
					this.SendPropertyChanged("GamerTag");
					this.OnGamerTagChanged();
				}
			}
		}
		
		[global::System.Data.Linq.Mapping.ColumnAttribute(Storage="_Flags", DbType="Int NOT NULL")]
		public int Flags
		{
			get
			{
				return this._Flags;
			}
			set
			{
				if ((this._Flags != value))
				{
					this.OnFlagsChanging(value);
					this.SendPropertyChanging();
					this._Flags = value;
					this.SendPropertyChanged("Flags");
					this.OnFlagsChanged();
				}
			}
		}
		
		[global::System.Data.Linq.Mapping.ColumnAttribute(Storage="_LastAccessedTime", DbType="DateTime2 NOT NULL")]
		public System.DateTime LastAccessedTime
		{
			get
			{
				return this._LastAccessedTime;
			}
			set
			{
				if ((this._LastAccessedTime != value))
				{
					this.OnLastAccessedTimeChanging(value);
					this.SendPropertyChanging();
					this._LastAccessedTime = value;
					this.SendPropertyChanged("LastAccessedTime");
					this.OnLastAccessedTimeChanged();
				}
			}
		}
		
		public event PropertyChangingEventHandler PropertyChanging;
		
		public event PropertyChangedEventHandler PropertyChanged;
		
		protected virtual void SendPropertyChanging()
		{
			if ((this.PropertyChanging != null))
			{
				this.PropertyChanging(this, emptyChangingEventArgs);
			}
		}
		
		protected virtual void SendPropertyChanged(String propertyName)
		{
			if ((this.PropertyChanged != null))
			{
				this.PropertyChanged(this, new PropertyChangedEventArgs(propertyName));
			}
		}
	}
	
	public partial class spGetTitleMapResult
	{
		
		private int _i_title_id;
		
		private string _vc_fbApp_id;
		
		private string _vc_name;
		
		private bool _b_blacklisted;
		
		private bool _b_whitelisted;
		
		private System.DateTime _dt_LastUpdatedTime;
		
		public spGetTitleMapResult()
		{
		}
		
		[global::System.Data.Linq.Mapping.ColumnAttribute(Storage="_i_title_id", DbType="Int NOT NULL")]
		public int i_title_id
		{
			get
			{
				return this._i_title_id;
			}
			set
			{
				if ((this._i_title_id != value))
				{
					this._i_title_id = value;
				}
			}
		}
		
		[global::System.Data.Linq.Mapping.ColumnAttribute(Storage="_vc_fbApp_id", DbType="NVarChar(MAX) NOT NULL", CanBeNull=false)]
		public string vc_fbApp_id
		{
			get
			{
				return this._vc_fbApp_id;
			}
			set
			{
				if ((this._vc_fbApp_id != value))
				{
					this._vc_fbApp_id = value;
				}
			}
		}
		
		[global::System.Data.Linq.Mapping.ColumnAttribute(Storage="_vc_name", DbType="NVarChar(64)")]
		public string vc_name
		{
			get
			{
				return this._vc_name;
			}
			set
			{
				if ((this._vc_name != value))
				{
					this._vc_name = value;
				}
			}
		}
		
		[global::System.Data.Linq.Mapping.ColumnAttribute(Storage="_b_blacklisted", DbType="Bit NOT NULL")]
		public bool b_blacklisted
		{
			get
			{
				return this._b_blacklisted;
			}
			set
			{
				if ((this._b_blacklisted != value))
				{
					this._b_blacklisted = value;
				}
			}
		}
		
		[global::System.Data.Linq.Mapping.ColumnAttribute(Storage="_b_whitelisted", DbType="Bit NOT NULL")]
		public bool b_whitelisted
		{
			get
			{
				return this._b_whitelisted;
			}
			set
			{
				if ((this._b_whitelisted != value))
				{
					this._b_whitelisted = value;
				}
			}
		}
		
		[global::System.Data.Linq.Mapping.ColumnAttribute(Storage="_dt_LastUpdatedTime", DbType="DateTime2 NOT NULL")]
		public System.DateTime dt_LastUpdatedTime
		{
			get
			{
				return this._dt_LastUpdatedTime;
			}
			set
			{
				if ((this._dt_LastUpdatedTime != value))
				{
					this._dt_LastUpdatedTime = value;
				}
			}
		}
	}
	
	public partial class spGetTitleMapBlacklistResult
	{
		
		private int _i_title_id;
		
		private string _vc_fbApp_id;
		
		private string _vc_name;
		
		private bool _b_blacklisted;
		
		private bool _b_whitelisted;
		
		private System.DateTime _dt_LastUpdatedTime;
		
		public spGetTitleMapBlacklistResult()
		{
		}
		
		[global::System.Data.Linq.Mapping.ColumnAttribute(Storage="_i_title_id", DbType="Int NOT NULL")]
		public int i_title_id
		{
			get
			{
				return this._i_title_id;
			}
			set
			{
				if ((this._i_title_id != value))
				{
					this._i_title_id = value;
				}
			}
		}
		
		[global::System.Data.Linq.Mapping.ColumnAttribute(Storage="_vc_fbApp_id", DbType="NVarChar(MAX) NOT NULL", CanBeNull=false)]
		public string vc_fbApp_id
		{
			get
			{
				return this._vc_fbApp_id;
			}
			set
			{
				if ((this._vc_fbApp_id != value))
				{
					this._vc_fbApp_id = value;
				}
			}
		}
		
		[global::System.Data.Linq.Mapping.ColumnAttribute(Storage="_vc_name", DbType="NVarChar(64)")]
		public string vc_name
		{
			get
			{
				return this._vc_name;
			}
			set
			{
				if ((this._vc_name != value))
				{
					this._vc_name = value;
				}
			}
		}
		
		[global::System.Data.Linq.Mapping.ColumnAttribute(Storage="_b_blacklisted", DbType="Bit NOT NULL")]
		public bool b_blacklisted
		{
			get
			{
				return this._b_blacklisted;
			}
			set
			{
				if ((this._b_blacklisted != value))
				{
					this._b_blacklisted = value;
				}
			}
		}
		
		[global::System.Data.Linq.Mapping.ColumnAttribute(Storage="_b_whitelisted", DbType="Bit NOT NULL")]
		public bool b_whitelisted
		{
			get
			{
				return this._b_whitelisted;
			}
			set
			{
				if ((this._b_whitelisted != value))
				{
					this._b_whitelisted = value;
				}
			}
		}
		
		[global::System.Data.Linq.Mapping.ColumnAttribute(Storage="_dt_LastUpdatedTime", DbType="DateTime2 NOT NULL")]
		public System.DateTime dt_LastUpdatedTime
		{
			get
			{
				return this._dt_LastUpdatedTime;
			}
			set
			{
				if ((this._dt_LastUpdatedTime != value))
				{
					this._dt_LastUpdatedTime = value;
				}
			}
		}
	}
	
	public partial class spGetTitleMapFullResult
	{
		
		private int _i_title_id;
		
		private string _vc_fbApp_id;
		
		private bool _b_blacklisted;
		
		private bool _b_whitelisted;
		
		private System.DateTime _dt_LastUpdatedTime;
		
		public spGetTitleMapFullResult()
		{
		}
		
		[global::System.Data.Linq.Mapping.ColumnAttribute(Storage="_i_title_id", DbType="Int NOT NULL")]
		public int i_title_id
		{
			get
			{
				return this._i_title_id;
			}
			set
			{
				if ((this._i_title_id != value))
				{
					this._i_title_id = value;
				}
			}
		}
		
		[global::System.Data.Linq.Mapping.ColumnAttribute(Storage="_vc_fbApp_id", DbType="NVarChar(MAX) NOT NULL", CanBeNull=false)]
		public string vc_fbApp_id
		{
			get
			{
				return this._vc_fbApp_id;
			}
			set
			{
				if ((this._vc_fbApp_id != value))
				{
					this._vc_fbApp_id = value;
				}
			}
		}
		
		[global::System.Data.Linq.Mapping.ColumnAttribute(Storage="_b_blacklisted", DbType="Bit NOT NULL")]
		public bool b_blacklisted
		{
			get
			{
				return this._b_blacklisted;
			}
			set
			{
				if ((this._b_blacklisted != value))
				{
					this._b_blacklisted = value;
				}
			}
		}
		
		[global::System.Data.Linq.Mapping.ColumnAttribute(Storage="_b_whitelisted", DbType="Bit NOT NULL")]
		public bool b_whitelisted
		{
			get
			{
				return this._b_whitelisted;
			}
			set
			{
				if ((this._b_whitelisted != value))
				{
					this._b_whitelisted = value;
				}
			}
		}
		
		[global::System.Data.Linq.Mapping.ColumnAttribute(Storage="_dt_LastUpdatedTime", DbType="DateTime2 NOT NULL")]
		public System.DateTime dt_LastUpdatedTime
		{
			get
			{
				return this._dt_LastUpdatedTime;
			}
			set
			{
				if ((this._dt_LastUpdatedTime != value))
				{
					this._dt_LastUpdatedTime = value;
				}
			}
		}
	}
	
	public partial class spGetTitleMapWhitelistResult
	{
		
		private int _i_title_id;
		
		private string _vc_fbApp_id;
		
		private string _vc_name;
		
		private bool _b_blacklisted;
		
		private bool _b_whitelisted;
		
		private System.DateTime _dt_LastUpdatedTime;
		
		public spGetTitleMapWhitelistResult()
		{
		}
		
		[global::System.Data.Linq.Mapping.ColumnAttribute(Storage="_i_title_id", DbType="Int NOT NULL")]
		public int i_title_id
		{
			get
			{
				return this._i_title_id;
			}
			set
			{
				if ((this._i_title_id != value))
				{
					this._i_title_id = value;
				}
			}
		}
		
		[global::System.Data.Linq.Mapping.ColumnAttribute(Storage="_vc_fbApp_id", DbType="NVarChar(MAX) NOT NULL", CanBeNull=false)]
		public string vc_fbApp_id
		{
			get
			{
				return this._vc_fbApp_id;
			}
			set
			{
				if ((this._vc_fbApp_id != value))
				{
					this._vc_fbApp_id = value;
				}
			}
		}
		
		[global::System.Data.Linq.Mapping.ColumnAttribute(Storage="_vc_name", DbType="NVarChar(64)")]
		public string vc_name
		{
			get
			{
				return this._vc_name;
			}
			set
			{
				if ((this._vc_name != value))
				{
					this._vc_name = value;
				}
			}
		}
		
		[global::System.Data.Linq.Mapping.ColumnAttribute(Storage="_b_blacklisted", DbType="Bit NOT NULL")]
		public bool b_blacklisted
		{
			get
			{
				return this._b_blacklisted;
			}
			set
			{
				if ((this._b_blacklisted != value))
				{
					this._b_blacklisted = value;
				}
			}
		}
		
		[global::System.Data.Linq.Mapping.ColumnAttribute(Storage="_b_whitelisted", DbType="Bit NOT NULL")]
		public bool b_whitelisted
		{
			get
			{
				return this._b_whitelisted;
			}
			set
			{
				if ((this._b_whitelisted != value))
				{
					this._b_whitelisted = value;
				}
			}
		}
		
		[global::System.Data.Linq.Mapping.ColumnAttribute(Storage="_dt_LastUpdatedTime", DbType="DateTime2 NOT NULL")]
		public System.DateTime dt_LastUpdatedTime
		{
			get
			{
				return this._dt_LastUpdatedTime;
			}
			set
			{
				if ((this._dt_LastUpdatedTime != value))
				{
					this._dt_LastUpdatedTime = value;
				}
			}
		}
	}
	
	public partial class spGetXUIDSResult
	{
		
		private long _XUID;
		
		private string _SNUserId;
		
		private string _GamerTag;
		
		private int _Flags;
		
		public spGetXUIDSResult()
		{
		}
		
		[global::System.Data.Linq.Mapping.ColumnAttribute(Storage="_XUID", DbType="BigInt NOT NULL")]
		public long XUID
		{
			get
			{
				return this._XUID;
			}
			set
			{
				if ((this._XUID != value))
				{
					this._XUID = value;
				}
			}
		}
		
		[global::System.Data.Linq.Mapping.ColumnAttribute(Storage="_SNUserId", DbType="NVarChar(128) NOT NULL", CanBeNull=false)]
		public string SNUserId
		{
			get
			{
				return this._SNUserId;
			}
			set
			{
				if ((this._SNUserId != value))
				{
					this._SNUserId = value;
				}
			}
		}
		
		[global::System.Data.Linq.Mapping.ColumnAttribute(Storage="_GamerTag", DbType="VarChar(16) NOT NULL", CanBeNull=false)]
		public string GamerTag
		{
			get
			{
				return this._GamerTag;
			}
			set
			{
				if ((this._GamerTag != value))
				{
					this._GamerTag = value;
				}
			}
		}
		
		[global::System.Data.Linq.Mapping.ColumnAttribute(Storage="_Flags", DbType="Int NOT NULL")]
		public int Flags
		{
			get
			{
				return this._Flags;
			}
			set
			{
				if ((this._Flags != value))
				{
					this._Flags = value;
				}
			}
		}
	}
	
	public partial class spGetXUIDSExResult
	{
		
		private long _XUID;
		
		private string _SNUserId;
		
		private string _GamerTag;
		
		private int _Flags;
		
		public spGetXUIDSExResult()
		{
		}
		
		[global::System.Data.Linq.Mapping.ColumnAttribute(Storage="_XUID", DbType="BigInt NOT NULL")]
		public long XUID
		{
			get
			{
				return this._XUID;
			}
			set
			{
				if ((this._XUID != value))
				{
					this._XUID = value;
				}
			}
		}
		
		[global::System.Data.Linq.Mapping.ColumnAttribute(Storage="_SNUserId", DbType="NVarChar(128) NOT NULL", CanBeNull=false)]
		public string SNUserId
		{
			get
			{
				return this._SNUserId;
			}
			set
			{
				if ((this._SNUserId != value))
				{
					this._SNUserId = value;
				}
			}
		}
		
		[global::System.Data.Linq.Mapping.ColumnAttribute(Storage="_GamerTag", DbType="VarChar(16) NOT NULL", CanBeNull=false)]
		public string GamerTag
		{
			get
			{
				return this._GamerTag;
			}
			set
			{
				if ((this._GamerTag != value))
				{
					this._GamerTag = value;
				}
			}
		}
		
		[global::System.Data.Linq.Mapping.ColumnAttribute(Storage="_Flags", DbType="Int NOT NULL")]
		public int Flags
		{
			get
			{
				return this._Flags;
			}
			set
			{
				if ((this._Flags != value))
				{
					this._Flags = value;
				}
			}
		}
	}
}
#pragma warning restore 1591
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\TokenManagement\Contracts\DataContractV1.cs ===
ï»¿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Runtime.Serialization;


namespace Xonline.Mix.TokenManagement.Contract
{
    [DataContract(Name = "TokenCategory", Namespace = "http://xonline.mix.tokenmanagement.contracts/V1")]
    public class TokenCategoryV1
    {
        /// <summary>
        /// The id of the token category
        /// </summary>
        [DataMember(Name = "TokenCategoryId")]
        public Guid TokenCategoryId { get; set; }

        /// <summary>
        /// The name of the token category, for example "BestBuy 12-month Gold Prepaid Card"
        /// </summary>
        [DataMember(Name = "TokenCategoryName")]
        public string TokenCategoryName { get; set; }

        /// <summary>
        /// The expiration date of all the tokens in this category
        /// </summary>
        [DataMember(Name = "ExpirationDate")]
        public DateTime ExpirationDate { get; set; }

        /// <summary>
        /// The offer id associated with the tokens in this category
        /// </summary>
        [DataMember(Name = "OfferId")]
        public Guid OfferId { get; set; }

        /// <summary>
        /// The promotion id associated with the tokens in this category
        /// </summary>
        [DataMember(Name = "PromotionId")]
        public Guid PromotionId { get; set; }

        /// <summary>
        /// The product type of the offer associated with the tokens in this category
        /// </summary>
        [DataMember(Name = "ProductTypeId")]
        public uint ProductTypeId { get; set; }

        /// <summary>
        /// Whether the tokens in this category is in CSAT system
        /// </summary>
        [DataMember(Name = "InCsat")]
        public bool InCsat { get; set; }

        /// <summary>
        /// RSM token flag
        /// </summary>
        [DataMember(Name = "IsRsm")]
        public bool IsRsm { get; set; }

        /// <summary>
        /// PKPN property
        /// </summary>
        [DataMember(Name = "Pkpn")]
        public string Pkpn { get; set; }

        /// <summary>
        /// ChannelTypeId property
        /// </summary>
        [DataMember(Name = "ChannelTypeId")]
        public int ChannelTypeId { get; set; }

        /// <summary>
        /// IsRevenueBearing token flag
        /// </summary>
        [DataMember(Name = "IsRevenueBearing")]
        public bool IsRevenueBearing { get; set; }

        /// <summary>
        /// Token Type Property used to categorize tokens
        /// </summary>
        [DataMember(Name = "TokenType")]
        public string TokenType { get; set; }

        /// <summary>
        /// Channel SKU Property for Setting Partner Configuration.
        /// </summary>
        [DataMember(Name = "ChannelSKUArray")]

        public ChannelSKU[] ChannelSKUArray { get; set; }

        /// <summary>
        /// Royalty bearing flag
        /// </summary>
        [DataMember(Name = "IsRoyaltyBearing")]

        public bool IsRoyaltyBearing { get; set; }

        /// <summary>
        /// Redemption State Flag, true means token is redeemable
        /// </summary>
        [DataMember(Name = "IsRedeemable")]

        public bool IsRedeemable { get; set; }
    }

    [DataContract(Name = "TokenInfo", Namespace = "http://xonline.mix.tokenmanagement.contracts/V1")]
    public class TokenInfoV1
    {
        /// <summary>
        /// TokenCategory object associated with that token
        /// </summary>
        [DataMember(Name = "Category")]
        public TokenCategoryV1 Category { get; set; }

        /// <summary>
        /// Hash code for that token
        /// </summary>
        [DataMember(Name = "Hash")]
        public byte[] Hash { get; set; }

        /// <summary>
        /// Token Status ID
        /// </summary>
        [DataMember(Name = "StatusId")]
        public int StatusId { get; set; }

        /// <summary>
        /// Token use count (for multi-use tokens)
        /// </summary>
        [DataMember(Name = "UseCount")]
        public int UseCount { get; set; }

        /// <summary>
        /// the version of console
        /// NOTE: this field is for XBox1 only and to be deprecated by the next release
        ///       however it must be supported for backward compatibility reasons
        /// </summary>
        [DataMember(Name = "ConsoleVersion")]
        public byte ConsoleVersion { get; set; }

        /// <summary>
        /// Sequence number of this token.
        /// PKPN (saved in token category) + Sequence Number will uniquely identify a token.
        /// It is used for other systems such as CSAT to keep track of tokens.
        /// </summary>
        [DataMember(Name = "SequenceNumber")]
        public uint SequenceNumber { get; set; }

        /// <summary>
        /// returns TokenRedemption[] collection of objects;
        /// links to userPuid and dateRedeemed values in each object
        /// </summary>
        [DataMember(Name = "Redemptions")]
        public TokenRedemptionV1[] Redemptions { get; set; }
    }

    [DataContract(Name = "TokenRedemption", Namespace = "http://xonline.mix.tokenmanagement.contracts/V1")]
    public class TokenRedemptionV1
    {
        /// <summary>
        /// Puid for that user
        /// </summary>
        [DataMember(Name = "UserPuid")]
        public ulong UserPuid { get; set; }

        /// <summary>
        /// Date the token was redeemed
        /// </summary>
        [DataMember(Name = "DateRedeemed")]
        public DateTime DateRedeemed { get; set; }
    }


    [DataContract(Name = "TokenJob", Namespace = "http://xonline.mix.tokenmanagement.contracts/V1")]
    public class TokenJobV1
    {
        /// <summary>
        /// Id of the token job
        /// </summary>
        [DataMember(Name = "TokenJobId")]
        public Guid TokenJobId { get; set; }

        /// <summary>
        /// Which token category the job need to generate the tokens for
        /// </summary>
        [DataMember(Name = "TokenCategoryId")]
        public Guid TokenCategoryId { get; set; }

        /// <summary>
        /// How many tokens need to be generated
        /// </summary>
        [DataMember(Name = "NumTokensRequested")]
        public uint NumTokensRequested;
    }

    [DataContract(Name = "TokenJobStatusEnum", Namespace = "http://xonline.mix.tokenmanagement.contracts/V1")]
    public enum TokenJobStatusEnumV1
    {
        [EnumMember]
        Pending = 1,
        [EnumMember]
        InProgress = 2,
        [EnumMember]
        Delivered = 3,
        [EnumMember]
        Failed = 4,
    }

    [DataContract(Name = "TokenJobStatus", Namespace = "http://xonline.mix.tokenmanagement.contracts/V1")]
    public class TokenJobStatusV1
    {
        /// <summary>
        /// Token job id
        /// </summary>
        [DataMember(Name = "TokenJobId")]
        public Guid TokenJobId { get; set; }

        /// <summary>
        /// What is the status code of this job
        /// </summary>
        [DataMember(Name = "Status")]
        public TokenJobStatusEnumV1 Status { get; set; }

        /// <summary>
        /// When is the last time the job has any activity
        /// </summary>
        [DataMember(Name = "LastActivity")]
        public DateTime LastActivity { get; set; }

        /// <summary>
        /// Is the job not being accessed for a very long time
        /// </summary>
        [DataMember(Name = "IsStale")]
        public bool IsStale { get; set; }

        /// <summary>
        /// Number of tokens that already been generated
        /// </summary>
        [DataMember(Name = "NumTokensRequested")]
        public uint NumTokensRequested { get; set; }

        /// <summary>
        /// Number of tokens that already been generated
        /// </summary>
        [DataMember(Name = "NumTokensCompleted")]
        public uint NumTokensCompleted { get; set; }

        /// <summary>
        /// When the job was originally submitted
        /// </summary>
        [DataMember(Name = "Submitted")]
        public DateTime Submitted { get; set; }

        /// <summary>
        /// Number of failures encountered processing token job
        /// </summary>
        [DataMember(Name = "NumFailures")]
        public uint NumFailures { get; set; }

        /// <summary>
        /// When the job is next eligible to be processed
        /// </summary>
        [DataMember(Name = "NextProcessing")]
        public DateTime NextProcessing { get; set; }

        /// <summary>
        /// Is the job for generating test tokens
        /// </summary>
        [DataMember(Name = "IsTest")]
        public bool IsTest { get; set; }

        /// <summary>
        /// TokenFile filename
        /// </summary>
        [DataMember(Name = "TokenFile")]
        public string TokenFile { get; set; }

        /// <summary>
        /// HashFile filename
        /// </summary>
        [DataMember(Name = "HashFile")]
        public string HashFile { get; set; }

    }

    [DataContract(Name = "TokenEntry", Namespace = "http://xonline.mix.tokenmanagement.contracts/V1")]
    public class TokenEntry
    {
        /// <summary>
        /// Token string (5x5 format)
        /// </summary>
        [DataMember(Name = "Token")]
        public string Token { get; set; }

        /// <summary>
        /// PKPN property
        /// </summary>
        [DataMember(Name = "Pkpn")]
        public string Pkpn { get; set; }

        /// <summary>
        /// Sequence number of this token.
        /// PKPN (saved in token category) + Sequence Number will uniquely identify a token.
        /// It is used for other systems such as CSAT to keep track of tokens.
        /// </summary>
        [DataMember(Name = "SequenceNumber")]
        public uint SequenceNumber { get; set; }
    }

    [DataContract(Name = "ChannelSKU", Namespace = "http://xonline.mix.tokenmanagement.contracts/V1")]
    public class ChannelSKU
    {
        /// <summary>
        /// Channel SKU Value
        /// </summary>
        [DataMember(Name = "ID")]
        public string ID { get; set; }

        /// <summary>
        /// Percentage allocation of the PKPN in Channel SKU
        /// </summary>
        [DataMember(Name = "PercentageAllocation")]
        public double PercentageAllocation { get; set; }

        /// <summary>
        /// Bill of meterial's quantity
        /// </summary>
        [DataMember(Name = "BOMQuantity")]
        public int BOMQuantity { get; set; }

        /// <summary>
        /// Min price of the PKPN sold
        /// </summary>
        [DataMember(Name = "MinPriceUSD")]
        public double MinPriceUSD { get; set; }

        /// <summary>
        /// Max price of the PKPN sold
        /// </summary>
        [DataMember(Name = "MaxPriceUSD")]
        public double MaxPriceUSD { get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\TokenManagement\DecryptTool\DecryptLibrary\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\TokenManagement\Contracts\ServiceContractV1.cs ===
ï»¿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.ServiceModel;
using xonline.mix.common;

namespace Xonline.Mix.TokenManagement.Contract
{
    // NOTE: If you change the interface name "IMixTokenManagement" here, you must also update the reference to "IMixTokenManagement" in Web.config.
    [ServiceContract(Name = "IMixTokenManagement", Namespace = "http://xonline.mix.tokenmanagement.contracts/V1")]
    public interface IMixTokenManagementV1
    {
        /// <summary>
        /// Configure (create or update) the token category in the database (TokenDB).
        /// </summary>
        [OperationContract(Name = "ConfigureTokenCategory")]
        [FaultContract(typeof(MixClientFault))]
        void ConfigureTokenCategory(TokenCategoryV1 tokenCategory);

        /// <summary>
        /// Retrieve the token category from the database by specifying the id.
        /// </summary>
        [OperationContract(Name = "GetTokenCategoryById")]
        [FaultContract(typeof(MixClientFault))]
        TokenCategoryV1 GetTokenCategoryById(Guid id);

        /// <summary>
        /// Retrieve the token category from the database by specifying the name
        /// </summary>
        [OperationContract(Name = "GetTokenCategoryByName")]
        [FaultContract(typeof(MixClientFault))]
        TokenCategoryV1 GetTokenCategoryByName(string name);

        /// <summary>
        /// Retrieve a list of token categories from a particuliar offer
        /// </summary>
        [OperationContract(Name = "GetTokenCategoryByOffer")]
        [FaultContract(typeof(MixClientFault))]
        TokenCategoryV1[] GetTokenCategoryByOffer(Guid offerId);

        /// <summary>
        /// Gets TokenInfo object for given Token
        /// </summary>
        /// <param name="token">token as a string</param>
        /// <returns>TokenInfoV1 object</returns>
        [OperationContract(Name = "GetTokenInfoByToken")]
        [FaultContract(typeof(MixClientFault))]
        TokenInfoV1 GetTokenInfoByToken(string token);

        /// <summary>
        /// Gets TokenInfo object for given TokenHash
        /// </summary>
        /// <param name="tokenHash">byte[] representaion of TokenHash</param>
        /// <returns>TokenInfoV1 object</returns>
        [OperationContract(Name = "GetTokenInfoByHash")]
        [FaultContract(typeof(MixClientFault))]
        TokenInfoV1 GetTokenInfoByHash(byte[] tokenHash);

        /// <summary>
        /// Submit a token generation request, the system will schedule a job, and return the job to the caller
        /// </summary>
        [OperationContract(Name = "GenerateTokens")]
        [FaultContract(typeof(MixClientFault))]
        TokenJobV1 GenerateTokens(Guid tokenCategoryId, uint numTokens, byte[] key, bool isTest);

        /// <summary>
        /// Get the status of the submitted job.
        /// </summary>
        [OperationContract(Name = "GetTokenJobStatus")]
        [FaultContract(typeof(MixClientFault))]
        TokenJobStatusV1 GetTokenJobStatus(Guid jobId);
        
        /// <summary>
        /// Get the status of the submitted jobs for the category.
        /// </summary>
        [OperationContract(Name = "GetTokenJobStatusByCategory")]
        [FaultContract(typeof(MixClientFault))]
        TokenJobStatusV1[] GetTokenJobStatusByCategory(Guid tokenCategoryId);
        
        /// <summary>
        /// Get 'count' tokens from token file.
        /// </summary>
        /// <param name="jobId">Guid - Used to locate token file</param>
        /// <param name="key">byte[] - Encryption key</param>
        /// <param name="start">int - Token number in file to start read</param>
        /// <param name="count">int - Number of tokens to retrieve from file</param>
        /// <returns>TokenInvov1 object array</returns>
        [OperationContract(Name = "GetTokens")]
        [FaultContract(typeof(MixClientFault))]
        TokenEntry[] GetTokens(Guid jobId, byte[] key, int start, int count);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\TokenManagement\DecryptTool\DecryptLibrary\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\TokenManagement\DecryptTool\DecryptToolApp\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\TokenManagement\Contracts\objd\i386\TokenManagementProxy.cs ===
ï»¿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.4971
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

[assembly: System.Runtime.Serialization.ContractNamespaceAttribute("http://xonline.mix.tokenmanagement.contracts/V1", ClrNamespace="xonline.mix.tokenmanagement.contracts.V1")]

namespace xonline.mix.tokenmanagement.contracts.V1
{
    using System.Runtime.Serialization;
    
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="TokenCategory", Namespace="http://xonline.mix.tokenmanagement.contracts/V1")]
    public partial class TokenCategory : object, System.Runtime.Serialization.IExtensibleDataObject
    {
        
        private System.Runtime.Serialization.ExtensionDataObject extensionDataField;
        
        private xonline.mix.tokenmanagement.contracts.V1.ChannelSKU[] ChannelSKUArrayField;
        
        private int ChannelTypeIdField;
        
        private System.DateTime ExpirationDateField;
        
        private bool InCsatField;
        
        private bool IsRedeemableField;
        
        private bool IsRevenueBearingField;
        
        private bool IsRoyaltyBearingField;
        
        private bool IsRsmField;
        
        private System.Guid OfferIdField;
        
        private string PkpnField;
        
        private uint ProductTypeIdField;
        
        private System.Guid PromotionIdField;
        
        private System.Guid TokenCategoryIdField;
        
        private string TokenCategoryNameField;
        
        private string TokenTypeField;
        
        public System.Runtime.Serialization.ExtensionDataObject ExtensionData
        {
            get
            {
                return this.extensionDataField;
            }
            set
            {
                this.extensionDataField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public xonline.mix.tokenmanagement.contracts.V1.ChannelSKU[] ChannelSKUArray
        {
            get
            {
                return this.ChannelSKUArrayField;
            }
            set
            {
                this.ChannelSKUArrayField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public int ChannelTypeId
        {
            get
            {
                return this.ChannelTypeIdField;
            }
            set
            {
                this.ChannelTypeIdField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public System.DateTime ExpirationDate
        {
            get
            {
                return this.ExpirationDateField;
            }
            set
            {
                this.ExpirationDateField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public bool InCsat
        {
            get
            {
                return this.InCsatField;
            }
            set
            {
                this.InCsatField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public bool IsRedeemable
        {
            get
            {
                return this.IsRedeemableField;
            }
            set
            {
                this.IsRedeemableField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public bool IsRevenueBearing
        {
            get
            {
                return this.IsRevenueBearingField;
            }
            set
            {
                this.IsRevenueBearingField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public bool IsRoyaltyBearing
        {
            get
            {
                return this.IsRoyaltyBearingField;
            }
            set
            {
                this.IsRoyaltyBearingField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public bool IsRsm
        {
            get
            {
                return this.IsRsmField;
            }
            set
            {
                this.IsRsmField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public System.Guid OfferId
        {
            get
            {
                return this.OfferIdField;
            }
            set
            {
                this.OfferIdField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string Pkpn
        {
            get
            {
                return this.PkpnField;
            }
            set
            {
                this.PkpnField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public uint ProductTypeId
        {
            get
            {
                return this.ProductTypeIdField;
            }
            set
            {
                this.ProductTypeIdField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public System.Guid PromotionId
        {
            get
            {
                return this.PromotionIdField;
            }
            set
            {
                this.PromotionIdField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public System.Guid TokenCategoryId
        {
            get
            {
                return this.TokenCategoryIdField;
            }
            set
            {
                this.TokenCategoryIdField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string TokenCategoryName
        {
            get
            {
                return this.TokenCategoryNameField;
            }
            set
            {
                this.TokenCategoryNameField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string TokenType
        {
            get
            {
                return this.TokenTypeField;
            }
            set
            {
                this.TokenTypeField = value;
            }
        }
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="ChannelSKU", Namespace="http://xonline.mix.tokenmanagement.contracts/V1")]
    public partial class ChannelSKU : object, System.Runtime.Serialization.IExtensibleDataObject
    {
        
        private System.Runtime.Serialization.ExtensionDataObject extensionDataField;
        
        private int BOMQuantityField;
        
        private string IDField;
        
        private double MaxPriceUSDField;
        
        private double MinPriceUSDField;
        
        private double PercentageAllocationField;
        
        public System.Runtime.Serialization.ExtensionDataObject ExtensionData
        {
            get
            {
                return this.extensionDataField;
            }
            set
            {
                this.extensionDataField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public int BOMQuantity
        {
            get
            {
                return this.BOMQuantityField;
            }
            set
            {
                this.BOMQuantityField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string ID
        {
            get
            {
                return this.IDField;
            }
            set
            {
                this.IDField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public double MaxPriceUSD
        {
            get
            {
                return this.MaxPriceUSDField;
            }
            set
            {
                this.MaxPriceUSDField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public double MinPriceUSD
        {
            get
            {
                return this.MinPriceUSDField;
            }
            set
            {
                this.MinPriceUSDField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public double PercentageAllocation
        {
            get
            {
                return this.PercentageAllocationField;
            }
            set
            {
                this.PercentageAllocationField = value;
            }
        }
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="TokenInfo", Namespace="http://xonline.mix.tokenmanagement.contracts/V1")]
    public partial class TokenInfo : object, System.Runtime.Serialization.IExtensibleDataObject
    {
        
        private System.Runtime.Serialization.ExtensionDataObject extensionDataField;
        
        private xonline.mix.tokenmanagement.contracts.V1.TokenCategory CategoryField;
        
        private byte ConsoleVersionField;
        
        private byte[] HashField;
        
        private xonline.mix.tokenmanagement.contracts.V1.TokenRedemption[] RedemptionsField;
        
        private uint SequenceNumberField;
        
        private int StatusIdField;
        
        private int UseCountField;
        
        public System.Runtime.Serialization.ExtensionDataObject ExtensionData
        {
            get
            {
                return this.extensionDataField;
            }
            set
            {
                this.extensionDataField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public xonline.mix.tokenmanagement.contracts.V1.TokenCategory Category
        {
            get
            {
                return this.CategoryField;
            }
            set
            {
                this.CategoryField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public byte ConsoleVersion
        {
            get
            {
                return this.ConsoleVersionField;
            }
            set
            {
                this.ConsoleVersionField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public byte[] Hash
        {
            get
            {
                return this.HashField;
            }
            set
            {
                this.HashField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public xonline.mix.tokenmanagement.contracts.V1.TokenRedemption[] Redemptions
        {
            get
            {
                return this.RedemptionsField;
            }
            set
            {
                this.RedemptionsField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public uint SequenceNumber
        {
            get
            {
                return this.SequenceNumberField;
            }
            set
            {
                this.SequenceNumberField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public int StatusId
        {
            get
            {
                return this.StatusIdField;
            }
            set
            {
                this.StatusIdField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public int UseCount
        {
            get
            {
                return this.UseCountField;
            }
            set
            {
                this.UseCountField = value;
            }
        }
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="TokenRedemption", Namespace="http://xonline.mix.tokenmanagement.contracts/V1")]
    public partial class TokenRedemption : object, System.Runtime.Serialization.IExtensibleDataObject
    {
        
        private System.Runtime.Serialization.ExtensionDataObject extensionDataField;
        
        private System.DateTime DateRedeemedField;
        
        private ulong UserPuidField;
        
        public System.Runtime.Serialization.ExtensionDataObject ExtensionData
        {
            get
            {
                return this.extensionDataField;
            }
            set
            {
                this.extensionDataField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public System.DateTime DateRedeemed
        {
            get
            {
                return this.DateRedeemedField;
            }
            set
            {
                this.DateRedeemedField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public ulong UserPuid
        {
            get
            {
                return this.UserPuidField;
            }
            set
            {
                this.UserPuidField = value;
            }
        }
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="TokenJob", Namespace="http://xonline.mix.tokenmanagement.contracts/V1")]
    public partial class TokenJob : object, System.Runtime.Serialization.IExtensibleDataObject
    {
        
        private System.Runtime.Serialization.ExtensionDataObject extensionDataField;
        
        private uint NumTokensRequestedField;
        
        private System.Guid TokenCategoryIdField;
        
        private System.Guid TokenJobIdField;
        
        public System.Runtime.Serialization.ExtensionDataObject ExtensionData
        {
            get
            {
                return this.extensionDataField;
            }
            set
            {
                this.extensionDataField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public uint NumTokensRequested
        {
            get
            {
                return this.NumTokensRequestedField;
            }
            set
            {
                this.NumTokensRequestedField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public System.Guid TokenCategoryId
        {
            get
            {
                return this.TokenCategoryIdField;
            }
            set
            {
                this.TokenCategoryIdField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public System.Guid TokenJobId
        {
            get
            {
                return this.TokenJobIdField;
            }
            set
            {
                this.TokenJobIdField = value;
            }
        }
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="TokenJobStatus", Namespace="http://xonline.mix.tokenmanagement.contracts/V1")]
    public partial class TokenJobStatus : object, System.Runtime.Serialization.IExtensibleDataObject
    {
        
        private System.Runtime.Serialization.ExtensionDataObject extensionDataField;
        
        private string HashFileField;
        
        private bool IsStaleField;
        
        private bool IsTestField;
        
        private System.DateTime LastActivityField;
        
        private System.DateTime NextProcessingField;
        
        private uint NumFailuresField;
        
        private uint NumTokensCompletedField;
        
        private uint NumTokensRequestedField;
        
        private xonline.mix.tokenmanagement.contracts.V1.TokenJobStatusEnum StatusField;
        
        private System.DateTime SubmittedField;
        
        private string TokenFileField;
        
        private System.Guid TokenJobIdField;
        
        public System.Runtime.Serialization.ExtensionDataObject ExtensionData
        {
            get
            {
                return this.extensionDataField;
            }
            set
            {
                this.extensionDataField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string HashFile
        {
            get
            {
                return this.HashFileField;
            }
            set
            {
                this.HashFileField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public bool IsStale
        {
            get
            {
                return this.IsStaleField;
            }
            set
            {
                this.IsStaleField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public bool IsTest
        {
            get
            {
                return this.IsTestField;
            }
            set
            {
                this.IsTestField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public System.DateTime LastActivity
        {
            get
            {
                return this.LastActivityField;
            }
            set
            {
                this.LastActivityField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public System.DateTime NextProcessing
        {
            get
            {
                return this.NextProcessingField;
            }
            set
            {
                this.NextProcessingField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public uint NumFailures
        {
            get
            {
                return this.NumFailuresField;
            }
            set
            {
                this.NumFailuresField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public uint NumTokensCompleted
        {
            get
            {
                return this.NumTokensCompletedField;
            }
            set
            {
                this.NumTokensCompletedField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public uint NumTokensRequested
        {
            get
            {
                return this.NumTokensRequestedField;
            }
            set
            {
                this.NumTokensRequestedField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public xonline.mix.tokenmanagement.contracts.V1.TokenJobStatusEnum Status
        {
            get
            {
                return this.StatusField;
            }
            set
            {
                this.StatusField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public System.DateTime Submitted
        {
            get
            {
                return this.SubmittedField;
            }
            set
            {
                this.SubmittedField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string TokenFile
        {
            get
            {
                return this.TokenFileField;
            }
            set
            {
                this.TokenFileField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public System.Guid TokenJobId
        {
            get
            {
                return this.TokenJobIdField;
            }
            set
            {
                this.TokenJobIdField = value;
            }
        }
    }
    
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="TokenJobStatusEnum", Namespace="http://xonline.mix.tokenmanagement.contracts/V1")]
    public enum TokenJobStatusEnum : int
    {
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        Pending = 1,
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        InProgress = 2,
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        Delivered = 3,
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        Failed = 4,
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="TokenEntry", Namespace="http://xonline.mix.tokenmanagement.contracts/V1")]
    public partial class TokenEntry : object, System.Runtime.Serialization.IExtensibleDataObject
    {
        
        private System.Runtime.Serialization.ExtensionDataObject extensionDataField;
        
        private string PkpnField;
        
        private uint SequenceNumberField;
        
        private string TokenField;
        
        public System.Runtime.Serialization.ExtensionDataObject ExtensionData
        {
            get
            {
                return this.extensionDataField;
            }
            set
            {
                this.extensionDataField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string Pkpn
        {
            get
            {
                return this.PkpnField;
            }
            set
            {
                this.PkpnField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public uint SequenceNumber
        {
            get
            {
                return this.SequenceNumberField;
            }
            set
            {
                this.SequenceNumberField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string Token
        {
            get
            {
                return this.TokenField;
            }
            set
            {
                this.TokenField = value;
            }
        }
    }
}


[System.CodeDom.Compiler.GeneratedCodeAttribute("System.ServiceModel", "3.0.0.0")]
[System.ServiceModel.ServiceContractAttribute(Namespace="http://xonline.mix.tokenmanagement.contracts/V1", ConfigurationName="IMixTokenManagement")]
public interface IMixTokenManagement
{
    
    [System.ServiceModel.OperationContractAttribute(Action="http://xonline.mix.tokenmanagement.contracts/V1/IMixTokenManagement/ConfigureToke" +
        "nCategory", ReplyAction="http://xonline.mix.tokenmanagement.contracts/V1/IMixTokenManagement/ConfigureToke" +
        "nCategoryResponse")]
    [System.ServiceModel.FaultContractAttribute(typeof(xonline.mix.common.MixClientFault), Action="http://xonline.mix.tokenmanagement.contracts/V1/IMixTokenManagement/ConfigureToke" +
        "nCategoryMixClientFaultFault", Name="MixClientFault", Namespace="http://xonline.mix.common.contracts")]
    void ConfigureTokenCategory(xonline.mix.tokenmanagement.contracts.V1.TokenCategory tokenCategory);
    
    [System.ServiceModel.OperationContractAttribute(Action="http://xonline.mix.tokenmanagement.contracts/V1/IMixTokenManagement/GetTokenCateg" +
        "oryById", ReplyAction="http://xonline.mix.tokenmanagement.contracts/V1/IMixTokenManagement/GetTokenCateg" +
        "oryByIdResponse")]
    [System.ServiceModel.FaultContractAttribute(typeof(xonline.mix.common.MixClientFault), Action="http://xonline.mix.tokenmanagement.contracts/V1/IMixTokenManagement/GetTokenCateg" +
        "oryByIdMixClientFaultFault", Name="MixClientFault", Namespace="http://xonline.mix.common.contracts")]
    xonline.mix.tokenmanagement.contracts.V1.TokenCategory GetTokenCategoryById(System.Guid id);
    
    [System.ServiceModel.OperationContractAttribute(Action="http://xonline.mix.tokenmanagement.contracts/V1/IMixTokenManagement/GetTokenCateg" +
        "oryByName", ReplyAction="http://xonline.mix.tokenmanagement.contracts/V1/IMixTokenManagement/GetTokenCateg" +
        "oryByNameResponse")]
    [System.ServiceModel.FaultContractAttribute(typeof(xonline.mix.common.MixClientFault), Action="http://xonline.mix.tokenmanagement.contracts/V1/IMixTokenManagement/GetTokenCateg" +
        "oryByNameMixClientFaultFault", Name="MixClientFault", Namespace="http://xonline.mix.common.contracts")]
    xonline.mix.tokenmanagement.contracts.V1.TokenCategory GetTokenCategoryByName(string name);
    
    [System.ServiceModel.OperationContractAttribute(Action="http://xonline.mix.tokenmanagement.contracts/V1/IMixTokenManagement/GetTokenCateg" +
        "oryByOffer", ReplyAction="http://xonline.mix.tokenmanagement.contracts/V1/IMixTokenManagement/GetTokenCateg" +
        "oryByOfferResponse")]
    [System.ServiceModel.FaultContractAttribute(typeof(xonline.mix.common.MixClientFault), Action="http://xonline.mix.tokenmanagement.contracts/V1/IMixTokenManagement/GetTokenCateg" +
        "oryByOfferMixClientFaultFault", Name="MixClientFault", Namespace="http://xonline.mix.common.contracts")]
    xonline.mix.tokenmanagement.contracts.V1.TokenCategory[] GetTokenCategoryByOffer(System.Guid offerId);
    
    [System.ServiceModel.OperationContractAttribute(Action="http://xonline.mix.tokenmanagement.contracts/V1/IMixTokenManagement/GetTokenInfoB" +
        "yToken", ReplyAction="http://xonline.mix.tokenmanagement.contracts/V1/IMixTokenManagement/GetTokenInfoB" +
        "yTokenResponse")]
    [System.ServiceModel.FaultContractAttribute(typeof(xonline.mix.common.MixClientFault), Action="http://xonline.mix.tokenmanagement.contracts/V1/IMixTokenManagement/GetTokenInfoB" +
        "yTokenMixClientFaultFault", Name="MixClientFault", Namespace="http://xonline.mix.common.contracts")]
    xonline.mix.tokenmanagement.contracts.V1.TokenInfo GetTokenInfoByToken(string token);
    
    [System.ServiceModel.OperationContractAttribute(Action="http://xonline.mix.tokenmanagement.contracts/V1/IMixTokenManagement/GetTokenInfoB" +
        "yHash", ReplyAction="http://xonline.mix.tokenmanagement.contracts/V1/IMixTokenManagement/GetTokenInfoB" +
        "yHashResponse")]
    [System.ServiceModel.FaultContractAttribute(typeof(xonline.mix.common.MixClientFault), Action="http://xonline.mix.tokenmanagement.contracts/V1/IMixTokenManagement/GetTokenInfoB" +
        "yHashMixClientFaultFault", Name="MixClientFault", Namespace="http://xonline.mix.common.contracts")]
    xonline.mix.tokenmanagement.contracts.V1.TokenInfo GetTokenInfoByHash(byte[] tokenHash);
    
    [System.ServiceModel.OperationContractAttribute(Action="http://xonline.mix.tokenmanagement.contracts/V1/IMixTokenManagement/GenerateToken" +
        "s", ReplyAction="http://xonline.mix.tokenmanagement.contracts/V1/IMixTokenManagement/GenerateToken" +
        "sResponse")]
    [System.ServiceModel.FaultContractAttribute(typeof(xonline.mix.common.MixClientFault), Action="http://xonline.mix.tokenmanagement.contracts/V1/IMixTokenManagement/GenerateToken" +
        "sMixClientFaultFault", Name="MixClientFault", Namespace="http://xonline.mix.common.contracts")]
    xonline.mix.tokenmanagement.contracts.V1.TokenJob GenerateTokens(System.Guid tokenCategoryId, uint numTokens, byte[] key, bool isTest);
    
    [System.ServiceModel.OperationContractAttribute(Action="http://xonline.mix.tokenmanagement.contracts/V1/IMixTokenManagement/GetTokenJobSt" +
        "atus", ReplyAction="http://xonline.mix.tokenmanagement.contracts/V1/IMixTokenManagement/GetTokenJobSt" +
        "atusResponse")]
    [System.ServiceModel.FaultContractAttribute(typeof(xonline.mix.common.MixClientFault), Action="http://xonline.mix.tokenmanagement.contracts/V1/IMixTokenManagement/GetTokenJobSt" +
        "atusMixClientFaultFault", Name="MixClientFault", Namespace="http://xonline.mix.common.contracts")]
    xonline.mix.tokenmanagement.contracts.V1.TokenJobStatus GetTokenJobStatus(System.Guid jobId);
    
    [System.ServiceModel.OperationContractAttribute(Action="http://xonline.mix.tokenmanagement.contracts/V1/IMixTokenManagement/GetTokenJobSt" +
        "atusByCategory", ReplyAction="http://xonline.mix.tokenmanagement.contracts/V1/IMixTokenManagement/GetTokenJobSt" +
        "atusByCategoryResponse")]
    [System.ServiceModel.FaultContractAttribute(typeof(xonline.mix.common.MixClientFault), Action="http://xonline.mix.tokenmanagement.contracts/V1/IMixTokenManagement/GetTokenJobSt" +
        "atusByCategoryMixClientFaultFault", Name="MixClientFault", Namespace="http://xonline.mix.common.contracts")]
    xonline.mix.tokenmanagement.contracts.V1.TokenJobStatus[] GetTokenJobStatusByCategory(System.Guid tokenCategoryId);
    
    [System.ServiceModel.OperationContractAttribute(Action="http://xonline.mix.tokenmanagement.contracts/V1/IMixTokenManagement/GetTokens", ReplyAction="http://xonline.mix.tokenmanagement.contracts/V1/IMixTokenManagement/GetTokensResp" +
        "onse")]
    [System.ServiceModel.FaultContractAttribute(typeof(xonline.mix.common.MixClientFault), Action="http://xonline.mix.tokenmanagement.contracts/V1/IMixTokenManagement/GetTokensMixC" +
        "lientFaultFault", Name="MixClientFault", Namespace="http://xonline.mix.common.contracts")]
    xonline.mix.tokenmanagement.contracts.V1.TokenEntry[] GetTokens(System.Guid jobId, byte[] key, int start, int count);
}

[System.CodeDom.Compiler.GeneratedCodeAttribute("System.ServiceModel", "3.0.0.0")]
public interface IMixTokenManagementChannel : IMixTokenManagement, System.ServiceModel.IClientChannel
{
}

[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.CodeDom.Compiler.GeneratedCodeAttribute("System.ServiceModel", "3.0.0.0")]
public partial class MixTokenManagementClient : System.ServiceModel.ClientBase<IMixTokenManagement>, IMixTokenManagement
{
    
    public MixTokenManagementClient()
    {
    }
    
    public MixTokenManagementClient(string endpointConfigurationName) : 
            base(endpointConfigurationName)
    {
    }
    
    public MixTokenManagementClient(string endpointConfigurationName, string remoteAddress) : 
            base(endpointConfigurationName, remoteAddress)
    {
    }
    
    public MixTokenManagementClient(string endpointConfigurationName, System.ServiceModel.EndpointAddress remoteAddress) : 
            base(endpointConfigurationName, remoteAddress)
    {
    }
    
    public MixTokenManagementClient(System.ServiceModel.Channels.Binding binding, System.ServiceModel.EndpointAddress remoteAddress) : 
            base(binding, remoteAddress)
    {
    }
    
    public void ConfigureTokenCategory(xonline.mix.tokenmanagement.contracts.V1.TokenCategory tokenCategory)
    {
        base.Channel.ConfigureTokenCategory(tokenCategory);
    }
    
    public xonline.mix.tokenmanagement.contracts.V1.TokenCategory GetTokenCategoryById(System.Guid id)
    {
        return base.Channel.GetTokenCategoryById(id);
    }
    
    public xonline.mix.tokenmanagement.contracts.V1.TokenCategory GetTokenCategoryByName(string name)
    {
        return base.Channel.GetTokenCategoryByName(name);
    }
    
    public xonline.mix.tokenmanagement.contracts.V1.TokenCategory[] GetTokenCategoryByOffer(System.Guid offerId)
    {
        return base.Channel.GetTokenCategoryByOffer(offerId);
    }
    
    public xonline.mix.tokenmanagement.contracts.V1.TokenInfo GetTokenInfoByToken(string token)
    {
        return base.Channel.GetTokenInfoByToken(token);
    }
    
    public xonline.mix.tokenmanagement.contracts.V1.TokenInfo GetTokenInfoByHash(byte[] tokenHash)
    {
        return base.Channel.GetTokenInfoByHash(tokenHash);
    }
    
    public xonline.mix.tokenmanagement.contracts.V1.TokenJob GenerateTokens(System.Guid tokenCategoryId, uint numTokens, byte[] key, bool isTest)
    {
        return base.Channel.GenerateTokens(tokenCategoryId, numTokens, key, isTest);
    }
    
    public xonline.mix.tokenmanagement.contracts.V1.TokenJobStatus GetTokenJobStatus(System.Guid jobId)
    {
        return base.Channel.GetTokenJobStatus(jobId);
    }
    
    public xonline.mix.tokenmanagement.contracts.V1.TokenJobStatus[] GetTokenJobStatusByCategory(System.Guid tokenCategoryId)
    {
        return base.Channel.GetTokenJobStatusByCategory(tokenCategoryId);
    }
    
    public xonline.mix.tokenmanagement.contracts.V1.TokenEntry[] GetTokens(System.Guid jobId, byte[] key, int start, int count)
    {
        return base.Channel.GetTokens(jobId, key, start, count);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\TokenManagement\Contracts\obj\i386\TokenManagementProxy.cs ===
ï»¿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.4971
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

[assembly: System.Runtime.Serialization.ContractNamespaceAttribute("http://xonline.mix.tokenmanagement.contracts/V1", ClrNamespace="xonline.mix.tokenmanagement.contracts.V1")]

namespace xonline.mix.tokenmanagement.contracts.V1
{
    using System.Runtime.Serialization;
    
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="TokenCategory", Namespace="http://xonline.mix.tokenmanagement.contracts/V1")]
    public partial class TokenCategory : object, System.Runtime.Serialization.IExtensibleDataObject
    {
        
        private System.Runtime.Serialization.ExtensionDataObject extensionDataField;
        
        private xonline.mix.tokenmanagement.contracts.V1.ChannelSKU[] ChannelSKUArrayField;
        
        private int ChannelTypeIdField;
        
        private System.DateTime ExpirationDateField;
        
        private bool InCsatField;
        
        private bool IsRedeemableField;
        
        private bool IsRevenueBearingField;
        
        private bool IsRoyaltyBearingField;
        
        private bool IsRsmField;
        
        private System.Guid OfferIdField;
        
        private string PkpnField;
        
        private uint ProductTypeIdField;
        
        private System.Guid PromotionIdField;
        
        private System.Guid TokenCategoryIdField;
        
        private string TokenCategoryNameField;
        
        private string TokenTypeField;
        
        public System.Runtime.Serialization.ExtensionDataObject ExtensionData
        {
            get
            {
                return this.extensionDataField;
            }
            set
            {
                this.extensionDataField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public xonline.mix.tokenmanagement.contracts.V1.ChannelSKU[] ChannelSKUArray
        {
            get
            {
                return this.ChannelSKUArrayField;
            }
            set
            {
                this.ChannelSKUArrayField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public int ChannelTypeId
        {
            get
            {
                return this.ChannelTypeIdField;
            }
            set
            {
                this.ChannelTypeIdField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public System.DateTime ExpirationDate
        {
            get
            {
                return this.ExpirationDateField;
            }
            set
            {
                this.ExpirationDateField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public bool InCsat
        {
            get
            {
                return this.InCsatField;
            }
            set
            {
                this.InCsatField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public bool IsRedeemable
        {
            get
            {
                return this.IsRedeemableField;
            }
            set
            {
                this.IsRedeemableField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public bool IsRevenueBearing
        {
            get
            {
                return this.IsRevenueBearingField;
            }
            set
            {
                this.IsRevenueBearingField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public bool IsRoyaltyBearing
        {
            get
            {
                return this.IsRoyaltyBearingField;
            }
            set
            {
                this.IsRoyaltyBearingField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public bool IsRsm
        {
            get
            {
                return this.IsRsmField;
            }
            set
            {
                this.IsRsmField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public System.Guid OfferId
        {
            get
            {
                return this.OfferIdField;
            }
            set
            {
                this.OfferIdField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string Pkpn
        {
            get
            {
                return this.PkpnField;
            }
            set
            {
                this.PkpnField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public uint ProductTypeId
        {
            get
            {
                return this.ProductTypeIdField;
            }
            set
            {
                this.ProductTypeIdField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public System.Guid PromotionId
        {
            get
            {
                return this.PromotionIdField;
            }
            set
            {
                this.PromotionIdField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public System.Guid TokenCategoryId
        {
            get
            {
                return this.TokenCategoryIdField;
            }
            set
            {
                this.TokenCategoryIdField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string TokenCategoryName
        {
            get
            {
                return this.TokenCategoryNameField;
            }
            set
            {
                this.TokenCategoryNameField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string TokenType
        {
            get
            {
                return this.TokenTypeField;
            }
            set
            {
                this.TokenTypeField = value;
            }
        }
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="ChannelSKU", Namespace="http://xonline.mix.tokenmanagement.contracts/V1")]
    public partial class ChannelSKU : object, System.Runtime.Serialization.IExtensibleDataObject
    {
        
        private System.Runtime.Serialization.ExtensionDataObject extensionDataField;
        
        private int BOMQuantityField;
        
        private string IDField;
        
        private double MaxPriceUSDField;
        
        private double MinPriceUSDField;
        
        private double PercentageAllocationField;
        
        public System.Runtime.Serialization.ExtensionDataObject ExtensionData
        {
            get
            {
                return this.extensionDataField;
            }
            set
            {
                this.extensionDataField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public int BOMQuantity
        {
            get
            {
                return this.BOMQuantityField;
            }
            set
            {
                this.BOMQuantityField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string ID
        {
            get
            {
                return this.IDField;
            }
            set
            {
                this.IDField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public double MaxPriceUSD
        {
            get
            {
                return this.MaxPriceUSDField;
            }
            set
            {
                this.MaxPriceUSDField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public double MinPriceUSD
        {
            get
            {
                return this.MinPriceUSDField;
            }
            set
            {
                this.MinPriceUSDField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public double PercentageAllocation
        {
            get
            {
                return this.PercentageAllocationField;
            }
            set
            {
                this.PercentageAllocationField = value;
            }
        }
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="TokenInfo", Namespace="http://xonline.mix.tokenmanagement.contracts/V1")]
    public partial class TokenInfo : object, System.Runtime.Serialization.IExtensibleDataObject
    {
        
        private System.Runtime.Serialization.ExtensionDataObject extensionDataField;
        
        private xonline.mix.tokenmanagement.contracts.V1.TokenCategory CategoryField;
        
        private byte ConsoleVersionField;
        
        private byte[] HashField;
        
        private xonline.mix.tokenmanagement.contracts.V1.TokenRedemption[] RedemptionsField;
        
        private uint SequenceNumberField;
        
        private int StatusIdField;
        
        private int UseCountField;
        
        public System.Runtime.Serialization.ExtensionDataObject ExtensionData
        {
            get
            {
                return this.extensionDataField;
            }
            set
            {
                this.extensionDataField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public xonline.mix.tokenmanagement.contracts.V1.TokenCategory Category
        {
            get
            {
                return this.CategoryField;
            }
            set
            {
                this.CategoryField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public byte ConsoleVersion
        {
            get
            {
                return this.ConsoleVersionField;
            }
            set
            {
                this.ConsoleVersionField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public byte[] Hash
        {
            get
            {
                return this.HashField;
            }
            set
            {
                this.HashField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public xonline.mix.tokenmanagement.contracts.V1.TokenRedemption[] Redemptions
        {
            get
            {
                return this.RedemptionsField;
            }
            set
            {
                this.RedemptionsField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public uint SequenceNumber
        {
            get
            {
                return this.SequenceNumberField;
            }
            set
            {
                this.SequenceNumberField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public int StatusId
        {
            get
            {
                return this.StatusIdField;
            }
            set
            {
                this.StatusIdField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public int UseCount
        {
            get
            {
                return this.UseCountField;
            }
            set
            {
                this.UseCountField = value;
            }
        }
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="TokenRedemption", Namespace="http://xonline.mix.tokenmanagement.contracts/V1")]
    public partial class TokenRedemption : object, System.Runtime.Serialization.IExtensibleDataObject
    {
        
        private System.Runtime.Serialization.ExtensionDataObject extensionDataField;
        
        private System.DateTime DateRedeemedField;
        
        private ulong UserPuidField;
        
        public System.Runtime.Serialization.ExtensionDataObject ExtensionData
        {
            get
            {
                return this.extensionDataField;
            }
            set
            {
                this.extensionDataField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public System.DateTime DateRedeemed
        {
            get
            {
                return this.DateRedeemedField;
            }
            set
            {
                this.DateRedeemedField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public ulong UserPuid
        {
            get
            {
                return this.UserPuidField;
            }
            set
            {
                this.UserPuidField = value;
            }
        }
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="TokenJob", Namespace="http://xonline.mix.tokenmanagement.contracts/V1")]
    public partial class TokenJob : object, System.Runtime.Serialization.IExtensibleDataObject
    {
        
        private System.Runtime.Serialization.ExtensionDataObject extensionDataField;
        
        private uint NumTokensRequestedField;
        
        private System.Guid TokenCategoryIdField;
        
        private System.Guid TokenJobIdField;
        
        public System.Runtime.Serialization.ExtensionDataObject ExtensionData
        {
            get
            {
                return this.extensionDataField;
            }
            set
            {
                this.extensionDataField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public uint NumTokensRequested
        {
            get
            {
                return this.NumTokensRequestedField;
            }
            set
            {
                this.NumTokensRequestedField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public System.Guid TokenCategoryId
        {
            get
            {
                return this.TokenCategoryIdField;
            }
            set
            {
                this.TokenCategoryIdField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public System.Guid TokenJobId
        {
            get
            {
                return this.TokenJobIdField;
            }
            set
            {
                this.TokenJobIdField = value;
            }
        }
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="TokenJobStatus", Namespace="http://xonline.mix.tokenmanagement.contracts/V1")]
    public partial class TokenJobStatus : object, System.Runtime.Serialization.IExtensibleDataObject
    {
        
        private System.Runtime.Serialization.ExtensionDataObject extensionDataField;
        
        private string HashFileField;
        
        private bool IsStaleField;
        
        private bool IsTestField;
        
        private System.DateTime LastActivityField;
        
        private System.DateTime NextProcessingField;
        
        private uint NumFailuresField;
        
        private uint NumTokensCompletedField;
        
        private uint NumTokensRequestedField;
        
        private xonline.mix.tokenmanagement.contracts.V1.TokenJobStatusEnum StatusField;
        
        private System.DateTime SubmittedField;
        
        private string TokenFileField;
        
        private System.Guid TokenJobIdField;
        
        public System.Runtime.Serialization.ExtensionDataObject ExtensionData
        {
            get
            {
                return this.extensionDataField;
            }
            set
            {
                this.extensionDataField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string HashFile
        {
            get
            {
                return this.HashFileField;
            }
            set
            {
                this.HashFileField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public bool IsStale
        {
            get
            {
                return this.IsStaleField;
            }
            set
            {
                this.IsStaleField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public bool IsTest
        {
            get
            {
                return this.IsTestField;
            }
            set
            {
                this.IsTestField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public System.DateTime LastActivity
        {
            get
            {
                return this.LastActivityField;
            }
            set
            {
                this.LastActivityField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public System.DateTime NextProcessing
        {
            get
            {
                return this.NextProcessingField;
            }
            set
            {
                this.NextProcessingField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public uint NumFailures
        {
            get
            {
                return this.NumFailuresField;
            }
            set
            {
                this.NumFailuresField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public uint NumTokensCompleted
        {
            get
            {
                return this.NumTokensCompletedField;
            }
            set
            {
                this.NumTokensCompletedField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public uint NumTokensRequested
        {
            get
            {
                return this.NumTokensRequestedField;
            }
            set
            {
                this.NumTokensRequestedField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public xonline.mix.tokenmanagement.contracts.V1.TokenJobStatusEnum Status
        {
            get
            {
                return this.StatusField;
            }
            set
            {
                this.StatusField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public System.DateTime Submitted
        {
            get
            {
                return this.SubmittedField;
            }
            set
            {
                this.SubmittedField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string TokenFile
        {
            get
            {
                return this.TokenFileField;
            }
            set
            {
                this.TokenFileField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public System.Guid TokenJobId
        {
            get
            {
                return this.TokenJobIdField;
            }
            set
            {
                this.TokenJobIdField = value;
            }
        }
    }
    
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="TokenJobStatusEnum", Namespace="http://xonline.mix.tokenmanagement.contracts/V1")]
    public enum TokenJobStatusEnum : int
    {
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        Pending = 1,
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        InProgress = 2,
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        Delivered = 3,
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        Failed = 4,
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="TokenEntry", Namespace="http://xonline.mix.tokenmanagement.contracts/V1")]
    public partial class TokenEntry : object, System.Runtime.Serialization.IExtensibleDataObject
    {
        
        private System.Runtime.Serialization.ExtensionDataObject extensionDataField;
        
        private string PkpnField;
        
        private uint SequenceNumberField;
        
        private string TokenField;
        
        public System.Runtime.Serialization.ExtensionDataObject ExtensionData
        {
            get
            {
                return this.extensionDataField;
            }
            set
            {
                this.extensionDataField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string Pkpn
        {
            get
            {
                return this.PkpnField;
            }
            set
            {
                this.PkpnField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public uint SequenceNumber
        {
            get
            {
                return this.SequenceNumberField;
            }
            set
            {
                this.SequenceNumberField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string Token
        {
            get
            {
                return this.TokenField;
            }
            set
            {
                this.TokenField = value;
            }
        }
    }
}


[System.CodeDom.Compiler.GeneratedCodeAttribute("System.ServiceModel", "3.0.0.0")]
[System.ServiceModel.ServiceContractAttribute(Namespace="http://xonline.mix.tokenmanagement.contracts/V1", ConfigurationName="IMixTokenManagement")]
public interface IMixTokenManagement
{
    
    [System.ServiceModel.OperationContractAttribute(Action="http://xonline.mix.tokenmanagement.contracts/V1/IMixTokenManagement/ConfigureToke" +
        "nCategory", ReplyAction="http://xonline.mix.tokenmanagement.contracts/V1/IMixTokenManagement/ConfigureToke" +
        "nCategoryResponse")]
    [System.ServiceModel.FaultContractAttribute(typeof(xonline.mix.common.MixClientFault), Action="http://xonline.mix.tokenmanagement.contracts/V1/IMixTokenManagement/ConfigureToke" +
        "nCategoryMixClientFaultFault", Name="MixClientFault", Namespace="http://xonline.mix.common.contracts")]
    void ConfigureTokenCategory(xonline.mix.tokenmanagement.contracts.V1.TokenCategory tokenCategory);
    
    [System.ServiceModel.OperationContractAttribute(Action="http://xonline.mix.tokenmanagement.contracts/V1/IMixTokenManagement/GetTokenCateg" +
        "oryById", ReplyAction="http://xonline.mix.tokenmanagement.contracts/V1/IMixTokenManagement/GetTokenCateg" +
        "oryByIdResponse")]
    [System.ServiceModel.FaultContractAttribute(typeof(xonline.mix.common.MixClientFault), Action="http://xonline.mix.tokenmanagement.contracts/V1/IMixTokenManagement/GetTokenCateg" +
        "oryByIdMixClientFaultFault", Name="MixClientFault", Namespace="http://xonline.mix.common.contracts")]
    xonline.mix.tokenmanagement.contracts.V1.TokenCategory GetTokenCategoryById(System.Guid id);
    
    [System.ServiceModel.OperationContractAttribute(Action="http://xonline.mix.tokenmanagement.contracts/V1/IMixTokenManagement/GetTokenCateg" +
        "oryByName", ReplyAction="http://xonline.mix.tokenmanagement.contracts/V1/IMixTokenManagement/GetTokenCateg" +
        "oryByNameResponse")]
    [System.ServiceModel.FaultContractAttribute(typeof(xonline.mix.common.MixClientFault), Action="http://xonline.mix.tokenmanagement.contracts/V1/IMixTokenManagement/GetTokenCateg" +
        "oryByNameMixClientFaultFault", Name="MixClientFault", Namespace="http://xonline.mix.common.contracts")]
    xonline.mix.tokenmanagement.contracts.V1.TokenCategory GetTokenCategoryByName(string name);
    
    [System.ServiceModel.OperationContractAttribute(Action="http://xonline.mix.tokenmanagement.contracts/V1/IMixTokenManagement/GetTokenCateg" +
        "oryByOffer", ReplyAction="http://xonline.mix.tokenmanagement.contracts/V1/IMixTokenManagement/GetTokenCateg" +
        "oryByOfferResponse")]
    [System.ServiceModel.FaultContractAttribute(typeof(xonline.mix.common.MixClientFault), Action="http://xonline.mix.tokenmanagement.contracts/V1/IMixTokenManagement/GetTokenCateg" +
        "oryByOfferMixClientFaultFault", Name="MixClientFault", Namespace="http://xonline.mix.common.contracts")]
    xonline.mix.tokenmanagement.contracts.V1.TokenCategory[] GetTokenCategoryByOffer(System.Guid offerId);
    
    [System.ServiceModel.OperationContractAttribute(Action="http://xonline.mix.tokenmanagement.contracts/V1/IMixTokenManagement/GetTokenInfoB" +
        "yToken", ReplyAction="http://xonline.mix.tokenmanagement.contracts/V1/IMixTokenManagement/GetTokenInfoB" +
        "yTokenResponse")]
    [System.ServiceModel.FaultContractAttribute(typeof(xonline.mix.common.MixClientFault), Action="http://xonline.mix.tokenmanagement.contracts/V1/IMixTokenManagement/GetTokenInfoB" +
        "yTokenMixClientFaultFault", Name="MixClientFault", Namespace="http://xonline.mix.common.contracts")]
    xonline.mix.tokenmanagement.contracts.V1.TokenInfo GetTokenInfoByToken(string token);
    
    [System.ServiceModel.OperationContractAttribute(Action="http://xonline.mix.tokenmanagement.contracts/V1/IMixTokenManagement/GetTokenInfoB" +
        "yHash", ReplyAction="http://xonline.mix.tokenmanagement.contracts/V1/IMixTokenManagement/GetTokenInfoB" +
        "yHashResponse")]
    [System.ServiceModel.FaultContractAttribute(typeof(xonline.mix.common.MixClientFault), Action="http://xonline.mix.tokenmanagement.contracts/V1/IMixTokenManagement/GetTokenInfoB" +
        "yHashMixClientFaultFault", Name="MixClientFault", Namespace="http://xonline.mix.common.contracts")]
    xonline.mix.tokenmanagement.contracts.V1.TokenInfo GetTokenInfoByHash(byte[] tokenHash);
    
    [System.ServiceModel.OperationContractAttribute(Action="http://xonline.mix.tokenmanagement.contracts/V1/IMixTokenManagement/GenerateToken" +
        "s", ReplyAction="http://xonline.mix.tokenmanagement.contracts/V1/IMixTokenManagement/GenerateToken" +
        "sResponse")]
    [System.ServiceModel.FaultContractAttribute(typeof(xonline.mix.common.MixClientFault), Action="http://xonline.mix.tokenmanagement.contracts/V1/IMixTokenManagement/GenerateToken" +
        "sMixClientFaultFault", Name="MixClientFault", Namespace="http://xonline.mix.common.contracts")]
    xonline.mix.tokenmanagement.contracts.V1.TokenJob GenerateTokens(System.Guid tokenCategoryId, uint numTokens, byte[] key, bool isTest);
    
    [System.ServiceModel.OperationContractAttribute(Action="http://xonline.mix.tokenmanagement.contracts/V1/IMixTokenManagement/GetTokenJobSt" +
        "atus", ReplyAction="http://xonline.mix.tokenmanagement.contracts/V1/IMixTokenManagement/GetTokenJobSt" +
        "atusResponse")]
    [System.ServiceModel.FaultContractAttribute(typeof(xonline.mix.common.MixClientFault), Action="http://xonline.mix.tokenmanagement.contracts/V1/IMixTokenManagement/GetTokenJobSt" +
        "atusMixClientFaultFault", Name="MixClientFault", Namespace="http://xonline.mix.common.contracts")]
    xonline.mix.tokenmanagement.contracts.V1.TokenJobStatus GetTokenJobStatus(System.Guid jobId);
    
    [System.ServiceModel.OperationContractAttribute(Action="http://xonline.mix.tokenmanagement.contracts/V1/IMixTokenManagement/GetTokenJobSt" +
        "atusByCategory", ReplyAction="http://xonline.mix.tokenmanagement.contracts/V1/IMixTokenManagement/GetTokenJobSt" +
        "atusByCategoryResponse")]
    [System.ServiceModel.FaultContractAttribute(typeof(xonline.mix.common.MixClientFault), Action="http://xonline.mix.tokenmanagement.contracts/V1/IMixTokenManagement/GetTokenJobSt" +
        "atusByCategoryMixClientFaultFault", Name="MixClientFault", Namespace="http://xonline.mix.common.contracts")]
    xonline.mix.tokenmanagement.contracts.V1.TokenJobStatus[] GetTokenJobStatusByCategory(System.Guid tokenCategoryId);
    
    [System.ServiceModel.OperationContractAttribute(Action="http://xonline.mix.tokenmanagement.contracts/V1/IMixTokenManagement/GetTokens", ReplyAction="http://xonline.mix.tokenmanagement.contracts/V1/IMixTokenManagement/GetTokensResp" +
        "onse")]
    [System.ServiceModel.FaultContractAttribute(typeof(xonline.mix.common.MixClientFault), Action="http://xonline.mix.tokenmanagement.contracts/V1/IMixTokenManagement/GetTokensMixC" +
        "lientFaultFault", Name="MixClientFault", Namespace="http://xonline.mix.common.contracts")]
    xonline.mix.tokenmanagement.contracts.V1.TokenEntry[] GetTokens(System.Guid jobId, byte[] key, int start, int count);
}

[System.CodeDom.Compiler.GeneratedCodeAttribute("System.ServiceModel", "3.0.0.0")]
public interface IMixTokenManagementChannel : IMixTokenManagement, System.ServiceModel.IClientChannel
{
}

[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.CodeDom.Compiler.GeneratedCodeAttribute("System.ServiceModel", "3.0.0.0")]
public partial class MixTokenManagementClient : System.ServiceModel.ClientBase<IMixTokenManagement>, IMixTokenManagement
{
    
    public MixTokenManagementClient()
    {
    }
    
    public MixTokenManagementClient(string endpointConfigurationName) : 
            base(endpointConfigurationName)
    {
    }
    
    public MixTokenManagementClient(string endpointConfigurationName, string remoteAddress) : 
            base(endpointConfigurationName, remoteAddress)
    {
    }
    
    public MixTokenManagementClient(string endpointConfigurationName, System.ServiceModel.EndpointAddress remoteAddress) : 
            base(endpointConfigurationName, remoteAddress)
    {
    }
    
    public MixTokenManagementClient(System.ServiceModel.Channels.Binding binding, System.ServiceModel.EndpointAddress remoteAddress) : 
            base(binding, remoteAddress)
    {
    }
    
    public void ConfigureTokenCategory(xonline.mix.tokenmanagement.contracts.V1.TokenCategory tokenCategory)
    {
        base.Channel.ConfigureTokenCategory(tokenCategory);
    }
    
    public xonline.mix.tokenmanagement.contracts.V1.TokenCategory GetTokenCategoryById(System.Guid id)
    {
        return base.Channel.GetTokenCategoryById(id);
    }
    
    public xonline.mix.tokenmanagement.contracts.V1.TokenCategory GetTokenCategoryByName(string name)
    {
        return base.Channel.GetTokenCategoryByName(name);
    }
    
    public xonline.mix.tokenmanagement.contracts.V1.TokenCategory[] GetTokenCategoryByOffer(System.Guid offerId)
    {
        return base.Channel.GetTokenCategoryByOffer(offerId);
    }
    
    public xonline.mix.tokenmanagement.contracts.V1.TokenInfo GetTokenInfoByToken(string token)
    {
        return base.Channel.GetTokenInfoByToken(token);
    }
    
    public xonline.mix.tokenmanagement.contracts.V1.TokenInfo GetTokenInfoByHash(byte[] tokenHash)
    {
        return base.Channel.GetTokenInfoByHash(tokenHash);
    }
    
    public xonline.mix.tokenmanagement.contracts.V1.TokenJob GenerateTokens(System.Guid tokenCategoryId, uint numTokens, byte[] key, bool isTest)
    {
        return base.Channel.GenerateTokens(tokenCategoryId, numTokens, key, isTest);
    }
    
    public xonline.mix.tokenmanagement.contracts.V1.TokenJobStatus GetTokenJobStatus(System.Guid jobId)
    {
        return base.Channel.GetTokenJobStatus(jobId);
    }
    
    public xonline.mix.tokenmanagement.contracts.V1.TokenJobStatus[] GetTokenJobStatusByCategory(System.Guid tokenCategoryId)
    {
        return base.Channel.GetTokenJobStatusByCategory(tokenCategoryId);
    }
    
    public xonline.mix.tokenmanagement.contracts.V1.TokenEntry[] GetTokens(System.Guid jobId, byte[] key, int start, int count)
    {
        return base.Channel.GetTokens(jobId, key, start, count);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\TokenManagement\DecryptTool\DecryptLibrary\DecryptTokenFile.cs ===
ï»¿using System;
using System.IO;
using System.IO.Compression;
using System.Security.Cryptography;
using System.Text;

using xonline.common.token;

namespace xonline.server.mix.TokenManagement.Tools
{
    public enum DecryptOutputOptions
    {
        Default = 0,  // Normal output, with job ID, token 5x5 and seq number
        Token5x5Only = 1   // Only output the 5x5 code, easier to hand off to 3rd parties. 
    }

    public class DecryptTokenFile
    {
        int processLineCount = 0;

        public DecryptTokenFile()
        {
            //empty
        }

        public int GetLinesProcessed()
        {
            return this.processLineCount;
        }

        public bool DecryptFile(string encryptedFile, string decryptedFile, string password)
        {
            return DecryptFile(encryptedFile, decryptedFile, password, DecryptOutputOptions.Default);
        }

        public bool DecryptFile(string encryptedFile, string decryptedFile, string password, DecryptOutputOptions options)
        {
            bool result = false;
            if (string.IsNullOrEmpty(password))
            {
                throw new ArgumentException("Password Cannot be Null or Empty.");
            }

            // try to use the new password encryption first, if it fails, use try old one
            try
            {
                //convert password to byte array
                byte[] key = GetNewKeyFromPassword(password);
                result = this.DecryptFile(encryptedFile, decryptedFile, key, options);
            }
            catch( InvalidDataException)
            {
                // There is no public property to capture HResult. Alternative way is to get using following
                // But we will always try the old key if the new key fails
                // IDE_HRESULT = -2146233087; //Message =  "The magic number in GZip header is not correct. Make sure you are passing in a GZip stream."
                //if (System.Runtime.InteropServices.Marshal.GetHRForException(ide) == IDE_HRESULT)
                //{
                    //convert password to byte array
                    byte[] key = GetOldKeyFromPassword(password);
                    result = this.DecryptFile(encryptedFile, decryptedFile, key, options);
                //}
                //else
                //{
                //    throw;
                //}
            }

            return result;
        }

        public bool DecryptFile(string encryptedFile, string decryptedFile, byte[] key, DecryptOutputOptions options)
        {
            //This algorithm supports key lengths of 128 bits.
            bool validKeyLength = (TokenJob.MaxKeyLength == key.Length);
            if (!validKeyLength)
            {
                throw new ArgumentException("Invalid Key Length. It cannot be greater than 16 characters.");
            }

            // parse job id from input file
            Guid jobId = DecryptTokenFile.GetJobId(encryptedFile);
            if (Guid.Empty.Equals(jobId))
            {
                throw new ArgumentException("Invalid Input File Name. Could not parse JobId.");
            }

            // check input file read access
            bool inFileStatus = DecryptTokenFile.CheckReadAccess(encryptedFile);
            if (!inFileStatus)
            {
                throw new ArgumentException("Unable to Read the input file: " + encryptedFile);
            }
            else
            {
                // check if input file exists
                inFileStatus = File.Exists(encryptedFile);
                if (!inFileStatus)
                {
                    throw new ArgumentException("Input file: " + encryptedFile + ", does not exist.");
                }
            }

            // validate output file path exists and has write access
            bool outFileStatus = DecryptTokenFile.CheckWriteAccess(decryptedFile);
            if (!outFileStatus)
            {
                throw new ArgumentException("Unable to write the output file: " + decryptedFile);
            }

            bool status = this.DecryptFile(encryptedFile, decryptedFile, key, jobId, options);

            return status;
        }

        public bool DecryptFile(string encryptedFile, string outputFile, byte[] key, Guid jobId, DecryptOutputOptions options)
        {
            bool status = true;

            byte[] iv = jobId.ToByteArray();
            processLineCount = 0;

            using (FileStream inputFile = File.Open(encryptedFile, FileMode.Open, FileAccess.Read, FileShare.None))
            using (CryptoStream cryptoStream = TokenCrypto.GetTokenFileCryptoStream(inputFile, key, iv, CryptoStreamMode.Read))
            using (GZipStream gzipStream = new GZipStream(cryptoStream, CompressionMode.Decompress, false))
            using (StreamReader reader = new StreamReader(gzipStream))
            using (StreamWriter writer = new StreamWriter(outputFile))
            {
                if (options != DecryptOutputOptions.Token5x5Only)
                {
                    writer.WriteLine(string.Format("JobId:{0}\n", jobId));
                    writer.WriteLine("#No      : 5x5                           : SequenceNumber");
                    writer.WriteLine("---------: xxxxx-xxxxx-xxxxx-xxxxx-xxxxx : ----------\n");
                }
                string line;
                while ((line = reader.ReadLine()) != null)
                {
                    processLineCount++;
                    string[] tuple = line.Split(',');
                    if (options != DecryptOutputOptions.Token5x5Only)
                    {
                        writer.WriteLine(string.Format("{0:d9}: {1} : {2}", processLineCount, tuple[0], tuple[2]));
                    }
                    else
                    {
                        writer.WriteLine(string.Format("{0}", tuple[0]));
                    }
                }
                if (options != DecryptOutputOptions.Token5x5Only)
                {
                    writer.WriteLine(string.Format("\nTotal Tokens Decrypted:{0}\n", processLineCount));
                }
            }

            return status;
        }

        // parse job id from input file
        public static Guid GetJobId(string inputFileName)
        {
            Guid jobid = Guid.Empty;
            // example 55d04a2c-eeed-4dbf-bc92-71e6e6de52d7.xtx
            // remove the last 4 constant characters from the file name
            if (string.IsNullOrEmpty(inputFileName))
            {
                throw new ArgumentException("Empty or Null input file.");
            }
            else
            {
                int guidStart = inputFileName.Length - 36 - 4;// 13;
                //if (inputFileName.Length < 36 )
                if (guidStart < 0)
                {
                    throw new ArgumentException("Invalid input file name (JobId cannot be determined): " + inputFileName);
                }
                string strJobId = inputFileName.Substring(guidStart, 36);
                try
                {
                    jobid = new Guid(strJobId);
                }
                catch
                {
                    //do nothing
                }
            }

            return jobid;
        }

        private byte[] GetOldKeyFromPassword(string password)
        {
            using (SHA1CryptoServiceProvider sha1 = new SHA1CryptoServiceProvider())
            {
                byte[] passwordBytes = ASCIIEncoding.UTF8.GetBytes(password);

                if (passwordBytes.Length > TokenJob.MaxKeyLength)
                {
                    throw new ArgumentException(string.Format("Invalid Password Length. Cannot be more than {0} bytes.", TokenJob.MaxKeyLength));
                }

                // check length and pad if necessary
                byte[] paddedKey = new Byte[TokenJob.MaxKeyLength];
                if (passwordBytes != null)
                {
                    passwordBytes.CopyTo(paddedKey, 0);
                }

                return paddedKey;
            }
        }

        /// <summary>
        /// The original suggestion from Ken Requires Web Service Enhancements 3.0, download from
        /// http://www.microsoft.com/downloads/en/details.aspx?FamilyID=018a09fd-3a74-43c5-8ec1-8d789091255d&displaylang=en
        /// instead using native .net implementation http://blogs.msdn.com/b/shawnfa/archive/2004/04/14/113514.aspx
        /// </summary>
        private byte[] GetNewKeyFromPassword(string password)
        {
            Rfc2898DeriveBytes pwdGen = new Rfc2898DeriveBytes(password, TokenConstants.SALT, 1000);
            // generate an RC2 key
            byte[] key = pwdGen.GetBytes(16);

            return key;
        }

        private static bool CheckReadAccess(string inputFile)
        {
            bool access = false;
            // check the read access 
            try
            {
                string path = Path.GetDirectoryName(inputFile);
                DirectoryInfo dir = new DirectoryInfo(path);
                FileInfo[] fi = dir.GetFiles();
                access = true;
            }
            catch (Exception)
            {
                access = false;
            }

            return access;
        }

        private static bool CheckWriteAccess(string outputFile)
        {
            bool access = false;
            FileStream fs = null;
            string tempFile = null;

            // check the write access 
            try
            {
                string path = Path.GetDirectoryName(outputFile);
                DirectoryInfo dir = new DirectoryInfo(path);
                FileInfo[] fi = dir.GetFiles();
                if (!Directory.Exists(path))
                {
                    Directory.CreateDirectory(path);
                }
                tempFile = Path.Combine(path, Path.GetRandomFileName());
                fs = new FileStream(tempFile, FileMode.CreateNew);

                access = true;
            }
            catch (Exception)
            {
                access = false;
            }
            finally
            {
                if (fs != null)
                {
                    fs.Close();
                    File.Delete(tempFile);
                }
            }

            return access;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\TokenManagement\DecryptTool\DecryptToolApp\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\TokenManagement\DecryptTool\DecryptToolApp\DecryptTool.cs ===
ï»¿using System;
using System.Collections.Generic;
using System.Linq;
using System.Windows.Forms;

namespace DecryptToolApp
{
    static class DecryptTool
    {
        /// <summary>
        /// The main entry point for the application.
        /// </summary>
        [STAThread]
        static void Main()
        {
            Application.EnableVisualStyles();
            Application.SetCompatibleTextRenderingDefault(false);
            Application.Run(new fmDecrypt());
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\TokenManagement\DecryptTool\DecryptToolApp\DecryptForm.Designer.cs ===
ï»¿namespace DecryptToolApp
{
    partial class fmDecrypt
    {
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            this.menuStrip1 = new System.Windows.Forms.MenuStrip();
            this.msFile = new System.Windows.Forms.ToolStripMenuItem();
            this.miExit = new System.Windows.Forms.ToolStripMenuItem();
            this.lbInputFile = new System.Windows.Forms.Label();
            this.lbPassword = new System.Windows.Forms.Label();
            this.lbOutputFile = new System.Windows.Forms.Label();
            this.btProcess = new System.Windows.Forms.Button();
            this.btCancel = new System.Windows.Forms.Button();
            this.tbInputFile = new System.Windows.Forms.TextBox();
            this.tbPassword = new System.Windows.Forms.TextBox();
            this.tbOutputFile = new System.Windows.Forms.TextBox();
            this.label1 = new System.Windows.Forms.Label();
            this.label2 = new System.Windows.Forms.Label();
            this.label3 = new System.Windows.Forms.Label();
            this.tbMessages = new System.Windows.Forms.TextBox();
            this.btInputFileSelect = new System.Windows.Forms.Button();
            this.sbStartTime = new System.Windows.Forms.Label();
            this.lbEndTime = new System.Windows.Forms.Label();
            this.lbTokenCount = new System.Windows.Forms.Label();
            this.label8 = new System.Windows.Forms.Label();
            this.label9 = new System.Windows.Forms.Label();
            this.label10 = new System.Windows.Forms.Label();
            this.tbStartTime = new System.Windows.Forms.TextBox();
            this.tbEndTime = new System.Windows.Forms.TextBox();
            this.tbTokenCount = new System.Windows.Forms.TextBox();
            this.lbPasswordTip = new System.Windows.Forms.Label();
            this.btOutputPathSelect = new System.Windows.Forms.Button();
            this.tabOutput = new System.Windows.Forms.TabControl();
            this.tabOutputLog = new System.Windows.Forms.TabPage();
            this.tabOutputText = new System.Windows.Forms.TabPage();
            this.rtbTokenOutput = new System.Windows.Forms.RichTextBox();
            this.checkBoxToken5x5Only = new System.Windows.Forms.CheckBox();
            this.groupBoxOutputOptions = new System.Windows.Forms.GroupBox();
            this.menuStrip1.SuspendLayout();
            this.tabOutput.SuspendLayout();
            this.tabOutputLog.SuspendLayout();
            this.tabOutputText.SuspendLayout();
            this.groupBoxOutputOptions.SuspendLayout();
            this.SuspendLayout();
            // 
            // menuStrip1
            // 
            this.menuStrip1.Items.AddRange(new System.Windows.Forms.ToolStripItem[] {
            this.msFile});
            this.menuStrip1.Location = new System.Drawing.Point(0, 0);
            this.menuStrip1.Name = "menuStrip1";
            this.menuStrip1.Size = new System.Drawing.Size(940, 24);
            this.menuStrip1.TabIndex = 18;
            this.menuStrip1.Text = "menuStrip1";
            // 
            // msFile
            // 
            this.msFile.DropDownItems.AddRange(new System.Windows.Forms.ToolStripItem[] {
            this.miExit});
            this.msFile.Name = "msFile";
            this.msFile.ShortcutKeyDisplayString = "F";
            this.msFile.ShortcutKeys = ((System.Windows.Forms.Keys)((System.Windows.Forms.Keys.Alt | System.Windows.Forms.Keys.F)));
            this.msFile.Size = new System.Drawing.Size(37, 20);
            this.msFile.Text = "&File";
            // 
            // miExit
            // 
            this.miExit.Name = "miExit";
            this.miExit.Size = new System.Drawing.Size(92, 22);
            this.miExit.Text = "&Exit";
            this.miExit.Click += new System.EventHandler(this.miExit_Click);
            // 
            // lbInputFile
            // 
            this.lbInputFile.AutoSize = true;
            this.lbInputFile.Location = new System.Drawing.Point(34, 48);
            this.lbInputFile.Name = "lbInputFile";
            this.lbInputFile.Size = new System.Drawing.Size(50, 13);
            this.lbInputFile.TabIndex = 1;
            this.lbInputFile.Text = "Input File";
            // 
            // lbPassword
            // 
            this.lbPassword.AutoSize = true;
            this.lbPassword.Location = new System.Drawing.Point(31, 129);
            this.lbPassword.Name = "lbPassword";
            this.lbPassword.Size = new System.Drawing.Size(53, 13);
            this.lbPassword.TabIndex = 4;
            this.lbPassword.Text = "Password";
            // 
            // lbOutputFile
            // 
            this.lbOutputFile.AutoSize = true;
            this.lbOutputFile.Location = new System.Drawing.Point(26, 159);
            this.lbOutputFile.Name = "lbOutputFile";
            this.lbOutputFile.Size = new System.Drawing.Size(58, 13);
            this.lbOutputFile.TabIndex = 6;
            this.lbOutputFile.Text = "Output File";
            // 
            // btProcess
            // 
            this.btProcess.Location = new System.Drawing.Point(106, 291);
            this.btProcess.Name = "btProcess";
            this.btProcess.Size = new System.Drawing.Size(116, 26);
            this.btProcess.TabIndex = 16;
            this.btProcess.Text = "&Decrypt Tokens";
            this.btProcess.UseVisualStyleBackColor = true;
            this.btProcess.Click += new System.EventHandler(this.btProcess_Click);
            // 
            // btCancel
            // 
            this.btCancel.Location = new System.Drawing.Point(12, 291);
            this.btCancel.Name = "btCancel";
            this.btCancel.Size = new System.Drawing.Size(75, 26);
            this.btCancel.TabIndex = 15;
            this.btCancel.Text = "&Cancel";
            this.btCancel.UseVisualStyleBackColor = true;
            this.btCancel.Click += new System.EventHandler(this.btCancel_Click);
            // 
            // tbInputFile
            // 
            this.tbInputFile.Location = new System.Drawing.Point(106, 44);
            this.tbInputFile.MaxLength = 255;
            this.tbInputFile.Name = "tbInputFile";
            this.tbInputFile.Size = new System.Drawing.Size(807, 20);
            this.tbInputFile.TabIndex = 2;
            this.tbInputFile.TextChanged += new System.EventHandler(this.tbInputFile_TextChanged);
            // 
            // tbPassword
            // 
            this.tbPassword.Location = new System.Drawing.Point(106, 125);
            this.tbPassword.MaxLength = 16;
            this.tbPassword.Name = "tbPassword";
            this.tbPassword.PasswordChar = '*';
            this.tbPassword.Size = new System.Drawing.Size(165, 20);
            this.tbPassword.TabIndex = 5;
            this.tbPassword.TextChanged += new System.EventHandler(this.tbPassword_TextChanged);
            // 
            // tbOutputFile
            // 
            this.tbOutputFile.Location = new System.Drawing.Point(106, 155);
            this.tbOutputFile.MaxLength = 255;
            this.tbOutputFile.Name = "tbOutputFile";
            this.tbOutputFile.Size = new System.Drawing.Size(807, 20);
            this.tbOutputFile.TabIndex = 7;
            this.tbOutputFile.TextChanged += new System.EventHandler(this.tbOutputFile_TextChanged);
            // 
            // label1
            // 
            this.label1.AutoSize = true;
            this.label1.Location = new System.Drawing.Point(90, 48);
            this.label1.Name = "label1";
            this.label1.Size = new System.Drawing.Size(10, 13);
            this.label1.TabIndex = 0;
            this.label1.Text = ":";
            // 
            // label2
            // 
            this.label2.AutoSize = true;
            this.label2.Location = new System.Drawing.Point(90, 159);
            this.label2.Name = "label2";
            this.label2.Size = new System.Drawing.Size(10, 13);
            this.label2.TabIndex = 0;
            this.label2.Text = ":";
            // 
            // label3
            // 
            this.label3.AutoSize = true;
            this.label3.Location = new System.Drawing.Point(90, 129);
            this.label3.Name = "label3";
            this.label3.Size = new System.Drawing.Size(10, 13);
            this.label3.TabIndex = 0;
            this.label3.Text = ":";
            // 
            // tbMessages
            // 
            this.tbMessages.Enabled = false;
            this.tbMessages.Location = new System.Drawing.Point(0, 0);
            this.tbMessages.Multiline = true;
            this.tbMessages.Name = "tbMessages";
            this.tbMessages.ScrollBars = System.Windows.Forms.ScrollBars.Both;
            this.tbMessages.Size = new System.Drawing.Size(897, 298);
            this.tbMessages.TabIndex = 18;
            // 
            // btInputFileSelect
            // 
            this.btInputFileSelect.Location = new System.Drawing.Point(106, 81);
            this.btInputFileSelect.Name = "btInputFileSelect";
            this.btInputFileSelect.Size = new System.Drawing.Size(116, 23);
            this.btInputFileSelect.TabIndex = 3;
            this.btInputFileSelect.Text = "&Select File";
            this.btInputFileSelect.UseVisualStyleBackColor = true;
            this.btInputFileSelect.Click += new System.EventHandler(this.btInputFileSelect_Click);
            // 
            // sbStartTime
            // 
            this.sbStartTime.AutoSize = true;
            this.sbStartTime.Location = new System.Drawing.Point(29, 227);
            this.sbStartTime.Name = "sbStartTime";
            this.sbStartTime.Size = new System.Drawing.Size(55, 13);
            this.sbStartTime.TabIndex = 9;
            this.sbStartTime.Text = "Start Time";
            // 
            // lbEndTime
            // 
            this.lbEndTime.AutoSize = true;
            this.lbEndTime.Location = new System.Drawing.Point(32, 262);
            this.lbEndTime.Name = "lbEndTime";
            this.lbEndTime.Size = new System.Drawing.Size(52, 13);
            this.lbEndTime.TabIndex = 11;
            this.lbEndTime.Text = "End Time";
            // 
            // lbTokenCount
            // 
            this.lbTokenCount.AutoSize = true;
            this.lbTokenCount.Location = new System.Drawing.Point(664, 227);
            this.lbTokenCount.Name = "lbTokenCount";
            this.lbTokenCount.Size = new System.Drawing.Size(127, 13);
            this.lbTokenCount.TabIndex = 13;
            this.lbTokenCount.Text = "No. of Tokens Decrypted";
            // 
            // label8
            // 
            this.label8.AutoSize = true;
            this.label8.Location = new System.Drawing.Point(90, 227);
            this.label8.Name = "label8";
            this.label8.Size = new System.Drawing.Size(10, 13);
            this.label8.TabIndex = 0;
            this.label8.Text = ":";
            // 
            // label9
            // 
            this.label9.AutoSize = true;
            this.label9.Location = new System.Drawing.Point(90, 262);
            this.label9.Name = "label9";
            this.label9.Size = new System.Drawing.Size(10, 13);
            this.label9.TabIndex = 0;
            this.label9.Text = ":";
            // 
            // label10
            // 
            this.label10.AutoSize = true;
            this.label10.Location = new System.Drawing.Point(797, 227);
            this.label10.Name = "label10";
            this.label10.Size = new System.Drawing.Size(10, 13);
            this.label10.TabIndex = 0;
            this.label10.Text = ":";
            // 
            // tbStartTime
            // 
            this.tbStartTime.Enabled = false;
            this.tbStartTime.Location = new System.Drawing.Point(106, 223);
            this.tbStartTime.Name = "tbStartTime";
            this.tbStartTime.Size = new System.Drawing.Size(165, 20);
            this.tbStartTime.TabIndex = 10;
            // 
            // tbEndTime
            // 
            this.tbEndTime.Enabled = false;
            this.tbEndTime.Location = new System.Drawing.Point(106, 258);
            this.tbEndTime.Name = "tbEndTime";
            this.tbEndTime.Size = new System.Drawing.Size(165, 20);
            this.tbEndTime.TabIndex = 12;
            // 
            // tbTokenCount
            // 
            this.tbTokenCount.Enabled = false;
            this.tbTokenCount.Location = new System.Drawing.Point(813, 223);
            this.tbTokenCount.MaxLength = 16;
            this.tbTokenCount.Name = "tbTokenCount";
            this.tbTokenCount.Size = new System.Drawing.Size(100, 20);
            this.tbTokenCount.TabIndex = 14;
            this.tbTokenCount.TextAlign = System.Windows.Forms.HorizontalAlignment.Right;
            // 
            // lbPasswordTip
            // 
            this.lbPasswordTip.AutoSize = true;
            this.lbPasswordTip.Location = new System.Drawing.Point(277, 129);
            this.lbPasswordTip.Name = "lbPasswordTip";
            this.lbPasswordTip.Size = new System.Drawing.Size(104, 13);
            this.lbPasswordTip.TabIndex = 19;
            this.lbPasswordTip.Text = "(Max. 16 characters)";
            // 
            // btOutputPathSelect
            // 
            this.btOutputPathSelect.Location = new System.Drawing.Point(106, 186);
            this.btOutputPathSelect.Name = "btOutputPathSelect";
            this.btOutputPathSelect.Size = new System.Drawing.Size(116, 23);
            this.btOutputPathSelect.TabIndex = 8;
            this.btOutputPathSelect.Text = "Select &Output Folder";
            this.btOutputPathSelect.UseVisualStyleBackColor = true;
            this.btOutputPathSelect.Click += new System.EventHandler(this.btOutputPathSelect_Click);
            // 
            // tabOutput
            // 
            this.tabOutput.Controls.Add(this.tabOutputLog);
            this.tabOutput.Controls.Add(this.tabOutputText);
            this.tabOutput.Location = new System.Drawing.Point(12, 334);
            this.tabOutput.Name = "tabOutput";
            this.tabOutput.SelectedIndex = 0;
            this.tabOutput.Size = new System.Drawing.Size(901, 320);
            this.tabOutput.TabIndex = 17;
            // 
            // tabOutputLog
            // 
            this.tabOutputLog.Controls.Add(this.tbMessages);
            this.tabOutputLog.Location = new System.Drawing.Point(4, 22);
            this.tabOutputLog.Name = "tabOutputLog";
            this.tabOutputLog.Padding = new System.Windows.Forms.Padding(3);
            this.tabOutputLog.Size = new System.Drawing.Size(893, 294);
            this.tabOutputLog.TabIndex = 0;
            this.tabOutputLog.Text = "Output Log";
            this.tabOutputLog.UseVisualStyleBackColor = true;
            // 
            // tabOutputText
            // 
            this.tabOutputText.Controls.Add(this.rtbTokenOutput);
            this.tabOutputText.Location = new System.Drawing.Point(4, 22);
            this.tabOutputText.Name = "tabOutputText";
            this.tabOutputText.Padding = new System.Windows.Forms.Padding(3);
            this.tabOutputText.Size = new System.Drawing.Size(893, 294);
            this.tabOutputText.TabIndex = 1;
            this.tabOutputText.Text = "Token Output";
            this.tabOutputText.UseVisualStyleBackColor = true;
            // 
            // rtbTokenOutput
            // 
            this.rtbTokenOutput.Font = new System.Drawing.Font("Courier New", 9F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.rtbTokenOutput.Location = new System.Drawing.Point(0, 0);
            this.rtbTokenOutput.Name = "rtbTokenOutput";
            this.rtbTokenOutput.ReadOnly = true;
            this.rtbTokenOutput.Size = new System.Drawing.Size(893, 298);
            this.rtbTokenOutput.TabIndex = 19;
            this.rtbTokenOutput.Text = "";
            // 
            // checkBoxToken5x5Only
            // 
            this.checkBoxToken5x5Only.AutoSize = true;
            this.checkBoxToken5x5Only.Checked = true;
            this.checkBoxToken5x5Only.CheckState = System.Windows.Forms.CheckState.Checked;
            this.checkBoxToken5x5Only.Location = new System.Drawing.Point(15, 28);
            this.checkBoxToken5x5Only.Name = "checkBoxToken5x5Only";
            this.checkBoxToken5x5Only.Size = new System.Drawing.Size(99, 17);
            this.checkBoxToken5x5Only.TabIndex = 20;
            this.checkBoxToken5x5Only.Text = "Token 5x5 only";
            this.checkBoxToken5x5Only.UseVisualStyleBackColor = true;
            // 
            // groupBoxOutputOptions
            // 
            this.groupBoxOutputOptions.Controls.Add(this.checkBoxToken5x5Only);
            this.groupBoxOutputOptions.Location = new System.Drawing.Point(404, 81);
            this.groupBoxOutputOptions.Name = "groupBoxOutputOptions";
            this.groupBoxOutputOptions.Size = new System.Drawing.Size(508, 60);
            this.groupBoxOutputOptions.TabIndex = 21;
            this.groupBoxOutputOptions.TabStop = false;
            this.groupBoxOutputOptions.Text = "Output Options";
            // 
            // fmDecrypt
            // 
            this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            this.ClientSize = new System.Drawing.Size(940, 666);
            this.Controls.Add(this.tabOutput);
            this.Controls.Add(this.btOutputPathSelect);
            this.Controls.Add(this.lbPasswordTip);
            this.Controls.Add(this.tbTokenCount);
            this.Controls.Add(this.tbEndTime);
            this.Controls.Add(this.tbStartTime);
            this.Controls.Add(this.label10);
            this.Controls.Add(this.label9);
            this.Controls.Add(this.label8);
            this.Controls.Add(this.lbTokenCount);
            this.Controls.Add(this.lbEndTime);
            this.Controls.Add(this.sbStartTime);
            this.Controls.Add(this.btInputFileSelect);
            this.Controls.Add(this.label3);
            this.Controls.Add(this.label2);
            this.Controls.Add(this.label1);
            this.Controls.Add(this.btCancel);
            this.Controls.Add(this.btProcess);
            this.Controls.Add(this.lbOutputFile);
            this.Controls.Add(this.lbPassword);
            this.Controls.Add(this.tbOutputFile);
            this.Controls.Add(this.lbInputFile);
            this.Controls.Add(this.menuStrip1);
            this.Controls.Add(this.tbPassword);
            this.Controls.Add(this.tbInputFile);
            this.Controls.Add(this.groupBoxOutputOptions);
            this.MainMenuStrip = this.menuStrip1;
            this.Name = "fmDecrypt";
            this.Text = "Token File Decryption Tool";
            this.Load += new System.EventHandler(this.Form1_Load);
            this.menuStrip1.ResumeLayout(false);
            this.menuStrip1.PerformLayout();
            this.tabOutput.ResumeLayout(false);
            this.tabOutputLog.ResumeLayout(false);
            this.tabOutputLog.PerformLayout();
            this.tabOutputText.ResumeLayout(false);
            this.groupBoxOutputOptions.ResumeLayout(false);
            this.groupBoxOutputOptions.PerformLayout();
            this.ResumeLayout(false);
            this.PerformLayout();

        }

        #endregion

        private System.Windows.Forms.MenuStrip menuStrip1;
        private System.Windows.Forms.ToolStripMenuItem msFile;
        private System.Windows.Forms.ToolStripMenuItem miExit;
        private System.Windows.Forms.Label lbInputFile;
        private System.Windows.Forms.Label lbPassword;
        private System.Windows.Forms.Label lbOutputFile;
        private System.Windows.Forms.Button btProcess;
        private System.Windows.Forms.Button btCancel;
        private System.Windows.Forms.TextBox tbInputFile;
        private System.Windows.Forms.TextBox tbOutputFile;
        private System.Windows.Forms.TextBox tbPassword;
        private System.Windows.Forms.Label label1;
        private System.Windows.Forms.Label label2;
        private System.Windows.Forms.Label label3;
        private System.Windows.Forms.TextBox tbMessages;
        private System.Windows.Forms.Button btInputFileSelect;
        private System.Windows.Forms.Label sbStartTime;
        private System.Windows.Forms.Label lbEndTime;
        private System.Windows.Forms.Label lbTokenCount;
        private System.Windows.Forms.Label label8;
        private System.Windows.Forms.Label label9;
        private System.Windows.Forms.Label label10;
        private System.Windows.Forms.TextBox tbStartTime;
        private System.Windows.Forms.TextBox tbEndTime;
        private System.Windows.Forms.TextBox tbTokenCount;
        private System.Windows.Forms.Label lbPasswordTip;
        private System.Windows.Forms.Button btOutputPathSelect;
        private System.Windows.Forms.TabControl tabOutput;
        private System.Windows.Forms.TabPage tabOutputLog;
        private System.Windows.Forms.TabPage tabOutputText;
        private System.Windows.Forms.RichTextBox rtbTokenOutput;
        private System.Windows.Forms.CheckBox checkBoxToken5x5Only;
        private System.Windows.Forms.GroupBox groupBoxOutputOptions;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\TokenManagement\DecryptTool\DecryptToolUnitTest\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\TokenManagement\DecryptTool\DecryptToolApp\DecryptForm.cs ===
ï»¿using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.IO;
using System.Linq;
using System.Text;
using System.Windows.Forms;

using xonline.server.mix.TokenManagement.Tools;

namespace DecryptToolApp
{
    public partial class fmDecrypt : Form
    {
        DecryptTokenFile decryptor ;
        StringBuilder buffer;

        public fmDecrypt()
        {
            InitializeComponent();
            this.AcceptButton = this.btProcess;
            this.CancelButton = this.btCancel;
            this.tabOutput.SelectedTab = this.tabOutputLog;
            this.tbMessages.Parent = this.tabOutputLog;
            this.rtbTokenOutput.Parent = this.tabOutputText;
            this.rtbTokenOutput.ScrollBars = RichTextBoxScrollBars.Both;
            this.tabOutput.SelectedIndexChanged += new System.EventHandler(this.tabOutput_SelectedIndexChanged);

            this.tbInputFile.LostFocus += new System.EventHandler(tbInputFile_LostFocus);
            this.btInputFileSelect.LostFocus += new System.EventHandler(btInputFileSelect_LostFocus);
        }

        private void Form1_Load(object sender, EventArgs e)
        {
            decryptor = new DecryptTokenFile();
            toggleProcessButton();
        }

        private void miExit_Click(object sender, EventArgs e)
        {
            this.Close();
        }

        private void tbInputFile_TextChanged(object sender, EventArgs e)
        {
            toggleProcessButton();
        }

        private void tbPassword_TextChanged(object sender, EventArgs e)
        {
            toggleProcessButton();
        }

        private void tbOutputFile_TextChanged(object sender, EventArgs e)
        {
            toggleProcessButton();
        }

        private void toggleProcessButton()
        {
            //validate length of all fields
            this.btProcess.Enabled = (this.tbInputFile.Text.Length >= 1) && (this.tbOutputFile.Text.Length > 0) && (this.tbPassword.Text.Length > 1);
        }

        private void tbInputFile_LostFocus(object sender, EventArgs e)
        {
            this.SetDefaultOutputFileName();
        }

        private void btInputFileSelect_LostFocus(object sender, EventArgs e)
        {
            this.SetDefaultOutputFileName();
        }

        private void btCancel_Click(object sender, EventArgs e)
        {
            this.tbInputFile.Text = "";
            this.tbOutputFile.Text = "";
            this.tbPassword.Text = "";
            this.tbMessages.Text = "";
            this.tbStartTime.Text = "";
            this.tbEndTime.Text = "";
            this.tbTokenCount.Text = "";
            this.rtbTokenOutput.Clear();
            this.tabOutput.SelectedTab = this.tabOutputLog;

            buffer = new StringBuilder();
        }

        private void btProcess_Click(object sender, EventArgs e)
        {
            bool continueDecrypt = this.VerifyOutputFileCreation();
            if (continueDecrypt)
            {
                this.tabOutput.SelectedTab = this.tabOutputLog;
                buffer = new StringBuilder();
                buffer.Append(string.Format("Starting to decrypt file {0} using Password: {2}. The Decrypted Tokens in file: {1} \n", this.tbInputFile.Text, this.tbOutputFile.Text, this.tbPassword.Text));
                this.tbMessages.Text = buffer.ToString();
                this.tbStartTime.Text = DateTime.Now.ToString();
                try
                {
                    this.btProcess.Enabled = false;
                    this.btCancel.Enabled = false;
                    Cursor.Current = Cursors.WaitCursor;
                    bool status = decryptor.DecryptFile(this.tbInputFile.Text.Trim(), this.tbOutputFile.Text.Trim(), this.tbPassword.Text.Trim(), OutputOptions);
                }
                // exception thrown
                // ArgumentException
                // Guid conversion
                catch (Exception ex)
                {
                    buffer.Append("\nError Decrypting tokens: " + ex.Message + "\n\n" + ex.StackTrace + "\n\n");
                }
                finally
                {
                    Cursor.Current = Cursors.Default;
                    this.btProcess.Enabled = true;
                    this.btCancel.Enabled = true;
                }
                this.tbEndTime.Text = DateTime.Now.ToString();
                buffer.Append("\nTotal Tokens Processed: " + decryptor.GetLinesProcessed());
                this.tbMessages.Text = buffer.ToString();
                this.tbTokenCount.Text = decryptor.GetLinesProcessed().ToString("###,###,###,##0");
            }
            else
            {
                this.tbOutputFile.Focus();
            }
        }

        private DecryptOutputOptions OutputOptions
        {
            get
            {
                DecryptOutputOptions options = DecryptOutputOptions.Default;
                if (checkBoxToken5x5Only.Checked)
                {
                    options = DecryptOutputOptions.Token5x5Only;
                }
                return options;
            }
        }

        private void btInputFileSelect_Click(object sender, EventArgs e)
        {
            OpenFileDialog ofd = new OpenFileDialog();
            if ( !(string.IsNullOrEmpty(this.tbInputFile.Text.Trim())))
            {
                ofd.InitialDirectory = Path.GetDirectoryName(this.tbInputFile.Text.Trim());
            }
            ofd.Title = "Select the Encrypted Token Binary File";
            ofd.Filter = "Encrypted Token (*.xtx)|*.xtx|All files (*.*)|*.*";
            ofd.RestoreDirectory = true;

            if (DialogResult.OK == ofd.ShowDialog())
            {
                this.tbInputFile.Text = ofd.FileName;
            }
            ofd.Dispose();
        }

        private void btOutputPathSelect_Click(object sender, EventArgs e)
        {
            FolderBrowserDialog fbd = new FolderBrowserDialog();
            if (!(string.IsNullOrEmpty(this.tbOutputFile.Text.Trim())))
            {
                fbd.SelectedPath = Path.GetDirectoryName(this.tbOutputFile.Text.Trim());
            }
            fbd.Description = "Select the Folder/File for Decrypted Token Text File";
            fbd.ShowNewFolderButton = true;

            if (DialogResult.OK == fbd.ShowDialog())
            {
                this.tbOutputFile.Text = fbd.SelectedPath;
            }
            fbd.Dispose();
        }

        private void tabOutput_SelectedIndexChanged(object sender, System.EventArgs e)
        {
            this.tabOutput.TabPages[this.tabOutput.SelectedIndex].Focus();
            if (this.tabOutput.SelectedTab == this.tabOutputText)
            {
                if (!(string.IsNullOrEmpty(this.tbOutputFile.Text.Trim())) && File.Exists(this.tbOutputFile.Text.Trim()))
                {
                    this.rtbTokenOutput.LoadFile(this.tbOutputFile.Text.Trim(), RichTextBoxStreamType.PlainText);
                }
            }
        }

        private bool VerifyOutputFileCreation()
        {
            bool result = true;
            if (!(string.IsNullOrEmpty(this.tbOutputFile.Text.Trim())) && File.Exists(this.tbOutputFile.Text.Trim()))
            {
                DialogResult dialogResult = MessageBox.Show(string.Format("Do You Want to Replace File '{0}' (y/n)?", this.tbOutputFile.Text.Trim()), 
                            "Confirm File Overwrite",
                            MessageBoxButtons.YesNo
                            );
                result = (dialogResult == DialogResult.OK || dialogResult == DialogResult.Yes) ? true : false;
            }

            return result;
        }

        private void SetDefaultOutputFileName()
        {
            if (!(string.IsNullOrEmpty(this.tbInputFile.Text.Trim())))
            {
                string directory = Path.GetDirectoryName(this.tbInputFile.Text.Trim());
                string extension = Path.GetExtension(this.tbInputFile.Text.Trim());
                string filename  = Path.GetFileName(this.tbInputFile.Text.Trim());
                int extIndex = filename.IndexOf(extension);
                // if no extension
                if (extIndex == 0)
                {
                    extIndex = filename.Length; 
                }
                string outputFileName = filename.Substring( 0, extIndex)  +"_decrypted.txt";
                this.tbOutputFile.Text = string.IsNullOrEmpty(directory) ? outputFileName : Path.Combine(directory, outputFileName);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\TokenManagement\DecryptTool\DecryptToolUnitTest\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\TokenManagement\DecryptTool\TestDecryptTool\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\TokenManagement\DecryptTool\DecryptToolApp\Properties\Resources.Designer.cs ===
ï»¿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.4927
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace DecryptToolApp.Properties
{


    /// <summary>
    ///   A strongly-typed resource class, for looking up localized strings, etc.
    /// </summary>
    // This class was auto-generated by the StronglyTypedResourceBuilder
    // class via a tool like ResGen or Visual Studio.
    // To add or remove a member, edit your .ResX file then rerun ResGen
    // with the /str option, or rebuild your VS project.
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "2.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    internal class Resources
    {

        private static global::System.Resources.ResourceManager resourceMan;

        private static global::System.Globalization.CultureInfo resourceCulture;

        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal Resources()
        {
        }

        /// <summary>
        ///   Returns the cached ResourceManager instance used by this class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Resources.ResourceManager ResourceManager
        {
            get
            {
                if ((resourceMan == null))
                {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("DecryptToolApp.Properties.Resources", typeof(Resources).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }

        /// <summary>
        ///   Overrides the current thread's CurrentUICulture property for all
        ///   resource lookups using this strongly typed resource class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Globalization.CultureInfo Culture
        {
            get
            {
                return resourceCulture;
            }
            set
            {
                resourceCulture = value;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\TokenManagement\DecryptTool\TestDecryptTool\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\TokenManagement\DecryptTool\DecryptToolUnitTest\DecryptToolUnitTest.cs ===
ï»¿using System;
using System.IO;
using Microsoft.VisualStudio.TestTools.UnitTesting;

using xonline.server.mix.TokenManagement.Tools;

namespace DecryptToolUnitTest
{
    /// <summary>
    /// Summary description for UnitTest1
    /// </summary>
    [TestClass]
    public class DecryptToolUnitTest
    {
        //		\\private\\server\\Mix\\TokenManagement\\DecryptTool\\TestResults\\ramittal_RAMITTAL3 2010-08-02 17_07_25\\Out"	
        private static string EncryptedFile = "..\\..\\..\\DecryptToolUnitTest\\22ede6ce-6a40-4d7e-94d5-4a58963e894f.xtx";
        private static string password = "TokenGeneration";

        private static string EncryptedFile1 = "..\\..\\..\\DecryptToolUnitTest\\pwd-123456789abcdefg-4f86a76b-1e9e-4846-bad8-4fcaab44937b.xtx";
        private static string password1 = "123456789abcdefg";

        private static string EncryptedFile2 = "..\\..\\..\\DecryptToolUnitTest\\pwd-balma-c861eea8-9027-4b9d-8980-25947f78c197.xtx";
        private static string password2 = "balma";

        private static string EncryptedFile3 = "..\\..\\..\\DecryptToolUnitTest\\pwd-TokensGeneration-NewEncryption-56590407-1d7c-4e76-9700-fdb1981f4323.xtx";
        private static string password3 = "TokensGeneration";

        public DecryptToolUnitTest()
        {
            //
            // TODO: Add constructor logic here
            //
        }

        private TestContext testContextInstance;

        /// <summary>
        ///Gets or sets the test context which provides
        ///information about and functionality for the current test run.
        ///</summary>
        public TestContext TestContext
        {
            get
            {
                return testContextInstance;
            }
            set
            {
                testContextInstance = value;
            }
        }

        #region Additional test attributes
        //
        // You can use the following additional attributes as you write your tests:
        //
        // Use ClassInitialize to run code before running the first test in the class
        // [ClassInitialize()]
        // public static void MyClassInitialize(TestContext testContext) { }
        //
        // Use ClassCleanup to run code after all tests in a class have run
        // [ClassCleanup()]
        // public static void MyClassCleanup() { }
        //
        // Use TestInitialize to run code before running each test 
        // [TestInitialize()]
        // public void MyTestInitialize() { }
        //
        // Use TestCleanup to run code after each test has run
        // [TestCleanup()]
        // public void MyTestCleanup() { }
        //
        #endregion

        [TestMethod]
        [ExpectedException(typeof(ArgumentException), "Password Cannot be Null or Empty.")]
        public void PasswordNull()
        {
            DecryptTokenFile decryptor = new DecryptTokenFile();
            string password = null;
            bool status = decryptor.DecryptFile(null, null, password);
        }

        [TestMethod]
        [ExpectedException(typeof(ArgumentException), "Password cannot be null or empty.")]
        public void EmptyPasswordEmpty()
        {
            DecryptTokenFile decryptor = new DecryptTokenFile();
            bool status = decryptor.DecryptFile(EncryptedFile, "\\\\sharepoint\\Perflogs\\decrypted.txt", "");
        }

        [TestMethod]
        [ExpectedException(typeof(ArgumentException), "Invalid Password Length. Cannot be more than 16 bytes.")]
        public void PasswordGreaterThan16()
        {
            DecryptTokenFile decryptor = new DecryptTokenFile();
            bool status = decryptor.DecryptFile(EncryptedFile, "\\\\sharepoint\\Perflogs\\decrypted.txt", "012345678901234567890");
        }

        [TestMethod]
        [ExpectedException(typeof(ArgumentException), "Empty or Null input file.")] 
        public void InputFileNameNull()
        {
            DecryptTokenFile decryptor = new DecryptTokenFile();
            bool status = decryptor.DecryptFile(null, null, "0123456789");
        }

        [TestMethod]
        [ExpectedException(typeof(ArgumentException), "Invalid input file name (JobId cannot be determined):")]
        public void InputFileNameInvalid()
        {
            DecryptTokenFile decryptor = new DecryptTokenFile();
            bool status = decryptor.DecryptFile("c:\\windows\\win.ini", null, "0123456789012345");
        }

        [TestMethod]
        [ExpectedException(typeof(ArgumentException), "Unable to Read the input file: ")]
        public void InputFileNameNoReadAccess()
        {
            DecryptTokenFile decryptor = new DecryptTokenFile();
            bool status = decryptor.DecryptFile("\\\\sharepoint\\backup\\9890c5e0-66b1-4170-937f-c9bbbd3188dd.xtx", null, "0123456789");
        }

        [TestMethod]
        [ExpectedException(typeof(ArgumentException), "Input file: {0) does not exist.")]
        public void InputFileNameNonExisting()
        {
            DecryptTokenFile decryptor = new DecryptTokenFile();
            bool status = decryptor.DecryptFile("c:\\temp\\9890c5e0-66b1-4170-937f-c9bbbd3188dd.xtx", null, "0123456789");
        }

        [TestMethod]
        [ExpectedException(typeof(ArgumentException), "Invalid Input File Name. Could not parse JobId.")]
        public void InputFileNameInvalidJobId()
        {
            DecryptTokenFile decryptor = new DecryptTokenFile();
            bool status = decryptor.DecryptFile("c:\\temp\\badguid-9890c5e0-66b1-....-937f-c9bbbd3188dd.xtx", null, "0123456789");
        }

        [TestMethod]
        [ExpectedException(typeof(ArgumentException), "Unable to write the output file: ")]
        public void OutputFileNamePathNoWriteAccess()
        {
            DecryptTokenFile decryptor = new DecryptTokenFile();
            bool status = decryptor.DecryptFile(EncryptedFile, "\\\\sharepoint\\Perflogs\\decrypted.txt", "0123456789");
        }

        [TestMethod]
        [ExpectedException(typeof(InvalidDataException), "The magic number in GZip header is not correct. Make sure you are passing in a GZip stream..	")]
        public void WrongPassword()
        {
            DecryptTokenFile decryptor = new DecryptTokenFile();
            string outputFile = Path.GetTempFileName();
            bool status = decryptor.DecryptFile(EncryptedFile, outputFile, password);
            Assert.IsTrue(false);
            //Assert.AreEqual<int>(5, decryptor.GetLinesProcessed());
            File.Delete(outputFile);
        }

        [TestMethod]
        public void DecryptTokenTestSuccessMaxLEngthPassword()
        {
            DecryptTokenFile decryptor = new DecryptTokenFile();
            string outputFile1 = Path.GetTempFileName();
            bool status = decryptor.DecryptFile(EncryptedFile1, outputFile1, password1);
            Assert.IsTrue(status);
            Assert.AreEqual<int>(10, decryptor.GetLinesProcessed());
            File.Delete(outputFile1);
        }

        [TestMethod]
        public void DecryptTokenTestSuccessShortPassword()
        {
            DecryptTokenFile decryptor = new DecryptTokenFile();
            string outputFile2 = Path.GetTempFileName();
            bool status = decryptor.DecryptFile(EncryptedFile2, outputFile2, password2);
            Assert.IsTrue(status);
            Assert.AreEqual<int>(7, decryptor.GetLinesProcessed());
            File.Delete(outputFile2);
        }

        [TestMethod]
        public void DecryptTokenTestSuccessUsingNewEncryption()
        {
            DecryptTokenFile decryptor = new DecryptTokenFile();
            string outputFile3 = Path.GetTempFileName();
            bool status = decryptor.DecryptFile(EncryptedFile3, outputFile3, password3);
            Assert.IsTrue(status);
            Assert.AreEqual<int>( 3, decryptor.GetLinesProcessed());
            File.Delete(outputFile3);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\TokenManagement\DecryptTool\DecryptToolApp\Properties\Settings.Designer.cs ===
ï»¿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.4927
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace DecryptToolApp.Properties
{


    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.Editors.SettingsDesigner.SettingsSingleFileGenerator", "9.0.0.0")]
    internal sealed partial class Settings : global::System.Configuration.ApplicationSettingsBase
    {

        private static Settings defaultInstance = ((Settings)(global::System.Configuration.ApplicationSettingsBase.Synchronized(new Settings())));

        public static Settings Default
        {
            get
            {
                return defaultInstance;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\TokenManagement\Service\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\TokenManagement\DecryptTool\TestDecryptTool\TestDecryption.cs ===
ï»¿using System;
using System.IO;

using xonline.server.mix.TokenManagement.Tools;

namespace TestDecryptTool
{
    class TestDecryption
    {
        static void Main(string[] args)
        {
            string inputFile = "..\\..\\pwd-123456789abcdefg-4f86a76b-1e9e-4846-bad8-4fcaab44937b.xtx";
            string outputFile = Path.GetTempFileName();
            string password = "123456789abcdefg";

            inputFile = "..\\..\\pwd-balma-c861eea8-9027-4b9d-8980-25947f78c197.xtx";
            password = "balma";

            inputFile = "..\\..\\pwd-Frank-3bf22a47-5fb8-458c-ab43-8ac68cff14db.xtx";
            password = "Frank";

            if (args.Length > 0)
            {
                inputFile = args[0];
                if (args.Length > 1)
                {
                    outputFile = args[1];

                    if (args.Length > 2)
                    {
                        password = args[2];
                    }
                }
            }

            string crrdir = Directory.GetCurrentDirectory();

            Console.WriteLine(string.Format("InputFile:{0}:\nOutputFile:{1}:\nPassword:{2}:\n", inputFile, outputFile, password));
            DecryptTokenFile decryptor = new DecryptTokenFile();
            bool status = decryptor.DecryptFile(inputFile, outputFile, password);
            Console.WriteLine("Decrypt Status: {0},\nTotal Tokens Decrypted: {1}.\n", status, decryptor.GetLinesProcessed());
            Console.ReadKey();

            return;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\TokenManagement\Service\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\TokenManagement\Service\global.asax.cs ===
using System;
using xonline.common.service;
using xonline.common.mgmt;
using xonline.server.mgmt.soap;
using xonline.mix.common;


namespace xonline.mix.tokenmanagement.service
{
    public class MixTokenManagementApp : SoapFrontEndApp
    {
        /// <summary>
        /// Default constructor
        /// </summary>
        public MixTokenManagementApp()
            : base()
        {

        }

        public override void Application_Start(object sender, EventArgs eventArgs)
        {
            //Call the base 
            base.Application_Start(sender, eventArgs);

            EventBuilder.ShowSGInfo = false;
            // Custom start code
            XomControl.ControlRequestEvent += new XomControl.ControlRequestEventHandler(OnXomControlRequest);

        }
        /// <summary>
        /// Event handler for the Xmgmt control request event
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="args"></param>
        public void OnXomControlRequest(object sender, ControlRequestEventArgs args)
        {
            //TODO add xmgmt control command parsing logic and code
            //Is there any thing to reload, cancel? 
        }
        /// <summary>
        /// Error handling for Mix will happen using MixError handler
        /// On Error is not capable of catching FaultExceptions
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="ea"></param>
        public override void Application_OnError(object sender, EventArgs ea)
        {
            //We handle errors in the MixErrorHandler
        }

        public override void Application_EndRequest(object sender, EventArgs ea)
        {
            //We dont need to reformat any response
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\TokenManagement\DVT\main.cs ===
using System;
using System.IO;
using System.Threading;
using System.Collections.Generic;
using System.Text;
using System.Security.Cryptography;
using System.ServiceModel;
using xonline.mix.tokenmanagement.contracts.V1;
using xonline.mix.common;

class Test
{
    static void Main()
    {
        Guid jobId;
        TokenGenerationTests(out jobId);
        GetTokenInfoTests(jobId);
    }

    static void TokenGenerationTests(out Guid jobId)
    {
        jobId = Guid.Empty;
        try
        {
            MixTokenManagementClient client = new MixTokenManagementClient();
            
            // Configure (create) a token category first.
            Console.WriteLine("Configuring token category...");
            TokenCategory tc1 = new TokenCategory();
            tc1.TokenCategoryId = Guid.NewGuid();
            tc1.TokenCategoryName = "Test TC " + DateTime.Now.ToString(); // Has to be unique
            tc1.ExpirationDate = new DateTime(2099, 12, 31);
            tc1.ProductTypeId = 23; // Full Arcade Game
            tc1.OfferId = new Guid("00000001-0000-4000-8000-0000584107F6"); // Texas Hold'em Full Game, part of the BVT titles.
            tc1.IsRsm = false;
            tc1.Pkpn = "test_pkpn_value";
            client.ConfigureTokenCategory(tc1);
            Dump(tc1);
            Console.WriteLine("Configure token category done.");

            // Generate tokens for this category
            Console.WriteLine("Generating tokens ...");
            TokenJob tj = client.GenerateTokens(tc1.TokenCategoryId, 100);
            Console.WriteLine("Got token job:");
            Dump(tj);
            Console.WriteLine("Now please refresh the cron health check on your xblob in order to trigger the job to run!");
            client.Close();
            
            // Querying for the status, in a loop, 10 sec each, for 30 times
            // We have to use different client each time, otherwise the connection will timeout.
            for (int i=0; i<30; i++)
            {
                MixTokenManagementClient clientStatus = new MixTokenManagementClient();                
                TokenJobStatus tjs = clientStatus.GetTokenJobStatus(tj.TokenJobId);
                Console.WriteLine("Querying token job status @{0}:", DateTime.Now);
                Dump(tjs);
                clientStatus.Close();
                if (tjs.Status == TokenJobStatusEnum.Delivered)
                {
                    ReportSuccess("Token Generation DVT");
                    jobId = tj.TokenJobId;
                    return;
                }
                Thread.Sleep(10000);
            }
            Exception ex = new Exception("Job didn't finish within testing timeframe!");
            ReportFailure("Token Generation DVT", ex);
        }
        catch (Exception ex)
        {
            ReportFailure("Token Generation DVT", ex);
        }
    }

    static void GetTokenInfoTests(Guid jobId)
    {
        try
        {
            // First, make sure the job is delivered.
            Console.WriteLine("Querying token job {0} status...", jobId.ToString());
            MixTokenManagementClient client = new MixTokenManagementClient();                
            TokenJobStatus tjs = client.GetTokenJobStatus(jobId);
            Dump(tjs);
            client.Close();
            if (tjs.Status != TokenJobStatusEnum.Delivered)
            {
                Exception ex = new Exception("Token job didn't finish!");
                ReportFailure("GetTokenInfo DVT", ex);
                return;
            }            
            // Now, get the token codes that the job generated.
            Console.WriteLine("Getting token codes...");
            string[] tokens = GetTokenCodes(jobId);
            // Make sure it has the same number of tokens the job reports
            if (tokens.Length != tjs.NumTokenCompleted)
            {
                Exception ex = new Exception("Didn't get the same number of tokens!");
                ReportFailure("GetTokenInfo DVT", ex);
                return;                
            }
            // Get the token info for the first and last of it.
            GetTokenInfoTest(tokens[0]);
            GetTokenInfoTest(tokens[tokens.Length - 1]);
            ReportSuccess("GetTokenInfo DVT");
        }
        catch (Exception ex)
        {
            ReportFailure("GetTokenInfo DVT", ex);
            throw;
        }
    }

    static void GetTokenInfoTest(string token)
    {
        MixTokenManagementClient client = new MixTokenManagementClient();
        // Get TokenInfo for clear text token value
        Console.WriteLine("Getting TokenInfo for clear text token {0} ...", token);        
        TokenInfo tokenInfo1 = client.GetTokenInfoByToken(token);
        Dump(tokenInfo1);
        Console.WriteLine("Getting TokenInfo for clear text token done.");
        
        // Get TokenInfo for tokenHash value
        Console.Write("Getting TokenInfo for tokenHash ");
        byte[] tokenHash = null;
        // Get token's hash value, the new tokens are using
        // SHA256 hash, and then truncate to 20 bytes for maintain compatibility.
        using (SHA256CryptoServiceProvider sha256 = new SHA256CryptoServiceProvider())
        {
            UnicodeEncoding enc = new UnicodeEncoding();
            byte[] keyBytes = enc.GetBytes(token + "\0");
            byte[] sha256Hash = sha256.ComputeHash(keyBytes);
            tokenHash = new byte[20];
            Array.Copy(sha256Hash, tokenHash, 20);
        }
        foreach (byte b in tokenHash)
        {
            Console.Write("{0:X} ", b);
        }
        Console.WriteLine("");
        TokenInfo tokenInfo2 = client.GetTokenInfoByHash(tokenHash);
        Dump(tokenInfo2);
        Console.WriteLine("Getting TokenInfo for tokenHash done.");
        // TODO: add later comparison for tokenInfo1 = tokenInfo2 match
        client.Close();        
    }

    static string[] GetTokenCodes(Guid jobId)
    {
        // Temporary hard code the output directory here, this is the same as the default npdb settings the token service uses
        MixTokenManagementClient client = new MixTokenManagementClient();
        string path = string.Format(@"\\{0}\C$\TokenOutput\{1}.txt", client.Endpoint.Address.Uri.Host, jobId.ToString());
        client.Close();
        Console.WriteLine("Token file path = {0}", path);
        List<string> tokenCodes = new List<string>();
        using (StreamReader sr = new StreamReader(path)) 
        {
            string line;
            while ((line = sr.ReadLine()) != null) 
            {
                tokenCodes.Add(line);
                //Console.WriteLine(line);
            }
        }
        return tokenCodes.ToArray();
    }

    
    static void ReportSuccess(string test)
    {
        ConsoleColor color = Console.ForegroundColor;
        Console.ForegroundColor = ConsoleColor.Green;
        Console.WriteLine("{0} succeeded", test);
        Console.ForegroundColor = color;
    }

    static void ReportFailure(string test, Exception ex)
    {
        ConsoleColor color = Console.ForegroundColor;
        Console.ForegroundColor = ConsoleColor.Red;
        Console.WriteLine("{0} failed", test);
        FaultException fex = ex as FaultException;
        if (fex != null)
        {
            Console.WriteLine("Fault Exception Code : {0}", fex.Code.Name);
            Console.WriteLine("Fault Exception Reason : {0}", fex.Reason);
        }
        else
        {
            Console.WriteLine("Error: {0}", ex.Message);
        }
        Console.ForegroundColor = color;
    }
    
    static void Dump(TokenCategory tc)
    {
        Console.WriteLine("TokenCategoryId = {0}", tc.TokenCategoryId.ToString());
        Console.WriteLine("TokenCategoryName = {0}", tc.TokenCategoryName);
        Console.WriteLine("Expiration Date = {0}", tc.ExpirationDate);
        Console.WriteLine("OfferId = {0}", tc.OfferId);
        Console.WriteLine("PromotionId = {0}", tc.PromotionId);
        Console.WriteLine("ProductType = {0}", tc.ProductTypeId);
        Console.WriteLine("InCsat={0}", tc.InCsat);
        Console.WriteLine("IsPosa={0}", tc.IsPosa);
        Console.WriteLine("IsRsm={0}", tc.IsRsm);
        Console.WriteLine("Pkpn={0}", tc.Pkpn);
    }

    static void Dump(TokenInfo ti)
    {
        Dump(ti.Category);
        Console.WriteLine("Hash = {0}", ti.Hash.ToString());
        Console.WriteLine("StatusId = {0}", ti.StatusId.ToString());
        Console.WriteLine("ConsoleVersion = {0}", ti.ConsoleVersion.ToString());
        Console.WriteLine("UseCount = {0}", ti.UseCount.ToString());
        Console.WriteLine("SequenceNumber = {0}", ti.SequenceNumber);
        Dump(ti.Redemptions);
    }

    static void Dump(TokenRedemption[] redemptions)
    {
        if (redemptions == null || redemptions.Length == 0) return;
        
        foreach (TokenRedemption trd in redemptions)
        {
            Console.WriteLine("UserPuid = {0}", trd.UserPuid.ToString());
            Console.WriteLine("DateRedeemed = {0}", trd.DateRedeemed.ToString());
        }
    }

    static void Dump(TokenJob tj)
    {
        Console.WriteLine("TokenJobId = {0}", tj.TokenJobId.ToString());
        Console.WriteLine("TokenCategoryId = {0}", tj.TokenCategoryId.ToString());
        Console.WriteLine("NumTokensRequested = {0}", tj.NumTokensRequested);
    }

    static void Dump(TokenJobStatus tjs)
    {
        Console.WriteLine("TokenJobId = {0}", tjs.TokenJobId.ToString());
        Console.WriteLine("Status = {0}", tjs.Status);
        Console.WriteLine("LastActivity = {0}", tjs.LastActivity);
        Console.WriteLine("IsStale = {0}", tjs.IsStale);
        Console.WriteLine("NumTokenCompleted = {0}", tjs.NumTokenCompleted);
    }
    
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\TokenManagement\TokenGenerationTool\FormMain.Designer.cs ===
namespace TokenGenerationTool
{
    partial class FormMain
    {
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            System.Windows.Forms.DataGridViewCellStyle dataGridViewCellStyle1 = new System.Windows.Forms.DataGridViewCellStyle();
            System.Windows.Forms.DataGridViewCellStyle dataGridViewCellStyle2 = new System.Windows.Forms.DataGridViewCellStyle();
            System.Windows.Forms.DataGridViewCellStyle dataGridViewCellStyle3 = new System.Windows.Forms.DataGridViewCellStyle();
            this.tabControlMain = new System.Windows.Forms.TabControl();
            this.tabPage1 = new System.Windows.Forms.TabPage();
            this.buttonTcApply = new System.Windows.Forms.Button();
            this.groupBox1 = new System.Windows.Forms.GroupBox();
            this.radioButtonGetTcByOffer = new System.Windows.Forms.RadioButton();
            this.radioButtonGetTcByName = new System.Windows.Forms.RadioButton();
            this.radioButtonUpdateTc = new System.Windows.Forms.RadioButton();
            this.radioButtonCreateTc = new System.Windows.Forms.RadioButton();
            this.radioButtonGetTcById = new System.Windows.Forms.RadioButton();
            this.panel1 = new System.Windows.Forms.Panel();
            this.checkBoxRsm = new System.Windows.Forms.CheckBox();
            this.textBoxPkpn = new System.Windows.Forms.TextBox();
            this.label19 = new System.Windows.Forms.Label();
            this.checkBoxRevenue = new System.Windows.Forms.CheckBox();
            this.checkBoxCsat = new System.Windows.Forms.CheckBox();
            this.comboBoxTcProdType = new System.Windows.Forms.ComboBox();
            this.textBoxTcOfferId = new System.Windows.Forms.TextBox();
            this.dateTimePickerTcExpDate = new System.Windows.Forms.DateTimePicker();
            this.label7 = new System.Windows.Forms.Label();
            this.label6 = new System.Windows.Forms.Label();
            this.label5 = new System.Windows.Forms.Label();
            this.textBoxTcName = new System.Windows.Forms.TextBox();
            this.label4 = new System.Windows.Forms.Label();
            this.textBoxTcId = new System.Windows.Forms.TextBox();
            this.label3 = new System.Windows.Forms.Label();
            this.tabPage2 = new System.Windows.Forms.TabPage();
            this.buttonJobApply = new System.Windows.Forms.Button();
            this.groupBox2 = new System.Windows.Forms.GroupBox();
            this.radioButtonGetJobStatus = new System.Windows.Forms.RadioButton();
            this.radioButtonGenerateTokens = new System.Windows.Forms.RadioButton();
            this.panel2 = new System.Windows.Forms.Panel();
            this.confirmTextBox = new System.Windows.Forms.TextBox();
            this.label22 = new System.Windows.Forms.Label();
            this.passwordTextBox = new System.Windows.Forms.TextBox();
            this.label21 = new System.Windows.Forms.Label();
            this.textBoxTokenRequested = new System.Windows.Forms.TextBox();
            this.label13 = new System.Windows.Forms.Label();
            this.textBoxJobTcId = new System.Windows.Forms.TextBox();
            this.label11 = new System.Windows.Forms.Label();
            this.textBoxJobId = new System.Windows.Forms.TextBox();
            this.label12 = new System.Windows.Forms.Label();
            this.tabPage5 = new System.Windows.Forms.TabPage();
            this.textBoxNextProcessing = new System.Windows.Forms.TextBox();
            this.label27 = new System.Windows.Forms.Label();
            this.textBoxNumFailures = new System.Windows.Forms.TextBox();
            this.label26 = new System.Windows.Forms.Label();
            this.textBoxSubmitted = new System.Windows.Forms.TextBox();
            this.label25 = new System.Windows.Forms.Label();
            this.textBoxTokensGenerated = new System.Windows.Forms.TextBox();
            this.textBoxJobStatus = new System.Windows.Forms.TextBox();
            this.checkBoxStale = new System.Windows.Forms.CheckBox();
            this.textBoxJobLastActivity = new System.Windows.Forms.TextBox();
            this.label8 = new System.Windows.Forms.Label();
            this.label10 = new System.Windows.Forms.Label();
            this.label9 = new System.Windows.Forms.Label();
            this.button1 = new System.Windows.Forms.Button();
            this.textBoxJobStatusJobId = new System.Windows.Forms.TextBox();
            this.label24 = new System.Windows.Forms.Label();
            this.tabPage3 = new System.Windows.Forms.TabPage();
            this.fetchTokensPasswordTextBox = new System.Windows.Forms.TextBox();
            this.label23 = new System.Windows.Forms.Label();
            this.dataGridTokens = new System.Windows.Forms.DataGridView();
            this.buttonGetTokens = new System.Windows.Forms.Button();
            this.textBoxTokensJobId = new System.Windows.Forms.TextBox();
            this.label2 = new System.Windows.Forms.Label();
            this.tabPage4 = new System.Windows.Forms.TabPage();
            this.buttonTokenInfoApply = new System.Windows.Forms.Button();
            this.groupBox3 = new System.Windows.Forms.GroupBox();
            this.radioButtonGetTokenInfoByHash = new System.Windows.Forms.RadioButton();
            this.radioButtonGetTokenInfoByCode = new System.Windows.Forms.RadioButton();
            this.panel3 = new System.Windows.Forms.Panel();
            this.textBoxSeqNum = new System.Windows.Forms.TextBox();
            this.label20 = new System.Windows.Forms.Label();
            this.label17 = new System.Windows.Forms.Label();
            this.textBoxTokenInfoTcId = new System.Windows.Forms.TextBox();
            this.textBoxTokenHash = new System.Windows.Forms.TextBox();
            this.label1 = new System.Windows.Forms.Label();
            this.textBoxTokenCode = new System.Windows.Forms.TextBox();
            this.label18 = new System.Windows.Forms.Label();
            this.listBoxRedemptions = new System.Windows.Forms.ListBox();
            this.textBoxUseCount = new System.Windows.Forms.TextBox();
            this.label16 = new System.Windows.Forms.Label();
            this.textBoxTokenInfoStatus = new System.Windows.Forms.TextBox();
            this.label15 = new System.Windows.Forms.Label();
            this.label14 = new System.Windows.Forms.Label();
            this.textBoxTokensRequested = new System.Windows.Forms.TextBox();
            this.label28 = new System.Windows.Forms.Label();
            this.checkBoxRoyalty = new System.Windows.Forms.CheckBox();
            this.checkBoxRedeemable = new System.Windows.Forms.CheckBox();
            this.tabControlMain.SuspendLayout();
            this.tabPage1.SuspendLayout();
            this.groupBox1.SuspendLayout();
            this.panel1.SuspendLayout();
            this.tabPage2.SuspendLayout();
            this.groupBox2.SuspendLayout();
            this.panel2.SuspendLayout();
            this.tabPage5.SuspendLayout();
            this.tabPage3.SuspendLayout();
            ((System.ComponentModel.ISupportInitialize)(this.dataGridTokens)).BeginInit();
            this.tabPage4.SuspendLayout();
            this.groupBox3.SuspendLayout();
            this.panel3.SuspendLayout();
            this.SuspendLayout();
            // 
            // tabControlMain
            // 
            this.tabControlMain.Controls.Add(this.tabPage1);
            this.tabControlMain.Controls.Add(this.tabPage2);
            this.tabControlMain.Controls.Add(this.tabPage5);
            this.tabControlMain.Controls.Add(this.tabPage3);
            this.tabControlMain.Controls.Add(this.tabPage4);
            this.tabControlMain.Location = new System.Drawing.Point(2, 4);
            this.tabControlMain.Name = "tabControlMain";
            this.tabControlMain.SelectedIndex = 0;
            this.tabControlMain.Size = new System.Drawing.Size(565, 324);
            this.tabControlMain.TabIndex = 0;
            // 
            // tabPage1
            // 
            this.tabPage1.Controls.Add(this.buttonTcApply);
            this.tabPage1.Controls.Add(this.groupBox1);
            this.tabPage1.Controls.Add(this.panel1);
            this.tabPage1.Location = new System.Drawing.Point(4, 22);
            this.tabPage1.Name = "tabPage1";
            this.tabPage1.Padding = new System.Windows.Forms.Padding(3);
            this.tabPage1.Size = new System.Drawing.Size(557, 298);
            this.tabPage1.TabIndex = 0;
            this.tabPage1.Text = "Token Category";
            this.tabPage1.UseVisualStyleBackColor = true;
            // 
            // buttonTcApply
            // 
            this.buttonTcApply.Location = new System.Drawing.Point(462, 160);
            this.buttonTcApply.Name = "buttonTcApply";
            this.buttonTcApply.Size = new System.Drawing.Size(75, 23);
            this.buttonTcApply.TabIndex = 12;
            this.buttonTcApply.Text = "Apply";
            this.buttonTcApply.UseVisualStyleBackColor = true;
            this.buttonTcApply.Click += new System.EventHandler(this.buttonTcApply_Click);
            // 
            // groupBox1
            // 
            this.groupBox1.Controls.Add(this.radioButtonGetTcByOffer);
            this.groupBox1.Controls.Add(this.radioButtonGetTcByName);
            this.groupBox1.Controls.Add(this.radioButtonUpdateTc);
            this.groupBox1.Controls.Add(this.radioButtonCreateTc);
            this.groupBox1.Controls.Add(this.radioButtonGetTcById);
            this.groupBox1.Location = new System.Drawing.Point(352, 9);
            this.groupBox1.Name = "groupBox1";
            this.groupBox1.Size = new System.Drawing.Size(185, 135);
            this.groupBox1.TabIndex = 11;
            this.groupBox1.TabStop = false;
            this.groupBox1.Text = "Choose your action";
            // 
            // radioButtonGetTcByOffer
            // 
            this.radioButtonGetTcByOffer.AutoSize = true;
            this.radioButtonGetTcByOffer.Location = new System.Drawing.Point(6, 103);
            this.radioButtonGetTcByOffer.Name = "radioButtonGetTcByOffer";
            this.radioButtonGetTcByOffer.Size = new System.Drawing.Size(174, 17);
            this.radioButtonGetTcByOffer.TabIndex = 4;
            this.radioButtonGetTcByOffer.TabStop = true;
            this.radioButtonGetTcByOffer.Text = "Get Token Category By Offer Id";
            this.radioButtonGetTcByOffer.UseVisualStyleBackColor = true;
            this.radioButtonGetTcByOffer.CheckedChanged += new System.EventHandler(this.radioButtonGetTcByOffer_CheckedChanged);
            // 
            // radioButtonGetTcByName
            // 
            this.radioButtonGetTcByName.AutoSize = true;
            this.radioButtonGetTcByName.Location = new System.Drawing.Point(6, 82);
            this.radioButtonGetTcByName.Name = "radioButtonGetTcByName";
            this.radioButtonGetTcByName.Size = new System.Drawing.Size(167, 17);
            this.radioButtonGetTcByName.TabIndex = 3;
            this.radioButtonGetTcByName.TabStop = true;
            this.radioButtonGetTcByName.Text = "Get Token Category By Name";
            this.radioButtonGetTcByName.UseVisualStyleBackColor = true;
            this.radioButtonGetTcByName.CheckedChanged += new System.EventHandler(this.radioButtonGetTcByName_CheckedChanged);
            // 
            // radioButtonUpdateTc
            // 
            this.radioButtonUpdateTc.AutoSize = true;
            this.radioButtonUpdateTc.Location = new System.Drawing.Point(6, 40);
            this.radioButtonUpdateTc.Name = "radioButtonUpdateTc";
            this.radioButtonUpdateTc.Size = new System.Drawing.Size(139, 17);
            this.radioButtonUpdateTc.TabIndex = 2;
            this.radioButtonUpdateTc.TabStop = true;
            this.radioButtonUpdateTc.Text = "Update Token Category";
            this.radioButtonUpdateTc.UseVisualStyleBackColor = true;
            this.radioButtonUpdateTc.CheckedChanged += new System.EventHandler(this.radioButtonUpdateTc_CheckedChanged);
            // 
            // radioButtonCreateTc
            // 
            this.radioButtonCreateTc.AutoSize = true;
            this.radioButtonCreateTc.Location = new System.Drawing.Point(6, 19);
            this.radioButtonCreateTc.Name = "radioButtonCreateTc";
            this.radioButtonCreateTc.Size = new System.Drawing.Size(135, 17);
            this.radioButtonCreateTc.TabIndex = 1;
            this.radioButtonCreateTc.TabStop = true;
            this.radioButtonCreateTc.Text = "Create Token Category";
            this.radioButtonCreateTc.UseVisualStyleBackColor = true;
            this.radioButtonCreateTc.CheckedChanged += new System.EventHandler(this.radioButtonCreateTc_CheckedChanged);
            // 
            // radioButtonGetTcById
            // 
            this.radioButtonGetTcById.AutoSize = true;
            this.radioButtonGetTcById.Location = new System.Drawing.Point(6, 61);
            this.radioButtonGetTcById.Name = "radioButtonGetTcById";
            this.radioButtonGetTcById.Size = new System.Drawing.Size(148, 17);
            this.radioButtonGetTcById.TabIndex = 0;
            this.radioButtonGetTcById.TabStop = true;
            this.radioButtonGetTcById.Text = "Get Token Category By Id";
            this.radioButtonGetTcById.UseVisualStyleBackColor = true;
            this.radioButtonGetTcById.CheckedChanged += new System.EventHandler(this.radioButtonGetTcById_CheckedChanged);
            // 
            // panel1
            // 
            this.panel1.BackColor = System.Drawing.Color.Transparent;
            this.panel1.BorderStyle = System.Windows.Forms.BorderStyle.Fixed3D;
            this.panel1.Controls.Add(this.checkBoxRedeemable);
            this.panel1.Controls.Add(this.checkBoxRoyalty);
            this.panel1.Controls.Add(this.checkBoxRsm);
            this.panel1.Controls.Add(this.textBoxPkpn);
            this.panel1.Controls.Add(this.label19);
            this.panel1.Controls.Add(this.checkBoxRevenue);
            this.panel1.Controls.Add(this.checkBoxCsat);
            this.panel1.Controls.Add(this.comboBoxTcProdType);
            this.panel1.Controls.Add(this.textBoxTcOfferId);
            this.panel1.Controls.Add(this.dateTimePickerTcExpDate);
            this.panel1.Controls.Add(this.label7);
            this.panel1.Controls.Add(this.label6);
            this.panel1.Controls.Add(this.label5);
            this.panel1.Controls.Add(this.textBoxTcName);
            this.panel1.Controls.Add(this.label4);
            this.panel1.Controls.Add(this.textBoxTcId);
            this.panel1.Controls.Add(this.label3);
            this.panel1.Location = new System.Drawing.Point(16, 16);
            this.panel1.Name = "panel1";
            this.panel1.Size = new System.Drawing.Size(315, 257);
            this.panel1.TabIndex = 0;
            // 
            // checkBoxRsm
            // 
            this.checkBoxRsm.AutoSize = true;
            this.checkBoxRsm.Location = new System.Drawing.Point(10, 189);
            this.checkBoxRsm.Name = "checkBoxRsm";
            this.checkBoxRsm.Size = new System.Drawing.Size(50, 17);
            this.checkBoxRsm.TabIndex = 16;
            this.checkBoxRsm.Text = "RSM";
            this.checkBoxRsm.UseVisualStyleBackColor = true;
            // 
            // textBoxPkpn
            // 
            this.textBoxPkpn.Location = new System.Drawing.Point(56, 138);
            this.textBoxPkpn.Name = "textBoxPkpn";
            this.textBoxPkpn.Size = new System.Drawing.Size(242, 20);
            this.textBoxPkpn.TabIndex = 15;
            // 
            // label19
            // 
            this.label19.AutoSize = true;
            this.label19.Location = new System.Drawing.Point(8, 142);
            this.label19.Name = "label19";
            this.label19.Size = new System.Drawing.Size(42, 13);
            this.label19.TabIndex = 14;
            this.label19.Text = "PKPN :";
            // 
            // checkBoxRevenue
            // 
            this.checkBoxRevenue.AutoSize = true;
            this.checkBoxRevenue.Location = new System.Drawing.Point(128, 166);
            this.checkBoxRevenue.Name = "checkBoxRevenue";
            this.checkBoxRevenue.Size = new System.Drawing.Size(109, 17);
            this.checkBoxRevenue.TabIndex = 13;
            this.checkBoxRevenue.Text = "Revenue-Bearing";
            this.checkBoxRevenue.UseVisualStyleBackColor = true;
            // 
            // checkBoxCsat
            // 
            this.checkBoxCsat.AutoSize = true;
            this.checkBoxCsat.Location = new System.Drawing.Point(11, 166);
            this.checkBoxCsat.Name = "checkBoxCsat";
            this.checkBoxCsat.Size = new System.Drawing.Size(54, 17);
            this.checkBoxCsat.TabIndex = 12;
            this.checkBoxCsat.Text = "CSAT";
            this.checkBoxCsat.UseVisualStyleBackColor = true;
            // 
            // comboBoxTcProdType
            // 
            this.comboBoxTcProdType.FormattingEnabled = true;
            this.comboBoxTcProdType.Location = new System.Drawing.Point(88, 110);
            this.comboBoxTcProdType.Name = "comboBoxTcProdType";
            this.comboBoxTcProdType.Size = new System.Drawing.Size(121, 21);
            this.comboBoxTcProdType.TabIndex = 11;
            // 
            // textBoxTcOfferId
            // 
            this.textBoxTcOfferId.Location = new System.Drawing.Point(57, 84);
            this.textBoxTcOfferId.Name = "textBoxTcOfferId";
            this.textBoxTcOfferId.Size = new System.Drawing.Size(241, 20);
            this.textBoxTcOfferId.TabIndex = 10;
            // 
            // dateTimePickerTcExpDate
            // 
            this.dateTimePickerTcExpDate.Format = System.Windows.Forms.DateTimePickerFormat.Short;
            this.dateTimePickerTcExpDate.Location = new System.Drawing.Point(98, 58);
            this.dateTimePickerTcExpDate.Name = "dateTimePickerTcExpDate";
            this.dateTimePickerTcExpDate.Size = new System.Drawing.Size(200, 20);
            this.dateTimePickerTcExpDate.TabIndex = 9;
            // 
            // label7
            // 
            this.label7.AutoSize = true;
            this.label7.Location = new System.Drawing.Point(8, 113);
            this.label7.Name = "label7";
            this.label7.Size = new System.Drawing.Size(74, 13);
            this.label7.TabIndex = 6;
            this.label7.Text = "Product Type:";
            // 
            // label6
            // 
            this.label6.AutoSize = true;
            this.label6.Location = new System.Drawing.Point(8, 87);
            this.label6.Name = "label6";
            this.label6.Size = new System.Drawing.Size(45, 13);
            this.label6.TabIndex = 5;
            this.label6.Text = "Offer Id:";
            // 
            // label5
            // 
            this.label5.AutoSize = true;
            this.label5.Location = new System.Drawing.Point(7, 61);
            this.label5.Name = "label5";
            this.label5.Size = new System.Drawing.Size(82, 13);
            this.label5.TabIndex = 4;
            this.label5.Text = "Expiration Date:";
            // 
            // textBoxTcName
            // 
            this.textBoxTcName.Location = new System.Drawing.Point(57, 31);
            this.textBoxTcName.Name = "textBoxTcName";
            this.textBoxTcName.Size = new System.Drawing.Size(242, 20);
            this.textBoxTcName.TabIndex = 3;
            // 
            // label4
            // 
            this.label4.AutoSize = true;
            this.label4.Location = new System.Drawing.Point(7, 35);
            this.label4.Name = "label4";
            this.label4.Size = new System.Drawing.Size(38, 13);
            this.label4.TabIndex = 2;
            this.label4.Text = "Name:";
            // 
            // textBoxTcId
            // 
            this.textBoxTcId.Location = new System.Drawing.Point(57, 5);
            this.textBoxTcId.Name = "textBoxTcId";
            this.textBoxTcId.Size = new System.Drawing.Size(242, 20);
            this.textBoxTcId.TabIndex = 1;
            // 
            // label3
            // 
            this.label3.AutoSize = true;
            this.label3.Location = new System.Drawing.Point(8, 8);
            this.label3.Name = "label3";
            this.label3.Size = new System.Drawing.Size(19, 13);
            this.label3.TabIndex = 0;
            this.label3.Text = "Id:";
            // 
            // tabPage2
            // 
            this.tabPage2.Controls.Add(this.buttonJobApply);
            this.tabPage2.Controls.Add(this.groupBox2);
            this.tabPage2.Controls.Add(this.panel2);
            this.tabPage2.Location = new System.Drawing.Point(4, 22);
            this.tabPage2.Name = "tabPage2";
            this.tabPage2.Padding = new System.Windows.Forms.Padding(3);
            this.tabPage2.Size = new System.Drawing.Size(557, 298);
            this.tabPage2.TabIndex = 1;
            this.tabPage2.Text = "Token Job";
            this.tabPage2.UseVisualStyleBackColor = true;
            // 
            // buttonJobApply
            // 
            this.buttonJobApply.Location = new System.Drawing.Point(457, 100);
            this.buttonJobApply.Name = "buttonJobApply";
            this.buttonJobApply.Size = new System.Drawing.Size(75, 23);
            this.buttonJobApply.TabIndex = 14;
            this.buttonJobApply.Text = "Apply";
            this.buttonJobApply.UseVisualStyleBackColor = true;
            this.buttonJobApply.Click += new System.EventHandler(this.buttonJobApply_Click);
            // 
            // groupBox2
            // 
            this.groupBox2.Controls.Add(this.radioButtonGetJobStatus);
            this.groupBox2.Controls.Add(this.radioButtonGenerateTokens);
            this.groupBox2.Location = new System.Drawing.Point(347, 10);
            this.groupBox2.Name = "groupBox2";
            this.groupBox2.Size = new System.Drawing.Size(185, 70);
            this.groupBox2.TabIndex = 13;
            this.groupBox2.TabStop = false;
            this.groupBox2.Text = "Choose your action";
            // 
            // radioButtonGetJobStatus
            // 
            this.radioButtonGetJobStatus.AutoSize = true;
            this.radioButtonGetJobStatus.Location = new System.Drawing.Point(6, 40);
            this.radioButtonGetJobStatus.Name = "radioButtonGetJobStatus";
            this.radioButtonGetJobStatus.Size = new System.Drawing.Size(95, 17);
            this.radioButtonGetJobStatus.TabIndex = 2;
            this.radioButtonGetJobStatus.TabStop = true;
            this.radioButtonGetJobStatus.Text = "Get Job Status";
            this.radioButtonGetJobStatus.UseVisualStyleBackColor = true;
            this.radioButtonGetJobStatus.CheckedChanged += new System.EventHandler(this.radioButtonGetJobStatus_CheckedChanged);
            // 
            // radioButtonGenerateTokens
            // 
            this.radioButtonGenerateTokens.AutoSize = true;
            this.radioButtonGenerateTokens.Location = new System.Drawing.Point(6, 19);
            this.radioButtonGenerateTokens.Name = "radioButtonGenerateTokens";
            this.radioButtonGenerateTokens.Size = new System.Drawing.Size(168, 17);
            this.radioButtonGenerateTokens.TabIndex = 1;
            this.radioButtonGenerateTokens.TabStop = true;
            this.radioButtonGenerateTokens.Text = "Generate Tokens (Create Job)";
            this.radioButtonGenerateTokens.UseVisualStyleBackColor = true;
            this.radioButtonGenerateTokens.CheckedChanged += new System.EventHandler(this.radioButtonGenerateTokens_CheckedChanged);
            // 
            // panel2
            // 
            this.panel2.BorderStyle = System.Windows.Forms.BorderStyle.Fixed3D;
            this.panel2.Controls.Add(this.confirmTextBox);
            this.panel2.Controls.Add(this.label22);
            this.panel2.Controls.Add(this.passwordTextBox);
            this.panel2.Controls.Add(this.label21);
            this.panel2.Controls.Add(this.textBoxTokenRequested);
            this.panel2.Controls.Add(this.label13);
            this.panel2.Controls.Add(this.textBoxJobTcId);
            this.panel2.Controls.Add(this.label11);
            this.panel2.Controls.Add(this.textBoxJobId);
            this.panel2.Controls.Add(this.label12);
            this.panel2.Location = new System.Drawing.Point(16, 16);
            this.panel2.Name = "panel2";
            this.panel2.Size = new System.Drawing.Size(315, 258);
            this.panel2.TabIndex = 2;
            // 
            // confirmTextBox
            // 
            this.confirmTextBox.Location = new System.Drawing.Point(73, 117);
            this.confirmTextBox.MaxLength = 15;
            this.confirmTextBox.Name = "confirmTextBox";
            this.confirmTextBox.PasswordChar = 'â';
            this.confirmTextBox.Size = new System.Drawing.Size(228, 20);
            this.confirmTextBox.TabIndex = 21;
            // 
            // label22
            // 
            this.label22.AutoSize = true;
            this.label22.Location = new System.Drawing.Point(10, 121);
            this.label22.Name = "label22";
            this.label22.Size = new System.Drawing.Size(45, 13);
            this.label22.TabIndex = 20;
            this.label22.Text = "Confirm:";
            // 
            // passwordTextBox
            // 
            this.passwordTextBox.Location = new System.Drawing.Point(73, 88);
            this.passwordTextBox.MaxLength = 15;
            this.passwordTextBox.Name = "passwordTextBox";
            this.passwordTextBox.PasswordChar = 'â';
            this.passwordTextBox.Size = new System.Drawing.Size(228, 20);
            this.passwordTextBox.TabIndex = 19;
            // 
            // label21
            // 
            this.label21.AutoSize = true;
            this.label21.Location = new System.Drawing.Point(8, 92);
            this.label21.Name = "label21";
            this.label21.Size = new System.Drawing.Size(56, 13);
            this.label21.TabIndex = 18;
            this.label21.Text = "Password:";
            // 
            // textBoxTokenRequested
            // 
            this.textBoxTokenRequested.Location = new System.Drawing.Point(107, 60);
            this.textBoxTokenRequested.Name = "textBoxTokenRequested";
            this.textBoxTokenRequested.Size = new System.Drawing.Size(191, 20);
            this.textBoxTokenRequested.TabIndex = 17;
            // 
            // label13
            // 
            this.label13.AutoSize = true;
            this.label13.Location = new System.Drawing.Point(8, 63);
            this.label13.Name = "label13";
            this.label13.Size = new System.Drawing.Size(101, 13);
            this.label13.TabIndex = 16;
            this.label13.Text = "Tokens Requested:";
            // 
            // textBoxJobTcId
            // 
            this.textBoxJobTcId.Location = new System.Drawing.Point(71, 31);
            this.textBoxJobTcId.Name = "textBoxJobTcId";
            this.textBoxJobTcId.Size = new System.Drawing.Size(228, 20);
            this.textBoxJobTcId.TabIndex = 3;
            // 
            // label11
            // 
            this.label11.AutoSize = true;
            this.label11.Location = new System.Drawing.Point(8, 35);
            this.label11.Name = "label11";
            this.label11.Size = new System.Drawing.Size(64, 13);
            this.label11.TabIndex = 2;
            this.label11.Text = "Category Id:";
            // 
            // textBoxJobId
            // 
            this.textBoxJobId.Location = new System.Drawing.Point(71, 5);
            this.textBoxJobId.Name = "textBoxJobId";
            this.textBoxJobId.Size = new System.Drawing.Size(228, 20);
            this.textBoxJobId.TabIndex = 1;
            // 
            // label12
            // 
            this.label12.AutoSize = true;
            this.label12.Location = new System.Drawing.Point(8, 8);
            this.label12.Name = "label12";
            this.label12.Size = new System.Drawing.Size(39, 13);
            this.label12.TabIndex = 0;
            this.label12.Text = "Job Id:";
            // 
            // tabPage5
            // 
            this.tabPage5.Controls.Add(this.label28);
            this.tabPage5.Controls.Add(this.textBoxTokensRequested);
            this.tabPage5.Controls.Add(this.textBoxNextProcessing);
            this.tabPage5.Controls.Add(this.label27);
            this.tabPage5.Controls.Add(this.textBoxNumFailures);
            this.tabPage5.Controls.Add(this.label26);
            this.tabPage5.Controls.Add(this.textBoxSubmitted);
            this.tabPage5.Controls.Add(this.label25);
            this.tabPage5.Controls.Add(this.textBoxTokensGenerated);
            this.tabPage5.Controls.Add(this.textBoxJobStatus);
            this.tabPage5.Controls.Add(this.checkBoxStale);
            this.tabPage5.Controls.Add(this.textBoxJobLastActivity);
            this.tabPage5.Controls.Add(this.label8);
            this.tabPage5.Controls.Add(this.label10);
            this.tabPage5.Controls.Add(this.label9);
            this.tabPage5.Controls.Add(this.button1);
            this.tabPage5.Controls.Add(this.textBoxJobStatusJobId);
            this.tabPage5.Controls.Add(this.label24);
            this.tabPage5.Location = new System.Drawing.Point(4, 22);
            this.tabPage5.Name = "tabPage5";
            this.tabPage5.Padding = new System.Windows.Forms.Padding(3);
            this.tabPage5.Size = new System.Drawing.Size(557, 298);
            this.tabPage5.TabIndex = 4;
            this.tabPage5.Text = "Job Status";
            this.tabPage5.UseVisualStyleBackColor = true;
            // 
            // textBoxNextProcessing
            // 
            this.textBoxNextProcessing.Enabled = false;
            this.textBoxNextProcessing.Location = new System.Drawing.Point(119, 263);
            this.textBoxNextProcessing.Name = "textBoxNextProcessing";
            this.textBoxNextProcessing.Size = new System.Drawing.Size(191, 20);
            this.textBoxNextProcessing.TabIndex = 28;
            // 
            // label27
            // 
            this.label27.AutoSize = true;
            this.label27.Location = new System.Drawing.Point(20, 265);
            this.label27.Name = "label27";
            this.label27.Size = new System.Drawing.Size(87, 13);
            this.label27.TabIndex = 27;
            this.label27.Text = "Next Processing:";
            // 
            // textBoxNumFailures
            // 
            this.textBoxNumFailures.Enabled = false;
            this.textBoxNumFailures.Location = new System.Drawing.Point(118, 230);
            this.textBoxNumFailures.Name = "textBoxNumFailures";
            this.textBoxNumFailures.Size = new System.Drawing.Size(191, 20);
            this.textBoxNumFailures.TabIndex = 26;
            // 
            // label26
            // 
            this.label26.AutoSize = true;
            this.label26.Location = new System.Drawing.Point(19, 233);
            this.label26.Name = "label26";
            this.label26.Size = new System.Drawing.Size(71, 13);
            this.label26.TabIndex = 25;
            this.label26.Text = "Num Failures:";
            // 
            // textBoxSubmitted
            // 
            this.textBoxSubmitted.Enabled = false;
            this.textBoxSubmitted.Location = new System.Drawing.Point(118, 200);
            this.textBoxSubmitted.Name = "textBoxSubmitted";
            this.textBoxSubmitted.Size = new System.Drawing.Size(191, 20);
            this.textBoxSubmitted.TabIndex = 24;
            // 
            // label25
            // 
            this.label25.AutoSize = true;
            this.label25.Location = new System.Drawing.Point(19, 202);
            this.label25.Name = "label25";
            this.label25.Size = new System.Drawing.Size(57, 13);
            this.label25.TabIndex = 23;
            this.label25.Text = "Submitted:";
            // 
            // textBoxTokensGenerated
            // 
            this.textBoxTokensGenerated.Enabled = false;
            this.textBoxTokensGenerated.Location = new System.Drawing.Point(118, 139);
            this.textBoxTokensGenerated.Name = "textBoxTokensGenerated";
            this.textBoxTokensGenerated.Size = new System.Drawing.Size(191, 20);
            this.textBoxTokensGenerated.TabIndex = 22;
            // 
            // textBoxJobStatus
            // 
            this.textBoxJobStatus.Enabled = false;
            this.textBoxJobStatus.Location = new System.Drawing.Point(118, 84);
            this.textBoxJobStatus.Name = "textBoxJobStatus";
            this.textBoxJobStatus.Size = new System.Drawing.Size(192, 20);
            this.textBoxJobStatus.TabIndex = 21;
            // 
            // checkBoxStale
            // 
            this.checkBoxStale.AutoSize = true;
            this.checkBoxStale.Location = new System.Drawing.Point(23, 168);
            this.checkBoxStale.Name = "checkBoxStale";
            this.checkBoxStale.Size = new System.Drawing.Size(50, 17);
            this.checkBoxStale.TabIndex = 20;
            this.checkBoxStale.Text = "Stale";
            this.checkBoxStale.UseVisualStyleBackColor = true;
            // 
            // textBoxJobLastActivity
            // 
            this.textBoxJobLastActivity.Enabled = false;
            this.textBoxJobLastActivity.Location = new System.Drawing.Point(118, 111);
            this.textBoxJobLastActivity.Name = "textBoxJobLastActivity";
            this.textBoxJobLastActivity.Size = new System.Drawing.Size(191, 20);
            this.textBoxJobLastActivity.TabIndex = 19;
            // 
            // label8
            // 
            this.label8.AutoSize = true;
            this.label8.Location = new System.Drawing.Point(19, 142);
            this.label8.Name = "label8";
            this.label8.Size = new System.Drawing.Size(99, 13);
            this.label8.TabIndex = 18;
            this.label8.Text = "Tokens Generated:";
            // 
            // label10
            // 
            this.label10.AutoSize = true;
            this.label10.Location = new System.Drawing.Point(19, 113);
            this.label10.Name = "label10";
            this.label10.Size = new System.Drawing.Size(93, 13);
            this.label10.TabIndex = 17;
            this.label10.Text = "Last Activity Time:";
            // 
            // label9
            // 
            this.label9.AutoSize = true;
            this.label9.Location = new System.Drawing.Point(19, 87);
            this.label9.Name = "label9";
            this.label9.Size = new System.Drawing.Size(40, 13);
            this.label9.TabIndex = 16;
            this.label9.Text = "Status:";
            // 
            // button1
            // 
            this.button1.Location = new System.Drawing.Point(341, 27);
            this.button1.Name = "button1";
            this.button1.Size = new System.Drawing.Size(75, 23);
            this.button1.TabIndex = 15;
            this.button1.Text = "Get Status";
            this.button1.UseVisualStyleBackColor = true;
            this.button1.Click += new System.EventHandler(this.buttonGetStatus_Click);
            // 
            // textBoxJobStatusJobId
            // 
            this.textBoxJobStatusJobId.Location = new System.Drawing.Point(82, 27);
            this.textBoxJobStatusJobId.Name = "textBoxJobStatusJobId";
            this.textBoxJobStatusJobId.Size = new System.Drawing.Size(228, 20);
            this.textBoxJobStatusJobId.TabIndex = 3;
            // 
            // label24
            // 
            this.label24.AutoSize = true;
            this.label24.Location = new System.Drawing.Point(19, 30);
            this.label24.Name = "label24";
            this.label24.Size = new System.Drawing.Size(39, 13);
            this.label24.TabIndex = 2;
            this.label24.Text = "Job Id:";
            // 
            // tabPage3
            // 
            this.tabPage3.Controls.Add(this.fetchTokensPasswordTextBox);
            this.tabPage3.Controls.Add(this.label23);
            this.tabPage3.Controls.Add(this.dataGridTokens);
            this.tabPage3.Controls.Add(this.buttonGetTokens);
            this.tabPage3.Controls.Add(this.textBoxTokensJobId);
            this.tabPage3.Controls.Add(this.label2);
            this.tabPage3.Location = new System.Drawing.Point(4, 22);
            this.tabPage3.Name = "tabPage3";
            this.tabPage3.Size = new System.Drawing.Size(557, 298);
            this.tabPage3.TabIndex = 2;
            this.tabPage3.Text = "Tokens";
            this.tabPage3.UseVisualStyleBackColor = true;
            // 
            // fetchTokensPasswordTextBox
            // 
            this.fetchTokensPasswordTextBox.Location = new System.Drawing.Point(91, 37);
            this.fetchTokensPasswordTextBox.MaxLength = 15;
            this.fetchTokensPasswordTextBox.Name = "fetchTokensPasswordTextBox";
            this.fetchTokensPasswordTextBox.PasswordChar = 'â';
            this.fetchTokensPasswordTextBox.Size = new System.Drawing.Size(264, 20);
            this.fetchTokensPasswordTextBox.TabIndex = 21;
            // 
            // label23
            // 
            this.label23.AutoSize = true;
            this.label23.Location = new System.Drawing.Point(26, 41);
            this.label23.Name = "label23";
            this.label23.Size = new System.Drawing.Size(56, 13);
            this.label23.TabIndex = 20;
            this.label23.Text = "Password:";
            // 
            // dataGridTokens
            // 
            dataGridViewCellStyle1.BackColor = System.Drawing.Color.White;
            dataGridViewCellStyle1.ForeColor = System.Drawing.Color.Black;
            this.dataGridTokens.AlternatingRowsDefaultCellStyle = dataGridViewCellStyle1;
            this.dataGridTokens.AutoSizeColumnsMode = System.Windows.Forms.DataGridViewAutoSizeColumnsMode.DisplayedCells;
            dataGridViewCellStyle2.Alignment = System.Windows.Forms.DataGridViewContentAlignment.MiddleLeft;
            dataGridViewCellStyle2.BackColor = System.Drawing.SystemColors.Control;
            dataGridViewCellStyle2.Font = new System.Drawing.Font("Microsoft Sans Serif", 9F, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            dataGridViewCellStyle2.ForeColor = System.Drawing.SystemColors.WindowText;
            dataGridViewCellStyle2.SelectionBackColor = System.Drawing.SystemColors.Highlight;
            dataGridViewCellStyle2.SelectionForeColor = System.Drawing.SystemColors.HighlightText;
            dataGridViewCellStyle2.WrapMode = System.Windows.Forms.DataGridViewTriState.True;
            this.dataGridTokens.ColumnHeadersDefaultCellStyle = dataGridViewCellStyle2;
            this.dataGridTokens.ColumnHeadersHeightSizeMode = System.Windows.Forms.DataGridViewColumnHeadersHeightSizeMode.AutoSize;
            dataGridViewCellStyle3.Alignment = System.Windows.Forms.DataGridViewContentAlignment.MiddleLeft;
            dataGridViewCellStyle3.BackColor = System.Drawing.SystemColors.Window;
            dataGridViewCellStyle3.Font = new System.Drawing.Font("Lucida Console", 9F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            dataGridViewCellStyle3.ForeColor = System.Drawing.SystemColors.ControlText;
            dataGridViewCellStyle3.SelectionBackColor = System.Drawing.SystemColors.Highlight;
            dataGridViewCellStyle3.SelectionForeColor = System.Drawing.SystemColors.HighlightText;
            dataGridViewCellStyle3.WrapMode = System.Windows.Forms.DataGridViewTriState.False;
            this.dataGridTokens.DefaultCellStyle = dataGridViewCellStyle3;
            this.dataGridTokens.Location = new System.Drawing.Point(15, 83);
            this.dataGridTokens.Name = "dataGridTokens";
            this.dataGridTokens.ReadOnly = true;
            this.dataGridTokens.Size = new System.Drawing.Size(534, 210);
            this.dataGridTokens.TabIndex = 6;
            this.dataGridTokens.Visible = false;
            // 
            // buttonGetTokens
            // 
            this.buttonGetTokens.Location = new System.Drawing.Point(415, 34);
            this.buttonGetTokens.Name = "buttonGetTokens";
            this.buttonGetTokens.Size = new System.Drawing.Size(75, 23);
            this.buttonGetTokens.TabIndex = 4;
            this.buttonGetTokens.Text = "Get Tokens";
            this.buttonGetTokens.UseVisualStyleBackColor = true;
            this.buttonGetTokens.Click += new System.EventHandler(this.buttonGetTokens_Click);
            // 
            // textBoxTokensJobId
            // 
            this.textBoxTokensJobId.Font = new System.Drawing.Font("Lucida Console", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.textBoxTokensJobId.Location = new System.Drawing.Point(91, 13);
            this.textBoxTokensJobId.Name = "textBoxTokensJobId";
            this.textBoxTokensJobId.Size = new System.Drawing.Size(264, 18);
            this.textBoxTokensJobId.TabIndex = 3;
            // 
            // label2
            // 
            this.label2.AutoSize = true;
            this.label2.Location = new System.Drawing.Point(12, 15);
            this.label2.Name = "label2";
            this.label2.Size = new System.Drawing.Size(73, 13);
            this.label2.TabIndex = 2;
            this.label2.Text = "Token Job Id:";
            // 
            // tabPage4
            // 
            this.tabPage4.Controls.Add(this.buttonTokenInfoApply);
            this.tabPage4.Controls.Add(this.groupBox3);
            this.tabPage4.Controls.Add(this.panel3);
            this.tabPage4.Location = new System.Drawing.Point(4, 22);
            this.tabPage4.Name = "tabPage4";
            this.tabPage4.Size = new System.Drawing.Size(557, 298);
            this.tabPage4.TabIndex = 3;
            this.tabPage4.Text = "Token Information";
            this.tabPage4.UseVisualStyleBackColor = true;
            // 
            // buttonTokenInfoApply
            // 
            this.buttonTokenInfoApply.Location = new System.Drawing.Point(474, 100);
            this.buttonTokenInfoApply.Name = "buttonTokenInfoApply";
            this.buttonTokenInfoApply.Size = new System.Drawing.Size(75, 23);
            this.buttonTokenInfoApply.TabIndex = 15;
            this.buttonTokenInfoApply.Text = "Apply";
            this.buttonTokenInfoApply.UseVisualStyleBackColor = true;
            this.buttonTokenInfoApply.Click += new System.EventHandler(this.buttonTokenInfoApply_Click);
            // 
            // groupBox3
            // 
            this.groupBox3.Controls.Add(this.radioButtonGetTokenInfoByHash);
            this.groupBox3.Controls.Add(this.radioButtonGetTokenInfoByCode);
            this.groupBox3.Location = new System.Drawing.Point(364, 10);
            this.groupBox3.Name = "groupBox3";
            this.groupBox3.Size = new System.Drawing.Size(185, 77);
            this.groupBox3.TabIndex = 14;
            this.groupBox3.TabStop = false;
            this.groupBox3.Text = "Choose your action";
            // 
            // radioButtonGetTokenInfoByHash
            // 
            this.radioButtonGetTokenInfoByHash.AutoSize = true;
            this.radioButtonGetTokenInfoByHash.Location = new System.Drawing.Point(6, 40);
            this.radioButtonGetTokenInfoByHash.Name = "radioButtonGetTokenInfoByHash";
            this.radioButtonGetTokenInfoByHash.Size = new System.Drawing.Size(140, 17);
            this.radioButtonGetTokenInfoByHash.TabIndex = 2;
            this.radioButtonGetTokenInfoByHash.TabStop = true;
            this.radioButtonGetTokenInfoByHash.Text = "Get Token Info By Hash";
            this.radioButtonGetTokenInfoByHash.UseVisualStyleBackColor = true;
            this.radioButtonGetTokenInfoByHash.CheckedChanged += new System.EventHandler(this.radioButtonGetTokenInfoByHash_CheckedChanged);
            // 
            // radioButtonGetTokenInfoByCode
            // 
            this.radioButtonGetTokenInfoByCode.AutoSize = true;
            this.radioButtonGetTokenInfoByCode.Location = new System.Drawing.Point(6, 19);
            this.radioButtonGetTokenInfoByCode.Name = "radioButtonGetTokenInfoByCode";
            this.radioButtonGetTokenInfoByCode.Size = new System.Drawing.Size(140, 17);
            this.radioButtonGetTokenInfoByCode.TabIndex = 1;
            this.radioButtonGetTokenInfoByCode.TabStop = true;
            this.radioButtonGetTokenInfoByCode.Text = "Get Token Info By Code";
            this.radioButtonGetTokenInfoByCode.UseVisualStyleBackColor = true;
            this.radioButtonGetTokenInfoByCode.CheckedChanged += new System.EventHandler(this.radioButtonGetTokenInfoByCode_CheckedChanged);
            // 
            // panel3
            // 
            this.panel3.BorderStyle = System.Windows.Forms.BorderStyle.Fixed3D;
            this.panel3.Controls.Add(this.textBoxSeqNum);
            this.panel3.Controls.Add(this.label20);
            this.panel3.Controls.Add(this.label17);
            this.panel3.Controls.Add(this.textBoxTokenInfoTcId);
            this.panel3.Controls.Add(this.textBoxTokenHash);
            this.panel3.Controls.Add(this.label1);
            this.panel3.Controls.Add(this.textBoxTokenCode);
            this.panel3.Controls.Add(this.label18);
            this.panel3.Controls.Add(this.listBoxRedemptions);
            this.panel3.Controls.Add(this.textBoxUseCount);
            this.panel3.Controls.Add(this.label16);
            this.panel3.Controls.Add(this.textBoxTokenInfoStatus);
            this.panel3.Controls.Add(this.label15);
            this.panel3.Controls.Add(this.label14);
            this.panel3.Location = new System.Drawing.Point(8, 10);
            this.panel3.Name = "panel3";
            this.panel3.Size = new System.Drawing.Size(344, 257);
            this.panel3.TabIndex = 0;
            // 
            // textBoxSeqNum
            // 
            this.textBoxSeqNum.Location = new System.Drawing.Point(69, 141);
            this.textBoxSeqNum.Name = "textBoxSeqNum";
            this.textBoxSeqNum.Size = new System.Drawing.Size(100, 20);
            this.textBoxSeqNum.TabIndex = 13;
            // 
            // label20
            // 
            this.label20.AutoSize = true;
            this.label20.Location = new System.Drawing.Point(4, 144);
            this.label20.Name = "label20";
            this.label20.Size = new System.Drawing.Size(42, 13);
            this.label20.TabIndex = 12;
            this.label20.Text = "Seq # :";
            // 
            // label17
            // 
            this.label17.AutoSize = true;
            this.label17.Location = new System.Drawing.Point(4, 62);
            this.label17.Name = "label17";
            this.label17.Size = new System.Drawing.Size(64, 13);
            this.label17.TabIndex = 11;
            this.label17.Text = "Category Id:";
            // 
            // textBoxTokenInfoTcId
            // 
            this.textBoxTokenInfoTcId.Location = new System.Drawing.Point(69, 59);
            this.textBoxTokenInfoTcId.Name = "textBoxTokenInfoTcId";
            this.textBoxTokenInfoTcId.Size = new System.Drawing.Size(264, 20);
            this.textBoxTokenInfoTcId.TabIndex = 10;
            // 
            // textBoxTokenHash
            // 
            this.textBoxTokenHash.Location = new System.Drawing.Point(51, 33);
            this.textBoxTokenHash.Name = "textBoxTokenHash";
            this.textBoxTokenHash.Size = new System.Drawing.Size(282, 20);
            this.textBoxTokenHash.TabIndex = 9;
            // 
            // label1
            // 
            this.label1.AutoSize = true;
            this.label1.Location = new System.Drawing.Point(4, 10);
            this.label1.Name = "label1";
            this.label1.Size = new System.Drawing.Size(41, 13);
            this.label1.TabIndex = 4;
            this.label1.Text = "Token:";
            // 
            // textBoxTokenCode
            // 
            this.textBoxTokenCode.Location = new System.Drawing.Point(51, 7);
            this.textBoxTokenCode.Name = "textBoxTokenCode";
            this.textBoxTokenCode.Size = new System.Drawing.Size(282, 20);
            this.textBoxTokenCode.TabIndex = 2;
            // 
            // label18
            // 
            this.label18.AutoSize = true;
            this.label18.Location = new System.Drawing.Point(1, 169);
            this.label18.Name = "label18";
            this.label18.Size = new System.Drawing.Size(72, 13);
            this.label18.TabIndex = 8;
            this.label18.Text = "Redemptions:";
            // 
            // listBoxRedemptions
            // 
            this.listBoxRedemptions.FormattingEnabled = true;
            this.listBoxRedemptions.Location = new System.Drawing.Point(4, 185);
            this.listBoxRedemptions.Name = "listBoxRedemptions";
            this.listBoxRedemptions.Size = new System.Drawing.Size(329, 56);
            this.listBoxRedemptions.TabIndex = 6;
            // 
            // textBoxUseCount
            // 
            this.textBoxUseCount.Location = new System.Drawing.Point(69, 111);
            this.textBoxUseCount.Name = "textBoxUseCount";
            this.textBoxUseCount.Size = new System.Drawing.Size(100, 20);
            this.textBoxUseCount.TabIndex = 5;
            // 
            // label16
            // 
            this.label16.AutoSize = true;
            this.label16.Location = new System.Drawing.Point(4, 114);
            this.label16.Name = "label16";
            this.label16.Size = new System.Drawing.Size(60, 13);
            this.label16.TabIndex = 4;
            this.label16.Text = "Use Count:";
            // 
            // textBoxTokenInfoStatus
            // 
            this.textBoxTokenInfoStatus.Location = new System.Drawing.Point(69, 85);
            this.textBoxTokenInfoStatus.Name = "textBoxTokenInfoStatus";
            this.textBoxTokenInfoStatus.Size = new System.Drawing.Size(100, 20);
            this.textBoxTokenInfoStatus.TabIndex = 3;
            // 
            // label15
            // 
            this.label15.AutoSize = true;
            this.label15.Location = new System.Drawing.Point(4, 88);
            this.label15.Name = "label15";
            this.label15.Size = new System.Drawing.Size(40, 13);
            this.label15.TabIndex = 2;
            this.label15.Text = "Status:";
            // 
            // label14
            // 
            this.label14.AutoSize = true;
            this.label14.Location = new System.Drawing.Point(5, 35);
            this.label14.Name = "label14";
            this.label14.Size = new System.Drawing.Size(35, 13);
            this.label14.TabIndex = 0;
            this.label14.Text = "Hash:";
            // 
            // textBoxTokensRequested
            // 
            this.textBoxTokensRequested.Enabled = false;
            this.textBoxTokensRequested.Location = new System.Drawing.Point(340, 139);
            this.textBoxTokensRequested.Name = "textBoxTokensRequested";
            this.textBoxTokensRequested.Size = new System.Drawing.Size(191, 20);
            this.textBoxTokensRequested.TabIndex = 29;
            // 
            // label28
            // 
            this.label28.AutoSize = true;
            this.label28.Location = new System.Drawing.Point(315, 142);
            this.label28.Name = "label28";
            this.label28.Size = new System.Drawing.Size(19, 13);
            this.label28.TabIndex = 30;
            this.label28.Text = "of:";
            // 
            // checkBoxRoyalty
            // 
            this.checkBoxRoyalty.AutoSize = true;
            this.checkBoxRoyalty.Location = new System.Drawing.Point(128, 189);
            this.checkBoxRoyalty.Name = "checkBoxRoyalty";
            this.checkBoxRoyalty.Size = new System.Drawing.Size(100, 17);
            this.checkBoxRoyalty.TabIndex = 17;
            this.checkBoxRoyalty.Text = "Royalty-Bearing";
            this.checkBoxRoyalty.UseVisualStyleBackColor = true;
            // 
            // checkBoxRedeemable
            // 
            this.checkBoxRedeemable.AutoSize = true;
            this.checkBoxRedeemable.Location = new System.Drawing.Point(128, 212);
            this.checkBoxRedeemable.Name = "checkBoxRedeemable";
            this.checkBoxRedeemable.Size = new System.Drawing.Size(86, 17);
            this.checkBoxRedeemable.TabIndex = 18;
            this.checkBoxRedeemable.Text = "Redeemable";
            this.checkBoxRedeemable.UseVisualStyleBackColor = true;
            // 
            // FormMain
            // 
            this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            this.ClientSize = new System.Drawing.Size(567, 330);
            this.Controls.Add(this.tabControlMain);
            this.Name = "FormMain";
            this.Text = "Token Generation Tool";
            this.tabControlMain.ResumeLayout(false);
            this.tabPage1.ResumeLayout(false);
            this.groupBox1.ResumeLayout(false);
            this.groupBox1.PerformLayout();
            this.panel1.ResumeLayout(false);
            this.panel1.PerformLayout();
            this.tabPage2.ResumeLayout(false);
            this.groupBox2.ResumeLayout(false);
            this.groupBox2.PerformLayout();
            this.panel2.ResumeLayout(false);
            this.panel2.PerformLayout();
            this.tabPage5.ResumeLayout(false);
            this.tabPage5.PerformLayout();
            this.tabPage3.ResumeLayout(false);
            this.tabPage3.PerformLayout();
            ((System.ComponentModel.ISupportInitialize)(this.dataGridTokens)).EndInit();
            this.tabPage4.ResumeLayout(false);
            this.groupBox3.ResumeLayout(false);
            this.groupBox3.PerformLayout();
            this.panel3.ResumeLayout(false);
            this.panel3.PerformLayout();
            this.ResumeLayout(false);

        }

        #endregion

        private System.Windows.Forms.TabControl tabControlMain;
        private System.Windows.Forms.TabPage tabPage1;
        private System.Windows.Forms.TabPage tabPage2;
        private System.Windows.Forms.TabPage tabPage3;
        private System.Windows.Forms.TabPage tabPage4;
        private System.Windows.Forms.Button buttonGetTokens;
        private System.Windows.Forms.TextBox textBoxTokensJobId;
        private System.Windows.Forms.Label label2;
        private System.Windows.Forms.Panel panel1;
        private System.Windows.Forms.TextBox textBoxTcName;
        private System.Windows.Forms.Label label4;
        private System.Windows.Forms.TextBox textBoxTcId;
        private System.Windows.Forms.Label label3;
        private System.Windows.Forms.Label label7;
        private System.Windows.Forms.Label label6;
        private System.Windows.Forms.Label label5;
        private System.Windows.Forms.CheckBox checkBoxRevenue;
        private System.Windows.Forms.CheckBox checkBoxCsat;
        private System.Windows.Forms.ComboBox comboBoxTcProdType;
        private System.Windows.Forms.TextBox textBoxTcOfferId;
        private System.Windows.Forms.DateTimePicker dateTimePickerTcExpDate;
        private System.Windows.Forms.Panel panel2;
        private System.Windows.Forms.TextBox textBoxJobTcId;
        private System.Windows.Forms.Label label11;
        private System.Windows.Forms.TextBox textBoxJobId;
        private System.Windows.Forms.Label label12;
        private System.Windows.Forms.Panel panel3;
        private System.Windows.Forms.Label label15;
        private System.Windows.Forms.Label label14;
        private System.Windows.Forms.TextBox textBoxTokenInfoStatus;
        private System.Windows.Forms.TextBox textBoxUseCount;
        private System.Windows.Forms.Label label16;
        private System.Windows.Forms.Label label18;
        private System.Windows.Forms.TextBox textBoxTokenCode;
        private System.Windows.Forms.TextBox textBoxTokenRequested;
        private System.Windows.Forms.Label label13;
        private System.Windows.Forms.Label label1;
        private System.Windows.Forms.Label label17;
        private System.Windows.Forms.TextBox textBoxTokenInfoTcId;
        private System.Windows.Forms.TextBox textBoxTokenHash;
        private System.Windows.Forms.ListBox listBoxRedemptions;
        private System.Windows.Forms.GroupBox groupBox1;
        private System.Windows.Forms.RadioButton radioButtonGetTcByOffer;
        private System.Windows.Forms.RadioButton radioButtonGetTcByName;
        private System.Windows.Forms.RadioButton radioButtonUpdateTc;
        private System.Windows.Forms.RadioButton radioButtonCreateTc;
        private System.Windows.Forms.RadioButton radioButtonGetTcById;
        private System.Windows.Forms.Button buttonTcApply;
        private System.Windows.Forms.Button buttonJobApply;
        private System.Windows.Forms.GroupBox groupBox2;
        private System.Windows.Forms.RadioButton radioButtonGetJobStatus;
        private System.Windows.Forms.RadioButton radioButtonGenerateTokens;
        private System.Windows.Forms.Button buttonTokenInfoApply;
        private System.Windows.Forms.GroupBox groupBox3;
        private System.Windows.Forms.RadioButton radioButtonGetTokenInfoByHash;
        private System.Windows.Forms.RadioButton radioButtonGetTokenInfoByCode;
        private System.Windows.Forms.Label label19;
        private System.Windows.Forms.CheckBox checkBoxRsm;
        private System.Windows.Forms.TextBox textBoxPkpn;
        private System.Windows.Forms.Label label20;
        private System.Windows.Forms.TextBox textBoxSeqNum;
        private System.Windows.Forms.DataGridView dataGridTokens;
        private System.Windows.Forms.TextBox passwordTextBox;
        private System.Windows.Forms.Label label21;
        private System.Windows.Forms.TextBox confirmTextBox;
        private System.Windows.Forms.Label label22;
        private System.Windows.Forms.TextBox fetchTokensPasswordTextBox;
        private System.Windows.Forms.Label label23;
        private System.Windows.Forms.TabPage tabPage5;
        private System.Windows.Forms.Button button1;
        private System.Windows.Forms.TextBox textBoxJobStatusJobId;
        private System.Windows.Forms.Label label24;
        private System.Windows.Forms.TextBox textBoxSubmitted;
        private System.Windows.Forms.Label label25;
        private System.Windows.Forms.TextBox textBoxTokensGenerated;
        private System.Windows.Forms.TextBox textBoxJobStatus;
        private System.Windows.Forms.CheckBox checkBoxStale;
        private System.Windows.Forms.TextBox textBoxJobLastActivity;
        private System.Windows.Forms.Label label8;
        private System.Windows.Forms.Label label10;
        private System.Windows.Forms.Label label9;
        private System.Windows.Forms.TextBox textBoxNextProcessing;
        private System.Windows.Forms.Label label27;
        private System.Windows.Forms.TextBox textBoxNumFailures;
        private System.Windows.Forms.Label label26;
        private System.Windows.Forms.TextBox textBoxTokensRequested;
        private System.Windows.Forms.Label label28;
        private System.Windows.Forms.CheckBox checkBoxRedeemable;
        private System.Windows.Forms.CheckBox checkBoxRoyalty;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\TokenManagement\TokenGenerationTool\TokenConstants.cs ===
ï»¿using System.Text;

namespace xonline.server.mix.TokenManagement.Tools
{
    public class TokenConstants
    {
        // Setup the password generator
        //public readonly static byte[] SALT = new byte[] { 0, 1, 2, 3, 4, 5, 6, 7 };
        public readonly static byte[] SALT = ASCIIEncoding.Unicode.GetBytes( "MixTokenGenerationSalt2010");
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\TokenManagement\TokenGenerationTool\Program.cs ===
ï»¿using System;
using System.Collections.Generic;
using System.Linq;
using System.Windows.Forms;

namespace TokenGenerationTool
{
    static class Program
    {
        /// <summary>
        /// The main entry point for the application.
        /// </summary>
        [STAThread]
        static void Main()
        {
            Application.EnableVisualStyles();
            Application.SetCompatibleTextRenderingDefault(false);
            Application.Run(new FormMain());
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\TokenManagement\TokenGenerationTool\FormMain.cs ===
ï»¿using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.IO;
using System.IO.Compression;
using System.Linq;
using System.Text;
using System.Net;
using System.Security.Cryptography;
using System.ServiceModel;
using System.ServiceModel.Channels;
using System.Windows.Forms;
using xonline.server.mix.TokenManagement.Tools;

using TokenGenerationTool.xonline.mix.tokenmanagement.contracts.v1;

namespace TokenGenerationTool
{
    public partial class FormMain : Form
    {
        // constant strings for WebSG headers
        private const string SubjectName = "Subject-Name";
        private const string ClientIPPort = "Client-IP-Port";
        private const string RequestId = "RequestId";

        public FormMain()
        {
            InitializeComponent();
        }

        #region TokenCategory

        private void radioButtonCreateTc_CheckedChanged(object sender, EventArgs e)
        {
            if (radioButtonCreateTc.Checked)
            {
                textBoxTcId.Text = Guid.NewGuid().ToString();
                textBoxTcId.ReadOnly = true;
                textBoxTcName.ReadOnly = false;
                textBoxTcOfferId.ReadOnly = false;
                textBoxPkpn.ReadOnly = false;
                dateTimePickerTcExpDate.Enabled = true;
                comboBoxTcProdType.Enabled = true;
                checkBoxCsat.Enabled = true;
                checkBoxRsm.Enabled = true;
                checkBoxRevenue.Enabled = true;
                checkBoxRoyalty.Enabled = true;
                checkBoxRedeemable.Enabled = true;
            }
        }

        private void radioButtonUpdateTc_CheckedChanged(object sender, EventArgs e)
        {
            if (radioButtonUpdateTc.Checked)
            {
                textBoxTcId.ReadOnly = false;
                textBoxTcName.ReadOnly = false;
                textBoxTcOfferId.ReadOnly = false;
                textBoxPkpn.ReadOnly = false;
                dateTimePickerTcExpDate.Enabled = true;
                comboBoxTcProdType.Enabled = true;
                checkBoxCsat.Enabled = true;
                checkBoxRsm.Enabled = true;
                checkBoxRevenue.Enabled = true;
                checkBoxRoyalty.Enabled = true;
                checkBoxRedeemable.Enabled = true;
            }
        }

        private void radioButtonGetTcById_CheckedChanged(object sender, EventArgs e)
        {
            if (radioButtonGetTcById.Checked)
            {
                textBoxTcId.ReadOnly = false;
                textBoxTcName.ReadOnly = true;
                textBoxTcOfferId.ReadOnly = true;
                textBoxPkpn.ReadOnly = true;
                dateTimePickerTcExpDate.Enabled = false;
                comboBoxTcProdType.Enabled = false;
                checkBoxCsat.Enabled = false;
                checkBoxRsm.Enabled = false;
                checkBoxRevenue.Enabled = false;
                checkBoxRoyalty.Enabled = false;
                checkBoxRedeemable.Enabled = false;
            }
        }

        private void radioButtonGetTcByName_CheckedChanged(object sender, EventArgs e)
        {
            if (radioButtonGetTcByName.Checked)
            {
                textBoxTcId.ReadOnly = true;
                textBoxTcName.ReadOnly = false;
                textBoxTcOfferId.ReadOnly = true;
                textBoxPkpn.ReadOnly = true;
                dateTimePickerTcExpDate.Enabled = false;
                comboBoxTcProdType.Enabled = false;
                checkBoxCsat.Enabled = false;
                checkBoxRsm.Enabled = false;
                checkBoxRevenue.Enabled = false;
                checkBoxRoyalty.Enabled = false;
                checkBoxRedeemable.Enabled = false;
            }
        }

        private void radioButtonGetTcByOffer_CheckedChanged(object sender, EventArgs e)
        {
            if (radioButtonGetTcByOffer.Checked)
            {
                textBoxTcId.ReadOnly = true;
                textBoxTcName.ReadOnly = true;
                textBoxTcOfferId.ReadOnly = false;
                textBoxPkpn.ReadOnly = true;
                dateTimePickerTcExpDate.Enabled = false;
                comboBoxTcProdType.Enabled = false;
                checkBoxCsat.Enabled = false;
                checkBoxRsm.Enabled = false;
                checkBoxRevenue.Enabled = false;
                checkBoxRoyalty.Enabled = false;
                checkBoxRedeemable.Enabled = false;
            }
        }

        /// <summary>
        /// This will generate number strings (0,1,2,....9).
        /// The entire string is composed of chars in the 48 - 57 range
        /// </summary>
        /// <param name="MaxLength"></param>
        /// <returns></returns>
        private string GenerateNumberString(int MaxLength)
        {
            StringBuilder Name = new StringBuilder(MaxLength);
            Random randGen = new Random();

            for (int i = 0; i < MaxLength; i++)
            {
                Name.Append((char)randGen.Next(0x30, 0x3a));
            }
            return Name.ToString();
        }

        private void buttonTcApply_Click(object sender, EventArgs e)
        {
            Cursor = Cursors.WaitCursor;
            buttonTcApply.Enabled = false;
            try
            {
                if (radioButtonCreateTc.Checked)
                {
                    TokenCategory tc = new TokenCategory();
                    tc.TokenCategoryId = new Guid(textBoxTcId.Text);
                    tc.TokenCategoryName = textBoxTcName.Text;
                    tc.OfferId = new Guid(textBoxTcOfferId.Text);
                    tc.ProductTypeId = Convert.ToUInt32(comboBoxTcProdType.Text);
                    tc.Pkpn = textBoxPkpn.Text;
                    tc.ExpirationDate = DateTime.Parse(dateTimePickerTcExpDate.Text);
                    tc.InCsat = checkBoxCsat.Checked;
                    tc.IsRsm = checkBoxRsm.Checked;
                    tc.IsRevenueBearing = checkBoxRevenue.Checked;
                    tc.IsRoyaltyBearing = checkBoxRoyalty.Checked;
                    tc.IsRedeemable = checkBoxRedeemable.Checked;
                    tc.TokenType = "TestTokenType";

                    // create ChannelSKU for CTP tokens
                    if (tc.InCsat || tc.IsRevenueBearing || tc.IsRoyaltyBearing)
                    {
                        ChannelSKU channelSku = new ChannelSKU();
                        channelSku.ID = "YYY-" + GenerateNumberString(5);    // format of Channel SKU ID, XXX-01234

                        channelSku.BOMQuantity = 10;
                        channelSku.MaxPriceUSD = 10;
                        channelSku.MinPriceUSD = 10;
                        channelSku.PercentageAllocation = 1;

                        tc.ChannelSKUArray = new ChannelSKU[] { channelSku };
                    }

                    MixTokenManagementClient client = new MixTokenManagementClient();
                    using (OperationContextScope scope = new OperationContextScope(client.InnerChannel))
                    {
                        OperationContext.Current.OutgoingMessageProperties[HttpRequestMessageProperty.Name] = CreateMsgProperty();

                        client.ConfigureTokenCategory(tc);
                        client.Close();
                    }
                }
                else if (radioButtonUpdateTc.Checked)
                {
                    TokenCategory tc = new TokenCategory();
                    tc.TokenCategoryId = new Guid(textBoxTcId.Text);
                    tc.TokenCategoryName = textBoxTcName.Text;
                    tc.OfferId = new Guid(textBoxTcOfferId.Text);
                    tc.ProductTypeId = Convert.ToUInt32(comboBoxTcProdType.Text);
                    tc.Pkpn = textBoxPkpn.Text;
                    tc.ExpirationDate = DateTime.Parse(dateTimePickerTcExpDate.Text);
                    tc.InCsat = checkBoxCsat.Checked;
                    tc.IsRsm = checkBoxRsm.Checked;
                    tc.IsRevenueBearing = checkBoxRevenue.Checked;
                    tc.IsRoyaltyBearing = checkBoxRoyalty.Checked;
                    tc.IsRedeemable = checkBoxRedeemable.Checked;
                    MixTokenManagementClient client = new MixTokenManagementClient();
                    using (OperationContextScope scope = new OperationContextScope(client.InnerChannel))
                    {
                        OperationContext.Current.OutgoingMessageProperties[HttpRequestMessageProperty.Name] = CreateMsgProperty();

                        client.ConfigureTokenCategory(tc);
                        client.Close();
                    }
                }
                else if (radioButtonGetTcById.Checked)
                {
                    Guid tcId = new Guid(textBoxTcId.Text);
                    MixTokenManagementClient client = new MixTokenManagementClient();
                    using (OperationContextScope scope = new OperationContextScope(client.InnerChannel))
                    {
                        OperationContext.Current.OutgoingMessageProperties[HttpRequestMessageProperty.Name] = CreateMsgProperty();

                        TokenCategory tc = client.GetTokenCategoryById(tcId);
                        client.Close();
                        textBoxTcName.Text = tc.TokenCategoryName;
                        textBoxTcOfferId.Text = tc.OfferId.ToString();
                        textBoxPkpn.Text = tc.Pkpn;
                        comboBoxTcProdType.Text = tc.ProductTypeId.ToString();
                        checkBoxCsat.Checked = tc.InCsat;
                        checkBoxRsm.Checked = tc.IsRsm;
                        checkBoxRevenue.Checked = tc.IsRevenueBearing;
                        checkBoxRoyalty.Checked = tc.IsRoyaltyBearing;
                        checkBoxRedeemable.Checked = tc.IsRedeemable;
                    }
                    PopulateTokenJobFromTokenCategory();
                }
                else if (radioButtonGetTcByName.Checked)
                {
                    MixTokenManagementClient client = new MixTokenManagementClient();
                    using (OperationContextScope scope = new OperationContextScope(client.InnerChannel))
                    {
                        OperationContext.Current.OutgoingMessageProperties[HttpRequestMessageProperty.Name] = CreateMsgProperty();

                        TokenCategory tc = client.GetTokenCategoryByName(textBoxTcName.Text);
                        client.Close();
                        textBoxTcId.Text = tc.TokenCategoryId.ToString();
                        textBoxTcOfferId.Text = tc.OfferId.ToString();
                        textBoxPkpn.Text = tc.Pkpn;
                        comboBoxTcProdType.Text = tc.ProductTypeId.ToString();
                        checkBoxCsat.Checked = tc.InCsat;
                        checkBoxRsm.Checked = tc.IsRsm;
                        checkBoxRevenue.Checked = tc.IsRevenueBearing;
                        checkBoxRoyalty.Checked = tc.IsRoyaltyBearing;
                        checkBoxRedeemable.Checked = tc.IsRedeemable;
                    }
                    PopulateTokenJobFromTokenCategory();
                }
                else if (radioButtonGetTcByOffer.Checked)
                {
                    Guid tcOfferId = new Guid(textBoxTcOfferId.Text);
                    MixTokenManagementClient client = new MixTokenManagementClient();
                    using (OperationContextScope scope = new OperationContextScope(client.InnerChannel))
                    {
                        OperationContext.Current.OutgoingMessageProperties[HttpRequestMessageProperty.Name] = CreateMsgProperty();

                        TokenCategory[] tcs = client.GetTokenCategoryByOffer(tcOfferId);
                        client.Close();
                        // TODO: pop up a list for user to choose. Right now, let's just use the first one.
                        if (tcs.Length >= 1)
                        {
                            TokenCategory tc = tcs[0];
                            textBoxTcId.Text = tc.TokenCategoryId.ToString();
                            textBoxTcName.Text = tc.TokenCategoryName;
                            textBoxTcOfferId.Text = tc.OfferId.ToString();
                            textBoxPkpn.Text = tc.Pkpn;
                            comboBoxTcProdType.Text = tc.ProductTypeId.ToString();
                            checkBoxCsat.Checked = tc.InCsat;
                            checkBoxRsm.Checked = tc.IsRsm;
                            checkBoxRevenue.Checked = tc.IsRevenueBearing;
                            checkBoxRoyalty.Checked = tc.IsRoyaltyBearing;
                            checkBoxRedeemable.Checked = tc.IsRedeemable;
                        }
                    }
                }
                else
                {
                    MessageBox.Show("Please choose an action first.");
                }
            }
            catch (FormatException ex)
            {
                MessageBox.Show(ex.Message, "Format Error");
            }
            catch (FaultException ex)
            {
                // TODO: proper handling fault here.
                MessageBox.Show(ex.Message, "Server Error");
            }
            Cursor = Cursors.Default;
            buttonTcApply.Enabled = true;
        }

        private void PopulateTokenJobFromTokenCategory()
        {
            textBoxJobTcId.Text = textBoxTcId.Text;
        }

        #endregion  // TokenCategory

        #region TokenJob

        private void radioButtonGenerateTokens_CheckedChanged(object sender, EventArgs e)
        {
            if (radioButtonGenerateTokens.Checked)
            {
                textBoxJobId.Text = String.Empty;
                textBoxJobId.ReadOnly = true;
                textBoxJobTcId.ReadOnly = false;
                textBoxTokenRequested.ReadOnly = false;
                textBoxJobStatus.Text = String.Empty;
                textBoxJobStatus.ReadOnly = true;
                textBoxJobLastActivity.Text = String.Empty;
                textBoxJobLastActivity.ReadOnly = true;
                textBoxTokensGenerated.Text = String.Empty;
                textBoxTokensGenerated.ReadOnly = true;
                checkBoxStale.Enabled = false;
            }
        }

        private void radioButtonGetJobStatus_CheckedChanged(object sender, EventArgs e)
        {
            if (radioButtonGetJobStatus.Checked)
            {
                textBoxJobId.ReadOnly = false;
                textBoxJobTcId.ReadOnly = true;
                textBoxTokenRequested.ReadOnly = true;
                textBoxJobStatus.ReadOnly = true;
                textBoxJobLastActivity.ReadOnly = true;
                textBoxTokensGenerated.ReadOnly = true;
                checkBoxStale.Enabled = false;
            }
        }

        private static HttpRequestMessageProperty CreateMsgProperty()
        {
            HttpRequestMessageProperty msgProperty = new HttpRequestMessageProperty();
            msgProperty.Headers.Add(SubjectName, "DebugPartner");
            msgProperty.Headers.Add(ClientIPPort, "1.1.1.1:1000");
            msgProperty.Headers.Add(RequestId, "4a601e02d7d87344");
            return msgProperty;
        }

        private void CronHealthCheck()
        {
            // Form the cron health check URL
            MixTokenManagementClient client = new MixTokenManagementClient();
            string url = string.Format(@"http://{0}:11210/cron/health.ashx?op=status", client.Endpoint.Address.Uri.Host);
            client.Close();
            try
            {
                // Now get it.
                WebClient webClient = new WebClient();
                webClient.DownloadData(url);
            }
            catch (Exception ex)
            {
                MessageBox.Show(string.Format("CronHealthCheck failed. If Token Generation failed, please try to manually run Cron HealthCheck instead. \n URL used: {0}\nError Message: {1}", url, ex.Message));
            }
        }

        private byte[] GetOldKeyFromPassword(string password)
        {
            using (SHA1CryptoServiceProvider sha1 = new SHA1CryptoServiceProvider())
            {
                UnicodeEncoding ue = new UnicodeEncoding();
                byte[] passwordBytes = ue.GetBytes(password);
                byte[] passwordHash = sha1.ComputeHash(passwordBytes);
                byte[] key = new byte[16];
                Array.Copy(passwordHash, key, key.Length);
                return key;
            }
        }

        private byte[] GetNewKeyFromPassword(string password)
        {
            Rfc2898DeriveBytes pwdGen = new Rfc2898DeriveBytes(password, TokenConstants.SALT, 1000);
            // generate an RC2 key
            byte[] key = pwdGen.GetBytes(16);

            return key;
        }

        private void buttonJobApply_Click(object sender, EventArgs e)
        {
            Cursor = Cursors.WaitCursor;
            buttonJobApply.Enabled = false;
            try
            {
                if (radioButtonGenerateTokens.Checked)
                {
                    if (passwordTextBox.Text != confirmTextBox.Text)
                    {
                        MessageBox.Show("The passwords entered do not match!");
                        passwordTextBox.SelectionStart = 0;
                        passwordTextBox.SelectionLength = passwordTextBox.Text.Length;
                        passwordTextBox.Focus();
                        return;
                    }

                    if (string.IsNullOrEmpty(passwordTextBox.Text))
                    {
                        MessageBox.Show("A password must be provided!");
                        passwordTextBox.Focus();
                        return;
                    }

                    //byte[] key = GetOldKeyFromPassword(passwordTextBox.Text);
                    byte[] key = GetNewKeyFromPassword(passwordTextBox.Text);

                    Guid tcId = new Guid(textBoxJobTcId.Text);
                    uint numTokens = Convert.ToUInt32(textBoxTokenRequested.Text);
                    bool isTest = false;
                    MixTokenManagementClient client = new MixTokenManagementClient();
                    using (OperationContextScope scope = new OperationContextScope(client.InnerChannel))
                    {
                        OperationContext.Current.OutgoingMessageProperties[HttpRequestMessageProperty.Name] = CreateMsgProperty();

                        TokenJob tj = client.GenerateTokens(tcId, numTokens, key, isTest);
                        client.Close();
                        // Have to hit the cron health check to trigger cron to pick up the job.
                        CronHealthCheck();
                        textBoxJobId.Text = tj.TokenJobId.ToString();

                        // prepopulate JobStatus job id
                        textBoxJobStatusJobId.Text = tj.TokenJobId.ToString();
                    }
                }
                else if (radioButtonGetJobStatus.Checked)
                {
                    Guid jobId = new Guid(textBoxJobId.Text);
                    MixTokenManagementClient client = new MixTokenManagementClient();
                    using (OperationContextScope scope = new OperationContextScope(client.InnerChannel))
                    {
                        OperationContext.Current.OutgoingMessageProperties[HttpRequestMessageProperty.Name] = CreateMsgProperty();

                        TokenJobStatus tjs = client.GetTokenJobStatus(jobId);
                        client.Close();
                        // Todo: get this from token job.
                        textBoxJobTcId.Text = string.Empty;
                        textBoxTokenRequested.Text = string.Empty;
                        textBoxJobStatus.Text = tjs.Status.ToString();
                        textBoxJobLastActivity.Text = tjs.LastActivity.ToString();
                        textBoxTokensGenerated.Text = tjs.NumTokensCompleted.ToString();
                        checkBoxStale.Checked = tjs.IsStale;
                    }
                }
                else
                {
                    MessageBox.Show("Please choose an action first.");
                }
            }
            catch (FormatException ex)
            {
                MessageBox.Show(ex.Message, "Format Error");
            }
            catch (FaultException ex)
            {
                // TODO: proper handling fault here.
                MessageBox.Show(ex.Message, "Server Error");
            }
            finally
            {
                Cursor = Cursors.Default;
                buttonJobApply.Enabled = true;
            }
        }

        #endregion // TokenJob

        #region Tokens

        private void buttonGetTokens_Click(object sender, EventArgs e)
        {
            Cursor = Cursors.WaitCursor;
            buttonGetTokens.Enabled = false;
            try
            {
                byte[] hash = HexStringToBytes(textBoxTokenHash.Text);
                MixTokenManagementClient client = new MixTokenManagementClient();
                using (OperationContextScope scope = new OperationContextScope(client.InnerChannel))
                {
                    OperationContext.Current.OutgoingMessageProperties[HttpRequestMessageProperty.Name] = CreateMsgProperty();

                    // Get the job id, key 
                    Guid jobId = new Guid(textBoxTokensJobId.Text);
                    byte[] key = GetNewKeyFromPassword(fetchTokensPasswordTextBox.Text);

                    // Get the token count
                    TokenJobStatus tjs = client.GetTokenJobStatus(jobId);
                    
                    TokenEntry[] tokens = client.GetTokens(jobId, key, 1, (int)tjs.NumTokensRequested);
                    client.Close();

                    DataTable tokenTable = new DataTable("TokenOutput");
                    tokenTable.Columns.Add("5x5", typeof(string));
                    tokenTable.Columns.Add("seqNum", typeof(string));

                    foreach (TokenEntry tokenEntry in tokens)
                    {
                        DataRow tokenRow = tokenTable.NewRow();
                        tokenRow["5x5"] = tokenEntry.Token;
                        tokenRow["seqNum"] = tokenEntry.SequenceNumber;
                        tokenTable.Rows.Add(tokenRow);
                    }
                    dataGridTokens.DataSource = tokenTable;
                    dataGridTokens.Visible = true;
                }
            }
            catch (FormatException ex)
            {
                MessageBox.Show(ex.Message, "Format Error");
            }
            catch (FaultException ex)
            {
                // TODO: proper handling fault here.
                MessageBox.Show(ex.Message, "Server Error");
            }
            Cursor = Cursors.Default;
            buttonGetTokens.Enabled = true;

#if false

            try
            {
                // Get the job id
                Guid jobId = new Guid(textBoxTokensJobId.Text);
                // Temporary hard code the output directory here, this is the same as the default npdb settings the token service uses
                MixTokenManagementClient client = new MixTokenManagementClient();
                string path = string.Format(@"\\{0}\C$\TokenOutput\{1}.xtx", client.Endpoint.Address.Uri.Host, jobId.ToString());
                client.Close();

                if (string.IsNullOrEmpty(fetchTokensPasswordTextBox.Text))
                {
                    MessageBox.Show("A password must be specified!");
                    fetchTokensPasswordTextBox.Focus();
                    return;
                }

                //byte[] key = GetOldKeyFromPassword(fetchTokensPasswordTextBox.Text);
                byte[] key = GetNewKeyFromPassword(fetchTokensPasswordTextBox.Text);

                // create a decryptor transform
                RijndaelManaged aes = new RijndaelManaged();
                aes.Key = key;
                aes.IV = jobId.ToByteArray();
                aes.Padding = PaddingMode.None; // don't check padding since we may not be reading the entire file

                ICryptoTransform cryptoXform = aes.CreateDecryptor();

                List<string> rawTokenList = new List<string>();

                DataTable tokenTable = new DataTable("TokenOutput");
                tokenTable.Columns.Add("5x5", typeof(string));
                tokenTable.Columns.Add("seqNum", typeof(string));

                try
                {

                    using (FileStream inputFile = new FileStream(path, FileMode.Open))
                    using (CryptoStream cryptoStream = new CryptoStream(inputFile, cryptoXform, CryptoStreamMode.Read))
                    using (GZipStream gzipStream = new GZipStream(cryptoStream, CompressionMode.Decompress, false))
                    using (StreamReader sr = new StreamReader(gzipStream))
                    {
                        string line;
                        while ((line = sr.ReadLine()) != null)
                        {
                            string[] tuple = line.Split(',');

                            DataRow tokenRow = tokenTable.NewRow();
                            tokenRow["5x5"] = tuple[0];
                            tokenRow["seqNum"] = tuple[2];
                            tokenTable.Rows.Add(tokenRow);

                            rawTokenList.Add(string.Format("{0}\t{1}", tuple[0], tuple[2]));
                            if (rawTokenList.Count >= 1000)
                            {
                                break;
                            }
                        }
                    }
                }
                catch (InvalidDataException)
                {
                    MessageBox.Show("Unable to decrypt token file. Verify the password is entered correctly.");
                    return;
                }

                //textBoxTokens.Lines = rawTokenList.ToArray();
                dataGridTokens.DataSource = tokenTable;
                dataGridTokens.Visible = true;

                //Console.WriteLine("Token file path = {0}", path);
                List<string> tokenCodes = new List<string>();
                using (StreamReader sr = new StreamReader(path))
                {
                    string line;
                    while ((line = sr.ReadLine()) != null)
                    {
                        tokenCodes.Add(line);
                        if (tokenCodes.Count >= 1000) // Only return first 1000 tokens for now
                        {
                            break;
                        }
                    }
                }
                textBoxTokens.Lines = tokenCodes.ToArray();
            }
            catch (FileNotFoundException ex)
            {
                MessageBox.Show(ex.Message, "Token file is not found!\n");
            }
#endif
        }

        #endregion // Tokens

        #region TokenInfo

        private void radioButtonGetTokenInfoByCode_CheckedChanged(object sender, EventArgs e)
        {
            if (radioButtonGetTokenInfoByCode.Checked)
            {
                textBoxTokenCode.ReadOnly = false;
                textBoxTokenHash.Text = String.Empty;
                textBoxTokenHash.ReadOnly = true;
                textBoxTokenInfoStatus.Text = String.Empty;
                textBoxTokenInfoStatus.ReadOnly = true;
                textBoxTokenInfoTcId.Text = String.Empty;
                textBoxTokenInfoTcId.ReadOnly = true;
                textBoxUseCount.Text = String.Empty;
                textBoxUseCount.ReadOnly = true;
                textBoxSeqNum.Text = String.Empty;
                textBoxSeqNum.ReadOnly = true;
                listBoxRedemptions.Items.Clear();
            }
        }

        private void radioButtonGetTokenInfoByHash_CheckedChanged(object sender, EventArgs e)
        {
            if (radioButtonGetTokenInfoByHash.Checked)
            {
                textBoxTokenCode.Text = String.Empty;
                textBoxTokenCode.ReadOnly = true;
                textBoxTokenHash.ReadOnly = false;
                textBoxTokenInfoStatus.Text = String.Empty;
                textBoxTokenInfoStatus.ReadOnly = true;
                textBoxTokenInfoTcId.Text = String.Empty;
                textBoxTokenInfoTcId.ReadOnly = true;
                textBoxUseCount.Text = String.Empty;
                textBoxUseCount.ReadOnly = true;
                textBoxSeqNum.Text = String.Empty;
                textBoxSeqNum.ReadOnly = true;
                listBoxRedemptions.Items.Clear();
            }
        }

        private string BytesToHexString(byte[] bytes)
        {
            StringBuilder sb = new StringBuilder(bytes.Length * 2);
            foreach (byte b in bytes)
            {
                sb.Append(b.ToString("X2"));
            }
            return sb.ToString();
        }

        private byte[] HexStringToBytes(string s)
        {
            List<byte> lb = new List<byte>();
            for (int i = 0; i < s.Length; i += 2)
            {
                string sub = s.Substring(i, 2);
                lb.Add(Convert.ToByte(sub, 16));
            }
            return lb.ToArray();
        }

        private void buttonTokenInfoApply_Click(object sender, EventArgs e)
        {
            Cursor = Cursors.WaitCursor;
            buttonTokenInfoApply.Enabled = false;
            try
            {
                if (radioButtonGetTokenInfoByCode.Checked)
                {
                    MixTokenManagementClient client = new MixTokenManagementClient();
                    using (OperationContextScope scope = new OperationContextScope(client.InnerChannel))
                    {
                        OperationContext.Current.OutgoingMessageProperties[HttpRequestMessageProperty.Name] = CreateMsgProperty();

                        TokenInfo ti = client.GetTokenInfoByToken(textBoxTokenCode.Text);
                        client.Close();
                        textBoxTokenHash.Text = BytesToHexString(ti.Hash);
                        textBoxTokenInfoStatus.Text = ti.StatusId.ToString();
                        textBoxTokenInfoTcId.Text = ti.Category.TokenCategoryId.ToString();
                        textBoxUseCount.Text = ti.UseCount.ToString();
                        textBoxSeqNum.Text = ti.SequenceNumber.ToString("D09");
                        foreach (TokenRedemption tr in ti.Redemptions)
                        {
                            listBoxRedemptions.Items.Add("User:" + tr.UserPuid.ToString("X") + ", Time:" + tr.DateRedeemed.ToString());
                            //listBoxRedemptions.Items.Add("User: 0x9000800070006001, Time : " + DateTime.Now.ToString());
                        }
                    }
                }
                else if (radioButtonGetTokenInfoByHash.Checked)
                {
                    byte[] hash = HexStringToBytes(textBoxTokenHash.Text);
                    MixTokenManagementClient client = new MixTokenManagementClient();
                    using (OperationContextScope scope = new OperationContextScope(client.InnerChannel))
                    {
                        OperationContext.Current.OutgoingMessageProperties[HttpRequestMessageProperty.Name] = CreateMsgProperty();

                        TokenInfo ti = client.GetTokenInfoByHash(hash);
                        client.Close();
                        textBoxTokenHash.Text = BytesToHexString(ti.Hash);
                        textBoxTokenInfoStatus.Text = ti.StatusId.ToString();
                        textBoxTokenInfoTcId.Text = ti.Category.TokenCategoryId.ToString();
                        textBoxUseCount.Text = ti.UseCount.ToString();
                        foreach (TokenRedemption tr in ti.Redemptions)
                        {
                            listBoxRedemptions.Items.Add("User:" + tr.UserPuid.ToString("X") + ", Time:" + tr.DateRedeemed.ToString());
                        }
                    }
                }
                else
                {
                    MessageBox.Show("Please choose an action first.");
                }
            }
            catch (FormatException ex)
            {
                MessageBox.Show(ex.Message, "Format Error");
            }
            catch (FaultException ex)
            {
                // TODO: proper handling fault here.
                MessageBox.Show(ex.Message, "Server Error");
            }
            Cursor = Cursors.Default;
            buttonTokenInfoApply.Enabled = true;
        }

        #endregion // TokenInfo

#region // GetStatus
        private void buttonGetStatus_Click(object sender, EventArgs e)
        {
            Guid jobId = new Guid(textBoxJobStatusJobId.Text);
            MixTokenManagementClient client = new MixTokenManagementClient();
            using (OperationContextScope scope = new OperationContextScope(client.InnerChannel))
            {
                OperationContext.Current.OutgoingMessageProperties[HttpRequestMessageProperty.Name] = CreateMsgProperty();

                TokenJobStatus tjs = client.GetTokenJobStatus(jobId);
                client.Close();
                // Todo: get this from token job.
                textBoxJobTcId.Text = string.Empty;
                textBoxTokenRequested.Text = string.Empty;
                textBoxJobStatus.Text = tjs.Status.ToString();
                textBoxJobLastActivity.Text = tjs.LastActivity.ToString();
                textBoxTokensGenerated.Text = tjs.NumTokensCompleted.ToString();
                textBoxTokensRequested.Text = tjs.NumTokensRequested.ToString();
                checkBoxStale.Checked = tjs.IsStale;
                textBoxSubmitted.Text = tjs.Submitted.ToString();
                textBoxNumFailures.Text = tjs.NumFailures.ToString("d");
                if (tjs.Status == TokenJobStatusEnum.Pending)
                {
                    textBoxNextProcessing.Text = tjs.NextProcessing.ToString();
                    label27.Visible = true;
                    textBoxNextProcessing.Visible = true;
                }
                else
                {
                    label27.Visible = false;
                    textBoxNextProcessing.Visible = false;
                }
            }
        }
#endregion

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\TokenManagement\TokenGenerationTool\Properties\AssemblyInfo.cs ===
ï»¿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("TokenGenerationTool")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("Microsoft")]
[assembly: AssemblyProduct("TokenGenerationTool")]
[assembly: AssemblyCopyright("Copyright Â© Microsoft 2009")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("1c51cc6d-42a6-4a30-8171-7639d968c30a")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\TokenManagement\TokenGenerationTool\Properties\Settings.Designer.cs ===
ï»¿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.4927
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace TokenGenerationTool.Properties
{


    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.Editors.SettingsDesigner.SettingsSingleFileGenerator", "9.0.0.0")]
    internal sealed partial class Settings : global::System.Configuration.ApplicationSettingsBase
    {

        private static Settings defaultInstance = ((Settings)(global::System.Configuration.ApplicationSettingsBase.Synchronized(new Settings())));

        public static Settings Default
        {
            get
            {
                return defaultInstance;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\TokenManagement\TokenGenerationTool\Properties\Resources.Designer.cs ===
ï»¿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.4927
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace TokenGenerationTool.Properties
{


    /// <summary>
    ///   A strongly-typed resource class, for looking up localized strings, etc.
    /// </summary>
    // This class was auto-generated by the StronglyTypedResourceBuilder
    // class via a tool like ResGen or Visual Studio.
    // To add or remove a member, edit your .ResX file then rerun ResGen
    // with the /str option, or rebuild your VS project.
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "2.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    internal class Resources
    {

        private static global::System.Resources.ResourceManager resourceMan;

        private static global::System.Globalization.CultureInfo resourceCulture;

        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal Resources()
        {
        }

        /// <summary>
        ///   Returns the cached ResourceManager instance used by this class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Resources.ResourceManager ResourceManager
        {
            get
            {
                if ((resourceMan == null))
                {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("TokenGenerationTool.Properties.Resources", typeof(Resources).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }

        /// <summary>
        ///   Overrides the current thread's CurrentUICulture property for all
        ///   resource lookups using this strongly typed resource class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Globalization.CultureInfo Culture
        {
            get
            {
                return resourceCulture;
            }
            set
            {
                resourceCulture = value;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\TokenManagement\Service\MixTokenManagementV1.svc.cs ===
ï»¿using System;
using System.Collections.Generic;
using System.IO;
using System.IO.Compression;
using System.Security.Cryptography;
using System.ServiceModel.Activation;
using System.Text;
using System.Text.RegularExpressions;
using System.Web;
using System.Xml;
using System.Xml.Serialization;

using xonline.common.billing;
using xonline.common.config;
using xonline.common.installer;
using xonline.common.mgmt;
using xonline.common.service;
using xonline.server.webcache.common;
using Xonline.Mix.TokenManagement.Contract;
using common = xonline.common.token;

[assembly: XomAreaDefinition(XomAreaName.log)]
[assembly: XomIisInstallerAttribute(Interface.mixtokenmanagement)]
[assembly: ConfigAttribute(Component.mixtokenmanagement)]

namespace Xonline.Mix.TokenManagement.Service
{
    // NOTE: If you change the class name "MixTokenManagementV1" here, you must also update the reference to "Mix" in Web.config and in the associated .svc file.
    //Set the compat mode to allow the WCF application mimic the ASPNET lifecycle. This will ensure that the current components like FEAPP will continue to work with our service
    [AspNetCompatibilityRequirements(RequirementsMode = AspNetCompatibilityRequirementsMode.Required)]
    public class MixTokenManagementV1 : IMixTokenManagementV1
    {
        #region Constants Definition
        // these are the API names as defined in WebDB
        private static readonly string ConfigureTokenCategoryApiName  = "TokenManagement.ConfigureTokenCategory";
        private static readonly string GenerateTokensApiName          = "TokenManagement.GenerateTokens";
        private static readonly string GetTokenCategoryApiName        = "TokenManagement.GetTokenCategory";
        private static readonly string GetTokenInfoApiName            = "TokenManagement.GetTokenInfo";
        private static readonly string GetTokenJobStatusApiName       = "TokenManagement.GetTokenJobStatus";
        private static readonly string GetTokensApiName               = "TokenManagement.GetTokens";

        // these are variants of the above-defined WebDB API names -- none of these API names exist as-is in WebDB
        private static readonly string GetTokenJobStatusByCategoryApiName = "TokenManagement.GetTokenJobStatusByCategory";
        private static readonly string GetTokenInfoByHashApiName      = "TokenManagement.GetTokenInfoByHash";
        private static readonly string GetTokenInfoByTokenApiName     = "TokenManagement.GetTokenInfoByToken";
        private static readonly string GetTokenCategoryByIdApiName    = "TokenManagement.GetTokenCategoryById";
        private static readonly string GetTokenCategoryByNameApiName  = "TokenManagement.GetTokenCategoryByName";
        private static readonly string GetTokenCategoryByOfferApiName = "TokenManagement.GetTokenCategoryByOffer";
        #endregion Constants Definition

        // APIs
        // Contains the service APIs the exposed to external callers (clients)
        #region APIs

        public void ConfigureTokenCategory(TokenCategoryV1 tcV1)
        {
            HResult hr = HResult.S_OK;
            string err = string.Empty;
            XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();

            common.TokenCategory tc = null;
            try
            {
                WebSgApiCheck(ConfigureTokenCategoryApiName);

                // at the moment, LIVE token generation does not support subscription or points bundle tokens
                if (CatalogUtil.IsSubscriptionMediaType((int)tcV1.ProductTypeId) || CatalogUtil.IsPointsBundleMediaType((int)tcV1.ProductTypeId))
                {
                    throw new XRLExceptionWithoutEvent(HResult.E_INVALIDARG, "{0}: Invalid media type: {1}. Token categories for subscription and points bundle are not yet supported.", ConfigureTokenCategoryApiName, tcV1.ProductTypeId);
                }

                tc = new common.TokenCategory(tcV1.TokenCategoryId,
                                                                   tcV1.TokenCategoryName,
                                                                   tcV1.ExpirationDate,
                                                                   tcV1.OfferId,
                                                                   tcV1.PromotionId,
                                                                   tcV1.ProductTypeId,
                                                                   tcV1.InCsat,
                                                                   tcV1.IsRsm,
                                                                   tcV1.Pkpn,
                                                                   tcV1.ChannelTypeId,
                                                                   tcV1.IsRevenueBearing,
                                                                   tcV1.IsRoyaltyBearing,
                                                                   tcV1.IsRedeemable,
                                                                   tcV1.TokenType);

                // add Behavior Injection
                AddBehaviorInjectionSupport();

                // use longer SCS timeout values because these calls are server <-> server
                BdkWrapper.SetSessionClientType(SessionClientType.LiveService);

                try
                {
                    common.ChannelSKU[] channelSKUs = null;

                    if ((tcV1.IsRevenueBearing || tcV1.IsRoyaltyBearing || tcV1.InCsat) && tcV1.ChannelSKUArray != null)
                    {
                        channelSKUs = new common.ChannelSKU[tcV1.ChannelSKUArray.Length];

                        for (int i=0; i < tcV1.ChannelSKUArray.Length; i++)
                        {
                            ChannelSKU tcV1ChannelSKU = tcV1.ChannelSKUArray[i];

                            common.ChannelSKU channelSKU = new common.ChannelSKU();
                            channelSKU.ID = tcV1ChannelSKU.ID;

                            common.PKPNSet pkpnSet = new common.PKPNSet();
                            pkpnSet.PKPNID = tc.Pkpn;
                            pkpnSet.PercentageAllocation = tcV1ChannelSKU.PercentageAllocation;
                            pkpnSet.BOMQuantity = tcV1ChannelSKU.BOMQuantity;
                            pkpnSet.MinPriceUSD = tcV1ChannelSKU.MinPriceUSD;
                            pkpnSet.MaxPriceUSD = tcV1ChannelSKU.MaxPriceUSD;

                            channelSKU.PKPNSetList = new common.PKPNSet[] { pkpnSet };
                            channelSKUs[i] = channelSKU;
                        }
                    }

                    tc.Configure(channelSKUs);
                }
                finally
                {
                    // clear Bahavior Injection
                    RequestHeaderBehaviorInjectionMgr.ClearBehaviorInjections();
                }
            }
            catch (Exception e)
            {
                hr = XRLException.ToHResult(e, HResult.XONLINE_E_MIX_UNKNOWNERROR);
                err = e.Message;
                throw;
            }
            finally
            {
                WriteToLog(ConfigureTokenCategoryApiName, hr, err, timeElapsed.MillisecondsElapsed, tcV1, tc);
            }
        }

        public TokenCategoryV1 GetTokenCategoryById(Guid id)
        {
            HResult hr = HResult.S_OK;
            string err = string.Empty;
            XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();

            TokenCategoryV1 tcV1 = null;
            try
            {
                WebSgApiCheck(GetTokenCategoryApiName);

                common.TokenCategory tc = common.TokenCategory.GetTokenCategory(id);
                tcV1 = CreateTokenCategoryV1FromInternal(tc);
            }
            catch (Exception e)
            {
                hr = XRLException.ToHResult(e, HResult.XONLINE_E_MIX_UNKNOWNERROR);
                err = e.Message;
                throw;
            }
            finally
            {
                WriteToLog( MixTokenManagementV1.GetTokenCategoryByIdApiName, hr, err, timeElapsed.MillisecondsElapsed, id, tcV1);
            }

            return tcV1;
        }

        public TokenCategoryV1 GetTokenCategoryByName(string name)
        {
            HResult hr = HResult.S_OK;
            string err = string.Empty;
            XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();

            TokenCategoryV1 tcV1 = null;
            try
            {
                WebSgApiCheck(GetTokenCategoryApiName);

                common.TokenCategory tc = common.TokenCategory.GetTokenCategory(name);
                tcV1 = CreateTokenCategoryV1FromInternal(tc);
            }
            catch (Exception e)
            {
                hr = XRLException.ToHResult(e, HResult.XONLINE_E_MIX_UNKNOWNERROR);
                err = e.Message;
                throw;
            }
            finally
            {
                WriteToLog( MixTokenManagementV1.GetTokenCategoryByNameApiName, hr, err, timeElapsed.MillisecondsElapsed, SerializeTokenObjects(name), tcV1);
            }

            return tcV1;
        }

        public TokenCategoryV1[] GetTokenCategoryByOffer(Guid offerId)
        {
            HResult hr = HResult.S_OK;
            string err = string.Empty;
            XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();

            TokenCategoryV1[] tcV1Array = new TokenCategoryV1[0];

            try
            {
                WebSgApiCheck(GetTokenCategoryApiName);

                if (offerId.Equals(Guid.Empty))
                {
                    throw new XRLExceptionWithoutEvent(HResult.E_INVALIDARG, "offerId cannot be equivalent to Guid.Empty");
                }

                List<common.TokenCategory> tcList = common.TokenCategory.GetTokenCategories(offerId);
                tcV1Array = new TokenCategoryV1[tcList.Count];
                for (int i = 0; i < tcList.Count; i++)
                {
                    tcV1Array[i] = CreateTokenCategoryV1FromInternal(tcList[i]);
                }
            }
            catch (Exception e)
            {
                hr = XRLException.ToHResult(e, HResult.XONLINE_E_MIX_UNKNOWNERROR);
                err = e.Message;
                throw;
            }
            finally
            {
                WriteToLog(GetTokenCategoryByOfferApiName, hr, err, timeElapsed.MillisecondsElapsed, offerId, tcV1Array);
            }

            return tcV1Array;
        }

        /// <summary>
        /// Returns TokenInfoV1 object for given clear text token
        /// </summary>
        /// <param name="token">clear text token as input parameter</param>
        /// <returns>TokenInfoV1 object</returns>
        public TokenInfoV1 GetTokenInfoByToken(string token)
        {
            HResult hr = HResult.S_OK;
            string err = string.Empty;
            XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();

            TokenInfoV1 tokenInfoV1 = null;

            try
            {
                WebSgApiCheck(GetTokenInfoApiName);

                // sanity check for input parameter
                if (String.IsNullOrEmpty(token))
                {
                    string exMessage = "token value is missing in GetTokenInfo(string token) method call";
                    throw new XRLExceptionWithoutEvent(HResult.E_INVALIDARG, exMessage);
                }
                common.TokenInfo tokenInfo = common.TokenInfo.GetTokenInfo(token);
                tokenInfoV1 = CreateTokenInfoV1FromInternal(tokenInfo);
            }
            catch (Exception e)
            {
                hr = XRLException.ToHResult(e, HResult.XONLINE_E_MIX_UNKNOWNERROR);
                err = e.Message;
                throw;
            }
            finally
            {
                WriteToLog( MixTokenManagementV1.GetTokenInfoByTokenApiName, hr, err, timeElapsed.MillisecondsElapsed, tokenInfoV1);
            }

            return tokenInfoV1;
        }

        /// <summary>
        /// Returns TokenInfoV1 object for given tokenHash value
        /// </summary>
        /// <param name="tokenHash">the hash value of token</param>
        /// <returns>TokenInfoV1 object</returns>
        public TokenInfoV1 GetTokenInfoByHash(byte[] tokenHash)
        {
            HResult hr = HResult.S_OK;
            string err = string.Empty;
            XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();

            TokenInfoV1 tokenInfoV1 = null;
            try
            {
                WebSgApiCheck(GetTokenInfoApiName);

                // "not null" sanity check for input parameter tokenHash
                if (tokenHash == null)
                {
                    string exMessage = "tokenHash value is missing in GetTokenInfo(byte[] tokenHash) method call";
                    throw new XRLExceptionWithoutEvent(HResult.E_INVALIDARG, exMessage);
                }

                // sanity check for input parameter to be exactly 20 bytes long
                if (tokenHash.Length != 20)
                {
                    string exMessage = "Invalid tokenHash value (must be 20 bytes) in GetTokenInfo(byte[] tokenHash) method call";
                    throw new XRLExceptionWithoutEvent(HResult.E_INVALIDARG, exMessage);
                }

                common.TokenInfo tokenInfo = common.TokenInfo.GetTokenInfo(tokenHash);
                tokenInfoV1 = CreateTokenInfoV1FromInternal(tokenInfo);
            }
            catch (Exception e)
            {
                hr = XRLException.ToHResult(e, HResult.XONLINE_E_MIX_UNKNOWNERROR);
                err = e.Message;
                throw;
            }
            finally
            {
                WriteToLog( MixTokenManagementV1.GetTokenInfoByHashApiName, hr, err, timeElapsed.MillisecondsElapsed, tokenHash, tokenInfoV1);
            }
            return tokenInfoV1;
        }

        public TokenJobV1 GenerateTokens(Guid tokenCategoryId, uint numTokens, byte[] key, bool isTest)
        {
            HResult hr = HResult.S_OK;
            string err = string.Empty;
            XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();

            TokenJobV1 tokenJobV1 = null;
            try
            {
                WebSgApiCheck(GenerateTokensApiName);

                // sanity check for input parameter
                if (numTokens == 0)
                {
                    throw new XRLExceptionWithoutEvent(HResult.E_INVALIDARG, "numTokens must be greater than zero");
                }

                if (tokenCategoryId.Equals(Guid.Empty))
                {
                    throw new XRLExceptionWithoutEvent(HResult.E_INVALIDARG, "tokenCategoryId cannot be equivalent to Guid.Empty");
                }

                if (key == null || key.Length == 0 || key.Length > common.TokenJob.MaxKeyLength)
                {
                    throw new XRLExceptionWithoutEvent(HResult.E_INVALIDARG, "key must be non-null and no more than 16 bytes.");
                }

                // add Behavior Injection
                AddBehaviorInjectionSupport();
                try
                {
                    common.TokenCategory tc = common.TokenCategory.GetTokenCategory(tokenCategoryId);

                    if (DateTime.UtcNow >= tc.ExpirationDate)
                    {
                        throw new XRLExceptionWithoutEvent(HResult.XONLINE_E_TOKEN_EXPIRED_TOKEN_CATEGORY, "GenerateTokens: cannot generate tokens for an expired token category. Token category {0} expired on {1}", tokenCategoryId.ToString(), tc.ExpirationDate.ToString("s"));
                    }

                    // at the moment, LIVE token generation does not support subscription or points bundle tokens
                    if (CatalogUtil.IsSubscriptionMediaType((int)tc.MediaTypeId) || CatalogUtil.IsPointsBundleMediaType((int)tc.MediaTypeId))
                    {
                        throw new XRLExceptionWithoutEvent(HResult.E_INVALIDARG, "{0}: Invalid media type: {1}. Generating tokens for subscription and points bundle are not yet supported.", GenerateTokensApiName, tc.MediaTypeId);
                    }

                    // save the AlternateBillingUrl to TokenJob if it is available, otherwise check other Behavior Injections
                    string behaviorInjection = BillingProvider.GetSessionAlternateUrl();
                    if (string.IsNullOrEmpty(behaviorInjection))
                    {
                        behaviorInjection = HttpContext.Current.Request.Headers[RequestHeaderBehaviorInjectionMgr.BEHAVIOR_INJECTION_KEY];
                        if (!string.IsNullOrEmpty(behaviorInjection))
                        {
                            behaviorInjection = RequestHeaderBehaviorInjectionMgr.BEHAVIOR_INJECTION_KEY + ":" + behaviorInjection;
                        }
                    }

                    // pad the key with zeros if it is less than the max length
                    byte[] paddedKey = new byte[common.TokenJob.MaxKeyLength];
                    key.CopyTo(paddedKey, 0);

                    common.TokenJob job = new common.TokenJob(Guid.NewGuid(), tc.Id, tc.Pkpn, (int)numTokens, paddedKey, isTest, behaviorInjection);
                    job.RecordJobPending();
                    tokenJobV1 = CreateTokenJobV1FromInternal(job);
                }
                finally
                {
                    // clear Bahavior Injection
                    RequestHeaderBehaviorInjectionMgr.ClearBehaviorInjections();
                }
            }
            catch (Exception e)
            {
                hr = XRLException.ToHResult(e, HResult.XONLINE_E_MIX_UNKNOWNERROR);
                err = e.Message;
                throw;
            }
            finally
            {
                WriteToLog( GenerateTokensApiName, hr, err, timeElapsed.MillisecondsElapsed,
                    tokenCategoryId,
                    numTokens,
                    isTest,
                    tokenJobV1
                );
            }
            return tokenJobV1;
        }

        public TokenJobStatusV1 GetTokenJobStatus(Guid jobId)
        {
            HResult hr = HResult.S_OK;
            string err = string.Empty;
            XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();

            TokenJobStatusV1 tjsV1 = null;

            try
            {
                WebSgApiCheck(GetTokenJobStatusApiName);

                if (jobId.Equals(Guid.Empty))
                {
                    throw new XRLExceptionWithoutEvent(HResult.E_INVALIDARG, "jobId cannot be equivalent to Guid.Empty");
                }

                common.TokenJobStatus tjs = common.TokenJob.GetStatus(jobId);
                tjsV1 = CreateTokenJobStatusV1FromInternal(tjs);
            }
            catch (Exception e)
            {
                hr = XRLException.ToHResult(e, HResult.XONLINE_E_MIX_UNKNOWNERROR);
                err = e.Message;
                throw;
            }
            finally
            {
                WriteToLog( MixTokenManagementV1.GetTokenJobStatusApiName, hr, err, timeElapsed.MillisecondsElapsed, jobId, tjsV1);
            }

            return tjsV1;
        }

        public TokenJobStatusV1[] GetTokenJobStatusByCategory(Guid tokenCategoryId)
        {
            HResult hr = HResult.S_OK;
            string err = string.Empty;
            XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();

            TokenJobStatusV1[] tjsV1Array = new TokenJobStatusV1[0];

            try
            {
                WebSgApiCheck(GetTokenJobStatusApiName);

                if (tokenCategoryId.Equals(Guid.Empty))
                {
                    throw new XRLExceptionWithoutEvent(HResult.E_INVALIDARG, "tokenCategoryId cannot be equivalent to Guid.Empty");
                }

                List<common.TokenJobStatus> tjsList = common.TokenJob.GetStatusByCategory(tokenCategoryId);
                tjsV1Array = new TokenJobStatusV1[tjsList.Count];
                for (int i = 0; i < tjsList.Count; i++)
                {
                    tjsV1Array[i] = CreateTokenJobStatusV1FromInternal(tjsList[i]);
                }
            }
            catch (Exception e)
            {
                hr = XRLException.ToHResult(e, HResult.XONLINE_E_MIX_UNKNOWNERROR);
                err = e.Message;
                throw;
            }
            finally
            {
                WriteToLog(GetTokenJobStatusByCategoryApiName, hr, err, timeElapsed.MillisecondsElapsed, tokenCategoryId, tjsV1Array);
            }
            return tjsV1Array;
        }

        /// <summary>
        /// Return 'count' tokens from an encrypted token file
        /// </summary>
        /// <param name="jobId">Token Job identifier</param>
        /// <param name="key">Encryption key</param>
        /// <param name="start">Token item at which retrieval begins</param>
        /// <param name="count">Number of tokens to retrieve from token file</param>
        /// <returns>TokenEntry[]</returns>
        public TokenEntry[] GetTokens(Guid jobId, byte[] key, int start, int count)
        {
            HResult hr = HResult.S_OK;
            string err = string.Empty;
            XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();

            List<TokenEntry> tokenEntryList = new List<TokenEntry>();

            try
            {
                WebSgApiCheck(GetTokensApiName);

                int maxNumTokens = Config.GetIntSetting("tokenService_maxNumTokens");

                int expectedRetrievedItemCount = 3;

                if ((count <= 0) || (count > maxNumTokens))
                {
                    string exMessage = string.Format("'count' parameter must be greater than zero and less than or equal to {0}", maxNumTokens);
                    throw new XRLExceptionWithoutEvent(HResult.XONLINE_E_TOKEN_REQUESTED_TOKENS_EXCEEDS_MAXIMUM_ALLOWABLE, exMessage);
                }

                if (start <= 0)
                {
                    string exMessage = "'start' parameter must be greater than zero";
                    throw new XRLExceptionWithoutEvent(HResult.XONLINE_E_TOKEN_INVALID_START_PARAMETER, exMessage);
                }

                if (key == null || key.Length == 0 || key.Length > common.TokenJob.MaxKeyLength)
                {
                     throw new XRLExceptionWithoutEvent(HResult.E_INVALIDARG, "key must be non-null and no more than 16 bytes.");
                }

                TokenJobStatusV1 jobStatus = GetTokenJobStatus(jobId);

                if (jobStatus.Status == TokenJobStatusEnumV1.Delivered)
                {
                    string path = common.TokenJob.GetFinalOutputPath(jobId);
                    FileInfo fi = new FileInfo(path);
                    if (!fi.Exists)
                    {
                        string exMessage = string.Format("File Not Found: {0}", path);
                        throw new XRLException(HResult.XONLINE_E_TOKEN_FILE_NOT_FOUND, XEvent.Id.MIX_TOKEN_FILE_NOT_FOUND, exMessage);
                    }

                    byte[] paddedKey = new byte[common.TokenJob.MaxKeyLength];
                    key.CopyTo(paddedKey, 0);

                    using (FileStream inputFile = new FileStream(path, FileMode.Open))
                    using (CryptoStream cryptoStream = common.TokenCrypto.GetTokenFileCryptoStream(inputFile, paddedKey, jobId.ToByteArray(), CryptoStreamMode.Read, PaddingMode.None))
                    using (GZipStream gzipStream = new GZipStream(cryptoStream, CompressionMode.Decompress, false))
                    using (StreamReader sr = new StreamReader(gzipStream))
                    {
                        string line;
                        int lineCount = 0;

                        try
                        {
                            // Three checks are made to ensure that returned token data is valid
                            // 1. Information decrypts without error (failure of this check is most likely due to an incorrect decryption key)
                            // 2. Decrypted information contains 3 items, seperated by commas
                            // 3. The first item is a properly formated 5x5 string
                            //
                            // Check 1. is made when a ReadLine() is made against the encrypted, compressed stream
                            while (((line = sr.ReadLine()) != null) && (tokenEntryList.Count != count))
                            {
                                lineCount++;
                                if (lineCount >= start)
                                {
                                    // Check 2. is made after 'tuple' is populated with data
                                    string[] tuple = line.Split(',');

                                    if (tuple.Length != expectedRetrievedItemCount)
                                    {
                                        string exMessage = string.Format("Retrived data is malformed. It should contain {0} items", expectedRetrievedItemCount);
                                        throw new XRLException(HResult.XONLINE_E_TOKEN_MALFORMED_TOKEN_ENTRY_FOUND, XEvent.Id.MIX_TOKEN_MALFORMED_TOKEN_ENTRY_FOUND, exMessage);
                                    }

                                    // Check 3. is made by investingating tuple[0], which should contain the 5x5 token string
                                    // The valid token format is ?????-?????-?????-?????-????N format. (Last character must be N).
                                    // Where ? is 0-9, A-Z without 0,1,2,5,A,E,I,O,U,N,L,S,Z
                                    // All live generated token will ends with "Z".
                                    bool tokenIsValid = Regex.IsMatch(tuple[0], @"^[0-9A-Z^0125AEIOUNLSZ]{5}-[0-9A-Z^0125AEIOUNLSZ]{5}-[0-9A-Z^0125AEIOUNLSZ]{5}-[0-9A-Z^0125AEIOUNLSZ]{5}-[0-9A-Z^0125AEIOUNLSZ]{4}Z$");
                                    if (!tokenIsValid)
                                    {
                                        string exMessage = string.Format("Retrived data is malformed. It should contain {0} items", expectedRetrievedItemCount);
                                        throw new XRLExceptionWithoutEvent(HResult.XONLINE_E_BAD_CONTENT_TYPE, exMessage);
                                    }


                                    TokenEntry tokenEntry = new TokenEntry();
                                    tokenEntry.Token = tuple[0];
                                    tokenEntry.Pkpn = tuple[1];
                                    tokenEntry.SequenceNumber = Convert.ToUInt32(tuple[2]);

                                    // ToDo: Format Check here

                                    tokenEntryList.Add(tokenEntry);
                                }
                            }
                        }
                        catch
                        {
                            string exMessage = "Decryption Error";
                            throw new XRLException(HResult.XONLINE_E_TOKEN_FILE_COULD_NOT_BE_DECRYPTED, XEvent.Id.MIX_TOKEN_FILE_DECRYPTION_ERROR, exMessage);
                        }

                        if (tokenEntryList.Count != count)
                        {
                            string exMessage = string.Format("End Of File reached before 'count' [{0}] tokens retrieved", count);
                            throw new XRLException(HResult.XONLINE_E_TOKEN_EOF_REACHED_BEFORE_ALL_TOKENS_RETRIEVED, XEvent.Id.MIX_TOKEN_EOF_REACHED_BEFORE_ALL_TOKENS_RETRIEVED, exMessage);
                        }
                    }
                }
                else
                {
                    string exMessage = string.Format("Job {0} not in 'Delivered' state", count);
                    throw new XRLException(HResult.XONLINE_E_TOKEN_JOB_NOT_IN_REQUIRED_STATE, XEvent.Id.MIX_TOKEN_JOB_NOT_IN_REQUIRED_STATE, exMessage);
                }
            }
            catch (Exception e)
            {
                hr = XRLException.ToHResult(e, HResult.XONLINE_E_MIX_UNKNOWNERROR);
                err = e.Message;
                throw;
            }
            finally
            {
                // As there can be large number of tokens generated, instead of filling the log file
                // we are just logging the count of tokens returned in the array
                WriteToLog(GetTokensApiName, hr, err, timeElapsed.MillisecondsElapsed, jobId, start, count, tokenEntryList.Count);
            }

            return tokenEntryList.ToArray();
        }

        #endregion APIs

        // Helpers functions:
        //
        // Contains helper functions such as CreateTokenxxxV1FromInternal group of methods
        // to convert common.TokenXXX objects to WCF form

        #region Helpers

        private static void AddBehaviorInjectionSupport()
        {
            // ensure BdkWrapper has initialized and installed the Marketplace-specifc ScsFailure behavior injection classes
            BdkWrapper.Init();

            // add Behavior Injection
            RequestHeaderBehaviorInjectionMgr.AddBehaviorInjections(HttpContext.Current.Request.Headers);

            // In test environments (BillingConfig.AllowUrlOverrideInRequest=true)
            // we support the AlternateBillingUrl header which can be used to redirect
            // requests to a different billing url for a single request
            BillingProvider.ResetSessionAlternateUrl();
            UrlRedirect alternateUrl = null;
            if (RequestHeaderBehaviorInjectionMgr.TryGetBehaviorInjection("AlternateBillingUrl", out alternateUrl))
            {
                if (BillingConfig.AllowUrlOverrideInRequest)
                {
                    BillingProvider.SetSessionAlternateUrl(alternateUrl.Url);
                }
            }
        }

        private void WebSgApiCheck(string api)
        {
            try
            {
                Utilities.Instance.CheckAPI(api);
            }
            catch (XboxWebInternalException ex)
            {
                throw new XRLException(HResult.XONLINE_E_MIX_WEBSGVALIDATIONERROR, XEvent.Id.MIX_WEBSGVALIDATION_HEADERINVALID, string.Format("Partner Validation did not pass, WebSG header information missing {0}", ex.Message), false);
            }
            catch (XboxWebException ex)
            {
                //catches incorrect IP information
                throw new XRLException(HResult.XONLINE_E_MIX_WEBSGVALIDATIONERROR, XEvent.Id.MIX_WEBSGVALIDATION_HEADERINVALID, string.Format("Partner Validation did not pass, WebSG header information missing {0}", ex.Message), false);
            }
            catch (KeyNotFoundException ex)
            {
                throw new XRLException(HResult.XONLINE_E_MIX_WEBSGVALIDATIONERROR, XEvent.Id.MIX_WEBSGVALIDATION_HEADERMISSING, string.Format("Partner Validation did not pass, WebSG header information invalid {0}", ex.Message), false);
            }
        }

        /// <summary>
        /// Creates the V1 data object from its internal common.TokenCategory object
        /// </summary>
        /// <param name="tc">common.TokenCategory</param>
        /// <returns>TokenCategoryV1 object</returns>
        private TokenCategoryV1 CreateTokenCategoryV1FromInternal(common.TokenCategory tc)
        {
            TokenCategoryV1 tcV1 = new TokenCategoryV1();
            tcV1.TokenCategoryId = tc.Id;
            tcV1.TokenCategoryName = tc.Name;
            tcV1.ExpirationDate = tc.ExpirationDate;
            tcV1.OfferId = tc.OfferId;
            tcV1.PromotionId = tc.PromotionId;
            tcV1.ProductTypeId = tc.MediaTypeId;
            tcV1.InCsat = tc.InCsat;
            tcV1.IsRsm = tc.IsRsm;
            tcV1.Pkpn = tc.Pkpn;
            tcV1.ChannelTypeId = tc.ChannelTypeId;
            tcV1.IsRevenueBearing = tc.IsRevenueBearing;
            tcV1.IsRoyaltyBearing = tc.IsRoyaltyBearing;
            tcV1.IsRedeemable = tc.IsRedeemable;

            return tcV1;
        }

        /// <summary>
        /// Creating the V1 style TokenInfoV1 object
        /// from internal common.TokenInfo object
        /// </summary>
        /// <param name="tokenInfo">common.TokenInfo object</param>
        /// <returns></returns>
        private TokenInfoV1 CreateTokenInfoV1FromInternal(common.TokenInfo tokenInfo)
        {
            TokenInfoV1 tiV1 = new TokenInfoV1();
            tiV1.Category = CreateTokenCategoryV1FromInternal(tokenInfo.Category);
            tiV1.Hash = tokenInfo.Hash;
            tiV1.StatusId = tokenInfo.StatusId;
            tiV1.UseCount = tokenInfo.UseCount;
            tiV1.ConsoleVersion = tokenInfo.ConsoleVersion;
            tiV1.SequenceNumber = tokenInfo.SequenceNumber;
            tiV1.Redemptions = CreateTokenRedemptionV1FromInternal(tokenInfo.Redemptions);

            return tiV1;
        }

        /// <summary>
        /// Creating the V1 style object collection
        /// from internal common.TokenRedemption[] collection
        /// </summary>
        /// <param name="redemption">common.TokenRedemption[]</param>
        /// <returns>TokenRedemptionV1[] as Array[]</returns>
        private TokenRedemptionV1[] CreateTokenRedemptionV1FromInternal(common.TokenRedemption[] redemption)
        {
            // if redemption object collection is empty - return null rather than empty Array[]
            if (redemption == null) return null;

            List<TokenRedemptionV1> trdmV1 = new List<TokenRedemptionV1>();

            // looping thru all redemption objects in collection and converting them to WCF standard
            foreach (common.TokenRedemption tr in redemption)
            {
                TokenRedemptionV1 trV1 = new TokenRedemptionV1();
                trV1.UserPuid = tr.UserPuid;
                trV1.DateRedeemed = tr.DateRedeemed;

                trdmV1.Add(trV1);
            }

            return trdmV1.ToArray();
        }


        // Creating the V1 token job object from our internal data
        private TokenJobV1 CreateTokenJobV1FromInternal(xonline.common.token.TokenJob tj)
        {
            TokenJobV1 tjV1 = new TokenJobV1();
            tjV1.TokenJobId = tj.Id;
            tjV1.TokenCategoryId = tj.TokenCategoryId;
            tjV1.NumTokensRequested = (uint) tj.NumTokensRequested;
            return tjV1;
        }

        /// <summary>
        /// Creates the V1 data object from its internal common.TokenJobStatus object
        /// </summary>
        /// <param name="tjs">common.TokenJobStatus</param>
        /// <returns>TokenJobStatusV1 object</returns>
        private TokenJobStatusV1 CreateTokenJobStatusV1FromInternal(common.TokenJobStatus tjs)
        {
            TokenJobStatusV1 tjsV1 = new TokenJobStatusV1();
            tjsV1.TokenJobId = tjs.Id;
            tjsV1.Status = (TokenJobStatusEnumV1) tjs.Status;
            tjsV1.LastActivity = tjs.LastActivity;
            tjsV1.IsStale = tjs.JobIsStale;
            tjsV1.NumTokensRequested = (uint) tjs.NumTokensRequested;
            tjsV1.NumTokensCompleted = (uint) tjs.NumTokensCompleted;
            tjsV1.Submitted = tjs.Submitted;
            tjsV1.NumFailures = (uint) tjs.NumFailures;
            tjsV1.NextProcessing = tjs.NextProcessing;
            tjsV1.IsTest = tjs.IsTest;
            tjsV1.TokenFile = tjs.TokenFile;
            tjsV1.HashFile = string.Empty;
            return tjsV1;
        }

        /// <summary>
        /// Write the objects to the log file
        /// </summary>
        /// <param name="ApiName">Name of the API requesting the logging</param>
        /// <param name="objectsToSerialize">Array of objects to write to log file. Each object is written on separate line.</param>
        private void WriteToLog( string apiName, HResult hr, string err, long millisecondsElapsed, params Object[] objectsToSerialize)
        {
            StringBuilder buffer = new StringBuilder();
            string delimiter = " ";

            foreach (Object objectToSerialize in objectsToSerialize)
            {
                buffer.Append(delimiter + SerializeTokenObjects(objectToSerialize));
                delimiter = xonline.mix.common.MixConstants.AppLogSeparator;
            }
            WriteToLog(apiName, hr, err, millisecondsElapsed, buffer.ToString());
        }

        /// <summary>
        /// Write the objects to the log file
        /// </summary>
        /// <param name="apiName">Name of the API requesting the logging</param>
        /// <param name="objectToSerialize">Object to write to log file.</param>
        private void WriteToLog(string apiName, HResult hr, string err, long millisecondsElapsed, Object objectToSerialize)
        {
            WriteToLog(apiName, hr, err, millisecondsElapsed, SerializeTokenObjects(objectToSerialize));
        }

        /// <summary>
        /// Write the objects to the log file
        /// </summary>
        /// <param name="apiName">Name of the API requesting the logging</param>
        /// <param name="stringToLog">string to write to log file.</param>
        private void WriteToLog(string apiName, HResult hr, string err, long millisecondsElapsed, string stringToLog)
        {
            // Logging API name and input parameters
            string appLog = string.Join(xonline.mix.common.MixConstants.AppLogSeparator, new string[]
                        {
                            apiName,
                            hr.ToString(),
                            err,
                            millisecondsElapsed.ToString("d"),
                            stringToLog
                        });

            Xom.Log(XomAreaName.log, appLog);
        }

        /// <summary>
        /// Serializing Token objects for logging.
        /// Using the XML serializer instead of DataContractSerializer to avoid
        /// serialization issues for collections.
        /// </summary>
        /// <param name="objectToSerialize">Object</param>
        private string SerializeTokenObjects(Object objectToSerialize)
        {
            string serializedTokenCategory = string.Empty;

            XmlDocument xmlDocument = new XmlDocument();
            if (null != objectToSerialize)
            {
                StringBuilder stringBuilder = new StringBuilder();
                using (StringWriterUTF8 stringWriter = new StringWriterUTF8(stringBuilder))
                {
                    XmlSerializer xmlSerializer = new XmlSerializer(objectToSerialize.GetType());
                    try
                    {
                        xmlSerializer.Serialize(stringWriter, objectToSerialize);
                    }
                    catch (InvalidOperationException ioe)
                    {
                        Xom.NtEvent(XEvent.Id.MIX_TOKEN_MANAGEMENT_SERIALIZATION_ERROR, ioe, "There was an error serializing the object.");
                    }
                }
                xmlDocument.PreserveWhitespace = false;
                xmlDocument.LoadXml(stringBuilder.ToString());
            }
            serializedTokenCategory = xmlDocument.OuterXml;

            return serializedTokenCategory;
        }

        #endregion helpers
    }

    /// <summary>
    /// Implements a StringWriter for writing an xml document to a UTF8 string
    /// </summary>
    internal class StringWriterUTF8 : StringWriter
    {
        /// <summary>
        /// encoding is the encoding in which the output is written
        /// </summary>
        private Encoding encoding = Encoding.UTF8;

        /// <summary>
        /// Initializes a new instance of the StringWriterUTF8 class
        /// </summary>
        /// <param name="stringBuilder">The StringBuilder to write to</param>
        public StringWriterUTF8(StringBuilder stringBuilder)
            : base(stringBuilder)
        {
        }

        /// <summary>
        /// Gets the encoding in which the output is written
        /// </summary>
        public override Encoding Encoding
        {
            get { return this.encoding; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\perfapp\perfapi.cpp ===
//+-------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1996 - 2000
//
//  File:       perfapi.cpp
//
//  Classes:    
//
//  Contents:   This file implements the standard interfaces a performance
//              monitor program expects -- open, collect, and close. It also
//              implements the interface to create and destroy performance
//              objects, counters, and instances.
//
//--------------------------------------------------------------------------


#include "perfappp.h"


//+------------------------------------------------------------------------
//
//  Function:   CreatePerfObject
//
//  Synopsis:   Create a performance object
//
//-------------------------------------------------------------------------
extern "C"
PERF_APP_API HANDLE
CreatePerfObject( DWORD dwIndex, DWORD dwNumCounters, PVOID *ppvObjectStart )
{
    return( g_PerfObjects.CreatePerfObject( dwIndex, dwNumCounters, ppvObjectStart ) );
}


//+------------------------------------------------------------------------
//
//  Function:   OpenPerfObject
//
//  Synopsis:   Open an existing performance object
//
//-------------------------------------------------------------------------
extern "C"
PERF_APP_API HANDLE
OpenPerfObject( DWORD dwIndex, PVOID *ppvObjectStart )
{
    return( g_PerfObjects.OpenPerfObject( dwIndex, ppvObjectStart ) );
}


//+------------------------------------------------------------------------
//
//  Function:   DestroyPerfObject
//
//  Synopsis:   Delete a performance object
//
//-------------------------------------------------------------------------
extern "C"
PERF_APP_API BOOL
DestroyPerfObject( HANDLE hObjHandle )
{
    return( g_PerfObjects.DestroyPerfObject( hObjHandle ) );
}

//+------------------------------------------------------------------------
//
//  Function:   DestroyAllPerfObjects
//
//  Synopsis:   Deletes all performance objects
//
//-------------------------------------------------------------------------
extern "C"
PERF_APP_API void
DestroyAllPerfObjects()
{
    g_PerfObjects.DestroyAllPerfObjects();
}


//+------------------------------------------------------------------------
//
//  Function:   CreatePerfCounter
//
//  Synopsis:   Create a performance counter
//
//-------------------------------------------------------------------------
extern "C"
PERF_APP_API DWORD
CreatePerfCounter( DWORD dwType, DWORD dwScale, DWORD dwSize,
                   HANDLE hObject, DWORD dwIndex, HANDLE *phMutex )
{
    return( g_PerfObjects.CreatePerfCounter( dwType, dwScale, dwSize, hObject,
                                             dwIndex, phMutex ) );
}


//+------------------------------------------------------------------------
//
//  Function:   DestroyPerfCounter
//
//  Synopsis:   Delete a performance counter
//
//-------------------------------------------------------------------------
extern "C"
PERF_APP_API BOOL
DestroyPerfCounter( HANDLE hCounterHandle, LPVOID pvUserCounterData )
{
    return( g_PerfObjects.DestroyPerfCounter( hCounterHandle, pvUserCounterData ) );
}


//+------------------------------------------------------------------------
//
//  Function:   CreateObjectInstance
//
//  Synopsis:   Create a performance instance
//
//-------------------------------------------------------------------------
extern "C"
PERF_APP_API DWORD
CreateObjectInstance( HANDLE hObject, PWCHAR pszName, PVOID *ppvInstanceName, PVOID *ppvInstanceStart)
{
    return( g_PerfObjects.CreateObjectInstance( hObject, pszName, ppvInstanceName, ppvInstanceStart ) );
}

//+------------------------------------------------------------------------
//
//  Function:   RenameObjectInstance
//
//  Synopsis:   Rename a performance instance
//
//-------------------------------------------------------------------------
extern "C"
PERF_APP_API void
RenameObjectInstance( HANDLE hObject, PWCHAR pszNewName, BYTE *pNameAddrInPerf )
{
    g_PerfObjects.RenameObjectInstance( hObject, pszNewName, pNameAddrInPerf );
}

//+------------------------------------------------------------------------
//
//  Function:   DestroyObjectInstance
//
//  Synopsis:   Delete a performance instance
//
//-------------------------------------------------------------------------
extern "C"
PERF_APP_API BOOL
DestroyObjectInstance( HANDLE hObjectHandle, DWORD dwInstanceID )
{
    return( g_PerfObjects.DestroyObjectInstance( hObjectHandle, dwInstanceID ) );
}


//+------------------------------------------------------------------------
//
//  Function:   AppPerfOpen
//
//  Synopsis:   Standard open function for performance monitor program
//
//-------------------------------------------------------------------------
extern "C"
DWORD WINAPI
AppPerfOpen( LPWSTR lpDeviceNames )
{
    return( g_PerfObjects.AppPerfOpen() );
}


//+------------------------------------------------------------------------
//
//  Function:   AppPerfCollect
//
//  Synopsis:   Standard collect function for performance monitor program
//
//-------------------------------------------------------------------------
extern "C"
DWORD WINAPI
AppPerfCollect( LPWSTR lpwszValue, LPVOID *lppData,
                LPDWORD lpcbBytes, LPDWORD lpcObjectTypes )
{
    DWORD   dwErrorCode;
    LPVOID  lpBuffer;
    LPWSTR  lpwszForeign;
    
    if( lppData == NULL || *lppData == NULL || lpcbBytes == NULL )
    {
        return( ERROR_MORE_DATA );
    }

    lpwszForeign = wcsstr( lpwszValue, L"Foreign " );
    if( NULL != lpwszForeign && lpwszForeign == lpwszValue )
    {
        // It does not process "Foreign" request.
        *lpcbBytes = 0;
        *lpcObjectTypes = 0;
        dwErrorCode = ERROR_SUCCESS;
    }
    else
    {
        lpBuffer = *lppData;
        dwErrorCode = g_PerfObjects.AppPerfCollect( lpBuffer, *lpcbBytes, lpcObjectTypes );
        if( ERROR_SUCCESS == dwErrorCode )
        {
            // As part of the spec, update lppData only when it succeeds.
            *lppData = lpBuffer;
        }
    }

    return( dwErrorCode );
}


//+------------------------------------------------------------------------
//
//  Function:   AppPerfClose
//
//  Synopsis:   Standard close function for performance monitor program
//
//-------------------------------------------------------------------------
extern "C"
DWORD WINAPI
AppPerfClose()
{
    return( g_PerfObjects.AppPerfClose() );
}


//+------------------------------------------------------------------------
//
//  Function:   GetInstanceCount
//
//  Synopsis:   Return the number of perf instances currently existing
//
//-------------------------------------------------------------------------
extern "C"
PERF_APP_API HRESULT
GetInstanceCount( DWORD dwObjectRelativeID, DWORD *pdwInstanceCount )
{
    return( g_PerfObjects.GetInstanceCount( dwObjectRelativeID, pdwInstanceCount ) );
}


//+------------------------------------------------------------------------
//
//  Function:   GetInstanceName
//
//  Synopsis:   Return the name of an instance
//
//-------------------------------------------------------------------------
extern "C"
PERF_APP_API HRESULT
GetInstanceName( DWORD dwObjectRelativeID, DWORD dwInstanceID, LPWSTR pwszInstanceName, DWORD *pcchNameLength )
{
    return( g_PerfObjects.GetInstanceName( dwObjectRelativeID, dwInstanceID, pwszInstanceName, pcchNameLength ) );
}


//+------------------------------------------------------------------------
//
//  Function:   GetCounterValue
//
//  Synopsis:   Return the value of a counter in a QWORD, with a flag to show it's a DWORD
//
//-------------------------------------------------------------------------
extern "C"
PERF_APP_API HRESULT
GetCounterValue( DWORD dwObjectRelativeID, DWORD dwInstanceID, DWORD dwCounterRelativeID, BOOL *pfIsDWORD, QWORD *pqwValue )
{
    return( g_PerfObjects.GetCounterValue( dwObjectRelativeID, dwInstanceID, dwCounterRelativeID, pfIsDWORD, pqwValue ) );
}


//+------------------------------------------------------------------------
//
//  Function:   GetCounterBasis
//
//  Synopsis:   Returns registry information about our perf counters.
//
//-------------------------------------------------------------------------
extern "C"
PERF_APP_API HRESULT 
GetCounterBasis( DWORD &dwFirstCounter, DWORD &dwLastCounter, DWORD &dwFirstHelp, DWORD &dwLastHelp )
{
    return( g_PerfReg.GetCounterBasis( dwFirstCounter, dwLastCounter, dwFirstHelp, dwLastHelp ) );
}


//+------------------------------------------------------------------------
//
//  Function:   CPerfObjects::AppPerfOpen
//
//  Synopsis:   Initialize performance capability for a performance
//              monitor program.
//
//-------------------------------------------------------------------------
DWORD
CPerfObjects::AppPerfOpen()
{
    DWORD dwErrorCode = ERROR_SUCCESS;
    
    // If we want to set the shared memory to read only, we need to figure
    // out another way to initialize the memory (to all zeros) if the
    // performance monitor program is launched first.
    // NOTE: if the memory is already mapped, MapPerfInfoMemory is basically a noop.
    if ( !MapPerfInfoMemory( FALSE /*don't create the memory*/) ) {
        dwErrorCode = GetLastError();
    }

    return( dwErrorCode );

}


//+------------------------------------------------------------------------
//
//  Function:   CPerfObjects::AppPerfCollect
//
//  Synopsis:   Collect counter information of all performance objects
//              and put it in the standard format defined in winperf.h
//
//-------------------------------------------------------------------------
DWORD
CPerfObjects::AppPerfCollect( LPVOID &pvData, DWORD &dwNumBytes, LPDWORD pdwObjectTypes )
{
    CPerfObj   *pObj;
    LPBYTE      pbBuffer;
    DWORD       dwErrorCode;
    DWORD       dwBytesWritten;
    DWORD       dwTotalBytesWritten;
    DWORD       dwBufferSize;
    DWORD       dwTempObjTypes;
    DWORD       dwObjIndex;
    DWORD       dwAbsIndex;

    // If the performance monitor program didn't call AppPerfOpen(), call
    // the function for it.
    if ( NULL == m_pPerfInfo )
    {
        dwErrorCode = AppPerfOpen();
        if( ERROR_SUCCESS != dwErrorCode )
        {
            dwNumBytes = 0;
            if( NULL != pdwObjectTypes )
            {
                *pdwObjectTypes = 0;
            }
            return( ERROR_SUCCESS );
        }
    }

    // This is a common case: no object is created.
    if( 0 == m_pPerfInfo->m_dwNumObjects )
    {
        dwNumBytes = 0;
        if( NULL != pdwObjectTypes )
        {
            *pdwObjectTypes = 0;
        }
        return( ERROR_SUCCESS );
    }

    dwTotalBytesWritten = 0;
    dwTempObjTypes = 0;
    dwBufferSize = dwNumBytes;
    pbBuffer = (LPBYTE) pvData;

    // Loop through all the objects.
    for( dwObjIndex = 0, dwAbsIndex = 0;
       ( dwObjIndex < m_pPerfInfo->m_dwNumObjects) && ( dwAbsIndex < MAX_PERF_OBJECTS ); 
         dwAbsIndex++ )
    {
        pObj = m_pPerfObj + dwAbsIndex;

        // Is this object being used?
        if( !pObj->IsInUse() )
        {
            continue;
        }

        dwObjIndex++;

        // Lock the mutex of this object so that nobody else can change
        // it while we collecting data.
        WaitForSingleObject( pObj->GetDataMutex(), INFINITE );
        dwErrorCode = pObj->CollectPerfData( pbBuffer, dwBufferSize, dwBytesWritten );
        ReleaseMutex( pObj->GetDataMutex() );

        if( ERROR_SUCCESS != dwErrorCode )
        {
            dwNumBytes = 0;
            if( NULL != pdwObjectTypes )
            {
                *pdwObjectTypes = 0;
            }
            return( dwErrorCode );
        }

        pbBuffer += dwBytesWritten;
        dwBufferSize -= dwBytesWritten;
        dwTotalBytesWritten += dwBytesWritten;
        ++dwTempObjTypes;
    }

    pvData = pbBuffer;
    dwNumBytes = dwTotalBytesWritten;
    if( NULL != pdwObjectTypes )
    {
        *pdwObjectTypes = dwTempObjTypes;
    }

    return( ERROR_SUCCESS );
}


//+------------------------------------------------------------------------
//
//  Function:   CPerfObjects::AppPerfClose
//
//  Synopsis:   Close and clean up performance related data
//
//-------------------------------------------------------------------------
DWORD
CPerfObjects::AppPerfClose()
{
    UnmapPerfInfoMemory();
    return( ERROR_SUCCESS );
}


//+------------------------------------------------------------------------
//
//  Function:   CPerfObj::CollectPerfData
//
//  Synopsis:   Collect counter information of a performance object
//
//-------------------------------------------------------------------------
DWORD
CPerfObj::CollectPerfData( LPBYTE pbBuffer, DWORD dwBufferSize, DWORD &dwBytesWritten )
{
    DWORD   dwErrorCode;
    DWORD   dwSize;
    DWORD   dwInstanceOffset;
    DWORD   i;
    DWORD   dwID;
    DWORD   dwPadding;
    PPERF_OBJECT_TYPE           pObjType;
    PPERF_COUNTER_BLOCK         pCounterBlock;
    PPERF_COUNTER_DEFINITION    pCounterDef;
    PPERF_INSTANCE_DEFINITION   pInstanceDef;

    if( m_dwUpdateRev < m_pObjInfo->m_dwUpdateRev )
    {
        // Application has changed the mapping. Unmap the old file.
        UnmapDataMemory();
    }

    // If the mapped memory is not initialized, we want to do it now.
    if( !IsMapped() )
    {
        if( !MapDataMemory( FALSE ) )
        {
            dwErrorCode = GetLastError();
            return( dwErrorCode );
        }
    }

    dwBytesWritten = 0;

    // Check if the buffer is big enough.
    if( GetTotalPerfDataSize() > dwBufferSize )
    {
        return( ERROR_MORE_DATA );
    }

    pObjType = (PPERF_OBJECT_TYPE) pbBuffer;
    pObjType->NumCounters = m_pObjInfo->m_dwNumCounters;

    // It is still a success if there is no counter.
    if( 0 == pObjType->NumCounters )
    {
        return( ERROR_SUCCESS );
    }

    // Fill in various fields.
    pObjType->ObjectNameTitleIndex = m_pObjInfo->m_ObjectType.ObjectNameTitleIndex;
    pObjType->ObjectHelpTitleIndex = m_pObjInfo->m_ObjectType.ObjectHelpTitleIndex;
    pObjType->DetailLevel = PERF_DETAIL_NOVICE;
    pObjType->DefaultCounter = 0;
    pObjType->CodePage = 0;
    pObjType->NumInstances = m_pObjInfo->m_dwNumInstances;
    pObjType->TotalByteLength = pObjType->HeaderLength = sizeof(PERF_OBJECT_TYPE);

    QueryPerformanceCounter( &pObjType->PerfTime );
    QueryPerformanceFrequency( &pObjType->PerfFreq );

    pbBuffer += sizeof(PERF_OBJECT_TYPE);

    // Now buffer is pointing the area for counter definitions.
    // Copy all the counter definitions to it.
    dwSize = m_pObjInfo->m_dwNumCounters * sizeof(PERF_COUNTER_DEFINITION);
    memmove( pbBuffer, m_pbCounterDefinitions, dwSize);
    pObjType->TotalByteLength += dwSize;
    pObjType->DefinitionLength = pObjType->TotalByteLength;

    // Set the name and help string pointers to null, since we don't have them.
    // In any case, this information cannot be used by perfmon, since these
    // are local pointers.
    pCounterDef = (PPERF_COUNTER_DEFINITION) pbBuffer;
    for( i = 0; i < m_pObjInfo->m_dwNumCounters; ++i, ++pCounterDef )
    {
        pCounterDef->CounterNameTitle = NULL;
        pCounterDef->CounterHelpTitle = NULL;
    }
        
    pbBuffer += dwSize;
        
    //
    // MarkV - 10/21/98 - we now initialize (N/n)umInstances to 0xffffffff
    // in order to make NT5 happy - treat that value the same as 0.
    //
    if( ( 0 == pObjType->NumInstances ) || ( 0xffffffff == pObjType->NumInstances ) )
    {
        // There is only one instance, and we copy the Counter block of data
        pCounterBlock = (PERF_COUNTER_BLOCK *) pbBuffer;
        pbBuffer += sizeof(PERF_COUNTER_BLOCK);
        dwPadding = 7 - ( ( sizeof(PERF_COUNTER_BLOCK) - 1 ) & 7 );

        // We have to copy the whole data area.
        memcpy( pbBuffer, m_pbCounterData, dwSize = INSTANCE_COUNTER_DATA_SIZE );
        ZeroMemory( pbBuffer + dwSize, dwPadding );

        pbBuffer += dwSize + dwPadding;
        pObjType->TotalByteLength += dwSize + sizeof(PERF_COUNTER_BLOCK) + dwPadding;
        pCounterBlock->ByteLength = dwSize + sizeof(PERF_COUNTER_BLOCK) + dwPadding;
    }
    else
    {
        // It has multiple instances. We need to add PERF_INSTANCE_DEFINITION
        // structure, instance name, counter block, and the data.
        for( i = 0, dwInstanceOffset = 0, dwID = 0; dwID <  (DWORD) pObjType->NumInstances; ++i)
        {
            pInstanceDef = GetInstanceDef( i );
            if( NULL == pInstanceDef )
            {
                ConditionalOutputDebugString(L"Someone has their instances messed up.\n\r");
                return( ERROR_SUCCESS );
            }  
    
            if ( L'\0' != *(WCHAR *)((PBYTE) pInstanceDef + pInstanceDef->NameOffset) )
            {
                // Now we copy a PERF_INSTANCE_DEFINITION and name
                memcpy( pbBuffer, pInstanceDef, pInstanceDef->ByteLength ); 
                pObjType->TotalByteLength += pInstanceDef->ByteLength;
                pbBuffer += pInstanceDef->ByteLength;

                pCounterBlock = (PERF_COUNTER_BLOCK *) pbBuffer;
                pbBuffer += sizeof(PERF_COUNTER_BLOCK);
                dwPadding = 7 - ( ( sizeof(PERF_COUNTER_BLOCK) - 1 ) & 7 );

                memcpy( pbBuffer, m_pbCounterData + dwInstanceOffset, dwSize = INSTANCE_COUNTER_DATA_SIZE);
                ZeroMemory( pbBuffer + dwSize, dwPadding );

                pbBuffer += dwSize + dwPadding;
                pObjType->TotalByteLength += dwSize + sizeof(PERF_COUNTER_BLOCK) + dwPadding;
                pCounterBlock->ByteLength = dwSize + sizeof(PERF_COUNTER_BLOCK) + dwPadding;
                dwID++;
            }
            dwInstanceOffset += m_pObjInfo->m_dwMaxDataSize / MAX_INSTANCES_PER_OBJECT;
        }
    }

    dwBytesWritten = pObjType->TotalByteLength;

    return( ERROR_SUCCESS );
}


//+------------------------------------------------------------------------
//
//  Function:   CPerfObj::GetTotalPerfDataSize
//
//  Synopsis:   Calculate the size of the buffer needed to store the
//              counter information of a performance object.
//
//-------------------------------------------------------------------------
DWORD
CPerfObj::GetTotalPerfDataSize()
{
    PPERF_INSTANCE_DEFINITION   pInstanceDef;
    DWORD   i;
    DWORD   dwID;
    DWORD   dwSize;
    DWORD   dwPadding = 7 - ( ( sizeof(PERF_COUNTER_BLOCK) - 1 ) & 7 );

    dwSize = sizeof(PERF_OBJECT_TYPE) + m_pObjInfo->m_dwNumCounters * sizeof(PERF_COUNTER_DEFINITION);

        
    //
    // MarkV - 10/21/98 - we now initialize m_pObjInfo->m_dwNumInstances to 0xffffffff
    // in order to make NT5 happy - treat that value the same as 0.
    //
    if( ( 0 == m_pObjInfo->m_dwNumInstances ) || ( 0xffffffff == m_pObjInfo->m_dwNumInstances ) )
    {
        // no instance
        dwSize += INSTANCE_COUNTER_DATA_SIZE + sizeof(PERF_COUNTER_BLOCK) + dwPadding;
    }
    else
    {
        // Has at least one instance. The format is different.
        dwSize += m_pObjInfo->m_dwNumInstances * ( INSTANCE_COUNTER_DATA_SIZE + sizeof(PERF_COUNTER_BLOCK) + dwPadding );
                    
                    
        for( i = 0, dwID = 0; dwID < m_pObjInfo->m_dwNumInstances; ++i )
        {
            pInstanceDef = GetInstanceDef( i );
            
            if( NULL == pInstanceDef )
            {
                ConditionalOutputDebugString(L"Someone has their instances messed up, CollectProc()\n\r");
                return ERROR_SUCCESS;          
            }  

            if ( L'\0' != *(WCHAR *)((PBYTE) pInstanceDef + pInstanceDef->NameOffset) )
            {
                dwSize += pInstanceDef->ByteLength;
                dwID++;
            }
        }
    }

    return( dwSize );
}


//+------------------------------------------------------------------------
//
//  Function:   CPerfObjects::GetInstanceCount
//
//  Synopsis:   Return the number of perf instances currently existing
//
//-------------------------------------------------------------------------
HRESULT
CPerfObjects::GetInstanceCount( DWORD dwObjectRelativeID, DWORD *pdwInstanceCount )
{
    HRESULT     hr = S_OK;
    DWORD       dwError = ERROR_SUCCESS;
    DWORD       dwFirstCounter = 0;
    DWORD       dwLastCounter = 0;
    DWORD       dwFirstHelp = 0;
    DWORD       dwLastHelp = 0;
    DWORD       dwObjectID = 0;
    CPerfObj   *pPerfObj = NULL;
    
    if( NULL == pdwInstanceCount )
    {
        return( E_POINTER );
    }

    dwError = g_PerfReg.GetCounterBasis( dwFirstCounter, dwLastCounter, dwFirstHelp, dwLastHelp );
    if( ERROR_SUCCESS != dwError )
    {
        return( HRESULT_FROM_WIN32( dwError ) );
    }

    dwObjectID = dwObjectRelativeID + dwFirstCounter;

    pPerfObj = FindObjectByIndex( dwObjectID );
    if( NULL == pPerfObj )
    {
        return( E_FAIL );
    }

    *pdwInstanceCount = pPerfObj->GetInstanceCount();
    
    return( hr );
}


//+------------------------------------------------------------------------
//
//  Function:   CPerfObjects::GetInstanceName
//
//  Synopsis:   Return the name of an instance
//
//-------------------------------------------------------------------------
HRESULT
CPerfObjects::GetInstanceName( DWORD dwObjectRelativeID, DWORD dwInstanceID, LPWSTR pwszInstanceName, DWORD *pcchNameLength )
{
    HRESULT     hr = S_OK;
    DWORD       dwError = ERROR_SUCCESS;
    DWORD       dwFirstCounter = 0;
    DWORD       dwLastCounter = 0;
    DWORD       dwFirstHelp = 0;
    DWORD       dwLastHelp = 0;
    DWORD       dwObjectID = 0;
    CPerfObj   *pPerfObj = NULL;
    
    if( NULL == pwszInstanceName || NULL == pcchNameLength )
    {
        return( E_POINTER );
    }

    dwError = g_PerfReg.GetCounterBasis( dwFirstCounter, dwLastCounter, dwFirstHelp, dwLastHelp );
    if( ERROR_SUCCESS != dwError )
    {
        return( HRESULT_FROM_WIN32( dwError ) );
    }

    dwObjectID = dwObjectRelativeID + dwFirstCounter;

    pPerfObj = FindObjectByIndex( dwObjectID );
    if( NULL == pPerfObj )
    {
        return( E_FAIL );
    }

    dwError = pPerfObj->GetInstanceName( dwInstanceID, pwszInstanceName, pcchNameLength );
    if( ERROR_SUCCESS != dwError )
    {
        return( E_FAIL );
    }

    return( hr );
}


//+------------------------------------------------------------------------
//
//  Function:   CPerfObjects::GetCounterValue
//
//  Synopsis:   Return the value of a counter in a QWORD, with a flag to show it's a DWORD
//
//-------------------------------------------------------------------------
HRESULT
CPerfObjects::GetCounterValue( DWORD dwObjectRelativeID, DWORD dwInstanceID, DWORD dwCounterRelativeID, BOOL *pfIsDWORD, QWORD *pqwValue )
{
    DWORD       dwError = ERROR_SUCCESS;
    DWORD       dwFirstCounter = 0;
    DWORD       dwLastCounter = 0;
    DWORD       dwFirstHelp = 0;
    DWORD       dwLastHelp = 0;
    DWORD       dwObjectID = 0;
    DWORD       dwCounterID = 0;
    CPerfObj   *pPerfObj = NULL;
    
    if( NULL == pfIsDWORD || NULL == pqwValue )
    {
        return( E_POINTER );
    }

    dwError = g_PerfReg.GetCounterBasis( dwFirstCounter, dwLastCounter, dwFirstHelp, dwLastHelp );
    if( ERROR_SUCCESS != dwError )
    {
        return( HRESULT_FROM_WIN32( dwError ) );
    }

    dwObjectID = dwObjectRelativeID + dwFirstCounter;
    dwCounterID = dwCounterRelativeID + dwFirstCounter;
    
    pPerfObj = FindObjectByIndex( dwObjectID );
    if( NULL == pPerfObj )
    {
        return( E_FAIL );
    }

    dwError = pPerfObj->GetCounterValue( dwInstanceID, dwCounterID, pfIsDWORD, pqwValue );
    if( ERROR_SUCCESS != dwError )
    {
        return( E_FAIL );
    }
    
    return( S_OK );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\perfapp\perfapi.h ===
#pragma once
//+-------------------------------------------------------------------------
//
//  Copyright (c) Microsoft Corporation.  All rights reserved
//
//  File:       perfapi.h
//
//  Classes:    CPerfObj and CPerfObjects
//
//  Contents:   Define interfaces for applications as well as performance
//              monitor programs.
//
//--------------------------------------------------------------------------


#ifndef __PERFAPI_H__
#define __PERFAPI_H__

#include <winperf.h>

#ifndef QWORD
#define QWORD unsigned __int64
#endif 

#define	PERF_APP_API  __declspec(dllexport)

#ifdef __cplusplus
extern "C"  {
#endif

/*
	CreatePerfObject:: Creates a logical perf object, under which one can create 
	counters. This perf object shows up as an object in Perfmon and counters
	show up under it. A maximum number of instances can be specified. (Currently 
	this is hardcoded to 32). And instances can be dynamically created and
	destroyed.

	An object can be removed with the DestroyObject API. The handle returned by
	the MakeObject is used to denote the object. Note this removes all the
	instances (and all the counters) that were associated with the Object.
	All pointers returned by the MakeCounter become invalidated and the risk is
	on the API user not to reference them anymore.
*/

HANDLE  PERF_APP_API CreatePerfObject( DWORD dwIndex, DWORD dwNumCounters, PVOID *ppvObjectStart );
HANDLE  PERF_APP_API OpenPerfObject( DWORD dwIndex, PVOID *ppvObjectStart );
BOOL    PERF_APP_API DestroyPerfObject( HANDLE hObjHandle );

void PERF_APP_API DestroyAllPerfObjects();

/*
	CreatePerfCounter:: Returns the Offset of the counter from the start of the
	object.
*/

DWORD   PERF_APP_API CreatePerfCounter( DWORD dwType, DWORD dwScale, DWORD dwSize, HANDLE hObject, DWORD dwIndex, HANDLE *phMutex );
BOOL    PERF_APP_API DestroyPerfCounter( HANDLE hCounterHandle, LPVOID pvUserCounterData );

/*
	CreateObjectInstance  - creates a new instance of an already existing Object and
	duplicates all its counters, further any counter created for the object gets
	duplicated too. 
	
    If the API failed, return -1. Otherwise return instance id.
	The instance id can be used to Destroy the object instance.
*/

DWORD   PERF_APP_API CreateObjectInstance( HANDLE hObject, PWCHAR pszName, PVOID *ppvInstanceName, PVOID *ppvInstanceStart);
void    PERF_APP_API RenameObjectInstance( HANDLE hObject, PWCHAR pszNewName, BYTE *pNameAddrInPerf );
BOOL    PERF_APP_API DestroyObjectInstance( HANDLE hObjectHandle, DWORD dwInstanceID );

HRESULT PERF_APP_API GetInstanceCount( DWORD dwObjectRelativeID, DWORD *pdwInstanceCount );
HRESULT PERF_APP_API GetInstanceName( DWORD dwObjectRelativeID, DWORD dwInstanceID, LPWSTR pwszInstanceName, DWORD *pcchNameLength );
HRESULT PERF_APP_API GetCounterValue( DWORD dwObjectRelativeID, DWORD dwInstanceID, DWORD dwCounterRelativeID, BOOL *pfIsDWORD, QWORD *pqwValue );

/*
        GetCounterBasis - exposed mainly for error reporting. Will return error code if we 
        failed to open the registry key. Also, will return the exact limits of the indices
        to see if that was the reason something above failed.
*/
HRESULT PERF_APP_API GetCounterBasis( DWORD &dwFirstCounter, DWORD &dwLastCounter, DWORD &dwFirstHelp, DWORD &dwLastHelp );


#ifdef __cplusplus
}
#endif

#endif // __PERFAPI_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\perfapp\perfapp.cpp ===
//+-------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1996 - 2000.
//
//  File:       perfapp.cpp
//
//  Contents:   Implementation of DLL Exports.
//
//--------------------------------------------------------------------------

// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f perfappps.mak in the project directory.

#include "perfappp.h"


HINSTANCE g_hInstance = NULL;

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain( HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/ )
{
    if( DLL_PROCESS_ATTACH == dwReason )
    {
        g_hInstance = hInstance;
        DisableThreadLibraryCalls( hInstance );
    }
    else if( DLL_PROCESS_DETACH == dwReason )
    {
    }
    
    return( TRUE );    // ok
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer( void )
{
    HRESULT hr = S_OK;

    // Try to initialize the perf count with retrys.
    for (int i = 0; i < 12; i++) 
    {
        //
        // Call into the CPerfReg class to ensure we set our special DLL
        // information into the registry. Note that we do not mess with First/Last Counter/Help
        // at this time. This is done by lodctr/unlodctr.
        //
        hr = g_PerfReg.RegisterServer();
        if( !FAILED( hr ) )
        {
            return( hr );
        }

        //
        // We failed to register the perf counters? Lets attempt to unload them
        // in case it is an issue with them not being cleaned up properly
        // 
        g_PerfReg.UnRegisterServer();

        //
        // Put in a delay of 0.5 seconds before we retry
        // 
        Sleep( 500 );
    }
    
    return( hr );
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer( void )
{
    HRESULT hr = S_OK;
    
    //
    // Call into the CPerfReg class to have our registery data removed.  This
    // will kill the HKLM\SYSTEM\CurrentControlSet\Services\* key that we
    // created in the DllRegisterServer() call above. 
    //
    hr = g_PerfReg.UnRegisterServer();
    if( FAILED( hr ) )
    {
        return( hr );
    }


    return( S_OK );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\perfapp\perfappp.h ===
#pragma once


#include <stdlib.h>
#include <stdio.h>
#include <malloc.h>
#include <string.h>

#include <windows.h>
#include <winperf.h>
#include <wchar.h>
#include <assert.h>    
#include <crtdbg.h>
#include <loadperf.h>

#include <wmsstd.h>

#include "svrspec.h"
#include "perfreg.h"
#include "perfobj.h"
#include "perfdbg.h"
#include "perfapi.h"

#include "resource.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\perfapp\perfdbg.h ===
#pragma once
#ifndef __PERFDBG_H__
#define __PERFDBG_H__

void	ConditionalOutputDebugString(LPTSTR string);
void	OutputMultiSzString(LPTSTR strings);

extern	BOOL	fEnableOutputDebugString;

#endif // __PERFDBG_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\perfapp\perfobj.h ===
#pragma once
//+-------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1996 - 2000.
//
//  File:       perfobj.h
//
//  Classes:    CPerfObj and CPerfObjects
//
//  Contents:   Classes that define a performance object and
//              a set of objects
//
//--------------------------------------------------------------------------

#ifndef __PERFOBJ_H__
#define __PERFOBJ_H__

#if DBG
#define _DEBUG                1    // needed for _ASSERT
#endif // DBG


//
// Helper method for dealing with global namespace in Win2K with terminal services.
//
static BOOL IsWindows2000()
{
    OSVERSIONINFO    OSVersionInfo;
    OSVersionInfo.dwOSVersionInfoSize = sizeof (OSVERSIONINFO);
    GetVersionEx (&OSVersionInfo);
    return( ( VER_PLATFORM_WIN32_NT == OSVersionInfo.dwPlatformId ) && ( OSVersionInfo.dwMajorVersion > 4 ) );
}

// MAX_PERF_OBJECTS, MAX_COUNTERS, and MAX_INSTANCES_PER_OBJECT have been moved
// to svrspec.h so that each server can tune these parameters.

#define TEXT_BUFFER_LENGTH                1024

// Counter Definition mapped memory size. We don't store counter names.
#define COUNTER_DEF_MM_SIZE             (MAX_COUNTERS * sizeof(PERF_COUNTER_DEFINITION))

// Instance Definition Mapped MemorySize
#define INSTANCE_DEF_MM_SIZE            (MAX_INSTANCES_PER_OBJECT * (sizeof(PERF_INSTANCE_DEFINITION) + MAX_INSTANCE_NAME * sizeof(WCHAR)))

// !!! Assuming Counters are never > 8 bytes
#define MAX_COUNTER_SIZE                (sizeof(DWORD) * 2)

#define INSTANCE_COUNTER_DATA_SIZE        (MAX_COUNTERS * MAX_COUNTER_SIZE)

#define OBJECT_COUNTER_DATA_SIZE        (MAX_INSTANCES_PER_OBJECT * INSTANCE_COUNTER_DATA_SIZE) 

// {1E5AAD5E-9050-411c-B9BF-75CA582F054C}
DEFINE_GUID(IID_IPerfApp, 0x1e5aad5e, 0x9050, 0x411c, 0xb9, 0xbf, 0x75, 0xca, 0x58, 0x2f, 0x05, 0x4c);


/* Structures */

typedef struct tagOBJECT_PERFINFO {
    PERF_OBJECT_TYPE m_ObjectType;
    BOOL    m_fInUse;                        // object in use
    DWORD    m_dwUpdateRev;                    // revision number of update
    DWORD   m_dwNumCounters;                // number of counters of this object
    DWORD   m_dwNumInstances;                // number of instances of this object
    DWORD   m_dwMaxDataSize;                // maximum data size allowed
    DWORD   m_dwObjectID;                   // Object ID for use in creating shared memory region
} OBJECT_PERFINFO;

typedef struct tagGLOBAL_PERFINFO {
    DWORD   m_dwNumObjects;
} GLOBAL_PERFINFO;

// Classes
class CPerfObj {
  public:
    CPerfObj(void);
    ~CPerfObj(void);
    
    void                        SetObjInfoPtr( GLOBAL_PERFINFO *pPerfInfo, int index );
    BOOL                        MapDataMemory( BOOL fCreate, BOOL fOpenWriteable = FALSE );
    void                        UnmapDataMemory( void );
    BOOL                        InitPerfObject( DWORD dwIndex, DWORD dwMaxCounters );
    BOOL                        OpenPerfObject( DWORD dwIndex );
    BOOL                        DestroyPerfObject( void );
    BOOL                        InitPerfCounter( DWORD dwType, DWORD dwScale, DWORD dwSize, DWORD dwIndex, DWORD &dwCounterDataOffset );
    BOOL                        DestroyPerfCounter( LPVOID pvCounterData );
    DWORD                       InitPerfInstance( LPWSTR pszName, LPVOID *ppvInstanceName, LPVOID *ppvInstanceStart );
    DWORD                       GetNextFreeInstance( void );
    DWORD                       GetInstanceCount( void )        { return( m_pObjInfo->m_dwNumInstances ); }
    BOOL                        DestroyPerfInstance( DWORD dwInstanceID );
    DWORD                       FindCounterByID( DWORD dwCounterID );
    DWORD                       FindInstanceByName( LPWSTR pszName, BOOL fHaveMySelf );
    DWORD                       GetCounterSize( DWORD dwCounterIndex );
    PPERF_INSTANCE_DEFINITION   GetInstanceDef( DWORD dwInstanceID );
    PBYTE                       GetCounterData( void )          { return( m_pbCounterData ); }
    PBYTE                       GetCounterDef( void )           { return( m_pbCounterDefinitions ); }
    DWORD                       GetObjectIndex( void )          { return( m_pObjInfo->m_dwObjectID ); }
    void                        SetObjectIndex( DWORD dwIndex ) { m_pObjInfo->m_dwObjectID = dwIndex; }
    BOOL                        IsInUse( void )                 { return( m_pObjInfo->m_fInUse ); }
    BOOL                        IsMapped( void )                { return( NULL != m_pbCounterData); }
    HANDLE                      GetDataMutex( void )            { return( m_hDataMutex ); }
    DWORD                       CollectPerfData( LPBYTE pbBuffer, DWORD dwBufferSize, DWORD &dwBytesWritten );
    DWORD                       GetTotalPerfDataSize( void );
    DWORD                       GetInstanceName( DWORD dwInstanceID, LPWSTR pwszInstanceName, DWORD *pcchNameLength );
    DWORD                       GetCounterValue( DWORD dwInstanceID, DWORD dwCounterID, BOOL *pfIsDWORD, QWORD *pqwValue );
    
    // For debugging
    void                        DumpCounters( void );
    void                        DumpInstances( void );

  private:
    OBJECT_PERFINFO    *m_pObjInfo;         // point to object info below perfInfo
    PBYTE   m_pbCounterData;                // these three pointers point to various
    PBYTE   m_pbCounterDefinitions;         //   area of a shared memory region
    PBYTE   m_pbInstanceDefinitions;        //   counterData is the starting point
    HANDLE  m_hMMFileHandle;                // handle to the shared memory above
    HANDLE  m_hDataMutex;                   // mutex for data access
    DWORD   m_dwUpdateRev;                  // local update revision number
    DWORD   m_dwIndex;                      // object or counter index

};



class CPerfObjects
{
public:
    CPerfObjects();
    ~CPerfObjects();

    HANDLE  CreatePerfObject( DWORD dwIndex, DWORD dwNumCounters, PVOID *ppvObjectStart );
                                    
    HANDLE  OpenPerfObject( DWORD dwIndex, PVOID *ppvObjectStart );
                                    
    BOOL    DestroyPerfObject( HANDLE hObjHandle );
    
    void    DestroyAllPerfObjects();
    
    DWORD   CreatePerfCounter( DWORD dwType, DWORD dwScale, DWORD dwSize, HANDLE hObject, DWORD dwIndex, HANDLE *phMutex );

    BOOL    DestroyPerfCounter( HANDLE hObjHandle, HANDLE pbCounterData );
    
    DWORD   CreateObjectInstance( HANDLE hObject, PWCHAR pszName, PVOID *ppvInstanceName, PVOID *ppvInstanceStart );

    void    RenameObjectInstance( HANDLE hObject, PWCHAR pszInstNewName, BYTE *pNameAddrInPerf );

    BOOL    DestroyObjectInstance( HANDLE hObject, DWORD dwInstanceID );

    // Support performance monitor program interface.
    DWORD    AppPerfOpen( void );
    DWORD    AppPerfCollect( LPVOID &hData, DWORD &dwNumBytes, LPDWORD pdwObjectTypes);
    DWORD    AppPerfClose( void );

    // Provide simple interface for SNMP collection code.
    HRESULT GetInstanceCount( DWORD dwObjectRelativeID, DWORD *pdwInstanceCount );
    HRESULT GetInstanceName( DWORD dwObjectRelativeID, DWORD dwInstanceID, LPWSTR pwszInstanceName, DWORD *pcchNameLength );
    HRESULT GetCounterValue( DWORD dwObjectRelativeID, DWORD dwInstanceID, DWORD dwCounterRelativeID, BOOL *pfIsDWORD, QWORD *pqwValue );

    // For debugging
    void    DumpCounters( void );
    void    DumpInstances( void );

private:
    BOOL                MapPerfInfoMemory( BOOL fCreate );
    void                UnmapPerfInfoMemory( void );
    CPerfObj           *FindObjectByIndex( DWORD dwIndex );
    CPerfObj           *FindUnusedObject( void );

    GLOBAL_PERFINFO    *m_pPerfInfo;                        // shared info for all processes (mapped memory)
    HANDLE              m_hMMFileHandle;                    // handle to perfInfo mapped memory
    HANDLE              m_hPerfInfoMutex;                   // mutex for m_pPerfInfo;
    CPerfObj            m_pPerfObj[ MAX_PERF_OBJECTS ];     // performance objects
    BOOL                m_bMMFileHandleReadOnly;            // Indicates if the shared memory is read-only

    volatile LONG m_lPerfMemRefCount;

    friend class CPerfObj;
};

extern    SECURITY_ATTRIBUTES g_SecurityAttributes;     // global security attributes (shared memory, mutexes, etc.)
extern    CPerfReg            g_PerfReg;                // registry information, has to be before PerfObjects
extern    CPerfObjects        g_PerfObjects;            // performance objects and counters

#endif // __PERFOBJ_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\perfapp\perfobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1996 - 2000.
//
//  File:       perfobj.cpp
//
//  Classes:    CPerfObj
//
//  Contents:   Single performance object class
//
//--------------------------------------------------------------------------

#include "perfappp.h"


//+------------------------------------------------------------------------
//
//  Function:   CPerfObj::CPerfObj
//
//  Synopsis:   
//
//-------------------------------------------------------------------------
CPerfObj::CPerfObj() :
    m_pObjInfo( NULL ),
    m_pbCounterData( NULL ),
    m_pbCounterDefinitions( NULL ),
    m_pbInstanceDefinitions( NULL ),
    m_hMMFileHandle( NULL ),
    m_hDataMutex( NULL ),
    m_dwUpdateRev( 0 ),
    m_dwIndex( -1 )
{
}


//+------------------------------------------------------------------------
//
//  Function:   CPerfObj::~CPerfObj
//
//  Synopsis:   
//
//-------------------------------------------------------------------------
CPerfObj::~CPerfObj()
{
    if( IsMapped() )
    {
        UnmapDataMemory();
    }
    SAFE_CLOSEHANDLE( m_hDataMutex );
}


//+------------------------------------------------------------------------
//
//  Function:   CPerfObj::GetCounterSize
//
//  Synopsis:   Given the counter number, return the size of the counter.
//
//-------------------------------------------------------------------------
DWORD
CPerfObj::GetCounterSize( DWORD dwCounterNum )
{
    PPERF_COUNTER_DEFINITION pCounterDef;
    
    pCounterDef = (PPERF_COUNTER_DEFINITION) GetCounterDef();

    if( dwCounterNum < m_pObjInfo->m_dwNumCounters )
    {
        return( pCounterDef[ dwCounterNum ].CounterSize );
    }
    else
    {
        return( 0 );
    }
}


//+------------------------------------------------------------------------
//
//  Function:   CPerfObj::GetInstancDef
//
//  Synopsis:   Given the instance id, return the instance definition.
//
//-------------------------------------------------------------------------
PPERF_INSTANCE_DEFINITION
CPerfObj::GetInstanceDef( DWORD dwInstanceID )
{
    PPERF_INSTANCE_DEFINITION    pInstanceDef;
    DWORD dwTempInstanceID;

    if( NULL == m_pbInstanceDefinitions )
    {
        return( NULL );
    }
    
    if( (DWORD)-1 == dwInstanceID )
    {
        return( NULL );
    }

    //
    // MarkV - 10/21/98 - we now initialize m_pObjInfo->m_dwNumInstances to 0xffffffff
    // in order to make NT5 happy.  If we somehow get into this code, adjust it to 0.
    //
    if( 0xffffffff == m_pObjInfo->m_dwNumInstances )
    {
        m_pObjInfo->m_dwNumInstances = 0;
    }
    
    pInstanceDef = (PPERF_INSTANCE_DEFINITION) m_pbInstanceDefinitions;
    for( dwTempInstanceID = 0; dwTempInstanceID < dwInstanceID; ++dwTempInstanceID )
    {
        pInstanceDef = (PPERF_INSTANCE_DEFINITION)((PBYTE) pInstanceDef + pInstanceDef->ByteLength);
    }

    return( pInstanceDef );
}


//+------------------------------------------------------------------------
//
//  Function:   CPerfObj::SetObjInfoPtr
//
//  Synopsis:   Initialize the m_pObjInfo to point to the appropriate
//              location inside the perfInfo of the CPerfObjects.
//
//-------------------------------------------------------------------------
void
CPerfObj::SetObjInfoPtr( GLOBAL_PERFINFO *pPerfObjects, int index )
{
    m_pObjInfo = (OBJECT_PERFINFO *)( pPerfObjects + 1 );
    m_pObjInfo += index;
}


//+------------------------------------------------------------------------
//
//  Function:   CPerfObj::MapDataMemory
//
//  Synopsis:   Set up mapped memory for counter data, counter definitions,
//              and instance definitions.
//
//-------------------------------------------------------------------------
BOOL
CPerfObj::MapDataMemory( BOOL fCreate, BOOL fOpenWriteable )
{
    PPERF_COUNTER_DEFINITION pCounterDef;
    DWORD   dwCounterNum;
    BOOL    fOld;
    DWORD   dwMMFSize;
    DWORD   dwErrorCode;
    WCHAR   pszTextBuffer[TEXT_BUFFER_LENGTH];    // a temporary string buffer
    
    // This memory-mapped file contains counter data followed by
    // counter definitions followed by instance definitions, all
    // in one chunk of memory.
    dwMMFSize = m_pObjInfo->m_dwMaxDataSize + COUNTER_DEF_MM_SIZE + INSTANCE_DEF_MM_SIZE;

    if( IsWindows2000() )
    {
        wsprintf( pszTextBuffer, L"Global\\%s_%d", szCounterDataSharedMemory, m_pObjInfo->m_dwObjectID );
    }
    else
    {
        wsprintf( pszTextBuffer, L"%s_%d", szCounterDataSharedMemory, m_pObjInfo->m_dwObjectID );
    }

    if ( fCreate )
    {
        //In this scenario, CreateFileMapping creates a file mapping object of a specified size that is backed by the system paging file instead of by a file in the file system.
        //In other words, were creating a stand-alone memory mapped file that is not stored on disk 
        m_hMMFileHandle = CreateFileMapping( INVALID_HANDLE_VALUE, &g_SecurityAttributes, PAGE_READWRITE,
                                             0, dwMMFSize, pszTextBuffer);
        if ( NULL == m_hMMFileHandle )
        {
            dwErrorCode = GetLastError();
            ConditionalOutputDebugString(TEXT("App requesting a Counter, Couldn't Open Memory File"));
            return( FALSE );
        }

        fOld = ( ERROR_ALREADY_EXISTS == GetLastError() );

        // Perfmon or other monitor programs usually set it to read only.
        // The applications usually set it to writeable.
        m_pbCounterData = (LPBYTE) MapViewOfFile( m_hMMFileHandle, FILE_MAP_WRITE, 0, 0, 0 );
    }
    else
    {
        m_hMMFileHandle = OpenFileMapping( fOpenWriteable ? FILE_MAP_WRITE : FILE_MAP_READ, FALSE, pszTextBuffer );
        if ( NULL == m_hMMFileHandle )
        {
            dwErrorCode = GetLastError();
            ConditionalOutputDebugString(TEXT("App requesting a Counter, Couldn't Open Memory File"));
            return( FALSE );
        }

        fOld = TRUE;

        // Perfmon or other monitor programs usually set it to read only.
        // The applications usually set it to writeable.
        m_pbCounterData = (LPBYTE) MapViewOfFile( m_hMMFileHandle, fOpenWriteable ? FILE_MAP_WRITE : FILE_MAP_READ, 0, 0, 0 );
    }
    
    if( NULL == m_pbCounterData )
    {
        dwErrorCode = GetLastError();
        ConditionalOutputDebugString(TEXT("App requesting a Counter, Couldn't Open Memory File"));
        SAFE_CLOSEHANDLE( m_hMMFileHandle );
        m_hMMFileHandle = NULL;
        return( FALSE );
    }

    // Point other two pointers to the right location in MMF memory.
    m_pbCounterDefinitions = m_pbCounterData + m_pObjInfo->m_dwMaxDataSize;
    m_pbInstanceDefinitions = m_pbCounterDefinitions + COUNTER_DEF_MM_SIZE;

    if( !fOld )
    {
        // Initialize all the counters.
        pCounterDef = (PPERF_COUNTER_DEFINITION) m_pbCounterDefinitions;
        for( dwCounterNum = 0; dwCounterNum < MAX_COUNTERS; ++dwCounterNum, ++pCounterDef )
        {
            pCounterDef->CounterType = PERF_COUNTER_NODATA;
        }
    }

    // Now we have an up-to-date version of definitions and data.
    m_dwUpdateRev = m_pObjInfo->m_dwUpdateRev;

    return TRUE;
}


//+------------------------------------------------------------------------
//
//  Function:   CPerfObj::UnmapDataMemory
//
//  Synopsis:   Unmap the mapped memory that contains counter data,
//              counter definitions, and instance definitions.
//
//-------------------------------------------------------------------------
void
CPerfObj::UnmapDataMemory()
{
    if( m_pbCounterData )
    {
        UnmapViewOfFile( m_pbCounterData ) ;
        m_pbCounterData = NULL;
        m_pbCounterDefinitions  = NULL;
        m_pbInstanceDefinitions = NULL;
    }

    SAFE_CLOSEHANDLE( m_hMMFileHandle );
}


//+------------------------------------------------------------------------
//
//  Function:   CPerfObj::GetInstanceName
//
//  Synopsis:   Find an instance name from its ID.
//
//-------------------------------------------------------------------------
DWORD
CPerfObj::GetInstanceName( DWORD dwInstanceID, LPWSTR pwszInstanceName, DWORD *pcchNameLength )
{
    DWORD   dwError = ERROR_SUCCESS;
    DWORD   cchLen = 0;
    LPWSTR  pwszName = NULL;
    PPERF_INSTANCE_DEFINITION pPerfInstanceDefinition = NULL;

    if( m_dwUpdateRev < m_pObjInfo->m_dwUpdateRev )
    {
        // Application has changed the mapping. Unmap the old file.
        UnmapDataMemory();
    }

    // If the mapped memory is not initialized, we want to do it now.
    if( !IsMapped() )
    {
        if( !MapDataMemory( FALSE ) )
        {
            dwError = GetLastError();
            return( dwError );
        }
    }
    
    pPerfInstanceDefinition = GetInstanceDef( dwInstanceID );
    if( NULL == pPerfInstanceDefinition )
    {
        return( E_FAIL );
    }

    pwszName = (LPWSTR)( (BYTE *)pPerfInstanceDefinition + pPerfInstanceDefinition->NameOffset );
    cchLen = MIN( *pcchNameLength - 1, wcslen( pwszName ) );
    wcsncpy( pwszInstanceName, pwszName, cchLen );
    pwszInstanceName[ cchLen ] = L'\0';
    *pcchNameLength = cchLen;
    
    return( dwError );
}


//+------------------------------------------------------------------------
//
//  Function:   CPerfObj::FindCounterByID
//
//  Synopsis:   Given a counter ID, find its counter number.
//              Return -1 if cannot find this counter.
//
//-------------------------------------------------------------------------
DWORD
CPerfObj::FindCounterByID( DWORD dwCounterID )
{
    PPERF_COUNTER_DEFINITION pCounterDef = NULL;
    DWORD   dwCounterNum = 0;

    if( NULL == m_pbCounterDefinitions )
    {
        return( (DWORD)-1 );
    }

    pCounterDef = (PPERF_COUNTER_DEFINITION) m_pbCounterDefinitions;
    for( dwCounterNum = 0;
         dwCounterNum < m_pObjInfo->m_dwNumCounters;
         ++dwCounterNum, ++pCounterDef )
    {
        if( ( pCounterDef->CounterType & PERF_COUNTER_NODATA ) != PERF_COUNTER_NODATA )
        {
            if ( pCounterDef->CounterNameTitleIndex == dwCounterID )
            {
                return( dwCounterNum );
            }
        }
    }

    return (DWORD) -1;
}


//+------------------------------------------------------------------------
//
//  Function:   CPerfObj::GetCounterValue
//
//  Synopsis:   Given an instance ID and a counter ID, return the counter value.
//              Stash the value in a QWORD and return a flag to say if it's
//              really a DWORD value.
//
//-------------------------------------------------------------------------
DWORD
CPerfObj::GetCounterValue( DWORD dwInstanceID, DWORD dwCounterID, BOOL *pfIsDWORD, QWORD *pqwValue )
{
    DWORD   dwError = ERROR_SUCCESS;
    DWORD   dwCounterIndex = 0;
    DWORD   dwCounterSize = 0;
    BYTE   *pbCounterDataAddress = NULL;
    PPERF_INSTANCE_DEFINITION pPerfInstanceDefinition = NULL;

    if( m_dwUpdateRev < m_pObjInfo->m_dwUpdateRev )
    {
        // Application has changed the mapping. Unmap the old file.
        UnmapDataMemory();
    }

    // If the mapped memory is not initialized, we want to do it now.
    if( !IsMapped() )
    {
        if( !MapDataMemory( FALSE ) )
        {
            dwError = GetLastError();
            return( dwError );
        }
    }

    if( PERF_NO_INSTANCES == m_pObjInfo->m_dwNumInstances )
    {
        if( (DWORD)-1 != dwInstanceID )
        {
            return( (DWORD)-1 );
        }
    }
    
    dwCounterIndex = FindCounterByID( dwCounterID );
    if( (DWORD)-1 == dwCounterIndex )
    {
        return( (DWORD)-1 );
    }

    dwCounterSize = GetCounterSize( dwCounterIndex );
    *pfIsDWORD = ( sizeof(DWORD) == dwCounterSize );

    if( (DWORD)-1 == dwInstanceID )
    {
        pbCounterDataAddress = m_pbCounterData + dwCounterIndex * MAX_COUNTER_SIZE;
    }
    else
    {
        pbCounterDataAddress = m_pbCounterData + dwInstanceID * ( m_pObjInfo->m_dwMaxDataSize / MAX_INSTANCES_PER_OBJECT ) + dwCounterIndex * MAX_COUNTER_SIZE;
    }

    if( *pfIsDWORD )
    {
        *pqwValue = *(DWORD *)pbCounterDataAddress;
    }
    else
    {
        *pqwValue = *(QWORD *)pbCounterDataAddress;
    }
    
    return( dwError );
}


//+------------------------------------------------------------------------
//
//  Function:   CPerfObj::FindInstanceByName
//
//  Synopsis:   Given an instance name, find its instance id.
//              Return -1 if cannot find this instance.
//
//-------------------------------------------------------------------------
DWORD
CPerfObj::FindInstanceByName( LPWSTR pszName, BOOL fHaveMySelf )
{
    DWORD   dwInstanceID;
    DWORD   dwTestInstanceID;
    PPERF_INSTANCE_DEFINITION pInstanceDef;

    if( NULL == pszName )
    {
        return( (DWORD)-1 );
    }

    pInstanceDef = (PPERF_INSTANCE_DEFINITION) m_pbInstanceDefinitions;
    if( NULL == pInstanceDef )
    {
        return( (DWORD)-1 );
    }
        
    //
    // MarkV - 10/21/98 - we now initialize m_pObjInfo->m_dwNumInstances to 0xffffffff
    // in order to make NT5 happy.  If we somehow get into this code, adjust it to 0.
    //
    if( 0xffffffff == m_pObjInfo->m_dwNumInstances )
    {
        m_pObjInfo->m_dwNumInstances = 0;
    }

    dwInstanceID = 0;
    for( dwTestInstanceID = 0; dwTestInstanceID < ( m_pObjInfo->m_dwNumInstances - ( int ) fHaveMySelf ); ++dwInstanceID )
    {
        if( L'\0' != *(WCHAR *)( (PBYTE) pInstanceDef + pInstanceDef->NameOffset ) )
        {
            ++dwTestInstanceID;
            if( 0 == wcscmp( (WCHAR *)( (PBYTE) pInstanceDef + pInstanceDef->NameOffset ), pszName ) )
            {
                return( dwInstanceID );
            }
        }
        // Go to next instance definition.
        pInstanceDef = (PPERF_INSTANCE_DEFINITION)( (PBYTE) pInstanceDef + pInstanceDef->ByteLength );
    }

    return( (DWORD)-1 );
}


//+------------------------------------------------------------------------
//
//  Function:   CPerfObj::InitPerfObject
//
//  Synopsis:   Initialize the performance object in shared memory
//
//-------------------------------------------------------------------------
BOOL
CPerfObj::InitPerfObject( DWORD dwIndex, DWORD dwMaxCounters )
{
    BOOL    fSuccess = TRUE;
    DWORD   dwDataSize;
    DWORD   dwNameIndex;
    DWORD   dwHelpIndex;
    WCHAR   pszTextBuffer[TEXT_BUFFER_LENGTH];    // a temporary string buffer
    
    // We need a mutex for every object.
    if( IsWindows2000() )
    {
        wsprintf( pszTextBuffer, TEXT("Global\\%s_%d"), szDataMutexName, dwIndex ) ;
    }
    else
    {
        wsprintf( pszTextBuffer, TEXT("%s_%d"), szDataMutexName, dwIndex ) ;
    }

    if( m_hDataMutex == NULL )
    {
        m_hDataMutex = CreateMutex( &g_SecurityAttributes, TRUE, pszTextBuffer );
        if( NULL == m_hDataMutex )
        {
            ConditionalOutputDebugString(TEXT("Can't create data mutex\n\r"));
            return( FALSE );
        }
    }
    else
    {
        WaitForSingleObject(m_hDataMutex, INFINITE);
    }

    dwNameIndex = dwIndex;
    dwHelpIndex = dwIndex + 1;

    SetObjectIndex( dwIndex );
    
    m_pObjInfo->m_ObjectType.ObjectNameTitleIndex = dwNameIndex;
    m_pObjInfo->m_ObjectType.ObjectHelpTitleIndex = dwHelpIndex;
    
    //
    // MarkV - 10/21/98 - NT5 wants single instance objects to report numInstances
    // as "-1"
    //
    m_pObjInfo->m_dwNumInstances = 0xffffffff;

    // If maxCounters is zero, we use default size. Otherwise we compute the
    // size. If it is set to too small and other programs that share this
    // memory expect
    dwDataSize = ( 0 == dwMaxCounters )
                        ? OBJECT_COUNTER_DATA_SIZE
                        : dwMaxCounters * MAX_INSTANCES_PER_OBJECT * MAX_COUNTER_SIZE;

    // Set the m_dwMaxDataSize only if nobody else has initialized it.
    // In other words, if two programs want to set the size of the
    // shared memory. The first value it is set to stays.
    if( !IsInUse() || 0 == m_pObjInfo->m_dwMaxDataSize )
    {
        m_pObjInfo->m_dwMaxDataSize = dwDataSize;
    }

    // Copy the object ID into the global memory. This has be done before the MapDataMemory call,
    // since we use the object ID to create a unique shared memory mapping for this object.
    m_pObjInfo->m_dwObjectID = dwNameIndex;
    
    if( !MapDataMemory( TRUE ) )
    {
        fSuccess = FALSE;
    }
    else
    {
        m_pObjInfo->m_fInUse = TRUE;
        ++m_dwUpdateRev;                    // signal the change
    }

    ReleaseMutex( m_hDataMutex );

    return( fSuccess );
}


//+------------------------------------------------------------------------
//
//  Function:   CPerfObj::OpenPerfObject
//
//  Synopsis:   Initialize the performance object in shared memory
//
//-------------------------------------------------------------------------
BOOL
CPerfObj::OpenPerfObject( DWORD dwIndex )
{
    BOOL    fSuccess = TRUE;
    DWORD   dwDataSize;
    DWORD   dwNameIndex;
    DWORD   dwHelpIndex;
    WCHAR   pszTextBuffer[TEXT_BUFFER_LENGTH];    // a temporary string buffer
    
    // We need a mutex for every object.
    if( IsWindows2000() )
    {
        wsprintf( pszTextBuffer, TEXT("Global\\%s_%d"), szDataMutexName, dwIndex ) ;
    }
    else
    {
        wsprintf( pszTextBuffer, TEXT("%s_%d"), szDataMutexName, dwIndex ) ;
    }

    if( m_hDataMutex == NULL )
    {
        m_hDataMutex = CreateMutex( &g_SecurityAttributes, TRUE, pszTextBuffer );
        if( NULL == m_hDataMutex )
        {
            ConditionalOutputDebugString(TEXT("Can't create data mutex\n\r"));
            return( FALSE );
        }
    }
    else
    {
        WaitForSingleObject(m_hDataMutex, INFINITE);
    }
        
    if( !MapDataMemory( FALSE, TRUE ) )
    {
        fSuccess = FALSE;
    }
    else
    {
        m_pObjInfo->m_fInUse = TRUE;
        ++m_dwUpdateRev;                    // signal the change
    }

    ReleaseMutex( m_hDataMutex );

    return( fSuccess );
}


//+------------------------------------------------------------------------
//
//  Function:   CPerfObj::DestroyPerfObject
//
//  Synopsis:   Delete and clean up structure/data of an object.
//
//-------------------------------------------------------------------------
BOOL
CPerfObj::DestroyPerfObject()
{
    if (m_pObjInfo)
    {
        m_pObjInfo->m_fInUse = FALSE;
    }
    UnmapDataMemory();

    return( TRUE );
}


//+------------------------------------------------------------------------
//
//  Function:   CPerfObj::InitPerfCounter
//
//  Synopsis:   Initialize the performance counter
//
//-------------------------------------------------------------------------
BOOL
CPerfObj::InitPerfCounter( DWORD dwType, DWORD dwScale, DWORD dwSize,
                           DWORD dwIndex, DWORD &dwCounterDataOffset)
{
    PPERF_COUNTER_DEFINITION pNewCounterDef;
    DWORD   dwNameIndex = 0;
    DWORD   dwHelpIndex = 0;
    DWORD   dwCounterNum;

    // Make sure we have space for one more counter.
    if( MAX_COUNTERS == m_pObjInfo->m_dwNumCounters )
    {
        return( FALSE );
    }

    // Find an empty counter slot.
    pNewCounterDef = (PPERF_COUNTER_DEFINITION) m_pbCounterDefinitions;
    for( dwCounterNum = 0; dwCounterNum < MAX_COUNTERS; ++dwCounterNum, ++pNewCounterDef)
    {
        if( ( pNewCounterDef->CounterType & PERF_COUNTER_NODATA ) == PERF_COUNTER_NODATA )
        {
            // Found an unused counter.
            break;
        }
    }

    if( MAX_COUNTERS == dwCounterNum )
    {
        ConditionalOutputDebugString(TEXT("Exceed max. # of counters per object\n\r"));
        return( FALSE );
    }

    pNewCounterDef->ByteLength = sizeof(PERF_COUNTER_DEFINITION);

    dwNameIndex = dwIndex;
    dwHelpIndex = dwIndex + 1;

    // We assume maximum counter size to be 8 bytes. So we can determine
    // the fixed location of the counter data by the counter number.
    // The reason we design the code this way is to allow unused counters
    // to keep their reserved space.
    dwCounterDataOffset = dwCounterNum * MAX_COUNTER_SIZE;

    pNewCounterDef->CounterNameTitleIndex = dwNameIndex;
    pNewCounterDef->CounterHelpTitleIndex = dwHelpIndex;

    // We don't store anything in these two global pointers because
    // each process stores name title in different address locations.
    pNewCounterDef->CounterNameTitle = NULL;
    pNewCounterDef->CounterHelpTitle = NULL; 

    pNewCounterDef->DefaultScale  = dwScale;
    pNewCounterDef->DetailLevel   = PERF_DETAIL_NOVICE;
    pNewCounterDef->CounterType   = dwType;
    pNewCounterDef->CounterSize   = dwSize;
    pNewCounterDef->CounterOffset = dwCounterDataOffset + sizeof(PERF_COUNTER_BLOCK);
    ++m_pObjInfo->m_dwNumCounters;

    return( TRUE );
}


//+------------------------------------------------------------------------
//
//  Function:   CPerfObj::DestroyPerfCounter
//
//  Synopsis:   Delete and clean up structure/data of a counter.
//
//  Note:       There is a safer way of implementing this function.
//              All we need is a counter number which will pass to
//              the application when it calls CreatePerfCounter.
//              However, this requires an API change on CreatePerfCounter.
//
//-------------------------------------------------------------------------
BOOL
CPerfObj::DestroyPerfCounter( LPVOID pvThisCounterData )
{
    PPERF_COUNTER_DEFINITION pCounterDef;
    PBYTE   pbCounterData;

    pCounterDef  = (PPERF_COUNTER_DEFINITION) GetCounterDef();
    pbCounterData = GetCounterData();

    // Search for this counter.
    for( ; pvThisCounterData > pbCounterData; ++pCounterDef, pbCounterData += MAX_COUNTER_SIZE );

    if( pvThisCounterData != pbCounterData )
    {
        return( FALSE );
    }

    pCounterDef->CounterType |= PERF_COUNTER_NODATA;
    
    return( TRUE );
}


//+------------------------------------------------------------------------
//
//  Function:   CPerfObj::InitPerfInstance
//
//  Synopsis:   Initialize the performance object instance.
//
//-------------------------------------------------------------------------
DWORD
CPerfObj::InitPerfInstance( LPWSTR pszName, LPVOID *ppvInstanceName, LPVOID *ppvInstanceStart )
{
    DWORD           dwLen;
    DWORD           dwNewInstanceID;
    PPERF_INSTANCE_DEFINITION   pNewInstance;

    if( NULL == m_pbInstanceDefinitions )
    {
        return( (DWORD)-1 );
    }
        
    //
    // MarkV - 10/21/98 - we now initialize m_pObjInfo->m_dwNumInstances to 0xffffffff
    // in order to make NT5 happy.  If we somehow get into this code, adjust it to 0.
    //
    if( 0xffffffff == m_pObjInfo->m_dwNumInstances )
    {
        m_pObjInfo->m_dwNumInstances = 0;
    }

    // We assume that instances are always packed together
    // (i.e. no unused instance between two valid instances.
    // So the new instance will be the instance after the
    // instance.
    dwNewInstanceID = GetNextFreeInstance();
    pNewInstance = GetInstanceDef( dwNewInstanceID );

    if( NULL == pNewInstance )
    {
        return( (DWORD)-1 );
    }

    //
    // We don't need to round to an 8-byte length multiple here, since we've
    // already taken care that the instance name length is a multiple of 8 bytes
    // including the terminating NULL. However, we're telling perfmon that the
    // total length includes MAX_INSTANCE_NAME * sizeof(WCHAR) bytes,
    // but we store the real name length of the instance.
    //
    dwLen = ( wcslen( pszName ) + 1 ) * sizeof(WCHAR);
    ZeroMemory( pNewInstance + 1, dwLen);

    pNewInstance->ParentObjectTitleIndex = 0;
    pNewInstance->ByteLength = sizeof(PERF_INSTANCE_DEFINITION) + MAX_INSTANCE_NAME * sizeof(WCHAR);
    pNewInstance->NameOffset = sizeof(PERF_INSTANCE_DEFINITION);
    pNewInstance->NameLength = dwLen;
    pNewInstance->UniqueID   = PERF_NO_UNIQUE_ID;

    if( ppvInstanceName )
    {
        *ppvInstanceName = (LPVOID *)( pNewInstance + 1 );
    }
    memcpy( pNewInstance + 1, pszName, dwLen );

    if( ppvInstanceStart )
    {
        *ppvInstanceStart = m_pbCounterData + dwNewInstanceID * ( m_pObjInfo->m_dwMaxDataSize / MAX_INSTANCES_PER_OBJECT );
    }

    m_pObjInfo->m_dwNumInstances++;
    
    return( dwNewInstanceID );
}


//+------------------------------------------------------------------------
//
//  Function:   CPerfObj::DestroyPerfInstance
//
//  Synopsis:   Delete and clean up structure/data of an object instance.
//
//-------------------------------------------------------------------------
BOOL
CPerfObj::DestroyPerfInstance( DWORD dwInstanceID )
{
    PPERF_INSTANCE_DEFINITION pInstanceDef;

    pInstanceDef = GetInstanceDef( dwInstanceID );
    if( NULL == pInstanceDef )
    {
        return( FALSE );
    }

    //
    // This sets our unused marker
    //
    *(WCHAR *)( (PBYTE) pInstanceDef + pInstanceDef->NameOffset ) = L'\0';

    m_pObjInfo->m_dwNumInstances--;
    
    return ( TRUE );
}


//+------------------------------------------------------------------------
//
//  Function:   CPerfObj::GetNextFreeInstance
//
//  Synopsis:   Return the next available instance ID.
//
//-------------------------------------------------------------------------
DWORD
CPerfObj::GetNextFreeInstance()
{
    PPERF_INSTANCE_DEFINITION pInstanceDef = (PPERF_INSTANCE_DEFINITION) m_pbInstanceDefinitions;
    DWORD dwInstanceID = 0;
    DWORD dwNextFreeInstanceID;

    if( MAX_INSTANCES_PER_OBJECT == m_pObjInfo->m_dwNumInstances )
    {
        return( (DWORD)-1 );
    }

    for( dwNextFreeInstanceID = 0; dwInstanceID < m_pObjInfo->m_dwNumInstances; ++dwNextFreeInstanceID )
    {
        if( L'\0' == *(WCHAR *)((PBYTE) pInstanceDef + pInstanceDef->NameOffset))
        {
            return ( dwNextFreeInstanceID );
        }
        else
        {
            dwInstanceID++;
        }
        pInstanceDef = (PPERF_INSTANCE_DEFINITION)( (PBYTE) pInstanceDef + pInstanceDef->ByteLength );
    }

    return( dwNextFreeInstanceID );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\perfapp\perfdbg.cpp ===
//+-------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1996 - 2000.
//
//  File:       perfdbg.cpp
//
//  Classes:    
//
//  Contents:   Code that print out debug information.
//
//--------------------------------------------------------------------------

#include "perfappp.h"


BOOL fEnableOutputDebugString = TRUE;


//+------------------------------------------------------------------------
//
//  Function:   ConditionalOutputDebugString
//
//  Synopsis:   OutputDebugString only in checked build
//
//-------------------------------------------------------------------------

void
ConditionalOutputDebugString( LPTSTR string )
{
#if _BLDTYPE == CHECKED
    if( fEnableOutputDebugString ) {
        OutputDebugString( string );
    }
#else
    UNREFERENCED_PARAMETER(string);
#endif
}


//+------------------------------------------------------------------------
//
//  Function:   OutputMultiSzString
//
//  Synopsis:   Print out the contents of multiple sz strings
//
//-------------------------------------------------------------------------

void
OutputMultiSzString(LPTSTR strings)
{
    if (strings == NULL) return;

    while (strings[0] != TEXT('\0')) {
        ConditionalOutputDebugString(strings);
        ConditionalOutputDebugString(TEXT("\n"));
        strings += lstrlen(strings) + 1;
    }
}


//+------------------------------------------------------------------------
//
//  Function:   CPerfObj::DumpCounters
//
//  Synopsis:   Print out the contents of counters of an object
//
//-------------------------------------------------------------------------

void
CPerfObj::DumpCounters()
{
    PPERF_COUNTER_DEFINITION counterDef;
    DWORD    counterNum;
    DWORD    n;
    LPBYTE    p;
    WCHAR pszTextBuffer[TEXT_BUFFER_LENGTH];    // a temporary string buffer

    if( NULL == m_pbCounterData )
    {
        return;
    }

    // General information
    p = m_pbCounterData;
    wsprintf(pszTextBuffer, L"NumOfCounters= %lu SizeOfData= %lu "
             L"NameIndex= %lu HelpIndex= %lu\r\n",
             m_pObjInfo->m_dwNumCounters,
             INSTANCE_COUNTER_DATA_SIZE,
             m_pObjInfo->m_ObjectType.ObjectNameTitleIndex,
             m_pObjInfo->m_ObjectType.ObjectHelpTitleIndex);
    ConditionalOutputDebugString(pszTextBuffer);

    // Counter definitions
    counterDef = (PPERF_COUNTER_DEFINITION) m_pbCounterDefinitions;
    for (counterNum = 0;
         counterNum < m_pObjInfo->m_dwNumCounters;
         ++counterNum, ++counterDef){

        n = counterDef->CounterOffset - sizeof(PERF_COUNTER_BLOCK) / sizeof(DWORD);
        wsprintf(pszTextBuffer,
                 L"COUNTER #%d:\r\nLength= %lu, NameIndex= %lu, HelpIndex= %lu, "
                 L"Index= %d,Scale= %lu, Type= %lu\r\n\tValue= %lu (%lu)\r\n\n",
                 counterNum,
                 counterDef->ByteLength,
                 counterDef->CounterNameTitleIndex,
                 counterDef->CounterHelpTitleIndex,
                 counterNum,
                 counterDef->DefaultScale,
                 counterDef->CounterType,
                 ((DWORD *) p)[n],
                 counterDef->CounterType | PERF_SIZE_DWORD
                    ? 0L : (counterDef->CounterType | PERF_SIZE_LARGE
                        ? ((DWORD *) p)[n + 1] : 0L)
                );
        ConditionalOutputDebugString(pszTextBuffer);
    }
}


//+------------------------------------------------------------------------
//
//  Function:   CPerfObj::DumpInstances
//
//  Synopsis:   Print out the instances of an object
//
//-------------------------------------------------------------------------

void
CPerfObj::DumpInstances()
{
    PPERF_INSTANCE_DEFINITION instanceDef;
    DWORD    instanceNum;                                                     
    WCHAR pszTextBuffer[TEXT_BUFFER_LENGTH];    // a temporary string buffer

    if( NULL == m_pbInstanceDefinitions )
    {
        return;
    }

    // General information
    wsprintf(pszTextBuffer, L"NumOfInstances:%lu NameIndex= %lu HelpIndex= %lu\r\n",
             m_pObjInfo->m_dwNumInstances,
             m_pObjInfo->m_ObjectType.ObjectNameTitleIndex,
             m_pObjInfo->m_ObjectType.ObjectHelpTitleIndex);
    ConditionalOutputDebugString(pszTextBuffer);

    // Instance definitions
    for (instanceNum = 0; instanceNum < m_pObjInfo->m_dwNumInstances; ++instanceNum){
        instanceDef = GetInstanceDef(instanceNum);
        _ASSERT(instanceDef != NULL);
        wsprintf(pszTextBuffer,
                 L"Instance #%d:\r\nLength= %lu, Name= %ws, NameLength= %lu\r\n\n",
                 instanceNum,
                 instanceDef->ByteLength,
                 (LPTSTR) ((PBYTE) (instanceDef) + instanceDef->NameOffset),
                 instanceDef->NameLength
                );
        ConditionalOutputDebugString(pszTextBuffer);
    }
    return;
}


//+------------------------------------------------------------------------
//
//  Function:   CPerfObjects::DumpCounters
//
//  Synopsis:   Print out the contents of counters of all the objects
//
//-------------------------------------------------------------------------

void
CPerfObjects::DumpCounters()
{
    DWORD        objNum;
    WCHAR pszTextBuffer[TEXT_BUFFER_LENGTH];    // a temporary string buffer

    for (objNum = 0; objNum < m_pPerfInfo->m_dwNumObjects; ++objNum) {
        wsprintf(pszTextBuffer, L"Object %d\n", m_pPerfObj[objNum].GetObjectIndex());
        ConditionalOutputDebugString(pszTextBuffer) ;
        m_pPerfObj[objNum].DumpCounters();
    }
}


//+------------------------------------------------------------------------
//
//  Function:   CPerfObjects::dumpInstances
//
//  Synopsis:   Print out the contents of instances of all the objects
//
//-------------------------------------------------------------------------

void
CPerfObjects::DumpInstances()
{
    DWORD        objNum;
    WCHAR pszTextBuffer[TEXT_BUFFER_LENGTH];    // a temporary string buffer

    for (objNum = 0; objNum < m_pPerfInfo->m_dwNumObjects; ++objNum) {
        wsprintf(pszTextBuffer, L"Object %d\n", m_pPerfObj[objNum].GetObjectIndex());
        ConditionalOutputDebugString(pszTextBuffer) ;
        m_pPerfObj[objNum].DumpCounters();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\perfapp\perfreg.cpp ===
//+-------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1996 - 2000.
//
//  File:       perfreg.cpp
//
//  Classes:    CPerfReg
//
//  Contents:   Class that communicates to registry.
//
//--------------------------------------------------------------------------

#include "perfappp.h"

#define  DEFINE_NAMES
#include "svrspec.h"

extern HINSTANCE g_hInstance;

// Global Variables
SECURITY_ATTRIBUTES g_SecurityAttributes;                   // security attributes for named mutexes etc.
CPerfReg            g_PerfReg;                              // registry information, has to be before PerfObjects
CPerfObjects        g_PerfObjects;                          // performance objects and counters

static    WCHAR szCloseAPI[]   = L"AppPerfClose";
static    WCHAR szCollectAPI[] = L"AppPerfCollect";
static    WCHAR szOpenAPI[]    = L"AppPerfOpen";

//////////////////////////////////////////////////////////////////////////////
//
// CreateSids
//
// Create 2 Security IDs
//
// Caller must free memory allocated to SIDs on success.
//
// Returns: TRUE if successful, FALSE if not.
//
//////////////////////////////////////////////////////////////////////////////
BOOL CreateSids(
    PSID                    *BuiltInAdministrators,
    PSID                    *AuthenticatedUsers
)
{
    //
    // An SID is built from an Identifier Authority and a set of Relative IDs
    // (RIDs).  The Authority of interest to us SECURITY_NT_AUTHORITY.
    //

    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY LocalAuthority = SECURITY_LOCAL_SID_AUTHORITY;

    //
    // Each RID represents a sub-unit of the authority.  Two of the SIDs we
    // want to build, Local Administrators, and Power Users, are in the "built
    // in" domain.  The other SID, for Authenticated users, is based directly
    // off of the authority.
    //     
    // For examples of other useful SIDs consult the list in
    // \nt\public\sdk\inc\ntseapi.h.
    //

    if (!AllocateAndInitializeSid(&NtAuthority,
                                  2,            // 2 sub-authorities
                                  SECURITY_BUILTIN_DOMAIN_RID,
                                  DOMAIN_ALIAS_RID_ADMINS,
                                  0,0,0,0,0,0,
                                  BuiltInAdministrators)) {

        // error

    } else if (!AllocateAndInitializeSid(&LocalAuthority,
                                         1,            // 1 sub-authority
                                         //SECURITY_AUTHENTICATED_USER_RID,
                                         SECURITY_WORLD_RID,
                                         0,0,0,0,0,0,0,
                                         AuthenticatedUsers)) {

        // error

        FreeSid(BuiltInAdministrators);
        BuiltInAdministrators = NULL;

    } else {
        return TRUE;
    }

    return FALSE;
}


//////////////////////////////////////////////////////////////////////////////
//
// CreateSd
//
// Creates a SECURITY_DESCRIPTOR with specific DACLs.  Modify the code to
// change. 
//
// Caller must free the returned buffer if not NULL.
//
//////////////////////////////////////////////////////////////////////////////
PSECURITY_DESCRIPTOR CreateSd()
{
    PSID                    AuthenticatedUsers = NULL;
    PSID                    BuiltInAdministrators = NULL;
    PSECURITY_DESCRIPTOR    Sd = NULL;
    DWORD                   dwError = ERROR_SUCCESS;

    if( CreateSids( &BuiltInAdministrators, &AuthenticatedUsers ) )
    {

        // 
        // Calculate the size of and allocate a buffer for the DACL, we need
        // this value independently of the total alloc size for ACL init.
        //

        ULONG                   AclSize;

        //
        // "- sizeof (ULONG)" represents the SidStart field of the
        // ACCESS_ALLOWED_ACE.  Since we're adding the entire length of the
        // SID, this field is counted twice.
        //

        AclSize = sizeof (ACL) +
            (2 * (sizeof (ACCESS_ALLOWED_ACE) - sizeof (ULONG))) +
            GetLengthSid(AuthenticatedUsers) +
            GetLengthSid(BuiltInAdministrators);

        Sd = malloc( SECURITY_DESCRIPTOR_MIN_LENGTH + AclSize );

        if ( NULL != Sd )
        {
            ACL *Acl;

            Acl = (ACL *)((BYTE *)Sd + SECURITY_DESCRIPTOR_MIN_LENGTH);

            if (!InitializeAcl(Acl,
                               AclSize,
                               ACL_REVISION))
            {
                goto abort;
            }
            
            if ( !AddAccessAllowedAce( Acl,
                                       ACL_REVISION,
                                       //SYNCHRONIZE | GENERIC_READ,
                                       GENERIC_ALL,
                                       AuthenticatedUsers ) )
            {
                // Failed to build the ACE granting "Authenticated users"
                // (SYNCHRONIZE | GENERIC_READ) access.
                goto abort;
            }

            if ( !AddAccessAllowedAce( Acl,
                                       ACL_REVISION,
                                       GENERIC_ALL,
                                       BuiltInAdministrators ) )
            {
                // Failed to build the ACE granting "Built-in Administrators"
                // GENERIC_ALL access.
                goto abort;
            }

            if ( !InitializeSecurityDescriptor( Sd, SECURITY_DESCRIPTOR_REVISION ) )
            {
                goto abort;
            }

            if ( !SetSecurityDescriptorDacl( Sd,
                                             TRUE,
                                             Acl,
                                             FALSE ) )
            {
                goto abort;
            }

            FreeSid( AuthenticatedUsers );
            FreeSid( BuiltInAdministrators );

            return Sd;
        }

    }

abort:
    if ( Sd )
    {
        free( Sd );
    }
    if ( AuthenticatedUsers )
    {
        FreeSid( AuthenticatedUsers );
    }
    if ( BuiltInAdministrators )
    {
        FreeSid( BuiltInAdministrators );
    }
    
    return NULL;
}


//+------------------------------------------------------------------------
//
//  Function:   CPerfReg::CPerfReg
//
//  Synopsis:   
//
//-------------------------------------------------------------------------

CPerfReg::CPerfReg() :
    m_hRegMutex( NULL ),
    m_hkPerfRegKey( 0 ),
    m_dwFirstCounterID( 0 ),
    m_dwFirstHelpID( 0 ),
    m_dwLastCounterID( 0 ),
    m_dwLastHelpID( 0 ),
    m_fInitialized( FALSE ),
    m_fCreatedACL( FALSE )
{
    InitializeCriticalSection( &m_CritSec );
}


//+------------------------------------------------------------------------
//
//  Function:   CPerfReg::~CPerfReg
//
//  Synopsis:   
//
//-------------------------------------------------------------------------
CPerfReg::~CPerfReg()
{
    SAFE_CLOSEHANDLE( m_hRegMutex );
    if( NULL != m_hkPerfRegKey )
    {
        RegCloseKey( m_hkPerfRegKey );
    }
    free( g_SecurityAttributes.lpSecurityDescriptor );
    DeleteCriticalSection( &m_CritSec );
}


//+------------------------------------------------------------------------
//
//  Function:   CPerfReg::Initialize
//
//  Synopsis:   Initialize data relevant to creating new objects/counters,
//              such as security attributes for shared memory, mutexes and
//              open registry keys.
//
//-------------------------------------------------------------------------
DWORD
CPerfReg::Initialize()
{
    DWORD   dwError = ERROR_SUCCESS;
    WCHAR   wstrExtendedMutexName[ TEXT_BUFFER_LENGTH ];
    
    // Have to initialize the security attributes before anything else
    // because function calls in constructors need it.

    EnterCriticalSection( &m_CritSec );

    do
    {
        if( !m_fCreatedACL )
        {
            // Initialize a default Security attributes and giving world permissions.
            // This is basically prevent Semaphores and other named objects from
            // being created because of default acls given by winlogon when perfmon
            // is being used remotely.
            g_SecurityAttributes.bInheritHandle = FALSE;
            g_SecurityAttributes.nLength = sizeof(SECURITY_ATTRIBUTES);
            g_SecurityAttributes.lpSecurityDescriptor = CreateSd();
            if( NULL == g_SecurityAttributes.lpSecurityDescriptor )
            {
                dwError = GetLastError();
                ConditionalOutputDebugString(TEXT("Can't create SD.\r\n"));
                _ASSERT( 0 );
                break;
            }

            if( IsWindows2000() )
            {
                wcscpy( wstrExtendedMutexName, L"Global\\" );
            }
            wcscat( wstrExtendedMutexName, szRegistryMutexName );
            
            m_hRegMutex = CreateMutex( &g_SecurityAttributes, FALSE, wstrExtendedMutexName );
            if( NULL == m_hRegMutex )
            {
                dwError = GetLastError();
                break;
            }

            m_fCreatedACL = TRUE;
        }
    }
    while( FALSE );
    
    LeaveCriticalSection( &m_CritSec );

    return( dwError );
}


//+------------------------------------------------------------------------
//
//  Function:   CPerfReg::RegisterServer
//
//  Synopsis:   Set up the library pointers for perfmon in our service key.
//
//-------------------------------------------------------------------------
DWORD
CPerfReg::RegisterServer()
{
    DWORD dwError = ERROR_SUCCESS;
    DWORD dwAction = 0;
    WCHAR pszTextBuffer[TEXT_BUFFER_LENGTH];    // a temporary string buffer
    
    dwError = Initialize();
    if( ERROR_SUCCESS != dwError )
    {
        return( dwError );
    }
    
    // Guarded by a mutex so that nobody else can look into the data
    // we are modifying.
    WaitForSingleObject( m_hRegMutex, INFINITE );

    do
    {
        dwError = RegCreateKeyEx( HKEY_LOCAL_MACHINE, szRegistryPathToPerformanceKeys, 0,
                                  NULL, REG_OPTION_NON_VOLATILE, KEY_SET_VALUE,
                                  NULL, &m_hkPerfRegKey, &dwAction );
        // Open our Performance key. If unsuccessful create it.
        if( ERROR_SUCCESS != dwError )
        {
            // The registry is in very bad shape. We are in big trouble here !!
            ConditionalOutputDebugString(TEXT("Failed to create/open reg entry\n\r"));
            m_hkPerfRegKey = NULL;
            break;
        }

        //
        // Write our library information into the this service's Performance key.
        // We attempt to write the Library value with the location of this DLL.
        //
        DWORD dwLength = 0;
        dwLength = ::GetModuleFileNameW( g_hInstance, pszTextBuffer, TEXT_BUFFER_LENGTH );
        pszTextBuffer[ TEXT_BUFFER_LENGTH - 1 ] = L'\0';
        if( 0 != dwLength && dwLength < TEXT_BUFFER_LENGTH )
        {
            dwLength = ( wcslen( pszTextBuffer ) + 1 ) * sizeof(WCHAR);
            dwError = RegSetValueEx( m_hkPerfRegKey, L"Library", 0, REG_SZ, (CONST BYTE *)pszTextBuffer, dwLength );
            if( ERROR_SUCCESS != dwError )
            {
                break;
            }
        }
        else
        {
            dwError = GetLastError();
            break;
        }

        dwError = RegSetValueEx( m_hkPerfRegKey, L"Close", 0, REG_SZ,
                                 (CONST BYTE *)szCloseAPI, ( wcslen( szCloseAPI ) + 1 ) * sizeof(WCHAR) );
        if( ERROR_SUCCESS != dwError )
        {
            break;
        }
        dwError = RegSetValueEx( m_hkPerfRegKey, L"Collect", 0, REG_SZ,
                                 (CONST BYTE *)szCollectAPI, ( wcslen( szCollectAPI ) + 1 ) * sizeof(WCHAR) );
        if( ERROR_SUCCESS != dwError )
        {
            break;
        }
        dwError = RegSetValueEx( m_hkPerfRegKey, L"Open", 0, REG_SZ,
                                 (CONST BYTE *)szOpenAPI, ( wcslen( szOpenAPI ) + 1 ) * sizeof(WCHAR) );
        if( ERROR_SUCCESS != dwError )
        {
            break;
        }

        //
        // Remember the directory this DLL was loaded from in order to find
        // our perf counter .ini file
        //
        char szDllPath[ MAX_PATH ];
        GetModuleFileNameA( g_hInstance, szDllPath, MAX_PATH );
        szDllPath[ MAX_PATH - 1 ] = '\0';

        *strrchr( szDllPath, '\\' ) = '\0';

        //
        // Use the same routine as lodctr.exe to do the proper registry
        // grovelling necessary to add our counters
        //
        char szCmdLine[ MAX_PATH ];
        sprintf( szCmdLine, "lodctr.exe %s\\%s.ini", szDllPath, PERF_APP_NAME );

        dwError = LoadPerfCounterTextStringsA( szCmdLine, TRUE );

        if( ERROR_SUCCESS != dwError )
        {
            break;
        }
    }
    while( FALSE );

    ReleaseMutex( m_hRegMutex );

    return( dwError );
}


//+------------------------------------------------------------------------
//
//  Function:   CPerfReg::RegisterServer
//
//  Synopsis:   Set up the library pointers for perfmon in our service key.
//
//-------------------------------------------------------------------------
DWORD
CPerfReg::UnRegisterServer()
{
    DWORD dwError = ERROR_SUCCESS;
    
    dwError = Initialize();
    if( ERROR_SUCCESS != dwError )
    {
        return( dwError );
    }
    
    // Guarded by a mutex so that nobody else can look into the data
    // we are modifying.
    WaitForSingleObject( m_hRegMutex, INFINITE );

    do
    {
        dwError = RegDeleteKey( HKEY_LOCAL_MACHINE, szRegistryPathToPerformanceKeys);
        if( ERROR_SUCCESS != dwError )
        {
            // The registry is in very bad shape. We are in big trouble here !!
            ConditionalOutputDebugString(TEXT("Unable to delete reg entry\n\r"));
            m_hkPerfRegKey = NULL;
            break;
        }

    }
    while( FALSE );

    ReleaseMutex( m_hRegMutex );

    return( dwError );
}


//+------------------------------------------------------------------------
//
//  Function:   CPerfReg::GetCounterBasis
//
//  Synopsis:   Read the First/Last counter values from our Performance key.
//
//-------------------------------------------------------------------------
DWORD
CPerfReg::GetCounterBasis( DWORD &dwFirstCounter, DWORD &dwLastCounter, DWORD &dwFirstHelp, DWORD &dwLastHelp )
{
    DWORD   dwError = ERROR_SUCCESS;
    DWORD   dwValueSize;
    DWORD   dwValueType = 0;
    
    Initialize();

    WaitForSingleObject( m_hRegMutex, INFINITE );

    if( m_fInitialized )
    {
        dwFirstCounter = m_dwFirstCounterID;
        dwLastCounter = m_dwLastCounterID;
        dwFirstHelp = m_dwFirstHelpID;
        dwLastHelp = m_dwLastHelpID;
        ReleaseMutex( m_hRegMutex );
        return( S_OK );
    }
    
    do
    {
        dwError = RegOpenKeyEx( HKEY_LOCAL_MACHINE, szRegistryPathToPerformanceKeys, 0,
                                KEY_QUERY_VALUE, &m_hkPerfRegKey );
        // Open our Performance key.
        if( ERROR_SUCCESS != dwError )
        {
            // The registry is in very bad shape. We are in big trouble here !!
            ConditionalOutputDebugString(TEXT("Failed to create/open reg entry\n\r"));
            m_hkPerfRegKey = NULL;
            break;
        }
        
        dwValueSize = sizeof(DWORD);
        dwError = RegQueryValueEx( m_hkPerfRegKey, L"First Counter", NULL, &dwValueType, (LPBYTE)&dwFirstCounter, &dwValueSize );
        if( ERROR_SUCCESS != dwError )
        {
            break;
        }
        
        dwValueSize = sizeof(DWORD);
        dwError = RegQueryValueEx( m_hkPerfRegKey, L"First Help", NULL, &dwValueType, (LPBYTE)&dwFirstHelp, &dwValueSize );
        if( ERROR_SUCCESS != dwError )
        {
            break;
        }

        dwValueSize = sizeof(DWORD);
        dwError = RegQueryValueEx( m_hkPerfRegKey, L"Last Counter", NULL, &dwValueType, (LPBYTE)&dwLastCounter, &dwValueSize );
        if( ERROR_SUCCESS != dwError )
        {
            break;
        }
        
        dwValueSize = sizeof(DWORD);
        dwError = RegQueryValueEx( m_hkPerfRegKey, L"Last Help", NULL, &dwValueType, (LPBYTE)&dwLastHelp, &dwValueSize );
        if( ERROR_SUCCESS != dwError )
        {
            break;
        }
    }
    while( FALSE );
    
    if( ERROR_SUCCESS != dwError )
    {
        ReleaseMutex( m_hRegMutex );
        return( dwError );
    }
    
    m_dwFirstCounterID = dwFirstCounter;
    m_dwFirstHelpID = dwFirstHelp;
    m_dwLastCounterID = dwLastCounter;
    m_dwLastHelpID = dwLastHelp;
    m_fInitialized = TRUE;
    
    ReleaseMutex( m_hRegMutex );

    return( dwError );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\perfapp\perfreg.h ===
#pragma once
//+-------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1996 - 2000.
//
//  File:       perfreg.h
//
//  Classes:    CPerfReg
//
//  Contents:   Class that communicates to registry
//
//--------------------------------------------------------------------------


#ifndef __PERFREG_H__
#define __PERFREG_H__

class CPerfReg
{
public:
	CPerfReg();
	~CPerfReg();

    DWORD   Initialize();
    DWORD   RegisterServer();
    DWORD   UnRegisterServer();
    DWORD   GetCounterBasis( DWORD &dwFirstCounter, DWORD &dwLastCounter, DWORD &dwFirstHelp, DWORD &dwLastHelp );

private:
	HANDLE	            m_hRegMutex;			// mutex for accessing registry
	HKEY	            m_hkPerfRegKey;		    // cached keys
    DWORD               m_dwFirstCounterID;
    DWORD               m_dwFirstHelpID;
    DWORD               m_dwLastCounterID;
    DWORD               m_dwLastHelpID;
    BOOL                m_fInitialized;
    BOOL                m_fCreatedACL;
    CRITICAL_SECTION    m_CritSec;
};

#endif // __PERFREG_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\perfapp\resource.h ===
#pragma once
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by perfapp.rc
//
#define IDS_PERFAPP1_DESC	1



// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\perfapp\pobjects.cpp ===
//+-------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1996 - 2000.
//
//  File:       pobjects.cpp
//
//  Classes:    CPerfObjects
//
//  Contents:   Class for a set of performance objects
//
//--------------------------------------------------------------------------

#include "perfappp.h"


//+------------------------------------------------------------------------
//
//  Function:   CPerfObjects::CperfObjects
//
//  Synopsis:   
//
//-------------------------------------------------------------------------

CPerfObjects::CPerfObjects()
{
    m_pPerfInfo = NULL;
    m_hMMFileHandle = NULL;
    m_bMMFileHandleReadOnly = FALSE;

    WCHAR   wstrExtendedMutexName[ TEXT_BUFFER_LENGTH ];

    if( IsWindows2000() )
    {
        wcscpy( wstrExtendedMutexName, L"Global\\" );
    }
    wcscat( wstrExtendedMutexName, szPerfInfoMutexName );
    
    m_hPerfInfoMutex = CreateMutex( &g_SecurityAttributes, FALSE, wstrExtendedMutexName );
}


//+------------------------------------------------------------------------
//
//  Function:   CPerfObjects::~CperfObjects
//
//  Synopsis:   
//
//-------------------------------------------------------------------------

CPerfObjects::~CPerfObjects()
{
    if( NULL != m_pPerfInfo )
    {
        UnmapPerfInfoMemory();
    }
    SAFE_CLOSEHANDLE( m_hPerfInfoMutex );
}


//+------------------------------------------------------------------------
//
//  Function:   CPerfObjects::MapPerfInfoMemory
//
//  Synopsis:   Create mapped memory for global performance info.
//
//-------------------------------------------------------------------------

BOOL
CPerfObjects::MapPerfInfoMemory( BOOL fCreate )
{
    int     i;
    DWORD   dwErrorCode;
    DWORD   dwSizeOfPerfInfoMemory = sizeof(GLOBAL_PERFINFO) + MAX_PERF_OBJECTS * sizeof(OBJECT_PERFINFO);
    WCHAR   wstrExtendedName[ TEXT_BUFFER_LENGTH ];

    // If somebody already created it, simply return with success.
    if( NULL != m_pPerfInfo )
    {
        // Fail if we are being asked to create but have already opened
        // the shared memory map file as R/O.
        if( TRUE == fCreate && TRUE == m_bMMFileHandleReadOnly) 
        {
            return( FALSE );
        }

        // one more caller who's planning on using the memory mapped file
        InterlockedIncrement( &m_lPerfMemRefCount );
        return( TRUE );
    }

    if( IsWindows2000() )
    {
        wcscpy( wstrExtendedName, L"Global\\" );
    }
    wcscat( wstrExtendedName, szGlobalInfoSharedMemory );

    if ( fCreate )
    {
        m_hMMFileHandle = CreateFileMapping( INVALID_HANDLE_VALUE, &g_SecurityAttributes,
                                             PAGE_READWRITE | SEC_COMMIT, 0,
                                             dwSizeOfPerfInfoMemory, wstrExtendedName);
        dwErrorCode = GetLastError();
        if( NULL == m_hMMFileHandle )
        {
            ConditionalOutputDebugString(TEXT("Couldn't create GlobalInfoFileMapping\n"));
            return( FALSE );
        }

        m_pPerfInfo = (GLOBAL_PERFINFO *)MapViewOfFile( m_hMMFileHandle, FILE_MAP_WRITE, 0, 0, 0 );

        if( ERROR_ALREADY_EXISTS != dwErrorCode )
        {
            memset( m_pPerfInfo, 0, dwSizeOfPerfInfoMemory );
        }

        // Remember that the file has been created R/W
        m_bMMFileHandleReadOnly = FALSE;
    }
    else
    {
        m_hMMFileHandle = OpenFileMapping( FILE_MAP_READ, FALSE, wstrExtendedName );
        if( NULL == m_hMMFileHandle )
        {
            dwErrorCode = GetLastError();
            ConditionalOutputDebugString(TEXT("Couldn't open GlobalInfoFileMapping\n"));
            return( FALSE );
        }

        m_pPerfInfo = (GLOBAL_PERFINFO *)MapViewOfFile( m_hMMFileHandle, FILE_MAP_READ, 0, 0, 0 );

        // Remember that the file has been created R/O
        m_bMMFileHandleReadOnly = TRUE;
    }
    
    if( NULL == m_pPerfInfo )
    {
        dwErrorCode = GetLastError();
        ConditionalOutputDebugString(TEXT("Couldn't Map GlobalInfofileMapping\n\r"));
        SAFE_CLOSEHANDLE( m_hMMFileHandle );
        m_hMMFileHandle = NULL;
        return( FALSE );
    }

    // Set up pointers into this mapped memory from each performance object.
    for( i = 0; i < MAX_PERF_OBJECTS; ++i )
    {
        m_pPerfObj[ i ].SetObjInfoPtr( m_pPerfInfo, i );
    }

    // one more caller who's planning on using the memory mapped file
    InterlockedIncrement( &m_lPerfMemRefCount );

    return( TRUE );
}


//+------------------------------------------------------------------------
//
//  Function:   CPerfObjects::UnmapPerfInfoMemory
//
//  Synopsis:   Unmap the mapped memory that contains global information.
//
//-------------------------------------------------------------------------

void
CPerfObjects::UnmapPerfInfoMemory()
{
    // This ref counting  was put in place because AppPerfOpen/Close were getting called as
    // side-effects of a webstore call, and resulting in premature unmapping of perfinfomem.
    if((InterlockedDecrement( &m_lPerfMemRefCount ) == 0))
    {
        if(NULL != m_pPerfInfo)
        {
            UnmapViewOfFile( m_pPerfInfo );
            m_pPerfInfo = NULL;
        }

        SAFE_CLOSEHANDLE( m_hMMFileHandle );
    }
}


//+------------------------------------------------------------------------
//
//  Function:   CPerfObjects::FindObjectByIndex
//
//  Synopsis:   Given a object index, find the object.
//
//-------------------------------------------------------------------------

CPerfObj *
CPerfObjects::FindObjectByIndex( DWORD dwIndex )
{
    int i;

    for( i = 0; i < MAX_PERF_OBJECTS; ++i )
    {
        if( m_pPerfObj[ i ].IsInUse() && ( m_pPerfObj[i].GetObjectIndex() == dwIndex ) )
        {
            // Found it.
            return( m_pPerfObj + i );
        }
    }

    return( NULL );
}


//+------------------------------------------------------------------------
//
//  Function:   CPerfObjects::FindUnusedObject
//
//  Synopsis:   Find an unused object.
//
//-------------------------------------------------------------------------

CPerfObj *
CPerfObjects::FindUnusedObject()
{
    int i;

    for( i = 0; i < MAX_PERF_OBJECTS; ++i )
    {
        if( !m_pPerfObj[ i ].IsInUse() )
        {
            // Found it.
            return( m_pPerfObj + i );
        }
    }

    return( NULL );
}


//+------------------------------------------------------------------------
//
//  Function:   CPerfObjects::CreatePerfObject
//
//  Synopsis:   Create a performance object.
//
//-------------------------------------------------------------------------

HANDLE
CPerfObjects::CreatePerfObject( DWORD dwRelativeIndex, DWORD dwNumCounters, PVOID *ppvObjectStart )
{
    DWORD       dwError;
    HANDLE      hHandle = NULL;
    CPerfObj   *pPerfObj;
    DWORD       dwIndex = 0;
    DWORD       dwFirstCounter = 0;
    DWORD       dwLastCounter = 0;
    DWORD       dwFirstHelp = 0;
    DWORD       dwLastHelp = 0;

    if( NULL != ppvObjectStart )
    {
        *ppvObjectStart = (PVOID)INVALID_HANDLE_VALUE;
    }

    dwError = g_PerfReg.GetCounterBasis( dwFirstCounter, dwLastCounter, dwFirstHelp, dwLastHelp );
    if( ERROR_SUCCESS != dwError )
    {
        return( NULL );
    }
    
    // If we haven't create the memory-mapped file, create it now.
    if( NULL == m_pPerfInfo )
    {
        if( !MapPerfInfoMemory( TRUE ) )
        {
            ConditionalOutputDebugString(TEXT("Can't create memory mapped file\n\r"));
            return( NULL );
        }
    }
    else if(m_bMMFileHandleReadOnly)
    {
        ConditionalOutputDebugString(TEXT("Memory mapped file is read-only\n\r"));
        return( NULL );        
    }


    dwIndex = dwFirstCounter + dwRelativeIndex;
    if( ( dwIndex > dwLastCounter ) || ( dwIndex + 1 > dwLastHelp ) )
    {
        return( NULL );
    }
    
    // If this process crashed and is re-run again,
    // we need to attach to any existing shared memory.
    pPerfObj = FindObjectByIndex( dwIndex );
    if( NULL == pPerfObj )
    {
        pPerfObj = FindUnusedObject();
        // If we run out of objects, exit immediately.
        if( NULL == pPerfObj )
        {
            ConditionalOutputDebugString(TEXT("Exceed max. # of objects\n\r"));
            return( NULL );
        }
    } 

    // Note: We don't need to lock it in order to read because
    // perfmon or other monitor programs will only read the shared
    // memory. However, we do need to lock it in order to change it.
    WaitForSingleObject( m_hPerfInfoMutex, INFINITE );

    if( pPerfObj->InitPerfObject( dwIndex, dwNumCounters ) )
    {
        hHandle = (HANDLE *)pPerfObj;

        // We allow application programs pass in a null for lppObjectStart.
        // This only make sense if that program call CreateObjectInstance
        // to create an instance for this object. Otherwise, there is no
        // way to reference the storage for the counters.
        if( NULL != ppvObjectStart )
        {
            *ppvObjectStart = (BYTE *)pPerfObj->GetCounterData();
        }
        ++m_pPerfInfo->m_dwNumObjects;
    }
    else
    {
        ConditionalOutputDebugString(TEXT("Can't initialize a performance object\n\r"));
    }

    ReleaseMutex( m_hPerfInfoMutex );

    return( hHandle );
}


//+------------------------------------------------------------------------
//
//  Function:   CPerfObjects::OpenPerfObject
//
//  Synopsis:   Open an existing performance object.
//
//-------------------------------------------------------------------------

HANDLE
CPerfObjects::OpenPerfObject( DWORD dwRelativeIndex, PVOID *ppvObjectStart )
{
    DWORD       dwError;
    HANDLE      hHandle = NULL;
    CPerfObj   *pPerfObj;
    DWORD       dwIndex = 0;
    DWORD       dwFirstCounter = 0;
    DWORD       dwLastCounter = 0;
    DWORD       dwFirstHelp = 0;
    DWORD       dwLastHelp = 0;

    if( NULL != ppvObjectStart )
    {
        *ppvObjectStart = (PVOID)INVALID_HANDLE_VALUE;
    }

    dwError = g_PerfReg.GetCounterBasis( dwFirstCounter, dwLastCounter, dwFirstHelp, dwLastHelp );
    if( ERROR_SUCCESS != dwError )
    {
        return( NULL );
    }
    
    // If we haven't create the memory-mapped file, create it now.
    if( NULL == m_pPerfInfo )
    {
        if( !MapPerfInfoMemory( TRUE ) )
        {
            ConditionalOutputDebugString(TEXT("Can't create memory mapped file\n\r"));
            return( NULL );
        }
    }

    dwIndex = dwFirstCounter + dwRelativeIndex;
    if( ( dwIndex > dwLastCounter ) || ( dwIndex + 1 > dwLastHelp ) )
    {
        return( NULL );
    }
    
    // we need to attach to any existing shared memory.
    pPerfObj = FindObjectByIndex( dwIndex );
    if( NULL == pPerfObj )
    {
        return NULL;
    }
    
    // Note: We don't need to lock it in order to read because
    // perfmon or other monitor programs will only read the shared
    // memory. However, we do need to lock it in order to change it.
    WaitForSingleObject( m_hPerfInfoMutex, INFINITE );

    if( pPerfObj->OpenPerfObject( dwIndex ) )
    {
        hHandle = (HANDLE *)pPerfObj;

        // We allow application programs pass in a null for lppObjectStart.
        // This only make sense if that program call CreateObjectInstance
        // to create an instance for this object. Otherwise, there is no
        // way to reference the storage for the counters.
        if( NULL != ppvObjectStart )
        {
            *ppvObjectStart = (BYTE *)pPerfObj->GetCounterData();
        }
        ++m_pPerfInfo->m_dwNumObjects;
    }
    else
    {
        ConditionalOutputDebugString(TEXT("Can't initialize a performance object\n\r"));
    }

    ReleaseMutex( m_hPerfInfoMutex );


    return( hHandle );
}


//+------------------------------------------------------------------------
//
//  Function:   CPerfObjects::DestroyPerfObject
//
//  Synopsis:   Delete a performance object.
//
//-------------------------------------------------------------------------

BOOL
CPerfObjects::DestroyPerfObject( HANDLE hObjHandle )
{
    HRESULT     hr = S_OK;
    BOOL        fSuccess;
    CPerfObj   *pObj;

    if( NULL == hObjHandle )
    {
        return( FALSE );
    }

    pObj = (CPerfObj *) hObjHandle;

    WaitForSingleObject( m_hPerfInfoMutex, INFINITE );
    fSuccess = pObj->DestroyPerfObject();
    if( fSuccess )
    {
        --m_pPerfInfo->m_dwNumObjects;
    }
    
    ReleaseMutex( m_hPerfInfoMutex );

    return( fSuccess );
}


//+------------------------------------------------------------------------
//
//  Function:   CPerfObjects::DestroyAllPerfObjects
//
//  Synopsis:   Delete all performance objects.
//
//-------------------------------------------------------------------------

void
CPerfObjects::DestroyAllPerfObjects()
{
    int i;

    for( i = 0; i < MAX_PERF_OBJECTS; ++i )
    {
        DestroyPerfObject((HANDLE)(m_pPerfObj + i));
    }
}


//+------------------------------------------------------------------------
//
//  Function:   CPerfObjects::CreatePerfCounter
//
//  Synopsis:   Create a performance counter.
//
//-------------------------------------------------------------------------

DWORD
CPerfObjects::CreatePerfCounter( DWORD dwType, DWORD dwScale, DWORD dwSize, HANDLE hObject, DWORD dwRelativeIndex, HANDLE *phMutex )
{
    DWORD       dwError = ERROR_SUCCESS;
    CPerfObj   *pObj;
    DWORD       dwCounterDataOffset;
    LONG        lCounterNumber;
    DWORD       dwCounterID = 0;
    DWORD       dwFirstCounter = 0;
    DWORD       dwLastCounter = 0;
    DWORD       dwFirstHelp = 0;
    DWORD       dwLastHelp = 0;

    // If the object handle is NULL, we simply fail it. The proper
    // order is create an object, create one or more counters and
    // for each instance of the object we duplicate the counters.
    if( NULL == hObject )
    {
        ConditionalOutputDebugString(TEXT("Need an object handle to create a counter\n\r"));
        return( (DWORD)-1 );
    }

    dwError = g_PerfReg.GetCounterBasis( dwFirstCounter, dwLastCounter, dwFirstHelp, dwLastHelp );
    if( ERROR_SUCCESS != dwError )
    {
        return( (DWORD)-1 );
    }

    dwCounterID = dwFirstCounter + dwRelativeIndex;
    if( ( dwCounterID > dwLastCounter ) || ( dwCounterID + 1 > dwLastHelp ) )
    {
        return( (DWORD)-1 );
    }

    pObj = (CPerfObj *) hObject;
    // Is it a New counter?
    lCounterNumber = pObj->FindCounterByID( dwCounterID );
    if( (DWORD)-1 == lCounterNumber )
    {
        WaitForSingleObject( m_hPerfInfoMutex, INFINITE );
        if( !pObj->InitPerfCounter( dwType, dwScale, dwSize,
                                    dwCounterID, dwCounterDataOffset ) )
        {
            ReleaseMutex( m_hPerfInfoMutex );
            return( (DWORD)-1 );
        }
        ReleaseMutex( m_hPerfInfoMutex );
    }
    else
    {
        // Existing counter.
        dwCounterDataOffset = ( ( (PPERF_COUNTER_DEFINITION)pObj->GetCounterDef() ) + lCounterNumber )->CounterOffset
                              - sizeof(PERF_COUNTER_BLOCK);
    }

    // Return handle of the data mutex for atomic data access by the applications.
    if( NULL != phMutex )
    {
        *phMutex = pObj->GetDataMutex();
    }

    // Return beginning of mapped memory + Instance Offset + Counter within
    // that specific instance.
    return( dwCounterDataOffset );
}


//+------------------------------------------------------------------------
//
//  Function:   CPerfObjects::DestroyPerfCounter
//
//  Synopsis:   Delete a performance counter.
//
//-------------------------------------------------------------------------

BOOL
CPerfObjects::DestroyPerfCounter( HANDLE hObjHandle, LPVOID pvCounterData )
{
    CPerfObj   *pObj;
    BOOL        fSuccess;

    if( NULL == hObjHandle || NULL == pvCounterData )
    {
        return( FALSE );
    }
    
    pObj = (CPerfObj *) hObjHandle;
    if( !pObj->IsInUse() )
    {
        return( FALSE  );
    }

    WaitForSingleObject( m_hPerfInfoMutex, INFINITE );
    fSuccess = pObj->DestroyPerfCounter( pvCounterData );
    ReleaseMutex( m_hPerfInfoMutex );

    return( fSuccess );
}


//+------------------------------------------------------------------------
//
//  Function:   CPerfObjects::CreateObjectInstance
//
//  Synopsis:   Create an instance of a performance object.
//
//-------------------------------------------------------------------------

DWORD
CPerfObjects::CreateObjectInstance( HANDLE hObject, PWCHAR pszInstName, PVOID *ppvInstanceName, PVOID *ppvInstanceStart )
{
    HRESULT     hr = S_OK;
    DWORD       dwInstanceID = (DWORD)-1;
    CPerfObj   *pObj;
    WCHAR       pszFormattedName[ MAX_INSTANCE_NAME ];
    LONG        lLen;

    if( NULL == hObject || NULL == pszInstName || 0 == wcslen( pszInstName ) )
    {
        ConditionalOutputDebugString(TEXT("Need an object handle and instance name to create an instance\n\r"));
        return( E_INVALIDARG );
    }

    if( NULL == ppvInstanceName )
    {
        ConditionalOutputDebugString(TEXT("Need a pointer to store instance name\n\r"));
        return( (DWORD)-1 );
    }
    if( NULL == ppvInstanceStart )
    {
        ConditionalOutputDebugString(TEXT("Need a pointer to store instance starting point\n\r"));
        return( (DWORD)-1 );
    }

    pObj = (CPerfObj *) hObject;

    //
    // Make string a fixed length, either truncated or padded.
    // Note that MAX_INSTANCE_NAME includes the terminating NULL, but wcslen() does not.
    //
    lLen = wcslen( pszInstName );
    if ( lLen <= ( MAX_INSTANCE_NAME - 1 ) )
    {
        wcscpy( pszFormattedName, pszInstName );
        for ( int i = lLen; i < MAX_INSTANCE_NAME - 1; i++ )
        {
            pszFormattedName[ i ] = L'\0';
        }
        pszFormattedName[ MAX_INSTANCE_NAME - 1 ] = L'\0';
    }
    else
    {
        wcsncpy( pszFormattedName, pszInstName, MAX_INSTANCE_NAME - 1 );
        pszFormattedName[ MAX_INSTANCE_NAME - 1 ] = L'\0';
    }

    WaitForSingleObject( m_hPerfInfoMutex, INFINITE );

    dwInstanceID = pObj->FindInstanceByName( pszFormattedName, 0 );
    if( (DWORD)-1 == dwInstanceID )
    {
        // a new instance
        dwInstanceID = pObj->InitPerfInstance( pszFormattedName, ppvInstanceName, ppvInstanceStart );
    }

    ReleaseMutex( m_hPerfInfoMutex );

    return( dwInstanceID );
}


//+------------------------------------------------------------------------
//
//  Function:   CPerfObjects::DestroyObjectInstance
//
//  Synopsis:   Delete an instance of a performance object.
//
//-------------------------------------------------------------------------

BOOL
CPerfObjects::DestroyObjectInstance( HANDLE hObject, DWORD dwInstanceID )
{
    CPerfObj   *pObj;
    BOOL        fSuccess;

    if( NULL == hObject )
    {
        return( FALSE );
    }

    pObj = (CPerfObj *) hObject;

    if( !pObj->IsInUse() )
    {
        return( FALSE );
    }

    WaitForSingleObject( m_hPerfInfoMutex, INFINITE );
    fSuccess = pObj->DestroyPerfInstance( dwInstanceID );
    ReleaseMutex( m_hPerfInfoMutex );

    return( fSuccess );
}

//+------------------------------------------------------------------------
//
//  Function:   CPerfObjects::RenameObjectInstance
//
//  Synopsis:   Rename an instance of a performance object.
//
//-------------------------------------------------------------------------

void
CPerfObjects::RenameObjectInstance( HANDLE hObject, PWCHAR pszInstNewName, BYTE *pNameAddrInPerf )
{
    HRESULT     hr = S_OK;
    DWORD       dwInstanceID = (DWORD)-1;
    CPerfObj   *pObj;
    WCHAR       pszFormattedName[ MAX_INSTANCE_NAME ];
    LONG        lLen;

    if( NULL == hObject || NULL == pszInstNewName || 0 == wcslen( pszInstNewName ) )
    {
        ConditionalOutputDebugString(TEXT("Need an object handle and instance name to rename an instance\n\r"));
        return;
    }

    if( NULL == pNameAddrInPerf )
    {
        ConditionalOutputDebugString(TEXT("Need a pointer to store instance starting point\n\r"));
        return;
    }

    pObj = (CPerfObj *) hObject;

    //
    // Make string a fixed length, either truncated or padded.
    // Note that MAX_INSTANCE_NAME includes the terminating NULL, but wcslen() does not.
    //
    lLen = wcslen( pszInstNewName );
    if ( lLen <= ( MAX_INSTANCE_NAME - 1 ) )
    {
        wcscpy( pszFormattedName, pszInstNewName );
        for ( int i = lLen; i < MAX_INSTANCE_NAME - 1; i++ )
        {
            pszFormattedName[ i ] = L'\0';
        }
        pszFormattedName[ MAX_INSTANCE_NAME - 1 ] = L'\0';
    }
    else
    {
        wcsncpy( pszFormattedName, pszInstNewName, MAX_INSTANCE_NAME - 1 );
        pszFormattedName[ MAX_INSTANCE_NAME - 1 ] = L'\0';
    }

    WaitForSingleObject( m_hPerfInfoMutex, INFINITE );

    ZeroMemory( pNameAddrInPerf, MAX_INSTANCE_NAME * sizeof( WCHAR ) );

    dwInstanceID = pObj->FindInstanceByName( pszFormattedName, 1 );
    if( (DWORD)-1 == dwInstanceID )
    {
        memcpy( pNameAddrInPerf, pszFormattedName, MAX_INSTANCE_NAME * sizeof( WCHAR ) );
        ( ( PPERF_INSTANCE_DEFINITION ) pNameAddrInPerf - 1 )->NameLength = ( wcslen( pszFormattedName ) + 1 ) * sizeof(WCHAR);
    }
    else
    {
        //
        // The following part is copied from CreateObjectInstance, since their functionalities are similar 
        //
        
        const int   iStop = 3;
        BOOL        fExists = TRUE;
        int         iPos;
        WCHAR       cVal;
        WCHAR       cSavedVal;

        for( iPos = MIN( wcslen( pszFormattedName ), MAX_INSTANCE_NAME - 1 ) - 1; fExists && ( iPos >= iStop ); iPos-- )
        {
            cSavedVal = pszFormattedName[ iPos ];
            for( cVal = L'0'; fExists && cVal <= L'9'; cVal++ )
            {
                pszFormattedName[ iPos ] = cVal;
                dwInstanceID = pObj->FindInstanceByName( pszFormattedName, 1 );
                fExists = ( (DWORD)-1 != dwInstanceID );
                if( !fExists )
                {
                    memcpy( pNameAddrInPerf, pszFormattedName, MAX_INSTANCE_NAME * sizeof( WCHAR ) );
                    ( ( PPERF_INSTANCE_DEFINITION ) pNameAddrInPerf - 1 )->NameLength = ( wcslen( pszFormattedName ) + 1 ) * sizeof(WCHAR);
                    break;
                }
            }
            if( fExists )
            {
                pszFormattedName[ iPos ] = cSavedVal;
            }
            else
            {
                break;
            }
        }

        if( fExists )
        {
            dwInstanceID = -1;
        }
    }

    ReleaseMutex( m_hPerfInfoMutex );

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\perfapp\sources.inc ===
USE_LIBCMT=1
# Copyright (c) Microsoft Corporation.  All rights reserved
!INCLUDE $(INETROOT)\build\paths.all
!INCLUDE $(INETROOT)\build\sources.all

UMTYPE=windows

TARGETPATH=obj
TARGETTYPE=DYNLINK

COMMON_SOURCES = \
    ..\perfapi.cpp  \
    ..\perfapp.cpp  \
    ..\perfdbg.cpp  \
    ..\perfobj.cpp  \
    ..\perfreg.cpp  \
    ..\pobjects.cpp

PRECOMPILED_INCLUDE=..\perfappp.h
PRECOMPILED_CXX=1

C_DEFINES=$(C_DEFINES) -DUNICODE -D_UNICODE

USE_LIBCMT=1

XL_CODE_COVERAGE=1
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\perfapp\accelperf\accelperf.h ===
// NOTE: these numbers MUST start at 0 and increment by 2 each.  no missing values!!
// counters must come after their respective objects.

#define ACCELERATIONPERF_SERVER_OBJECT_GENERAL 0
#define ACCELERATION_SWITCHBOARD_WAIT_TIME_AVERAGE 2
#define ACCELERATION_SWITCHBOARD_WAIT_TIME_BASE 4
#define ACCELERATION_SWITCHBOARD_COMPLETION_RATE 6
#define ACCELERATION_SWITCHBOARD_CONTEXT_TIME_AVERAGE 8
#define ACCELERATION_SWITCHBOARD_CONTEXT_TIME_BASE 10
#define ACCELERATION_HEARTBEAT_TIME_AVERAGE 12
#define ACCELERATION_HEARTBEAT_TIME_BASE 14
#define ACCELERATION_NUM_OPEN_CONNECTIONS 16
#define ACCELERATION_REQUEST_MESSAGE_RATE 18
#define ACCELERATION_BUFFERPOOL_NUM_TOTAL 20
#define ACCELERATION_BUFFERPOOL_NUM_FREE 22
#define ACCELERATION_BUFFERPOOL_CREATE_RATE 24
#define ACCELERATION_BUFFERPOOL_BYPASS_RATE 26
#define ACCELERATION_CONTEXTPOOL_NUM_TOTAL 28
#define ACCELERATION_CONTEXTPOOL_NUM_FREE 30
#define ACCELERATION_CONTEXTPOOL_CREATE_RATE 32
#define ACCELERATION_CONTAINERPOOL_NUM_TOTAL 34
#define ACCELERATION_CONTAINERPOOL_NUM_FREE 36
#define ACCELERATION_CONTAINERPOOL_CREATE_RATE 38
#define ACCELERATION_BUCKET_MAINTENANCE_RATE 40
#define ACCELERATION_LOCK_RATE 42
#define ACCELERATION_LOCK_SPINCOUNT_AVERAGE 44
#define ACCELERATION_LOCK_SPINCOUNT_BASE 46
#define ACCELERATION_ALLOCATOR_ITEM_CREATE_RATE 48
#define ACCELERATION_ALLOCATOR_NUM_ITEMS_TOTAL 50
#define ACCELERATION_ALLOCATOR_NUM_PAGES_TOTAL 52
#define ACCELERATION_ITEM_DELETE_RATE 54
#define ACCELERATION_CHANGELIST_CHANGE_RATE 56
#define ACCELERATION_DELETIONLIST_SIZE 58
#define ACCELERATION_DELETIONLIST_DELETE_RATE 60
#define ACCELERATION_ALLOCATOR_WASTED_BYTES 62
#define ACCELERATION_ALLOCATOR_BYPASS_RATE 64
#define ACCELERATION_ALLOCATOR_LARGEST_OBJECT 66

#define ACCELERATIONPERF_SERVER_OBJECT_DATA 68
#define ACCELERATION_NUM_CACHE_ITEMS 70
#define ACCELERATION_NUM_CACHE_BYTES 72
#define ACCELERATION_EXPIRE_RATE 74
#define ACCELERATION_PURGE_RATE 76
#define ACCELERATION_CACHE_HIT_RATE 78
#define ACCELERATION_CACHE_MISS_RATE 80
#define ACCELERATION_CACHE_HIT_RATIO 82
#define ACCELERATION_CACHE_HIT_RATIO_BASE 84
#define ACCELERATION_NUM_CACHE_DATA_BYTES 86
#define ACCELERATION_NUM_CACHE_OVERHEAD_BYTES 88
#define ACCELERATION_LOOKUPTABLE_FIND_RATE 90
#define ACCELERATION_LOOKUPTABLE_ADD_RATE 92
#define ACCELERATION_LOOKUPTABLE_REMOVE_RATE 94
#define ACCELERATION_LOOKUPTABLE_LOCK_RATE 96
#define ACCELERATION_QUERY_API_RATE 98
#define ACCELERATION_INSERT_API_RATE 100
#define ACCELERATION_REMOVE_API_RATE 102
#define ACCELERATION_SETDATA_API_RATE 104
#define ACCELERATION_INCREMENT_API_RATE 106
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\Mix\TokenManagement\TokenGenerationTool\Service References\xonline.mix.tokenmanagement.contracts.v1\Reference.cs ===
ï»¿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.4927
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace TokenGenerationTool.xonline.mix.tokenmanagement.contracts.v1 {
    using System.Runtime.Serialization;
    using System;
    
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="TokenCategory", Namespace="http://xonline.mix.tokenmanagement.contracts/V1")]
    [System.SerializableAttribute()]
    public partial class TokenCategory : object, System.Runtime.Serialization.IExtensibleDataObject, System.ComponentModel.INotifyPropertyChanged {
        
        [System.NonSerializedAttribute()]
        private System.Runtime.Serialization.ExtensionDataObject extensionDataField;
        
        [System.Runtime.Serialization.OptionalFieldAttribute()]
        private TokenGenerationTool.xonline.mix.tokenmanagement.contracts.v1.ChannelSKU[] ChannelSKUArrayField;
        
        [System.Runtime.Serialization.OptionalFieldAttribute()]
        private int ChannelTypeIdField;
        
        [System.Runtime.Serialization.OptionalFieldAttribute()]
        private System.DateTime ExpirationDateField;
        
        [System.Runtime.Serialization.OptionalFieldAttribute()]
        private bool InCsatField;
        
        [System.Runtime.Serialization.OptionalFieldAttribute()]
        private bool IsRedeemableField;
        
        [System.Runtime.Serialization.OptionalFieldAttribute()]
        private bool IsRevenueBearingField;
        
        [System.Runtime.Serialization.OptionalFieldAttribute()]
        private bool IsRoyaltyBearingField;
        
        [System.Runtime.Serialization.OptionalFieldAttribute()]
        private bool IsRsmField;
        
        [System.Runtime.Serialization.OptionalFieldAttribute()]
        private System.Guid OfferIdField;
        
        [System.Runtime.Serialization.OptionalFieldAttribute()]
        private string PkpnField;
        
        [System.Runtime.Serialization.OptionalFieldAttribute()]
        private uint ProductTypeIdField;
        
        [System.Runtime.Serialization.OptionalFieldAttribute()]
        private System.Guid PromotionIdField;
        
        [System.Runtime.Serialization.OptionalFieldAttribute()]
        private System.Guid TokenCategoryIdField;
        
        [System.Runtime.Serialization.OptionalFieldAttribute()]
        private string TokenCategoryNameField;
        
        [System.Runtime.Serialization.OptionalFieldAttribute()]
        private string TokenTypeField;
        
        [global::System.ComponentModel.BrowsableAttribute(false)]
        public System.Runtime.Serialization.ExtensionDataObject ExtensionData {
            get {
                return this.extensionDataField;
            }
            set {
                this.extensionDataField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public TokenGenerationTool.xonline.mix.tokenmanagement.contracts.v1.ChannelSKU[] ChannelSKUArray {
            get {
                return this.ChannelSKUArrayField;
            }
            set {
                if ((object.ReferenceEquals(this.ChannelSKUArrayField, value) != true)) {
                    this.ChannelSKUArrayField = value;
                    this.RaisePropertyChanged("ChannelSKUArray");
                }
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public int ChannelTypeId {
            get {
                return this.ChannelTypeIdField;
            }
            set {
                if ((this.ChannelTypeIdField.Equals(value) != true)) {
                    this.ChannelTypeIdField = value;
                    this.RaisePropertyChanged("ChannelTypeId");
                }
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public System.DateTime ExpirationDate {
            get {
                return this.ExpirationDateField;
            }
            set {
                if ((this.ExpirationDateField.Equals(value) != true)) {
                    this.ExpirationDateField = value;
                    this.RaisePropertyChanged("ExpirationDate");
                }
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public bool InCsat {
            get {
                return this.InCsatField;
            }
            set {
                if ((this.InCsatField.Equals(value) != true)) {
                    this.InCsatField = value;
                    this.RaisePropertyChanged("InCsat");
                }
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public bool IsRedeemable {
            get {
                return this.IsRedeemableField;
            }
            set {
                if ((this.IsRedeemableField.Equals(value) != true)) {
                    this.IsRedeemableField = value;
                    this.RaisePropertyChanged("IsRedeemable");
                }
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public bool IsRevenueBearing {
            get {
                return this.IsRevenueBearingField;
            }
            set {
                if ((this.IsRevenueBearingField.Equals(value) != true)) {
                    this.IsRevenueBearingField = value;
                    this.RaisePropertyChanged("IsRevenueBearing");
                }
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public bool IsRoyaltyBearing {
            get {
                return this.IsRoyaltyBearingField;
            }
            set {
                if ((this.IsRoyaltyBearingField.Equals(value) != true)) {
                    this.IsRoyaltyBearingField = value;
                    this.RaisePropertyChanged("IsRoyaltyBearing");
                }
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public bool IsRsm {
            get {
                return this.IsRsmField;
            }
            set {
                if ((this.IsRsmField.Equals(value) != true)) {
                    this.IsRsmField = value;
                    this.RaisePropertyChanged("IsRsm");
                }
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public System.Guid OfferId {
            get {
                return this.OfferIdField;
            }
            set {
                if ((this.OfferIdField.Equals(value) != true)) {
                    this.OfferIdField = value;
                    this.RaisePropertyChanged("OfferId");
                }
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string Pkpn {
            get {
                return this.PkpnField;
            }
            set {
                if ((object.ReferenceEquals(this.PkpnField, value) != true)) {
                    this.PkpnField = value;
                    this.RaisePropertyChanged("Pkpn");
                }
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public uint ProductTypeId {
            get {
                return this.ProductTypeIdField;
            }
            set {
                if ((this.ProductTypeIdField.Equals(value) != true)) {
                    this.ProductTypeIdField = value;
                    this.RaisePropertyChanged("ProductTypeId");
                }
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public System.Guid PromotionId {
            get {
                return this.PromotionIdField;
            }
            set {
                if ((this.PromotionIdField.Equals(value) != true)) {
                    this.PromotionIdField = value;
                    this.RaisePropertyChanged("PromotionId");
                }
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public System.Guid TokenCategoryId {
            get {
                return this.TokenCategoryIdField;
            }
            set {
                if ((this.TokenCategoryIdField.Equals(value) != true)) {
                    this.TokenCategoryIdField = value;
                    this.RaisePropertyChanged("TokenCategoryId");
                }
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string TokenCategoryName {
            get {
                return this.TokenCategoryNameField;
            }
            set {
                if ((object.ReferenceEquals(this.TokenCategoryNameField, value) != true)) {
                    this.TokenCategoryNameField = value;
                    this.RaisePropertyChanged("TokenCategoryName");
                }
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string TokenType {
            get {
                return this.TokenTypeField;
            }
            set {
                if ((object.ReferenceEquals(this.TokenTypeField, value) != true)) {
                    this.TokenTypeField = value;
                    this.RaisePropertyChanged("TokenType");
                }
            }
        }
        
        public event System.ComponentModel.PropertyChangedEventHandler PropertyChanged;
        
        protected void RaisePropertyChanged(string propertyName) {
            System.ComponentModel.PropertyChangedEventHandler propertyChanged = this.PropertyChanged;
            if ((propertyChanged != null)) {
                propertyChanged(this, new System.ComponentModel.PropertyChangedEventArgs(propertyName));
            }
        }
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="ChannelSKU", Namespace="http://xonline.mix.tokenmanagement.contracts/V1")]
    [System.SerializableAttribute()]
    public partial class ChannelSKU : object, System.Runtime.Serialization.IExtensibleDataObject, System.ComponentModel.INotifyPropertyChanged {
        
        [System.NonSerializedAttribute()]
        private System.Runtime.Serialization.ExtensionDataObject extensionDataField;
        
        [System.Runtime.Serialization.OptionalFieldAttribute()]
        private int BOMQuantityField;
        
        [System.Runtime.Serialization.OptionalFieldAttribute()]
        private string IDField;
        
        [System.Runtime.Serialization.OptionalFieldAttribute()]
        private double MaxPriceUSDField;
        
        [System.Runtime.Serialization.OptionalFieldAttribute()]
        private double MinPriceUSDField;
        
        [System.Runtime.Serialization.OptionalFieldAttribute()]
        private string PartnerGUIDField;
        
        [System.Runtime.Serialization.OptionalFieldAttribute()]
        private double PercentageAllocationField;
        
        [global::System.ComponentModel.BrowsableAttribute(false)]
        public System.Runtime.Serialization.ExtensionDataObject ExtensionData {
            get {
                return this.extensionDataField;
            }
            set {
                this.extensionDataField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public int BOMQuantity {
            get {
                return this.BOMQuantityField;
            }
            set {
                if ((this.BOMQuantityField.Equals(value) != true)) {
                    this.BOMQuantityField = value;
                    this.RaisePropertyChanged("BOMQuantity");
                }
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string ID {
            get {
                return this.IDField;
            }
            set {
                if ((object.ReferenceEquals(this.IDField, value) != true)) {
                    this.IDField = value;
                    this.RaisePropertyChanged("ID");
                }
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public double MaxPriceUSD {
            get {
                return this.MaxPriceUSDField;
            }
            set {
                if ((this.MaxPriceUSDField.Equals(value) != true)) {
                    this.MaxPriceUSDField = value;
                    this.RaisePropertyChanged("MaxPriceUSD");
                }
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public double MinPriceUSD {
            get {
                return this.MinPriceUSDField;
            }
            set {
                if ((this.MinPriceUSDField.Equals(value) != true)) {
                    this.MinPriceUSDField = value;
                    this.RaisePropertyChanged("MinPriceUSD");
                }
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string PartnerGUID {
            get {
                return this.PartnerGUIDField;
            }
            set {
                if ((object.ReferenceEquals(this.PartnerGUIDField, value) != true)) {
                    this.PartnerGUIDField = value;
                    this.RaisePropertyChanged("PartnerGUID");
                }
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public double PercentageAllocation {
            get {
                return this.PercentageAllocationField;
            }
            set {
                if ((this.PercentageAllocationField.Equals(value) != true)) {
                    this.PercentageAllocationField = value;
                    this.RaisePropertyChanged("PercentageAllocation");
                }
            }
        }
        
        public event System.ComponentModel.PropertyChangedEventHandler PropertyChanged;
        
        protected void RaisePropertyChanged(string propertyName) {
            System.ComponentModel.PropertyChangedEventHandler propertyChanged = this.PropertyChanged;
            if ((propertyChanged != null)) {
                propertyChanged(this, new System.ComponentModel.PropertyChangedEventArgs(propertyName));
            }
        }
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="TokenInfo", Namespace="http://xonline.mix.tokenmanagement.contracts/V1")]
    [System.SerializableAttribute()]
    public partial class TokenInfo : object, System.Runtime.Serialization.IExtensibleDataObject, System.ComponentModel.INotifyPropertyChanged {
        
        [System.NonSerializedAttribute()]
        private System.Runtime.Serialization.ExtensionDataObject extensionDataField;
        
        [System.Runtime.Serialization.OptionalFieldAttribute()]
        private TokenGenerationTool.xonline.mix.tokenmanagement.contracts.v1.TokenCategory CategoryField;
        
        [System.Runtime.Serialization.OptionalFieldAttribute()]
        private byte ConsoleVersionField;
        
        [System.Runtime.Serialization.OptionalFieldAttribute()]
        private byte[] HashField;
        
        [System.Runtime.Serialization.OptionalFieldAttribute()]
        private TokenGenerationTool.xonline.mix.tokenmanagement.contracts.v1.TokenRedemption[] RedemptionsField;
        
        [System.Runtime.Serialization.OptionalFieldAttribute()]
        private uint SequenceNumberField;
        
        [System.Runtime.Serialization.OptionalFieldAttribute()]
        private int StatusIdField;
        
        [System.Runtime.Serialization.OptionalFieldAttribute()]
        private int UseCountField;
        
        [global::System.ComponentModel.BrowsableAttribute(false)]
        public System.Runtime.Serialization.ExtensionDataObject ExtensionData {
            get {
                return this.extensionDataField;
            }
            set {
                this.extensionDataField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public TokenGenerationTool.xonline.mix.tokenmanagement.contracts.v1.TokenCategory Category {
            get {
                return this.CategoryField;
            }
            set {
                if ((object.ReferenceEquals(this.CategoryField, value) != true)) {
                    this.CategoryField = value;
                    this.RaisePropertyChanged("Category");
                }
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public byte ConsoleVersion {
            get {
                return this.ConsoleVersionField;
            }
            set {
                if ((this.ConsoleVersionField.Equals(value) != true)) {
                    this.ConsoleVersionField = value;
                    this.RaisePropertyChanged("ConsoleVersion");
                }
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public byte[] Hash {
            get {
                return this.HashField;
            }
            set {
                if ((object.ReferenceEquals(this.HashField, value) != true)) {
                    this.HashField = value;
                    this.RaisePropertyChanged("Hash");
                }
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public TokenGenerationTool.xonline.mix.tokenmanagement.contracts.v1.TokenRedemption[] Redemptions {
            get {
                return this.RedemptionsField;
            }
            set {
                if ((object.ReferenceEquals(this.RedemptionsField, value) != true)) {
                    this.RedemptionsField = value;
                    this.RaisePropertyChanged("Redemptions");
                }
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public uint SequenceNumber {
            get {
                return this.SequenceNumberField;
            }
            set {
                if ((this.SequenceNumberField.Equals(value) != true)) {
                    this.SequenceNumberField = value;
                    this.RaisePropertyChanged("SequenceNumber");
                }
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public int StatusId {
            get {
                return this.StatusIdField;
            }
            set {
                if ((this.StatusIdField.Equals(value) != true)) {
                    this.StatusIdField = value;
                    this.RaisePropertyChanged("StatusId");
                }
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public int UseCount {
            get {
                return this.UseCountField;
            }
            set {
                if ((this.UseCountField.Equals(value) != true)) {
                    this.UseCountField = value;
                    this.RaisePropertyChanged("UseCount");
                }
            }
        }
        
        public event System.ComponentModel.PropertyChangedEventHandler PropertyChanged;
        
        protected void RaisePropertyChanged(string propertyName) {
            System.ComponentModel.PropertyChangedEventHandler propertyChanged = this.PropertyChanged;
            if ((propertyChanged != null)) {
                propertyChanged(this, new System.ComponentModel.PropertyChangedEventArgs(propertyName));
            }
        }
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="TokenRedemption", Namespace="http://xonline.mix.tokenmanagement.contracts/V1")]
    [System.SerializableAttribute()]
    public partial class TokenRedemption : object, System.Runtime.Serialization.IExtensibleDataObject, System.ComponentModel.INotifyPropertyChanged {
        
        [System.NonSerializedAttribute()]
        private System.Runtime.Serialization.ExtensionDataObject extensionDataField;
        
        [System.Runtime.Serialization.OptionalFieldAttribute()]
        private System.DateTime DateRedeemedField;
        
        [System.Runtime.Serialization.OptionalFieldAttribute()]
        private ulong UserPuidField;
        
        [global::System.ComponentModel.BrowsableAttribute(false)]
        public System.Runtime.Serialization.ExtensionDataObject ExtensionData {
            get {
                return this.extensionDataField;
            }
            set {
                this.extensionDataField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public System.DateTime DateRedeemed {
            get {
                return this.DateRedeemedField;
            }
            set {
                if ((this.DateRedeemedField.Equals(value) != true)) {
                    this.DateRedeemedField = value;
                    this.RaisePropertyChanged("DateRedeemed");
                }
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public ulong UserPuid {
            get {
                return this.UserPuidField;
            }
            set {
                if ((this.UserPuidField.Equals(value) != true)) {
                    this.UserPuidField = value;
                    this.RaisePropertyChanged("UserPuid");
                }
            }
        }
        
        public event System.ComponentModel.PropertyChangedEventHandler PropertyChanged;
        
        protected void RaisePropertyChanged(string propertyName) {
            System.ComponentModel.PropertyChangedEventHandler propertyChanged = this.PropertyChanged;
            if ((propertyChanged != null)) {
                propertyChanged(this, new System.ComponentModel.PropertyChangedEventArgs(propertyName));
            }
        }
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="TokenJob", Namespace="http://xonline.mix.tokenmanagement.contracts/V1")]
    [System.SerializableAttribute()]
    public partial class TokenJob : object, System.Runtime.Serialization.IExtensibleDataObject, System.ComponentModel.INotifyPropertyChanged {
        
        [System.NonSerializedAttribute()]
        private System.Runtime.Serialization.ExtensionDataObject extensionDataField;
        
        [System.Runtime.Serialization.OptionalFieldAttribute()]
        private uint NumTokensRequestedField;
        
        [System.Runtime.Serialization.OptionalFieldAttribute()]
        private System.Guid TokenCategoryIdField;
        
        [System.Runtime.Serialization.OptionalFieldAttribute()]
        private System.Guid TokenJobIdField;
        
        [global::System.ComponentModel.BrowsableAttribute(false)]
        public System.Runtime.Serialization.ExtensionDataObject ExtensionData {
            get {
                return this.extensionDataField;
            }
            set {
                this.extensionDataField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public uint NumTokensRequested {
            get {
                return this.NumTokensRequestedField;
            }
            set {
                if ((this.NumTokensRequestedField.Equals(value) != true)) {
                    this.NumTokensRequestedField = value;
                    this.RaisePropertyChanged("NumTokensRequested");
                }
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public System.Guid TokenCategoryId {
            get {
                return this.TokenCategoryIdField;
            }
            set {
                if ((this.TokenCategoryIdField.Equals(value) != true)) {
                    this.TokenCategoryIdField = value;
                    this.RaisePropertyChanged("TokenCategoryId");
                }
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public System.Guid TokenJobId {
            get {
                return this.TokenJobIdField;
            }
            set {
                if ((this.TokenJobIdField.Equals(value) != true)) {
                    this.TokenJobIdField = value;
                    this.RaisePropertyChanged("TokenJobId");
                }
            }
        }
        
        public event System.ComponentModel.PropertyChangedEventHandler PropertyChanged;
        
        protected void RaisePropertyChanged(string propertyName) {
            System.ComponentModel.PropertyChangedEventHandler propertyChanged = this.PropertyChanged;
            if ((propertyChanged != null)) {
                propertyChanged(this, new System.ComponentModel.PropertyChangedEventArgs(propertyName));
            }
        }
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="TokenJobStatus", Namespace="http://xonline.mix.tokenmanagement.contracts/V1")]
    [System.SerializableAttribute()]
    public partial class TokenJobStatus : object, System.Runtime.Serialization.IExtensibleDataObject, System.ComponentModel.INotifyPropertyChanged {
        
        [System.NonSerializedAttribute()]
        private System.Runtime.Serialization.ExtensionDataObject extensionDataField;
        
        [System.Runtime.Serialization.OptionalFieldAttribute()]
        private string HashFileField;
        
        [System.Runtime.Serialization.OptionalFieldAttribute()]
        private bool IsStaleField;
        
        [System.Runtime.Serialization.OptionalFieldAttribute()]
        private bool IsTestField;
        
        [System.Runtime.Serialization.OptionalFieldAttribute()]
        private System.DateTime LastActivityField;
        
        [System.Runtime.Serialization.OptionalFieldAttribute()]
        private System.DateTime NextProcessingField;
        
        [System.Runtime.Serialization.OptionalFieldAttribute()]
        private uint NumFailuresField;
        
        [System.Runtime.Serialization.OptionalFieldAttribute()]
        private uint NumTokensCompletedField;
        
        [System.Runtime.Serialization.OptionalFieldAttribute()]
        private uint NumTokensRequestedField;
        
        [System.Runtime.Serialization.OptionalFieldAttribute()]
        private TokenGenerationTool.xonline.mix.tokenmanagement.contracts.v1.TokenJobStatusEnum StatusField;
        
        [System.Runtime.Serialization.OptionalFieldAttribute()]
        private System.DateTime SubmittedField;
        
        [System.Runtime.Serialization.OptionalFieldAttribute()]
        private string TokenFileField;
        
        [System.Runtime.Serialization.OptionalFieldAttribute()]
        private System.Guid TokenJobIdField;
        
        [global::System.ComponentModel.BrowsableAttribute(false)]
        public System.Runtime.Serialization.ExtensionDataObject ExtensionData {
            get {
                return this.extensionDataField;
            }
            set {
                this.extensionDataField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string HashFile {
            get {
                return this.HashFileField;
            }
            set {
                if ((object.ReferenceEquals(this.HashFileField, value) != true)) {
                    this.HashFileField = value;
                    this.RaisePropertyChanged("HashFile");
                }
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public bool IsStale {
            get {
                return this.IsStaleField;
            }
            set {
                if ((this.IsStaleField.Equals(value) != true)) {
                    this.IsStaleField = value;
                    this.RaisePropertyChanged("IsStale");
                }
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public bool IsTest {
            get {
                return this.IsTestField;
            }
            set {
                if ((this.IsTestField.Equals(value) != true)) {
                    this.IsTestField = value;
                    this.RaisePropertyChanged("IsTest");
                }
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public System.DateTime LastActivity {
            get {
                return this.LastActivityField;
            }
            set {
                if ((this.LastActivityField.Equals(value) != true)) {
                    this.LastActivityField = value;
                    this.RaisePropertyChanged("LastActivity");
                }
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public System.DateTime NextProcessing {
            get {
                return this.NextProcessingField;
            }
            set {
                if ((this.NextProcessingField.Equals(value) != true)) {
                    this.NextProcessingField = value;
                    this.RaisePropertyChanged("NextProcessing");
                }
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public uint NumFailures {
            get {
                return this.NumFailuresField;
            }
            set {
                if ((this.NumFailuresField.Equals(value) != true)) {
                    this.NumFailuresField = value;
                    this.RaisePropertyChanged("NumFailures");
                }
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public uint NumTokensCompleted {
            get {
                return this.NumTokensCompletedField;
            }
            set {
                if ((this.NumTokensCompletedField.Equals(value) != true)) {
                    this.NumTokensCompletedField = value;
                    this.RaisePropertyChanged("NumTokensCompleted");
                }
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public uint NumTokensRequested {
            get {
                return this.NumTokensRequestedField;
            }
            set {
                if ((this.NumTokensRequestedField.Equals(value) != true)) {
                    this.NumTokensRequestedField = value;
                    this.RaisePropertyChanged("NumTokensRequested");
                }
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public TokenGenerationTool.xonline.mix.tokenmanagement.contracts.v1.TokenJobStatusEnum Status {
            get {
                return this.StatusField;
            }
            set {
                if ((this.StatusField.Equals(value) != true)) {
                    this.StatusField = value;
                    this.RaisePropertyChanged("Status");
                }
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public System.DateTime Submitted {
            get {
                return this.SubmittedField;
            }
            set {
                if ((this.SubmittedField.Equals(value) != true)) {
                    this.SubmittedField = value;
                    this.RaisePropertyChanged("Submitted");
                }
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string TokenFile {
            get {
                return this.TokenFileField;
            }
            set {
                if ((object.ReferenceEquals(this.TokenFileField, value) != true)) {
                    this.TokenFileField = value;
                    this.RaisePropertyChanged("TokenFile");
                }
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public System.Guid TokenJobId {
            get {
                return this.TokenJobIdField;
            }
            set {
                if ((this.TokenJobIdField.Equals(value) != true)) {
                    this.TokenJobIdField = value;
                    this.RaisePropertyChanged("TokenJobId");
                }
            }
        }
        
        public event System.ComponentModel.PropertyChangedEventHandler PropertyChanged;
        
        protected void RaisePropertyChanged(string propertyName) {
            System.ComponentModel.PropertyChangedEventHandler propertyChanged = this.PropertyChanged;
            if ((propertyChanged != null)) {
                propertyChanged(this, new System.ComponentModel.PropertyChangedEventArgs(propertyName));
            }
        }
    }
    
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="TokenJobStatusEnum", Namespace="http://xonline.mix.tokenmanagement.contracts/V1")]
    public enum TokenJobStatusEnum : int {
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        Pending = 1,
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        InProgress = 2,
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        Delivered = 3,
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        Failed = 4,
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="TokenEntry", Namespace="http://xonline.mix.tokenmanagement.contracts/V1")]
    [System.SerializableAttribute()]
    public partial class TokenEntry : object, System.Runtime.Serialization.IExtensibleDataObject, System.ComponentModel.INotifyPropertyChanged {
        
        [System.NonSerializedAttribute()]
        private System.Runtime.Serialization.ExtensionDataObject extensionDataField;
        
        [System.Runtime.Serialization.OptionalFieldAttribute()]
        private string PkpnField;
        
        [System.Runtime.Serialization.OptionalFieldAttribute()]
        private uint SequenceNumberField;
        
        [System.Runtime.Serialization.OptionalFieldAttribute()]
        private string TokenField;
        
        [global::System.ComponentModel.BrowsableAttribute(false)]
        public System.Runtime.Serialization.ExtensionDataObject ExtensionData {
            get {
                return this.extensionDataField;
            }
            set {
                this.extensionDataField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string Pkpn {
            get {
                return this.PkpnField;
            }
            set {
                if ((object.ReferenceEquals(this.PkpnField, value) != true)) {
                    this.PkpnField = value;
                    this.RaisePropertyChanged("Pkpn");
                }
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public uint SequenceNumber {
            get {
                return this.SequenceNumberField;
            }
            set {
                if ((this.SequenceNumberField.Equals(value) != true)) {
                    this.SequenceNumberField = value;
                    this.RaisePropertyChanged("SequenceNumber");
                }
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string Token {
            get {
                return this.TokenField;
            }
            set {
                if ((object.ReferenceEquals(this.TokenField, value) != true)) {
                    this.TokenField = value;
                    this.RaisePropertyChanged("Token");
                }
            }
        }
        
        public event System.ComponentModel.PropertyChangedEventHandler PropertyChanged;
        
        protected void RaisePropertyChanged(string propertyName) {
            System.ComponentModel.PropertyChangedEventHandler propertyChanged = this.PropertyChanged;
            if ((propertyChanged != null)) {
                propertyChanged(this, new System.ComponentModel.PropertyChangedEventArgs(propertyName));
            }
        }
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="MixClientFaultBase", Namespace="http://xonline.mix.common.contracts")]
    [System.SerializableAttribute()]
    [System.Runtime.Serialization.KnownTypeAttribute(typeof(TokenGenerationTool.xonline.mix.tokenmanagement.contracts.v1.MixClientFault))]
    public partial class MixClientFaultBase : object, System.Runtime.Serialization.IExtensibleDataObject, System.ComponentModel.INotifyPropertyChanged {
        
        [System.NonSerializedAttribute()]
        private System.Runtime.Serialization.ExtensionDataObject extensionDataField;
        
        [System.Runtime.Serialization.OptionalFieldAttribute()]
        private bool IsRetryableField;
        
        [System.Runtime.Serialization.OptionalFieldAttribute()]
        private string MessageField;
        
        [global::System.ComponentModel.BrowsableAttribute(false)]
        public System.Runtime.Serialization.ExtensionDataObject ExtensionData {
            get {
                return this.extensionDataField;
            }
            set {
                this.extensionDataField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public bool IsRetryable {
            get {
                return this.IsRetryableField;
            }
            set {
                if ((this.IsRetryableField.Equals(value) != true)) {
                    this.IsRetryableField = value;
                    this.RaisePropertyChanged("IsRetryable");
                }
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string Message {
            get {
                return this.MessageField;
            }
            set {
                if ((object.ReferenceEquals(this.MessageField, value) != true)) {
                    this.MessageField = value;
                    this.RaisePropertyChanged("Message");
                }
            }
        }
        
        public event System.ComponentModel.PropertyChangedEventHandler PropertyChanged;
        
        protected void RaisePropertyChanged(string propertyName) {
            System.ComponentModel.PropertyChangedEventHandler propertyChanged = this.PropertyChanged;
            if ((propertyChanged != null)) {
                propertyChanged(this, new System.ComponentModel.PropertyChangedEventArgs(propertyName));
            }
        }
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="MixClientFault", Namespace="http://xonline.mix.common.contracts")]
    [System.SerializableAttribute()]
    public partial class MixClientFault : TokenGenerationTool.xonline.mix.tokenmanagement.contracts.v1.MixClientFaultBase {
        
        [System.Runtime.Serialization.OptionalFieldAttribute()]
        private uint HResultField;
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public uint HResult {
            get {
                return this.HResultField;
            }
            set {
                if ((this.HResultField.Equals(value) != true)) {
                    this.HResultField = value;
                    this.RaisePropertyChanged("HResult");
                }
            }
        }
    }
    
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.ServiceModel", "3.0.0.0")]
    [System.ServiceModel.ServiceContractAttribute(Namespace="http://xonline.mix.tokenmanagement.contracts/V1", ConfigurationName="xonline.mix.tokenmanagement.contracts.v1.IMixTokenManagement")]
    public interface IMixTokenManagement {
        
        [System.ServiceModel.OperationContractAttribute(Action="http://xonline.mix.tokenmanagement.contracts/V1/IMixTokenManagement/ConfigureToke" +
            "nCategory", ReplyAction="http://xonline.mix.tokenmanagement.contracts/V1/IMixTokenManagement/ConfigureToke" +
            "nCategoryResponse")]
        [System.ServiceModel.FaultContractAttribute(typeof(TokenGenerationTool.xonline.mix.tokenmanagement.contracts.v1.MixClientFault), Action="http://xonline.mix.tokenmanagement.contracts/V1/IMixTokenManagement/ConfigureToke" +
            "nCategoryMixClientFaultFault", Name="MixClientFault", Namespace="http://xonline.mix.common.contracts")]
        void ConfigureTokenCategory(TokenGenerationTool.xonline.mix.tokenmanagement.contracts.v1.TokenCategory tokenCategory);
        
        [System.ServiceModel.OperationContractAttribute(Action="http://xonline.mix.tokenmanagement.contracts/V1/IMixTokenManagement/GetTokenCateg" +
            "oryById", ReplyAction="http://xonline.mix.tokenmanagement.contracts/V1/IMixTokenManagement/GetTokenCateg" +
            "oryByIdResponse")]
        [System.ServiceModel.FaultContractAttribute(typeof(TokenGenerationTool.xonline.mix.tokenmanagement.contracts.v1.MixClientFault), Action="http://xonline.mix.tokenmanagement.contracts/V1/IMixTokenManagement/GetTokenCateg" +
            "oryByIdMixClientFaultFault", Name="MixClientFault", Namespace="http://xonline.mix.common.contracts")]
        TokenGenerationTool.xonline.mix.tokenmanagement.contracts.v1.TokenCategory GetTokenCategoryById(System.Guid id);
        
        [System.ServiceModel.OperationContractAttribute(Action="http://xonline.mix.tokenmanagement.contracts/V1/IMixTokenManagement/GetTokenCateg" +
            "oryByName", ReplyAction="http://xonline.mix.tokenmanagement.contracts/V1/IMixTokenManagement/GetTokenCateg" +
            "oryByNameResponse")]
        [System.ServiceModel.FaultContractAttribute(typeof(TokenGenerationTool.xonline.mix.tokenmanagement.contracts.v1.MixClientFault), Action="http://xonline.mix.tokenmanagement.contracts/V1/IMixTokenManagement/GetTokenCateg" +
            "oryByNameMixClientFaultFault", Name="MixClientFault", Namespace="http://xonline.mix.common.contracts")]
        TokenGenerationTool.xonline.mix.tokenmanagement.contracts.v1.TokenCategory GetTokenCategoryByName(string name);
        
        [System.ServiceModel.OperationContractAttribute(Action="http://xonline.mix.tokenmanagement.contracts/V1/IMixTokenManagement/GetTokenCateg" +
            "oryByOffer", ReplyAction="http://xonline.mix.tokenmanagement.contracts/V1/IMixTokenManagement/GetTokenCateg" +
            "oryByOfferResponse")]
        [System.ServiceModel.FaultContractAttribute(typeof(TokenGenerationTool.xonline.mix.tokenmanagement.contracts.v1.MixClientFault), Action="http://xonline.mix.tokenmanagement.contracts/V1/IMixTokenManagement/GetTokenCateg" +
            "oryByOfferMixClientFaultFault", Name="MixClientFault", Namespace="http://xonline.mix.common.contracts")]
        TokenGenerationTool.xonline.mix.tokenmanagement.contracts.v1.TokenCategory[] GetTokenCategoryByOffer(System.Guid offerId);
        
        [System.ServiceModel.OperationContractAttribute(Action="http://xonline.mix.tokenmanagement.contracts/V1/IMixTokenManagement/GetTokenInfoB" +
            "yToken", ReplyAction="http://xonline.mix.tokenmanagement.contracts/V1/IMixTokenManagement/GetTokenInfoB" +
            "yTokenResponse")]
        [System.ServiceModel.FaultContractAttribute(typeof(TokenGenerationTool.xonline.mix.tokenmanagement.contracts.v1.MixClientFault), Action="http://xonline.mix.tokenmanagement.contracts/V1/IMixTokenManagement/GetTokenInfoB" +
            "yTokenMixClientFaultFault", Name="MixClientFault", Namespace="http://xonline.mix.common.contracts")]
        TokenGenerationTool.xonline.mix.tokenmanagement.contracts.v1.TokenInfo GetTokenInfoByToken(string token);
        
        [System.ServiceModel.OperationContractAttribute(Action="http://xonline.mix.tokenmanagement.contracts/V1/IMixTokenManagement/GetTokenInfoB" +
            "yHash", ReplyAction="http://xonline.mix.tokenmanagement.contracts/V1/IMixTokenManagement/GetTokenInfoB" +
            "yHashResponse")]
        [System.ServiceModel.FaultContractAttribute(typeof(TokenGenerationTool.xonline.mix.tokenmanagement.contracts.v1.MixClientFault), Action="http://xonline.mix.tokenmanagement.contracts/V1/IMixTokenManagement/GetTokenInfoB" +
            "yHashMixClientFaultFault", Name="MixClientFault", Namespace="http://xonline.mix.common.contracts")]
        TokenGenerationTool.xonline.mix.tokenmanagement.contracts.v1.TokenInfo GetTokenInfoByHash(byte[] tokenHash);
        
        [System.ServiceModel.OperationContractAttribute(Action="http://xonline.mix.tokenmanagement.contracts/V1/IMixTokenManagement/GenerateToken" +
            "s", ReplyAction="http://xonline.mix.tokenmanagement.contracts/V1/IMixTokenManagement/GenerateToken" +
            "sResponse")]
        [System.ServiceModel.FaultContractAttribute(typeof(TokenGenerationTool.xonline.mix.tokenmanagement.contracts.v1.MixClientFault), Action="http://xonline.mix.tokenmanagement.contracts/V1/IMixTokenManagement/GenerateToken" +
            "sMixClientFaultFault", Name="MixClientFault", Namespace="http://xonline.mix.common.contracts")]
        TokenGenerationTool.xonline.mix.tokenmanagement.contracts.v1.TokenJob GenerateTokens(System.Guid tokenCategoryId, uint numTokens, byte[] key, bool isTest);
        
        [System.ServiceModel.OperationContractAttribute(Action="http://xonline.mix.tokenmanagement.contracts/V1/IMixTokenManagement/GetTokenJobSt" +
            "atus", ReplyAction="http://xonline.mix.tokenmanagement.contracts/V1/IMixTokenManagement/GetTokenJobSt" +
            "atusResponse")]
        [System.ServiceModel.FaultContractAttribute(typeof(TokenGenerationTool.xonline.mix.tokenmanagement.contracts.v1.MixClientFault), Action="http://xonline.mix.tokenmanagement.contracts/V1/IMixTokenManagement/GetTokenJobSt" +
            "atusMixClientFaultFault", Name="MixClientFault", Namespace="http://xonline.mix.common.contracts")]
        TokenGenerationTool.xonline.mix.tokenmanagement.contracts.v1.TokenJobStatus GetTokenJobStatus(System.Guid jobId);
        
        [System.ServiceModel.OperationContractAttribute(Action="http://xonline.mix.tokenmanagement.contracts/V1/IMixTokenManagement/GetTokenJobSt" +
            "atusByCategory", ReplyAction="http://xonline.mix.tokenmanagement.contracts/V1/IMixTokenManagement/GetTokenJobSt" +
            "atusByCategoryResponse")]
        [System.ServiceModel.FaultContractAttribute(typeof(TokenGenerationTool.xonline.mix.tokenmanagement.contracts.v1.MixClientFault), Action="http://xonline.mix.tokenmanagement.contracts/V1/IMixTokenManagement/GetTokenJobSt" +
            "atusByCategoryMixClientFaultFault", Name="MixClientFault", Namespace="http://xonline.mix.common.contracts")]
        TokenGenerationTool.xonline.mix.tokenmanagement.contracts.v1.TokenJobStatus[] GetTokenJobStatusByCategory(System.Guid tokenCategoryId);
        
        [System.ServiceModel.OperationContractAttribute(Action="http://xonline.mix.tokenmanagement.contracts/V1/IMixTokenManagement/GetTokens", ReplyAction="http://xonline.mix.tokenmanagement.contracts/V1/IMixTokenManagement/GetTokensResp" +
            "onse")]
        [System.ServiceModel.FaultContractAttribute(typeof(TokenGenerationTool.xonline.mix.tokenmanagement.contracts.v1.MixClientFault), Action="http://xonline.mix.tokenmanagement.contracts/V1/IMixTokenManagement/GetTokensMixC" +
            "lientFaultFault", Name="MixClientFault", Namespace="http://xonline.mix.common.contracts")]
        TokenGenerationTool.xonline.mix.tokenmanagement.contracts.v1.TokenEntry[] GetTokens(System.Guid jobId, byte[] key, int start, int count);
    }
    
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.ServiceModel", "3.0.0.0")]
    public interface IMixTokenManagementChannel : TokenGenerationTool.xonline.mix.tokenmanagement.contracts.v1.IMixTokenManagement, System.ServiceModel.IClientChannel {
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.ServiceModel", "3.0.0.0")]
    public partial class MixTokenManagementClient : System.ServiceModel.ClientBase<TokenGenerationTool.xonline.mix.tokenmanagement.contracts.v1.IMixTokenManagement>, TokenGenerationTool.xonline.mix.tokenmanagement.contracts.v1.IMixTokenManagement {
        
        public MixTokenManagementClient() {
        }
        
        public MixTokenManagementClient(string endpointConfigurationName) : 
                base(endpointConfigurationName) {
        }
        
        public MixTokenManagementClient(string endpointConfigurationName, string remoteAddress) : 
                base(endpointConfigurationName, remoteAddress) {
        }
        
        public MixTokenManagementClient(string endpointConfigurationName, System.ServiceModel.EndpointAddress remoteAddress) : 
                base(endpointConfigurationName, remoteAddress) {
        }
        
        public MixTokenManagementClient(System.ServiceModel.Channels.Binding binding, System.ServiceModel.EndpointAddress remoteAddress) : 
                base(binding, remoteAddress) {
        }
        
        public void ConfigureTokenCategory(TokenGenerationTool.xonline.mix.tokenmanagement.contracts.v1.TokenCategory tokenCategory) {
            base.Channel.ConfigureTokenCategory(tokenCategory);
        }
        
        public TokenGenerationTool.xonline.mix.tokenmanagement.contracts.v1.TokenCategory GetTokenCategoryById(System.Guid id) {
            return base.Channel.GetTokenCategoryById(id);
        }
        
        public TokenGenerationTool.xonline.mix.tokenmanagement.contracts.v1.TokenCategory GetTokenCategoryByName(string name) {
            return base.Channel.GetTokenCategoryByName(name);
        }
        
        public TokenGenerationTool.xonline.mix.tokenmanagement.contracts.v1.TokenCategory[] GetTokenCategoryByOffer(System.Guid offerId) {
            return base.Channel.GetTokenCategoryByOffer(offerId);
        }
        
        public TokenGenerationTool.xonline.mix.tokenmanagement.contracts.v1.TokenInfo GetTokenInfoByToken(string token) {
            return base.Channel.GetTokenInfoByToken(token);
        }
        
        public TokenGenerationTool.xonline.mix.tokenmanagement.contracts.v1.TokenInfo GetTokenInfoByHash(byte[] tokenHash) {
            return base.Channel.GetTokenInfoByHash(tokenHash);
        }
        
        public TokenGenerationTool.xonline.mix.tokenmanagement.contracts.v1.TokenJob GenerateTokens(System.Guid tokenCategoryId, uint numTokens, byte[] key, bool isTest) {
            return base.Channel.GenerateTokens(tokenCategoryId, numTokens, key, isTest);
        }
        
        public TokenGenerationTool.xonline.mix.tokenmanagement.contracts.v1.TokenJobStatus GetTokenJobStatus(System.Guid jobId) {
            return base.Channel.GetTokenJobStatus(jobId);
        }
        
        public TokenGenerationTool.xonline.mix.tokenmanagement.contracts.v1.TokenJobStatus[] GetTokenJobStatusByCategory(System.Guid tokenCategoryId) {
            return base.Channel.GetTokenJobStatusByCategory(tokenCategoryId);
        }
        
        public TokenGenerationTool.xonline.mix.tokenmanagement.contracts.v1.TokenEntry[] GetTokens(System.Guid jobId, byte[] key, int start, int count) {
            return base.Channel.GetTokens(jobId, key, start, count);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\perfapp\askdcperf\svrspec.h ===
#ifdef DEFINE_NAMES

WCHAR szDataMutexName[] = L"Shared Mutex for ASKDCPERF Data Collection";
WCHAR szPerfInfoMutexName[] = L"ASKDCPERF_INFO_MUTEX";
WCHAR szRegistryMutexName[] = L"ASKDCPERF_REGISTRY_MUTEX";
WCHAR szRegistryPathToPerformanceKeys[] = L"SYSTEM\\CurrentControlSet\\Services\\ASKDC\\Performance";
WCHAR szCounterDataSharedMemory[] = L"ASKDCPERF PerfAPI Counter Data ShMem";
WCHAR szGlobalInfoSharedMemory[] = L"ASKDCPERF PerfAPI Global Info ShMem";

#else

extern WCHAR szDataMutexName[];
extern WCHAR szPerfInfoMutexName[];
extern WCHAR szRegistryMutexName[];
extern WCHAR szRegistryPathToPerformanceKeys[];
extern WCHAR szCounterDataSharedMemory[];
extern WCHAR szGlobalInfoSharedMemory[];

#endif

#define PERF_APP_NAME "ASKDCPERF"
#define WIDE_PERF_APP_NAME L"ASKDCPERF"

#define MAX_PERF_OBJECTS                2
#define MAX_COUNTERS                    80
#define MAX_INSTANCES_PER_OBJECT        32

//
// Only allow a 24 character maximum on the instance name. Perfmon has trouble dealing with long
// names anyway, so if we're presented with a longer one, we truncate it. However, we attempt to
// make the truncated name unique again if possible. This value should be a multiple of 4 characters
// for perfmon not to complain.
//
#define MAX_INSTANCE_NAME               24
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\perfapp\askdcperf\askdcperf.h ===
#define ASKDCPERF_SERVER_OBJECT 0

// Do not change these without changing them in xkdcperf or xmacsperf.  The
// base perfcounter code relies on these values being the same for all of the
// KDC providers.
#define ASKDCPERF_SERVER_AS_REQ_COUNTER                          2
#define ASKDCPERF_SERVER_AS_REQ_RATE                             4
#define ASKDCPERF_SERVER_TGS_REQ_COUNTER                         6
#define ASKDCPERF_SERVER_TGS_REQ_RATE                            8

#define ASKDCPERF_SERVER_AS_SUCCESS_COUNTER                     10
#define ASKDCPERF_SERVER_AS_SUCCESS_RATE                        12
#define ASKDCPERF_SERVER_AS_FAILURE_COUNTER                     14
#define ASKDCPERF_SERVER_AS_FAILURE_RATE                        16

#define ASKDCPERF_SERVER_TGS_SUCCESS_COUNTER                    18
#define ASKDCPERF_SERVER_TGS_SUCCESS_RATE                       20
#define ASKDCPERF_SERVER_TGS_FAILURE_COUNTER                    22
#define ASKDCPERF_SERVER_TGS_FAILURE_RATE                       24

#define ASKDCPERF_SERVER_TIMESKEW_COUNTER                       26
#define ASKDCPERF_SERVER_TIMESKEW_RATE                          28
#define ASKDCPERF_SERVER_SILENT_FAILURE_COUNTER                 30
#define ASKDCPERF_SERVER_SILENT_FAILURE_RATE                    32

#define ASKDCPERF_SERVER_HTTP_REQ_COUNTER                       34
#define ASKDCPERF_SERVER_HTTP_REQ_RATE                          36
#define ASKDCPERF_SERVER_HTTP_REQ_CURRENT                       38
#define ASKDCPERF_SERVER_HTTP_REQ_TIME_AVERAGE                  40
#define ASKDCPERF_SERVER_HTTP_REQ_TIME_BASE                     42
#define ASKDCPERF_SERVER_HTTP_REQ_500_COUNTER                   44
#define ASKDCPERF_SERVER_HTTP_REQ_500_RATE                      46
#define ASKDCPERF_SERVER_HTTP_REQ_TIMEOUT_COUNTER               48
#define ASKDCPERF_SERVER_HTTP_REQ_TIMEOUT_RATE                  50
#define ASKDCPERF_SERVER_HTTP_REQ_RETRY_COUNTER                 52
#define ASKDCPERF_SERVER_HTTP_REQ_RETRY_RATE                    54

#define ASKDCPERF_SERVER_GETPRINCIPAL_COUNTER                   56
#define ASKDCPERF_SERVER_GETPRINCIPAL_RATE                      58
#define ASKDCPERF_SERVER_GETPRINCIPAL_CURRENT                   60
#define ASKDCPERF_SERVER_GETPRINCIPAL_TIME_AVERAGE              62
#define ASKDCPERF_SERVER_GETPRINCIPAL_TIME_BASE                 64


// These counters are specific to ASKDC and may be changed without affecting
// other providers.
#define ASKDCPERF_SERVER_DOS_ENTRIES_IN_USE                     66
#define ASKDCPERF_SERVER_DOS_CACHE_HIT                          68
#define ASKDCPERF_SERVER_DOS_CACHE_HIT_RATE                     70
#define ASKDCPERF_SERVER_DOS_CACHE_HIT_TOO_SOON                 72
#define ASKDCPERF_SERVER_DOS_CACHE_HIT_TOO_SOON_RATE            74
#define ASKDCPERF_SERVER_DOS_CACHE_HIT_EXISTS                   76
#define ASKDCPERF_SERVER_DOS_CACHE_HIT_EXISTS_RATE              78
#define ASKDCPERF_SERVER_DOS_CACHE_HIT_NONEXISTENT              80
#define ASKDCPERF_SERVER_DOS_CACHE_HIT_NONEXISTENT_RATE         82
#define ASKDCPERF_SERVER_DOS_CACHE_HIT_EXPIRED                  84
#define ASKDCPERF_SERVER_DOS_CACHE_HIT_EXPIRED_RATE             86
#define ASKDCPERF_SERVER_DOS_ALLOC_UNEXPIRED                    88
#define ASKDCPERF_SERVER_DOS_REPLAYS                            90
#define ASKDCPERF_SERVER_DOS_REPLAYS_RATE                       92

#define ASKDCPERF_SERVER_RPS_USER_AUTH_RATE                     94
#define ASKDCPERF_SERVER_RPS_USER_AUTH_FAILURE_RATE             96
#define ASKDCPERF_SERVER_XBOX360_MACHINE_AUTH_RATE              98
#define ASKDCPERF_SERVER_XBOX360_MACHINE_AUTH_FAILURE_RATE     100
#define ASKDCPERF_SERVER_PC_MACHINE_AUTH_RATE                  102
#define ASKDCPERF_SERVER_PC_MACHINE_AUTH_FAILURE_RATE          104
#define ASKDCPERF_SERVER_XBOX_USER_AUTH_RATE                   106
#define ASKDCPERF_SERVER_XBOX_USER_AUTH_FAILURE_RATE           108
#define ASKDCPERF_SERVER_PASSPORT_USER_AUTH_RATE               110
#define ASKDCPERF_SERVER_PASSPORT_USER_AUTH_FAILURE_RATE       112

#define ASKDCPERF_SERVER_ECHO_FAIL_CHECKSUM_RATE               114
#define ASKDCPERF_SERVER_ECHO_FAIL_CHECKSUM_TOTAL              116
#define ASKDCPERF_SERVER_ECHO_FAIL_IP_RATE                     118
#define ASKDCPERF_SERVER_ECHO_FAIL_IP_TOTAL                    120
#define ASKDCPERF_SERVER_ECHO_FAIL_TIMESTAMP_RATE              122
#define ASKDCPERF_SERVER_ECHO_FAIL_TIMESTAMP_TOTAL             124
#define ASKDCPERF_SERVER_ECHO_FAIL_NOTPRESENT_RATE             126
#define ASKDCPERF_SERVER_ECHO_FAIL_TOTAL_RATE                  128
#define ASKDCPERF_SERVER_ECHO_FAIL_PERCENT                     130
#define ASKDCPERF_SERVER_ECHO_FAIL_PERCENT_BASE                132
#define ASKDCPERF_SERVER_ECHO_SUCCESS_RATE                     134
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\perfapp\accelperf\svrspec.h ===
#ifdef DEFINE_NAMES

WCHAR szDataMutexName[] = L"Shared Mutex for AccelPerf Data Collection";
WCHAR szPerfInfoMutexName[] = L"ACCELPERF_INFO_MUTEX";
WCHAR szRegistryMutexName[] = L"ACCELPERF_REGISTRY_MUTEX";
WCHAR szRegistryPathToPerformanceKeys[] = L"SYSTEM\\CurrentControlSet\\Services\\acceleration\\Performance";
WCHAR szCounterDataSharedMemory[] = L"ACCELPERF PerfAPI Counter Data ShMem";
WCHAR szGlobalInfoSharedMemory[] = L"ACCELPERF PerfAPI Global Info ShMem";

#else

extern WCHAR szDataMutexName[];
extern WCHAR szPerfInfoMutexName[];
extern WCHAR szRegistryMutexName[];
extern WCHAR szRegistryPathToPerformanceKeys[];
extern WCHAR szCounterDataSharedMemory[];
extern WCHAR szGlobalInfoSharedMemory[];

#endif

#define PERF_APP_NAME "accelPerf"
#define WIDE_PERF_APP_NAME L"accelPerf"

#define MAX_PERF_OBJECTS                2
#define MAX_COUNTERS                    100
#define MAX_INSTANCES_PER_OBJECT        32

//
// Only allow a 24 character maximum on the instance name. Perfmon has trouble dealing with long
// names anyway, so if we're presented with a longer one, we truncate it. However, we attempt to
// make the truncated name unique again if possible. This value should be a multiple of 4 characters
// for perfmon not to complain.
//
#define MAX_INSTANCE_NAME               24
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\perfapp\kdccoreperf\kdccoreperf.h ===
// Copyright (c) Microsoft Corporation
//
// WARNING WARNING WARNING WARNING WARNING WARNING
// ***********************************************
//
//              DO NOT EDIT THIS FILE
//
// Edit kdccoreperf.ctr and use genctr.pl to rebuild.
//
// ***********************************************
// WARNING WARNING WARNING WARNING WARNING WARNING


enum XQPC_TYPES
{
    XQPC_DWORD = 1,
    XQPC_QWORD = 2,
    XQPC_OBJECT = 3
};

struct PERFCOUNTER
{
    XQPC_TYPES ctrType;
    DWORD dwPerfType;
    DWORD dwDataSize;
    DWORD dwPerfIndex;
    LONG lDataScale;
    BYTE *pbPerfCtrData;
};

struct PERFOBJECT
{
    DWORD dwPerfIndex;
    HANDLE hPerfObject;
    BYTE *pbPerfCtrDataStart;
};

// With SCALE param
#if 0

#define DWORD_AVERAGE( INDEX, SCALE ) \
    { XQPC_DWORD, PERF_AVERAGE_TIMER, sizeof(DWORD), INDEX, SCALE, NULL }

#define DWORD_BASE( INDEX, SCALE ) \
    { XQPC_DWORD, PERF_AVERAGE_BASE, sizeof(DWORD), INDEX, SCALE, NULL }

#define DWORD_COUNTER( INDEX, SCALE ) \
    { XQPC_DWORD, PERF_COUNTER_RAWCOUNT, sizeof(DWORD), INDEX, SCALE, NULL }

#define DWORD_RATE( INDEX, SCALE ) \
    { XQPC_DWORD, PERF_COUNTER_COUNTER, sizeof(DWORD), INDEX, SCALE, NULL }

#define QWORD_AVERAGE( INDEX, SCALE ) \
    { XQPC_QWORD, PERF_AVERAGE_BULK, sizeof(QWORD), INDEX, SCALE, NULL }

#define QWORD_COUNTER( INDEX, SCALE ) \
    { XQPC_QWORD, PERF_COUNTER_LARGE_RAWCOUNT, sizeof(QWORD), INDEX, SCALE, NULL }

#define QWORD_RATE( INDEX, SCALE ) \
    { XQPC_QWORD, PERF_COUNTER_BULK_COUNT, sizeof(QWORD), INDEX, SCALE, NULL }

#define QWORD_100NSTIMER( INDEX, SCALE ) \
    { XQPC_QWORD, PERF_100NSEC_TIMER, sizeof(QWORD), INDEX, SCALE, NULL}

#define QWORD_TIMER( INDEX, SCALE ) \
    { XQPC_QWORD, PERF_OBJ_TIME_TIMER, sizeof(QWORD), INDEX, SCALE, NULL}

#define OBJECT( INDEX, SCALE ) \
    { XQPC_OBJECT, 0, 0, INDEX, SCALE, NULL }

#endif

// No SCALE param
#define DWORD_AVERAGE( INDEX ) \
    { XQPC_DWORD, PERF_AVERAGE_TIMER, sizeof(DWORD), INDEX, 0, NULL }

#define DWORD_BASE( INDEX ) \
    { XQPC_DWORD, PERF_AVERAGE_BASE, sizeof(DWORD), INDEX, 0, NULL }

#define DWORD_COUNTER( INDEX ) \
    { XQPC_DWORD, PERF_COUNTER_RAWCOUNT, sizeof(DWORD), INDEX, 0, NULL }

#define DWORD_RATE( INDEX ) \
    { XQPC_DWORD, PERF_COUNTER_COUNTER, sizeof(DWORD), INDEX, 0, NULL }

#define QWORD_AVERAGE( INDEX ) \
    { XQPC_QWORD, PERF_AVERAGE_BULK, sizeof(QWORD), INDEX, 0, NULL }

#define QWORD_COUNTER( INDEX ) \
    { XQPC_QWORD, PERF_COUNTER_LARGE_RAWCOUNT, sizeof(QWORD), INDEX, 0, NULL }

#define QWORD_RATE( INDEX ) \
    { XQPC_QWORD, PERF_COUNTER_BULK_COUNT, sizeof(QWORD), INDEX, 0, NULL }

#define QWORD_100NSTIMER( INDEX ) \
    { XQPC_QWORD, PERF_100NSEC_TIMER, sizeof(QWORD), INDEX, 0, NULL}

#define QWORD_TIMER( INDEX ) \
    { XQPC_QWORD, PERF_OBJ_TIME_TIMER, sizeof(QWORD), INDEX, 0, NULL}

#define OBJECT( INDEX ) \
    { XQPC_OBJECT, 0, 0, INDEX, 0, NULL }

#define KDCCOREPERF_SERVER_OBJECT_GLOBAL                   0
#define KDCCOREPERF_ATQ_WORKERTHREAD_CREATED_COUNTER       2
#define KDCCOREPERF_ATQ_WORKERTHREAD_ALIVE_CURRENT         4
#define KDCCOREPERF_ATQ_WORKERTHREAD_ACTIVE_CURRENT        6
#define KDCCOREPERF_ATQ_WORKERTHREAD_AVAILABLE_CURRENT     8
#define KDCCOREPERF_ATQ_RECV_BYTES_RATE                    10
#define KDCCOREPERF_ATQ_XMIT_BYTES_RATE                    12
#define KDCCOREPERF_ATQ_RECV_PACKETS_RATE                  14
#define KDCCOREPERF_ATQ_XMIT_PACKETS_RATE                  16
#define KDCCOREPERF_GOODRESPONSE_RATE                      18
#define KDCCOREPERF_GOODRESPONSE_PERCENT                   20
#define KDCCOREPERF_GOODRESPONSE_PERCENT_BASE              22
#define KDCCOREPERF_BADRESPONSE_RATE                       24
#define KDCCOREPERF_BADRESPONSE_PERCENT                    26
#define KDCCOREPERF_BADRESPONSE_PERCENT_BASE               28
#define KDCCOREPERF_NORESPONSE_RATE                        30
#define KDCCOREPERF_NORESPONSE_PERCENT                     32
#define KDCCOREPERF_NORESPONSE_PERCENT_BASE                34
#define KDCCOREPERF_BUSYRESPONSE_RATE                      36
#define KDCCOREPERF_BUSYRESPONSE_PERCENT                   38
#define KDCCOREPERF_BUSYRESPONSE_PERCENT_BASE              40
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\perfapp\askdcperf\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_askdcperf_none_12.4.56.0_none_16e2f8afc15123ff
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_askdcperf_no-public-key_12.4.56.0_x-ww_ecfab817
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=askdcperf
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_askdcperf_no-public-key_12.4.56.0_x-ww_ecfab817
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_askdcperf_no-public-key_12.4.56.0_x-ww_ecfab817.manifest
XP_MANIFEST_PATH=manifests\x86_askdcperf_no-public-key_12.4.56.0_x-ww_ecfab817.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_askdcperf_no-public-key_12.4.56.0_x-ww_ecfab817.cat
XP_CATALOG_PATH=manifests\x86_askdcperf_no-public-key_12.4.56.0_x-ww_ecfab817.cat
XP_PAYLOAD_PATH=x86_askdcperf_no-public-key_12.4.56.0_x-ww_ecfab817
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=askdcperf,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\perfapp\askdcperf\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_askdcperf_none_12.4.56.0_none_16e2f8afc15123ff
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_askdcperf_no-public-key_12.4.56.0_x-ww_ecfab817
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=askdcperf
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_askdcperf_no-public-key_12.4.56.0_x-ww_ecfab817
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_askdcperf_no-public-key_12.4.56.0_x-ww_ecfab817.manifest
XP_MANIFEST_PATH=manifests\x86_askdcperf_no-public-key_12.4.56.0_x-ww_ecfab817.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_askdcperf_no-public-key_12.4.56.0_x-ww_ecfab817.cat
XP_CATALOG_PATH=manifests\x86_askdcperf_no-public-key_12.4.56.0_x-ww_ecfab817.cat
XP_PAYLOAD_PATH=x86_askdcperf_no-public-key_12.4.56.0_x-ww_ecfab817
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=askdcperf,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\perfapp\kdccoreperf\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_kdccoreperf_none_12.4.56.0_none_ef0e420147138816
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_kdccoreperf_no-public-key_12.4.56.0_x-ww_efa836a8
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=kdccoreperf
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_kdccoreperf_no-public-key_12.4.56.0_x-ww_efa836a8
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_kdccoreperf_no-public-key_12.4.56.0_x-ww_efa836a8.manifest
XP_MANIFEST_PATH=manifests\x86_kdccoreperf_no-public-key_12.4.56.0_x-ww_efa836a8.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_kdccoreperf_no-public-key_12.4.56.0_x-ww_efa836a8.cat
XP_CATALOG_PATH=manifests\x86_kdccoreperf_no-public-key_12.4.56.0_x-ww_efa836a8.cat
XP_PAYLOAD_PATH=x86_kdccoreperf_no-public-key_12.4.56.0_x-ww_efa836a8
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=kdccoreperf,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\perfapp\kdccoreperf\svrspec.h ===
#ifdef DEFINE_NAMES

WCHAR szDataMutexName[] = L"Shared Mutex for KDCCOREPERF Data Collection";
WCHAR szPerfInfoMutexName[] = L"KDCCOREPERF_INFO_MUTEX";
WCHAR szRegistryMutexName[] = L"KDCCOREPERF_REGISTRY_MUTEX";
WCHAR szRegistryPathToPerformanceKeys[] = L"SYSTEM\\CurrentControlSet\\Services\\kdc\\Performance";
WCHAR szCounterDataSharedMemory[] = L"KDCCOREPERF PerfAPI Counter Data ShMem";
WCHAR szGlobalInfoSharedMemory[] = L"KDCCOREPERF PerfAPI Global Info ShMem";

#else

extern WCHAR szDataMutexName[];
extern WCHAR szPerfInfoMutexName[];
extern WCHAR szRegistryMutexName[];
extern WCHAR szRegistryPathToPerformanceKeys[];
extern WCHAR szCounterDataSharedMemory[];
extern WCHAR szGlobalInfoSharedMemory[];

#endif

#define PERF_APP_NAME "KDCCOREPERF"
#define WIDE_PERF_APP_NAME L"KDCCOREPERF"

#define MAX_PERF_OBJECTS                2
#define MAX_COUNTERS                    80
#define MAX_INSTANCES_PER_OBJECT        32

//
// Only allow a 24 character maximum on the instance name. Perfmon has trouble dealing with long
// names anyway, so if we're presented with a longer one, we truncate it. However, we attempt to
// make the truncated name unique again if possible. This value should be a multiple of 4 characters
// for perfmon not to complain.
//
#define MAX_INSTANCE_NAME               24
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\perfapp\kdccoreperf\kdccoreperf.cpp ===
// Copyright (c) Microsoft Corporation
//
// WARNING WARNING WARNING WARNING WARNING WARNING
// ***********************************************
//
//              DO NOT EDIT THIS FILE
//
// Edit kdccoreperf.ctr and use genctr.pl to rebuild.
//
// ***********************************************
// WARNING WARNING WARNING WARNING WARNING WARNING

    OBJECT       ( KDCCOREPERF_SERVER_OBJECT_GLOBAL                   ),
    QWORD_COUNTER( KDCCOREPERF_ATQ_WORKERTHREAD_CREATED_COUNTER       ),
    QWORD_COUNTER( KDCCOREPERF_ATQ_WORKERTHREAD_ALIVE_CURRENT         ),
    QWORD_COUNTER( KDCCOREPERF_ATQ_WORKERTHREAD_ACTIVE_CURRENT        ),
    QWORD_COUNTER( KDCCOREPERF_ATQ_WORKERTHREAD_AVAILABLE_CURRENT     ),
    QWORD_RATE   ( KDCCOREPERF_ATQ_RECV_BYTES_RATE                    ),
    QWORD_RATE   ( KDCCOREPERF_ATQ_XMIT_BYTES_RATE                    ),
    QWORD_RATE   ( KDCCOREPERF_ATQ_RECV_PACKETS_RATE                  ),
    QWORD_RATE   ( KDCCOREPERF_ATQ_XMIT_PACKETS_RATE                  ),
    QWORD_RATE   ( KDCCOREPERF_GOODRESPONSE_RATE                      ),
    QWORD_AVERAGE( KDCCOREPERF_GOODRESPONSE_PERCENT                   ),
    DWORD_BASE   ( KDCCOREPERF_GOODRESPONSE_PERCENT_BASE              ),
    QWORD_RATE   ( KDCCOREPERF_BADRESPONSE_RATE                       ),
    QWORD_AVERAGE( KDCCOREPERF_BADRESPONSE_PERCENT                    ),
    DWORD_BASE   ( KDCCOREPERF_BADRESPONSE_PERCENT_BASE               ),
    QWORD_RATE   ( KDCCOREPERF_NORESPONSE_RATE                        ),
    QWORD_AVERAGE( KDCCOREPERF_NORESPONSE_PERCENT                     ),
    DWORD_BASE   ( KDCCOREPERF_NORESPONSE_PERCENT_BASE                ),
    QWORD_RATE   ( KDCCOREPERF_BUSYRESPONSE_RATE                      ),
    QWORD_AVERAGE( KDCCOREPERF_BUSYRESPONSE_PERCENT                   ),
    DWORD_BASE   ( KDCCOREPERF_BUSYRESPONSE_PERCENT_BASE              ),
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\perfapp\kdccoreperf\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_kdccoreperf_none_12.4.56.0_none_ef0e420147138816
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_kdccoreperf_no-public-key_12.4.56.0_x-ww_efa836a8
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=kdccoreperf
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_kdccoreperf_no-public-key_12.4.56.0_x-ww_efa836a8
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_kdccoreperf_no-public-key_12.4.56.0_x-ww_efa836a8.manifest
XP_MANIFEST_PATH=manifests\x86_kdccoreperf_no-public-key_12.4.56.0_x-ww_efa836a8.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_kdccoreperf_no-public-key_12.4.56.0_x-ww_efa836a8.cat
XP_CATALOG_PATH=manifests\x86_kdccoreperf_no-public-key_12.4.56.0_x-ww_efa836a8.cat
XP_PAYLOAD_PATH=x86_kdccoreperf_no-public-key_12.4.56.0_x-ww_efa836a8
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=kdccoreperf,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\perfapp\lbsvrperf\lbsvrperf.cpp ===
// Copyright (c) Microsoft Corporation
//
// WARNING WARNING WARNING WARNING WARNING WARNING
// ***********************************************
//
//              DO NOT EDIT THIS FILE
//
// Edit lbsvrperf.ctr and use genctr.pl to rebuild.
//
// ***********************************************
// WARNING WARNING WARNING WARNING WARNING WARNING

    OBJECT       ( LBPERF_SERVER_OBJECT                               ),
    DWORD_COUNTER( LBPERF_SERVER_TOTAL_MSGS_COUNTER                   ),
    DWORD_RATE   ( LBPERF_SERVER_TOTAL_MSGS_RATE                      ),
    DWORD_COUNTER( LBPERF_SERVER_FAILED_MSGS_COUNTER                  ),
    DWORD_RATE   ( LBPERF_SERVER_FAILED_MSGS_RATE                     ),
    DWORD_COUNTER( LBPERF_SERVER_TOTAL_FREE_UMS_THREAD_COUNTER        ),
    DWORD_COUNTER( LBPERF_SERVER_CONNECTION_COUNTER                   ),
    DWORD_COUNTER( LBPERF_SERVER_DBQUEUE_COUNTER                      ),
    DWORD_COUNTER( LBPERF_SERVER_TOTAL_PAGES_COUNTER                  ),
    DWORD_RATE   ( LBPERF_SERVER_PAGE_IO_RATE                         ),
    DWORD_COUNTER( LBPERF_SERVER_TOTAL_PHYSICAL_PAGES_COUNTER         ),
    DWORD_COUNTER( LBPERF_SERVER_TOTAL_PAGE_REQUESTS_IN_QUEUE         ),
    QWORD_AVERAGE( LBPERF_SERVER_DB_ROWUPDATE_EXEC_TIME               ),
    DWORD_BASE   ( LBPERF_SERVER_DB_ROWUPDATE_EXEC_TIME_BASE          ),
    QWORD_AVERAGE( LBPERF_SERVER_DB_ROWREMOVE_EXEC_TIME               ),
    DWORD_BASE   ( LBPERF_SERVER_DB_ROWREMOVE_EXEC_TIME_BASE          ),
    QWORD_AVERAGE( LBPERF_SERVER_DB_LBRESET_PART_EXEC_TIME            ),
    DWORD_BASE   ( LBPERF_SERVER_DB_LBRESET_PART_EXEC_TIME_BASE       ),
    DWORD_RATE   ( LBPERF_SERVER_DB_ROWUPDATE_RATE                    ),
    DWORD_RATE   ( LBPERF_SERVER_DB_ROWREMOVE_RATE                    ),
    DWORD_RATE   ( LBPERF_SERVER_DB_LBRESET_RATE                      ),
    DWORD_RATE   ( LBPERF_SERVER_DB_ROWREAD_RATE                      ),
    DWORD_RATE   ( LBPERF_SERVER_DB_LBRESET_FAIL_RATE                 ),
    DWORD_RATE   ( LBPERF_SERVER_DB_ROWREMOVE_FAIL_RATE               ),
    DWORD_RATE   ( LBPERF_SERVER_DB_ROWUPDATE_FAIL_RATE               ),
    OBJECT       ( LBPERF_SERVER_INSTANCES_OBJECT                     ),
    DWORD_RATE   ( LBPERF_SERVER_STAT_READ_RATE_INSTANCED             ),
    QWORD_AVERAGE( LBPERF_SERVER_STAT_READ_EXEC_TIME_INSTANCED        ),
    DWORD_BASE   ( LBPERF_SERVER_STAT_READ_EXEC_TIME_BASE_INSTANCED   ),
    DWORD_RATE   ( LBPERF_SERVER_STAT_WRITE_RATE_INSTANCED            ),
    QWORD_AVERAGE( LBPERF_SERVER_STAT_WRITE_EXEC_TIME_INSTANCED       ),
    DWORD_BASE   ( LBPERF_SERVER_STAT_WRITE_EXEC_TIME_BASE_INSTANCED  ),
    DWORD_RATE   ( LBPERF_SERVER_STAT_ENUM_RATE_INSTANCED             ),
    QWORD_AVERAGE( LBPERF_SERVER_STAT_ENUM_EXEC_TIME_INSTANCED        ),
    DWORD_BASE   ( LBPERF_SERVER_STAT_ENUM_EXEC_TIME_BASE_INSTANCED   ),
    DWORD_RATE   ( LBPERF_SERVER_STAT_ESTIMATE_RANK_RATE_INSTANCED    ),
    QWORD_AVERAGE( LBPERF_SERVER_STAT_ESTIMATE_RANK_EXEC_TIME_INSTANCED ),
    DWORD_BASE   ( LBPERF_SERVER_STAT_ESTIMATE_RANK_EXEC_TIME_BASE_INSTANCED ),
    DWORD_RATE   ( LBPERF_SERVER_STAT_RESET_RATE_INSTANCED            ),
    QWORD_AVERAGE( LBPERF_SERVER_STAT_RESET_EXEC_TIME_INSTANCED       ),
    DWORD_BASE   ( LBPERF_SERVER_STAT_RESET_EXEC_TIME_BASE_INSTANCED  ),
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\perfapp\lbsvrperf\perfctrs.cpp ===
#include "perfappp.h"
#include "lbsvrperf.h"
#include "perfctrscommon.h"

PERFCOUNTER s_ServerPerfCtrs [] =
{
	#include "lbsvrperf.cpp"
};

DWORD NUM_SERVER_PERF_COUNTERS = (ARRAY_ELEMENTS(s_ServerPerfCtrs));
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\perfapp\lbsvrperf\lbsvrperf.h ===
// Copyright (c) Microsoft Corporation
//
// WARNING WARNING WARNING WARNING WARNING WARNING
// ***********************************************
//
//              DO NOT EDIT THIS FILE
//
// Edit lbsvrperf.ctr and use genctr.pl to rebuild.
//
// ***********************************************
// WARNING WARNING WARNING WARNING WARNING WARNING

#define LBPERF_SERVER_OBJECT                               0
#define LBPERF_SERVER_TOTAL_MSGS_COUNTER                   2
#define LBPERF_SERVER_TOTAL_MSGS_RATE                      4
#define LBPERF_SERVER_FAILED_MSGS_COUNTER                  6
#define LBPERF_SERVER_FAILED_MSGS_RATE                     8
#define LBPERF_SERVER_TOTAL_FREE_UMS_THREAD_COUNTER        10
#define LBPERF_SERVER_CONNECTION_COUNTER                   12
#define LBPERF_SERVER_DBQUEUE_COUNTER                      14
#define LBPERF_SERVER_TOTAL_PAGES_COUNTER                  16
#define LBPERF_SERVER_PAGE_IO_RATE                         18
#define LBPERF_SERVER_TOTAL_PHYSICAL_PAGES_COUNTER         20
#define LBPERF_SERVER_TOTAL_PAGE_REQUESTS_IN_QUEUE         22
#define LBPERF_SERVER_DB_ROWUPDATE_EXEC_TIME               24
#define LBPERF_SERVER_DB_ROWUPDATE_EXEC_TIME_BASE          26
#define LBPERF_SERVER_DB_ROWREMOVE_EXEC_TIME               28
#define LBPERF_SERVER_DB_ROWREMOVE_EXEC_TIME_BASE          30
#define LBPERF_SERVER_DB_LBRESET_PART_EXEC_TIME            32
#define LBPERF_SERVER_DB_LBRESET_PART_EXEC_TIME_BASE       34
#define LBPERF_SERVER_DB_ROWUPDATE_RATE                    36
#define LBPERF_SERVER_DB_ROWREMOVE_RATE                    38
#define LBPERF_SERVER_DB_LBRESET_RATE                      40
#define LBPERF_SERVER_DB_ROWREAD_RATE                      42
#define LBPERF_SERVER_DB_LBRESET_FAIL_RATE                 44
#define LBPERF_SERVER_DB_ROWREMOVE_FAIL_RATE               46
#define LBPERF_SERVER_DB_ROWUPDATE_FAIL_RATE               48
#define LBPERF_SERVER_INSTANCES_OBJECT                     50
#define LBPERF_SERVER_STAT_READ_RATE_INSTANCED             52
#define LBPERF_SERVER_STAT_READ_EXEC_TIME_INSTANCED        54
#define LBPERF_SERVER_STAT_READ_EXEC_TIME_BASE_INSTANCED   56
#define LBPERF_SERVER_STAT_WRITE_RATE_INSTANCED            58
#define LBPERF_SERVER_STAT_WRITE_EXEC_TIME_INSTANCED       60
#define LBPERF_SERVER_STAT_WRITE_EXEC_TIME_BASE_INSTANCED  62
#define LBPERF_SERVER_STAT_ENUM_RATE_INSTANCED             64
#define LBPERF_SERVER_STAT_ENUM_EXEC_TIME_INSTANCED        66
#define LBPERF_SERVER_STAT_ENUM_EXEC_TIME_BASE_INSTANCED   68
#define LBPERF_SERVER_STAT_ESTIMATE_RANK_RATE_INSTANCED    70
#define LBPERF_SERVER_STAT_ESTIMATE_RANK_EXEC_TIME_INSTANCED 72
#define LBPERF_SERVER_STAT_ESTIMATE_RANK_EXEC_TIME_BASE_INSTANCED 74
#define LBPERF_SERVER_STAT_RESET_RATE_INSTANCED            76
#define LBPERF_SERVER_STAT_RESET_EXEC_TIME_INSTANCED       78
#define LBPERF_SERVER_STAT_RESET_EXEC_TIME_BASE_INSTANCED  80
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\perfapp\lbsvrperf\svrspec.h ===
#ifdef DEFINE_NAMES

WCHAR szDataMutexName[] = L"Shared Mutex for LBSVR Data Collection";
WCHAR szPerfInfoMutexName[] = L"LBSVRPERF_INFO_MUTEX";
WCHAR szRegistryMutexName[] = L"LBSVRPERF_REGISTRY_MUTEX";
WCHAR szRegistryPathToPerformanceKeys[] = L"SYSTEM\\CurrentControlSet\\Services\\LBSVR\\Performance";
WCHAR szCounterDataSharedMemory[] = L"LBSVR PerfAPI Counter Data ShMem";
WCHAR szGlobalInfoSharedMemory[] = L"LBSVR PerfAPI Global Info ShMem";

#else

extern WCHAR szDataMutexName[];
extern WCHAR szPerfInfoMutexName[];
extern WCHAR szRegistryMutexName[];
extern WCHAR szRegistryPathToPerformanceKeys[];
extern WCHAR szCounterDataSharedMemory[];
extern WCHAR szGlobalInfoSharedMemory[];

#endif

#define PERF_APP_NAME "LBSVRPERF"
#define WIDE_PERF_APP_NAME L"LBSVRPERF"

#define MAX_PERF_OBJECTS                2
#define MAX_COUNTERS                    100
#define MAX_INSTANCES_PER_OBJECT        1000

//
// Only allow a 24 character maximum on the instance name. Perfmon has trouble dealing with long
// names anyway, so if we're presented with a longer one, we truncate it. However, we attempt to
// make the truncated name unique again if possible. This value should be a multiple of 4 characters
// for perfmon not to complain.
//
#define MAX_INSTANCE_NAME               24
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\perfapp\presperf\presperf.h ===
// Copyright (c) Microsoft Corporation
//
// WARNING WARNING WARNING WARNING WARNING WARNING
// ***********************************************
//
//              DO NOT EDIT THIS FILE
//
// Edit presperf.ctr and use genctr.pl to rebuild.
//
// ***********************************************
// WARNING WARNING WARNING WARNING WARNING WARNING

#define XPPERF_SERVER_OBJECT                               0
#define XPPERF_SERVER_ACTIVE_USERS_COUNTER                 2
#define XPPERF_SERVER_USER_SESSION_TIME_AVERAGE            4
#define XPPERF_SERVER_USER_SESSION_TIME_BASE               6
#define XPPERF_SERVER_CLIENT_CONNECTIONS_COUNTER           8
#define XPPERF_SERVER_DROPPED_CLIENT_CONNECTIONS_COUNTER   10
#define XPPERF_SERVER_DROPPED_CLIENT_CONNECTIONS_RATE      12
#define XPPERF_SERVER_Q_CONNECTIONS_COUNTER                14
#define XPPERF_SERVER_DROPPED_Q_CONNECTIONS_COUNTER        16
#define XPPERF_SERVER_DROPPED_Q_CONNECTIONS_RATE           18
#define XPPERF_SERVER_PCONN_MSGS_SEND_COUNT                20
#define XPPERF_SERVER_PCONN_MSGS_SEND_RATE                 22
#define XPPERF_SERVER_PCONN_MSGS_RECV_COUNT                24
#define XPPERF_SERVER_PCONN_MSGS_RECV_RATE                 26
#define XPPERF_SERVER_PCONN_BYTES_SEND_COUNT               28
#define XPPERF_SERVER_PCONN_BYTES_SEND_RATE                30
#define XPPERF_SERVER_PCONN_BYTES_RECV_COUNT               32
#define XPPERF_SERVER_PCONN_BYTES_RECV_RATE                34
#define XPPERF_SERVER_PRES_CONNECTIONS_COUNTER             36
#define XPPERF_SERVER_DROPPED_PRES_CONNECTIONS_COUNTER     38
#define XPPERF_SERVER_DROPPED_PRES_CONNECTIONS_RATE        40
#define XPPERF_SERVER_BAD_USER_COUNTER                     42
#define XPPERF_SERVER_BAD_USER_RATE                        44
#define XPPERF_SERVER_TOTAL_MSGS_COUNTER                   46
#define XPPERF_SERVER_TOTAL_MSGS_RATE                      48
#define XPPERF_SERVER_FAILED_MSGS_COUNTER                  50
#define XPPERF_SERVER_FAILED_MSGS_RATE                     52
#define XPPERF_SERVER_HELLO_MSGS_COUNTER                   54
#define XPPERF_SERVER_HELLO_MSGS_RATE                      56
#define XPPERF_SERVER_ALIVE_MSGS_COUNTER                   58
#define XPPERF_SERVER_ALIVE_MSGS_RATE                      60
#define XPPERF_SERVER_SYNC_MSGS_COUNTER                    62
#define XPPERF_SERVER_SYNC_MSGS_RATE                       64
#define XPPERF_SERVER_NICKNAME_MSGS_COUNTER                66
#define XPPERF_SERVER_NICKNAME_MSGS_RATE                   68
#define XPPERF_SERVER_REFRESH_MSGS_COUNTER                 70
#define XPPERF_SERVER_REFRESH_MSGS_RATE                    72
#define XPPERF_SERVER_ADD_MSGS_COUNTER                     74
#define XPPERF_SERVER_ADD_MSGS_RATE                        76
#define XPPERF_SERVER_ADD_AFFILIATES_MSGS_COUNTER          78
#define XPPERF_SERVER_ADD_AFFILIATES_MSGS_RATE             80
#define XPPERF_SERVER_IS_AFFILIATE_MSGS_COUNTER            82
#define XPPERF_SERVER_IS_AFFILIATE_MSGS_RATE               84
#define XPPERF_SERVER_QUERY_AFFILIATES_MSGS_COUNTER        86
#define XPPERF_SERVER_QUERY_AFFILIATES_MSGS_RATE           88
#define XPPERF_SERVER_GET_PRESENCE_INFO_MSGS_COUNTER       90
#define XPPERF_SERVER_GET_PRESENCE_INFO_MSGS_RATE          92
#define XPPERF_SERVER_DELETE_MSGS_COUNTER                  94
#define XPPERF_SERVER_DELETE_MSGS_RATE                     96
#define XPPERF_SERVER_ACCEPT_MSGS_COUNTER                  98
#define XPPERF_SERVER_ACCEPT_MSGS_RATE                     100
#define XPPERF_SERVER_REJECT_MSGS_COUNTER                  102
#define XPPERF_SERVER_REJECT_MSGS_RATE                     104
#define XPPERF_SERVER_BLOCK_MSGS_COUNTER                   106
#define XPPERF_SERVER_BLOCK_MSGS_RATE                      108
#define XPPERF_SERVER_UNBLOCK_MSGS_COUNTER                 110
#define XPPERF_SERVER_UNBLOCK_MSGS_RATE                    112
#define XPPERF_SERVER_INVITE_MSGS_COUNTER                  114
#define XPPERF_SERVER_INVITE_MSGS_RATE                     116
#define XPPERF_SERVER_ANSWER_INV_MSGS_COUNTER              118
#define XPPERF_SERVER_ANSWER_INV_MSGS_RATE                 120
#define XPPERF_SERVER_CANCEL_INV_MSGS_COUNTER              122
#define XPPERF_SERVER_CANCEL_INV_MSGS_RATE                 124
#define XPPERF_SERVER_STATE_MSGS_COUNTER                   126
#define XPPERF_SERVER_STATE_MSGS_RATE                      128
#define XPPERF_SERVER_DEAD_USER_MSGS_COUNTER               130
#define XPPERF_SERVER_DEAD_USER_MSGS_RATE                  132
#define XPPERF_SERVER_DEAD_XBOX_MSGS_COUNTER               134
#define XPPERF_SERVER_DEAD_XBOX_MSGS_RATE                  136
#define XPPERF_SERVER_DEAD_SG_MSGS_COUNTER                 138
#define XPPERF_SERVER_DEAD_SG_MSGS_RATE                    140
#define XPPERF_SERVER_ANNOUNCE_MSGS_COUNTER                142
#define XPPERF_SERVER_ANNOUNCE_MSGS_RATE                   144
#define XPPERF_SERVER_SUBSCRIBE_MSGS_COUNTER               146
#define XPPERF_SERVER_SUBSCRIBE_MSGS_RATE                  148
#define XPPERF_SERVER_UNSUBSCRIBE_MSGS_COUNTER             150
#define XPPERF_SERVER_UNSUBSCRIBE_MSGS_RATE                152
#define XPPERF_SERVER_ADDED_MSGS_COUNTER                   154
#define XPPERF_SERVER_ADDED_MSGS_RATE                      156
#define XPPERF_SERVER_ACCEPTED_MSGS_COUNTER                158
#define XPPERF_SERVER_ACCEPTED_MSGS_RATE                   160
#define XPPERF_SERVER_REMOVED_MSGS_COUNTER                 162
#define XPPERF_SERVER_REMOVED_MSGS_RATE                    164
#define XPPERF_SERVER_LIST_CHANGE_NOT_COUNTER              166
#define XPPERF_SERVER_LIST_CHANGE_NOT_RATE                 168
#define XPPERF_SERVER_PRESENCE_NOT_COUNTER                 170
#define XPPERF_SERVER_PRESENCE_NOT_RATE                    172
#define XPPERF_SERVER_INVITATION_NOT_COUNTER               174
#define XPPERF_SERVER_INVITATION_NOT_RATE                  176
#define XPPERF_SERVER_INV_ANSWER_NOT_COUNTER               178
#define XPPERF_SERVER_INV_ANSWER_NOT_RATE                  180
#define XPPERF_SERVER_KICK_MSGS_COUNTER                    182
#define XPPERF_SERVER_KICK_MSGS_RATE                       184
#define XPPERF_SERVER_SQL_WORK_ITEMS                       186
#define XPPERF_SERVER_TOTAL_USERS_COUNTER                  188
#define XPPERF_SERVER_ALIVE_CACHE_HIT_COUNTER              190
#define XPPERF_SERVER_ALIVE_CACHE_HIT_RATE                 192
#define XPPERF_SERVER_WEB_ALIVE_MSGS_COUNTER               194
#define XPPERF_SERVER_WEB_ALIVE_MSGS_RATE                  196
#define XPPERF_SERVER_WEB_ANNOUNCE_MSGS_COUNTER            198
#define XPPERF_SERVER_WEB_ANNOUNCE_MSGS_RATE               200
#define XPPERF_SERVER_WEB_SUBSCRIBE_MSGS_COUNTER           202
#define XPPERF_SERVER_WEB_SUBSCRIBE_MSGS_RATE              204
#define XPPERF_SERVER_WEB_UNSUBSCRIBE_MSGS_COUNTER         206
#define XPPERF_SERVER_WEB_UNSUBSCRIBE_MSGS_RATE            208
#define XPPERF_SERVER_PEER_SESSION_MSGS_COUNTER            210
#define XPPERF_SERVER_PEER_SESSION_MSGS_RATE               212
#define XPPERF_SERVER_TEAM_LIST_TEAMS_MSGS_COUNTER         214
#define XPPERF_SERVER_TEAM_LIST_TEAMS_MSGS_RATE            216
#define XPPERF_SERVER_TEAM_LIST_MEMBERS_MSGS_COUNTER       218
#define XPPERF_SERVER_TEAM_LIST_MEMBERS_MSGS_RATE          220
#define XPPERF_SERVER_PEER_SUBSCRIBE_MSGS_COUNTER          222
#define XPPERF_SERVER_PEER_SUBSCRIBE_MSGS_RATE             224
#define XPPERF_SERVER_PEER_UNSUBSCRIBE_MSGS_COUNTER        226
#define XPPERF_SERVER_PEER_UNSUBSCRIBE_MSGS_RATE           228
#define XPPERF_SERVER_TEAM_CREATE_MSGS_COUNTER             230
#define XPPERF_SERVER_TEAM_CREATE_MSGS_RATE                232
#define XPPERF_SERVER_TEAM_DELETE_MSGS_COUNTER             234
#define XPPERF_SERVER_TEAM_DELETE_MSGS_RATE                236
#define XPPERF_SERVER_TEAM_REMOVE_MSGS_COUNTER             238
#define XPPERF_SERVER_TEAM_REMOVE_MSGS_RATE                240
#define XPPERF_SERVER_TEAM_MANAGE_TEAM_MSGS_COUNTER        242
#define XPPERF_SERVER_TEAM_MANAGE_TEAM_MSGS_RATE           244
#define XPPERF_SERVER_TEAM_MANAGE_MEMBER_MSGS_COUNTER      246
#define XPPERF_SERVER_TEAM_MANAGE_MEMBER_MSGS_RATE         248
#define XPPERF_SERVER_TEAM_RECRUIT_MSGS_COUNTER            250
#define XPPERF_SERVER_TEAM_RECRUIT_MSGS_RATE               252
#define XPPERF_SERVER_TEAM_JOIN_MSGS_COUNTER               254
#define XPPERF_SERVER_TEAM_JOIN_MSGS_RATE                  256
#define XPPERF_SERVER_TEAM_GET_TICKET_MSGS_COUNTER         258
#define XPPERF_SERVER_TEAM_GET_TICKET_MSGS_RATE            260
#define XPPERF_SERVER_LOGON_ALERT_COUNTER                  262
#define XPPERF_SERVER_LOGON_ALERT_RATE                     264
#define XPPERF_SERVER_SWITCHBOARD_QUEUE_WAIT_TIME_AVERAGE  266
#define XPPERF_SERVER_SWITCHBOARD_QUEUE_WAIT_TIME_BASE     268
#define XPPERF_SERVER_SQL_QUEUE_WAIT_TIME_AVERAGE          270
#define XPPERF_SERVER_SQL_QUEUE_WAIT_TIME_BASE             272
#define XPPERF_SERVER_HEARTBEAT_TIME_AVERAGE               274
#define XPPERF_SERVER_HEARTBEAT_TIME_BASE                  276
#define XPPERF_SERVER_ALIVE_CLIENT_TIME_AVERAGE            278
#define XPPERF_SERVER_ALIVE_CLIENT_TIME_BASE               280
#define XPPERF_SERVER_ALIVE_STORE_TIME_AVERAGE             282
#define XPPERF_SERVER_ALIVE_STORE_TIME_BASE                284
#define XPPERF_SERVER_ALIVE_STORE_COMPLETE_TIME_AVERAGE    286
#define XPPERF_SERVER_ALIVE_STORE_COMPLETE_TIME_BASE       288
#define XPPERF_SERVER_ALIVE_USER_INFO_COMPLETE_TIME_AVERAGE 290
#define XPPERF_SERVER_ALIVE_USER_INFO_COMPLETE_TIME_BASE   292
#define XPPERF_SERVER_SYNC_CLIENT_TIME_AVERAGE             294
#define XPPERF_SERVER_SYNC_CLIENT_TIME_BASE                296
#define XPPERF_SERVER_SYNC_STORE_TIME_AVERAGE              298
#define XPPERF_SERVER_SYNC_STORE_TIME_BASE                 300
#define XPPERF_SERVER_SYNC_COMPLETION_TIME_AVERAGE         302
#define XPPERF_SERVER_SYNC_COMPLETION_TIME_BASE            304
#define XPPERF_SERVER_ADD_BUDDY_CLIENT_TIME_AVERAGE        306
#define XPPERF_SERVER_ADD_BUDDY_CLIENT_TIME_BASE           308
#define XPPERF_SERVER_ADD_AFFILIATES_CLIENT_TIME_AVERAGE   310
#define XPPERF_SERVER_ADD_AFFILIATES_CLIENT_TIME_BASE      312
#define XPPERF_SERVER_IS_AFFILIATE_CLIENT_TIME_AVERAGE     314
#define XPPERF_SERVER_IS_AFFILIATE_CLIENT_TIME_BASE        316
#define XPPERF_SERVER_QUERY_AFFILIATES_CLIENT_TIME_AVERAGE 318
#define XPPERF_SERVER_QUERY_AFFILIATES_CLIENT_TIME_BASE    320
#define XPPERF_SERVER_GET_PRESENCE_INFO_PEER_TIME_AVERAGE  322
#define XPPERF_SERVER_GET_PRESENCE_INFO_PEER_TIME_BASE     324
#define XPPERF_SERVER_ADD_BUDDY_STORE_TIME_AVERAGE         326
#define XPPERF_SERVER_ADD_BUDDY_STORE_TIME_BASE            328
#define XPPERF_SERVER_ADD_AFFILIATES_STORE_TIME_AVERAGE    330
#define XPPERF_SERVER_ADD_AFFILIATES_STORE_TIME_BASE       332
#define XPPERF_SERVER_IS_AFFILIATE_STORE_TIME_AVERAGE      334
#define XPPERF_SERVER_IS_AFFILIATE_STORE_TIME_BASE         336
#define XPPERF_SERVER_QUERY_AFFILIATES_STORE_TIME_AVERAGE  338
#define XPPERF_SERVER_QUERY_AFFILIATES_STORE_TIME_BASE     340
#define XPPERF_SERVER_ADD_BUDDY_COMPLETION_TIME_AVERAGE    342
#define XPPERF_SERVER_ADD_BUDDY_COMPLETION_TIME_BASE       344
#define XPPERF_SERVER_ADD_AFFILIATES_COMPLETION_TIME_AVERAGE 346
#define XPPERF_SERVER_ADD_AFFILIATES_COMPLETION_TIME_BASE  348
#define XPPERF_SERVER_IS_AFFILIATE_COMPLETION_TIME_AVERAGE 350
#define XPPERF_SERVER_IS_AFFILIATE_COMPLETION_TIME_BASE    352
#define XPPERF_SERVER_QUERY_AFFILIATES_COMPLETION_TIME_AVERAGE 354
#define XPPERF_SERVER_QUERY_AFFILIATES_COMPLETION_TIME_BASE 356
#define XPPERF_SERVER_ACCEPT_BUDDY_CLIENT_TIME_AVERAGE     358
#define XPPERF_SERVER_ACCEPT_BUDDY_CLIENT_TIME_BASE        360
#define XPPERF_SERVER_ACCEPT_BUDDY_STORE_TIME_AVERAGE      362
#define XPPERF_SERVER_ACCEPT_BUDDY_STORE_TIME_BASE         364
#define XPPERF_SERVER_ACCEPT_BUDDY_COMPLETION_TIME_AVERAGE 366
#define XPPERF_SERVER_ACCEPT_BUDDY_COMPLETION_TIME_BASE    368
#define XPPERF_SERVER_REJECT_BUDDY_CLIENT_TIME_AVERAGE     370
#define XPPERF_SERVER_REJECT_BUDDY_CLIENT_TIME_BASE        372
#define XPPERF_SERVER_REJECT_BUDDY_STORE_TIME_AVERAGE      374
#define XPPERF_SERVER_REJECT_BUDDY_STORE_TIME_BASE         376
#define XPPERF_SERVER_REJECT_BUDDY_COMPLETION_TIME_AVERAGE 378
#define XPPERF_SERVER_REJECT_BUDDY_COMPLETION_TIME_BASE    380
#define XPPERF_SERVER_DELETE_BUDDY_CLIENT_TIME_AVERAGE     382
#define XPPERF_SERVER_DELETE_BUDDY_CLIENT_TIME_BASE        384
#define XPPERF_SERVER_DELETE_BUDDY_STORE_TIME_AVERAGE      386
#define XPPERF_SERVER_DELETE_BUDDY_STORE_TIME_BASE         388
#define XPPERF_SERVER_DELETE_BUDDY_COMPLETION_TIME_AVERAGE 390
#define XPPERF_SERVER_DELETE_BUDDY_COMPLETION_TIME_BASE    392
#define XPPERF_SERVER_MUTE_CLIENT_TIME_AVERAGE             394
#define XPPERF_SERVER_MUTE_CLIENT_TIME_BASE                396
#define XPPERF_SERVER_MUTE_STORE_TIME_AVERAGE              398
#define XPPERF_SERVER_MUTE_STORE_TIME_BASE                 400
#define XPPERF_SERVER_MUTE_COMPLETION_TIME_AVERAGE         402
#define XPPERF_SERVER_MUTE_COMPLETION_TIME_BASE            404
#define XPPERF_SERVER_UNMUTE_CLIENT_TIME_AVERAGE           406
#define XPPERF_SERVER_UNMUTE_CLIENT_TIME_BASE              408
#define XPPERF_SERVER_UNMUTE_STORE_TIME_AVERAGE            410
#define XPPERF_SERVER_UNMUTE_STORE_TIME_BASE               412
#define XPPERF_SERVER_UNMUTE_COMPLETION_TIME_AVERAGE       414
#define XPPERF_SERVER_UNMUTE_COMPLETION_TIME_BASE          416
#define XPPERF_SERVER_FLUSH_TICKETS_STORE_TIME_AVERAGE     418
#define XPPERF_SERVER_FLUSH_TICKETS_STORE_TIME_BASE        420
#define XPPERF_SERVER_WEB_ALIVE_CLIENT_TIME_AVERAGE        422
#define XPPERF_SERVER_WEB_ALIVE_CLIENT_TIME_BASE           424
#define XPPERF_SERVER_WEB_ALIVE_STORE_TIME_AVERAGE         426
#define XPPERF_SERVER_WEB_ALIVE_STORE_TIME_BASE            428
#define XPPERF_SERVER_WEB_ALIVE_STORE_COMPLETE_TIME_AVERAGE 430
#define XPPERF_SERVER_WEB_ALIVE_STORE_COMPLETE_TIME_BASE   432
#define XPPERF_SERVER_WEB_ALIVE_USER_INFO_COMPLETE_TIME_AVERAGE 434
#define XPPERF_SERVER_WEB_ALIVE_USER_INFO_COMPLETE_TIME_BASE 436
#define XPPERF_SERVER_LIST_TEAMS_CLIENT_TIME_AVERAGE       438
#define XPPERF_SERVER_LIST_TEAMS_CLIENT_TIME_BASE          440
#define XPPERF_SERVER_LIST_TEAMS_STORE_TIME_AVERAGE        442
#define XPPERF_SERVER_LIST_TEAMS_STORE_TIME_BASE           444
#define XPPERF_SERVER_LIST_TEAMS_COMPLETION_TIME_AVERAGE   446
#define XPPERF_SERVER_LIST_TEAMS_COMPLETION_TIME_BASE      448
#define XPPERF_SERVER_LIST_TEAM_MEMBERS_CLIENT_TIME_AVERAGE 450
#define XPPERF_SERVER_LIST_TEAM_MEMBERS_CLIENT_TIME_BASE   452
#define XPPERF_SERVER_LIST_TEAM_MEMBERS_STORE_TIME_AVERAGE 454
#define XPPERF_SERVER_LIST_TEAM_MEMBERS_STORE_TIME_BASE    456
#define XPPERF_SERVER_LIST_TEAM_MEMBERS_COMPLETION_TIME_AVERAGE 458
#define XPPERF_SERVER_LIST_TEAM_MEMBERS_COMPLETION_TIME_BASE 460
#define XPPERF_SERVER_TEAM_CREATE_CLIENT_TIME_AVERAGE      462
#define XPPERF_SERVER_TEAM_CREATE_CLIENT_TIME_BASE         464
#define XPPERF_SERVER_TEAM_CREATE_STORE_TIME_AVERAGE       466
#define XPPERF_SERVER_TEAM_CREATE_STORE_TIME_BASE          468
#define XPPERF_SERVER_TEAM_CREATE_COMPLETION_TIME_AVERAGE  470
#define XPPERF_SERVER_TEAM_CREATE_COMPLETION_TIME_BASE     472
#define XPPERF_SERVER_TEAM_DELETE_CLIENT_TIME_AVERAGE      474
#define XPPERF_SERVER_TEAM_DELETE_CLIENT_TIME_BASE         476
#define XPPERF_SERVER_TEAM_DELETE_STORE_TIME_AVERAGE       478
#define XPPERF_SERVER_TEAM_DELETE_STORE_TIME_BASE          480
#define XPPERF_SERVER_TEAM_DELETE_COMPLETION_TIME_AVERAGE  482
#define XPPERF_SERVER_TEAM_DELETE_COMPLETION_TIME_BASE     484
#define XPPERF_SERVER_TEAM_REMOVE_MEMBER_CLIENT_TIME_AVERAGE 486
#define XPPERF_SERVER_TEAM_REMOVE_MEMBER_CLIENT_TIME_BASE  488
#define XPPERF_SERVER_TEAM_REMOVE_MEMBER_STORE_TIME_AVERAGE 490
#define XPPERF_SERVER_TEAM_REMOVE_MEMBER_STORE_TIME_BASE   492
#define XPPERF_SERVER_TEAM_REMOVE_MEMBER_COMPLETION_TIME_AVERAGE 494
#define XPPERF_SERVER_TEAM_REMOVE_MEMBER_COMPLETION_TIME_BASE 496
#define XPPERF_SERVER_TEAM_MANAGE_CLIENT_TIME_AVERAGE      498
#define XPPERF_SERVER_TEAM_MANAGE_CLIENT_TIME_BASE         500
#define XPPERF_SERVER_TEAM_MANAGE_STORE_TIME_AVERAGE       502
#define XPPERF_SERVER_TEAM_MANAGE_STORE_TIME_BASE          504
#define XPPERF_SERVER_TEAM_MANAGE_COMPLETION_TIME_AVERAGE  506
#define XPPERF_SERVER_TEAM_MANAGE_COMPLETION_TIME_BASE     508
#define XPPERF_SERVER_TEAM_MANAGE_MEMBER_CLIENT_TIME_AVERAGE 510
#define XPPERF_SERVER_TEAM_MANAGE_MEMBER_CLIENT_TIME_BASE  512
#define XPPERF_SERVER_TEAM_MANAGE_MEMBER_STORE_TIME_AVERAGE 514
#define XPPERF_SERVER_TEAM_MANAGE_MEMBER_STORE_TIME_BASE   516
#define XPPERF_SERVER_TEAM_MANAGE_MEMBER_COMPLETION_TIME_AVERAGE 518
#define XPPERF_SERVER_TEAM_MANAGE_MEMBER_COMPLETION_TIME_BASE 520
#define XPPERF_SERVER_TEAM_RECRUIT_CLIENT_TIME_AVERAGE     522
#define XPPERF_SERVER_TEAM_RECRUIT_CLIENT_TIME_BASE        524
#define XPPERF_SERVER_TEAM_RECRUIT_STORE_TIME_AVERAGE      526
#define XPPERF_SERVER_TEAM_RECRUIT_STORE_TIME_BASE         528
#define XPPERF_SERVER_TEAM_RECRUIT_COMPLETION_TIME_AVERAGE 530
#define XPPERF_SERVER_TEAM_RECRUIT_COMPLETION_TIME_BASE    532
#define XPPERF_SERVER_TEAM_JOIN_CLIENT_TIME_AVERAGE        534
#define XPPERF_SERVER_TEAM_JOIN_CLIENT_TIME_BASE           536
#define XPPERF_SERVER_TEAM_JOIN_STORE_TIME_AVERAGE         538
#define XPPERF_SERVER_TEAM_JOIN_STORE_TIME_BASE            540
#define XPPERF_SERVER_TEAM_JOIN_COMPLETION_TIME_AVERAGE    542
#define XPPERF_SERVER_TEAM_JOIN_COMPLETION_TIME_BASE       544
#define XPPERF_SERVER_TEAM_GET_TICKET_CLIENT_TIME_AVERAGE  546
#define XPPERF_SERVER_TEAM_GET_TICKET_CLIENT_TIME_BASE     548
#define XPPERF_SERVER_TEAM_GET_TICKET_STORE_TIME_AVERAGE   550
#define XPPERF_SERVER_TEAM_GET_TICKET_STORE_TIME_BASE      552
#define XPPERF_SERVER_TEAM_GET_TICKET_COMPLETION_TIME_AVERAGE 554
#define XPPERF_SERVER_TEAM_GET_TICKET_COMPLETION_TIME_BASE 556
#define XPPERF_SERVER_INVITE_CLIENT_TIME_AVERAGE           558
#define XPPERF_SERVER_INVITE_CLIENT_TIME_BASE              560
#define XPPERF_SERVER_CANCEL_INVITE_CLIENT_TIME_AVERAGE    562
#define XPPERF_SERVER_CANCEL_INVITE_CLIENT_TIME_BASE       564
#define XPPERF_SERVER_INVITE_ANSWER_CLIENT_TIME_AVERAGE    566
#define XPPERF_SERVER_INVITE_ANSWER_CLIENT_TIME_BASE       568
#define XPPERF_SERVER_NICKNAME_CLIENT_TIME_AVERAGE         570
#define XPPERF_SERVER_NICKNAME_CLIENT_TIME_BASE            572
#define XPPERF_SERVER_STATE_CLIENT_TIME_AVERAGE            574
#define XPPERF_SERVER_STATE_CLIENT_TIME_BASE               576
#define XPPERF_SERVER_DEAD_USER_CLIENT_TIME_AVERAGE        578
#define XPPERF_SERVER_DEAD_USER_CLIENT_TIME_BASE           580
#define XPPERF_SERVER_DEAD_XBOX_CLIENT_TIME_AVERAGE        582
#define XPPERF_SERVER_DEAD_XBOX_CLIENT_TIME_BASE           584
#define XPPERF_SERVER_DEAD_SG_CLIENT_TIME_AVERAGE          586
#define XPPERF_SERVER_DEAD_SG_CLIENT_TIME_BASE             588
#define XPPERF_SERVER_KICK_CLIENT_TIME_AVERAGE             590
#define XPPERF_SERVER_KICK_CLIENT_TIME_BASE                592
#define XPPERF_SERVER_PEER_SESSION_CLIENT_TIME_AVERAGE     594
#define XPPERF_SERVER_PEER_SESSION_CLIENT_TIME_BASE        596
#define XPPERF_SERVER_PEER_SUBSCRIBE_CLIENT_TIME_AVERAGE   598
#define XPPERF_SERVER_PEER_SUBSCRIBE_CLIENT_TIME_BASE      600
#define XPPERF_SERVER_PEER_UNSUBSCRIBE_CLIENT_TIME_AVERAGE 602
#define XPPERF_SERVER_PEER_UNSUBSCRIBE_CLIENT_TIME_BASE    604
#define XPPERF_SERVER_SEND_REPLY_NOTI_TIME_AVERAGE         606
#define XPPERF_SERVER_SEND_REPLY_NOTI_TIME_BASE            608
#define XPPERF_SERVER_ANNOUNCE_PEER_TIME_AVERAGE           610
#define XPPERF_SERVER_ANNOUNCE_PEER_TIME_BASE              612
#define XPPERF_SERVER_SUBSCRIBED_PEER_TIME_AVERAGE         614
#define XPPERF_SERVER_SUBSCRIBED_PEER_TIME_BASE            616
#define XPPERF_SERVER_UNSUBSCRIBE_PEER_TIME_AVERAGE        618
#define XPPERF_SERVER_UNSUBSCRIBE_PEER_TIME_BASE           620
#define XPPERF_SERVER_ADDED_PEER_TIME_AVERAGE              622
#define XPPERF_SERVER_ADDED_PEER_TIME_BASE                 624
#define XPPERF_SERVER_ACCEPTED_PEER_TIME_AVERAGE           626
#define XPPERF_SERVER_ACCEPTED_PEER_TIME_BASE              628
#define XPPERF_SERVER_REMOVED_PEER_TIME_AVERAGE            630
#define XPPERF_SERVER_REMOVED_PEER_TIME_BASE               632
#define XPPERF_SERVER_INVITE_ANSWER_PEER_TIME_AVERAGE      634
#define XPPERF_SERVER_INVITE_ANSWER_PEER_TIME_BASE         636
#define XPPERF_SERVER_WEB_ANNOUNCE_PEER_TIME_AVERAGE       638
#define XPPERF_SERVER_WEB_ANNOUNCE_PEER_TIME_BASE          640
#define XPPERF_SERVER_WEB_SUBSCRIBED_PEER_TIME_AVERAGE     642
#define XPPERF_SERVER_WEB_SUBSCRIBED_PEER_TIME_BASE        644
#define XPPERF_SERVER_WEB_UNSUBSCRIBE_PEER_TIME_AVERAGE    646
#define XPPERF_SERVER_WEB_UNSUBSCRIBE_PEER_TIME_BASE       648
#define XPPERF_SERVER_WATCH_START_PEER_TIME_AVERAGE        650
#define XPPERF_SERVER_WATCH_START_PEER_TIME_BASE           652
#define XPPERF_SERVER_WATCH_STOP_PEER_TIME_AVERAGE         654
#define XPPERF_SERVER_WATCH_STOP_PEER_TIME_BASE            656
#define XPPERF_SERVER_Q_ADD_MSGS_COUNTER                   658
#define XPPERF_SERVER_Q_ADD_MSGS_RATE                      660
#define XPPERF_SERVER_DEQUEUE_MSGS_COUNTER                 662
#define XPPERF_SERVER_DEQUEUE_MSGS_RATE                    664
#define XPPERF_SERVER_NOUSER_ADD_MSGS_COUNTER              666
#define XPPERF_SERVER_NOUSER_ADD_MSGS_RATE                 668
#define XPPERF_SERVER_NOUSER_DEQUEUE_MSGS_COUNTER          670
#define XPPERF_SERVER_NOUSER_DEQUEUE_MSGS_RATE             672
#define XPPERF_SERVER_ACK_MSGS_COUNTER                     674
#define XPPERF_SERVER_ACK_MSGS_RATE                        676
#define XPPERF_SERVER_LIST_REPLY_MSGS_COUNTER              678
#define XPPERF_SERVER_LIST_REPLY_MSGS_RATE                 680
#define XPPERF_SERVER_TICKLE_MSGS_COUNTER                  682
#define XPPERF_SERVER_TICKLE_MSGS_RATE                     684
#define XPPERF_SERVER_WEB_USER_INFO_MSGS_COUNTER           686
#define XPPERF_SERVER_WEB_USER_INFO_MSGS_RATE              688
#define XPPERF_SERVER_WEB_LIST_MSGS_COUNTER                690
#define XPPERF_SERVER_WEB_LIST_MSGS_RATE                   692
#define XPPERF_SERVER_ACTIVE_WEB_USERS_COUNTER             694
#define XPPERF_SERVER_ENUM_MESSAGES_MSGS_COUNTER           696
#define XPPERF_SERVER_ENUM_MESSAGES_MSGS_RATE              698
#define XPPERF_SERVER_MESSAGE_SUMMARY_MSGS_COUNTER         700
#define XPPERF_SERVER_MESSAGE_SUMMARY_MSGS_RATE            702
#define XPPERF_SERVER_MESSAGE_DETAILS_MSGS_COUNTER         704
#define XPPERF_SERVER_MESSAGE_DETAILS_MSGS_RATE            706
#define XPPERF_SERVER_Q_DELETE_MESSAGE_MSGS_COUNTER        708
#define XPPERF_SERVER_Q_DELETE_MESSAGE_MSGS_RATE           710
#define XPPERF_SERVER_SEND_MESSAGE_MSGS_COUNTER            712
#define XPPERF_SERVER_SEND_MESSAGE_MSGS_RATE               714
#define XPPERF_SERVER_REVOKE_MESSAGE_MSGS_COUNTER          716
#define XPPERF_SERVER_REVOKE_MESSAGE_MSGS_RATE             718
#define XPPERF_SERVER_DELETE_TITLE_MSGS_COUNTER            720
#define XPPERF_SERVER_DELETE_TITLE_MSGS_RATE               722
#define XPPERF_SERVER_ENUM_TITLES_MSGS_COUNTER             724
#define XPPERF_SERVER_ENUM_TITLES_MSGS_RATE                726
#define XPPERF_SERVER_MESSAGE_FLAGS_MSGS_COUNTER           728
#define XPPERF_SERVER_MESSAGE_FLAGS_MSGS_RATE              730
#define XPPERF_SERVER_ENUM_SYSTEM_MESSAGES_MSGS_COUNTER    732
#define XPPERF_SERVER_ENUM_SYSTEM_MESSAGES_MSGS_RATE       734
#define XPPERF_SERVER_SYSTEM_MESSAGE_DETAILS_MSGS_COUNTER  736
#define XPPERF_SERVER_SYSTEM_MESSAGE_DETAILS_MSGS_RATE     738
#define XPPERF_SERVER_DELETE_SYSTEM_MESSAGE_MSGS_COUNTER   740
#define XPPERF_SERVER_DELETE_SYSTEM_MESSAGE_MSGS_RATE      742
#define XPPERF_SERVER_SEND_SYSTEM_MESSAGE_MSGS_COUNTER     744
#define XPPERF_SERVER_SEND_SYSTEM_MESSAGE_MSGS_RATE        746
#define XPPERF_SERVER_REVOKE_MESSAGE_MSGS_FROM_PRES_COUNTER 748
#define XPPERF_SERVER_REVOKE_MESSAGE_MSGS_FROM_PRES_RATE   750
#define XPPERF_SERVER_SEND_MESSAGE_MSGS_FROM_PRES_COUNTER  752
#define XPPERF_SERVER_SEND_MESSAGE_MSGS_FROM_PRES_RATE     754
#define XPPERF_SERVER_DELETE_MESSAGE_MSGS_FROM_PRES_COUNTER 756
#define XPPERF_SERVER_DELETE_MESSAGE_MSGS_FROM_PRES_RATE   758
#define XPPERF_SERVER_MSG_ALERT_COUNTER                    760
#define XPPERF_SERVER_MSG_ALERT_RATE                       762
#define XPPERF_SERVER_ENUM_MESSAGES_CLIENT_TIME_AVERAGE    764
#define XPPERF_SERVER_ENUM_MESSAGES_CLIENT_TIME_BASE       766
#define XPPERF_SERVER_ENUM_MESSAGES_STORE_TIME_AVERAGE     768
#define XPPERF_SERVER_ENUM_MESSAGES_STORE_TIME_BASE        770
#define XPPERF_SERVER_ENUM_MESSAGES_COMPLETION_TIME_AVERAGE 772
#define XPPERF_SERVER_ENUM_MESSAGES_COMPLETION_TIME_BASE   774
#define XPPERF_SERVER_MESSAGE_SUMMARY_CLIENT_TIME_AVERAGE  776
#define XPPERF_SERVER_MESSAGE_SUMMARY_CLIENT_TIME_BASE     778
#define XPPERF_SERVER_MESSAGE_SUMMARY_STORE_TIME_AVERAGE   780
#define XPPERF_SERVER_MESSAGE_SUMMARY_STORE_TIME_BASE      782
#define XPPERF_SERVER_MESSAGE_SUMMARY_COMPLETION_TIME_AVERAGE 784
#define XPPERF_SERVER_MESSAGE_SUMMARY_COMPLETION_TIME_BASE 786
#define XPPERF_SERVER_MESSAGE_DETAILS_CLIENT_TIME_AVERAGE  788
#define XPPERF_SERVER_MESSAGE_DETAILS_CLIENT_TIME_BASE     790
#define XPPERF_SERVER_MESSAGE_DETAILS_STORE_TIME_AVERAGE   792
#define XPPERF_SERVER_MESSAGE_DETAILS_STORE_TIME_BASE      794
#define XPPERF_SERVER_MESSAGE_DETAILS_COMPLETION_TIME_AVERAGE 796
#define XPPERF_SERVER_MESSAGE_DETAILS_COMPLETION_TIME_BASE 798
#define XPPERF_SERVER_DELETE_MESSAGE_CLIENT_TIME_AVERAGE   800
#define XPPERF_SERVER_DELETE_MESSAGE_CLIENT_TIME_BASE      802
#define XPPERF_SERVER_DELETE_MESSAGE_PRESENCE_TIME_AVERAGE 804
#define XPPERF_SERVER_DELETE_MESSAGE_PRESENCE_TIME_BASE    806
#define XPPERF_SERVER_DELETE_MESSAGE_STORE_TIME_AVERAGE    808
#define XPPERF_SERVER_DELETE_MESSAGE_STORE_TIME_BASE       810
#define XPPERF_SERVER_DELETE_MESSAGE_COMPLETION_TIME_AVERAGE 812
#define XPPERF_SERVER_DELETE_MESSAGE_COMPLETION_TIME_BASE  814
#define XPPERF_SERVER_SEND_MESSAGE_CLIENT_TIME_AVERAGE     816
#define XPPERF_SERVER_SEND_MESSAGE_CLIENT_TIME_BASE        818
#define XPPERF_SERVER_SEND_MESSAGE_PEER_TIME_AVERAGE       820
#define XPPERF_SERVER_SEND_MESSAGE_PEER_TIME_BASE          822
#define XPPERF_SERVER_SEND_MESSAGE_REPLY_PEER_TIME_AVERAGE 824
#define XPPERF_SERVER_SEND_MESSAGE_REPLY_PEER_TIME_BASE    826
#define XPPERF_SERVER_SEND_MESSAGE_PRESENCE_TIME_AVERAGE   828
#define XPPERF_SERVER_SEND_MESSAGE_PRESENCE_TIME_BASE      830
#define XPPERF_SERVER_SEND_MESSAGE_STORE_TIME_AVERAGE      832
#define XPPERF_SERVER_SEND_MESSAGE_STORE_TIME_BASE         834
#define XPPERF_SERVER_SEND_MESSAGE_COMPLETION_TIME_AVERAGE 836
#define XPPERF_SERVER_SEND_MESSAGE_COMPLETION_TIME_BASE    838
#define XPPERF_SERVER_SEND_MESSAGE_RESOLVE_WEBIDS_TIME_AVERAGE 840
#define XPPERF_SERVER_SEND_MESSAGE_RESOLVE_WEBIDS_TIME_BASE 842
#define XPPERF_SERVER_SEND_MESSAGE_ALERT_TIME_AVERAGE      844
#define XPPERF_SERVER_SEND_MESSAGE_ALERT_TIME_BASE         846
#define XPPERF_SERVER_REVOKE_MESSAGE_CLIENT_TIME_AVERAGE   848
#define XPPERF_SERVER_REVOKE_MESSAGE_CLIENT_TIME_BASE      850
#define XPPERF_SERVER_REVOKE_MESSAGE_PEER_TIME_AVERAGE     852
#define XPPERF_SERVER_REVOKE_MESSAGE_PEER_TIME_BASE        854
#define XPPERF_SERVER_REVOKE_MESSAGE_PRESENCE_TIME_AVERAGE 856
#define XPPERF_SERVER_REVOKE_MESSAGE_PRESENCE_TIME_BASE    858
#define XPPERF_SERVER_REVOKE_MESSAGE_STORE_TIME_AVERAGE    860
#define XPPERF_SERVER_REVOKE_MESSAGE_STORE_TIME_BASE       862
#define XPPERF_SERVER_REVOKE_MESSAGE_COMPLETION_TIME_AVERAGE 864
#define XPPERF_SERVER_REVOKE_MESSAGE_COMPLETION_TIME_BASE  866
#define XPPERF_SERVER_DELETE_TITLE_CLIENT_TIME_AVERAGE     868
#define XPPERF_SERVER_DELETE_TITLE_CLIENT_TIME_BASE        870
#define XPPERF_SERVER_DELETE_TITLE_STORE_TIME_AVERAGE      872
#define XPPERF_SERVER_DELETE_TITLE_STORE_TIME_BASE         874
#define XPPERF_SERVER_DELETE_TITLE_COMPLETION_TIME_AVERAGE 876
#define XPPERF_SERVER_DELETE_TITLE_COMPLETION_TIME_BASE    878
#define XPPERF_SERVER_ENUM_TITLES_CLIENT_TIME_AVERAGE      880
#define XPPERF_SERVER_ENUM_TITLES_CLIENT_TIME_BASE         882
#define XPPERF_SERVER_ENUM_TITLES_STORE_TIME_AVERAGE       884
#define XPPERF_SERVER_ENUM_TITLES_STORE_TIME_BASE          886
#define XPPERF_SERVER_ENUM_TITLES_COMPLETION_TIME_AVERAGE  888
#define XPPERF_SERVER_ENUM_TITLES_COMPLETION_TIME_BASE     890
#define XPPERF_SERVER_MESSAGE_FLAGS_CLIENT_TIME_AVERAGE    892
#define XPPERF_SERVER_MESSAGE_FLAGS_CLIENT_TIME_BASE       894
#define XPPERF_SERVER_MESSAGE_FLAGS_STORE_TIME_AVERAGE     896
#define XPPERF_SERVER_MESSAGE_FLAGS_STORE_TIME_BASE        898
#define XPPERF_SERVER_MESSAGE_FLAGS_COMPLETION_TIME_AVERAGE 900
#define XPPERF_SERVER_MESSAGE_FLAGS_COMPLETION_TIME_BASE   902
#define XPPERF_SERVER_ENUM_SYSTEM_MESSAGES_CLIENT_TIME_AVERAGE 904
#define XPPERF_SERVER_ENUM_SYSTEM_MESSAGES_CLIENT_TIME_BASE 906
#define XPPERF_SERVER_ENUM_SYSTEM_MESSAGES_STORE_TIME_AVERAGE 908
#define XPPERF_SERVER_ENUM_SYSTEM_MESSAGES_STORE_TIME_BASE 910
#define XPPERF_SERVER_ENUM_SYSTEM_MESSAGES_COMPLETION_TIME_AVERAGE 912
#define XPPERF_SERVER_ENUM_SYSTEM_MESSAGES_COMPLETION_TIME_BASE 914
#define XPPERF_SERVER_SYSTEM_MESSAGE_DETAILS_CLIENT_TIME_AVERAGE 916
#define XPPERF_SERVER_SYSTEM_MESSAGE_DETAILS_CLIENT_TIME_BASE 918
#define XPPERF_SERVER_SYSTEM_MESSAGE_DETAILS_STORE_TIME_AVERAGE 920
#define XPPERF_SERVER_SYSTEM_MESSAGE_DETAILS_STORE_TIME_BASE 922
#define XPPERF_SERVER_SYSTEM_MESSAGE_DETAILS_COMPLETION_TIME_AVERAGE 924
#define XPPERF_SERVER_SYSTEM_MESSAGE_DETAILS_COMPLETION_TIME_BASE 926
#define XPPERF_SERVER_DELETE_SYSTEM_MESSAGE_CLIENT_TIME_AVERAGE 928
#define XPPERF_SERVER_DELETE_SYSTEM_MESSAGE_CLIENT_TIME_BASE 930
#define XPPERF_SERVER_DELETE_SYSTEM_MESSAGE_STORE_TIME_AVERAGE 932
#define XPPERF_SERVER_DELETE_SYSTEM_MESSAGE_STORE_TIME_BASE 934
#define XPPERF_SERVER_DELETE_SYSTEM_MESSAGE_COMPLETION_TIME_AVERAGE 936
#define XPPERF_SERVER_DELETE_SYSTEM_MESSAGE_COMPLETION_TIME_BASE 938
#define XPPERF_SERVER_SEND_SYSTEM_MESSAGE_CLIENT_TIME_AVERAGE 940
#define XPPERF_SERVER_SEND_SYSTEM_MESSAGE_CLIENT_TIME_BASE 942
#define XPPERF_SERVER_SEND_SYSTEM_MESSAGE_STORE_TIME_AVERAGE 944
#define XPPERF_SERVER_SEND_SYSTEM_MESSAGE_STORE_TIME_BASE  946
#define XPPERF_SERVER_SEND_SYSTEM_MESSAGE_COMPLETION_TIME_AVERAGE 948
#define XPPERF_SERVER_SEND_SYSTEM_MESSAGE_COMPLETION_TIME_BASE 950
#define XPPERF_SERVER_UNBLOCK_USERS_STORE_TIME_AVERAGE     952
#define XPPERF_SERVER_UNBLOCK_USERS_STORE_TIME_BASE        954
#define XPPERF_SERVER_BLOCK_USERS_STORE_TIME_AVERAGE       956
#define XPPERF_SERVER_BLOCK_USERS_STORE_TIME_BASE          958
#define XPPERF_SERVER_DEQUEUE_CLIENT_TIME_AVERAGE          960
#define XPPERF_SERVER_DEQUEUE_CLIENT_TIME_BASE             962
#define XPPERF_SERVER_WEB_LIST_CLIENT_TIME_AVERAGE         964
#define XPPERF_SERVER_WEB_LIST_CLIENT_TIME_BASE            966
#define XPPERF_SERVER_USER_INFO_PRESENCE_TIME_AVERAGE      968
#define XPPERF_SERVER_USER_INFO_PRESENCE_TIME_BASE         970
#define XPPERF_SERVER_ADD_PRESENCE_TIME_AVERAGE            972
#define XPPERF_SERVER_ADD_PRESENCE_TIME_BASE               974
#define XPPERF_SERVER_DEAD_USER_PRESENCE_TIME_AVERAGE      976
#define XPPERF_SERVER_DEAD_USER_PRESENCE_TIME_BASE         978
#define XPPERF_SERVER_WEB_USER_INFO_PRESENCE_TIME_AVERAGE  980
#define XPPERF_SERVER_WEB_USER_INFO_PRESENCE_TIME_BASE     982
#define XPPERF_SERVER_WEB_PRESENCE_TIME_AVERAGE            984
#define XPPERF_SERVER_WEB_PRESENCE_TIME_BASE               986
#define XPPERF_SERVER_STATE2_MSGS_COUNTER                  988
#define XPPERF_SERVER_STATE2_MSGS_RATE                     990
#define XPPERF_SERVER_GET_STATE_MSGS_COUNTER               992
#define XPPERF_SERVER_GET_STATE_MSGS_RATE                  994
#define XPPERF_SERVER_STATE2_CLIENT_TIME_AVERAGE           996
#define XPPERF_SERVER_STATE2_CLIENT_TIME_BASE              998
#define XPPERF_SERVER_GET_STATE_CLIENT_TIME_AVERAGE        1000
#define XPPERF_SERVER_GET_STATE_CLIENT_TIME_BASE           1002
#define XPPERF_SERVER_LOGON_CHECK_MSGS_COUNTER             1004
#define XPPERF_SERVER_LOGON_CHECK_MSGS_RATE                1006
#define XPPERF_SERVER_LOGON_CHECK_CLIENT_TIME_AVERAGE      1008
#define XPPERF_SERVER_LOGON_CHECK_CLIENT_TIME_BASE         1010
#define XPPERF_SERVER_SUBSCRIPTIONS_TOTAL                  1012
#define XPPERF_SERVER_PEER_SUBSCRIPTIONS_TOTAL             1014
#define XPPERF_SERVER_QUEUE_ITEMS_TOTAL                    1016
#define XPPERF_SERVER_PRESENCE_QUEUE_ITEMS_TOTAL           1018
#define XPPERF_SERVER_PRESENCE2_QUEUE_ITEMS_TOTAL          1020
#define XPPERF_SERVER_STATECHANGE_TITLEID_RATE             1022
#define XPPERF_SERVER_STATECHANGE_TITLEDATA_RATE           1024
#define XPPERF_SERVER_STATECHANGE_SESSIONID_RATE           1026
#define XPPERF_SERVER_STATECHANGE_RICHPRES_RATE            1028
#define XPPERF_SERVER_STATECHANGE_USERSTATE_RATE           1030
#define XPPERF_SERVER_STATECHANGE_ONLINE_RATE              1032
#define XPPERF_SERVER_STATECHANGE_PLAYING_RATE             1034
#define XPPERF_SERVER_STATECHANGE_PARTY_PLAYING_RATE       1036
#define XPPERF_SERVER_STATECHANGE_CLOAKED_RATE             1038
#define XPPERF_SERVER_STATECHANGE_VOICE_RATE               1040
#define XPPERF_SERVER_STATECHANGE_JOINABLE_RATE            1042
#define XPPERF_SERVER_STATECHANGE_PARTY_JOINABLE_RATE      1044
#define XPPERF_SERVER_STATECHANGE_PARTY_COUNTER_RATE       1046
#define XPPERF_SERVER_FILTERED_NOTIFICATIONS_RATE          1048
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\perfapp\presperf\svrspec.h ===
#ifdef DEFINE_NAMES

WCHAR szDataMutexName[] = L"Shared Mutex for PRESPERF Data Collection";
WCHAR szPerfInfoMutexName[] = L"PRESPERF_INFO_MUTEX";
WCHAR szRegistryMutexName[] = L"PRESPERF_REGISTRY_MUTEX";
WCHAR szRegistryPathToPerformanceKeys[] = L"SYSTEM\\CurrentControlSet\\Services\\XPServer\\Performance";
WCHAR szCounterDataSharedMemory[] = L"PRESPERF PerfAPI Counter Data ShMem";
WCHAR szGlobalInfoSharedMemory[] = L"PRESPERF PerfAPI Global Info ShMem";

#else

extern WCHAR szDataMutexName[];
extern WCHAR szPerfInfoMutexName[];
extern WCHAR szRegistryMutexName[];
extern WCHAR szRegistryPathToPerformanceKeys[];
extern WCHAR szCounterDataSharedMemory[];
extern WCHAR szGlobalInfoSharedMemory[];

#endif

#define PERF_APP_NAME "PRESPERF"
#define WIDE_PERF_APP_NAME L"PRESPERF"

#define MAX_PERF_OBJECTS                1
#define MAX_COUNTERS                    1000
#define MAX_INSTANCES_PER_OBJECT        32

//
// Only allow a 24 character maximum on the instance name. Perfmon has trouble dealing with long
// names anyway, so if we're presented with a longer one, we truncate it. However, we attempt to
// make the truncated name unique again if possible. This value should be a multiple of 4 characters
// for perfmon not to complain.
//
#define MAX_INSTANCE_NAME               24
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\perfapp\sglspperf\sgperf.h ===
// Copyright (c) Microsoft Corporation
//
// WARNING WARNING WARNING WARNING WARNING WARNING
// ***********************************************
//
//              DO NOT EDIT THIS FILE
//
// Edit sgperf.ctr and use genctr.pl to rebuild.
//
// ***********************************************
// WARNING WARNING WARNING WARNING WARNING WARNING

#define SGPERF_SERVER_OBJECT_GLOBAL                        0
#define SGPERF_SERVER_CURRENT_CONNECTIONS_COUNTER          2
#define SGPERF_SERVER_CURRENT_FREE_CONNECTIONS_COUNTER     4
#define SGPERF_SERVER_CURRENT_FREE_CONNECTIONS_PERCENTAGE  6
#define SGPERF_SERVER_MAXIMUM_CONNECTIONS_PERCENTAGE       8
#define SGPERF_SERVER_ZRECV_RATE                           10
#define SGPERF_SERVER_ZXMIT_RATE                           12
#define SGPERF_SERVER_ZRECV_BYTES_RATE                     14
#define SGPERF_SERVER_ZXMIT_BYTES_RATE                     16
#define SGPERF_SERVER_IRECV_BYTES_RATE                     18
#define SGPERF_SERVER_IXMIT_BYTES_RATE                     20
#define SGPERF_SERVER_IRECV_RATE                           22
#define SGPERF_SERVER_IXMIT_RATE                           24
#define SGPERF_SERVER_PACKETS_AVAILABLE                    26
#define SGPERF_SERVER_KEYEX_RATE                           28
#define SGPERF_SERVER_LOGOFF_RATE                          30
#define SGPERF_SERVER_DROP_XSP_HDR_RATE                    32
#define SGPERF_SERVER_QUEUED                               34
#define SGPERF_SERVER_SGMSG_SPIDATA_REQ_RATE               36
#define SGPERF_SERVER_SGMSG_LATENCY_AVERAGE                38
#define SGPERF_SERVER_SGMSG_LATENCY_BASE                   40
#define SGPERF_SERVER_SGMSG_LATENCY_MAX                    42
#define SGPERF_DRIVER_PACKET_LATENCY_AVERAGE               44
#define SGPERF_DRIVER_PACKET_LATENCY_BASE                  46
#define SGPERF_DRIVER_PACKET_LATENCY_MAX                   48
#define SGPERF_SERVER_OBJECT_EXTENDED                      50
#define SGPERF_SERVER_CONNECTIONS_CIPHER_DES_COUNTER       52
#define SGPERF_SERVER_CONNECTIONS_CIPHER_DES3_COUNTER      54
#define SGPERF_SERVER_CONNECTIONS_CIPHER_AES_COUNTER       56
#define SGPERF_SERVER_CONNECTIONS_CIPHER_NULL_COUNTER      58
#define SGPERF_SERVER_RECV_TOTAL                           60
#define SGPERF_SERVER_RECV_BYTES                           62
#define SGPERF_SERVER_XMIT_TOTAL                           64
#define SGPERF_SERVER_QUEUED_PROC                          66
#define SGPERF_SERVER_QUEUED_CLI                           68
#define SGPERF_SERVER_DROPPED_CLI_RATE                     70
#define SGPERF_SERVER_QUEUED_SPI                           72
#define SGPERF_SERVER_DROPPED_SPI_RATE                     74
#define SGPERF_SERVER_CURRENT_BLOCKED                      76
#define SGPERF_SERVER_DROPPED_BLOCKED                      78
#define SGPERF_SERVER_DROPPED_BLOCKED_RATE                 80
#define SGPERF_SERVER_CURRENT_FREE_BLOCK_ITEMS             82
#define SGPERF_SERVER_IRECV                                84
#define SGPERF_SERVER_IRECV_BYTES                          86
#define SGPERF_SERVER_IXMIT                                88
#define SGPERF_SERVER_IXMIT_BYTES                          90
#define SGPERF_SERVER_KEYEX                                92
#define SGPERF_SERVER_KEYEX_CS                             94
#define SGPERF_SERVER_KEYEX_TOTAL                          96
#define SGPERF_SERVER_LOGOFF_TIMEOUT                       98
#define SGPERF_SERVER_LOGOFF_TIMEOUT_KEYEX                 100
#define SGPERF_SERVER_LOGOFF_TIMEOUT_REINIT                102
#define SGPERF_SERVER_LOGOFF_SECMSG                        104
#define SGPERF_SERVER_LOGOFF_KICK                          106
#define SGPERF_SERVER_XSP_RECV                             108
#define SGPERF_SERVER_XSP_RECV_TOTAL                       110
#define SGPERF_SERVER_XSP_XMIT                             112
#define SGPERF_SERVER_AUTHDATAV2                           114
#define SGPERF_SERVER_AUTHDATAV3                           116
#define SGPERF_SERVER_AUTHDATAV4                           118
#define SGPERF_SERVER_AUTHDATAV2_RATE                      120
#define SGPERF_SERVER_AUTHDATAV3_RATE                      122
#define SGPERF_SERVER_AUTHDATAV4_RATE                      124
#define SGPERF_SERVER_KEYEX_CS_RATE                        126
#define SGPERF_SERVER_KEYEX_TOTAL_RATE                     128
#define SGPERF_SERVER_XSP_RECV_RATE                        130
#define SGPERF_SERVER_XSP_RECV_TOTAL_RATE                  132
#define SGPERF_SERVER_XSP_XMIT_RATE                        134
#define SGPERF_SERVER_ZRECV                                136
#define SGPERF_SERVER_ZRECV_BYTES                          138
#define SGPERF_SERVER_ZXMIT                                140
#define SGPERF_SERVER_ZXMIT_BYTES                          142
#define SGPERF_SERVER_SGMSG                                144
#define SGPERF_SERVER_SGMSG_RATE                           146
#define SGPERF_SERVER_SGMSG_INVALID                        148
#define SGPERF_SERVER_SGMSG_INVALID_RATE                   150
#define SGPERF_SERVER_SGMSG_NOMATCH                        152
#define SGPERF_SERVER_SGMSG_NOMATCH_RATE                   154
#define SGPERF_SERVER_SGMSG_SPIDATA_REQ                    156
#define SGPERF_SERVER_SGMSG_SPIDATA2_REQ                   158
#define SGPERF_SERVER_SGMSG_SPIDATA2_REQ_RATE              160
#define SGPERF_SERVER_SGMSG_SPIDATA2_BACKCOMPAT_REQ        162
#define SGPERF_SERVER_SGMSG_SPIDATA2_BACKCOMPAT_REQ_RATE   164
#define SGPERF_SERVER_SGMSG_KICK                           166
#define SGPERF_SERVER_SGMSG_KICK_RATE                      168
#define SGPERF_SERVER_SGMSG_QVALS_LAZY                     170
#define SGPERF_SERVER_SGMSG_QVALS_LAZY_RATE                172
#define SGPERF_SERVER_SGMSG_QVALS_PUSH                     174
#define SGPERF_SERVER_SGMSG_QVALS_PUSH_RATE                176
#define SGPERF_SERVER_SGMSG_XBTOXB_FORWARD                 178
#define SGPERF_SERVER_SGMSG_XBTOXB_FORWARD_RATE            180
#define SGPERF_SERVER_SECMSG                               182
#define SGPERF_SERVER_SECMSG_RATE                          184
#define SGPERF_SERVER_SECMSG_DELETE                        186
#define SGPERF_SERVER_SECMSG_DELETE_RATE                   188
#define SGPERF_SERVER_SECMSG_PULSE                         190
#define SGPERF_SERVER_SECMSG_PULSE_RATE                    192
#define SGPERF_SERVER_SECMSG_DATA_PULSE                    194
#define SGPERF_SERVER_SECMSG_DATA_PULSE_RATE               196
#define SGPERF_SERVER_SECMSG_XBTOXB_FORWARD                198
#define SGPERF_SERVER_SECMSG_XBTOXB_FORWARD_RATE           200
#define SGPERF_SERVER_SECMSG_QOS                           202
#define SGPERF_SERVER_SECMSG_QOS_RATE                      204
#define SGPERF_SERVER_SECMSG_CHANGE_USERS                  206
#define SGPERF_SERVER_SECMSG_CHANGE_USERS_RATE             208
#define SGPERF_SERVER_DROP_ENET_HDR                        210
#define SGPERF_SERVER_DROP_ENET_HDR_RATE                   212
#define SGPERF_SERVER_DROP_IP_HDR                          214
#define SGPERF_SERVER_DROP_IP_HDR_RATE                     216
#define SGPERF_SERVER_DROP_XSP_HDR                         218
#define SGPERF_SERVER_DROP_XSP_HASH                        220
#define SGPERF_SERVER_DROP_XSP_HASH_RATE                   222
#define SGPERF_SERVER_DROP_DENIED                          224
#define SGPERF_SERVER_DROP_DENIED_RATE                     226
#define SGPERF_SERVER_DROP_KEYEX_BLOCKED                   228
#define SGPERF_SERVER_DROP_KEYEX_BLOCKED_RATE              230
#define SGPERF_SERVER_DROP_KEYEX_FORMAT                    232
#define SGPERF_SERVER_DROP_KEYEX_FORMAT_RATE               234
#define SGPERF_SERVER_DROP_KEYEX_KERB                      236
#define SGPERF_SERVER_DROP_KEYEX_KERB_RATE                 238
#define SGPERF_SERVER_DROP_KEYEX_AUTHENTICATOR             240
#define SGPERF_SERVER_DROP_KEYEX_AUTHENTICATOR_RATE        242
#define SGPERF_SERVER_DROP_KEYEX_TOO_SOON                  244
#define SGPERF_SERVER_DROP_KEYEX_TOO_SOON_RATE             246
#define SGPERF_SERVER_DROP_KEYEX_HASH                      248
#define SGPERF_SERVER_DROP_KEYEX_HASH_RATE                 250
#define SGPERF_SERVER_THREAD_POOL_WAIT_RATE                252
#define SGPERF_SERVER_THREAD_POOL_ACTIVE                   254
#define SGPERF_SERVER_THREAD_POOL_WORKITEMS_MISS_RATE      256
#define SGPERF_SERVER_THREAD_POOL_WORKITEMS_HIT_RATE       258
#define SGPERF_SERVER_THREAD_POOL_BATCHSIZE_AVERAGE        260
#define SGPERF_SERVER_THREAD_POOL_BATCHSIZE_BASE           262
#define SGPERF_SERVER_SPIN_LOCK_COLLISION_RATE             264
#define SGPERF_SERVER_SPIN_LOCK_SLEEP_RATE                 266
#define SGPERF_SERVER_SPIN_LOCK_LOCKS_RATE                 268
#define SGPERF_SERVER_PACKETALLOC_FAIL                     270
#define SGPERF_SERVER_PACKETALLOC_FAIL_RATE                272
#define SGPERF_SERVER_PACKETALLOC_SUCCESS_RATE             274
#define SGPERF_SERVER_ZLATENCY_AVERAGE                     276
#define SGPERF_SERVER_ZLATENCY_BASE                        278
#define SGPERF_SERVER_ZLATENCY_MAX                         280
#define SGPERF_SERVER_ILATENCY_AVERAGE                     282
#define SGPERF_SERVER_ILATENCY_BASE                        284
#define SGPERF_SERVER_ILATENCY_MAX                         286
#define SGPERF_SERVER_LOGLINES_FLOWMAP_RATE                288
#define SGPERF_SERVER_OBJECT_DRIVER                        290
#define SGPERF_DRIVER_PACKETS_ALLOCATED                    292
#define SGPERF_DRIVER_PROTOCOL_RECEIVE_PACKET_CALLS        294
#define SGPERF_DRIVER_PROTOCOL_RECEIVE_PACKET_COPY_CALLS   296
#define SGPERF_DRIVER_PROTOCOL_RECEIVE_INDICATION_CALLS    298
#define SGPERF_DRIVER_PROTOCOL_RECEIVE_INDICATION_DISCARD  300
#define SGPERF_DRIVER_PROTOCOL_RECEIVE_COMPLETE_CALLS      302
#define SGPERF_SERVER_IRECV_BATCH_THRESHOLD                304
#define SGPERF_SERVER_IXMIT_INPROGRESS                     306
#define SGPERF_SERVER_IXMIT_STAGE1_COUNT                   308
#define SGPERF_SERVER_IXMIT_STAGE2_COUNT                   310
#define SGPERF_SERVER_IDROP_PACKETS_DRIVER_RATE            312
#define SGPERF_SERVER_IRECV_PACKETS_DRIVER_RATE            314
#define SGPERF_SERVER_IXMIT_PACKETS_DRIVER_RATE            316
#define SGPERF_SERVER_IRECV_DRIVER_CALLS_RATE              318
#define SGPERF_SERVER_IXMIT_DRIVER_CALLS_RATE              320
#define SGPERF_SERVER_ZRECV_BATCH_THRESHOLD                322
#define SGPERF_SERVER_ZXMIT_INPROGRESS                     324
#define SGPERF_SERVER_ZXMIT_STAGE1_COUNT                   326
#define SGPERF_SERVER_ZXMIT_STAGE2_COUNT                   328
#define SGPERF_SERVER_ZDROP_PACKETS_DRIVER_RATE            330
#define SGPERF_SERVER_ZRECV_PACKETS_DRIVER_RATE            332
#define SGPERF_SERVER_ZXMIT_PACKETS_DRIVER_RATE            334
#define SGPERF_SERVER_ZRECV_DRIVER_CALLS_RATE              336
#define SGPERF_SERVER_ZXMIT_DRIVER_CALLS_RATE              338
#define SGPERF_SERVER_OBJECT_NOTIFICATIONS                 340
#define SGPERF_SERVER_NOTIFICATIONS_DELETE_RATE            342
#define SGPERF_SERVER_NOTIFICATIONS_UPDATE_RATE            344
#define SGPERF_SERVER_NOTIFICATIONS_TITLECHANGE_RATE       346
#define SGPERF_SERVER_NOTIFICATIONS_USERCHANGE_RATE        348
#define SGPERF_SERVER_NOTIFICATIONS_SPIUPDATE_RATE         350
#define SGPERF_SERVER_NOTIFICATIONS_DELETE_DROP_TOTAL      352
#define SGPERF_SERVER_NOTIFICATIONS_UPDATE_DROP_TOTAL      354
#define SGPERF_SERVER_NOTIFICATIONS_TITLECHANGE_DROP_TOTAL 356
#define SGPERF_SERVER_NOTIFICATIONS_USERCHANGE_DROP_TOTAL  358
#define SGPERF_SERVER_NOTIFICATIONS_SPIUPDATE_DROP_TOTAL   360
#define SGPERF_SERVER_NOTIFICATIONS_DELETE_QUEUE           362
#define SGPERF_SERVER_NOTIFICATIONS_UPDATE_QUEUE           364
#define SGPERF_SERVER_NOTIFICATIONS_TITLECHANGE_QUEUE      366
#define SGPERF_SERVER_NOTIFICATIONS_USERCHANGE_QUEUE       368
#define SGPERF_SERVER_NOTIFICATIONS_SPIUPDATE_QUEUE        370
#define SGPERF_SERVER_NOTIFICATIONS_DELETE_BATCHES         372
#define SGPERF_SERVER_NOTIFICATIONS_UPDATE_BATCHES         374
#define SGPERF_SERVER_NOTIFICATIONS_TITLECHANGE_BATCHES    376
#define SGPERF_SERVER_NOTIFICATIONS_USERCHANGE_BATCHES     378
#define SGPERF_SERVER_NOTIFICATIONS_SPIUPDATE_BATCHES      380
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\perfapp\sglspperf\svrspec.h ===
#ifdef DEFINE_NAMES

WCHAR szDataMutexName[] = L"Shared Mutex for SGPerf Data Collection";
WCHAR szPerfInfoMutexName[] = L"SGPERF_INFO_MUTEX";
WCHAR szRegistryMutexName[] = L"SGPERF_REGISTRY_MUTEX";
WCHAR szRegistryPathToPerformanceKeys[] = L"SYSTEM\\CurrentControlSet\\Services\\SGSVC\\Performance";
WCHAR szCounterDataSharedMemory[] = L"SGPerf PerfAPI Counter Data ShMem";
WCHAR szGlobalInfoSharedMemory[] = L"SGPerf PerfAPI Global Info ShMem";

#else

extern WCHAR szDataMutexName[];
extern WCHAR szPerfInfoMutexName[];
extern WCHAR szRegistryMutexName[];
extern WCHAR szRegistryPathToPerformanceKeys[];
extern WCHAR szCounterDataSharedMemory[];
extern WCHAR szGlobalInfoSharedMemory[];

#endif

#define PERF_APP_NAME "SGPerf"
#define WIDE_PERF_APP_NAME L"SGPerf"

#define MAX_PERF_OBJECTS                4
#define MAX_COUNTERS                    300
#define MAX_INSTANCES_PER_OBJECT        32

//
// Only allow a 24 character maximum on the instance name. Perfmon has trouble dealing with long
// names anyway, so if we're presented with a longer one, we truncate it. However, we attempt to
// make the truncated name unique again if possible. This value should be a multiple of 4 characters
// for perfmon not to complain.
//
#define MAX_INSTANCE_NAME               24
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\perfapp\presperf\presperf.cpp ===
// Copyright (c) Microsoft Corporation
//
// WARNING WARNING WARNING WARNING WARNING WARNING
// ***********************************************
//
//              DO NOT EDIT THIS FILE
//
// Edit presperf.ctr and use genctr.pl to rebuild.
//
// ***********************************************
// WARNING WARNING WARNING WARNING WARNING WARNING

    DWORD_COUNTER( XPPERF_SERVER_ACTIVE_USERS_COUNTER                 ),
    QWORD_AVERAGE( XPPERF_SERVER_USER_SESSION_TIME_AVERAGE            ),
    DWORD_BASE   ( XPPERF_SERVER_USER_SESSION_TIME_BASE               ),
    DWORD_COUNTER( XPPERF_SERVER_CLIENT_CONNECTIONS_COUNTER           ),
    DWORD_COUNTER( XPPERF_SERVER_DROPPED_CLIENT_CONNECTIONS_COUNTER   ),
    DWORD_RATE   ( XPPERF_SERVER_DROPPED_CLIENT_CONNECTIONS_RATE      ),
    DWORD_COUNTER( XPPERF_SERVER_Q_CONNECTIONS_COUNTER                ),
    DWORD_COUNTER( XPPERF_SERVER_DROPPED_Q_CONNECTIONS_COUNTER        ),
    DWORD_RATE   ( XPPERF_SERVER_DROPPED_Q_CONNECTIONS_RATE           ),
    DWORD_COUNTER( XPPERF_SERVER_PCONN_MSGS_SEND_COUNT                ),
    DWORD_RATE   ( XPPERF_SERVER_PCONN_MSGS_SEND_RATE                 ),
    DWORD_COUNTER( XPPERF_SERVER_PCONN_MSGS_RECV_COUNT                ),
    DWORD_RATE   ( XPPERF_SERVER_PCONN_MSGS_RECV_RATE                 ),
    DWORD_COUNTER( XPPERF_SERVER_PCONN_BYTES_SEND_COUNT               ),
    DWORD_RATE   ( XPPERF_SERVER_PCONN_BYTES_SEND_RATE                ),
    DWORD_COUNTER( XPPERF_SERVER_PCONN_BYTES_RECV_COUNT               ),
    DWORD_RATE   ( XPPERF_SERVER_PCONN_BYTES_RECV_RATE                ),
    DWORD_COUNTER( XPPERF_SERVER_PRES_CONNECTIONS_COUNTER             ),
    DWORD_COUNTER( XPPERF_SERVER_DROPPED_PRES_CONNECTIONS_COUNTER     ),
    DWORD_RATE   ( XPPERF_SERVER_DROPPED_PRES_CONNECTIONS_RATE        ),
    DWORD_COUNTER( XPPERF_SERVER_BAD_USER_COUNTER                     ),
    DWORD_RATE   ( XPPERF_SERVER_BAD_USER_RATE                        ),
    DWORD_COUNTER( XPPERF_SERVER_TOTAL_MSGS_COUNTER                   ),
    DWORD_RATE   ( XPPERF_SERVER_TOTAL_MSGS_RATE                      ),
    DWORD_COUNTER( XPPERF_SERVER_FAILED_MSGS_COUNTER                  ),
    DWORD_RATE   ( XPPERF_SERVER_FAILED_MSGS_RATE                     ),
    DWORD_COUNTER( XPPERF_SERVER_HELLO_MSGS_COUNTER                   ),
    DWORD_RATE   ( XPPERF_SERVER_HELLO_MSGS_RATE                      ),
    DWORD_COUNTER( XPPERF_SERVER_ALIVE_MSGS_COUNTER                   ),
    DWORD_RATE   ( XPPERF_SERVER_ALIVE_MSGS_RATE                      ),
    DWORD_COUNTER( XPPERF_SERVER_SYNC_MSGS_COUNTER                    ),
    DWORD_RATE   ( XPPERF_SERVER_SYNC_MSGS_RATE                       ),
    DWORD_COUNTER( XPPERF_SERVER_NICKNAME_MSGS_COUNTER                ),
    DWORD_RATE   ( XPPERF_SERVER_NICKNAME_MSGS_RATE                   ),
    DWORD_COUNTER( XPPERF_SERVER_REFRESH_MSGS_COUNTER                 ),
    DWORD_RATE   ( XPPERF_SERVER_REFRESH_MSGS_RATE                    ),
    DWORD_COUNTER( XPPERF_SERVER_ADD_MSGS_COUNTER                     ),
    DWORD_RATE   ( XPPERF_SERVER_ADD_MSGS_RATE                        ),
    DWORD_COUNTER( XPPERF_SERVER_ADD_AFFILIATES_MSGS_COUNTER          ),
    DWORD_RATE   ( XPPERF_SERVER_ADD_AFFILIATES_MSGS_RATE             ),
    DWORD_COUNTER( XPPERF_SERVER_IS_AFFILIATE_MSGS_COUNTER            ),
    DWORD_RATE   ( XPPERF_SERVER_IS_AFFILIATE_MSGS_RATE               ),
    DWORD_COUNTER( XPPERF_SERVER_QUERY_AFFILIATES_MSGS_COUNTER        ),
    DWORD_RATE   ( XPPERF_SERVER_QUERY_AFFILIATES_MSGS_RATE           ),
    DWORD_COUNTER( XPPERF_SERVER_GET_PRESENCE_INFO_MSGS_COUNTER       ),
    DWORD_RATE   ( XPPERF_SERVER_GET_PRESENCE_INFO_MSGS_RATE          ),
    DWORD_COUNTER( XPPERF_SERVER_DELETE_MSGS_COUNTER                  ),
    DWORD_RATE   ( XPPERF_SERVER_DELETE_MSGS_RATE                     ),
    DWORD_COUNTER( XPPERF_SERVER_ACCEPT_MSGS_COUNTER                  ),
    DWORD_RATE   ( XPPERF_SERVER_ACCEPT_MSGS_RATE                     ),
    DWORD_COUNTER( XPPERF_SERVER_REJECT_MSGS_COUNTER                  ),
    DWORD_RATE   ( XPPERF_SERVER_REJECT_MSGS_RATE                     ),
    DWORD_COUNTER( XPPERF_SERVER_BLOCK_MSGS_COUNTER                   ),
    DWORD_RATE   ( XPPERF_SERVER_BLOCK_MSGS_RATE                      ),
    DWORD_COUNTER( XPPERF_SERVER_UNBLOCK_MSGS_COUNTER                 ),
    DWORD_RATE   ( XPPERF_SERVER_UNBLOCK_MSGS_RATE                    ),
    DWORD_COUNTER( XPPERF_SERVER_INVITE_MSGS_COUNTER                  ),
    DWORD_RATE   ( XPPERF_SERVER_INVITE_MSGS_RATE                     ),
    DWORD_COUNTER( XPPERF_SERVER_ANSWER_INV_MSGS_COUNTER              ),
    DWORD_RATE   ( XPPERF_SERVER_ANSWER_INV_MSGS_RATE                 ),
    DWORD_COUNTER( XPPERF_SERVER_CANCEL_INV_MSGS_COUNTER              ),
    DWORD_RATE   ( XPPERF_SERVER_CANCEL_INV_MSGS_RATE                 ),
    DWORD_COUNTER( XPPERF_SERVER_STATE_MSGS_COUNTER                   ),
    DWORD_RATE   ( XPPERF_SERVER_STATE_MSGS_RATE                      ),
    DWORD_COUNTER( XPPERF_SERVER_DEAD_USER_MSGS_COUNTER               ),
    DWORD_RATE   ( XPPERF_SERVER_DEAD_USER_MSGS_RATE                  ),
    DWORD_COUNTER( XPPERF_SERVER_DEAD_XBOX_MSGS_COUNTER               ),
    DWORD_RATE   ( XPPERF_SERVER_DEAD_XBOX_MSGS_RATE                  ),
    DWORD_COUNTER( XPPERF_SERVER_DEAD_SG_MSGS_COUNTER                 ),
    DWORD_RATE   ( XPPERF_SERVER_DEAD_SG_MSGS_RATE                    ),
    DWORD_COUNTER( XPPERF_SERVER_ANNOUNCE_MSGS_COUNTER                ),
    DWORD_RATE   ( XPPERF_SERVER_ANNOUNCE_MSGS_RATE                   ),
    DWORD_COUNTER( XPPERF_SERVER_SUBSCRIBE_MSGS_COUNTER               ),
    DWORD_RATE   ( XPPERF_SERVER_SUBSCRIBE_MSGS_RATE                  ),
    DWORD_COUNTER( XPPERF_SERVER_UNSUBSCRIBE_MSGS_COUNTER             ),
    DWORD_RATE   ( XPPERF_SERVER_UNSUBSCRIBE_MSGS_RATE                ),
    DWORD_COUNTER( XPPERF_SERVER_ADDED_MSGS_COUNTER                   ),
    DWORD_RATE   ( XPPERF_SERVER_ADDED_MSGS_RATE                      ),
    DWORD_COUNTER( XPPERF_SERVER_ACCEPTED_MSGS_COUNTER                ),
    DWORD_RATE   ( XPPERF_SERVER_ACCEPTED_MSGS_RATE                   ),
    DWORD_COUNTER( XPPERF_SERVER_REMOVED_MSGS_COUNTER                 ),
    DWORD_RATE   ( XPPERF_SERVER_REMOVED_MSGS_RATE                    ),
    DWORD_COUNTER( XPPERF_SERVER_LIST_CHANGE_NOT_COUNTER              ),
    DWORD_RATE   ( XPPERF_SERVER_LIST_CHANGE_NOT_RATE                 ),
    DWORD_COUNTER( XPPERF_SERVER_PRESENCE_NOT_COUNTER                 ),
    DWORD_RATE   ( XPPERF_SERVER_PRESENCE_NOT_RATE                    ),
    DWORD_COUNTER( XPPERF_SERVER_INVITATION_NOT_COUNTER               ),
    DWORD_RATE   ( XPPERF_SERVER_INVITATION_NOT_RATE                  ),
    DWORD_COUNTER( XPPERF_SERVER_INV_ANSWER_NOT_COUNTER               ),
    DWORD_RATE   ( XPPERF_SERVER_INV_ANSWER_NOT_RATE                  ),
    DWORD_COUNTER( XPPERF_SERVER_KICK_MSGS_COUNTER                    ),
    DWORD_RATE   ( XPPERF_SERVER_KICK_MSGS_RATE                       ),
    DWORD_COUNTER( XPPERF_SERVER_SQL_WORK_ITEMS                       ),
    DWORD_COUNTER( XPPERF_SERVER_TOTAL_USERS_COUNTER                  ),
    DWORD_COUNTER( XPPERF_SERVER_ALIVE_CACHE_HIT_COUNTER              ),
    DWORD_RATE   ( XPPERF_SERVER_ALIVE_CACHE_HIT_RATE                 ),
    DWORD_COUNTER( XPPERF_SERVER_WEB_ALIVE_MSGS_COUNTER               ),
    DWORD_RATE   ( XPPERF_SERVER_WEB_ALIVE_MSGS_RATE                  ),
    DWORD_COUNTER( XPPERF_SERVER_WEB_ANNOUNCE_MSGS_COUNTER            ),
    DWORD_RATE   ( XPPERF_SERVER_WEB_ANNOUNCE_MSGS_RATE               ),
    DWORD_COUNTER( XPPERF_SERVER_WEB_SUBSCRIBE_MSGS_COUNTER           ),
    DWORD_RATE   ( XPPERF_SERVER_WEB_SUBSCRIBE_MSGS_RATE              ),
    DWORD_COUNTER( XPPERF_SERVER_WEB_UNSUBSCRIBE_MSGS_COUNTER         ),
    DWORD_RATE   ( XPPERF_SERVER_WEB_UNSUBSCRIBE_MSGS_RATE            ),
    DWORD_COUNTER( XPPERF_SERVER_PEER_SESSION_MSGS_COUNTER            ),
    DWORD_RATE   ( XPPERF_SERVER_PEER_SESSION_MSGS_RATE               ),
    DWORD_COUNTER( XPPERF_SERVER_TEAM_LIST_TEAMS_MSGS_COUNTER         ),
    DWORD_RATE   ( XPPERF_SERVER_TEAM_LIST_TEAMS_MSGS_RATE            ),
    DWORD_COUNTER( XPPERF_SERVER_TEAM_LIST_MEMBERS_MSGS_COUNTER       ),
    DWORD_RATE   ( XPPERF_SERVER_TEAM_LIST_MEMBERS_MSGS_RATE          ),
    DWORD_COUNTER( XPPERF_SERVER_PEER_SUBSCRIBE_MSGS_COUNTER          ),
    DWORD_RATE   ( XPPERF_SERVER_PEER_SUBSCRIBE_MSGS_RATE             ),
    DWORD_COUNTER( XPPERF_SERVER_PEER_UNSUBSCRIBE_MSGS_COUNTER        ),
    DWORD_RATE   ( XPPERF_SERVER_PEER_UNSUBSCRIBE_MSGS_RATE           ),
    DWORD_COUNTER( XPPERF_SERVER_TEAM_CREATE_MSGS_COUNTER             ),
    DWORD_RATE   ( XPPERF_SERVER_TEAM_CREATE_MSGS_RATE                ),
    DWORD_COUNTER( XPPERF_SERVER_TEAM_DELETE_MSGS_COUNTER             ),
    DWORD_RATE   ( XPPERF_SERVER_TEAM_DELETE_MSGS_RATE                ),
    DWORD_COUNTER( XPPERF_SERVER_TEAM_REMOVE_MSGS_COUNTER             ),
    DWORD_RATE   ( XPPERF_SERVER_TEAM_REMOVE_MSGS_RATE                ),
    DWORD_COUNTER( XPPERF_SERVER_TEAM_MANAGE_TEAM_MSGS_COUNTER        ),
    DWORD_RATE   ( XPPERF_SERVER_TEAM_MANAGE_TEAM_MSGS_RATE           ),
    DWORD_COUNTER( XPPERF_SERVER_TEAM_MANAGE_MEMBER_MSGS_COUNTER      ),
    DWORD_RATE   ( XPPERF_SERVER_TEAM_MANAGE_MEMBER_MSGS_RATE         ),
    DWORD_COUNTER( XPPERF_SERVER_TEAM_RECRUIT_MSGS_COUNTER            ),
    DWORD_RATE   ( XPPERF_SERVER_TEAM_RECRUIT_MSGS_RATE               ),
    DWORD_COUNTER( XPPERF_SERVER_TEAM_JOIN_MSGS_COUNTER               ),
    DWORD_RATE   ( XPPERF_SERVER_TEAM_JOIN_MSGS_RATE                  ),
    DWORD_COUNTER( XPPERF_SERVER_TEAM_GET_TICKET_MSGS_COUNTER         ),
    DWORD_RATE   ( XPPERF_SERVER_TEAM_GET_TICKET_MSGS_RATE            ),
    DWORD_COUNTER( XPPERF_SERVER_LOGON_ALERT_COUNTER                  ),
    DWORD_RATE   ( XPPERF_SERVER_LOGON_ALERT_RATE                     ),
    QWORD_AVERAGE( XPPERF_SERVER_SWITCHBOARD_QUEUE_WAIT_TIME_AVERAGE  ),
    DWORD_BASE   ( XPPERF_SERVER_SWITCHBOARD_QUEUE_WAIT_TIME_BASE     ),
    QWORD_AVERAGE( XPPERF_SERVER_SQL_QUEUE_WAIT_TIME_AVERAGE          ),
    DWORD_BASE   ( XPPERF_SERVER_SQL_QUEUE_WAIT_TIME_BASE             ),
    QWORD_AVERAGE( XPPERF_SERVER_HEARTBEAT_TIME_AVERAGE               ),
    DWORD_BASE   ( XPPERF_SERVER_HEARTBEAT_TIME_BASE                  ),
    QWORD_AVERAGE( XPPERF_SERVER_ALIVE_CLIENT_TIME_AVERAGE            ),
    DWORD_BASE   ( XPPERF_SERVER_ALIVE_CLIENT_TIME_BASE               ),
    QWORD_AVERAGE( XPPERF_SERVER_ALIVE_STORE_TIME_AVERAGE             ),
    DWORD_BASE   ( XPPERF_SERVER_ALIVE_STORE_TIME_BASE                ),
    QWORD_AVERAGE( XPPERF_SERVER_ALIVE_STORE_COMPLETE_TIME_AVERAGE    ),
    DWORD_BASE   ( XPPERF_SERVER_ALIVE_STORE_COMPLETE_TIME_BASE       ),
    QWORD_AVERAGE( XPPERF_SERVER_ALIVE_USER_INFO_COMPLETE_TIME_AVERAGE ),
    DWORD_BASE   ( XPPERF_SERVER_ALIVE_USER_INFO_COMPLETE_TIME_BASE   ),
    QWORD_AVERAGE( XPPERF_SERVER_SYNC_CLIENT_TIME_AVERAGE             ),
    DWORD_BASE   ( XPPERF_SERVER_SYNC_CLIENT_TIME_BASE                ),
    QWORD_AVERAGE( XPPERF_SERVER_SYNC_STORE_TIME_AVERAGE              ),
    DWORD_BASE   ( XPPERF_SERVER_SYNC_STORE_TIME_BASE                 ),
    QWORD_AVERAGE( XPPERF_SERVER_SYNC_COMPLETION_TIME_AVERAGE         ),
    DWORD_BASE   ( XPPERF_SERVER_SYNC_COMPLETION_TIME_BASE            ),
    QWORD_AVERAGE( XPPERF_SERVER_ADD_BUDDY_CLIENT_TIME_AVERAGE        ),
    DWORD_BASE   ( XPPERF_SERVER_ADD_BUDDY_CLIENT_TIME_BASE           ),
    QWORD_AVERAGE( XPPERF_SERVER_ADD_AFFILIATES_CLIENT_TIME_AVERAGE   ),
    DWORD_BASE   ( XPPERF_SERVER_ADD_AFFILIATES_CLIENT_TIME_BASE      ),
    QWORD_AVERAGE( XPPERF_SERVER_IS_AFFILIATE_CLIENT_TIME_AVERAGE     ),
    DWORD_BASE   ( XPPERF_SERVER_IS_AFFILIATE_CLIENT_TIME_BASE        ),
    QWORD_AVERAGE( XPPERF_SERVER_QUERY_AFFILIATES_CLIENT_TIME_AVERAGE ),
    DWORD_BASE   ( XPPERF_SERVER_QUERY_AFFILIATES_CLIENT_TIME_BASE    ),
    QWORD_AVERAGE( XPPERF_SERVER_GET_PRESENCE_INFO_PEER_TIME_AVERAGE  ),
    DWORD_BASE   ( XPPERF_SERVER_GET_PRESENCE_INFO_PEER_TIME_BASE     ),
    QWORD_AVERAGE( XPPERF_SERVER_ADD_BUDDY_STORE_TIME_AVERAGE         ),
    DWORD_BASE   ( XPPERF_SERVER_ADD_BUDDY_STORE_TIME_BASE            ),
    QWORD_AVERAGE( XPPERF_SERVER_ADD_AFFILIATES_STORE_TIME_AVERAGE    ),
    DWORD_BASE   ( XPPERF_SERVER_ADD_AFFILIATES_STORE_TIME_BASE       ),
    QWORD_AVERAGE( XPPERF_SERVER_IS_AFFILIATE_STORE_TIME_AVERAGE      ),
    DWORD_BASE   ( XPPERF_SERVER_IS_AFFILIATE_STORE_TIME_BASE         ),
    QWORD_AVERAGE( XPPERF_SERVER_QUERY_AFFILIATES_STORE_TIME_AVERAGE  ),
    DWORD_BASE   ( XPPERF_SERVER_QUERY_AFFILIATES_STORE_TIME_BASE     ),
    QWORD_AVERAGE( XPPERF_SERVER_ADD_BUDDY_COMPLETION_TIME_AVERAGE    ),
    DWORD_BASE   ( XPPERF_SERVER_ADD_BUDDY_COMPLETION_TIME_BASE       ),
    QWORD_AVERAGE( XPPERF_SERVER_ADD_AFFILIATES_COMPLETION_TIME_AVERAGE ),
    DWORD_BASE   ( XPPERF_SERVER_ADD_AFFILIATES_COMPLETION_TIME_BASE  ),
    QWORD_AVERAGE( XPPERF_SERVER_IS_AFFILIATE_COMPLETION_TIME_AVERAGE ),
    DWORD_BASE   ( XPPERF_SERVER_IS_AFFILIATE_COMPLETION_TIME_BASE    ),
    QWORD_AVERAGE( XPPERF_SERVER_QUERY_AFFILIATES_COMPLETION_TIME_AVERAGE ),
    DWORD_BASE   ( XPPERF_SERVER_QUERY_AFFILIATES_COMPLETION_TIME_BASE ),
    QWORD_AVERAGE( XPPERF_SERVER_ACCEPT_BUDDY_CLIENT_TIME_AVERAGE     ),
    DWORD_BASE   ( XPPERF_SERVER_ACCEPT_BUDDY_CLIENT_TIME_BASE        ),
    QWORD_AVERAGE( XPPERF_SERVER_ACCEPT_BUDDY_STORE_TIME_AVERAGE      ),
    DWORD_BASE   ( XPPERF_SERVER_ACCEPT_BUDDY_STORE_TIME_BASE         ),
    QWORD_AVERAGE( XPPERF_SERVER_ACCEPT_BUDDY_COMPLETION_TIME_AVERAGE ),
    DWORD_BASE   ( XPPERF_SERVER_ACCEPT_BUDDY_COMPLETION_TIME_BASE    ),
    QWORD_AVERAGE( XPPERF_SERVER_REJECT_BUDDY_CLIENT_TIME_AVERAGE     ),
    DWORD_BASE   ( XPPERF_SERVER_REJECT_BUDDY_CLIENT_TIME_BASE        ),
    QWORD_AVERAGE( XPPERF_SERVER_REJECT_BUDDY_STORE_TIME_AVERAGE      ),
    DWORD_BASE   ( XPPERF_SERVER_REJECT_BUDDY_STORE_TIME_BASE         ),
    QWORD_AVERAGE( XPPERF_SERVER_REJECT_BUDDY_COMPLETION_TIME_AVERAGE ),
    DWORD_BASE   ( XPPERF_SERVER_REJECT_BUDDY_COMPLETION_TIME_BASE    ),
    QWORD_AVERAGE( XPPERF_SERVER_DELETE_BUDDY_CLIENT_TIME_AVERAGE     ),
    DWORD_BASE   ( XPPERF_SERVER_DELETE_BUDDY_CLIENT_TIME_BASE        ),
    QWORD_AVERAGE( XPPERF_SERVER_DELETE_BUDDY_STORE_TIME_AVERAGE      ),
    DWORD_BASE   ( XPPERF_SERVER_DELETE_BUDDY_STORE_TIME_BASE         ),
    QWORD_AVERAGE( XPPERF_SERVER_DELETE_BUDDY_COMPLETION_TIME_AVERAGE ),
    DWORD_BASE   ( XPPERF_SERVER_DELETE_BUDDY_COMPLETION_TIME_BASE    ),
    QWORD_AVERAGE( XPPERF_SERVER_MUTE_CLIENT_TIME_AVERAGE             ),
    DWORD_BASE   ( XPPERF_SERVER_MUTE_CLIENT_TIME_BASE                ),
    QWORD_AVERAGE( XPPERF_SERVER_MUTE_STORE_TIME_AVERAGE              ),
    DWORD_BASE   ( XPPERF_SERVER_MUTE_STORE_TIME_BASE                 ),
    QWORD_AVERAGE( XPPERF_SERVER_MUTE_COMPLETION_TIME_AVERAGE         ),
    DWORD_BASE   ( XPPERF_SERVER_MUTE_COMPLETION_TIME_BASE            ),
    QWORD_AVERAGE( XPPERF_SERVER_UNMUTE_CLIENT_TIME_AVERAGE           ),
    DWORD_BASE   ( XPPERF_SERVER_UNMUTE_CLIENT_TIME_BASE              ),
    QWORD_AVERAGE( XPPERF_SERVER_UNMUTE_STORE_TIME_AVERAGE            ),
    DWORD_BASE   ( XPPERF_SERVER_UNMUTE_STORE_TIME_BASE               ),
    QWORD_AVERAGE( XPPERF_SERVER_UNMUTE_COMPLETION_TIME_AVERAGE       ),
    DWORD_BASE   ( XPPERF_SERVER_UNMUTE_COMPLETION_TIME_BASE          ),
    QWORD_AVERAGE( XPPERF_SERVER_FLUSH_TICKETS_STORE_TIME_AVERAGE     ),
    DWORD_BASE   ( XPPERF_SERVER_FLUSH_TICKETS_STORE_TIME_BASE        ),
    QWORD_AVERAGE( XPPERF_SERVER_WEB_ALIVE_CLIENT_TIME_AVERAGE        ),
    DWORD_BASE   ( XPPERF_SERVER_WEB_ALIVE_CLIENT_TIME_BASE           ),
    QWORD_AVERAGE( XPPERF_SERVER_WEB_ALIVE_STORE_TIME_AVERAGE         ),
    DWORD_BASE   ( XPPERF_SERVER_WEB_ALIVE_STORE_TIME_BASE            ),
    QWORD_AVERAGE( XPPERF_SERVER_WEB_ALIVE_STORE_COMPLETE_TIME_AVERAGE ),
    DWORD_BASE   ( XPPERF_SERVER_WEB_ALIVE_STORE_COMPLETE_TIME_BASE   ),
    QWORD_AVERAGE( XPPERF_SERVER_WEB_ALIVE_USER_INFO_COMPLETE_TIME_AVERAGE ),
    DWORD_BASE   ( XPPERF_SERVER_WEB_ALIVE_USER_INFO_COMPLETE_TIME_BASE ),
    QWORD_AVERAGE( XPPERF_SERVER_LIST_TEAMS_CLIENT_TIME_AVERAGE       ),
    DWORD_BASE   ( XPPERF_SERVER_LIST_TEAMS_CLIENT_TIME_BASE          ),
    QWORD_AVERAGE( XPPERF_SERVER_LIST_TEAMS_STORE_TIME_AVERAGE        ),
    DWORD_BASE   ( XPPERF_SERVER_LIST_TEAMS_STORE_TIME_BASE           ),
    QWORD_AVERAGE( XPPERF_SERVER_LIST_TEAMS_COMPLETION_TIME_AVERAGE   ),
    DWORD_BASE   ( XPPERF_SERVER_LIST_TEAMS_COMPLETION_TIME_BASE      ),
    QWORD_AVERAGE( XPPERF_SERVER_LIST_TEAM_MEMBERS_CLIENT_TIME_AVERAGE ),
    DWORD_BASE   ( XPPERF_SERVER_LIST_TEAM_MEMBERS_CLIENT_TIME_BASE   ),
    QWORD_AVERAGE( XPPERF_SERVER_LIST_TEAM_MEMBERS_STORE_TIME_AVERAGE ),
    DWORD_BASE   ( XPPERF_SERVER_LIST_TEAM_MEMBERS_STORE_TIME_BASE    ),
    QWORD_AVERAGE( XPPERF_SERVER_LIST_TEAM_MEMBERS_COMPLETION_TIME_AVERAGE ),
    DWORD_BASE   ( XPPERF_SERVER_LIST_TEAM_MEMBERS_COMPLETION_TIME_BASE ),
    QWORD_AVERAGE( XPPERF_SERVER_TEAM_CREATE_CLIENT_TIME_AVERAGE      ),
    DWORD_BASE   ( XPPERF_SERVER_TEAM_CREATE_CLIENT_TIME_BASE         ),
    QWORD_AVERAGE( XPPERF_SERVER_TEAM_CREATE_STORE_TIME_AVERAGE       ),
    DWORD_BASE   ( XPPERF_SERVER_TEAM_CREATE_STORE_TIME_BASE          ),
    QWORD_AVERAGE( XPPERF_SERVER_TEAM_CREATE_COMPLETION_TIME_AVERAGE  ),
    DWORD_BASE   ( XPPERF_SERVER_TEAM_CREATE_COMPLETION_TIME_BASE     ),
    QWORD_AVERAGE( XPPERF_SERVER_TEAM_DELETE_CLIENT_TIME_AVERAGE      ),
    DWORD_BASE   ( XPPERF_SERVER_TEAM_DELETE_CLIENT_TIME_BASE         ),
    QWORD_AVERAGE( XPPERF_SERVER_TEAM_DELETE_STORE_TIME_AVERAGE       ),
    DWORD_BASE   ( XPPERF_SERVER_TEAM_DELETE_STORE_TIME_BASE          ),
    QWORD_AVERAGE( XPPERF_SERVER_TEAM_DELETE_COMPLETION_TIME_AVERAGE  ),
    DWORD_BASE   ( XPPERF_SERVER_TEAM_DELETE_COMPLETION_TIME_BASE     ),
    QWORD_AVERAGE( XPPERF_SERVER_TEAM_REMOVE_MEMBER_CLIENT_TIME_AVERAGE ),
    DWORD_BASE   ( XPPERF_SERVER_TEAM_REMOVE_MEMBER_CLIENT_TIME_BASE  ),
    QWORD_AVERAGE( XPPERF_SERVER_TEAM_REMOVE_MEMBER_STORE_TIME_AVERAGE ),
    DWORD_BASE   ( XPPERF_SERVER_TEAM_REMOVE_MEMBER_STORE_TIME_BASE   ),
    QWORD_AVERAGE( XPPERF_SERVER_TEAM_REMOVE_MEMBER_COMPLETION_TIME_AVERAGE ),
    DWORD_BASE   ( XPPERF_SERVER_TEAM_REMOVE_MEMBER_COMPLETION_TIME_BASE ),
    QWORD_AVERAGE( XPPERF_SERVER_TEAM_MANAGE_CLIENT_TIME_AVERAGE      ),
    DWORD_BASE   ( XPPERF_SERVER_TEAM_MANAGE_CLIENT_TIME_BASE         ),
    QWORD_AVERAGE( XPPERF_SERVER_TEAM_MANAGE_STORE_TIME_AVERAGE       ),
    DWORD_BASE   ( XPPERF_SERVER_TEAM_MANAGE_STORE_TIME_BASE          ),
    QWORD_AVERAGE( XPPERF_SERVER_TEAM_MANAGE_COMPLETION_TIME_AVERAGE  ),
    DWORD_BASE   ( XPPERF_SERVER_TEAM_MANAGE_COMPLETION_TIME_BASE     ),
    QWORD_AVERAGE( XPPERF_SERVER_TEAM_MANAGE_MEMBER_CLIENT_TIME_AVERAGE ),
    DWORD_BASE   ( XPPERF_SERVER_TEAM_MANAGE_MEMBER_CLIENT_TIME_BASE  ),
    QWORD_AVERAGE( XPPERF_SERVER_TEAM_MANAGE_MEMBER_STORE_TIME_AVERAGE ),
    DWORD_BASE   ( XPPERF_SERVER_TEAM_MANAGE_MEMBER_STORE_TIME_BASE   ),
    QWORD_AVERAGE( XPPERF_SERVER_TEAM_MANAGE_MEMBER_COMPLETION_TIME_AVERAGE ),
    DWORD_BASE   ( XPPERF_SERVER_TEAM_MANAGE_MEMBER_COMPLETION_TIME_BASE ),
    QWORD_AVERAGE( XPPERF_SERVER_TEAM_RECRUIT_CLIENT_TIME_AVERAGE     ),
    DWORD_BASE   ( XPPERF_SERVER_TEAM_RECRUIT_CLIENT_TIME_BASE        ),
    QWORD_AVERAGE( XPPERF_SERVER_TEAM_RECRUIT_STORE_TIME_AVERAGE      ),
    DWORD_BASE   ( XPPERF_SERVER_TEAM_RECRUIT_STORE_TIME_BASE         ),
    QWORD_AVERAGE( XPPERF_SERVER_TEAM_RECRUIT_COMPLETION_TIME_AVERAGE ),
    DWORD_BASE   ( XPPERF_SERVER_TEAM_RECRUIT_COMPLETION_TIME_BASE    ),
    QWORD_AVERAGE( XPPERF_SERVER_TEAM_JOIN_CLIENT_TIME_AVERAGE        ),
    DWORD_BASE   ( XPPERF_SERVER_TEAM_JOIN_CLIENT_TIME_BASE           ),
    QWORD_AVERAGE( XPPERF_SERVER_TEAM_JOIN_STORE_TIME_AVERAGE         ),
    DWORD_BASE   ( XPPERF_SERVER_TEAM_JOIN_STORE_TIME_BASE            ),
    QWORD_AVERAGE( XPPERF_SERVER_TEAM_JOIN_COMPLETION_TIME_AVERAGE    ),
    DWORD_BASE   ( XPPERF_SERVER_TEAM_JOIN_COMPLETION_TIME_BASE       ),
    QWORD_AVERAGE( XPPERF_SERVER_TEAM_GET_TICKET_CLIENT_TIME_AVERAGE  ),
    DWORD_BASE   ( XPPERF_SERVER_TEAM_GET_TICKET_CLIENT_TIME_BASE     ),
    QWORD_AVERAGE( XPPERF_SERVER_TEAM_GET_TICKET_STORE_TIME_AVERAGE   ),
    DWORD_BASE   ( XPPERF_SERVER_TEAM_GET_TICKET_STORE_TIME_BASE      ),
    QWORD_AVERAGE( XPPERF_SERVER_TEAM_GET_TICKET_COMPLETION_TIME_AVERAGE ),
    DWORD_BASE   ( XPPERF_SERVER_TEAM_GET_TICKET_COMPLETION_TIME_BASE ),
    QWORD_AVERAGE( XPPERF_SERVER_INVITE_CLIENT_TIME_AVERAGE           ),
    DWORD_BASE   ( XPPERF_SERVER_INVITE_CLIENT_TIME_BASE              ),
    QWORD_AVERAGE( XPPERF_SERVER_CANCEL_INVITE_CLIENT_TIME_AVERAGE    ),
    DWORD_BASE   ( XPPERF_SERVER_CANCEL_INVITE_CLIENT_TIME_BASE       ),
    QWORD_AVERAGE( XPPERF_SERVER_INVITE_ANSWER_CLIENT_TIME_AVERAGE    ),
    DWORD_BASE   ( XPPERF_SERVER_INVITE_ANSWER_CLIENT_TIME_BASE       ),
    QWORD_AVERAGE( XPPERF_SERVER_NICKNAME_CLIENT_TIME_AVERAGE         ),
    DWORD_BASE   ( XPPERF_SERVER_NICKNAME_CLIENT_TIME_BASE            ),
    QWORD_AVERAGE( XPPERF_SERVER_STATE_CLIENT_TIME_AVERAGE            ),
    DWORD_BASE   ( XPPERF_SERVER_STATE_CLIENT_TIME_BASE               ),
    QWORD_AVERAGE( XPPERF_SERVER_DEAD_USER_CLIENT_TIME_AVERAGE        ),
    DWORD_BASE   ( XPPERF_SERVER_DEAD_USER_CLIENT_TIME_BASE           ),
    QWORD_AVERAGE( XPPERF_SERVER_DEAD_XBOX_CLIENT_TIME_AVERAGE        ),
    DWORD_BASE   ( XPPERF_SERVER_DEAD_XBOX_CLIENT_TIME_BASE           ),
    QWORD_AVERAGE( XPPERF_SERVER_DEAD_SG_CLIENT_TIME_AVERAGE          ),
    DWORD_BASE   ( XPPERF_SERVER_DEAD_SG_CLIENT_TIME_BASE             ),
    QWORD_AVERAGE( XPPERF_SERVER_KICK_CLIENT_TIME_AVERAGE             ),
    DWORD_BASE   ( XPPERF_SERVER_KICK_CLIENT_TIME_BASE                ),
    QWORD_AVERAGE( XPPERF_SERVER_PEER_SESSION_CLIENT_TIME_AVERAGE     ),
    DWORD_BASE   ( XPPERF_SERVER_PEER_SESSION_CLIENT_TIME_BASE        ),
    QWORD_AVERAGE( XPPERF_SERVER_PEER_SUBSCRIBE_CLIENT_TIME_AVERAGE   ),
    DWORD_BASE   ( XPPERF_SERVER_PEER_SUBSCRIBE_CLIENT_TIME_BASE      ),
    QWORD_AVERAGE( XPPERF_SERVER_PEER_UNSUBSCRIBE_CLIENT_TIME_AVERAGE ),
    DWORD_BASE   ( XPPERF_SERVER_PEER_UNSUBSCRIBE_CLIENT_TIME_BASE    ),
    QWORD_AVERAGE( XPPERF_SERVER_SEND_REPLY_NOTI_TIME_AVERAGE         ),
    DWORD_BASE   ( XPPERF_SERVER_SEND_REPLY_NOTI_TIME_BASE            ),
    QWORD_AVERAGE( XPPERF_SERVER_ANNOUNCE_PEER_TIME_AVERAGE           ),
    DWORD_BASE   ( XPPERF_SERVER_ANNOUNCE_PEER_TIME_BASE              ),
    QWORD_AVERAGE( XPPERF_SERVER_SUBSCRIBED_PEER_TIME_AVERAGE         ),
    DWORD_BASE   ( XPPERF_SERVER_SUBSCRIBED_PEER_TIME_BASE            ),
    QWORD_AVERAGE( XPPERF_SERVER_UNSUBSCRIBE_PEER_TIME_AVERAGE        ),
    DWORD_BASE   ( XPPERF_SERVER_UNSUBSCRIBE_PEER_TIME_BASE           ),
    QWORD_AVERAGE( XPPERF_SERVER_ADDED_PEER_TIME_AVERAGE              ),
    DWORD_BASE   ( XPPERF_SERVER_ADDED_PEER_TIME_BASE                 ),
    QWORD_AVERAGE( XPPERF_SERVER_ACCEPTED_PEER_TIME_AVERAGE           ),
    DWORD_BASE   ( XPPERF_SERVER_ACCEPTED_PEER_TIME_BASE              ),
    QWORD_AVERAGE( XPPERF_SERVER_REMOVED_PEER_TIME_AVERAGE            ),
    DWORD_BASE   ( XPPERF_SERVER_REMOVED_PEER_TIME_BASE               ),
    QWORD_AVERAGE( XPPERF_SERVER_INVITE_ANSWER_PEER_TIME_AVERAGE      ),
    DWORD_BASE   ( XPPERF_SERVER_INVITE_ANSWER_PEER_TIME_BASE         ),
    QWORD_AVERAGE( XPPERF_SERVER_WEB_ANNOUNCE_PEER_TIME_AVERAGE       ),
    DWORD_BASE   ( XPPERF_SERVER_WEB_ANNOUNCE_PEER_TIME_BASE          ),
    QWORD_AVERAGE( XPPERF_SERVER_WEB_SUBSCRIBED_PEER_TIME_AVERAGE     ),
    DWORD_BASE   ( XPPERF_SERVER_WEB_SUBSCRIBED_PEER_TIME_BASE        ),
    QWORD_AVERAGE( XPPERF_SERVER_WEB_UNSUBSCRIBE_PEER_TIME_AVERAGE    ),
    DWORD_BASE   ( XPPERF_SERVER_WEB_UNSUBSCRIBE_PEER_TIME_BASE       ),
    QWORD_AVERAGE( XPPERF_SERVER_WATCH_START_PEER_TIME_AVERAGE        ),
    DWORD_BASE   ( XPPERF_SERVER_WATCH_START_PEER_TIME_BASE           ),
    QWORD_AVERAGE( XPPERF_SERVER_WATCH_STOP_PEER_TIME_AVERAGE         ),
    DWORD_BASE   ( XPPERF_SERVER_WATCH_STOP_PEER_TIME_BASE            ),
    DWORD_COUNTER( XPPERF_SERVER_Q_ADD_MSGS_COUNTER                   ),
    DWORD_RATE   ( XPPERF_SERVER_Q_ADD_MSGS_RATE                      ),
    DWORD_COUNTER( XPPERF_SERVER_DEQUEUE_MSGS_COUNTER                 ),
    DWORD_RATE   ( XPPERF_SERVER_DEQUEUE_MSGS_RATE                    ),
    DWORD_COUNTER( XPPERF_SERVER_NOUSER_ADD_MSGS_COUNTER              ),
    DWORD_RATE   ( XPPERF_SERVER_NOUSER_ADD_MSGS_RATE                 ),
    DWORD_COUNTER( XPPERF_SERVER_NOUSER_DEQUEUE_MSGS_COUNTER          ),
    DWORD_RATE   ( XPPERF_SERVER_NOUSER_DEQUEUE_MSGS_RATE             ),
    DWORD_COUNTER( XPPERF_SERVER_ACK_MSGS_COUNTER                     ),
    DWORD_RATE   ( XPPERF_SERVER_ACK_MSGS_RATE                        ),
    DWORD_COUNTER( XPPERF_SERVER_LIST_REPLY_MSGS_COUNTER              ),
    DWORD_RATE   ( XPPERF_SERVER_LIST_REPLY_MSGS_RATE                 ),
    DWORD_COUNTER( XPPERF_SERVER_TICKLE_MSGS_COUNTER                  ),
    DWORD_RATE   ( XPPERF_SERVER_TICKLE_MSGS_RATE                     ),
    DWORD_COUNTER( XPPERF_SERVER_WEB_USER_INFO_MSGS_COUNTER           ),
    DWORD_RATE   ( XPPERF_SERVER_WEB_USER_INFO_MSGS_RATE              ),
    DWORD_COUNTER( XPPERF_SERVER_WEB_LIST_MSGS_COUNTER                ),
    DWORD_RATE   ( XPPERF_SERVER_WEB_LIST_MSGS_RATE                   ),
    DWORD_COUNTER( XPPERF_SERVER_ACTIVE_WEB_USERS_COUNTER             ),
    DWORD_COUNTER( XPPERF_SERVER_ENUM_MESSAGES_MSGS_COUNTER           ),
    DWORD_RATE   ( XPPERF_SERVER_ENUM_MESSAGES_MSGS_RATE              ),
    DWORD_COUNTER( XPPERF_SERVER_MESSAGE_SUMMARY_MSGS_COUNTER         ),
    DWORD_RATE   ( XPPERF_SERVER_MESSAGE_SUMMARY_MSGS_RATE            ),
    DWORD_COUNTER( XPPERF_SERVER_MESSAGE_DETAILS_MSGS_COUNTER         ),
    DWORD_RATE   ( XPPERF_SERVER_MESSAGE_DETAILS_MSGS_RATE            ),
    DWORD_COUNTER( XPPERF_SERVER_Q_DELETE_MESSAGE_MSGS_COUNTER        ),
    DWORD_RATE   ( XPPERF_SERVER_Q_DELETE_MESSAGE_MSGS_RATE           ),
    DWORD_COUNTER( XPPERF_SERVER_SEND_MESSAGE_MSGS_COUNTER            ),
    DWORD_RATE   ( XPPERF_SERVER_SEND_MESSAGE_MSGS_RATE               ),
    DWORD_COUNTER( XPPERF_SERVER_REVOKE_MESSAGE_MSGS_COUNTER          ),
    DWORD_RATE   ( XPPERF_SERVER_REVOKE_MESSAGE_MSGS_RATE             ),
    DWORD_COUNTER( XPPERF_SERVER_DELETE_TITLE_MSGS_COUNTER            ),
    DWORD_RATE   ( XPPERF_SERVER_DELETE_TITLE_MSGS_RATE               ),
    DWORD_COUNTER( XPPERF_SERVER_ENUM_TITLES_MSGS_COUNTER             ),
    DWORD_RATE   ( XPPERF_SERVER_ENUM_TITLES_MSGS_RATE                ),
    DWORD_COUNTER( XPPERF_SERVER_MESSAGE_FLAGS_MSGS_COUNTER           ),
    DWORD_RATE   ( XPPERF_SERVER_MESSAGE_FLAGS_MSGS_RATE              ),
    DWORD_COUNTER( XPPERF_SERVER_ENUM_SYSTEM_MESSAGES_MSGS_COUNTER    ),
    DWORD_RATE   ( XPPERF_SERVER_ENUM_SYSTEM_MESSAGES_MSGS_RATE       ),
    DWORD_COUNTER( XPPERF_SERVER_SYSTEM_MESSAGE_DETAILS_MSGS_COUNTER  ),
    DWORD_RATE   ( XPPERF_SERVER_SYSTEM_MESSAGE_DETAILS_MSGS_RATE     ),
    DWORD_COUNTER( XPPERF_SERVER_DELETE_SYSTEM_MESSAGE_MSGS_COUNTER   ),
    DWORD_RATE   ( XPPERF_SERVER_DELETE_SYSTEM_MESSAGE_MSGS_RATE      ),
    DWORD_COUNTER( XPPERF_SERVER_SEND_SYSTEM_MESSAGE_MSGS_COUNTER     ),
    DWORD_RATE   ( XPPERF_SERVER_SEND_SYSTEM_MESSAGE_MSGS_RATE        ),
    DWORD_COUNTER( XPPERF_SERVER_REVOKE_MESSAGE_MSGS_FROM_PRES_COUNTER ),
    DWORD_RATE   ( XPPERF_SERVER_REVOKE_MESSAGE_MSGS_FROM_PRES_RATE   ),
    DWORD_COUNTER( XPPERF_SERVER_SEND_MESSAGE_MSGS_FROM_PRES_COUNTER  ),
    DWORD_RATE   ( XPPERF_SERVER_SEND_MESSAGE_MSGS_FROM_PRES_RATE     ),
    DWORD_COUNTER( XPPERF_SERVER_DELETE_MESSAGE_MSGS_FROM_PRES_COUNTER ),
    DWORD_RATE   ( XPPERF_SERVER_DELETE_MESSAGE_MSGS_FROM_PRES_RATE   ),
    DWORD_COUNTER( XPPERF_SERVER_MSG_ALERT_COUNTER                    ),
    DWORD_RATE   ( XPPERF_SERVER_MSG_ALERT_RATE                       ),
    QWORD_AVERAGE( XPPERF_SERVER_ENUM_MESSAGES_CLIENT_TIME_AVERAGE    ),
    DWORD_BASE   ( XPPERF_SERVER_ENUM_MESSAGES_CLIENT_TIME_BASE       ),
    QWORD_AVERAGE( XPPERF_SERVER_ENUM_MESSAGES_STORE_TIME_AVERAGE     ),
    DWORD_BASE   ( XPPERF_SERVER_ENUM_MESSAGES_STORE_TIME_BASE        ),
    QWORD_AVERAGE( XPPERF_SERVER_ENUM_MESSAGES_COMPLETION_TIME_AVERAGE ),
    DWORD_BASE   ( XPPERF_SERVER_ENUM_MESSAGES_COMPLETION_TIME_BASE   ),
    QWORD_AVERAGE( XPPERF_SERVER_MESSAGE_SUMMARY_CLIENT_TIME_AVERAGE  ),
    DWORD_BASE   ( XPPERF_SERVER_MESSAGE_SUMMARY_CLIENT_TIME_BASE     ),
    QWORD_AVERAGE( XPPERF_SERVER_MESSAGE_SUMMARY_STORE_TIME_AVERAGE   ),
    DWORD_BASE   ( XPPERF_SERVER_MESSAGE_SUMMARY_STORE_TIME_BASE      ),
    QWORD_AVERAGE( XPPERF_SERVER_MESSAGE_SUMMARY_COMPLETION_TIME_AVERAGE ),
    DWORD_BASE   ( XPPERF_SERVER_MESSAGE_SUMMARY_COMPLETION_TIME_BASE ),
    QWORD_AVERAGE( XPPERF_SERVER_MESSAGE_DETAILS_CLIENT_TIME_AVERAGE  ),
    DWORD_BASE   ( XPPERF_SERVER_MESSAGE_DETAILS_CLIENT_TIME_BASE     ),
    QWORD_AVERAGE( XPPERF_SERVER_MESSAGE_DETAILS_STORE_TIME_AVERAGE   ),
    DWORD_BASE   ( XPPERF_SERVER_MESSAGE_DETAILS_STORE_TIME_BASE      ),
    QWORD_AVERAGE( XPPERF_SERVER_MESSAGE_DETAILS_COMPLETION_TIME_AVERAGE ),
    DWORD_BASE   ( XPPERF_SERVER_MESSAGE_DETAILS_COMPLETION_TIME_BASE ),
    QWORD_AVERAGE( XPPERF_SERVER_DELETE_MESSAGE_CLIENT_TIME_AVERAGE   ),
    DWORD_BASE   ( XPPERF_SERVER_DELETE_MESSAGE_CLIENT_TIME_BASE      ),
    QWORD_AVERAGE( XPPERF_SERVER_DELETE_MESSAGE_PRESENCE_TIME_AVERAGE ),
    DWORD_BASE   ( XPPERF_SERVER_DELETE_MESSAGE_PRESENCE_TIME_BASE    ),
    QWORD_AVERAGE( XPPERF_SERVER_DELETE_MESSAGE_STORE_TIME_AVERAGE    ),
    DWORD_BASE   ( XPPERF_SERVER_DELETE_MESSAGE_STORE_TIME_BASE       ),
    QWORD_AVERAGE( XPPERF_SERVER_DELETE_MESSAGE_COMPLETION_TIME_AVERAGE ),
    DWORD_BASE   ( XPPERF_SERVER_DELETE_MESSAGE_COMPLETION_TIME_BASE  ),
    QWORD_AVERAGE( XPPERF_SERVER_SEND_MESSAGE_CLIENT_TIME_AVERAGE     ),
    DWORD_BASE   ( XPPERF_SERVER_SEND_MESSAGE_CLIENT_TIME_BASE        ),
    QWORD_AVERAGE( XPPERF_SERVER_SEND_MESSAGE_PEER_TIME_AVERAGE       ),
    DWORD_BASE   ( XPPERF_SERVER_SEND_MESSAGE_PEER_TIME_BASE          ),
    QWORD_AVERAGE( XPPERF_SERVER_SEND_MESSAGE_REPLY_PEER_TIME_AVERAGE ),
    DWORD_BASE   ( XPPERF_SERVER_SEND_MESSAGE_REPLY_PEER_TIME_BASE    ),
    QWORD_AVERAGE( XPPERF_SERVER_SEND_MESSAGE_PRESENCE_TIME_AVERAGE   ),
    DWORD_BASE   ( XPPERF_SERVER_SEND_MESSAGE_PRESENCE_TIME_BASE      ),
    QWORD_AVERAGE( XPPERF_SERVER_SEND_MESSAGE_STORE_TIME_AVERAGE      ),
    DWORD_BASE   ( XPPERF_SERVER_SEND_MESSAGE_STORE_TIME_BASE         ),
    QWORD_AVERAGE( XPPERF_SERVER_SEND_MESSAGE_COMPLETION_TIME_AVERAGE ),
    DWORD_BASE   ( XPPERF_SERVER_SEND_MESSAGE_COMPLETION_TIME_BASE    ),
    QWORD_AVERAGE( XPPERF_SERVER_SEND_MESSAGE_RESOLVE_WEBIDS_TIME_AVERAGE ),
    DWORD_BASE   ( XPPERF_SERVER_SEND_MESSAGE_RESOLVE_WEBIDS_TIME_BASE ),
    QWORD_AVERAGE( XPPERF_SERVER_SEND_MESSAGE_ALERT_TIME_AVERAGE      ),
    DWORD_BASE   ( XPPERF_SERVER_SEND_MESSAGE_ALERT_TIME_BASE         ),
    QWORD_AVERAGE( XPPERF_SERVER_REVOKE_MESSAGE_CLIENT_TIME_AVERAGE   ),
    DWORD_BASE   ( XPPERF_SERVER_REVOKE_MESSAGE_CLIENT_TIME_BASE      ),
    QWORD_AVERAGE( XPPERF_SERVER_REVOKE_MESSAGE_PEER_TIME_AVERAGE     ),
    DWORD_BASE   ( XPPERF_SERVER_REVOKE_MESSAGE_PEER_TIME_BASE        ),
    QWORD_AVERAGE( XPPERF_SERVER_REVOKE_MESSAGE_PRESENCE_TIME_AVERAGE ),
    DWORD_BASE   ( XPPERF_SERVER_REVOKE_MESSAGE_PRESENCE_TIME_BASE    ),
    QWORD_AVERAGE( XPPERF_SERVER_REVOKE_MESSAGE_STORE_TIME_AVERAGE    ),
    DWORD_BASE   ( XPPERF_SERVER_REVOKE_MESSAGE_STORE_TIME_BASE       ),
    QWORD_AVERAGE( XPPERF_SERVER_REVOKE_MESSAGE_COMPLETION_TIME_AVERAGE ),
    DWORD_BASE   ( XPPERF_SERVER_REVOKE_MESSAGE_COMPLETION_TIME_BASE  ),
    QWORD_AVERAGE( XPPERF_SERVER_DELETE_TITLE_CLIENT_TIME_AVERAGE     ),
    DWORD_BASE   ( XPPERF_SERVER_DELETE_TITLE_CLIENT_TIME_BASE        ),
    QWORD_AVERAGE( XPPERF_SERVER_DELETE_TITLE_STORE_TIME_AVERAGE      ),
    DWORD_BASE   ( XPPERF_SERVER_DELETE_TITLE_STORE_TIME_BASE         ),
    QWORD_AVERAGE( XPPERF_SERVER_DELETE_TITLE_COMPLETION_TIME_AVERAGE ),
    DWORD_BASE   ( XPPERF_SERVER_DELETE_TITLE_COMPLETION_TIME_BASE    ),
    QWORD_AVERAGE( XPPERF_SERVER_ENUM_TITLES_CLIENT_TIME_AVERAGE      ),
    DWORD_BASE   ( XPPERF_SERVER_ENUM_TITLES_CLIENT_TIME_BASE         ),
    QWORD_AVERAGE( XPPERF_SERVER_ENUM_TITLES_STORE_TIME_AVERAGE       ),
    DWORD_BASE   ( XPPERF_SERVER_ENUM_TITLES_STORE_TIME_BASE          ),
    QWORD_AVERAGE( XPPERF_SERVER_ENUM_TITLES_COMPLETION_TIME_AVERAGE  ),
    DWORD_BASE   ( XPPERF_SERVER_ENUM_TITLES_COMPLETION_TIME_BASE     ),
    QWORD_AVERAGE( XPPERF_SERVER_MESSAGE_FLAGS_CLIENT_TIME_AVERAGE    ),
    DWORD_BASE   ( XPPERF_SERVER_MESSAGE_FLAGS_CLIENT_TIME_BASE       ),
    QWORD_AVERAGE( XPPERF_SERVER_MESSAGE_FLAGS_STORE_TIME_AVERAGE     ),
    DWORD_BASE   ( XPPERF_SERVER_MESSAGE_FLAGS_STORE_TIME_BASE        ),
    QWORD_AVERAGE( XPPERF_SERVER_MESSAGE_FLAGS_COMPLETION_TIME_AVERAGE ),
    DWORD_BASE   ( XPPERF_SERVER_MESSAGE_FLAGS_COMPLETION_TIME_BASE   ),
    QWORD_AVERAGE( XPPERF_SERVER_ENUM_SYSTEM_MESSAGES_CLIENT_TIME_AVERAGE ),
    DWORD_BASE   ( XPPERF_SERVER_ENUM_SYSTEM_MESSAGES_CLIENT_TIME_BASE ),
    QWORD_AVERAGE( XPPERF_SERVER_ENUM_SYSTEM_MESSAGES_STORE_TIME_AVERAGE ),
    DWORD_BASE   ( XPPERF_SERVER_ENUM_SYSTEM_MESSAGES_STORE_TIME_BASE ),
    QWORD_AVERAGE( XPPERF_SERVER_ENUM_SYSTEM_MESSAGES_COMPLETION_TIME_AVERAGE ),
    DWORD_BASE   ( XPPERF_SERVER_ENUM_SYSTEM_MESSAGES_COMPLETION_TIME_BASE ),
    QWORD_AVERAGE( XPPERF_SERVER_SYSTEM_MESSAGE_DETAILS_CLIENT_TIME_AVERAGE ),
    DWORD_BASE   ( XPPERF_SERVER_SYSTEM_MESSAGE_DETAILS_CLIENT_TIME_BASE ),
    QWORD_AVERAGE( XPPERF_SERVER_SYSTEM_MESSAGE_DETAILS_STORE_TIME_AVERAGE ),
    DWORD_BASE   ( XPPERF_SERVER_SYSTEM_MESSAGE_DETAILS_STORE_TIME_BASE ),
    QWORD_AVERAGE( XPPERF_SERVER_SYSTEM_MESSAGE_DETAILS_COMPLETION_TIME_AVERAGE ),
    DWORD_BASE   ( XPPERF_SERVER_SYSTEM_MESSAGE_DETAILS_COMPLETION_TIME_BASE ),
    QWORD_AVERAGE( XPPERF_SERVER_DELETE_SYSTEM_MESSAGE_CLIENT_TIME_AVERAGE ),
    DWORD_BASE   ( XPPERF_SERVER_DELETE_SYSTEM_MESSAGE_CLIENT_TIME_BASE ),
    QWORD_AVERAGE( XPPERF_SERVER_DELETE_SYSTEM_MESSAGE_STORE_TIME_AVERAGE ),
    DWORD_BASE   ( XPPERF_SERVER_DELETE_SYSTEM_MESSAGE_STORE_TIME_BASE ),
    QWORD_AVERAGE( XPPERF_SERVER_DELETE_SYSTEM_MESSAGE_COMPLETION_TIME_AVERAGE ),
    DWORD_BASE   ( XPPERF_SERVER_DELETE_SYSTEM_MESSAGE_COMPLETION_TIME_BASE ),
    QWORD_AVERAGE( XPPERF_SERVER_SEND_SYSTEM_MESSAGE_CLIENT_TIME_AVERAGE ),
    DWORD_BASE   ( XPPERF_SERVER_SEND_SYSTEM_MESSAGE_CLIENT_TIME_BASE ),
    QWORD_AVERAGE( XPPERF_SERVER_SEND_SYSTEM_MESSAGE_STORE_TIME_AVERAGE ),
    DWORD_BASE   ( XPPERF_SERVER_SEND_SYSTEM_MESSAGE_STORE_TIME_BASE  ),
    QWORD_AVERAGE( XPPERF_SERVER_SEND_SYSTEM_MESSAGE_COMPLETION_TIME_AVERAGE ),
    DWORD_BASE   ( XPPERF_SERVER_SEND_SYSTEM_MESSAGE_COMPLETION_TIME_BASE ),
    QWORD_AVERAGE( XPPERF_SERVER_UNBLOCK_USERS_STORE_TIME_AVERAGE     ),
    DWORD_BASE   ( XPPERF_SERVER_UNBLOCK_USERS_STORE_TIME_BASE        ),
    QWORD_AVERAGE( XPPERF_SERVER_BLOCK_USERS_STORE_TIME_AVERAGE       ),
    DWORD_BASE   ( XPPERF_SERVER_BLOCK_USERS_STORE_TIME_BASE          ),
    QWORD_AVERAGE( XPPERF_SERVER_DEQUEUE_CLIENT_TIME_AVERAGE          ),
    DWORD_BASE   ( XPPERF_SERVER_DEQUEUE_CLIENT_TIME_BASE             ),
    QWORD_AVERAGE( XPPERF_SERVER_WEB_LIST_CLIENT_TIME_AVERAGE         ),
    DWORD_BASE   ( XPPERF_SERVER_WEB_LIST_CLIENT_TIME_BASE            ),
    QWORD_AVERAGE( XPPERF_SERVER_USER_INFO_PRESENCE_TIME_AVERAGE      ),
    DWORD_BASE   ( XPPERF_SERVER_USER_INFO_PRESENCE_TIME_BASE         ),
    QWORD_AVERAGE( XPPERF_SERVER_ADD_PRESENCE_TIME_AVERAGE            ),
    DWORD_BASE   ( XPPERF_SERVER_ADD_PRESENCE_TIME_BASE               ),
    QWORD_AVERAGE( XPPERF_SERVER_DEAD_USER_PRESENCE_TIME_AVERAGE      ),
    DWORD_BASE   ( XPPERF_SERVER_DEAD_USER_PRESENCE_TIME_BASE         ),
    QWORD_AVERAGE( XPPERF_SERVER_WEB_USER_INFO_PRESENCE_TIME_AVERAGE  ),
    DWORD_BASE   ( XPPERF_SERVER_WEB_USER_INFO_PRESENCE_TIME_BASE     ),
    QWORD_AVERAGE( XPPERF_SERVER_WEB_PRESENCE_TIME_AVERAGE            ),
    DWORD_BASE   ( XPPERF_SERVER_WEB_PRESENCE_TIME_BASE               ),
    DWORD_COUNTER( XPPERF_SERVER_STATE2_MSGS_COUNTER                  ),
    DWORD_RATE   ( XPPERF_SERVER_STATE2_MSGS_RATE                     ),
    DWORD_COUNTER( XPPERF_SERVER_GET_STATE_MSGS_COUNTER               ),
    DWORD_RATE   ( XPPERF_SERVER_GET_STATE_MSGS_RATE                  ),
    QWORD_AVERAGE( XPPERF_SERVER_STATE2_CLIENT_TIME_AVERAGE           ),
    DWORD_BASE   ( XPPERF_SERVER_STATE2_CLIENT_TIME_BASE              ),
    QWORD_AVERAGE( XPPERF_SERVER_GET_STATE_CLIENT_TIME_AVERAGE        ),
    DWORD_BASE   ( XPPERF_SERVER_GET_STATE_CLIENT_TIME_BASE           ),
    DWORD_COUNTER( XPPERF_SERVER_LOGON_CHECK_MSGS_COUNTER             ),
    DWORD_RATE   ( XPPERF_SERVER_LOGON_CHECK_MSGS_RATE                ),
    QWORD_AVERAGE( XPPERF_SERVER_LOGON_CHECK_CLIENT_TIME_AVERAGE      ),
    DWORD_BASE   ( XPPERF_SERVER_LOGON_CHECK_CLIENT_TIME_BASE         ),
    DWORD_COUNTER( XPPERF_SERVER_SUBSCRIPTIONS_TOTAL                  ),
    DWORD_COUNTER( XPPERF_SERVER_PEER_SUBSCRIPTIONS_TOTAL             ),
    DWORD_COUNTER( XPPERF_SERVER_QUEUE_ITEMS_TOTAL                    ),
    DWORD_COUNTER( XPPERF_SERVER_PRESENCE_QUEUE_ITEMS_TOTAL           ),
    DWORD_COUNTER( XPPERF_SERVER_PRESENCE2_QUEUE_ITEMS_TOTAL          ),
    DWORD_RATE   ( XPPERF_SERVER_STATECHANGE_TITLEID_RATE             ),
    DWORD_RATE   ( XPPERF_SERVER_STATECHANGE_TITLEDATA_RATE           ),
    DWORD_RATE   ( XPPERF_SERVER_STATECHANGE_SESSIONID_RATE           ),
    DWORD_RATE   ( XPPERF_SERVER_STATECHANGE_RICHPRES_RATE            ),
    DWORD_RATE   ( XPPERF_SERVER_STATECHANGE_USERSTATE_RATE           ),
    DWORD_RATE   ( XPPERF_SERVER_STATECHANGE_ONLINE_RATE              ),
    DWORD_RATE   ( XPPERF_SERVER_STATECHANGE_PLAYING_RATE             ),
    DWORD_RATE   ( XPPERF_SERVER_STATECHANGE_PARTY_PLAYING_RATE       ),
    DWORD_RATE   ( XPPERF_SERVER_STATECHANGE_CLOAKED_RATE             ),
    DWORD_RATE   ( XPPERF_SERVER_STATECHANGE_VOICE_RATE               ),
    DWORD_RATE   ( XPPERF_SERVER_STATECHANGE_JOINABLE_RATE            ),
    DWORD_RATE   ( XPPERF_SERVER_STATECHANGE_PARTY_JOINABLE_RATE      ),
    DWORD_RATE   ( XPPERF_SERVER_STATECHANGE_PARTY_COUNTER_RATE       ),
    DWORD_RATE   ( XPPERF_SERVER_FILTERED_NOTIFICATIONS_RATE          ),
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\perfapp\sglspperf\sgperf.cpp ===
// Copyright (c) Microsoft Corporation
//
// WARNING WARNING WARNING WARNING WARNING WARNING
// ***********************************************
//
//              DO NOT EDIT THIS FILE
//
// Edit sgperf.ctr and use genctr.pl to rebuild.
//
// ***********************************************
// WARNING WARNING WARNING WARNING WARNING WARNING

    OBJECT       ( SGPERF_SERVER_OBJECT_GLOBAL                        ),
    QWORD_COUNTER( SGPERF_SERVER_CURRENT_CONNECTIONS_COUNTER          ),
    QWORD_COUNTER( SGPERF_SERVER_CURRENT_FREE_CONNECTIONS_COUNTER     ),
    QWORD_RAW_FRACTION( SGPERF_SERVER_CURRENT_FREE_CONNECTIONS_PERCENTAGE  ),
    QWORD_RAW_BASE( SGPERF_SERVER_MAXIMUM_CONNECTIONS_PERCENTAGE       ),
    QWORD_RATE   ( SGPERF_SERVER_ZRECV_RATE                           ),
    QWORD_RATE   ( SGPERF_SERVER_ZXMIT_RATE                           ),
    QWORD_RATE   ( SGPERF_SERVER_ZRECV_BYTES_RATE                     ),
    QWORD_RATE   ( SGPERF_SERVER_ZXMIT_BYTES_RATE                     ),
    QWORD_RATE   ( SGPERF_SERVER_IRECV_BYTES_RATE                     ),
    QWORD_RATE   ( SGPERF_SERVER_IXMIT_BYTES_RATE                     ),
    QWORD_RATE   ( SGPERF_SERVER_IRECV_RATE                           ),
    QWORD_RATE   ( SGPERF_SERVER_IXMIT_RATE                           ),
    QWORD_COUNTER( SGPERF_SERVER_PACKETS_AVAILABLE                    ),
    QWORD_RATE   ( SGPERF_SERVER_KEYEX_RATE                           ),
    QWORD_RATE   ( SGPERF_SERVER_LOGOFF_RATE                          ),
    QWORD_RATE   ( SGPERF_SERVER_DROP_XSP_HDR_RATE                    ),
    QWORD_COUNTER( SGPERF_SERVER_QUEUED                               ),
    QWORD_RATE   ( SGPERF_SERVER_SGMSG_SPIDATA_REQ_RATE               ),
    QWORD_AVERAGE( SGPERF_SERVER_SGMSG_LATENCY_AVERAGE                ),
    DWORD_BASE   ( SGPERF_SERVER_SGMSG_LATENCY_BASE                   ),
    QWORD_AVERAGE( SGPERF_SERVER_SGMSG_LATENCY_MAX                    ),
    QWORD_AVERAGE( SGPERF_DRIVER_PACKET_LATENCY_AVERAGE               ),
    DWORD_BASE   ( SGPERF_DRIVER_PACKET_LATENCY_BASE                  ),
    QWORD_COUNTER( SGPERF_DRIVER_PACKET_LATENCY_MAX                   ),
    OBJECT       ( SGPERF_SERVER_OBJECT_EXTENDED                      ),
    QWORD_COUNTER( SGPERF_SERVER_CONNECTIONS_CIPHER_DES_COUNTER       ),
    QWORD_COUNTER( SGPERF_SERVER_CONNECTIONS_CIPHER_DES3_COUNTER      ),
    QWORD_COUNTER( SGPERF_SERVER_CONNECTIONS_CIPHER_AES_COUNTER       ),
    QWORD_COUNTER( SGPERF_SERVER_CONNECTIONS_CIPHER_NULL_COUNTER      ),
    QWORD_COUNTER( SGPERF_SERVER_RECV_TOTAL                           ),
    QWORD_COUNTER( SGPERF_SERVER_RECV_BYTES                           ),
    QWORD_COUNTER( SGPERF_SERVER_XMIT_TOTAL                           ),
    QWORD_COUNTER( SGPERF_SERVER_QUEUED_PROC                          ),
    QWORD_COUNTER( SGPERF_SERVER_QUEUED_CLI                           ),
    QWORD_RATE   ( SGPERF_SERVER_DROPPED_CLI_RATE                     ),
    QWORD_COUNTER( SGPERF_SERVER_QUEUED_SPI                           ),
    QWORD_RATE   ( SGPERF_SERVER_DROPPED_SPI_RATE                     ),
    QWORD_COUNTER( SGPERF_SERVER_CURRENT_BLOCKED                      ),
    QWORD_COUNTER( SGPERF_SERVER_DROPPED_BLOCKED                      ),
    QWORD_RATE   ( SGPERF_SERVER_DROPPED_BLOCKED_RATE                 ),
    QWORD_COUNTER( SGPERF_SERVER_CURRENT_FREE_BLOCK_ITEMS             ),
    QWORD_COUNTER( SGPERF_SERVER_IRECV                                ),
    QWORD_COUNTER( SGPERF_SERVER_IRECV_BYTES                          ),
    QWORD_COUNTER( SGPERF_SERVER_IXMIT                                ),
    QWORD_COUNTER( SGPERF_SERVER_IXMIT_BYTES                          ),
    QWORD_COUNTER( SGPERF_SERVER_KEYEX                                ),
    QWORD_COUNTER( SGPERF_SERVER_KEYEX_CS                             ),
    QWORD_COUNTER( SGPERF_SERVER_KEYEX_TOTAL                          ),
    QWORD_COUNTER( SGPERF_SERVER_LOGOFF_TIMEOUT                       ),
    QWORD_COUNTER( SGPERF_SERVER_LOGOFF_TIMEOUT_KEYEX                 ),
    QWORD_COUNTER( SGPERF_SERVER_LOGOFF_TIMEOUT_REINIT                ),
    QWORD_COUNTER( SGPERF_SERVER_LOGOFF_SECMSG                        ),
    QWORD_COUNTER( SGPERF_SERVER_LOGOFF_KICK                          ),
    QWORD_COUNTER( SGPERF_SERVER_XSP_RECV                             ),
    QWORD_COUNTER( SGPERF_SERVER_XSP_RECV_TOTAL                       ),
    QWORD_COUNTER( SGPERF_SERVER_XSP_XMIT                             ),
    QWORD_COUNTER( SGPERF_SERVER_AUTHDATAV2                           ),
    QWORD_COUNTER( SGPERF_SERVER_AUTHDATAV3                           ),
    QWORD_COUNTER( SGPERF_SERVER_AUTHDATAV4                           ),
    QWORD_RATE   ( SGPERF_SERVER_AUTHDATAV2_RATE                      ),
    QWORD_RATE   ( SGPERF_SERVER_AUTHDATAV3_RATE                      ),
    QWORD_RATE   ( SGPERF_SERVER_AUTHDATAV4_RATE                      ),
    QWORD_RATE   ( SGPERF_SERVER_KEYEX_CS_RATE                        ),
    QWORD_RATE   ( SGPERF_SERVER_KEYEX_TOTAL_RATE                     ),
    QWORD_RATE   ( SGPERF_SERVER_XSP_RECV_RATE                        ),
    QWORD_RATE   ( SGPERF_SERVER_XSP_RECV_TOTAL_RATE                  ),
    QWORD_RATE   ( SGPERF_SERVER_XSP_XMIT_RATE                        ),
    QWORD_COUNTER( SGPERF_SERVER_ZRECV                                ),
    QWORD_COUNTER( SGPERF_SERVER_ZRECV_BYTES                          ),
    QWORD_COUNTER( SGPERF_SERVER_ZXMIT                                ),
    QWORD_COUNTER( SGPERF_SERVER_ZXMIT_BYTES                          ),
    QWORD_COUNTER( SGPERF_SERVER_SGMSG                                ),
    QWORD_RATE   ( SGPERF_SERVER_SGMSG_RATE                           ),
    QWORD_COUNTER( SGPERF_SERVER_SGMSG_INVALID                        ),
    QWORD_RATE   ( SGPERF_SERVER_SGMSG_INVALID_RATE                   ),
    QWORD_COUNTER( SGPERF_SERVER_SGMSG_NOMATCH                        ),
    QWORD_RATE   ( SGPERF_SERVER_SGMSG_NOMATCH_RATE                   ),
    QWORD_COUNTER( SGPERF_SERVER_SGMSG_SPIDATA_REQ                    ),
    QWORD_COUNTER( SGPERF_SERVER_SGMSG_SPIDATA2_REQ                   ),
    QWORD_RATE   ( SGPERF_SERVER_SGMSG_SPIDATA2_REQ_RATE              ),
    QWORD_COUNTER( SGPERF_SERVER_SGMSG_SPIDATA2_BACKCOMPAT_REQ        ),
    QWORD_RATE   ( SGPERF_SERVER_SGMSG_SPIDATA2_BACKCOMPAT_REQ_RATE   ),
    QWORD_COUNTER( SGPERF_SERVER_SGMSG_KICK                           ),
    QWORD_RATE   ( SGPERF_SERVER_SGMSG_KICK_RATE                      ),
    QWORD_COUNTER( SGPERF_SERVER_SGMSG_QVALS_LAZY                     ),
    QWORD_RATE   ( SGPERF_SERVER_SGMSG_QVALS_LAZY_RATE                ),
    QWORD_COUNTER( SGPERF_SERVER_SGMSG_QVALS_PUSH                     ),
    QWORD_RATE   ( SGPERF_SERVER_SGMSG_QVALS_PUSH_RATE                ),
    QWORD_COUNTER( SGPERF_SERVER_SGMSG_XBTOXB_FORWARD                 ),
    QWORD_RATE   ( SGPERF_SERVER_SGMSG_XBTOXB_FORWARD_RATE            ),
    QWORD_COUNTER( SGPERF_SERVER_SECMSG                               ),
    QWORD_RATE   ( SGPERF_SERVER_SECMSG_RATE                          ),
    QWORD_COUNTER( SGPERF_SERVER_SECMSG_DELETE                        ),
    QWORD_RATE   ( SGPERF_SERVER_SECMSG_DELETE_RATE                   ),
    QWORD_COUNTER( SGPERF_SERVER_SECMSG_PULSE                         ),
    QWORD_RATE   ( SGPERF_SERVER_SECMSG_PULSE_RATE                    ),
    QWORD_COUNTER( SGPERF_SERVER_SECMSG_DATA_PULSE                    ),
    QWORD_RATE   ( SGPERF_SERVER_SECMSG_DATA_PULSE_RATE               ),
    QWORD_COUNTER( SGPERF_SERVER_SECMSG_XBTOXB_FORWARD                ),
    QWORD_RATE   ( SGPERF_SERVER_SECMSG_XBTOXB_FORWARD_RATE           ),
    QWORD_COUNTER( SGPERF_SERVER_SECMSG_QOS                           ),
    QWORD_RATE   ( SGPERF_SERVER_SECMSG_QOS_RATE                      ),
    QWORD_COUNTER( SGPERF_SERVER_SECMSG_CHANGE_USERS                  ),
    QWORD_RATE   ( SGPERF_SERVER_SECMSG_CHANGE_USERS_RATE             ),
    QWORD_COUNTER( SGPERF_SERVER_DROP_ENET_HDR                        ),
    QWORD_RATE   ( SGPERF_SERVER_DROP_ENET_HDR_RATE                   ),
    QWORD_COUNTER( SGPERF_SERVER_DROP_IP_HDR                          ),
    QWORD_RATE   ( SGPERF_SERVER_DROP_IP_HDR_RATE                     ),
    QWORD_COUNTER( SGPERF_SERVER_DROP_XSP_HDR                         ),
    QWORD_COUNTER( SGPERF_SERVER_DROP_XSP_HASH                        ),
    QWORD_RATE   ( SGPERF_SERVER_DROP_XSP_HASH_RATE                   ),
    QWORD_COUNTER( SGPERF_SERVER_DROP_DENIED                          ),
    QWORD_RATE   ( SGPERF_SERVER_DROP_DENIED_RATE                     ),
    QWORD_COUNTER( SGPERF_SERVER_DROP_KEYEX_BLOCKED                   ),
    QWORD_RATE   ( SGPERF_SERVER_DROP_KEYEX_BLOCKED_RATE              ),
    QWORD_COUNTER( SGPERF_SERVER_DROP_KEYEX_FORMAT                    ),
    QWORD_RATE   ( SGPERF_SERVER_DROP_KEYEX_FORMAT_RATE               ),
    QWORD_COUNTER( SGPERF_SERVER_DROP_KEYEX_KERB                      ),
    QWORD_RATE   ( SGPERF_SERVER_DROP_KEYEX_KERB_RATE                 ),
    QWORD_COUNTER( SGPERF_SERVER_DROP_KEYEX_AUTHENTICATOR             ),
    QWORD_RATE   ( SGPERF_SERVER_DROP_KEYEX_AUTHENTICATOR_RATE        ),
    QWORD_COUNTER( SGPERF_SERVER_DROP_KEYEX_TOO_SOON                  ),
    QWORD_RATE   ( SGPERF_SERVER_DROP_KEYEX_TOO_SOON_RATE             ),
    QWORD_COUNTER( SGPERF_SERVER_DROP_KEYEX_HASH                      ),
    QWORD_RATE   ( SGPERF_SERVER_DROP_KEYEX_HASH_RATE                 ),
    QWORD_RATE   ( SGPERF_SERVER_THREAD_POOL_WAIT_RATE                ),
    QWORD_COUNTER( SGPERF_SERVER_THREAD_POOL_ACTIVE                   ),
    QWORD_RATE   ( SGPERF_SERVER_THREAD_POOL_WORKITEMS_MISS_RATE      ),
    QWORD_RATE   ( SGPERF_SERVER_THREAD_POOL_WORKITEMS_HIT_RATE       ),
    QWORD_AVERAGE( SGPERF_SERVER_THREAD_POOL_BATCHSIZE_AVERAGE        ),
    DWORD_BASE   ( SGPERF_SERVER_THREAD_POOL_BATCHSIZE_BASE           ),
    QWORD_RATE   ( SGPERF_SERVER_SPIN_LOCK_COLLISION_RATE             ),
    QWORD_RATE   ( SGPERF_SERVER_SPIN_LOCK_SLEEP_RATE                 ),
    QWORD_RATE   ( SGPERF_SERVER_SPIN_LOCK_LOCKS_RATE                 ),
    QWORD_COUNTER( SGPERF_SERVER_PACKETALLOC_FAIL                     ),
    QWORD_RATE   ( SGPERF_SERVER_PACKETALLOC_FAIL_RATE                ),
    QWORD_RATE   ( SGPERF_SERVER_PACKETALLOC_SUCCESS_RATE             ),
    QWORD_AVERAGE( SGPERF_SERVER_ZLATENCY_AVERAGE                     ),
    DWORD_BASE   ( SGPERF_SERVER_ZLATENCY_BASE                        ),
    QWORD_COUNTER( SGPERF_SERVER_ZLATENCY_MAX                         ),
    QWORD_AVERAGE( SGPERF_SERVER_ILATENCY_AVERAGE                     ),
    DWORD_BASE   ( SGPERF_SERVER_ILATENCY_BASE                        ),
    QWORD_COUNTER( SGPERF_SERVER_ILATENCY_MAX                         ),
    QWORD_RATE   ( SGPERF_SERVER_LOGLINES_FLOWMAP_RATE                ),
    OBJECT       ( SGPERF_SERVER_OBJECT_DRIVER                        ),
    QWORD_COUNTER( SGPERF_DRIVER_PACKETS_ALLOCATED                    ),
    QWORD_RATE   ( SGPERF_DRIVER_PROTOCOL_RECEIVE_PACKET_CALLS        ),
    QWORD_RATE   ( SGPERF_DRIVER_PROTOCOL_RECEIVE_PACKET_COPY_CALLS   ),
    QWORD_RATE   ( SGPERF_DRIVER_PROTOCOL_RECEIVE_INDICATION_CALLS    ),
    QWORD_RATE   ( SGPERF_DRIVER_PROTOCOL_RECEIVE_INDICATION_DISCARD  ),
    QWORD_RATE   ( SGPERF_DRIVER_PROTOCOL_RECEIVE_COMPLETE_CALLS      ),
    QWORD_COUNTER( SGPERF_SERVER_IRECV_BATCH_THRESHOLD                ),
    QWORD_COUNTER( SGPERF_SERVER_IXMIT_INPROGRESS                     ),
    QWORD_COUNTER( SGPERF_SERVER_IXMIT_STAGE1_COUNT                   ),
    QWORD_COUNTER( SGPERF_SERVER_IXMIT_STAGE2_COUNT                   ),
    QWORD_RATE   ( SGPERF_SERVER_IDROP_PACKETS_DRIVER_RATE            ),
    QWORD_RATE   ( SGPERF_SERVER_IRECV_PACKETS_DRIVER_RATE            ),
    QWORD_RATE   ( SGPERF_SERVER_IXMIT_PACKETS_DRIVER_RATE            ),
    QWORD_RATE   ( SGPERF_SERVER_IRECV_DRIVER_CALLS_RATE              ),
    QWORD_RATE   ( SGPERF_SERVER_IXMIT_DRIVER_CALLS_RATE              ),
    QWORD_COUNTER( SGPERF_SERVER_ZRECV_BATCH_THRESHOLD                ),
    QWORD_COUNTER( SGPERF_SERVER_ZXMIT_INPROGRESS                     ),
    QWORD_COUNTER( SGPERF_SERVER_ZXMIT_STAGE1_COUNT                   ),
    QWORD_COUNTER( SGPERF_SERVER_ZXMIT_STAGE2_COUNT                   ),
    QWORD_RATE   ( SGPERF_SERVER_ZDROP_PACKETS_DRIVER_RATE            ),
    QWORD_RATE   ( SGPERF_SERVER_ZRECV_PACKETS_DRIVER_RATE            ),
    QWORD_RATE   ( SGPERF_SERVER_ZXMIT_PACKETS_DRIVER_RATE            ),
    QWORD_RATE   ( SGPERF_SERVER_ZRECV_DRIVER_CALLS_RATE              ),
    QWORD_RATE   ( SGPERF_SERVER_ZXMIT_DRIVER_CALLS_RATE              ),
    OBJECT       ( SGPERF_SERVER_OBJECT_NOTIFICATIONS                 ),
    QWORD_RATE   ( SGPERF_SERVER_NOTIFICATIONS_DELETE_RATE            ),
    QWORD_RATE   ( SGPERF_SERVER_NOTIFICATIONS_UPDATE_RATE            ),
    QWORD_RATE   ( SGPERF_SERVER_NOTIFICATIONS_TITLECHANGE_RATE       ),
    QWORD_RATE   ( SGPERF_SERVER_NOTIFICATIONS_USERCHANGE_RATE        ),
    QWORD_RATE   ( SGPERF_SERVER_NOTIFICATIONS_SPIUPDATE_RATE         ),
    QWORD_COUNTER( SGPERF_SERVER_NOTIFICATIONS_DELETE_DROP_TOTAL      ),
    QWORD_COUNTER( SGPERF_SERVER_NOTIFICATIONS_UPDATE_DROP_TOTAL      ),
    QWORD_COUNTER( SGPERF_SERVER_NOTIFICATIONS_TITLECHANGE_DROP_TOTAL ),
    QWORD_COUNTER( SGPERF_SERVER_NOTIFICATIONS_USERCHANGE_DROP_TOTAL  ),
    QWORD_COUNTER( SGPERF_SERVER_NOTIFICATIONS_SPIUPDATE_DROP_TOTAL   ),
    QWORD_COUNTER( SGPERF_SERVER_NOTIFICATIONS_DELETE_QUEUE           ),
    QWORD_COUNTER( SGPERF_SERVER_NOTIFICATIONS_UPDATE_QUEUE           ),
    QWORD_COUNTER( SGPERF_SERVER_NOTIFICATIONS_TITLECHANGE_QUEUE      ),
    QWORD_COUNTER( SGPERF_SERVER_NOTIFICATIONS_USERCHANGE_QUEUE       ),
    QWORD_COUNTER( SGPERF_SERVER_NOTIFICATIONS_SPIUPDATE_QUEUE        ),
    QWORD_RATE   ( SGPERF_SERVER_NOTIFICATIONS_DELETE_BATCHES         ),
    QWORD_RATE   ( SGPERF_SERVER_NOTIFICATIONS_UPDATE_BATCHES         ),
    QWORD_RATE   ( SGPERF_SERVER_NOTIFICATIONS_TITLECHANGE_BATCHES    ),
    QWORD_RATE   ( SGPERF_SERVER_NOTIFICATIONS_USERCHANGE_BATCHES     ),
    QWORD_RATE   ( SGPERF_SERVER_NOTIFICATIONS_SPIUPDATE_BATCHES      ),
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\perfapp\sgperf\sgperf.cpp ===
// Copyright (c) Microsoft Corporation
//
// WARNING WARNING WARNING WARNING WARNING WARNING
// ***********************************************
//
//              DO NOT EDIT THIS FILE
//
// Edit sgperf.ctr and use genctr.pl to rebuild.
//
// ***********************************************
// WARNING WARNING WARNING WARNING WARNING WARNING

    OBJECT       ( SGPERF_SERVER_OBJECT_GLOBAL                        ),
    QWORD_COUNTER( SGPERF_SERVER_CURRENT_CONNECTIONS_COUNTER          ),
    QWORD_COUNTER( SGPERF_SERVER_CURRENT_FREE_CONNECTIONS_COUNTER     ),
    QWORD_RAW_FRACTION( SGPERF_SERVER_CURRENT_FREE_CONNECTIONS_PERCENTAGE  ),
    QWORD_RAW_BASE( SGPERF_SERVER_MAXIMUM_CONNECTIONS_PERCENTAGE       ),
    QWORD_RATE   ( SGPERF_SERVER_ZRECV_RATE                           ),
    QWORD_RATE   ( SGPERF_SERVER_ZXMIT_RATE                           ),
    QWORD_RATE   ( SGPERF_SERVER_ZRECV_BYTES_RATE                     ),
    QWORD_RATE   ( SGPERF_SERVER_ZXMIT_BYTES_RATE                     ),
    QWORD_RATE   ( SGPERF_SERVER_IRECV_BYTES_RATE                     ),
    QWORD_RATE   ( SGPERF_SERVER_IXMIT_BYTES_RATE                     ),
    QWORD_RATE   ( SGPERF_SERVER_IRECV_RATE                           ),
    QWORD_RATE   ( SGPERF_SERVER_IXMIT_RATE                           ),
    QWORD_COUNTER( SGPERF_SERVER_PACKETS_AVAILABLE                    ),
    QWORD_RATE   ( SGPERF_SERVER_KEYEX_RATE                           ),
    QWORD_RATE   ( SGPERF_SERVER_LOGOFF_RATE                          ),
    QWORD_RATE   ( SGPERF_SERVER_DROP_XSP_HDR_RATE                    ),
    QWORD_COUNTER( SGPERF_SERVER_QUEUED                               ),
    QWORD_RATE   ( SGPERF_SERVER_SGMSG_SPIDATA_REQ_RATE               ),
    QWORD_AVERAGE( SGPERF_SERVER_SGMSG_LATENCY_AVERAGE                ),
    DWORD_BASE   ( SGPERF_SERVER_SGMSG_LATENCY_BASE                   ),
    QWORD_AVERAGE( SGPERF_SERVER_SGMSG_LATENCY_MAX                    ),
    QWORD_AVERAGE( SGPERF_DRIVER_PACKET_LATENCY_AVERAGE               ),
    DWORD_BASE   ( SGPERF_DRIVER_PACKET_LATENCY_BASE                  ),
    QWORD_COUNTER( SGPERF_DRIVER_PACKET_LATENCY_MAX                   ),
    OBJECT       ( SGPERF_SERVER_OBJECT_EXTENDED                      ),
    QWORD_COUNTER( SGPERF_SERVER_CONNECTIONS_CIPHER_DES_COUNTER       ),
    QWORD_COUNTER( SGPERF_SERVER_CONNECTIONS_CIPHER_DES3_COUNTER      ),
    QWORD_COUNTER( SGPERF_SERVER_CONNECTIONS_CIPHER_AES_COUNTER       ),
    QWORD_COUNTER( SGPERF_SERVER_CONNECTIONS_CIPHER_NULL_COUNTER      ),
    QWORD_COUNTER( SGPERF_SERVER_RECV_TOTAL                           ),
    QWORD_COUNTER( SGPERF_SERVER_RECV_BYTES                           ),
    QWORD_COUNTER( SGPERF_SERVER_XMIT_TOTAL                           ),
    QWORD_COUNTER( SGPERF_SERVER_QUEUED_PROC                          ),
    QWORD_COUNTER( SGPERF_SERVER_QUEUED_CLI                           ),
    QWORD_RATE   ( SGPERF_SERVER_DROPPED_CLI_RATE                     ),
    QWORD_COUNTER( SGPERF_SERVER_QUEUED_SPI                           ),
    QWORD_RATE   ( SGPERF_SERVER_DROPPED_SPI_RATE                     ),
    QWORD_COUNTER( SGPERF_SERVER_CURRENT_BLOCKED                      ),
    QWORD_COUNTER( SGPERF_SERVER_DROPPED_BLOCKED                      ),
    QWORD_RATE   ( SGPERF_SERVER_DROPPED_BLOCKED_RATE                 ),
    QWORD_COUNTER( SGPERF_SERVER_CURRENT_FREE_BLOCK_ITEMS             ),
    QWORD_COUNTER( SGPERF_SERVER_IRECV                                ),
    QWORD_COUNTER( SGPERF_SERVER_IRECV_BYTES                          ),
    QWORD_COUNTER( SGPERF_SERVER_IXMIT                                ),
    QWORD_COUNTER( SGPERF_SERVER_IXMIT_BYTES                          ),
    QWORD_COUNTER( SGPERF_SERVER_KEYEX                                ),
    QWORD_COUNTER( SGPERF_SERVER_KEYEX_CS                             ),
    QWORD_COUNTER( SGPERF_SERVER_KEYEX_TOTAL                          ),
    QWORD_COUNTER( SGPERF_SERVER_LOGOFF_TIMEOUT                       ),
    QWORD_COUNTER( SGPERF_SERVER_LOGOFF_TIMEOUT_KEYEX                 ),
    QWORD_COUNTER( SGPERF_SERVER_LOGOFF_TIMEOUT_REINIT                ),
    QWORD_COUNTER( SGPERF_SERVER_LOGOFF_SECMSG                        ),
    QWORD_COUNTER( SGPERF_SERVER_LOGOFF_KICK                          ),
    QWORD_COUNTER( SGPERF_SERVER_XSP_RECV                             ),
    QWORD_COUNTER( SGPERF_SERVER_XSP_RECV_TOTAL                       ),
    QWORD_COUNTER( SGPERF_SERVER_XSP_XMIT                             ),
    QWORD_COUNTER( SGPERF_SERVER_AUTHDATAV2                           ),
    QWORD_COUNTER( SGPERF_SERVER_AUTHDATAV3                           ),
    QWORD_COUNTER( SGPERF_SERVER_AUTHDATAV4                           ),
    QWORD_RATE   ( SGPERF_SERVER_AUTHDATAV2_RATE                      ),
    QWORD_RATE   ( SGPERF_SERVER_AUTHDATAV3_RATE                      ),
    QWORD_RATE   ( SGPERF_SERVER_AUTHDATAV4_RATE                      ),
    QWORD_RATE   ( SGPERF_SERVER_KEYEX_CS_RATE                        ),
    QWORD_RATE   ( SGPERF_SERVER_KEYEX_TOTAL_RATE                     ),
    QWORD_RATE   ( SGPERF_SERVER_XSP_RECV_RATE                        ),
    QWORD_RATE   ( SGPERF_SERVER_XSP_RECV_TOTAL_RATE                  ),
    QWORD_RATE   ( SGPERF_SERVER_XSP_XMIT_RATE                        ),
    QWORD_COUNTER( SGPERF_SERVER_ZRECV                                ),
    QWORD_COUNTER( SGPERF_SERVER_ZRECV_BYTES                          ),
    QWORD_COUNTER( SGPERF_SERVER_ZXMIT                                ),
    QWORD_COUNTER( SGPERF_SERVER_ZXMIT_BYTES                          ),
    QWORD_COUNTER( SGPERF_SERVER_SGMSG                                ),
    QWORD_RATE   ( SGPERF_SERVER_SGMSG_RATE                           ),
    QWORD_COUNTER( SGPERF_SERVER_SGMSG_INVALID                        ),
    QWORD_RATE   ( SGPERF_SERVER_SGMSG_INVALID_RATE                   ),
    QWORD_COUNTER( SGPERF_SERVER_SGMSG_NOMATCH                        ),
    QWORD_RATE   ( SGPERF_SERVER_SGMSG_NOMATCH_RATE                   ),
    QWORD_COUNTER( SGPERF_SERVER_SGMSG_SPIDATA_REQ                    ),
    QWORD_COUNTER( SGPERF_SERVER_SGMSG_SPIDATA2_REQ                   ),
    QWORD_RATE   ( SGPERF_SERVER_SGMSG_SPIDATA2_REQ_RATE              ),
    QWORD_COUNTER( SGPERF_SERVER_SGMSG_SPIDATA2_BACKCOMPAT_REQ        ),
    QWORD_RATE   ( SGPERF_SERVER_SGMSG_SPIDATA2_BACKCOMPAT_REQ_RATE   ),
    QWORD_COUNTER( SGPERF_SERVER_SGMSG_KICK                           ),
    QWORD_RATE   ( SGPERF_SERVER_SGMSG_KICK_RATE                      ),
    QWORD_COUNTER( SGPERF_SERVER_SGMSG_QVALS_LAZY                     ),
    QWORD_RATE   ( SGPERF_SERVER_SGMSG_QVALS_LAZY_RATE                ),
    QWORD_COUNTER( SGPERF_SERVER_SGMSG_QVALS_PUSH                     ),
    QWORD_RATE   ( SGPERF_SERVER_SGMSG_QVALS_PUSH_RATE                ),
    QWORD_COUNTER( SGPERF_SERVER_SGMSG_XBTOXB_FORWARD                 ),
    QWORD_RATE   ( SGPERF_SERVER_SGMSG_XBTOXB_FORWARD_RATE            ),
    QWORD_COUNTER( SGPERF_SERVER_SECMSG                               ),
    QWORD_RATE   ( SGPERF_SERVER_SECMSG_RATE                          ),
    QWORD_COUNTER( SGPERF_SERVER_SECMSG_DELETE                        ),
    QWORD_RATE   ( SGPERF_SERVER_SECMSG_DELETE_RATE                   ),
    QWORD_COUNTER( SGPERF_SERVER_SECMSG_PULSE                         ),
    QWORD_RATE   ( SGPERF_SERVER_SECMSG_PULSE_RATE                    ),
    QWORD_COUNTER( SGPERF_SERVER_SECMSG_DATA_PULSE                    ),
    QWORD_RATE   ( SGPERF_SERVER_SECMSG_DATA_PULSE_RATE               ),
    QWORD_COUNTER( SGPERF_SERVER_SECMSG_XBTOXB_FORWARD                ),
    QWORD_RATE   ( SGPERF_SERVER_SECMSG_XBTOXB_FORWARD_RATE           ),
    QWORD_COUNTER( SGPERF_SERVER_SECMSG_QOS                           ),
    QWORD_RATE   ( SGPERF_SERVER_SECMSG_QOS_RATE                      ),
    QWORD_COUNTER( SGPERF_SERVER_SECMSG_CHANGE_USERS                  ),
    QWORD_RATE   ( SGPERF_SERVER_SECMSG_CHANGE_USERS_RATE             ),
    QWORD_COUNTER( SGPERF_SERVER_DROP_ENET_HDR                        ),
    QWORD_RATE   ( SGPERF_SERVER_DROP_ENET_HDR_RATE                   ),
    QWORD_COUNTER( SGPERF_SERVER_DROP_IP_HDR                          ),
    QWORD_RATE   ( SGPERF_SERVER_DROP_IP_HDR_RATE                     ),
    QWORD_COUNTER( SGPERF_SERVER_DROP_XSP_HDR                         ),
    QWORD_COUNTER( SGPERF_SERVER_DROP_XSP_HASH                        ),
    QWORD_RATE   ( SGPERF_SERVER_DROP_XSP_HASH_RATE                   ),
    QWORD_COUNTER( SGPERF_SERVER_DROP_DENIED                          ),
    QWORD_RATE   ( SGPERF_SERVER_DROP_DENIED_RATE                     ),
    QWORD_COUNTER( SGPERF_SERVER_DROP_KEYEX_BLOCKED                   ),
    QWORD_RATE   ( SGPERF_SERVER_DROP_KEYEX_BLOCKED_RATE              ),
    QWORD_COUNTER( SGPERF_SERVER_DROP_KEYEX_FORMAT                    ),
    QWORD_RATE   ( SGPERF_SERVER_DROP_KEYEX_FORMAT_RATE               ),
    QWORD_COUNTER( SGPERF_SERVER_DROP_KEYEX_KERB                      ),
    QWORD_RATE   ( SGPERF_SERVER_DROP_KEYEX_KERB_RATE                 ),
    QWORD_COUNTER( SGPERF_SERVER_DROP_KEYEX_AUTHENTICATOR             ),
    QWORD_RATE   ( SGPERF_SERVER_DROP_KEYEX_AUTHENTICATOR_RATE        ),
    QWORD_COUNTER( SGPERF_SERVER_DROP_KEYEX_TOO_SOON                  ),
    QWORD_RATE   ( SGPERF_SERVER_DROP_KEYEX_TOO_SOON_RATE             ),
    QWORD_COUNTER( SGPERF_SERVER_DROP_KEYEX_HASH                      ),
    QWORD_RATE   ( SGPERF_SERVER_DROP_KEYEX_HASH_RATE                 ),
    QWORD_RATE   ( SGPERF_SERVER_THREAD_POOL_WAIT_RATE                ),
    QWORD_COUNTER( SGPERF_SERVER_THREAD_POOL_ACTIVE                   ),
    QWORD_RATE   ( SGPERF_SERVER_THREAD_POOL_WORKITEMS_MISS_RATE      ),
    QWORD_RATE   ( SGPERF_SERVER_THREAD_POOL_WORKITEMS_HIT_RATE       ),
    QWORD_AVERAGE( SGPERF_SERVER_THREAD_POOL_BATCHSIZE_AVERAGE        ),
    DWORD_BASE   ( SGPERF_SERVER_THREAD_POOL_BATCHSIZE_BASE           ),
    QWORD_RATE   ( SGPERF_SERVER_SPIN_LOCK_COLLISION_RATE             ),
    QWORD_RATE   ( SGPERF_SERVER_SPIN_LOCK_SLEEP_RATE                 ),
    QWORD_RATE   ( SGPERF_SERVER_SPIN_LOCK_LOCKS_RATE                 ),
    QWORD_COUNTER( SGPERF_SERVER_PACKETALLOC_FAIL                     ),
    QWORD_RATE   ( SGPERF_SERVER_PACKETALLOC_FAIL_RATE                ),
    QWORD_RATE   ( SGPERF_SERVER_PACKETALLOC_SUCCESS_RATE             ),
    QWORD_AVERAGE( SGPERF_SERVER_ZLATENCY_AVERAGE                     ),
    DWORD_BASE   ( SGPERF_SERVER_ZLATENCY_BASE                        ),
    QWORD_COUNTER( SGPERF_SERVER_ZLATENCY_MAX                         ),
    QWORD_AVERAGE( SGPERF_SERVER_ILATENCY_AVERAGE                     ),
    DWORD_BASE   ( SGPERF_SERVER_ILATENCY_BASE                        ),
    QWORD_COUNTER( SGPERF_SERVER_ILATENCY_MAX                         ),
    QWORD_RATE   ( SGPERF_SERVER_LOGLINES_FLOWMAP_RATE                ),
    OBJECT       ( SGPERF_SERVER_OBJECT_DRIVER                        ),
    QWORD_COUNTER( SGPERF_DRIVER_PACKETS_ALLOCATED                    ),
    QWORD_RATE   ( SGPERF_DRIVER_PROTOCOL_RECEIVE_PACKET_CALLS        ),
    QWORD_RATE   ( SGPERF_DRIVER_PROTOCOL_RECEIVE_PACKET_COPY_CALLS   ),
    QWORD_RATE   ( SGPERF_DRIVER_PROTOCOL_RECEIVE_INDICATION_CALLS    ),
    QWORD_RATE   ( SGPERF_DRIVER_PROTOCOL_RECEIVE_INDICATION_DISCARD  ),
    QWORD_RATE   ( SGPERF_DRIVER_PROTOCOL_RECEIVE_COMPLETE_CALLS      ),
    QWORD_COUNTER( SGPERF_SERVER_IRECV_BATCH_THRESHOLD                ),
    QWORD_COUNTER( SGPERF_SERVER_IXMIT_INPROGRESS                     ),
    QWORD_COUNTER( SGPERF_SERVER_IXMIT_STAGE1_COUNT                   ),
    QWORD_COUNTER( SGPERF_SERVER_IXMIT_STAGE2_COUNT                   ),
    QWORD_RATE   ( SGPERF_SERVER_IDROP_PACKETS_DRIVER_RATE            ),
    QWORD_RATE   ( SGPERF_SERVER_IRECV_PACKETS_DRIVER_RATE            ),
    QWORD_RATE   ( SGPERF_SERVER_IXMIT_PACKETS_DRIVER_RATE            ),
    QWORD_RATE   ( SGPERF_SERVER_IRECV_DRIVER_CALLS_RATE              ),
    QWORD_RATE   ( SGPERF_SERVER_IXMIT_DRIVER_CALLS_RATE              ),
    QWORD_COUNTER( SGPERF_SERVER_ZRECV_BATCH_THRESHOLD                ),
    QWORD_COUNTER( SGPERF_SERVER_ZXMIT_INPROGRESS                     ),
    QWORD_COUNTER( SGPERF_SERVER_ZXMIT_STAGE1_COUNT                   ),
    QWORD_COUNTER( SGPERF_SERVER_ZXMIT_STAGE2_COUNT                   ),
    QWORD_RATE   ( SGPERF_SERVER_ZDROP_PACKETS_DRIVER_RATE            ),
    QWORD_RATE   ( SGPERF_SERVER_ZRECV_PACKETS_DRIVER_RATE            ),
    QWORD_RATE   ( SGPERF_SERVER_ZXMIT_PACKETS_DRIVER_RATE            ),
    QWORD_RATE   ( SGPERF_SERVER_ZRECV_DRIVER_CALLS_RATE              ),
    QWORD_RATE   ( SGPERF_SERVER_ZXMIT_DRIVER_CALLS_RATE              ),
    OBJECT       ( SGPERF_SERVER_OBJECT_NOTIFICATIONS                 ),
    QWORD_RATE   ( SGPERF_SERVER_NOTIFICATIONS_DELETE_RATE            ),
    QWORD_RATE   ( SGPERF_SERVER_NOTIFICATIONS_UPDATE_RATE            ),
    QWORD_RATE   ( SGPERF_SERVER_NOTIFICATIONS_TITLECHANGE_RATE       ),
    QWORD_RATE   ( SGPERF_SERVER_NOTIFICATIONS_USERCHANGE_RATE        ),
    QWORD_RATE   ( SGPERF_SERVER_NOTIFICATIONS_SPIUPDATE_RATE         ),
    QWORD_COUNTER( SGPERF_SERVER_NOTIFICATIONS_DELETE_DROP_TOTAL      ),
    QWORD_COUNTER( SGPERF_SERVER_NOTIFICATIONS_UPDATE_DROP_TOTAL      ),
    QWORD_COUNTER( SGPERF_SERVER_NOTIFICATIONS_TITLECHANGE_DROP_TOTAL ),
    QWORD_COUNTER( SGPERF_SERVER_NOTIFICATIONS_USERCHANGE_DROP_TOTAL  ),
    QWORD_COUNTER( SGPERF_SERVER_NOTIFICATIONS_SPIUPDATE_DROP_TOTAL   ),
    QWORD_COUNTER( SGPERF_SERVER_NOTIFICATIONS_DELETE_QUEUE           ),
    QWORD_COUNTER( SGPERF_SERVER_NOTIFICATIONS_UPDATE_QUEUE           ),
    QWORD_COUNTER( SGPERF_SERVER_NOTIFICATIONS_TITLECHANGE_QUEUE      ),
    QWORD_COUNTER( SGPERF_SERVER_NOTIFICATIONS_USERCHANGE_QUEUE       ),
    QWORD_COUNTER( SGPERF_SERVER_NOTIFICATIONS_SPIUPDATE_QUEUE        ),
    QWORD_RATE   ( SGPERF_SERVER_NOTIFICATIONS_DELETE_BATCHES         ),
    QWORD_RATE   ( SGPERF_SERVER_NOTIFICATIONS_UPDATE_BATCHES         ),
    QWORD_RATE   ( SGPERF_SERVER_NOTIFICATIONS_TITLECHANGE_BATCHES    ),
    QWORD_RATE   ( SGPERF_SERVER_NOTIFICATIONS_USERCHANGE_BATCHES     ),
    QWORD_RATE   ( SGPERF_SERVER_NOTIFICATIONS_SPIUPDATE_BATCHES      ),
    OBJECT       ( SGPERF_SERVER_OBJECT_CHALLENGES                    ),
    QWORD_COUNTER( SGPERF_CHAL_SYNC_ISSUE                             ),
    QWORD_RATE   ( SGPERF_CHAL_SYNC_ISSUE_RATE                        ),
    QWORD_COUNTER( SGPERF_CHAL_SYNC_RESPONSE                          ),
    QWORD_RATE   ( SGPERF_CHAL_SYNC_RESPONSE_RATE                     ),
    QWORD_COUNTER( SGPERF_CHAL_SYNC_TIMEOUT                           ),
    QWORD_RATE   ( SGPERF_CHAL_SYNC_TIMEOUT_RATE                      ),
    QWORD_COUNTER( SGPERF_CHAL_SYNC_OUTCOME_PASS                      ),
    QWORD_RATE   ( SGPERF_CHAL_SYNC_OUTCOME_PASS_RATE                 ),
    QWORD_COUNTER( SGPERF_CHAL_SYNC_OUTCOME_FAIL                      ),
    QWORD_RATE   ( SGPERF_CHAL_SYNC_OUTCOME_FAIL_RATE                 ),
    QWORD_COUNTER( SGPERF_CHAL_SYNC_OUTCOME_BLOCK                     ),
    QWORD_RATE   ( SGPERF_CHAL_SYNC_OUTCOME_BLOCK_RATE                ),
    QWORD_COUNTER( SGPERF_CHAL_ASYNC_ISSUE                            ),
    QWORD_RATE   ( SGPERF_CHAL_ASYNC_ISSUE_RATE                       ),
    QWORD_COUNTER( SGPERF_CHAL_ASYNC_RESPONSE                         ),
    QWORD_RATE   ( SGPERF_CHAL_ASYNC_RESPONSE_RATE                    ),
    QWORD_COUNTER( SGPERF_CHAL_ASYNC_TIMEOUT                          ),
    QWORD_RATE   ( SGPERF_CHAL_ASYNC_TIMEOUT_RATE                     ),
    QWORD_COUNTER( SGPERF_CHAL_ASYNC_TIMEOUT_ACK                      ),
    QWORD_RATE   ( SGPERF_CHAL_ASYNC_TIMEOUT_ACK_RATE                 ),
    QWORD_COUNTER( SGPERF_CHAL_ASYNC_TIMEOUT_RESP                     ),
    QWORD_RATE   ( SGPERF_CHAL_ASYNC_TIMEOUT_RESP_RATE                ),
    QWORD_COUNTER( SGPERF_CHAL_ASYNC_OUTCOME_PASS                     ),
    QWORD_RATE   ( SGPERF_CHAL_ASYNC_OUTCOME_PASS_RATE                ),
    QWORD_COUNTER( SGPERF_CHAL_ASYNC_OUTCOME_FAIL                     ),
    QWORD_RATE   ( SGPERF_CHAL_ASYNC_OUTCOME_FAIL_RATE                ),
    QWORD_COUNTER( SGPERF_CHAL_ASYNC_OUTCOME_BLOCK                    ),
    QWORD_RATE   ( SGPERF_CHAL_ASYNC_OUTCOME_BLOCK_RATE               ),
    QWORD_COUNTER( SGPERF_CHAL_GLOBAL_ISSUE                           ),
    QWORD_RATE   ( SGPERF_CHAL_GLOBAL_ISSUE_RATE                      ),
    QWORD_COUNTER( SGPERF_CHAL_GLOBAL_RESPONSE                        ),
    QWORD_RATE   ( SGPERF_CHAL_GLOBAL_RESPONSE_RATE                   ),
    QWORD_COUNTER( SGPERF_CHAL_GLOBAL_TIMEOUT                         ),
    QWORD_RATE   ( SGPERF_CHAL_GLOBAL_TIMEOUT_RATE                    ),
    QWORD_COUNTER( SGPERF_CHAL_GLOBAL_OUTCOME_PASS                    ),
    QWORD_RATE   ( SGPERF_CHAL_GLOBAL_OUTCOME_PASS_RATE               ),
    QWORD_COUNTER( SGPERF_CHAL_GLOBAL_OUTCOME_FAIL                    ),
    QWORD_RATE   ( SGPERF_CHAL_GLOBAL_OUTCOME_FAIL_RATE               ),
    QWORD_COUNTER( SGPERF_CHAL_GLOBAL_OUTCOME_BLOCK                   ),
    QWORD_RATE   ( SGPERF_CHAL_GLOBAL_OUTCOME_BLOCK_RATE              ),
    QWORD_RAW_FRACTION( SGPERF_CHAL_ACTIVE                                 ),
    QWORD_RAW_BASE( SGPERF_CHAL_ACTIVE_BASE                            ),
    QWORD_RAW_FRACTION( SGPERF_CHAL_RETRY                                  ),
    QWORD_RAW_BASE( SGPERF_CHAL_RETRY_BASE                             ),
    QWORD_RAW_FRACTION( SGPERF_CHAL_RETRY_ACK_1                            ),
    QWORD_RAW_BASE( SGPERF_CHAL_RETRY_ACK_1_BASE                       ),
    QWORD_RAW_FRACTION( SGPERF_CHAL_RETRY_ACK_2                            ),
    QWORD_RAW_BASE( SGPERF_CHAL_RETRY_ACK_2_BASE                       ),
    QWORD_RAW_FRACTION( SGPERF_CHAL_RETRY_ACK_3                            ),
    QWORD_RAW_BASE( SGPERF_CHAL_RETRY_ACK_3_BASE                       ),
    QWORD_RAW_FRACTION( SGPERF_CHAL_RETRY_ACK_4                            ),
    QWORD_RAW_BASE( SGPERF_CHAL_RETRY_ACK_4_BASE                       ),
    QWORD_RAW_FRACTION( SGPERF_CHAL_RETRY_ACK_5                            ),
    QWORD_RAW_BASE( SGPERF_CHAL_RETRY_ACK_5_BASE                       ),
    QWORD_RAW_FRACTION( SGPERF_CHAL_RETRY_RESP_1                           ),
    QWORD_RAW_BASE( SGPERF_CHAL_RETRY_RESP_1_BASE                      ),
    QWORD_RAW_FRACTION( SGPERF_CHAL_RETRY_RESP_2                           ),
    QWORD_RAW_BASE( SGPERF_CHAL_RETRY_RESP_2_BASE                      ),
    QWORD_RAW_FRACTION( SGPERF_CHAL_RETRY_RESP_3                           ),
    QWORD_RAW_BASE( SGPERF_CHAL_RETRY_RESP_3_BASE                      ),
    QWORD_RAW_FRACTION( SGPERF_CHAL_RETRY_RESP_4                           ),
    QWORD_RAW_BASE( SGPERF_CHAL_RETRY_RESP_4_BASE                      ),
    QWORD_RAW_FRACTION( SGPERF_CHAL_RETRY_RESP_5                           ),
    QWORD_RAW_BASE( SGPERF_CHAL_RETRY_RESP_5_BASE                      ),
    OBJECT       ( SGPERF_SERVER_OBJECT_FILTERS                       ),
    QWORD_COUNTER( SGPERF_FILTER_KICK                                 ),
    QWORD_RATE   ( SGPERF_FILTER_KICK_RATE                            ),
    QWORD_COUNTER( SGPERF_FILTER_CIPHER_DES                           ),
    QWORD_RATE   ( SGPERF_FILTER_CIPHER_DES_RATE                      ),
    QWORD_COUNTER( SGPERF_FILTER_CIPHER_DES3                          ),
    QWORD_RATE   ( SGPERF_FILTER_CIPHER_DES3_RATE                     ),
    QWORD_COUNTER( SGPERF_FILTER_CIPHER_AES                           ),
    QWORD_RATE   ( SGPERF_FILTER_CIPHER_AES_RATE                      ),
    QWORD_COUNTER( SGPERF_FILTER_CIPHER_NULL                          ),
    QWORD_RATE   ( SGPERF_FILTER_CIPHER_NULL_RATE                     ),
    OBJECT       ( SGPERF_SERVER_OBJECT_LUA                           ),
    QWORD_COUNTER( SGPERF_SERVER_LUA_CALLS                            ),
    QWORD_RATE   ( SGPERF_SERVER_LUA_CALLS_RATE                       ),
    QWORD_COUNTER( SGPERF_SERVER_LUA_MEMORY_USAGE_BYTES               ),
    QWORD_COUNTER( SGPERF_SERVER_LUA_STATE_INUSE                      ),
    QWORD_RATE   ( SGPERF_SERVER_LUA_STATE_ACQUIRE_RATE               ),
    QWORD_TIMER  ( SGPERF_SERVER_LUA_STATE_TIME                       ),
    QWORD_TIMER  ( SGPERF_SERVER_LUA_STATE_LOCK_TIME                  ),
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\perfapp\uaperf\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_uaperf_none_12.4.56.0_none_4f9f7af34c670cc7
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_uaperf_no-public-key_12.4.56.0_x-ww_b059d64b
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=uaperf
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_uaperf_no-public-key_12.4.56.0_x-ww_b059d64b
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_uaperf_no-public-key_12.4.56.0_x-ww_b059d64b.manifest
XP_MANIFEST_PATH=manifests\x86_uaperf_no-public-key_12.4.56.0_x-ww_b059d64b.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_uaperf_no-public-key_12.4.56.0_x-ww_b059d64b.cat
XP_CATALOG_PATH=manifests\x86_uaperf_no-public-key_12.4.56.0_x-ww_b059d64b.cat
XP_PAYLOAD_PATH=x86_uaperf_no-public-key_12.4.56.0_x-ww_b059d64b
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=uaperf,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\perfapp\sgperf\sgperf.h ===
// Copyright (c) Microsoft Corporation
//
// WARNING WARNING WARNING WARNING WARNING WARNING
// ***********************************************
//
//              DO NOT EDIT THIS FILE
//
// Edit sgperf.ctr and use genctr.pl to rebuild.
//
// ***********************************************
// WARNING WARNING WARNING WARNING WARNING WARNING

#define SGPERF_SERVER_OBJECT_GLOBAL                        0
#define SGPERF_SERVER_CURRENT_CONNECTIONS_COUNTER          2
#define SGPERF_SERVER_CURRENT_FREE_CONNECTIONS_COUNTER     4
#define SGPERF_SERVER_CURRENT_FREE_CONNECTIONS_PERCENTAGE  6
#define SGPERF_SERVER_MAXIMUM_CONNECTIONS_PERCENTAGE       8
#define SGPERF_SERVER_ZRECV_RATE                           10
#define SGPERF_SERVER_ZXMIT_RATE                           12
#define SGPERF_SERVER_ZRECV_BYTES_RATE                     14
#define SGPERF_SERVER_ZXMIT_BYTES_RATE                     16
#define SGPERF_SERVER_IRECV_BYTES_RATE                     18
#define SGPERF_SERVER_IXMIT_BYTES_RATE                     20
#define SGPERF_SERVER_IRECV_RATE                           22
#define SGPERF_SERVER_IXMIT_RATE                           24
#define SGPERF_SERVER_PACKETS_AVAILABLE                    26
#define SGPERF_SERVER_KEYEX_RATE                           28
#define SGPERF_SERVER_LOGOFF_RATE                          30
#define SGPERF_SERVER_DROP_XSP_HDR_RATE                    32
#define SGPERF_SERVER_QUEUED                               34
#define SGPERF_SERVER_SGMSG_SPIDATA_REQ_RATE               36
#define SGPERF_SERVER_SGMSG_LATENCY_AVERAGE                38
#define SGPERF_SERVER_SGMSG_LATENCY_BASE                   40
#define SGPERF_SERVER_SGMSG_LATENCY_MAX                    42
#define SGPERF_DRIVER_PACKET_LATENCY_AVERAGE               44
#define SGPERF_DRIVER_PACKET_LATENCY_BASE                  46
#define SGPERF_DRIVER_PACKET_LATENCY_MAX                   48
#define SGPERF_SERVER_OBJECT_EXTENDED                      50
#define SGPERF_SERVER_CONNECTIONS_CIPHER_DES_COUNTER       52
#define SGPERF_SERVER_CONNECTIONS_CIPHER_DES3_COUNTER      54
#define SGPERF_SERVER_CONNECTIONS_CIPHER_AES_COUNTER       56
#define SGPERF_SERVER_CONNECTIONS_CIPHER_NULL_COUNTER      58
#define SGPERF_SERVER_RECV_TOTAL                           60
#define SGPERF_SERVER_RECV_BYTES                           62
#define SGPERF_SERVER_XMIT_TOTAL                           64
#define SGPERF_SERVER_QUEUED_PROC                          66
#define SGPERF_SERVER_QUEUED_CLI                           68
#define SGPERF_SERVER_DROPPED_CLI_RATE                     70
#define SGPERF_SERVER_QUEUED_SPI                           72
#define SGPERF_SERVER_DROPPED_SPI_RATE                     74
#define SGPERF_SERVER_CURRENT_BLOCKED                      76
#define SGPERF_SERVER_DROPPED_BLOCKED                      78
#define SGPERF_SERVER_DROPPED_BLOCKED_RATE                 80
#define SGPERF_SERVER_CURRENT_FREE_BLOCK_ITEMS             82
#define SGPERF_SERVER_IRECV                                84
#define SGPERF_SERVER_IRECV_BYTES                          86
#define SGPERF_SERVER_IXMIT                                88
#define SGPERF_SERVER_IXMIT_BYTES                          90
#define SGPERF_SERVER_KEYEX                                92
#define SGPERF_SERVER_KEYEX_CS                             94
#define SGPERF_SERVER_KEYEX_TOTAL                          96
#define SGPERF_SERVER_LOGOFF_TIMEOUT                       98
#define SGPERF_SERVER_LOGOFF_TIMEOUT_KEYEX                 100
#define SGPERF_SERVER_LOGOFF_TIMEOUT_REINIT                102
#define SGPERF_SERVER_LOGOFF_SECMSG                        104
#define SGPERF_SERVER_LOGOFF_KICK                          106
#define SGPERF_SERVER_XSP_RECV                             108
#define SGPERF_SERVER_XSP_RECV_TOTAL                       110
#define SGPERF_SERVER_XSP_XMIT                             112
#define SGPERF_SERVER_AUTHDATAV2                           114
#define SGPERF_SERVER_AUTHDATAV3                           116
#define SGPERF_SERVER_AUTHDATAV4                           118
#define SGPERF_SERVER_AUTHDATAV2_RATE                      120
#define SGPERF_SERVER_AUTHDATAV3_RATE                      122
#define SGPERF_SERVER_AUTHDATAV4_RATE                      124
#define SGPERF_SERVER_KEYEX_CS_RATE                        126
#define SGPERF_SERVER_KEYEX_TOTAL_RATE                     128
#define SGPERF_SERVER_XSP_RECV_RATE                        130
#define SGPERF_SERVER_XSP_RECV_TOTAL_RATE                  132
#define SGPERF_SERVER_XSP_XMIT_RATE                        134
#define SGPERF_SERVER_ZRECV                                136
#define SGPERF_SERVER_ZRECV_BYTES                          138
#define SGPERF_SERVER_ZXMIT                                140
#define SGPERF_SERVER_ZXMIT_BYTES                          142
#define SGPERF_SERVER_SGMSG                                144
#define SGPERF_SERVER_SGMSG_RATE                           146
#define SGPERF_SERVER_SGMSG_INVALID                        148
#define SGPERF_SERVER_SGMSG_INVALID_RATE                   150
#define SGPERF_SERVER_SGMSG_NOMATCH                        152
#define SGPERF_SERVER_SGMSG_NOMATCH_RATE                   154
#define SGPERF_SERVER_SGMSG_SPIDATA_REQ                    156
#define SGPERF_SERVER_SGMSG_SPIDATA2_REQ                   158
#define SGPERF_SERVER_SGMSG_SPIDATA2_REQ_RATE              160
#define SGPERF_SERVER_SGMSG_SPIDATA2_BACKCOMPAT_REQ        162
#define SGPERF_SERVER_SGMSG_SPIDATA2_BACKCOMPAT_REQ_RATE   164
#define SGPERF_SERVER_SGMSG_KICK                           166
#define SGPERF_SERVER_SGMSG_KICK_RATE                      168
#define SGPERF_SERVER_SGMSG_QVALS_LAZY                     170
#define SGPERF_SERVER_SGMSG_QVALS_LAZY_RATE                172
#define SGPERF_SERVER_SGMSG_QVALS_PUSH                     174
#define SGPERF_SERVER_SGMSG_QVALS_PUSH_RATE                176
#define SGPERF_SERVER_SGMSG_XBTOXB_FORWARD                 178
#define SGPERF_SERVER_SGMSG_XBTOXB_FORWARD_RATE            180
#define SGPERF_SERVER_SECMSG                               182
#define SGPERF_SERVER_SECMSG_RATE                          184
#define SGPERF_SERVER_SECMSG_DELETE                        186
#define SGPERF_SERVER_SECMSG_DELETE_RATE                   188
#define SGPERF_SERVER_SECMSG_PULSE                         190
#define SGPERF_SERVER_SECMSG_PULSE_RATE                    192
#define SGPERF_SERVER_SECMSG_DATA_PULSE                    194
#define SGPERF_SERVER_SECMSG_DATA_PULSE_RATE               196
#define SGPERF_SERVER_SECMSG_XBTOXB_FORWARD                198
#define SGPERF_SERVER_SECMSG_XBTOXB_FORWARD_RATE           200
#define SGPERF_SERVER_SECMSG_QOS                           202
#define SGPERF_SERVER_SECMSG_QOS_RATE                      204
#define SGPERF_SERVER_SECMSG_CHANGE_USERS                  206
#define SGPERF_SERVER_SECMSG_CHANGE_USERS_RATE             208
#define SGPERF_SERVER_DROP_ENET_HDR                        210
#define SGPERF_SERVER_DROP_ENET_HDR_RATE                   212
#define SGPERF_SERVER_DROP_IP_HDR                          214
#define SGPERF_SERVER_DROP_IP_HDR_RATE                     216
#define SGPERF_SERVER_DROP_XSP_HDR                         218
#define SGPERF_SERVER_DROP_XSP_HASH                        220
#define SGPERF_SERVER_DROP_XSP_HASH_RATE                   222
#define SGPERF_SERVER_DROP_DENIED                          224
#define SGPERF_SERVER_DROP_DENIED_RATE                     226
#define SGPERF_SERVER_DROP_KEYEX_BLOCKED                   228
#define SGPERF_SERVER_DROP_KEYEX_BLOCKED_RATE              230
#define SGPERF_SERVER_DROP_KEYEX_FORMAT                    232
#define SGPERF_SERVER_DROP_KEYEX_FORMAT_RATE               234
#define SGPERF_SERVER_DROP_KEYEX_KERB                      236
#define SGPERF_SERVER_DROP_KEYEX_KERB_RATE                 238
#define SGPERF_SERVER_DROP_KEYEX_AUTHENTICATOR             240
#define SGPERF_SERVER_DROP_KEYEX_AUTHENTICATOR_RATE        242
#define SGPERF_SERVER_DROP_KEYEX_TOO_SOON                  244
#define SGPERF_SERVER_DROP_KEYEX_TOO_SOON_RATE             246
#define SGPERF_SERVER_DROP_KEYEX_HASH                      248
#define SGPERF_SERVER_DROP_KEYEX_HASH_RATE                 250
#define SGPERF_SERVER_THREAD_POOL_WAIT_RATE                252
#define SGPERF_SERVER_THREAD_POOL_ACTIVE                   254
#define SGPERF_SERVER_THREAD_POOL_WORKITEMS_MISS_RATE      256
#define SGPERF_SERVER_THREAD_POOL_WORKITEMS_HIT_RATE       258
#define SGPERF_SERVER_THREAD_POOL_BATCHSIZE_AVERAGE        260
#define SGPERF_SERVER_THREAD_POOL_BATCHSIZE_BASE           262
#define SGPERF_SERVER_SPIN_LOCK_COLLISION_RATE             264
#define SGPERF_SERVER_SPIN_LOCK_SLEEP_RATE                 266
#define SGPERF_SERVER_SPIN_LOCK_LOCKS_RATE                 268
#define SGPERF_SERVER_PACKETALLOC_FAIL                     270
#define SGPERF_SERVER_PACKETALLOC_FAIL_RATE                272
#define SGPERF_SERVER_PACKETALLOC_SUCCESS_RATE             274
#define SGPERF_SERVER_ZLATENCY_AVERAGE                     276
#define SGPERF_SERVER_ZLATENCY_BASE                        278
#define SGPERF_SERVER_ZLATENCY_MAX                         280
#define SGPERF_SERVER_ILATENCY_AVERAGE                     282
#define SGPERF_SERVER_ILATENCY_BASE                        284
#define SGPERF_SERVER_ILATENCY_MAX                         286
#define SGPERF_SERVER_LOGLINES_FLOWMAP_RATE                288
#define SGPERF_SERVER_OBJECT_DRIVER                        290
#define SGPERF_DRIVER_PACKETS_ALLOCATED                    292
#define SGPERF_DRIVER_PROTOCOL_RECEIVE_PACKET_CALLS        294
#define SGPERF_DRIVER_PROTOCOL_RECEIVE_PACKET_COPY_CALLS   296
#define SGPERF_DRIVER_PROTOCOL_RECEIVE_INDICATION_CALLS    298
#define SGPERF_DRIVER_PROTOCOL_RECEIVE_INDICATION_DISCARD  300
#define SGPERF_DRIVER_PROTOCOL_RECEIVE_COMPLETE_CALLS      302
#define SGPERF_SERVER_IRECV_BATCH_THRESHOLD                304
#define SGPERF_SERVER_IXMIT_INPROGRESS                     306
#define SGPERF_SERVER_IXMIT_STAGE1_COUNT                   308
#define SGPERF_SERVER_IXMIT_STAGE2_COUNT                   310
#define SGPERF_SERVER_IDROP_PACKETS_DRIVER_RATE            312
#define SGPERF_SERVER_IRECV_PACKETS_DRIVER_RATE            314
#define SGPERF_SERVER_IXMIT_PACKETS_DRIVER_RATE            316
#define SGPERF_SERVER_IRECV_DRIVER_CALLS_RATE              318
#define SGPERF_SERVER_IXMIT_DRIVER_CALLS_RATE              320
#define SGPERF_SERVER_ZRECV_BATCH_THRESHOLD                322
#define SGPERF_SERVER_ZXMIT_INPROGRESS                     324
#define SGPERF_SERVER_ZXMIT_STAGE1_COUNT                   326
#define SGPERF_SERVER_ZXMIT_STAGE2_COUNT                   328
#define SGPERF_SERVER_ZDROP_PACKETS_DRIVER_RATE            330
#define SGPERF_SERVER_ZRECV_PACKETS_DRIVER_RATE            332
#define SGPERF_SERVER_ZXMIT_PACKETS_DRIVER_RATE            334
#define SGPERF_SERVER_ZRECV_DRIVER_CALLS_RATE              336
#define SGPERF_SERVER_ZXMIT_DRIVER_CALLS_RATE              338
#define SGPERF_SERVER_OBJECT_NOTIFICATIONS                 340
#define SGPERF_SERVER_NOTIFICATIONS_DELETE_RATE            342
#define SGPERF_SERVER_NOTIFICATIONS_UPDATE_RATE            344
#define SGPERF_SERVER_NOTIFICATIONS_TITLECHANGE_RATE       346
#define SGPERF_SERVER_NOTIFICATIONS_USERCHANGE_RATE        348
#define SGPERF_SERVER_NOTIFICATIONS_SPIUPDATE_RATE         350
#define SGPERF_SERVER_NOTIFICATIONS_DELETE_DROP_TOTAL      352
#define SGPERF_SERVER_NOTIFICATIONS_UPDATE_DROP_TOTAL      354
#define SGPERF_SERVER_NOTIFICATIONS_TITLECHANGE_DROP_TOTAL 356
#define SGPERF_SERVER_NOTIFICATIONS_USERCHANGE_DROP_TOTAL  358
#define SGPERF_SERVER_NOTIFICATIONS_SPIUPDATE_DROP_TOTAL   360
#define SGPERF_SERVER_NOTIFICATIONS_DELETE_QUEUE           362
#define SGPERF_SERVER_NOTIFICATIONS_UPDATE_QUEUE           364
#define SGPERF_SERVER_NOTIFICATIONS_TITLECHANGE_QUEUE      366
#define SGPERF_SERVER_NOTIFICATIONS_USERCHANGE_QUEUE       368
#define SGPERF_SERVER_NOTIFICATIONS_SPIUPDATE_QUEUE        370
#define SGPERF_SERVER_NOTIFICATIONS_DELETE_BATCHES         372
#define SGPERF_SERVER_NOTIFICATIONS_UPDATE_BATCHES         374
#define SGPERF_SERVER_NOTIFICATIONS_TITLECHANGE_BATCHES    376
#define SGPERF_SERVER_NOTIFICATIONS_USERCHANGE_BATCHES     378
#define SGPERF_SERVER_NOTIFICATIONS_SPIUPDATE_BATCHES      380
#define SGPERF_SERVER_OBJECT_CHALLENGES                    382
#define SGPERF_CHAL_SYNC_ISSUE                             384
#define SGPERF_CHAL_SYNC_ISSUE_RATE                        386
#define SGPERF_CHAL_SYNC_RESPONSE                          388
#define SGPERF_CHAL_SYNC_RESPONSE_RATE                     390
#define SGPERF_CHAL_SYNC_TIMEOUT                           392
#define SGPERF_CHAL_SYNC_TIMEOUT_RATE                      394
#define SGPERF_CHAL_SYNC_OUTCOME_PASS                      396
#define SGPERF_CHAL_SYNC_OUTCOME_PASS_RATE                 398
#define SGPERF_CHAL_SYNC_OUTCOME_FAIL                      400
#define SGPERF_CHAL_SYNC_OUTCOME_FAIL_RATE                 402
#define SGPERF_CHAL_SYNC_OUTCOME_BLOCK                     404
#define SGPERF_CHAL_SYNC_OUTCOME_BLOCK_RATE                406
#define SGPERF_CHAL_ASYNC_ISSUE                            408
#define SGPERF_CHAL_ASYNC_ISSUE_RATE                       410
#define SGPERF_CHAL_ASYNC_RESPONSE                         412
#define SGPERF_CHAL_ASYNC_RESPONSE_RATE                    414
#define SGPERF_CHAL_ASYNC_TIMEOUT                          416
#define SGPERF_CHAL_ASYNC_TIMEOUT_RATE                     418
#define SGPERF_CHAL_ASYNC_TIMEOUT_ACK                      420
#define SGPERF_CHAL_ASYNC_TIMEOUT_ACK_RATE                 422
#define SGPERF_CHAL_ASYNC_TIMEOUT_RESP                     424
#define SGPERF_CHAL_ASYNC_TIMEOUT_RESP_RATE                426
#define SGPERF_CHAL_ASYNC_OUTCOME_PASS                     428
#define SGPERF_CHAL_ASYNC_OUTCOME_PASS_RATE                430
#define SGPERF_CHAL_ASYNC_OUTCOME_FAIL                     432
#define SGPERF_CHAL_ASYNC_OUTCOME_FAIL_RATE                434
#define SGPERF_CHAL_ASYNC_OUTCOME_BLOCK                    436
#define SGPERF_CHAL_ASYNC_OUTCOME_BLOCK_RATE               438
#define SGPERF_CHAL_GLOBAL_ISSUE                           440
#define SGPERF_CHAL_GLOBAL_ISSUE_RATE                      442
#define SGPERF_CHAL_GLOBAL_RESPONSE                        444
#define SGPERF_CHAL_GLOBAL_RESPONSE_RATE                   446
#define SGPERF_CHAL_GLOBAL_TIMEOUT                         448
#define SGPERF_CHAL_GLOBAL_TIMEOUT_RATE                    450
#define SGPERF_CHAL_GLOBAL_OUTCOME_PASS                    452
#define SGPERF_CHAL_GLOBAL_OUTCOME_PASS_RATE               454
#define SGPERF_CHAL_GLOBAL_OUTCOME_FAIL                    456
#define SGPERF_CHAL_GLOBAL_OUTCOME_FAIL_RATE               458
#define SGPERF_CHAL_GLOBAL_OUTCOME_BLOCK                   460
#define SGPERF_CHAL_GLOBAL_OUTCOME_BLOCK_RATE              462
#define SGPERF_CHAL_ACTIVE                                 464
#define SGPERF_CHAL_ACTIVE_BASE                            466
#define SGPERF_CHAL_RETRY                                  468
#define SGPERF_CHAL_RETRY_BASE                             470
#define SGPERF_CHAL_RETRY_ACK_1                            472
#define SGPERF_CHAL_RETRY_ACK_1_BASE                       474
#define SGPERF_CHAL_RETRY_ACK_2                            476
#define SGPERF_CHAL_RETRY_ACK_2_BASE                       478
#define SGPERF_CHAL_RETRY_ACK_3                            480
#define SGPERF_CHAL_RETRY_ACK_3_BASE                       482
#define SGPERF_CHAL_RETRY_ACK_4                            484
#define SGPERF_CHAL_RETRY_ACK_4_BASE                       486
#define SGPERF_CHAL_RETRY_ACK_5                            488
#define SGPERF_CHAL_RETRY_ACK_5_BASE                       490
#define SGPERF_CHAL_RETRY_RESP_1                           492
#define SGPERF_CHAL_RETRY_RESP_1_BASE                      494
#define SGPERF_CHAL_RETRY_RESP_2                           496
#define SGPERF_CHAL_RETRY_RESP_2_BASE                      498
#define SGPERF_CHAL_RETRY_RESP_3                           500
#define SGPERF_CHAL_RETRY_RESP_3_BASE                      502
#define SGPERF_CHAL_RETRY_RESP_4                           504
#define SGPERF_CHAL_RETRY_RESP_4_BASE                      506
#define SGPERF_CHAL_RETRY_RESP_5                           508
#define SGPERF_CHAL_RETRY_RESP_5_BASE                      510
#define SGPERF_SERVER_OBJECT_FILTERS                       512
#define SGPERF_FILTER_KICK                                 514
#define SGPERF_FILTER_KICK_RATE                            516
#define SGPERF_FILTER_CIPHER_DES                           518
#define SGPERF_FILTER_CIPHER_DES_RATE                      520
#define SGPERF_FILTER_CIPHER_DES3                          522
#define SGPERF_FILTER_CIPHER_DES3_RATE                     524
#define SGPERF_FILTER_CIPHER_AES                           526
#define SGPERF_FILTER_CIPHER_AES_RATE                      528
#define SGPERF_FILTER_CIPHER_NULL                          530
#define SGPERF_FILTER_CIPHER_NULL_RATE                     532
#define SGPERF_SERVER_OBJECT_LUA                           534
#define SGPERF_SERVER_LUA_CALLS                            536
#define SGPERF_SERVER_LUA_CALLS_RATE                       538
#define SGPERF_SERVER_LUA_MEMORY_USAGE_BYTES               540
#define SGPERF_SERVER_LUA_STATE_INUSE                      542
#define SGPERF_SERVER_LUA_STATE_ACQUIRE_RATE               544
#define SGPERF_SERVER_LUA_STATE_TIME                       546
#define SGPERF_SERVER_LUA_STATE_LOCK_TIME                  548
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\perfapp\uaperf\UAPerf.h ===
#define UA_SERVER_OBJECT                            0

// UdpAdpt Perf counters
#define UA_REQUESTS_PER_SEC_COUNTER                 2
#define UA_REQUESTS_COUNTER                         4
#define UA_FAILED_REQUESTS_PER_SEC_COUNTER          6
#define UA_FAILED_REQUESTS_COUNTER                  8
#define UA_INVALID_HTTP_PAYLOADS_PER_SEC_COUNTER    10
#define UA_INVALID_HTTP_PAYLOADS_REQUESTS_COUNTER   12
#define UA_FAILED_HTTP_REQUESTS_PER_SEC_COUNTER     14
#define UA_FAILED_HTTP_REQUESTS_COUNTER             16
#define UA_FAILED_UDP_REPLIES_PER_SEC_COUNTER       18
#define UA_FAILED_UDP_REPLIES_COUNTER               20
#define UA_SUCCESSFUL_REPLIES_PER_SEC_COUNTER       22
#define UA_SUCCESSFUL_UDP_REPLIES_COUNTER           24
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\perfapp\uaperf\svrspec.h ===
#ifdef DEFINE_NAMES

WCHAR szDataMutexName[] = L"Shared Mutex for UDP Adaptor Data Collection";
WCHAR szPerfInfoMutexName[] = L"UA_INFO_MUTEX";
WCHAR szRegistryMutexName[] = L"UA_REGISTRY_MUTEX";
WCHAR szRegistryPathToPerformanceKeys[] = L"SYSTEM\\CurrentControlSet\\Services\\UdpAdpt\\Performance";
WCHAR szCounterDataSharedMemory[] = L"UdpAdpt PerfAPI Counter Data ShMem";
WCHAR szGlobalInfoSharedMemory[] = L"UdpAdpt PerfAPI Global Info ShMem";

#else

extern WCHAR szDataMutexName[];
extern WCHAR szPerfInfoMutexName[];
extern WCHAR szRegistryMutexName[];
extern WCHAR szRegistryPathToPerformanceKeys[];
extern WCHAR szCounterDataSharedMemory[];
extern WCHAR szGlobalInfoSharedMemory[];

#endif

#define PERF_APP_NAME "UAPerf"
#define WIDE_PERF_APP_NAME L"UAPerf"

#define MAX_PERF_OBJECTS                2
#define MAX_COUNTERS                    80
#define MAX_INSTANCES_PER_OBJECT        32

//
// Only allow a 24 character maximum on the instance name. Perfmon has trouble dealing with long
// names anyway, so if we're presented with a longer one, we truncate it. However, we attempt to
// make the truncated name unique again if possible. This value should be a multiple of 4 characters
// for perfmon not to complain.
//
#define MAX_INSTANCE_NAME               24
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\perfapp\uaperf\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_uaperf_none_12.4.56.0_none_4f9f7af34c670cc7
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_uaperf_no-public-key_12.4.56.0_x-ww_b059d64b
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=uaperf
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_uaperf_no-public-key_12.4.56.0_x-ww_b059d64b
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_uaperf_no-public-key_12.4.56.0_x-ww_b059d64b.manifest
XP_MANIFEST_PATH=manifests\x86_uaperf_no-public-key_12.4.56.0_x-ww_b059d64b.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_uaperf_no-public-key_12.4.56.0_x-ww_b059d64b.cat
XP_CATALOG_PATH=manifests\x86_uaperf_no-public-key_12.4.56.0_x-ww_b059d64b.cat
XP_PAYLOAD_PATH=x86_uaperf_no-public-key_12.4.56.0_x-ww_b059d64b
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=uaperf,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\perfapp\sgperf\svrspec.h ===
#ifdef DEFINE_NAMES

WCHAR szDataMutexName[] = L"Shared Mutex for SGPerf Data Collection";
WCHAR szPerfInfoMutexName[] = L"SGPERF_INFO_MUTEX";
WCHAR szRegistryMutexName[] = L"SGPERF_REGISTRY_MUTEX";
WCHAR szRegistryPathToPerformanceKeys[] = L"SYSTEM\\CurrentControlSet\\Services\\SGSVC\\Performance";
WCHAR szCounterDataSharedMemory[] = L"SGPerf PerfAPI Counter Data ShMem";
WCHAR szGlobalInfoSharedMemory[] = L"SGPerf PerfAPI Global Info ShMem";

#else

extern WCHAR szDataMutexName[];
extern WCHAR szPerfInfoMutexName[];
extern WCHAR szRegistryMutexName[];
extern WCHAR szRegistryPathToPerformanceKeys[];
extern WCHAR szCounterDataSharedMemory[];
extern WCHAR szGlobalInfoSharedMemory[];

#endif

#define PERF_APP_NAME "SGPerf"
#define WIDE_PERF_APP_NAME L"SGPerf"

#define MAX_PERF_OBJECTS                7
#define MAX_COUNTERS                    300
#define MAX_INSTANCES_PER_OBJECT        32

//
// Only allow a 24 character maximum on the instance name. Perfmon has trouble dealing with long
// names anyway, so if we're presented with a longer one, we truncate it. However, we attempt to
// make the truncated name unique again if possible. This value should be a multiple of 4 characters
// for perfmon not to complain.
//
#define MAX_INSTANCE_NAME               24
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\perfapp\xbancperf\svrspec.h ===
#ifdef DEFINE_NAMES

WCHAR szDataMutexName[] = L"Shared Mutex for XBancPerf Data Collection";
WCHAR szPerfInfoMutexName[] = L"XBANCPERF_INFO_MUTEX";
WCHAR szRegistryMutexName[] = L"XBANCPERF_REGISTRY_MUTEX";
WCHAR szRegistryPathToPerformanceKeys[] = L"SYSTEM\\CurrentControlSet\\Services\\xbanc\\Performance";
WCHAR szCounterDataSharedMemory[] = L"XBANCPERF PerfAPI Counter Data ShMem";
WCHAR szGlobalInfoSharedMemory[] = L"XBANCPERF PerfAPI Global Info ShMem";

#else

extern WCHAR szDataMutexName[];
extern WCHAR szPerfInfoMutexName[];
extern WCHAR szRegistryMutexName[];
extern WCHAR szRegistryPathToPerformanceKeys[];
extern WCHAR szCounterDataSharedMemory[];
extern WCHAR szGlobalInfoSharedMemory[];

#endif

#define PERF_APP_NAME "xbancPerf"
#define WIDE_PERF_APP_NAME L"xbancPerf"

#define MAX_PERF_OBJECTS                2
#define MAX_COUNTERS                    80
#define MAX_INSTANCES_PER_OBJECT        32

//
// Only allow a 24 character maximum on the instance name. Perfmon has trouble dealing with long
// names anyway, so if we're presented with a longer one, we truncate it. However, we attempt to
// make the truncated name unique again if possible. This value should be a multiple of 4 characters
// for perfmon not to complain.
//
#define MAX_INSTANCE_NAME               24
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\perfapp\WebSGperf\WebSGperf.h ===
#define WEBSGPERF_SERVER_OBJECT 0

// 
#define WEBSG_HTTP_REQUESTS_PER_SEC_COUNTER                 2
#define WEBSG_HTTP_REQUESTS_TOTAL_COUNTER                   4
#define WEBSG_HTTP_REQUESTS_FAILURES_PER_SEC_COUNTER        6
#define WEBSG_HTTP_REQUESTS_FAILURES_TOTAL_COUNTER          8
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\perfapp\WebSGperf\svrspec.h ===
#ifdef DEFINE_NAMES

WCHAR szDataMutexName[] = L"Shared Mutex for WebSGPerf Data Collection";
WCHAR szPerfInfoMutexName[] = L"WEBSGPERF_INFO_MUTEX";
WCHAR szRegistryMutexName[] = L"WEBSGPERF_REGISTRY_MUTEX";
WCHAR szRegistryPathToPerformanceKeys[] = L"SYSTEM\\CurrentControlSet\\Services\\WebSG\\Performance";
WCHAR szCounterDataSharedMemory[] = L"WEBSGPERF PerfAPI Counter Data ShMem";
WCHAR szGlobalInfoSharedMemory[] = L"WEBSGPERF PerfAPI Global Info ShMem";

#else

extern WCHAR szDataMutexName[];
extern WCHAR szPerfInfoMutexName[];
extern WCHAR szRegistryMutexName[];
extern WCHAR szRegistryPathToPerformanceKeys[];
extern WCHAR szCounterDataSharedMemory[];
extern WCHAR szGlobalInfoSharedMemory[];

#endif

#define PERF_APP_NAME "WebSGPerf"
#define WIDE_PERF_APP_NAME L"WebSGPerf"

#define MAX_PERF_OBJECTS                2
#define MAX_COUNTERS                    80
#define MAX_INSTANCES_PER_OBJECT        32

//
// Only allow a 24 character maximum on the instance name. Perfmon has trouble dealing with long
// names anyway, so if we're presented with a longer one, we truncate it. However, we attempt to
// make the truncated name unique again if possible. This value should be a multiple of 4 characters
// for perfmon not to complain.
//
#define MAX_INSTANCE_NAME               24
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\perfapp\xbancperf\xbancperf.h ===
// NOTE: these numbers MUST start at 0 and increment by 2 each.  no missing values!!
// counters must come after their respective objects.

#define XBANCPERF_SERVER_OBJECT_GENERAL 0
#define XBANC_SWITCHBOARD_WAIT_TIME_AVERAGE 2
#define XBANC_SWITCHBOARD_WAIT_TIME_BASE 4
#define XBANC_SWITCHBOARD_COMPLETION_RATE 6
#define XBANC_SWITCHBOARD_CONTEXT_TIME_AVERAGE 8
#define XBANC_SWITCHBOARD_CONTEXT_TIME_BASE 10
#define XBANC_HEARTBEAT_TIME_AVERAGE 12
#define XBANC_HEARTBEAT_TIME_BASE 14
#define XBANC_NUM_OPEN_CONNECTIONS 16
#define XBANC_REQUEST_MESSAGE_RATE 18

#define XBANCPERF_SERVER_OBJECT_DATA 20
#define XBANC_NUM_CACHE_ITEMS 22
#define XBANC_NUM_CACHE_BYTES 24
#define XBANC_INSERT_RATE 26
#define XBANC_QUERY_RATE 28
#define XBANC_REMOVE_RATE 30
#define XBANC_PURGE_RATE 32
#define XBANC_CACHE_HIT_RATE 34
#define XBANC_CACHE_MISS_RATE 36
#define XBANC_CACHE_HIT_RATIO 38
#define XBANC_CACHE_HIT_RATIO_BASE 40
#define XBANC_NUM_CACHE_DATA_BYTES 42
#define XBANC_NUM_CACHE_OVERHEAD_BYTES 44
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\perfapp\xbancperf\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_xbancperf_none_12.4.56.0_none_30be930cc673a31d
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_xbancperf_no-public-key_12.4.56.0_x-ww_7da1cdeb
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=xbancperf
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_xbancperf_no-public-key_12.4.56.0_x-ww_7da1cdeb
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_xbancperf_no-public-key_12.4.56.0_x-ww_7da1cdeb.manifest
XP_MANIFEST_PATH=manifests\x86_xbancperf_no-public-key_12.4.56.0_x-ww_7da1cdeb.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_xbancperf_no-public-key_12.4.56.0_x-ww_7da1cdeb.cat
XP_CATALOG_PATH=manifests\x86_xbancperf_no-public-key_12.4.56.0_x-ww_7da1cdeb.cat
XP_PAYLOAD_PATH=x86_xbancperf_no-public-key_12.4.56.0_x-ww_7da1cdeb
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=xbancperf,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\perfapp\xbancperf\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_xbancperf_none_12.4.56.0_none_30be930cc673a31d
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_xbancperf_no-public-key_12.4.56.0_x-ww_7da1cdeb
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=xbancperf
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_xbancperf_no-public-key_12.4.56.0_x-ww_7da1cdeb
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_xbancperf_no-public-key_12.4.56.0_x-ww_7da1cdeb.manifest
XP_MANIFEST_PATH=manifests\x86_xbancperf_no-public-key_12.4.56.0_x-ww_7da1cdeb.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_xbancperf_no-public-key_12.4.56.0_x-ww_7da1cdeb.cat
XP_CATALOG_PATH=manifests\x86_xbancperf_no-public-key_12.4.56.0_x-ww_7da1cdeb.cat
XP_PAYLOAD_PATH=x86_xbancperf_no-public-key_12.4.56.0_x-ww_7da1cdeb
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=xbancperf,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\perfapp\xdsperf\svrspec.h ===
#ifdef DEFINE_NAMES

WCHAR szDataMutexName[] = L"Shared Mutex for XDS Data Collection";
WCHAR szPerfInfoMutexName[] = L"XDS_INFO_MUTEX";
WCHAR szRegistryMutexName[] = L"XDS_REGISTRY_MUTEX";
WCHAR szRegistryPathToPerformanceKeys[] = L"SYSTEM\\CurrentControlSet\\Services\\XDS\\Performance";
WCHAR szCounterDataSharedMemory[] = L"XDS PerfAPI Counter Data ShMem";
WCHAR szGlobalInfoSharedMemory[] = L"XDS PerfAPI Global Info ShMem";

#else

extern WCHAR szDataMutexName[];
extern WCHAR szPerfInfoMutexName[];
extern WCHAR szRegistryMutexName[];
extern WCHAR szRegistryPathToPerformanceKeys[];
extern WCHAR szCounterDataSharedMemory[];
extern WCHAR szGlobalInfoSharedMemory[];

#endif

#define PERF_APP_NAME "XdsPerf"
#define WIDE_PERF_APP_NAME L"XdsPerf"

#define MAX_PERF_OBJECTS                2
#define MAX_COUNTERS                    80
#define MAX_INSTANCES_PER_OBJECT        32

//
// Only allow a 24 character maximum on the instance name. Perfmon has trouble dealing with long
// names anyway, so if we're presented with a longer one, we truncate it. However, we attempt to
// make the truncated name unique again if possible. This value should be a multiple of 4 characters
// for perfmon not to complain.
//
#define MAX_INSTANCE_NAME               24
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\perfapp\xdsperf\XdsPerf.h ===
#define XDS_SERVER_OBJECT                            0

// Xds Perf counters
#define XDS_REQUESTS_PER_SEC_COUNTER                 2
#define XDS_REQUESTS_COUNTER                         4
#define XDS_SUCCESSFUL_REQUESTS_PER_SEC_COUNTER      6
#define XDS_SUCCESSFUL_REQUESTS_COUNTER              8
#define XDS_REFLECTIONS_REQUESTS_PER_SEC_COUNTER     10
#define XDS_REFLECTIONS_REQUESTS_COUNTER             12
#define XDS_LOG_REQUESTS_PER_SEC_COUNTER             14
#define XDS_LOG_REQUESTS_COUNTER                     16
#define XDS_ICMP_REQUESTS_PER_SEC_COUNTER            18
#define XDS_ICMP_REQUESTS_COUNTER                    20
#define XDS_INVALID_REQUESTS_PER_SEC_COUNTER         22
#define XDS_INVALID_REQUESTS_COUNTER                 24
#define XDS_INVALID_SIGNATURE_PER_SEC_COUNTER        26
#define XDS_INVALID_SIGNATURE_COUNTER                28
#define XDS_INVALID_TIMESTAMP_PER_SEC_COUNTER        30
#define XDS_INVALID_TIMESTAMP_COUNTER                32
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\perfapp\xdsperf\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_xdsperf_none_12.4.56.0_none_e74b706d9cf920b0
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_xdsperf_no-public-key_12.4.56.0_x-ww_7c0b1e06
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=xdsperf
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_xdsperf_no-public-key_12.4.56.0_x-ww_7c0b1e06
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_xdsperf_no-public-key_12.4.56.0_x-ww_7c0b1e06.manifest
XP_MANIFEST_PATH=manifests\x86_xdsperf_no-public-key_12.4.56.0_x-ww_7c0b1e06.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_xdsperf_no-public-key_12.4.56.0_x-ww_7c0b1e06.cat
XP_CATALOG_PATH=manifests\x86_xdsperf_no-public-key_12.4.56.0_x-ww_7c0b1e06.cat
XP_PAYLOAD_PATH=x86_xdsperf_no-public-key_12.4.56.0_x-ww_7c0b1e06
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=xdsperf,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\perfapp\xeventperf\xeventperf.h ===
#define XEVENTPERF_SERVER_OBJECT 0

#define XEVENTPERF_SERVER_CONCURRENT_THREADS 2
#define XEVENTPERF_SERVER_EVENTS_TOTAL_COUNTER 4
#define XEVENTPERF_SERVER_EVENTS_TOTAL_RATE 6
#define XEVENTPERF_SERVER_EVENTS_FAILED_COUNTER 8
#define XEVENTPERF_SERVER_EVENTS_FAILED_RATE 10
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\perfapp\xeventperf\svrspec.h ===
#ifdef DEFINE_NAMES

WCHAR szDataMutexName[] = L"Shared Mutex for XEvents Data Collection";
WCHAR szPerfInfoMutexName[] = L"XEVENTPERF_INFO_MUTEX";
WCHAR szRegistryMutexName[] = L"XEVENTPERF_REGISTRY_MUTEX";
WCHAR szRegistryPathToPerformanceKeys[] = L"SYSTEM\\CurrentControlSet\\Services\\XEvents\\Performance";
WCHAR szCounterDataSharedMemory[] = L"XEvents PerfAPI Counter Data ShMem";
WCHAR szGlobalInfoSharedMemory[] = L"XEvents PerfAPI Global Info ShMem";

#else

extern WCHAR szDataMutexName[];
extern WCHAR szPerfInfoMutexName[];
extern WCHAR szRegistryMutexName[];
extern WCHAR szRegistryPathToPerformanceKeys[];
extern WCHAR szCounterDataSharedMemory[];
extern WCHAR szGlobalInfoSharedMemory[];

#endif

#define PERF_APP_NAME "XEVENTPERF"
#define WIDE_PERF_APP_NAME L"XEVENTPERF"

#define MAX_PERF_OBJECTS                1
#define MAX_COUNTERS                    20
#define MAX_INSTANCES_PER_OBJECT        4

//
// Only allow a 24 character maximum on the instance name. Perfmon has trouble dealing with long
// names anyway, so if we're presented with a longer one, we truncate it. However, we attempt to
// make the truncated name unique again if possible. This value should be a multiple of 4 characters
// for perfmon not to complain.
//
#define MAX_INSTANCE_NAME               24
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\perfapp\xkdcperf\svrspec.h ===
#ifdef DEFINE_NAMES

WCHAR szDataMutexName[] = L"Shared Mutex for XKDCPERF Data Collection";
WCHAR szPerfInfoMutexName[] = L"XKDCPERF_INFO_MUTEX";
WCHAR szRegistryMutexName[] = L"XKDCPERF_REGISTRY_MUTEX";
WCHAR szRegistryPathToPerformanceKeys[] = L"SYSTEM\\CurrentControlSet\\Services\\XKDCP\\Performance";
WCHAR szCounterDataSharedMemory[] = L"XKDCPERF PerfAPI Counter Data ShMem";
WCHAR szGlobalInfoSharedMemory[] = L"XKDCPERF PerfAPI Global Info ShMem";

#else

extern WCHAR szDataMutexName[];
extern WCHAR szPerfInfoMutexName[];
extern WCHAR szRegistryMutexName[];
extern WCHAR szRegistryPathToPerformanceKeys[];
extern WCHAR szCounterDataSharedMemory[];
extern WCHAR szGlobalInfoSharedMemory[];

#endif

#define PERF_APP_NAME "XKDCPERF"
#define WIDE_PERF_APP_NAME L"XKDCPERF"

#define MAX_PERF_OBJECTS                2
#define MAX_COUNTERS                    80
#define MAX_INSTANCES_PER_OBJECT        32

//
// Only allow a 24 character maximum on the instance name. Perfmon has trouble dealing with long
// names anyway, so if we're presented with a longer one, we truncate it. However, we attempt to
// make the truncated name unique again if possible. This value should be a multiple of 4 characters
// for perfmon not to complain.
//
#define MAX_INSTANCE_NAME               24
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\perfapp\xkdcperf\xkdcperf.h ===
#define XKDCPERF_SERVER_OBJECT 0

// Do not change these without changing them in askdcperf or xmacsperf.  The
// base perfcounter code relies on these values being the same for all of the
// KDC providers.
#define XKDCPERF_SERVER_AS_REQ_COUNTER                  2
#define XKDCPERF_SERVER_AS_REQ_RATE                     4
#define XKDCPERF_SERVER_TGS_REQ_COUNTER                 6
#define XKDCPERF_SERVER_TGS_REQ_RATE                    8

#define XKDCPERF_SERVER_AS_SUCCESS_COUNTER             10
#define XKDCPERF_SERVER_AS_SUCCESS_RATE                12
#define XKDCPERF_SERVER_AS_FAILURE_COUNTER             14
#define XKDCPERF_SERVER_AS_FAILURE_RATE                16

#define XKDCPERF_SERVER_TGS_SUCCESS_COUNTER            18
#define XKDCPERF_SERVER_TGS_SUCCESS_RATE               20
#define XKDCPERF_SERVER_TGS_FAILURE_COUNTER            22
#define XKDCPERF_SERVER_TGS_FAILURE_RATE               24

#define XKDCPERF_SERVER_TIMESKEW_COUNTER               26
#define XKDCPERF_SERVER_TIMESKEW_RATE                  28
#define XKDCPERF_SERVER_SILENT_FAILURE_COUNTER         30
#define XKDCPERF_SERVER_SILENT_FAILURE_RATE            32

#define XKDCPERF_SERVER_HTTP_REQ_COUNTER               34
#define XKDCPERF_SERVER_HTTP_REQ_RATE                  36
#define XKDCPERF_SERVER_HTTP_REQ_CURRENT               38
#define XKDCPERF_SERVER_HTTP_REQ_TIME_AVERAGE          40
#define XKDCPERF_SERVER_HTTP_REQ_TIME_BASE             42
#define XKDCPERF_SERVER_HTTP_REQ_500_COUNTER           44
#define XKDCPERF_SERVER_HTTP_REQ_500_RATE              46
#define XKDCPERF_SERVER_HTTP_REQ_TIMEOUT_COUNTER       48
#define XKDCPERF_SERVER_HTTP_REQ_TIMEOUT_RATE          50
#define XKDCPERF_SERVER_HTTP_REQ_RETRY_COUNTER         52
#define XKDCPERF_SERVER_HTTP_REQ_RETRY_RATE            54

#define XKDCPERF_SERVER_GETPRINCIPAL_COUNTER           56
#define XKDCPERF_SERVER_GETPRINCIPAL_RATE              58
#define XKDCPERF_SERVER_GETPRINCIPAL_CURRENT           60
#define XKDCPERF_SERVER_GETPRINCIPAL_TIME_AVERAGE      62
#define XKDCPERF_SERVER_GETPRINCIPAL_TIME_BASE         64


// These counters are specific to XKDC and may be changed without affecting
// other providers.
#define XKDCPERF_SERVER_DOS_ENTRIES_IN_USE             66
#define XKDCPERF_SERVER_DOS_REPLAYS                    68
#define XKDCPERF_SERVER_DOS_REPLAYS_RATE               70
#define XKDCPERF_SERVER_MACHINE_TICKETS                72
#define XKDCPERF_SERVER_MACHINE_TICKETS_RATE           74
#define XKDCPERF_SERVER_USER_TICKETS                   76
#define XKDCPERF_SERVER_USER_TICKETS_RATE              78
#define XKDCPERF_SERVER_USER_TICKETS_TOTAL_USERS       80
#define XKDCPERF_SERVER_USERS_PER_TICKET_AVERAGE       82
#define XKDCPERF_SERVER_USERS_PER_TICKET_BASE          84
#define XKDCPERF_SERVER_INVALID_TICKETS                86
#define XKDCPERF_SERVER_INVALID_TICKETS_RATE           88
#define XKDCPERF_SERVER_XBOX_REQUESTS_RATE             90
#define XKDCPERF_SERVER_XBOX_FAILURES_RATE             92
#define XKDCPERF_SERVER_XBOX360_REQUESTS_RATE          94
#define XKDCPERF_SERVER_XBOX360_FAILURES_RATE          96
#define XKDCPERF_SERVER_PC_REQUESTS_RATE               98
#define XKDCPERF_SERVER_PC_FAILURES_RATE               100
#define XKDCPERF_SERVER_CACHE_INUSE_FAILURE_COUNTER    102
#define XKDCPERF_SERVER_CACHE_INUSE_FAILURE_RATE       104
#define XKDCPERF_SERVER_CACHE_NORECORD_FAILURE_COUNTER 106
#define XKDCPERF_SERVER_CACHE_NORECORD_FAILURE_RATE    108
#define XKDCPERF_SERVER_CACHE_MISS_INITIALREQ_RATE     110
#define XKDCPERF_SERVER_CACHE_MISS_NOTFOUND_RATE       112
#define XKDCPERF_SERVER_CACHE_MISS_INVALID_RATE        114
#define XKDCPERF_SERVER_CACHE_HIT_RATE                 116
#define XKDCPERF_SERVER_FLASH_VERSION_UPDATE_COUNTER   118
#define XKDCPERF_SERVER_FLASH_VERSION_UPDATE_RATE      120
#define XKDCPERF_SERVER_FLASH_VERSION_UPDATE_FAILED_COUNTER 122
#define XKDCPERF_SERVER_FLASH_VERSION_UPDATE_FAILED_RATE    124
#define XKDCPERF_SERVER_FLASH_VERSION_ROLLBACK_COUNTER 126
#define XKDCPERF_SERVER_FLASH_VERSION_ROLLBACK_RATE    128
#define XKDCPERF_SERVER_CONSOLE_REGION_SET_COUNTER     130
#define XKDCPERF_SERVER_CONSOLE_REGION_SET_RATE        132
#define XKDCPERF_SERVER_CONSOLE_REGION_SET_FAILED_COUNTER 134
#define XKDCPERF_SERVER_CONSOLE_REGION_SET_FAILED_RATE 136
#define XKDCPERF_SERVER_CONSOLE_REGION_OVERWRITTEN_COUNTER 138
#define XKDCPERF_SERVER_CONSOLE_REGION_OVERWRITTEN_RATE 140
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\perfapp\xkdcperf\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_xkdcperf_none_12.4.56.0_none_1d4806529a9d23b9
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_xkdcperf_no-public-key_12.4.56.0_x-ww_56e05591
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=xkdcperf
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_xkdcperf_no-public-key_12.4.56.0_x-ww_56e05591
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_xkdcperf_no-public-key_12.4.56.0_x-ww_56e05591.manifest
XP_MANIFEST_PATH=manifests\x86_xkdcperf_no-public-key_12.4.56.0_x-ww_56e05591.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_xkdcperf_no-public-key_12.4.56.0_x-ww_56e05591.cat
XP_CATALOG_PATH=manifests\x86_xkdcperf_no-public-key_12.4.56.0_x-ww_56e05591.cat
XP_PAYLOAD_PATH=x86_xkdcperf_no-public-key_12.4.56.0_x-ww_56e05591
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=xkdcperf,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\perfapp\xkdcperf\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_xkdcperf_none_12.4.56.0_none_1d4806529a9d23b9
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_xkdcperf_no-public-key_12.4.56.0_x-ww_56e05591
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=xkdcperf
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_xkdcperf_no-public-key_12.4.56.0_x-ww_56e05591
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_xkdcperf_no-public-key_12.4.56.0_x-ww_56e05591.manifest
XP_MANIFEST_PATH=manifests\x86_xkdcperf_no-public-key_12.4.56.0_x-ww_56e05591.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_xkdcperf_no-public-key_12.4.56.0_x-ww_56e05591.cat
XP_CATALOG_PATH=manifests\x86_xkdcperf_no-public-key_12.4.56.0_x-ww_56e05591.cat
XP_PAYLOAD_PATH=x86_xkdcperf_no-public-key_12.4.56.0_x-ww_56e05591
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=xkdcperf,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\perfapp\xmacsperf\svrspec.h ===
#ifdef DEFINE_NAMES

WCHAR szDataMutexName[] = L"Shared Mutex for XMACSPERF Data Collection";
WCHAR szPerfInfoMutexName[] = L"XMACSPERF_INFO_MUTEX";
WCHAR szRegistryMutexName[] = L"XMACSPERF_REGISTRY_MUTEX";
WCHAR szRegistryPathToPerformanceKeys[] = L"SYSTEM\\CurrentControlSet\\Services\\XMACS\\Performance";
WCHAR szCounterDataSharedMemory[] = L"XMACSPERF PerfAPI Counter Data ShMem";
WCHAR szGlobalInfoSharedMemory[] = L"XMACSPERF PerfAPI Global Info ShMem";

#else

extern WCHAR szDataMutexName[];
extern WCHAR szPerfInfoMutexName[];
extern WCHAR szRegistryMutexName[];
extern WCHAR szRegistryPathToPerformanceKeys[];
extern WCHAR szCounterDataSharedMemory[];
extern WCHAR szGlobalInfoSharedMemory[];

#endif

#define PERF_APP_NAME "XMACSPERF"
#define WIDE_PERF_APP_NAME L"XMACSPERF"

#define MAX_PERF_OBJECTS                2
#define MAX_COUNTERS                    80
#define MAX_INSTANCES_PER_OBJECT        32

//
// Only allow a 24 character maximum on the instance name. Perfmon has trouble dealing with long
// names anyway, so if we're presented with a longer one, we truncate it. However, we attempt to
// make the truncated name unique again if possible. This value should be a multiple of 4 characters
// for perfmon not to complain.
//
#define MAX_INSTANCE_NAME               24
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\perfapp\xmacsperf\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_xmacsperf_none_12.4.56.0_none_40066c6b6f0bef3d
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_xmacsperf_no-public-key_12.4.56.0_x-ww_7d486b7b
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=xmacsperf
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_xmacsperf_no-public-key_12.4.56.0_x-ww_7d486b7b
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_xmacsperf_no-public-key_12.4.56.0_x-ww_7d486b7b.manifest
XP_MANIFEST_PATH=manifests\x86_xmacsperf_no-public-key_12.4.56.0_x-ww_7d486b7b.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_xmacsperf_no-public-key_12.4.56.0_x-ww_7d486b7b.cat
XP_CATALOG_PATH=manifests\x86_xmacsperf_no-public-key_12.4.56.0_x-ww_7d486b7b.cat
XP_PAYLOAD_PATH=x86_xmacsperf_no-public-key_12.4.56.0_x-ww_7d486b7b
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=xmacsperf,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\perfapp\xmacsperf\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_xmacsperf_none_12.4.56.0_none_40066c6b6f0bef3d
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_xmacsperf_no-public-key_12.4.56.0_x-ww_7d486b7b
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=xmacsperf
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_xmacsperf_no-public-key_12.4.56.0_x-ww_7d486b7b
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_xmacsperf_no-public-key_12.4.56.0_x-ww_7d486b7b.manifest
XP_MANIFEST_PATH=manifests\x86_xmacsperf_no-public-key_12.4.56.0_x-ww_7d486b7b.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_xmacsperf_no-public-key_12.4.56.0_x-ww_7d486b7b.cat
XP_CATALOG_PATH=manifests\x86_xmacsperf_no-public-key_12.4.56.0_x-ww_7d486b7b.cat
XP_PAYLOAD_PATH=x86_xmacsperf_no-public-key_12.4.56.0_x-ww_7d486b7b
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=xmacsperf,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\perfapp\xmacsperf\xmacsperf.h ===
#define XMACSPERF_SERVER_OBJECT                             0

// Do not change these without changing them in askdcperf or xkdcperf.  The
// base perfcounter code relies on these values being the same for all of the
// KDC providers.
#define XMACSPERF_SERVER_AS_REQ_COUNTER                      2
#define XMACSPERF_SERVER_AS_REQ_RATE                         4
#define XMACSPERF_SERVER_TGS_REQ_COUNTER                     6
#define XMACSPERF_SERVER_TGS_REQ_RATE                        8

#define XMACSPERF_SERVER_AS_SUCCESS_COUNTER                 10
#define XMACSPERF_SERVER_AS_SUCCESS_RATE                    12
#define XMACSPERF_SERVER_AS_FAILURE_COUNTER                 14
#define XMACSPERF_SERVER_AS_FAILURE_RATE                    16

#define XMACSPERF_SERVER_TGS_SUCCESS_COUNTER                18
#define XMACSPERF_SERVER_TGS_SUCCESS_RATE                   20
#define XMACSPERF_SERVER_TGS_FAILURE_COUNTER                22
#define XMACSPERF_SERVER_TGS_FAILURE_RATE                   24

#define XMACSPERF_SERVER_TIMESKEW_COUNTER                   26
#define XMACSPERF_SERVER_TIMESKEW_RATE                      28
#define XMACSPERF_SERVER_SILENT_FAILURE_COUNTER             30
#define XMACSPERF_SERVER_SILENT_FAILURE_RATE                32

#define XMACSPERF_SERVER_HTTP_REQ_COUNTER                   34
#define XMACSPERF_SERVER_HTTP_REQ_RATE                      36
#define XMACSPERF_SERVER_HTTP_REQ_CURRENT                   38
#define XMACSPERF_SERVER_HTTP_REQ_TIME_AVERAGE              40
#define XMACSPERF_SERVER_HTTP_REQ_TIME_BASE                 42
#define XMACSPERF_SERVER_HTTP_REQ_500_COUNTER               44
#define XMACSPERF_SERVER_HTTP_REQ_500_RATE                  46
#define XMACSPERF_SERVER_HTTP_REQ_TIMEOUT_COUNTER           48
#define XMACSPERF_SERVER_HTTP_REQ_TIMEOUT_RATE              50
#define XMACSPERF_SERVER_HTTP_REQ_RETRY_COUNTER             52
#define XMACSPERF_SERVER_HTTP_REQ_RETRY_RATE                54

#define XMACSPERF_SERVER_GETPRINCIPAL_COUNTER               56
#define XMACSPERF_SERVER_GETPRINCIPAL_RATE                  58
#define XMACSPERF_SERVER_GETPRINCIPAL_CURRENT               60
#define XMACSPERF_SERVER_GETPRINCIPAL_TIME_AVERAGE          62
#define XMACSPERF_SERVER_GETPRINCIPAL_TIME_BASE             64

// These counters are specific to XKDC and may be changed without affecting
// other providers.
#define XMACSPERF_SERVER_DEV_KIT_ENTRIES_COUNTER            66
#define XMACSPERF_SERVER_NCIPHER_COUNTER                    68
#define XMACSPERF_SERVER_NCIPHER_TIME_AVERAGE               70
#define XMACSPERF_SERVER_NCIPHER_TIME_BASE                  72
#define XMACSPERF_SERVER_NCIPHER_USAGE_RATE_PER_SEC         74
#define XMACSPERF_SERVER_DOS_MAXALLOWANCE_COUNTER           76
#define XMACSPERF_SERVER_DOS_CACHE_REPLAY_COUNTER           78
#define XMACSPERF_SERVER_INVALID_REQUEST_COUNTER            80
#define XMACSPERF_SERVER_REQUEST_SUCCESSFUL                 82

#define XMACSPERF_SERVER_PPA_DOS_CACHE_MISS                 84
#define XMACSPERF_SERVER_PPA_DOS_SPPA2T_MISMATCH            86
#define XMACSPERF_SERVER_PPA_DOS_BAD_TIME_DONT_RESPOND      88
#define XMACSPERF_SERVER_PPA_DOS_BAD_TIME_RESPOND           90

#define XMACSPERF_SERVER_THREADS_IN_NCIPHER                 92

#define XMACSPERF_SERVER_SUCCESS_PWD_RESET                  94 
#define XMACSPERF_SERVER_SUCCESS_PWD_RESET_RATE_PER_SEC     96 
#define XMACSPERF_SERVER_SUCCESS_CREATE_ACCOUNT             98 
#define XMACSPERF_SERVER_SUCCESS_CREATE_ACCOUNT_PER_SEC     100

#define XMACSPERF_SERVER_SUCCESS_PWD_RESET_XBOX360_RATE     102
#define XMACSPERF_SERVER_SUCCESS_CREATE_ACCOUNT_XBOX360_RATE 104

#define XMACSPERF_SERVER_SUCCESS_PWD_RESET_PC_RATE          106
#define XMACSPERF_SERVER_SUCCESS_CREATE_ACCOUNT_PC_RATE     108

#define XMACSPERF_SERVER_SUCCESS_PWD_RESET_LIMITED_RATE     110
#define XMACSPERF_SERVER_SUCCESS_CREATE_ACCOUNT_LIMITED_RATE 112

#define XMACSPERF_SERVER_SUCCESS_PWD_RESET_PC2_RATE         114
#define XMACSPERF_SERVER_SUCCESS_CREATE_ACCOUNT_PC2_RATE    116
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\fd\AssemblyInfo.cs ===
[assembly: System.Reflection.AssemblyTitle("Xbox Live Presence Front Door")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\clientstub\clientstub\presclient.cs ===
using System;
using System.Collections;

using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.protocol;
using xonline.common.service;

using xonline.common.sql.webstore;
using Microsoft.Webstore.WstClient;

namespace xonline.server.presence.client
{
    public class PresClient
    {
        //Return list of title played by the user
        public static ArrayList GetPlayedTitles(ulong  qwUserID)
        {
            ArrayList alTitles = new ArrayList();
            
            HResult hr = HResult.S_OK;
            EnumTitlesRequest actualReq = new EnumTitlesRequest();
            EnumTitlesResponse actualResp = new EnumTitlesResponse();
            XRLObject2 xrlObject = actualResp;

            actualReq.UserId = qwUserID;
            actualReq.ForUserId = qwUserID;
            actualReq.LocaleId = (ushort)Locales.en_US;
            actualReq.StartingIndex = 0;
            actualReq.MaxTitles = ushort.MaxValue;

            // this stuff is coming off the web, we don't have a machine id
            // or a user id, so we like about it.  pass zeroes for all that
            HTTPAuthData authData = new HTTPAuthData(0, 0, 0, 0, qwUserID, XOn.XENON_DASH_TITLE_ID, (uint)XOService.Progress, 0);

            hr = XRLUtil.PostXrlRequest(VirtualInterface.progressfd_int, actualReq.Xrl, authData.GetBase64EncodedString(), actualReq, ref xrlObject);

            if (HResult.S_OK == hr)
            {
                foreach (UserTitle title in actualResp.Titles)
                {
                    alTitles.Add(title.TitleId);
                }
            }

            return alTitles;
        }

        /// <summary>
        /// Overload for TagFrag Xbox1
        /// </summary>
        /// <param name="qwUserID">userId to delete</param>
        /// <param name="qwMachineID">machineId to reserve the tag to.</param>
        /// <param name="dtExpires">Expiration of reservation</param>
        public static void DeleteGamertagFromUODB(ulong qwUserID, ulong qwMachineID, DateTime dtExpires)
        {
            PresClient.DeleteGamertagFromUODB(false, qwUserID, qwMachineID, dtExpires);
        }

        /// <summary>
        /// Deletes a gamertag from UODB.
        /// </summary>
        /// <param name="leaveRecoverable">flag to leave this user acocunt in a recoverable state.</param>
        /// <param name="qwUserID">UserId to affect</param>
        /// <param name="qwMachineID">MachineId to reserve the tag to.</param>
        /// <param name="dtExpires">Expiration of reservation</param>
        public static void DeleteGamertagFromUODB(bool leaveRecoverable, ulong qwUserID, ulong qwMachineID, DateTime dtExpires)
        {
            string gamertag = null;
            ulong qwPassport = 0;
            
            // first call on the puid partition (t_users)
            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                ws.ClearParameters();
                ws.StoredProc = leaveRecoverable ? "dbo.[p_tagrecycle_delete_user]" : "dbo.[p_recycling_delete_user]";
                ws.Partition = ws.CalcPartition(qwUserID);
                ws.AddParameter("@bi_user_puid", qwUserID);

                WstDataReader reader = ws.Execute();
                if (reader.Read())
                {
                    gamertag = (string)reader["vc_gamertag"];
                    qwPassport = (ulong)(long)reader["bi_user_passport_puid"];
                }
                reader.Close();
            }

            if (gamertag != null)
            {
                // next call on the gamertag partition (t_user_names)
                using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
                {
                    ws.ClearParameters();
                    ws.StoredProc = "dbo.[p_recycling_delete_user_name]";
                    ws.Partition = ws.CalcPartition(gamertag);
                    ws.AddParameter("@vc_gamertag", gamertag);
                    ws.AddParameter("@dt_expires", dtExpires );
                    ws.AddParameter("@bi_machine_puid", (Int64) qwMachineID );
                    ws.AddParameter("@si_hash_bucket", ws.Partition );

                    WstDataReader reader = ws.Execute();
                    reader.Close();
                }
            }

            if (!leaveRecoverable && qwPassport != 0)
            {
                // next call on the passport partition (t_user_passport_puids)
                using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
                {
                    ws.ClearParameters();
                    ws.StoredProc = "dbo.[p_recycling_delete_user_passport]";
                    ws.Partition = ws.CalcPartition(qwPassport);
                    ws.AddParameter("@bi_user_passport_puid", qwPassport);

                    WstDataReader reader = ws.Execute();
                    reader.Close();
                }
            }
        }

        public static HResult RemoveAllFriends(ulong qwUserID)
        {
            ArrayList alFriends = new ArrayList();
            XRLObject2 xrlo = null;
            HResult hr = HResult.S_OK;

            // get the friends from uodb
            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.StoredProc = "dbo.p_xprof_get_friends";
                ws.Partition = ws.CalcPartition(qwUserID);

                ws.AddParameter("@bi_user_puid", qwUserID);

                WstDataReader reader = ws.Execute();

                if (reader.HasRows)
                {
                    while (reader.Read())
                    {
                        alFriends.Add((ulong)(long)reader["bi_friend_puid"]);
                    }
                }
            }

            // remove all the friends (this removes the user from each of his friends' lists.)
            foreach (ulong qwFriendID in alFriends)
            {
                PresenceDeleteBuddyMsg reqDeleteBuddy = new PresenceDeleteBuddyMsg();
                reqDeleteBuddy.qwUserID = qwUserID;
                reqDeleteBuddy.qwBuddyID = qwFriendID;
                xrlo = null;
                hr = XRLUtil.PostXrlRequest(VirtualInterface.xpnfd_presence_int, reqDeleteBuddy.GetXRL(), null, reqDeleteBuddy, ref xrlo);
                if (HResult.Failed(hr))
                {
                    throw new ApplicationException("DeleteBuddy failed for" +
                        " user 0x" + qwUserID.ToString("X") + 
                        " buddy 0x" + reqDeleteBuddy.qwBuddyID.ToString("X") + 
                        " hr = " + hr);
                }
            }

            return hr;
        }
        
        public static HResult DeleteUser(ulong qwUserID)
        {
            HResult hr = HResult.S_OK;
            XRLObject2 xrlo = null;

            // remove all the user's friends.
            hr = RemoveAllFriends(qwUserID);

            // remove the user from presence.
            PurgeUserRequest reqPurgeUser = new PurgeUserRequest();
            reqPurgeUser.puid = qwUserID;
            PurgeUserResponse replyPurgeUser = new PurgeUserResponse();
            xrlo = replyPurgeUser;
            hr = XRLUtil.PostXrlRequest(VirtualInterface.xpnfd_presence_int, reqPurgeUser.GetXRL(), null, reqPurgeUser, ref xrlo);
            if (HResult.Failed(hr) || 
                (HResult.Failed(replyPurgeUser.hr) && (replyPurgeUser.hr != 0x8000FFFF))) // E_UNEXPECTED returned when friend deletes are still in progress.  it's ok.
            {
                throw new ApplicationException("PurgeUser failed for" + 
                    " user 0x" + qwUserID.ToString("X") + 
                    " hr = " + hr +
                    " inner hr = " + ((HResult) replyPurgeUser.hr));
            }

            return hr;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\fd\CancelInvite.cs ===
ï»¿//
// GetMessageDetails.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Xbox Online Service
//
using System;
using System.Collections;
using System.IO;
using System.Text;
using System.Web;
using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.protocol;
using xonline.common.service;
using xonline.common.community;
using Microsoft.Webstore.WstClient;

namespace xonline.server.presence.fd
{

    //-----------------------------------------------------------------------------------
    // Process InviteAnswer requests
    //-----------------------------------------------------------------------------------
    public class CancelInviteHandler : PresenceHandlerBase
    {
        //-----------------------------------------------------------------------------------
        // Private data
        //-----------------------------------------------------------------------------------
        private PresenceCancelInviteMsg m_request;

        //-----------------------------------------------------------------------------------
        // Constructor
        //-----------------------------------------------------------------------------------
        public CancelInviteHandler(BaseHeader header)
            : base(header)
        {
            m_request = new PresenceCancelInviteMsg();
        }

        //-----------------------------------------------------------------------------------
        // Give the superclass access to the response
        //-----------------------------------------------------------------------------------
        protected override XRLObject2 GetResponse()
        {
            return null;
        }

        //-----------------------------------------------------------------------------------
        // Process the incoming request and generate the response
        //-----------------------------------------------------------------------------------
        public override void ProcessRequest()
        {
            // Deserialize the incoming stream
            m_request.ReadStream(new BinaryReader(HttpContext.Current.Request.InputStream));

            // Check for m_request.qwUserID!=0 done at PresenceHandlerBase::ValidateHeader()

            // Session id zero is invalid
            if (m_request.qwMatchSessionID == 0)
            {
                throw new XRLException(
                    HResult.E_INVALIDARG,
                    XEvent.Id.PRESENCE_CANCELINVITE_INVALID_SESSIONID,
                    "User {0} sent invalid sessionID of zero in InviteAnswer message", 
                    (Puid)m_request.qwUserID
                    );
            }

            // check the userid
            if (XCache.LookupGamerTag(m_request.qwUserID) == XCache.InvalidGamertag)
            {
                throw new XRLException(
                    Win32ErrorCode.GetHResult(Win32ErrorCode.Codes.ERROR_NO_SUCH_USER),
                    XEvent.Id.PRESENCE_CANCELINVITE_INVALID_USERID,
                    "User {0} does not exist.", 
                    (Puid)m_request.qwUserID
                    );
            }

            if (m_request.cInvitees > 0)
            {
                // Remove the invitees from the invitation record in the cache
                PresenceUtil.RemoveInvitees(m_request.qwUserID, m_request.rgqwInvitees, m_request.qwMatchSessionID);
                PresenceUtil.RevokeInvitees(m_request.qwUserID, m_request.rgqwInvitees, m_request.qwMatchSessionID);
            }
            else
            {
                // remove all invitees.
                PresenceUtil.ClearSpecificInvitation(m_request.qwUserID, m_request.qwMatchSessionID);
            }

        }

        //-----------------------------------------------------------------------------------
        // Handle errors during processing
        //-----------------------------------------------------------------------------------
        public override HResult ProcessError(HResult hr)
        {
            // Put the hresult in the response
            return HResult.S_OK;
        }

        //-----------------------------------------------------------------------------------
        // Log the activity
        //-----------------------------------------------------------------------------------
        public override void LogResults()
        {
            StringBuilder sb = new StringBuilder();
            foreach (ulong xuid in m_request.rgqwInvitees)
            {
                sb.AppendFormat("{0:X16};", xuid);
            }
            Xom.Log(XomAreaName.PresenceLog,
                "CAN|{0:X}|{1:X}|{2:X}|{3:X}|{4:X}|{5}|{6}",
                m_request.header.sgaddr.qwXboxId,
                m_request.header.sgaddr.inaSg,
                m_request.header.sgaddr.dwSpiSg,
                m_request.qwUserID,
                m_request.qwMatchSessionID,
                m_request.cInvitees,
                sb.ToString()
                );
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\fd\ControlRequest.cs ===
using System;
using System.Collections;
using System.Diagnostics;
using System.IO;
using System.Net;
using System.Net.Sockets;
using System.Text;
using System.Web;

using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.protocol;
using xonline.common.service;
using xonline.common.community;


namespace xonline.server.presence.fd
{
    public class XMGMTControl
    {
        public static void OnControlRequest(object sender, ControlRequestEventArgs args)
        {
            try
            {
                XomControl.ControlRequestEventHandler handler = null;
                
                switch (args.Command.ToLower())
                {
                    case "help": handler = AdminHelp; break;
                    case "showcachedata": handler = AdminShowCacheData; break;
                    case "removecachekey": handler = AdminRemoveCacheKey; break;
                    case "kick": handler = AdminKick; break;
                }

                if (handler != null)
                {
                    handler(sender, args);
                }
            }
            catch(Exception e)
            {
                XomControlConnection.SendMessage("Error: " + e.ToString() + "\r\n\r\n", args.RequestId);
            }
        }

        public static void AdminHelp(object sender, ControlRequestEventArgs args)
        {
            // leave args.Handled alone so that other help handlers may fire.
            
            StringBuilder sbOutput = new StringBuilder();
            sbOutput.AppendLine("");
            sbOutput.AppendLine("XPNFD help:");
            sbOutput.AppendLine("  ShowCacheData <key> -- Display cache value for specified key.");
            sbOutput.AppendLine("  RemoveCacheKey <key> -- Delete specified key from cache.");
            sbOutput.AppendLine("  Kick <userid (decimal)> -- Kick an online user off Xbox Live.");

            XomControlConnection.SendMessage(sbOutput.ToString(), args.RequestId);
        }
        
        public static void AdminShowCacheData(object sender, ControlRequestEventArgs args)
        {
            args.Handled = true;
            
            StringBuilder sbOutput = new StringBuilder();

            BaseDataHeader item = CacheUtil.ReadFromCache(args.CommandArgs[0]);

            if (item != null)
            {
                sbOutput.AppendLine("Item found in Cache:");
                sbOutput.AppendLine(item.ToString());
            }
            else
            {
                sbOutput.AppendLine("Item not found in Cache.");
            }

            XomControlConnection.SendMessage(sbOutput.ToString(), args.RequestId);
        }

        public static void AdminRemoveCacheKey(object sender, ControlRequestEventArgs args)
        {
            args.Handled = true;
            
            CacheUtil.RemoveFromCache(args.CommandArgs[0]);

            XomControlConnection.SendMessage("Removed key: " + args.CommandArgs[0] + ".\r\n", args.RequestId);
        }

        public static void AdminKick(object sender, ControlRequestEventArgs args)
        {
            args.Handled = true;

            ulong qwUserID = UInt64.Parse(args.CommandArgs[0]);

            PresenceRecord presence = PresenceUtil.GetPresenceRecord(qwUserID);
            if (presence == null)
            {
                XomControlConnection.SendMessage("Presence record not found for user " + qwUserID + ".\r\n", args.RequestId);
            }
            else if (!presence.IsOnline())
            {
                XomControlConnection.SendMessage("User " + qwUserID + " is not online.\r\n", args.RequestId);
            }
            else
            {
                // They're on, kick them off the system
                SGComm.SendKick(presence.sgaddr);

                XomControlConnection.SendMessage("User " + qwUserID + " was kicked.\r\n", args.RequestId);
            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\fd\FindUsers.cs ===
using System;
using System.IO;
using System.Web;
using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.protocol;
using xonline.common.service;
using xonline.common.community;
using xonline.common.sql.webstore;
using Microsoft.Webstore.WstClient;

namespace xonline.server.presence.fd
{

    internal class FindUserHandler : PresenceHandlerBase
    {
        private FindUserMsg _request;
        private FindUserReplyMsg _response;

        public FindUserHandler(BaseHeader header)
            : base(header)
        {
            _request = new FindUserMsg();
            _response = new FindUserReplyMsg();
        }

        public override void ProcessRequest()
        {
            //Parse out the request
            _request.ReadStream(new BinaryReader(HttpContext.Current.Request.InputStream));

            // User id of 0 check is not necessary since PresenceHandlerBase calls it
            // If that code ever changes we need to check 0 user id scenario here too.


            // Find the requested user via XCache  
            if (_request.qwFindID == 0)
            {
                _response.qwFoundID = XCache.LookupPUID(_request.szGamerTag);
                _response.szGamerTag = XCache.LookupGamerTag(_response.qwFoundID);
            }
            else
            {
                _response.szGamerTag = XCache.LookupGamerTag(_request.qwFindID);
                _response.qwFoundID = XCache.LookupPUID(_response.szGamerTag);
            }

            if (_response.qwFoundID == 0)
            {
                _response.szGamerTag = null;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="hr">Error return code</param>
        public override HResult ProcessError(HResult hr)
        {
            _response.qwFoundID = 0;
            _response.szGamerTag = null;
            return hr;
        }

        /// <summary>
        /// 
        /// </summary>
        public override void LogResults()
        {
            Xom.Log(XomAreaName.PresenceLog, "FindUser|{0}:{1:X}|{2}|{3}|{4}|{5}|{6}",
                    SGInfo.Current.ClientIP,
                    SGInfo.Current.ClientPort,
                    (Puid)_request.qwUserID,
                    (Puid)_request.qwFindID,
                    _request.szGamerTag,
                    (Puid)_response.qwFoundID,
                    (_response.szGamerTag == null) ? "" : _response.szGamerTag);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <returns>Base class that derives from XRLObject2</returns>
        protected override XRLObject2 GetResponse()
        {
            _response.header.dwSeqNum = m_header.dwSeqNum;
            _response.header.sgaddr = m_header.sgaddr;
            return _response;
        }
    }

    internal class FindUsersHandler : PresenceHandlerBase
    {
        private FindUsersMsg _request;
        private FindUsersReplyMsg _response;

        public FindUsersHandler(BaseHeader header)
            : base(header)
        {
            _request = new FindUsersMsg();
            _response = new FindUsersReplyMsg();
        }

        public override void ProcessRequest()
        {
            //Parse out the request
            _request.ReadStream(new BinaryReader(HttpContext.Current.Request.InputStream));

            // User id of 0 check is not necessary since PresenceHandlerBase calls it
            // If that code ever changes we need to check 0 user id scenario here too.

            // populate sparse list of gamertags.
            string[] gamertags = new string[_request.cdwQueries];
            for (uint iUser = 0; iUser < _request.cdwQueries; iUser++)
            {
                if (_request.rgQueries[iUser].qwUserID == 0)
                {
                    gamertags[iUser] = _request.rgQueries[iUser].szGamerTag;
                }
                else
                {
                    // dont pass null to xcache.
                    gamertags[iUser] = "";
                }
            }

            // get puids from xcache.
            ulong[] puids = XCache.LookupPUIDs(gamertags);

            // overwrite any puids that were passed in.
            for (uint iUser = 0; iUser < _request.cdwQueries; iUser++)
            {
                if (_request.rgQueries[iUser].qwUserID != 0)
                {
                    puids[iUser] = _request.rgQueries[iUser].qwUserID;
                }
            }

            // lookup gamertags again, this time for all puids.
            gamertags = XCache.LookupGamerTags(puids);

            // format response
            _response.rgResults = new FindUsersData[_request.cdwQueries];
            for (uint iUser = 0; iUser < _request.cdwQueries; iUser++)
            {
                // erase any gamertags for invalid users.
                if (puids[iUser] == 0)
                {
                    gamertags[iUser] = "";
                }
                else if (XCache.IsInvalidGamertag(gamertags[iUser]))
                {
                    gamertags[iUser] = "";
                    puids[iUser] = 0;
                }
                
                _response.rgResults[iUser] = new FindUsersData();
                _response.rgResults[iUser].qwUserID = puids[iUser];
                _response.rgResults[iUser].szGamerTag = gamertags[iUser];
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="hr">Error return code</param>
        public override HResult ProcessError(HResult hr)
        {
            _response.cdwResults = 0;
            _response.rgResults = null;
            return hr;
        }

        /// <summary>
        /// 
        /// </summary>
        public override void LogResults()
        {
            Xom.Log(XomAreaName.PresenceLog, "FindUsers|{0}:{1:X}|{2}|{3}|{4}",
                    SGInfo.Current.ClientIP,
                    SGInfo.Current.ClientPort,
                    (Puid)_request.qwUserID,
                    _request.cdwQueries,
                    _response.cdwResults);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <returns>Base class that derives from XRLObject2</returns>
        protected override XRLObject2 GetResponse()
        {
            _response.header.dwSeqNum = m_header.dwSeqNum;
            _response.header.sgaddr = m_header.sgaddr;
            return _response;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\fd\Affiliates.cs ===
ï»¿//
// GetMessageDetails.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Xbox Online Service
//
using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Text;
using System.Web;
using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.protocol;
using xonline.common.service;
using xonline.common.community;
using Microsoft.Webstore.WstClient;

namespace xonline.server.presence.fd
{
    #region PMSG_ADD_AFFILIATES
    //-----------------------------------------------------------------------------------
    // Process AddAffiliates requests
    //-----------------------------------------------------------------------------------
    public class AddAffiliatesHandler : PresenceHandlerBase
    {
        //-----------------------------------------------------------------------------------
        // Private data
        //-----------------------------------------------------------------------------------
        private PresenceAddAffiliatesMsg m_request;

        //-----------------------------------------------------------------------------------
        // Constructor
        //-----------------------------------------------------------------------------------
        public AddAffiliatesHandler(BaseHeader header)
            : base(header)
        {
            m_request = new PresenceAddAffiliatesMsg();
        }

        //-----------------------------------------------------------------------------------
        // Give the superclass access to the response
        //-----------------------------------------------------------------------------------
        protected override XRLObject2 GetResponse()
        {
            return null;
        }

        //-----------------------------------------------------------------------------------
        // Process the incoming request and generate the response
        //-----------------------------------------------------------------------------------
        public override void ProcessRequest()
        {
            // Deserialize the incoming stream
            m_request.ReadStream(new BinaryReader(HttpContext.Current.Request.InputStream));

            // Must have users to add
            if (m_request.cwAffiliates == 0)
            {
                throw new XRLException(
                    HResult.E_INVALIDARG,
                    XEvent.Id.PRESENCE_ADD_AFFILIATES_ZERO_AFFILIATES,
                    "Received message with zero affiliates from user={0}", 
                    (Puid)m_request.qwSenderID
                    );
            }

            // Can't add more than the pre-established maximum per call
            if (m_request.cwAffiliates > PresDefs.MAX_ADD_AFFILIATE)
            {
                throw new XRLException(
                    HResult.E_INVALIDARG,
                    XEvent.Id.PRESENCE_ADD_AFFILIATES_TOO_MANY_AFFILIATES,
                    "Received message with too many affiliates ({0}) from user={1}", 
                    m_request.cwAffiliates, 
                    (Puid)m_request.qwSenderID
                    );
            }

            // Can only add to one list at a time
            if ((m_request.dwListFlag & (m_request.dwListFlag - 1)) != 0)
            {
                throw new XRLException(
                    HResult.E_INVALIDARG,
                    XEvent.Id.PRESENCE_ADD_AFFILIATES_MULTIPLE_LISTS,
                    "Received bogus list flags ({0}) from user={1}", 
                    m_request.dwListFlag, 
                    (Puid)m_request.qwSenderID
                    );
            }

            // Check for valid list type
            uint dwListType = PresDefs.X_AFFILIATE_FLAG_TO_INDEX(m_request.dwListFlag);
            if (dwListType >= PresDefs.NUM_STORED_AFFILIATE_LISTS || dwListType == PresDefs.X_AFFILIATE_AVOIDING_ME_INDEX)
            {
                throw new XRLException(
                    HResult.E_INVALIDARG,
                    XEvent.Id.PRESENCE_ADD_AFFILIATES_INVALID_LIST,
                    "Received bogus list flags ({0}) from user={1}", 
                    m_request.dwListFlag, 
                    (Puid)m_request.qwSenderID
                    );
            }

            // Only encountered or completed game players can be batch added
            if (m_request.cwAffiliates > 1 && dwListType != PresDefs.X_AFFILIATE_COMPLETED_GAME_INDEX && dwListType != PresDefs.X_AFFILIATE_ENCOUNTERED_INDEX)
            {
                throw new XRLException(
                    HResult.E_INVALIDARG,
                    XEvent.Id.PRESENCE_ADD_AFFILIATES_NO_BATCHING,
                    "Received batched request ({0}) for unsupported type ({1}) from user={2}", 
                    dwListType, 
                    m_request.dwListFlag, 
                    (Puid)m_request.qwSenderID
                    );
            }

            // Check that affiliates are not 'self' or 0
            foreach (ulong qwAffiliateID in m_request.pqwAffiliates)
            {
                if (m_request.qwSenderID == qwAffiliateID)
                {
                    throw new XRLException(
                        HResult.E_INVALIDARG,
                        XEvent.Id.PRESENCE_ADD_AFFILIATES_ADDING_SELF,
                        "User={0} attempted to add itself to list type={1}", 
                        (Puid)m_request.qwSenderID, dwListType
                        );
                }
                if (0 == qwAffiliateID)
                {
                    throw new XRLException(
                        HResult.E_INVALIDARG,
                        XEvent.Id.PRESENCE_ADD_AFFILIATES_ADDING_ZERO_XUID,
                        "User={0} attempted to add XUID 0 to list type={1}", 
                        (Puid)m_request.qwSenderID, 
                        dwListType
                        );
                }
            }

            PresenceUtil.AddAffiliates(
                m_request.qwSenderID, 
                dwListType, 
                m_request.pqwAffiliates, 
                m_request.dwTitleID, 
                MsgDefs.DateTimeToMsgTime(DateTime.UtcNow));
        }

        //-----------------------------------------------------------------------------------
        // Handle errors during processing
        //-----------------------------------------------------------------------------------
        public override HResult ProcessError(HResult hr)
        {
            // Put the hresult in the response
            return HResult.S_OK;
        }

        //-----------------------------------------------------------------------------------
        // Log the activity
        //-----------------------------------------------------------------------------------
        public override void LogResults()
        {
            StringBuilder sb = new StringBuilder();
            if (null != m_request.pqwAffiliates)
            {
                foreach (ulong xuid in m_request.pqwAffiliates)
                {
                    sb.AppendFormat("{0:X16};", xuid);
                }
            }
            Xom.Log(XomAreaName.PresenceLog,
                "ADD_AFFILIATES|{0}|{1:X}|{2:X}|{3}|{4}|{5}|{6}",
                (Puid)m_request.header.sgaddr.qwXboxId,
                m_request.header.sgaddr.inaSg,
                m_request.header.sgaddr.dwSpiSg,
                (Puid)m_request.qwSenderID,
                (TitleId)m_request.dwTitleID,
                m_request.cwAffiliates,
                sb.ToString());
        }
    }
    #endregion

    #region PMSG_QUERY_AFFILIATES
    //-----------------------------------------------------------------------------------
    // Process AddAffiliates requests
    //-----------------------------------------------------------------------------------
    public class QueryAffiliatesHandler : PresenceHandlerBase
    {
        //-----------------------------------------------------------------------------------
        // Private data
        //-----------------------------------------------------------------------------------
        private PresenceQueryAffiliatesMsg m_request;
        private PresenceQueryAffiliatesReplyMsg m_response;

        //-----------------------------------------------------------------------------------
        // Constructor
        //-----------------------------------------------------------------------------------
        public QueryAffiliatesHandler(BaseHeader header)
            : base(header)
        {
            m_request = new PresenceQueryAffiliatesMsg();
            m_response = new PresenceQueryAffiliatesReplyMsg();
            m_response.header.dwSeqNum = header.dwSeqNum;
            m_response.header.sgaddr = header.sgaddr;
        }

        //-----------------------------------------------------------------------------------
        // Give the superclass access to the response
        //-----------------------------------------------------------------------------------
        protected override XRLObject2 GetResponse()
        {
            return m_response;
        }

        //-----------------------------------------------------------------------------------
        // Process the incoming request and generate the response
        //-----------------------------------------------------------------------------------
        public override void ProcessRequest()
        {
            // Deserialize the incoming stream
            m_request.ReadStream(new BinaryReader(HttpContext.Current.Request.InputStream));

            // Must specify at least one list. For ALL lists, send -1.
            if (m_request.dwListFlags == 0)
            {
                throw new XRLException(
                    HResult.E_INVALIDARG,
                    XEvent.Id.PRESENCE_QUERY_AFFILIATES_NO_LISTS,
                    "Received zero list flags from user={0}", 
                    (Puid)m_request.qwSenderID
                    );
            }

            // Can't specify a return limit when querying multiple lists.
            if (m_request.cdwLimit != 0 && (m_request.dwListFlags & (m_request.dwListFlags - 1)) != 0)
            {
                throw new XRLException(
                    HResult.E_INVALIDARG,
                    XEvent.Id.PRESENCE_QUERY_AFFILIATES_MULTIPLE_LIST_LIMIT,
                    "Specified return limit ({0}) for multiple lists ({1}) from user={2}", 
                    m_request.cdwLimit, 
                    m_request.dwListFlags, 
                    (Puid)m_request.qwSenderID
                    );
            }

            Hashtable listsLoaded = new Hashtable((int)PresDefs.NUM_STORED_AFFILIATE_LISTS);
            List<QueryAffiliatesReplyData> results = new List<QueryAffiliatesReplyData>();
            SortedList<ulong, PresenceRecord> presInfos = null;
            if (m_request.dwOnlineTitleID != 0)
            {
                presInfos = new SortedList<ulong, PresenceRecord>();
            }

            // Get friends if specified by the user
            if ((m_request.dwListFlags & PresDefs.X_AFFILIATE_INDEX_TO_FLAG(PresDefs.X_AFFILIATE_FRIEND_INDEX)) != 0)
            {
                FriendsList flist = FriendsListUtil.GetFriendsListForXuid(m_request.qwSenderID);
                foreach(UserData u in flist.rgUsers)
                {
                    QueryAffiliatesReplyData r = new QueryAffiliatesReplyData();
                    r.dwListFlags = PresDefs.X_AFFILIATE_INDEX_TO_FLAG(PresDefs.X_AFFILIATE_FRIEND_INDEX);
                    r.dwTitleID = 0;
                    r.qwAffiliateID = u.qwXUID;
                    r.qwSessionID = 0;
                    r.szGamerTag = null;
                    r.mtDateUpdated = 0;
                    results.Add(r);
                    if (presInfos != null)
                    {
                        // Add this XUID to the list passed later to GetBasicPresenceForUsers
                        presInfos[r.qwAffiliateID] = null;
                    }
                }
            }

            // Get users from the neverlist if specified
            if ((m_request.dwListFlags & PresDefs.X_AFFILIATE_INDEX_TO_FLAG(PresDefs.X_AFFILIATE_BLOCK_INDEX)) != 0)
            {
                foreach (ulong qwXUID in PresenceUtil.GetNeverList(m_request.qwSenderID).rgNevers)
                {
                    QueryAffiliatesReplyData r = new QueryAffiliatesReplyData();
                    r.dwListFlags = PresDefs.X_AFFILIATE_INDEX_TO_FLAG(PresDefs.X_AFFILIATE_BLOCK_INDEX);
                    r.dwTitleID = 0;
                    r.qwAffiliateID = qwXUID;
                    r.qwSessionID = 0;
                    r.szGamerTag = null;
                    r.mtDateUpdated = 0;
                    results.Add(r);
                    if (presInfos != null)
                    {
                        // Add this XUID to the list passed later to GetBasicPresenceForUsers
                        presInfos[r.qwAffiliateID] = null;
                    }
                }
            }

            // Finally, query the valid affiliate lists
            for (uint dwFlags = m_request.dwListFlags; dwFlags != 0; dwFlags &= (dwFlags - 1))
            {
                uint dwListType = PresDefs.X_AFFILIATE_FLAG_TO_INDEX(dwFlags - (dwFlags & (dwFlags - 1)));
                if (dwListType != PresDefs.X_AFFILIATE_INDEX_ERROR)
                {
                    AffiliateList current;
                    listsLoaded[(int)dwListType] = current = AffiliateList.Load(m_request.qwSenderID, dwListType);
                    foreach (Affiliate a in current.rgAffiliates)
                    {
                        QueryAffiliatesReplyData r = new QueryAffiliatesReplyData();
                        r.dwListFlags = PresDefs.X_AFFILIATE_INDEX_TO_FLAG(dwListType);
                        r.dwTitleID = a.dwTitleID;
                        r.qwAffiliateID = a.qwAffiliateID;
                        r.qwSessionID = 0;
                        r.szGamerTag = null;
                        r.mtDateUpdated = a.mtDateUpdated;
                        results.Add(r);
                        if (presInfos != null)
                        {
                            // Add this XUID to the list passed later to GetBasicPresenceForUsers
                            presInfos[r.qwAffiliateID] = null;
                        }
                    }
                }
            }

            // If we require presence information for the returned results, fetch it from the cache
            if (presInfos != null)
            {
                string[] rgCacheKeys = new string[presInfos.Keys.Count];
                for (int iKey = 0; iKey < rgCacheKeys.Length; iKey++)
                {
                    rgCacheKeys[iKey] = CacheUtil.BuildCacheKey(DATA_TYPES.eInternalPresence, presInfos.Keys[iKey], 0);
                }

                BaseDataHeader[] rgCacheValues = CacheUtil.ReadFromPresenceCache(rgCacheKeys);

                for (int iValue = 0; iValue < rgCacheValues.Length; iValue++)
                {
                    PresenceRecord presRec = rgCacheValues[iValue] as PresenceRecord;
                    if (presRec != null)
                    {
                        presInfos[presRec.OwnerID] = presRec;
                    }
                }

                for (int i = 0; i < results.Count; )
                {
                    PresenceRecord b = presInfos[results[i].qwAffiliateID];
                    // Check for a nonzero session ID and the TitleID in question
                    bool fUse = (b != null && b.qwSessionID != 0 && b.dwTitleID == m_request.dwOnlineTitleID && b.IsOnline());
                    if (fUse && 
                        (b.dwState & PresDefs.P_STATE_FLAG_CLOAKED) != 0 && 
                        (results[i].dwListFlags & PresDefs.X_AFFILIATE_MASK_POSITIVE) != 0)
                    {
                        // We remove cloaked users with positive affiliation. Negative ones still persist.
                        fUse = false;
                    }
                    if (fUse)
                    {
                        results[i].qwSessionID = b.qwSessionID;
                        results[i].szGamerTag = b.sGamertag;
                        ++i;
                    }
                    else
                    {
                        results.RemoveAt(i);
                    }
                }
            }

            // Final steps: enforce result count limit and query other affiliations if this is a HUD query for recent players
            // If limit is > 0 and request was made with zero title ID, get gamertags from XCache
            if (m_request.cdwLimit > 0)
            {
                // Sort by date, most recent at the top
                results.Sort((left, right) => { return ((int)right.mtDateUpdated - (int)left.mtDateUpdated); });
                if (m_request.cdwLimit < results.Count)
                {
                    results.RemoveRange((int)m_request.cdwLimit, results.Count - (int)m_request.cdwLimit);
                }

                if (m_request.dwOnlineTitleID == 0 && results.Count > 0)
                {
                    // Get xuids for the trimmed list, then get gamertags for those xuids from XCache
                    // Then set the gamertags on each reply data object
                    ulong[] resultXuids = new ulong[results.Count];
                    for (int iResult = 0; iResult < results.Count; iResult++)
                    {
                        resultXuids[iResult] = results[iResult].qwAffiliateID;
                    }
                    
                    string[] rgGamerTags = XCache.LookupGamerTags(resultXuids);
                    for (int iGamerTag = 0; iGamerTag < rgGamerTags.Length; iGamerTag++)
                    {
                        results[iGamerTag].szGamerTag = rgGamerTags[iGamerTag];
                    }
                }
            }

            if ((m_request.dwListFlags & (m_request.dwListFlags - 1)) == 0)
            {
                // This usually means the API is being called by the HUD, requesting the encountered list.
                // We can return all the lists that each user exists in. The other data (titleID, mtDateUpdated) is impled to still apply.
                for (int iList = 0; iList < PresDefs.NUM_STORED_AFFILIATE_LISTS; iList++)
                {
                    AffiliateList list = listsLoaded.Contains(iList) ? listsLoaded[iList] as AffiliateList : AffiliateList.Load(m_request.qwSenderID, (uint)iList);
                    for (int iResult = 0; iResult < results.Count; iResult++)
                    {
                        if (list.IsAffiliate(results[iResult].qwAffiliateID))
                        {
                            results[iResult].dwListFlags |= PresDefs.X_AFFILIATE_INDEX_TO_FLAG((uint)iList);
                        }
                    }
                }
            }

            m_response.rgResults = results.ToArray();
            m_response.cdwResults = (uint)results.Count;

            if (!Config.GetBoolSetting(Setting.presence_QueryAffiliatesOkToPeerSubscribe))
            {
                m_response.hr = HResult.XONLINE_S_NOTIFICATION_NO_PEER_SUBSCRIBE;
            }
        }

        //-----------------------------------------------------------------------------------
        // Handle errors during processing
        //-----------------------------------------------------------------------------------
        public override HResult ProcessError(HResult hr)
        {
            // Put the hresult in the response
            m_response.rgResults = null;
            m_response.cdwResults = 0;
            m_response.hr = hr;
            return HResult.S_OK;
        }

        //-----------------------------------------------------------------------------------
        // Log the activity
        //-----------------------------------------------------------------------------------
        public override void LogResults()
        {
            Xom.Log(XomAreaName.PresenceLog,
                "QUERY_AFFILIATES|{0}|{1:X}|{2:X}|{3}",
                (Puid)m_request.header.sgaddr.qwXboxId,
                m_request.header.sgaddr.inaSg,
                m_request.header.sgaddr.dwSpiSg,
                (Puid)m_request.qwSenderID
                );
        }
    }
    #endregion

    #region PMSG_IS_AFFILIATE
    //-----------------------------------------------------------------------------------
    // Process AddAffiliates requests
    //-----------------------------------------------------------------------------------
    public class IsAffiliateHandler : PresenceHandlerBase
    {
        //-----------------------------------------------------------------------------------
        // Private data
        //-----------------------------------------------------------------------------------
        private PresenceIsAffiliateMsg m_request;
        private PresenceIsAffiliateReplyMsg m_response;

        //-----------------------------------------------------------------------------------
        // Constructor
        //-----------------------------------------------------------------------------------
        public IsAffiliateHandler(BaseHeader header)
            : base(header)
        {
            m_request = new PresenceIsAffiliateMsg();
            m_response = new PresenceIsAffiliateReplyMsg();
            m_response.header.dwSeqNum = header.dwSeqNum;
            m_response.header.sgaddr = header.sgaddr;
        }

        //-----------------------------------------------------------------------------------
        // Give the superclass access to the response
        //-----------------------------------------------------------------------------------
        protected override XRLObject2 GetResponse()
        {
            return m_response;
        }

        //-----------------------------------------------------------------------------------
        // Process the incoming request and generate the response
        //-----------------------------------------------------------------------------------
        public override void ProcessRequest()
        {
            // Deserialize the incoming stream
            m_request.ReadStream(new BinaryReader(HttpContext.Current.Request.InputStream));

            // Must specify a valid affiliate XUID
            if (m_request.qwAffiliateID == 0)
            {
                throw new XRLException(
                    HResult.E_INVALIDARG,
                    XEvent.Id.PRESENCE_IS_AFFILIATE_ZERO_AFFILIATE_ID,
                    "Request for affiliate with ID zero from user={0}", 
                    (Puid)m_request.qwSenderID
                    );
            }

            // Can't be your own affiliate
            if (m_request.qwAffiliateID == m_request.qwSenderID)
            {
                throw new XRLException(
                    HResult.E_INVALIDARG,
                    XEvent.Id.PRESENCE_IS_AFFILIATE_TO_SELF,
                    "Request for affiliate with same ID as requestor from user={0}", 
                    (Puid)m_request.qwSenderID
                    );
            }

            m_response.qwAffiliateID = m_request.qwAffiliateID;
            m_response.dwListFlags = PresenceUtil.IsAffiliate(m_request.qwSenderID, m_request.qwAffiliateID);
            
            // If no flags are set, user is not an affiliate
            if (m_response.dwListFlags == 0)
            {
                m_response.hr = HResult.S_FALSE;
            }
        }

        //-----------------------------------------------------------------------------------
        // Handle errors during processing
        //-----------------------------------------------------------------------------------
        public override HResult ProcessError(HResult hr)
        {
            // Put the hresult in the response
            m_response.hr = hr;
            return HResult.S_OK;
        }

        //-----------------------------------------------------------------------------------
        // Log the activity
        //-----------------------------------------------------------------------------------
        public override void LogResults()
        {
            Xom.Log(XomAreaName.PresenceLog,
                "IS_AFFILIATE|{0}|{1:X}|{2:X}|{3}|{4}",
               (Puid)m_request.header.sgaddr.qwXboxId,
                m_request.header.sgaddr.inaSg,
                m_request.header.sgaddr.dwSpiSg,
                (Puid)m_request.qwSenderID,
                (Puid)m_request.qwAffiliateID
                );
        }
    }
    #endregion
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\fd\Dequeue.cs ===
using System;
using System.IO;
using System.Web;
using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.protocol;
using xonline.common.service;
using xonline.common.community;
using xonline.common.sql.webstore;
using Microsoft.Webstore.WstClient;

namespace xonline.server.presence.fd
{

    internal class DequeueHandler : PresenceHandlerBase
    {
        private NotificationDequeueMsg _request;
        private NotificationDequeueReply _response;

        public DequeueHandler(BaseHeader header)
            : base(header)
        {
            _request = new NotificationDequeueMsg();
            _response = new NotificationDequeueReply();
        }

        public override void ProcessRequest()
        {
            //Parse out the request
            _request.ReadStream(new BinaryReader(HttpContext.Current.Request.InputStream));

            // User id of 0 check is not necessary since PresenceHandlerBase calls it
            // If that code ever changes we need to check 0 user id scenario here too.

            _response.qwUserID = _request.qwUserID;
            _response.wQType = _request.wQType;

            switch (_request.wQType)
            {
            // supported queue types
            case (ushort)P_QUEUE_TYPES.PQUEUE_BUDDY_REQ:
            case (ushort)P_QUEUE_TYPES.PQUEUE_LIST_CHANGE:
            case (ushort)P_QUEUE_TYPES.PQUEUE_INVITE:
            case (ushort)P_QUEUE_TYPES.PQUEUE_INVITE_ANSWER:
                break;

            case (ushort)P_QUEUE_TYPES.PQUEUE_PRESENCE:
            case (ushort)P_QUEUE_TYPES.PQUEUE_TRANSIENT_MSGS:
            case (ushort)P_QUEUE_TYPES.PQUEUE_PEER_PRESENCE:
            case (ushort)P_QUEUE_TYPES.PQUEUE_PRESENCE_2:
                throw new XRLException(HResult.E_INVALIDARG, XEvent.Id.PRESENCE_UNSUPPORTED_QUEUE_TYPE, 
                    "DequeueHandler: Unsupported queue type {0}", _request.wQType);

            default:
                throw new XRLException(HResult.E_INVALIDARG, XEvent.Id.PRESENCE_INVALID_QUEUE_TYPE,
                    "DequeueHandler: Invalid queue type {0}", _request.wQType);
            }

            PresenceRecord record = PresenceUtil.GetPresenceRecord(_request.qwUserID);
            if ((null == record) || !record.IsOnline())
            {
                throw new XRLException(Win32ErrorCode.GetHResult(Win32ErrorCode.Codes.ERROR_NO_SUCH_USER), 
                    XEvent.Id.PRESENCE_CACHE_NOTFOUND,
                    "DequeueHandler: user not online.");
            }

            UserQueue userQueue = new UserQueue(_request.qwUserID, _request.wQType);

            uint cMaxBytes = _request.dwMaxTotalItemDataSize;
            _response.rgListItems = userQueue.DequeueItems(
                _request.dwStartItemID,
                _request.wMaxItems,
                ref cMaxBytes,
                out _response.dwNextItemID,
                out _response.wQLeft);

            if (_response.wQLeft == 0)
            {
                // no items left on the queue.
                record.ClearQFlag(_request.wQType);
            }
            
            _response.dwTotalItemDataSize = cMaxBytes;
            _response.cQVals = (ushort)record.rgQVals.Length;
            _response.rgdwQVals = record.rgQVals;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="hr">Error return code</param>
        public override HResult ProcessError(HResult hr)
        {
            _response.hr = hr;
            return HResult.S_OK;
        }

        /// <summary>
        /// 
        /// </summary>
        public override void LogResults()
        {
            Xom.Log(XomAreaName.PresenceLog, "Dequeue|{0}:{1:X}|{2}|{3}|{4}|{5}",
                    SGInfo.Current.ClientIP,
                    SGInfo.Current.ClientPort,
                    (Puid)_request.qwUserID,
                    _request.wQType,
                    _response.hr,
                    (_response.rgListItems == null) ? 0 : _response.rgListItems.Length);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <returns>Base class that derives from XRLObject2</returns>
        protected override XRLObject2 GetResponse()
        {
            _response.header.dwSeqNum = m_header.dwSeqNum;
            _response.header.sgaddr = m_header.sgaddr;
            return _response;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\fd\FriendHandlers.cs ===
using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using System.Web;
using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.protocol;
using xonline.common.service;
using xonline.common.community;

namespace xonline.server.presence.fd
{
    internal class FriendHandlerHelpers
    {
        /// <summary>
        /// Gets the friends list with presence data formated for return in either a 
        /// GetFriendsListResponse or a GetWebFriendsList response
        /// Currently the GetFriendsListData and WebFriendsData structs are identical.
        ///  If that changes this helper will no longer work.
        /// </summary>
        /// <param name="viewerList"></param>
        /// <param name="targetList"></param>
        /// <returns></returns>
        public static GetFriendsListData[] GetFriendsWithPresenceForResponse(FriendsList viewerList, FriendsList targetList)
        {
            ulong[] xuids = new ulong[targetList.rgUsers.Length];
            GetFriendsListData[] returnArray = new GetFriendsListData[targetList.rgUsers.Length];

            for (int iFriend = 0; iFriend < xuids.Length; iFriend++)
            {
                xuids[iFriend] = targetList.rgUsers[iFriend].qwXUID;
            }

            BasicPresence[] presenceBlobs = PresenceUtil.GetBasicPresenceForUsers(viewerList, xuids);
            string[] rpStrings = PresenceUtil.GetRichPresenceStringForUsers(viewerList, SGInfo.Current, xuids);

            GetFriendsListData data = null;

            for (int i = 0; i < targetList.rgUsers.Length; i++)
            {
                if (targetList.rgUsers[i].qwXUID != presenceBlobs[i].OwnerID)
                {
                    throw new XRLException(HResult.E_INVALID_DATA, XEvent.Id.PRESENCE_DATA_MISMATCH, "presencefd: FriendsList and BasicPresence data mismatch!");
                }

                data = new GetFriendsListData();
                data.FriendStatus = CacheUtil.GetFriendStatus(targetList.rgUsers[i].dwUserFlags);
                data.Puid = targetList.rgUsers[i].qwXUID;
                data.szGamerTag = presenceBlobs[i].sGamertag;
                data.TitleId = presenceBlobs[i].dwTitleID;
                data.mtLastActive = presenceBlobs[i].mtLastSeen;
                data.RPData = Encoding.UTF8.GetBytes(rpStrings[i]);
                data.RPDataLen = (uint)data.RPData.Length;
                data.OnlineState = presenceBlobs[i].dwState;
                returnArray[i] = data;
            }

            return returnArray;
        }

        public static GetFriendsLimitedPresenceData[] GetFriendsWithLimitedPresenceForResponse(FriendsList viewerList, FriendsList targetList)
        {
            ulong[] xuids = new ulong[targetList.rgUsers.Length];
            for (int iFriend = 0; iFriend < xuids.Length; iFriend++)
            {
                xuids[iFriend] = targetList.rgUsers[iFriend].qwXUID;
            }

            LimitedPresence[] presenceBlobs = PresenceUtil.GetLimitedPresenceForUsers(xuids);

            GetFriendsLimitedPresenceData[] nonPendingFriendsData = new GetFriendsLimitedPresenceData[targetList.rgUsers.Length];
            for (int i = 0; i < targetList.rgUsers.Length; i++)
            {
                if (targetList.rgUsers[i].qwXUID != presenceBlobs[i].OwnerID)
                {
                    throw new XRLException(HResult.E_INVALID_DATA, XEvent.Id.PRESENCE_DATA_MISMATCH, "presencefd: FriendsList and LimitedPresence data mismatch!");
                }

                GetFriendsLimitedPresenceData data = new GetFriendsLimitedPresenceData();
                data.FriendStatus = CacheUtil.GetFriendStatus(targetList.rgUsers[i].dwUserFlags);
                data.Puid = targetList.rgUsers[i].qwXUID;
                data.OnlineState = presenceBlobs[i].dwState;
                data.TitleId = presenceBlobs[i].dwTitleID;
                data.szGamerTag = presenceBlobs[i].sGamertag;
                data.mtLastSeen = presenceBlobs[i].mtLastSeen;

                // if the data is blocked to this viewer, mark the owner as cloaked.
                if (!CacheUtil.IsDataAccessible(data.Puid, viewerList.OwnerID, presenceBlobs[i].HeaderFlags, viewerList.AreAcceptedBuddies))
                {
                    data.OnlineState |= PresDefs.P_STATE_FLAG_CLOAKED;
                }

                nonPendingFriendsData[i] = data;
            }

            return nonPendingFriendsData;
        }

        public static byte[] FixupBuddyRequest( BinaryReader reader )
        {
            PresenceAddBuddy2Msg newmsg = new PresenceAddBuddy2Msg();
            newmsg.ReadStream( reader );

            FixupBuddyRequest(ref newmsg);
            
            return (byte[]) newmsg;
        }

        public static void FixupBuddyRequest( ref PresenceAddBuddy2Msg msg )
        {
            // use xcache to fill in any missing details about the buddy.  this saves a scan of all databases.
            if (msg.qwBuddyID == 0)
            {
                XCacheUserResponseData xcurd = XCache.LookupUserByGamertag(msg.szBuddyAcctName);

                if (xcurd.qwUserID != 0)
                {
                    msg.qwBuddyID = xcurd.qwUserID;
                }

                if (xcurd.szGamertag != XCache.InvalidGamertag)
                {
                    msg.szBuddyAcctName = xcurd.szGamertag;
                }
            }
            else
            {
                // always overwrite the gamertag if there's a userid provided.
                string szGamertag = XCache.LookupGamerTag(msg.qwBuddyID);
                
                if (szGamertag != XCache.InvalidGamertag)
                {
                    msg.szBuddyAcctName = szGamertag;
                }
            }            
        }
    }

    internal class GetFriendsListHandler : PresenceHandlerBase
    {
        private GetFriendsListRequest m_requestMessage;
        private GetFriendsListResponse m_response;

        public GetFriendsListHandler(BaseHeader header) 
            : base (header)
        {
            m_requestMessage = new GetFriendsListRequest();
            m_response = new GetFriendsListResponse();
        }

        public override void ProcessRequest()
        {
            m_response.version = 0xFFFFFFFF;
            m_requestMessage.ReadStream(new BinaryReader(HttpContext.Current.Request.InputStream));

            if (0 == m_requestMessage.qwSender)
            {
                throw new XRLException(HResult.E_INVALIDARG, XEvent.Id.PRESENCE_INVALID_USERID, "GetFriendsList: qwSender is zero");
            }

            if (0 == m_requestMessage.qwTarget)
            {
                throw new XRLException(HResult.E_INVALIDARG, XEvent.Id.PRESENCE_INVALID_USERID, "GetFriendsList: qwTarget is zero");
            }
            
            if (XCache.LookupGamerTag(m_requestMessage.qwTarget) == XCache.InvalidGamertag)
            {
                throw new XRLException(Win32ErrorCode.GetHResult(Win32ErrorCode.Codes.ERROR_NO_SUCH_USER), XEvent.Id.PRESENCE_INVALID_USERID, "GetFriendsList: qwTarget:{0} is unknown", m_requestMessage.qwTarget);
            }

            FriendsList targetFriendList = FriendsListUtil.GetFriendsListForXuid(m_requestMessage.qwTarget);

            if (!targetFriendList.CanShareList(m_requestMessage.qwSender))
            {
                throw new XRLException(HResult.XONLINE_E_MESSAGE_INSUFFICIENT_PRIVILEGES, XEvent.Id.PRESENCE_DO_NOT_LOG_EVENT, "GetFriendsList: no access to this list");
            }
            
            FriendsList senderFriendList = FriendsListUtil.GetFriendsListForXuid(m_requestMessage.qwSender);

            GetFriendsListData[] returnData = FriendHandlerHelpers.GetFriendsWithPresenceForResponse(senderFriendList, targetFriendList);
            m_response.puid = m_requestMessage.qwSender;
            m_response.version = targetFriendList.dwListVersion;
            m_response.cdwFriends = (uint)returnData.Length;
            m_response.rgFriends = returnData;
        }

        public override HResult ProcessError(HResult hr)
        {
            m_response.hr = hr;
            return HResult.S_OK;
        }

        public override void LogResults()
        {
            Xom.Log(XomAreaName.PresenceLog, "GetFriendsList|{0}:{1:X}|{2}|{3}|{4:X}|{5}",
                    SGInfo.Current.ClientIP,
                    SGInfo.Current.ClientPort,
                    (Puid)m_requestMessage.qwSender,
                    (Puid)m_requestMessage.qwTarget,
                    m_requestMessage.header.dwMsgType,
                    m_response.hr);
        }

        protected override XRLObject2 GetResponse()
        {
            if (m_response != null)
            {
                m_response.header.dwSeqNum = m_header.dwSeqNum;
                m_response.header.sgaddr = m_header.sgaddr;
            }
            return m_response;
        }
    }

    internal class GetWebFriendsListHandler : PresenceHandlerBase
    {
        private WebFriendsRequest m_requestMessage;
        private WebFriendsResponse m_response;

        public GetWebFriendsListHandler(BaseHeader header)
            : base(header)
        {
            m_requestMessage = new WebFriendsRequest();
            m_response = new WebFriendsResponse();
        }

        private static WebFriendsData Convert(GetFriendsListData friend)
        {
            WebFriendsData webFriend = new WebFriendsData();
            webFriend.FriendStatus = friend.FriendStatus;
            webFriend.mtLastActive = friend.mtLastActive;
            webFriend.OnlineState = friend.OnlineState;
            webFriend.Puid = friend.Puid;
            webFriend.RPData = friend.RPData;
            webFriend.RPDataLen = friend.RPDataLen;
            webFriend.StateData = friend.StateData;
            webFriend.StateDataLen = friend.StateDataLen;
            webFriend.szGamerTag = friend.szGamerTag;
            webFriend.TitleId = friend.TitleId;

            return webFriend;
        }

        public override void ProcessRequest()
        {
            m_response.version = 0xFFFFFFFF;
            m_requestMessage.ReadStream(new BinaryReader(HttpContext.Current.Request.InputStream));

            if (0 == m_requestMessage.puid)
            {
                throw new XRLException(HResult.E_INVALIDARG, XEvent.Id.PRESENCE_INVALID_USERID, "GetWebFriends: puid is zero");
            }
            
            if (XCache.LookupGamerTag(m_requestMessage.puid) == XCache.InvalidGamertag)
            {
                throw new XRLException(Win32ErrorCode.GetHResult(Win32ErrorCode.Codes.ERROR_NO_SUCH_USER), XEvent.Id.PRESENCE_INVALID_USERID, "GetWebFriends: puid:{0} is unknown", m_requestMessage.puid);
            }

            // WebFriends only gets the sender's list, so there is no target. and no need to check privledges
            FriendsList friendList = FriendsListUtil.GetFriendsListForXuid(m_requestMessage.puid);

            WebFriendsData[] returnData = Array.ConvertAll<GetFriendsListData, WebFriendsData>(FriendHandlerHelpers.GetFriendsWithPresenceForResponse(friendList, friendList), Convert);
            m_response.puid = m_requestMessage.puid;
            m_response.version = friendList.dwListVersion;
            m_response.cdwFriends = (uint)returnData.Length;
            m_response.rgFriends = returnData;
        }

        public override HResult ProcessError(HResult hr)
        {
            m_response.hr = hr;
            return HResult.S_OK;
        }

        public override void LogResults()
        {
            Xom.Log(XomAreaName.PresenceLog, "GetWebFriendsList|{0}:{1:X}|{2}|{3:X}|{4}",
                    SGInfo.Current.ClientIP,
                    SGInfo.Current.ClientPort,
                    (Puid)m_requestMessage.puid,
                    m_requestMessage.header.dwMsgType,
                    m_response.hr);
        }

        protected override XRLObject2 GetResponse()
        {
            if (m_response != null)
            {
                m_response.header.dwSeqNum = m_header.dwSeqNum;
                m_response.header.sgaddr = m_header.sgaddr;
            }
            return m_response;
        }
    }

    internal class GetFriendsLimitedPresenceHandler : PresenceHandlerBase
    {
        private GetFriendsLimitedPresenceRequest m_requestMessage;
        private GetFriendsLimitedPresenceResponse m_response;

        public GetFriendsLimitedPresenceHandler(BaseHeader header)
            : base(header)
        {
            m_requestMessage = new GetFriendsLimitedPresenceRequest();
            m_response = new GetFriendsLimitedPresenceResponse();
        }

        public override void ProcessRequest()
        {
            m_requestMessage.ReadStream(new BinaryReader(HttpContext.Current.Request.InputStream));

            if (0 == m_requestMessage.puid)
            {
                throw new XRLException(HResult.E_INVALIDARG, XEvent.Id.PRESENCE_INVALID_USERID, "GetFriendsLimitedPresence: puid is zero");
            }

            if (XCache.LookupGamerTag(m_requestMessage.puid) == XCache.InvalidGamertag)
            {
                throw new XRLException(Win32ErrorCode.GetHResult(Win32ErrorCode.Codes.ERROR_NO_SUCH_USER), XEvent.Id.PRESENCE_INVALID_USERID, "GetFriendsLimitedPresence: puid:{0} is unknown", m_requestMessage.puid);
            }

            // WebFriends only gets the sender's list, so there is no target. and no need to check privledges
            FriendsList friendList = FriendsListUtil.GetFriendsListForXuid(m_requestMessage.puid);

            GetFriendsLimitedPresenceData[] returnData = FriendHandlerHelpers.GetFriendsWithLimitedPresenceForResponse(friendList, friendList);
            m_response.puid = m_requestMessage.puid;
            m_response.cdwFriends = (uint)returnData.Length;
            m_response.rgFriends = returnData;
        }

        public override HResult ProcessError(HResult hr)
        {
            m_response.hr = hr;
            return HResult.S_OK;
        }

        public override void LogResults()
        {
            Xom.Log(XomAreaName.PresenceLog, "GetFriendsLimitedPresence|{0}:{1:X}|{2}|{3:X}|{4}",
                    SGInfo.Current.ClientIP,
                    SGInfo.Current.ClientPort,
                    (Puid)m_requestMessage.puid,
                    m_requestMessage.header.dwMsgType,
                    m_response.hr);
        }

        protected override XRLObject2 GetResponse()
        {
            if (m_response != null)
            {
                m_response.header.dwSeqNum = m_header.dwSeqNum;
                m_response.header.sgaddr = m_header.sgaddr;
            }
            return m_response;
        }
    }

    internal class GetFriendsNoPresenceHandler : PresenceHandlerBase
    {
        private GetFriendsNoPresenceRequest m_requestMessage;
        private GetFriendsNoPresenceResponse m_response;

        public GetFriendsNoPresenceHandler(BaseHeader header)
            : base(header)
        {
            m_requestMessage = new GetFriendsNoPresenceRequest();
            m_response = new GetFriendsNoPresenceResponse();
        }

        public override void ProcessRequest()
        {
            m_requestMessage.ReadStream(new BinaryReader(HttpContext.Current.Request.InputStream));

            if (0 == m_requestMessage.puid)
            {
                throw new XRLException(HResult.E_INVALIDARG, XEvent.Id.PRESENCE_INVALID_USERID, "GetFriendsNoPresence: puid is zero");
            }

            if (XCache.LookupGamerTag(m_requestMessage.puid) == XCache.InvalidGamertag)
            {
                throw new XRLException(Win32ErrorCode.GetHResult(Win32ErrorCode.Codes.ERROR_NO_SUCH_USER), XEvent.Id.PRESENCE_INVALID_USERID, "GetFriendsNoPresence: puid:{0} is unknown", m_requestMessage.puid);
            }

            FriendsList friendList = FriendsListUtil.GetFriendsListForXuid(m_requestMessage.puid);
            
            GetFriendsNoPresenceData[] returnData = new GetFriendsNoPresenceData[friendList.rgUsers.Length];
            for (int i = 0; i < friendList.rgUsers.Length; i++)
            {
                GetFriendsNoPresenceData data = new GetFriendsNoPresenceData();
                data.Puid = friendList.rgUsers[i].qwXUID;
                data.FriendStatus = CacheUtil.GetFriendStatus(friendList.rgUsers[i].dwUserFlags);
                returnData[i] = data;
            }

            m_response.puid = m_requestMessage.puid;
            m_response.cdwFriends = (uint)returnData.Length;
            m_response.rgFriends = returnData;
        }

        public override HResult ProcessError(HResult hr)
        {
            m_response.hr = hr;
            return HResult.S_OK;
        }

        public override void LogResults()
        {
            Xom.Log(XomAreaName.PresenceLog, "GetFriendsNoPresence|{0}:{1:X}|{2}|{3:X}|{4}",
                    SGInfo.Current.ClientIP,
                    SGInfo.Current.ClientPort,
                    (Puid)m_requestMessage.puid,
                    m_requestMessage.header.dwMsgType,
                    m_response.hr);
        }

        protected override XRLObject2 GetResponse()
        {
            if (m_response != null)
            {
                m_response.header.dwSeqNum = m_header.dwSeqNum;
                m_response.header.sgaddr = m_header.sgaddr;
            }
            return m_response;
        }
    }

    internal class FriendAddHandler : PresenceHandlerBase
    {
        private PresenceAddBuddy2Msg m_requestMessage;
        private HResult m_hr;

        public FriendAddHandler(BaseHeader header)
            : base(header)
        {
            m_requestMessage = new PresenceAddBuddy2Msg();
        }

        public override void ProcessRequest()
        {
            
            if (m_header.dwMsgType == (uint)P_MSG_TYPES.PMSG_ADD)
            {
                PresenceAddBuddyMsg v1Msg = new PresenceAddBuddyMsg();
                v1Msg.ReadStream(new BinaryReader(HttpContext.Current.Request.InputStream));

                // Set the BASE_MSG_HEADER fields
                m_requestMessage.header.dwSeqNum = v1Msg.header.dwSeqNum;
                m_requestMessage.header.sgaddr = v1Msg.header.sgaddr;

                // Fill in common properties
                m_requestMessage.qwSenderID = v1Msg.qwSenderID;
                m_requestMessage.qwBuddyID = v1Msg.qwBuddyID;
                m_requestMessage.szBuddyAcctName = v1Msg.szBuddyAcctName;

                // Fill in properties that only exist on the new type
                m_requestMessage.dwMessageFlags = 0;
                m_requestMessage.cbDetails = 0;
                m_requestMessage.details = new MessageDetails();
            }
            else
            {
                m_requestMessage.ReadStream(new BinaryReader(HttpContext.Current.Request.InputStream));
            }

            // validate the message
            if (0 == m_requestMessage.qwSenderID)
            {
                throw new XRLException(HResult.E_INVALIDARG, XEvent.Id.PRESENCE_INVALID_USERID, "AddFriend: qwSenderID is zero");
            }

            FriendHandlerHelpers.FixupBuddyRequest(ref m_requestMessage);

            if (m_requestMessage.qwBuddyID == 0)
            {
                throw new XRLException(Win32ErrorCode.GetHResult(Win32ErrorCode.Codes.ERROR_NO_SUCH_USER), XEvent.Id.PRESENCE_FRIEND_NOT_SPECIFIED, "AddFriend: qwBuddyID is zero or szBuddyAcctName is empty");
            }

            // can't be your own buddy. Well you can. Just not on our service.
            if (m_requestMessage.qwSenderID == m_requestMessage.qwBuddyID)
            {
                throw new XRLException(HResult.E_INVALIDARG, XEvent.Id.PRESENCE_FRIEND_IS_SENDER, "AddFriend: qwSenderID is equal to qwBuddyID");
            }

            if (string.IsNullOrEmpty(m_requestMessage.szBuddyAcctName) ||
                m_requestMessage.szBuddyAcctName.Length >= PresDefs.XONLINE_GAMERTAG_SIZE)
            {
                throw new XRLException(HResult.E_INVALIDARG, 
                    XEvent.Id.PRESENCE_INVALID_GAMERTAG, 
                    "AddFriend: Got bad gamertag: {0} for buddy account: {1}",
                    m_requestMessage.szBuddyAcctName,
                    (Puid)m_requestMessage.qwBuddyID);
            }

            string senderGamerTag = XCache.LookupGamerTag(m_requestMessage.qwSenderID);

            if (string.IsNullOrEmpty(senderGamerTag) ||
                senderGamerTag.Length >= PresDefs.XONLINE_GAMERTAG_SIZE)
            {
                throw new XRLException(HResult.E_INVALIDARG,
                    XEvent.Id.PRESENCE_INVALID_GAMERTAG,
                    "AddFriend: Got bad gamertag: {0} for buddy account: {1}",
                    m_requestMessage.szBuddyAcctName,
                    (Puid)m_requestMessage.qwBuddyID);
            }

            m_hr = FriendsListUtil.Add(m_requestMessage.qwSenderID,
                m_requestMessage.qwBuddyID,
                senderGamerTag,
                m_requestMessage.szBuddyAcctName);

            if (HResult.Succeeded(m_hr))
            {
                // send the friend request message.  best effort -- we dont check the return code.
                MsgReq friendMsg = new MsgReq();
                RecipientResult[] results = null;
                HResult hr = friendMsg.SendMessage(
                    m_requestMessage.qwSenderID, 
                    senderGamerTag, 
                    XOn.XENON_DASH_TITLE_ID, 
                    0, 
                    m_requestMessage.dwMessageFlags,
                    MessagingUtil.GetMessageExpiration(MsgDefs.XONLINE_MSG_TYPE_FRIEND_REQUEST),
                    MsgDefs.XONLINE_MSG_TYPE_FRIEND_REQUEST,
                    new ulong[]{m_requestMessage.qwBuddyID}, 
                    m_requestMessage.details, 
                    out results);
            }
        }

        public override HResult ProcessError(HResult hr)
        {
            // try to send the caller his qval
            if ((m_requestMessage != null) && (m_requestMessage.qwSenderID != 0))
            {
                PresenceRecord userRecord = PresenceUtil.GetPresenceRecord(m_requestMessage.qwSenderID);
                if ((userRecord != null) && (userRecord.IsOnline()))
                {
                    userRecord.QueueListChangeQVals(
                        0,
                        m_requestMessage.qwBuddyID,
                        PresenceRecord.PLIST_CHANGE.PLIST_BUDDY_ADD,
                        hr,
                        "");
                }
            }

            m_hr = hr;
            return HResult.S_OK;
        }

        public override void LogResults()
        {
            Xom.Log(XomAreaName.PresenceLog, "ADD|{0}:{1:X}|{2}|{3}|{4:X}|{5}",
                    SGInfo.Current.ClientIP,
                    SGInfo.Current.ClientPort,
                    (Puid)m_requestMessage.qwSenderID,
                    (Puid)m_requestMessage.qwBuddyID,
                    m_requestMessage.header.dwMsgType,
                    m_hr);
        }

        protected override XRLObject2 GetResponse()
        {
            return null;
        }
    }

    internal class FriendAcceptHandler : PresenceHandlerBase
    {
        private PresenceAcceptBuddyMsg m_requestMessage;
        private HResult m_hr;

        public FriendAcceptHandler(BaseHeader header)
            : base(header)
        {
            m_requestMessage = new PresenceAcceptBuddyMsg();
        }

        public override void ProcessRequest()
        {
            m_requestMessage.ReadStream(new BinaryReader(HttpContext.Current.Request.InputStream));

            if (0 == m_requestMessage.qwUserID || 0 == m_requestMessage.qwBuddyID)
            {
                throw new XRLException(HResult.E_INVALIDARG, XEvent.Id.PRESENCE_INVALID_USERID, "AcceptFriend: qwBuddyID or qwUserID is zero");
            }

            if (m_requestMessage.qwUserID == m_requestMessage.qwBuddyID)
            {
                throw new XRLException(HResult.E_INVALIDARG, XEvent.Id.PRESENCE_FRIEND_IS_SENDER, "AcceptFriend: qwSenderID is equal to qwBuddyID");
            }

            m_hr = FriendsListUtil.Accept(m_requestMessage.qwUserID, m_requestMessage.qwBuddyID);

            if (HResult.Succeeded(m_hr))
            {
                // send the friend revoke message.  best effort -- we dont check the return code.
                MsgReq revokeMsg = new MsgReq();
                RecipientResult[] results = new RecipientResult[] { new RecipientResult() };
                //Little confusing, this is the user rejecting the friend request, we will fire a revoke for the message whose sender is the buddy
                results[0].qwUserID = m_requestMessage.qwUserID;
                HResult hr = revokeMsg.RevokeMessageEx(m_requestMessage.qwBuddyID,
                    0,
                    MsgDefs.XONLINE_MSG_TYPE_FRIEND_REQUEST,
                    MsgDefs.XMSG_REVOKE_MESSAGE_EX_FLAG_USE_TYPE |
                        MsgDefs.XMSG_REVOKE_MESSAGE_EX_FLAG_USE_SENDER,
                    results,
                    0,
                    null);
            }
        }

        public override HResult ProcessError(HResult hr)
        {
            // try to send the caller his qval
            if ((m_requestMessage != null) && (m_requestMessage.qwUserID != 0))
            {
                PresenceRecord userRecord = PresenceUtil.GetPresenceRecord(m_requestMessage.qwUserID);
                if ((userRecord != null) && (userRecord.IsOnline()))
                {
                    userRecord.QueueListChangeQVals(
                        0,
                        m_requestMessage.qwBuddyID,
                        PresenceRecord.PLIST_CHANGE.PLIST_BUDDY_ACCEPT,
                        hr,
                        "");
                }
            }

            m_hr = hr;
            return HResult.S_OK;
        }

        public override void LogResults()
        {
            Xom.Log(XomAreaName.PresenceLog, "AcceptFriend|{0}:{1:X}|{2}|{3}|{4:X}|{5}",
                    SGInfo.Current.ClientIP,
                    SGInfo.Current.ClientPort,
                    (Puid)m_requestMessage.qwUserID,
                    (Puid)m_requestMessage.qwBuddyID,
                    m_requestMessage.header.dwMsgType,
                    m_hr);
        }

        protected override XRLObject2 GetResponse()
        {
            return null;
        }
    }

    internal class FriendRejectHandler : PresenceHandlerBase
    {
        private PresenceRejectBuddyMsg m_requestMessage;
        private HResult m_hr;

        public FriendRejectHandler(BaseHeader header)
            : base(header)
        {
            m_requestMessage = new PresenceRejectBuddyMsg();
        }

        public override void ProcessRequest()
        {
            m_requestMessage.ReadStream(new BinaryReader(HttpContext.Current.Request.InputStream));

            if (0 == m_requestMessage.qwUserID || 0 == m_requestMessage.qwBuddyID)
            {
                throw new XRLException(HResult.E_INVALIDARG, XEvent.Id.PRESENCE_INVALID_USERID, "RejectFriend: qwBuddyID or qwUserID is zero");
            }

            if (m_requestMessage.qwUserID == m_requestMessage.qwBuddyID)
            {
                throw new XRLException(HResult.E_INVALIDARG, XEvent.Id.PRESENCE_FRIEND_IS_SENDER, "RejectFriend: qwSenderID is equal to qwBuddyID");
            }

            m_hr = FriendsListUtil.Reject(m_requestMessage.qwUserID, m_requestMessage.qwBuddyID, m_requestMessage.fNever);

            if (HResult.Succeeded(m_hr))
            {
                // send the friend revoke message.  best effort -- we dont check the return code.
                MsgReq revokeMsg = new MsgReq();
                RecipientResult[] results = new RecipientResult[]{new RecipientResult()};
                //Little confusing, this is the user rejecting the friend request, we will fire a revoke for the message whose sender is the buddy
                results[0].qwUserID = m_requestMessage.qwUserID;
                HResult hr = revokeMsg.RevokeMessageEx(m_requestMessage.qwBuddyID,
                    0,
                    MsgDefs.XONLINE_MSG_TYPE_FRIEND_REQUEST,
                    MsgDefs.XMSG_REVOKE_MESSAGE_EX_FLAG_USE_TYPE |
                        MsgDefs.XMSG_REVOKE_MESSAGE_EX_FLAG_USE_SENDER,
                    results,
                    0,
                    null);
            }
        }

        public override HResult ProcessError(HResult hr)
        {
            // try to send the caller his qval
            if ((m_requestMessage != null) && (m_requestMessage.qwUserID != 0))
            {
                PresenceRecord userRecord = PresenceUtil.GetPresenceRecord(m_requestMessage.qwUserID);
                if ((userRecord != null) && (userRecord.IsOnline()))
                {
                    userRecord.QueueListChangeQVals(
                        0,
                        m_requestMessage.qwBuddyID,
                        PresenceRecord.PLIST_CHANGE.PLIST_BUDDY_REJECT,
                        hr,
                        "");
                }
            }

            m_hr = hr;
            return HResult.S_OK;
        }

        public override void LogResults()
        {
            Xom.Log(XomAreaName.PresenceLog, "AddFriend|{0}:{1:X}|{2}|{3}|{4:X}|{5}",
                    SGInfo.Current.ClientIP,
                    SGInfo.Current.ClientPort,
                    (Puid)m_requestMessage.qwUserID,
                    (Puid)m_requestMessage.qwBuddyID,
                    m_requestMessage.header.dwMsgType,
                    m_hr);
        }

        protected override XRLObject2 GetResponse()
        {
            return null;
        }
    }

    internal class FriendDeleteHandler : PresenceHandlerBase
    {
        private PresenceDeleteBuddyMsg m_requestMessage;
        private HResult m_hr;

        public FriendDeleteHandler(BaseHeader header)
            : base(header)
        {
            m_requestMessage = new PresenceDeleteBuddyMsg();
        }

        public override void ProcessRequest()
        {
            m_requestMessage.ReadStream(new BinaryReader(HttpContext.Current.Request.InputStream));

            if (0 == m_requestMessage.qwUserID || 0 == m_requestMessage.qwBuddyID)
            {
                throw new XRLException(HResult.E_INVALIDARG, XEvent.Id.PRESENCE_INVALID_USERID, "RejectFriend: qwBuddyID or qwUserID is zero");
                
            }

            if (m_requestMessage.qwUserID == m_requestMessage.qwBuddyID)
            {
                throw new XRLException(HResult.E_INVALIDARG, XEvent.Id.PRESENCE_FRIEND_IS_SENDER, "DeleteFriend: qwSenderID is equal to qwBuddyID");
            }

            m_hr = FriendsListUtil.Delete(m_requestMessage.qwUserID, m_requestMessage.qwBuddyID);

            if (HResult.Succeeded(m_hr))
            {
                MsgReq revokeMsg = new MsgReq();
                RecipientResult[] results = new RecipientResult[] { new RecipientResult() };
                //We need to revoke any friend request from the buddy and any buddy request we sent to the buddy.
                //this is a revoke for a message sent to the friend, we will fire a revoke for the message whose sender is the user who deleted
                results[0].qwUserID = m_requestMessage.qwBuddyID;
                HResult hr = revokeMsg.RevokeMessageEx(m_requestMessage.qwUserID,
                    0,
                    MsgDefs.XONLINE_MSG_TYPE_FRIEND_REQUEST,
                    MsgDefs.XMSG_REVOKE_MESSAGE_EX_FLAG_USE_TYPE |
                        MsgDefs.XMSG_REVOKE_MESSAGE_EX_FLAG_USE_SENDER,
                    results,
                    0,
                    null);
                //Next this is the user deleting the friend, we will fire a revoke for the message whose sender is the buddy
                results[0] = new RecipientResult();
                results[0].qwUserID = m_requestMessage.qwUserID;
                hr = revokeMsg.RevokeMessageEx(m_requestMessage.qwBuddyID,
                    0,
                    MsgDefs.XONLINE_MSG_TYPE_FRIEND_REQUEST,
                    MsgDefs.XMSG_REVOKE_MESSAGE_EX_FLAG_USE_TYPE |
                        MsgDefs.XMSG_REVOKE_MESSAGE_EX_FLAG_USE_SENDER,
                    results,
                    0,
                    null);
            }
        }

        public override HResult ProcessError(HResult hr)
        {
            // try to send the caller his qval
            if ((m_requestMessage != null) && (m_requestMessage.qwUserID != 0))
            {
                PresenceRecord userRecord = PresenceUtil.GetPresenceRecord(m_requestMessage.qwUserID);
                if ((userRecord != null) && (userRecord.IsOnline()))
                {
                    userRecord.QueueListChangeQVals(
                        0,
                        m_requestMessage.qwBuddyID,
                        PresenceRecord.PLIST_CHANGE.PLIST_BUDDY_DELETE,
                        hr,
                        "");
                }
            }

            m_hr = hr;
            return HResult.S_OK;
        }

        public override void LogResults()
        {
            Xom.Log(XomAreaName.PresenceLog, "DeleteFriend|{0}:{1:X}|{2}|{3}|{4:X}|{5}",
                    SGInfo.Current.ClientIP,
                    SGInfo.Current.ClientPort,
                    (Puid)m_requestMessage.qwUserID,
                    (Puid)m_requestMessage.qwBuddyID,
                    m_requestMessage.header.dwMsgType,
                    m_hr);
        }

        protected override XRLObject2 GetResponse()
        {
            return null;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\fd\DeadUser.cs ===
ï»¿//
// DeadStuff.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Xbox Online Service
//
// Author: mayankd
//
using System;
using System.IO;
using System.Web;
using System.Diagnostics;
using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.protocol;
using xonline.common.service;
using xonline.common.community;
using xonline.common.sql.webstore;

namespace xonline.server.presence.fd
{
    /// <summary>
    /// Handler for the DeadUser event. 
    /// <seealso cref="PresenceHandlerBase.GetHandler"/>
    /// <remarks>This class is responsible for parsing out the request stream.</remarks>
    /// </summary>
    internal class DeadUserHandler : PresenceHandlerBase
    {
        private PresenceDeadUserMsg _request;
        private uint _nonce;
        private HResult _hr;

        /// <summary>
        /// Constructor
        /// </summary>
        /// <param name="header">BaseHeader representing common header</param>
        public DeadUserHandler(BaseHeader header)
            : base(header)
        {
            _request = new PresenceDeadUserMsg();
            _nonce = 0;
            _hr = HResult.S_OK;
        }

        /// <summary>
        /// 
        /// </summary>
        public override void ProcessRequest()
        {
            PresenceRecord record = null;
            try
            {
                //Parse out the thing
                _request.ReadStream(new BinaryReader(HttpContext.Current.Request.InputStream));

                // UserID of 0 check is not necessary since PresenceHandlerBase calls it
                // If that code ever changes we need to check 0 user id scenario here too

                // Check if presence record is found, ERROR_NO_SUCH_USER in case not
                record = PresenceUtil.GetPresenceRecord(_request.qwUserID);
                if (null == record)
                {
                    _hr = Win32ErrorCode.GetHResult(Win32ErrorCode.Codes.ERROR_NO_SUCH_USER);
                    return;
                }
                // Check SGAddr against presence record. 
                if ( record.IsOnline() && !record.sgaddr.IsEqual(_request.header.sgaddr) )
                {
                    _hr = Win32ErrorCode.GetHResult(Win32ErrorCode.Codes.ERROR_USER_EXISTS);
                    return;
                }
                // Kill users, but ignore failures, before kill retrieve the nonce of the user to the above function, for logging purposes??
                try
                {
                    PresenceUtil.KillUser(record);
                }
                catch (Exception) { }
            }
            finally
            {
                if (HResult.Failed(_hr))
                {
                    //Don't throw an event for this, just log it for tracing purposes...
                    //Logging will happen anyways below.
                    Xom.Trace(XomAreaName.PresenceFDDebug,
                        LogLevel.L_WARNING,
                        "DeadUserHandler failed, called with userid: {0} and sgaddr: {1:X}:{2:X}, presence record found contains userid: {3:X16} and sgaddr: {4}:{5}, hr: {6:X8}",
                        (Puid)_request.qwUserID, _request.header.sgaddr.inaSg, _request.header.sgaddr.dwSpiSg,
                        (record == null ? "<null>" : ((Puid)record.OwnerID).ToString()), 
                        (record == null ? "<null>" : record.sgaddr.inaSg.ToString()), 
                        (record == null ? "<null>" : record.sgaddr.dwSpiSg.ToString()),
                        _hr
                        );
                }
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="hr">Error return code</param>
        public override HResult ProcessError(HResult hr)
        {
            _hr = hr;
            return HResult.S_OK;
        }

        /// <summary>
        /// 
        /// </summary>
        public override void LogResults()
        {
            Xom.Log(XomAreaName.PresenceLog, "DUS|{0}|{1:X}|{2:X}|{3:X}|{4}|{5}",
                    (Puid)_request.header.sgaddr.qwXboxId,
                    _nonce,
                    _request.header.sgaddr.inaSg,
                    _request.header.sgaddr.dwSpiSg,
                    (Puid)_request.qwUserID, _hr);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <returns>Base class that derives from XRLObject2</returns>
        protected override XRLObject2 GetResponse()
        {
            return null;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\fd\GetPresenceInfo.cs ===
using System;
using System.IO;
using System.Web;
using System.Text;
using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.protocol;
using xonline.common.service;
using xonline.common.community;

namespace xonline.server.presence.fd
{
    internal class GetPresenceInfoHandler : PresenceHandlerBase
    {
        private GetPresenceInfoRequest m_request;
        private PresenceInfoResponse m_response;

        public GetPresenceInfoHandler(BaseHeader header)
            : base(header)
        {
            m_request = new GetPresenceInfoRequest();
            m_response = new PresenceInfoResponse();
        }

        public override void ProcessRequest()
        {
            m_request.ReadStream(new BinaryReader(HttpContext.Current.Request.InputStream));

            m_response.qwSenderID = m_request.qwSenderID;
            m_response.dwContext = m_request.dwContext;
            m_response.header.dwSeqNum = m_header.dwSeqNum;
            m_response.header.sgaddr = m_header.sgaddr;
            
            if (m_request.cdwUsers == 0)
            {
                throw new XRLException(HResult.E_INVALIDARG, XEvent.Id.PRESENCE_INFO_INVALID_USER_COUNT, "GetPresenceInfo: target user count {0} is invalid", m_request.cdwUsers);
            }
            
            // Make one call to xcache to verify gamertags for sender and targets.
            // This API can be called legitimately with a non-existent gamertag, so we don't want to fail
            // but should avoid caching an empty friends list. 
            ulong[] rgSenderAndTargetIDs = new ulong[m_request.cdwUsers + 1];
            rgSenderAndTargetIDs[m_request.cdwUsers] = m_request.qwSenderID;
            for (int iUser = 0; iUser < rgSenderAndTargetIDs.Length - 1; iUser++)
            {
                rgSenderAndTargetIDs[iUser] = m_request.rgUsers[iUser];
            }
            
            string[] rgGamertags = XCache.LookupGamerTags(rgSenderAndTargetIDs);
            // first check targets. if any do not exist, throw an exception.
            for (int iGamertag = 0; iGamertag < rgGamertags.Length - 1; iGamertag++)
            {
                if (rgGamertags[iGamertag] == XCache.InvalidGamertag)
                {
                    throw new XRLException(Win32ErrorCode.GetHResult(Win32ErrorCode.Codes.ERROR_NO_SUCH_USER), XEvent.Id.PRESENCE_INVALID_USERID, "GetPresenceInfo: target user ID:{0} is unknown", rgSenderAndTargetIDs[iGamertag]);
                }
            }
            
            // now check sender
            FriendsList friends;
            if (rgGamertags[rgGamertags.Length - 1] == XCache.InvalidGamertag)
            {
                friends = new FriendsList();
                friends.OwnerID = m_request.qwSenderID;
                friends.rgUsers = new UserData[0];
            }
            else
            {
                friends = FriendsListUtil.GetFriendsListForXuid(m_request.qwSenderID);
            }
            
            PresenceInfoData[] infos = new PresenceInfoData[m_request.cdwUsers];
            BasicPresence[] basicPresence = PresenceUtil.GetBasicPresenceForUsers(friends, m_request.rgUsers);
            string[] richPresence = PresenceUtil.GetRichPresenceStringForUsers(friends, SGInfo.Current, m_request.rgUsers);

            for (int i = 0; i < m_request.cdwUsers; ++i)
            {
                infos[i] = new PresenceInfoData();
                infos[i].Puid = m_request.rgUsers[i];
                infos[i].OnlineState = basicPresence[i].dwState;
                infos[i].mtLastActive = basicPresence[i].mtLastSeen;
                infos[i].TitleId = basicPresence[i].dwTitleID;
                infos[i].qwSessionID = basicPresence[i].qwSessionID;
                infos[i].szGamerTag = basicPresence[i].sGamertag;
                if (richPresence[i] != null)
                {
                    infos[i].RPData = Encoding.UTF8.GetBytes(richPresence[i]);
                    infos[i].RPDataLen = (uint)infos[i].RPData.Length;
                }
            }

            m_response.cdwUsers = m_request.cdwUsers;
            m_response.rgUsers = infos;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="hr">Error return code</param>
        public override HResult ProcessError(HResult hr)
        {
            m_response.qwSenderID = 0;
            m_response.cdwUsers = 0;
            m_response.rgUsers = null;
            return hr;
        }

         /// <summary>
        /// 
        /// </summary>
        public override void LogResults()
        {
            StringBuilder sb = new StringBuilder();
            foreach (ulong user in m_request.rgUsers)
            {
                sb.AppendFormat("{0};", (Puid)user);
            }
            Xom.Log(XomAreaName.PresenceLog,
                "GPI|{0}|{1:X}|{2:X}|{3}|{4}",
                (Puid)m_request.header.sgaddr.qwXboxId,
                m_request.header.sgaddr.inaSg,
                m_request.header.sgaddr.dwSpiSg,
                (Puid)m_request.qwSenderID,
                sb.ToString());
        }

        /// <summary>
        /// 
        /// </summary>
        /// <returns>Base class that derives from XRLObject2</returns>
        protected override XRLObject2 GetResponse()
        {
            return m_response;
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\fd\InvalidateUser.cs ===
using System;
using System.IO;
using System.Web;
using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.protocol;
using xonline.common.service;
using xonline.common.community;
using xonline.common.sql.webstore;
using Microsoft.Webstore.WstClient;

namespace xonline.server.presence.fd
{
    internal class InvalidateUserHandler : PresenceHandlerBase
    {
        private InvalidateUserMsg _request;
        private uint _hr;

        public InvalidateUserHandler(BaseHeader header)
            : base(header)
        {
            _request = new InvalidateUserMsg();
        }

        public override void ProcessRequest()
        {
            //Parse out the request
            _request.ReadStream(new BinaryReader(HttpContext.Current.Request.InputStream));

            // User id of 0 check is not necessary since PresenceHandlerBase calls it
            // If that code ever changes we need to check 0 user id scenario here too.

            // remove the cached privileges.
            CacheUtil.RemoveFromCache(CacheUtil.BuildCacheKey(DATA_TYPES.eUserPrivileges, _request.qwUserID));

            // here we use the presenceutil function which will read from the db and populate the cache.
            UserPrivileges privs = PresenceUtil.GetUserPrivileges(_request.qwUserID);
            if (privs == null)
            {
                HResult hr = Win32ErrorCode.GetHResult(Win32ErrorCode.Codes.ERROR_NO_SUCH_USER);
                throw new XRLException(
                    hr, 
                    XEvent.Id.PRESENCE_INVALIDATE_USER_UNKNOWN_USER, 
                    "InvalidateUser: could not load privileges for user {0}", 
                    (Puid)_request.qwUserID
                    );
            }

            // now we need to update the header flags for privacy on any public items.
            
            string[] rgNotiKeys = {
                CacheUtil.BuildCacheKey(DATA_TYPES.eLimitedPresence, _request.qwUserID),
                CacheUtil.BuildCacheKey(DATA_TYPES.eBasicPresence, _request.qwUserID),
                CacheUtil.BuildCacheKey(DATA_TYPES.eRichPresenceString, _request.qwUserID),
                CacheUtil.BuildCacheKey(DATA_TYPES.eFriendsList, _request.qwUserID)
            };

            BaseDataHeader[] rgNotiValues = CacheUtil.ReadFromNotificationCache(rgNotiKeys);

            for (int iValue = 0; iValue < rgNotiValues.Length; iValue++)
            {
                if (rgNotiValues[iValue] == null) continue;

                rgNotiValues[iValue].HeaderFlags &= (uint)~((uint)CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_EVERYONE | (uint)CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_FRIENDS);

                if (rgNotiValues[iValue] is FriendsList)
                {
                    rgNotiValues[iValue].HeaderFlags |= privs.HasPrivilege(XOn.XPRIVILEGE_SHARE_FRIENDS_LIST) ? (uint)CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_EVERYONE : 0;
                    rgNotiValues[iValue].HeaderFlags |= privs.HasPrivilege(XOn.XPRIVILEGE_SHARE_FRIENDS_LIST_FRIENDS_ONLY) ? (uint)CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_FRIENDS : 0;
                }
                else
                {
                    rgNotiValues[iValue].HeaderFlags |= privs.HasPrivilege(XOn.XPRIVILEGE_PRESENCE) ? (uint)CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_EVERYONE : 0;
                    rgNotiValues[iValue].HeaderFlags |= privs.HasPrivilege(XOn.XPRIVILEGE_PRESENCE_FRIENDS_ONLY) ? (uint)CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_FRIENDS : 0;
                }
            }

            CacheUtil.OverwriteNotificationCache(rgNotiValues);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="hr">Error return code</param>
        public override HResult ProcessError(HResult hr)
        {
            _hr = hr;
            return HResult.S_OK;
        }

        /// <summary>
        /// 
        /// </summary>
        public override void LogResults()
        {
            Xom.Log(XomAreaName.PresenceLog, "InvalidateUser|{0}:{1:X}|{2}|{3}",
                    SGInfo.Current.ClientIP,
                    SGInfo.Current.ClientPort,
                    (Puid)_request.qwUserID,
                    _hr);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <returns>Base class that derives from XRLObject2</returns>
        protected override XRLObject2 GetResponse()
        {
            return null;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\fd\presence.cs ===
// 
// Presence.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Presence Front Door
// Xbox Online Service
// 

using System;
using System.IO;
using System.Text;
using System.Web;
using System.Diagnostics;
using xonline.common.config;
using xonline.common.protocol;
using xonline.common.service;
using xonline.common.mgmt;


namespace xonline.server.presence.fd
{
    // -----------------------------------------------------------------------------------
    // Presence class - handles Presence requests
    // -----------------------------------------------------------------------------------

    public class Presence : IHttpHandler
    {
        public void ProcessRequest(HttpContext httpCtx)
        {
            // just for kicks, make sure this is cached.
            HttpContext ctx = HttpContext.Current;
            MemoryStream response = new MemoryStream();
            HResult hr = HResult.S_OK;
            
            // This is the first step, so log the request to the debug stream
            LogFDRequest();

            while (ctx.Request.InputStream.Position < ctx.Request.InputStream.Length)
            {
                // Get the handler 
                PresenceHandlerBase handler = null;
                XomRequestTimeElapsed elapsed = new XomRequestTimeElapsed();

                try
                {
                    PresenceHandlerBase.GetHandler(out handler);
                    handler.m_bIsProcessed = true;
                    handler.ProcessRequest();

                    PresencePerAPICounters.Total.SuccessRate.Increment();
                    PresencePerAPICounters.Total[PresenceHandlerBase.GetRequestTypeName(handler.m_header.dwMsgType)].SuccessRate.Increment();
                }
                catch (Exception e)
                {
                    XEvent.Id eventId = XEvent.Id.MC_APPLICATION_ERROR;
                    hr = HResult.XONLINE_E_SERVER_ERROR;
                    XRLException xrle = e as XRLException;
                    if (xrle != null)
                    {
                        hr = xrle.HResult;
                        eventId = xrle.EventId;
                    }

                    if (eventId != XEvent.Id.PRESENCE_DO_NOT_LOG_EVENT)
                    {
                        Xom.NtEvent(eventId, e, "Error processing request, Message type: {0}: {1}, User ID: {2}",
                            (handler == null) ? 0 : handler.m_header.dwMsgType,
                            (handler == null) ? "unknown" : PresenceHandlerBase.GetRequestTypeName(handler.m_header.dwMsgType),
                            (Puid)((handler == null) ? 0 : handler.m_qwUserID));
                    }

                    if (handler != null)
                    {
                        HResult hrInner = handler.ProcessError(hr);
                        if (handler.m_bIsProcessed)
                        {
                            hr = hrInner;
                        }
                        PresencePerAPICounters.Total[PresenceHandlerBase.GetRequestTypeName(handler.m_header.dwMsgType)].FailureRate.Increment();
                    }

                    PresencePerAPICounters.Total.FailureRate.Increment();
                    break;
                }
                finally
                {
                    if (handler != null)
                    {
                        handler.WriteResponse(response);
                        handler.LogResults();
                        PresencePerAPICounters.Total[PresenceHandlerBase.GetRequestTypeName(handler.m_header.dwMsgType)].RequestsPerSecond.Increment();
                        PresencePerAPICounters.Total[PresenceHandlerBase.GetRequestTypeName(handler.m_header.dwMsgType)].ResponseTimeAvg.IncrementBy(elapsed.MillisecondsElapsed);
                        PresencePerAPICounters.Total[PresenceHandlerBase.GetRequestTypeName(handler.m_header.dwMsgType)].ResponseTimeAvgBase.Increment();
                    }

                    PresencePerAPICounters.Total.RequestsPerSecond.Increment();
                    PresencePerAPICounters.Total.ResponseTimeAvg.IncrementBy(elapsed.MillisecondsElapsed);
                    PresencePerAPICounters.Total.ResponseTimeAvgBase.Increment();
                }
            }
            byte[] rgbResponse = response.ToArray();
            XRLUtil.SetXRLResponse(HttpContext.Current.Response, XOService.PresNotification, 0, hr, (rgbResponse.Length > 0) ? rgbResponse : null);
        }

        // -------------------------------------------------------------------------------
        // IsReusable - allow reuse of this instance
        // -------------------------------------------------------------------------------
        public bool IsReusable
        {
            get { return true; }
        }

        //-------------------------------------------------------------------------------
        // LogFDRequest - Log the incoming request
        //-------------------------------------------------------------------------------
        public static void LogFDRequest()
        {
            Xom.Trace(XomAreaName.PresenceFDDebug, LogLevel.L_NORMAL, "Request: Url={0} User-Agent={1}\r\n{2}",
                      HttpContext.Current.Request.RawUrl, HttpContext.Current.Request.UserAgent,
                      StreamToString(HttpContext.Current.Request.InputStream, true));
        }

        //-------------------------------------------------------------------------------
        // StreamToString - returns a string representation of a stream
        //-------------------------------------------------------------------------------
        private static string StreamToString(Stream stream, bool fShowOffset)
        {
            if(stream == null) {
                return("");
            }

            // Store the original position of the stream
            long lOriginalPos = stream.Position;

            // Seek to the beginning of the stream
            stream.Seek(0, SeekOrigin.Begin);

            StringBuilder sb = new StringBuilder();

            // We will build lines of the format:
            // "00000000 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................"
            uint dwOffset = 0;
            while(dwOffset < stream.Length) {
                // Add the offset if requested
                if(fShowOffset) {
                    sb.Append(dwOffset.ToString("X8"));
                    sb.Append(" ");
                }

                long lLineStartPos = stream.Position;

                // Display the raw bytes
                for(uint iByte = 0; iByte < 16; iByte++) {
                    if(dwOffset + iByte < stream.Length) {
                        byte b = (byte)stream.ReadByte();
                        sb.Append(b.ToString("X2"));
                        sb.Append(" ");
                    } else {
                        sb.Append("   ");
                    }
                }

                // We want 4 spaces between the byte and character display (one space already follows the last byte)
                sb.Append("   ");

                // Go back to the start of the line
                stream.Seek(lLineStartPos, SeekOrigin.Begin);

                // Display the bytes as characters
                for(uint iByte = 0; iByte < 16; iByte++) {
                    if(dwOffset + iByte < stream.Length) {
                        byte b = (byte)stream.ReadByte();

                        if(0x20 <= b && 0x7E >= b) {// C's isprint function
                            sb.Append((char)b);
                        } else {
                            sb.Append(".");
                        }
                    } else {
                        sb.Append(" ");
                    }
                }

                // End the line
                sb.Append("\r\n");

                dwOffset += 16;
            }

            // Put the stream back where we found it
            stream.Seek(lOriginalPos, SeekOrigin.Begin);

            return(sb.ToString());
        } 
    }

    [XomPerformanceCounterCategoryAttr( "Presence FD - API", "XBox Live Presence Service Frontdoor: Per API Info" )]
    public class PresencePerAPICounters : XomPerformanceCounterCategory
    {
        public PresencePerAPICounters() : base(true)
        {
        }
        
        public virtual PresencePerAPICounters this[string APIName]
        {
            get
            {
                return (PresencePerAPICounters) GetInstance(APIName);
            }
        }

        static public PresencePerAPICounters Total = new PresencePerAPICounters();

        [XomPerformanceCounterAttr(
            "Requests per Second", 
            "Number of requests per second", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter RequestsPerSecond;

        [XomPerformanceCounterAttr(
            "Average Response Time", 
            "Average time a request takes to be processed.", 
             PerformanceCounterType.AverageTimer32)]
        public PerformanceCounter ResponseTimeAvg;
        
        [XomPerformanceCounterAttr(
            "Average Respone Time Base", 
            "Base for Average time a request takes to be processed.",
             PerformanceCounterType.AverageBase)]
        public PerformanceCounter ResponseTimeAvgBase;

        [XomPerformanceCounterAttr(
            "Success Rate", 
            "Number of requests succeeded per second.", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter SuccessRate;

        [XomPerformanceCounterAttr(
            "Failure Rate", 
            "Number of requests failed per second.",
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter FailureRate;

    }

} // namespace xonline.server.presence.fd
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\fd\InviteAnswer.cs ===
ï»¿//
// GetMessageDetails.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Xbox Online Service
//
using System;
using System.Collections;
using System.IO;
using System.Text;
using System.Web;
using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.protocol;
using xonline.common.service;
using xonline.common.community;
using Microsoft.Webstore.WstClient;

namespace xonline.server.presence.fd
{

    //-----------------------------------------------------------------------------------
    // Process InviteAnswer requests
    //-----------------------------------------------------------------------------------
    public class InviteAnswerHandler : PresenceHandlerBase
    {
        //-----------------------------------------------------------------------------------
        // Private data
        //-----------------------------------------------------------------------------------
        private PresenceAnswerInviteMsg m_request;

        //-----------------------------------------------------------------------------------
        // Constructor
        //-----------------------------------------------------------------------------------
        public InviteAnswerHandler(BaseHeader header)
            : base(header)
        {
            m_request = new PresenceAnswerInviteMsg();
        }

        //-----------------------------------------------------------------------------------
        // Give the superclass access to the response
        //-----------------------------------------------------------------------------------
        protected override XRLObject2 GetResponse()
        {
            return null;
        }

        //-----------------------------------------------------------------------------------
        // Process the incoming request and generate the response
        //-----------------------------------------------------------------------------------
        public override void ProcessRequest()
        {
            // Deserialize the incoming stream
            m_request.ReadStream(new BinaryReader(HttpContext.Current.Request.InputStream));

            // Check for m_request.qwUserID!=0 done at PresenceHandlerBase::ValidateHeader()

            //HostID zero is invalid
            if (m_request.qwHostID == 0)
            {
                throw new XRLException(
                    HResult.E_INVALIDARG,
                    XEvent.Id.PRESENCE_INVITEANSWER_INVALID_HOSTID,
                    "User {0} sent invalid hostID of zero in InviteAnswer message",
                    (Puid)m_request.qwUserID
                    );
            }

            // Make sure the response is supported
            switch(m_request.wAnswer)
            {
                case PresDefs.PINVITE_REPLY_YES:
                case PresDefs.PINVITE_REPLY_NO:
                case PresDefs.PINVITE_REPLY_NEVER:
                    break;
                default:
                    throw new XRLException(
                        HResult.E_INVALIDARG,
                        XEvent.Id.PRESENCE_INVITEANSWER_INVALID_ANSWER,
                        "User {0} sent invalid answer ({1}) in InviteAnswer message", 
                        (Puid)m_request.qwUserID,
                        m_request.wAnswer
                        );
            }

            // Session id zero is invalid
            if (m_request.qwMatchSessionID == 0)
            {
                throw new XRLException(
                    HResult.E_INVALIDARG,
                    XEvent.Id.PRESENCE_INVITEANSWER_INVALID_SESSIONID,
                    "User {0} sent invalid sessionID of zero in InviteAnswer message",
                    (Puid)m_request.qwUserID
                    );
            }

            // check the userid
            if (XCache.LookupGamerTag(m_request.qwUserID) == XCache.InvalidGamertag)
            {
                throw new XRLException(
                    Win32ErrorCode.GetHResult(Win32ErrorCode.Codes.ERROR_NO_SUCH_USER),
                    XEvent.Id.PRESENCE_INVITEANSWER_INVALID_USERID, 
                    "User {0} does not exist.", 
                    (Puid)m_request.qwUserID
                    );
            }

            // If we accepted, clear our outgoing invitations
            if (m_request.wAnswer == PresDefs.PINVITE_REPLY_YES)
            {
                PresenceUtil.PreserveSpecificInvitation(m_request.qwUserID, m_request.qwMatchSessionID);
            }

            PresenceRecord hostPresence = PresenceUtil.GetPresenceRecord(m_request.qwHostID);
            if (hostPresence != null && hostPresence.IsOnline())
            {
                // Remove invitee from current invitation record
                PresenceUtil.RemoveInvitees(m_request.qwHostID, new ulong[] { m_request.qwUserID }, m_request.qwMatchSessionID);

                // Notify the host about the invitation answer
                hostPresence.QueueInviteAnswerQVals(
                    m_request.qwUserID,
                    m_request.qwMatchSessionID,
                    (m_request.wAnswer == PresDefs.PINVITE_REPLY_NEVER) ? PresDefs.PINVITE_REPLY_NO : m_request.wAnswer);
            }

            // Revoke the invitation message from the invitee queue
            RecipientResult recipient = new RecipientResult();
            recipient.qwUserID = m_request.qwUserID;
            recipient.dwMessageID = 0;

            uint dwFlags = 
                MsgDefs.XMSG_REVOKE_MESSAGE_EX_FLAG_USE_PROP |
                MsgDefs.XMSG_REVOKE_MESSAGE_EX_FLAG_USE_TYPE |
                MsgDefs.XMSG_REVOKE_MESSAGE_EX_FLAG_USE_SENDER;

            if (m_request.wAnswer == PresDefs.PINVITE_REPLY_NEVER)
            {
                dwFlags |= MsgDefs.XMSG_REVOKE_MESSAGE_EX_FLAG_BLOCK_SENDER;
            }

            MsgReq req = new MsgReq();
            req.RevokeMessageEx(
                m_request.qwHostID,                                 // qwSenderId
                0,                                                  // qwSenderContext
                MsgDefs.XONLINE_MSG_TYPE_GAME_INVITE,               // bMessageType
                dwFlags,                                            // dwFlags
                new RecipientResult[] { recipient },                // rgRecipients
                MsgDefs.XONLINE_MSG_PROP_SESSION_ID,                // wPropTag
                BitConverter.GetBytes(m_request.qwMatchSessionID)   // rgbProp
                );
        }

        //-----------------------------------------------------------------------------------
        // Handle errors during processing
        //-----------------------------------------------------------------------------------
        public override HResult ProcessError(HResult hr)
        {
            // Put the hresult in the response
            return HResult.S_OK;
        }

        //-----------------------------------------------------------------------------------
        // Log the activity
        //-----------------------------------------------------------------------------------
        public override void LogResults()
        {
            Xom.Log(XomAreaName.PresenceLog,
                "ANS|{0}|{1:X}|{2:X}|{3}|{4}|{5}|{6}",
                (Puid)m_request.header.sgaddr.qwXboxId,
                m_request.header.sgaddr.inaSg,
                m_request.header.sgaddr.dwSpiSg,
                (Puid)m_request.qwUserID,
                (Puid)m_request.qwHostID,
                (Puid)m_request.qwMatchSessionID,
                m_request.wAnswer
                );
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\fd\Kick.cs ===
using System;
using System.IO;
using System.Web;
using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.protocol;
using xonline.common.service;
using xonline.common.community;
using xonline.common.sql.webstore;
using Microsoft.Webstore.WstClient;

namespace xonline.server.presence.fd
{
    internal class KickHandler : PresenceHandlerBase
    {
        private uint m_hr;
        private KickMsg m_request;

        public KickHandler(BaseHeader header)
            : base(header)
        {
            m_request = new KickMsg();
        }

        public override void ProcessRequest()
        {
            //Parse out the request
            m_request.ReadStream(new BinaryReader(HttpContext.Current.Request.InputStream));

            // User id of 0 check is done by PresenceHandlerBase

            // Check that the target user XUID is valid
            if (XCache.LookupGamerTag(m_request.qwUserID) == XCache.InvalidGamertag)
            {
                throw new XRLException(
                    Win32ErrorCode.GetHResult(Win32ErrorCode.Codes.ERROR_NO_SUCH_USER),
                    XEvent.Id.PRESENCE_KICK_UNKNOWN_USER,
                    "Kick: Invalid qwUserID {0}",
                    (Puid)m_request.qwUserID
                    );
            }

            // First set the flush tickets flag
            if (m_request.fFlushTickets != 0)
            {
                PresenceUtil.SetFlushTickets(m_request.qwUserID);
            }

            PresenceRecord presence = PresenceUtil.GetPresenceRecord(m_request.qwUserID);
            if (presence != null && presence.IsOnline())
            {
                // They're on, kick them off the system
                SGComm.SendKick(presence.sgaddr);
            }

            m_hr = HResult.S_OK;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="hr">Error return code</param>
        public override HResult ProcessError(HResult hr)
        {
            m_hr = hr;
            return HResult.S_OK;
        }

        /// <summary>
        /// 
        /// </summary>
        public override void LogResults()
        {
            Xom.Log(XomAreaName.PresenceLog, "Kick|{0}|{1:X}|{2:X}|{3}|{4}|{5}",
                (Puid)m_request.header.sgaddr.qwXboxId,
                m_request.header.sgaddr.inaSg,
                m_request.header.sgaddr.dwSpiSg,
                (Puid)m_request.qwUserID,
                m_request.fFlushTickets,
                m_hr);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <returns>Base class that derives from XRLObject2</returns>
        protected override XRLObject2 GetResponse()
        {
            return null;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\fd\NeverList.cs ===
ï»¿//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Xbox Online Service
//
using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using System.Web;
using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.protocol;
using xonline.common.service;
using xonline.common.community;

namespace xonline.server.presence.fd
{

    //-----------------------------------------------------------------------------------
    // Process AddUsersToNeverList requests
    //-----------------------------------------------------------------------------------
    public class AddUsersToNeverListHandler : PresenceHandlerBase
    {
        //-----------------------------------------------------------------------------------
        // Private data
        //-----------------------------------------------------------------------------------
        private AddUsersToNeverListMsg _request;
        private HResult _hr;

        //-----------------------------------------------------------------------------------
        // Constructor
        //-----------------------------------------------------------------------------------
        public AddUsersToNeverListHandler(BaseHeader header)
            : base(header)
        {
            _request = new AddUsersToNeverListMsg();
        }

        //-----------------------------------------------------------------------------------
        // Give the superclass access to the response
        //-----------------------------------------------------------------------------------
        protected override XRLObject2 GetResponse()
        {
            return null;
        }

        //-----------------------------------------------------------------------------------
        // Process the incoming request and generate the response
        //-----------------------------------------------------------------------------------
        public override void ProcessRequest()
        {
            // Deserialize the incoming stream
            _request.ReadStream(new BinaryReader(HttpContext.Current.Request.InputStream));

            if (XCache.LookupGamerTag(_request.qwUserID) == XCache.InvalidGamertag)
            {
                HResult hr = Win32ErrorCode.GetHResult(Win32ErrorCode.Codes.ERROR_NO_SUCH_USER);
                throw new XRLException(hr,
                    XEvent.Id.PRESENCE_NEVERLIST_INVALID_USER,
                    "AddUsersToNeverList (sender: {0}) failed hr={1}",
                    (Puid)_request.qwUserID, hr);
            }

            PresenceUtil.AddUsersToNeverList(_request.qwUserID, _request.rgqwNeverListUsers);
        }

        //-----------------------------------------------------------------------------------
        // Handle errors during processing
        //-----------------------------------------------------------------------------------
        public override HResult ProcessError(HResult hr)
        {
            _hr = hr;
            return _hr;
        }

        //-----------------------------------------------------------------------------------
        // Log the activity
        //-----------------------------------------------------------------------------------
        public override void LogResults()
        {
            StringBuilder sb = new StringBuilder();
            if (_hr == HResult.S_OK)
            {
                foreach (ulong xuid in _request.rgqwNeverListUsers)
                {
                    sb.AppendFormat("{0};", (Puid)xuid);
                }
            }
            Xom.Log(XomAreaName.PresenceLog, "AddUsersToNeverList|{0}:{1:X}|{2}|{3}|{4}",
                    SGInfo.Current.ClientIP,
                    SGInfo.Current.ClientPort,
                    (Puid)_request.qwUserID,
                    sb.ToString(),
                    _hr);
        }
    }

    //-----------------------------------------------------------------------------------
    // Process RemoveUsersFromNeverList requests
    //-----------------------------------------------------------------------------------
    public class RemoveUsersFromNeverListHandler : PresenceHandlerBase
    {
        //-----------------------------------------------------------------------------------
        // Private data
        //-----------------------------------------------------------------------------------
        private RemoveUsersFromNeverListMsg _request;
        private HResult _hr;

        //-----------------------------------------------------------------------------------
        // Constructor
        //-----------------------------------------------------------------------------------
        public RemoveUsersFromNeverListHandler(BaseHeader header)
            : base(header)
        {
            _request = new RemoveUsersFromNeverListMsg();
        }

        //-----------------------------------------------------------------------------------
        // Give the superclass access to the response
        //-----------------------------------------------------------------------------------
        protected override XRLObject2 GetResponse()
        {
            return null;
        }

        //-----------------------------------------------------------------------------------
        // Process the incoming request and generate the response
        //-----------------------------------------------------------------------------------
        public override void ProcessRequest()
        {
            // Deserialize the incoming stream
            _request.ReadStream(new BinaryReader(HttpContext.Current.Request.InputStream));

            if (XCache.LookupGamerTag(_request.qwUserID) == XCache.InvalidGamertag)
            {
                HResult hr = Win32ErrorCode.GetHResult(Win32ErrorCode.Codes.ERROR_NO_SUCH_USER);
                throw new XRLException(hr,
                    XEvent.Id.PRESENCE_NEVERLIST_INVALID_USER,
                    "RemoveUsersFromNeverList (sender: {0}) failed hr={1}",
                    (Puid)_request.qwUserID, hr);
            }

            PresenceUtil.RemoveUsersFromNeverList(_request.qwUserID, _request.rgqwNeverListUsers);
        }

        //-----------------------------------------------------------------------------------
        // Handle errors during processing
        //-----------------------------------------------------------------------------------
        public override HResult ProcessError(HResult hr)
        {
            _hr = hr;
            return _hr;
        }

        //-----------------------------------------------------------------------------------
        // Log the activity
        //-----------------------------------------------------------------------------------
        public override void LogResults()
        {
            StringBuilder sb = new StringBuilder();
            if (_hr == HResult.S_OK)
            {
                foreach (ulong xuid in _request.rgqwNeverListUsers)
                {
                    sb.AppendFormat("{0};", (Puid)xuid);
                }
            }

            Xom.Log(XomAreaName.PresenceLog, "RemoveUsersFromNeverList|{0}:{1:X}|{2}|{3}|{4}",
                    SGInfo.Current.ClientIP,
                    SGInfo.Current.ClientPort,
                    (Puid)_request.qwUserID,
                    sb.ToString(),
                    _hr);
        }
    }

    //-----------------------------------------------------------------------------------
    // Process CanSendMessageToUsers requests
    //-----------------------------------------------------------------------------------
    public class CanSendMessageToUsersHandler : PresenceHandlerBase
    {
        //-----------------------------------------------------------------------------------
        // Private data
        //-----------------------------------------------------------------------------------
        private CanSendMessageToUsersMsg _request;
        private CanSendMessageToUsersResponse _response;
        private HResult _hr;

        //-----------------------------------------------------------------------------------
        // Constructor
        //-----------------------------------------------------------------------------------
        public CanSendMessageToUsersHandler(BaseHeader header)
            : base(header)
        {
            _request = new CanSendMessageToUsersMsg();
            _response = new CanSendMessageToUsersResponse();
        }

        //-----------------------------------------------------------------------------------
        // Give the superclass access to the response
        //-----------------------------------------------------------------------------------
        protected override XRLObject2 GetResponse()
        {
            return _response;
        }

        //-----------------------------------------------------------------------------------
        // Process the incoming request and generate the response
        //-----------------------------------------------------------------------------------
        public override void ProcessRequest()
        {
            // Deserialize the incoming stream
            _request.ReadStream(new BinaryReader(HttpContext.Current.Request.InputStream));
            _response.rghrResponses = new uint[_request.cUserListCount];
            _response.cResponseListCount = _request.cUserListCount;

            if (XCache.LookupGamerTag(_request.qwUserID) == XCache.InvalidGamertag)
            {
                HResult hr = Win32ErrorCode.GetHResult(Win32ErrorCode.Codes.ERROR_NO_SUCH_USER);
                throw new XRLException(hr,
                    XEvent.Id.PRESENCE_NEVERLIST_INVALID_USER,
                    "CanSendMessageToUsers (sender: {0}) failed hr={1}",
                    (Puid)_request.qwUserID,  hr);
            }

            //check the userlist 
            PopulateResponse();

        }

        private void PopulateResponse()
        {
            var receiverNeverList = PresenceUtil.GetNeverList(_request.rgqwUsers);
            var receiverPrivileges = PresenceUtil.GetUserPrivileges(_request.rgqwUsers);
            var senderFriends = FriendsListUtil.GetFriendsListForXuid(_request.qwUserID);
            var userGamertags = XCache.LookupGamerTags(_request.rgqwUsers);

            for (int i = 0; i < _request.cUserListCount; i++)
            {
                _response.rghrResponses[i] = HResult.S_OK;

                //check for valid recipient userids
                if (userGamertags[i] == XCache.InvalidGamertag)
                {
                    _response.rghrResponses[i] = Win32ErrorCode.GetHResult(Win32ErrorCode.Codes.ERROR_NO_SUCH_USER);
                    continue;
                }

                //check to see if reciepient allow everyone or just friends
                if (!PresenceUtil.IsSharingAllowed(senderFriends, _request.rgqwUsers[i],
                    receiverPrivileges[i].HasPrivilege(XOn.XPRIVILEGE_COMMUNICATIONS), receiverPrivileges[i].HasPrivilege(XOn.XPRIVILEGE_COMMUNICATIONS_FRIENDS_ONLY)))
                {
                    _response.rghrResponses[i] = HResult.XONLINE_E_MESSAGE_INSUFFICIENT_PRIVILEGES;
                    continue;
                }

                //check to see if the sender is no in neverlist of reciepient
                if (null != receiverNeverList[i])
                {
                    if (receiverNeverList[i].ContainsUser(_request.qwUserID))
                    {
                        _response.rghrResponses[i] = HResult.XONLINE_E_MESSAGE_SENDER_BLOCKED;
                        continue;
                    }
                }
            }
        }

        //-----------------------------------------------------------------------------------
        // Handle errors during processing
        //-----------------------------------------------------------------------------------
        public override HResult ProcessError(HResult hr)
        {
            _hr = hr;
            return _hr;
        }

        //-----------------------------------------------------------------------------------
        // Log the activity
        //-----------------------------------------------------------------------------------
        public override void LogResults()
        {
            StringBuilder sb = new StringBuilder();
            if (_hr == HResult.S_OK)
            {
                int i = 0;
                foreach (ulong xuid in _request.rgqwUsers)
                {
                    sb.AppendFormat("userid-{0}; hresult-{1}", (Puid)xuid, _response.rghrResponses[i++]);
                }
            }
            Xom.Log(XomAreaName.PresenceLog, "CanSendMessageToUsers|{0}:{1:X}|{2}|{3}|{4}",
                    SGInfo.Current.ClientIP,
                    SGInfo.Current.ClientPort,
                    (Puid)_request.qwUserID,
                    sb.ToString(),
                    _hr);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\fd\Logon.cs ===
ï»¿//
// GetMessageDetails.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Xbox Online Service
//
// Author: dberke
//
using System;
using System.Collections.Generic;
using System.IO;
using System.Web;
using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.protocol;
using xonline.common.service;
using xonline.common.community;
using xonline.common.sql.webstore;
using Microsoft.Webstore.WstClient;

namespace xonline.server.presence.fd
{

    /// <summary>
    /// Handler for the LogonCheck event.
    /// <seealso cref="PresenceHandlerBase.GetHandler"/>
    /// <remarks>This class is responsible for parsing out the request stream.</remarks>
    /// </summary>
    internal class LogonCheckHandler : PresenceHandlerBase
    {
        private PresenceLogonCheckMsg _request;
        private PresenceLogonCheckReplyMsg _response;

        /// <summary>
        /// Constructor
        /// </summary>
        /// <param name="header">BaseHeader representing common header</param>
        public LogonCheckHandler(BaseHeader header)
            : base(header)
        {
            _request = new PresenceLogonCheckMsg();
            _response = new PresenceLogonCheckReplyMsg();
        }

        /// <summary>
        ///
        /// </summary>
        public override void ProcessRequest()
        {
            //Parse out the thing
            _request.ReadStream(new BinaryReader(HttpContext.Current.Request.InputStream));

            // User id of 0 check is not necessary since PresenceHandlerBase calls it
            // If that code ever changes we need to check 0 user id scenario here too.

            //Find the Presence
            PresenceRecord record = PresenceUtil.GetPresenceRecord(_request.qwUserID);
            if (null == record)
            {
                //Convert using implicit operand for uint
                HResult hr = Win32ErrorCode.GetHResult(Win32ErrorCode.Codes.ERROR_NO_SUCH_USER);
                throw new XRLException(hr, XEvent.Id.PRESENCE_CACHE_NOTFOUND,
                    "LogonCheck failed user={0} hr={1}",
                    (Puid)_request.qwUserID, hr);
            }
            if (record.IsOnline() && record.sgaddr.qwXboxId != _request.header.sgaddr.qwXboxId)
            {
                //Raise from win32 error ERROR_USER_EXISTS
                HResult hr = Win32ErrorCode.GetHResult(Win32ErrorCode.Codes.ERROR_USER_EXISTS);
                throw new XRLException(hr, XEvent.Id.PRESENCE_DO_NOT_LOG_EVENT, "");
            }
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="hr">Error return code</param>
        public override HResult ProcessError(HResult hr)
        {
            _response.hr = hr;
            return HResult.S_OK;
        }

        /// <summary>
        ///
        /// </summary>
        public override void LogResults()
        {
            Xom.Log(XomAreaName.PresenceLog, "LogonCheckHandler|{0}:{1:X}|{2}|{3:X}|{4}",
                    SGInfo.Current.ClientIP,
                    SGInfo.Current.ClientPort,
                    (Puid)_request.qwUserID,
                    _request.header.dwMsgType,
                    _response.hr);
        }

        /// <summary>
        ///
        /// </summary>
        /// <returns>Base class that derives from XRLObject2</returns>
        protected override XRLObject2 GetResponse()
        {
            _response.header.dwSeqNum = m_header.dwSeqNum;
            _response.header.sgaddr = m_header.sgaddr;
            return _response;
        }
    }

    //-----------------------------------------------------------------------------------
    // Process Login requests
    //-----------------------------------------------------------------------------------
    public class Alive2Handler : PresenceHandlerBase
    {
        //-----------------------------------------------------------------------------------
        // Private data
        //-----------------------------------------------------------------------------------
        private PresenceAlive2Msg m_request;
        private PresenceAliveReply m_response;

        private bool m_fNameChanged;
        private byte[] m_rgbPrivileges;
        private int m_firstLogin;

        private PresenceRecord m_presenceRecord;
        private NeverList m_neverList;

        //-----------------------------------------------------------------------------------
        // Constructor
        //-----------------------------------------------------------------------------------
        public Alive2Handler(BaseHeader header) : base(header)
        {
            m_request  = new PresenceAlive2Msg();
            m_response = new PresenceAliveReply();
            m_rgbPrivileges = new byte[32];
        }

        //-----------------------------------------------------------------------------------
        // Give the superclass access to the response
        //-----------------------------------------------------------------------------------
        protected override XRLObject2 GetResponse()
        {
            m_response.header.dwSeqNum = m_header.dwSeqNum;
            m_response.header.sgaddr = m_header.sgaddr;
            return m_response;
        }

        //-----------------------------------------------------------------------------------
        // Process the incoming request and generate the response
        //-----------------------------------------------------------------------------------
        public override void ProcessRequest()
        {
            // Deserialize the incoming stream
            m_request.ReadStream(new BinaryReader(HttpContext.Current.Request.InputStream));

            // TitleID of 0 not allowed
            if(m_request.dwTitleID == 0)
            {
                throw new XRLException(HResult.E_INVALIDARG, XEvent.Id.PRESENCE_ALIVE_INVALID_TITLEID,
                    "Alive2Handler: Invalid title ID 0, seq num {0:X8}", m_request.header.dwSeqNum);
            }

            VerifyLoginGamertag();

            // check if the user is already online.
            m_presenceRecord = PresenceUtil.GetPresenceRecord(m_request.qwUserID);
            if (m_presenceRecord != null)
            {
                if (!m_presenceRecord.sgaddr.IsEqual(m_request.header.sgaddr) && (m_presenceRecord.sgaddr.inaSg != 0))
                {
                    // Kick him from old SG
                    SGComm.SendKick(m_presenceRecord.sgaddr);
                }
                // remove him from his old machine.
                PresenceUtil.RemoveUserFromMachine(m_request.qwUserID, m_presenceRecord.sgaddr);
            }

            // call into uodb.
            SProcAlive();

            if (m_response.hr == HResult.XONLINE_E_NOTIFICATION_FLUSH_TICKETS)
            {
                // fail this call to "force" ticket flush and re-logon.
                return;
            }

            if (m_fNameChanged)
            {
                // Ignore return code. Best-effort operation, will happen again next Alive/Logon if failed.
                PresenceUtil.UpdateNameAll(m_request.qwUserID, m_request.szAcctName);
            }

            // cache stuff.
            UserPrivileges privs = new UserPrivileges(m_request.qwUserID, m_rgbPrivileges);
            PresenceUtil.WriteUserPrivilegesToCache(privs);

            PresenceUtil.WriteNeverListToCache(m_neverList);
            FriendsListUtil.RefreshFriendsListCache(m_request.qwUserID);

            m_presenceRecord = PresenceRecord.Init(
                m_request.qwUserID,
                m_request.szAcctName,
                m_request.dwTitleID,
                m_request.header.sgaddr,
                privs,
                SGInfo.Current);

            PresenceUtil.AddUserToMachine(m_request.qwUserID, m_request.header.sgaddr);

            TransientMessage[] xmsgs = MessagingUtil.GetTransientMessages(m_request.qwUserID);
            if (xmsgs.Length > 0)
            {
                // If the user previously had transient messages in the queue these must be filtered by the current neverlist
                List<uint> deleteIds = new List<uint>();
                foreach (TransientMessage xmsg in xmsgs)
                {
                    if (m_neverList.ContainsUser(xmsg.Summary.qwSenderID))
                    {
                        deleteIds.Add(xmsg.Summary.dwMessageID);
                    }
                }
                if (deleteIds.Count > 0)
                {
                    MessagingUtil.DeleteTransientMessages(m_request.qwUserID, deleteIds.ToArray());
                    xmsgs = MessagingUtil.GetTransientMessages(m_request.qwUserID);
                }
                if (xmsgs.Length > 0)
                {
                    // If there are transient messages remaining, send the respective PQUEUE_INVITE items
                    foreach (TransientMessage xmsg in xmsgs)
                    {
                        if ((xmsg.Summary.dwMessageFlags & MsgDefs.XONLINE_MSG_FLAG_SENDER_IS_FRIEND) != 0)
                        {
                            m_presenceRecord.QueueInviteQVals(xmsg.Summary.qwSenderID, xmsg.MatchSessionID, xmsg.Summary.dwSenderTitleID);
                        }
                    }
                    // If there are transient messages remaining, message enumeration should be flagged
                    if (m_response.hr == HResult.S_OK)
                    {
                        m_response.hr = HResult.XONLINE_S_LOGON_USER_MESSAGE_ENUMERATION_NEEDED;
                    }
                }
            }

            // do other Logon related tasks.
            OnSuccessfulLogin();
        }

        private void OnSuccessfulLogin()
        {
            //////////////////////////////////////////////////////////////////////////////
            //
            // THIS IS WHERE YOU ADD TASKS TO BE PERFORMED WHEN A USER LOGS INTO XBOX LIVE
            //
            //////////////////////////////////////////////////////////////////////////////

            // DoSomething();

            SendWelcomeMessage();
            UpdateLicenseTransferDestConsole();


            PresenceEvents.PublishLoginChange(new PresenceEvents.LoginChangeEventArgs 
                {
                    Xuid = m_request.qwUserID,
                    TitleId = m_request.dwTitleID,
                    Privacy = 0,  // always cloaked on login (provisional state)
                    PlatformType = SGInfo.GetPlatform(), 
                    ClientVersion = m_presenceRecord.ClientVersion
                }
            );
        }

        private void SendWelcomeMessage()
        {
            try
            {
                uint dwWelcomeMessage = 0;
                switch (m_firstLogin)
                {
                    case (int)PresDefs.XONLINE_PRESENCE_LOGON_FIRST_TIME_CONSOLE:
                        dwWelcomeMessage = Config.GetUIntSetting(Setting.presence_WelcomeToNewConsoleMessage);
                        break;
                    case (int)PresDefs.XONLINE_PRESENCE_LOGON_FIRST_TIME_LIVE:
                        dwWelcomeMessage = Config.GetUIntSetting(Setting.presence_WelcomeToXboxLiveMessage);
                        break;
                    default:
                        return;
                }

                if (dwWelcomeMessage != 0)
                {
                    CUserMessage sysmsg = new CUserMessage(
                        0, // sender = 0, means xbox live
                        0, // sender context
                        MsgDefs.XONLINE_MSG_FLAG_RECOMMENDED,
                        XOn.DASH_TITLE_ID,
                        0, // expire minutes = default
                        MsgDefs.XONLINE_MSG_TYPE_LIVE_MESSAGE,
                        "LIVE System");

                    sysmsg.AddRecipient(m_request.qwUserID);
                    sysmsg.AddProperty(MsgDefs.XONLINE_MSG_PROP_SYSTEM_TEXT, dwWelcomeMessage);

                    sysmsg.Send();
                }
            }
            catch (Exception e)
            {
                Xom.NtEvent(XEvent.Id.PRESENCE_WELCOME_MESSAGE_ERROR, e, "SendWelcomeMessage threw an exception.");
            }
        }

        // -------------------------------------------------------------------------------
        // UpdateLicenseTransferDestConsole - update user license transfer destination machine
        // -------------------------------------------------------------------------------
        private void UpdateLicenseTransferDestConsole()
        {
            try
            {
                // only call this sproc when UserCommerceDB is enabled to avoid calling UODB
                if (SGInfo.Current.MachineId != 0 && ConfigUtil.GetUserCommerceWebstoreApp() == ConfigUtil.UserCommercedbWebstoreApp)
                {
                    using (WSClient ws = new WSClient(ConfigUtil.GetUserCommerceWebstoreApp(), CmdType.WRITEONLY_COMMANDTYPE))
                    {
                        // Data is partitioned by user puid
                        ws.PartitionType = WstPartitionType.Logical;
                        ws.SetHashVal(m_request.qwUserID);
                        ws.StoredProc = "dbo.p_user_license_transfer_set_destination_console";

                        ws.AddParameter(ParamType.RETVAL, "@hr", 0);
                        ws.AddParameter("@bi_xuid", m_request.qwUserID);
                        ws.AddParameter("@bi_destination_machine_puid", SGInfo.Current.MachineId);

                        ws.ExecuteNonQuery();
                    }
                }
            }
            catch (Exception e)
            {
                Xom.NtEvent(XEvent.Id.PRESENCE_LICENSE_MIGRATION_ERROR, e, "UpdateLicenseTransferDestConsole threw an exception.");
            }
        } // UpdateLicenseTransferDestConsole

        private void SProcAlive()
        {
            SGInfo sginfo = SGInfo.Current;

            // call the alive sproc.
            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.StoredProc = "dbo.p_pres_alive_V2";
                ws.Partition = ws.CalcPartition(m_qwUserID);

                ws.AddParameter(ParamType.RETVAL, "@RETVAL", 0);
                ws.AddParameter("@bi_user_puid", m_qwUserID);
                ws.AddParameter("@vc_client_gamertag", m_request.szAcctName);
                ws.AddParameter("@i_client_friend_list_ver", m_request.dwBuddyListVersion);
                ws.AddParameter("@i_client_lockout_list_ver", m_request.dwBlockListVersion);
                ws.AddParameter("@i_title_id", sginfo.TitleId);
                ws.AddParameter("@i_title_alt_id1", sginfo.AltTitleId1);
                ws.AddParameter("@i_title_alt_id2", sginfo.AltTitleId2);
                ws.AddParameter("@i_title_alt_id3", sginfo.AltTitleId3);
                ws.AddParameter("@i_title_alt_id4", sginfo.AltTitleId4);
                ws.AddParameter("@i_title_region", sginfo.TitleRegion);
                ws.AddParameter("@vc_ip_address", sginfo.ClientIP.ToString());
                ws.AddParameter(ParamType.OUTPUT, "@f_name_changed", (uint)0);
                ws.AddParameter(ParamType.OUTPUT, "@f_need_messaging_write", (uint)0);
                ws.AddParameter("@bi_machine_puid", sginfo.MachineId);

                WstDataReader reader = ws.Execute();
                //This part is interesting, Execute above calls ExecuteReader and one of the problems with
                //ExecuteReader is that unless the Reader is closed or iterated through completely
                //the return value is not properly returned. Nice, isn't it?
                //Keeping the old version here in case no rows come back
                m_response.hr = (uint)ws.GetIntParameter("@RETVAL");

                //For this error no rows should be returned, so OK to check here
                if (m_response.hr == HResult.XONLINE_E_NOTIFICATION_FLUSH_TICKETS)
                {
                    // fail this call to "force" ticket flush and re-logon.
                    return;
                }

                //For anything other than XONLINE_E_LOGON_USER_ACCOUNT_REQUIRES_MANAGEMENT no rows should be returned
                //so OK to check here. Refer to p_pres_alive_V2 stored proc.
                if (HResult.Failed(m_response.hr) &&
                    (m_response.hr != HResult.XONLINE_E_LOGON_USER_ACCOUNT_REQUIRES_MANAGEMENT))
                {
                    throw new XRLException(m_response.hr, XEvent.Id.PRESENCE_ALIVE_DB_READ_ERROR,
                        "p_pres_alive_V2 return failure.");
                }

                // read the first result set.
                if (reader.HasRows && reader.Read())
                {
                    m_response.dwBuddyListVersion = (uint)reader.GetInt32(0);
                    m_response.dwBlockListVersion = (uint)reader.GetInt32(1);
                    reader.GetBytes(4, 0, m_rgbPrivileges, 0, m_rgbPrivileges.Length);
                    m_firstLogin = reader.GetInt32(5);
                    reader.NextResult();
                }
                else
                {
                    throw new XRLException(HResult.XONLINE_E_DATABASE_RESULT_ERROR, XEvent.Id.PRESENCE_ALIVE_DB_READ_ERROR,
                        "No initial result returned from p_pres_alive_V2.");
                }

                if (m_response.dwBuddyListVersion != m_request.dwBuddyListVersion)
                {
                    // read the new count of friends.
                    int friendCount;
                    if (reader.HasRows && reader.Read())
                    {
                        friendCount = reader.GetInt32(0);
                        reader.NextResult();
                    }
                    else
                    {
                        throw new XRLException(HResult.XONLINE_E_DATABASE_RESULT_ERROR, XEvent.Id.PRESENCE_ALIVE_DB_READ_ERROR,
                            "No friend count returned from p_pres_alive_V2.");
                    }

                    // read the friends.
                    m_response.rgReplyBuddies = new ReplyBuddy[friendCount];
                    int iBuddy = 0;
                    while (reader.HasRows && reader.Read())
                    {
                        m_response.rgReplyBuddies[iBuddy] = new ReplyBuddy();
                        m_response.rgReplyBuddies[iBuddy].qwBuddyID = (ulong)reader.GetInt64(0);
                        m_response.rgReplyBuddies[iBuddy].szAcctName = reader.GetString(1);
                        m_response.rgReplyBuddies[iBuddy].bStatus = reader.GetByte(2);
                        iBuddy++;
                    }
                    reader.NextResult();

                    if (iBuddy != friendCount)
                    {
                        throw new XRLException(HResult.XONLINE_E_DATABASE_RESULT_ERROR, XEvent.Id.PRESENCE_ALIVE_DB_READ_ERROR,
                            "Not enough friends returned from p_pres_alive_V2: {0} != {1}" , iBuddy, friendCount);
                    }
                }

                // compare the mute list.  sometimes this is called blocks, but here we mean mutes.
                if (m_response.dwBlockListVersion != m_request.dwBlockListVersion)
                {
                    // read the new count of mutes.
                    int muteCount;
                    if (reader.HasRows && reader.Read())
                    {
                        muteCount = reader.GetInt32(0);
                        reader.NextResult();
                    }
                    else
                    {
                        throw new XRLException(HResult.XONLINE_E_DATABASE_RESULT_ERROR, XEvent.Id.PRESENCE_ALIVE_DB_READ_ERROR,
                            "No mute count returned from p_pres_alive_V2.");
                    }

                    // read the mutes.
                    m_response.rgqwBlockIDs = new ulong[muteCount];
                    int iMute = 0;
                    while (reader.HasRows && reader.Read())
                    {
                        m_response.rgqwBlockIDs[iMute] = (ulong)reader.GetInt64(0);
                        iMute++;
                    }
                    reader.NextResult();

                    if (iMute != muteCount)
                    {
                        throw new XRLException(HResult.XONLINE_E_DATABASE_RESULT_ERROR, XEvent.Id.PRESENCE_ALIVE_DB_READ_ERROR,
                            "Not enough friends returned from p_pres_alive_V2: {0} != {1}", iMute , muteCount);
                    }
                }

                // always read the never list.  sometimes these are called blocks (as in block communications).
                // we call it the never list, as that does not interfere with mutes which are also sometimes referred to as blocks.
                // read the new count of nevers.
                int neverCount;
                if (reader.HasRows && reader.Read())
                {
                    neverCount = reader.GetInt32(0);
                    reader.NextResult();
                }
                else
                {
                    throw new XRLException(HResult.XONLINE_E_DATABASE_RESULT_ERROR, XEvent.Id.PRESENCE_ALIVE_DB_READ_ERROR,
                        "No never count returned from p_pres_alive_V2.");
                }

                // read the nevers.
                m_neverList = new NeverList();
                m_neverList.OwnerID = m_request.qwUserID;
                m_neverList.rgNevers = new ulong[neverCount];
                int iNever = 0;
                while (reader.HasRows && reader.Read())
                {
                    m_neverList.rgNevers[iNever] = (ulong)reader.GetInt64(0);
                    iNever++;
                }
                reader.NextResult();

                if (iNever != neverCount)
                {
                    throw new XRLException(HResult.XONLINE_E_DATABASE_RESULT_ERROR, XEvent.Id.PRESENCE_ALIVE_DB_READ_ERROR,
                        "Not enough nevers returned from p_pres_alive_V2: {0} != {1}" , iNever, neverCount);
                }

                // apparently you can only read output parameters after all rowsets are read.
                while (reader.NextResult());
                m_fNameChanged = (0 != (int)ws.GetIntParameter("@f_name_changed"));

                //And for the same reason the hr returned would also need to be set.
                //We should get here ONLY for the XONLINE_S_LOGON_USER_HAS_MESSAGE or XONLINE_S_LOGON_USER_MESSAGE_ENUMERATION_NEEDED cases
                //or the REQUIRES_MANAGEMENT cases. Check the sproc for details. We can safely overwrite and return to caller
                m_response.hr = (uint)ws.GetIntParameter("@RETVAL");
            }
        }

        private void VerifyLoginGamertag()
        {
            if (m_request.szAcctName.Length >= PresDefs.XONLINE_GAMERTAG_SIZE)
            {
                throw new XRLException(HResult.E_INVALIDARG, XEvent.Id.PRESENCE_LOGIN_NAME_MISMATCH,
                    "Alive sent with gamertag length too large: " + m_request.szAcctName.Length);
            }

            // dev/test kits are exempt from this check.
            if (0 != (SGInfo.Current.AuthDataFlags & (SGInfo.XONLINE_AUTHDATA_FLAGS_ISDEVKIT | SGInfo.XONLINE_AUTHDATA_FLAGS_ISTESTKIT)))
            {
                return;
            }

            /*
            // xonwatch ips check is no longer necessary, now that we exempt brand new accounts as well.
            // this is commented out because it generates a compiler error due to use of deprecated IPAddress.Address.

            // xonwatch ips are exempt from this check.
            string sXonWatchIps = Config.GetSetting(Setting.presence_XonWatchIPs);
            string[] rgsXonWatchIps = sXonWatchIps.Split(new string[]{", ", "; "}, StringSplitOptions.None);

            for (int iIp = 0; iIp < rgsXonWatchIps.Length / 2; iIp++)
            {
                IPAddress ip = IPAddress.Parse(rgsXonWatchIps[iIp * 2]);
                IPAddress mask = IPAddress.Parse(rgsXonWatchIps[(iIp * 2) + 1]);

                if ((sginfo.ClientIP.Address & mask.Address) == (ip.Address & mask.Address))
                {
                    return;
                }
            }
            */

            // get the correct gamertag from xcache.
            string sXCacheGamertag = XCache.LookupGamerTag(m_qwUserID);

            if (sXCacheGamertag == XCache.InvalidGamertag)
            {
                // no gamertag found for this userid?  probably a new account that xcache hasnt picked up yet.
                // if the user is really invalid, xpserver will figure it out.
                return;
            }

            if (sXCacheGamertag.ToUpper() != m_request.szAcctName.ToUpper())
            {
                throw new XRLException(HResult.XONLINE_E_LOGON_INVALID_USER, XEvent.Id.PRESENCE_LOGIN_NAME_MISMATCH,
                    "Logon gamertag ({0}) does not match XCache user lookup ({1}) for userID {2}.  This may be due to a gamertag purchase or FNC.  If this problem persists for a particular user, that user may be attempting to spoof his gamertag.",
                    m_request.szAcctName, sXCacheGamertag, (Puid)m_qwUserID);
            }

            // just overrule the user with what XCache says.
            m_request.szAcctName = sXCacheGamertag;
        }


        //-----------------------------------------------------------------------------------
        // Handle errors during processing
        //-----------------------------------------------------------------------------------
        public override HResult ProcessError(HResult hr)
        {
            //Since an error has occurred reset the response to be certain
            m_response = new PresenceAliveReply();
            m_response.header.dwSeqNum = m_header.dwSeqNum;
            m_response.header.sgaddr = m_header.sgaddr;
            // Put the hresult in the response
            m_response.hr = hr;

            if (m_presenceRecord != null)
            {
                PresenceUtil.KillUser(m_presenceRecord);
            }

            return HResult.S_OK;
        }

        //-----------------------------------------------------------------------------------
        // Log the activity
        //-----------------------------------------------------------------------------------
        public override void LogResults()
        {
            Xom.Log(XomAreaName.PresenceLog,
                "ALV|{0}|{1:X}|{2:X}|{3:X}|{4}|{5}|{6:X}|{7:X}|{8:X}|{9:X}|{10}",
                (Puid)m_request.header.sgaddr.qwXboxId,
                m_request.liNonce,
                m_request.header.sgaddr.inaSg,
                m_request.header.sgaddr.dwSpiSg,
                (Puid)m_request.qwUserID,
                (TitleId)m_request.dwTitleID,
                m_request.dwTitleVersion,
                m_request.dwTitleRegion,
                SGInfo.Current.ClientPort,
                BitConverter.ToUInt32(SGInfo.Current.ClientIP.GetAddressBytes(), 0),
                m_response.hr);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\fd\Invite.cs ===
ï»¿//
// GetMessageDetails.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Xbox Online Service
//
using System;
using System.Collections;
using System.IO;
using System.Text;
using System.Web;
using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.protocol;
using xonline.common.service;
using xonline.common.community;
using Microsoft.Webstore.WstClient;

namespace xonline.server.presence.fd
{

    //-----------------------------------------------------------------------------------
    // Process Invite2 requests
    //-----------------------------------------------------------------------------------
    public class Invite2Handler : PresenceHandlerBase
    {
        //-----------------------------------------------------------------------------------
        // Private data
        //-----------------------------------------------------------------------------------
        private PresenceInviteUser2Msg m_request;

        //-----------------------------------------------------------------------------------
        // Constructor
        //-----------------------------------------------------------------------------------
        public Invite2Handler(BaseHeader header)
            : base(header)
        {
            m_request = new PresenceInviteUser2Msg();
        }

        //-----------------------------------------------------------------------------------
        // Give the superclass access to the response
        //-----------------------------------------------------------------------------------
        protected override XRLObject2 GetResponse()
        {
            return null;
        }

        private bool GetInviteSessionID(out ulong qwSessionID)
        {
            if (m_request.details != null)
            {
                byte[] rgbProp = MessagingUtil.GetMessageProperty(MsgDefs.XONLINE_MSG_PROP_SESSION_ID, m_request.details);
                if (rgbProp != null && rgbProp.Length == sizeof(ulong))
                {
                    qwSessionID = BitConverter.ToUInt64(rgbProp, 0);
                    return true;
                }
            }
            qwSessionID = 0;
            return false;
        }

        //-----------------------------------------------------------------------------------
        // Process the incoming request and generate the response
        //-----------------------------------------------------------------------------------
        public override void ProcessRequest()
        {
            // Deserialize the incoming stream
            m_request.ReadStream(new BinaryReader(HttpContext.Current.Request.InputStream));

            // Get the presence record for the sender
            PresenceRecord senderPresence = PresenceUtil.GetPresenceRecord(m_request.qwUserID);
            if (senderPresence == null)
            {
                throw new XRLException(
                    HResult.E_INVALIDARG,
                    XEvent.Id.PRESENCE_INVITE_SENDER_INVALID_USERID, 
                    "Failed to retrieve presence record for user={0}",
                    (Puid)m_request.qwUserID
                    );
            }
            if (!senderPresence.IsOnline())
            {
                throw new XRLException(
                    HResult.E_INVALIDARG,
                    XEvent.Id.PRESENCE_INVITE_SENDER_IS_OFFLINE,
                    "Sender user={0} is marked as offline",
                    (Puid)m_request.qwUserID
                    );
            }
            ulong qwSessionID;
            if (!GetInviteSessionID(out qwSessionID) || qwSessionID == 0)
            {
                throw new XRLException(
                    HResult.E_INVALIDARG,
                    XEvent.Id.PRESENCE_INVITE_MISSING_SESSION_ID,
                    "User={0} sent an invitation without a valid session ID", 
                    (Puid)m_request.qwUserID
                    );
            }
            if (m_request.rgqwInvitees.Length == 0 || m_request.rgqwInvitees.Length > MsgDefs.XONLINE_MAX_MESSAGE_RECIPIENTS)
            {
                throw new XRLException(
                    HResult.E_INVALIDARG,
                    XEvent.Id.PRESENCE_INVITE_BAD_NUMBER_INVITEES,
                    "User={0} sent an invitation to a bad number of invitees: {1}",
                    (Puid)m_request.qwUserID, m_request.rgqwInvitees.Length
                    );
            }

            ulong[] qwRecipientIDs = PresenceUtil.CreateOrAddInvite(m_request.qwUserID, m_request.dwTitleID, qwSessionID, m_request.rgqwInvitees);
            if (qwRecipientIDs != null && qwRecipientIDs.Length > 0)
            {
                MsgReqInternal request = new MsgReqInternal();
                RecipientResult[] results = null;
                HResult hr = request.SendMessage(
                    m_request.qwUserID, 
                    senderPresence.sGamertag, 
                    m_request.dwTitleID, 
                    m_request.qwSenderContext, 
                    m_request.dwMessageFlags,
                    MessagingUtil.GetMessageExpiration(MsgDefs.XONLINE_MSG_TYPE_GAME_INVITE),
                    MsgDefs.XONLINE_MSG_TYPE_GAME_INVITE,
                    m_request.rgqwInvitees, 
                    m_request.details, 
                    out results);
            }
        }

        //-----------------------------------------------------------------------------------
        // Handle errors during processing
        //-----------------------------------------------------------------------------------
        public override HResult ProcessError(HResult hr)
        {
            // Put the hresult in the response
            return HResult.S_OK;
        }

        //-----------------------------------------------------------------------------------
        // Log the activity
        //-----------------------------------------------------------------------------------
        public override void LogResults()
        {
            StringBuilder sb = new StringBuilder();
            foreach (ulong xuid in m_request.rgqwInvitees)
            {
                sb.AppendFormat("{0};", (Puid)xuid);
            }
            Xom.Log(XomAreaName.PresenceLog,
                "INV|{0}|{1:X}|{2:X}|{3}|{4}|{5}",
                (Puid)m_request.header.sgaddr.qwXboxId,
                m_request.header.sgaddr.inaSg,
                m_request.header.sgaddr.dwSpiSg,
                (Puid)m_request.qwUserID,
                (TitleId)m_request.dwTitleID,
                sb.ToString());
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\fd\MuteList.cs ===
using System;
using System.IO;
using System.Web;
using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.protocol;
using xonline.common.service;
using xonline.common.community;
using xonline.common.sql.webstore;
using Microsoft.Webstore.WstClient;

namespace xonline.server.presence.fd
{

    internal class MuteUserHandler : PresenceHandlerBase
    {
        private PresenceMuteUserMsg _request;
        private uint _hr;

        public MuteUserHandler(BaseHeader header)
            : base(header)
        {
            _request = new PresenceMuteUserMsg();
        }

        public override void ProcessRequest()
        {
            //Parse out the request
            _request.ReadStream(new BinaryReader(HttpContext.Current.Request.InputStream));

            // User id of 0 check is not necessary since PresenceHandlerBase calls it
            // If that code ever changes we need to check 0 user id scenario here too.

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                // Call the sproc
                ws.StoredProc = "dbo.p_pres_add_lockout";
                ws.Partition = ws.CalcPartition(_request.qwUserID);
                ws.AddParameter(ParamType.RETVAL, "@RETVAL", 0);
                ws.AddParameter("@bi_user_puid", _request.qwUserID);
                ws.AddParameter("@bi_lockout_puid", _request.qwBlockID);

                WstDataReader wsReader = ws.Execute();

                // discard all the result sets.
                while (wsReader.HasRows && wsReader.Read() && wsReader.NextResult())
                {
                }

                _hr = (uint)ws.GetIntParameter("@RETVAL");
            }

            if (_hr != HResult.S_OK)
            {
                throw new XRLException(_hr, XEvent.Id.PRESENCE_MUTELIST_ADD_ERROR, 
                    "MuteUser: failed to add user to mute list.  userid: {0}, targetid: {1}, hr: {2}",
                    (Puid)_request.qwUserID,
                   (Puid)_request.qwBlockID,
                    _hr);
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="hr">Error return code</param>
        public override HResult ProcessError(HResult hr)
        {
            _hr = hr;
            return HResult.S_OK;
        }

        /// <summary>
        /// 
        /// </summary>
        public override void LogResults()
        {
            Xom.Log(XomAreaName.PresenceLog, "Mute|{0}:{1:X}|{2}|{3}|{4}",
                    SGInfo.Current.ClientIP,
                    SGInfo.Current.ClientPort,
                    (Puid)_request.qwUserID,
                    (Puid)_request.qwBlockID,
                    _hr);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <returns>Base class that derives from XRLObject2</returns>
        protected override XRLObject2 GetResponse()
        {
            return null;
        }
    }

    internal class UnmuteUserHandler : PresenceHandlerBase
    {
        private PresenceUnmuteUserMsg _request;
        private uint _hr;

        public UnmuteUserHandler(BaseHeader header)
            : base(header)
        {
            _request = new PresenceUnmuteUserMsg();
        }

        public override void ProcessRequest()
        {
            //Parse out the request
            _request.ReadStream(new BinaryReader(HttpContext.Current.Request.InputStream));

            // User id of 0 check is not necessary since PresenceHandlerBase calls it
            // If that code ever changes we need to check 0 user id scenario here too.

            if (_request.qwBlockID == 0)
            {
                using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
                {
                    // Call the sproc
                    ws.StoredProc = "dbo.p_pres_clear_lockout_list";
                    ws.Partition = ws.CalcPartition(_request.qwUserID);
                    ws.AddParameter(ParamType.RETVAL, "@RETVAL", 0);
                    ws.AddParameter("@bi_user_puid", _request.qwUserID);

                    WstDataReader wsReader = ws.Execute();

                    // discard all the result sets.
                    while (wsReader.HasRows && wsReader.Read() && wsReader.NextResult())
                    {
                    }

                    _hr = (uint)ws.GetIntParameter("@RETVAL");
                }
            }
            else
            {
                using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
                {
                    // Call the sproc
                    ws.StoredProc = "dbo.p_pres_delete_lockout";
                    ws.Partition = ws.CalcPartition(_request.qwUserID);
                    ws.AddParameter(ParamType.RETVAL, "@RETVAL", 0);
                    ws.AddParameter("@bi_user_puid", _request.qwUserID);
                    ws.AddParameter("@bi_lockout_puid", _request.qwBlockID);

                    WstDataReader wsReader = ws.Execute();

                    // discard all the result sets.
                    while (wsReader.HasRows && wsReader.Read() && wsReader.NextResult())
                    {
                    }

                    _hr = (uint)ws.GetIntParameter("@RETVAL");
                }
            }
            
            if (_hr != HResult.S_OK)
            {
                throw new XRLException(_hr, XEvent.Id.PRESENCE_MUTELIST_DELETE_ERROR, 
                    "MuteUser: failed to remove user from mute list.  userid: {0}, targetid: {1}, hr: {2}",
                    (Puid)_request.qwUserID,
                    (Puid)_request.qwBlockID,
                    _hr);
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="hr">Error return code</param>
        public override HResult ProcessError(HResult hr)
        {
            _hr = hr;
            return HResult.S_OK;
        }

        /// <summary>
        /// 
        /// </summary>
        public override void LogResults()
        {
            Xom.Log(XomAreaName.PresenceLog, "Unmute|{0}:{1:X}|{2}|{3}|{4}",
                    SGInfo.Current.ClientIP,
                    SGInfo.Current.ClientPort,
                    (Puid)_request.qwUserID,
                    (Puid)_request.qwBlockID,
                    _hr);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <returns>Base class that derives from XRLObject2</returns>
        protected override XRLObject2 GetResponse()
        {
            return null;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\fd\PresenceHandlerBase.cs ===
ï»¿//
// PresenceHandlerBase.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Xbox Online Service
//
// Author: dberke
//
using System;
using System.IO;
using System.Text;
using System.Threading;
using System.Web;
using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.protocol;
using xonline.common.service;

namespace xonline.server.presence.fd
{
    //-----------------------------------------------------------------------------------
    // Base class for presence service handlers
    //-----------------------------------------------------------------------------------
    public abstract class PresenceHandlerBase
    {
        //-----------------------------------------------------------------------------------
        // Functions to be implemented is the specific subclasses
        //-----------------------------------------------------------------------------------
        public    abstract void       ProcessRequest();
        public    abstract HResult    ProcessError(HResult hr);
        public    abstract void       LogResults();
        protected abstract XRLObject2 GetResponse();

        //-----------------------------------------------------------------------------------
        // member data
        //-----------------------------------------------------------------------------------
        public BaseHeader m_header;
        public ulong m_qwUserID;
        public bool        m_bIsDatacenter;
        public bool        m_bIsProcessed;

        //-----------------------------------------------------------------------------------
        // Constructor
        //-----------------------------------------------------------------------------------
        protected PresenceHandlerBase(BaseHeader header)
        {
            m_header = header;
        }


        //-----------------------------------------------------------------------------------
        // Get the handler based on message type
        //-----------------------------------------------------------------------------------
        public static void GetHandler(out PresenceHandlerBase handler)
        {
            // Save the starting position of the stream
            long streamStartPos = HttpContext.Current.Request.InputStream.Position;
            handler = null;

            try
            {
                BaseHeader header = ReadHeader(HttpContext.Current);

                switch(header.dwMsgType) 
                {
                case (uint)P_MSG_TYPES.PMSG_ALIVE_2:
                    handler = new Alive2Handler(header);
                    break;
                case (uint)P_MSG_TYPES.PMSG_ADD:
                case (uint)P_MSG_TYPES.PMSG_ADD_2:
                    handler = new FriendAddHandler(header);
                    break;
                case (uint)P_MSG_TYPES.PMSG_ACCEPT:
                    handler = new FriendAcceptHandler(header);
                    break;
                case (uint)P_MSG_TYPES.PMSG_REJECT:
                    handler = new FriendRejectHandler(header);
                    break;
                case (uint)P_MSG_TYPES.PMSG_DELETE:
                    handler = new FriendDeleteHandler(header);
                    break;
                case (uint)P_MSG_TYPES.PMSG_GET_FRIENDS_LIST:
                    handler = new GetFriendsListHandler(header);
                    break;
                case (uint)P_MSG_TYPES.PMSG_WEB_FRIENDS:
                    handler = new GetWebFriendsListHandler(header);
                    break;
                case (uint)P_MSG_TYPES.PMSG_GET_FRIENDS_NO_PRESENCE:
                    handler = new GetFriendsNoPresenceHandler(header);
                    break;
                case (uint)P_MSG_TYPES.PMSG_GET_FRIENDS_LIMITED_PRESENCE:
                    handler = new GetFriendsLimitedPresenceHandler(header);
                    break;
                case (uint)P_MSG_TYPES.PMSG_DEAD_USER:
                    handler = new DeadUserHandler(header);
                    break;
                case (uint)P_MSG_TYPES.PMSG_LOGON_CHECK:
                    handler = new LogonCheckHandler(header);
                    break;
                case (uint)P_MSG_TYPES.PMSG_INVITE_2:
                    handler = new Invite2Handler(header);
                    break;
                case (uint)Q_MSG_TYPES.QMSG_DEQUEUE:
                    handler = new DequeueHandler(header);
                    break;
                case (uint)P_MSG_TYPES.PMSG_FIND_USER:
                    handler = new FindUserHandler(header);
                    break;
                case (uint)P_MSG_TYPES.PMSG_FIND_USERS:
                    handler = new FindUsersHandler(header);
                    break;
                case (uint)P_MSG_TYPES.PMSG_GET_PRESENCE_INFO:
                    handler = new GetPresenceInfoHandler(header);
                    break;
                case (uint)P_MSG_TYPES.PMSG_INVITE_ANSWER:
                    handler = new InviteAnswerHandler(header);
                    break;
                case (uint)P_MSG_TYPES.PMSG_CANCEL:
                    handler = new CancelInviteHandler(header);
                    break;
                case (uint)P_MSG_TYPES.PMSG_MUTE:
                    handler = new MuteUserHandler(header);
                    break;
                case (uint)P_MSG_TYPES.PMSG_UNMUTE:
                    handler = new UnmuteUserHandler(header);
                    break;
                case (uint)P_MSG_TYPES.PMSG_INVALIDATE_USER:
                    handler = new InvalidateUserHandler(header);
                    break;
                case (uint)P_MSG_TYPES.PMSG_KICK:
                    handler = new KickHandler(header);
                    break;
                case (uint)P_MSG_TYPES.PMSG_PURGE_USER:
                    handler = new PurgeUserHandler(header);
                    break;
                case (uint)P_MSG_TYPES.PMSG_ADD_AFFILIATES:
                    handler = new AddAffiliatesHandler(header);
                    break;
                case (uint)P_MSG_TYPES.PMSG_QUERY_AFFILIATES:
                    handler = new QueryAffiliatesHandler(header);
                    break;
                case (uint)P_MSG_TYPES.PMSG_IS_AFFILIATE:
                    handler = new IsAffiliateHandler(header);
                    break;
                case (uint)P_MSG_TYPES.PMSG_WEB_ALIVE:
                    handler = new WebAliveHandler(header);
                    break;
                case (uint)P_MSG_TYPES.PMSG_WEB_ALIVE2:
                    handler = new WebAlive2Handler(header);
                    break;
                case (uint)P_MSG_TYPES.PMSG_ADD_USERS_TO_NEVERLIST:
                    handler = new AddUsersToNeverListHandler(header);
                    break;
                case (uint)P_MSG_TYPES.PMSG_REMOVE_USERS_FROM_NEVERLIST:
                    handler = new RemoveUsersFromNeverListHandler(header);
                    break;
                case (uint)P_MSG_TYPES.PMSG_CAN_SEND_MESSAGE:
                    handler = new CanSendMessageToUsersHandler(header);
                    break;
                    
                case (uint)P_MSG_TYPES.PMSG_STATE_2:
                case (uint)P_MSG_TYPES.PMSG_GET_STATE:
                case (uint)P_MSG_TYPES.PMSG_DEAD_XBOX:
                case (uint)P_MSG_TYPES.PMSG_DEAD_SG:
                    break;

                // Unsupported message types from Xbox V1:
                case (uint)P_MSG_TYPES.PMSG_CHECK_TITLE_MESSAGES:
                case (uint)P_MSG_TYPES.PMSG_PEER_SESSION:
                    break;
                }

                if (handler == null)
                {
                    throw new XRLException(HResult.E_INVALIDARG, XEvent.Id.PRESENCE_UNKNOWN_MESSAGE_TYPE,
                        "presencefd: Unknown message type {0}", header.dwMsgType);
                }

                handler.m_header = header;
                
                // Perform required validations
                handler.CheckSource();
                handler.ValidateHeader();
            }
            finally
            {
                // Reset the stream position
                HttpContext.Current.Request.InputStream.Position = streamStartPos;
            }
        }

        //-----------------------------------------------------------------------------------
        // Read the header
        //-----------------------------------------------------------------------------------
        private static BaseHeader ReadHeader(HttpContext httpCtx)
        {
            BaseHeader header = new BaseHeader();
            BinaryReader reader = new BinaryReader(httpCtx.Request.InputStream);
            
            long dwBytesLeft = httpCtx.Request.InputStream.Length - httpCtx.Request.InputStream.Position;
            if(dwBytesLeft < header.Size())
            {
                throw new XRLException(HResult.XONLINE_E_NOTIFICATION_MESSAGE_TRUNCATED, XEvent.Id.PRESENCE_HEADER_TRUNCATED,
                                       "presencefd: Message is too short for header.");
            }

            // Read in the header
            header.ReadStream(reader);

            return header;
        }

        //-----------------------------------------------------------------------------------
        // Send the response to the caller
        //-----------------------------------------------------------------------------------
        public void WriteResponse(MemoryStream stream)
        {
            XRLObject2 resp = GetResponse();
            if (resp != null)
            {
                byte[] rgbResp = (byte[])resp; 
                stream.Write(rgbResp, 0, rgbResp.Length);
            }
        }

        //-----------------------------------------------------------------------------------
        // Validate the call source
        //-----------------------------------------------------------------------------------
        private void CheckSource()
        {
            // Check the port the request came from
            // For some reason, HttpContext.Request.Url is rather slow.
            // To help us out, xrlscan has dropped the request port into an
            // HTTP header, which seems to be quicker than getting the port
            // out of the URL. If the header is there, use it.
            ushort wPortUsed;
            string serverPort = HttpContext.Current.Request.Headers["ServerPort"];
            if (serverPort != null)
            {
                // Strangely, while the REMOTE_PORT server variable returns the port in network
                // order, so we have to byte swap it, the SERVER_PORT server variable returns
                // the port in host order, so no byte swap is required. Very confusing.
                wPortUsed = Convert.ToUInt16(serverPort);
            } 
            else
            {
                wPortUsed = (ushort)HttpContext.Current.Request.Url.Port;
            }

            string viface = VirtualInterface.None;
            if (CallSource.IsVirtualInterfacePort(VirtualInterface.xpnfd_presence, wPortUsed))
            {
                viface = VirtualInterface.xpnfd_presence;
                m_bIsDatacenter = false;
            }
            else if (CallSource.IsVirtualInterfacePort(VirtualInterface.xpnfd_presence_int, wPortUsed))
            {
                viface = VirtualInterface.xpnfd_presence_int;
                m_bIsDatacenter = true;
            }

            if (viface == VirtualInterface.None)
            {
                throw new XRLException(HResult.XONLINE_E_NOTIFICATION_ERROR, XEvent.Id.PRESENCE_NO_VINTERFACE,
                    "presencefd.CheckSource: Could not determine virtual interface for port " + wPortUsed);
            }

            CallSource.Set(HttpContext.Current, viface);

            Xom.Trace(XomAreaName.PresenceFDDebug, LogLevel.L_LOW, "presencefd.CheckSource: vinterface={0}", viface);
        }

        //-----------------------------------------------------------------------------------
        // Validate data in the header - message length, type, etc.
        //-----------------------------------------------------------------------------------
        private void ValidateHeader()
        {
            // Validate service request on XRL post
            if (!XRLUtil.IsValidXOnlineRequest(HttpContext.Current.Request, XOService.PresNotification))
            {
                throw new XRLException(HResult.XONLINE_E_BAD_CONTENT_TYPE, XEvent.Id.PRESENCE_BAD_CONTENT_TYPE,
                    "presencefd.ValidateHeader: Content-Type in request is incorrect " +
                    "User-Agent: " + HttpContext.Current.Request.UserAgent +
                    ", Content-Type: " + HttpContext.Current.Request.ContentType +
                    ", Expected: " + (uint)XOService.PresNotification);
            }

            // we already read the header.  inputstream should be pointing at the point right after it.
            BinaryReader reader = new BinaryReader(HttpContext.Current.Request.InputStream);
            long dwBytesLeft = HttpContext.Current.Request.InputStream.Length - HttpContext.Current.Request.InputStream.Position;

            // Make sure there is enough room for the request
            if (dwBytesLeft < m_header.dwMsgLen)
            {
                throw new XRLException(HResult.XONLINE_E_NOTIFICATION_MESSAGE_TRUNCATED, XEvent.Id.PRESENCE_REQUEST_TRUNCATED,
                                      "presencefd.HandleRequest: Message is too short for request." );
            }

            if (IsUserMessageType(m_header.dwMsgType))
            {
                // Make sure there is enough room to read the user ID
                if (m_header.dwMsgLen < 8)
                {
                    throw new XRLException(HResult.XONLINE_E_NOTIFICATION_MESSAGE_TRUNCATED, XEvent.Id.PRESENCE_NOTIFICATION_MESSAGE_TRUNCATED,
                                           "presencefd.ValidateHeader: Message is too short for userId.");
                }

                // Read user ID
                m_qwUserID = reader.ReadUInt64();

                // Can't get a connection without a PUID
                if (m_qwUserID == 0 && m_bIsDatacenter == false)
                {
                    throw new XRLException(HResult.E_INVALIDARG/*HResult.XONLINE_E_NOTIFICATION_INVALID_PUID*/, XEvent.Id.PRESENCE_INVALID_USERID,
                                          "presencefd.ValidateHeader: User PUID is zero. type {0}, sg {1:X}, spi {2:X}, xb {3}", 
                                                         m_header.dwMsgType, m_header.sgaddr.inaSg, m_header.sgaddr.dwSpiSg,
                                                         (Puid)m_header.sgaddr.qwXboxId);
                }

                if ((0xffffffffffffffff == m_qwUserID))
                {
                    throw new XRLException(HResult.XONLINE_E_NOTIFICATION_INVALID_PUID, XEvent.Id.PRESENCE_INVALID_USERID,  
                                           "presencefd.ValidateHeader: User PUID is 0xffffffffffffffff. type {0}, sg {1:X}, spi {2:X}, xb {3}", 
                                                         m_header.dwMsgType, m_header.sgaddr.inaSg, m_header.sgaddr.dwSpiSg,
                                                         (Puid)m_header.sgaddr.qwXboxId);
                }
            }

            // We relax several restrictions for calls on the datacenter port
            if (m_bIsDatacenter)
            {
                //  Make sure that this message was sent to the right place
                if (IsDatacenterMessageType(m_header.dwMsgType) == false)
                {
                    throw new XRLException(HResult.XONLINE_E_NOTIFICATION_INVALID_MESSAGE_TYPE, XEvent.Id.PRESENCE_INVALID_DC_MESSAGE_TYPE,
                                           "presencefd.ValidateHeader: Invalid datacenter message type " + m_header.dwMsgType);                    
                }
            }
            else
            {
                //  Make sure that this message was sent to the right place
                if (IsClientMessageType(m_header.dwMsgType) == false)
                {
                    throw new XRLException(HResult.XONLINE_E_NOTIFICATION_INVALID_MESSAGE_TYPE, XEvent.Id.PRESENCE_INVALID_CLIENT_MESSAGE_TYPE,
                                           "presencefd.ValidateHeader: Invalid client message type " + m_header.dwMsgType);                    
                }

                // Do we authenticate this type of message?
                if (IsAuthMessageType(m_header.dwMsgType))
                {
                    CheckSgInfo();
                }
            }
        }

        private void CheckSgInfo()
        {
            // Get the sgaddr
            SGInfo sginfo = SGInfo.Current;

            // verify the machine id in the request matches what the SG told us
            sginfo.VerifyMachineId2(m_header.sgaddr.qwXboxId);

            // TODO: SGInfo doesn't allow access to inaSg and dwSpiSg right now

            // DEAD_USER is the only message allowed when the user is not present, and DEAD_USER is
            // only valid in this case. If the user is present, the msgtype must not be DEAD_USER,
            // and if the user is not present, the msgtype must be DEAD_USER.
            if (sginfo.IsUserPresent(m_qwUserID) == ((uint)P_MSG_TYPES.PMSG_DEAD_USER == m_header.dwMsgType))
            {
                throw new XRLException(HResult.XONLINE_E_NOTIFICATION_INVALID_PUID, XEvent.Id.PRESENCE_SGINFO_INVALID_PUID,
                                       "presencefd.CheckSgInfo: Mismatch (DEAD_USER) == (PUID found) in request, user={0} msgtype={1}",
                                       (Puid)m_qwUserID, m_header.dwMsgType);
            }

        }



        // -------------------------------------------------------------------------------
        // IsAuthMessageType - true if auth data should be requested from the Security Gateway
        // -------------------------------------------------------------------------------
        private static bool IsAuthMessageType( uint dwMsgType )
        {
            switch( dwMsgType )
            {
            case (uint) P_MSG_TYPES.PMSG_LOGON_CHECK:
            case (uint) P_MSG_TYPES.PMSG_ALIVE_2:
            case (uint) P_MSG_TYPES.PMSG_DEAD_USER:
            case (uint) P_MSG_TYPES.PMSG_ADD_2:
            case (uint) P_MSG_TYPES.PMSG_ADD_AFFILIATES:
            case (uint) P_MSG_TYPES.PMSG_IS_AFFILIATE:
            case (uint) P_MSG_TYPES.PMSG_QUERY_AFFILIATES:
            case (uint) P_MSG_TYPES.PMSG_DELETE:
            case (uint) P_MSG_TYPES.PMSG_ACCEPT:
            case (uint) P_MSG_TYPES.PMSG_REJECT:
            case (uint) P_MSG_TYPES.PMSG_MUTE:
            case (uint) P_MSG_TYPES.PMSG_UNMUTE:
            case (uint) P_MSG_TYPES.PMSG_PEER_SESSION:
            case (uint) P_MSG_TYPES.PMSG_GET_FRIENDS_LIST:
            case (uint) P_MSG_TYPES.PMSG_GET_FRIENDS_NO_PRESENCE:
            case (uint) P_MSG_TYPES.PMSG_ADD_USERS_TO_NEVERLIST:
            case (uint) P_MSG_TYPES.PMSG_REMOVE_USERS_FROM_NEVERLIST:
            case (uint) P_MSG_TYPES.PMSG_CAN_SEND_MESSAGE:
                return true;
            default:
                return false;
            }

        } // IsAuthMessageType

        // -------------------------------------------------------------------------------
        // IsNonUserMessageType - true if user ID directly follows the header in the request
        // -------------------------------------------------------------------------------
        private static bool IsUserMessageType( uint dwMsgType )
        {
            switch( dwMsgType )
            {
            case (uint) P_MSG_TYPES.PMSG_HELLO:
            case (uint) P_MSG_TYPES.PMSG_DEAD_XBOX:
            case (uint) P_MSG_TYPES.PMSG_DEAD_SG:
            case (uint) P_MSG_TYPES.PMSG_GET_PRESENCE_INFO:
                return false;
            default:
                return true;
            }

        } // IsNonUserMessageType
        

        // -------------------------------------------------------------------------------
        // IsDatacenterMessageType - true if this message is valid on the datacenter port
        // -------------------------------------------------------------------------------
        private static bool IsDatacenterMessageType(uint dwMsgType )
        {
            switch( dwMsgType )
            {
            case (uint) P_MSG_TYPES.PMSG_STATE_2:
            case (uint) P_MSG_TYPES.PMSG_GET_STATE:
            case (uint) P_MSG_TYPES.PMSG_DEAD_XBOX:
            case (uint) P_MSG_TYPES.PMSG_DEAD_SG:
            case (uint) P_MSG_TYPES.PMSG_WEB_ALIVE:
            case (uint) P_MSG_TYPES.PMSG_WEB_ALIVE2:
            case (uint) P_MSG_TYPES.PMSG_WEB_FRIENDS:
            case (uint) P_MSG_TYPES.PMSG_GET_FRIENDS_LIST:
            case (uint) P_MSG_TYPES.PMSG_GET_FRIENDS_NO_PRESENCE:
            case (uint) P_MSG_TYPES.PMSG_GET_FRIENDS_LIMITED_PRESENCE:
            case (uint) P_MSG_TYPES.PMSG_ADD:
            case (uint) P_MSG_TYPES.PMSG_ADD_AFFILIATES:
            case (uint) P_MSG_TYPES.PMSG_IS_AFFILIATE:
            case (uint) P_MSG_TYPES.PMSG_QUERY_AFFILIATES:
            case (uint) P_MSG_TYPES.PMSG_GET_PRESENCE_INFO:
            case (uint) P_MSG_TYPES.PMSG_DELETE:
            case (uint) P_MSG_TYPES.PMSG_ACCEPT:
            case (uint) P_MSG_TYPES.PMSG_REJECT:
            case (uint) P_MSG_TYPES.PMSG_INVITE_2:
            case (uint) P_MSG_TYPES.PMSG_INVITE_ANSWER:
            case (uint) P_MSG_TYPES.PMSG_MUTE:
            case (uint) P_MSG_TYPES.PMSG_UNMUTE:
            case (uint) P_MSG_TYPES.PMSG_CANCEL:
            case (uint) P_MSG_TYPES.PMSG_ADD_2:
            case (uint) P_MSG_TYPES.PMSG_INVALIDATE_USER:
            case (uint) P_MSG_TYPES.PMSG_FIND_USER:
            case (uint) P_MSG_TYPES.PMSG_FIND_USERS:
            case (uint) P_MSG_TYPES.PMSG_CHECK_TITLE_MESSAGES:
            case (uint) P_MSG_TYPES.PMSG_PURGE_USER:
            case (uint) P_MSG_TYPES.PMSG_KICK:
            case (uint) P_MSG_TYPES.PMSG_ADD_USERS_TO_NEVERLIST:
            case (uint) P_MSG_TYPES.PMSG_REMOVE_USERS_FROM_NEVERLIST:
            case (uint) P_MSG_TYPES.PMSG_CAN_SEND_MESSAGE:
                return true;
            default:
                return false;
            }

        } // IsDatacenterMessageType

        // -------------------------------------------------------------------------------
        // IsClientMessageType - true if this message is valid on the client port
        // -------------------------------------------------------------------------------
        private static bool IsClientMessageType(uint dwMsgType )
        {
            switch( dwMsgType )
            {
            case (uint) P_MSG_TYPES.PMSG_LOGON_CHECK:
            case (uint) P_MSG_TYPES.PMSG_ALIVE_2:
            case (uint) P_MSG_TYPES.PMSG_CANCEL:
            case (uint) P_MSG_TYPES.PMSG_INVITE_2:
            case (uint) P_MSG_TYPES.PMSG_INVITE_ANSWER:
            case (uint) P_MSG_TYPES.PMSG_MUTE:
            case (uint) P_MSG_TYPES.PMSG_UNMUTE:
            case (uint) P_MSG_TYPES.PMSG_ADD:
            case (uint) P_MSG_TYPES.PMSG_ADD_2:
            case (uint) P_MSG_TYPES.PMSG_ADD_AFFILIATES:
            case (uint) P_MSG_TYPES.PMSG_IS_AFFILIATE:
            case (uint) P_MSG_TYPES.PMSG_QUERY_AFFILIATES:
            case (uint) P_MSG_TYPES.PMSG_DELETE:
            case (uint) P_MSG_TYPES.PMSG_ACCEPT:
            case (uint) P_MSG_TYPES.PMSG_REJECT:
            case (uint) P_MSG_TYPES.PMSG_KICK:
            case (uint) P_MSG_TYPES.PMSG_DEAD_USER:
            case (uint) P_MSG_TYPES.PMSG_PEER_SESSION:
            case (uint) P_MSG_TYPES.PMSG_FIND_USER:
            case (uint) P_MSG_TYPES.PMSG_FIND_USERS:
            case (uint) P_MSG_TYPES.PMSG_CHECK_TITLE_MESSAGES:
            case (uint) P_MSG_TYPES.PMSG_GET_FRIENDS_LIST:
            case (uint) P_MSG_TYPES.PMSG_GET_FRIENDS_NO_PRESENCE:
            case (uint) Q_MSG_TYPES.QMSG_DEQUEUE:
            case (uint) P_MSG_TYPES.PMSG_ADD_USERS_TO_NEVERLIST:
            case (uint) P_MSG_TYPES.PMSG_REMOVE_USERS_FROM_NEVERLIST:
            case (uint) P_MSG_TYPES.PMSG_CAN_SEND_MESSAGE:
                return true;
            default:
                return false;
            }

        } // IsClientMessageType

        public static string GetRequestTypeName(uint dwMsgType)
        {
            if (((dwMsgType >= (uint)P_MSG_TYPES.PMSG_MIN_REQ_TYPE) && (dwMsgType <= (uint)P_MSG_TYPES.PMSG_MAX_REQ_TYPE)) ||
                ((dwMsgType >= (uint)P_MSG_TYPES.PMSG_MIN_REPLY_TYPE) && (dwMsgType <= (uint)P_MSG_TYPES.PMSG_MAX_REPLY_TYPE)))
            {
                return ((P_MSG_TYPES)dwMsgType).ToString();
            }
            if (((dwMsgType >= (uint)Q_MSG_TYPES.QMSG_MIN_REQ_TYPE) && (dwMsgType <= (uint)Q_MSG_TYPES.QMSG_MAX_REQ_TYPE)) ||
                ((dwMsgType >= (uint)Q_MSG_TYPES.QMSG_MIN_REPLY_TYPE) && (dwMsgType <= (uint)Q_MSG_TYPES.QMSG_MAX_REPLY_TYPE)))
            {
                return ((Q_MSG_TYPES)dwMsgType).ToString();
            }

            return "Unknown Message Type!";
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\fd\PurgeUser.cs ===
using System;
using System.IO;
using System.Web;
using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.protocol;
using xonline.common.service;
using xonline.common.community;
using xonline.common.sql.webstore;
using Microsoft.Webstore.WstClient;

namespace xonline.server.presence.fd
{
    internal class PurgeUserHandler : PresenceHandlerBase
    {
        private uint m_hr;
        private PurgeUserRequest m_request;
        private PurgeUserResponse m_response;

        public PurgeUserHandler(BaseHeader header)
            : base(header)
        {
            m_request = new PurgeUserRequest();
            m_response = new PurgeUserResponse();
        }

        public override void ProcessRequest()
        {
            //Parse out the request
            m_request.ReadStream(new BinaryReader(HttpContext.Current.Request.InputStream));

            // User id of 0 check is done by PresenceHandlerBase

            // See if the user is on the system
            PresenceRecord presence = PresenceUtil.GetPresenceRecord(m_request.puid);
            if (presence != null)
            {
                if (presence.IsOnline())
                {
                    // why were we asked to purge this user??
                    throw new XRLException(
                        Win32ErrorCode.GetHResult(Win32ErrorCode.Codes.ERROR_USER_EXISTS),
                        XEvent.Id.PRESENCE_PURGE_USER_TARGET_IS_ONLINE,
                        "PurgeUser: Specified user {0} is online.", (Puid)m_request.puid
                        );
                }

                // Return user's gamertag to caller
                m_response.szGamerTag = presence.sGamertag;

                // Remove user from presence cache
                PresenceUtil.PurgeUser(presence.OwnerID);
            }

            m_hr = HResult.S_OK;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="hr">Error return code</param>
        public override HResult ProcessError(HResult hr)
        {
            m_hr = hr;
            return HResult.S_OK;
        }

        /// <summary>
        /// 
        /// </summary>
        public override void LogResults()
        {
            Xom.Log(XomAreaName.PresenceLog, "Kick|{0}|{1:X}|{2:X}|{3}|{4}",
                (Puid)m_request.header.sgaddr.qwXboxId,
                m_request.header.sgaddr.inaSg,
                m_request.header.sgaddr.dwSpiSg,
                (Puid)m_request.puid,
                m_hr);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <returns>Base class that derives from XRLObject2</returns>
        protected override XRLObject2 GetResponse()
        {
            m_response.hr = m_hr;
            return m_response;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\fd\richpresence.cs ===
// 
// RichPresence.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Xbox Online Service
// 

using System;
using System.Collections;
using System.Collections.Generic;
using System.Data;
using System.Data.SqlClient;
using System.Globalization;
using System.IO;
using System.Runtime.InteropServices;
using System.Security.Principal;
using System.Text;
using System.Threading;
using System.Web;
using System.Web.Caching;
using System.Xml;
using System.Xml.Serialization;
using System.Xml.XPath;

using xonline.common.config;
using xonline.common.protocol;
using xonline.common.service;
using xonline.common.mgmt;


namespace xonline.server.presence.fd
{
    /// <summary>
    /// Presence class - handles Presence requests
    /// </summary>
    public class RichPresenceFormatter
    {
        public const string c_szFormatStringKey = "Fmt";
        public const string c_szgixsdFileName = "gi.xsd";
        
        public class ParamSpecifier
        {
            public bool isContext;
            public uint Id;
        }

        public class TitleEntry
        {
            public string defaultLocale;
            public ArrayList alLocales;
            public Hashtable htCacheEntries;
        }
        
        /// <summary>
        /// The basic building block for the RichPresence Cache containing data
        /// </summary>
        public class CacheEntry
        {
            public uint presenceContext;
            public string locale;
            public string formatString;
            public ParamSpecifier[] parameters;
        }
        
        /// <summary>
        /// Initialize - setup our internal values
        /// </summary>
        public static void Initialize( )
        {
            // Save off the current credentials for the timer thread to use later
            m_id = WindowsIdentity.GetCurrent();

            // Create a RichPresence Cache to store RichPresence strings
            m_PresenceCache = new Dictionary<uint, TitleEntry>();

            XboxLiveThread initThread = new XboxLiveThread(new System.Threading.ThreadStart(InitProc));
            initThread.Start();
        }

        /// <summary>
        /// ShutDown - cleanup our internal values
        /// </summary>
        public static void ShutDown( )
        {
        }

        public static string[] GetTitleSupportedLocales(uint dwTitleID)
        {
            // Check if InitProc was called or if the Title exists in the Cache
            if (!m_fInit || (!m_PresenceCache.ContainsKey(dwTitleID)))
            {
                return null;
            }

            TitleEntry titleEntry = m_PresenceCache[dwTitleID];
            if ((titleEntry == null) || (titleEntry.alLocales == null))
            {
                return null;
            }

            return (string[])(titleEntry.alLocales.ToArray(typeof(string)));
        }

        /// <summary>
        /// FormatRichPresence - formats a blob of contexts and properties into a Rich Presence string
        /// </summary>
        /// <param name="userId">User ID</param>
        /// <param name="titleId">Game Title ID</param>
        /// <param name="titlePresence">Title Presence Mode</param>
        /// <param name="locales">Set of Locales</param>
        /// <param name="rgProps">Properties</param>
        /// <param name="rgContexts">Contexts</param>
        /// <returns>Formatted RichPresence String</returns>
        public static string FormatRichPresenceString( ulong userId, uint titleId, uint titlePresence, string[] locales, GIProperty[] rgProps, GIContext[] rgContexts )
        {
            // Check if InitProc was called or if the Title exists in the Cache
            if (!m_fInit || (!m_PresenceCache.ContainsKey(titleId)))
            {
                return "";
            }
            
            // Update PerfCounters
            PresenceCounters.Current.RichPresenceFormatTotal.Increment();
            PresenceCounters.Current.RichPresenceFormatRate.Increment();
            
            CacheEntry  formatData = null;
            string      key;
            string      localizedKey;
            string      formattedString = "";
            TitleEntry titleEntry = m_PresenceCache[titleId];
            Hashtable   tempPresenceCacheTitle = titleEntry.htCacheEntries;

            try
            {
                key = BuildKey(c_szFormatStringKey, titlePresence.ToString());

                if (null != locales)
                {
                    foreach(string locale in locales)
                    {                        
                        localizedKey = AppendLocaleToKey(key, locale);

                        formatData = (CacheEntry)tempPresenceCacheTitle[localizedKey];

                        if (null != formatData)
                        {
                            break;
                        }
                    }
                }
                
                if (formatData == null)
                {
                    // get the default format string
                    formatData = (CacheEntry)tempPresenceCacheTitle[key];
                }

                if (formatData == null)
                {
                    Xom.NtEvent(XEvent.Id.PRESENCE_RICHPRESENCE_FORMAT_NOT_FOUND,
                        "FormatRichPresenceString requested for titleId = " + (TitleId) titleId +
                        ", presence context=" + titlePresence.ToString() + " was not found. The config file is probably not loaded."
                    );

                    goto lDone;
                }
                
                // parse out the parameters from the formatString            
                ArrayList       parameters = new ArrayList();
                
                foreach(ParamSpecifier param in formatData.parameters)
                {
                    bool found = false;
                    
                    if (param.isContext)
                    {
                        // context
                        foreach (GIContext ctx in rgContexts)
                        {
                            if (ctx.Id == param.Id)
                            {
                                // need to look up the context label
                                key = BuildKey(ctx.Id.ToString("X"), ctx.Value.ToString());
                                localizedKey = AppendLocaleToKey(key, formatData.locale);

                                string label = null;
                                label = (string)tempPresenceCacheTitle[localizedKey];

                                if (label == null)
                                {
                                    // get the default format string
                                    label = (string)tempPresenceCacheTitle[key];
                                }

                                if (label == null)
                                {
                                    if (Config.GetBoolSetting(Setting.presence_RichPresenceDebug))
                                    {
                                        // Indicate the problem in the RP string
                                        parameters.Add("c" + param.Id.ToString("X") + ":v" + ctx.Value.ToString() + " label missing ");
                                        found = true;
                                        break;
                                    }
                                    
                                    Xom.NtEvent(XEvent.Id.PRESENCE_RICHPRESENCE_CONTEXT_LABEL_NOT_FOUND,
                                        "FormatRichPresenceString requested for titleId = " + (TitleId) titleId + 
                                        ", context label for context=" + key + " was not found. The config file is probably not loaded."
                                    );

                                    goto lDone;
                                }
                
                                parameters.Add(label);
                                found = true;
                                break;
                            }
                        }

                        if (!found)
                        {                    
                            if (!Config.GetBoolSetting(Setting.presence_RichPresenceDebug))
                            {
                                Xom.NtEvent(XEvent.Id.PRESENCE_RICHPRESENCE_CONTEXT_NOT_FOUND,
                                    "Context " + param.Id.ToString("X") + " not found in context data for user=" +
                                    (Puid)userId + " in titleId = " + (TitleId) titleId + ", presence context=" + 
                                    titlePresence.ToString() + ", format string=" + formatData.formatString
                                );

                                goto lDone;
                            }
                            else
                            {
                                parameters.Add("c0x" + param.Id.ToString("X") + " data missing");
                            }
                        }
                    }
                    else
                    {
                        // property
                        foreach (GIProperty prop in rgProps)
                        {
                            if (prop.Id == param.Id)
                            {
                                parameters.Add(prop.Value);
                                found = true;
                                break;
                            }
                        }

                        if (!found)
                        {
                            // Properties may not be passed if they have not yet been set in the client. 
                            Xom.Trace(XomAreaName.PresenceRPDebug, LogLevel.L_WARNING, "Missing value for property id=" + param.Id.ToString("X") + ". titlePresence=" + titlePresence + " in title=" + (TitleId)titleId + " for user=" + (Puid)userId + ".\n" 
                                + "format string=" + formatData.formatString);
                            
                            if (Config.GetBoolSetting(Setting.presence_RichPresenceDebug))
                            {
                                // Properties may not be passed if they have not yet been set in the client. 
                                Xom.Trace(XomAreaName.PresenceRPDebug, LogLevel.L_WARNING, "Defaulting value for property id=" + param.Id.ToString("X") + " because it is not in the Rich Presence data required." );
                                formattedString = "ERROR: missing property id=0x" + param.Id.ToString("X") + " presCtx=" + titlePresence + " loc=" + formatData.locale;
                                goto lDone;
                            }
                            else
                            {
                                Xom.Trace(XomAreaName.PresenceRPDebug, LogLevel.L_WARNING, "Aborting rich presence format due to missing property id=" + param.Id.ToString("X"));
                                goto lDone;
                            }
                        }
                    }
                }
                
                CultureInfo cultureInfo = new CultureInfo(formatData.locale);
               
                formattedString = String.Format(cultureInfo, formatData.formatString, parameters.ToArray() );
                
                Xom.Trace(XomAreaName.PresenceRPDebug, LogLevel.L_INFO, "Formatted Rich Presence string titlePresence = " + titlePresence + " in titleId = " + (TitleId) titleId + " for user =" + (Puid) userId + " in locale=" + formatData.locale + ".\n"
                        + "format string=" + formatData.formatString + ".\n"
                        + "formatted string=" + formattedString + ".");
            }
            catch (Exception e)
            {
                Xom.NtEvent( XEvent.Id.PRESENCE_RICHPRESENCE_FORMAT_FAILED, e,
                    "Format Rich Presence string FAILED. titlePresence = " + titlePresence + 
                    " in titleId = " + (TitleId) titleId + " for user = " + (Puid) userId + 
                    " in locale=" + formatData.locale + ".\n" + 
                    "format string=" + formatData.formatString
                );


                // Give a better error message if RichPresenceDebug is on. 
                if (Config.GetBoolSetting(Setting.presence_RichPresenceDebug))
                {
                    formattedString = "Game Configuration Error: presCtx=" + titlePresence + " loc=" + formatData.locale + ". " + e.Message;
                }
            }
            
        lDone:
            
            return formattedString;
        }
        
        /// <summary>
        /// Builds the base Hash Key
        /// </summary>
        /// <param name="type">Key Type (e.g. "Fmt")</param>
        /// <param name="index">Reference Index</param>
        /// <returns>Hash Key String</returns>
        public static string BuildKey( string type, string index )
        {
            string key = type + ":" + index;
            return key;
        }

        /// <summary>
        /// Appends the Locale string to the string
        /// </summary>
        /// <param name="key">The base key generated by BuildKey ( )</param>
        /// <param name="locale">The Locale string to append</param>
        /// <returns>Appended Hash Key String</returns>
        public static string AppendLocaleToKey( string key, string locale )
        {
            if (null != locale)
            {
                key = key + ":" + locale;
            }
            
            return key;
        }

        /// <summary>
        /// Reads and replaces the Presence Format String according to locale and context
        /// </summary>
        /// <param name="titleId">Game Title ID</param>
        /// <param name="presenceContext">Context String</param>
        /// <param name="locale">Locale String</param>
        /// <param name="rawFormatString">Format String</param>
        /// <returns>Formatted Cache Data Structure</returns>
        public static CacheEntry ParseFormatString(uint titleId, string presenceContext, string locale, string rawFormatString)
        {
            CacheEntry  formatData = new CacheEntry();
            ArrayList   parameters = new ArrayList();

            formatData.presenceContext = UInt32.Parse(presenceContext);
            formatData.locale = locale;

            // parse out the parameters from the formatString            
            StringBuilder   sb = new StringBuilder();
            string []       splits = rawFormatString.Split('{');
            int             index = 0;
            
            sb.Append(splits[0]);
            
            for ( int i=1; i<splits.Length; i++)
            {
                ParamSpecifier  param = new ParamSpecifier();                
                bool            found = false;
                string          temp = null;

                string          split = splits[i];

                // The format parameter is embedded with zero or more format items of the form: {(p|c)id[,alignment][:formatString]}
                //  we just care about extracting the type (property or context) and id, 
                //  and converting the remaining to the standard form: {index[,alignment][:formatString]}
                int offset = split.IndexOfAny(new char [] {'}', ',', ':'});
                
                temp = split.Substring(0, offset);
                
                if (temp.Substring(1).StartsWith("0x"))
                {
                    param.Id = UInt32.Parse(temp.Substring(3), NumberStyles.HexNumber);                    
                }
                else
                {
                    param.Id = UInt32.Parse(temp.Substring(1), NumberStyles.Number);
                }

                if ((param.Id & GITypes.XONLINE_STAT_DATATYPE_MASK) == GITypes.XONLINE_STAT_BINARY)
                {
                    throw new Exception("Format specifier referenced binary type (unsupported) for title=" + (TitleId)titleId + ", presence context=" + presenceContext);                            
                }

                if (temp[0] == 'p')
                {
                    // property
                    parameters.Add(param);     
                    found = true;
                }
                else if (temp[0] == 'c')
                {
                    // context
                    param.isContext = true;
                    parameters.Add(param);                                
                    found = true;
                }
                else if (temp == "")
                {
                    // This is ok - we are likely formatting a "{{" char into the output
                }
                else
                {
                    throw new Exception("Format specifier {" + temp + "} is not valid for title=" + (TitleId)titleId + ", presence context=" + presenceContext + ", format split=" + split);                            
                }
                
                sb.Append("{");                 // if we have a format specifier, we need to put the '{' back on
                
                if (found)          
                {
                    // BUGBUG: This could do multiple replaces in split
                    sb.Append(split.Replace(temp, index.ToString()));   // add the string we split back to the final format string
                    
                    index++;        
                }               
                else if (Config.GetBoolSetting(Setting.presence_RichPresenceDebug))
                {
                    sb.Append(split);           // add the original string back in for debugging purposes
                }
            }

            formatData.formatString = sb.ToString();
            formatData.parameters = (ParamSpecifier [])parameters.ToArray(typeof(ParamSpecifier));

            return formatData;
        }

        /// <summary>
        /// Caches the strings into a new Inner Cache
        /// </summary>
        /// <param name="innerCache">The new Inner Cache to put into RichPresenceCache</param>
        /// <param name="key">The format string key</param>
        /// <param name="nav">XPathNavigator</param>
        /// <param name="nsmgr">XmlNamespaceManager</param>
        /// <param name="stringId">String ID</param>
        /// <param name="label">Context Label</param>
        /// <param name="defaultLocale">Default Locale String</param>
        public static void CacheStringData(ref Hashtable innerCache, uint titleId, string key, XPathNavigator nav, XmlNamespaceManager nsmgr, uint stringId, string label, string defaultLocale)
        {
            XPathExpression expr;

            expr = nav.Compile("//xlast:LocalizedStrings/xlast:LocalizedString[@id='" + stringId + "']/xlast:Translation");
            expr.SetContext(nsmgr);

            XPathNodeIterator stringIterator = nav.Select(expr);

            if (stringIterator.Count == 0)
            {
                Xom.Trace(XomAreaName.PresenceRPDebug, LogLevel.L_INFO, "String Translation elements not found. Expected at least 1 LocalizedString[@id='" + stringId + "']/Translation element");
                Xom.NtEvent(XEvent.Id.PRESENCE_TITLECONFIG_TRANSLATION_NOT_FOUND, "String Translation elements not found. Expected at least 1 LocalizedString[@id='" + stringId + "']/Translation element");
            }

            while (stringIterator.MoveNext())
            {
                string locale = stringIterator.Current.GetAttribute("locale", "");
                string value = stringIterator.Current.Value;
                object data = value;

                locale = locale.Substring(0, 2).ToLower() + locale.Substring(2).ToUpper();

                // Bug 38251. The service cannot format properties in zh-CHT so translate everything
                //  to zh-TW internally on the server. 
                if (locale == "zh-CHT")
                {
                    locale = "zh-TW";
                }

                // Parse the xml file and insert the data
                string localizedKey = AppendLocaleToKey(key, locale);

                // Is this a simple label or a complex format specifier?
                if (key.IndexOf(c_szFormatStringKey) != -1)
                {
                    // Preprocess format strings and cache CacheEntry structs instead of the raw string
                    CacheEntry formatData = ParseFormatString(titleId, label, locale, value);
                    data = formatData;
                }

                if (locale == defaultLocale)
                {
                    Xom.Trace(XomAreaName.PresenceRPDebug, LogLevel.L_INFO, "CacheInsert: Key=" + key + ", Data=" + value);
                    innerCache.Add(key, data);
                }

                // Cache the simple string directly by ID
                Xom.Trace(XomAreaName.PresenceRPDebug, LogLevel.L_INFO, "CacheInsert: Key=" + localizedKey + ", Data=" + value);
                innerCache.Add(localizedKey, data);
            }
        }

        /// <summary>
        /// Checks for errors in the XML Configuration File
        /// </summary>
        /// <param name="xmlConfig">XML Configuration File as a string</param>
        private static void ValidateConfigXml( string xmlConfig )
        {
            // string gixsdPath = Path.Combine(Path.GetDirectoryName(Config.AssemblyPath), c_szgixsdFileName);

            // Load the GI XSD from file            
            // XmlTextReader           xsdReader = new XmlTextReader(gixsdPath);

            if (null == m_xsdReader)
            {
                Xom.Trace(XomAreaName.PresenceRPDebug, LogLevel.L_INFO, "Config schema not loaded. ConfigXML validation skipped. " );
                Xom.NtEvent(XEvent.Id.PRESENCE_TITLECONFIG_SCHEMA_NOT_LOADED, "Config schema not loaded. ConfigXML validation skipped. " );
                return;
            }

            // Create the validating reader to do the dirty work
            XmlReaderSettings xmlSettings = new XmlReaderSettings();
            xmlSettings.ValidationType = ValidationType.Schema;
            xmlSettings.Schemas.Add(@"http://www.xboxlive.com/xlast", m_xsdReader);
            
            NameTable nt = new NameTable();
            XmlParserContext context = new XmlParserContext(nt, null, null, XmlSpace.None);
            XmlReader vr = XmlReader.Create(xmlConfig, xmlSettings, context);

            // Run through the XML to validate it
            while (vr.Read())
            {
                // Do nothing, just move on to the next node
            }        
        }        
        
        /// <summary>
        /// Reads the XML Configuration File and updates the Cache with the corresponding Game Title
        /// </summary>
        /// <param name="titleId">Game Title ID</param>
        /// <param name="xmlDoc">XML Configuration File</param>
        private static void ParseConfigXml( uint titleId, XmlDocument xmlDoc )
        {
            try
            {
                XPathNavigator          nav = xmlDoc.CreateNavigator();
                XmlNamespaceManager     nsmgr = new XmlNamespaceManager(nav.NameTable);
                XPathExpression         expr;
                string                  defaultLocale = "en-US";
                Hashtable               newInnerCache = new Hashtable();
                ArrayList alSupportedLocales = new ArrayList();
                
                Xom.Trace(XomAreaName.PresenceRPDebug, LogLevel.L_INFO, "Parsing config data for title " + (TitleId)titleId );

                nsmgr.AddNamespace("xlast", "http://www.xboxlive.com/xlast");

                // Get the titleId and make sure it matches what was passed from the DB
                expr = nav.Compile("//xlast:GameConfigProject");
                expr.SetContext(nsmgr);
                XPathNodeIterator titleIterator = nav.Select(expr);

                if (titleIterator.Count != 1)
                {
                    Xom.Trace(XomAreaName.PresenceRPDebug, LogLevel.L_INFO, "GameConfigProject aggregate not found for titleId = " + (TitleId) titleId + ".");
                    Xom.NtEvent( XEvent.Id.PRESENCE_TITLECONFIG_NO_GAMECONFIGPROJECT, "GameConfigProject aggregate not found for titleId = {0}.", (TitleId) titleId);
                }                
                            
                while(titleIterator.MoveNext())
                {
                    string value = titleIterator.Current.GetAttribute("titleId", "");
                    uint configTitleId = (uint)SafeConvert.ToInt32(value);   // Always in hex

                    if (configTitleId != titleId)
                    {
                        throw new Exception("GameConfigProject contains titleId " + (TitleId)configTitleId + ". Expected " + (TitleId)titleId );
                    }
                }

                
                // Find the default string locale for this title
                expr = nav.Compile("//xlast:LocalizedStrings");
                expr.SetContext(nsmgr);
                XPathNodeIterator stringIterator = nav.Select(expr);
                            
                if (stringIterator.Count == 0)
                {
                    Xom.Trace(XomAreaName.PresenceRPDebug, LogLevel.L_INFO, "LocalizedStrings aggregate not found for titleId = " + (TitleId) titleId + "." );
                    Xom.NtEvent( XEvent.Id.PRESENCE_TITLECONFIG_NO_LOCALIZEDSTRINGS, "LocalizedStrings aggregate not found for titleId = {0}.", (TitleId) titleId);
                }
                
                while(stringIterator.MoveNext())                
                {
                    string value = stringIterator.Current.GetAttribute("defaultLocale", "");
                    defaultLocale = value.Substring(0,2).ToLower() + value.Substring(2).ToUpper();

                    // Bug 38251. The service cannot format properties in zh-CHT so translate everything
                    //  to zh-TW internally on the server. 
                    if (defaultLocale == "zh-CHT")
                    {
                        defaultLocale = "zh-TW";
                    }
                }                

                // Load all supported locales
                expr = nav.Compile("//xlast:LocalizedStrings/xlast:SupportedLocale");
                expr.SetContext(nsmgr);
                XPathNodeIterator localeIterator = nav.Select(expr);

                if (localeIterator.Count == 0)
                {
                    Xom.Trace(XomAreaName.PresenceRPDebug, LogLevel.L_INFO, "SupportedLocale elements not found for titleId = " + (TitleId) titleId + ". Expected at least 1 SupportedLocale element.");
                    Xom.NtEvent(XEvent.Id.PRESENCE_TITLECONFIG_NO_SUPPORTEDLOCALE, "SupportedLocale elements not found for titleId = {0}.  Expected at least 1 SupportedLocale element.",  (TitleId) titleId);
                }
                
                while(localeIterator.MoveNext())                
                {
                    string value = localeIterator.Current.GetAttribute("locale", "");
                    string locale = value.Substring(0,2).ToLower() + value.Substring(2).ToUpper();

                    // Bug 38251. The service cannot format properties in zh-CHT so translate everything
                    //  to zh-TW internally on the server. 
                    if (locale == "zh-CHT")
                    {
                        locale = "zh-TW";
                    }

                    // Cache locale into the new Inner Cache
                    if ((locale == defaultLocale) && (alSupportedLocales.Count > 0))
                    {
                        // put the default in index 0.
                        locale = (string)(alSupportedLocales[0]);
                        alSupportedLocales[0] = defaultLocale;
                    }
                    alSupportedLocales.Add(locale);
                }                

                // at least get the default locale in the list if the SupportedLocales key is missing.
                if (alSupportedLocales.Count == 0)
                {
                    alSupportedLocales.Add(defaultLocale);
                }

                // Load presence format string data
                expr = nav.Compile("//xlast:Presence/xlast:PresenceMode");
                expr.SetContext(nsmgr);
                XPathNodeIterator presenceIterator = nav.Select(expr);

                if (presenceIterator.Count == 0)
                {
                    Xom.Trace(XomAreaName.PresenceRPDebug, LogLevel.L_INFO, "PresenceMode elements not found for titleId = " + (TitleId) titleId + ". Expected at least 1 PresenceMode element.");
                    Xom.NtEvent( XEvent.Id.PRESENCE_TITLECONFIG_NO_PRESENCEMODE, "PresenceMode elements not found for titleId = {0}. Expected at least 1 PresenceMode element.", (TitleId) titleId);
                }
                
                while(presenceIterator.MoveNext())                
                {
                    string      contextValue = presenceIterator.Current.GetAttribute("contextValue", "");
                    uint        fstringId = (uint)SafeConvert.ToInt32(presenceIterator.Current.GetAttribute("stringId", ""));

                    // Cache Presence Format Strings into the new Inner Cache
                    CacheStringData(ref newInnerCache, titleId, BuildKey(c_szFormatStringKey, contextValue), nav, nsmgr, fstringId, contextValue, defaultLocale);
                }                

                // Load game mode labels for this title
                expr = nav.Compile("//xlast:GameModes/xlast:GameMode");
                expr.SetContext(nsmgr);
                XPathNodeIterator modeIterator = nav.Select(expr);
                
                while(modeIterator.MoveNext())                
                {
                    string value = modeIterator.Current.GetAttribute("value", "");
                    uint cvstringId = (uint)SafeConvert.ToInt32(modeIterator.Current.GetAttribute("stringId", ""));
                        
                    Xom.Trace(XomAreaName.PresenceRPDebug, LogLevel.L_INFO, "Found GameMode: value=" + value + ". string ID=0x" + cvstringId.ToString("X") );

                    // Cache the Game Mode Labels into the Inner Cache
                    CacheStringData(ref newInnerCache, titleId, BuildKey(GIDefs.X_CONTEXT_GAME_MODE.ToString("X"), value), nav, nsmgr, cvstringId, value, defaultLocale);
                }                    
                
                // Load context labels for this title
                expr = nav.Compile("//xlast:Contexts/xlast:Context");
                expr.SetContext(nsmgr);
                XPathNodeIterator contextIterator = nav.Select(expr);

                if (contextIterator.Count == 0)
                {
                    Xom.Trace(XomAreaName.PresenceRPDebug, LogLevel.L_INFO, "Context elements not found for titleId = " + (TitleId) titleId + ". Expected at least 1 Context element.");
                    Xom.NtEvent(XEvent.Id.PRESENCE_TITLECONFIG_NO_CONTEXT, "Context elements not found for titleId = {0}. Expected at least 1 Context element.", (TitleId) titleId);
                }
                
                while(contextIterator.MoveNext())                
                {
                    string cId = contextIterator.Current.GetAttribute("id", "");
                    uint contextId = (uint)SafeConvert.ToInt32(cId);
                    uint cstringId = (uint)SafeConvert.ToInt32(contextIterator.Current.GetAttribute("stringId", ""));

                    // Xlast files use inconsitent case representations on the hex id of contexts, so we use the 
                    //  literal string representation in the following query
                    expr = nav.Compile("//xlast:Contexts/xlast:Context[@id='" + cId + "']/xlast:ContextValue");
                    expr.SetContext(nsmgr);
                    XPathNodeIterator contextValueIterator = nav.Select(expr);

                    if (contextValueIterator.Count == 0)
                    {
                        Xom.Trace(XomAreaName.PresenceRPDebug, LogLevel.L_INFO, "ContextValue elements not found for titleId = " + (TitleId) titleId + ", context 0x" + contextId.ToString("X") + ". Expected at least 1 ContextValue element.");
                        Xom.NtEvent( XEvent.Id.PRESENCE_TITLECONFIG_NO_CONTEXTVALUE, "ContextValue elements not found for titleId = {0}, context 0x{1}. Expected at least 1 ContextValue element.", (TitleId) titleId, contextId.ToString("X"));
                    }

                    while(contextValueIterator.MoveNext())                
                    {
                        string value = contextValueIterator.Current.GetAttribute("value", "");
                        uint cvstringId = (uint)SafeConvert.ToInt32(contextValueIterator.Current.GetAttribute("stringId", ""));
                            
                        Xom.Trace(XomAreaName.PresenceRPDebug, LogLevel.L_INFO, "Found ContextValue: value=" + value + ". string ID=0x" + cvstringId.ToString("X") );

                        // Cache the Context Labels into the new Inner Cache
                        CacheStringData(ref newInnerCache, titleId, BuildKey(contextId.ToString("X"), value), nav, nsmgr, cvstringId, value, defaultLocale);
                    }
                }

                // Decrement the Perf Counter Value by the number of expiring entries
                //   (Only if it exists in the Cache already)
                if (m_PresenceCache.ContainsKey(titleId))
                    PresenceCounters.Current.RichPresenceCacheEntries.IncrementBy (-m_PresenceCache[titleId].htCacheEntries.Count);

                // Replace the existing/null InnerCache with the new InnerCache
                TitleEntry titleEntry = new TitleEntry();
                titleEntry.defaultLocale = defaultLocale;
                titleEntry.alLocales = alSupportedLocales;
                titleEntry.htCacheEntries = newInnerCache;
                m_PresenceCache[titleId] = titleEntry;

                // Increment the Perf Counter Value by the number of new entries
                PresenceCounters.Current.RichPresenceCacheEntries.IncrementBy(newInnerCache.Count);

                Xom.Trace(XomAreaName.PresenceRPDebug, LogLevel.L_INFO, "SUCCEEDED: Parsing config data for titleId = " + (TitleId) titleId);
                Xom.NtEvent( XEvent.Id.PRESENCE_TITLECONFIG_PARSE_SUCCESS, "Successfully parsed config data for titleId = {0}.", (TitleId) titleId);
            }
            catch(Exception e)
            {
                Xom.Trace(XomAreaName.PresenceRPDebug, LogLevel.L_ERROR, "FAILED: Parsing config data for titleId = " + (TitleId) titleId + "\r\n" + e.ToString());
                Xom.NtEvent( XEvent.Id.PRESENCE_TITLECONFIG_PARSE_FAILED, e, "Failed to parse config XML for titleId = {0}.", (TitleId) titleId);
            }                        
        }
        
        /// <summary>
        /// Loads the Updated Configuration Files since the last update
        /// </summary>
        /// <param name="dtLastUpdateTime">Last Update Time</param>
        private static void LoadNewConfigData( DateTime dtLastUpdateTime )
        {
            // Go to SQL and load new config files since the last update into the HTTP cache
            Xom.Trace(XomAreaName.PresenceRPDebug, LogLevel.L_INFO, "Presence FD: Loading config data from SQL, new config files since " + dtLastUpdateTime.ToString() );

            SqlConnection cxn = null;
            SqlCommand cmd = null;
            SqlParameter param = null;
            SqlDataReader reader = null;

            try
            {
                cxn = new SqlConnection( ConfigUtil.NpdbConnectionString );
                cxn.Open();
                
                cmd = new SqlCommand( "p_game_get_all_configs", cxn );
                cmd.CommandType = CommandType.StoredProcedure;
                
                param = new SqlParameter();
                param.ParameterName = "@dt_changed";
                param.Direction = ParameterDirection.Input;
                param.DbType = DbType.Date;
                param.Value = dtLastUpdateTime;
                cmd.Parameters.Add( param );

                reader = cmd.ExecuteReader();

                int titleIDOrd = reader.GetOrdinal("i_title_id");
                int dtChangedOrd = reader.GetOrdinal("dt_changed");
                int xmlConfigOrd = reader.GetOrdinal("xml_config");

                while( reader.Read() )
                {
                    // Add results to the HTTP cache
                    uint titleId = (uint) reader.GetInt32( titleIDOrd );
                    DateTime changedDate = (DateTime) reader.GetDateTime( dtChangedOrd );
                    string xmlConfig = reader.GetString( xmlConfigOrd );

                    XmlDocument xmlDoc = new XmlDocument();
                    try
                    {
                        xmlDoc.LoadXml(xmlConfig);
                    }
                    catch (Exception e)
                    {
                        Xom.Trace(XomAreaName.PresenceRPDebug, LogLevel.L_ERROR, "Presence FD: Loading XmlConfig failed");
                        Xom.NtEvent(XEvent.Id.PRESENCE_TITLECONFIG_BAD_FILE, e, "Presence FD: Loading XmlConfig failed.");

                        // Resume the Reader without Parsing
                        continue;
                    }

                    ParseConfigXml(titleId, xmlDoc);
                }

                // Set the Perf Counter for # of Titles
                PresenceCounters.Current.RichPresenceCacheTitles.RawValue = m_PresenceCache.Count;
             }
            catch (Exception e)
            {
                Xom.Trace(XomAreaName.PresenceRPDebug, LogLevel.L_ERROR, "Presence FD: Loading from SQL failed" );
                Xom.NtEvent(XEvent.Id.PRESENCE_TITLECONFIG_SQL_LOAD_FAILED, e, "Presence FD: Loading from SQL failed.");
                
                throw;
            }
            finally
            {
                if( cmd != null )
                {
                    cmd.Cancel();
                }
                if( reader != null ) 
                {
                    reader.Close();
                }
                if( cxn != null )
                {
                    cxn.Close();
                }
            }
        }

        private static void LoadConfigSchema( )
        {
            // Go to SQL and load new config files since the last update into the HTTP cache
            Xom.Trace(XomAreaName.PresenceRPDebug, LogLevel.L_INFO, "Presence FD: Loading config schema from SQL" );

            SqlConnection cxn = null;
            SqlCommand cmd = null;
            SqlParameter param = null;
            SqlDataReader reader = null;

            try
            {
                cxn = new SqlConnection( ConfigUtil.NpdbConnectionString );
                cxn.Open();
                
                cmd = new SqlCommand( "p_game_get_config", cxn );
                cmd.CommandType = CommandType.StoredProcedure;

                param = new SqlParameter();
                param.ParameterName = "@i_title_id";
                param.Direction = ParameterDirection.Input;
                param.DbType = DbType.Int32;
                param.Value = 0;
                cmd.Parameters.Add( param );

                reader = cmd.ExecuteReader();
                                
                if ( reader.Read() )
                {
                    int titleIDOrd = reader.GetOrdinal("i_title_id");
                    int dtChangedOrd = reader.GetOrdinal("dt_changed");
                    int xmlConfigOrd = reader.GetOrdinal("xml_config");
                    
                    // cache the schema for future validation
                    uint titleId = (uint) reader.GetInt32( titleIDOrd );
                    DateTime changedDate = (DateTime) reader.GetDateTime( dtChangedOrd );
                    string xmlSchema = reader.GetString( xmlConfigOrd );
                    
                    XmlDocument   xmlDoc = new XmlDocument();
                    xmlDoc.LoadXml(xmlSchema);

                    XmlNodeReader xsdReader = new XmlNodeReader(xmlDoc);

                    m_xsdReader = xsdReader;                    
                }    
                else
                {
                    Xom.Trace(XomAreaName.PresenceRPDebug, LogLevel.L_INFO, "Config schema was not found. ConfigXML validation will be skipped." );
                    Xom.NtEvent( XEvent.Id.PRESENCE_TITLECONFIG_NO_SCHEMA, "Config schema was not found. ConfigXML validation will be skipped." );                    
                }
            }
            catch (Exception e)
            {
                Xom.Trace(XomAreaName.PresenceRPDebug, LogLevel.L_ERROR, "Presence FD: Loading from SQL failed" );
                Xom.NtEvent(XEvent.Id.PRESENCE_TITLECONFIG_SQL_LOAD_FAILED, e, "Presence FD: Loading from SQL failed.");
                
                throw;
            }
            finally
            {
                if( cmd != null )
                {
                    cmd.Cancel();
                }
                if( reader != null ) 
                {
                    reader.Close();
                }
                if( cxn != null )
                {
                    cxn.Close();
                }
            }
        }

        /// <summary>
        /// Initializing Function, setting the Event Handlers
        /// </summary>
        public static void InitProc()
        {
            LoadGameConfigProc(null);
            
            // Setup an event to handle config change notifications
            Config.GameConfigChange += new GameConfigChangeEventHandler(RichPresenceFormatter.OnGameConfigChange);
            
            Config.MultiSettingChange += new MultiSettingChangeEventHandler(OnRPTitleBlacklistChange);
            
            //Seed the cache here to make sure invalid entries get flagged in the eventlog.
            //This should fire an event that is noticeable by Ops at startup.
            ValidateBlacklist(Config.GetMultiSetting(MultiSetting.presenceFD_StringPresence_BlackList));

            m_fInit = true;
        }

        /// <summary>
        /// Loads Configuration Files into the Cache
        /// </summary>
        /// <param name="o"></param>
        public static void LoadGameConfigProc(object o)
        {
            WindowsIdentity id = (WindowsIdentity)o;
            WindowsImpersonationContext impctx = null;
            DateTime dtNow = DateTime.UtcNow;

            if (id == null)
            {
                id = m_id;
            }
            
            try
            {
                impctx = id.Impersonate();
                
                // We are no longer validating config files via the XSD in the FD
                LoadNewConfigData( LastUpdateTime );
                LastUpdateTime = dtNow;
                
                Xom.Trace(XomAreaName.PresenceRPDebug, LogLevel.L_INFO, "LoadGameConfigProc called at " + LastUpdateTime.ToString());            
                
                impctx.Undo();
            }
            catch (Exception e)
            {
                Xom.NtEvent( XEvent.Id.PRESENCE_TITLECONFIG_LODEGAMECONFIGPROC_FAILED, e, "Failed to execute LoadGameConfigProc");
            }            
        }
        
        ///
        ///Is the title blacklisted?
        ///
        public static bool IsRPTitleBlacklisted(uint titleId)
        {
            TitleEntry entry;
            if (!m_PresenceCache.TryGetValue(titleId, out entry))
            {
                return false;
            }
            //Now we retrieve from the cache, the first hit may incur a DB hit
            return IsTitleInList(titleId, Config.GetMultiSetting(MultiSetting.presenceFD_StringPresence_BlackList));
        }

        private static bool IsTitleInList(uint titleId, string[] list)
        {
            foreach (string title in list)
            {
                if (string.IsNullOrEmpty(title))
                {
                    continue;
                }
                
                //This is a sanity check, should not happen
                TitleId tid;
                if (!TitleId.TryParse(title, out tid))
                {
                    continue;
                }
                if (tid == titleId)
                    return true;
            }
            return false;
        }

        public static void ValidateBlacklist(string[] blacklist)
        {
            //Sanity check
            if (null == blacklist)
                return;
            foreach (string setting in blacklist)
            {
                if (string.IsNullOrEmpty(setting))
                {
                    continue;
                }
                
                TitleId tid;
                TitleEntry entry;
                if (!TitleId.TryParse(setting, out tid) || !m_PresenceCache.TryGetValue(tid, out entry))
                {
                    //We also log an event indicating that the data is corrupt.
                    Xom.NtEvent(XEvent.Id.PRESENCE_CONFIG_PRESENCE_BLACKLIST, "XPNFD.PresenceFDContext.ValidateBlacklist: "
                        + "TitleId invalid for multisetting value "
                        + setting
                        + " for setting named " + MultiSetting.presenceFD_StringPresence_BlackList + "\r\n"
                        + "Possible reason: Not a titleid or titleid not in presence cache");
                }
            }
        }

        ///
        ///Respond to t_multisetting changes
        ///
        public static void OnRPTitleBlacklistChange(object sender, MultiSettingChangeEventArgs eventArgs)
        {
            /*Check out RefreshMultisettings in configinstance.cs for further details*/
            if (MultiSetting.presenceFD_StringPresence_BlackList == eventArgs.MultiSetting)
            {
                ValidateBlacklist(eventArgs.ValueNew);
            }
        }

        /// <summary>
        /// Event Handler for Configuration File Changes
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        public static void OnGameConfigChange(object sender, EventArgs e)
        {
            LoadGameConfigProc(null);
        }    

        /// <summary>
        /// Last Rich Presence Update Property
        /// </summary>
        public static DateTime LastUpdateTime
        {
            get { return m_dtLastUpdateTime; }
            set { m_dtLastUpdateTime = value; }
        }

        /// <summary>
        /// Xsd File Reader
        /// </summary>
        public static XmlNodeReader XsdReader
        {
            get { return m_xsdReader; }
            set { m_xsdReader = value; }
        }

        private static bool m_fInit = false; // Initialize Check for InitProc Call
        private static WindowsIdentity m_id = null;
        private static Dictionary<uint, TitleEntry> m_PresenceCache = null; // The main Cache that is hashed by TitleID, holding a Hashtable per TitleID
        private static XmlNodeReader m_xsdReader = null;           
        private static DateTime m_dtLastUpdateTime = new DateTime( 2001, 1, 1, 0, 0, 0, 0 ); // Last Update currently defaults to Jan 1, 2001


    } // class RichPresenceFormatter

} // namespace xonline.server.presence.fd
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\fd\sgnotifydelete.cs ===
// 
// SgNotifyDelete.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Presence Front Door
// Xbox Online Service
// 

using System;
using System.IO;
using System.Web;
using System.Threading;
using xonline.common.config;
using xonline.common.protocol;
using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.community;

namespace xonline.server.presence.fd
{
    // -----------------------------------------------------------------------------------
    // SgNotifyDelete class - handles DeadXbox/DeadSg notifications from the Security Gateway
    // -----------------------------------------------------------------------------------
    public class SgNotifyDelete : IHttpHandler
    {
        public static void ProcessDeadXboxMsg(object param)
        {
            XomRequestTimeElapsed elapsed = new XomRequestTimeElapsed();
            uint dwMsgType = (uint)P_MSG_TYPES.PMSG_DEAD_XBOX;
            
            try
            {
                CSgMsgNotifyCliDelete request = param as CSgMsgNotifyCliDelete;
                
                if( request.header._cbEnt != request.Size() )
                {
                    throw new XRLException(HResult.XONLINE_E_NOTIFICATION_MESSAGE_TRUNCATED, XEvent.Id.PRESENCE_SGNOTIFYDELETE_INNER_REQUEST_INVALID_LENGTH, "XPNFD.SgNotifyDelete.ProcessRequest: Size contained in request is incorrect (" + request.header._cbEnt.ToString() + " != " + request.Size().ToString() + ")" );                    
                }

                if( (ushort) SG_MSG_TYPES.SGMSG_TYPE_NOTIFY_CLI_DEL != request.header._wType )
                {
                    throw new XRLException(HResult.XONLINE_E_NOTIFICATION_MESSAGE_TRUNCATED, XEvent.Id.PRESENCE_SGNOTIFYDELETE_INNER_REQUEST_INVALID_TYPE, "XPNFD.SgNotifyDelete.ProcessRequest: Request has unexpected type (" + request.header._wType.ToString() + " != " + SG_MSG_TYPES.SGMSG_TYPE_NOTIFY_CLI_DEL.ToString() + ")");                    
                }

                //Kill all users on the xbox:
                MachineUserList list = PresenceUtil.GetMachineUserList(request._sgaddr);
                if (null != list)
                {
                    //If the presence cache does not find the entry
                    //the rgUsers array can be null
                    if (null != list.rgUsers)
                    {
                        //Get list of each user on the xbox
                        //Confirm sgaddr is equal to the sgaddr here.
                        foreach (ulong qwid in list.rgUsers)
                        {
                            PresenceRecord record = PresenceUtil.GetPresenceRecord(qwid);
                            if ((record != null) && (record.sgaddr.IsEqual(request._sgaddr)))
                            {
                                //Kill the user, their presence actually...
                                //don't want to physically kill them of course....
                                PresenceUtil.KillUser(record);

                                Xom.Log(XomAreaName.PresenceLog, "DXB|{0}|{1:X}|{2:X}|{3}",
                                        (Puid)request._sgaddr.qwXboxId,
                                        request._sgaddr.inaSg,
                                        request._sgaddr.dwSpiSg,
                                        (Puid)qwid);
                            }
                            else
                            {
                                // clean this stale user up from the machine list.
                                PresenceUtil.RemoveUserFromMachine(qwid, request._sgaddr);
                            }
                        }
                    }
                }

                PresencePerAPICounters.Total.SuccessRate.Increment();
                PresencePerAPICounters.Total[PresenceHandlerBase.GetRequestTypeName(dwMsgType)].SuccessRate.Increment();
            }
            catch( XRLException e )
            {
                Xom.Trace(XomAreaName.PresenceFDDebug, LogLevel.L_ERROR, "XPNFD.SgNotifyDelete.RequestLoop: XrlException, hr = " + e.HResult.ToString() + ", msg=" + e.Message + "." );

                // Since we are going to eat this exception, ensure we log the appropriate NT events here
                Xom.NtEvent( XEvent.Id.PRESENCE_SGNOTIFYDELETE_UNEXPECTED_FAILURE, e, "XPNFD.SgNotifyDelete.RequestLoop: Unexpected failure.");

                PresencePerAPICounters.Total.FailureRate.Increment();
                PresencePerAPICounters.Total[PresenceHandlerBase.GetRequestTypeName(dwMsgType)].FailureRate.Increment();
            }
            catch( Exception e )
            {
                Xom.Trace(XomAreaName.PresenceFDDebug, LogLevel.L_ERROR, "XPNFD.SgNotifyDelete.RequestLoop: Unexpected failure. msg=" + e.Message );
                
                // Since we are going to eat this exception, ensure we log the appropriate NT events here
                Xom.NtEvent( XEvent.Id.PRESENCE_SGNOTIFYDELETE_UNEXPECTED_FAILURE, e, "XPNFD.SgNotifyDelete.RequestLoop: Unexpected failure.");

                PresencePerAPICounters.Total.FailureRate.Increment();
                PresencePerAPICounters.Total[PresenceHandlerBase.GetRequestTypeName(dwMsgType)].FailureRate.Increment();
            }

            PresencePerAPICounters.Total.RequestsPerSecond.Increment();
            PresencePerAPICounters.Total[PresenceHandlerBase.GetRequestTypeName(dwMsgType)].RequestsPerSecond.Increment();
            PresencePerAPICounters.Total.ResponseTimeAvg.IncrementBy(elapsed.MillisecondsElapsed);
            PresencePerAPICounters.Total[PresenceHandlerBase.GetRequestTypeName(dwMsgType)].ResponseTimeAvg.IncrementBy(elapsed.MillisecondsElapsed);
            PresencePerAPICounters.Total.ResponseTimeAvgBase.Increment();
            PresencePerAPICounters.Total[PresenceHandlerBase.GetRequestTypeName(dwMsgType)].ResponseTimeAvgBase.Increment();
        }

        // -------------------------------------------------------------------------------
        // ProcessRequest - entry point for HTTP request
        // -------------------------------------------------------------------------------
        public void ProcessRequest( HttpContext ctx )
        {
            PresenceCounters.Current.SGNotifyDeleteInputTotal.Increment();
            PresenceCounters.Current.SGNotifyDeleteInputTotalRate.Increment();

            CSgMsgNotifyCliDelete request = new CSgMsgNotifyCliDelete();

            try
            {
                Presence.LogFDRequest();

                // validate service request on XRL post
                if( !XRLUtil.IsValidXOnlineRequest( ctx.Request, XOService.PresNotification ) )
                {
                    // The service ID in the request is incorrect (all other failures throw an XrlException)
                    throw new XRLException(HResult.XONLINE_E_BAD_CONTENT_TYPE, XEvent.Id.PRESENCE_SGNOTIFYDELETE_INVALID_SERVICEID, "XPNFD.SgNotifyDelete.ProcessRequest: Request is invalid." );                    
                 }

                if( ctx.Request.InputStream.Length < request.Size() )
                {
                    // Request too small
                    throw new XRLException(HResult.XONLINE_E_NOTIFICATION_MESSAGE_TRUNCATED, XEvent.Id.PRESENCE_SGNOTIFYDELETE_REQUEST_TOO_SMALL, "XPNFD.SgNotifyDelete.ProcessRequest: Request too small (" + ctx.Request.InputStream.Length.ToString() + " < " + request.Size().ToString() + ")" );                    
                }

                if( 0 != ctx.Request.InputStream.Length % request.Size() )
                {
                    throw new XRLException(HResult.XONLINE_E_NOTIFICATION_MESSAGE_TRUNCATED, XEvent.Id.PRESENCE_SGNOTIFYDELETE_REQUEST_INVALID_LENGTH, "XPNFD.SgNotifyDelete.ProcessRequest: Request size is not a multiple of size of CSgMsgNotifyCliDelete (" + ctx.Request.InputStream.Length.ToString() + ", " + request.Size().ToString() + ")" );                    
                }

                BinaryReader reader = new BinaryReader( ctx.Request.InputStream );

                // lock here to only allow one thread to add items to the queue at a time.  this helps preseve the ordering of queued items
                // that come in batches.  each batch will be added without any interleaving of items from other batches.
                lock (XpnfdApp.s_FanoutQueueLock)
                {
                    // read and queue each internal delete message.
                    while (ctx.Request.InputStream.Position < ctx.Request.InputStream.Length)
                    {
                        request = new CSgMsgNotifyCliDelete();
                        request.ReadStream(reader);
                        
                        // See if we have a dead xbox or SG
                        if( 0 == request._sgaddr.dwSpiSg &&
                            0 == request._sgaddr.qwXboxId )
                        {
                            // TODO: what do we do about deadsg?
                        }
                        else
                        {
                            XpnfdApp.m_tpWorker.QueueUserWorkItem(ProcessDeadXboxMsg, request);
                        }
                    }
                }

                XRLUtil.SetXRLResponse( ctx, ctx.Response, XOService.PresNotification, 0, HResult.S_OK, null);
            }
            catch( XRLException e )
            {
                Xom.Trace(XomAreaName.PresenceFDDebug, LogLevel.L_ERROR, "XPNFD.SgNotifyDelete.ProcessRequest: XrlException, hr = " + e.HResult.ToString() + ", msg=" + e.Message + "." );
                
                throw;
            }
            catch( Exception e )
            {
                Xom.Trace(XomAreaName.PresenceFDDebug, LogLevel.L_ERROR, "XPNFD.SgNotifyDelete.ProcessRequest: Unexpected failure. msg=" + e.Message );

                throw;
            }

        } // ProcessRequest
        
        // -------------------------------------------------------------------------------
        // IsReusable - allow reuse of this instance
        // -------------------------------------------------------------------------------
        public bool IsReusable
        {
            get { return true; }
        }

    } // class SgNotifyDelete

} // namespace xonline.server.presence.fd
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\fd\sgnotifytitlechange.cs ===
// 
// SgNotifyTitleChange.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Presence Front Door
// Xbox Online Service
// 

using System;
using System.IO;
using System.Web;
using System.Threading;
using xonline.common.config;
using xonline.common.protocol;
using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.community;

namespace xonline.server.presence.fd
{
    // -----------------------------------------------------------------------------------
    // SgNotifyTitleChange class - handles TitleChange notifications from the Security Gateway
    // -----------------------------------------------------------------------------------
    public class SgNotifyTitleChange : IHttpHandler
    {
        public static void ProcessTitleChangeMsg(object param)
        {
            XomRequestTimeElapsed elapsed = new XomRequestTimeElapsed();
            uint dwMsgType = (uint)P_MSG_TYPES.PMSG_TITLE_CHANGE;
            
            try
            {
                CSgMsgNotifyCliTitleChange request = param as CSgMsgNotifyCliTitleChange;
                
                if( request.header._cbEnt != request.Size() )
                {
                    throw new XRLException(HResult.XONLINE_E_NOTIFICATION_MESSAGE_TRUNCATED, XEvent.Id.PRESENCE_SGNOTIFYTITLECHANGE_INNER_REQUEST_INVALID_LENGTH, "XPNFD.SgNotifyTitleChange.ProcessRequest: Size contained in request is incorrect (" + request.header._cbEnt.ToString() + " != " + request.Size().ToString() + ")" );                    
                }

                if( (ushort) SG_MSG_TYPES.SGMSG_TYPE_NOTIFY_CLI_TCHG != request.header._wType )
                {
                    throw new XRLException(HResult.XONLINE_E_NOTIFICATION_MESSAGE_TRUNCATED, XEvent.Id.PRESENCE_SGNOTIFYTITLECHANGE_INNER_REQUEST_INVALID_TYPE, "XPNFD.SgNotifyTitleChange.ProcessRequest: Request has unexpected type (" + request.header._wType.ToString() + " != " + SG_MSG_TYPES.SGMSG_TYPE_NOTIFY_CLI_TCHG.ToString() + ")");                    
                }

                //Change all users on the xbox:
                MachineUserList list = PresenceUtil.GetMachineUserList(request._sgaddr);
                if (null != list)
                {
                    //If the presence cache does not find the entry
                    //the rgUsers array can be null
                    if (null != list.rgUsers)
                    {
                        //Get list of each user on the xbox
                        //Confirm sgaddr is equal to the sgaddr here.
                        foreach (ulong qwid in list.rgUsers)
                        {
                            PresenceRecord record = PresenceUtil.GetPresenceRecord(qwid);
                            bool fAccepted = true;
                            
                            do
                            {
                                if ((record != null) && (record.sgaddr.IsEqual(request._sgaddr)))
                                {
                                    record.extension.dwPrevSGTitleId = request._dwOldTitleId;
                                    record.extension.dwCurrentSGTitleId = request._dwNewTitleId;
                                }
                                else
                                {
                                    // clean this stale user up from the machine list.
                                    PresenceUtil.RemoveUserFromMachine(qwid, request._sgaddr);
                                    fAccepted = false;
                                    break;
                                }
                            }
                            while (!record.TryWrite());

                            if (fAccepted)
                            {
                                uint dwHeaderFlags = 0;
                                if ((record.dwState & PresDefs.P_STATE_FLAG_CLOAKED) == 0)
                                {
                                    UserPrivileges privs = PresenceUtil.GetUserPrivileges(record.OwnerID);
                                    dwHeaderFlags |= privs.HasPrivilege(XOn.XPRIVILEGE_PRESENCE) ? (uint)CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_EVERYONE : 0;
                                    dwHeaderFlags |= privs.HasPrivilege(XOn.XPRIVILEGE_PRESENCE_FRIENDS_ONLY) ? (uint)CacheUtil.XONLINE_CACHE_DATA_FLAG_SHARE_FRIENDS : 0;
                                }

                                PresenceEvents.PublishTitleIdChange(new PresenceEvents.TitleIdChangeEventArgs()
                                {
                                    Xuid = record.OwnerID, 
                                    TitleId = request._dwNewTitleId,
                                    Privacy = dwHeaderFlags, 
                                    PlatformType = PresDefs.GetPlatformType(record.dwState), 
                                    ClientVersion = record.ClientVersion
                                });

                                Xom.Log(XomAreaName.PresenceLog, "TCHG|{0}|{1:X}|{2:X}|{3}|{4}|{5}",
                                    (Puid)request._sgaddr.qwXboxId,
                                    request._sgaddr.inaSg,
                                    request._sgaddr.dwSpiSg,
                                    (Puid)qwid,
                                    (TitleId)request._dwOldTitleId,
                                    (TitleId)request._dwNewTitleId);
                            }
                        }
                    }
                }

                PresencePerAPICounters.Total.SuccessRate.Increment();
                PresencePerAPICounters.Total[PresenceHandlerBase.GetRequestTypeName(dwMsgType)].SuccessRate.Increment();
            }
            catch( XRLException e )
            {
                Xom.Trace(XomAreaName.PresenceFDDebug, LogLevel.L_ERROR, "XPNFD.SgNotifyTitleChange.RequestLoop: XrlException, hr = " + e.HResult.ToString() + ", msg=" + e.Message + "." );

                // Since we are going to eat this exception, ensure we log the appropriate NT events here
                Xom.NtEvent( XEvent.Id.PRESENCE_SGNOTIFYTITLECHANGE_UNEXPECTED_FAILURE, e, "XPNFD.SgNotifyTitleChange.RequestLoop: Unexpected failure.");

                PresencePerAPICounters.Total.FailureRate.Increment();
                PresencePerAPICounters.Total[PresenceHandlerBase.GetRequestTypeName(dwMsgType)].FailureRate.Increment();
            }
            catch( Exception e )
            {
                Xom.Trace(XomAreaName.PresenceFDDebug, LogLevel.L_ERROR, "XPNFD.SgNotifyTitleChange.RequestLoop: Unexpected failure. msg=" + e.Message );
                
                // Since we are going to eat this exception, ensure we log the appropriate NT events here
                Xom.NtEvent( XEvent.Id.PRESENCE_SGNOTIFYTITLECHANGE_UNEXPECTED_FAILURE, e, "XPNFD.SgNotifyTitleChange.RequestLoop: Unexpected failure.");

                PresencePerAPICounters.Total.FailureRate.Increment();
                PresencePerAPICounters.Total[PresenceHandlerBase.GetRequestTypeName(dwMsgType)].FailureRate.Increment();
            }

            PresencePerAPICounters.Total.RequestsPerSecond.Increment();
            PresencePerAPICounters.Total[PresenceHandlerBase.GetRequestTypeName(dwMsgType)].RequestsPerSecond.Increment();
            PresencePerAPICounters.Total.ResponseTimeAvg.IncrementBy(elapsed.MillisecondsElapsed);
            PresencePerAPICounters.Total[PresenceHandlerBase.GetRequestTypeName(dwMsgType)].ResponseTimeAvg.IncrementBy(elapsed.MillisecondsElapsed);
            PresencePerAPICounters.Total.ResponseTimeAvgBase.Increment();
            PresencePerAPICounters.Total[PresenceHandlerBase.GetRequestTypeName(dwMsgType)].ResponseTimeAvgBase.Increment();
        }

        // -------------------------------------------------------------------------------
        // ProcessRequest - entry point for HTTP request
        // -------------------------------------------------------------------------------
        public void ProcessRequest( HttpContext ctx )
        {
            PresenceCounters.Current.SGNotifyTitleChangeInputTotal.Increment();
            PresenceCounters.Current.SGNotifyTitleChangeInputTotalRate.Increment();

            CSgMsgNotifyCliTitleChange request = new CSgMsgNotifyCliTitleChange();

            try
            {
                Presence.LogFDRequest();

                // validate service request on XRL post
                if( !XRLUtil.IsValidXOnlineRequest( ctx.Request, XOService.PresNotification ) )
                {
                    // The service ID in the request is incorrect (all other failures throw an XrlException)
                    throw new XRLException(HResult.XONLINE_E_BAD_CONTENT_TYPE, XEvent.Id.PRESENCE_SGNOTIFYTITLECHANGE_INVALID_SERVICEID, "XPNFD.SgNotifyTitleChange.ProcessRequest: Request is invalid." );                    
                 }

                if( ctx.Request.InputStream.Length < request.Size() )
                {
                    // Request too small
                    throw new XRLException(HResult.XONLINE_E_NOTIFICATION_MESSAGE_TRUNCATED, XEvent.Id.PRESENCE_SGNOTIFYTITLECHANGE_REQUEST_TOO_SMALL, "XPNFD.SgNotifyTitleChange.ProcessRequest: Request too small (" + ctx.Request.InputStream.Length.ToString() + " < " + request.Size().ToString() + ")" );                    
                }

                if( 0 != ctx.Request.InputStream.Length % request.Size() )
                {
                    throw new XRLException(HResult.XONLINE_E_NOTIFICATION_MESSAGE_TRUNCATED, XEvent.Id.PRESENCE_SGNOTIFYTITLECHANGE_REQUEST_INVALID_LENGTH, "XPNFD.SgNotifyTitleChange.ProcessRequest: Request size is not a multiple of size of CSgMsgNotifyCliTitleChange (" + ctx.Request.InputStream.Length.ToString() + ", " + request.Size().ToString() + ")" );                    
                }

                BinaryReader reader = new BinaryReader( ctx.Request.InputStream );

                // lock here to only allow one thread to add items to the queue at a time.  this helps preseve the ordering of queued items
                // that come in batches.  each batch will be added without any interleaving of items from other batches.
                lock (XpnfdApp.s_FanoutQueueLock)
                {
                    // read and queue each internal titlechange message.
                    while (ctx.Request.InputStream.Position < ctx.Request.InputStream.Length)
                    {
                        request = new CSgMsgNotifyCliTitleChange();
                        request.ReadStream(reader);
                        
                        XpnfdApp.m_tpWorker.QueueUserWorkItem(ProcessTitleChangeMsg, request);
                    }
                }

                XRLUtil.SetXRLResponse( ctx, ctx.Response, XOService.PresNotification, 0, HResult.S_OK, null);
            }
            catch( XRLException e )
            {
                Xom.Trace(XomAreaName.PresenceFDDebug, LogLevel.L_ERROR, "XPNFD.SgNotifyTitleChange.ProcessRequest: XrlException, hr = " + e.HResult.ToString() + ", msg=" + e.Message + "." );
                
                throw;
            }
            catch( Exception e )
            {
                Xom.Trace(XomAreaName.PresenceFDDebug, LogLevel.L_ERROR, "XPNFD.SgNotifyTitleChange.ProcessRequest: Unexpected failure. msg=" + e.Message );

                throw;
            }

        } // ProcessRequest
        
        // -------------------------------------------------------------------------------
        // IsReusable - allow reuse of this instance
        // -------------------------------------------------------------------------------
        public bool IsReusable
        {
            get { return true; }
        }

    } // class SgNotifyTitleChange

} // namespace xonline.server.presence.fd
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\fd\PubSubNotifications.cs ===
ï»¿using System;
using System.Collections.Generic;
using System.Runtime.Serialization;
using System.Runtime.Serialization.Json;
using System.IO;
using System.Net;
using System.Web;
using Microsoft.IdentityModel.Claims;
using Microsoft.XboxLive.Auth;
using Microsoft.XboxLive.Auth.Claims;
using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.protocol;
using xonline.common.service;
using xonline.common.community;

namespace xonline.server.presence.fd
{
    public class PubSubNotifications
    {
        protected static FastFailHelper _fastfail = new FastFailHelper(
        Setting.PubSubEvent_fastFailTimeoutThresholdCount, 
        Setting.PubSubEvent_fastFailTimeoutTimespanSeconds, 
        Setting.PubSubEvent_fastFailBlockIntervalSeconds);

        public static void Initialize()
        {
            PresenceEvents.LoginChange += ((object sender, PresenceEvents.LoginChangeEventArgs args) =>
            {
                NotifyLoginChange(args.Xuid, args.TitleId, args.Privacy, args.PlatformType, args.ClientVersion);
            });
            PresenceEvents.Announce += ((object sender, PresenceEvents.AnnounceEventArgs args) =>
            {
                NotifyAnnounce(args.Xuid, args.TitleId, args.Privacy, args.PlatformType, args.ClientVersion);
            });
            PresenceEvents.TitleIdChange += ((object sender, PresenceEvents.TitleIdChangeEventArgs args) =>
            {
                NotifyTitleChange(args.Xuid, args.TitleId, args.Privacy, args.PlatformType, args.ClientVersion);
            });
            PresenceEvents.FriendsChange += ((object sender, PresenceEvents.FriendsChangeEventArgs args) =>
            { 
                NotifyFriendsChange(args.Xuid1, args.Xuid2, args.AreFriends);   
            });
        }

        public static void NotifyLoginChange(ulong xuid, uint titleid, uint privacy, uint platformType, XBOX_LIBRARY_VERSION clientVersion)
        {
            try
            {
                if (!Config.GetBoolSetting(Setting.presence_pubsubNotificationEnabled))
                {
                    return;
                }

                DataContractJsonSerializer logonChangeSz = new DataContractJsonSerializer(typeof(LogonEventData));
                String serviceUrl = Config.GetSetting(Setting.presence_pubsubEventUrl);
           
                LogonEventData change = new LogonEventData()
                {
                    UserId = xuid,
                    TitleId = titleid, 
                    PresencePrivacy = privacy,
                    ClientPlatformType = platformType,
                    ClientVersion = new ClientVersionData()
                    {
                        MajorVersion = clientVersion.wMajorVersion,
                        MinorVersion = clientVersion.wMinorVersion,
                        QFENumber = clientVersion.wQFENumber,
                        BuildNumber = clientVersion.wBuildNumber
                    }
                };

                String url = String.Format(serviceUrl, "UserLoggedOn", "1");
                MemoryStream mStream = new MemoryStream();
                logonChangeSz.WriteObject(mStream, change);
                PublishEvent(url, mStream.ToArray(), GetSLSInternalClaims(xuid));
            }
            catch (System.Exception e)
            {
                Xom.Log(XomAreaName.PresenceLog, e, "Failed to notify login change to pubsub");
            }
        }

        public static void NotifyAnnounce(ulong xuid, uint titleid, uint privacy, uint platformType, XBOX_LIBRARY_VERSION clientVersion)
        {
            try
            {
                if (!Config.GetBoolSetting(Setting.presence_pubsubNotificationEnabled))
                {
                    return;
                }

                DataContractJsonSerializer logonChangeSz = new DataContractJsonSerializer(typeof(AnnounceEventData));
                String serviceUrl = Config.GetSetting(Setting.presence_pubsubEventUrl);
           
                AnnounceEventData change = new AnnounceEventData()
                {
                    UserId = xuid,
                    TitleId = titleid,
                    PresencePrivacy = privacy,
                    ClientPlatformType = platformType,
                    ClientVersion = new ClientVersionData()
                    {
                        MajorVersion = clientVersion.wMajorVersion,
                        MinorVersion = clientVersion.wMinorVersion,
                        QFENumber = clientVersion.wQFENumber,
                        BuildNumber = clientVersion.wBuildNumber
                    }
                };

                String url = String.Format(serviceUrl, "UserAnnounce", "1");
                MemoryStream mStream = new MemoryStream();
                logonChangeSz.WriteObject(mStream, change);
                PublishEvent(url, mStream.ToArray(), GetSLSInternalClaims(xuid));
            }
            catch (System.Exception e)
            {
                Xom.Log(XomAreaName.PresenceLog, e, "Failed to notify announce to pubsub");
            }
        }

        public static void NotifyTitleChange(ulong xuid, uint titleId, uint privacy, uint platformType, XBOX_LIBRARY_VERSION clientVersion)
        {
            try
            {
                if (!Config.GetBoolSetting(Setting.presence_pubsubNotificationEnabled))
                {
                    return;
                }

                DataContractJsonSerializer titleChangeSz = new DataContractJsonSerializer(typeof(TitleChangeEventData));
                String serviceUrl = Config.GetSetting(Setting.presence_pubsubEventUrl);
                TitleChangeEventData change = new TitleChangeEventData()
                {
                    UserId  = xuid,
                    TitleId = titleId,
                    PresencePrivacy = privacy,
                    ClientPlatformType = platformType,
                    ClientVersion = new ClientVersionData()
                    {
                        MajorVersion = clientVersion.wMajorVersion,
                        MinorVersion = clientVersion.wMinorVersion,
                        QFENumber = clientVersion.wQFENumber,
                        BuildNumber = clientVersion.wBuildNumber
                    }
                };

                String url = String.Format(serviceUrl, "TitleChanged", "1");
                MemoryStream mStream = new MemoryStream();
                titleChangeSz.WriteObject(mStream, change);
                PublishEvent(url, mStream.ToArray(), GetSLSInternalClaims(xuid));
            }
            catch (System.Exception e) 
            {
                Xom.Log(XomAreaName.PresenceLog, e, "Failed to notify titleid change to pubsub");
            }
        }

        public static void NotifyFriendsChange(ulong xuid, ulong friendxuid, bool status)
        {
            try
            {
                if (!Config.GetBoolSetting(Setting.presence_pubsubNotificationEnabled))
                {
                    return;
                }

                DataContractJsonSerializer freindsChangeSz = new DataContractJsonSerializer(typeof(FriendsChangeEventData));
                String serviceUrl = Config.GetSetting(Setting.presence_pubsubEventUrl);
                FriendsChangeEventData change = new FriendsChangeEventData()
                {
                    UserId1 = xuid,
                    UserId2 = friendxuid,
                    AreFriends = status
                };

                String url = String.Format(serviceUrl, "FriendsChange", "1");
                MemoryStream mStream = new MemoryStream();
                freindsChangeSz.WriteObject(mStream, change);
                PublishEvent(url, mStream.ToArray(), GetSLSInternalClaims(xuid));
            }
            catch (System.Exception e)
            {
                Xom.Log(XomAreaName.PresenceLog, e, "Failed to notify friends change to pubsub");
            }
        }

        private static void PublishEvent(String url, byte[] postData, IClaimsPrincipal internalClaims)
        {
            // check fast fail first.
            if (_fastfail.InFastFailState(url))
            {
                return;
            }
            
            HttpWebRequest webrequest = HttpWebRequest.Create(url) as HttpWebRequest;
            webrequest.ContentType = "application/json";
            webrequest.Method = "POST";
            if(internalClaims != null)
            {
                webrequest.Headers.SetXAuthdata(internalClaims);
            }
            webrequest.Timeout = Config.GetIntSetting(Setting.presence_pubsubEventTimeout);
            Stream requestStream = webrequest.GetRequestStream();
            requestStream.Write(postData, 0, postData.Length);
            requestStream.Close();

            HttpWebResponse response = null;
            try
            {
                response = (HttpWebResponse)webrequest.GetResponse();
                _fastfail.ReportSuccess(url);
            }
            catch (System.Exception e)//catch any exceptions
            {
                _fastfail.ReportFailure(url, "Timed out.");
                Xom.Log(XomAreaName.PresenceLog, e, "Failed to notify change to pubsub. Url: {0}", url);
            }
            finally
            {
                if (response != null)
                {
                    response.Close(); //closes the response and any underlying stream
                }
            }
        }

        private static IClaimsPrincipal GetSLSInternalClaims(ulong xuid)
        {
            string slsinternalClaimType = "http://services.xboxlive.com/sls/internalServiceClaim";
            List<Claim> claims = new List<Claim>(2)
            {
                new Claim(
                    slsinternalClaimType, 
                    "Presence", 
                    "string", 
                    "Presence"),
                new Claim(
                    AuthClaimTypes.Xuid,
                    xuid.ToString("d"),
                    AuthClaimTypes.ValueTypes[AuthClaimTypes.Xuid],
                    new AuthHelper().Issuer)
            };
            
            ClaimsIdentity[] ids = new ClaimsIdentity[1];
            ids[0] = new ClaimsIdentity(claims);
            ClaimsIdentityCollection cic = new ClaimsIdentityCollection(ids);
            return new ClaimsPrincipal(cic);
        }

        [DataContract]
        class FriendsChangeEventData
        {
            [DataMember] public ulong UserId1 { get; set; }
            [DataMember] public ulong UserId2 { get; set; }
            [DataMember] public bool AreFriends { get; set; }
        }

        [DataContract]
        class LogonEventData
        {
            [DataMember] public ulong UserId { get; set; }
            [DataMember] public uint TitleId { get; set; }
            [DataMember] public uint PresencePrivacy { get; set; }
            [DataMember] public uint ClientPlatformType { get; set; }
            [DataMember] public ClientVersionData ClientVersion { get; set; }
        }

        [DataContract]
        class AnnounceEventData
        {
            [DataMember] public ulong UserId { get; set; }
            [DataMember] public uint TitleId { get; set; }
            [DataMember] public uint PresencePrivacy { get; set; }
            [DataMember] public uint ClientPlatformType { get; set; }
            [DataMember] public ClientVersionData ClientVersion { get; set; }
        }

        [DataContract]
        class TitleChangeEventData
        {
            [DataMember] public ulong UserId { get; set; }
            [DataMember] public uint TitleId { get; set; }
            [DataMember] public uint PresencePrivacy { get; set; }
            [DataMember] public uint ClientPlatformType { get; set; }
            [DataMember] public ClientVersionData ClientVersion { get; set; }
        }

        [DataContract]
        class ClientVersionData
        {
            [DataMember] public ushort MajorVersion { get; set; }
            [DataMember] public ushort MinorVersion { get; set; }
            [DataMember] public ushort BuildNumber { get; set; }
            [DataMember] public ushort QFENumber { get; set; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\fd\WebAlive2.cs ===
using System;
using System.IO;
using System.Web;
using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.protocol;
using xonline.common.service;
using xonline.common.community;
using xonline.common.sql.webstore;
using Microsoft.Webstore.WstClient;

namespace xonline.server.presence.fd
{
    internal class WebAlive2Handler : PresenceHandlerBase
    {
        private WebAlive2Request _request;
        private WebAliveResponse _response;
        private uint _dwTitleID;

        public WebAlive2Handler(BaseHeader header)
            : base(header)
        {
            _request = new WebAlive2Request();
            _response = new WebAliveResponse();
        }

        public override void ProcessRequest()
        {
            //Parse out the request
            _request.ReadStream(new BinaryReader(HttpContext.Current.Request.InputStream));

            // User id of 0 check is not necessary since PresenceHandlerBase calls it
            // If that code ever changes we need to check 0 user id scenario here too.

            _response.puid = _request.puid;

            bool fReconstruct; // unused.
            PresenceRecord record = PresenceRecord.ReadOrCreate(_request.puid, out fReconstruct);

            // get the titleid from the request.  if titleId is 0 the default to xbox.com.
            _dwTitleID = (_request.titleId > 0) ? _request.titleId : XOn.WEB_TITLE_ID;

            record.SetLastWebTime(_dwTitleID);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="hr">Error return code</param>
        public override HResult ProcessError(HResult hr)
        {
            _response.hr = hr;
            return HResult.S_OK;
        }

        /// <summary>
        /// 
        /// </summary>
        public override void LogResults()
        {
            Xom.Log(XomAreaName.PresenceLog, "WebAlive2|{0}:{1:X}|{2}|{3}|{4}",
                    SGInfo.Current.ClientIP,
                    SGInfo.Current.ClientPort,
                    (Puid)_request.puid,
                    _dwTitleID,
                    _response.hr);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <returns>Base class that derives from XRLObject2</returns>
        protected override XRLObject2 GetResponse()
        {
            _response.header.dwSeqNum = m_header.dwSeqNum;
            _response.header.sgaddr = m_header.sgaddr;
            return _response;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\fd\WebAlive.cs ===
using System;
using System.IO;
using System.Web;
using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.protocol;
using xonline.common.service;
using xonline.common.community;
using xonline.common.sql.webstore;
using Microsoft.Webstore.WstClient;

namespace xonline.server.presence.fd
{

    internal class WebAliveHandler : PresenceHandlerBase
    {
        private WebAliveRequest _request;
        private WebAliveResponse _response;
        private uint _dwTitleID;

        public WebAliveHandler(BaseHeader header)
            : base(header)
        {
            _request = new WebAliveRequest();
            _response = new WebAliveResponse();
        }

        public override void ProcessRequest()
        {
            //Parse out the request
            _request.ReadStream(new BinaryReader(HttpContext.Current.Request.InputStream));

            // User id of 0 check is not necessary since PresenceHandlerBase calls it
            // If that code ever changes we need to check 0 user id scenario here too.

            _response.puid = _request.puid;

            bool fReconstruct; // unused.
            PresenceRecord record = PresenceRecord.ReadOrCreate(_request.puid, out fReconstruct);

            // get the titleid to use from the platform type.  default to xbox.com.
            _dwTitleID = XOn.WEB_TITLE_ID;
            int platformType = 0;
            if (SGInfo.IsFromLiveCache())
            {
                string OnBehalfHeader = HttpContext.Current.Request.Headers[XHttpHdr.XPLT_I];

                if (!String.IsNullOrEmpty(OnBehalfHeader))
                {
                    platformType = int.Parse(OnBehalfHeader);
                    switch (platformType)
                    {
                    case XOn.XPLT_MOBILE:
                        _dwTitleID = XOn.MOBILE_TITLE_ID;
                        break;
                    }
                }
            }

            record.SetLastWebTime(_dwTitleID);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="hr">Error return code</param>
        public override HResult ProcessError(HResult hr)
        {
            _response.hr = hr;
            return HResult.S_OK;
        }

        /// <summary>
        /// 
        /// </summary>
        public override void LogResults()
        {
            Xom.Log(XomAreaName.PresenceLog, "WebAlive|{0}:{1:X}|{2}|{3}|{4}",
                    SGInfo.Current.ClientIP,
                    SGInfo.Current.ClientPort,
                    (Puid)_request.puid,
                    _dwTitleID,
                    _response.hr);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <returns>Base class that derives from XRLObject2</returns>
        protected override XRLObject2 GetResponse()
        {
            _response.header.dwSeqNum = m_header.dwSeqNum;
            _response.header.sgaddr = m_header.sgaddr;
            return _response;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\inh\BufferPool.cpp ===
#include "stdafx.h"

BufferPool *g_pBufferPool = NULL;

CTCPCntVarPoolBuffer * CTCPCntVarPoolBuffer::CreateInstance(BufferPool *pPool, DWORD dwIndex)
{
    if (pPool == NULL)
    {
        return NULL;
    }
    
    CTCPCntVarPoolBuffer *pCRet;

    pCRet = (CTCPCntVarPoolBuffer *) XAlloc(POOLBUFFER_DEFAULT_SIZE + sizeof(CTCPCntVarPoolBuffer));
    if (pCRet == NULL)
    {
        return NULL;
    }
    else
    {
        pCRet->CTCPCntVarPoolBuffer::CTCPCntVarPoolBuffer();
        pCRet->m_cbBuffer = POOLBUFFER_DEFAULT_SIZE;
        pCRet->m_pPool = pPool;
        pCRet->m_dwPoolIndex = dwIndex;
        return pCRet;
    }        
}
        
ULONG CTCPCntVarPoolBuffer::Release()
{
    // call parent release.
    ULONG refCount = CTCPCntVarBuffer::Release();

    // check if anyone other than us still has a handle.
    if (refCount == 1)
    {
        // its just us.  reset the buffer size to what we know it really is, then give it back to the pool.
        m_cbBuffer = POOLBUFFER_DEFAULT_SIZE;
        m_pPool->ReclaimBuffer(this);
    }

    return refCount;
}

BufferPool::BufferPool() :
    m_cBuffers(0),
    m_cUsedBuffers(0),
    m_rgBuffers(NULL)    
{
    InitializeCriticalSection(&m_cs);
    
    // make some buffers to start.
    Grow(BUFFERPOOL_INIT_NUM_BUFFERS);
}

BufferPool::~BufferPool()
{
    EnterCriticalSection(&m_cs);
    
    for (DWORD iBuffer = 0; iBuffer < m_cBuffers; iBuffer++)
    {
        m_rgBuffers[iBuffer]->Release();
    }

    delete m_rgBuffers;
    
    LeaveCriticalSection(&m_cs);
    
    DeleteCriticalSection(&m_cs);
}

bool BufferPool::Grow(DWORD dwNewSize)
{
    bool fRet = false;

    if (m_cBuffers == BUFFERPOOL_MAX_NUM_BUFFERS)
    {
        XomNtEvent(XEVENT_PRESENCE_CODE_29, "BufferPool::Grow() reached max buffers.");
        return fRet;
    }

    if (dwNewSize > BUFFERPOOL_MAX_NUM_BUFFERS)
    {
        dwNewSize = BUFFERPOOL_MAX_NUM_BUFFERS;
    }
    
    // new pool array
    CTCPCntVarPoolBuffer **rgNew = new CTCPCntVarPoolBuffer *[dwNewSize];
    if (rgNew == NULL)
    {
        return fRet;
    }

    // copy the old buffer pointers
    memcpy(rgNew, m_rgBuffers, m_cBuffers * sizeof(CTCPCntVarPoolBuffer *));
    // delete the old array
    delete m_rgBuffers;

    m_rgBuffers = rgNew;

    // make new buffers
    while (m_cBuffers < dwNewSize)
    {
        m_rgBuffers[m_cBuffers] = CTCPCntVarPoolBuffer::CreateInstance(this, m_cBuffers);
        if (m_rgBuffers[m_cBuffers] == NULL)
        {
            // stop if there are any NULLs.
            XomNtEvent(XEVENT_PRESENCE_CODE_30, "BufferPool::Grow() could not allocate buffer #%d", m_cBuffers);
            break;
        }
        
        fRet = true;
        m_cBuffers++;
    }

    return fRet;
}
    
CTCPCntVarBuffer *BufferPool::GetBuffer(DWORD dwSize)
{
    CTCPCntVarBuffer *pBuffer = NULL;
    
    EnterCriticalSection(&m_cs);
    
    if (dwSize > POOLBUFFER_DEFAULT_SIZE)
    {
        // requested size is bigger than the pool buffers.  just bypass the pool.
        pBuffer = CTCPCntVarBuffer::CreateInstance(dwSize);
        goto lDone;
    }

    // no room?  make more?
    if ((m_cUsedBuffers == m_cBuffers) && !Grow(m_cBuffers * 2))
    {
        // pool is full and we couldnt grow.  bypass the pool.
        pBuffer = CTCPCntVarBuffer::CreateInstance(dwSize);
        goto lDone;
    }
    
    pBuffer = (CTCPCntVarBuffer *)m_rgBuffers[m_cUsedBuffers];

    // add the caller's reference.
    pBuffer->AddRef();

    // size it to the requested nubmer of bytes.
    pBuffer->Resize(dwSize);

    // one more in use.
    m_cUsedBuffers++;

lDone:
    
    LeaveCriticalSection(&m_cs);

    return pBuffer;
}

void BufferPool::ReclaimBuffer(CTCPCntVarPoolBuffer *pBuffer)
{
    EnterCriticalSection(&m_cs);
    
    if ((pBuffer == NULL) ||
        (m_cUsedBuffers == 0) ||
        (m_cBuffers == 0))
    {
        goto lDone;
    }
    
    // one less in use
    m_cUsedBuffers--;

    // switch positions in the pool with the last used buffer.
    DWORD dwIndex = pBuffer->GetPoolIndex();
    m_rgBuffers[dwIndex] = m_rgBuffers[m_cUsedBuffers];
    m_rgBuffers[dwIndex]->SetPoolIndex(dwIndex);
    m_rgBuffers[m_cUsedBuffers] = pBuffer;
    pBuffer->SetPoolIndex(m_cUsedBuffers);

lDone:

    LeaveCriticalSection(&m_cs);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\inh\BufferPool.h ===
#ifndef BUFFERPOOL_H_INCLUDED
#define BUFFERPOOL_H_INCLUDED

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "tcpcnt.h"

#define POOLBUFFER_DEFAULT_SIZE (g_CPresCfg.GetPoolBufferSize())
#define BUFFERPOOL_INIT_NUM_BUFFERS (g_CPresCfg.GetStartNumPoolBuffers())
#define BUFFERPOOL_MAX_NUM_BUFFERS (g_CPresCfg.GetMaxNumPoolBuffers())

class BufferPool;

extern BufferPool *g_pBufferPool;

class CTCPCntVarPoolBuffer :
    public CTCPCntVarBuffer
{

friend class BufferPool;
    
public:

    virtual ULONG Release();
    
    virtual BYTE* GetBuffer()
    {
        return (BYTE *)(this + 1);
    }

    void operator delete(void *pv) { XFree(pv); }
    
    DWORD GetPoolIndex() { return m_dwPoolIndex; }
    void SetPoolIndex(DWORD dwIndex) { m_dwPoolIndex = dwIndex; }
                
protected:
    
    static CTCPCntVarPoolBuffer * __stdcall CreateInstance(BufferPool *pPool, DWORD dwIndex);
    
    void *operator new(size_t len) { return NULL; }

    BufferPool *m_pPool;    
    DWORD m_dwPoolIndex;    
};


// NOTE: BufferPool is NOT threadsafe!  Only use BufferPool from switchboard's thread.
class BufferPool {
    
friend class CTCPCntVarPoolBuffer;

public:

    BufferPool();    
    ~BufferPool();

    DWORD GetPoolSize() { return m_cBuffers; }
    DWORD NumBuffersInUse() { return m_cUsedBuffers; }
    
    CTCPCntVarBuffer *GetBuffer(DWORD dwSize);

protected:
    
    bool Grow(DWORD dwNewSize);
    void ReclaimBuffer(CTCPCntVarPoolBuffer *pBuffer);

    CTCPCntVarPoolBuffer **m_rgBuffers;
    DWORD m_cBuffers;
    DWORD m_cUsedBuffers;

    CRITICAL_SECTION m_cs;
};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\fd\sgnotifyupdate.cs ===
// 
// SgNotifyUpdate.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Presence Front Door
// Xbox Online Service
// 

using System;
using System.IO;
using System.Web;
using System.Text;
using System.Net;
using System.Threading;
using System.Collections;
using xonline.common.config;
using xonline.common.community;
using xonline.common.protocol;
using xonline.common.mgmt;
using xonline.common.service;

namespace xonline.server.presence.fd
{
    public class UserStateContext
    {
        public CSgMsgNotifyCliUpdate request;
        public ulong qwSGSeqNum;
    }
    
    // -----------------------------------------------------------------------------------
    // SgNotifyUpdate class - handles State notifications from the Security Gateway
    // -----------------------------------------------------------------------------------
    public class SgNotifyUpdate : IHttpHandler
    {
        public static void ProcessState2Msg(object param)
        {
            XomRequestTimeElapsed elapsed = new XomRequestTimeElapsed();
            
            try
            {
                UserStateContext ctx = param as UserStateContext;
                CSgMsgNotifyCliUpdate request = ctx.request;

                if( request.header._cbEnt != request.Size() )
                {
                    throw new XRLException(HResult.XONLINE_E_NOTIFICATION_MESSAGE_TRUNCATED, XEvent.Id.PRESENCE_SGNOTIFYUPDATE_INNER_REQUEST_INVALID_LENGTH, "XPNFD.SgNotifyUpdate.ProcessRequest: Size contained in request is incorrect (" + request.header._cbEnt.ToString() + " != " + request.Size().ToString() + ")" );                    
                }

                if( (ushort) SG_MSG_TYPES.SGMSG_TYPE_NOTIFY_CLI_UPD != request.header._wType )
                {
                    throw new XRLException(HResult.XONLINE_E_NOTIFICATION_MESSAGE_TRUNCATED, XEvent.Id.PRESENCE_SGNOTIFYUPDATE_INNER_REQUEST_INVALID_TYPE, "XPNFD.SgNotifyUpdate.ProcessRequest: Request has unexpected type (" + request.header._wType.ToString() + " != " + SG_MSG_TYPES.SGMSG_TYPE_NOTIFY_CLI_UPD.ToString() + ")" );                    
                }

                RichPresence rpData = new RichPresence();
                byte[] rgbRPData = new byte[0];
                string[] rgLocales = null;
                string[] rgLocalizedStrings = null;

                bool fReconstruct;
                PresenceRecord record = PresenceRecord.ReadOrCreate(request._qwUserId, out fReconstruct);
                if (fReconstruct)
                {
                    // try to repopulate the presence record with stuff that might be useful.
                    // these edits are done outside the trywrite loop, because they are only valid if the record does not exist.

                    // we need an active sgaddr to push qvals.
                    record.sgaddr = request._sgaddr;

                    // we guess that this number is greater than the client's sequence number.
                    record.dwSeqQVals = 5000;
                    record.dwSeqXMsgAddQVal = 5000;
                    record.dwSeqXMsgDeleteQVal = 5000;

                    // reset the provisional state.  record.SetState() will overwrite this, but we need to make sure it gets called.
                    record.dwState = PresDefs.P_STATE_FLAG_ONLINE | PresDefs.P_STATE_FLAG_CLOAKED;

                    // Initialize the nonce to -1 (all F's), to distinguish from pre Aug 2010 XSR record
                    record.qwNonce = ulong.MaxValue;
                }

                // ignore any state update that comes in for users that are offline or on mismatched sgaddr.
                if (record.IsOnline() && 
                    request._sgaddr.IsEqual(record.sgaddr) && 
                    ((ctx.qwSGSeqNum == 0) || (record.extension.qwSGSeqNum < ctx.qwSGSeqNum)))
                {
                    if ((request._cbTitleData >= 8) && !RichPresenceFormatter.IsRPTitleBlacklisted(request._dwTitleId))
                    {
                        rpData.ReadBytes(request._rgbTitleData);
                        
                        rgLocales = RichPresenceFormatter.GetTitleSupportedLocales(request._dwTitleId);

                        if (rgLocales != null)
                        {
                            rgLocalizedStrings = new string[rgLocales.Length];
                            for (int iLocale = 0; iLocale < rgLocales.Length; iLocale++)
                            {
                                // Format the rich presence string from the details
                                rgLocalizedStrings[iLocale] = RichPresenceFormatter.FormatRichPresenceString(
                                    request._qwUserId,
                                    request._dwTitleId,
                                    rpData.titlePresence,
                                    new string[] { rgLocales[iLocale] },
                                    rpData.rgProps,
                                    rpData.rgContexts);
                            }

                            rgbRPData = (byte[])rpData;
                        }
                    }

                    // update the user's state.
                    record.SetState(
                        request._dwTitleId, 
                        request._dwState, 
                        request._qwXnkid, 
                        rgbRPData, 
                        rgLocales, 
                        rgLocalizedStrings, 
                        record.sgaddr, 
                        ctx.qwSGSeqNum);

                    // refresh the machine user list.
                    PresenceUtil.AddUserToMachine(record.OwnerID, record.sgaddr);
                }
                // else intentionally do nothing.
                
                PresencePerAPICounters.Total.SuccessRate.Increment();
                PresencePerAPICounters.Total[PresenceHandlerBase.GetRequestTypeName((uint)P_MSG_TYPES.PMSG_STATE_2)].SuccessRate.Increment();
            }
            catch( XRLException e )
            {
                Xom.Trace(XomAreaName.PresenceFDDebug, LogLevel.L_ERROR, "XPNFD.SgNotifyUpdate.RequestLoop: XrlException, hr = " + e.HResult.ToString() + ", msg=" + e.Message + "." );

                if (e.EventId != XEvent.Id.PRESENCE_DO_NOT_LOG_EVENT)
                {
                    // Since we are going to eat this exception, ensure we log the appropriate NT events here
                    Xom.NtEvent(e.EventId, e, "XPNFD.SgNotifyUpdate.RequestLoop: XrlException.");
                }

                PresencePerAPICounters.Total.FailureRate.Increment();
                PresencePerAPICounters.Total[PresenceHandlerBase.GetRequestTypeName((uint)P_MSG_TYPES.PMSG_STATE_2)].FailureRate.Increment();
            }
            catch( Exception e )
            {
                Xom.Trace(XomAreaName.PresenceFDDebug, LogLevel.L_ERROR, "XPNFD.SgNotifyUpdate.RequestLoop: Unexpected failure. msg=" + e.Message );
                
                // Since we are going to eat this exception, ensure we log the appropriate NT events here
                Xom.NtEvent( XEvent.Id.PRESENCE_SGNOTIFYUPDATE_UNEXPECTED_FAILURE, e, "XPNFD.SgNotifyUpdate.RequestLoop: Unexpected failure.");

                PresencePerAPICounters.Total.FailureRate.Increment();
                PresencePerAPICounters.Total[PresenceHandlerBase.GetRequestTypeName((uint)P_MSG_TYPES.PMSG_STATE_2)].FailureRate.Increment();
            }

            PresencePerAPICounters.Total.RequestsPerSecond.Increment();
            PresencePerAPICounters.Total[PresenceHandlerBase.GetRequestTypeName((uint)P_MSG_TYPES.PMSG_STATE_2)].RequestsPerSecond.Increment();
            PresencePerAPICounters.Total.ResponseTimeAvg.IncrementBy(elapsed.MillisecondsElapsed);
            PresencePerAPICounters.Total[PresenceHandlerBase.GetRequestTypeName((uint)P_MSG_TYPES.PMSG_STATE_2)].ResponseTimeAvg.IncrementBy(elapsed.MillisecondsElapsed);
            PresencePerAPICounters.Total.ResponseTimeAvgBase.Increment();
            PresencePerAPICounters.Total[PresenceHandlerBase.GetRequestTypeName((uint)P_MSG_TYPES.PMSG_STATE_2)].ResponseTimeAvgBase.Increment();
        }
        
        public void ProcessRequest( HttpContext ctx )
        {
            PresenceCounters.Current.SGNotifyUpdateInputTotal.Increment();
            PresenceCounters.Current.SGNotifyUpdateInputTotalRate.Increment();

            CSgMsgNotifyCliUpdate request = new CSgMsgNotifyCliUpdate();
            
            try
            {
                Presence.LogFDRequest();

                // validate service request on XRL post
                if( !XRLUtil.IsValidXOnlineRequest( ctx.Request, XOService.PresNotification ) )
                {
                    // The service ID in the request is incorrect (all other failures throw an XrlException)
                    throw new XRLException(HResult.XONLINE_E_BAD_CONTENT_TYPE, XEvent.Id.PRESENCE_SGNOTIFYUPDATE_INVALID_SERVICEID, "XPNFD.SgNotifyUpdate.ProcessRequest: Request is invalid." );                    
                }


                if( ctx.Request.InputStream.Length < request.Size() )
                {
                    // Request too small
                    throw new XRLException(HResult.XONLINE_E_NOTIFICATION_MESSAGE_TRUNCATED, XEvent.Id.PRESENCE_SGNOTIFYUPDATE_REQUEST_TOO_SMALL, "XPNFD.SgNotifyUpdate.ProcessRequest: Request too small (" + ctx.Request.InputStream.Length.ToString() + " < " + request.Size().ToString() + ")" );                    
                }

                if( 0 != ctx.Request.InputStream.Length % request.Size() )
                {
                    throw new XRLException(HResult.XONLINE_E_NOTIFICATION_MESSAGE_TRUNCATED, XEvent.Id.PRESENCE_SGNOTIFYUPDATE_REQUEST_INVALID_LENGTH, "XPNFD.SgNotifyUpdate.ProcessRequest: Request size is not a multiple of size of CSgMsgNotifyCliUpdate (" + ctx.Request.InputStream.Length.ToString() + ", " + request.Size().ToString() + ")"  );                    
                }

                BinaryReader reader = new BinaryReader( ctx.Request.InputStream );
                Hashtable htUserState = new Hashtable();
                ulong qwSGSeqNum = 0;

                try
                {
                    string SGSequenceHeader = HttpContext.Current.Request.Headers["SG-UpdateSeqNum"];
                    qwSGSeqNum = UInt64.Parse(SGSequenceHeader);
                }
                catch (Exception)
                {
                    // eat any exception here.
                }

                // read and hash each internal state message.
                while (ctx.Request.InputStream.Position < ctx.Request.InputStream.Length)
                {
                    UserStateContext userState = new UserStateContext();
                    userState.request = new CSgMsgNotifyCliUpdate();
                    userState.request.ReadStream(reader);
                    userState.qwSGSeqNum = qwSGSeqNum;

                    // put this state in a hashtable keyed on userid.  this overwrites any duplicates from the same user.
                    // we only care about the final state.
                    htUserState[userState.request._qwUserId] = userState;
                }

                // lock here to only allow one thread to add items to the queue at a time.  this helps preseve the ordering of queued items
                // that come in batches.  each batch will be added without any interleaving of items from other batches.
                lock(XpnfdApp.s_FanoutQueueLock)
                {
                    // queue each internal state message.
                    foreach (UserStateContext state in htUserState.Values)
                    {
                        XpnfdApp.m_tpWorker.QueueUserWorkItem(ProcessState2Msg, state);
                    }
                }
                
                XRLUtil.SetXRLResponse( ctx, ctx.Response, XOService.PresNotification, 0, HResult.S_OK, null);
            }
            catch( XRLException e )
            {
                Xom.Trace(XomAreaName.PresenceFDDebug, LogLevel.L_ERROR, "XPNFD.SgNotifyUpdate.ProcessRequest: XrlException, hr = " + e.HResult.ToString() + ", msg=" + e.Message + "." );
                
                throw;
            }
            catch( Exception e )
            {
                Xom.Trace(XomAreaName.PresenceFDDebug, LogLevel.L_ERROR, "XPNFD.SgNotifyUpdate.ProcessRequest: Unexpected failure. msg=" + e.Message );

                throw;
            }
        } // ProcessRequest
        
        // -------------------------------------------------------------------------------
        // IsReusable - allow reuse of this instance
        // -------------------------------------------------------------------------------
        public bool IsReusable
        {
            get { return true; }
        }

    } // class SgNotifyUpdate

} // namespace xonline.server.presence.fd
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\inh\callback.h ===
// Copyright (c) Microsoft Corporation.  All rights reserved

#pragma once

/*****************************************************************************

CPresControlCallback

Receives requests from the XOM management framework

*****************************************************************************/

class CPresControlCallback : public CXomControlCallback
{
public:

    CPresControlCallback() : m_pCSwitchboard(NULL) {}
    ~CPresControlCallback()
    {
        SAFE_CLOSEHANDLE(g_hControlCallbackEvent);
        SAFE_RELEASE(m_pCSwitchboard);
    }

    ULONG __stdcall AddRef () { return 1; }
    ULONG __stdcall Release() { return 1; } 

    void Init(CSwitchboard *pCSwitchboard)
    {
        if (pCSwitchboard != NULL)
        {
            m_pCSwitchboard = pCSwitchboard;
            m_pCSwitchboard->AddRef();
        }

        g_hControlCallbackEvent = CreateEvent(NULL, TRUE, TRUE, NULL);
    }

    virtual HRESULT OnControlRequest(
        LPCSTR pszRequest,
        DWORD dwRequestId,
        CXomControlResponseInterface* pResponseInterface );

protected:

    CSwitchboard *m_pCSwitchboard;
};

extern CPresControlCallback g_ControlCallback;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\inh\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\fd\xpnfdapp.cs ===
// 
// XpnfdApp.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Presence Front Door
// Xbox Online Service
// 

using System;
using System.Collections;
using System.Diagnostics;
using System.IO;
using System.Net;
using System.Net.Sockets;
using System.Reflection;
using System.Text;
using System.Threading;
using System.Web;

using xonline.common.config;
using xonline.common.installer;
using xonline.common.mgmt;
using xonline.common.protocol;
using xonline.common.service;
using xonline.common.community;

[assembly: XomSrfInstallerAttribute( Interface.xpnfd_presence     )]
[assembly: XomSrfInstallerAttribute( Interface.xpnfd_presence_int )]
[assembly: XomSrfInstallerAttribute( Interface.xpnfd_teams        )]
[assembly: XomSrfInstallerAttribute( Interface.xpnfd_teams_int    )]
[assembly: ConfigAttribute(Component.xpnfd)]
    
[assembly: XomAreaDefinition(XomAreaName.PresenceFDDebug)]
[assembly: XomAreaDefinition(XomAreaName.PresenceRPDebug)]
[assembly: XomAreaDefinition(XomAreaName.PresenceLog)]

namespace xonline.server.presence.fd
{
    // -----------------------------------------------------------------------------------
    // XpnfdApp class - the main application class
    // -----------------------------------------------------------------------------------
    public class XpnfdApp : FrontEndApp
    {
        public static object s_FanoutQueueLock;
        static XpnfdApp()
        {
            // Register our event handler for the CacheFlush event
            FrontEndApp.FlushCacheEvent += new FrontEndApp.FlushCacheEventHandler(XpnfdApp.FlushHandler);

            s_FanoutQueueLock = new object();
        }

        // -------------------------------------------------------------------------------
        // Application_Start - called once when the front door starts up
        // -------------------------------------------------------------------------------
        public override void Application_Start( object sender, EventArgs e )
        {
            Config.Assembly = Assembly.GetExecutingAssembly();

            // Call the base class
            base.Application_Start( sender, e );

            XomControl.ControlRequestEvent += new XomControl.ControlRequestEventHandler(XMGMTControl.OnControlRequest);
       }

        // -------------------------------------------------------------------------------
        // Application_End - called when the app domain is being shut down
        // -------------------------------------------------------------------------------
        public override void Application_End( object sender, EventArgs e )
        {
            // Do application termination here
            Xom.Trace(XomAreaName.PresenceFDDebug, LogLevel.L_NORMAL, "Presence FD: Shutting down..." );

            RichPresenceFormatter.ShutDown();

            if (m_tpWorker != null)
            {
                m_tpWorker.Shutdown();
            }

            Xom.Trace(XomAreaName.PresenceFDDebug, LogLevel.L_NORMAL, "Presence FD: Shutting down...Done" );

            base.Application_End(sender, e);
        }

        // -------------------------------------------------------------------------------
        // Application_BeginRequest - called at the beginning of every request
        // -------------------------------------------------------------------------------
        public override void Application_BeginRequest( object sender, EventArgs e )
        {
            // we have to do initalization here instead of Application_Start, because
            // the former isn't yet impersonating the iis application's credentials. 
            if (m_fInitialized == false)
            {
                lock(typeof(XpnfdApp))
                {
                    if (m_fInitialized == false)
                    {
                        Xom.Trace(XomAreaName.PresenceFDDebug, LogLevel.L_NORMAL, "Presence FD: Initializing..." );

                        //Init the static cacheaccess class. Trying to fix #176695
                        CacheUtil.GetDataKeyString((ushort)DATA_TYPES.eBasicPresence, 0, 0);

                        //Initialize Presence Notifications 
                        PubSubNotifications.Initialize();

                        RichPresenceFormatter.Initialize();

                        m_tpWorker = new FastThreadPool("xpnfd", Config.GetIntSetting(Setting.presenceFD_NumPoolThreads), ThreadPriority.Normal);

                        Config.SettingChange += new SettingChangeEventHandler(OnSettingChange);

                        Xom.Trace(XomAreaName.PresenceFDDebug, LogLevel.L_NORMAL, "Presence FD: Initializing...Done" );
                        m_fInitialized = true;
                    }
                }
            }    
            
            // Call the base class
            base.Application_BeginRequest( sender, e );            
        }
            
        public static void FlushHandler(object o, EventArgs e)
        {
            // Flush the cache. Since we only have a handle to the HttpContext cache
            //  object, and we can't destroy or replace that cache, we are forced
            //  to cycle through the cache and remove each item individually. 
            // For this reason, the FlushHandler simply refreshes the data in the cache. 
            //  it does NOT ensure that expired strings are removed from the cache. 
            //  Only restaring the appdomain will ensure that the cache is clean. 
            
            RichPresenceFormatter.LastUpdateTime = new DateTime( 2001, 1, 1, 0, 0, 0, 0 );

            RichPresenceFormatter.XsdReader = null;

            RichPresenceFormatter.LoadGameConfigProc(null);
        }

        public static void OnSettingChange(object sender, SettingChangeEventArgs e)
        {
        }

        private static bool m_fInitialized = false;
        public static FastThreadPool m_tpWorker = null; 
    }
    
    [XomPerformanceCounterCategoryAttr( "Presence FD", "XBox Live Presence Service Frontdoor" )]
    public class PresenceCounters : XomPerformanceCounterCategory
    {
        public PresenceCounters() : base(true)
        {
        }
        
        static public PresenceCounters Current = new PresenceCounters();
        
        [XomPerformanceCounterAttr(
            "SGNotifyDelete Input Message Rate", 
            "Total number of SGNotifyDelete Input requests per second processed by the server.", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter SGNotifyDeleteInputTotalRate;
        
        [XomPerformanceCounterAttr(
            "SGNotifyDelete Input Messages", 
            "Total number of SGNotifyDelete Input requests processed by the server.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter SGNotifyDeleteInputTotal;
        
        [XomPerformanceCounterAttr(
            "SGNotifyTitleChange Input Message Rate", 
            "Total number of SGNotifyTitleChange Input requests per second processed by the server.", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter SGNotifyTitleChangeInputTotalRate;
        
        [XomPerformanceCounterAttr(
            "SGNotifyTitleChange Input Messages", 
            "Total number of SGNotifyTitleChange Input requests processed by the server.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter SGNotifyTitleChangeInputTotal;
        
        [XomPerformanceCounterAttr(
            "SGNotifyUpdate Input Message Rate", 
            "Total number of SGNotifyUpdate Input requests per second processed by the server.", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter SGNotifyUpdateInputTotalRate;
        
        [XomPerformanceCounterAttr(
            "SGNotifyUpdate Input Messages", 
            "Total number of SGNotifyUpdate Input requests processed by the server.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter SGNotifyUpdateInputTotal;
        
        [XomPerformanceCounterAttr(
            "Rich Presence Format Rate", 
            "Total number of Rich Presence Formatting requests per second processed by the server.", 
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter RichPresenceFormatRate;
        
        [XomPerformanceCounterAttr(
            "Rich Presence Format Total", 
            "Total number of Rich Presence Format requests processed by the server.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter RichPresenceFormatTotal;

        [XomPerformanceCounterAttr(
            "Rich Presence Cache entries", 
            "Total number of Rich Presence cache entries on the server.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter RichPresenceCacheEntries;

        [XomPerformanceCounterAttr(
            "Rich Presence Cache Title entries", 
            "Total number of Rich Presence cached title entries on the server.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter RichPresenceCacheTitles;
    } // end perf counter class

} // namespace xonline.server.presence.fd
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\inh\callback.cpp ===
// Copyright (c) Microsoft Corporation.  All rights reserved

#include "stdafx.h"

BOOL                    g_bSimulateTooBusy = FALSE;
CPresControlCallback    g_ControlCallback;

HRESULT CPresControlCallback::OnControlRequest(
    LPCSTR pszRequest,
    DWORD dwRequestId,
    CXomControlResponseInterface* pResponseInterface )
{
    HRESULT hr = S_OK;
    CAdminControlRequestContext *pCCtx = NULL;
    
    if (m_pCSwitchboard == NULL)
    {
        pResponseInterface->WriteResponse(dwRequestId, (BYTE*)"FAILURE: m_pCSwitchboard is NULL.\r\n", (DWORD) -1);
        hr = E_UNEXPECTED;
        goto lDone;
    }

    if (WAIT_OBJECT_0 != WaitForSingleObject(g_hControlCallbackEvent, 0))
    {
        pResponseInterface->WriteResponse(dwRequestId, (BYTE*)"FAILURE: another request is in progress.\r\n", (DWORD) -1);
        hr = E_FAIL;
        goto lDone;
    }
    
    ResetEvent(g_hControlCallbackEvent);

    pCCtx = new CAdminControlRequestContext(m_pCSwitchboard);
    if (pCCtx == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    pCCtx->pszRequest = pszRequest;
    pCCtx->dwRequestId = dwRequestId;
    pCCtx->pResponseInterface = pResponseInterface;

    hr = m_pCSwitchboard->PostCompletion(pCCtx);

    WaitForSingleObject(g_hControlCallbackEvent, INFINITE);

lDone:

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\inh\cliconn.cpp ===
// Copyright (c) Microsoft Corporation.  All rights reserved

#include "stdafx.h"

/*****************************************************************************

CClientConnection::CClientConnection

Constructor

*****************************************************************************/
CClientConnection::CClientConnection() :
m_fSeenHello(FALSE),
m_pSwitchboard(NULL)
{
    memset(&m_sa, 0, sizeof(sockaddr_in));
    m_pszDesc[0] = '\0';

    g_Counters.IncrementValue32(XPPERF_SERVER_CLIENT_CONNECTIONS_COUNTER, 1);
}


/*****************************************************************************

CClientConnection::~CClientConnection

Destructor

*****************************************************************************/
CClientConnection::~CClientConnection()
{
    SAFE_RELEASE(m_pSwitchboard);

    g_Counters.DecrementValue32(XPPERF_SERVER_CLIENT_CONNECTIONS_COUNTER, 1);
    g_Counters.IncrementValue32(XPPERF_SERVER_DROPPED_CLIENT_CONNECTIONS_COUNTER, 1);
    g_Counters.IncrementValue32(XPPERF_SERVER_DROPPED_CLIENT_CONNECTIONS_RATE, 1);
}


/*****************************************************************************

CClientConnection::Init

Initializer, must be called before first use.

*****************************************************************************/
HRESULT CClientConnection::Init( CSwitchboard *pSwitchboard, CServerSocket *pSocket )
{
    HRESULT hr = S_OK;

    // Validate arguments
    if((NULL == pSocket) || (NULL == pSwitchboard))
    {
        XOMASSERT(FALSE);
        return E_INVALIDARG;
    }
 
    XOMASSERT( NULL == m_pSwitchboard );
    m_pSwitchboard = pSwitchboard;
    m_pSwitchboard->AddRef();
    
    hr = pSocket->GetPeerAddress( &m_sa );
    if (FAILED(hr))
    {
        goto lDone;
    }

    // Attach() will call Disconnect() on failure, which will result in a Release().
    // guard Attach() with an extra reference so we dont delete this.
    AddRef();
    
    hr = Attach(pSocket);
    if (FAILED(hr))
    {
        goto lDone;
    }

    // remove our extra reference on success.
    Release();
    
lDone:
    return hr;
}

/*****************************************************************************

CClientConnection::ProcessMessage

Receives a message from the connection object and posts a completion to switchboard for handling.

*****************************************************************************/
void CClientConnection::ProcessMessage(BYTE *pMsg, DWORD cbEntireMsg)
{
    if ((m_pSwitchboard == NULL) || (pMsg == NULL))
    {
        XOMASSERT(FALSE);
        return;
    }

    BASE_MSG_HEADER *pHeader = (BASE_MSG_HEADER *)pMsg;
    if (pHeader->dwMsgLen + sizeof(BASE_MSG_HEADER) > cbEntireMsg)
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_31,
            "Oversized message length = %d, type 0x%X, from client @ %s:%d", 
            pHeader->dwMsgLen + sizeof(BASE_MSG_HEADER),
            pHeader->dwMsgType, 
            inet_ntoa(m_sa.sin_addr), 
            ntohs(m_sa.sin_port));
        
        return;
    }

    CCliConnReceiveContext *pCCtx = new CCliConnReceiveContext(this);
    if (pCCtx != NULL)
    {
        pCCtx->m_cbEntireMsg = cbEntireMsg;
        pCCtx->m_pMsg = new BYTE[cbEntireMsg];
        if (pCCtx->m_pMsg != NULL)
        {
            memcpy(pCCtx->m_pMsg, pMsg, cbEntireMsg);
            m_pSwitchboard->PostCompletion(pCCtx);
        }
    }
}

HRESULT CClientConnection::DeferMessage(QWORD qwUserID, BASE_MSG_HEADER *pMsg, DWORD cbEntireMsg)
{
    XomTrace(PresenceDebug, L_NORMAL, "DeferMessage(user = %I64X, type = %d, seq = %d, size = %d)", qwUserID, pMsg->dwMsgType, pMsg->dwSeqNum, cbEntireMsg);
    
    HRESULT hr = S_OK;
    
    CCliConnReceiveContext *pCCtx = new CCliConnReceiveContext(this);
    if (pCCtx == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }
    
    pCCtx->m_cbEntireMsg = cbEntireMsg;
    pCCtx->m_pMsg = new BYTE[cbEntireMsg];
    if (pCCtx->m_pMsg == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;        
    }
    
    memcpy(pCCtx->m_pMsg, pMsg, cbEntireMsg);
    
    hr = g_CPresenceUserIndex.QueueDeferredRequest(qwUserID, pCCtx);

lDone:

    if (FAILED(hr))
    {
        XomNtEvent(XEVENT_PRESENCE_CODE_31, "DeferMessage(user = %I64X, type = %d, seq = %d, size = %d) failed.  hr = 0x%X", qwUserID, pMsg->dwMsgType, pMsg->dwSeqNum, cbEntireMsg, hr);
        SAFE_RELEASE(pCCtx);
    }

    return hr;
}


/*****************************************************************************

CClientConnection::ProcessCliConnMessage

Validates the message type, then calls the appropriate message handler.

*****************************************************************************/
void CClientConnection::ProcessCliConnMessage(BYTE *pMsg, DWORD cbEntireMsg)
{
    if ((m_pSwitchboard == NULL) || (pMsg == NULL))
    {
        XOMASSERT(FALSE);
        return;
    }

#ifdef ICECAP_BUILD
    StartProfile(PROFILE_THREADLEVEL, PROFILE_CURRENTID);
#endif
    
    struct MessageHandlers
    {
        DWORD dwMsgType;
        DWORD dwMinSize;
        MsgHandler pfnMsgHandler;
    };
    
    static MessageHandlers s_PMsgHandlers[1 + PMSG_MAX_REQ_TYPE - PMSG_MIN_REQ_TYPE] =
    {
        { PMSG_HELLO,              sizeof(P_HELLO_MSG),              (MsgHandler) &CClientConnection::ProcessMsgHello },
        { PMSG_ALIVE,              sizeof(P_ALIVE_MSG),              (MsgHandler) &CClientConnection::ProcessMsgNotSupported },
        { PMSG_SYNC,               sizeof(P_SYNC_MSG),               (MsgHandler) &CClientConnection::ProcessMsgSync },
        { PMSG_REFRESH,            sizeof(P_REFRESH_MSG),            (MsgHandler) &CClientConnection::ProcessMsgNotSupported },
        { PMSG_ADD,                sizeof(P_ADD_MSG),                (MsgHandler) &CClientConnection::ProcessMsgNotSupported },
        { PMSG_DELETE,             sizeof(P_DELETE_MSG),             (MsgHandler) &CClientConnection::ProcessMsgDelete },
        { PMSG_ACCEPT,             sizeof(P_ACCEPT_MSG),             (MsgHandler) &CClientConnection::ProcessMsgAccept },
        { PMSG_REJECT,             sizeof(P_REJECT_MSG),             (MsgHandler) &CClientConnection::ProcessMsgReject },
        { PMSG_BLOCK,              sizeof(P_BLOCK_MSG),              (MsgHandler) &CClientConnection::ProcessMsgBlock },
        { PMSG_UNBLOCK,            sizeof(P_UNBLOCK_MSG),            (MsgHandler) &CClientConnection::ProcessMsgUnblock },
        { PMSG_INVITE,             sizeof(P_INVITE_MSG),             (MsgHandler) &CClientConnection::ProcessMsgNotSupported },
        { PMSG_CANCEL,             sizeof(P_CANCEL_MSG),             (MsgHandler) &CClientConnection::ProcessMsgCancel },
        { PMSG_INVITE_ANSWER,      sizeof(P_INVITE_ANSWER_MSG),      (MsgHandler) &CClientConnection::ProcessMsgInviteAnswer },
        { PMSG_NICKNAME,           sizeof(P_NICKNAME_MSG),           (MsgHandler) &CClientConnection::ProcessMsgNickname },
        { PMSG_STATE,              sizeof(P_STATE_MSG),              (MsgHandler) &CClientConnection::ProcessMsgState },
        { PMSG_DEAD_XBOX,          sizeof(P_DEAD_XBOX_MSG),          (MsgHandler) &CClientConnection::ProcessMsgDeadXBox },
        { PMSG_DEAD_SG,            sizeof(P_DEAD_SG_MSG),            (MsgHandler) &CClientConnection::ProcessMsgDeadSG },
        { PMSG_ANNOUNCE,           sizeof(P_ANNOUNCE_MSG),           (MsgHandler) &CClientConnection::ProcessMsgNotSupported },
        { PMSG_SUBSCRIBED,         sizeof(P_SUBSCRIBED_MSG),         (MsgHandler) &CClientConnection::ProcessMsgNotSupported },
        { PMSG_UNSUBSCRIBE,        sizeof(P_UNSUBSCRIBE_MSG),        (MsgHandler) &CClientConnection::ProcessMsgNotSupported },
        { PMSG_ADDED,              sizeof(P_ADDED_MSG),              (MsgHandler) &CClientConnection::ProcessMsgNotSupported },
        { PMSG_ACCEPTED,           sizeof(P_ACCEPTED_MSG),           (MsgHandler) &CClientConnection::ProcessMsgNotSupported },
        { PMSG_REMOVED,            sizeof(P_REMOVED_MSG),            (MsgHandler) &CClientConnection::ProcessMsgNotSupported },
        { PMSG_KICK,               sizeof(P_KICK_MSG),               (MsgHandler) &CClientConnection::ProcessMsgKick },
        { PMSG_DEAD_USER,          sizeof(P_DEAD_USER_MSG),          (MsgHandler) &CClientConnection::ProcessMsgDeadUser },
        { PMSG_ALIVE_2,            sizeof(P_ALIVE_2_MSG),            (MsgHandler) &CClientConnection::ProcessMsgNotSupported },
        { PMSG_WEB_FRIENDS,        sizeof(P_WEB_FRIENDS_MSG),        (MsgHandler) &CClientConnection::ProcessMsgWebFriends },
        { PMSG_WEB_ALIVE,          sizeof(P_WEB_ALIVE_MSG),          (MsgHandler) &CClientConnection::ProcessMsgWebAlive },
        { PMSG_WEB_ANNOUNCE,       sizeof(P_WEB_ANNOUNCE_MSG),       (MsgHandler) &CClientConnection::ProcessMsgNotSupported },
        { PMSG_WEB_SUBSCRIBED,     sizeof(P_WEB_SUBSCRIBED_MSG),     (MsgHandler) &CClientConnection::ProcessMsgNotSupported },
        { PMSG_WEB_UNSUBSCRIBE,    sizeof(P_WEB_UNSUBSCRIBE_MSG),    (MsgHandler) &CClientConnection::ProcessMsgNotSupported },
        { PMSG_PEER_SESSION,       sizeof(P_PEER_SESSION_MSG),       (MsgHandler) &CClientConnection::ProcessMsgPeerSession },
        { PMSG_TEAM_LIST_TEAMS,    sizeof(P_TEAM_LIST_TEAMS_MSG),    (MsgHandler) &CClientConnection::ProcessMsgTeamListTeams },
        { PMSG_TEAM_LIST_MEMBERS,  sizeof(P_TEAM_LIST_MEMBERS_MSG),  (MsgHandler) &CClientConnection::ProcessMsgTeamListMembers },
        { PMSG_TEAM_CREATE,        sizeof(P_TEAM_CREATE_MSG),        (MsgHandler) &CClientConnection::ProcessMsgTeamCreate },
        { PMSG_TEAM_DELETE,        sizeof(P_TEAM_DELETE_MSG),        (MsgHandler) &CClientConnection::ProcessMsgTeamDelete },
        { PMSG_TEAM_REMOVE,        sizeof(P_TEAM_REMOVE_MSG),        (MsgHandler) &CClientConnection::ProcessMsgTeamRemove },
        { PMSG_TEAM_MANAGE_TEAM,   sizeof(P_TEAM_MANAGE_TEAM_MSG),   (MsgHandler) &CClientConnection::ProcessMsgTeamManageTeam },
        { PMSG_TEAM_MANAGE_MEMBER, sizeof(P_TEAM_MANAGE_MEMBER_MSG), (MsgHandler) &CClientConnection::ProcessMsgTeamManageMember },
        { PMSG_TEAM_RECRUIT,       sizeof(P_TEAM_RECRUIT_MSG),       (MsgHandler) &CClientConnection::ProcessMsgTeamRecruit },
        { PMSG_TEAM_JOIN,          sizeof(P_TEAM_JOIN_MSG),          (MsgHandler) &CClientConnection::ProcessMsgTeamJoin },
        { PMSG_TEAM_GET_TICKET,    sizeof(P_TEAM_GET_TICKET_MSG),    (MsgHandler) &CClientConnection::ProcessMsgTeamGetTicket },
        { PMSG_PEER_SUBSCRIBE,     sizeof(P_PEER_SUBSCRIBE_MSG),     (MsgHandler) &CClientConnection::ProcessMsgPeerSubscribe },
        { PMSG_PEER_UNSUBSCRIBE,   sizeof(P_PEER_UNSUBSCRIBE_MSG),   (MsgHandler) &CClientConnection::ProcessMsgPeerUnsubscribe },
        { PMSG_WATCH_START,        sizeof(P_WATCH_START_MSG),        (MsgHandler) &CClientConnection::ProcessMsgNotSupported },
        { PMSG_WATCH_STOP,         sizeof(P_WATCH_STOP_MSG),         (MsgHandler) &CClientConnection::ProcessMsgNotSupported },
        { PMSG_ADD_2,              sizeof(P_ADD_2_MSG),              (MsgHandler) &CClientConnection::ProcessMsgAdd },
        { PMSG_INVITE_2,           sizeof(P_INVITE_2_MSG),           (MsgHandler) &CClientConnection::ProcessMsgInvite },
        { PMSG_ALIVE_INTERNAL,     sizeof(P_ALIVE_INTERNAL_MSG),     (MsgHandler) &CClientConnection::ProcessMsgAliveInternal },
        { PMSG_STATE_2,            sizeof(P_STATE_2_MSG),            (MsgHandler) &CClientConnection::ProcessMsgState2 },
        { PMSG_GET_STATE,          sizeof(P_GET_STATE_MSG),          (MsgHandler) &CClientConnection::ProcessMsgGetState },
        { PMSG_TEAM_CREATE_XE,     sizeof(P_TEAM_CREATE_MSG),        (MsgHandler) &CClientConnection::ProcessMsgTeamCreate },
        { PMSG_TEAM_MANAGE_TEAM_XE,sizeof(P_TEAM_MANAGE_TEAM_MSG),   (MsgHandler) &CClientConnection::ProcessMsgTeamManageTeam },
        { PMSG_ADD_AFFILIATES,     sizeof(P_ADD_AFFILIATES_MSG),     (MsgHandler) &CClientConnection::ProcessMsgAddAffiliates },
        { PMSG_IS_AFFILIATE,       sizeof(P_IS_AFFILIATE_MSG),       (MsgHandler) &CClientConnection::ProcessMsgIsAffiliate },
        { PMSG_QUERY_AFFILIATES,   sizeof(P_QUERY_AFFILIATES_MSG),   (MsgHandler) &CClientConnection::ProcessMsgQueryAffiliates },
        { PMSG_GET_PRESENCE_INFO,  sizeof(P_GET_PRESENCE_INFO_MSG),  (MsgHandler) &CClientConnection::ProcessMsgGetPresenceInfo },
        { PMSG_PRESENCE_INFO_REPLY,sizeof(P_GET_PRESENCE_INFO_MSG),  (MsgHandler) &CClientConnection::ProcessMsgNotSupported },
        { PMSG_INVALIDATE_USER,    sizeof(P_INVALIDATE_USER_MSG),    (MsgHandler) &CClientConnection::ProcessMsgInvalidateUser },
        { PMSG_FIND_USER,          sizeof(P_FIND_USER_MSG),          (MsgHandler) &CClientConnection::ProcessMsgNotSupported },
        { PMSG_CHECK_TITLE_MESSAGES,  sizeof(P_CHECK_TITLE_MESSAGES_MSG),    (MsgHandler) &CClientConnection::ProcessMsgCheckTitleMessages },
        { PMSG_TEAM_LIST_USER_TEAMS,  sizeof(P_TEAM_LIST_USER_TEAMS_MSG),    (MsgHandler) &CClientConnection::ProcessMsgTeamListUserTeams },
        { PMSG_USER_PRE_MIGRATION,  sizeof(P_USER_PRE_MIGRATION_MSG),    (MsgHandler) &CClientConnection::ProcessMsgNotSupported },
        { PMSG_USER_FULL_MIGRATION,  sizeof(P_USER_FULL_MIGRATION_MSG),    (MsgHandler) &CClientConnection::ProcessMsgNotSupported },
        { PMSG_LOGON_CHECK,  sizeof(P_LOGON_CHECK_MSG),    (MsgHandler) &CClientConnection::ProcessMsgLogonCheck },
        { PMSG_FIND_USERS,          sizeof(P_FIND_USERS_MSG),          (MsgHandler) &CClientConnection::ProcessMsgNotSupported },
        { PMSG_ALIVE_INTERNAL_2,     sizeof(P_ALIVE_INTERNAL_2_MSG),     (MsgHandler) &CClientConnection::ProcessMsgAliveInternal2 },
        { PMSG_PEER_SUBSCRIBE_EX,     sizeof(P_PEER_SUBSCRIBE_EX_MSG),     (MsgHandler) &CClientConnection::ProcessMsgPeerSubscribeEx },
        { PMSG_PURGE_USER,     sizeof(P_PURGE_USER_MSG),     (MsgHandler) &CClientConnection::ProcessMsgPurgeUser },
        { PMSG_GET_FRIENDS_LIST,     sizeof(P_GET_FRIENDS_LIST_MSG),     (MsgHandler) &CClientConnection::ProcessMsgGetFriendsList },
        { PMSG_CONTINUATION,     sizeof(BASE_MSG_HEADER),     (MsgHandler) &CClientConnection::ProcessMsgNotSupported },
        { PMSG_CONNECTION_HEALTH,     sizeof(P_CONNECTION_HEALTH_MSG),     (MsgHandler) &CClientConnection::ProcessMsgConnectionHealth },
    };

    static MessageHandlers s_QMsgHandlers[ 1 + QMSG_MAX_REQ_TYPE - QMSG_MIN_REQ_TYPE ] =
    {
        { QMSG_HELLO,                 sizeof( Q_HELLO_MSG ),                 (MsgHandler) &CClientConnection::ProcessMsgHello               },
        { QMSG_USER_INFO,             sizeof( Q_USER_INFO_MSG ),             (MsgHandler) &CClientConnection::ProcessMsgNotSupported        },
        { QMSG_ADD,                   sizeof( Q_ADD_MSG ),                   (MsgHandler) &CClientConnection::ProcessMsgNotSupported        },
        { QMSG_DELETE,                sizeof( Q_DELETE_MSG ),                (MsgHandler) &CClientConnection::ProcessMsgNotSupported        },
        { QMSG_DELETE_MATCHES,        sizeof( Q_DELETE_MATCHES_MSG ),        (MsgHandler) &CClientConnection::ProcessMsgNotSupported        },
        { QMSG_DEAD_XBOX,             sizeof( Q_DEAD_XBOX_MSG ),             (MsgHandler) &CClientConnection::ProcessMsgDeadXBox            },
        { QMSG_DEAD_SG,               sizeof( Q_DEAD_SG_MSG ),               (MsgHandler) &CClientConnection::ProcessMsgDeadSG              },
        { QMSG_LIST,                  sizeof( Q_LIST_MSG ),                  (MsgHandler) &CClientConnection::ProcessMsgNotSupported        },
        { QMSG_DEQUEUE,               sizeof( Q_DEQUEUE_MSG ),               (MsgHandler) &CClientConnection::ProcessMsgDequeue             },
        { QMSG_DEAD_USER,             sizeof( Q_DEAD_USER_MSG ),             (MsgHandler) &CClientConnection::ProcessMsgNotSupported        },
        { QMSG_WEB_USER_INFO,         sizeof( Q_WEB_USER_INFO_MSG ),         (MsgHandler) &CClientConnection::ProcessMsgNotSupported        },
        { QMSG_WEB_PRESENCE,          sizeof( Q_WEB_PRESENCE_MSG ),          (MsgHandler) &CClientConnection::ProcessMsgNotSupported        },
        { QMSG_WEB_LIST,              sizeof( Q_WEB_LIST_MSG ),              (MsgHandler) &CClientConnection::ProcessMsgNotSupported             },

        // Message handlers for Messaging
        { QMSG_ENUM_MESSAGES,         sizeof( Q_ENUM_MESSAGES_MSG ),         (MsgHandler) &CClientConnection::ProcessMsgEnumerateMessages   },
        { QMSG_MESSAGE_SUMMARY,       sizeof( Q_MESSAGE_SUMMARY_MSG ),       (MsgHandler) &CClientConnection::ProcessMsgGetMessageSummary   },
        { QMSG_MESSAGE_DETAILS,       sizeof( Q_MESSAGE_DETAILS_MSG ),       (MsgHandler) &CClientConnection::ProcessMsgGetMessageDetails   },
        { QMSG_DELETE_MESSAGE,        sizeof( Q_DELETE_MESSAGE_MSG ),        (MsgHandler) &CClientConnection::ProcessMsgDeleteMessage       },
        { QMSG_SEND_MESSAGE,          sizeof( Q_SEND_MESSAGE_MSG ),          (MsgHandler) &CClientConnection::ProcessMsgSendMessage         },
        { QMSG_REVOKE_MESSAGE,        sizeof( Q_REVOKE_MESSAGE_MSG ),        (MsgHandler) &CClientConnection::ProcessMsgNotSupported        },
        { QMSG_DELETE_TITLE,          sizeof( Q_DELETE_TITLE_MSG ),          (MsgHandler) &CClientConnection::ProcessMsgDeleteUserTitle     },
        { QMSG_ENUM_TITLES,           sizeof( Q_ENUM_TITLES_MSG ),           (MsgHandler) &CClientConnection::ProcessMsgEnumerateUserTitles },
        { QMSG_MESSAGE_FLAGS,         sizeof( Q_MESSAGE_FLAGS_MSG ),         (MsgHandler) &CClientConnection::ProcessMsgMessageFlags        },
        { QMSG_ENUM_SYSTEM_MESSAGES,  sizeof( Q_ENUM_SYSTEM_MESSAGES_MSG ),  (MsgHandler) &CClientConnection::ProcessMsgEnumSystemMessages  },
        { QMSG_SYSTEM_MESSAGE_DETAILS,sizeof( Q_SYSTEM_MESSAGE_DETAILS_MSG ),(MsgHandler) &CClientConnection::ProcessMsgSystemMessageDetails},
        { QMSG_DELETE_SYSTEM_MESSAGE, sizeof( Q_DELETE_SYSTEM_MESSAGE_MSG ), (MsgHandler) &CClientConnection::ProcessMsgDeleteSystemMessage },
        { QMSG_SEND_SYSTEM_MESSAGE,   sizeof( Q_SEND_SYSTEM_MESSAGE_MSG ),   (MsgHandler) &CClientConnection::ProcessMsgSendSystemMessage   },
        { QMSG_REVOKE_MESSAGE_EX,     sizeof( Q_REVOKE_MESSAGE_EX_MSG ),     (MsgHandler) &CClientConnection::ProcessMsgRevokeMessage       },
        { QMSG_ENUM_MESSAGES_2,       sizeof( Q_ENUM_MESSAGES_2_MSG ),       (MsgHandler) &CClientConnection::ProcessMsgEnumerateMessages   },
        { QMSG_MESSAGE_SUMMARY_2,     sizeof( Q_MESSAGE_SUMMARY_2_MSG ),     (MsgHandler) &CClientConnection::ProcessMsgGetMessageSummary   },
    };
    
    BASE_MSG_HEADER *pMsgHeader = (BASE_MSG_HEADER *) pMsg;
    DWORD dwMsgType = pMsgHeader->dwMsgType;

    // Check for hello
    if((dwMsgType != PMSG_HELLO) && (dwMsgType != QMSG_HELLO) && (!m_fSeenHello))
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_24,
            "Client @ %s:%d didn't send a hello",
            inet_ntoa(m_sa.sin_addr), 
            ntohs(m_sa.sin_port));

        Disconnect(E_INVALIDARG);
        goto lDone;
    }

    #pragma warning( push )
    #pragma warning( disable : 4296 )
    
    if((dwMsgType >= PMSG_HELLO) && (dwMsgType <= PMSG_MAX_REQ_TYPE))
    {
        // Make sure we have the right table entry
        XOMASSERT(s_PMsgHandlers[dwMsgType - PMSG_HELLO].dwMsgType == dwMsgType);
        
        // Minimum size check
        if (cbEntireMsg < s_PMsgHandlers[dwMsgType - PMSG_HELLO].dwMinSize)
        {
            XomNtEvent(
                XEVENT_PRESENCE_HACK_25,
                "Type 0x%X from client @ %s:%d (size %d < %d)",
                dwMsgType, 
                inet_ntoa(m_sa.sin_addr), 
                ntohs(m_sa.sin_port),
                cbEntireMsg,
                s_PMsgHandlers[dwMsgType - PMSG_HELLO].dwMinSize);

            Disconnect(E_INVALIDARG);
            goto lDone;
        }
        
        // Run the message handler
        (this->*s_PMsgHandlers[ dwMsgType - PMSG_HELLO ].pfnMsgHandler)(
            pMsgHeader,
            cbEntireMsg );
    }
    else if((dwMsgType >= QMSG_HELLO) && (dwMsgType <= QMSG_MAX_REQ_TYPE))
    {
        // Make sure we have the right table entry
        XOMASSERT(s_QMsgHandlers[dwMsgType - QMSG_HELLO].dwMsgType == dwMsgType);
        
        // Minimum size check
        if (cbEntireMsg < s_QMsgHandlers[dwMsgType - QMSG_HELLO].dwMinSize)
        {
            XomNtEvent(
                XEVENT_PRESENCE_HACK_26,
                "Type 0x%X from client @ %s:%d (size %d < %d)",
                dwMsgType, 
                inet_ntoa(m_sa.sin_addr), 
                ntohs(m_sa.sin_port),
                cbEntireMsg,
                s_QMsgHandlers[dwMsgType - QMSG_HELLO].dwMinSize);

            Disconnect(E_INVALIDARG);
            goto lDone;
        }
        
        // Run the message handler
        (this->*s_QMsgHandlers[ dwMsgType - QMSG_HELLO ].pfnMsgHandler)(
            pMsgHeader,
            cbEntireMsg );
    }
    else
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_27, 
            "Unexpected type 0x%X from client @ %s:%d", 
            dwMsgType, 
            inet_ntoa(m_sa.sin_addr), 
            ntohs(m_sa.sin_port));
        
        Disconnect(E_INVALIDARG);
        goto lDone;
    }

    #pragma warning( pop )
    
lDone:
#ifdef ICECAP_BUILD
    StopProfile(PROFILE_THREADLEVEL, PROFILE_CURRENTID);
#endif
    return;
}


/*****************************************************************************

CClientConnection::ProcessMsgHello

Process Hello messages.

*****************************************************************************/
void CClientConnection::ProcessMsgHello(P_HELLO_MSG *pMsg, DWORD cbEntireMsg)
{
    XOMASSERT(pMsg != NULL);
    XOMASSERT(m_pSwitchboard != NULL);

    HRESULT hr = S_OK;   
    DWORD cchDesc = 0;

    // Only accept the current version of the protocol
    if( pMsg->dwProtocolVersion != CURRENT_XPPROTOCOL_VER )
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_28,
            "Hello from client @ %s:%d using bad protocol ver 0x%X",
            inet_ntoa(m_sa.sin_addr), 
            ntohs(m_sa.sin_port), 
            pMsg->dwProtocolVersion);

        hr = E_INVALIDARG;
        goto lDone;
    }
    
    // Only allow one Hello
    if( m_fSeenHello )
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_29,  
            "Hello from client @ %s:%d duplicate hello",
            inet_ntoa(m_sa.sin_addr), 
            ntohs(m_sa.sin_port));

        hr = E_INVALIDARG;
        goto lDone;
    }
    
    // Rest of hello message is descriptive string - grab a copy
    cchDesc = cbEntireMsg - sizeof(P_HELLO_MSG);
    
    if( cchDesc > MAX_HELLO_DESCRIPTION_LEN )
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_30,  
            "Hello from client @ %s:%d using bad description length %d",
            inet_ntoa( m_sa.sin_addr ), 
            ntohs(m_sa.sin_port), 
            cchDesc);

        hr = E_INVALIDARG;
        goto lDone;
    }
    
    memcpy (m_pszDesc, (char *)( pMsg + 1 ), cchDesc);

    m_pszDesc[ cchDesc ] = '\0';
    
    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "Hello from client %s:%d desc = %s",
        inet_ntoa(m_sa.sin_addr), 
        ntohs(m_sa.sin_port), 
        m_pszDesc);
    
    m_fSeenHello = TRUE;
 
lDone:
    
    // Keep track of things
    if( SUCCEEDED( hr ) )
    {
        g_Counters.TrackSuccessfulMessage( XPPERF_SERVER_HELLO_MSGS_COUNTER );
    }
    else
    {
        // Always disconnect on hello failure
        Disconnect(hr);

        g_Counters.TrackFailureMessage( XPPERF_SERVER_HELLO_MSGS_COUNTER );

        XomNtEvent( 
            XEVENT_PRESENCE_CODE_32,  
            "CConnection::ProcessMsgHello failed hr=0x%X", 
            hr);
    }
}

void CClientConnection::ProcessMsgConnectionHealth(P_CONNECTION_HEALTH_MSG *pMsg, DWORD cbEntireMsg)
{
    XOMASSERT(pMsg != NULL);

    HRESULT hr = S_OK;   

    // Only accept the current version of the protocol
    if( pMsg->dwVersion != CURRENT_XPPROTOCOL_VER )
    {
        XomNtEvent(
            XEVENT_PRESENCE_HEALTH_PROTOCOL_MISMATCH,
            "Connection Health from client @ %s:%d using bad protocol ver 0x%X",
            inet_ntoa(m_sa.sin_addr), 
            ntohs(m_sa.sin_port), 
            pMsg->dwVersion);

        hr = E_INVALIDARG;
        goto lDone;
    }
    
    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "Connection Health from client %s:%d",
        inet_ntoa(m_sa.sin_addr), 
        ntohs(m_sa.sin_port));
     
lDone:

    // always try to send a response.
    CTCPCntVarBuffer *pBuffer = g_pBufferPool->GetBuffer(sizeof(P_CONNECTION_HEALTH_REPLY_MSG));
    if (pBuffer == NULL)
    {
        hr = E_OUTOFMEMORY;
    }
    else
    {
        P_CONNECTION_HEALTH_REPLY_MSG *pReply = (P_CONNECTION_HEALTH_REPLY_MSG *)pBuffer->GetBuffer();
        
        pReply->dwMsgType = PMSG_CONNECTION_HEALTH_REPLY;
        pReply->dwMsgLen = sizeof(P_CONNECTION_HEALTH_REPLY_MSG) - sizeof(BASE_MSG_HEADER);
        pReply->dwSeqNum = pMsg->dwSeqNum;
        pReply->hr = hr;
        pReply->dwFlags = 0;

        Send(pBuffer);
    }

    SAFE_RELEASE(pBuffer);
    
    // Keep track of things
    if( FAILED( hr ) )
    {
        XomNtEvent(
            XEVENT_PRESENCE_CONNECTION_HEALTH_FAILURE,
            "Connection Health from client @ %s:%d failed.  hr = 0x%X",
            inet_ntoa(m_sa.sin_addr), 
            ntohs(m_sa.sin_port), 
            hr);

        // Always disconnect on hello failure
        Disconnect(hr);
    }
}

/*****************************************************************************

CClientConnection::ProcessMsgNotSupported

Messages not supported or implemented via peer connections.

*****************************************************************************/
void CClientConnection::ProcessMsgNotSupported(BASE_MSG_HEADER *pMsg, DWORD cbEntireMsg)
{
    XOMASSERT(pMsg != NULL);
    XOMASSERT(m_pSwitchboard != NULL);

    // Report it, then disconnect
    XomNtEvent(
            XEVENT_PRESENCE_HACK_31,
            "Unsupported message type 0x%X from client @ %s:%d", 
            pMsg->dwMsgType, 
            inet_ntoa(m_sa.sin_addr), 
            ntohs(m_sa.sin_port));

    HRESULT hr = E_INVALIDARG;

    Disconnect(hr);
}

void CClientConnection::ProcessMsgLogonCheck(P_LOGON_CHECK_MSG * pMsg, DWORD cbEntireMsg)
{
    CScopeTimer scope( XPPERF_SERVER_LOGON_CHECK_CLIENT_TIME_AVERAGE, XPPERF_SERVER_LOGON_CHECK_CLIENT_TIME_BASE );
    
    XOMASSERT(pMsg != NULL);
    XOMASSERT(m_pSwitchboard != NULL);

    HRESULT hr = S_OK;

    // msg right size?
    if (cbEntireMsg != sizeof(P_LOGON_CHECK_MSG))
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_218,
            "LogonCheck from client @ %s:%d (size %d != %d)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port),
            cbEntireMsg,
            sizeof(P_LOGON_CHECK_MSG));

        hr = E_INVALIDARG;
        goto lDone;
    }

    // userid cannot be zero.
    if (pMsg->qwUserID == 0)
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_219,
            "LogonCheck from client @ %s:%d (userid = 0)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port));
        
        hr = E_INVALIDARG;
        goto lDone;
    }

    // Are we on the right presence server?
    if (!g_CPresCfg.CheckDestination(pMsg->qwUserID))
    {
        XomNtEvent(
            XEVENT_PRESENCE_CODE_220,
            "LogonCheck from client @ %s:%d sent to the wrong server %I64X",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port),
            pMsg->qwUserID);

        hr = E_UNEXPECTED;
        goto lDone;
    }

    hr = m_pSwitchboard->LogonCheck(
        pMsg->sgaddr,
        pMsg->qwUserID);

    lDone:
        
    if (hr == XONLINE_E_PRESENCE_DEFER_REQUEST)
    {
        hr = DeferMessage(pMsg->qwUserID, pMsg, cbEntireMsg);
    }
    else if (hr == XONLINE_E_PRESENCE_USER_MIGRATED)
    {
        hr = m_pSwitchboard->GetClientListener()->ForwardMessage(this, pMsg->qwUserID, pMsg, cbEntireMsg);
    }

    // Keep track of things
    if( FAILED(hr) && (hr != HRESULT_FROM_WIN32(ERROR_USER_EXISTS)))
    {
        g_Counters.TrackFailureMessage( XPPERF_SERVER_LOGON_CHECK_MSGS_COUNTER );

        XomNtEvent( 
            XEVENT_PRESENCE_CODE_494, 
            "CClientConnection::ProcessMsgLogonCheck failed user=%I64X hr=0x%X",
            pMsg->qwUserID,
            hr);
    }
    else
    {
        g_Counters.TrackSuccessfulMessage( XPPERF_SERVER_LOGON_CHECK_MSGS_COUNTER );
    }

    HRESULT hrResp = m_pSwitchboard->SendLogonCheckReply(
        pMsg->dwSeqNum,
        hr,
        this);
        
    if (FAILED(hrResp))
    {
        // Disconnect if we fail to send a response
        Disconnect(hrResp);
    }
}

/*****************************************************************************

CClientConnection::ProcessMsgAliveInternal

Process Alive Internal messages.

*****************************************************************************/
void CClientConnection::ProcessMsgAliveInternal(P_ALIVE_INTERNAL_MSG *pMsg, DWORD cbEntireMsg)
{
    // translate into alive internal 2.
    BYTE *pNewMsg = new BYTE[cbEntireMsg + sizeof(P_ALIVE_INTERNAL_2_MSG) - sizeof(P_ALIVE_INTERNAL_MSG)];

    memcpy(pNewMsg, pMsg, sizeof(P_ALIVE_INTERNAL_MSG));
    ZeroMemory(pNewMsg + sizeof(P_ALIVE_INTERNAL_MSG), sizeof(P_ALIVE_INTERNAL_2_MSG) - sizeof(P_ALIVE_INTERNAL_MSG));
    memcpy(pNewMsg + sizeof(P_ALIVE_INTERNAL_2_MSG), pMsg + 1, cbEntireMsg - sizeof(P_ALIVE_INTERNAL_MSG));

    P_ALIVE_INTERNAL_2_MSG *pAliveInt2 = (P_ALIVE_INTERNAL_2_MSG *)pNewMsg;
    pAliveInt2->dwMsgType = PMSG_ALIVE_INTERNAL_2;
    pAliveInt2->dwMsgLen += sizeof(P_ALIVE_INTERNAL_2_MSG) - sizeof(P_ALIVE_INTERNAL_MSG);

    ProcessMsgAliveInternal2((P_ALIVE_INTERNAL_2_MSG *)pNewMsg, cbEntireMsg + sizeof(P_ALIVE_INTERNAL_2_MSG) - sizeof(P_ALIVE_INTERNAL_MSG));
    
    delete[] pNewMsg;
}

void CClientConnection::ProcessMsgAliveInternal2(P_ALIVE_INTERNAL_2_MSG *pMsg, DWORD cbEntireMsg)
{
    CScopeTimer scope( XPPERF_SERVER_ALIVE_CLIENT_TIME_AVERAGE, XPPERF_SERVER_ALIVE_CLIENT_TIME_BASE );

    XOMASSERT(pMsg != NULL);
    XOMASSERT(m_pSwitchboard != NULL);

    HRESULT hr = S_OK;
    HRESULT hrResp = S_OK;
    LPCSTR szAcctName = NULL;
    
    // Check message size
    if( cbEntireMsg != sizeof(P_ALIVE_INTERNAL_2_MSG) + pMsg->cbAcctName)
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_32,
            "Alive Internal from client @ %s:%d (size %d != %d)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port),
            cbEntireMsg,
            sizeof(P_ALIVE_INTERNAL_2_MSG) + pMsg->cbAcctName);

        hr = E_INVALIDARG;
        Disconnect(hr);
        goto lDone;
    }

    // UserID of 0 not allowed
    if(0 == pMsg->qwUserID)
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_33,
            "Alive Internal from client @ %s:%d Bad user id (0)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port));

        hr = E_INVALIDARG;
        goto lDone;
    }

    // TitleID of 0 is not allowed
    if(0 == pMsg->dwTitleID)
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_34,
            "Alive Internal from client @ %s:%d Bad title id (0)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port));

        hr = E_INVALIDARG;
        goto lDone;
    }

    // Make sure the account name is not too big
    if (pMsg->cbAcctName > MAX_ACCTNAME_BYTES)
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_35,
            "Alive Internal from client @ %s:%d Too long of szAcctName (%d > %d)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port),
            pMsg->cbAcctName,
            MAX_ACCTNAME_BYTES);

        hr = E_INVALIDARG;
        goto lDone;
    }

    szAcctName = (LPCSTR)( pMsg + 1 );

    // Account name must be NULL terminated
    if (szAcctName[pMsg->cbAcctName - 1] != '\0')
    {
         XomNtEvent(
            XEVENT_PRESENCE_HACK_36,
            "Alive Internal from client @ %s:%d Acct name not null terminated",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port ));

        hr = E_INVALIDARG;
        goto lDone;
    }

    // locale must be NULL terminated
    if (pMsg->szLocale[XONLINE_PRESENCE_LOCALE_SIZE - 1] != '\0')
    {
         XomNtEvent(
            XEVENT_PRESENCE_HACK_36,
            "Alive Internal from client @ %s:%d locale not null terminated",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port ));

        hr = E_INVALIDARG;
        goto lDone;
    }

    // Are we on the right presence server?
    if (!g_CPresCfg.CheckDestination(pMsg->qwUserID))
    {
        XomNtEvent(
            XEVENT_PRESENCE_CODE_33,
            "Alive Internal from client @ %s:%d sent to the wrong server %I64X",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port),
            pMsg->qwUserID);

        hr = E_INVALIDARG;
        goto lDone;
    }

    // Everything looks cool, send it on to the switchboard
    XOMASSERT(m_pSwitchboard != NULL);
    hr = m_pSwitchboard->Alive(
        pMsg->sgaddr,
        pMsg->qwUserID,
        pMsg->cbAcctName,
        szAcctName,
        CLIENTVERSION_TO_DWORD(pMsg->clientVersion),
        pMsg->dwBuddyListVersion,
        pMsg->dwBlockListVersion,
        pMsg->liNonce.QuadPart,
        pMsg->dwAuthDataFlags,
        pMsg->dwTitleID,
        pMsg->dwAltTitleID1,
        pMsg->dwAltTitleID2,
        pMsg->dwAltTitleID3,
        pMsg->dwAltTitleID4,
        pMsg->dwTitleVersion,
        pMsg->dwTitleRegion,
        pMsg->xnaddr,
        pMsg->xnkid,
        pMsg->xnkey,
        pMsg->ipaI,
        pMsg->ipportI,
        pMsg->szLocale,
        pMsg->qwVersionFlags,
        this,
        pMsg->dwSeqNum);

    // LineType|MachinePUID|Nonce|SG IP|SG SPI|UserPUID|TitleID|TitleVer|TitleRegion|Xbox IP|Xbox port|Locale|hr
    XomLog(
        PresenceLog,
        "ALV|%I64X|%I64X|%X|%X|%I64X|%X|%X|%X|%X|%X|%s|%X|%X",
        pMsg->sgaddr.qwXboxID,
        pMsg->liNonce,
        pMsg->sgaddr.inaSg,
        pMsg->sgaddr.dwSpiSg,
        pMsg->qwUserID,
        pMsg->dwTitleID,
        pMsg->dwTitleVersion,
        pMsg->dwTitleRegion,
        pMsg->ipportI,
        pMsg->ipaI,
        pMsg->szLocale,
        pMsg->qwVersionFlags,
        hr);

lDone:

    if (hr == XONLINE_E_PRESENCE_DEFER_REQUEST)
    {
        hr = DeferMessage(pMsg->qwUserID, pMsg, cbEntireMsg);
    }
    else if (hr == XONLINE_E_PRESENCE_USER_MIGRATED)
    {
        hr = m_pSwitchboard->GetClientListener()->ForwardMessage(this, pMsg->qwUserID, pMsg, cbEntireMsg);
    }

    // Keep track of things
    if( FAILED(hr) )
    {
        g_Counters.TrackFailureMessage( XPPERF_SERVER_ALIVE_MSGS_COUNTER );

        XomNtEvent( 
            XEVENT_PRESENCE_CODE_34, 
            "CClientConnection::ProcessMsgAliveInternal failed user=%I64X name=%s title=%d hr=0x%X",
            pMsg->qwUserID,
            szAcctName == NULL ? "NULL" : szAcctName,
            pMsg->dwTitleID,
            hr);

        hrResp = m_pSwitchboard->SendEmptyAliveReply( pMsg->dwSeqNum, hr, 0, 0, this );
        if (FAILED(hrResp))
        {
            // Disconnect if we fail to send a response
            Disconnect(hr);
            hr = hrResp;
        }
    }
    // Success counter incremented on DB callback
}

/*****************************************************************************

CClientConnection::ProcessMsgCheckTitleMessages

Process system messages on a title change.

*****************************************************************************/
void CClientConnection::ProcessMsgCheckTitleMessages(P_CHECK_TITLE_MESSAGES_MSG *pMsg, DWORD cbEntireMsg)
{
    CScopeTimer scope( XPPERF_SERVER_ENUM_MESSAGES_CLIENT_TIME_AVERAGE, XPPERF_SERVER_ENUM_MESSAGES_CLIENT_TIME_BASE );

    XOMASSERT(pMsg != NULL);
    XOMASSERT(m_pSwitchboard != NULL);

    HRESULT hr = S_OK;
    HRESULT hrResp = S_OK;

    // UserID of 0 not allowed
    if(0 == pMsg->qwUserID)
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_37,
            "CheckTitleMessages from client @ %s:%d Bad user id (0)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port));

        hr = E_INVALIDARG;
        goto lDone;
    }
    
    // Everything looks cool, send it on to the switchboard
    hr = m_pSwitchboard->CheckTitleMessages(
        pMsg->qwUserID,
        pMsg->dwTitleID,
        pMsg->dwAltTitleID1,
        pMsg->dwAltTitleID2,
        pMsg->dwAltTitleID3,
        pMsg->dwAltTitleID4,
        pMsg->dwTitleRegion,
        pMsg->dwTitleVersion,
        this,
        pMsg->dwSeqNum);

    // LineType|MachinePUID|SG IP|SG SPI|UserPUID|TitleID|AltTitleID1|AltTitleID2|AltTitleID3|AltTitleID4|TitleRegion|TitleVer|hr
    XomLog(
        PresenceLog,
        "CTM|%I64X|%X|%X|%I64X|%X|%X|%X|%X|%X|%X|%X|%X",
        pMsg->sgaddr.qwXboxID,
        pMsg->sgaddr.inaSg,
        pMsg->sgaddr.dwSpiSg,
        pMsg->qwUserID,
        pMsg->dwTitleID,
        pMsg->dwAltTitleID1,
        pMsg->dwAltTitleID2,
        pMsg->dwAltTitleID3,
        pMsg->dwAltTitleID4,
        pMsg->dwTitleRegion,
        pMsg->dwTitleVersion,
        hr);

lDone:
    
    if (hr == XONLINE_E_PRESENCE_DEFER_REQUEST)
    {
        hr = DeferMessage(pMsg->qwUserID, pMsg, cbEntireMsg);
    }
    else if (hr == XONLINE_E_PRESENCE_USER_MIGRATED)
    {
        hr = m_pSwitchboard->GetClientListener()->ForwardMessage(this, pMsg->qwUserID, pMsg, cbEntireMsg);
    }

    // Keep track of things
    if( FAILED(hr) )
    {
        g_Counters.TrackFailureMessage( XPPERF_SERVER_ENUM_MESSAGES_MSGS_COUNTER );

        XomNtEvent( 
            XEVENT_PRESENCE_CODE_35, 
            "CClientConnection::ProcessMsgCheckTitleMessages failed for user=%I64X, titleid=0x%X, hr=0x%X", 
            pMsg->qwUserID,
            pMsg->dwTitleID,
            hr);

        hrResp = m_pSwitchboard->SendCheckTitleMessagesReply(pMsg->dwSeqNum, hr, this);
        if (FAILED(hrResp))
        {
            // Disconnect if we fail to send a response
            Disconnect(hr);
            hr = hrResp;
        }
    }
    // Success counter incremented on DB callback
}

/*****************************************************************************

CClientConnection::ProcessMsgSync

Process Sync messages.

*****************************************************************************/
void CClientConnection::ProcessMsgSync(P_SYNC_MSG *pMsg, DWORD cbEntireMsg)
{
    CScopeTimer scope( XPPERF_SERVER_SYNC_CLIENT_TIME_AVERAGE, XPPERF_SERVER_SYNC_CLIENT_TIME_BASE );

    XOMASSERT(pMsg != NULL);
    XOMASSERT(m_pSwitchboard != NULL);

    HRESULT hr = S_OK;
    HRESULT hrResp = S_OK;

    // UserID of 0 not allowed
    if(0 == pMsg->qwUserID)
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_38,
            "Sync from client @ %s:%d Bad user id (0)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port));

        hr = E_INVALIDARG;
        goto lDone;
    }
    
    // Everything looks cool, send it on to the switchboard
    hr = m_pSwitchboard->Sync(
        pMsg->sgaddr,
        pMsg->qwUserID,
        pMsg->dwBuddyListVersion,
        pMsg->dwBlockListVersion,
        this,
        pMsg->dwSeqNum);

    // LineType|MachinePUID|SG IP|SG SPI|UserPUID|BuddyListVer|BlockListVer|hr
    XomLog(
        PresenceLog,
        "SYNC|%I64X|%X|%X|%I64X|%X|%X|%X",
        pMsg->sgaddr.qwXboxID,
        pMsg->sgaddr.inaSg,
        pMsg->sgaddr.dwSpiSg,
        pMsg->qwUserID,
        pMsg->dwBuddyListVersion,
        pMsg->dwBlockListVersion,
        hr);
    
lDone:
    
    if (hr == XONLINE_E_PRESENCE_DEFER_REQUEST)
    {
        hr = DeferMessage(pMsg->qwUserID, pMsg, cbEntireMsg);
    }
    else if (hr == XONLINE_E_PRESENCE_USER_MIGRATED)
    {
        hr = m_pSwitchboard->GetClientListener()->ForwardMessage(this, pMsg->qwUserID, pMsg, cbEntireMsg);
    }

    // Keep track of things
    if( FAILED(hr) )
    {
        g_Counters.TrackFailureMessage( XPPERF_SERVER_SYNC_MSGS_COUNTER );

        XomNtEvent( 
            XEVENT_PRESENCE_CODE_36, 
            "CClientConnection::ProcessMsgSync failed hr=0x%X", 
            hr);

        hrResp = m_pSwitchboard->SendErrorSyncReply(pMsg->dwSeqNum, hr, this);
        if (FAILED(hrResp))
        {
            // Disconnect if we fail to send a response
            Disconnect(hr);
            hr = hrResp;
        }
    }
    // Success counter incremented on DB callback
}

/*****************************************************************************

CClientConnection::ProcessMsgAdd

Process Add messages.

*****************************************************************************/
void CClientConnection::ProcessMsgAdd(P_ADD_2_MSG *pMsg, DWORD cbEntireMsg)
{
    CScopeTimer scope( XPPERF_SERVER_ADD_BUDDY_CLIENT_TIME_AVERAGE, XPPERF_SERVER_ADD_BUDDY_CLIENT_TIME_BASE );

    XOMASSERT(pMsg != NULL);
    XOMASSERT(m_pSwitchboard != NULL);

    HRESULT hr = S_OK;
    HRESULT hrQ;
    QWORD qwNonce = 0;

    // Account name must be NULL terminated
    if( 0 != pMsg->szBuddyAcctName[ XONLINE_GAMERTAG_SIZE -1 ] )
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_39,
            "Add from client @ %s:%d Buddy acctname not null terminated",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port));

        hr = E_INVALIDARG;
        goto lDone;
    }

    // Must specify either a Buddy User ID or Account Name.
    if ((0 == pMsg->qwBuddyID) && (0 == pMsg->szBuddyAcctName[0]))
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_40,
            "Add from client @ %s:%d zero buddy name and id.",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port));

        hr = E_INVALIDARG;
        goto lDone;
    }

    // UserID of 0 not allowed
    if(0 == pMsg->qwSenderID)
    {
         XomNtEvent(
            XEVENT_PRESENCE_HACK_41,
            "Add from client @ %s:%d Bad user id (0)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port));

        hr = E_INVALIDARG;
        goto lDone;
    }

    // Can't be your own buddy
    if(pMsg->qwSenderID == pMsg->qwBuddyID)
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_42,
            "Add from client @ %s:%d UserID equals BuddyID (%I64X)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port),
            pMsg->qwSenderID);

        hr = E_INVALIDARG;
        goto lDone;
    }

    DWORD cbDesiredMsg = sizeof(P_ADD_2_MSG) + pMsg->cbDetails;

    // Check the message size
    if(cbEntireMsg != cbDesiredMsg)
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_43,
            "Add from client @ %s:%d (size %d != %d)",
            inet_ntoa( m_sa.sin_addr ),
            ntohs( m_sa.sin_port ),
            cbEntireMsg,
            cbDesiredMsg);

        hr = E_INVALIDARG;
        Disconnect(hr);
        goto lDone;
    }

    // Everything looks cool, send it on to the switchboard
    hr = m_pSwitchboard->Add(
        pMsg->sgaddr,
        pMsg->dwSeqNum,
        pMsg->qwSenderID,
        pMsg->qwBuddyID,
        pMsg->dwMessageFlags,
        pMsg->cbDetails,
        (const BYTE*)( pMsg + 1 ),
        pMsg->szBuddyAcctName,
        &qwNonce);

    // LineType|MachinePUID|Nonce|SG IP|SG SPI|UserPUID|BuddyPUID|BuddyName|hr
    XomLog(
        PresenceLog,
        "ADD|%I64X|%I64X|%X|%X|%I64X|%I64X|%s|%X",
        pMsg->sgaddr.qwXboxID,
        qwNonce,
        pMsg->sgaddr.inaSg,
        pMsg->sgaddr.dwSpiSg,
        pMsg->qwSenderID,
        pMsg->qwBuddyID,
        pMsg->szBuddyAcctName,
        hr);

lDone:

    if (hr == XONLINE_E_PRESENCE_DEFER_REQUEST)
    {
        hr = DeferMessage(pMsg->qwSenderID, pMsg, cbEntireMsg);
    }
    else if (hr == XONLINE_E_PRESENCE_USER_MIGRATED)
    {
        hr = m_pSwitchboard->GetClientListener()->ForwardMessage(this, pMsg->qwSenderID, pMsg, cbEntireMsg);
    }

    // Send client notification of failures
    if (FAILED(hr))
    {
        hrQ = m_pSwitchboard->GetPCluser()->QueueListChange(
            pMsg->qwSenderID, 
            0,
            pMsg->qwBuddyID,
            PLIST_BUDDY_ADD,
            hr,
            0,
            "");
        if (FAILED(hrQ) && (hrQ != HRESULT_FROM_WIN32(ERROR_NO_SUCH_USER)))
        {
            // Log and continue
            XomNtEvent( 
                XEVENT_PRESENCE_CODE_37, 
                "Failure to enqueue add list change item UserID=%I64X hr=0x%X", 
                pMsg->qwSenderID, 
                hrQ);
        }
    }

    // Keep track of things
    if(FAILED(hr))
    {
        g_Counters.TrackFailureMessage( XPPERF_SERVER_ADD_MSGS_COUNTER );

        XomNtEvent( 
            XEVENT_PRESENCE_CODE_38, 
            "CClientConnection::ProcessMsgAdd failed user=%I64X buddy=%I64X hr=0x%X",
            pMsg->qwSenderID,
            pMsg->qwBuddyID,
            hr);
    }
    // Success counter incremented on DB callback
}

/*****************************************************************************

CClientConnection::ProcessMsgAddAffiliates

Process AddAffiliates messages.

*****************************************************************************/
void CClientConnection::ProcessMsgAddAffiliates(P_ADD_AFFILIATES_MSG *pMsg, DWORD cbEntireMsg)
{
    CScopeTimer scope( XPPERF_SERVER_ADD_AFFILIATES_CLIENT_TIME_AVERAGE, XPPERF_SERVER_ADD_AFFILIATES_CLIENT_TIME_BASE );

    XOMASSERT(pMsg != NULL);
    XOMASSERT(m_pSwitchboard != NULL);

    HRESULT hr = S_OK;
    
    // must have users to add
    if (0 == pMsg->cwAffiliates)
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_44,
            "AddAffiliates from client @ %s:%d Zero Affiliates",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port));

        hr = E_INVALIDARG;
        goto lDone;
    }

    if (pMsg->cwAffiliates > X_ADD_AFFILIATE_MAX)
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_45,
            "AddAffiliates from client @ %s:%d Too many Affiliates(%d)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port),
            pMsg->cwAffiliates);

        hr = E_INVALIDARG;
        goto lDone;
    }

    // can only add to one list at a time.
    if (pMsg->dwListFlag & (pMsg->dwListFlag - 1))
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_46,
            "AddAffiliates from client @ %s:%d Multiple list bits set",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port));

        hr = E_INVALIDARG;
        goto lDone;
    }

    // check for valid list type
    if (X_AFFILIATE_FLAG_TO_INDEX(pMsg->dwListFlag) >= NUM_STORED_AFFILIATE_LISTS)
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_47,
            "AddAffiliates from client @ %s:%d bad list flags (0x%X)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port),
            pMsg->dwListFlag);

        hr = E_INVALIDARG;
        goto lDone;
    }

    // TODO: is this check valid/important?
    // only encountered or completed game players can be batch added
    if ((1 < pMsg->cwAffiliates) &&
        (pMsg->dwListFlag != X_AFFILIATE_INDEX_TO_FLAG(X_AFFILIATE_COMPLETED_GAME_INDEX)) &&
        (pMsg->dwListFlag != X_AFFILIATE_INDEX_TO_FLAG(X_AFFILIATE_ENCOUNTERED_INDEX)))
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_48,
            "AddAffiliates from client @ %s:%d batch add for invalid affiliate type (0x%X)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port),
            pMsg->dwListFlag);

        hr = E_INVALIDARG;
        goto lDone;
    }

    // UserID of 0 not allowed
    if(0 == pMsg->qwSenderID)
    {
         XomNtEvent(
            XEVENT_PRESENCE_HACK_49,
            "AddAffiliates from client @ %s:%d Bad user id (0)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port));

        hr = E_INVALIDARG;
        goto lDone;
    }

    // message size must equal size of advertised data
    if (pMsg->dwMsgLen != sizeof(P_ADD_AFFILIATES_MSG) - sizeof(BASE_MSG_HEADER) + (pMsg->cwAffiliates * sizeof(ULONGLONG)))
    {
         XomNtEvent(
            XEVENT_PRESENCE_HACK_50,
            "AddAffiliates from client @ %s:%d failed data size check -- dwMsgLen(%d), cwAffiliates(%d)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port),
            pMsg->dwMsgLen,
            pMsg->cwAffiliates);

        hr = E_INVALIDARG;
        goto lDone;
    }
    
    // Can't be your own affiliate or have affiliate = 0
    ULONGLONG *pqwAffiliates = (ULONGLONG *)(pMsg + 1);
    for (WORD i = 0; i < pMsg->cwAffiliates; i++)
    {
        if(pMsg->qwSenderID == pqwAffiliates[i])
        {
            XomNtEvent(
                XEVENT_PRESENCE_HACK_51,
                "AddAffiliates from client @ %s:%d SenderID equals AffiliateID (%I64X)",
                inet_ntoa(m_sa.sin_addr),
                ntohs(m_sa.sin_port),
                pMsg->qwSenderID);

            hr = E_INVALIDARG;
            goto lDone;
        }

        if(0 == pqwAffiliates[i])
        {
            XomNtEvent(
                XEVENT_PRESENCE_HACK_52,
                "AddAffiliates from client @ %s:%d user = %I64X, AffiliateID = 0",
                inet_ntoa(m_sa.sin_addr),
                ntohs(m_sa.sin_port),
                pMsg->qwSenderID);

            hr = E_INVALIDARG;
            goto lDone;
        }
    }

    // Everything looks cool, send it on to the switchboard
    hr = m_pSwitchboard->AddAffiliates(
        pMsg->sgaddr,
        pMsg->qwSenderID,
        pMsg->dwListFlag,
        pMsg->dwTitleID,
        pMsg->cwAffiliates,
        pqwAffiliates);

    // LineType|MachinePUID|SG IP|SG SPI|UserPUID|#ofAffiliates|hr
    XomLog(
        PresenceLog,
        "ADD_AFFILIATES|%I64X|%X|%X|%I64X|%I64X|%X",
        pMsg->sgaddr.qwXboxID,
        pMsg->sgaddr.inaSg,
        pMsg->sgaddr.dwSpiSg,
        pMsg->qwSenderID,
        pMsg->cwAffiliates,
        hr);
    
lDone:
    
    if (hr == XONLINE_E_PRESENCE_DEFER_REQUEST)
    {
        hr = DeferMessage(pMsg->qwSenderID, pMsg, cbEntireMsg);
    }
    else if (hr == XONLINE_E_PRESENCE_USER_MIGRATED)
    {
        hr = m_pSwitchboard->GetClientListener()->ForwardMessage(this, pMsg->qwSenderID, pMsg, cbEntireMsg);
    }

    // Keep track of things
    if(FAILED(hr))
    {
        g_Counters.TrackFailureMessage( XPPERF_SERVER_ADD_AFFILIATES_MSGS_COUNTER );

        if (hr != XONLINE_E_SERVER_ERROR)
        {
            XomNtEvent( 
                XEVENT_PRESENCE_CODE_39, 
                "CClientConnection::ProcessMsgAddAffiliates failed user=%I64X, flags=0x%X, title=0x%X, hr=0x%X",
                pMsg->qwSenderID,
                pMsg->dwListFlag,
                pMsg->dwTitleID,
                hr);
        }
    }

    // success tracked on callback.    
}

/*****************************************************************************

CClientConnection::ProcessMsgIsAffiliate

Process IsAffiliate messages.

*****************************************************************************/
void CClientConnection::ProcessMsgIsAffiliate(P_IS_AFFILIATE_MSG *pMsg, DWORD cbEntireMsg)
{
    CScopeTimer scope( XPPERF_SERVER_IS_AFFILIATE_CLIENT_TIME_AVERAGE, XPPERF_SERVER_IS_AFFILIATE_CLIENT_TIME_BASE );

    XOMASSERT(pMsg != NULL);
    XOMASSERT(m_pSwitchboard != NULL);

    HRESULT hr = S_OK;

    // UserID of 0 not allowed
    if(0 == pMsg->qwSenderID)
    {
         XomNtEvent(
            XEVENT_PRESENCE_HACK_53,
            "IsAffiliate from client @ %s:%d Bad user id (0)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port));

        hr = E_INVALIDARG;
        goto lDone;
    }

    // AffiliateID of 0 not allowed
    if(0 == pMsg->qwAffiliateID)
    {
         XomNtEvent(
            XEVENT_PRESENCE_HACK_54,
            "IsAffiliate from client @ %s:%d Bad affiliate id (0)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port));

        hr = E_INVALIDARG;
        goto lDone;
    }
    
    // Can't be your own affiliate
    if(pMsg->qwSenderID == pMsg->qwAffiliateID)
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_55,
            "IsAffiliate from client @ %s:%d SenderID equals AffiliateID (%I64X)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port),
            pMsg->qwSenderID);

        hr = E_INVALIDARG;
        goto lDone;
    }
      
    // Everything looks cool, send it on to the switchboard
    hr = m_pSwitchboard->IsAffiliate(
        pMsg->sgaddr,
        pMsg->dwSeqNum,
        pMsg->qwSenderID,
        pMsg->qwAffiliateID,
        this);

    // LineType|MachinePUID|SG IP|SG SPI|UserPUID|AffiliatePUID|hr
    XomLog(
        PresenceLog,
        "IS_AFFILIATE|%I64X|%X|%X|%I64X|%I64X|%X",
        pMsg->sgaddr.qwXboxID,
        pMsg->sgaddr.inaSg,
        pMsg->sgaddr.dwSpiSg,
        pMsg->qwSenderID,
        pMsg->qwAffiliateID,
        hr);
    
lDone:
    
    if (hr == XONLINE_E_PRESENCE_DEFER_REQUEST)
    {
        hr = DeferMessage(pMsg->qwSenderID, pMsg, cbEntireMsg);
    }
    else if (hr == XONLINE_E_PRESENCE_USER_MIGRATED)
    {
        hr = m_pSwitchboard->GetClientListener()->ForwardMessage(this, pMsg->qwSenderID, pMsg, cbEntireMsg);
    }

    // Keep track of things
    if(FAILED(hr))
    {
        g_Counters.TrackFailureMessage( XPPERF_SERVER_IS_AFFILIATE_MSGS_COUNTER );
        
        HRESULT hrResp = m_pSwitchboard->SendIsAffiliateReply(
            pMsg->dwSeqNum,
            hr,
            pMsg->qwAffiliateID,
            0,
            this);
        if (FAILED(hrResp))
        {
            // Disconnect if we fail to send a response
            Disconnect(hr);
            hr = hrResp;
        }

        // pull titleid out of the presence record.
        CPresence *pCPresence = NULL;
        g_CPresenceUserIndex.FindPresence(pMsg->qwSenderID, &pCPresence);
        DWORD dwTitleID = (pCPresence == NULL) ? 0 : pCPresence->GetTitleID();
        SAFE_RELEASE(pCPresence);

        XomNtEvent( 
            XEVENT_PRESENCE_CODE_40, 
            "CClientConnection::ProcessMsgIsAffiliate failed user=%I64X, title=0x%X, hr=0x%X",
            pMsg->qwSenderID,
            dwTitleID,
            hr);
    }

    // success tracked on callback.    
}

/*****************************************************************************

CClientConnection::ProcessMsgQueryAffiliates

Process QueryAffiliates messages.

*****************************************************************************/
void CClientConnection::ProcessMsgQueryAffiliates(P_QUERY_AFFILIATES_MSG *pMsg, DWORD cbEntireMsg)
{
    CScopeTimer scope( XPPERF_SERVER_QUERY_AFFILIATES_CLIENT_TIME_AVERAGE, XPPERF_SERVER_QUERY_AFFILIATES_CLIENT_TIME_BASE );

    XOMASSERT(pMsg != NULL);
    XOMASSERT(m_pSwitchboard != NULL);

    HRESULT hr = S_OK;

    // UserID of 0 not allowed
    if(0 == pMsg->qwSenderID)
    {
         XomNtEvent(
            XEVENT_PRESENCE_HACK_56,
            "QueryAffiliates from client @ %s:%d Bad user id (0)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port));

        hr = E_INVALIDARG;
        goto lDone;
    }

    // must specify at least one list.  for all lists, send -1.
    if(0 == pMsg->dwListFlags)
    {
         XomNtEvent(
            XEVENT_PRESENCE_HACK_57,
            "QueryAffiliates from client @ %s:%d no affiliate lists specified",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port));

        hr = E_INVALIDARG;
        goto lDone;
    }

    // DEV NOTE: cant specify a limit with multiple lists.  how would i prioritize the entiries?
    if ((pMsg->cdwLimit != 0) &&
        (pMsg->dwListFlags & (pMsg->dwListFlags - 1)))  // test for single bit
    {
         XomNtEvent(
            XEVENT_PRESENCE_HACK_58,
            "QueryAffiliates from client @ %s:%d limited results with multiple lists requested.  unsupported call.",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port));

        hr = E_INVALIDARG;
        goto lDone;
    }

    // Everything looks cool, send it on to the switchboard
    hr = m_pSwitchboard->QueryAffiliates(
        pMsg->sgaddr,
        pMsg->dwSeqNum,
        pMsg->qwSenderID,
        pMsg->dwListFlags,
        pMsg->cdwLimit,
        pMsg->dwOnlineTitleID,
        this);

    // LineType|MachinePUID|SG IP|SG SPI|UserPUID|hr
    XomLog(
        PresenceLog,
        "QUERY_AFFILIATES|%I64X|%X|%X|%I64X|%X",
        pMsg->sgaddr.qwXboxID,
        pMsg->sgaddr.inaSg,
        pMsg->sgaddr.dwSpiSg,
        pMsg->qwSenderID,
        hr);
    
lDone:
    
    if (hr == XONLINE_E_PRESENCE_DEFER_REQUEST)
    {
        hr = DeferMessage(pMsg->qwSenderID, pMsg, cbEntireMsg);
    }
    else if (hr == XONLINE_E_PRESENCE_USER_MIGRATED)
    {
        hr = m_pSwitchboard->GetClientListener()->ForwardMessage(this, pMsg->qwSenderID, pMsg, cbEntireMsg);
    }

    // Keep track of things
    if(FAILED(hr))
    {
        g_Counters.TrackFailureMessage( XPPERF_SERVER_QUERY_AFFILIATES_MSGS_COUNTER );
        
        HRESULT hrResp = m_pSwitchboard->SendQueryAffiliatesReply(
            pMsg->dwSeqNum,
            hr,
            0,
            NULL,
            this);
        if (FAILED(hrResp))
        {
            // Disconnect if we fail to send a response
            Disconnect(hr);
            hr = hrResp;
        }

        // pull titleid out of the presence record.
        CPresence *pCPresence = NULL;
        g_CPresenceUserIndex.FindPresence(pMsg->qwSenderID, &pCPresence);
        DWORD dwTitleID = (pCPresence == NULL) ? 0 : pCPresence->GetTitleID();
        SAFE_RELEASE(pCPresence);

        XomNtEvent( 
            XEVENT_PRESENCE_CODE_41, 
            "CClientConnection::ProcessMsgQueryAffiliates failed user=%I64X, title=0x%X, hr=0x%X",
            pMsg->qwSenderID,
            dwTitleID,
            hr);
    }

    // success tracked on callback.    
}

/*****************************************************************************

CClientConnection::ProcessMsgGetPresenceInfo

Process GetPresenceInfo messages.

*****************************************************************************/
void CClientConnection::ProcessMsgGetPresenceInfo(P_GET_PRESENCE_INFO_MSG *pMsg, DWORD cbEntireMsg)
{
    CScopeTimer scope( XPPERF_SERVER_GET_PRESENCE_INFO_PEER_TIME_AVERAGE, XPPERF_SERVER_GET_PRESENCE_INFO_PEER_TIME_BASE );

    XOMASSERT(pMsg != NULL);
    XOMASSERT(m_pSwitchboard != NULL);

    HRESULT hr = S_OK;

    if(0 == pMsg->qwSenderID)
    {
        XomNtEvent(
            XEVENT_PRESENCE_COMM_6,
            "GetPresenceInfo from client @ %s:%d Bad user id (0)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port));

        hr = E_INVALIDARG;
        goto lDone;
    }

    if(1 != pMsg->cdwUsers)
    {
        XomNtEvent(
            XEVENT_PRESENCE_COMM_7,
            "GetPresenceInfo from client @ %s:%d cdwUsers = %d (must be 1)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port),
            pMsg->cdwUsers);

        hr = E_INVALIDARG;
        goto lDone;
    }

    if(cbEntireMsg != sizeof(P_GET_PRESENCE_INFO_MSG) + (pMsg->cdwUsers * sizeof(QWORD)))
    {
        XomNtEvent(
            XEVENT_PRESENCE_COMM_8,
            "GetPresenceInfo from client @ %s:%d (size %d != %d)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port),
            cbEntireMsg,
            sizeof(P_GET_PRESENCE_INFO_MSG) + (pMsg->cdwUsers * sizeof(QWORD)));

        hr = E_INVALIDARG;
        Disconnect(hr);
        goto lDone;
    }

    // the lone target id cannot be zero
    if(0 == *((QWORD *)(pMsg + 1)))
    {
        XomNtEvent(
            XEVENT_PRESENCE_COMM_6,
            "GetPresenceInfo from client @ %s:%d Bad target id (0)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port));

        hr = E_INVALIDARG;
        goto lDone;
    }

    hr = m_pSwitchboard->GetPresenceInfo(
        pMsg->dwSeqNum,
        pMsg->qwSenderID,
        pMsg->cdwUsers,
        (QWORD *)(pMsg + 1),
        FALSE,
        this);

    // LineType|SeqNum|RequestorPUID|NumRequested|RequesteePUID|hr
    XomLog(
        PresenceLog,
        "GPI|%X|%I64X|%X|%I64X|%X",
        pMsg->dwSeqNum,
        pMsg->qwSenderID,
        pMsg->cdwUsers,
        *(QWORD *)(pMsg + 1),        
        hr);
    
lDone:

    //NOTE: cliconn's version of GPI can only have 1 user
    if (hr == XONLINE_E_PRESENCE_DEFER_REQUEST)
    {
        hr = DeferMessage(*(QWORD *)(pMsg + 1), pMsg, cbEntireMsg);
    }
    else if (hr == XONLINE_E_PRESENCE_USER_MIGRATED)
    {
        hr = m_pSwitchboard->GetClientListener()->ForwardMessage(this, *(QWORD *)(pMsg + 1), pMsg, cbEntireMsg);
    }

    // Keep track of things
    if(SUCCEEDED(hr))
    {
        g_Counters.TrackSuccessfulMessage( XPPERF_SERVER_GET_PRESENCE_INFO_MSGS_COUNTER );
    }
    else
    {
        g_Counters.TrackFailureMessage( XPPERF_SERVER_GET_PRESENCE_INFO_MSGS_COUNTER );

        XomNtEvent( 
            XEVENT_PRESENCE_CODE_42,
            "CClientConnection::GetPresenceInfo failed hr=0x%X", 
            hr);

        // send a failure packet in repsonse
        CTCPCntVarBuffer *pSendBuffer = g_pBufferPool->GetBuffer(sizeof(P_GET_PRESENCE_INFO_MSG));
        if (pSendBuffer != NULL)
        {
            // Fill in the base message fields
            P_GET_PRESENCE_INFO_MSG *pResp = (P_GET_PRESENCE_INFO_MSG *)pSendBuffer->GetBuffer();

            pResp->dwMsgType = PMSG_PRESENCE_INFO_REPLY;
            pResp->dwMsgLen = sizeof(P_GET_PRESENCE_INFO_MSG) - sizeof(BASE_MSG_HEADER);
            pResp->dwSeqNum = pMsg->dwSeqNum;
            pResp->sgaddr = sgaddrIgnore;
            pResp->qwSenderID = pMsg->qwSenderID;
            pResp->cdwUsers = 0;
            pResp->dwContext = pMsg->dwSeqNum;

            Send(pSendBuffer);
        }

        SAFE_RELEASE(pSendBuffer);
    }
}


/*****************************************************************************

CClientConnection::ProcessMsgDelete

Process Delete messages.

*****************************************************************************/
void CClientConnection::ProcessMsgDelete(P_DELETE_MSG *pMsg, DWORD cbEntireMsg)
{
    CScopeTimer scope( XPPERF_SERVER_DELETE_BUDDY_CLIENT_TIME_AVERAGE, XPPERF_SERVER_DELETE_BUDDY_CLIENT_TIME_BASE );

    XOMASSERT(pMsg != NULL);
    XOMASSERT(m_pSwitchboard != NULL);

    HRESULT hr = S_OK;
    HRESULT hrQ = S_OK;
    QWORD qwNonce = 0;

    // Check for UserID of zero
    if((0 == pMsg->qwUserID) || (0 == pMsg->qwBuddyID))
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_59,
            "Delete from client @ %s:%d Bad user id or buddy id (0)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port));

        hr = E_INVALIDARG;
        goto lDone;
    }

    // Can't be your own buddy
    if(pMsg->qwUserID == pMsg->qwBuddyID)
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_60,
            "Delete from client @ %s:%d UserID equals BuddyID (%I64X)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port),
            pMsg->qwUserID);

        hr = E_INVALIDARG;
        goto lDone;
    }

    // Everything looks cool, send it on to the switchboard
    hr = m_pSwitchboard->Delete(
        pMsg->sgaddr,
        pMsg->dwSeqNum,
        pMsg->qwUserID,
        pMsg->qwBuddyID,
        &qwNonce);

    // LineType|MachinePUID|Nonce|SG IP|SG SPI|UserPUID|BuddyPUID|hr
    XomLog(
        PresenceLog,
        "DEL|%I64X|%I64X|%X|%X|%I64X|%I64X|%X",
        pMsg->sgaddr.qwXboxID,
        qwNonce,
        pMsg->sgaddr.inaSg,
        pMsg->sgaddr.dwSpiSg,
        pMsg->qwUserID,
        pMsg->qwBuddyID,
        hr);

lDone:

    if (hr == XONLINE_E_PRESENCE_DEFER_REQUEST)
    {
        hr = DeferMessage(pMsg->qwUserID, pMsg, cbEntireMsg);
    }
    else if (hr == XONLINE_E_PRESENCE_USER_MIGRATED)
    {
        hr = m_pSwitchboard->GetClientListener()->ForwardMessage(this, pMsg->qwUserID, pMsg, cbEntireMsg);
    }

    // Send client notification of failures
    if (FAILED(hr))
    {
        hrQ = m_pSwitchboard->GetPCluser()->QueueListChange(
            pMsg->qwUserID, 
            0,
            pMsg->qwBuddyID,
            PLIST_BUDDY_DELETE,
            hr,
            0,
            "");
        if (FAILED(hrQ))
        {
            // Log and continue
            XomNtEvent( 
                XEVENT_PRESENCE_CODE_43, 
                "Failure to enqueue delete list change item UserID=%I64X hr=0x%X", 
                pMsg->qwUserID, 
                hrQ);
        }
    }

    // Keep track of things
    if(FAILED(hr))
    {
        g_Counters.TrackFailureMessage(XPPERF_SERVER_DELETE_MSGS_COUNTER);

        XomNtEvent( 
            XEVENT_PRESENCE_CODE_44, 
            "CClientConnection::ProcessMsgDelete failed user=%I64X buddy=%I64X hr=0x%X",
            pMsg->qwUserID,
            pMsg->qwBuddyID,
            hr);
    }
    // Success counter incremented on DB callback
}

/*****************************************************************************

CClientConnection::ProcessMsgAccept

Process Accept messages.

*****************************************************************************/
void CClientConnection::ProcessMsgAccept(P_ACCEPT_MSG *pMsg, DWORD cbEntireMsg)
{
    CScopeTimer scope( XPPERF_SERVER_ACCEPT_BUDDY_CLIENT_TIME_AVERAGE, XPPERF_SERVER_ACCEPT_BUDDY_CLIENT_TIME_BASE );

    XOMASSERT(pMsg != NULL);
    XOMASSERT(m_pSwitchboard != NULL);

    HRESULT hr = S_OK;
    HRESULT hrQ = S_OK;
    QWORD qwNonce = 0;

    // UserID of 0 is invalid
    if((0 == pMsg->qwUserID) || (0 == pMsg->qwBuddyID))
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_61,
            "Accept from client @ %s:%d Bad user or buddy id (0)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port));

        hr = E_INVALIDARG;
        goto lDone;
    }

    // Can't be your own buddy
    if(pMsg->qwUserID == pMsg->qwBuddyID)
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_62,
            "Accept from client @ %s:%d UserID equals BuddyID (%I64X)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port),            
            pMsg->qwUserID);

        hr = E_INVALIDARG;
        goto lDone;
    }

    // Everything looks cool, send it on to the switchboard
    hr = m_pSwitchboard->Accept(
        pMsg->sgaddr,
        pMsg->dwSeqNum,
        pMsg->qwUserID,
        pMsg->qwBuddyID,
        &qwNonce);

    // LineType|MachinePUID|Nonce|SG IP|SG SPI|UserPUID|BuddyPUID|hr
    XomLog(
        PresenceLog,
        "ACC|%I64X|%I64X|%X|%X|%I64X|%I64X|%X",
        pMsg->sgaddr.qwXboxID,
        qwNonce,
        pMsg->sgaddr.inaSg,
        pMsg->sgaddr.dwSpiSg,
        pMsg->qwUserID,
        pMsg->qwBuddyID,
        hr);

lDone:

    if (hr == XONLINE_E_PRESENCE_DEFER_REQUEST)
    {
        hr = DeferMessage(pMsg->qwUserID, pMsg, cbEntireMsg);
    }
    else if (hr == XONLINE_E_PRESENCE_USER_MIGRATED)
    {
        hr = m_pSwitchboard->GetClientListener()->ForwardMessage(this, pMsg->qwUserID, pMsg, cbEntireMsg);
    }

    // Send client notification of failures
    if (FAILED(hr))
    {
        hrQ = m_pSwitchboard->GetPCluser()->QueueListChange(
            pMsg->qwUserID, 
            0,
            pMsg->qwBuddyID,
            PLIST_BUDDY_ACCEPT,
            hr,
            0,
            "");
        if (FAILED(hrQ) && (hrQ != HRESULT_FROM_WIN32(ERROR_NO_SUCH_USER)))
        {
            // Log and continue
            XomNtEvent( 
                XEVENT_PRESENCE_CODE_45,
                "Failure to enqueue accept list change item UserID=%I64X hr=0x%X", 
                pMsg->qwUserID, 
                hrQ);
        }
    }

    // Keep track of things
    if( FAILED(hr) )
    {
        g_Counters.TrackFailureMessage( XPPERF_SERVER_ACCEPT_MSGS_COUNTER );

        XomNtEvent( 
            XEVENT_PRESENCE_CODE_46, 
            "CClientConnection::ProcessMsgAccept failed user=%I64X buddy=%I64X hr=0x%X",
            pMsg->qwUserID,
            pMsg->qwBuddyID,
            hr);
    }

    // Success counter incremented on DB callback
}

/*****************************************************************************

CClientConnection::ProcessMsgReject

Process Reject messages.

*****************************************************************************/
void CClientConnection::ProcessMsgReject(P_REJECT_MSG *pMsg, DWORD cbEntireMsg)
{
    CScopeTimer scope( XPPERF_SERVER_REJECT_BUDDY_CLIENT_TIME_AVERAGE, XPPERF_SERVER_REJECT_BUDDY_CLIENT_TIME_BASE );

    XOMASSERT(pMsg != NULL);
    XOMASSERT(m_pSwitchboard != NULL);

    HRESULT hr = S_OK;
    HRESULT hrQ = S_OK;
    QWORD qwNonce = 0;

    // UserID of 0 is invalid
    if((0 == pMsg->qwUserID) || (0 == pMsg->qwBuddyID))
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_63,
            "Reject from client @ %s:%d Bad user id (0)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port));

        hr = E_INVALIDARG;
        goto lDone;
    }

    // Can't be your own buddy
    if(pMsg->qwUserID == pMsg->qwBuddyID)
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_64,
            "Reject from client @ %s:%d UserID equals BuddyID (%I64X)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port),            
            pMsg->qwUserID);

        hr = E_INVALIDARG;
        goto lDone;
    }

    // Everything looks cool, send it on to the switchboard
    hr = m_pSwitchboard->Reject(
        pMsg->sgaddr,
        pMsg->dwSeqNum,
        pMsg->qwUserID,
        pMsg->qwBuddyID,
        pMsg->fNever,
        &qwNonce);

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "Reject from %s:%d sg %X spi %X xb %I64X user %I64X bdy %I64X never %d hr=%X",
        inet_ntoa(m_sa.sin_addr), 
        ntohs(m_sa.sin_port), 
        pMsg->sgaddr.inaSg,
        pMsg->sgaddr.dwSpiSg,
        pMsg->sgaddr.qwXboxID,
        pMsg->qwUserID,
        pMsg->qwBuddyID,
        pMsg->fNever,
        hr);

    // LineType|MachinePUID|Nonce|SG IP|SG SPI|UserPUID|BuddyPUID|Never|hr
    XomLog(
        PresenceLog,
        "REJ|%I64X|%I64X|%X|%X|%I64X|%I64X|%X|%X",
        pMsg->sgaddr.qwXboxID,
        qwNonce,
        pMsg->sgaddr.inaSg,
        pMsg->sgaddr.dwSpiSg,
        pMsg->qwUserID,
        pMsg->qwBuddyID,
        pMsg->fNever,
        hr);

lDone:

    if (hr == XONLINE_E_PRESENCE_DEFER_REQUEST)
    {
        hr = DeferMessage(pMsg->qwUserID, pMsg, cbEntireMsg);
    }
    else if (hr == XONLINE_E_PRESENCE_USER_MIGRATED)
    {
        hr = m_pSwitchboard->GetClientListener()->ForwardMessage(this, pMsg->qwUserID, pMsg, cbEntireMsg);
    }

    // Send client notification of failures
    if (FAILED(hr))
    {
        hrQ = m_pSwitchboard->GetPCluser()->QueueListChange(
            pMsg->qwUserID,
            0,
            pMsg->qwBuddyID,
            PLIST_BUDDY_REJECT,
            hr,
            0,
            "");
        if (FAILED(hrQ))
        {
            // Log and continue
            XomNtEvent( 
                XEVENT_PRESENCE_CODE_47, 
                "Failure to enqueue reject list change item UserID=%I64X hr=0x%X", 
                pMsg->qwUserID, 
                hrQ);
        }
    }

    // Keep track of things
    if( FAILED(hr) )
    {
        g_Counters.TrackFailureMessage( XPPERF_SERVER_REJECT_MSGS_COUNTER );

        XomNtEvent( 
            XEVENT_PRESENCE_CODE_48, 
            "CClientConnection::ProcessMsgReject failed user=%I64X buddy=%I64X hr=0x%X",
            pMsg->qwUserID,
            pMsg->qwBuddyID,
            hr);
    }
    // Success counter incremented on DB callback
}

/*****************************************************************************

CClientConnection::ProcessMsgBlock

Process Block messages.

*****************************************************************************/
void CClientConnection::ProcessMsgBlock(P_BLOCK_MSG *pMsg, DWORD cbEntireMsg)
{
    CScopeTimer scope( XPPERF_SERVER_MUTE_CLIENT_TIME_AVERAGE, XPPERF_SERVER_MUTE_CLIENT_TIME_BASE );

    XOMASSERT(pMsg != NULL);
    XOMASSERT(m_pSwitchboard != NULL);

    HRESULT hr = S_OK;
    QWORD qwNonce = 0;

    // UserID of zero is invalid
    if((0 == pMsg->qwUserID) || (0 == pMsg->qwBlockID))
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_65,
            "Block from client @ %s:%d Bad user id (0)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port));

        hr = E_INVALIDARG;
        goto lDone;
    }

    // Can't block yourself
    if(pMsg->qwUserID == pMsg->qwBlockID)
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_66,
            "Block from client @ %s:%d UserID equals BlockID (%I64X)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port),
            pMsg->qwUserID);

        hr = E_INVALIDARG;
        goto lDone;
    }

    // Everything looks cool, send it on to the switchboard
    hr = m_pSwitchboard->Block(
        pMsg->sgaddr,
        pMsg->dwSeqNum,
        pMsg->qwUserID,
        pMsg->qwBlockID,
        &qwNonce);

    // LineType|MachinePUID|Nonce|SG IP|SG SPI|UserPUID|BlockPUID|hr
    XomLog(
        PresenceLog,
        "BLK|%I64X|%I64X|%X|%X|%I64X|%I64X|%X",
        pMsg->sgaddr.qwXboxID,
        qwNonce,
        pMsg->sgaddr.inaSg,
        pMsg->sgaddr.dwSpiSg,
        pMsg->qwUserID,
        pMsg->qwBlockID,
        hr);

lDone:

    if (hr == XONLINE_E_PRESENCE_DEFER_REQUEST)
    {
        hr = DeferMessage(pMsg->qwUserID, pMsg, cbEntireMsg);
    }
    else if (hr == XONLINE_E_PRESENCE_USER_MIGRATED)
    {
        hr = m_pSwitchboard->GetClientListener()->ForwardMessage(this, pMsg->qwUserID, pMsg, cbEntireMsg);
    }

    // Keep track of things
    if(FAILED(hr))
    {
        g_Counters.TrackFailureMessage( XPPERF_SERVER_BLOCK_MSGS_COUNTER );

        XomNtEvent( 
            XEVENT_PRESENCE_CODE_49, 
            "CClientConnection::ProcessMsgBlock failed user=%I64X block=%I64X hr=0x%X",
            pMsg->qwUserID,
            pMsg->qwBlockID,
            hr);
    }
    // Success counter incremented on DB callback
}

/*****************************************************************************

CClientConnection::ProcessMsgUnblock

Process Block messages.

*****************************************************************************/
void CClientConnection::ProcessMsgUnblock( P_UNBLOCK_MSG *pMsg, DWORD cbEntireMsg )
{
    CScopeTimer scope( XPPERF_SERVER_UNMUTE_CLIENT_TIME_AVERAGE, XPPERF_SERVER_UNMUTE_CLIENT_TIME_BASE );

    XOMASSERT(pMsg != NULL);
    XOMASSERT(m_pSwitchboard != NULL);

    HRESULT hr = S_OK;
    QWORD qwNonce = 0;

    // UserID of zero is invalid
    if( 0 == pMsg->qwUserID )
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_67,
            "Unblock from client @ %s:%d Bad user id (0)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port));

        hr = E_INVALIDARG;
        goto lDone;
    }

    // Can't block yourself
    if(pMsg->qwUserID == pMsg->qwBlockID)
    {
       XomNtEvent(
            XEVENT_PRESENCE_HACK_68,
            "Unblock from client @ %s:%d UserID equals BlockID (%I64X)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port),
            pMsg->qwUserID);

        hr = E_INVALIDARG;
        goto lDone;
    }

    // Everything looks cool, send it on to the switchboard
    hr = m_pSwitchboard->Unblock(
        pMsg->sgaddr,
        pMsg->dwSeqNum,
        pMsg->qwUserID,
        pMsg->qwBlockID,
        &qwNonce);

    // LineType|MachinePUID|Nonce|SG IP|SG SPI|UserPUID|BlockPUID|hr
    XomLog(
        PresenceLog,
        "UBK|%I64X|%I64X|%X|%X|%I64X|%I64X|%X",
        pMsg->sgaddr.qwXboxID,
        qwNonce,
        pMsg->sgaddr.inaSg,
        pMsg->sgaddr.dwSpiSg,
        pMsg->qwUserID,
        pMsg->qwBlockID,
        hr);

lDone:

    if (hr == XONLINE_E_PRESENCE_DEFER_REQUEST)
    {
        hr = DeferMessage(pMsg->qwUserID, pMsg, cbEntireMsg);
    }
    else if (hr == XONLINE_E_PRESENCE_USER_MIGRATED)
    {
        hr = m_pSwitchboard->GetClientListener()->ForwardMessage(this, pMsg->qwUserID, pMsg, cbEntireMsg);
    }

    // Keep track of things
    if(FAILED(hr))
    {
        g_Counters.TrackFailureMessage( XPPERF_SERVER_UNBLOCK_MSGS_COUNTER );

        XomNtEvent( 
            XEVENT_PRESENCE_CODE_50, 
            "CClientConnection::ProcessMsgUnblock failed user=%I64X block=%I64X hr=0x%X",
            pMsg->qwUserID,
            pMsg->qwBlockID,
            hr); 
    }
    // Success counter incremented on DB callback
}


/*****************************************************************************

CClientConnection::ProcessMsgInvite

Process Invite messages.

*****************************************************************************/
void CClientConnection::ProcessMsgInvite(P_INVITE_2_MSG *pMsg, DWORD cbEntireMsg)
{
    CScopeTimer scope( XPPERF_SERVER_INVITE_CLIENT_TIME_AVERAGE, XPPERF_SERVER_INVITE_CLIENT_TIME_BASE );

    XOMASSERT(pMsg != NULL);
    XOMASSERT(m_pSwitchboard != NULL);

    HRESULT hr = S_OK;
    DWORD cbExpected = 0;
    const QWORD *pqwInvitees = NULL;
    QWORD qwNonce = 0;
    const XMSG_DETAILS* pDetails = NULL;
    QWORD qwMatchSessionID = 0;

    // UserID zero is invalid
    if(0 == pMsg->qwUserID)
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_69,
            "Invite from client @ %s:%d Bad user id (0)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port));

        hr = E_INVALIDARG;
        goto lDone;
    }

    // Check the message size against what is expected
    cbExpected = sizeof(P_INVITE_2_MSG) + ( pMsg->cInvitees * sizeof(QWORD) ) + pMsg->cbDetails;

    if( cbEntireMsg != cbExpected)
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_70,
            "Invite from client @ %s:%d (size %d != %d)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port),
            cbEntireMsg,
            cbExpected);

        hr = E_INVALIDARG;
        Disconnect(hr);
        goto lDone;
    }

    // Make sure it is safe to read the details
    if( pMsg->cbDetails < sizeof( XMSG_DETAILS ) )
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_71,
            "Invite from client @ %s:%d invalid details (size=%d)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port),
            pMsg->cbDetails);

        hr = E_INVALIDARG;
        Disconnect(hr);
        goto lDone;
    }

    pDetails = (const XMSG_DETAILS*)( (BYTE*)( pMsg + 1 ) + ( pMsg->cInvitees * sizeof(QWORD) ) );

    // Validate that the details section is at least large enough to hold as many property descriptors as it specifies
    if( pMsg->cbDetails < sizeof( XMSG_DETAILS ) + pDetails->wPropCount * sizeof( XMSG_PROPERTY ) )
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_72,
            "Invite from client @ %s:%d too small for %d property descriptors (%d)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port),
            pDetails->wPropCount,
            pMsg->cbDetails);

        hr = E_INVALIDARG;
        Disconnect(hr);
        goto lDone;
    }

    // Look for the required session ID property
    for( WORD iProp = 0; iProp < pDetails->wPropCount; iProp++ )
    {
        XMSG_PROPERTY* pProp = (XMSG_PROPERTY*)( pDetails + 1 ) + iProp;

        if( XONLINE_MSG_PROP_SESSION_ID == pProp->wPropTag )
        {
            // Make sure there is enough room for the property data
            if( pMsg->cbDetails < pProp->wPropOffset + sizeof( QWORD ) )
            {
                XomNtEvent(
                    XEVENT_PRESENCE_HACK_73,
                    "Invite from client @ %s:%d too small for property 0x%04X (%d)",
                    inet_ntoa(m_sa.sin_addr),
                    ntohs(m_sa.sin_port),
                    pProp->wPropTag,
                    pMsg->cbDetails);

                hr = E_INVALIDARG;
                Disconnect(hr);
                goto lDone;
            }

            qwMatchSessionID = *((QWORD*)((BYTE*)( pDetails + 1 ) + ( pDetails->wPropCount * sizeof( XMSG_PROPERTY ) ) + pProp->wPropOffset));
            break;
        }
    }

    // Session id zero is invalid
    if(0 == qwMatchSessionID)
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_74,
            "Invite from client @ %s:%d User %I64X Bad session id (0)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port),
            pMsg->qwUserID);

        hr = E_INVALIDARG;
        goto lDone;
    }

    // Make sure there is at least one invitee
    if ((0 == pMsg->cInvitees) ||
        (pMsg->cInvitees > XONLINE_MAX_MESSAGE_RECIPIENTS))
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_75,
            "Invite from client @ %s:%d Bad number of invitees (%d)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port),
            pMsg->cInvitees);

        hr = E_INVALIDARG;
        goto lDone;
    }

    pqwInvitees = (const QWORD *)( pMsg + 1 );

    // Everything looks cool, send it on to the switchboard
    hr = m_pSwitchboard->Invite(
        pMsg->sgaddr,
        pMsg->qwUserID,
        pMsg->dwTitleID,
        qwMatchSessionID,
        pMsg->cInvitees,
        pqwInvitees,
        pMsg->dwMessageFlags,
        pMsg->qwSenderContext,
        pMsg->cbDetails,
        (const BYTE*) pDetails,
        &qwNonce);

    // LineType|MachinePUID|Nonce|SG IP|SG SPI|UserPUID|TitleID|MatchSessID|NumInv|hr
    XomLog(
        PresenceLog,
        "INV|%I64X|%I64X|%X|%X|%I64X|%X|%I64X|%X|%X",
        pMsg->sgaddr.qwXboxID,
        qwNonce,
        pMsg->sgaddr.inaSg,
        pMsg->sgaddr.dwSpiSg,
        pMsg->qwUserID,
        pMsg->dwTitleID,
        qwMatchSessionID,
        pMsg->cInvitees,
        hr);

lDone:
    
    if (hr == XONLINE_E_PRESENCE_DEFER_REQUEST)
    {
        hr = DeferMessage(pMsg->qwUserID, pMsg, cbEntireMsg);
    }
    else if (hr == XONLINE_E_PRESENCE_USER_MIGRATED)
    {
        hr = m_pSwitchboard->GetClientListener()->ForwardMessage(this, pMsg->qwUserID, pMsg, cbEntireMsg);
    }

    // Keep track of things
    if( SUCCEEDED(hr) )
    {
        g_Counters.TrackSuccessfulMessage( XPPERF_SERVER_INVITE_MSGS_COUNTER );
    }
    else
    {
        g_Counters.TrackFailureMessage( XPPERF_SERVER_INVITE_MSGS_COUNTER );

        XomNtEvent( 
            XEVENT_PRESENCE_CODE_51, 
            "CClientConnection::ProcessMsgInvite failed user=%I64X title=%d session=%I64X num=%d inv0=%I64X hr=0x%X",
            pMsg->qwUserID,
            pMsg->dwTitleID,
            qwMatchSessionID,
            pMsg->cInvitees,
            ((pqwInvitees != 0) && (pMsg->cInvitees > 0) ? pqwInvitees[0] : 0),
            hr);
    }
}

/*****************************************************************************

CClientConnection::ProcessMsgCancel

Process Cancel messages.

*****************************************************************************/
void CClientConnection::ProcessMsgCancel(P_CANCEL_MSG *pMsg, DWORD cbEntireMsg)
{
    CScopeTimer scope( XPPERF_SERVER_CANCEL_INVITE_CLIENT_TIME_AVERAGE, XPPERF_SERVER_CANCEL_INVITE_CLIENT_TIME_BASE );

    XOMASSERT(pMsg != NULL);
    XOMASSERT(m_pSwitchboard != NULL);

    HRESULT hr = S_OK;
    DWORD cbExpected = 0;
    QWORD *pqwInvitees = NULL;
    QWORD qwNonce = 0;

    // UserID zero is invalid
    if(0 == pMsg->qwUserID)
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_76,
            "Cancel from client @ %s:%d Bad user id (0)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port));
        
        hr = E_INVALIDARG;
        goto lDone;
    }

    // Session id zero is invalid
    if(0 == pMsg->qwMatchSessionID)
    {
        // Old clients can send these, so debug spew only
         XomTrace(
            PresenceDebug, 
            L_NORMAL,
            "Cancel from client @ %s:%d User %I64X Bad session id (0)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port),
            pMsg->qwUserID);

        hr = E_INVALIDARG;
        goto lDone;
    }

    // Check the message size against what is expected
    cbExpected = (pMsg->cInvitees * sizeof(QWORD)) + sizeof(P_CANCEL_MSG);

    if( cbEntireMsg != cbExpected)
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_77,
            "Cancel from client @ %s:%d (size %d != %d)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port),
            cbEntireMsg,
            cbExpected);

        hr = E_INVALIDARG;
        Disconnect(hr);
        goto lDone;
    }

    pqwInvitees = (QWORD *)( pMsg + 1 );

    // Everything looks cool, send it on to the switchboard
    hr = m_pSwitchboard->Cancel(
        pMsg->sgaddr,
        pMsg->qwUserID,
        pMsg->qwMatchSessionID,
        pMsg->cInvitees,
        pqwInvitees,
        &qwNonce);

    // LineType|MachinePUID|Nonce|SG IP|SG SPI|UserPUID|MatchSessID|NumInv|hr
    XomLog(
        PresenceLog,
        "CAN|%I64X|%I64X|%X|%X|%I64X|%I64X|%X|%X",
        pMsg->sgaddr.qwXboxID,
        qwNonce,
        pMsg->sgaddr.inaSg,
        pMsg->sgaddr.dwSpiSg,
        pMsg->qwUserID,
        pMsg->qwMatchSessionID,
        pMsg->cInvitees,
        hr);

lDone:

    if (hr == XONLINE_E_PRESENCE_DEFER_REQUEST)
    {
        hr = DeferMessage(pMsg->qwUserID, pMsg, cbEntireMsg);
    }
    else if (hr == XONLINE_E_PRESENCE_USER_MIGRATED)
    {
        hr = m_pSwitchboard->GetClientListener()->ForwardMessage(this, pMsg->qwUserID, pMsg, cbEntireMsg);
    }

   // Keep track of things
    if(SUCCEEDED(hr))
    {
        g_Counters.TrackSuccessfulMessage( XPPERF_SERVER_CANCEL_INV_MSGS_COUNTER );
    }
    else
    {
        g_Counters.TrackFailureMessage( XPPERF_SERVER_CANCEL_INV_MSGS_COUNTER );

        // Don't spew on SeesionID of zero
        if (pMsg->qwMatchSessionID != 0)
        {
            XomNtEvent( 
                XEVENT_PRESENCE_CODE_52, 
                "CClientConnection::ProcessMsgCancel failed user=%I64X session=%I64X num=%d inv0=%I64X hr=0x%X",
                pMsg->qwUserID,
                pMsg->qwMatchSessionID,
                pMsg->cInvitees,
                ((pqwInvitees != 0) && (pMsg->cInvitees > 0) ? pqwInvitees[0] : 0),
                hr);
        }
    }
}

/*****************************************************************************

CClientConnection::ProcessMsgInviteAnswer

Process Invite Answer messages.

*****************************************************************************/
void CClientConnection::ProcessMsgInviteAnswer(P_INVITE_ANSWER_MSG *pMsg, DWORD cbEntireMsg)
{
    CScopeTimer scope( XPPERF_SERVER_INVITE_ANSWER_CLIENT_TIME_AVERAGE, XPPERF_SERVER_INVITE_ANSWER_CLIENT_TIME_BASE );

    XOMASSERT(pMsg != NULL);
    XOMASSERT(m_pSwitchboard != NULL);

    HRESULT hr = S_OK;
    QWORD qwNonce = 0;

    // UserID zero is invalid
    if(0 == pMsg->qwUserID)
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_78,
            "InviteAnswer from client @ %s:%d Bad UserID (0)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port));
        
        hr = E_INVALIDARG;
        goto lDone;
    }

    // HostID zero is invalid
    if(0 == pMsg->qwHostID)
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_79,
            "InviteAnswer from client @ %s:%d Bad HostID (0)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port));
        
        hr = E_INVALIDARG;
        goto lDone;
    }

    // Make sure the response is supported
    if((pMsg->wAnswer != PINVITE_REPLY_NO) && 
       (pMsg->wAnswer != PINVITE_REPLY_YES) &&
       (pMsg->wAnswer != PINVITE_REPLY_NEVER))
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_80,
            "InviteAnswer from client @ %s:%d Wrong answer (%d)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port),
            pMsg->wAnswer);
        
        hr = E_INVALIDARG;
        goto lDone;
    }

    // Session id zero is invalid
    if(0 == pMsg->qwMatchSessionID)
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_81,
            "Invite Answer from client @ %s:%d User %I64X Bad session id (0)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port),
            pMsg->qwUserID);

        hr = E_INVALIDARG;
        goto lDone;
    }


    // Everything looks cool, send it on to the switchboard
    hr = m_pSwitchboard->InviteAnswer(
        pMsg->sgaddr,
        pMsg->qwUserID,
        pMsg->qwHostID,
        pMsg->qwMatchSessionID,
        pMsg->wAnswer,
        &qwNonce);

    // LineType|MachinePUID|Nonce|SG IP|SG SPI|UserPUID|MatchSessID|NumInv|hr
    XomLog(
        PresenceLog,
        "ANS|%I64X|%I64X|%X|%X|%I64X|%I64X|%I64X|%X|%X",
        pMsg->sgaddr.qwXboxID,
        qwNonce,
        pMsg->sgaddr.inaSg,
        pMsg->sgaddr.dwSpiSg,
        pMsg->qwUserID,
        pMsg->qwHostID,
        pMsg->qwMatchSessionID,
        pMsg->wAnswer,
        hr);

lDone:

    if (hr == XONLINE_E_PRESENCE_DEFER_REQUEST)
    {
        hr = DeferMessage(pMsg->qwUserID, pMsg, cbEntireMsg);
    }
    else if (hr == XONLINE_E_PRESENCE_USER_MIGRATED)
    {
        hr = m_pSwitchboard->GetClientListener()->ForwardMessage(this, pMsg->qwUserID, pMsg, cbEntireMsg);
    }

   // Keep track of things
    if( SUCCEEDED(hr) )
    {
        g_Counters.TrackSuccessfulMessage( XPPERF_SERVER_ANSWER_INV_MSGS_COUNTER );
    }
    else
    {
        g_Counters.TrackFailureMessage( XPPERF_SERVER_ANSWER_INV_MSGS_COUNTER );

        XomNtEvent( 
            XEVENT_PRESENCE_CODE_53,
            "CClientConnection::ProcessMsgInviteAnswer failed user=%I64X host=%I64X session=%I64X ans=%d hr=0x%X",
            pMsg->qwUserID,
            pMsg->qwHostID,
            pMsg->qwMatchSessionID,
            pMsg->wAnswer,
            hr);
    }
}

/*****************************************************************************

CClientConnection::ProcessMsgNickname

Process Nickname messages.

*****************************************************************************/
void CClientConnection::ProcessMsgNickname(P_NICKNAME_MSG *pMsg, DWORD cbEntireMsg)
{
    CScopeTimer scope( XPPERF_SERVER_NICKNAME_CLIENT_TIME_AVERAGE, XPPERF_SERVER_NICKNAME_CLIENT_TIME_BASE );

    XOMASSERT(pMsg != NULL);
    XOMASSERT(m_pSwitchboard != NULL);

    HRESULT hr = S_OK;
    DWORD cbExpected;
    QWORD qwNonce = 0;

    // UserID of 0 not allowed
    if(0 == pMsg->qwUserID)
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_82,
            "Nickname from client @ %s:%d Bad user id (0)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port));

        hr = E_INVALIDARG;
        goto lDone;
    }

    // Make sure the nickname is not too big
    if (pMsg->cbNickname > MAX_NICKNAME_BYTES)
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_83,
            "Nickname from client @ %s:%d Too long of cbNickname (%d > %d)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port),
            pMsg->cbNickname,
            MAX_NICKNAME_BYTES);

        hr = E_INVALIDARG;
        goto lDone;
    }

    // Make sure the whole message adds up
    cbExpected = pMsg->cbNickname + sizeof(P_NICKNAME_MSG);
    if(cbEntireMsg != cbExpected)
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_84,
            "Nickname from client @ %s:%d (size %d != %d)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port),
            cbEntireMsg,
            cbExpected );

        hr = E_INVALIDARG;
        Disconnect(hr);
        goto lDone;
    }

    // Everything looks cool, send it on to the switchboard
    hr = m_pSwitchboard->Nickname(
        pMsg->sgaddr,
        pMsg->qwUserID,
        pMsg->cbNickname,
        (const BYTE *)( pMsg + 1 ),
        &qwNonce);

    char szNickName[MAX_NICKNAME_BYTES];
    memcpy(szNickName, (const BYTE *)( pMsg + 1 ), pMsg->cbNickname);
    szNickName[pMsg->cbNickname] = '\0';

    // LineType|MachinePUID|Nonce|SG IP|SG SPI|UserPUID|Nickname|hr
    XomLog(
        PresenceLog,
        "NICK|%I64X|%I64X|%X|%X|%I64X|%s|%X",
        pMsg->sgaddr.qwXboxID,
        qwNonce,
        pMsg->sgaddr.inaSg,
        pMsg->sgaddr.dwSpiSg,
        pMsg->qwUserID,
        szNickName,
        hr);

lDone:

    if (hr == XONLINE_E_PRESENCE_DEFER_REQUEST)
    {
        hr = DeferMessage(pMsg->qwUserID, pMsg, cbEntireMsg);
    }
    else if (hr == XONLINE_E_PRESENCE_USER_MIGRATED)
    {
        hr = m_pSwitchboard->GetClientListener()->ForwardMessage(this, pMsg->qwUserID, pMsg, cbEntireMsg);
    }

    // Keep track of things
    if( SUCCEEDED(hr) )
    {
        g_Counters.TrackSuccessfulMessage( XPPERF_SERVER_NICKNAME_MSGS_COUNTER );
    }
    else
    {
        g_Counters.TrackFailureMessage( XPPERF_SERVER_NICKNAME_MSGS_COUNTER );

        XomNtEvent( 
            XEVENT_PRESENCE_CODE_54,
            "CClientConnection::ProcessMsgNickname failed user=%I64X hr=0x%X",
            pMsg->qwUserID,
            hr);
    }
}

/*****************************************************************************

CClientConnection::ProcessMsgState

Process State messages.

*****************************************************************************/
void CClientConnection::ProcessMsgState( P_STATE_MSG *pMsg, DWORD cbEntireMsg )
{
    CScopeTimer scope( XPPERF_SERVER_STATE_CLIENT_TIME_AVERAGE, XPPERF_SERVER_STATE_CLIENT_TIME_BASE );

    XOMASSERT(pMsg != NULL);
    XOMASSERT(m_pSwitchboard != NULL);

    HRESULT hr = S_OK;
    QWORD qwNonce = 0;
    const BYTE *pbTitleStuff = NULL;
    CHAR szTitleStuff[(MAX_TITLE_STATE_BYTES * 2) + 1];
    CHAR szHex[16] = { '0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F' };
    DWORD dwIndex = 0;

    // UserID of 0 not allowed
    if( 0 == pMsg->qwUserID )
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_85,
            "State from client @ %s:%d Bad user id (0)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port));

        hr = E_INVALIDARG;
        goto lDone;
    }

    // Make sure the title stuff is not too big
    if (pMsg->cbTitleStuff > MAX_TITLE_STATE_BYTES)
    {
        CPresence *pCPresence = NULL;
        g_CPresenceUserIndex.FindPresence(pMsg->qwUserID, &pCPresence);

        if (pCPresence != NULL)
        {
            XomNtEvent(
                XEVENT_PRESENCE_HACK_86,
                "State from client @ %s:%d Too long of rgbTitleStuff (%d > %d).  TitleId = 0x%08X, TitleVersion = %d.",
                inet_ntoa(m_sa.sin_addr),
                ntohs(m_sa.sin_port),
                pMsg->cbTitleStuff,
                MAX_TITLE_STATE_BYTES,
                pCPresence->GetTitleID(),
                pCPresence->GetTitleVersion());
        }
        else
        {
            XomNtEvent(
                XEVENT_PRESENCE_HACK_87,
                "State from client @ %s:%d Too long of rgbTitleStuff (%d > %d)",
                inet_ntoa(m_sa.sin_addr),
                ntohs(m_sa.sin_port),
                pMsg->cbTitleStuff,
                MAX_TITLE_STATE_BYTES);
        }

        SAFE_RELEASE(pCPresence);
        hr = E_INVALIDARG;
        goto lDone;
    }

    pbTitleStuff = (const BYTE *)( pMsg + 1 );

    // Everything looks cool, send it on to the switchboard
    hr = m_pSwitchboard->State(
        pMsg->sgaddr,
        pMsg->qwUserID,
        pMsg->dwState,
        pMsg->qwMatchSessionID,
        0,  // 0 means the title hasn't changed
        pMsg->cbTitleStuff,
        pbTitleStuff,
        0,
        NULL,
        0,
        NULL,
        &qwNonce);

    // Translate the PData into a blob
    for (dwIndex = 0; dwIndex < pMsg->cbTitleStuff; dwIndex++)
    {
        szTitleStuff[dwIndex * 2] = szHex[pbTitleStuff[dwIndex] & 0xF];
        szTitleStuff[(dwIndex * 2) + 1] = szHex[pbTitleStuff[dwIndex] >> 4];
    }

    szTitleStuff[dwIndex * 2] = '\0';

    // removed STA log lines per Xenon bug 76932
    //    // LineType|MachinePUID|Nonce|SG IP|SG SPI|UserPUID|State|MatchSessID|DataLen|Data|hr
    //    XomLog(
    //        PresenceLog,
    //        "STA|%I64X|%I64X|%X|%X|%I64X|%X|%I64X|%X|%s|%X",
    //        pMsg->sgaddr.qwXboxID,
    //        qwNonce,
    //        pMsg->sgaddr.inaSg,
    //        pMsg->sgaddr.dwSpiSg,
    //        pMsg->qwUserID,
    //        pMsg->dwState,
    //        pMsg->qwMatchSessionID,
    //        pMsg->cbTitleStuff,
    //        szTitleStuff,
    //        hr);

lDone:

    if (hr == XONLINE_E_PRESENCE_DEFER_REQUEST)
    {
        hr = DeferMessage(pMsg->qwUserID, pMsg, cbEntireMsg);
    }
    else if (hr == XONLINE_E_PRESENCE_USER_MIGRATED)
    {
        hr = m_pSwitchboard->GetClientListener()->ForwardMessage(this, pMsg->qwUserID, pMsg, cbEntireMsg);
    }

    // Keep track of things
    // Treat not found as success, these often happen since the SG has latency
    // sending updates to us
    if( SUCCEEDED(hr) ||
        hr == HRESULT_FROM_WIN32(ERROR_NO_SUCH_USER))
    {
        g_Counters.TrackSuccessfulMessage( XPPERF_SERVER_STATE_MSGS_COUNTER );
    }
    else
    {
        g_Counters.TrackFailureMessage( XPPERF_SERVER_STATE_MSGS_COUNTER );
     
        // pull titleid out of the presence record.
        CPresence *pCPresence = NULL;
        g_CPresenceUserIndex.FindPresence(pMsg->qwUserID, &pCPresence);
        DWORD dwTitleID = (pCPresence == NULL) ? 0 : pCPresence->GetTitleID();
        SAFE_RELEASE(pCPresence);
        
        XomNtEvent( 
            XEVENT_PRESENCE_CODE_55, 
            "CClientConnection::ProcessMsgState failed user=%I64X, title=0x%X, xbox=%I64X hr=0x%X",
            pMsg->qwUserID,
            dwTitleID,
            pMsg->sgaddr.qwXboxID,
            hr);
    }
}

/*****************************************************************************

CClientConnection::ProcessMsgState2

Process State messages.

*****************************************************************************/
void CClientConnection::ProcessMsgState2( P_STATE_2_MSG *pMsg, DWORD cbEntireMsg )
{
    CScopeTimer scope( XPPERF_SERVER_STATE2_CLIENT_TIME_AVERAGE, XPPERF_SERVER_STATE2_CLIENT_TIME_BASE );

    XOMASSERT(pMsg != NULL);
    XOMASSERT(m_pSwitchboard != NULL);

    HRESULT hr = S_OK;
    QWORD qwNonce = 0;

    // UserID of 0 not allowed
    if( 0 == pMsg->qwUserID )
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_88,
            "State2 from client @ %s:%d Bad user id (0)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port));

        hr = E_INVALIDARG;
        goto lDone;
    }

    P_RICH_PRESENCE *pRichPresence;
    WORD cbRichPresence = (WORD)pMsg->cbRichPresence;
    BYTE *pMemcacheData;
    WORD cbMemcacheData = pMsg->cbMemcacheBlob;

    if (cbRichPresence == 0)
    {
        pRichPresence = NULL;
    }
    else
    {
        pRichPresence = (P_RICH_PRESENCE *)&pMsg->rp;
    }

    if (cbMemcacheData < sizeof(XONLINE_SUBNOTI::BASE_DATA_HEADER))
    {
        cbMemcacheData = 0;
        pMemcacheData = NULL;
    }
    else
    {
        pMemcacheData = (BYTE *)(&pMsg->rp) + cbRichPresence;
    }
    
    
    if (cbRichPresence > g_CPresCfg.GetMaxRichPresenceBytes())
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_89,
            "State2 from client @ %s:%d. Rich Presence data size of %d exceeds configured maximum of %d",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port),
            cbRichPresence,
            g_CPresCfg.GetMaxRichPresenceBytes());

        hr = E_INVALIDARG;
        goto lDone;        
    }
    
    // Everything looks cool, send it on to the switchboard
    hr = m_pSwitchboard->State(
        pMsg->sgaddr,
        pMsg->qwUserID,
        pMsg->dwState,
        pMsg->qwMatchSessionID,
        pMsg->dwTitleID,
        0,
        NULL,
        cbRichPresence,
        pRichPresence,
        cbMemcacheData,
        pMemcacheData,
        &qwNonce);

    // removed STA log lines per Xenon bug 76932
    //    // LineType|MachinePUID|Nonce|SG IP|SG SPI|UserPUID|State|MatchSessID|TitleID|RichPresence|cProperties|cContexts|hr
    //    XomLog(
    //        PresenceLog,
    //        "ST2|%I64X|%I64X|%X|%X|%I64X|%X|%I64X|%X|%X|%X|%X|%X",
    //        pMsg->sgaddr.qwXboxID,
    //        qwNonce,
    //        pMsg->sgaddr.inaSg,
    //        pMsg->sgaddr.dwSpiSg,
    //        pMsg->qwUserID,
    //        pMsg->dwState,
    //        pMsg->qwMatchSessionID,
    //        pMsg->dwTitleID,
    //        pMsg->rp.titlePresence,
    //        pMsg->rp.cProperties,
    //        pMsg->rp.cContexts,
    //        hr);

lDone:

    if (hr == XONLINE_E_PRESENCE_DEFER_REQUEST)
    {
        hr = DeferMessage(pMsg->qwUserID, pMsg, cbEntireMsg);
    }
    else if (hr == XONLINE_E_PRESENCE_USER_MIGRATED)
    {
        hr = m_pSwitchboard->GetClientListener()->ForwardMessage(this, pMsg->qwUserID, pMsg, cbEntireMsg);
    }

    // Keep track of things
    // Treat not found as success, these often happen since the SG has latency
    // sending updates to us
    if( SUCCEEDED(hr) ||
        hr == HRESULT_FROM_WIN32(ERROR_NO_SUCH_USER))
    {
        g_Counters.TrackSuccessfulMessage( XPPERF_SERVER_STATE2_MSGS_COUNTER );
    }
    else
    {
        g_Counters.TrackFailureMessage( XPPERF_SERVER_STATE2_MSGS_COUNTER );
     
        XomNtEvent( 
            XEVENT_PRESENCE_CODE_56, 
            "CClientConnection::ProcessMsgState2 failed user=%I64X, title=0x%X, hr=0x%X",
            pMsg->qwUserID,
            pMsg->dwTitleID,
            hr);
    }
}

/*****************************************************************************

CClientConnection::ProcessMsgGetState

Process GetState messages.

*****************************************************************************/
void CClientConnection::ProcessMsgGetState( P_GET_STATE_MSG *pMsg, DWORD cbEntireMsg )
{
    CScopeTimer scope( XPPERF_SERVER_GET_STATE_CLIENT_TIME_AVERAGE, XPPERF_SERVER_GET_STATE_CLIENT_TIME_BASE );

    XOMASSERT(pMsg != NULL);
    XOMASSERT(m_pSwitchboard != NULL);

    HRESULT hr = S_OK;
    QWORD qwNonce = 0;
    
    // UserID of 0 not allowed
    if( 0 == pMsg->qwUserID )
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_90,
            "GetState from client @ %s:%d Bad user id (0)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port));

        hr = E_INVALIDARG;
        goto lDone;
    }

    // 
    // TODO: Reply to GetState message
    // 
    //  - Fetch and return saved Rich Presence data for this user
    //  
    hr = m_pSwitchboard->GetState( 
        pMsg->dwSeqNum,
        pMsg->qwUserID,
        hr,
        this,
        &qwNonce);
    
    // LineType|MachinePUID|Nonce|SG IP|SG SPI|UserPUID|hr
    XomLog(
        PresenceLog,
        "GST|%I64X|%I64X|%X|%X|%I64X|%X",
        pMsg->sgaddr.qwXboxID,
        qwNonce,
        pMsg->sgaddr.inaSg,
        pMsg->sgaddr.dwSpiSg,
        pMsg->qwUserID,
        hr);

lDone:

    if (hr == XONLINE_E_PRESENCE_DEFER_REQUEST)
    {
        hr = DeferMessage(pMsg->qwUserID, pMsg, cbEntireMsg);
    }
    else if (hr == XONLINE_E_PRESENCE_USER_MIGRATED)
    {
        hr = m_pSwitchboard->GetClientListener()->ForwardMessage(this, pMsg->qwUserID, pMsg, cbEntireMsg);
    }

    // Keep track of things
    // Treat not found as success, these often happen since the SG has latency
    // sending updates to us
    if( SUCCEEDED(hr) )
    {
        g_Counters.TrackSuccessfulMessage( XPPERF_SERVER_GET_STATE_MSGS_COUNTER );
    }
    else
    {
        g_Counters.TrackFailureMessage( XPPERF_SERVER_GET_STATE_MSGS_COUNTER );
     
        HRESULT hrResp = m_pSwitchboard->SendGetStateReply( 
            pMsg->dwSeqNum,
            pMsg->qwUserID,
            hr,
            this, 
            NULL);
        if (FAILED(hrResp))
        {
            // Disconnect if we fail to send a response
            Disconnect(hr);
            hr = hrResp;
        }
        XomNtEvent( 
            XEVENT_PRESENCE_CODE_57, 
            "CClientConnection::ProcessMsgGetState failed user=%I64X hr=0x%X",
            pMsg->qwUserID,
            hr);
    }

}


/*****************************************************************************

CClientConnection::ProcessMsgDeadUser

Process DeadUser messages.

*****************************************************************************/
void CClientConnection::ProcessMsgDeadUser( P_DEAD_USER_MSG *pMsg, DWORD cbEntireMsg )
{
    CScopeTimer scope( XPPERF_SERVER_DEAD_USER_CLIENT_TIME_AVERAGE, XPPERF_SERVER_DEAD_USER_CLIENT_TIME_BASE );

    XOMASSERT(pMsg != NULL);
    XOMASSERT(m_pSwitchboard != NULL);

    HRESULT hr = S_OK;
    QWORD qwNonce = 0;

    // UserID of 0 not allowed
    if( 0 == pMsg->qwUserID )
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_91,
            "DeadUser from client @ %s:%d Bad user id (0)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port));

        hr = E_INVALIDARG;
        goto lDone;
    }

    // Everything looks cool, send it on to the switchboard
    hr = m_pSwitchboard->DeadUser(
        pMsg->sgaddr, 
        pMsg->qwUserID,
        &qwNonce);

    // LineType|MachinePUID|Nonce|SG IP|SG SPI|UserPUID|hr
    XomLog(
        PresenceLog,
        "DUS|%I64X|%I64X|%X|%X|%I64X|%X",
        pMsg->sgaddr.qwXboxID,
        qwNonce,
        pMsg->sgaddr.inaSg,
        pMsg->sgaddr.dwSpiSg,
        pMsg->qwUserID,
        hr);

lDone:

    if (hr == XONLINE_E_PRESENCE_DEFER_REQUEST)
    {
        hr = DeferMessage(pMsg->qwUserID, pMsg, cbEntireMsg);
    }
    else if (hr == XONLINE_E_PRESENCE_USER_MIGRATED)
    {
        hr = m_pSwitchboard->GetClientListener()->ForwardMessage(this, pMsg->qwUserID, pMsg, cbEntireMsg);
    }

    // Keep track of things
    if( SUCCEEDED(hr) )
    {
        g_Counters.TrackSuccessfulMessage( XPPERF_SERVER_DEAD_USER_MSGS_COUNTER );
    }
    else
    {
        g_Counters.TrackFailureMessage( XPPERF_SERVER_DEAD_USER_MSGS_COUNTER );

        XomNtEvent( 
            XEVENT_PRESENCE_CODE_58,
            "CClientConnection::ProcessMsgDeadUser failed hr=0x%X", 
            hr);
    }
}

/*****************************************************************************

CClientConnection::ProcessMsgDeadXBox

Process DeadXBox messages.

*****************************************************************************/
void CClientConnection::ProcessMsgDeadXBox( P_DEAD_XBOX_MSG *pMsg, DWORD cbEntireMsg )
{
    CScopeTimer scope( XPPERF_SERVER_DEAD_XBOX_CLIENT_TIME_AVERAGE, XPPERF_SERVER_DEAD_XBOX_CLIENT_TIME_BASE );

    XOMASSERT(pMsg != NULL);
    XOMASSERT(m_pSwitchboard != NULL);

    HRESULT hr = S_OK;

    // Everything looks cool, send it on to the switchboard
    hr = m_pSwitchboard->DeadXBox(pMsg->sgaddr);

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "DeadXBox from %s:%d sg %X spi %X xb %I64X hr=%X",
        inet_ntoa(m_sa.sin_addr), 
        ntohs(m_sa.sin_port), 
        pMsg->sgaddr.inaSg,
        pMsg->sgaddr.dwSpiSg,
        pMsg->sgaddr.qwXboxID,
        hr);

    //
    // We no longer want to persistently log Dead Xbox messages, since they have little value now that
    // there is a KILLED log line.
    //

    // Keep track of things
    if( SUCCEEDED(hr) )
    {
        g_Counters.TrackSuccessfulMessage( XPPERF_SERVER_DEAD_XBOX_MSGS_COUNTER );
    }
    else
    {
        g_Counters.TrackFailureMessage( XPPERF_SERVER_DEAD_XBOX_MSGS_COUNTER );

        XomNtEvent( 
            XEVENT_PRESENCE_CODE_59,
            "CClientConnection::ProcessMsgDeadXBox failed hr=0x%X", 
            hr);
    }
}

/*****************************************************************************

CClientConnection::ProcessMsgDeadSG

Process DeadSG messages.

*****************************************************************************/
void CClientConnection::ProcessMsgDeadSG( P_DEAD_SG_MSG *pMsg, DWORD cbEntireMsg )
{
    CScopeTimer scope( XPPERF_SERVER_DEAD_SG_CLIENT_TIME_AVERAGE, XPPERF_SERVER_DEAD_SG_CLIENT_TIME_BASE );

    XOMASSERT(pMsg != NULL);
    XOMASSERT(m_pSwitchboard != NULL);

    HRESULT hr = S_OK;

    // Everything looks cool, send it on to the switchboard
    hr = m_pSwitchboard->DeadSG(pMsg->sgaddr);

    // LineType|ClientIP|ClientPort|MachinePUID|SG IP|SG SPI|UserPUID|hr
    XomLog(
        PresenceLog,
        "DSG|%X|%X|%I64X|%X|%X|%X",
        m_sa.sin_addr,
        m_sa.sin_port,
        pMsg->sgaddr.qwXboxID,
        pMsg->sgaddr.inaSg,
        pMsg->sgaddr.dwSpiSg,
        hr);

//lDone:
    // Keep track of things
    if( SUCCEEDED(hr) )
    {
        g_Counters.TrackSuccessfulMessage( XPPERF_SERVER_DEAD_SG_MSGS_COUNTER );
    }
    else
    {
        g_Counters.TrackFailureMessage( XPPERF_SERVER_DEAD_SG_MSGS_COUNTER );

        XomNtEvent( 
            XEVENT_PRESENCE_CODE_60,
            "CClientConnection::ProcessMsgDeadSG failed hr=0x%X", 
            hr);
    }
}

/*****************************************************************************

CClientConnection::ProcessMsgKick

Process Kick messages.

*****************************************************************************/
void CClientConnection::ProcessMsgKick(P_KICK_MSG *pMsg, DWORD cbEntireMsg)
{
    CScopeTimer scope( XPPERF_SERVER_KICK_CLIENT_TIME_AVERAGE, XPPERF_SERVER_KICK_CLIENT_TIME_BASE );

    XOMASSERT(pMsg != NULL);
    XOMASSERT(m_pSwitchboard != NULL);

    HRESULT hr = S_OK;

    // Are we on the right presence server?
    if (!g_CPresCfg.CheckDestination(pMsg->qwUserID))
    {
        // kick messages go to all servers.  just eat the errors for these.
        return;
    }

    // Everything looks cool, send it on to the switchboard
    hr = m_pSwitchboard->Kick(pMsg->qwUserID, pMsg->fFlushTickets);

    // LineType|ClientIP|ClientPort|MachinePUID|SG IP|SG SPI|UserPUID|hr
    XomLog(
        PresenceLog,
        "KCK|%X|%X|%I64X|%X|%X|%I64X|%X|%X",
        m_sa.sin_addr,
        m_sa.sin_port,
        pMsg->sgaddr.qwXboxID,
        pMsg->sgaddr.inaSg,
        pMsg->sgaddr.dwSpiSg,
        pMsg->qwUserID,
        pMsg->fFlushTickets,
        hr);

//lDone:

    if (hr == XONLINE_E_PRESENCE_DEFER_REQUEST)
    {
        hr = DeferMessage(pMsg->qwUserID, pMsg, cbEntireMsg);
    }
    else if (hr == XONLINE_E_PRESENCE_USER_MIGRATED)
    {
        hr = m_pSwitchboard->GetClientListener()->ForwardMessage(this, pMsg->qwUserID, pMsg, cbEntireMsg);
    }

    // Keep track of things
    if( SUCCEEDED(hr) )
    {
        g_Counters.TrackSuccessfulMessage( XPPERF_SERVER_KICK_MSGS_COUNTER );
    }
    else
    {
        g_Counters.TrackFailureMessage( XPPERF_SERVER_KICK_MSGS_COUNTER );

        XomNtEvent( 
            XEVENT_PRESENCE_CODE_61,
            "CClientConnection::ProcessMsgKick failed hr=0x%X", 
            hr);
    }
}

void CClientConnection::ProcessMsgPurgeUser(P_PURGE_USER_MSG *pMsg, DWORD cbEntireMsg)
{
    XOMASSERT(pMsg != NULL);
    XOMASSERT(m_pSwitchboard != NULL);

    HRESULT hr = S_OK;

    if (0 == pMsg->qwUserID)
    {
        hr = E_INVALIDARG;
        goto lDone;
    }

    // Everything looks cool, send it on to the switchboard
    hr = m_pSwitchboard->PurgeUser(pMsg->qwUserID, pMsg->dwSeqNum, this);

    // LineType|ClientIP|ClientPort|UserPUID|hr
    XomLog(
        PresenceLog,
        "PURGE|%X|%X|%I64X|%X",
        m_sa.sin_addr,
        m_sa.sin_port,
        pMsg->qwUserID,
        hr);

lDone:

    if (hr == XONLINE_E_PRESENCE_DEFER_REQUEST)
    {
        hr = DeferMessage(pMsg->qwUserID, pMsg, cbEntireMsg);
    }
    else if (hr == XONLINE_E_PRESENCE_USER_MIGRATED)
    {
        hr = m_pSwitchboard->GetClientListener()->ForwardMessage(this, pMsg->qwUserID, pMsg, cbEntireMsg);
    }

    // Keep track of things
    if( FAILED(hr) )
    {
        XomNtEvent( 
            XEVENT_PRESENCE_CODE_61,
            "CClientConnection::ProcessMsgPurgeUser failed for user %I64X hr=0x%X", 
            pMsg->qwUserID,
            hr);
    }
}

/*****************************************************************************

CClientConnection::ProcessMsgInvalidateUser

Process InvalidateUser messages.

*****************************************************************************/
void CClientConnection::ProcessMsgInvalidateUser( P_INVALIDATE_USER_MSG *pMsg, DWORD cbEntireMsg )
{
    XOMASSERT(pMsg != NULL);
    XOMASSERT(m_pSwitchboard != NULL);

    HRESULT hr = S_OK;

    // Everything looks cool, send it on to the switchboard
    hr = m_pSwitchboard->InvalidateUser(pMsg->qwUserID);

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "InvalidateUser from %s:%d sg %X spi %X user %I64X hr=%X",
        inet_ntoa(m_sa.sin_addr), 
        ntohs(m_sa.sin_port), 
        pMsg->sgaddr.inaSg,
        pMsg->sgaddr.dwSpiSg,
        pMsg->qwUserID,
        hr);
    
    // LineType|ClientIP|ClientPort|SG IP|SG SPI|UserPUID|hr
    XomLog(
        PresenceLog,
        "INVUSR|%X|%X|%X|%X|%I64X|%X",
        m_sa.sin_addr, 
        m_sa.sin_port, 
        pMsg->sgaddr.inaSg,
        pMsg->sgaddr.dwSpiSg,
        pMsg->qwUserID,
        hr);

    if (hr == XONLINE_E_PRESENCE_DEFER_REQUEST)
    {
        hr = DeferMessage(pMsg->qwUserID, pMsg, cbEntireMsg);
    }
    else if (hr == XONLINE_E_PRESENCE_USER_MIGRATED)
    {
        hr = m_pSwitchboard->GetClientListener()->ForwardMessage(this, pMsg->qwUserID, pMsg, cbEntireMsg);
    }

    // Keep track of things
    if( SUCCEEDED(hr) )
    {
        // g_Counters.TrackSuccessfulMessage( XPPERF_SERVER_DEAD_XBOX_MSGS_COUNTER );
    }
    else
    {
        // g_Counters.TrackFailureMessage( XPPERF_SERVER_DEAD_XBOX_MSGS_COUNTER );

        XomNtEvent( 
            XEVENT_PRESENCE_CODE_62,
            "CClientConnection::ProcessMsgInvalidateUser failed hr=0x%X", 
            hr);
    }
}

/*****************************************************************************

CClientConnection::ProcessMsgWebFriends

Process Web Friends messages.

*****************************************************************************/
void CClientConnection::ProcessMsgWebFriends(P_WEB_FRIENDS_MSG *pMsg, DWORD cbEntireMsg)
{
    CScopeTimer scope( XPPERF_SERVER_WEB_LIST_CLIENT_TIME_AVERAGE, XPPERF_SERVER_WEB_LIST_CLIENT_TIME_BASE );

    XOMASSERT(pMsg != NULL);
    XOMASSERT(m_pSwitchboard != NULL);

    HRESULT hr = S_OK;
    HRESULT hrResp = S_OK;

    // UserID of 0 not allowed
    if( 0 == pMsg->qwUserID )
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_92,
            "WebFriends from client @ %s:%d Bad user id (0)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port));

        hr = E_INVALIDARG;
        goto lDone;
    }

    // Everything looks cool, send it on to the switchboard
    hr = m_pSwitchboard->GetFriendsList( 
        pMsg->qwUserID,
        pMsg->qwUserID, // userid = targetid
        this,
        pMsg->dwSeqNum,
        PMSG_WEB_FRIENDS_REPLY);

    // LineType|UserPUID|hr
    XomLog(
        PresenceLog,
        "WEBFR|%I64X|%X",
        pMsg->qwUserID,
        hr);
    
lDone:

    if (hr == XONLINE_E_PRESENCE_DEFER_REQUEST)
    {
        hr = DeferMessage(pMsg->qwUserID, pMsg, cbEntireMsg);
    }
    else if (hr == XONLINE_E_PRESENCE_USER_MIGRATED)
    {
        hr = m_pSwitchboard->GetClientListener()->ForwardMessage(this, pMsg->qwUserID, pMsg, cbEntireMsg);
    }

    if( SUCCEEDED(hr) )
    {
       g_Counters.TrackSuccessfulMessage( XPPERF_SERVER_WEB_LIST_MSGS_COUNTER );
    }
    else
    {
        g_Counters.TrackFailureMessage( XPPERF_SERVER_WEB_LIST_MSGS_COUNTER );

        XomNtEvent( 
            XEVENT_PRESENCE_CODE_63,
            "CClientConnection::ProcessMsgWebFriends failed hr=0x%X", 
            hr);

        hrResp = m_pSwitchboard->SendGetFriendsListReply(
            pMsg->qwUserID,
            pMsg->dwSeqNum,
            PMSG_WEB_FRIENDS_REPLY,
            hr,
            0xFFFFFFFF,
            0,
            NULL,
            this );
        
        if (FAILED(hrResp))
        {
            // Disconnect if we fail to send a response
            Disconnect(hr);
            hr = hrResp;
        }
    }
}

void CClientConnection::ProcessMsgGetFriendsList(P_GET_FRIENDS_LIST_MSG *pMsg, DWORD cbEntireMsg)
{
    CScopeTimer scope( XPPERF_SERVER_WEB_LIST_CLIENT_TIME_AVERAGE, XPPERF_SERVER_WEB_LIST_CLIENT_TIME_BASE );

    XOMASSERT(pMsg != NULL);
    XOMASSERT(m_pSwitchboard != NULL);

    HRESULT hr = S_OK;
    HRESULT hrResp = S_OK;

    // UserID of 0 not allowed
    if( 0 == pMsg->qwSenderID )
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_92,
            "GetFriendsList from client @ %s:%d Bad user id (0)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port));

        hr = E_INVALIDARG;
        goto lDone;
    }
    if( 0 == pMsg->qwTargetID )
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_92,
            "GetFriendsList from client @ %s:%d Bad target id (0)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port));

        hr = E_INVALIDARG;
        goto lDone;
    }

    // Everything looks cool, send it on to the switchboard
    hr = m_pSwitchboard->GetFriendsList( 
        pMsg->qwSenderID,
        pMsg->qwTargetID,
        this,
        pMsg->dwSeqNum,
        PMSG_GET_FRIENDS_LIST_REPLY);

    // LineType|UserPUID|TargetPUID|hr
    XomLog(
        PresenceLog,
        "GFL|%I64X|%I64X|%X",
        pMsg->qwSenderID,
        pMsg->qwTargetID,
        hr);
    
lDone:

    if (hr == XONLINE_E_PRESENCE_DEFER_REQUEST)
    {
        hr = DeferMessage(pMsg->qwTargetID, pMsg, cbEntireMsg);
    }
    else if (hr == XONLINE_E_PRESENCE_USER_MIGRATED)
    {
        hr = m_pSwitchboard->GetClientListener()->ForwardMessage(this, pMsg->qwTargetID, pMsg, cbEntireMsg);
    }

    if( SUCCEEDED(hr) )
    {
       g_Counters.TrackSuccessfulMessage( XPPERF_SERVER_WEB_LIST_MSGS_COUNTER );
    }
    else
    {
        g_Counters.TrackFailureMessage( XPPERF_SERVER_WEB_LIST_MSGS_COUNTER );

        if (hr != XONLINE_E_MESSAGE_INSUFFICIENT_PRIVILEGES)
        {
            XomNtEvent( 
                XEVENT_PRESENCE_CODE_63,
                "CClientConnection::ProcessMsgGetFriendsList failed hr=0x%X", 
                hr);
        }
        
        hrResp = m_pSwitchboard->SendGetFriendsListReply(
            pMsg->qwTargetID,
            pMsg->dwSeqNum,
            PMSG_GET_FRIENDS_LIST_REPLY,
            hr,
            0xFFFFFFFF,
            0,
            NULL,
            this );
        
        if (FAILED(hrResp))
        {
            // Disconnect if we fail to send a response
            Disconnect(hr);
            hr = hrResp;
        }
    }
}

void CClientConnection::ProcessMsgWebAlive(P_WEB_ALIVE_MSG *pMsg, DWORD cbEntireMsg)
{
    CScopeTimer scope( XPPERF_SERVER_WEB_ALIVE_CLIENT_TIME_AVERAGE, XPPERF_SERVER_WEB_ALIVE_CLIENT_TIME_BASE );

    XOMASSERT(pMsg != NULL);
    XOMASSERT(m_pSwitchboard != NULL);

    HRESULT hr = S_OK;
    HRESULT hrResp = S_OK;

    // UserID of 0 not allowed
    if( 0 == pMsg->qwUserID )
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_217,
            "WebAlive from client @ %s:%d Bad user id (0)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port));

        hr = E_INVALIDARG;
        goto lDone;
    }

    // Everything looks cool, send it on to the switchboard
    hr = m_pSwitchboard->WebAlive( 
        pMsg->qwUserID,
        this,
        pMsg->dwSeqNum);

    // LineType|UserPUID|hr
    XomLog(
        PresenceLog,
        "WEBALIVE|%I64X|%X",
        pMsg->qwUserID,
        hr);
    
lDone:

    if (hr == XONLINE_E_PRESENCE_DEFER_REQUEST)
    {
        hr = DeferMessage(pMsg->qwUserID, pMsg, cbEntireMsg);
    }
    else if (hr == XONLINE_E_PRESENCE_USER_MIGRATED)
    {
        hr = m_pSwitchboard->GetClientListener()->ForwardMessage(this, pMsg->qwUserID, pMsg, cbEntireMsg);
    }

    if( SUCCEEDED(hr) )
    {
       g_Counters.TrackSuccessfulMessage( XPPERF_SERVER_WEB_ALIVE_MSGS_COUNTER );
    }
    else
    {
        g_Counters.TrackFailureMessage( XPPERF_SERVER_WEB_ALIVE_MSGS_COUNTER );

        XomNtEvent( 
            XEVENT_PRESENCE_CODE_491,
            "CClientConnection::ProcessMsgWebAlive failed hr=0x%X", 
            hr);

        hrResp = m_pSwitchboard->SendWebAliveReply(
            pMsg->qwUserID,
            pMsg->dwSeqNum,
            hr,
            this );
        
        if (FAILED(hrResp))
        {
            // Disconnect if we fail to send a response
            Disconnect(hr);
            hr = hrResp;
        }
    }
}



/*****************************************************************************

CClientConnection::ProcessMsgPeerSession

Process Peer Session messages.

*****************************************************************************/
void CClientConnection::ProcessMsgPeerSession(P_PEER_SESSION_MSG *pMsg, DWORD cbEntireMsg)
{
    CScopeTimer scope( XPPERF_SERVER_PEER_SESSION_CLIENT_TIME_AVERAGE, XPPERF_SERVER_PEER_SESSION_CLIENT_TIME_BASE );

    XOMASSERT(pMsg != NULL);
    XOMASSERT(m_pSwitchboard != NULL);

    HRESULT hr = S_OK;
    HRESULT hrResp = S_OK;
    XNADDR xnaddrZero = { 0 };
    XNKID xkidZero = { 0 };
    XNKEY xnkeyZero = { 0 };

    // UserID of 0 not allowed
    if( 0 == pMsg->qwUserID )
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_93,
            "PeerSession from client @ %s:%d Bad user id (0)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port));

        hr = E_INVALIDARG;
        goto lDone;
    }

    // Everything looks cool, send it on to the switchboard
    hr = m_pSwitchboard->PeerSession( 
        pMsg->qwUserID,
        pMsg->qwHostUserID,
        this,
        pMsg->dwSeqNum);

    // LineType|MachinePUID|SG IP|SG SPI|UserPUID|HostPUID|hr
    XomLog(
        PresenceLog,
        "PEERSESSION|%I64X|%X|%X|%I64X|%I64X|%X",
        pMsg->sgaddr.qwXboxID,
        pMsg->sgaddr.inaSg,
        pMsg->sgaddr.dwSpiSg,
        pMsg->qwUserID,
        pMsg->qwHostUserID,
        hr);
    
lDone:

    if (hr == XONLINE_E_PRESENCE_DEFER_REQUEST)
    {
        hr = DeferMessage(pMsg->qwHostUserID, pMsg, cbEntireMsg);
    }
    else if (hr == XONLINE_E_PRESENCE_USER_MIGRATED)
    {
        hr = m_pSwitchboard->GetClientListener()->ForwardMessage(this, pMsg->qwHostUserID, pMsg, cbEntireMsg);
    }

    if( SUCCEEDED(hr) )
    {
        g_Counters.TrackSuccessfulMessage( XPPERF_SERVER_PEER_SESSION_MSGS_COUNTER );
    }
    else
    {
        g_Counters.TrackFailureMessage( XPPERF_SERVER_PEER_SESSION_MSGS_COUNTER );

        // pull titleid out of the presence record.
        CPresence *pCPresence = NULL;
        g_CPresenceUserIndex.FindPresence(pMsg->qwHostUserID, &pCPresence);
        DWORD dwTitleID = (pCPresence == NULL) ? 0 : pCPresence->GetTitleID();
        SAFE_RELEASE(pCPresence);

        XomNtEvent( 
            XEVENT_PRESENCE_CODE_64,
            "CClientConnection::ProcessMsgPeerSession failed host=%I64X, title=0x%X, hr=0x%X", 
            pMsg->qwHostUserID,
            dwTitleID,
            hr);

        hrResp = m_pSwitchboard->SendPeerSessionReply( 
            pMsg->dwSeqNum, 
            pMsg->qwHostUserID,
            0,
            0,
            0,
            xnaddrZero,
            xkidZero,
            xnkeyZero,
            this);
        if (FAILED(hrResp))
        {
            // Disconnect if we fail to send a response
            Disconnect(hr);
            hr = hrResp;
        }
    }
}

/*****************************************************************************

CClientConnection::ProcessMsgPeerSubscribe

Process Peer Subscribe messages.

*****************************************************************************/
void CClientConnection::ProcessMsgPeerSubscribe(P_PEER_SUBSCRIBE_MSG *pMsg, DWORD cbEntireMsg)
{
    CScopeTimer scope( XPPERF_SERVER_PEER_SUBSCRIBE_CLIENT_TIME_AVERAGE, XPPERF_SERVER_PEER_SUBSCRIBE_CLIENT_TIME_BASE );

    XOMASSERT(pMsg != NULL);
    XOMASSERT(m_pSwitchboard != NULL);

    HRESULT hr = S_OK;
    DWORD cbExpected = 0;
    QWORD *pqwSrcUserIDs = NULL;
    HRESULT hrResp = S_OK;

    // Check message size
    cbExpected = sizeof(P_PEER_SUBSCRIBE_MSG) +
        (pMsg->cSrcUserIDs * sizeof(QWORD));

    if( cbEntireMsg != cbExpected)
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_94,
            "Peer Subscribe from client @ %s:%d (size %d != %d)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port),
            cbEntireMsg,
            cbExpected);

        hr = E_INVALIDARG;
        Disconnect(hr);
        goto lDone;
    }

    // UserID of 0 not allowed
    if( 0 == pMsg->qwUserID )
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_95,
            "Peer Subscribe from client @ %s:%d Bad user id (0)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port));

        hr = E_INVALIDARG;
        goto lDone;
    }

    // Max teams
    if( pMsg->cSrcUserIDs > MAX_PEER_SUBSCRIPTIONS )
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_96,
            "Peer Subscribe from client @ %s:%d Bad source user id count %d > %d",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port),
            pMsg->cSrcUserIDs,
            MAX_PEER_SUBSCRIPTIONS);

        hr = E_INVALIDARG;
        goto lDone;
    }

    if (pMsg->cSrcUserIDs > 0)
    {
        pqwSrcUserIDs = (QWORD *)(pMsg + 1);
    }

    for (DWORD dwSubscribee = 0; dwSubscribee < pMsg->cSrcUserIDs; dwSubscribee++)
    {
        if (pqwSrcUserIDs[dwSubscribee] == 0)
        {
            XomNtEvent(
                XEVENT_PRESENCE_HACK_216,
                "Peer Subscribe from client @ %s:%d Bad source user id (0)",
                inet_ntoa(m_sa.sin_addr),
                ntohs(m_sa.sin_port));
            
            hr = E_INVALIDARG;
            goto lDone;
        }
    }

    // Everything looks cool, send it on to the switchboard
    hr = m_pSwitchboard->PeerSubscribe( 
        pMsg->sgaddr,
        pMsg->qwUserID,
        pMsg->cSrcUserIDs,
	 pqwSrcUserIDs,
        this,
        pMsg->dwSeqNum);

    // LineType|MachinePUID|SG IP|SG SPI|UserPUID|NumPeers|hr
    XomLog(
        PresenceLog,
        "PEERSUB|%I64X|%X|%X|%I64X|%X|%X",
        pMsg->sgaddr.qwXboxID,
        pMsg->sgaddr.inaSg,
        pMsg->sgaddr.dwSpiSg,
        pMsg->qwUserID,
        pMsg->cSrcUserIDs,
        hr);
    
lDone:

    if (hr == XONLINE_E_PRESENCE_DEFER_REQUEST)
    {
        hr = DeferMessage(pMsg->qwUserID, pMsg, cbEntireMsg);
    }
    else if (hr == XONLINE_E_PRESENCE_USER_MIGRATED)
    {
        hr = m_pSwitchboard->GetClientListener()->ForwardMessage(this, pMsg->qwUserID, pMsg, cbEntireMsg);
    }

    if( SUCCEEDED(hr) )
    {
        g_Counters.TrackSuccessfulMessage( XPPERF_SERVER_PEER_SUBSCRIBE_MSGS_COUNTER );
    }
    else
    {
        g_Counters.TrackFailureMessage( XPPERF_SERVER_PEER_SUBSCRIBE_MSGS_COUNTER );

        // pull titleid out of the presence record.
        CPresence *pCPresence = NULL;
        g_CPresenceUserIndex.FindPresence(pMsg->qwUserID, &pCPresence);
        DWORD dwTitleID = (pCPresence == NULL) ? 0 : pCPresence->GetTitleID();
        SAFE_RELEASE(pCPresence);

        XomNtEvent( 
            XEVENT_PRESENCE_CODE_65,
            "CClientConnection::ProcessMsgPeerSubscribe failed user=%I64X, title=0x%X, hr=0x%X", 
            pMsg->qwUserID,
            dwTitleID,
            hr);

        hrResp = m_pSwitchboard->SendPeerSubscribeReply( 
            pMsg->dwSeqNum,
            hr,
            this);
        
        if (FAILED(hrResp))
        {
            // Disconnect if we fail to send a response
            Disconnect(hr);
            hr = hrResp;
        }
    }
}

void CClientConnection::ProcessMsgPeerSubscribeEx(P_PEER_SUBSCRIBE_EX_MSG *pMsg, DWORD cbEntireMsg)
{
    CScopeTimer scope( XPPERF_SERVER_PEER_SUBSCRIBE_CLIENT_TIME_AVERAGE, XPPERF_SERVER_PEER_SUBSCRIBE_CLIENT_TIME_BASE );

    XOMASSERT(pMsg != NULL);
    XOMASSERT(m_pSwitchboard != NULL);

    HRESULT hr = S_OK;
    DWORD cbExpected = 0;
    QWORD *pqwUserIDs = NULL;

    // Check message size
    cbExpected = sizeof(P_PEER_SUBSCRIBE_EX_MSG) +
        (pMsg->cUserIDs * sizeof(QWORD));

    if( cbEntireMsg != cbExpected)
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_94,
            "PeerSubscribeEx from client @ %s:%d (size %d != %d)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port),
            cbEntireMsg,
            cbExpected);

        hr = E_INVALIDARG;
        Disconnect(hr);
        goto lDone;
    }

    // UserID of 0 not allowed
    if( 0 == pMsg->qwUserID )
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_95,
            "PeerSubscribeEx from client @ %s:%d Bad user id (0)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port));

        hr = E_INVALIDARG;
        goto lDone;
    }

    // Max teams
    if( pMsg->cUserIDs > MAX_PEER_SUBSCRIPTIONS )
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_96,
            "PeerSubscribeEx from client @ %s:%d Bad source user id count %d > %d",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port),
            pMsg->cUserIDs,
            MAX_PEER_SUBSCRIPTIONS);

        hr = E_INVALIDARG;
        goto lDone;
    }

    if (pMsg->cUserIDs > 0)
    {
        pqwUserIDs = (QWORD *)(pMsg + 1);
    }

    for (DWORD dwSubscribee = 0; dwSubscribee < pMsg->cUserIDs; dwSubscribee++)
    {
        if (pqwUserIDs[dwSubscribee] == 0)
        {
            XomNtEvent(
                XEVENT_PRESENCE_HACK_216,
                "PeerSubscribeEx from client @ %s:%d Bad source user id (0)",
                inet_ntoa(m_sa.sin_addr),
                ntohs(m_sa.sin_port));
            
            hr = E_INVALIDARG;
            goto lDone;
        }
    }

    // Everything looks cool, send it on to the switchboard
    hr = m_pSwitchboard->PeerSubscribeEx( 
        pMsg->sgaddr,
        pMsg->qwUserID,
        pMsg->dwFlags,
        pMsg->cUserIDs,
	 pqwUserIDs,
        this,
        pMsg->dwSeqNum);

    // LineType|MachinePUID|SG IP|SG SPI|UserPUID|Flags|NumPeers|hr
    XomLog(
        PresenceLog,
        "PEERSUBEX|%I64X|%X|%X|%I64X|%X|%X|%X",
        pMsg->sgaddr.qwXboxID,
        pMsg->sgaddr.inaSg,
        pMsg->sgaddr.dwSpiSg,
        pMsg->qwUserID,
        pMsg->dwFlags,
        pMsg->cUserIDs,
        hr);
    
lDone:

    if (hr == XONLINE_E_PRESENCE_DEFER_REQUEST)
    {
        hr = DeferMessage(pMsg->qwUserID, pMsg, cbEntireMsg);
    }
    else if (hr == XONLINE_E_PRESENCE_USER_MIGRATED)
    {
        hr = m_pSwitchboard->GetClientListener()->ForwardMessage(this, pMsg->qwUserID, pMsg, cbEntireMsg);
    }

    if( SUCCEEDED(hr) )
    {
        g_Counters.TrackSuccessfulMessage( XPPERF_SERVER_PEER_SUBSCRIBE_MSGS_COUNTER );
    }
    else
    {
        g_Counters.TrackFailureMessage( XPPERF_SERVER_PEER_SUBSCRIBE_MSGS_COUNTER );

        // pull titleid out of the presence record.
        CPresence *pCPresence = NULL;
        g_CPresenceUserIndex.FindPresence(pMsg->qwUserID, &pCPresence);
        DWORD dwTitleID = (pCPresence == NULL) ? 0 : pCPresence->GetTitleID();
        SAFE_RELEASE(pCPresence);

        XomNtEvent( 
            XEVENT_PRESENCE_CODE_65,
            "CClientConnection::ProcessMsgPeerSubscribeEx failed user=%I64X, title=0x%X, hr=0x%X", 
            pMsg->qwUserID,
            dwTitleID,
            hr);

        HRESULT hrResp = m_pSwitchboard->SendPeerSubscribeExReply( 
            pMsg->dwSeqNum,
            hr,
            0,
            NULL,
            this);
        
        if (FAILED(hrResp))
        {
            // Disconnect if we fail to send a response
            Disconnect(hr);
            hr = hrResp;
        }
    }
}


/*****************************************************************************

CClientConnection::ProcessMsgPeerUnsubscribe

Process Team Unsubscribe messages.

*****************************************************************************/
void CClientConnection::ProcessMsgPeerUnsubscribe(P_PEER_UNSUBSCRIBE_MSG *pMsg, DWORD cbEntireMsg)
{
    CScopeTimer scope( XPPERF_SERVER_PEER_UNSUBSCRIBE_CLIENT_TIME_AVERAGE, XPPERF_SERVER_PEER_UNSUBSCRIBE_CLIENT_TIME_BASE );

    XOMASSERT(pMsg != NULL);
    XOMASSERT(m_pSwitchboard != NULL);

    HRESULT hr = S_OK;
    DWORD cbExpected = 0;
    HRESULT hrResp = S_OK;

    // Check message size
    cbExpected = sizeof(P_PEER_UNSUBSCRIBE_MSG);

    if( cbEntireMsg != cbExpected)
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_97,
            "Team Unsubscribe from client @ %s:%d (size %d != %d)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port),
            cbEntireMsg,
            cbExpected);

        hr = E_INVALIDARG;
        Disconnect(hr);
        goto lDone;
    }

    // UserID of 0 not allowed
    if( 0 == pMsg->qwUserID )
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_98,
            "Team Unsubscribe from client @ %s:%d Bad user id (0)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port));

        hr = E_INVALIDARG;
        goto lDone;
    }

    // Everything looks cool, send it on to the switchboard
    hr = m_pSwitchboard->PeerUnsubscribe( 
        pMsg->sgaddr,
        pMsg->qwUserID,
        this,
        pMsg->dwSeqNum);

    // LineType|MachinePUID|SG IP|SG SPI|UserPUID|hr
    XomLog(
        PresenceLog,
        "PEERUNSUB|%I64X|%X|%X|%I64X|%X",
        pMsg->sgaddr.qwXboxID,
        pMsg->sgaddr.inaSg,
        pMsg->sgaddr.dwSpiSg,
        pMsg->qwUserID,
        hr);

lDone:

    if (hr == XONLINE_E_PRESENCE_DEFER_REQUEST)
    {
        hr = DeferMessage(pMsg->qwUserID, pMsg, cbEntireMsg);
    }
    else if (hr == XONLINE_E_PRESENCE_USER_MIGRATED)
    {
        hr = m_pSwitchboard->GetClientListener()->ForwardMessage(this, pMsg->qwUserID, pMsg, cbEntireMsg);
    }

    if( SUCCEEDED(hr) )
    {
        g_Counters.TrackSuccessfulMessage( XPPERF_SERVER_PEER_UNSUBSCRIBE_MSGS_COUNTER );
    }
    else
    {
        g_Counters.TrackFailureMessage( XPPERF_SERVER_PEER_UNSUBSCRIBE_MSGS_COUNTER );

        // pull titleid out of the presence record.
        CPresence *pCPresence = NULL;
        g_CPresenceUserIndex.FindPresence(pMsg->qwUserID, &pCPresence);
        DWORD dwTitleID = (pCPresence == NULL) ? 0 : pCPresence->GetTitleID();
        SAFE_RELEASE(pCPresence);

        XomNtEvent( 
            XEVENT_PRESENCE_CODE_66,
            "CClientConnection::ProcessMsgPeerUnsubscribe failed user=%I64X, title=0x%X, hr=0x%X", 
            pMsg->qwUserID,
            dwTitleID,
            hr);

        hrResp = m_pSwitchboard->SendPeerUnsubscribeReply( 
            pMsg->dwSeqNum,
            hr,
            this);
        if (FAILED(hrResp))
        {
            // Disconnect if we fail to send a response
            Disconnect(hr);
            hr = hrResp;
        }
    }
}


/*****************************************************************************

CClientConnection::ProcessMsgTeamListTeams

Process Team List Teams messages.

*****************************************************************************/
void CClientConnection::ProcessMsgTeamListTeams(P_TEAM_LIST_TEAMS_MSG *pMsg, DWORD cbEntireMsg)
{
    CScopeTimer scope( XPPERF_SERVER_LIST_TEAMS_CLIENT_TIME_AVERAGE, XPPERF_SERVER_LIST_TEAMS_CLIENT_TIME_BASE );

    XOMASSERT(pMsg != NULL);
    XOMASSERT(m_pSwitchboard != NULL);

    HRESULT hr = S_OK;
    DWORD cbExpected = 0;
    QWORD *pqwTeamIDs = NULL;
    HRESULT hrResp = S_OK;

    // Check message size
    cbExpected = sizeof(P_TEAM_LIST_TEAMS_MSG) +
        (pMsg->cTeamIDs * sizeof(QWORD));

    if( cbEntireMsg != cbExpected)
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_99,
            "Team List from client @ %s:%d (size %d != %d)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port),
            cbEntireMsg,
            cbExpected);

        hr = E_INVALIDARG;
        Disconnect(hr);
        goto lDone;
    }

    // UserID of 0 not allowed
    if( 0 == pMsg->qwUserID )
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_100,
            "MsgTeamList from client @ %s:%d Bad user id (0)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port));

        hr = E_INVALIDARG;
        goto lDone;
    }

    // TitleID of 0 is not allowed
    if(0 == pMsg->dwTitleID)
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_101,
            "MsgTeamList from client @ %s:%d Bad title id (0)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port));

        hr = E_INVALIDARG;
        goto lDone;
    }

    // Max teams
    if( pMsg->cTeamIDs > MAX_TEAMS )
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_102,
            "MsgTeamList from client @ %s:%d Bad team count %d > %d",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port),
            pMsg->cTeamIDs,
            MAX_TEAMS);

        hr = E_INVALIDARG;
        goto lDone;
    }

    if (pMsg->cTeamIDs > 0)
    {
        pqwTeamIDs = (QWORD *)(pMsg + 1);
    }

    // Everything looks cool, send it on to the switchboard
    hr = m_pSwitchboard->TeamListTeams( 
        pMsg->sgaddr,
        pMsg->qwUserID,
        pMsg->dwTitleID,
        pMsg->cTeamIDs,
	    pqwTeamIDs,
        this,
        pMsg->dwSeqNum);

    // LineType|MachinePUID|SG IP|SG SPI|UserPUID|TitleID|NumTeams|hr
    XomLog(
        TeamsLog,
        "TLT|%I64X|%X|%X|%I64X|%X|%X|%X",
        pMsg->sgaddr.qwXboxID,
        pMsg->sgaddr.inaSg,
        pMsg->sgaddr.dwSpiSg,
        pMsg->qwUserID,
        pMsg->dwTitleID,
        pMsg->cTeamIDs,
        hr);
    
lDone:

    if (hr == XONLINE_E_PRESENCE_DEFER_REQUEST)
    {
        hr = DeferMessage(pMsg->qwUserID, pMsg, cbEntireMsg);
    }
    else if (hr == XONLINE_E_PRESENCE_USER_MIGRATED)
    {
        hr = m_pSwitchboard->GetClientListener()->ForwardMessage(this, pMsg->qwUserID, pMsg, cbEntireMsg);
    }

    if( FAILED(hr) )
    {
        g_Counters.TrackFailureMessage( XPPERF_SERVER_TEAM_LIST_TEAMS_MSGS_COUNTER );

        XomNtEvent( 
            XEVENT_PRESENCE_CODE_67,
            "CClientConnection::ProcessMsgTeamListTeams failed user=%I64X, title=0x%X, hr=0x%X", 
            pMsg->qwUserID,
            pMsg->dwTitleID,
            hr);

        hrResp = m_pSwitchboard->SendTeamListTeamsReply( 
            pMsg->dwSeqNum,
            hr,
            0,
            NULL,
            this);
        
        if (FAILED(hrResp))
        {
            // Disconnect if we fail to send a response
            Disconnect(hr);
            hr = hrResp;
        }
    }
}

/*****************************************************************************

CClientConnection::ProcessMsgTeamListUserTeams

Process Team List User Teams messages.

*****************************************************************************/
void CClientConnection::ProcessMsgTeamListUserTeams(P_TEAM_LIST_USER_TEAMS_MSG *pMsg, DWORD cbEntireMsg)
{
    CScopeTimer scope( XPPERF_SERVER_LIST_TEAMS_CLIENT_TIME_AVERAGE, XPPERF_SERVER_LIST_TEAMS_CLIENT_TIME_BASE );

    XOMASSERT(pMsg != NULL);
    XOMASSERT(m_pSwitchboard != NULL);

    HRESULT hr = S_OK;
    DWORD cbExpected = 0;
    HRESULT hrResp = S_OK;

    // Check message size
    cbExpected = sizeof(P_TEAM_LIST_USER_TEAMS_MSG);

    if( cbEntireMsg != cbExpected)
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_103,
            "TeamListUserTeams from client @ %s:%d (size %d != %d)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port),
            cbEntireMsg,
            cbExpected);

        hr = E_INVALIDARG;
        Disconnect(hr);
        goto lDone;
    }

    // UserID of 0 not allowed
    if( 0 == pMsg->qwUserID )
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_104,
            "TeamListUserTeams from client @ %s:%d Bad user id (0)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port));

        hr = E_INVALIDARG;
        goto lDone;
    }

    // TitleID of 0 is not allowed
    if(0 == pMsg->dwTitleID)
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_105,
            "TeamListUserTeams from client @ %s:%d Bad title id (0)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port));

        hr = E_INVALIDARG;
        goto lDone;
    }

    // Everything looks cool, send it on to the switchboard
    hr = m_pSwitchboard->TeamListUserTeams( 
        pMsg->sgaddr,
        pMsg->qwUserID,
        pMsg->dwTitleID,
        this,
        pMsg->dwSeqNum);

    // LineType|MachinePUID|SG IP|SG SPI|UserPUID|TitleID|hr
    XomLog(
        TeamsLog,
        "TLUT|%I64X|%X|%X|%I64X|%X|%X|%X",
        pMsg->sgaddr.qwXboxID,
        pMsg->sgaddr.inaSg,
        pMsg->sgaddr.dwSpiSg,
        pMsg->qwUserID,
        pMsg->dwTitleID,
        hr);

lDone:

    if (hr == XONLINE_E_PRESENCE_DEFER_REQUEST)
    {
        hr = DeferMessage(pMsg->qwUserID, pMsg, cbEntireMsg);
    }
    else if (hr == XONLINE_E_PRESENCE_USER_MIGRATED)
    {
        hr = m_pSwitchboard->GetClientListener()->ForwardMessage(this, pMsg->qwUserID, pMsg, cbEntireMsg);
    }

    if( FAILED(hr) )
    {
        g_Counters.TrackFailureMessage( XPPERF_SERVER_TEAM_LIST_TEAMS_MSGS_COUNTER );

        XomNtEvent(
            XEVENT_PRESENCE_CODE_68,
            "CClientConnection::ProcessMsgTeamListUserTeams failed user=%I64X, title=0x%X, hr=0x%X", 
            pMsg->qwUserID,
            pMsg->dwTitleID,
            hr);

        hrResp = m_pSwitchboard->SendTeamListUserTeamsReply( 
            pMsg->dwSeqNum,
            hr,
            0,
            NULL,
            this);
        
        if (FAILED(hrResp))
        {
            // Disconnect if we fail to send a response
            Disconnect(hr);
            hr = hrResp;
        }
    }
}

/*****************************************************************************

CClientConnection::ProcessMsgTeamListMembers

Process Team List Members messages.

*****************************************************************************/
void CClientConnection::ProcessMsgTeamListMembers(P_TEAM_LIST_MEMBERS_MSG *pMsg, DWORD cbEntireMsg)
{
    CScopeTimer scope( XPPERF_SERVER_LIST_TEAM_MEMBERS_CLIENT_TIME_AVERAGE, XPPERF_SERVER_LIST_TEAM_MEMBERS_CLIENT_TIME_BASE );

    XOMASSERT(pMsg != NULL);
    XOMASSERT(m_pSwitchboard != NULL);

    HRESULT hr = S_OK;
    DWORD cbExpected = 0;
    HRESULT hrResp = S_OK;

    // Check message size
    cbExpected = sizeof(P_TEAM_LIST_MEMBERS_MSG);

    if( cbEntireMsg != cbExpected)
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_106,
            "Team List Members from client @ %s:%d (size %d != %d)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port),
            cbEntireMsg,
            cbExpected);

        hr = E_INVALIDARG;
        Disconnect(hr);
        goto lDone;
    }

    // UserID of 0 not allowed
    if( 0 == pMsg->qwUserID )
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_107,
            "Team List Members from client @ %s:%d Bad user id (0)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port));

        hr = E_INVALIDARG;
        goto lDone;
    }

    // TitleID of 0 is not allowed
    if(0 == pMsg->dwTitleID)
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_108,
            "Team List Members from client @ %s:%d Bad title id (0)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port));

        hr = E_INVALIDARG;
        goto lDone;
    }

    // TeamID of 0 not allowed
    if( 0 == pMsg->qwTeamID )
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_109,
            "Team List Members from client @ %s:%d Bad team id (0)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port));

        hr = E_INVALIDARG;
        goto lDone;
    }

    // Everything looks cool, send it on to the switchboard
    hr = m_pSwitchboard->TeamListMembers( 
        pMsg->sgaddr,
        pMsg->qwUserID,
        pMsg->dwTitleID,
        pMsg->qwTeamID,
        pMsg->fShowRecruits,
        this,
        pMsg->dwSeqNum);

    // LineType|MachinePUID|SG IP|SG SPI|UserPUID|TitleID|TeamPUID|ShowRecruits|hr
    XomLog(
        TeamsLog,
        "TLM|%I64X|%X|%X|%I64X|%X|%I64X|%X|%X",
        pMsg->sgaddr.qwXboxID,
        pMsg->sgaddr.inaSg,
        pMsg->sgaddr.dwSpiSg,
        pMsg->qwUserID,
        pMsg->dwTitleID,
        pMsg->qwTeamID,
        pMsg->fShowRecruits,
        hr);
    
lDone:

    if (hr == XONLINE_E_PRESENCE_DEFER_REQUEST)
    {
        hr = DeferMessage(pMsg->qwUserID, pMsg, cbEntireMsg);
    }
    else if (hr == XONLINE_E_PRESENCE_USER_MIGRATED)
    {
        hr = m_pSwitchboard->GetClientListener()->ForwardMessage(this, pMsg->qwUserID, pMsg, cbEntireMsg);
    }

    if( FAILED(hr) )
    {
        g_Counters.TrackFailureMessage( XPPERF_SERVER_TEAM_LIST_MEMBERS_MSGS_COUNTER );

        XomNtEvent( 
            XEVENT_PRESENCE_CODE_69,
            "CClientConnection::ProcessMsgTeamListMembers failed user=%I64X, team=%I64X, title=0x%X, hr=0x%X", 
            pMsg->qwUserID,
            pMsg->qwTeamID,
            pMsg->dwTitleID,
            hr);

        hrResp = m_pSwitchboard->SendTeamListMembersReply( 
            pMsg->dwSeqNum,
            hr,
            pMsg->qwTeamID,
            0,
            NULL,
            this);
        if (FAILED(hrResp))
        {
            // Disconnect if we fail to send a response
            Disconnect(hr);
            hr = hrResp;
        }
    }
}

/*****************************************************************************

CClientConnection::ProcessMsgTeamCreate

Process Team Create messages.

*****************************************************************************/
void CClientConnection::ProcessMsgTeamCreate(P_TEAM_CREATE_MSG *pMsg, DWORD cbEntireMsg)
{
    CScopeTimer scope( XPPERF_SERVER_TEAM_CREATE_CLIENT_TIME_AVERAGE, XPPERF_SERVER_TEAM_CREATE_CLIENT_TIME_BASE );

    XOMASSERT(pMsg != NULL);
    XOMASSERT(m_pSwitchboard != NULL);

    HRESULT hr = S_OK;
    HRESULT hrResp = S_OK;
    DWORD cbExpected = 0;
    BYTE *pbRead = NULL;
    LPCWSTR wszTeamName = NULL;
    LPCWSTR wszTeamDescription = NULL;
    LPCWSTR wszTeamMotto = NULL;
    LPCWSTR wszTeamURL = NULL;
    BYTE *pbTeamData = NULL;
    BYTE *pbCreatorData = NULL;

    // Check message size
    cbExpected = sizeof(P_TEAM_CREATE_MSG) +
        pMsg->cbTeamName + 
        pMsg->cbTeamDescription + 
        pMsg->cbTeamMotto + 
        pMsg->cbTeamURL + 
        pMsg->cbTeamData + 
        pMsg->cbCreatorData;

    if( cbEntireMsg != cbExpected)
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_110,
            "Team Create from client @ %s:%d (size %d != %d)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port),
            cbEntireMsg,
            cbExpected);

        hr = E_INVALIDARG;
        Disconnect(hr);
        goto lDone;
    }

    // UserID of 0 not allowed
    if( 0 == pMsg->qwUserID )
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_111,
            "Team Create from client @ %s:%d Bad user id (0)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port));

        hr = E_INVALIDARG;
        goto lDone;
    }

    // TitleID of 0 is not allowed
    if(0 == pMsg->dwTitleID)
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_112,
            "Team Create from client @ %s:%d Bad title id (0)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port));

        hr = E_INVALIDARG;
        goto lDone;
    }

    // Check range of max members
    if( (pMsg->dwMaxMembers < 2) || (pMsg->dwMaxMembers > XONLINE_MAX_TEAM_MEMBER_COUNT) )
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_113,
            "Team Create from client @ %s:%d Bad max members (%d)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port),
            pMsg->dwMaxMembers);

        hr = E_INVALIDARG;
        goto lDone;
    }

    // Extract the TeamName
    if ((pMsg->cbTeamName > MAX_TEAM_NAME_BYTES) || 
        (pMsg->cbTeamName < 2) ||
        ((pMsg->cbTeamName % 2) != 0))
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_114,
            "Team Create from client @ %s:%d TeamName size is invalid %d",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port),
            pMsg->cbTeamName);

        hr = E_INVALIDARG;
        goto lDone;
    }
    
    pbRead = (BYTE *)(pMsg + 1);
    wszTeamName = (LPCWSTR) pbRead;
    pbRead += pMsg->cbTeamName;

    if (wszTeamName[0] == L'\0')
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_115,
            "Team Create from client @ %s:%d wszTeamName is empty",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port));

        hr = E_INVALIDARG;
        goto lDone;
    }

    if (wszTeamName[(pMsg->cbTeamName / 2) - 1] != L'\0')
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_116,
            "Team Create from client @ %s:%d wszTeamName not null terminated",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port));

        hr = E_INVALIDARG;
        goto lDone;
    }

    // Extract the TeamDescription
    if ((pMsg->cbTeamDescription > MAX_TEAM_DESCRIPTION_BYTES) || 
        (pMsg->cbTeamDescription < 2) ||
        ((pMsg->cbTeamDescription % 2) != 0))
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_117,
            "Team Create from client @ %s:%d TeamDescription size is invalid %d",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port),
            pMsg->cbTeamDescription);

        hr = E_INVALIDARG;
        goto lDone;
    }

    wszTeamDescription = (LPCWSTR) pbRead;
    pbRead += pMsg->cbTeamDescription;

    if ((pMsg->cbTeamDescription > 0) && (wszTeamDescription[(pMsg->cbTeamDescription / 2) - 1] != L'\0'))
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_118,
            "Team Create from client @ %s:%d TeamDescription not null terminated",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port));

        hr = E_INVALIDARG;
        goto lDone;
    }

    // Extract the TeamMotto
    if ((pMsg->cbTeamMotto > MAX_TEAM_MOTTO_BYTES) || 
        (pMsg->cbTeamMotto < 2) ||
        ((pMsg->cbTeamMotto % 2) != 0))
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_119,
            "Team Create from client @ %s:%d TeamMotto size is invalid %d",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port),
            pMsg->cbTeamMotto);

        hr = E_INVALIDARG;
        goto lDone;
    }

    wszTeamMotto = (LPCWSTR) pbRead;
    pbRead += pMsg->cbTeamMotto;

    if ((pMsg->cbTeamMotto > 0) && (wszTeamMotto[(pMsg->cbTeamMotto / 2) - 1] != L'\0'))
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_120,
            "Team Create from client @ %s:%d TeamMotto not null terminated",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port));

        hr = E_INVALIDARG;
        goto lDone;
    }

    // Extract the TeamURL
    if ((pMsg->cbTeamURL > MAX_TEAM_URL_BYTES) || 
        (pMsg->cbTeamURL < 2) ||
        ((pMsg->cbTeamURL % 2) != 0))
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_121,
            "Team Create from client @ %s:%d TeamURL size is invalid %d",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port),
            pMsg->cbTeamURL);

        hr = E_INVALIDARG;
        goto lDone;
    }

    wszTeamURL = (LPCWSTR) pbRead;
    pbRead += pMsg->cbTeamURL;

    if ((pMsg->cbTeamURL > 0) && (wszTeamURL[(pMsg->cbTeamURL / 2) - 1] != L'\0'))
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_122,
            "Team Create from client @ %s:%d TeamURL not null terminated",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port));

        hr = E_INVALIDARG;
        goto lDone;
    }

    // Extract the TeamData
    if (pMsg->cbTeamData > MAX_TEAM_DATA_BYTES)
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_123,
            "Team Create from client @ %s:%d TeamData size is invalid %d",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port),
            pMsg->cbTeamData);

        hr = E_INVALIDARG;
        goto lDone;
    }

    pbTeamData = pbRead;
    pbRead += pMsg->cbTeamData;

    // Extract the CreatorData
    if (pMsg->cbCreatorData > MAX_TEAM_MEMBER_DATA_BYTES)
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_124,
            "Team Create from client @ %s:%d CreatorData size is invalid %d",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port),
            pMsg->cbCreatorData);

        hr = E_INVALIDARG;
        goto lDone;
    }
    pbCreatorData = pbRead;

    // Everything looks cool, send it on to the switchboard
    hr = m_pSwitchboard->TeamCreate(
        pMsg->sgaddr,
        pMsg->qwUserID,
        pMsg->dwTitleID,
        pMsg->dwMaxMembers,
        pMsg->cbTeamName,
        wszTeamName,
        pMsg->cbTeamDescription,
        wszTeamDescription,
        pMsg->cbTeamMotto,
        wszTeamMotto,
        pMsg->cbTeamURL,
        wszTeamURL,
        pMsg->cbTeamData,
        pbTeamData,
        pMsg->cbCreatorData,
        pbCreatorData,
        pMsg->dwMsgType == PMSG_TEAM_CREATE_XE,
        this,
        pMsg->dwSeqNum);

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "TeamCreate from %s:%d user %I64X title %d team %S hr=%X",
        inet_ntoa(m_sa.sin_addr), 
        ntohs(m_sa.sin_port),
        pMsg->qwUserID,
        pMsg->dwTitleID,
        wszTeamName,
        hr);

lDone:

    if (hr == XONLINE_E_PRESENCE_DEFER_REQUEST)
    {
        hr = DeferMessage(pMsg->qwUserID, pMsg, cbEntireMsg);
    }
    else if (hr == XONLINE_E_PRESENCE_USER_MIGRATED)
    {
        hr = m_pSwitchboard->GetClientListener()->ForwardMessage(this, pMsg->qwUserID, pMsg, cbEntireMsg);
    }

    if( FAILED(hr) )
    {
        g_Counters.TrackFailureMessage( XPPERF_SERVER_TEAM_CREATE_MSGS_COUNTER );

        XomNtEvent( 
            XEVENT_PRESENCE_CODE_70,
            "CClientConnection::ProcessMsgTeamCreate failed user=%I64X, title=0x%X, hr=0x%X", 
            pMsg->qwUserID,
            pMsg->dwTitleID,
            hr);

        hrResp = m_pSwitchboard->SendTeamCreateReply( 
            pMsg->dwSeqNum, 
            hr,
            0,
            this);
        if (FAILED(hrResp))
        {
            // Disconnect if we fail to send a response
            Disconnect(hr);
            hr = hrResp;
        }
    }
}

/*****************************************************************************

CClientConnection::ProcessMsgTeamDelete

Process Team Delete messages.

*****************************************************************************/
void CClientConnection::ProcessMsgTeamDelete(P_TEAM_DELETE_MSG *pMsg, DWORD cbEntireMsg)
{
    CScopeTimer scope( XPPERF_SERVER_TEAM_DELETE_CLIENT_TIME_AVERAGE, XPPERF_SERVER_TEAM_DELETE_CLIENT_TIME_BASE );

    XOMASSERT(pMsg != NULL);
    XOMASSERT(m_pSwitchboard != NULL);

    HRESULT hr = S_OK;
    HRESULT hrResp = S_OK;
    DWORD cbExpected = 0;

    // Check message size
    cbExpected = sizeof(P_TEAM_DELETE_MSG);

    if( cbEntireMsg != cbExpected)
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_125,
            "Team Delete from client @ %s:%d (size %d != %d)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port),
            cbEntireMsg,
            cbExpected);

        hr = E_INVALIDARG;
        Disconnect(hr);
        goto lDone;
    }

    // UserID of 0 not allowed
    if( 0 == pMsg->qwUserID )
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_126,
            "Team Delete from client @ %s:%d Bad user id (0)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port));

        hr = E_INVALIDARG;
        goto lDone;
    }

    // TitleID of 0 is not allowed
    if(0 == pMsg->dwTitleID)
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_127,
            "Team Delete from client @ %s:%d Bad title id (0)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port));

        hr = E_INVALIDARG;
        goto lDone;
    }

    // TeamID of 0 not allowed
    if( 0 == pMsg->qwTeamID )
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_128,
            "Team Delete from client @ %s:%d Bad team id (0)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port));

        hr = E_INVALIDARG;
        goto lDone;
    }

    // Everything looks cool, send it on to the switchboard
    hr = m_pSwitchboard->TeamDelete(
        pMsg->sgaddr,
        pMsg->qwUserID,
        pMsg->dwTitleID,
        pMsg->qwTeamID,
        this,
        pMsg->dwSeqNum);

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "Team Delete from %s:%d user %I64X title %d team %I64X hr=%X",
        inet_ntoa(m_sa.sin_addr), 
        ntohs(m_sa.sin_port),

        pMsg->qwUserID,
        pMsg->dwTitleID,
        pMsg->qwTeamID,
        hr);

lDone:

    if (hr == XONLINE_E_PRESENCE_DEFER_REQUEST)
    {
        hr = DeferMessage(pMsg->qwUserID, pMsg, cbEntireMsg);
    }
    else if (hr == XONLINE_E_PRESENCE_USER_MIGRATED)
    {
        hr = m_pSwitchboard->GetClientListener()->ForwardMessage(this, pMsg->qwUserID, pMsg, cbEntireMsg);
    }

    if( FAILED(hr) )
    {        
        g_Counters.TrackFailureMessage( XPPERF_SERVER_TEAM_DELETE_MSGS_COUNTER );

        XomNtEvent( 
            XEVENT_PRESENCE_CODE_71,
            "CClientConnection::ProcessMsgTeamDelete failed user=%I64X, team=%I64X, title=0x%X, hr=0x%X", 
            pMsg->qwUserID,
            pMsg->qwTeamID,
            pMsg->dwTitleID,
            hr);

        hrResp = m_pSwitchboard->SendTeamDeleteReply( 
            pMsg->dwSeqNum, 
            hr,
            this);
        if (FAILED(hrResp))
        {
            // Disconnect if we fail to send a response
            Disconnect(hr);
            hr = hrResp;
        }
    }
}

/*****************************************************************************

CClientConnection::ProcessMsgTeamRemove

Process Team Remove messages.

*****************************************************************************/
void CClientConnection::ProcessMsgTeamRemove(P_TEAM_REMOVE_MSG *pMsg, DWORD cbEntireMsg)
{
    CScopeTimer scope( XPPERF_SERVER_TEAM_REMOVE_MEMBER_CLIENT_TIME_AVERAGE, XPPERF_SERVER_TEAM_REMOVE_MEMBER_CLIENT_TIME_BASE );

    XOMASSERT(pMsg != NULL);
    XOMASSERT(m_pSwitchboard != NULL);

    HRESULT hr = S_OK;
    HRESULT hrResp = S_OK;
    DWORD cbExpected = 0;

    // Check message size
    cbExpected = sizeof(P_TEAM_REMOVE_MSG);

    if( cbEntireMsg != cbExpected)
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_129,
            "Team Remove from client @ %s:%d (size %d != %d)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port),
            cbEntireMsg,
            cbExpected);

        hr = E_INVALIDARG;
        Disconnect(hr);
        goto lDone;
    }

    // UserID of 0 not allowed
    if( 0 == pMsg->qwUserID )
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_130,
            "Team Remove from client @ %s:%d Bad user id (0)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port));

        hr = E_INVALIDARG;
        goto lDone;
    }

    // TitleID of 0 is not allowed
    if(0 == pMsg->dwTitleID)
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_131,
            "Team Remove from client @ %s:%d Bad title id (0)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port));

        hr = E_INVALIDARG;
        goto lDone;
    }

    // TeamID of 0 not allowed
    if( 0 == pMsg->qwTeamID )
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_132,
            "Team Remove from client @ %s:%d Bad team id (0)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port));

        hr = E_INVALIDARG;
        goto lDone;
    }

    // MemberID of 0 not allowed
    if( 0 == pMsg->qwMemberID )
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_133,
            "Team Remove from client @ %s:%d Bad member id (0)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port));

        hr = E_INVALIDARG;
        goto lDone;
    }

    // Everything looks cool, send it on to the switchboard
    hr = m_pSwitchboard->TeamRemove(
        pMsg->sgaddr,
        pMsg->qwUserID,
        pMsg->dwTitleID,
        pMsg->qwTeamID,
        pMsg->qwMemberID,
        this,
        pMsg->dwSeqNum);

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "TeamRemove from %s:%d user %I64X title %d team %I64X member %I64X hr=%X",
        inet_ntoa(m_sa.sin_addr), 
        ntohs(m_sa.sin_port),

        pMsg->qwUserID,
        pMsg->dwTitleID,
        pMsg->qwTeamID,
        pMsg->qwMemberID,
        hr);

lDone:

    if (hr == XONLINE_E_PRESENCE_DEFER_REQUEST)
    {
        hr = DeferMessage(pMsg->qwUserID, pMsg, cbEntireMsg);
    }
    else if (hr == XONLINE_E_PRESENCE_USER_MIGRATED)
    {
        hr = m_pSwitchboard->GetClientListener()->ForwardMessage(this, pMsg->qwUserID, pMsg, cbEntireMsg);
    }

    if( FAILED(hr) )
    {
        g_Counters.TrackFailureMessage( XPPERF_SERVER_TEAM_REMOVE_MSGS_COUNTER );

        XomNtEvent( 
            XEVENT_PRESENCE_CODE_72,
            "CClientConnection::ProcessMsgTeamRemove failed user=%I64X, team=%I64X, member=%I64X, title=0x%X, hr=0x%X", 
            pMsg->qwUserID,
            pMsg->qwTeamID,
            pMsg->qwMemberID,
            pMsg->dwTitleID,
            hr);

        hrResp = m_pSwitchboard->SendTeamRemoveReply( 
            pMsg->dwSeqNum, 
            hr,
            this);
        if (FAILED(hrResp))
        {
            // Disconnect if we fail to send a response
            Disconnect(hr);
            hr = hrResp;
        }
    }

}

/*****************************************************************************

CClientConnection::ProcessMsgTeamManageTeam

Process Team Manage Team messages.

*****************************************************************************/
void CClientConnection::ProcessMsgTeamManageTeam(P_TEAM_MANAGE_TEAM_MSG *pMsg, DWORD cbEntireMsg)
{
    CScopeTimer scope( XPPERF_SERVER_TEAM_MANAGE_CLIENT_TIME_AVERAGE, XPPERF_SERVER_TEAM_MANAGE_CLIENT_TIME_BASE );

    XOMASSERT(pMsg != NULL);
    XOMASSERT(m_pSwitchboard != NULL);

    HRESULT hr = S_OK;
    HRESULT hrResp = S_OK;
    DWORD cbExpected = 0;
    BYTE *pbRead = NULL;
    LPCWSTR wszTeamName = NULL;
    LPCWSTR wszTeamDescription = NULL;
    LPCWSTR wszTeamMotto = NULL;
    LPCWSTR wszTeamURL = NULL;
    BYTE *pbTeamData = NULL;

    // Check message size
    cbExpected = sizeof(P_TEAM_MANAGE_TEAM_MSG) +
        pMsg->cbTeamName + 
        pMsg->cbTeamDescription + 
        pMsg->cbTeamMotto + 
        pMsg->cbTeamURL + 
        pMsg->cbTeamData;

    if( cbEntireMsg != cbExpected)
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_134,
            "Team Manage Team from client @ %s:%d (size %d != %d)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port),
            cbEntireMsg,
            cbExpected);

        hr = E_INVALIDARG;
        Disconnect(hr);
        goto lDone;
    }

    // UserID of 0 not allowed
    if( 0 == pMsg->qwUserID )
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_135,
            "Team Manage Team from client @ %s:%d Bad user id (0)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port));

        hr = E_INVALIDARG;
        goto lDone;
    }

    // TitleID of 0 is not allowed
    if(0 == pMsg->dwTitleID)
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_136,
            "Team Manage Team from client @ %s:%d Bad title id (0)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port));

        hr = E_INVALIDARG;
        goto lDone;
    }

    // TeamID of 0 not allowed
    if( 0 == pMsg->qwTeamID )
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_137,
            "Team Manage Team from client @ %s:%d Bad team id (0)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port));

        hr = E_INVALIDARG;
        goto lDone;
    }

    // Extract the TeamName
    if ((pMsg->cbTeamName > MAX_TEAM_NAME_BYTES) || 
        (pMsg->cbTeamName < 2) ||
        ((pMsg->cbTeamName % 2) != 0))
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_138,
            "Team Manage Team from client @ %s:%d TeamName size is invalid %d",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port),
            pMsg->cbTeamName);

        hr = E_INVALIDARG;
        goto lDone;
    }
    
    pbRead = (BYTE *)(pMsg + 1);
    wszTeamName = (LPCWSTR) pbRead;
    pbRead += pMsg->cbTeamName;

    if (wszTeamName[0] == L'\0')
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_139,
            "Team Manage Team from client @ %s:%d wszTeamName is empty",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port));

        hr = E_INVALIDARG;
        goto lDone;
    }

    if (wszTeamName[(pMsg->cbTeamName / 2) - 1] != L'\0')
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_140,
            "Team Manage Team from client @ %s:%d wszTeamName not null terminated",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port));

        hr = E_INVALIDARG;
        goto lDone;
    }

    // Extract the TeamDescription
    if ((pMsg->cbTeamDescription > MAX_TEAM_DESCRIPTION_BYTES) || 
        (pMsg->cbTeamDescription < 2) ||
        ((pMsg->cbTeamDescription % 2) != 0))
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_141,
            "Team Manage Team from client @ %s:%d TeamDescription size is invalid %d",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port),
            pMsg->cbTeamDescription);

        hr = E_INVALIDARG;
        goto lDone;
    }

    wszTeamDescription = (LPCWSTR) pbRead;
    pbRead += pMsg->cbTeamDescription;

    if ((pMsg->cbTeamDescription > 0) && (wszTeamDescription[(pMsg->cbTeamDescription / 2) - 1] != L'\0'))
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_142,
            "Team Manage Team from client @ %s:%d TeamDescription not null terminated",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port));

        hr = E_INVALIDARG;
        goto lDone;
    }

    // Extract the TeamMotto
    if ((pMsg->cbTeamMotto > MAX_TEAM_MOTTO_BYTES) || 
        (pMsg->cbTeamMotto < 2) ||
        ((pMsg->cbTeamMotto % 2) != 0))
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_143,
            "Team Manage Team from client @ %s:%d TeamMotto size is invalid %d",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port),
            pMsg->cbTeamMotto);

        hr = E_INVALIDARG;
        goto lDone;
    }

    wszTeamMotto = (LPCWSTR) pbRead;
    pbRead += pMsg->cbTeamMotto;

    if ((pMsg->cbTeamMotto > 0) && (wszTeamMotto[(pMsg->cbTeamMotto / 2) - 1] != L'\0'))
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_144,
            "Team Manage Team from client @ %s:%d TeamMotto not null terminated",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port));

        hr = E_INVALIDARG;
        goto lDone;
    }

    // Extract the TeamURL
    if ((pMsg->cbTeamURL > MAX_TEAM_URL_BYTES) || 
        (pMsg->cbTeamURL < 2) ||
        ((pMsg->cbTeamURL % 2) != 0))
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_145,
            "Team Manage Team from client @ %s:%d TeamURL size is invalid %d",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port),
            pMsg->cbTeamURL);

        hr = E_INVALIDARG;
        goto lDone;
    }

    wszTeamURL = (LPCWSTR) pbRead;
    pbRead += pMsg->cbTeamURL;

    if ((pMsg->cbTeamURL > 0) && (wszTeamURL[(pMsg->cbTeamURL / 2) - 1] != L'\0'))
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_146,
            "Team Manage Team from client @ %s:%d TeamURL not null terminated",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port));

        hr = E_INVALIDARG;
        goto lDone;
    }

    // Extract the TeamData
    if (pMsg->cbTeamData > MAX_TEAM_DATA_BYTES)
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_147,
            "Team Manage Team from client @ %s:%d TeamData size is invalid %d",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port),
            pMsg->cbTeamData);

        hr = E_INVALIDARG;
        goto lDone;
    }

    pbTeamData = pbRead;

    // Everything looks cool, send it on to the switchboard
    hr = m_pSwitchboard->TeamManageTeam(
        pMsg->sgaddr,
        pMsg->qwUserID,
        pMsg->dwTitleID,
        pMsg->qwTeamID,
        pMsg->cbTeamName,
        wszTeamName,
        pMsg->cbTeamDescription,
        wszTeamDescription,
        pMsg->cbTeamMotto,
        wszTeamMotto,
        pMsg->cbTeamURL,
        wszTeamURL,
        pMsg->cbTeamData,
        pbTeamData,
        pMsg->dwMsgType == PMSG_TEAM_MANAGE_TEAM_XE,
        this,
        pMsg->dwSeqNum);

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "TeamManageTeam from %s:%d user %I64X title %d team %I64X hr=%X",
        inet_ntoa(m_sa.sin_addr), 
        ntohs(m_sa.sin_port),
        pMsg->qwUserID,
        pMsg->dwTitleID,
        pMsg->qwTeamID,
        hr);

lDone:

    if (hr == XONLINE_E_PRESENCE_DEFER_REQUEST)
    {
        hr = DeferMessage(pMsg->qwUserID, pMsg, cbEntireMsg);
    }
    else if (hr == XONLINE_E_PRESENCE_USER_MIGRATED)
    {
        hr = m_pSwitchboard->GetClientListener()->ForwardMessage(this, pMsg->qwUserID, pMsg, cbEntireMsg);
    }

    if( FAILED(hr) )
    {
        g_Counters.TrackFailureMessage( XPPERF_SERVER_TEAM_MANAGE_TEAM_MSGS_COUNTER );

        XomNtEvent( 
            XEVENT_PRESENCE_CODE_73,
            "CClientConnection::ProcessMsgTeamManageTeam failed user=%I64X, team=%I64X, title=0x%X, hr=0x%X", 
            pMsg->qwUserID,
            pMsg->qwTeamID,
            pMsg->dwTitleID,
            hr);

        hrResp = m_pSwitchboard->SendTeamManageTeamReply( 
            pMsg->dwSeqNum, 
            hr,
            this);
        if (FAILED(hrResp))
        {
            // Disconnect if we fail to send a response
            Disconnect(hr);
            hr = hrResp;
        }
    }

}

/*****************************************************************************

CClientConnection::ProcessMsgTeamManageMember

Process Team Manage Member messages.

*****************************************************************************/
void CClientConnection::ProcessMsgTeamManageMember(P_TEAM_MANAGE_MEMBER_MSG *pMsg, DWORD cbEntireMsg)
{
    CScopeTimer scope( XPPERF_SERVER_TEAM_MANAGE_MEMBER_CLIENT_TIME_AVERAGE, XPPERF_SERVER_TEAM_MANAGE_MEMBER_CLIENT_TIME_BASE );

    XOMASSERT(pMsg != NULL);
    XOMASSERT(m_pSwitchboard != NULL);

    HRESULT hr = S_OK;
    HRESULT hrResp = S_OK;
    DWORD cbExpected = 0;
    BYTE *pbMemberData = NULL;

    // Check message size
    cbExpected = sizeof(P_TEAM_MANAGE_MEMBER_MSG) +
        pMsg->cbMemberData;

    if( cbEntireMsg != cbExpected)
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_148,
            "Team Manage Member from client @ %s:%d (size %d != %d)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port),
            cbEntireMsg,
            cbExpected);

        hr = E_INVALIDARG;
        Disconnect(hr);
        goto lDone;
    }

    // UserID of 0 not allowed
    if( 0 == pMsg->qwUserID )
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_149,
            "Team Manage Member from client @ %s:%d Bad user id (0)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port));

        hr = E_INVALIDARG;
        goto lDone;
    }

    // TitleID of 0 is not allowed
    if(0 == pMsg->dwTitleID)
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_150,
            "Team Manage Member from client @ %s:%d Bad title id (0)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port));

        hr = E_INVALIDARG;
        goto lDone;
    }

    // TeamID of 0 not allowed
    if( 0 == pMsg->qwTeamID )
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_151,
            "Team Manage Member from client @ %s:%d Bad team id (0)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port));

        hr = E_INVALIDARG;
        goto lDone;
    }

    // MemberID of 0 not allowed
    if( 0 == pMsg->qwMemberID )
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_152,
            "Team Manage Member from client @ %s:%d Bad user id (0)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port));

        hr = E_INVALIDARG;
        goto lDone;
    }

    if (pMsg->cbMemberData > MAX_TEAM_MEMBER_DATA_BYTES)
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_153,
            "Team Create from client @ %s:%d MemberData size is invalid %d",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port),
            pMsg->cbMemberData);

        hr = E_INVALIDARG;
        goto lDone;
    }

    pbMemberData = (BYTE *)(pMsg + 1);

    // Everything looks cool, send it on to the switchboard
    hr = m_pSwitchboard->TeamManageMember(
        pMsg->sgaddr,
        pMsg->qwUserID, 
        pMsg->dwTitleID,
        pMsg->qwTeamID,
        pMsg->qwMemberID,
        pMsg->dwMemberPriv,
        pMsg->cbMemberData,
        pbMemberData,
        this,
        pMsg->dwSeqNum);

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "TeamManageMember from %s:%d user %I64X title %d team %I64X member %I64X hr=%X",
        inet_ntoa(m_sa.sin_addr), 
        ntohs(m_sa.sin_port),
        pMsg->qwUserID, 
        pMsg->dwTitleID,
        pMsg->qwTeamID,
        pMsg->qwMemberID,
        hr);

lDone:

    if (hr == XONLINE_E_PRESENCE_DEFER_REQUEST)
    {
        hr = DeferMessage(pMsg->qwUserID, pMsg, cbEntireMsg);
    }
    else if (hr == XONLINE_E_PRESENCE_USER_MIGRATED)
    {
        hr = m_pSwitchboard->GetClientListener()->ForwardMessage(this, pMsg->qwUserID, pMsg, cbEntireMsg);
    }

    if( FAILED(hr) )
    {
        g_Counters.TrackFailureMessage( XPPERF_SERVER_TEAM_MANAGE_MEMBER_MSGS_COUNTER );

        XomNtEvent( 
            XEVENT_PRESENCE_CODE_74,
            "CClientConnection::ProcessMsgTeamManageMember failed user=%I64X, team=%I64X, member=%I64X, title=0x%X, hr=0x%X", 
            pMsg->qwUserID,
            pMsg->qwTeamID,
            pMsg->qwMemberID,
            pMsg->dwTitleID,
            hr);

        hrResp = m_pSwitchboard->SendTeamManageMemberReply( 
            pMsg->dwSeqNum, 
            hr,
            this);
        if (FAILED(hrResp))
        {
            // Disconnect if we fail to send a response
            Disconnect(hr);
            hr = hrResp;
        }
    }
}

/*****************************************************************************

CClientConnection::ProcessMsgTeamRecruit

Process Team Recruit messages.

*****************************************************************************/
void CClientConnection::ProcessMsgTeamRecruit(P_TEAM_RECRUIT_MSG *pMsg, DWORD cbEntireMsg)
{
    CScopeTimer scope( XPPERF_SERVER_TEAM_RECRUIT_CLIENT_TIME_AVERAGE, XPPERF_SERVER_TEAM_RECRUIT_CLIENT_TIME_BASE );

    XOMASSERT(pMsg != NULL);
    XOMASSERT(m_pSwitchboard != NULL);

    HRESULT hr = S_OK;
    HRESULT hrResp = S_OK;
    DWORD cbExpected = 0;
    const BYTE *pbMemberData = NULL;
    const BYTE* pbDetails = NULL;

    // Check message size
    cbExpected = sizeof(P_TEAM_RECRUIT_MSG) +
        pMsg->cbMemberData + pMsg->cbDetails;

    if( cbEntireMsg != cbExpected)
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_154,
            "Team Recruit from client @ %s:%d (size %d != %d)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port),
            cbEntireMsg,
            cbExpected);

        hr = E_INVALIDARG;
        Disconnect(hr);
        goto lDone;
    }

    // UserID of 0 not allowed
    if( 0 == pMsg->qwUserID )
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_155,
            "Team Recruit from client @ %s:%d Bad user id (0)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port));

        hr = E_INVALIDARG;
        goto lDone;
    }

    // TitleID of 0 is not allowed
    if(0 == pMsg->dwTitleID)
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_156,
            "Team Recruit from client @ %s:%d Bad title id (0)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port));

        hr = E_INVALIDARG;
        goto lDone;
    }

    // TeamID of 0 not allowed
    if( 0 == pMsg->qwTeamID )
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_157,
            "Team Recruit from client @ %s:%d Bad team id (0)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port));

        hr = E_INVALIDARG;
        goto lDone;
    }

    // qwMemberID of 0 and no name not allowed
    if( (0 == pMsg->qwMemberID) && (pMsg->szMemberName[0] == '\0') )
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_158,
            "Team Recruit from client @ %s:%d Bad member id (0) and no member name",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port));

        hr = E_INVALIDARG;
        goto lDone;
    }

    // Sender name must be null terminated
    if( 0 != pMsg->szMemberName[ XONLINE_GAMERTAG_SIZE - 1 ] )
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_159,
            "Team Recruit from client @ %s:%d sender name not null terminated",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port));

        hr = E_INVALIDARG;
        goto lDone;
    }

    if( XONLINE_MAX_MESSAGE_DETAILS < pMsg->cbDetails )
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_160,
            "Team Recruit from client @ %s:%d Details size is invalid %d",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port),
            pMsg->cbDetails);

        hr = E_INVALIDARG;
        goto lDone;
    }

    pbDetails = (const BYTE *)(pMsg + 1);

    if (pMsg->cbMemberData > MAX_TEAM_MEMBER_DATA_BYTES)
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_161,
            "Team Recruit from client @ %s:%d MemberData size is invalid %d",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port),
            pMsg->cbMemberData);

        hr = E_INVALIDARG;
        goto lDone;
    }

    pbMemberData = pbDetails + pMsg->cbDetails;

    // Everything looks cool, send it on to the switchboard
    hr = m_pSwitchboard->TeamRecruit(
        pMsg->sgaddr,
        pMsg->qwUserID,
        pMsg->dwTitleID,
        pMsg->qwTeamID,
        pMsg->qwMemberID,
        pMsg->szMemberName,
        pMsg->dwMemberPriv,
        pMsg->dwMessageFlags,
        pMsg->cbDetails,
        pbDetails,
        pMsg->cbMemberData,
        pbMemberData,
        this,
        pMsg->dwSeqNum);

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "TeamRecruit from %s:%d user %I64X title %d team %I64X member %I64X hr=%X",
        inet_ntoa(m_sa.sin_addr), 
        ntohs(m_sa.sin_port),
        pMsg->qwUserID, 
        pMsg->dwTitleID,
        pMsg->qwTeamID,
        pMsg->qwMemberID,
        hr);

lDone:

    if (hr == XONLINE_E_PRESENCE_DEFER_REQUEST)
    {
        hr = DeferMessage(pMsg->qwUserID, pMsg, cbEntireMsg);
    }
    else if (hr == XONLINE_E_PRESENCE_USER_MIGRATED)
    {
        hr = m_pSwitchboard->GetClientListener()->ForwardMessage(this, pMsg->qwUserID, pMsg, cbEntireMsg);
    }

    if( FAILED(hr) )
    {
        g_Counters.TrackFailureMessage( XPPERF_SERVER_TEAM_RECRUIT_MSGS_COUNTER );

        XomNtEvent( 
            XEVENT_PRESENCE_CODE_75,
            "CClientConnection::ProcessMsgTeamRecruit failed user=%I64X, team=%I64X, member=%I64X, title=0x%X, hr=0x%X", 
            pMsg->qwUserID,
            pMsg->qwTeamID,
            pMsg->qwMemberID,
            pMsg->dwTitleID,
            hr);

        hrResp = m_pSwitchboard->SendTeamRecruitReply( 
            pMsg->dwSeqNum, 
            hr,
            this);
        if (FAILED(hrResp))
        {
            // Disconnect if we fail to send a response
            Disconnect(hr);
            hr = hrResp;
        }
    }
}

/*****************************************************************************

CClientConnection::ProcessMsgTeamJoin

Process Team Join messages.

*****************************************************************************/
void CClientConnection::ProcessMsgTeamJoin(P_TEAM_JOIN_MSG *pMsg, DWORD cbEntireMsg)
{
    CScopeTimer scope( XPPERF_SERVER_TEAM_JOIN_CLIENT_TIME_AVERAGE, XPPERF_SERVER_TEAM_JOIN_CLIENT_TIME_BASE );

    XOMASSERT(pMsg != NULL);
    XOMASSERT(m_pSwitchboard != NULL);

    HRESULT hr = S_OK;
    HRESULT hrResp = S_OK;
    DWORD cbExpected = 0;

    // Check message size
    cbExpected = sizeof(P_TEAM_JOIN_MSG);

    if( cbEntireMsg != cbExpected)
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_162,
            "Team Join from client @ %s:%d (size %d != %d)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port),
            cbEntireMsg,
            cbExpected);

        hr = E_INVALIDARG;
        Disconnect(hr);
        goto lDone;
    }

    // UserID of 0 not allowed
    if( 0 == pMsg->qwUserID )
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_163,
            "Team Join from client @ %s:%d Bad user id (0)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port));

        hr = E_INVALIDARG;
        goto lDone;
    }

    // TitleID of 0 is not allowed
    if(0 == pMsg->dwTitleID)
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_164,
            "Team Join from client @ %s:%d Bad title id (0)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port));

        hr = E_INVALIDARG;
        goto lDone;
    }

    // TeamID of 0 not allowed
    if( 0 == pMsg->qwTeamID )
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_165,
            "Team Join from client @ %s:%d Bad team id (0)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port));

        hr = E_INVALIDARG;
        goto lDone;
    }

    // Everything looks cool, send it on to the switchboard
    hr = m_pSwitchboard->TeamJoin(
        pMsg->sgaddr,
        pMsg->qwUserID,
        pMsg->dwTitleID,
        pMsg->qwTeamID,
        pMsg->dwRecruitMsgID,
        pMsg->bAnswer,
        this,
        pMsg->dwSeqNum);

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "Team Join from %s:%d user %I64X title %d team %I64X recruitmsg %d answer %d hr=%X",
        inet_ntoa(m_sa.sin_addr), 
        ntohs(m_sa.sin_port),
        pMsg->qwUserID,
        pMsg->dwTitleID,
        pMsg->qwTeamID,
        pMsg->dwRecruitMsgID,
        (DWORD) pMsg->bAnswer,
        hr);

lDone:

    if (hr == XONLINE_E_PRESENCE_DEFER_REQUEST)
    {
        hr = DeferMessage(pMsg->qwUserID, pMsg, cbEntireMsg);
    }
    else if (hr == XONLINE_E_PRESENCE_USER_MIGRATED)
    {
        hr = m_pSwitchboard->GetClientListener()->ForwardMessage(this, pMsg->qwUserID, pMsg, cbEntireMsg);
    }

    if( FAILED(hr) )
    {
        g_Counters.TrackFailureMessage( XPPERF_SERVER_TEAM_JOIN_MSGS_COUNTER );

        XomNtEvent( 
            XEVENT_PRESENCE_CODE_76,
            "CClientConnection::ProcessMsgTeamJoin failed user=%I64X, team=%I64X, title=0x%X, hr=0x%X", 
            pMsg->qwUserID,
            pMsg->qwTeamID,
            pMsg->dwTitleID,
            hr);

        hrResp = m_pSwitchboard->SendTeamJoinReply( 
            pMsg->dwSeqNum, 
            hr,
            this);
        if (FAILED(hrResp))
        {
            // Disconnect if we fail to send a response
            Disconnect(hr);
            hr = hrResp;
        }
    }
}

/*****************************************************************************

CClientConnection::ProcessMsgTeamGetTicket

Process Team Get Ticket messages.

*****************************************************************************/
void CClientConnection::ProcessMsgTeamGetTicket(P_TEAM_GET_TICKET_MSG *pMsg, DWORD cbEntireMsg)
{
    CScopeTimer scope( XPPERF_SERVER_TEAM_GET_TICKET_CLIENT_TIME_AVERAGE, XPPERF_SERVER_TEAM_GET_TICKET_CLIENT_TIME_BASE );

    XOMASSERT(pMsg != NULL);
    XOMASSERT(m_pSwitchboard != NULL);

    HRESULT hr = S_OK;
    HRESULT hrResp = S_OK;
    DWORD cbExpected = 0;

    // Check message size
    cbExpected = sizeof(P_TEAM_GET_TICKET_MSG);

    if( cbEntireMsg != cbExpected)
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_166,
            "Team Get Ticket from client @ %s:%d (size %d != %d)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port),
            cbEntireMsg,
            cbExpected);

        hr = E_INVALIDARG;
        Disconnect(hr);
        goto lDone;
    }

    // UserID of 0 not allowed
    if( 0 == pMsg->qwUserID )
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_167,
            "Team Get Ticket from client @ %s:%d Bad user id (0)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port));

        hr = E_INVALIDARG;
        goto lDone;
    }

    // TitleID of 0 is not allowed
    if(0 == pMsg->dwTitleID)
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_168,
            "Team Get Ticket from client @ %s:%d Bad title id (0)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port));

        hr = E_INVALIDARG;
        goto lDone;
    }

    // Everything looks cool, send it on to the switchboard
    hr = m_pSwitchboard->TeamGetTicket(
        pMsg->sgaddr,
        pMsg->qwUserID,
        pMsg->dwTitleID,
        this,
        pMsg->dwSeqNum);

    // LineType|MachinePUID|SG IP|SG SPI|UserPUID|TitleID|hr
    XomLog(
        TeamsLog,
        "TGETTICKET|%I64X|%X|%X|%I64X|%X|%X",
        pMsg->sgaddr.qwXboxID,
        pMsg->sgaddr.inaSg,
        pMsg->sgaddr.dwSpiSg,
        pMsg->qwUserID,
        pMsg->dwTitleID,
        hr);

lDone:

    if (hr == XONLINE_E_PRESENCE_DEFER_REQUEST)
    {
        hr = DeferMessage(pMsg->qwUserID, pMsg, cbEntireMsg);
    }
    else if (hr == XONLINE_E_PRESENCE_USER_MIGRATED)
    {
        hr = m_pSwitchboard->GetClientListener()->ForwardMessage(this, pMsg->qwUserID, pMsg, cbEntireMsg);
    }

    if( FAILED(hr) )
    {
        g_Counters.TrackFailureMessage( XPPERF_SERVER_TEAM_GET_TICKET_MSGS_COUNTER );

        XomNtEvent( 
            XEVENT_PRESENCE_CODE_77,
            "CClientConnection::ProcessMsgTeamGetTicket failed user=%I64X, title=0x%X, hr=0x%X", 
            pMsg->qwUserID,
            pMsg->dwTitleID,
            hr);

        hrResp = m_pSwitchboard->SendTeamGetTicketReply( 
            pMsg->dwSeqNum, 
            hr,
            pMsg->qwUserID,
            0,
            NULL,
            this);
        if (FAILED(hrResp))
        {
            // Disconnect if we fail to send a response
            Disconnect(hr);
            hr = hrResp;
        }
    }
}

/*****************************************************************************

CClientConnection::ProcessMsgDequeue

Process Dequeue messages.

*****************************************************************************/
void CClientConnection::ProcessMsgDequeue(Q_DEQUEUE_MSG *pMsg, DWORD cbEntireMsg)
{
    CScopeTimer scope( XPPERF_SERVER_DEQUEUE_CLIENT_TIME_AVERAGE, XPPERF_SERVER_DEQUEUE_CLIENT_TIME_BASE );

    XOMASSERT(pMsg != NULL);
    XOMASSERT(m_pSwitchboard != NULL);

    HRESULT hr = S_OK;
    
    // UserID zero is invalid
    if(0 == pMsg->qwUserID)
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_169,
            "Dequeue from client @ %s:%d Bad user id (0), type=%d",
            inet_ntoa( m_sa.sin_addr ),
            ntohs( m_sa.sin_port ),
            pMsg->wQType );

        hr = E_INVALIDARG;
        goto lDone;
    }

    // Make sure the QType is valid
    if(pMsg->wQType >= PQUEUE_NUM_TYPES)
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_170,
            "Dequeue from client @ %s:%d Bad queue type (%d)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port),
            pMsg->wQType);

        hr = E_INVALIDARG;
        goto lDone;
    }
    
    // Everything looks cool, send it on to the switchboard
    hr = m_pSwitchboard->Dequeue(
        pMsg->dwSeqNum,
        &pMsg->sgaddr,
        pMsg->qwUserID,
        pMsg->wQType,
        pMsg->dwStartItemID,
        pMsg->wMaxItems,
        pMsg->dwMaxTotalItemDataSize,
        this );
    
    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "Dequeue from %s:%d sg %X spi %X xb %I64X user %I64X type %d start %d maxnum %d maxsize %d hr=%X",
        inet_ntoa(m_sa.sin_addr), 
        ntohs(m_sa.sin_port), 
        pMsg->sgaddr.inaSg,
        pMsg->sgaddr.dwSpiSg,
        pMsg->sgaddr.qwXboxID,
        pMsg->qwUserID,
        pMsg->wQType,
        pMsg->dwStartItemID,
        pMsg->wMaxItems,
        pMsg->dwMaxTotalItemDataSize,
        hr);

    if (hr == XONLINE_E_PRESENCE_DEFER_REQUEST)
    {
        hr = DeferMessage(pMsg->qwUserID, pMsg, cbEntireMsg);
    }
    else if (hr == XONLINE_E_PRESENCE_USER_MIGRATED)
    {
        hr = m_pSwitchboard->GetClientListener()->ForwardMessage(this, pMsg->qwUserID, pMsg, cbEntireMsg);
    }

    if (FAILED(hr) && (HRESULT_FROM_WIN32(ERROR_NO_SUCH_USER) != hr))
    {
        XomNtEvent(
            XEVENT_PRESENCE_CODE_78,
            "m_pSwitchboard->Dequeue ( user %I64X qtype %d StartItemID %d items %d size %d ) failed hr=0x%X",
            pMsg->qwUserID,
            pMsg->wQType,
            pMsg->dwStartItemID,
            pMsg->wMaxItems,
            pMsg->dwMaxTotalItemDataSize,
            hr);
    }

lDone:
    
    // Keep track of things
    if(SUCCEEDED(hr))
    {
        g_Counters.TrackSuccessfulMessage(
            XPPERF_SERVER_DEQUEUE_MSGS_COUNTER);
    }
    else if(HRESULT_FROM_WIN32(ERROR_NO_SUCH_USER) == hr)
    {
        g_Counters.IncrementValue32( 
            XPPERF_SERVER_NOUSER_DEQUEUE_MSGS_COUNTER,
            1 );
        
        g_Counters.IncrementValue32( 
            XPPERF_SERVER_NOUSER_DEQUEUE_MSGS_RATE,
            1 );
    }
    else
    {
        g_Counters.TrackFailureMessage( XPPERF_SERVER_DEQUEUE_MSGS_COUNTER );

        // pull titleid out of the presence record.
        CPresence *pCPresence = NULL;
        g_CPresenceUserIndex.FindPresence(pMsg->qwUserID, &pCPresence);
        DWORD dwTitleID = (pCPresence == NULL) ? 0 : pCPresence->GetTitleID();
        SAFE_RELEASE(pCPresence);

        XomNtEvent(
            XEVENT_PRESENCE_CODE_79, 
            "CClientConnection::ProcessMsgDequeue failed user=%I64X, title=0x%X, hr=0x%X", 
            pMsg->qwUserID,
            dwTitleID,
            hr);
    }
    
    // List messages are special in that we communicate failure return values
    // using an empty list reply message
    if (FAILED(hr))
    {
        hr = SendErrorListReply(
            pMsg->dwSeqNum,
            &(pMsg->sgaddr),
            pMsg->qwUserID,
            pMsg->wQType,
            hr);

        if (FAILED(hr))
        {
            XomNtEvent(
                XEVENT_PRESENCE_CODE_80,
                "SendErrorListReply for dequeue failed hr=0x%X", 
                hr);
        }
    }
}


/*****************************************************************************

CClientConnection::ProcessMsgEnumerateMessages

Process EnumerateMessages messages.

*****************************************************************************/
void CClientConnection::ProcessMsgEnumerateMessages(Q_ENUM_MESSAGES_MSG *pMsg, DWORD cbEntireMsg)
{
    CScopeTimer scope( XPPERF_SERVER_ENUM_MESSAGES_CLIENT_TIME_AVERAGE, XPPERF_SERVER_ENUM_MESSAGES_CLIENT_TIME_BASE );

    XOMASSERT(pMsg != NULL);
    XOMASSERT(m_pSwitchboard != NULL);

    HRESULT hr = S_OK;

    // UserID of 0 not allowed
    if(0 == pMsg->qwUserID)
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_171,
            "EnumMessages from client @ %s:%d Bad user id (0)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port));

        hr = E_INVALIDARG;
        goto lDone;
    }

    // Are we on the right notification server?
    if (!g_CPresCfg.CheckDestination(pMsg->qwUserID))
    {
        XomNtEvent(
            XEVENT_PRESENCE_CODE_81,
            "EnumMessages from client @ %s:%d for user %I64X sent to the wrong server",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port),
            pMsg->qwUserID);

        hr = E_INVALIDARG;
        goto lDone;
    }

    // Everything looks cool, send it on to the switchboard
    hr = m_pSwitchboard->EnumerateMessages(
        pMsg->qwUserID,
        this,
        pMsg->dwMsgType,
        pMsg->dwSeqNum);

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "EnumMessages from %s:%d user %I64X hr=%X",
        inet_ntoa(m_sa.sin_addr), 
        ntohs(m_sa.sin_port),
        pMsg->qwUserID,
        hr);

lDone:

    if (hr == XONLINE_E_PRESENCE_DEFER_REQUEST)
    {
        hr = DeferMessage(pMsg->qwUserID, pMsg, cbEntireMsg);
    }
    else if (hr == XONLINE_E_PRESENCE_USER_MIGRATED)
    {
        hr = m_pSwitchboard->GetClientListener()->ForwardMessage(this, pMsg->qwUserID, pMsg, cbEntireMsg);
    }

    // Keep track of things
    if( FAILED(hr) )
    {
        HRESULT hrResp;

        // If the operation succeeds we will log it upon completion where we have more information available
        // (missing information is represented by zeroes here to keep the log format consistent).
        XomLog( PresenceLog, "ENM|%X:%X|%I64X|0|0|%X",
            ntohl( m_sa.sin_addr.S_un.S_addr ), 
            ntohs( m_sa.sin_port ),
            pMsg->qwUserID,
            hr );

        g_Counters.TrackFailureMessage( XPPERF_SERVER_ENUM_MESSAGES_MSGS_COUNTER );

        hrResp = m_pSwitchboard->SendEmptyReply( 
            QMSG_ENUM_MESSAGES_REPLY, 
            sizeof( Q_ENUM_MESSAGES_REPLY_MSG ), 
            pMsg->dwSeqNum, 
            hr, 
            this);
        if (FAILED(hrResp))
        {
            // Disconnect if we fail to send a response
            Disconnect(hr);
            hr = hrResp;
        }
    }

    // Success counter incremented on DB callback
}

/*****************************************************************************

CClientConnection::ProcessMsgGetMessageSummary

Process GetMessageSummary messages.

*****************************************************************************/
void CClientConnection::ProcessMsgGetMessageSummary(Q_MESSAGE_SUMMARY_MSG *pMsg, DWORD cbEntireMsg)
{
    CScopeTimer scope( XPPERF_SERVER_MESSAGE_SUMMARY_CLIENT_TIME_AVERAGE, XPPERF_SERVER_MESSAGE_SUMMARY_CLIENT_TIME_BASE );

    XOMASSERT(pMsg != NULL);
    XOMASSERT(m_pSwitchboard != NULL);

    HRESULT hr = S_OK;

    // UserID of 0 not allowed
    if(0 == pMsg->qwUserID)
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_172,
            "MessageSummary from client @ %s:%d Bad user id (0)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port));

        hr = E_INVALIDARG;
        goto lDone;
    }

    // Message ID from failed send not allowed
    if( pMsg->dwMessageID & XONLINE_MSG_ID_SEND_FAILED )
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_173,
            "MessageSummary from client @ %s:%d Bad message ID (0x%08X)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port),
            pMsg->dwMessageID);

        hr = E_INVALIDARG;
        goto lDone;
    }

    // Are we on the right notification server?
    if (!g_CPresCfg.CheckDestination(pMsg->qwUserID))
    {
        XomNtEvent(
            XEVENT_PRESENCE_CODE_82,
            "MessageSummary from client @ %s:%d for user %I64X sent to the wrong server",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port),
            pMsg->qwUserID);

        hr = E_INVALIDARG;
        goto lDone;
    }

    // Everything looks cool, send it on to the switchboard
    hr = m_pSwitchboard->GetMessageSummary(
        pMsg->qwUserID,
        pMsg->dwMessageID,
        this,
        pMsg->dwMsgType,
        pMsg->dwSeqNum);

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "MessageSummary from %s:%d user %I64X message %X hr=%X",
        inet_ntoa(m_sa.sin_addr), 
        ntohs(m_sa.sin_port),
        pMsg->qwUserID,
        pMsg->dwMessageID,
        hr);

lDone:

    if (hr == XONLINE_E_PRESENCE_DEFER_REQUEST)
    {
        hr = DeferMessage(pMsg->qwUserID, pMsg, cbEntireMsg);
    }
    else if (hr == XONLINE_E_PRESENCE_USER_MIGRATED)
    {
        hr = m_pSwitchboard->GetClientListener()->ForwardMessage(this, pMsg->qwUserID, pMsg, cbEntireMsg);
    }

    // Keep track of things
    if( FAILED(hr) )
    {
        HRESULT hrResp;

        // If the operation succeeds we will log it upon completion where we have more information available
        // (missing information is represented by zeroes here to keep the log format consistent).
        XomLog( PresenceLog, "SUM|%X:%X|%I64X|%X|0|%X",
            ntohl( m_sa.sin_addr.S_un.S_addr ), 
            ntohs( m_sa.sin_port ),
            pMsg->qwUserID,
            pMsg->dwMessageID,
            hr );

        g_Counters.TrackFailureMessage( XPPERF_SERVER_MESSAGE_SUMMARY_MSGS_COUNTER );

        hrResp = m_pSwitchboard->SendEmptyReply( 
            QMSG_MESSAGE_SUMMARY_REPLY, 
            sizeof( Q_MESSAGE_SUMMARY_REPLY_MSG ), 
            pMsg->dwSeqNum, 
            hr, 
            this);
        if (FAILED(hrResp))
        {
            // Disconnect if we fail to send a response
            Disconnect(hr);
            hr = hrResp;
        }
    }

    // Success counter incremented on DB callback
}

/*****************************************************************************

CClientConnection::ProcessMsgGetMessageDetails

Process GetMessageDetails messages.

*****************************************************************************/
void CClientConnection::ProcessMsgGetMessageDetails(Q_MESSAGE_DETAILS_MSG *pMsg, DWORD cbEntireMsg)
{
    CScopeTimer scope( XPPERF_SERVER_MESSAGE_DETAILS_CLIENT_TIME_AVERAGE, XPPERF_SERVER_MESSAGE_DETAILS_CLIENT_TIME_BASE );

    XOMASSERT(pMsg != NULL);
    XOMASSERT(m_pSwitchboard != NULL);

    HRESULT hr = S_OK;

    // UserID of 0 not allowed
    if(0 == pMsg->qwUserID)
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_174,
            "MessageDetails from client @ %s:%d Bad user id (0)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port));

        hr = E_INVALIDARG;
        goto lDone;
    }

    // They can't be setting and unsetting the same bits
    if( 0 != ( pMsg->dwSetFlags & pMsg->dwUnsetFlags ) )
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_175,
            "MessageDetails from client @ %s:%d user %I64X msg %X Attempting to set/unset the same flags (0x%08X, 0x%08X)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port),
            pMsg->qwUserID,
            pMsg->dwMessageID,
            pMsg->dwSetFlags,
            pMsg->dwUnsetFlags);

        hr = E_INVALIDARG;
        goto lDone;
    }

    // They can only set certain flags
    if( 0 != ( pMsg->dwSetFlags & ~(XONLINE_MSG_FLAGS_TITLE_SETABLE) ) )
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_176,
            "MessageDetails from client @ %s:%d user %I64X msg %X Attempting to set invalid flags (0x%08X not in 0x%08X)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port),
            pMsg->qwUserID,
            pMsg->dwMessageID,
            pMsg->dwSetFlags,
            XONLINE_MSG_FLAGS_TITLE_SETABLE);

        hr = E_INVALIDARG;
        goto lDone;
    }

    // They can only unset certain flags
    if( 0 != ( pMsg->dwUnsetFlags & ~(XONLINE_MSG_FLAGS_TITLE_CLEARABLE) ) )
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_177,
            "MessageDetails from client @ %s:%d user %I64X msg %X Attempting to unset invalid flags (0x%08X not in 0x%08X)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port),
            pMsg->qwUserID,
            pMsg->dwMessageID,
            pMsg->dwUnsetFlags,
            XONLINE_MSG_FLAGS_TITLE_CLEARABLE);

        hr = E_INVALIDARG;
        goto lDone;
    }

    // Message ID from failed send not allowed
    if( pMsg->dwMessageID & XONLINE_MSG_ID_SEND_FAILED )
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_178,
            "MessageDetails from client @ %s:%d user %I64X msg %X Bad message ID",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port),
            pMsg->qwUserID,
            pMsg->dwMessageID);

        hr = E_INVALIDARG;
        goto lDone;
    }

    // Are we on the right notification server?
    if (!g_CPresCfg.CheckDestination(pMsg->qwUserID))
    {
        XomNtEvent(
            XEVENT_PRESENCE_CODE_83,
            "MessageDetails from client @ %s:%d user %I64X msg %X sent to the wrong server",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port),
            pMsg->qwUserID,
            pMsg->dwMessageID);

        hr = E_INVALIDARG;
        goto lDone;
    }

    // Everything looks cool, send it on to the switchboard
    hr = m_pSwitchboard->GetMessageDetails(
        pMsg->qwUserID,
        pMsg->dwMessageID,
        pMsg->dwSetFlags,
        pMsg->dwUnsetFlags,
        this,
        pMsg->dwSeqNum);

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "MessageDetails from %s:%d user %I64X msg %X hr=%X",
        inet_ntoa(m_sa.sin_addr), 
        ntohs(m_sa.sin_port),
        pMsg->qwUserID,
        pMsg->dwMessageID,
        hr);

lDone:

    if (hr == XONLINE_E_PRESENCE_DEFER_REQUEST)
    {
        hr = DeferMessage(pMsg->qwUserID, pMsg, cbEntireMsg);
    }
    else if (hr == XONLINE_E_PRESENCE_USER_MIGRATED)
    {
        hr = m_pSwitchboard->GetClientListener()->ForwardMessage(this, pMsg->qwUserID, pMsg, cbEntireMsg);
    }

    // Keep track of things
    if( FAILED(hr) )
    {
        HRESULT hrResp;

        // If the operation succeeds we will log it upon completion where we have more information available
        // (missing information is represented by zeroes here to keep the log format consistent).
        XomLog( PresenceLog, "DET|%X:%X|%I64X|%X|%X|%X|0|%X",
            ntohl( m_sa.sin_addr.S_un.S_addr ), 
            ntohs( m_sa.sin_port ),
            pMsg->qwUserID,
            pMsg->dwMessageID,
            pMsg->dwSetFlags,
            pMsg->dwUnsetFlags,
            hr );

        g_Counters.TrackFailureMessage( XPPERF_SERVER_MESSAGE_DETAILS_MSGS_COUNTER );

        hrResp = m_pSwitchboard->SendEmptyReply( 
            QMSG_MESSAGE_DETAILS_REPLY, 
            sizeof( Q_MESSAGE_DETAILS_REPLY_MSG ), 
            pMsg->dwSeqNum, 
            hr, 
            this);
        if (FAILED(hrResp))
        {
            // Disconnect if we fail to send a response
            Disconnect(hr);
            hr = hrResp;
        }
    }

    // Success counter incremented on DB callback
}

/*****************************************************************************

CClientConnection::ProcessMsgDeleteMessage

Process DeleteMessage messages.

*****************************************************************************/
void CClientConnection::ProcessMsgDeleteMessage(Q_DELETE_MESSAGE_MSG *pMsg, DWORD cbEntireMsg)
{
    CScopeTimer scope( XPPERF_SERVER_DELETE_MESSAGE_CLIENT_TIME_AVERAGE, XPPERF_SERVER_DELETE_MESSAGE_CLIENT_TIME_BASE );

    XOMASSERT(pMsg != NULL);
    XOMASSERT(m_pSwitchboard != NULL);

    HRESULT hr = S_OK;

    // UserID of 0 not allowed
    if(0 == pMsg->qwUserID)
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_179,
            "DeleteMessage from client @ %s:%d Bad user id (0)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port));

        hr = E_INVALIDARG;
        goto lDone;
    }

    if( 0 != ( pMsg->dwFlags & ~(XMSG_DELETE_MESSAGE_FLAG_BLOCK_SENDER) ) )
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_180,
            "DeleteMessage from client @ %s:%d user %I64X msg %X Invalid flags (0x%08X)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port),
            pMsg->qwUserID,
            pMsg->dwMessageID,
            pMsg->dwFlags);

        hr = E_INVALIDARG;
        goto lDone;
    }
 
    // Message ID from failed send not allowed
    if( pMsg->dwMessageID & XONLINE_MSG_ID_SEND_FAILED )
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_181,
            "DeleteMessage from client @ %s:%d user %I64X msg %X Bad message ID",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port),
            pMsg->qwUserID,
            pMsg->dwMessageID);

        hr = E_INVALIDARG;
        goto lDone;
    }

    // Are we on the right notification server?
    if (!g_CPresCfg.CheckDestination(pMsg->qwUserID))
    {
        XomNtEvent(
            XEVENT_PRESENCE_CODE_84,
            "DeleteMessage from client @ %s:%d for user %I64X msg %X sent to the wrong server",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port),
            pMsg->qwUserID,
            pMsg->dwMessageID);

        hr = E_INVALIDARG;
        goto lDone;
    }

    // Everything looks cool, send it on to the switchboard
    hr = m_pSwitchboard->DeleteMessage(
        FALSE, // Not from Presence
        pMsg->qwUserID,
        pMsg->dwMessageID,
        pMsg->dwFlags,
        this,
        pMsg->dwSeqNum);

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "DeleteMessage from %s:%d user %I64X msg %X flags %X hr=%X",
        inet_ntoa(m_sa.sin_addr), 
        ntohs(m_sa.sin_port),
        pMsg->qwUserID,
        pMsg->dwMessageID,
        pMsg->dwFlags,
        hr);

lDone:

    if (hr == XONLINE_E_PRESENCE_DEFER_REQUEST)
    {
        hr = DeferMessage(pMsg->qwUserID, pMsg, cbEntireMsg);
    }
    else if (hr == XONLINE_E_PRESENCE_USER_MIGRATED)
    {
        hr = m_pSwitchboard->GetClientListener()->ForwardMessage(this, pMsg->qwUserID, pMsg, cbEntireMsg);
    }

    // Keep track of things
    if( FAILED(hr) )
    {
        HRESULT hrResp;

        // If the operation succeeds we will log it upon completion where we have more information available
        // (missing information is represented by zeroes here to keep the log format consistent).
        XomLog( PresenceLog, "DEL|%X:%X|%I64X|%X|%X|%X",
            ntohl( m_sa.sin_addr.S_un.S_addr ), 
            ntohs( m_sa.sin_port ),
            pMsg->qwUserID,
            pMsg->dwMessageID,
            pMsg->dwFlags,
            hr );

        g_Counters.TrackFailureMessage( XPPERF_SERVER_Q_DELETE_MESSAGE_MSGS_COUNTER );

        hrResp = m_pSwitchboard->SendEmptyReply( 
            QMSG_DELETE_MESSAGE_REPLY, 
            sizeof( Q_DELETE_MESSAGE_REPLY_MSG ), 
            pMsg->dwSeqNum, 
            hr, 
            this);
        if (FAILED(hrResp))
        {
            // Disconnect if we fail to send a response
            Disconnect(hr);
            hr = hrResp;
        }
    }

    // Success counter incremented on DB callback
}

/*****************************************************************************

CClientConnection::ProcessMsgSendMessage

Process SendMessage messages.

*****************************************************************************/
void CClientConnection::ProcessMsgSendMessage(Q_SEND_MESSAGE_MSG *pMsg, DWORD cbEntireMsg)
{
    CScopeTimer scope( XPPERF_SERVER_SEND_MESSAGE_CLIENT_TIME_AVERAGE, XPPERF_SERVER_SEND_MESSAGE_CLIENT_TIME_BASE );

    XOMASSERT(pMsg != NULL);
    XOMASSERT(m_pSwitchboard != NULL);

    HRESULT hr = S_OK;
    XMSG_DETAILS* pDetails = NULL;

    if( !ValidateSendMessage( pMsg, cbEntireMsg, &m_sa ) )
    {
        // ValidateSendMessage will log an event noting the failure reason

        hr = E_INVALIDARG;
        goto lDone;
    }    

    // Grab the details
    pDetails = (XMSG_DETAILS*)( (BYTE*)(pMsg + 1) + pMsg->cRecipients * sizeof(ULONGLONG) );

    // Everything looks cool, send it on to the switchboard
    hr = m_pSwitchboard->SendMessageExternal(
        FALSE, // Not from Presence
        pMsg,
        (ULONGLONG*)( pMsg + 1 ),
        (BYTE*) pDetails,
        NULL,
        this,
        pMsg->dwSeqNum );

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "SendMessage from client %s:%d sender %I64X title 0x%08X type %d expire %d cbDetails %d cRecipients %d flags 0x%08X recip0 %I64X hr=0x%08X",
        inet_ntoa(m_sa.sin_addr), 
        ntohs(m_sa.sin_port),
        pMsg->qwSenderID,
        pMsg->dwSenderTitleID,
        pMsg->bMessageType,
        pMsg->wExpireMinutes,
        pMsg->cbDetails,
        pMsg->cRecipients,
        pMsg->dwMessageFlags,
        *(ULONGLONG*)( pMsg + 1 ),
        hr );

lDone:

    if (hr == XONLINE_E_PRESENCE_DEFER_REQUEST)
    {
        hr = DeferMessage(pMsg->qwSenderID, pMsg, cbEntireMsg);
    }
    else if (hr == XONLINE_E_PRESENCE_USER_MIGRATED)
    {
        hr = m_pSwitchboard->GetClientListener()->ForwardMessage(this, pMsg->qwSenderID, pMsg, cbEntireMsg);
    }

    // Keep track of things
    if( FAILED( hr ) )
    {
        HRESULT hrResp;

        // If the operation succeeds we will log it upon completion where we have more information available
        // (missing information is represented by zeroes here to keep the log format consistent).
        XomLog( PresenceLog, "SND|%X:%X|%I64X|%I64X|%X|%X|%X|%X|%X|0|%X",
            ntohl( m_sa.sin_addr.S_un.S_addr ), 
            ntohs( m_sa.sin_port ),
            pMsg->qwSenderID,
            pMsg->qwSenderContext,
            pMsg->dwSenderTitleID,
            pMsg->dwMessageFlags,
            pMsg->wExpireMinutes,
            pMsg->cbDetails,
            pMsg->bMessageType,
            hr );

        g_Counters.TrackFailureMessage( XPPERF_SERVER_SEND_MESSAGE_MSGS_COUNTER );

        hrResp = m_pSwitchboard->SendEmptyReply( 
            QMSG_SEND_MESSAGE_REPLY, 
            sizeof( Q_SEND_MESSAGE_REPLY_MSG ), 
            pMsg->dwSeqNum, 
            hr, 
            this );
        if( FAILED( hrResp ) )
        {
            // Disconnect if we fail to send a response
            Disconnect( hr );
            hr = hrResp;
        }
    }

    // Success counter incremented on DB callback
}


/*****************************************************************************

CClientConnection::ProcessMsgRevokeMessage

Process RevokeMessage messages.

*****************************************************************************/
void CClientConnection::ProcessMsgRevokeMessage(Q_REVOKE_MESSAGE_EX_MSG *pMsg, DWORD cbEntireMsg)
{
    CScopeTimer scope( XPPERF_SERVER_REVOKE_MESSAGE_CLIENT_TIME_AVERAGE, XPPERF_SERVER_REVOKE_MESSAGE_CLIENT_TIME_BASE );

    XOMASSERT(pMsg != NULL);
    XOMASSERT(m_pSwitchboard != NULL);

    HRESULT hr = S_OK;
    const BYTE* pbProp;
    const Q_RECIPIENT_RESULT* pRecipients;

    if( !ValidateRevokeMessage( pMsg, cbEntireMsg, &m_sa ) )
    {
        hr = E_INVALIDARG;
        goto lDone;
    }  

    pRecipients = (const Q_RECIPIENT_RESULT*)( pMsg + 1 );
    pbProp = (const BYTE*)( (BYTE*)( pMsg + 1 ) + pMsg->cRecipients * sizeof( *pRecipients ) );

    // Everything looks cool, send it on to the switchboard
    hr = m_pSwitchboard->RevokeMessageExternal(
        pMsg,
        pRecipients,
        pbProp );

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "RevokeMessage from client %s:%d sender %I64X context %I64X cRecipients %hd dwFlags %hd wPropTag %hd cbProp %hd recip0 %I64X hr=%X",
        inet_ntoa(m_sa.sin_addr), 
        ntohs(m_sa.sin_port),
        pMsg->qwSenderID,
        pMsg->qwSenderContext,
        pMsg->cRecipients,
        pMsg->dwFlags,
        pMsg->wPropTag,
        pMsg->cbProp,
        pRecipients->qwUserID,
        hr );

lDone:

    XomLog( PresenceLog, "RVK|%X:%X|%I64X|%I64X|%X|%X|%X|%X|%X|%X",
        ntohl( m_sa.sin_addr.S_un.S_addr ), 
        ntohs( m_sa.sin_port ),
        pMsg->qwSenderID,
        pMsg->qwSenderContext,
        pMsg->cRecipients,
        pMsg->dwFlags,
        pMsg->wPropTag,
        pMsg->cbProp,
        pMsg->bMessageType,
        hr );

    if (hr == XONLINE_E_PRESENCE_DEFER_REQUEST)
    {
        hr = DeferMessage(pMsg->qwSenderID, pMsg, cbEntireMsg);
    }
    else if (hr == XONLINE_E_PRESENCE_USER_MIGRATED)
    {
        hr = m_pSwitchboard->GetClientListener()->ForwardMessage(this, pMsg->qwSenderID, pMsg, cbEntireMsg);
    }

    // Keep track of things
    if( SUCCEEDED( hr ) )
    {
        g_Counters.TrackSuccessfulMessage( XPPERF_SERVER_REVOKE_MESSAGE_MSGS_COUNTER );
    }
    else
    {
        g_Counters.TrackFailureMessage( XPPERF_SERVER_REVOKE_MESSAGE_MSGS_COUNTER );

        XomNtEvent( 
            XEVENT_PRESENCE_CODE_85, 
            "CClientConnection::ProcessMsgRevokeMessage failed user=%I64X hr=0x%X",
            pMsg->qwSenderID,
            hr);
    }

    // Success or failure, send a reply
    hr = m_pSwitchboard->SendEmptyReply( 
        QMSG_REVOKE_MESSAGE_REPLY, 
        sizeof( Q_REVOKE_MESSAGE_REPLY_MSG ), 
        pMsg->dwSeqNum, 
        hr, 
        this );
    if( FAILED( hr ) )
    {
        // Disconnect if we fail to send a response
        Disconnect( hr );
    }

}

/*****************************************************************************

CClientConnection::ProcessMsgDeleteUserTitle

Process DeleteUserTitle messages.

*****************************************************************************/
void CClientConnection::ProcessMsgDeleteUserTitle(Q_DELETE_TITLE_MSG *pMsg, DWORD cbEntireMsg)
{
    CScopeTimer scope( XPPERF_SERVER_DELETE_TITLE_CLIENT_TIME_AVERAGE, XPPERF_SERVER_DELETE_TITLE_CLIENT_TIME_BASE );

    XOMASSERT(pMsg != NULL);
    XOMASSERT(m_pSwitchboard != NULL);

    HRESULT hr = S_OK;

    // UserID of 0 not allowed
    if(0 == pMsg->qwUserID)
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_182,
            "DeleteTitle from client @ %s:%d Bad user id (0)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port));

        hr = E_INVALIDARG;
        goto lDone;
    }

    // TitleID of 0 not allowed
    if(0 == pMsg->dwTitleID)
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_183,
            "DeleteTitle from client @ %s:%d user %I64X Bad title id (0)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port),
            pMsg->qwUserID );

        hr = E_INVALIDARG;
        goto lDone;
    }

    // Are we on the right notification server?
    if (!g_CPresCfg.CheckDestination(pMsg->qwUserID))
    {
        XomNtEvent(
            XEVENT_PRESENCE_CODE_86,
            "DeleteTitle from client @ %s:%d for user %I64X title %X sent to the wrong server",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port),
            pMsg->qwUserID,
            pMsg->dwTitleID);

        hr = E_INVALIDARG;
        goto lDone;
    }

    // Everything looks cool, send it on to the switchboard
    hr = m_pSwitchboard->DeleteUserTitle(
        pMsg->qwUserID,
        pMsg->dwTitleID,
        this,
        pMsg->dwSeqNum);

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "DeleteTitle from %s:%d user %I64X title %X hr=%X",
        inet_ntoa(m_sa.sin_addr), 
        ntohs(m_sa.sin_port),
        pMsg->qwUserID,
        pMsg->dwTitleID,
        hr);

lDone:

    if (hr == XONLINE_E_PRESENCE_DEFER_REQUEST)
    {
        hr = DeferMessage(pMsg->qwUserID, pMsg, cbEntireMsg);
    }
    else if (hr == XONLINE_E_PRESENCE_USER_MIGRATED)
    {
        hr = m_pSwitchboard->GetClientListener()->ForwardMessage(this, pMsg->qwUserID, pMsg, cbEntireMsg);
    }

    // Keep track of things
    if( FAILED(hr) )
    {
        HRESULT hrResp;

        // If the operation succeeds we will log it upon completion where we have more information available
        // (missing information is represented by zeroes here to keep the log format consistent).
        XomLog( PresenceLog, "DTL|%X:%X|%I64X|%X|%X",
            ntohl( m_sa.sin_addr.S_un.S_addr ), 
            ntohs( m_sa.sin_port ),
            pMsg->qwUserID,
            pMsg->dwTitleID,
            hr );

        g_Counters.TrackFailureMessage( XPPERF_SERVER_DELETE_TITLE_MSGS_COUNTER );

        XomNtEvent( 
            XEVENT_PRESENCE_CODE_87, 
            "CClientConnection::ProcessMsgDeleteTitle failed user=%I64X hr=0x%X",
            pMsg->qwUserID,
            hr);

        hrResp = m_pSwitchboard->SendEmptyReply( 
            QMSG_DELETE_TITLE_REPLY, 
            sizeof( Q_DELETE_TITLE_REPLY_MSG ), 
            pMsg->dwSeqNum, 
            hr, 
            this);
        if (FAILED(hrResp))
        {
            // Disconnect if we fail to send a response
            Disconnect(hr);
            hr = hrResp;
        }
    }

    // Success counter incremented on DB callback
}

/*****************************************************************************

CClientConnection::ProcessMsgEnumerateUserTitles

Process EnumerateUserTitles messages.

*****************************************************************************/
void CClientConnection::ProcessMsgEnumerateUserTitles(Q_ENUM_TITLES_MSG *pMsg, DWORD cbEntireMsg)
{
    CScopeTimer scope( XPPERF_SERVER_ENUM_TITLES_CLIENT_TIME_AVERAGE, XPPERF_SERVER_ENUM_TITLES_CLIENT_TIME_BASE );

    XOMASSERT(pMsg != NULL);
    XOMASSERT(m_pSwitchboard != NULL);

    HRESULT hr = S_OK;

    // UserID of 0 not allowed
    if(0 == pMsg->qwUserID)
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_184,
            "EnumTitles from client @ %s:%d Bad user id (0)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port));

        hr = E_INVALIDARG;
        goto lDone;
    }

    // Are we on the right notification server?
    if (!g_CPresCfg.CheckDestination(pMsg->qwUserID))
    {
        XomNtEvent(
            XEVENT_PRESENCE_CODE_88,
            "EnumTitles from client @ %s:%d for user %I64X sent to the wrong server",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port),
            pMsg->qwUserID);

        hr = E_INVALIDARG;
        goto lDone;
    }

    // Everything looks cool, send it on to the switchboard
    hr = m_pSwitchboard->EnumerateUserTitles(
        pMsg->qwUserID,
        this,
        pMsg->dwSeqNum);

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "EnumTitles from %s:%d user %I64X hr=%X",
        inet_ntoa(m_sa.sin_addr), 
        ntohs(m_sa.sin_port),
        pMsg->qwUserID,
        hr);

lDone:

    if (hr == XONLINE_E_PRESENCE_DEFER_REQUEST)
    {
        hr = DeferMessage(pMsg->qwUserID, pMsg, cbEntireMsg);
    }
    else if (hr == XONLINE_E_PRESENCE_USER_MIGRATED)
    {
        hr = m_pSwitchboard->GetClientListener()->ForwardMessage(this, pMsg->qwUserID, pMsg, cbEntireMsg);
    }

    // Keep track of things
    if( FAILED(hr) )
    {
        HRESULT hrResp;

        // If the operation succeeds we will log it upon completion where we have more information available
        // (missing information is represented by zeroes here to keep the log format consistent).
        XomLog( PresenceLog, "ETL|%X:%X|%I64X|0|%X",
            ntohl( m_sa.sin_addr.S_un.S_addr ), 
            ntohs( m_sa.sin_port ),
            pMsg->qwUserID,
            hr );

        g_Counters.TrackFailureMessage( XPPERF_SERVER_ENUM_TITLES_MSGS_COUNTER );

        XomNtEvent( 
            XEVENT_PRESENCE_CODE_89, 
            "CClientConnection::ProcessMsgEnumerateUserTitles failed user=%I64X hr=0x%X",
            pMsg->qwUserID,
            hr);

        hrResp = m_pSwitchboard->SendEmptyReply( 
            QMSG_ENUM_TITLES_REPLY, 
            sizeof( Q_ENUM_TITLES_REPLY_MSG ), 
            pMsg->dwSeqNum, 
            hr, 
            this);
        if (FAILED(hrResp))
        {
            // Disconnect if we fail to send a response
            Disconnect(hr);
            hr = hrResp;
        }
    }

    // Success counter incremented on DB callback
}

/*****************************************************************************

CClientConnection::ProcessMsgMessageFlags

Process MessageFlags messages.

*****************************************************************************/
void CClientConnection::ProcessMsgMessageFlags(Q_MESSAGE_FLAGS_MSG *pMsg, DWORD cbEntireMsg)
{
    CScopeTimer scope( XPPERF_SERVER_MESSAGE_FLAGS_CLIENT_TIME_AVERAGE, XPPERF_SERVER_MESSAGE_FLAGS_CLIENT_TIME_BASE );

    XOMASSERT(pMsg != NULL);
    XOMASSERT(m_pSwitchboard != NULL);

    HRESULT hr = S_OK;

    // UserID of 0 not allowed
    if(0 == pMsg->qwUserID)
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_185,
            "MessageFlags from client @ %s:%d Bad user id (0)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port));

        hr = E_INVALIDARG;
        goto lDone;
    }

    // They can't be setting and unsetting the same bits
    if( 0 != ( pMsg->dwSetFlags & pMsg->dwUnsetFlags ) )
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_186,
            "MessageFlags from client @ %s:%d user %I64X msg %X Attempting to set/unset the same flags (0x%08X, 0x%08X)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port),
            pMsg->qwUserID,
            pMsg->dwMessageID,
            pMsg->dwSetFlags,
            pMsg->dwUnsetFlags);

        hr = E_INVALIDARG;
        goto lDone;
    }

    // They can only set certain flags
    if( 0 != ( pMsg->dwSetFlags & ~(XONLINE_MSG_FLAGS_TITLE_SETABLE) ) )
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_187,
            "MessageFlags from client @ %s:%d user %I64X msg %X Attempting to set invalid flags (0x%08X not in 0x%08X)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port),
            pMsg->qwUserID,
            pMsg->dwMessageID,
            pMsg->dwSetFlags,
            XONLINE_MSG_FLAGS_TITLE_SETABLE);

        hr = E_INVALIDARG;
        goto lDone;
    }

    // They can only unset certain flags
    if( 0 != ( pMsg->dwUnsetFlags & ~(XONLINE_MSG_FLAGS_TITLE_CLEARABLE) ) )
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_188,
            "MessageFlags from client @ %s:%d user %I64X msg %X Attempting to unset invalid flags (0x%08X not in 0x%08X)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port),
            pMsg->qwUserID,
            pMsg->dwMessageID,
            pMsg->dwUnsetFlags,
            XONLINE_MSG_FLAGS_TITLE_CLEARABLE);

        hr = E_INVALIDARG;
        goto lDone;
    }

    // Message ID from failed send not allowed
    if( pMsg->dwMessageID & XONLINE_MSG_ID_SEND_FAILED )
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_189,
            "MessageFlags from client @ %s:%d user %I64X Bad message ID (0x%08X)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port),
            pMsg->qwUserID,
            pMsg->dwMessageID);

        hr = E_INVALIDARG;
        goto lDone;
    }

    // Are we on the right notification server?
    if (!g_CPresCfg.CheckDestination(pMsg->qwUserID))
    {
        XomNtEvent(
            XEVENT_PRESENCE_CODE_90,
            "MessageFlags from client @ %s:%d for user %I64X sent to the wrong server",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port),
            pMsg->qwUserID);

        hr = E_INVALIDARG;
        goto lDone;
    }

    // Everything looks cool, send it on to the switchboard
    hr = m_pSwitchboard->MessageFlags(
        pMsg->qwUserID,
        pMsg->dwMessageID,
        pMsg->dwSetFlags,
        pMsg->dwUnsetFlags,
        this,
        pMsg->dwSeqNum);

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "MessageFlags from %s:%d user %I64X msg %X hr=%X",
        inet_ntoa(m_sa.sin_addr), 
        ntohs(m_sa.sin_port),
        pMsg->qwUserID,
        pMsg->dwMessageID,
        hr);

lDone:

    if (hr == XONLINE_E_PRESENCE_DEFER_REQUEST)
    {
        hr = DeferMessage(pMsg->qwUserID, pMsg, cbEntireMsg);
    }
    else if (hr == XONLINE_E_PRESENCE_USER_MIGRATED)
    {
        hr = m_pSwitchboard->GetClientListener()->ForwardMessage(this, pMsg->qwUserID, pMsg, cbEntireMsg);
    }

    // Keep track of things
    if( FAILED(hr) )
    {
        HRESULT hrResp;

        // If the operation succeeds we will log it upon completion where we have more information available
        // (missing information is represented by zeroes here to keep the log format consistent).
        XomLog( PresenceLog, "FLG|%X:%X|%I64X|%X|%X|%X|%X",
            ntohl( m_sa.sin_addr.S_un.S_addr ), 
            ntohs( m_sa.sin_port ),
            pMsg->qwUserID,
            pMsg->dwMessageID,
            pMsg->dwSetFlags,
            pMsg->dwUnsetFlags,
            hr );

        g_Counters.TrackFailureMessage( XPPERF_SERVER_MESSAGE_FLAGS_MSGS_COUNTER );

        if (hr != XONLINE_E_MESSAGE_INVALID_MESSAGE_ID)
        {
            XomNtEvent( 
                XEVENT_PRESENCE_CODE_91, 
                "CClientConnection::ProcessMsgMessageFlags failed user=%I64X hr=0x%X",
                pMsg->qwUserID,
                hr);
        }

        hrResp = m_pSwitchboard->SendEmptyReply( 
            QMSG_MESSAGE_FLAGS_REPLY, 
            sizeof( Q_MESSAGE_FLAGS_REPLY_MSG ), 
            pMsg->dwSeqNum, 
            hr, 
            this);
        if (FAILED(hrResp))
        {
            // Disconnect if we fail to send a response
            Disconnect(hr);
            hr = hrResp;
        }
    }

    // Success counter incremented on DB callback
}

/*****************************************************************************

CClientConnection::ProcessMsgEnumSystemMessages

Process EnumSystemMessages messages.

*****************************************************************************/
void CClientConnection::ProcessMsgEnumSystemMessages(Q_ENUM_SYSTEM_MESSAGES_MSG *pMsg, DWORD cbEntireMsg)
{
    CScopeTimer scope( XPPERF_SERVER_ENUM_SYSTEM_MESSAGES_CLIENT_TIME_AVERAGE, XPPERF_SERVER_ENUM_SYSTEM_MESSAGES_CLIENT_TIME_BASE );

    XOMASSERT(pMsg != NULL);
    XOMASSERT(m_pSwitchboard != NULL);

    HRESULT hr = S_OK;

    // Everything looks cool, send it on to the switchboard
    hr = m_pSwitchboard->EnumSystemMessages(
        pMsg->dwTitleID,
        this,
        pMsg->dwSeqNum);

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "EnumSystemMessages from %s:%d title 0x%08X hr=%X",
        inet_ntoa(m_sa.sin_addr), 
        ntohs(m_sa.sin_port),
        pMsg->dwTitleID,
        hr);

    // Keep track of things
    if( FAILED(hr) )
    {
        HRESULT hrResp;

        // If the operation succeeds we will log it upon completion where we have more information available
        // (missing information is represented by zeroes here to keep the log format consistent).
        XomLog( PresenceLog, "ENS|%X:%X|%X|0|%X",
            ntohl( m_sa.sin_addr.S_un.S_addr ), 
            ntohs( m_sa.sin_port ),
            pMsg->dwTitleID,
            hr );

        g_Counters.TrackFailureMessage( XPPERF_SERVER_ENUM_SYSTEM_MESSAGES_MSGS_COUNTER );

        XomNtEvent( 
            XEVENT_PRESENCE_CODE_92, 
            "CClientConnection::ProcessMsgEnumSystemMessages failed title=0x%08X hr=0x%X",
            pMsg->dwTitleID,
            hr);

        hrResp = m_pSwitchboard->SendEmptyReply( 
            QMSG_ENUM_SYSTEM_MESSAGES_REPLY, 
            sizeof( Q_ENUM_SYSTEM_MESSAGES_REPLY_MSG ), 
            pMsg->dwSeqNum, 
            hr, 
            this);
        if (FAILED(hrResp))
        {
            // Disconnect if we fail to send a response
            Disconnect(hr);
            hr = hrResp;
        }
    }

    // Success counter incremented on DB callback
}

/*****************************************************************************

CClientConnection::ProcessMsgSystemMessageDetails

Process SystemMessageDetails messages.

*****************************************************************************/
void CClientConnection::ProcessMsgSystemMessageDetails(Q_SYSTEM_MESSAGE_DETAILS_MSG *pMsg, DWORD cbEntireMsg)
{
    CScopeTimer scope( XPPERF_SERVER_SYSTEM_MESSAGE_DETAILS_CLIENT_TIME_AVERAGE, XPPERF_SERVER_SYSTEM_MESSAGE_DETAILS_CLIENT_TIME_BASE );

    XOMASSERT(pMsg != NULL);
    XOMASSERT(m_pSwitchboard != NULL);

    HRESULT hr = S_OK;

    // MessageID of 0 not allowed
    if(0 == pMsg->dwMessageID)
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_190,
            "SystemMessageDetails from client @ %s:%d Bad message id (0)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port));

        hr = E_INVALIDARG;
        goto lDone;
    }

    // Everything looks cool, send it on to the switchboard
    hr = m_pSwitchboard->GetSystemMessageDetails(
        pMsg->dwTitleID,
        pMsg->dwMessageID,
        this,
        pMsg->dwSeqNum);

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "SystemMessageDetails from %s:%d title=0x%08X message=0x%08X hr=%X",
        inet_ntoa(m_sa.sin_addr), 
        ntohs(m_sa.sin_port),
        pMsg->dwTitleID,
        pMsg->dwMessageID,
        hr);

lDone:

    // Keep track of things
    if( FAILED(hr) )
    {
        HRESULT hrResp;

        // If the operation succeeds we will log it upon completion where we have more information available
        // (missing information is represented by zeroes here to keep the log format consistent).
        XomLog( PresenceLog, "DTS|%X:%X|%X|%X|0|%X",
            ntohl( m_sa.sin_addr.S_un.S_addr ), 
            ntohs( m_sa.sin_port ),
            pMsg->dwTitleID,
            pMsg->dwMessageID,
            hr );

        g_Counters.TrackFailureMessage( XPPERF_SERVER_SYSTEM_MESSAGE_DETAILS_MSGS_COUNTER );

        XomNtEvent( 
            XEVENT_PRESENCE_CODE_93, 
            "CClientConnection::ProcessMsgSystemMessageDetails failed title=0x%08X message=0x%08X hr=0x%X",
            pMsg->dwTitleID,
            pMsg->dwMessageID,
            hr);

        hrResp = m_pSwitchboard->SendEmptyReply( 
            QMSG_SYSTEM_MESSAGE_DETAILS_REPLY, 
            sizeof( Q_SYSTEM_MESSAGE_DETAILS_REPLY_MSG ), 
            pMsg->dwSeqNum, 
            hr, 
            this);
        if (FAILED(hrResp))
        {
            // Disconnect if we fail to send a response
            Disconnect(hr);
            hr = hrResp;
        }
    }

    // Success counter incremented on DB callback
}

/*****************************************************************************

CClientConnection::ProcessMsgDeleteSystemMessage

Process DeleteSystemMessages messages.

*****************************************************************************/
void CClientConnection::ProcessMsgDeleteSystemMessage(Q_DELETE_SYSTEM_MESSAGE_MSG *pMsg, DWORD cbEntireMsg)
{
    CScopeTimer scope( XPPERF_SERVER_DELETE_SYSTEM_MESSAGE_CLIENT_TIME_AVERAGE, XPPERF_SERVER_DELETE_SYSTEM_MESSAGE_CLIENT_TIME_BASE );

    XOMASSERT(pMsg != NULL);
    XOMASSERT(m_pSwitchboard != NULL);

    HRESULT hr = S_OK;

    // MessageID of 0 not allowed
    if(0 == pMsg->dwMessageID)
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_191,
            "DeleteSystemMessage from client @ %s:%d Bad message id (0)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port));

        hr = E_INVALIDARG;
        goto lDone;
    }

    if( 0 != ( pMsg->dwFlags & ~(XMSG_DELETE_SYSTEM_MESSAGE_FLAG_REVOKE_ALL) ) )
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_192,
            "DeleteSystemMessage from client @ %s:%d title 0x%08X msg 0x%08X Invalid flags (0x%08X)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port),
            pMsg->dwTitleID,
            pMsg->dwMessageID,
            pMsg->dwFlags);

        hr = E_INVALIDARG;
        goto lDone;
    }

    // Everything looks cool, send it on to the switchboard
    hr = m_pSwitchboard->DeleteSystemMessage(
        pMsg->dwTitleID,
        pMsg->dwMessageID,
        pMsg->dwFlags,
        this,
        pMsg->dwSeqNum);

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "DeleteSystemMessage from %s:%d title=0x%08X message=0x%08X, flags=0x%08X hr=%X",
        inet_ntoa(m_sa.sin_addr), 
        ntohs(m_sa.sin_port),
        pMsg->dwTitleID,
        pMsg->dwMessageID,
        pMsg->dwFlags,
        hr);

lDone:

    // Keep track of things
    if( FAILED(hr) )
    {
        HRESULT hrResp;

        // If the operation succeeds we will log it upon completion where we have more information available
        // (missing information is represented by zeroes here to keep the log format consistent).
        XomLog( PresenceLog, "DES|%X:%X|%X|%X|%X|%X",
            ntohl( m_sa.sin_addr.S_un.S_addr ), 
            ntohs( m_sa.sin_port ),
            pMsg->dwTitleID,
            pMsg->dwMessageID,
            pMsg->dwFlags,
            hr );

        g_Counters.TrackFailureMessage( XPPERF_SERVER_DELETE_SYSTEM_MESSAGE_MSGS_COUNTER );

        XomNtEvent( 
            XEVENT_PRESENCE_CODE_94, 
            "CClientConnection::ProcessMsgDeleteSystemMessage failed title=0x%08X message=0x%08X hr=0x%X",
            pMsg->dwTitleID,
            pMsg->dwMessageID,
            hr);

        hrResp = m_pSwitchboard->SendEmptyReply( 
            QMSG_DELETE_SYSTEM_MESSAGE_REPLY, 
            sizeof( Q_DELETE_SYSTEM_MESSAGE_REPLY_MSG ), 
            pMsg->dwSeqNum, 
            hr, 
            this);
        if (FAILED(hrResp))
        {
            // Disconnect if we fail to send a response
            Disconnect(hr);
            hr = hrResp;
        }
    }

    // Success counter incremented on DB callback
}

/*****************************************************************************

CClientConnection::ProcessMsgSendSystemMessage

Process SendSystemMessage messages.

*****************************************************************************/
void CClientConnection::ProcessMsgSendSystemMessage(Q_SEND_SYSTEM_MESSAGE_MSG *pMsg, DWORD cbEntireMsg)
{
    CScopeTimer scope( XPPERF_SERVER_SEND_SYSTEM_MESSAGE_CLIENT_TIME_AVERAGE, XPPERF_SERVER_SEND_SYSTEM_MESSAGE_CLIENT_TIME_BASE );

    XOMASSERT(pMsg != NULL);
    XOMASSERT(m_pSwitchboard != NULL);

    HRESULT hr = S_OK;
    XMSG_DETAILS* pDetails = NULL;

    // Check extended message size
    if( cbEntireMsg < sizeof( Q_SEND_SYSTEM_MESSAGE_MSG ) + 
                      pMsg->cbDetails)
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_193,
            "SendSystemMessage from %s:%d (size %d < %d)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port),
            cbEntireMsg,
            sizeof( Q_SEND_SYSTEM_MESSAGE_MSG ) + 
                pMsg->cbDetails );

        hr = E_INVALIDARG;
        goto lDone;
    }    

    // Validate the message type and set the correct expiration
    if( !IsValidMessageType( pMsg->bMessageType, &pMsg->wExpireMinutes ) )
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_194,
            "SendSystemMessage from %s:%d Bad message type (%d)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port),
            pMsg->bMessageType);

        hr = E_INVALIDARG;
        goto lDone;
    }

    // Validate the message flags
    if( 0 != ( pMsg->dwMessageFlags & ~(XONLINE_MSG_FLAGS_VALID_SEND_MASK) ) )
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_195,
            "SendSystemMessage from %s:%d Bad message flags (0x%08X not in 0x%08X)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port),
            pMsg->dwMessageFlags,
            XONLINE_MSG_FLAGS_VALID_SEND_MASK);

        hr = E_INVALIDARG;
        goto lDone;
    }

    // Non-exportable is only allowed on TITLE_CUSTOM messages
    if( 0 != ( pMsg->dwMessageFlags & XONLINE_MSG_FLAG_NON_EXPORTABLE ) &&
        XONLINE_MSG_TYPE_TITLE_CUSTOM != pMsg->bMessageType )
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_196,
            "SendSystemMessage from %s:%d Non-exportable flag only allowed on TITLE_CUSTOM messages, type=%d",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port),
            pMsg->bMessageType);

        hr = E_INVALIDARG;
        goto lDone;
    }

    // Grab the details
    pDetails = (XMSG_DETAILS*)(pMsg + 1);

    // Validate properties
    if( !IsValidDetails( pDetails, pMsg->cbDetails ) )
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_197,
            "SendSystemMessage from %s:%d Message details are invalid",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port));

        hr = E_INVALIDARG;
        goto lDone;
    }

    // Validate description
    if( 0 != pMsg->szDescription[ XMSG_SYSTEM_MESSAGE_DESCRIPTION_LEN - 1 ] )
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_198,
            "SendSystemMessage from %s:%d Message description is not NULL-terminated",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port));

        hr = E_INVALIDARG;
        goto lDone;
    }

    // Everything looks cool, send it on to the switchboard
    hr = m_pSwitchboard->SendSystemMessage(
        pMsg,
        (BYTE*) pDetails,
        this,
        pMsg->dwSeqNum );

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "SendSystemMessage from client %s:%d title=0x%08X region=0x%08X context=0x%I64X type=%d expire=%d cbDetails=%d flags=0x%08X hr=0x%08X, description='%s'",
        inet_ntoa(m_sa.sin_addr), 
        ntohs(m_sa.sin_port),
        pMsg->dwTitleID,
        pMsg->dwRegion,
        pMsg->qwSenderContext,
        pMsg->bMessageType,
        pMsg->wExpireMinutes,
        pMsg->cbDetails,
        pMsg->dwMessageFlags,
        hr,
        pMsg->szDescription );

lDone:

    // Keep track of things
    if( FAILED( hr ) )
    {
        HRESULT hrResp;

        // If the operation succeeds we will log it upon completion where we have more information available
        // (missing information is represented by zeroes here to keep the log format consistent).
        XomLog( PresenceLog, "SNS|%X:%X|%I64X|%X|%X|%I64X|%X|%X|%X|%X|0|%X",
            ntohl( m_sa.sin_addr.S_un.S_addr ), 
            ntohs( m_sa.sin_port ),
            pMsg->qwSenderContext,
            pMsg->dwTitleID,
            pMsg->dwRegion,
            pMsg->ftSentTime,
            pMsg->dwMessageFlags,
            pMsg->wExpireMinutes,
            pMsg->cbDetails,
            pMsg->bMessageType,
            hr );

        g_Counters.TrackFailureMessage( XPPERF_SERVER_SEND_SYSTEM_MESSAGE_MSGS_COUNTER );

        XomNtEvent( 
            XEVENT_PRESENCE_CODE_95, 
            "CClientConnection::ProcessMsgSendSystemMessage failed title=0x%08X region=0x%08X context=0x%I64X type=%d expire=%d cbDetails=%d flags=0x%08X hr=0x%08X",
            pMsg->dwTitleID,
            pMsg->dwRegion,
            pMsg->qwSenderContext,
            pMsg->bMessageType,
            pMsg->wExpireMinutes,
            pMsg->cbDetails,
            pMsg->dwMessageFlags,
            hr );

        hrResp = m_pSwitchboard->SendEmptyReply( 
            QMSG_SEND_SYSTEM_MESSAGE_REPLY, 
            sizeof( Q_SEND_SYSTEM_MESSAGE_REPLY_MSG ), 
            pMsg->dwSeqNum, 
            hr, 
            this );
        if( FAILED( hrResp ) )
        {
            // Disconnect if we fail to send a response
            Disconnect( hr );
            hr = hrResp;
        }
    }

    // Success counter incremented on DB callback
}

/*****************************************************************************

CClientConnection::SendErrorListReply

Send a reply to a list or dequeue message.

*****************************************************************************/
HRESULT CClientConnection::SendErrorListReply(
    DWORD dwSeqNum,
    const SGADDR *psgaddr,
    QWORD qwUserID,
    DWORD dwQType,
    HRESULT hrList)
{
    XOMASSERT(psgaddr != NULL);

    HRESULT hr = S_OK;
    CTCPCntVarBuffer *pCReplyBuffer = NULL;
    Q_LIST_REPLY_MSG *pListReplyMsg = NULL;
    
    pCReplyBuffer = g_pBufferPool->GetBuffer(sizeof(Q_LIST_REPLY_MSG));        
    if( NULL == pCReplyBuffer )
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }
    
    // Fill out and send reply message
    pListReplyMsg = (Q_LIST_REPLY_MSG *) pCReplyBuffer->GetBuffer();
    
    pListReplyMsg->dwMsgType = QMSG_LIST_REPLY;
    pListReplyMsg->dwMsgLen = sizeof(Q_LIST_REPLY_MSG) - sizeof(BASE_MSG_HEADER);
    pListReplyMsg->dwSeqNum = dwSeqNum;
    pListReplyMsg->sgaddr = *psgaddr;
    pListReplyMsg->hr = hrList;
    pListReplyMsg->qwUserID = qwUserID;
    pListReplyMsg->wQType = (WORD)dwQType;
    pListReplyMsg->dwNextItemID = 0;
    pListReplyMsg->wQLeft = 0;
    pListReplyMsg->wNumItems = 0;
    pListReplyMsg->dwTotalItemDataSize = 0;
    pListReplyMsg->cdwQVals = 0;
    
    hr = Send(pCReplyBuffer);
    if(FAILED(hr))
    {
        goto lDone;
    }
    
    hr = S_OK;


    g_Counters.IncrementValue32( 
        XPPERF_SERVER_LIST_REPLY_MSGS_COUNTER,
        1 );
    
    g_Counters.IncrementValue32( 
        XPPERF_SERVER_LIST_REPLY_MSGS_RATE,
        1 );
    
lDone:

    // Clean up
    SAFE_RELEASE(pCReplyBuffer);
    
    return hr;
}


/*****************************************************************************

CClientListener::CClientListener

Constructor

*****************************************************************************/
CClientListener::CClientListener() :
    m_pCCompPort(NULL),
    m_pCSwitchboard(NULL),
    m_pCListenSocket(NULL)
{
}

/*****************************************************************************

CClientListener::~CClientConnection

Destructor

*****************************************************************************/
CClientListener::~CClientListener()
{
    Shutdown();
}

/*****************************************************************************

CClientConnection::Init

Initializer, must be called before first use.

*****************************************************************************/
HRESULT CClientListener::Init(CSwitchboard *pCSwitchboard)
{
    if (pCSwitchboard == NULL)
    {
        XOMASSERT(FALSE);
        return E_INVALIDARG;
    }

    HRESULT hr = S_OK;
    sockaddr_in sa;

    // Create worker threads to deal with incoming network traffic
    hr = CCompletionPort::CreateInstance(
        0,  // dwConcurrancy
        1,  // dwThreadPoolSize
        THREAD_PRIORITY_NORMAL,
        &m_pCCompPort );

    if(FAILED(hr))
    {
        XomNtEvent(XEVENT_PRESENCE_CONFIG_18, "Unrecoverable failure while initializing: CCompPort::CreateInstance failed (%X)", hr);
        goto lDone;
    }
    
    m_pCSwitchboard = pCSwitchboard;
    m_pCSwitchboard->AddRef();

    // Create our listening socket on the designated completion port
    hr = CServerSocket::CreateInstance(&m_pCListenSocket, m_pCCompPort, m_pCCompPort);
    if(FAILED(hr))
    {
       XomNtEvent(XEVENT_PRESENCE_CONFIG_19, "Unrecoverable failure while initializing: CServSocket::CreateInstance failed (%X)", hr);
       goto lDone;
    }
    
    memset(&sa, 0, sizeof(sa));
    
    sa.sin_family = AF_INET;
    sa.sin_port = g_CPresCfg.GetPresServerAddr(g_CPresCfg.GetMyPresServerIndex())->sin_port;
    
    hr = m_pCListenSocket->Init(IPPROTO_TCP, &sa, FALSE);
    if(FAILED(hr))
    {
        XomNtEvent(XEVENT_PRESENCE_CONFIG_20, "Unrecoverable failure while initializing: CServSocket::Init failed (%X)", hr);
        goto lDone;
    }
    
    hr = m_pCListenSocket->Listen(SOMAXCONN);
    if(FAILED(hr))
    {
        XomNtEvent(XEVENT_PRESENCE_CONFIG_21, "Unrecoverable failure while initializing: CServSocket::Listen failed (%X)", hr);
        goto lDone;
    }
    
    hr = m_pCListenSocket->Accept(this, 0x12345678);
    if( FAILED( hr ) )
    {
        goto lDone;
    }

    hr = InitForwarding();
    if (FAILED(hr))
    {
        goto lDone;
    }

    hr = S_OK;

lDone:

    return hr;
}

/*****************************************************************************

CClientListener::Shutdown

Deinitializer

*****************************************************************************/
void CClientListener::Shutdown()
{
    for (DWORD iServer = 0; iServer < (sizeof(m_rgpForwardingConnections)/sizeof(CForwardingConnection *)); iServer++)
    {
        SAFE_RELEASE(m_rgpForwardingConnections[iServer]);
    }

    SAFE_ARRAYDELETE(m_rgpForwardingConnections);    
    SAFE_SHUTRELEASE(m_pCCompPort);
    SAFE_RELEASE(m_pCSwitchboard);
    SAFE_RELEASE(m_pCListenSocket);
}

/*****************************************************************************

CClientListener::OnSocketAccept

Callback from listening socket, used to accept new connections.

*****************************************************************************/
void CClientListener::OnSocketAccept(
     CServerSocket *pCListenSocket,
     CServerSocket *pCAcceptedSocket,
     sockaddr_in *pLocalAddr,
     sockaddr_in *pRemoteAddr,
     HRESULT hrIn,
     QWORD qwCallbackArg )
{
    XOMASSERT(m_pCCompPort != NULL);
    XOMASSERT(m_pCSwitchboard != NULL);
    XOMASSERT(m_pCListenSocket != NULL);

    HRESULT hr = hrIn;
    CClientConnection *pCConnection = NULL;

    // Check the incomming HRESULT
    if(HRESULT_FROM_WIN32( ERROR_OPERATION_ABORTED) == hr)
    {
        // Most likely case is that we're shutting down
        hr = S_OK;

        goto lDone;
    }
    else if (FAILED(hr))
    {
        goto lDone;
    }
    
    XOMASSERT( m_pCListenSocket == pCListenSocket );
    
    // Before anything else happens, accept a new connection
    hr = m_pCListenSocket->Accept( this, 0x12345678 );
    if(FAILED(hr))
    {
        XomNtEvent(XEVENT_PRESENCE_CODE_96, "Error accepting new client hr=%X", hr );
        goto lDone;
    }
    
    XOMASSERT( NULL != pCAcceptedSocket );
    
    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "Client connected addr=%s:%d",
        inet_ntoa( pRemoteAddr->sin_addr ), 
        ntohs( pRemoteAddr->sin_port ));
    
    // Allocate a new connection management class
    pCConnection = new CClientConnection;
    if( NULL == pCConnection )
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    // Hand over control of the socket to the connection class
    hr = pCConnection->Init(m_pCSwitchboard, pCAcceptedSocket);
    if( FAILED( hr ) )
    {
        goto lDone;
    }
    
    pCConnection = NULL;
        
lDone:
    SAFE_RELEASE(pCConnection);
}

HRESULT CClientListener::InitForwarding()
{
    m_rgpForwardingConnections = new CForwardingConnection *[g_CPresCfg.GetNumPresServers()];
    if (m_rgpForwardingConnections == NULL)
    {
        return E_OUTOFMEMORY;
    }

    ZeroMemory(m_rgpForwardingConnections, sizeof(CForwardingConnection *) * g_CPresCfg.GetNumPresServers());

    return S_OK;
}

HRESULT CClientListener::ChangeServerList(DWORD * rgdwIndexMap, DWORD cOldServers)
{
    HRESULT hr = S_OK;
    
    // make a new forwarding list
    CForwardingConnection **pNewForwardingConnections = new CForwardingConnection *[g_CPresCfg.GetNumPresServers()];
    if (pNewForwardingConnections == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    ZeroMemory(pNewForwardingConnections, sizeof(CForwardingConnection *) * g_CPresCfg.GetNumPresServers());

    // clean up anything we're no longer using
    for (DWORD dwIndex = 0; dwIndex < cOldServers; dwIndex++)
    {
        if (rgdwIndexMap[dwIndex] == 0xFFFFFFFF)
        {
            RemoveForwardConnection(dwIndex);
        }
    }
    
    // copy over anything we're still using
    for (DWORD dwIndex = 0; dwIndex < cOldServers; dwIndex++)
    {
        if (rgdwIndexMap[dwIndex] != 0xFFFFFFFF)
        {
            pNewForwardingConnections[rgdwIndexMap[dwIndex]] = m_rgpForwardingConnections[dwIndex];
            if (m_rgpForwardingConnections[dwIndex] != NULL)
            {
                m_rgpForwardingConnections[dwIndex]->ChangeServerIndex(rgdwIndexMap[dwIndex]);
            }
        }
    }

    // switch to the new list.
    SAFE_ARRAYDELETE(m_rgpForwardingConnections);
    m_rgpForwardingConnections = pNewForwardingConnections;
    pNewForwardingConnections = NULL;

lDone:

    SAFE_ARRAYDELETE(pNewForwardingConnections);

    return hr;
}

HRESULT CClientListener::CreateForwardConnection(DWORD dwServerIndex)
{
    HRESULT hr = S_OK;

    if ((dwServerIndex >= g_CPresCfg.GetNumPresServers()) ||
        (dwServerIndex == g_CPresCfg.GetMyPresServerIndex()))
    {
        hr = E_INVALIDARG;
        goto lDone;
    }
    
    if (m_rgpForwardingConnections[dwServerIndex] != NULL)
    {
        goto lDone;
    }

    m_rgpForwardingConnections[dwServerIndex] = new CForwardingConnection();
    if (m_rgpForwardingConnections[dwServerIndex] == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    hr = m_rgpForwardingConnections[dwServerIndex]->InitConnect(dwServerIndex, m_pCCompPort, m_pCSwitchboard);

lDone:

    return hr;
}

HRESULT CClientListener::RemoveForwardConnection(DWORD dwServerIndex)
{
    SAFE_RELEASE(m_rgpForwardingConnections[dwServerIndex]);
    return S_OK;
}

HRESULT CClientListener::ForwardMessage(
    CClientConnection *pCCliConn,
    QWORD qwUserID,
    BASE_MSG_HEADER *pMsg,
    DWORD cbEntireMsg)
{
    XomTrace(PresenceDebug, L_NORMAL, "ForwardMessage(user = %I64X, type = %d, seq = %d, size = %d)", qwUserID, pMsg->dwMsgType, pMsg->dwSeqNum, cbEntireMsg);
    
    HRESULT hr = S_OK;
    CTCPCntVarBuffer *pBuffer = NULL;
    CForwardedMessageContext *pCCtx = NULL;
    
    DWORD dwServer = g_CPresCfg.MapUserToPresSrv(qwUserID, TRUE);
    if (dwServer == g_CPresCfg.GetMyPresServerIndex())
    {
        hr = E_UNEXPECTED;
        XomNtEvent(XEVENT_PRESENCE_CODE_97, "ForwardMessage(): unexpected forward to self (%d) for user %I64X", dwServer, qwUserID);
        goto lDone;
    }

    if ((m_rgpForwardingConnections[dwServer] == NULL) || (!m_rgpForwardingConnections[dwServer]->HasSentHello()))
    {
        hr = CreateForwardConnection(dwServer);
        if (FAILED(hr))
        {
            XomNtEvent(XEVENT_PRESENCE_CODE_98, "ForwardMessage(): failed to create connection for server %d, user %I64X", dwServer, qwUserID);
        }

        // this connection isnt connected yet.  we can't send on it.  just fail this forward here.
        hr = E_FAIL;
        goto lDone;
    }
    
    pCCtx = new CForwardedMessageContext(pCCliConn);
    if (pCCtx == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    pBuffer = g_pBufferPool->GetBuffer(cbEntireMsg);
    if (pBuffer == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    pCCtx->m_dwOldSeqNum = pMsg->dwSeqNum;

    // NOTE: I'm using the address of the context as the sequence number in the forward.  This will make it O(1) to find the context when
    // the reply comes back.  It also means that I'll be dereferencing a memory address that I pull from the received reply packed!  OMG!!
    pCCtx->m_dwNewSeqNum = (DWORD)pCCtx;
    
    pMsg->dwSeqNum = pCCtx->m_dwNewSeqNum;

    memcpy(pBuffer->GetBuffer(), pMsg, cbEntireMsg);

    pMsg->dwSeqNum = pCCtx->m_dwOldSeqNum;

    hr = m_rgpForwardingConnections[dwServer]->Send(pBuffer);
    if (FAILED(hr))
    {
        goto lDone;
    }

    pCCtx->AddRef();
        
lDone:

    if (FAILED(hr))
    {
        XomNtEvent(XEVENT_PRESENCE_CODE_99, "ForwardMessage(user = %I64X, type = %d, seq = %d, size = %d) failed.  hr = 0x%X", qwUserID, pMsg->dwMsgType, pMsg->dwSeqNum, cbEntireMsg, hr);
    }

    SAFE_RELEASE(pCCtx);
    SAFE_RELEASE(pBuffer);

    return hr;
}

CForwardingConnection::~CForwardingConnection()
{
}

HRESULT CForwardingConnection::InitConnect(
        DWORD dwServerIndex,
        CCompletionPort *pCompPort,
        CSwitchboard *pSwitchboard)
{
    HRESULT hr = S_OK;
    CServerSocket *pSock = NULL;

    // Validate arguments
    if((NULL == pCompPort) ||
        (NULL == pSwitchboard) ||
        (dwServerIndex >= g_CPresCfg.GetNumPresServers()) ||
        (dwServerIndex == g_CPresCfg.GetMyPresServerIndex()))
    {
        hr = E_INVALIDARG;
        goto lDone;
    }
    
    // Set references
    m_pSwitchboard = pSwitchboard;
    m_dwServerIndex = dwServerIndex;

    // Store off the destination address for future use
    memcpy(&m_sa, g_CPresCfg.GetPresServerAddr(dwServerIndex), sizeof(sockaddr_in));

    // Create a new TCP socket for use by this connection
    hr = CServerSocket::CreateInstance(&pSock, pCompPort, pCompPort);
    if(FAILED(hr))
    {
        XomNtEvent(XEVENT_PRESENCE_CODE_100, "CForwardingConnection::Init failed to create CServerSocket instance (%X)", hr);
        goto lDone;
    }

    // Bind it to a local address
    sockaddr_in saBind;
    memset(&saBind, 0, sizeof(saBind));

    saBind.sin_family = AF_INET;

    hr = pSock->Init( IPPROTO_TCP, &saBind, TRUE );
    if( FAILED( hr ) )
    {
        XomNtEvent(XEVENT_PRESENCE_CODE_101, "CForwardingConnection::Init failed to init CServerSocket object (%X)", hr);
        goto lDone;
    }
    
    // Start the connecting process
    hr = AttachAndConnect(pSock, &m_sa);
    if(FAILED(hr))
    {
        XomNtEvent(
            XEVENT_PRESENCE_CODE_102,
            "CForwardingConnection::Init failed to initiate connect for server @ %s:%d (%X)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port ),
            hr);
        goto lDone;
    }

lDone:

    SAFE_RELEASE( pSock );
    
    return hr;
}

CForwardedMessageContext *CForwardingConnection::FindContext(DWORD dwSeqNum)
{
    // NOTE: We're taking the sequence number returned from the forwarded message reply packet and casting it into a pointer to a context.
    CForwardedMessageContext *pRet = (CForwardedMessageContext *)dwSeqNum;

    // check the casted context
    if ((pRet == NULL) ||   // not null
        !g_XHeap.KnownArea(pRet) ||     // does the allocator recognize this address?
        (pRet->dwSig != FORWARDED_MESSAGE_CONTEXT_SIGNATURE))   // does it have our context signature?
    {
        pRet = NULL;
    }

    return pRet;
}

void CForwardingConnection::OnConnect()
{
    SendMsgHello();
}

void CForwardingConnection::OnDisconnect(HRESULT hrReason)
{
    // move this to switchboard thread.

    CFwdConnDisconnectContext *pCCtx = new CFwdConnDisconnectContext();
    if (pCCtx != NULL)
    {
        AddRef();
        pCCtx->m_pCConn = this;
        pCCtx->m_hrReason = hrReason;
        
        HRESULT hr = m_pSwitchboard->PostCompletion(pCCtx);
        if (FAILED(hr))
        {
            SAFE_RELEASE(pCCtx);
        }
    }   
}
void CForwardingConnection::OnDisconnectInternal(HRESULT hrReason)
{
    XomNtEvent(XEVENT_PRESENCE_CODE_103, "CForwardingConnection::OnDisconnect(hr = 0x%X)", hrReason);
    XOMASSERT(FALSE);

    m_pSwitchboard->GetClientListener()->RemoveForwardConnection(m_dwServerIndex);
}

void CForwardingConnection::ProcessMessage(BYTE * pMsg, DWORD cbEntireMsg)
{
    if ((m_pSwitchboard == NULL) || (pMsg == NULL))
    {
        XOMASSERT(FALSE);
        return;
    }

    CForwardReceiveContext *pCCtx = new CForwardReceiveContext(this);
    if (pCCtx != NULL)
    {
        pCCtx->m_cbEntireMsg = cbEntireMsg;
        pCCtx->m_pMsg = new BYTE[cbEntireMsg];
        if (pCCtx->m_pMsg != NULL)
        {
            memcpy(pCCtx->m_pMsg, pMsg, cbEntireMsg);
            m_pSwitchboard->PostCompletion(pCCtx);
        }
    }
}

void CForwardingConnection::ProcessReplyMessage(BYTE * pMsg, DWORD cbEntireMsg)
{
    CForwardedMessageContext *pCCtx = NULL;
    CTCPCntVarBuffer *pBuffer = NULL;
    
    if (cbEntireMsg < sizeof(BASE_MSG_HEADER))
    {
        goto lDone;
    }

    BASE_MSG_HEADER *pHeader = (BASE_MSG_HEADER *)pMsg;

    pCCtx = FindContext(pHeader->dwSeqNum);
    if (pCCtx == NULL)
    {
        goto lDone;
    }

    pBuffer = g_pBufferPool->GetBuffer(cbEntireMsg);
    if (pBuffer == NULL)
    {
        goto lDone;
    }

    pHeader->dwSeqNum = pCCtx->m_dwOldSeqNum;
    memcpy(pBuffer->GetBuffer(), pMsg, cbEntireMsg);

    pCCtx->m_pCCliConn->Send(pBuffer);
    
lDone:

    SAFE_RELEASE(pCCtx);
    SAFE_RELEASE(pBuffer);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\inh\darray.h ===
// Copyright (c) Microsoft Corporation.  All rights reserved

#ifndef _DARRAY_H_
#define _DARRAY_H_

template <
    class T, 
    int CELLSIZE, 
    int MAXCELLS, 
    int MAXEMPTYCELLS> 
class CDArray
{
public:
    
    CDArray()
    {
        m_cCells = 0;
        m_cNodes = 0;
    }

    HRESULT InsertBogus()
    {
        HRESULT hr = S_OK;
    
        if((m_cNodes / CELLSIZE) + 1 > m_cCells)
        {
            hr = Grow();
        }

        if(SUCCEEDED(hr))
        {
            m_cNodes++;
        }

        return hr;
    }

    HRESULT InsertAtTheEnd(
        T